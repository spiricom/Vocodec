
cube_for_new_genera_brain4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00028d64  08000298  08000298  00010298  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000229d0  08029000  08029000  00039000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0804b9d0  0804b9d0  000604a8  2**0
                  CONTENTS
  4 .ARM          00000008  0804b9d0  0804b9d0  0005b9d0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0804b9d8  0804b9d8  000604a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0804b9d8  0804b9d8  0005b9d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0804b9dc  0804b9dc  0005b9dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000004a8  20000000  0804b9e0  00060000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00019080  200004a8  0804be88  000604a8  2**3
                  ALLOC
 10 ._user_heap_stack 00006000  20019528  0804be88  00069528  2**0
                  ALLOC
 11 .RAM_D1       0007eb58  24000000  24000000  00070000  2**5
                  ALLOC
 12 .RAM_D2       000015e8  30000000  30000000  00070000  2**5
                  ALLOC
 13 .RAM_D3       00000201  38000000  38000000  00070000  2**5
                  ALLOC
 14 .SDRAM        02000000  60000000  60000000  00070000  2**5
                  ALLOC
 15 .ARM.attributes 0000002e  00000000  00000000  000604a8  2**0
                  CONTENTS, READONLY
 16 .debug_info   000c8c95  00000000  00000000  000604d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_abbrev 00011080  00000000  00000000  0012916b  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00067b9e  00000000  00000000  0013a1eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_aranges 00004490  00000000  00000000  001a1d90  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_ranges 00010898  00000000  00000000  001a6220  2**3
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_macro  0004a3e2  00000000  00000000  001b6ab8  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_line   000537de  00000000  00000000  00200e9a  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    0018c915  00000000  00000000  00254678  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .comment      0000007b  00000000  00000000  003e0f8d  2**0
                  CONTENTS, READONLY
 25 .debug_frame  0001026c  00000000  00000000  003e1008  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000298 <__do_global_dtors_aux>:
 8000298:	b510      	push	{r4, lr}
 800029a:	4c05      	ldr	r4, [pc, #20]	; (80002b0 <__do_global_dtors_aux+0x18>)
 800029c:	7823      	ldrb	r3, [r4, #0]
 800029e:	b933      	cbnz	r3, 80002ae <__do_global_dtors_aux+0x16>
 80002a0:	4b04      	ldr	r3, [pc, #16]	; (80002b4 <__do_global_dtors_aux+0x1c>)
 80002a2:	b113      	cbz	r3, 80002aa <__do_global_dtors_aux+0x12>
 80002a4:	4804      	ldr	r0, [pc, #16]	; (80002b8 <__do_global_dtors_aux+0x20>)
 80002a6:	f3af 8000 	nop.w
 80002aa:	2301      	movs	r3, #1
 80002ac:	7023      	strb	r3, [r4, #0]
 80002ae:	bd10      	pop	{r4, pc}
 80002b0:	200004a8 	.word	0x200004a8
 80002b4:	00000000 	.word	0x00000000
 80002b8:	08028fe4 	.word	0x08028fe4

080002bc <frame_dummy>:
 80002bc:	b508      	push	{r3, lr}
 80002be:	4b03      	ldr	r3, [pc, #12]	; (80002cc <frame_dummy+0x10>)
 80002c0:	b11b      	cbz	r3, 80002ca <frame_dummy+0xe>
 80002c2:	4903      	ldr	r1, [pc, #12]	; (80002d0 <frame_dummy+0x14>)
 80002c4:	4803      	ldr	r0, [pc, #12]	; (80002d4 <frame_dummy+0x18>)
 80002c6:	f3af 8000 	nop.w
 80002ca:	bd08      	pop	{r3, pc}
 80002cc:	00000000 	.word	0x00000000
 80002d0:	200004ac 	.word	0x200004ac
 80002d4:	08028fe4 	.word	0x08028fe4

080002d8 <strlen>:
 80002d8:	4603      	mov	r3, r0
 80002da:	f813 2b01 	ldrb.w	r2, [r3], #1
 80002de:	2a00      	cmp	r2, #0
 80002e0:	d1fb      	bne.n	80002da <strlen+0x2>
 80002e2:	1a18      	subs	r0, r3, r0
 80002e4:	3801      	subs	r0, #1
 80002e6:	4770      	bx	lr

080002e8 <__aeabi_drsub>:
 80002e8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002ec:	e002      	b.n	80002f4 <__adddf3>
 80002ee:	bf00      	nop

080002f0 <__aeabi_dsub>:
 80002f0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002f4 <__adddf3>:
 80002f4:	b530      	push	{r4, r5, lr}
 80002f6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002fa:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002fe:	ea94 0f05 	teq	r4, r5
 8000302:	bf08      	it	eq
 8000304:	ea90 0f02 	teqeq	r0, r2
 8000308:	bf1f      	itttt	ne
 800030a:	ea54 0c00 	orrsne.w	ip, r4, r0
 800030e:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000312:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000316:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800031a:	f000 80e2 	beq.w	80004e2 <__adddf3+0x1ee>
 800031e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000322:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000326:	bfb8      	it	lt
 8000328:	426d      	neglt	r5, r5
 800032a:	dd0c      	ble.n	8000346 <__adddf3+0x52>
 800032c:	442c      	add	r4, r5
 800032e:	ea80 0202 	eor.w	r2, r0, r2
 8000332:	ea81 0303 	eor.w	r3, r1, r3
 8000336:	ea82 0000 	eor.w	r0, r2, r0
 800033a:	ea83 0101 	eor.w	r1, r3, r1
 800033e:	ea80 0202 	eor.w	r2, r0, r2
 8000342:	ea81 0303 	eor.w	r3, r1, r3
 8000346:	2d36      	cmp	r5, #54	; 0x36
 8000348:	bf88      	it	hi
 800034a:	bd30      	pophi	{r4, r5, pc}
 800034c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000350:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000354:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000358:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800035c:	d002      	beq.n	8000364 <__adddf3+0x70>
 800035e:	4240      	negs	r0, r0
 8000360:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000364:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000368:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800036c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000370:	d002      	beq.n	8000378 <__adddf3+0x84>
 8000372:	4252      	negs	r2, r2
 8000374:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000378:	ea94 0f05 	teq	r4, r5
 800037c:	f000 80a7 	beq.w	80004ce <__adddf3+0x1da>
 8000380:	f1a4 0401 	sub.w	r4, r4, #1
 8000384:	f1d5 0e20 	rsbs	lr, r5, #32
 8000388:	db0d      	blt.n	80003a6 <__adddf3+0xb2>
 800038a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800038e:	fa22 f205 	lsr.w	r2, r2, r5
 8000392:	1880      	adds	r0, r0, r2
 8000394:	f141 0100 	adc.w	r1, r1, #0
 8000398:	fa03 f20e 	lsl.w	r2, r3, lr
 800039c:	1880      	adds	r0, r0, r2
 800039e:	fa43 f305 	asr.w	r3, r3, r5
 80003a2:	4159      	adcs	r1, r3
 80003a4:	e00e      	b.n	80003c4 <__adddf3+0xd0>
 80003a6:	f1a5 0520 	sub.w	r5, r5, #32
 80003aa:	f10e 0e20 	add.w	lr, lr, #32
 80003ae:	2a01      	cmp	r2, #1
 80003b0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80003b4:	bf28      	it	cs
 80003b6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003ba:	fa43 f305 	asr.w	r3, r3, r5
 80003be:	18c0      	adds	r0, r0, r3
 80003c0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003c4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003c8:	d507      	bpl.n	80003da <__adddf3+0xe6>
 80003ca:	f04f 0e00 	mov.w	lr, #0
 80003ce:	f1dc 0c00 	rsbs	ip, ip, #0
 80003d2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003d6:	eb6e 0101 	sbc.w	r1, lr, r1
 80003da:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003de:	d31b      	bcc.n	8000418 <__adddf3+0x124>
 80003e0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003e4:	d30c      	bcc.n	8000400 <__adddf3+0x10c>
 80003e6:	0849      	lsrs	r1, r1, #1
 80003e8:	ea5f 0030 	movs.w	r0, r0, rrx
 80003ec:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003f0:	f104 0401 	add.w	r4, r4, #1
 80003f4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003f8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003fc:	f080 809a 	bcs.w	8000534 <__adddf3+0x240>
 8000400:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000404:	bf08      	it	eq
 8000406:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800040a:	f150 0000 	adcs.w	r0, r0, #0
 800040e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000412:	ea41 0105 	orr.w	r1, r1, r5
 8000416:	bd30      	pop	{r4, r5, pc}
 8000418:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800041c:	4140      	adcs	r0, r0
 800041e:	eb41 0101 	adc.w	r1, r1, r1
 8000422:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000426:	f1a4 0401 	sub.w	r4, r4, #1
 800042a:	d1e9      	bne.n	8000400 <__adddf3+0x10c>
 800042c:	f091 0f00 	teq	r1, #0
 8000430:	bf04      	itt	eq
 8000432:	4601      	moveq	r1, r0
 8000434:	2000      	moveq	r0, #0
 8000436:	fab1 f381 	clz	r3, r1
 800043a:	bf08      	it	eq
 800043c:	3320      	addeq	r3, #32
 800043e:	f1a3 030b 	sub.w	r3, r3, #11
 8000442:	f1b3 0220 	subs.w	r2, r3, #32
 8000446:	da0c      	bge.n	8000462 <__adddf3+0x16e>
 8000448:	320c      	adds	r2, #12
 800044a:	dd08      	ble.n	800045e <__adddf3+0x16a>
 800044c:	f102 0c14 	add.w	ip, r2, #20
 8000450:	f1c2 020c 	rsb	r2, r2, #12
 8000454:	fa01 f00c 	lsl.w	r0, r1, ip
 8000458:	fa21 f102 	lsr.w	r1, r1, r2
 800045c:	e00c      	b.n	8000478 <__adddf3+0x184>
 800045e:	f102 0214 	add.w	r2, r2, #20
 8000462:	bfd8      	it	le
 8000464:	f1c2 0c20 	rsble	ip, r2, #32
 8000468:	fa01 f102 	lsl.w	r1, r1, r2
 800046c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000470:	bfdc      	itt	le
 8000472:	ea41 010c 	orrle.w	r1, r1, ip
 8000476:	4090      	lslle	r0, r2
 8000478:	1ae4      	subs	r4, r4, r3
 800047a:	bfa2      	ittt	ge
 800047c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000480:	4329      	orrge	r1, r5
 8000482:	bd30      	popge	{r4, r5, pc}
 8000484:	ea6f 0404 	mvn.w	r4, r4
 8000488:	3c1f      	subs	r4, #31
 800048a:	da1c      	bge.n	80004c6 <__adddf3+0x1d2>
 800048c:	340c      	adds	r4, #12
 800048e:	dc0e      	bgt.n	80004ae <__adddf3+0x1ba>
 8000490:	f104 0414 	add.w	r4, r4, #20
 8000494:	f1c4 0220 	rsb	r2, r4, #32
 8000498:	fa20 f004 	lsr.w	r0, r0, r4
 800049c:	fa01 f302 	lsl.w	r3, r1, r2
 80004a0:	ea40 0003 	orr.w	r0, r0, r3
 80004a4:	fa21 f304 	lsr.w	r3, r1, r4
 80004a8:	ea45 0103 	orr.w	r1, r5, r3
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	f1c4 040c 	rsb	r4, r4, #12
 80004b2:	f1c4 0220 	rsb	r2, r4, #32
 80004b6:	fa20 f002 	lsr.w	r0, r0, r2
 80004ba:	fa01 f304 	lsl.w	r3, r1, r4
 80004be:	ea40 0003 	orr.w	r0, r0, r3
 80004c2:	4629      	mov	r1, r5
 80004c4:	bd30      	pop	{r4, r5, pc}
 80004c6:	fa21 f004 	lsr.w	r0, r1, r4
 80004ca:	4629      	mov	r1, r5
 80004cc:	bd30      	pop	{r4, r5, pc}
 80004ce:	f094 0f00 	teq	r4, #0
 80004d2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004d6:	bf06      	itte	eq
 80004d8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004dc:	3401      	addeq	r4, #1
 80004de:	3d01      	subne	r5, #1
 80004e0:	e74e      	b.n	8000380 <__adddf3+0x8c>
 80004e2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004e6:	bf18      	it	ne
 80004e8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004ec:	d029      	beq.n	8000542 <__adddf3+0x24e>
 80004ee:	ea94 0f05 	teq	r4, r5
 80004f2:	bf08      	it	eq
 80004f4:	ea90 0f02 	teqeq	r0, r2
 80004f8:	d005      	beq.n	8000506 <__adddf3+0x212>
 80004fa:	ea54 0c00 	orrs.w	ip, r4, r0
 80004fe:	bf04      	itt	eq
 8000500:	4619      	moveq	r1, r3
 8000502:	4610      	moveq	r0, r2
 8000504:	bd30      	pop	{r4, r5, pc}
 8000506:	ea91 0f03 	teq	r1, r3
 800050a:	bf1e      	ittt	ne
 800050c:	2100      	movne	r1, #0
 800050e:	2000      	movne	r0, #0
 8000510:	bd30      	popne	{r4, r5, pc}
 8000512:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000516:	d105      	bne.n	8000524 <__adddf3+0x230>
 8000518:	0040      	lsls	r0, r0, #1
 800051a:	4149      	adcs	r1, r1
 800051c:	bf28      	it	cs
 800051e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000522:	bd30      	pop	{r4, r5, pc}
 8000524:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000528:	bf3c      	itt	cc
 800052a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800052e:	bd30      	popcc	{r4, r5, pc}
 8000530:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000534:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000538:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800053c:	f04f 0000 	mov.w	r0, #0
 8000540:	bd30      	pop	{r4, r5, pc}
 8000542:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000546:	bf1a      	itte	ne
 8000548:	4619      	movne	r1, r3
 800054a:	4610      	movne	r0, r2
 800054c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000550:	bf1c      	itt	ne
 8000552:	460b      	movne	r3, r1
 8000554:	4602      	movne	r2, r0
 8000556:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800055a:	bf06      	itte	eq
 800055c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000560:	ea91 0f03 	teqeq	r1, r3
 8000564:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000568:	bd30      	pop	{r4, r5, pc}
 800056a:	bf00      	nop

0800056c <__aeabi_ui2d>:
 800056c:	f090 0f00 	teq	r0, #0
 8000570:	bf04      	itt	eq
 8000572:	2100      	moveq	r1, #0
 8000574:	4770      	bxeq	lr
 8000576:	b530      	push	{r4, r5, lr}
 8000578:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800057c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000580:	f04f 0500 	mov.w	r5, #0
 8000584:	f04f 0100 	mov.w	r1, #0
 8000588:	e750      	b.n	800042c <__adddf3+0x138>
 800058a:	bf00      	nop

0800058c <__aeabi_i2d>:
 800058c:	f090 0f00 	teq	r0, #0
 8000590:	bf04      	itt	eq
 8000592:	2100      	moveq	r1, #0
 8000594:	4770      	bxeq	lr
 8000596:	b530      	push	{r4, r5, lr}
 8000598:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800059c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005a0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80005a4:	bf48      	it	mi
 80005a6:	4240      	negmi	r0, r0
 80005a8:	f04f 0100 	mov.w	r1, #0
 80005ac:	e73e      	b.n	800042c <__adddf3+0x138>
 80005ae:	bf00      	nop

080005b0 <__aeabi_f2d>:
 80005b0:	0042      	lsls	r2, r0, #1
 80005b2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80005b6:	ea4f 0131 	mov.w	r1, r1, rrx
 80005ba:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005be:	bf1f      	itttt	ne
 80005c0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005c4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005c8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005cc:	4770      	bxne	lr
 80005ce:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80005d2:	bf08      	it	eq
 80005d4:	4770      	bxeq	lr
 80005d6:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80005da:	bf04      	itt	eq
 80005dc:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80005e0:	4770      	bxeq	lr
 80005e2:	b530      	push	{r4, r5, lr}
 80005e4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005ec:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005f0:	e71c      	b.n	800042c <__adddf3+0x138>
 80005f2:	bf00      	nop

080005f4 <__aeabi_ul2d>:
 80005f4:	ea50 0201 	orrs.w	r2, r0, r1
 80005f8:	bf08      	it	eq
 80005fa:	4770      	bxeq	lr
 80005fc:	b530      	push	{r4, r5, lr}
 80005fe:	f04f 0500 	mov.w	r5, #0
 8000602:	e00a      	b.n	800061a <__aeabi_l2d+0x16>

08000604 <__aeabi_l2d>:
 8000604:	ea50 0201 	orrs.w	r2, r0, r1
 8000608:	bf08      	it	eq
 800060a:	4770      	bxeq	lr
 800060c:	b530      	push	{r4, r5, lr}
 800060e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000612:	d502      	bpl.n	800061a <__aeabi_l2d+0x16>
 8000614:	4240      	negs	r0, r0
 8000616:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800061a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800061e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000622:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000626:	f43f aed8 	beq.w	80003da <__adddf3+0xe6>
 800062a:	f04f 0203 	mov.w	r2, #3
 800062e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000632:	bf18      	it	ne
 8000634:	3203      	addne	r2, #3
 8000636:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800063a:	bf18      	it	ne
 800063c:	3203      	addne	r2, #3
 800063e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000642:	f1c2 0320 	rsb	r3, r2, #32
 8000646:	fa00 fc03 	lsl.w	ip, r0, r3
 800064a:	fa20 f002 	lsr.w	r0, r0, r2
 800064e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000652:	ea40 000e 	orr.w	r0, r0, lr
 8000656:	fa21 f102 	lsr.w	r1, r1, r2
 800065a:	4414      	add	r4, r2
 800065c:	e6bd      	b.n	80003da <__adddf3+0xe6>
 800065e:	bf00      	nop

08000660 <__aeabi_uldivmod>:
 8000660:	b953      	cbnz	r3, 8000678 <__aeabi_uldivmod+0x18>
 8000662:	b94a      	cbnz	r2, 8000678 <__aeabi_uldivmod+0x18>
 8000664:	2900      	cmp	r1, #0
 8000666:	bf08      	it	eq
 8000668:	2800      	cmpeq	r0, #0
 800066a:	bf1c      	itt	ne
 800066c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8000670:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8000674:	f000 b972 	b.w	800095c <__aeabi_idiv0>
 8000678:	f1ad 0c08 	sub.w	ip, sp, #8
 800067c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000680:	f000 f806 	bl	8000690 <__udivmoddi4>
 8000684:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000688:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800068c:	b004      	add	sp, #16
 800068e:	4770      	bx	lr

08000690 <__udivmoddi4>:
 8000690:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000694:	9e08      	ldr	r6, [sp, #32]
 8000696:	4604      	mov	r4, r0
 8000698:	4688      	mov	r8, r1
 800069a:	2b00      	cmp	r3, #0
 800069c:	d14b      	bne.n	8000736 <__udivmoddi4+0xa6>
 800069e:	428a      	cmp	r2, r1
 80006a0:	4615      	mov	r5, r2
 80006a2:	d967      	bls.n	8000774 <__udivmoddi4+0xe4>
 80006a4:	fab2 f282 	clz	r2, r2
 80006a8:	b14a      	cbz	r2, 80006be <__udivmoddi4+0x2e>
 80006aa:	f1c2 0720 	rsb	r7, r2, #32
 80006ae:	fa01 f302 	lsl.w	r3, r1, r2
 80006b2:	fa20 f707 	lsr.w	r7, r0, r7
 80006b6:	4095      	lsls	r5, r2
 80006b8:	ea47 0803 	orr.w	r8, r7, r3
 80006bc:	4094      	lsls	r4, r2
 80006be:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80006c2:	0c23      	lsrs	r3, r4, #16
 80006c4:	fbb8 f7fe 	udiv	r7, r8, lr
 80006c8:	fa1f fc85 	uxth.w	ip, r5
 80006cc:	fb0e 8817 	mls	r8, lr, r7, r8
 80006d0:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80006d4:	fb07 f10c 	mul.w	r1, r7, ip
 80006d8:	4299      	cmp	r1, r3
 80006da:	d909      	bls.n	80006f0 <__udivmoddi4+0x60>
 80006dc:	18eb      	adds	r3, r5, r3
 80006de:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
 80006e2:	f080 811b 	bcs.w	800091c <__udivmoddi4+0x28c>
 80006e6:	4299      	cmp	r1, r3
 80006e8:	f240 8118 	bls.w	800091c <__udivmoddi4+0x28c>
 80006ec:	3f02      	subs	r7, #2
 80006ee:	442b      	add	r3, r5
 80006f0:	1a5b      	subs	r3, r3, r1
 80006f2:	b2a4      	uxth	r4, r4
 80006f4:	fbb3 f0fe 	udiv	r0, r3, lr
 80006f8:	fb0e 3310 	mls	r3, lr, r0, r3
 80006fc:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000700:	fb00 fc0c 	mul.w	ip, r0, ip
 8000704:	45a4      	cmp	ip, r4
 8000706:	d909      	bls.n	800071c <__udivmoddi4+0x8c>
 8000708:	192c      	adds	r4, r5, r4
 800070a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800070e:	f080 8107 	bcs.w	8000920 <__udivmoddi4+0x290>
 8000712:	45a4      	cmp	ip, r4
 8000714:	f240 8104 	bls.w	8000920 <__udivmoddi4+0x290>
 8000718:	3802      	subs	r0, #2
 800071a:	442c      	add	r4, r5
 800071c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8000720:	eba4 040c 	sub.w	r4, r4, ip
 8000724:	2700      	movs	r7, #0
 8000726:	b11e      	cbz	r6, 8000730 <__udivmoddi4+0xa0>
 8000728:	40d4      	lsrs	r4, r2
 800072a:	2300      	movs	r3, #0
 800072c:	e9c6 4300 	strd	r4, r3, [r6]
 8000730:	4639      	mov	r1, r7
 8000732:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000736:	428b      	cmp	r3, r1
 8000738:	d909      	bls.n	800074e <__udivmoddi4+0xbe>
 800073a:	2e00      	cmp	r6, #0
 800073c:	f000 80eb 	beq.w	8000916 <__udivmoddi4+0x286>
 8000740:	2700      	movs	r7, #0
 8000742:	e9c6 0100 	strd	r0, r1, [r6]
 8000746:	4638      	mov	r0, r7
 8000748:	4639      	mov	r1, r7
 800074a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800074e:	fab3 f783 	clz	r7, r3
 8000752:	2f00      	cmp	r7, #0
 8000754:	d147      	bne.n	80007e6 <__udivmoddi4+0x156>
 8000756:	428b      	cmp	r3, r1
 8000758:	d302      	bcc.n	8000760 <__udivmoddi4+0xd0>
 800075a:	4282      	cmp	r2, r0
 800075c:	f200 80fa 	bhi.w	8000954 <__udivmoddi4+0x2c4>
 8000760:	1a84      	subs	r4, r0, r2
 8000762:	eb61 0303 	sbc.w	r3, r1, r3
 8000766:	2001      	movs	r0, #1
 8000768:	4698      	mov	r8, r3
 800076a:	2e00      	cmp	r6, #0
 800076c:	d0e0      	beq.n	8000730 <__udivmoddi4+0xa0>
 800076e:	e9c6 4800 	strd	r4, r8, [r6]
 8000772:	e7dd      	b.n	8000730 <__udivmoddi4+0xa0>
 8000774:	b902      	cbnz	r2, 8000778 <__udivmoddi4+0xe8>
 8000776:	deff      	udf	#255	; 0xff
 8000778:	fab2 f282 	clz	r2, r2
 800077c:	2a00      	cmp	r2, #0
 800077e:	f040 808f 	bne.w	80008a0 <__udivmoddi4+0x210>
 8000782:	1b49      	subs	r1, r1, r5
 8000784:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000788:	fa1f f885 	uxth.w	r8, r5
 800078c:	2701      	movs	r7, #1
 800078e:	fbb1 fcfe 	udiv	ip, r1, lr
 8000792:	0c23      	lsrs	r3, r4, #16
 8000794:	fb0e 111c 	mls	r1, lr, ip, r1
 8000798:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800079c:	fb08 f10c 	mul.w	r1, r8, ip
 80007a0:	4299      	cmp	r1, r3
 80007a2:	d907      	bls.n	80007b4 <__udivmoddi4+0x124>
 80007a4:	18eb      	adds	r3, r5, r3
 80007a6:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 80007aa:	d202      	bcs.n	80007b2 <__udivmoddi4+0x122>
 80007ac:	4299      	cmp	r1, r3
 80007ae:	f200 80cd 	bhi.w	800094c <__udivmoddi4+0x2bc>
 80007b2:	4684      	mov	ip, r0
 80007b4:	1a59      	subs	r1, r3, r1
 80007b6:	b2a3      	uxth	r3, r4
 80007b8:	fbb1 f0fe 	udiv	r0, r1, lr
 80007bc:	fb0e 1410 	mls	r4, lr, r0, r1
 80007c0:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 80007c4:	fb08 f800 	mul.w	r8, r8, r0
 80007c8:	45a0      	cmp	r8, r4
 80007ca:	d907      	bls.n	80007dc <__udivmoddi4+0x14c>
 80007cc:	192c      	adds	r4, r5, r4
 80007ce:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80007d2:	d202      	bcs.n	80007da <__udivmoddi4+0x14a>
 80007d4:	45a0      	cmp	r8, r4
 80007d6:	f200 80b6 	bhi.w	8000946 <__udivmoddi4+0x2b6>
 80007da:	4618      	mov	r0, r3
 80007dc:	eba4 0408 	sub.w	r4, r4, r8
 80007e0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80007e4:	e79f      	b.n	8000726 <__udivmoddi4+0x96>
 80007e6:	f1c7 0c20 	rsb	ip, r7, #32
 80007ea:	40bb      	lsls	r3, r7
 80007ec:	fa22 fe0c 	lsr.w	lr, r2, ip
 80007f0:	ea4e 0e03 	orr.w	lr, lr, r3
 80007f4:	fa01 f407 	lsl.w	r4, r1, r7
 80007f8:	fa20 f50c 	lsr.w	r5, r0, ip
 80007fc:	fa21 f30c 	lsr.w	r3, r1, ip
 8000800:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8000804:	4325      	orrs	r5, r4
 8000806:	fbb3 f9f8 	udiv	r9, r3, r8
 800080a:	0c2c      	lsrs	r4, r5, #16
 800080c:	fb08 3319 	mls	r3, r8, r9, r3
 8000810:	fa1f fa8e 	uxth.w	sl, lr
 8000814:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8000818:	fb09 f40a 	mul.w	r4, r9, sl
 800081c:	429c      	cmp	r4, r3
 800081e:	fa02 f207 	lsl.w	r2, r2, r7
 8000822:	fa00 f107 	lsl.w	r1, r0, r7
 8000826:	d90b      	bls.n	8000840 <__udivmoddi4+0x1b0>
 8000828:	eb1e 0303 	adds.w	r3, lr, r3
 800082c:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 8000830:	f080 8087 	bcs.w	8000942 <__udivmoddi4+0x2b2>
 8000834:	429c      	cmp	r4, r3
 8000836:	f240 8084 	bls.w	8000942 <__udivmoddi4+0x2b2>
 800083a:	f1a9 0902 	sub.w	r9, r9, #2
 800083e:	4473      	add	r3, lr
 8000840:	1b1b      	subs	r3, r3, r4
 8000842:	b2ad      	uxth	r5, r5
 8000844:	fbb3 f0f8 	udiv	r0, r3, r8
 8000848:	fb08 3310 	mls	r3, r8, r0, r3
 800084c:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8000850:	fb00 fa0a 	mul.w	sl, r0, sl
 8000854:	45a2      	cmp	sl, r4
 8000856:	d908      	bls.n	800086a <__udivmoddi4+0x1da>
 8000858:	eb1e 0404 	adds.w	r4, lr, r4
 800085c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8000860:	d26b      	bcs.n	800093a <__udivmoddi4+0x2aa>
 8000862:	45a2      	cmp	sl, r4
 8000864:	d969      	bls.n	800093a <__udivmoddi4+0x2aa>
 8000866:	3802      	subs	r0, #2
 8000868:	4474      	add	r4, lr
 800086a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800086e:	fba0 8902 	umull	r8, r9, r0, r2
 8000872:	eba4 040a 	sub.w	r4, r4, sl
 8000876:	454c      	cmp	r4, r9
 8000878:	46c2      	mov	sl, r8
 800087a:	464b      	mov	r3, r9
 800087c:	d354      	bcc.n	8000928 <__udivmoddi4+0x298>
 800087e:	d051      	beq.n	8000924 <__udivmoddi4+0x294>
 8000880:	2e00      	cmp	r6, #0
 8000882:	d069      	beq.n	8000958 <__udivmoddi4+0x2c8>
 8000884:	ebb1 050a 	subs.w	r5, r1, sl
 8000888:	eb64 0403 	sbc.w	r4, r4, r3
 800088c:	fa04 fc0c 	lsl.w	ip, r4, ip
 8000890:	40fd      	lsrs	r5, r7
 8000892:	40fc      	lsrs	r4, r7
 8000894:	ea4c 0505 	orr.w	r5, ip, r5
 8000898:	e9c6 5400 	strd	r5, r4, [r6]
 800089c:	2700      	movs	r7, #0
 800089e:	e747      	b.n	8000730 <__udivmoddi4+0xa0>
 80008a0:	f1c2 0320 	rsb	r3, r2, #32
 80008a4:	fa20 f703 	lsr.w	r7, r0, r3
 80008a8:	4095      	lsls	r5, r2
 80008aa:	fa01 f002 	lsl.w	r0, r1, r2
 80008ae:	fa21 f303 	lsr.w	r3, r1, r3
 80008b2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80008b6:	4338      	orrs	r0, r7
 80008b8:	0c01      	lsrs	r1, r0, #16
 80008ba:	fbb3 f7fe 	udiv	r7, r3, lr
 80008be:	fa1f f885 	uxth.w	r8, r5
 80008c2:	fb0e 3317 	mls	r3, lr, r7, r3
 80008c6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80008ca:	fb07 f308 	mul.w	r3, r7, r8
 80008ce:	428b      	cmp	r3, r1
 80008d0:	fa04 f402 	lsl.w	r4, r4, r2
 80008d4:	d907      	bls.n	80008e6 <__udivmoddi4+0x256>
 80008d6:	1869      	adds	r1, r5, r1
 80008d8:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 80008dc:	d22f      	bcs.n	800093e <__udivmoddi4+0x2ae>
 80008de:	428b      	cmp	r3, r1
 80008e0:	d92d      	bls.n	800093e <__udivmoddi4+0x2ae>
 80008e2:	3f02      	subs	r7, #2
 80008e4:	4429      	add	r1, r5
 80008e6:	1acb      	subs	r3, r1, r3
 80008e8:	b281      	uxth	r1, r0
 80008ea:	fbb3 f0fe 	udiv	r0, r3, lr
 80008ee:	fb0e 3310 	mls	r3, lr, r0, r3
 80008f2:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80008f6:	fb00 f308 	mul.w	r3, r0, r8
 80008fa:	428b      	cmp	r3, r1
 80008fc:	d907      	bls.n	800090e <__udivmoddi4+0x27e>
 80008fe:	1869      	adds	r1, r5, r1
 8000900:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 8000904:	d217      	bcs.n	8000936 <__udivmoddi4+0x2a6>
 8000906:	428b      	cmp	r3, r1
 8000908:	d915      	bls.n	8000936 <__udivmoddi4+0x2a6>
 800090a:	3802      	subs	r0, #2
 800090c:	4429      	add	r1, r5
 800090e:	1ac9      	subs	r1, r1, r3
 8000910:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8000914:	e73b      	b.n	800078e <__udivmoddi4+0xfe>
 8000916:	4637      	mov	r7, r6
 8000918:	4630      	mov	r0, r6
 800091a:	e709      	b.n	8000730 <__udivmoddi4+0xa0>
 800091c:	4607      	mov	r7, r0
 800091e:	e6e7      	b.n	80006f0 <__udivmoddi4+0x60>
 8000920:	4618      	mov	r0, r3
 8000922:	e6fb      	b.n	800071c <__udivmoddi4+0x8c>
 8000924:	4541      	cmp	r1, r8
 8000926:	d2ab      	bcs.n	8000880 <__udivmoddi4+0x1f0>
 8000928:	ebb8 0a02 	subs.w	sl, r8, r2
 800092c:	eb69 020e 	sbc.w	r2, r9, lr
 8000930:	3801      	subs	r0, #1
 8000932:	4613      	mov	r3, r2
 8000934:	e7a4      	b.n	8000880 <__udivmoddi4+0x1f0>
 8000936:	4660      	mov	r0, ip
 8000938:	e7e9      	b.n	800090e <__udivmoddi4+0x27e>
 800093a:	4618      	mov	r0, r3
 800093c:	e795      	b.n	800086a <__udivmoddi4+0x1da>
 800093e:	4667      	mov	r7, ip
 8000940:	e7d1      	b.n	80008e6 <__udivmoddi4+0x256>
 8000942:	4681      	mov	r9, r0
 8000944:	e77c      	b.n	8000840 <__udivmoddi4+0x1b0>
 8000946:	3802      	subs	r0, #2
 8000948:	442c      	add	r4, r5
 800094a:	e747      	b.n	80007dc <__udivmoddi4+0x14c>
 800094c:	f1ac 0c02 	sub.w	ip, ip, #2
 8000950:	442b      	add	r3, r5
 8000952:	e72f      	b.n	80007b4 <__udivmoddi4+0x124>
 8000954:	4638      	mov	r0, r7
 8000956:	e708      	b.n	800076a <__udivmoddi4+0xda>
 8000958:	4637      	mov	r7, r6
 800095a:	e6e9      	b.n	8000730 <__udivmoddi4+0xa0>

0800095c <__aeabi_idiv0>:
 800095c:	4770      	bx	lr
 800095e:	bf00      	nop

08000960 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
 8000960:	4b0f      	ldr	r3, [pc, #60]	; (80009a0 <HAL_InitTick+0x40>)
 8000962:	781b      	ldrb	r3, [r3, #0]
 8000964:	b90b      	cbnz	r3, 800096a <HAL_InitTick+0xa>
  {
    return HAL_ERROR;
 8000966:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 8000968:	4770      	bx	lr
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 800096a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800096e:	490d      	ldr	r1, [pc, #52]	; (80009a4 <HAL_InitTick+0x44>)
 8000970:	fbb2 f3f3 	udiv	r3, r2, r3
{
 8000974:	b510      	push	{r4, lr}
 8000976:	4604      	mov	r4, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 8000978:	6808      	ldr	r0, [r1, #0]
 800097a:	fbb0 f0f3 	udiv	r0, r0, r3
 800097e:	f001 fd2f 	bl	80023e0 <HAL_SYSTICK_Config>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000982:	2c0f      	cmp	r4, #15
 8000984:	d800      	bhi.n	8000988 <HAL_InitTick+0x28>
 8000986:	b108      	cbz	r0, 800098c <HAL_InitTick+0x2c>
    return HAL_ERROR;
 8000988:	2001      	movs	r0, #1
}
 800098a:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800098c:	2200      	movs	r2, #0
 800098e:	4621      	mov	r1, r4
 8000990:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000994:	f001 fcb0 	bl	80022f8 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8000998:	4b03      	ldr	r3, [pc, #12]	; (80009a8 <HAL_InitTick+0x48>)
 800099a:	2000      	movs	r0, #0
 800099c:	601c      	str	r4, [r3, #0]
}
 800099e:	bd10      	pop	{r4, pc}
 80009a0:	20000000 	.word	0x20000000
 80009a4:	200002bc 	.word	0x200002bc
 80009a8:	20000004 	.word	0x20000004

080009ac <HAL_Init>:
{
 80009ac:	b530      	push	{r4, r5, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80009ae:	2003      	movs	r0, #3
{
 80009b0:	b083      	sub	sp, #12
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80009b2:	f001 fc85 	bl	80022c0 <HAL_NVIC_SetPriorityGrouping>
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009b6:	4c12      	ldr	r4, [pc, #72]	; (8000a00 <HAL_Init+0x54>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009b8:	f007 fe9e 	bl	80086f8 <HAL_RCC_GetSysClockFreq>
 80009bc:	4a11      	ldr	r2, [pc, #68]	; (8000a04 <HAL_Init+0x58>)
 80009be:	4912      	ldr	r1, [pc, #72]	; (8000a08 <HAL_Init+0x5c>)
 80009c0:	6993      	ldr	r3, [r2, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009c2:	6992      	ldr	r2, [r2, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009c4:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemCoreClock = common_system_clock;
 80009c8:	4d10      	ldr	r5, [pc, #64]	; (8000a0c <HAL_Init+0x60>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009ca:	f002 020f 	and.w	r2, r2, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009ce:	5ccb      	ldrb	r3, [r1, r3]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009d0:	5c8a      	ldrb	r2, [r1, r2]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009d2:	f003 031f 	and.w	r3, r3, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009d6:	f002 021f 	and.w	r2, r2, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009da:	fa20 f303 	lsr.w	r3, r0, r3
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80009de:	2000      	movs	r0, #0
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009e0:	fa23 f202 	lsr.w	r2, r3, r2
  SystemCoreClock = common_system_clock;
 80009e4:	602b      	str	r3, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009e6:	6022      	str	r2, [r4, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80009e8:	f7ff ffba 	bl	8000960 <HAL_InitTick>
 80009ec:	b110      	cbz	r0, 80009f4 <HAL_Init+0x48>
    return HAL_ERROR;
 80009ee:	2001      	movs	r0, #1
}
 80009f0:	b003      	add	sp, #12
 80009f2:	bd30      	pop	{r4, r5, pc}
 80009f4:	9001      	str	r0, [sp, #4]
  HAL_MspInit();
 80009f6:	f01b f9ef 	bl	801bdd8 <HAL_MspInit>
  return HAL_OK;
 80009fa:	9801      	ldr	r0, [sp, #4]
}
 80009fc:	b003      	add	sp, #12
 80009fe:	bd30      	pop	{r4, r5, pc}
 8000a00:	200002c0 	.word	0x200002c0
 8000a04:	58024400 	.word	0x58024400
 8000a08:	0802a1f8 	.word	0x0802a1f8
 8000a0c:	200002bc 	.word	0x200002bc

08000a10 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 8000a10:	4a03      	ldr	r2, [pc, #12]	; (8000a20 <HAL_IncTick+0x10>)
 8000a12:	4b04      	ldr	r3, [pc, #16]	; (8000a24 <HAL_IncTick+0x14>)
 8000a14:	6811      	ldr	r1, [r2, #0]
 8000a16:	781b      	ldrb	r3, [r3, #0]
 8000a18:	440b      	add	r3, r1
 8000a1a:	6013      	str	r3, [r2, #0]
}
 8000a1c:	4770      	bx	lr
 8000a1e:	bf00      	nop
 8000a20:	20000674 	.word	0x20000674
 8000a24:	20000000 	.word	0x20000000

08000a28 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000a28:	4b01      	ldr	r3, [pc, #4]	; (8000a30 <HAL_GetTick+0x8>)
 8000a2a:	6818      	ldr	r0, [r3, #0]
}
 8000a2c:	4770      	bx	lr
 8000a2e:	bf00      	nop
 8000a30:	20000674 	.word	0x20000674

08000a34 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000a34:	b538      	push	{r3, r4, r5, lr}
 8000a36:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000a38:	f7ff fff6 	bl	8000a28 <HAL_GetTick>
 8000a3c:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000a3e:	1c63      	adds	r3, r4, #1
 8000a40:	d002      	beq.n	8000a48 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 8000a42:	4b04      	ldr	r3, [pc, #16]	; (8000a54 <HAL_Delay+0x20>)
 8000a44:	781b      	ldrb	r3, [r3, #0]
 8000a46:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8000a48:	f7ff ffee 	bl	8000a28 <HAL_GetTick>
 8000a4c:	1b40      	subs	r0, r0, r5
 8000a4e:	42a0      	cmp	r0, r4
 8000a50:	d3fa      	bcc.n	8000a48 <HAL_Delay+0x14>
  {
  }
}
 8000a52:	bd38      	pop	{r3, r4, r5, pc}
 8000a54:	20000000 	.word	0x20000000

08000a58 <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
 8000a58:	4b01      	ldr	r3, [pc, #4]	; (8000a60 <HAL_GetREVID+0x8>)
 8000a5a:	6818      	ldr	r0, [r3, #0]
}
 8000a5c:	0c00      	lsrs	r0, r0, #16
 8000a5e:	4770      	bx	lr
 8000a60:	5c001000 	.word	0x5c001000

08000a64 <HAL_SetFMCMemorySwappingConfig>:
  * @retval HAL state
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
 8000a64:	f030 7380 	bics.w	r3, r0, #16777216	; 0x1000000
{
 8000a68:	b510      	push	{r4, lr}
 8000a6a:	4604      	mov	r4, r0
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
 8000a6c:	d002      	beq.n	8000a74 <HAL_SetFMCMemorySwappingConfig+0x10>
 8000a6e:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
 8000a72:	d106      	bne.n	8000a82 <HAL_SetFMCMemorySwappingConfig+0x1e>
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
 8000a74:	4b06      	ldr	r3, [pc, #24]	; (8000a90 <HAL_SetFMCMemorySwappingConfig+0x2c>)
 8000a76:	6818      	ldr	r0, [r3, #0]
 8000a78:	f020 7040 	bic.w	r0, r0, #50331648	; 0x3000000
 8000a7c:	4320      	orrs	r0, r4
 8000a7e:	6018      	str	r0, [r3, #0]
}
 8000a80:	bd10      	pop	{r4, pc}
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
 8000a82:	f44f 6181 	mov.w	r1, #1032	; 0x408
 8000a86:	4803      	ldr	r0, [pc, #12]	; (8000a94 <HAL_SetFMCMemorySwappingConfig+0x30>)
 8000a88:	f012 ff22 	bl	80138d0 <assert_failed>
 8000a8c:	e7f2      	b.n	8000a74 <HAL_SetFMCMemorySwappingConfig+0x10>
 8000a8e:	bf00      	nop
 8000a90:	52004000 	.word	0x52004000
 8000a94:	0802904c 	.word	0x0802904c

08000a98 <HAL_ADC_Start_DMA>:
  * @param pData Destination Buffer address.
  * @param Length Number of data to be transferred from ADC peripheral to memory
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
{
 8000a98:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef tmp_hal_status;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000a9c:	4b6a      	ldr	r3, [pc, #424]	; (8000c48 <HAL_ADC_Start_DMA+0x1b0>)
{
 8000a9e:	460e      	mov	r6, r1
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000aa0:	6801      	ldr	r1, [r0, #0]
{
 8000aa2:	4604      	mov	r4, r0
 8000aa4:	4617      	mov	r7, r2
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000aa6:	4299      	cmp	r1, r3
 8000aa8:	d037      	beq.n	8000b1a <HAL_ADC_Start_DMA+0x82>
 8000aaa:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8000aae:	4299      	cmp	r1, r3
 8000ab0:	d033      	beq.n	8000b1a <HAL_ADC_Start_DMA+0x82>
 8000ab2:	4866      	ldr	r0, [pc, #408]	; (8000c4c <HAL_ADC_Start_DMA+0x1b4>)

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000ab4:	4a64      	ldr	r2, [pc, #400]	; (8000c48 <HAL_ADC_Start_DMA+0x1b0>)
 8000ab6:	4b66      	ldr	r3, [pc, #408]	; (8000c50 <HAL_ADC_Start_DMA+0x1b8>)
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultimode(ADC_Common_TypeDef *ADCxy_COMMON)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 8000ab8:	6885      	ldr	r5, [r0, #8]
 8000aba:	4291      	cmp	r1, r2
 8000abc:	bf18      	it	ne
 8000abe:	4299      	cmpne	r1, r3
 8000ac0:	d002      	beq.n	8000ac8 <HAL_ADC_Start_DMA+0x30>
 8000ac2:	4b64      	ldr	r3, [pc, #400]	; (8000c54 <HAL_ADC_Start_DMA+0x1bc>)
 8000ac4:	4299      	cmp	r1, r3
 8000ac6:	d12a      	bne.n	8000b1e <HAL_ADC_Start_DMA+0x86>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8000ac8:	688b      	ldr	r3, [r1, #8]
 8000aca:	075a      	lsls	r2, r3, #29
 8000acc:	d430      	bmi.n	8000b30 <HAL_ADC_Start_DMA+0x98>

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
  {
    /* Process locked */
    __HAL_LOCK(hadc);
 8000ace:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 8000ad2:	2b01      	cmp	r3, #1
 8000ad4:	d02c      	beq.n	8000b30 <HAL_ADC_Start_DMA+0x98>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 8000ad6:	f005 051f 	and.w	r5, r5, #31
 8000ada:	2301      	movs	r3, #1

    /* Ensure that multimode regular conversions are not enabled.   */
    /* Otherwise, dedicated API HAL_ADCEx_MultiModeStart_DMA() must be used.  */
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000adc:	2d09      	cmp	r5, #9
    __HAL_LOCK(hadc);
 8000ade:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000ae2:	d905      	bls.n	8000af0 <HAL_ADC_Start_DMA+0x58>
        LL_ADC_REG_StartConversion(hadc->Instance);
      }
      else
      {
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 8000ae4:	2300      	movs	r3, #0
 8000ae6:	2001      	movs	r0, #1
 8000ae8:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    tmp_hal_status = HAL_BUSY;
  }

  /* Return function status */
  return tmp_hal_status;
}
 8000aec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000af0:	f240 2021 	movw	r0, #545	; 0x221
 8000af4:	40e8      	lsrs	r0, r5
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
 8000af6:	07c3      	lsls	r3, r0, #31
 8000af8:	d5f4      	bpl.n	8000ae4 <HAL_ADC_Start_DMA+0x4c>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8000afa:	688b      	ldr	r3, [r1, #8]
 8000afc:	07d8      	lsls	r0, r3, #31
 8000afe:	d41a      	bmi.n	8000b36 <HAL_ADC_Start_DMA+0x9e>
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 8000b00:	688a      	ldr	r2, [r1, #8]
 8000b02:	4b55      	ldr	r3, [pc, #340]	; (8000c58 <HAL_ADC_Start_DMA+0x1c0>)
 8000b04:	421a      	tst	r2, r3
 8000b06:	d05b      	beq.n	8000bc0 <HAL_ADC_Start_DMA+0x128>
        }

        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000b08:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000b0a:	f043 0310 	orr.w	r3, r3, #16
 8000b0e:	6563      	str	r3, [r4, #84]	; 0x54

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000b10:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000b12:	f043 0301 	orr.w	r3, r3, #1
 8000b16:	65a3      	str	r3, [r4, #88]	; 0x58
 8000b18:	e7e4      	b.n	8000ae4 <HAL_ADC_Start_DMA+0x4c>
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000b1a:	4850      	ldr	r0, [pc, #320]	; (8000c5c <HAL_ADC_Start_DMA+0x1c4>)
 8000b1c:	e7ca      	b.n	8000ab4 <HAL_ADC_Start_DMA+0x1c>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000b1e:	f240 71a7 	movw	r1, #1959	; 0x7a7
 8000b22:	484f      	ldr	r0, [pc, #316]	; (8000c60 <HAL_ADC_Start_DMA+0x1c8>)
 8000b24:	f012 fed4 	bl	80138d0 <assert_failed>
 8000b28:	6821      	ldr	r1, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8000b2a:	688b      	ldr	r3, [r1, #8]
 8000b2c:	075a      	lsls	r2, r3, #29
 8000b2e:	d5ce      	bpl.n	8000ace <HAL_ADC_Start_DMA+0x36>
    tmp_hal_status = HAL_BUSY;
 8000b30:	2002      	movs	r0, #2
}
 8000b32:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000b36:	4b46      	ldr	r3, [pc, #280]	; (8000c50 <HAL_ADC_Start_DMA+0x1b8>)
 8000b38:	1ac9      	subs	r1, r1, r3
 8000b3a:	bf18      	it	ne
 8000b3c:	2101      	movne	r1, #1
        ADC_STATE_CLR_SET(hadc->State,
 8000b3e:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8000b40:	4b48      	ldr	r3, [pc, #288]	; (8000c64 <HAL_ADC_Start_DMA+0x1cc>)
 8000b42:	4013      	ands	r3, r2
 8000b44:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000b48:	6563      	str	r3, [r4, #84]	; 0x54
            || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000b4a:	b105      	cbz	r5, 8000b4e <HAL_ADC_Start_DMA+0xb6>
 8000b4c:	b119      	cbz	r1, 8000b56 <HAL_ADC_Start_DMA+0xbe>
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8000b4e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000b50:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8000b54:	6563      	str	r3, [r4, #84]	; 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
 8000b56:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000b58:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
 8000b5c:	d02e      	beq.n	8000bbc <HAL_ADC_Start_DMA+0x124>
          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
 8000b5e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000b60:	f023 0306 	bic.w	r3, r3, #6
 8000b64:	65a3      	str	r3, [r4, #88]	; 0x58
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8000b66:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8000b68:	463b      	mov	r3, r7
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8000b6a:	483f      	ldr	r0, [pc, #252]	; (8000c68 <HAL_ADC_Start_DMA+0x1d0>)
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8000b6c:	4632      	mov	r2, r6
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8000b6e:	4f3f      	ldr	r7, [pc, #252]	; (8000c6c <HAL_ADC_Start_DMA+0x1d4>)
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8000b70:	251c      	movs	r5, #28
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8000b72:	63c8      	str	r0, [r1, #60]	; 0x3c
        __HAL_UNLOCK(hadc);
 8000b74:	2100      	movs	r1, #0
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8000b76:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8000b78:	4e3d      	ldr	r6, [pc, #244]	; (8000c70 <HAL_ADC_Start_DMA+0x1d8>)
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8000b7a:	6407      	str	r7, [r0, #64]	; 0x40
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8000b7c:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8000b7e:	64c6      	str	r6, [r0, #76]	; 0x4c
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8000b80:	6820      	ldr	r0, [r4, #0]
 8000b82:	6005      	str	r5, [r0, #0]
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8000b84:	6820      	ldr	r0, [r4, #0]
        __HAL_UNLOCK(hadc);
 8000b86:	f884 1050 	strb.w	r1, [r4, #80]	; 0x50
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8000b8a:	6841      	ldr	r1, [r0, #4]
 8000b8c:	f041 0110 	orr.w	r1, r1, #16
 8000b90:	6041      	str	r1, [r0, #4]
        LL_ADC_REG_SetDataTransferMode(hadc->Instance, (uint32_t)hadc->Init.ConversionDataManagement);
 8000b92:	6820      	ldr	r0, [r4, #0]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DMNGT, DataTransferMode);
 8000b94:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 8000b96:	68c1      	ldr	r1, [r0, #12]
 8000b98:	f021 0103 	bic.w	r1, r1, #3
 8000b9c:	4329      	orrs	r1, r5
 8000b9e:	60c1      	str	r1, [r0, #12]
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8000ba0:	6821      	ldr	r1, [r4, #0]
 8000ba2:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8000ba4:	3140      	adds	r1, #64	; 0x40
 8000ba6:	f002 fc2b 	bl	8003400 <HAL_DMA_Start_IT>
        LL_ADC_REG_StartConversion(hadc->Instance);
 8000baa:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(ADCx->CR,
 8000bac:	4b31      	ldr	r3, [pc, #196]	; (8000c74 <HAL_ADC_Start_DMA+0x1dc>)
 8000bae:	6891      	ldr	r1, [r2, #8]
 8000bb0:	400b      	ands	r3, r1
 8000bb2:	f043 0304 	orr.w	r3, r3, #4
 8000bb6:	6093      	str	r3, [r2, #8]
}
 8000bb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          ADC_CLEAR_ERRORCODE(hadc);
 8000bbc:	65a3      	str	r3, [r4, #88]	; 0x58
 8000bbe:	e7d2      	b.n	8000b66 <HAL_ADC_Start_DMA+0xce>
  MODIFY_REG(ADCx->CR,
 8000bc0:	688a      	ldr	r2, [r1, #8]
 8000bc2:	4b2c      	ldr	r3, [pc, #176]	; (8000c74 <HAL_ADC_Start_DMA+0x1dc>)
 8000bc4:	4013      	ands	r3, r2
 8000bc6:	f043 0301 	orr.w	r3, r3, #1
 8000bca:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8000bcc:	f7ff ff2c 	bl	8000a28 <HAL_GetTick>
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000bd0:	6823      	ldr	r3, [r4, #0]
 8000bd2:	4a1d      	ldr	r2, [pc, #116]	; (8000c48 <HAL_ADC_Start_DMA+0x1b0>)
    tickstart = HAL_GetTick();
 8000bd4:	4680      	mov	r8, r0
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000bd6:	4293      	cmp	r3, r2
 8000bd8:	d022      	beq.n	8000c20 <HAL_ADC_Start_DMA+0x188>
 8000bda:	f502 7280 	add.w	r2, r2, #256	; 0x100
 8000bde:	4293      	cmp	r3, r2
 8000be0:	d01e      	beq.n	8000c20 <HAL_ADC_Start_DMA+0x188>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 8000be2:	4a1a      	ldr	r2, [pc, #104]	; (8000c4c <HAL_ADC_Start_DMA+0x1b4>)
 8000be4:	6892      	ldr	r2, [r2, #8]
  MODIFY_REG(ADCx->CR,
 8000be6:	f8df 908c 	ldr.w	r9, [pc, #140]	; 8000c74 <HAL_ADC_Start_DMA+0x1dc>
 8000bea:	e00c      	b.n	8000c06 <HAL_ADC_Start_DMA+0x16e>
 8000bec:	689a      	ldr	r2, [r3, #8]
 8000bee:	ea02 0209 	and.w	r2, r2, r9
 8000bf2:	f042 0201 	orr.w	r2, r2, #1
 8000bf6:	609a      	str	r2, [r3, #8]
        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8000bf8:	f7ff ff16 	bl	8000a28 <HAL_GetTick>
 8000bfc:	eba0 0008 	sub.w	r0, r0, r8
 8000c00:	2802      	cmp	r0, #2
 8000c02:	d881      	bhi.n	8000b08 <HAL_ADC_Start_DMA+0x70>
 8000c04:	6823      	ldr	r3, [r4, #0]
      while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8000c06:	681a      	ldr	r2, [r3, #0]
 8000c08:	07d2      	lsls	r2, r2, #31
 8000c0a:	d418      	bmi.n	8000c3e <HAL_ADC_Start_DMA+0x1a6>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8000c0c:	689a      	ldr	r2, [r3, #8]
 8000c0e:	07d1      	lsls	r1, r2, #31
 8000c10:	d5ec      	bpl.n	8000bec <HAL_ADC_Start_DMA+0x154>
        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8000c12:	f7ff ff09 	bl	8000a28 <HAL_GetTick>
 8000c16:	eba0 0008 	sub.w	r0, r0, r8
 8000c1a:	2802      	cmp	r0, #2
 8000c1c:	d9f2      	bls.n	8000c04 <HAL_ADC_Start_DMA+0x16c>
 8000c1e:	e773      	b.n	8000b08 <HAL_ADC_Start_DMA+0x70>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 8000c20:	490e      	ldr	r1, [pc, #56]	; (8000c5c <HAL_ADC_Start_DMA+0x1c4>)
    if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8000c22:	4a0b      	ldr	r2, [pc, #44]	; (8000c50 <HAL_ADC_Start_DMA+0x1b8>)
 8000c24:	6889      	ldr	r1, [r1, #8]
         || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000c26:	f011 0f1f 	tst.w	r1, #31
 8000c2a:	bf0c      	ite	eq
 8000c2c:	2101      	moveq	r1, #1
 8000c2e:	2100      	movne	r1, #0
 8000c30:	4293      	cmp	r3, r2
 8000c32:	bf18      	it	ne
 8000c34:	f041 0101 	orrne.w	r1, r1, #1
 8000c38:	2900      	cmp	r1, #0
 8000c3a:	d1d4      	bne.n	8000be6 <HAL_ADC_Start_DMA+0x14e>
 8000c3c:	e77f      	b.n	8000b3e <HAL_ADC_Start_DMA+0xa6>
 8000c3e:	4904      	ldr	r1, [pc, #16]	; (8000c50 <HAL_ADC_Start_DMA+0x1b8>)
 8000c40:	1a59      	subs	r1, r3, r1
 8000c42:	bf18      	it	ne
 8000c44:	2101      	movne	r1, #1
 8000c46:	e77a      	b.n	8000b3e <HAL_ADC_Start_DMA+0xa6>
 8000c48:	40022000 	.word	0x40022000
 8000c4c:	58026300 	.word	0x58026300
 8000c50:	40022100 	.word	0x40022100
 8000c54:	58026000 	.word	0x58026000
 8000c58:	8000003f 	.word	0x8000003f
 8000c5c:	40022300 	.word	0x40022300
 8000c60:	08029080 	.word	0x08029080
 8000c64:	fffff0fe 	.word	0xfffff0fe
 8000c68:	08000f65 	.word	0x08000f65
 8000c6c:	08000c79 	.word	0x08000c79
 8000c70:	08000fcd 	.word	0x08000fcd
 8000c74:	7fffffc0 	.word	0x7fffffc0

08000c78 <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)
{
 8000c78:	b508      	push	{r3, lr}

  /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
 8000c7a:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8000c7c:	f012 fc5e 	bl	801353c <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8000c80:	bd08      	pop	{r3, pc}
 8000c82:	bf00      	nop

08000c84 <HAL_ADC_LevelOutOfWindowCallback>:
 8000c84:	4770      	bx	lr
 8000c86:	bf00      	nop

08000c88 <HAL_ADC_ErrorCallback>:
 8000c88:	4770      	bx	lr
 8000c8a:	bf00      	nop

08000c8c <HAL_ADC_IRQHandler>:
{
 8000c8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000c8e:	4aa1      	ldr	r2, [pc, #644]	; (8000f14 <HAL_ADC_IRQHandler+0x288>)
{
 8000c90:	4604      	mov	r4, r0
  uint32_t tmp_isr = hadc->Instance->ISR;
 8000c92:	6803      	ldr	r3, [r0, #0]
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000c94:	4293      	cmp	r3, r2
  uint32_t tmp_isr = hadc->Instance->ISR;
 8000c96:	681d      	ldr	r5, [r3, #0]
  uint32_t tmp_ier = hadc->Instance->IER;
 8000c98:	685e      	ldr	r6, [r3, #4]
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000c9a:	f000 8096 	beq.w	8000dca <HAL_ADC_IRQHandler+0x13e>
 8000c9e:	f502 7280 	add.w	r2, r2, #256	; 0x100
 8000ca2:	4293      	cmp	r3, r2
 8000ca4:	f000 8091 	beq.w	8000dca <HAL_ADC_IRQHandler+0x13e>
 8000ca8:	4a9b      	ldr	r2, [pc, #620]	; (8000f18 <HAL_ADC_IRQHandler+0x28c>)
 8000caa:	6897      	ldr	r7, [r2, #8]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000cac:	4999      	ldr	r1, [pc, #612]	; (8000f14 <HAL_ADC_IRQHandler+0x288>)
 8000cae:	4a9b      	ldr	r2, [pc, #620]	; (8000f1c <HAL_ADC_IRQHandler+0x290>)
 8000cb0:	f007 071f 	and.w	r7, r7, #31
 8000cb4:	428b      	cmp	r3, r1
 8000cb6:	bf18      	it	ne
 8000cb8:	4293      	cmpne	r3, r2
 8000cba:	d003      	beq.n	8000cc4 <HAL_ADC_IRQHandler+0x38>
 8000cbc:	4a98      	ldr	r2, [pc, #608]	; (8000f20 <HAL_ADC_IRQHandler+0x294>)
 8000cbe:	4293      	cmp	r3, r2
 8000cc0:	f040 808b 	bne.w	8000dda <HAL_ADC_IRQHandler+0x14e>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
 8000cc4:	6923      	ldr	r3, [r4, #16]
 8000cc6:	2b04      	cmp	r3, #4
 8000cc8:	d001      	beq.n	8000cce <HAL_ADC_IRQHandler+0x42>
 8000cca:	2b08      	cmp	r3, #8
 8000ccc:	d17f      	bne.n	8000dce <HAL_ADC_IRQHandler+0x142>
  if (((tmp_isr & ADC_FLAG_EOSMP) == ADC_FLAG_EOSMP) && ((tmp_ier & ADC_IT_EOSMP) == ADC_IT_EOSMP))
 8000cce:	07a8      	lsls	r0, r5, #30
 8000cd0:	d502      	bpl.n	8000cd8 <HAL_ADC_IRQHandler+0x4c>
 8000cd2:	07b1      	lsls	r1, r6, #30
 8000cd4:	f100 80aa 	bmi.w	8000e2c <HAL_ADC_IRQHandler+0x1a0>
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
 8000cd8:	076b      	lsls	r3, r5, #29
 8000cda:	d56b      	bpl.n	8000db4 <HAL_ADC_IRQHandler+0x128>
 8000cdc:	0770      	lsls	r0, r6, #29
 8000cde:	d569      	bpl.n	8000db4 <HAL_ADC_IRQHandler+0x128>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8000ce0:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000ce2:	06db      	lsls	r3, r3, #27
 8000ce4:	d403      	bmi.n	8000cee <HAL_ADC_IRQHandler+0x62>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8000ce6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000ce8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000cec:	6563      	str	r3, [r4, #84]	; 0x54
    if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
 8000cee:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8000cf0:	68da      	ldr	r2, [r3, #12]
 8000cf2:	f412 6f40 	tst.w	r2, #3072	; 0xc00
 8000cf6:	d11c      	bne.n	8000d32 <HAL_ADC_IRQHandler+0xa6>
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8000cf8:	4a88      	ldr	r2, [pc, #544]	; (8000f1c <HAL_ADC_IRQHandler+0x290>)
 8000cfa:	4293      	cmp	r3, r2
 8000cfc:	f000 80fa 	beq.w	8000ef4 <HAL_ADC_IRQHandler+0x268>
        tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 8000d00:	68da      	ldr	r2, [r3, #12]
      if (READ_BIT(tmp_cfgr, ADC_CFGR_CONT) != ADC_CFGR_CONT)
 8000d02:	0490      	lsls	r0, r2, #18
 8000d04:	d415      	bmi.n	8000d32 <HAL_ADC_IRQHandler+0xa6>
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 8000d06:	681a      	ldr	r2, [r3, #0]
 8000d08:	0711      	lsls	r1, r2, #28
 8000d0a:	d512      	bpl.n	8000d32 <HAL_ADC_IRQHandler+0xa6>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8000d0c:	689a      	ldr	r2, [r3, #8]
 8000d0e:	0752      	lsls	r2, r2, #29
 8000d10:	f100 811a 	bmi.w	8000f48 <HAL_ADC_IRQHandler+0x2bc>
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8000d14:	685a      	ldr	r2, [r3, #4]
 8000d16:	f022 020c 	bic.w	r2, r2, #12
 8000d1a:	605a      	str	r2, [r3, #4]
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8000d1c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000d1e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000d22:	6563      	str	r3, [r4, #84]	; 0x54
            if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8000d24:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000d26:	04db      	lsls	r3, r3, #19
 8000d28:	d403      	bmi.n	8000d32 <HAL_ADC_IRQHandler+0xa6>
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8000d2a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000d2c:	f043 0301 	orr.w	r3, r3, #1
 8000d30:	6563      	str	r3, [r4, #84]	; 0x54
    HAL_ADC_ConvCpltCallback(hadc);
 8000d32:	4620      	mov	r0, r4
 8000d34:	f012 fc00 	bl	8013538 <HAL_ADC_ConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 8000d38:	6823      	ldr	r3, [r4, #0]
 8000d3a:	220c      	movs	r2, #12
 8000d3c:	601a      	str	r2, [r3, #0]
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
 8000d3e:	06a8      	lsls	r0, r5, #26
 8000d40:	d53e      	bpl.n	8000dc0 <HAL_ADC_IRQHandler+0x134>
 8000d42:	06b1      	lsls	r1, r6, #26
 8000d44:	d53c      	bpl.n	8000dc0 <HAL_ADC_IRQHandler+0x134>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8000d46:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000d48:	06d8      	lsls	r0, r3, #27
 8000d4a:	d403      	bmi.n	8000d54 <HAL_ADC_IRQHandler+0xc8>
      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 8000d4c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000d4e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000d52:	6563      	str	r3, [r4, #84]	; 0x54
    tmp_adc_inj_is_trigger_source_sw_start = LL_ADC_INJ_IsTriggerSourceSWStart(hadc->Instance);
 8000d54:	6823      	ldr	r3, [r4, #0]
    if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8000d56:	4871      	ldr	r0, [pc, #452]	; (8000f1c <HAL_ADC_IRQHandler+0x290>)
  return ((READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN)) ? 1UL : 0UL);
 8000d58:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000d5a:	4283      	cmp	r3, r0
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8000d5c:	68d9      	ldr	r1, [r3, #12]
  return ((READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN)) ? 1UL : 0UL);
 8000d5e:	f402 72c0 	and.w	r2, r2, #384	; 0x180
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8000d62:	f401 6140 	and.w	r1, r1, #3072	; 0xc00
 8000d66:	d06f      	beq.n	8000e48 <HAL_ADC_IRQHandler+0x1bc>
      tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 8000d68:	68d8      	ldr	r0, [r3, #12]
    if ((tmp_adc_inj_is_trigger_source_sw_start != 0UL)            ||
 8000d6a:	2a00      	cmp	r2, #0
 8000d6c:	d075      	beq.n	8000e5a <HAL_ADC_IRQHandler+0x1ce>
        ((READ_BIT(tmp_cfgr, ADC_CFGR_JAUTO) == 0UL)      &&
 8000d6e:	f000 7200 	and.w	r2, r0, #33554432	; 0x2000000
 8000d72:	430a      	orrs	r2, r1
 8000d74:	f000 80c3 	beq.w	8000efe <HAL_ADC_IRQHandler+0x272>
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
 8000d78:	4620      	mov	r0, r4
 8000d7a:	f001 f9d9 	bl	8002130 <HAL_ADCEx_InjectedConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC | ADC_FLAG_JEOS);
 8000d7e:	6823      	ldr	r3, [r4, #0]
 8000d80:	2260      	movs	r2, #96	; 0x60
 8000d82:	601a      	str	r2, [r3, #0]
  if (((tmp_isr & ADC_FLAG_AWD1) == ADC_FLAG_AWD1) && ((tmp_ier & ADC_IT_AWD1) == ADC_IT_AWD1))
 8000d84:	0628      	lsls	r0, r5, #24
 8000d86:	d502      	bpl.n	8000d8e <HAL_ADC_IRQHandler+0x102>
 8000d88:	0631      	lsls	r1, r6, #24
 8000d8a:	f100 809c 	bmi.w	8000ec6 <HAL_ADC_IRQHandler+0x23a>
  if (((tmp_isr & ADC_FLAG_AWD2) == ADC_FLAG_AWD2) && ((tmp_ier & ADC_IT_AWD2) == ADC_IT_AWD2))
 8000d8e:	05ea      	lsls	r2, r5, #23
 8000d90:	d502      	bpl.n	8000d98 <HAL_ADC_IRQHandler+0x10c>
 8000d92:	05f3      	lsls	r3, r6, #23
 8000d94:	f100 80a2 	bmi.w	8000edc <HAL_ADC_IRQHandler+0x250>
  if (((tmp_isr & ADC_FLAG_AWD3) == ADC_FLAG_AWD3) && ((tmp_ier & ADC_IT_AWD3) == ADC_IT_AWD3))
 8000d98:	05a8      	lsls	r0, r5, #22
 8000d9a:	d502      	bpl.n	8000da2 <HAL_ADC_IRQHandler+0x116>
 8000d9c:	05b1      	lsls	r1, r6, #22
 8000d9e:	f100 8086 	bmi.w	8000eae <HAL_ADC_IRQHandler+0x222>
  if (((tmp_isr & ADC_FLAG_OVR) == ADC_FLAG_OVR) && ((tmp_ier & ADC_IT_OVR) == ADC_IT_OVR))
 8000da2:	06ea      	lsls	r2, r5, #27
 8000da4:	d501      	bpl.n	8000daa <HAL_ADC_IRQHandler+0x11e>
 8000da6:	06f3      	lsls	r3, r6, #27
 8000da8:	d41d      	bmi.n	8000de6 <HAL_ADC_IRQHandler+0x15a>
  if (((tmp_isr & ADC_FLAG_JQOVF) == ADC_FLAG_JQOVF) && ((tmp_ier & ADC_IT_JQOVF) == ADC_IT_JQOVF))
 8000daa:	0568      	lsls	r0, r5, #21
 8000dac:	d501      	bpl.n	8000db2 <HAL_ADC_IRQHandler+0x126>
 8000dae:	0571      	lsls	r1, r6, #21
 8000db0:	d46c      	bmi.n	8000e8c <HAL_ADC_IRQHandler+0x200>
}
 8000db2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
 8000db4:	0729      	lsls	r1, r5, #28
 8000db6:	d5c2      	bpl.n	8000d3e <HAL_ADC_IRQHandler+0xb2>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
 8000db8:	0732      	lsls	r2, r6, #28
 8000dba:	d491      	bmi.n	8000ce0 <HAL_ADC_IRQHandler+0x54>
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
 8000dbc:	06a8      	lsls	r0, r5, #26
 8000dbe:	d4c0      	bmi.n	8000d42 <HAL_ADC_IRQHandler+0xb6>
 8000dc0:	066a      	lsls	r2, r5, #25
 8000dc2:	d5df      	bpl.n	8000d84 <HAL_ADC_IRQHandler+0xf8>
      (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
 8000dc4:	0673      	lsls	r3, r6, #25
 8000dc6:	d5dd      	bpl.n	8000d84 <HAL_ADC_IRQHandler+0xf8>
 8000dc8:	e7bd      	b.n	8000d46 <HAL_ADC_IRQHandler+0xba>
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000dca:	4a56      	ldr	r2, [pc, #344]	; (8000f24 <HAL_ADC_IRQHandler+0x298>)
 8000dcc:	e76d      	b.n	8000caa <HAL_ADC_IRQHandler+0x1e>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
 8000dce:	f640 0199 	movw	r1, #2201	; 0x899
 8000dd2:	4855      	ldr	r0, [pc, #340]	; (8000f28 <HAL_ADC_IRQHandler+0x29c>)
 8000dd4:	f012 fd7c 	bl	80138d0 <assert_failed>
 8000dd8:	e779      	b.n	8000cce <HAL_ADC_IRQHandler+0x42>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000dda:	f640 0198 	movw	r1, #2200	; 0x898
 8000dde:	4852      	ldr	r0, [pc, #328]	; (8000f28 <HAL_ADC_IRQHandler+0x29c>)
 8000de0:	f012 fd76 	bl	80138d0 <assert_failed>
 8000de4:	e76e      	b.n	8000cc4 <HAL_ADC_IRQHandler+0x38>
    if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
 8000de6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000de8:	b18b      	cbz	r3, 8000e0e <HAL_ADC_IRQHandler+0x182>
 8000dea:	6823      	ldr	r3, [r4, #0]
      if (tmp_multimode_config != LL_ADC_MULTI_INDEPENDENT)
 8000dec:	2f00      	cmp	r7, #0
 8000dee:	f000 809d 	beq.w	8000f2c <HAL_ADC_IRQHandler+0x2a0>
        if (LL_ADC_GetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DMA_EACH_ADC)
 8000df2:	4a48      	ldr	r2, [pc, #288]	; (8000f14 <HAL_ADC_IRQHandler+0x288>)
 8000df4:	4293      	cmp	r3, r2
 8000df6:	f000 80b0 	beq.w	8000f5a <HAL_ADC_IRQHandler+0x2ce>
 8000dfa:	f502 7280 	add.w	r2, r2, #256	; 0x100
 8000dfe:	4293      	cmp	r3, r2
 8000e00:	f000 80ab 	beq.w	8000f5a <HAL_ADC_IRQHandler+0x2ce>
 8000e04:	4a44      	ldr	r2, [pc, #272]	; (8000f18 <HAL_ADC_IRQHandler+0x28c>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DAMDF));
 8000e06:	6892      	ldr	r2, [r2, #8]
 8000e08:	f412 4f40 	tst.w	r2, #49152	; 0xc000
 8000e0c:	d00b      	beq.n	8000e26 <HAL_ADC_IRQHandler+0x19a>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
 8000e0e:	6d63      	ldr	r3, [r4, #84]	; 0x54
      HAL_ADC_ErrorCallback(hadc);
 8000e10:	4620      	mov	r0, r4
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
 8000e12:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000e16:	6563      	str	r3, [r4, #84]	; 0x54
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8000e18:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000e1a:	f043 0302 	orr.w	r3, r3, #2
 8000e1e:	65a3      	str	r3, [r4, #88]	; 0x58
      HAL_ADC_ErrorCallback(hadc);
 8000e20:	f7ff ff32 	bl	8000c88 <HAL_ADC_ErrorCallback>
 8000e24:	6823      	ldr	r3, [r4, #0]
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8000e26:	2210      	movs	r2, #16
 8000e28:	601a      	str	r2, [r3, #0]
 8000e2a:	e7be      	b.n	8000daa <HAL_ADC_IRQHandler+0x11e>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8000e2c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000e2e:	06da      	lsls	r2, r3, #27
 8000e30:	d403      	bmi.n	8000e3a <HAL_ADC_IRQHandler+0x1ae>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOSMP);
 8000e32:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000e34:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000e38:	6563      	str	r3, [r4, #84]	; 0x54
    HAL_ADCEx_EndOfSamplingCallback(hadc);
 8000e3a:	4620      	mov	r0, r4
 8000e3c:	f001 f980 	bl	8002140 <HAL_ADCEx_EndOfSamplingCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOSMP);
 8000e40:	6823      	ldr	r3, [r4, #0]
 8000e42:	2202      	movs	r2, #2
 8000e44:	601a      	str	r2, [r3, #0]
 8000e46:	e747      	b.n	8000cd8 <HAL_ADC_IRQHandler+0x4c>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_SIMULT)
 8000e48:	1fb8      	subs	r0, r7, #6
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_INTERL)
 8000e4a:	2801      	cmp	r0, #1
 8000e4c:	d98c      	bls.n	8000d68 <HAL_ADC_IRQHandler+0xdc>
 8000e4e:	2f00      	cmp	r7, #0
 8000e50:	d08a      	beq.n	8000d68 <HAL_ADC_IRQHandler+0xdc>
      tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
 8000e52:	4830      	ldr	r0, [pc, #192]	; (8000f14 <HAL_ADC_IRQHandler+0x288>)
 8000e54:	68c0      	ldr	r0, [r0, #12]
    if ((tmp_adc_inj_is_trigger_source_sw_start != 0UL)            ||
 8000e56:	2a00      	cmp	r2, #0
 8000e58:	d189      	bne.n	8000d6e <HAL_ADC_IRQHandler+0xe2>
      if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS))
 8000e5a:	681a      	ldr	r2, [r3, #0]
 8000e5c:	0652      	lsls	r2, r2, #25
 8000e5e:	d58b      	bpl.n	8000d78 <HAL_ADC_IRQHandler+0xec>
        if (READ_BIT(tmp_cfgr, ADC_CFGR_JQM) == 0UL)
 8000e60:	0281      	lsls	r1, r0, #10
 8000e62:	d489      	bmi.n	8000d78 <HAL_ADC_IRQHandler+0xec>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8000e64:	689a      	ldr	r2, [r3, #8]
 8000e66:	0712      	lsls	r2, r2, #28
 8000e68:	d465      	bmi.n	8000f36 <HAL_ADC_IRQHandler+0x2aa>
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC | ADC_IT_JEOS);
 8000e6a:	685a      	ldr	r2, [r3, #4]
 8000e6c:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 8000e70:	605a      	str	r2, [r3, #4]
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
 8000e72:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000e74:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000e78:	6563      	str	r3, [r4, #84]	; 0x54
            if ((hadc->State & HAL_ADC_STATE_REG_BUSY) == 0UL)
 8000e7a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000e7c:	05db      	lsls	r3, r3, #23
 8000e7e:	f53f af7b 	bmi.w	8000d78 <HAL_ADC_IRQHandler+0xec>
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8000e82:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000e84:	f043 0301 	orr.w	r3, r3, #1
 8000e88:	6563      	str	r3, [r4, #84]	; 0x54
 8000e8a:	e775      	b.n	8000d78 <HAL_ADC_IRQHandler+0xec>
    SET_BIT(hadc->State, HAL_ADC_STATE_INJ_JQOVF);
 8000e8c:	6d63      	ldr	r3, [r4, #84]	; 0x54
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JQOVF);
 8000e8e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000e92:	6822      	ldr	r2, [r4, #0]
    HAL_ADCEx_InjectedQueueOverflowCallback(hadc);
 8000e94:	4620      	mov	r0, r4
    SET_BIT(hadc->State, HAL_ADC_STATE_INJ_JQOVF);
 8000e96:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000e9a:	6563      	str	r3, [r4, #84]	; 0x54
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
 8000e9c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000e9e:	f043 0308 	orr.w	r3, r3, #8
 8000ea2:	65a3      	str	r3, [r4, #88]	; 0x58
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JQOVF);
 8000ea4:	6011      	str	r1, [r2, #0]
}
 8000ea6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    HAL_ADCEx_InjectedQueueOverflowCallback(hadc);
 8000eaa:	f001 b943 	b.w	8002134 <HAL_ADCEx_InjectedQueueOverflowCallback>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
 8000eae:	6d63      	ldr	r3, [r4, #84]	; 0x54
    HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
 8000eb0:	4620      	mov	r0, r4
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
 8000eb2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000eb6:	6563      	str	r3, [r4, #84]	; 0x54
    HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
 8000eb8:	f001 f940 	bl	800213c <HAL_ADCEx_LevelOutOfWindow3Callback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD3);
 8000ebc:	6823      	ldr	r3, [r4, #0]
 8000ebe:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000ec2:	601a      	str	r2, [r3, #0]
 8000ec4:	e76d      	b.n	8000da2 <HAL_ADC_IRQHandler+0x116>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8000ec6:	6d63      	ldr	r3, [r4, #84]	; 0x54
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8000ec8:	4620      	mov	r0, r4
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8000eca:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000ece:	6563      	str	r3, [r4, #84]	; 0x54
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8000ed0:	f7ff fed8 	bl	8000c84 <HAL_ADC_LevelOutOfWindowCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD1);
 8000ed4:	6823      	ldr	r3, [r4, #0]
 8000ed6:	2280      	movs	r2, #128	; 0x80
 8000ed8:	601a      	str	r2, [r3, #0]
 8000eda:	e758      	b.n	8000d8e <HAL_ADC_IRQHandler+0x102>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
 8000edc:	6d63      	ldr	r3, [r4, #84]	; 0x54
    HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
 8000ede:	4620      	mov	r0, r4
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
 8000ee0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000ee4:	6563      	str	r3, [r4, #84]	; 0x54
    HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
 8000ee6:	f001 f927 	bl	8002138 <HAL_ADCEx_LevelOutOfWindow2Callback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD2);
 8000eea:	6823      	ldr	r3, [r4, #0]
 8000eec:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000ef0:	601a      	str	r2, [r3, #0]
 8000ef2:	e751      	b.n	8000d98 <HAL_ADC_IRQHandler+0x10c>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000ef4:	2f09      	cmp	r7, #9
 8000ef6:	d906      	bls.n	8000f06 <HAL_ADC_IRQHandler+0x27a>
        tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
 8000ef8:	4a06      	ldr	r2, [pc, #24]	; (8000f14 <HAL_ADC_IRQHandler+0x288>)
 8000efa:	68d2      	ldr	r2, [r2, #12]
 8000efc:	e701      	b.n	8000d02 <HAL_ADC_IRQHandler+0x76>
         ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
 8000efe:	0481      	lsls	r1, r0, #18
 8000f00:	f53f af3a 	bmi.w	8000d78 <HAL_ADC_IRQHandler+0xec>
 8000f04:	e7a9      	b.n	8000e5a <HAL_ADC_IRQHandler+0x1ce>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000f06:	f240 2221 	movw	r2, #545	; 0x221
 8000f0a:	40fa      	lsrs	r2, r7
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
 8000f0c:	07d2      	lsls	r2, r2, #31
 8000f0e:	f53f aef7 	bmi.w	8000d00 <HAL_ADC_IRQHandler+0x74>
 8000f12:	e7f1      	b.n	8000ef8 <HAL_ADC_IRQHandler+0x26c>
 8000f14:	40022000 	.word	0x40022000
 8000f18:	58026300 	.word	0x58026300
 8000f1c:	40022100 	.word	0x40022100
 8000f20:	58026000 	.word	0x58026000
 8000f24:	40022300 	.word	0x40022300
 8000f28:	08029080 	.word	0x08029080
      if ((hadc->Instance->CFGR & ADC_CFGR_DMNGT) != 0UL)
 8000f2c:	68da      	ldr	r2, [r3, #12]
 8000f2e:	0797      	lsls	r7, r2, #30
 8000f30:	f43f af79 	beq.w	8000e26 <HAL_ADC_IRQHandler+0x19a>
 8000f34:	e76b      	b.n	8000e0e <HAL_ADC_IRQHandler+0x182>
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000f36:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000f38:	f043 0310 	orr.w	r3, r3, #16
 8000f3c:	6563      	str	r3, [r4, #84]	; 0x54
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000f3e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000f40:	f043 0301 	orr.w	r3, r3, #1
 8000f44:	65a3      	str	r3, [r4, #88]	; 0x58
 8000f46:	e717      	b.n	8000d78 <HAL_ADC_IRQHandler+0xec>
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000f48:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000f4a:	f043 0310 	orr.w	r3, r3, #16
 8000f4e:	6563      	str	r3, [r4, #84]	; 0x54
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000f50:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000f52:	f043 0301 	orr.w	r3, r3, #1
 8000f56:	65a3      	str	r3, [r4, #88]	; 0x58
 8000f58:	e6eb      	b.n	8000d32 <HAL_ADC_IRQHandler+0xa6>
        if (LL_ADC_GetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DMA_EACH_ADC)
 8000f5a:	4a01      	ldr	r2, [pc, #4]	; (8000f60 <HAL_ADC_IRQHandler+0x2d4>)
 8000f5c:	e753      	b.n	8000e06 <HAL_ADC_IRQHandler+0x17a>
 8000f5e:	bf00      	nop
 8000f60:	40022300 	.word	0x40022300

08000f64 <ADC_DMAConvCplt>:
{
 8000f64:	b510      	push	{r4, lr}
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8000f66:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
 8000f68:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8000f6a:	f012 0f50 	tst.w	r2, #80	; 0x50
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8000f6e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
 8000f70:	d11d      	bne.n	8000fae <ADC_DMAConvCplt+0x4a>
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
 8000f72:	6819      	ldr	r1, [r3, #0]
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8000f74:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000f78:	655a      	str	r2, [r3, #84]	; 0x54
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
 8000f7a:	680a      	ldr	r2, [r1, #0]
 8000f7c:	f012 0f08 	tst.w	r2, #8
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8000f80:	68ca      	ldr	r2, [r1, #12]
 8000f82:	d01b      	beq.n	8000fbc <ADC_DMAConvCplt+0x58>
 8000f84:	f412 6f40 	tst.w	r2, #3072	; 0xc00
 8000f88:	d10d      	bne.n	8000fa6 <ADC_DMAConvCplt+0x42>
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_CONT) == 0UL)
 8000f8a:	68ca      	ldr	r2, [r1, #12]
 8000f8c:	0494      	lsls	r4, r2, #18
 8000f8e:	d40a      	bmi.n	8000fa6 <ADC_DMAConvCplt+0x42>
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8000f90:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8000f92:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8000f96:	655a      	str	r2, [r3, #84]	; 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8000f98:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8000f9a:	04d1      	lsls	r1, r2, #19
 8000f9c:	d403      	bmi.n	8000fa6 <ADC_DMAConvCplt+0x42>
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8000f9e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8000fa0:	f042 0201 	orr.w	r2, r2, #1
 8000fa4:	655a      	str	r2, [r3, #84]	; 0x54
    HAL_ADC_ConvCpltCallback(hadc);
 8000fa6:	4618      	mov	r0, r3
 8000fa8:	f012 fac6 	bl	8013538 <HAL_ADC_ConvCpltCallback>
}
 8000fac:	bd10      	pop	{r4, pc}
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
 8000fae:	06d2      	lsls	r2, r2, #27
 8000fb0:	d407      	bmi.n	8000fc2 <ADC_DMAConvCplt+0x5e>
      hadc->DMA_Handle->XferErrorCallback(hdma);
 8000fb2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
 8000fb4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      hadc->DMA_Handle->XferErrorCallback(hdma);
 8000fb8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fba:	4718      	bx	r3
      if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMNGT) == 0UL)
 8000fbc:	0790      	lsls	r0, r2, #30
 8000fbe:	d1f2      	bne.n	8000fa6 <ADC_DMAConvCplt+0x42>
 8000fc0:	e7e6      	b.n	8000f90 <ADC_DMAConvCplt+0x2c>
      HAL_ADC_ErrorCallback(hadc);
 8000fc2:	4618      	mov	r0, r3
 8000fc4:	f7ff fe60 	bl	8000c88 <HAL_ADC_ErrorCallback>
}
 8000fc8:	bd10      	pop	{r4, pc}
 8000fca:	bf00      	nop

08000fcc <ADC_DMAError>:
  * @brief  DMA error callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAError(DMA_HandleTypeDef *hdma)
{
 8000fcc:	b508      	push	{r3, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8000fce:	6b83      	ldr	r3, [r0, #56]	; 0x38

  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8000fd0:	6d5a      	ldr	r2, [r3, #84]	; 0x54

  /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
 8000fd2:	4618      	mov	r0, r3
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8000fd4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000fd8:	655a      	str	r2, [r3, #84]	; 0x54
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 8000fda:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000fdc:	f042 0204 	orr.w	r2, r2, #4
 8000fe0:	659a      	str	r2, [r3, #88]	; 0x58
  HAL_ADC_ErrorCallback(hadc);
 8000fe2:	f7ff fe51 	bl	8000c88 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8000fe6:	bd08      	pop	{r3, pc}

08000fe8 <HAL_ADC_ConfigChannel>:
{
 8000fe8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000fea:	4605      	mov	r5, r0
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000fec:	4ab3      	ldr	r2, [pc, #716]	; (80012bc <HAL_ADC_ConfigChannel+0x2d4>)
 8000fee:	48b4      	ldr	r0, [pc, #720]	; (80012c0 <HAL_ADC_ConfigChannel+0x2d8>)
{
 8000ff0:	b083      	sub	sp, #12
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000ff2:	682b      	ldr	r3, [r5, #0]
  __IO uint32_t wait_loop_index = 0;
 8000ff4:	2600      	movs	r6, #0
{
 8000ff6:	460c      	mov	r4, r1
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000ff8:	4283      	cmp	r3, r0
 8000ffa:	bf18      	it	ne
 8000ffc:	4293      	cmpne	r3, r2
  __IO uint32_t wait_loop_index = 0;
 8000ffe:	9601      	str	r6, [sp, #4]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8001000:	d003      	beq.n	800100a <HAL_ADC_ConfigChannel+0x22>
 8001002:	4ab0      	ldr	r2, [pc, #704]	; (80012c4 <HAL_ADC_ConfigChannel+0x2dc>)
 8001004:	4293      	cmp	r3, r2
 8001006:	f040 8153 	bne.w	80012b0 <HAL_ADC_ConfigChannel+0x2c8>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
 800100a:	6862      	ldr	r2, [r4, #4]
 800100c:	f422 7340 	bic.w	r3, r2, #768	; 0x300
 8001010:	f422 7180 	bic.w	r1, r2, #256	; 0x100
 8001014:	1f98      	subs	r0, r3, #6
 8001016:	bf18      	it	ne
 8001018:	2001      	movne	r0, #1
 800101a:	2918      	cmp	r1, #24
 800101c:	f240 8119 	bls.w	8001252 <HAL_ADC_ConfigChannel+0x26a>
 8001020:	2301      	movs	r3, #1
 8001022:	f422 7600 	bic.w	r6, r2, #512	; 0x200
 8001026:	f5a2 7100 	sub.w	r1, r2, #512	; 0x200
 800102a:	f5b6 7680 	subs.w	r6, r6, #256	; 0x100
 800102e:	bf18      	it	ne
 8001030:	2601      	movne	r6, #1
 8001032:	2918      	cmp	r1, #24
 8001034:	f240 8107 	bls.w	8001246 <HAL_ADC_ConfigChannel+0x25e>
 8001038:	2201      	movs	r2, #1
 800103a:	4003      	ands	r3, r0
 800103c:	421e      	tst	r6, r3
 800103e:	d002      	beq.n	8001046 <HAL_ADC_ConfigChannel+0x5e>
 8001040:	2a00      	cmp	r2, #0
 8001042:	f040 8404 	bne.w	800184e <HAL_ADC_ConfigChannel+0x866>
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
 8001046:	68a3      	ldr	r3, [r4, #8]
 8001048:	2b07      	cmp	r3, #7
 800104a:	f200 8256 	bhi.w	80014fa <HAL_ADC_ConfigChannel+0x512>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
 800104e:	68e3      	ldr	r3, [r4, #12]
 8001050:	f240 72ff 	movw	r2, #2047	; 0x7ff
 8001054:	4293      	cmp	r3, r2
 8001056:	d003      	beq.n	8001060 <HAL_ADC_ConfigChannel+0x78>
 8001058:	4a9b      	ldr	r2, [pc, #620]	; (80012c8 <HAL_ADC_ConfigChannel+0x2e0>)
 800105a:	4293      	cmp	r3, r2
 800105c:	f040 8111 	bne.w	8001282 <HAL_ADC_ConfigChannel+0x29a>
  assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
 8001060:	6923      	ldr	r3, [r4, #16]
 8001062:	2b04      	cmp	r3, #4
 8001064:	f200 8116 	bhi.w	8001294 <HAL_ADC_ConfigChannel+0x2ac>
  if (hadc->Init.OversamplingMode == ENABLE)
 8001068:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
 800106c:	6961      	ldr	r1, [r4, #20]
 800106e:	2b01      	cmp	r3, #1
 8001070:	682a      	ldr	r2, [r5, #0]
  if((DBGMCU->IDCODE & 0x30000000UL) == 0x10000000UL) /* Rev.Y */
 8001072:	4b96      	ldr	r3, [pc, #600]	; (80012cc <HAL_ADC_ConfigChannel+0x2e4>)
 8001074:	f000 8223 	beq.w	80014be <HAL_ADC_ConfigChannel+0x4d6>
 8001078:	681b      	ldr	r3, [r3, #0]
 800107a:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 800107e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8001082:	f040 810d 	bne.w	80012a0 <HAL_ADC_ConfigChannel+0x2b8>
      return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
 8001086:	68d2      	ldr	r2, [r2, #12]
 8001088:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800108c:	0852      	lsrs	r2, r2, #1
 800108e:	f002 020e 	and.w	r2, r2, #14
 8001092:	40d3      	lsrs	r3, r2
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
 8001094:	4299      	cmp	r1, r3
 8001096:	f200 813f 	bhi.w	8001318 <HAL_ADC_ConfigChannel+0x330>
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
 800109a:	4b8b      	ldr	r3, [pc, #556]	; (80012c8 <HAL_ADC_ConfigChannel+0x2e0>)
 800109c:	68e2      	ldr	r2, [r4, #12]
 800109e:	429a      	cmp	r2, r3
 80010a0:	f000 8152 	beq.w	8001348 <HAL_ADC_ConfigChannel+0x360>
    assert_param(IS_ADC_CHANNEL(sConfig->Channel));
 80010a4:	6821      	ldr	r1, [r4, #0]
 80010a6:	4b8a      	ldr	r3, [pc, #552]	; (80012d0 <HAL_ADC_ConfigChannel+0x2e8>)
 80010a8:	4e8a      	ldr	r6, [pc, #552]	; (80012d4 <HAL_ADC_ConfigChannel+0x2ec>)
 80010aa:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 80010ae:	2901      	cmp	r1, #1
 80010b0:	bf18      	it	ne
 80010b2:	4299      	cmpne	r1, r3
 80010b4:	4888      	ldr	r0, [pc, #544]	; (80012d8 <HAL_ADC_ConfigChannel+0x2f0>)
 80010b6:	bf14      	ite	ne
 80010b8:	2301      	movne	r3, #1
 80010ba:	2300      	moveq	r3, #0
 80010bc:	42b1      	cmp	r1, r6
 80010be:	bf0c      	ite	eq
 80010c0:	2300      	moveq	r3, #0
 80010c2:	f003 0301 	andne.w	r3, r3, #1
 80010c6:	4e85      	ldr	r6, [pc, #532]	; (80012dc <HAL_ADC_ConfigChannel+0x2f4>)
 80010c8:	4281      	cmp	r1, r0
 80010ca:	bf0c      	ite	eq
 80010cc:	2300      	moveq	r3, #0
 80010ce:	f003 0301 	andne.w	r3, r3, #1
 80010d2:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
 80010d6:	42b1      	cmp	r1, r6
 80010d8:	bf0c      	ite	eq
 80010da:	2300      	moveq	r3, #0
 80010dc:	f003 0301 	andne.w	r3, r3, #1
 80010e0:	3018      	adds	r0, #24
 80010e2:	4e7f      	ldr	r6, [pc, #508]	; (80012e0 <HAL_ADC_ConfigChannel+0x2f8>)
 80010e4:	4281      	cmp	r1, r0
 80010e6:	bf0c      	ite	eq
 80010e8:	2300      	moveq	r3, #0
 80010ea:	f003 0301 	andne.w	r3, r3, #1
 80010ee:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
 80010f2:	42b1      	cmp	r1, r6
 80010f4:	bf0c      	ite	eq
 80010f6:	2300      	moveq	r3, #0
 80010f8:	f003 0301 	andne.w	r3, r3, #1
 80010fc:	3060      	adds	r0, #96	; 0x60
 80010fe:	4e79      	ldr	r6, [pc, #484]	; (80012e4 <HAL_ADC_ConfigChannel+0x2fc>)
 8001100:	4281      	cmp	r1, r0
 8001102:	bf0c      	ite	eq
 8001104:	2300      	moveq	r3, #0
 8001106:	f003 0301 	andne.w	r3, r3, #1
 800110a:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
 800110e:	42b1      	cmp	r1, r6
 8001110:	bf0c      	ite	eq
 8001112:	2300      	moveq	r3, #0
 8001114:	f003 0301 	andne.w	r3, r3, #1
 8001118:	f500 70c0 	add.w	r0, r0, #384	; 0x180
 800111c:	4e72      	ldr	r6, [pc, #456]	; (80012e8 <HAL_ADC_ConfigChannel+0x300>)
 800111e:	4281      	cmp	r1, r0
 8001120:	bf0c      	ite	eq
 8001122:	2300      	moveq	r3, #0
 8001124:	f003 0301 	andne.w	r3, r3, #1
 8001128:	f100 6008 	add.w	r0, r0, #142606336	; 0x8800000
 800112c:	42b1      	cmp	r1, r6
 800112e:	bf0c      	ite	eq
 8001130:	2300      	moveq	r3, #0
 8001132:	f003 0301 	andne.w	r3, r3, #1
 8001136:	f500 60c0 	add.w	r0, r0, #1536	; 0x600
 800113a:	f106 6606 	add.w	r6, r6, #140509184	; 0x8600000
 800113e:	4281      	cmp	r1, r0
 8001140:	bf0c      	ite	eq
 8001142:	2300      	moveq	r3, #0
 8001144:	f003 0301 	andne.w	r3, r3, #1
 8001148:	4868      	ldr	r0, [pc, #416]	; (80012ec <HAL_ADC_ConfigChannel+0x304>)
 800114a:	f506 6640 	add.w	r6, r6, #3072	; 0xc00
 800114e:	42b1      	cmp	r1, r6
 8001150:	bf0c      	ite	eq
 8001152:	2300      	moveq	r3, #0
 8001154:	f003 0301 	andne.w	r3, r3, #1
 8001158:	4e65      	ldr	r6, [pc, #404]	; (80012f0 <HAL_ADC_ConfigChannel+0x308>)
 800115a:	4281      	cmp	r1, r0
 800115c:	bf0c      	ite	eq
 800115e:	2300      	moveq	r3, #0
 8001160:	f003 0301 	andne.w	r3, r3, #1
 8001164:	4863      	ldr	r0, [pc, #396]	; (80012f4 <HAL_ADC_ConfigChannel+0x30c>)
 8001166:	42b1      	cmp	r1, r6
 8001168:	bf0c      	ite	eq
 800116a:	2300      	moveq	r3, #0
 800116c:	f003 0301 	andne.w	r3, r3, #1
 8001170:	4e61      	ldr	r6, [pc, #388]	; (80012f8 <HAL_ADC_ConfigChannel+0x310>)
 8001172:	4281      	cmp	r1, r0
 8001174:	bf0c      	ite	eq
 8001176:	2300      	moveq	r3, #0
 8001178:	f003 0301 	andne.w	r3, r3, #1
 800117c:	485f      	ldr	r0, [pc, #380]	; (80012fc <HAL_ADC_ConfigChannel+0x314>)
 800117e:	4960      	ldr	r1, [pc, #384]	; (8001300 <HAL_ADC_ConfigChannel+0x318>)
 8001180:	42b2      	cmp	r2, r6
 8001182:	bf0c      	ite	eq
 8001184:	2300      	moveq	r3, #0
 8001186:	f003 0301 	andne.w	r3, r3, #1
 800118a:	4282      	cmp	r2, r0
 800118c:	bf0c      	ite	eq
 800118e:	2300      	moveq	r3, #0
 8001190:	f003 0301 	andne.w	r3, r3, #1
 8001194:	428a      	cmp	r2, r1
 8001196:	bf0c      	ite	eq
 8001198:	2300      	moveq	r3, #0
 800119a:	f003 0301 	andne.w	r3, r3, #1
 800119e:	2b00      	cmp	r3, #0
 80011a0:	d166      	bne.n	8001270 <HAL_ADC_ConfigChannel+0x288>
  __HAL_LOCK(hadc);
 80011a2:	f895 3050 	ldrb.w	r3, [r5, #80]	; 0x50
 80011a6:	2b01      	cmp	r3, #1
 80011a8:	f000 82a2 	beq.w	80016f0 <HAL_ADC_ConfigChannel+0x708>
 80011ac:	2001      	movs	r0, #1
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 80011ae:	682a      	ldr	r2, [r5, #0]
  __HAL_LOCK(hadc);
 80011b0:	f885 0050 	strb.w	r0, [r5, #80]	; 0x50
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80011b4:	6893      	ldr	r3, [r2, #8]
 80011b6:	075b      	lsls	r3, r3, #29
 80011b8:	d451      	bmi.n	800125e <HAL_ADC_ConfigChannel+0x276>
    hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
 80011ba:	6823      	ldr	r3, [r4, #0]
 80011bc:	f3c3 0113 	ubfx	r1, r3, #0, #20
 80011c0:	2900      	cmp	r1, #0
 80011c2:	f040 81a2 	bne.w	800150a <HAL_ADC_ConfigChannel+0x522>
 80011c6:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80011ca:	4098      	lsls	r0, r3
 80011cc:	69d3      	ldr	r3, [r2, #28]
  MODIFY_REG(*preg,
 80011ce:	271f      	movs	r7, #31
 80011d0:	4318      	orrs	r0, r3
 80011d2:	61d0      	str	r0, [r2, #28]
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 80011d4:	6862      	ldr	r2, [r4, #4]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 80011d6:	6829      	ldr	r1, [r5, #0]
 80011d8:	0990      	lsrs	r0, r2, #6
  MODIFY_REG(*preg,
 80011da:	6823      	ldr	r3, [r4, #0]
 80011dc:	403a      	ands	r2, r7
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 80011de:	3130      	adds	r1, #48	; 0x30
 80011e0:	f000 000c 	and.w	r0, r0, #12
  MODIFY_REG(*preg,
 80011e4:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80011e8:	4097      	lsls	r7, r2
 80011ea:	5846      	ldr	r6, [r0, r1]
 80011ec:	4093      	lsls	r3, r2
 80011ee:	ea26 0207 	bic.w	r2, r6, r7
 80011f2:	4313      	orrs	r3, r2
 80011f4:	5043      	str	r3, [r0, r1]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 80011f6:	682b      	ldr	r3, [r5, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80011f8:	689a      	ldr	r2, [r3, #8]
 80011fa:	0757      	lsls	r7, r2, #29
 80011fc:	f100 8183 	bmi.w	8001506 <HAL_ADC_ConfigChannel+0x51e>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8001200:	689e      	ldr	r6, [r3, #8]
 8001202:	f016 0608 	ands.w	r6, r6, #8
 8001206:	f000 80f1 	beq.w	80013ec <HAL_ADC_ConfigChannel+0x404>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800120a:	689a      	ldr	r2, [r3, #8]
 800120c:	07d6      	lsls	r6, r2, #31
 800120e:	d418      	bmi.n	8001242 <HAL_ADC_ConfigChannel+0x25a>
  MODIFY_REG(ADCx->DIFSEL,
 8001210:	68e1      	ldr	r1, [r4, #12]
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 8001212:	6826      	ldr	r6, [r4, #0]
 8001214:	f001 0018 	and.w	r0, r1, #24
 8001218:	4a3a      	ldr	r2, [pc, #232]	; (8001304 <HAL_ADC_ConfigChannel+0x31c>)
 800121a:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
 800121e:	40c2      	lsrs	r2, r0
 8001220:	f3c6 0013 	ubfx	r0, r6, #0, #20
 8001224:	4032      	ands	r2, r6
 8001226:	ea21 0100 	bic.w	r1, r1, r0
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 800122a:	4827      	ldr	r0, [pc, #156]	; (80012c8 <HAL_ADC_ConfigChannel+0x2e0>)
 800122c:	430a      	orrs	r2, r1
 800122e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
 8001232:	68e3      	ldr	r3, [r4, #12]
 8001234:	4283      	cmp	r3, r0
 8001236:	f000 821c 	beq.w	8001672 <HAL_ADC_ConfigChannel+0x68a>
      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 800123a:	6822      	ldr	r2, [r4, #0]
 800123c:	2a00      	cmp	r2, #0
 800123e:	f2c0 81b6 	blt.w	80015ae <HAL_ADC_ConfigChannel+0x5c6>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8001242:	2000      	movs	r0, #0
 8001244:	e00f      	b.n	8001266 <HAL_ADC_ConfigChannel+0x27e>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
 8001246:	4a30      	ldr	r2, [pc, #192]	; (8001308 <HAL_ADC_ConfigChannel+0x320>)
 8001248:	40ca      	lsrs	r2, r1
 800124a:	43d2      	mvns	r2, r2
 800124c:	f002 0201 	and.w	r2, r2, #1
 8001250:	e6f3      	b.n	800103a <HAL_ADC_ConfigChannel+0x52>
 8001252:	4b2e      	ldr	r3, [pc, #184]	; (800130c <HAL_ADC_ConfigChannel+0x324>)
 8001254:	40cb      	lsrs	r3, r1
 8001256:	43db      	mvns	r3, r3
 8001258:	f003 0301 	and.w	r3, r3, #1
 800125c:	e6e1      	b.n	8001022 <HAL_ADC_ConfigChannel+0x3a>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800125e:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8001260:	f043 0320 	orr.w	r3, r3, #32
 8001264:	656b      	str	r3, [r5, #84]	; 0x54
  __HAL_UNLOCK(hadc);
 8001266:	2300      	movs	r3, #0
 8001268:	f885 3050 	strb.w	r3, [r5, #80]	; 0x50
}
 800126c:	b003      	add	sp, #12
 800126e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_CHANNEL(sConfig->Channel));
 8001270:	4b27      	ldr	r3, [pc, #156]	; (8001310 <HAL_ADC_ConfigChannel+0x328>)
 8001272:	429a      	cmp	r2, r3
 8001274:	d095      	beq.n	80011a2 <HAL_ADC_ConfigChannel+0x1ba>
 8001276:	f640 2174 	movw	r1, #2676	; 0xa74
 800127a:	4826      	ldr	r0, [pc, #152]	; (8001314 <HAL_ADC_ConfigChannel+0x32c>)
 800127c:	f012 fb28 	bl	80138d0 <assert_failed>
 8001280:	e78f      	b.n	80011a2 <HAL_ADC_ConfigChannel+0x1ba>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
 8001282:	f640 2161 	movw	r1, #2657	; 0xa61
 8001286:	4823      	ldr	r0, [pc, #140]	; (8001314 <HAL_ADC_ConfigChannel+0x32c>)
 8001288:	f012 fb22 	bl	80138d0 <assert_failed>
  assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
 800128c:	6923      	ldr	r3, [r4, #16]
 800128e:	2b04      	cmp	r3, #4
 8001290:	f67f aeea 	bls.w	8001068 <HAL_ADC_ConfigChannel+0x80>
 8001294:	f640 2162 	movw	r1, #2658	; 0xa62
 8001298:	481e      	ldr	r0, [pc, #120]	; (8001314 <HAL_ADC_ConfigChannel+0x32c>)
 800129a:	f012 fb19 	bl	80138d0 <assert_failed>
 800129e:	e6e3      	b.n	8001068 <HAL_ADC_ConfigChannel+0x80>
    if ((uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES)) == 0x0000001CUL)
 80012a0:	68d3      	ldr	r3, [r2, #12]
 80012a2:	f003 031c 	and.w	r3, r3, #28
 80012a6:	2b1c      	cmp	r3, #28
 80012a8:	f47f aeed 	bne.w	8001086 <HAL_ADC_ConfigChannel+0x9e>
 80012ac:	23ff      	movs	r3, #255	; 0xff
 80012ae:	e6f1      	b.n	8001094 <HAL_ADC_ConfigChannel+0xac>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80012b0:	f640 215e 	movw	r1, #2654	; 0xa5e
 80012b4:	4817      	ldr	r0, [pc, #92]	; (8001314 <HAL_ADC_ConfigChannel+0x32c>)
 80012b6:	f012 fb0b 	bl	80138d0 <assert_failed>
 80012ba:	e6a6      	b.n	800100a <HAL_ADC_ConfigChannel+0x22>
 80012bc:	40022100 	.word	0x40022100
 80012c0:	40022000 	.word	0x40022000
 80012c4:	58026000 	.word	0x58026000
 80012c8:	47ff0000 	.word	0x47ff0000
 80012cc:	5c001000 	.word	0x5c001000
 80012d0:	04300002 	.word	0x04300002
 80012d4:	08600004 	.word	0x08600004
 80012d8:	0c900008 	.word	0x0c900008
 80012dc:	10c00010 	.word	0x10c00010
 80012e0:	19200040 	.word	0x19200040
 80012e4:	21800100 	.word	0x21800100
 80012e8:	2a000400 	.word	0x2a000400
 80012ec:	36902000 	.word	0x36902000
 80012f0:	3ac04000 	.word	0x3ac04000
 80012f4:	3ef08000 	.word	0x3ef08000
 80012f8:	43210000 	.word	0x43210000
 80012fc:	47520000 	.word	0x47520000
 8001300:	4b840000 	.word	0x4b840000
 8001304:	000fffff 	.word	0x000fffff
 8001308:	01041001 	.word	0x01041001
 800130c:	01041000 	.word	0x01041000
 8001310:	4fb80000 	.word	0x4fb80000
 8001314:	08029080 	.word	0x08029080
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
 8001318:	f640 216a 	movw	r1, #2666	; 0xa6a
 800131c:	48bd      	ldr	r0, [pc, #756]	; (8001614 <HAL_ADC_ConfigChannel+0x62c>)
 800131e:	f012 fad7 	bl	80138d0 <assert_failed>
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
 8001322:	6923      	ldr	r3, [r4, #16]
 8001324:	2b04      	cmp	r3, #4
 8001326:	f43f aeb8 	beq.w	800109a <HAL_ADC_ConfigChannel+0xb2>
 800132a:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
 800132e:	2b01      	cmp	r3, #1
 8001330:	f47f aeb3 	bne.w	800109a <HAL_ADC_ConfigChannel+0xb2>
 8001334:	f640 216f 	movw	r1, #2671	; 0xa6f
 8001338:	48b6      	ldr	r0, [pc, #728]	; (8001614 <HAL_ADC_ConfigChannel+0x62c>)
 800133a:	f012 fac9 	bl	80138d0 <assert_failed>
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
 800133e:	4bb6      	ldr	r3, [pc, #728]	; (8001618 <HAL_ADC_ConfigChannel+0x630>)
 8001340:	68e2      	ldr	r2, [r4, #12]
 8001342:	429a      	cmp	r2, r3
 8001344:	f47f aeae 	bne.w	80010a4 <HAL_ADC_ConfigChannel+0xbc>
    if (hadc->Instance == ADC1)
 8001348:	682b      	ldr	r3, [r5, #0]
 800134a:	4ab4      	ldr	r2, [pc, #720]	; (800161c <HAL_ADC_ConfigChannel+0x634>)
 800134c:	4293      	cmp	r3, r2
 800134e:	f000 81d8 	beq.w	8001702 <HAL_ADC_ConfigChannel+0x71a>
    if (hadc->Instance == ADC2)
 8001352:	4ab3      	ldr	r2, [pc, #716]	; (8001620 <HAL_ADC_ConfigChannel+0x638>)
 8001354:	4293      	cmp	r3, r2
 8001356:	f000 80e7 	beq.w	8001528 <HAL_ADC_ConfigChannel+0x540>
    if (hadc->Instance == ADC3)
 800135a:	4ab2      	ldr	r2, [pc, #712]	; (8001624 <HAL_ADC_ConfigChannel+0x63c>)
 800135c:	4293      	cmp	r3, r2
 800135e:	f47f af20 	bne.w	80011a2 <HAL_ADC_ConfigChannel+0x1ba>
      assert_param(IS_ADC3_DIFF_CHANNEL(sConfig->Channel));
 8001362:	6822      	ldr	r2, [r4, #0]
 8001364:	4bb0      	ldr	r3, [pc, #704]	; (8001628 <HAL_ADC_ConfigChannel+0x640>)
 8001366:	48b1      	ldr	r0, [pc, #708]	; (800162c <HAL_ADC_ConfigChannel+0x644>)
 8001368:	49b1      	ldr	r1, [pc, #708]	; (8001630 <HAL_ADC_ConfigChannel+0x648>)
 800136a:	429a      	cmp	r2, r3
 800136c:	bf18      	it	ne
 800136e:	4282      	cmpne	r2, r0
 8001370:	48b0      	ldr	r0, [pc, #704]	; (8001634 <HAL_ADC_ConfigChannel+0x64c>)
 8001372:	bf14      	ite	ne
 8001374:	2301      	movne	r3, #1
 8001376:	2300      	moveq	r3, #0
 8001378:	428a      	cmp	r2, r1
 800137a:	bf0c      	ite	eq
 800137c:	2300      	moveq	r3, #0
 800137e:	f003 0301 	andne.w	r3, r3, #1
 8001382:	f101 6106 	add.w	r1, r1, #140509184	; 0x8600000
 8001386:	4282      	cmp	r2, r0
 8001388:	bf0c      	ite	eq
 800138a:	2300      	moveq	r3, #0
 800138c:	f003 0301 	andne.w	r3, r3, #1
 8001390:	3118      	adds	r1, #24
 8001392:	48a9      	ldr	r0, [pc, #676]	; (8001638 <HAL_ADC_ConfigChannel+0x650>)
 8001394:	428a      	cmp	r2, r1
 8001396:	bf0c      	ite	eq
 8001398:	2300      	moveq	r3, #0
 800139a:	f003 0301 	andne.w	r3, r3, #1
 800139e:	f101 51ca 	add.w	r1, r1, #423624704	; 0x19400000
 80013a2:	4282      	cmp	r2, r0
 80013a4:	bf0c      	ite	eq
 80013a6:	2300      	moveq	r3, #0
 80013a8:	f003 0301 	andne.w	r3, r3, #1
 80013ac:	f501 61fc 	add.w	r1, r1, #2016	; 0x7e0
 80013b0:	48a2      	ldr	r0, [pc, #648]	; (800163c <HAL_ADC_ConfigChannel+0x654>)
 80013b2:	428a      	cmp	r2, r1
 80013b4:	bf0c      	ite	eq
 80013b6:	2300      	moveq	r3, #0
 80013b8:	f003 0301 	andne.w	r3, r3, #1
 80013bc:	49a0      	ldr	r1, [pc, #640]	; (8001640 <HAL_ADC_ConfigChannel+0x658>)
 80013be:	4282      	cmp	r2, r0
 80013c0:	bf0c      	ite	eq
 80013c2:	2300      	moveq	r3, #0
 80013c4:	f003 0301 	andne.w	r3, r3, #1
 80013c8:	428a      	cmp	r2, r1
 80013ca:	bf0c      	ite	eq
 80013cc:	2300      	moveq	r3, #0
 80013ce:	f003 0301 	andne.w	r3, r3, #1
 80013d2:	2b00      	cmp	r3, #0
 80013d4:	f43f aee5 	beq.w	80011a2 <HAL_ADC_ConfigChannel+0x1ba>
 80013d8:	4b9a      	ldr	r3, [pc, #616]	; (8001644 <HAL_ADC_ConfigChannel+0x65c>)
 80013da:	429a      	cmp	r2, r3
 80013dc:	f43f aee1 	beq.w	80011a2 <HAL_ADC_ConfigChannel+0x1ba>
 80013e0:	f640 2184 	movw	r1, #2692	; 0xa84
 80013e4:	488b      	ldr	r0, [pc, #556]	; (8001614 <HAL_ADC_ConfigChannel+0x62c>)
 80013e6:	f012 fa73 	bl	80138d0 <assert_failed>
 80013ea:	e6da      	b.n	80011a2 <HAL_ADC_ConfigChannel+0x1ba>
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 80013ec:	6821      	ldr	r1, [r4, #0]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80013ee:	3314      	adds	r3, #20
  MODIFY_REG(*preg,
 80013f0:	2207      	movs	r2, #7
 80013f2:	68a7      	ldr	r7, [r4, #8]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80013f4:	0dc8      	lsrs	r0, r1, #23
  MODIFY_REG(*preg,
 80013f6:	f3c1 5104 	ubfx	r1, r1, #20, #5
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80013fa:	f000 0004 	and.w	r0, r0, #4
  MODIFY_REG(*preg,
 80013fe:	fa02 fc01 	lsl.w	ip, r2, r1
 8001402:	fa07 f101 	lsl.w	r1, r7, r1
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 8001406:	4f90      	ldr	r7, [pc, #576]	; (8001648 <HAL_ADC_ConfigChannel+0x660>)
 8001408:	58c2      	ldr	r2, [r0, r3]
 800140a:	ea22 020c 	bic.w	r2, r2, ip
 800140e:	430a      	orrs	r2, r1
 8001410:	50c2      	str	r2, [r0, r3]
 8001412:	683b      	ldr	r3, [r7, #0]
 8001414:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8001418:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800141c:	f000 8120 	beq.w	8001660 <HAL_ADC_ConfigChannel+0x678>
 8001420:	682b      	ldr	r3, [r5, #0]
 8001422:	6962      	ldr	r2, [r4, #20]
 8001424:	68d9      	ldr	r1, [r3, #12]
 8001426:	f011 0f10 	tst.w	r1, #16
 800142a:	68d9      	ldr	r1, [r3, #12]
 800142c:	f040 81ce 	bne.w	80017cc <HAL_ADC_ConfigChannel+0x7e4>
 8001430:	f3c1 0182 	ubfx	r1, r1, #2, #3
 8001434:	0049      	lsls	r1, r1, #1
 8001436:	fa02 f101 	lsl.w	r1, r2, r1
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 800143a:	6920      	ldr	r0, [r4, #16]
 800143c:	6822      	ldr	r2, [r4, #0]
 800143e:	2804      	cmp	r0, #4
 8001440:	f000 81a8 	beq.w	8001794 <HAL_ADC_ConfigChannel+0x7ac>
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8001444:	3360      	adds	r3, #96	; 0x60
  MODIFY_REG(*preg,
 8001446:	f002 42f8 	and.w	r2, r2, #2080374784	; 0x7c000000
 800144a:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
 800144e:	430a      	orrs	r2, r1
 8001450:	f007 4100 	and.w	r1, r7, #2147483648	; 0x80000000
 8001454:	430a      	orrs	r2, r1
 8001456:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetSignedSaturation));
 800145a:	7e63      	ldrb	r3, [r4, #25]
 800145c:	2b01      	cmp	r3, #1
 800145e:	d905      	bls.n	800146c <HAL_ADC_ConfigChannel+0x484>
 8001460:	f640 21b2 	movw	r1, #2738	; 0xab2
 8001464:	486b      	ldr	r0, [pc, #428]	; (8001614 <HAL_ADC_ConfigChannel+0x62c>)
 8001466:	f012 fa33 	bl	80138d0 <assert_failed>
 800146a:	7e63      	ldrb	r3, [r4, #25]
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSignedSaturation == ENABLE) ? LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE : LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
 800146c:	682a      	ldr	r2, [r5, #0]
 800146e:	2b01      	cmp	r3, #1
 8001470:	6921      	ldr	r1, [r4, #16]
   register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8001472:	f102 0260 	add.w	r2, r2, #96	; 0x60
 8001476:	bf14      	ite	ne
 8001478:	2000      	movne	r0, #0
 800147a:	f04f 4000 	moveq.w	r0, #2147483648	; 0x80000000
   MODIFY_REG(*preg, ADC_OFR1_SSATE, OffsetSignedSaturation);
 800147e:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8001482:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8001486:	4303      	orrs	r3, r0
 8001488:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetRightShift));
 800148c:	7e23      	ldrb	r3, [r4, #24]
 800148e:	2b01      	cmp	r3, #1
 8001490:	d905      	bls.n	800149e <HAL_ADC_ConfigChannel+0x4b6>
 8001492:	f640 21b6 	movw	r1, #2742	; 0xab6
 8001496:	485f      	ldr	r0, [pc, #380]	; (8001614 <HAL_ADC_ConfigChannel+0x62c>)
 8001498:	f012 fa1a 	bl	80138d0 <assert_failed>
 800149c:	7e23      	ldrb	r3, [r4, #24]
        LL_ADC_SetDataRightShift(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetRightShift == ENABLE) ? LL_ADC_OFFSET_RSHIFT_ENABLE : LL_ADC_OFFSET_RSHIFT_DISABLE);
 800149e:	2b01      	cmp	r3, #1
 80014a0:	682a      	ldr	r2, [r5, #0]
 80014a2:	6921      	ldr	r1, [r4, #16]
 80014a4:	d104      	bne.n	80014b0 <HAL_ADC_ConfigChannel+0x4c8>
 80014a6:	f001 011f 	and.w	r1, r1, #31
 80014aa:	f44f 6600 	mov.w	r6, #2048	; 0x800
 80014ae:	408e      	lsls	r6, r1
  MODIFY_REG(ADCx->CFGR2, (ADC_CFGR2_RSHIFT1 | ADC_CFGR2_RSHIFT2 | ADC_CFGR2_RSHIFT3 | ADC_CFGR2_RSHIFT4), RigthShift << (Offsety & 0x1FUL));
 80014b0:	6913      	ldr	r3, [r2, #16]
 80014b2:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 80014b6:	431e      	orrs	r6, r3
 80014b8:	6116      	str	r6, [r2, #16]
 80014ba:	682b      	ldr	r3, [r5, #0]
 80014bc:	e6a5      	b.n	800120a <HAL_ADC_ConfigChannel+0x222>
  if((DBGMCU->IDCODE & 0x30000000UL) == 0x10000000UL) /* Rev.Y */
 80014be:	681b      	ldr	r3, [r3, #0]
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset/(hadc->Init.Oversampling.Ratio+1U)));
 80014c0:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 80014c2:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 80014c6:	3001      	adds	r0, #1
 80014c8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80014cc:	fbb1 f1f0 	udiv	r1, r1, r0
 80014d0:	d123      	bne.n	800151a <HAL_ADC_ConfigChannel+0x532>
      return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
 80014d2:	68d2      	ldr	r2, [r2, #12]
 80014d4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80014d8:	0852      	lsrs	r2, r2, #1
 80014da:	f002 020e 	and.w	r2, r2, #14
 80014de:	40d3      	lsrs	r3, r2
 80014e0:	4299      	cmp	r1, r3
 80014e2:	f200 8108 	bhi.w	80016f6 <HAL_ADC_ConfigChannel+0x70e>
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
 80014e6:	6923      	ldr	r3, [r4, #16]
 80014e8:	2b04      	cmp	r3, #4
 80014ea:	f43f add6 	beq.w	800109a <HAL_ADC_ConfigChannel+0xb2>
 80014ee:	f640 216f 	movw	r1, #2671	; 0xa6f
 80014f2:	4848      	ldr	r0, [pc, #288]	; (8001614 <HAL_ADC_ConfigChannel+0x62c>)
 80014f4:	f012 f9ec 	bl	80138d0 <assert_failed>
 80014f8:	e721      	b.n	800133e <HAL_ADC_ConfigChannel+0x356>
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
 80014fa:	f44f 6126 	mov.w	r1, #2656	; 0xa60
 80014fe:	4845      	ldr	r0, [pc, #276]	; (8001614 <HAL_ADC_ConfigChannel+0x62c>)
 8001500:	f012 f9e6 	bl	80138d0 <assert_failed>
 8001504:	e5a3      	b.n	800104e <HAL_ADC_ConfigChannel+0x66>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8001506:	689a      	ldr	r2, [r3, #8]
 8001508:	e67f      	b.n	800120a <HAL_ADC_ConfigChannel+0x222>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800150a:	fa93 f3a3 	rbit	r3, r3
    hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
 800150e:	fab3 f383 	clz	r3, r3
 8001512:	f003 031f 	and.w	r3, r3, #31
 8001516:	4098      	lsls	r0, r3
 8001518:	e658      	b.n	80011cc <HAL_ADC_ConfigChannel+0x1e4>
    if ((uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES)) == 0x0000001CUL)
 800151a:	68d3      	ldr	r3, [r2, #12]
 800151c:	f003 031c 	and.w	r3, r3, #28
 8001520:	2b1c      	cmp	r3, #28
 8001522:	d1d6      	bne.n	80014d2 <HAL_ADC_ConfigChannel+0x4ea>
 8001524:	23ff      	movs	r3, #255	; 0xff
 8001526:	e7db      	b.n	80014e0 <HAL_ADC_ConfigChannel+0x4f8>
      assert_param(IS_ADC2_DIFF_CHANNEL(sConfig->Channel));
 8001528:	6822      	ldr	r2, [r4, #0]
 800152a:	4b3f      	ldr	r3, [pc, #252]	; (8001628 <HAL_ADC_ConfigChannel+0x640>)
 800152c:	493f      	ldr	r1, [pc, #252]	; (800162c <HAL_ADC_ConfigChannel+0x644>)
 800152e:	4840      	ldr	r0, [pc, #256]	; (8001630 <HAL_ADC_ConfigChannel+0x648>)
 8001530:	429a      	cmp	r2, r3
 8001532:	bf18      	it	ne
 8001534:	428a      	cmpne	r2, r1
 8001536:	493f      	ldr	r1, [pc, #252]	; (8001634 <HAL_ADC_ConfigChannel+0x64c>)
 8001538:	bf14      	ite	ne
 800153a:	2301      	movne	r3, #1
 800153c:	2300      	moveq	r3, #0
 800153e:	4282      	cmp	r2, r0
 8001540:	bf0c      	ite	eq
 8001542:	2300      	moveq	r3, #0
 8001544:	f003 0301 	andne.w	r3, r3, #1
 8001548:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
 800154c:	428a      	cmp	r2, r1
 800154e:	bf0c      	ite	eq
 8001550:	2300      	moveq	r3, #0
 8001552:	f003 0301 	andne.w	r3, r3, #1
 8001556:	3018      	adds	r0, #24
 8001558:	4937      	ldr	r1, [pc, #220]	; (8001638 <HAL_ADC_ConfigChannel+0x650>)
 800155a:	4282      	cmp	r2, r0
 800155c:	bf0c      	ite	eq
 800155e:	2300      	moveq	r3, #0
 8001560:	f003 0301 	andne.w	r3, r3, #1
 8001564:	f100 50ca 	add.w	r0, r0, #423624704	; 0x19400000
 8001568:	428a      	cmp	r2, r1
 800156a:	bf0c      	ite	eq
 800156c:	2300      	moveq	r3, #0
 800156e:	f003 0301 	andne.w	r3, r3, #1
 8001572:	f500 60fc 	add.w	r0, r0, #2016	; 0x7e0
 8001576:	f101 6106 	add.w	r1, r1, #140509184	; 0x8600000
 800157a:	4282      	cmp	r2, r0
 800157c:	bf0c      	ite	eq
 800157e:	2300      	moveq	r3, #0
 8001580:	f003 0301 	andne.w	r3, r3, #1
 8001584:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
 8001588:	428a      	cmp	r2, r1
 800158a:	bf0c      	ite	eq
 800158c:	2300      	moveq	r3, #0
 800158e:	f003 0301 	andne.w	r3, r3, #1
 8001592:	2b00      	cmp	r3, #0
 8001594:	f43f ae05 	beq.w	80011a2 <HAL_ADC_ConfigChannel+0x1ba>
 8001598:	4b2c      	ldr	r3, [pc, #176]	; (800164c <HAL_ADC_ConfigChannel+0x664>)
 800159a:	429a      	cmp	r2, r3
 800159c:	f43f ae01 	beq.w	80011a2 <HAL_ADC_ConfigChannel+0x1ba>
 80015a0:	f640 217e 	movw	r1, #2686	; 0xa7e
 80015a4:	481b      	ldr	r0, [pc, #108]	; (8001614 <HAL_ADC_ConfigChannel+0x62c>)
 80015a6:	f012 f993 	bl	80138d0 <assert_failed>
 80015aa:	682b      	ldr	r3, [r5, #0]
 80015ac:	e6d5      	b.n	800135a <HAL_ADC_ConfigChannel+0x372>
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 80015ae:	6829      	ldr	r1, [r5, #0]
 80015b0:	4b1a      	ldr	r3, [pc, #104]	; (800161c <HAL_ADC_ConfigChannel+0x634>)
 80015b2:	4299      	cmp	r1, r3
 80015b4:	f000 813d 	beq.w	8001832 <HAL_ADC_ConfigChannel+0x84a>
 80015b8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80015bc:	4299      	cmp	r1, r3
 80015be:	f000 8138 	beq.w	8001832 <HAL_ADC_ConfigChannel+0x84a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80015c2:	4e18      	ldr	r6, [pc, #96]	; (8001624 <HAL_ADC_ConfigChannel+0x63c>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80015c4:	4c22      	ldr	r4, [pc, #136]	; (8001650 <HAL_ADC_ConfigChannel+0x668>)
 80015c6:	68a0      	ldr	r0, [r4, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80015c8:	68b3      	ldr	r3, [r6, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80015ca:	f000 76e0 	and.w	r6, r0, #29360128	; 0x1c00000
 80015ce:	43db      	mvns	r3, r3
 80015d0:	f003 0301 	and.w	r3, r3, #1
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80015d4:	2b00      	cmp	r3, #0
 80015d6:	f000 8141 	beq.w	800185c <HAL_ADC_ConfigChannel+0x874>
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 80015da:	4b1e      	ldr	r3, [pc, #120]	; (8001654 <HAL_ADC_ConfigChannel+0x66c>)
 80015dc:	429a      	cmp	r2, r3
 80015de:	f000 8160 	beq.w	80018a2 <HAL_ADC_ConfigChannel+0x8ba>
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 80015e2:	4b1d      	ldr	r3, [pc, #116]	; (8001658 <HAL_ADC_ConfigChannel+0x670>)
 80015e4:	429a      	cmp	r2, r3
 80015e6:	f000 817e 	beq.w	80018e6 <HAL_ADC_ConfigChannel+0x8fe>
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 80015ea:	4b1c      	ldr	r3, [pc, #112]	; (800165c <HAL_ADC_ConfigChannel+0x674>)
 80015ec:	429a      	cmp	r2, r3
 80015ee:	f47f ae28 	bne.w	8001242 <HAL_ADC_ConfigChannel+0x25a>
            if (ADC_VREFINT_INSTANCE(hadc))
 80015f2:	0243      	lsls	r3, r0, #9
 80015f4:	f53f ae25 	bmi.w	8001242 <HAL_ADC_ConfigChannel+0x25a>
 80015f8:	4b0a      	ldr	r3, [pc, #40]	; (8001624 <HAL_ADC_ConfigChannel+0x63c>)
 80015fa:	4299      	cmp	r1, r3
 80015fc:	f47f ae21 	bne.w	8001242 <HAL_ADC_ConfigChannel+0x25a>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8001600:	68a2      	ldr	r2, [r4, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 8001602:	f446 0380 	orr.w	r3, r6, #4194304	; 0x400000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8001606:	2000      	movs	r0, #0
 8001608:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 800160c:	4313      	orrs	r3, r2
 800160e:	60a3      	str	r3, [r4, #8]
 8001610:	e629      	b.n	8001266 <HAL_ADC_ConfigChannel+0x27e>
 8001612:	bf00      	nop
 8001614:	08029080 	.word	0x08029080
 8001618:	47ff0000 	.word	0x47ff0000
 800161c:	40022000 	.word	0x40022000
 8001620:	40022100 	.word	0x40022100
 8001624:	58026000 	.word	0x58026000
 8001628:	04300002 	.word	0x04300002
 800162c:	08600004 	.word	0x08600004
 8001630:	0c900008 	.word	0x0c900008
 8001634:	10c00010 	.word	0x10c00010
 8001638:	2a000400 	.word	0x2a000400
 800163c:	36902000 	.word	0x36902000
 8001640:	3ac04000 	.word	0x3ac04000
 8001644:	3ef08000 	.word	0x3ef08000
 8001648:	5c001000 	.word	0x5c001000
 800164c:	4b840000 	.word	0x4b840000
 8001650:	58026300 	.word	0x58026300
 8001654:	cb840000 	.word	0xcb840000
 8001658:	c7520000 	.word	0xc7520000
 800165c:	cfb80000 	.word	0xcfb80000
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 8001660:	682b      	ldr	r3, [r5, #0]
 8001662:	6962      	ldr	r2, [r4, #20]
 8001664:	68d9      	ldr	r1, [r3, #12]
 8001666:	f3c1 0182 	ubfx	r1, r1, #2, #3
 800166a:	0049      	lsls	r1, r1, #1
 800166c:	fa02 f101 	lsl.w	r1, r2, r1
 8001670:	e6e3      	b.n	800143a <HAL_ADC_ConfigChannel+0x452>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8001672:	6822      	ldr	r2, [r4, #0]
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8001674:	6829      	ldr	r1, [r5, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8001676:	f3c2 0313 	ubfx	r3, r2, #0, #20
 800167a:	2b00      	cmp	r3, #0
 800167c:	f000 80ac 	beq.w	80017d8 <HAL_ADC_ConfigChannel+0x7f0>
 8001680:	fa92 f3a2 	rbit	r3, r2
 8001684:	fab3 f383 	clz	r3, r3
 8001688:	3301      	adds	r3, #1
 800168a:	f003 031f 	and.w	r3, r3, #31
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800168e:	2b09      	cmp	r3, #9
 8001690:	f200 80ea 	bhi.w	8001868 <HAL_ADC_ConfigChannel+0x880>
 8001694:	fa92 f3a2 	rbit	r3, r2
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8001698:	fab3 f383 	clz	r3, r3
 800169c:	fa92 f0a2 	rbit	r0, r2
 80016a0:	2601      	movs	r6, #1
 80016a2:	fab0 f080 	clz	r0, r0
 80016a6:	3301      	adds	r3, #1
 80016a8:	4430      	add	r0, r6
 80016aa:	069b      	lsls	r3, r3, #26
 80016ac:	f000 001f 	and.w	r0, r0, #31
 80016b0:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
 80016b4:	fa06 f000 	lsl.w	r0, r6, r0
 80016b8:	4303      	orrs	r3, r0
 80016ba:	fa92 f2a2 	rbit	r2, r2
 80016be:	fab2 f282 	clz	r2, r2
 80016c2:	4432      	add	r2, r6
 80016c4:	f002 021f 	and.w	r2, r2, #31
 80016c8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80016cc:	0512      	lsls	r2, r2, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80016ce:	431a      	orrs	r2, r3
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80016d0:	3114      	adds	r1, #20
  MODIFY_REG(*preg,
 80016d2:	2707      	movs	r7, #7
 80016d4:	68a3      	ldr	r3, [r4, #8]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80016d6:	0dd6      	lsrs	r6, r2, #23
  MODIFY_REG(*preg,
 80016d8:	f3c2 5204 	ubfx	r2, r2, #20, #5
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80016dc:	f006 0604 	and.w	r6, r6, #4
  MODIFY_REG(*preg,
 80016e0:	4097      	lsls	r7, r2
 80016e2:	4093      	lsls	r3, r2
 80016e4:	5870      	ldr	r0, [r6, r1]
 80016e6:	ea20 0207 	bic.w	r2, r0, r7
 80016ea:	431a      	orrs	r2, r3
 80016ec:	5072      	str	r2, [r6, r1]
 80016ee:	e5a4      	b.n	800123a <HAL_ADC_ConfigChannel+0x252>
  __HAL_LOCK(hadc);
 80016f0:	2002      	movs	r0, #2
}
 80016f2:	b003      	add	sp, #12
 80016f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset/(hadc->Init.Oversampling.Ratio+1U)));
 80016f6:	f640 2166 	movw	r1, #2662	; 0xa66
 80016fa:	4883      	ldr	r0, [pc, #524]	; (8001908 <HAL_ADC_ConfigChannel+0x920>)
 80016fc:	f012 f8e8 	bl	80138d0 <assert_failed>
 8001700:	e60f      	b.n	8001322 <HAL_ADC_ConfigChannel+0x33a>
      assert_param(IS_ADC1_DIFF_CHANNEL(sConfig->Channel));
 8001702:	6822      	ldr	r2, [r4, #0]
 8001704:	4b81      	ldr	r3, [pc, #516]	; (800190c <HAL_ADC_ConfigChannel+0x924>)
 8001706:	4882      	ldr	r0, [pc, #520]	; (8001910 <HAL_ADC_ConfigChannel+0x928>)
 8001708:	4982      	ldr	r1, [pc, #520]	; (8001914 <HAL_ADC_ConfigChannel+0x92c>)
 800170a:	429a      	cmp	r2, r3
 800170c:	bf18      	it	ne
 800170e:	4282      	cmpne	r2, r0
 8001710:	4881      	ldr	r0, [pc, #516]	; (8001918 <HAL_ADC_ConfigChannel+0x930>)
 8001712:	bf14      	ite	ne
 8001714:	2301      	movne	r3, #1
 8001716:	2300      	moveq	r3, #0
 8001718:	428a      	cmp	r2, r1
 800171a:	bf0c      	ite	eq
 800171c:	2300      	moveq	r3, #0
 800171e:	f003 0301 	andne.w	r3, r3, #1
 8001722:	f101 6106 	add.w	r1, r1, #140509184	; 0x8600000
 8001726:	4282      	cmp	r2, r0
 8001728:	bf0c      	ite	eq
 800172a:	2300      	moveq	r3, #0
 800172c:	f003 0301 	andne.w	r3, r3, #1
 8001730:	3118      	adds	r1, #24
 8001732:	487a      	ldr	r0, [pc, #488]	; (800191c <HAL_ADC_ConfigChannel+0x934>)
 8001734:	428a      	cmp	r2, r1
 8001736:	bf0c      	ite	eq
 8001738:	2300      	moveq	r3, #0
 800173a:	f003 0301 	andne.w	r3, r3, #1
 800173e:	f101 51ca 	add.w	r1, r1, #423624704	; 0x19400000
 8001742:	4282      	cmp	r2, r0
 8001744:	bf0c      	ite	eq
 8001746:	2300      	moveq	r3, #0
 8001748:	f003 0301 	andne.w	r3, r3, #1
 800174c:	f501 61fc 	add.w	r1, r1, #2016	; 0x7e0
 8001750:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
 8001754:	428a      	cmp	r2, r1
 8001756:	bf0c      	ite	eq
 8001758:	2300      	moveq	r3, #0
 800175a:	f003 0301 	andne.w	r3, r3, #1
 800175e:	4970      	ldr	r1, [pc, #448]	; (8001920 <HAL_ADC_ConfigChannel+0x938>)
 8001760:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
 8001764:	4282      	cmp	r2, r0
 8001766:	bf0c      	ite	eq
 8001768:	2300      	moveq	r3, #0
 800176a:	f003 0301 	andne.w	r3, r3, #1
 800176e:	428a      	cmp	r2, r1
 8001770:	bf0c      	ite	eq
 8001772:	2300      	moveq	r3, #0
 8001774:	f003 0301 	andne.w	r3, r3, #1
 8001778:	2b00      	cmp	r3, #0
 800177a:	f43f ad12 	beq.w	80011a2 <HAL_ADC_ConfigChannel+0x1ba>
 800177e:	4b69      	ldr	r3, [pc, #420]	; (8001924 <HAL_ADC_ConfigChannel+0x93c>)
 8001780:	429a      	cmp	r2, r3
 8001782:	f43f ad0e 	beq.w	80011a2 <HAL_ADC_ConfigChannel+0x1ba>
 8001786:	f640 217a 	movw	r1, #2682	; 0xa7a
 800178a:	485f      	ldr	r0, [pc, #380]	; (8001908 <HAL_ADC_ConfigChannel+0x920>)
 800178c:	f012 f8a0 	bl	80138d0 <assert_failed>
 8001790:	682b      	ldr	r3, [r5, #0]
 8001792:	e5de      	b.n	8001352 <HAL_ADC_ConfigChannel+0x36a>
          if (((hadc->Instance->OFR1) & ADC_OFR1_OFFSET1_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8001794:	6e19      	ldr	r1, [r3, #96]	; 0x60
 8001796:	0692      	lsls	r2, r2, #26
 8001798:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
 800179c:	4291      	cmp	r1, r2
 800179e:	d040      	beq.n	8001822 <HAL_ADC_ConfigChannel+0x83a>
          if (((hadc->Instance->OFR2) & ADC_OFR2_OFFSET2_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 80017a0:	6e59      	ldr	r1, [r3, #100]	; 0x64
 80017a2:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
 80017a6:	4291      	cmp	r1, r2
 80017a8:	d033      	beq.n	8001812 <HAL_ADC_ConfigChannel+0x82a>
          if (((hadc->Instance->OFR3) & ADC_OFR3_OFFSET3_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 80017aa:	6e99      	ldr	r1, [r3, #104]	; 0x68
 80017ac:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
 80017b0:	4291      	cmp	r1, r2
 80017b2:	d026      	beq.n	8001802 <HAL_ADC_ConfigChannel+0x81a>
          if (((hadc->Instance->OFR4) & ADC_OFR4_OFFSET4_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 80017b4:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80017b6:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
 80017ba:	4291      	cmp	r1, r2
 80017bc:	f47f ad25 	bne.w	800120a <HAL_ADC_ConfigChannel+0x222>
            CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_SSATE);
 80017c0:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80017c2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80017c6:	66da      	str	r2, [r3, #108]	; 0x6c
 80017c8:	682b      	ldr	r3, [r5, #0]
 80017ca:	e51e      	b.n	800120a <HAL_ADC_ConfigChannel+0x222>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 80017cc:	0849      	lsrs	r1, r1, #1
 80017ce:	f001 0108 	and.w	r1, r1, #8
 80017d2:	fa02 f101 	lsl.w	r1, r2, r1
 80017d6:	e630      	b.n	800143a <HAL_ADC_ConfigChannel+0x452>
 80017d8:	2601      	movs	r6, #1
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80017da:	0e92      	lsrs	r2, r2, #26
 80017dc:	4432      	add	r2, r6
 80017de:	f002 001f 	and.w	r0, r2, #31
 80017e2:	0693      	lsls	r3, r2, #26
 80017e4:	4086      	lsls	r6, r0
 80017e6:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80017ea:	2809      	cmp	r0, #9
 80017ec:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80017f0:	ea43 0306 	orr.w	r3, r3, r6
 80017f4:	f67f af6a 	bls.w	80016cc <HAL_ADC_ConfigChannel+0x6e4>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80017f8:	3a1e      	subs	r2, #30
 80017fa:	0512      	lsls	r2, r2, #20
 80017fc:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8001800:	e765      	b.n	80016ce <HAL_ADC_ConfigChannel+0x6e6>
            CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_SSATE);
 8001802:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8001804:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8001808:	669a      	str	r2, [r3, #104]	; 0x68
 800180a:	6822      	ldr	r2, [r4, #0]
 800180c:	682b      	ldr	r3, [r5, #0]
 800180e:	0692      	lsls	r2, r2, #26
 8001810:	e7d0      	b.n	80017b4 <HAL_ADC_ConfigChannel+0x7cc>
            CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_SSATE);
 8001812:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8001814:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8001818:	665a      	str	r2, [r3, #100]	; 0x64
 800181a:	6822      	ldr	r2, [r4, #0]
 800181c:	682b      	ldr	r3, [r5, #0]
 800181e:	0692      	lsls	r2, r2, #26
 8001820:	e7c3      	b.n	80017aa <HAL_ADC_ConfigChannel+0x7c2>
            CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_SSATE);
 8001822:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001824:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8001828:	661a      	str	r2, [r3, #96]	; 0x60
 800182a:	6822      	ldr	r2, [r4, #0]
 800182c:	682b      	ldr	r3, [r5, #0]
 800182e:	0692      	lsls	r2, r2, #26
 8001830:	e7b6      	b.n	80017a0 <HAL_ADC_ConfigChannel+0x7b8>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001832:	4b3d      	ldr	r3, [pc, #244]	; (8001928 <HAL_ADC_ConfigChannel+0x940>)
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8001834:	4e3d      	ldr	r6, [pc, #244]	; (800192c <HAL_ADC_ConfigChannel+0x944>)
 8001836:	4f3e      	ldr	r7, [pc, #248]	; (8001930 <HAL_ADC_ConfigChannel+0x948>)
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8001838:	461c      	mov	r4, r3
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 800183a:	6898      	ldr	r0, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800183c:	68bf      	ldr	r7, [r7, #8]
 800183e:	68b3      	ldr	r3, [r6, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001840:	f000 76e0 	and.w	r6, r0, #29360128	; 0x1c00000
 8001844:	433b      	orrs	r3, r7
 8001846:	43db      	mvns	r3, r3
 8001848:	f003 0301 	and.w	r3, r3, #1
 800184c:	e6c2      	b.n	80015d4 <HAL_ADC_ConfigChannel+0x5ec>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
 800184e:	f640 215f 	movw	r1, #2655	; 0xa5f
 8001852:	482d      	ldr	r0, [pc, #180]	; (8001908 <HAL_ADC_ConfigChannel+0x920>)
 8001854:	f012 f83c 	bl	80138d0 <assert_failed>
 8001858:	f7ff bbf5 	b.w	8001046 <HAL_ADC_ConfigChannel+0x5e>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800185c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
          tmp_hal_status = HAL_ERROR;
 800185e:	2001      	movs	r0, #1
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001860:	f043 0320 	orr.w	r3, r3, #32
 8001864:	656b      	str	r3, [r5, #84]	; 0x54
 8001866:	e4fe      	b.n	8001266 <HAL_ADC_ConfigChannel+0x27e>
 8001868:	fa92 f3a2 	rbit	r3, r2
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800186c:	fab3 f383 	clz	r3, r3
 8001870:	fa92 f0a2 	rbit	r0, r2
 8001874:	2601      	movs	r6, #1
 8001876:	fab0 f080 	clz	r0, r0
 800187a:	3301      	adds	r3, #1
 800187c:	4430      	add	r0, r6
 800187e:	069b      	lsls	r3, r3, #26
 8001880:	f000 001f 	and.w	r0, r0, #31
 8001884:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
 8001888:	fa06 f000 	lsl.w	r0, r6, r0
 800188c:	4303      	orrs	r3, r0
 800188e:	fa92 f2a2 	rbit	r2, r2
 8001892:	fab2 f282 	clz	r2, r2
 8001896:	4432      	add	r2, r6
 8001898:	f002 021f 	and.w	r2, r2, #31
 800189c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80018a0:	e7aa      	b.n	80017f8 <HAL_ADC_ConfigChannel+0x810>
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 80018a2:	0200      	lsls	r0, r0, #8
 80018a4:	f53f accd 	bmi.w	8001242 <HAL_ADC_ConfigChannel+0x25a>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 80018a8:	4b22      	ldr	r3, [pc, #136]	; (8001934 <HAL_ADC_ConfigChannel+0x94c>)
 80018aa:	4299      	cmp	r1, r3
 80018ac:	f47f acc9 	bne.w	8001242 <HAL_ADC_ConfigChannel+0x25a>
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 80018b0:	4b21      	ldr	r3, [pc, #132]	; (8001938 <HAL_ADC_ConfigChannel+0x950>)
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 80018b2:	f446 0200 	orr.w	r2, r6, #8388608	; 0x800000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80018b6:	68a1      	ldr	r1, [r4, #8]
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 80018b8:	681b      	ldr	r3, [r3, #0]
 80018ba:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 80018be:	481f      	ldr	r0, [pc, #124]	; (800193c <HAL_ADC_ConfigChannel+0x954>)
 80018c0:	099b      	lsrs	r3, r3, #6
 80018c2:	430a      	orrs	r2, r1
 80018c4:	fba0 1303 	umull	r1, r3, r0, r3
 80018c8:	60a2      	str	r2, [r4, #8]
 80018ca:	099b      	lsrs	r3, r3, #6
 80018cc:	005b      	lsls	r3, r3, #1
 80018ce:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0UL)
 80018d0:	9b01      	ldr	r3, [sp, #4]
 80018d2:	2b00      	cmp	r3, #0
 80018d4:	f43f acb5 	beq.w	8001242 <HAL_ADC_ConfigChannel+0x25a>
                wait_loop_index--;
 80018d8:	9b01      	ldr	r3, [sp, #4]
 80018da:	3b01      	subs	r3, #1
 80018dc:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0UL)
 80018de:	9b01      	ldr	r3, [sp, #4]
 80018e0:	2b00      	cmp	r3, #0
 80018e2:	d1f9      	bne.n	80018d8 <HAL_ADC_ConfigChannel+0x8f0>
 80018e4:	e4ad      	b.n	8001242 <HAL_ADC_ConfigChannel+0x25a>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 80018e6:	01c2      	lsls	r2, r0, #7
 80018e8:	f53f acab 	bmi.w	8001242 <HAL_ADC_ConfigChannel+0x25a>
 80018ec:	4b11      	ldr	r3, [pc, #68]	; (8001934 <HAL_ADC_ConfigChannel+0x94c>)
 80018ee:	4299      	cmp	r1, r3
 80018f0:	f47f aca7 	bne.w	8001242 <HAL_ADC_ConfigChannel+0x25a>
 80018f4:	68a2      	ldr	r2, [r4, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 80018f6:	f046 7380 	orr.w	r3, r6, #16777216	; 0x1000000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80018fa:	2000      	movs	r0, #0
 80018fc:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 8001900:	4313      	orrs	r3, r2
 8001902:	60a3      	str	r3, [r4, #8]
 8001904:	e4af      	b.n	8001266 <HAL_ADC_ConfigChannel+0x27e>
 8001906:	bf00      	nop
 8001908:	08029080 	.word	0x08029080
 800190c:	04300002 	.word	0x04300002
 8001910:	08600004 	.word	0x08600004
 8001914:	0c900008 	.word	0x0c900008
 8001918:	10c00010 	.word	0x10c00010
 800191c:	2a000400 	.word	0x2a000400
 8001920:	43210000 	.word	0x43210000
 8001924:	4b840000 	.word	0x4b840000
 8001928:	40022300 	.word	0x40022300
 800192c:	40022100 	.word	0x40022100
 8001930:	40022000 	.word	0x40022000
 8001934:	58026000 	.word	0x58026000
 8001938:	200002bc 	.word	0x200002bc
 800193c:	053e2d63 	.word	0x053e2d63

08001940 <ADC_Disable>:
{
 8001940:	b538      	push	{r3, r4, r5, lr}
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 8001942:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8001944:	6899      	ldr	r1, [r3, #8]
 8001946:	0789      	lsls	r1, r1, #30
 8001948:	d502      	bpl.n	8001950 <ADC_Disable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800194a:	689b      	ldr	r3, [r3, #8]
  return HAL_OK;
 800194c:	2000      	movs	r0, #0
}
 800194e:	bd38      	pop	{r3, r4, r5, pc}
 8001950:	6899      	ldr	r1, [r3, #8]
 8001952:	07ca      	lsls	r2, r1, #31
 8001954:	d524      	bpl.n	80019a0 <ADC_Disable+0x60>
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 8001956:	6899      	ldr	r1, [r3, #8]
 8001958:	4604      	mov	r4, r0
 800195a:	f001 010d 	and.w	r1, r1, #13
 800195e:	2901      	cmp	r1, #1
 8001960:	d008      	beq.n	8001974 <ADC_Disable+0x34>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001962:	6d63      	ldr	r3, [r4, #84]	; 0x54
        return HAL_ERROR;
 8001964:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001966:	f043 0310 	orr.w	r3, r3, #16
 800196a:	6563      	str	r3, [r4, #84]	; 0x54
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800196c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800196e:	4303      	orrs	r3, r0
 8001970:	65a3      	str	r3, [r4, #88]	; 0x58
}
 8001972:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG(ADCx->CR,
 8001974:	6898      	ldr	r0, [r3, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 8001976:	2103      	movs	r1, #3
 8001978:	4a0a      	ldr	r2, [pc, #40]	; (80019a4 <ADC_Disable+0x64>)
 800197a:	4002      	ands	r2, r0
 800197c:	f042 0202 	orr.w	r2, r2, #2
 8001980:	609a      	str	r2, [r3, #8]
 8001982:	6823      	ldr	r3, [r4, #0]
 8001984:	6019      	str	r1, [r3, #0]
    tickstart = HAL_GetTick();
 8001986:	f7ff f84f 	bl	8000a28 <HAL_GetTick>
 800198a:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 800198c:	e004      	b.n	8001998 <ADC_Disable+0x58>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 800198e:	f7ff f84b 	bl	8000a28 <HAL_GetTick>
 8001992:	1b40      	subs	r0, r0, r5
 8001994:	2802      	cmp	r0, #2
 8001996:	d8e4      	bhi.n	8001962 <ADC_Disable+0x22>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8001998:	6823      	ldr	r3, [r4, #0]
 800199a:	689b      	ldr	r3, [r3, #8]
 800199c:	07db      	lsls	r3, r3, #31
 800199e:	d4f6      	bmi.n	800198e <ADC_Disable+0x4e>
  return HAL_OK;
 80019a0:	2000      	movs	r0, #0
}
 80019a2:	bd38      	pop	{r3, r4, r5, pc}
 80019a4:	7fffffc0 	.word	0x7fffffc0

080019a8 <ADC_ConfigureBoostMode>:
  *         stopped.
  * @param  hadc ADC handle
  * @retval None.
  */
void ADC_ConfigureBoostMode(ADC_HandleTypeDef* hadc)
{
 80019a8:	b538      	push	{r3, r4, r5, lr}
  uint32_t freq;
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
 80019aa:	4a52      	ldr	r2, [pc, #328]	; (8001af4 <ADC_ConfigureBoostMode+0x14c>)
{
 80019ac:	4605      	mov	r5, r0
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
 80019ae:	6803      	ldr	r3, [r0, #0]
 80019b0:	4293      	cmp	r3, r2
 80019b2:	d027      	beq.n	8001a04 <ADC_ConfigureBoostMode+0x5c>
 80019b4:	f502 7280 	add.w	r2, r2, #256	; 0x100
 80019b8:	4293      	cmp	r3, r2
 80019ba:	d023      	beq.n	8001a04 <ADC_ConfigureBoostMode+0x5c>
 80019bc:	4b4e      	ldr	r3, [pc, #312]	; (8001af8 <ADC_ConfigureBoostMode+0x150>)
 80019be:	689b      	ldr	r3, [r3, #8]
 80019c0:	f413 3f40 	tst.w	r3, #196608	; 0x30000
 80019c4:	bf14      	ite	ne
 80019c6:	2301      	movne	r3, #1
 80019c8:	2300      	moveq	r3, #0
 80019ca:	b323      	cbz	r3, 8001a16 <ADC_ConfigureBoostMode+0x6e>
  {
    freq = HAL_RCC_GetHCLKFreq();
 80019cc:	f007 f930 	bl	8008c30 <HAL_RCC_GetHCLKFreq>
    switch(hadc->Init.ClockPrescaler)
 80019d0:	686b      	ldr	r3, [r5, #4]
    freq = HAL_RCC_GetHCLKFreq();
 80019d2:	4604      	mov	r4, r0
    switch(hadc->Init.ClockPrescaler)
 80019d4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80019d8:	d062      	beq.n	8001aa0 <ADC_ConfigureBoostMode+0xf8>
 80019da:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 80019de:	d072      	beq.n	8001ac6 <ADC_ConfigureBoostMode+0x11e>
 80019e0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80019e4:	d05c      	beq.n	8001aa0 <ADC_ConfigureBoostMode+0xf8>
  else /* if(freq > 25000000UL) */
  {
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
  }
#else
  if(HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
 80019e6:	f7ff f837 	bl	8000a58 <HAL_GetREVID>
 80019ea:	f241 0303 	movw	r3, #4099	; 0x1003
 80019ee:	4298      	cmp	r0, r3
 80019f0:	d832      	bhi.n	8001a58 <ADC_ConfigureBoostMode+0xb0>
  {
    if(freq > 20000000UL)
 80019f2:	4a42      	ldr	r2, [pc, #264]	; (8001afc <ADC_ConfigureBoostMode+0x154>)
 80019f4:	682b      	ldr	r3, [r5, #0]
 80019f6:	4294      	cmp	r4, r2
 80019f8:	d928      	bls.n	8001a4c <ADC_ConfigureBoostMode+0xa4>
    {
      SET_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
 80019fa:	689a      	ldr	r2, [r3, #8]
 80019fc:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001a00:	609a      	str	r2, [r3, #8]
    {
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    }
  }
#endif /* ADC_VER_V5_3 */
}
 8001a02:	bd38      	pop	{r3, r4, r5, pc}
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
 8001a04:	4b3e      	ldr	r3, [pc, #248]	; (8001b00 <ADC_ConfigureBoostMode+0x158>)
 8001a06:	689b      	ldr	r3, [r3, #8]
 8001a08:	f413 3f40 	tst.w	r3, #196608	; 0x30000
 8001a0c:	bf14      	ite	ne
 8001a0e:	2301      	movne	r3, #1
 8001a10:	2300      	moveq	r3, #0
 8001a12:	2b00      	cmp	r3, #0
 8001a14:	d1da      	bne.n	80019cc <ADC_ConfigureBoostMode+0x24>
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
 8001a16:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8001a1a:	f008 fbc1 	bl	800a1a0 <HAL_RCCEx_GetPeriphCLKFreq>
    switch(hadc->Init.ClockPrescaler)
 8001a1e:	686b      	ldr	r3, [r5, #4]
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
 8001a20:	4604      	mov	r4, r0
    switch(hadc->Init.ClockPrescaler)
 8001a22:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
 8001a26:	d049      	beq.n	8001abc <ADC_ConfigureBoostMode+0x114>
 8001a28:	d93e      	bls.n	8001aa8 <ADC_ConfigureBoostMode+0x100>
 8001a2a:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
 8001a2e:	d04e      	beq.n	8001ace <ADC_ConfigureBoostMode+0x126>
 8001a30:	d927      	bls.n	8001a82 <ADC_ConfigureBoostMode+0xda>
 8001a32:	f5b3 1f20 	cmp.w	r3, #2621440	; 0x280000
 8001a36:	d048      	beq.n	8001aca <ADC_ConfigureBoostMode+0x122>
 8001a38:	f5b3 1f30 	cmp.w	r3, #2883584	; 0x2c0000
 8001a3c:	d1d3      	bne.n	80019e6 <ADC_ConfigureBoostMode+0x3e>
  if(HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
 8001a3e:	f7ff f80b 	bl	8000a58 <HAL_GetREVID>
 8001a42:	f241 0303 	movw	r3, #4099	; 0x1003
 8001a46:	4298      	cmp	r0, r3
 8001a48:	d805      	bhi.n	8001a56 <ADC_ConfigureBoostMode+0xae>
 8001a4a:	682b      	ldr	r3, [r5, #0]
      CLEAR_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
 8001a4c:	689a      	ldr	r2, [r3, #8]
 8001a4e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001a52:	609a      	str	r2, [r3, #8]
}
 8001a54:	bd38      	pop	{r3, r4, r5, pc}
        freq /= 256UL;
 8001a56:	0a24      	lsrs	r4, r4, #8
    freq /= 2U; /* divider by 2 for Rev.V */
 8001a58:	0864      	lsrs	r4, r4, #1
    if (freq <= 6250000UL)
 8001a5a:	4a2a      	ldr	r2, [pc, #168]	; (8001b04 <ADC_ConfigureBoostMode+0x15c>)
 8001a5c:	682b      	ldr	r3, [r5, #0]
 8001a5e:	4294      	cmp	r4, r2
 8001a60:	d90a      	bls.n	8001a78 <ADC_ConfigureBoostMode+0xd0>
    else if(freq <= 12500000UL)
 8001a62:	4a29      	ldr	r2, [pc, #164]	; (8001b08 <ADC_ConfigureBoostMode+0x160>)
 8001a64:	4294      	cmp	r4, r2
 8001a66:	d914      	bls.n	8001a92 <ADC_ConfigureBoostMode+0xea>
    else if(freq <= 25000000UL)
 8001a68:	4a28      	ldr	r2, [pc, #160]	; (8001b0c <ADC_ConfigureBoostMode+0x164>)
 8001a6a:	4294      	cmp	r4, r2
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
 8001a6c:	689a      	ldr	r2, [r3, #8]
    else if(freq <= 25000000UL)
 8001a6e:	d932      	bls.n	8001ad6 <ADC_ConfigureBoostMode+0x12e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
 8001a70:	f442 7240 	orr.w	r2, r2, #768	; 0x300
 8001a74:	609a      	str	r2, [r3, #8]
}
 8001a76:	bd38      	pop	{r3, r4, r5, pc}
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, 0UL);
 8001a78:	689a      	ldr	r2, [r3, #8]
 8001a7a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001a7e:	609a      	str	r2, [r3, #8]
}
 8001a80:	bd38      	pop	{r3, r4, r5, pc}
    switch(hadc->Init.ClockPrescaler)
 8001a82:	f5b3 1fe0 	cmp.w	r3, #1835008	; 0x1c0000
 8001a86:	d024      	beq.n	8001ad2 <ADC_ConfigureBoostMode+0x12a>
 8001a88:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8001a8c:	d1ab      	bne.n	80019e6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 32UL;
 8001a8e:	0944      	lsrs	r4, r0, #5
        break;
 8001a90:	e7a9      	b.n	80019e6 <ADC_ConfigureBoostMode+0x3e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_0);
 8001a92:	689a      	ldr	r2, [r3, #8]
 8001a94:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001a98:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001a9c:	609a      	str	r2, [r3, #8]
}
 8001a9e:	bd38      	pop	{r3, r4, r5, pc}
        freq /= (hadc->Init.ClockPrescaler >> ADC_CCR_CKMODE_Pos);
 8001aa0:	0c1b      	lsrs	r3, r3, #16
 8001aa2:	fbb4 f4f3 	udiv	r4, r4, r3
        break;
 8001aa6:	e79e      	b.n	80019e6 <ADC_ConfigureBoostMode+0x3e>
    switch(hadc->Init.ClockPrescaler)
 8001aa8:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 8001aac:	d006      	beq.n	8001abc <ADC_ConfigureBoostMode+0x114>
 8001aae:	d818      	bhi.n	8001ae2 <ADC_ConfigureBoostMode+0x13a>
 8001ab0:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001ab4:	d002      	beq.n	8001abc <ADC_ConfigureBoostMode+0x114>
 8001ab6:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8001aba:	d194      	bne.n	80019e6 <ADC_ConfigureBoostMode+0x3e>
        freq /= ((hadc->Init.ClockPrescaler >> ADC_CCR_PRESC_Pos) << 1UL);
 8001abc:	0c9b      	lsrs	r3, r3, #18
 8001abe:	005b      	lsls	r3, r3, #1
 8001ac0:	fbb4 f4f3 	udiv	r4, r4, r3
        break;
 8001ac4:	e78f      	b.n	80019e6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 4UL;
 8001ac6:	0884      	lsrs	r4, r0, #2
        break;
 8001ac8:	e78d      	b.n	80019e6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 128UL;
 8001aca:	09c4      	lsrs	r4, r0, #7
        break;
 8001acc:	e78b      	b.n	80019e6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 64UL;
 8001ace:	0984      	lsrs	r4, r0, #6
        break;
 8001ad0:	e789      	b.n	80019e6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 16UL;
 8001ad2:	0904      	lsrs	r4, r0, #4
      break;
 8001ad4:	e787      	b.n	80019e6 <ADC_ConfigureBoostMode+0x3e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
 8001ad6:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001ada:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001ade:	609a      	str	r2, [r3, #8]
}
 8001ae0:	bd38      	pop	{r3, r4, r5, pc}
    switch(hadc->Init.ClockPrescaler)
 8001ae2:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8001ae6:	d0e9      	beq.n	8001abc <ADC_ConfigureBoostMode+0x114>
 8001ae8:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
 8001aec:	f47f af7b 	bne.w	80019e6 <ADC_ConfigureBoostMode+0x3e>
 8001af0:	e7e4      	b.n	8001abc <ADC_ConfigureBoostMode+0x114>
 8001af2:	bf00      	nop
 8001af4:	40022000 	.word	0x40022000
 8001af8:	58026300 	.word	0x58026300
 8001afc:	01312d00 	.word	0x01312d00
 8001b00:	40022300 	.word	0x40022300
 8001b04:	005f5e10 	.word	0x005f5e10
 8001b08:	00bebc20 	.word	0x00bebc20
 8001b0c:	017d7840 	.word	0x017d7840

08001b10 <HAL_ADC_Init>:
{
 8001b10:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint32_t wait_loop_index = 0UL;
 8001b12:	2300      	movs	r3, #0
{
 8001b14:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0UL;
 8001b16:	9301      	str	r3, [sp, #4]
  if (hadc == NULL)
 8001b18:	2800      	cmp	r0, #0
 8001b1a:	f000 81ab 	beq.w	8001e74 <HAL_ADC_Init+0x364>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8001b1e:	6803      	ldr	r3, [r0, #0]
 8001b20:	4604      	mov	r4, r0
 8001b22:	499a      	ldr	r1, [pc, #616]	; (8001d8c <HAL_ADC_Init+0x27c>)
 8001b24:	4a9a      	ldr	r2, [pc, #616]	; (8001d90 <HAL_ADC_Init+0x280>)
 8001b26:	428b      	cmp	r3, r1
 8001b28:	bf18      	it	ne
 8001b2a:	4293      	cmpne	r3, r2
 8001b2c:	d003      	beq.n	8001b36 <HAL_ADC_Init+0x26>
 8001b2e:	4a99      	ldr	r2, [pc, #612]	; (8001d94 <HAL_ADC_Init+0x284>)
 8001b30:	4293      	cmp	r3, r2
 8001b32:	f040 81b0 	bne.w	8001e96 <HAL_ADC_Init+0x386>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
 8001b36:	6862      	ldr	r2, [r4, #4]
 8001b38:	f422 2300 	bic.w	r3, r2, #524288	; 0x80000
 8001b3c:	f422 3540 	bic.w	r5, r2, #196608	; 0x30000
 8001b40:	f422 1080 	bic.w	r0, r2, #1048576	; 0x100000
 8001b44:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
 8001b48:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001b4c:	bf18      	it	ne
 8001b4e:	2d00      	cmpne	r5, #0
 8001b50:	bf14      	ite	ne
 8001b52:	2301      	movne	r3, #1
 8001b54:	2300      	moveq	r3, #0
 8001b56:	f5b2 1fe0 	cmp.w	r2, #1835008	; 0x1c0000
 8001b5a:	bf0c      	ite	eq
 8001b5c:	2300      	moveq	r3, #0
 8001b5e:	f003 0301 	andne.w	r3, r3, #1
 8001b62:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 8001b66:	bf0c      	ite	eq
 8001b68:	2300      	moveq	r3, #0
 8001b6a:	f003 0301 	andne.w	r3, r3, #1
 8001b6e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8001b72:	bf0c      	ite	eq
 8001b74:	2300      	moveq	r3, #0
 8001b76:	f003 0301 	andne.w	r3, r3, #1
 8001b7a:	b12b      	cbz	r3, 8001b88 <HAL_ADC_Init+0x78>
 8001b7c:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8001b80:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 8001b84:	f040 81e0 	bne.w	8001f48 <HAL_ADC_Init+0x438>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
 8001b88:	68a2      	ldr	r2, [r4, #8]
 8001b8a:	2a10      	cmp	r2, #16
 8001b8c:	f200 817d 	bhi.w	8001e8a <HAL_ADC_Init+0x37a>
 8001b90:	4b81      	ldr	r3, [pc, #516]	; (8001d98 <HAL_ADC_Init+0x288>)
 8001b92:	40d3      	lsrs	r3, r2
 8001b94:	07de      	lsls	r6, r3, #31
 8001b96:	f140 8178 	bpl.w	8001e8a <HAL_ADC_Init+0x37a>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
 8001b9a:	68e3      	ldr	r3, [r4, #12]
 8001b9c:	2b01      	cmp	r3, #1
 8001b9e:	f200 80e0 	bhi.w	8001d62 <HAL_ADC_Init+0x252>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
 8001ba2:	7d63      	ldrb	r3, [r4, #21]
 8001ba4:	2b01      	cmp	r3, #1
 8001ba6:	f200 80cc 	bhi.w	8001d42 <HAL_ADC_Init+0x232>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
 8001baa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001bac:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
 8001bb0:	f040 80d1 	bne.w	8001d56 <HAL_ADC_Init+0x246>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
 8001bb4:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001bb6:	f5b2 6fd0 	cmp.w	r2, #1664	; 0x680
 8001bba:	bf18      	it	ne
 8001bbc:	f5b2 6fb8 	cmpne.w	r2, #1472	; 0x5c0
 8001bc0:	f022 0040 	bic.w	r0, r2, #64	; 0x40
 8001bc4:	f022 0180 	bic.w	r1, r2, #128	; 0x80
 8001bc8:	f422 7590 	bic.w	r5, r2, #288	; 0x120
 8001bcc:	bf14      	ite	ne
 8001bce:	2301      	movne	r3, #1
 8001bd0:	2300      	moveq	r3, #0
 8001bd2:	f5b0 6f84 	cmp.w	r0, #1056	; 0x420
 8001bd6:	bf0c      	ite	eq
 8001bd8:	2300      	moveq	r3, #0
 8001bda:	f003 0301 	andne.w	r3, r3, #1
 8001bde:	f422 7080 	bic.w	r0, r2, #256	; 0x100
 8001be2:	f5b1 6f88 	cmp.w	r1, #1088	; 0x440
 8001be6:	bf0c      	ite	eq
 8001be8:	2300      	moveq	r3, #0
 8001bea:	f003 0301 	andne.w	r3, r3, #1
 8001bee:	f022 0160 	bic.w	r1, r2, #96	; 0x60
 8001bf2:	f5b5 6f90 	cmp.w	r5, #1152	; 0x480
 8001bf6:	bf0c      	ite	eq
 8001bf8:	2300      	moveq	r3, #0
 8001bfa:	f003 0301 	andne.w	r3, r3, #1
 8001bfe:	f5b0 6f9c 	cmp.w	r0, #1248	; 0x4e0
 8001c02:	bf0c      	ite	eq
 8001c04:	2300      	moveq	r3, #0
 8001c06:	f003 0301 	andne.w	r3, r3, #1
 8001c0a:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
 8001c0e:	bf0c      	ite	eq
 8001c10:	2300      	moveq	r3, #0
 8001c12:	f003 0301 	andne.w	r3, r3, #1
 8001c16:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
 8001c1a:	bf0c      	ite	eq
 8001c1c:	2300      	moveq	r3, #0
 8001c1e:	f003 0301 	andne.w	r3, r3, #1
 8001c22:	b11b      	cbz	r3, 8001c2c <HAL_ADC_Init+0x11c>
 8001c24:	f432 6380 	bics.w	r3, r2, #1024	; 0x400
 8001c28:	f040 8194 	bne.w	8001f54 <HAL_ADC_Init+0x444>
  assert_param(IS_ADC_CONVERSIONDATAMGT(hadc->Init.ConversionDataManagement));
 8001c2c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001c2e:	2b03      	cmp	r3, #3
 8001c30:	f200 8165 	bhi.w	8001efe <HAL_ADC_Init+0x3ee>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
 8001c34:	6923      	ldr	r3, [r4, #16]
 8001c36:	2b04      	cmp	r3, #4
 8001c38:	d006      	beq.n	8001c48 <HAL_ADC_Init+0x138>
 8001c3a:	2b08      	cmp	r3, #8
 8001c3c:	d004      	beq.n	8001c48 <HAL_ADC_Init+0x138>
 8001c3e:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 8001c42:	4856      	ldr	r0, [pc, #344]	; (8001d9c <HAL_ADC_Init+0x28c>)
 8001c44:	f011 fe44 	bl	80138d0 <assert_failed>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
 8001c48:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001c4a:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 8001c4e:	f040 8092 	bne.w	8001d76 <HAL_ADC_Init+0x266>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
 8001c52:	7d23      	ldrb	r3, [r4, #20]
 8001c54:	2b01      	cmp	r3, #1
 8001c56:	d86a      	bhi.n	8001d2e <HAL_ADC_Init+0x21e>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
 8001c58:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8001c5c:	2b01      	cmp	r3, #1
 8001c5e:	d85d      	bhi.n	8001d1c <HAL_ADC_Init+0x20c>
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8001c60:	68e3      	ldr	r3, [r4, #12]
 8001c62:	2b00      	cmp	r3, #0
 8001c64:	d141      	bne.n	8001cea <HAL_ADC_Init+0x1da>
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
 8001c66:	7f23      	ldrb	r3, [r4, #28]
 8001c68:	2b01      	cmp	r3, #1
 8001c6a:	d04e      	beq.n	8001d0a <HAL_ADC_Init+0x1fa>
  if (hadc->State == HAL_ADC_STATE_RESET)
 8001c6c:	6d65      	ldr	r5, [r4, #84]	; 0x54
 8001c6e:	2d00      	cmp	r5, #0
 8001c70:	f000 8104 	beq.w	8001e7c <HAL_ADC_Init+0x36c>
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8001c74:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 8001c76:	689a      	ldr	r2, [r3, #8]
 8001c78:	0095      	lsls	r5, r2, #2
 8001c7a:	d504      	bpl.n	8001c86 <HAL_ADC_Init+0x176>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8001c7c:	6899      	ldr	r1, [r3, #8]
 8001c7e:	4a48      	ldr	r2, [pc, #288]	; (8001da0 <HAL_ADC_Init+0x290>)
 8001c80:	400a      	ands	r2, r1
 8001c82:	609a      	str	r2, [r3, #8]
 8001c84:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8001c86:	689a      	ldr	r2, [r3, #8]
 8001c88:	00d0      	lsls	r0, r2, #3
 8001c8a:	d416      	bmi.n	8001cba <HAL_ADC_Init+0x1aa>
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8001c8c:	4a45      	ldr	r2, [pc, #276]	; (8001da4 <HAL_ADC_Init+0x294>)
  MODIFY_REG(ADCx->CR,
 8001c8e:	6898      	ldr	r0, [r3, #8]
 8001c90:	6812      	ldr	r2, [r2, #0]
 8001c92:	4d45      	ldr	r5, [pc, #276]	; (8001da8 <HAL_ADC_Init+0x298>)
 8001c94:	0992      	lsrs	r2, r2, #6
 8001c96:	4945      	ldr	r1, [pc, #276]	; (8001dac <HAL_ADC_Init+0x29c>)
 8001c98:	fba5 5202 	umull	r5, r2, r5, r2
 8001c9c:	4001      	ands	r1, r0
 8001c9e:	0992      	lsrs	r2, r2, #6
 8001ca0:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001ca4:	6099      	str	r1, [r3, #8]
 8001ca6:	9201      	str	r2, [sp, #4]
    while (wait_loop_index != 0UL)
 8001ca8:	9b01      	ldr	r3, [sp, #4]
 8001caa:	b12b      	cbz	r3, 8001cb8 <HAL_ADC_Init+0x1a8>
      wait_loop_index--;
 8001cac:	9b01      	ldr	r3, [sp, #4]
 8001cae:	3b01      	subs	r3, #1
 8001cb0:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8001cb2:	9b01      	ldr	r3, [sp, #4]
 8001cb4:	2b00      	cmp	r3, #0
 8001cb6:	d1f9      	bne.n	8001cac <HAL_ADC_Init+0x19c>
 8001cb8:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8001cba:	689a      	ldr	r2, [r3, #8]
 8001cbc:	00d1      	lsls	r1, r2, #3
 8001cbe:	f100 80d7 	bmi.w	8001e70 <HAL_ADC_Init+0x360>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001cc2:	6d62      	ldr	r2, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
 8001cc4:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001cc6:	f042 0210 	orr.w	r2, r2, #16
 8001cca:	6562      	str	r2, [r4, #84]	; 0x54
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001ccc:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8001cce:	432a      	orrs	r2, r5
 8001cd0:	65a2      	str	r2, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8001cd2:	689a      	ldr	r2, [r3, #8]
 8001cd4:	0752      	lsls	r2, r2, #29
 8001cd6:	d56b      	bpl.n	8001db0 <HAL_ADC_Init+0x2a0>
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8001cd8:	6d63      	ldr	r3, [r4, #84]	; 0x54
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001cda:	6d63      	ldr	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
 8001cdc:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001cde:	f043 0310 	orr.w	r3, r3, #16
}
 8001ce2:	4628      	mov	r0, r5
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001ce4:	6563      	str	r3, [r4, #84]	; 0x54
}
 8001ce6:	b003      	add	sp, #12
 8001ce8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
 8001cea:	69a3      	ldr	r3, [r4, #24]
 8001cec:	3b01      	subs	r3, #1
 8001cee:	2b0f      	cmp	r3, #15
 8001cf0:	f200 80ff 	bhi.w	8001ef2 <HAL_ADC_Init+0x3e2>
    assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
 8001cf4:	7f23      	ldrb	r3, [r4, #28]
 8001cf6:	2b01      	cmp	r3, #1
 8001cf8:	f200 80d3 	bhi.w	8001ea2 <HAL_ADC_Init+0x392>
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001cfc:	2b01      	cmp	r3, #1
 8001cfe:	d1b5      	bne.n	8001c6c <HAL_ADC_Init+0x15c>
      assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
 8001d00:	6a23      	ldr	r3, [r4, #32]
 8001d02:	3b01      	subs	r3, #1
 8001d04:	2b07      	cmp	r3, #7
 8001d06:	f200 810f 	bhi.w	8001f28 <HAL_ADC_Init+0x418>
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
 8001d0a:	7d63      	ldrb	r3, [r4, #21]
 8001d0c:	2b01      	cmp	r3, #1
 8001d0e:	d1ad      	bne.n	8001c6c <HAL_ADC_Init+0x15c>
 8001d10:	f240 11bf 	movw	r1, #447	; 0x1bf
 8001d14:	4821      	ldr	r0, [pc, #132]	; (8001d9c <HAL_ADC_Init+0x28c>)
 8001d16:	f011 fddb 	bl	80138d0 <assert_failed>
 8001d1a:	e7a7      	b.n	8001c6c <HAL_ADC_Init+0x15c>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
 8001d1c:	f240 11b1 	movw	r1, #433	; 0x1b1
 8001d20:	481e      	ldr	r0, [pc, #120]	; (8001d9c <HAL_ADC_Init+0x28c>)
 8001d22:	f011 fdd5 	bl	80138d0 <assert_failed>
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8001d26:	68e3      	ldr	r3, [r4, #12]
 8001d28:	2b00      	cmp	r3, #0
 8001d2a:	d09c      	beq.n	8001c66 <HAL_ADC_Init+0x156>
 8001d2c:	e7dd      	b.n	8001cea <HAL_ADC_Init+0x1da>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
 8001d2e:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8001d32:	481a      	ldr	r0, [pc, #104]	; (8001d9c <HAL_ADC_Init+0x28c>)
 8001d34:	f011 fdcc 	bl	80138d0 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
 8001d38:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8001d3c:	2b01      	cmp	r3, #1
 8001d3e:	d98f      	bls.n	8001c60 <HAL_ADC_Init+0x150>
 8001d40:	e7ec      	b.n	8001d1c <HAL_ADC_Init+0x20c>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
 8001d42:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8001d46:	4815      	ldr	r0, [pc, #84]	; (8001d9c <HAL_ADC_Init+0x28c>)
 8001d48:	f011 fdc2 	bl	80138d0 <assert_failed>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
 8001d4c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001d4e:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
 8001d52:	f43f af2f 	beq.w	8001bb4 <HAL_ADC_Init+0xa4>
 8001d56:	f240 11ab 	movw	r1, #427	; 0x1ab
 8001d5a:	4810      	ldr	r0, [pc, #64]	; (8001d9c <HAL_ADC_Init+0x28c>)
 8001d5c:	f011 fdb8 	bl	80138d0 <assert_failed>
 8001d60:	e728      	b.n	8001bb4 <HAL_ADC_Init+0xa4>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
 8001d62:	f240 11a9 	movw	r1, #425	; 0x1a9
 8001d66:	480d      	ldr	r0, [pc, #52]	; (8001d9c <HAL_ADC_Init+0x28c>)
 8001d68:	f011 fdb2 	bl	80138d0 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
 8001d6c:	7d63      	ldrb	r3, [r4, #21]
 8001d6e:	2b01      	cmp	r3, #1
 8001d70:	f67f af1b 	bls.w	8001baa <HAL_ADC_Init+0x9a>
 8001d74:	e7e5      	b.n	8001d42 <HAL_ADC_Init+0x232>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
 8001d76:	f240 11af 	movw	r1, #431	; 0x1af
 8001d7a:	4808      	ldr	r0, [pc, #32]	; (8001d9c <HAL_ADC_Init+0x28c>)
 8001d7c:	f011 fda8 	bl	80138d0 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
 8001d80:	7d23      	ldrb	r3, [r4, #20]
 8001d82:	2b01      	cmp	r3, #1
 8001d84:	f67f af68 	bls.w	8001c58 <HAL_ADC_Init+0x148>
 8001d88:	e7d1      	b.n	8001d2e <HAL_ADC_Init+0x21e>
 8001d8a:	bf00      	nop
 8001d8c:	40022000 	.word	0x40022000
 8001d90:	40022100 	.word	0x40022100
 8001d94:	58026000 	.word	0x58026000
 8001d98:	00011111 	.word	0x00011111
 8001d9c:	08029080 	.word	0x08029080
 8001da0:	5fffffc0 	.word	0x5fffffc0
 8001da4:	200002bc 	.word	0x200002bc
 8001da8:	053e2d63 	.word	0x053e2d63
 8001dac:	6fffffc0 	.word	0x6fffffc0
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8001db0:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001db2:	06d7      	lsls	r7, r2, #27
 8001db4:	d491      	bmi.n	8001cda <HAL_ADC_Init+0x1ca>
    ADC_STATE_CLR_SET(hadc->State,
 8001db6:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001db8:	f422 7281 	bic.w	r2, r2, #258	; 0x102
 8001dbc:	f042 0202 	orr.w	r2, r2, #2
 8001dc0:	6562      	str	r2, [r4, #84]	; 0x54
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8001dc2:	689a      	ldr	r2, [r3, #8]
 8001dc4:	07d6      	lsls	r6, r2, #31
 8001dc6:	d413      	bmi.n	8001df0 <HAL_ADC_Init+0x2e0>
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8001dc8:	4a91      	ldr	r2, [pc, #580]	; (8002010 <HAL_ADC_Init+0x500>)
 8001dca:	4293      	cmp	r3, r2
 8001dcc:	f000 80b2 	beq.w	8001f34 <HAL_ADC_Init+0x424>
 8001dd0:	f502 7280 	add.w	r2, r2, #256	; 0x100
 8001dd4:	4293      	cmp	r3, r2
 8001dd6:	f000 80ad 	beq.w	8001f34 <HAL_ADC_Init+0x424>
 8001dda:	4b8e      	ldr	r3, [pc, #568]	; (8002014 <HAL_ADC_Init+0x504>)
 8001ddc:	689b      	ldr	r3, [r3, #8]
 8001dde:	07d9      	lsls	r1, r3, #31
 8001de0:	d406      	bmi.n	8001df0 <HAL_ADC_Init+0x2e0>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8001de2:	4a8d      	ldr	r2, [pc, #564]	; (8002018 <HAL_ADC_Init+0x508>)
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8001de4:	6893      	ldr	r3, [r2, #8]
 8001de6:	6861      	ldr	r1, [r4, #4]
 8001de8:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8001dec:	430b      	orrs	r3, r1
 8001dee:	6093      	str	r3, [r2, #8]
    if((HAL_GetREVID() > REV_ID_Y) && (ADC_RESOLUTION_8B == hadc->Init.Resolution))
 8001df0:	f7fe fe32 	bl	8000a58 <HAL_GetREVID>
 8001df4:	f241 0303 	movw	r3, #4099	; 0x1003
 8001df8:	4298      	cmp	r0, r3
 8001dfa:	f240 8086 	bls.w	8001f0a <HAL_ADC_Init+0x3fa>
 8001dfe:	68a2      	ldr	r2, [r4, #8]
 8001e00:	7d61      	ldrb	r1, [r4, #21]
 8001e02:	7f20      	ldrb	r0, [r4, #28]
 8001e04:	2a10      	cmp	r2, #16
 8001e06:	ea4f 3141 	mov.w	r1, r1, lsl #13
 8001e0a:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8001e0c:	ea4f 4300 	mov.w	r3, r0, lsl #16
 8001e10:	f000 80e0 	beq.w	8001fd4 <HAL_ADC_Init+0x4c4>
                  hadc->Init.Overrun                                                    |
 8001e14:	430a      	orrs	r2, r1
 8001e16:	4332      	orrs	r2, r6
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8001e18:	431a      	orrs	r2, r3
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001e1a:	2801      	cmp	r0, #1
 8001e1c:	d103      	bne.n	8001e26 <HAL_ADC_Init+0x316>
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8001e1e:	6a23      	ldr	r3, [r4, #32]
 8001e20:	3b01      	subs	r3, #1
 8001e22:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8001e26:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001e28:	b123      	cbz	r3, 8001e34 <HAL_ADC_Init+0x324>
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8001e2a:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
 8001e2e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001e30:	430b      	orrs	r3, r1
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8001e32:	431a      	orrs	r2, r3
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 8001e34:	6821      	ldr	r1, [r4, #0]
 8001e36:	4b79      	ldr	r3, [pc, #484]	; (800201c <HAL_ADC_Init+0x50c>)
 8001e38:	68c8      	ldr	r0, [r1, #12]
 8001e3a:	4003      	ands	r3, r0
 8001e3c:	4313      	orrs	r3, r2
 8001e3e:	60cb      	str	r3, [r1, #12]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8001e40:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8001e42:	689a      	ldr	r2, [r3, #8]
 8001e44:	f012 0f04 	tst.w	r2, #4
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8001e48:	689a      	ldr	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8001e4a:	d101      	bne.n	8001e50 <HAL_ADC_Init+0x340>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8001e4c:	0712      	lsls	r2, r2, #28
 8001e4e:	d532      	bpl.n	8001eb6 <HAL_ADC_Init+0x3a6>
    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8001e50:	68e2      	ldr	r2, [r4, #12]
 8001e52:	2a01      	cmp	r2, #1
 8001e54:	d060      	beq.n	8001f18 <HAL_ADC_Init+0x408>
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8001e56:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001e58:	f022 020f 	bic.w	r2, r2, #15
 8001e5c:	631a      	str	r2, [r3, #48]	; 0x30
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8001e5e:	6d63      	ldr	r3, [r4, #84]	; 0x54
}
 8001e60:	4628      	mov	r0, r5
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8001e62:	f023 0303 	bic.w	r3, r3, #3
 8001e66:	f043 0301 	orr.w	r3, r3, #1
 8001e6a:	6563      	str	r3, [r4, #84]	; 0x54
}
 8001e6c:	b003      	add	sp, #12
 8001e6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8001e70:	2500      	movs	r5, #0
 8001e72:	e72e      	b.n	8001cd2 <HAL_ADC_Init+0x1c2>
    return HAL_ERROR;
 8001e74:	2501      	movs	r5, #1
}
 8001e76:	4628      	mov	r0, r5
 8001e78:	b003      	add	sp, #12
 8001e7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    HAL_ADC_MspInit(hadc);
 8001e7c:	4620      	mov	r0, r4
 8001e7e:	f00e fead 	bl	8010bdc <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8001e82:	65a5      	str	r5, [r4, #88]	; 0x58
    hadc->Lock = HAL_UNLOCKED;
 8001e84:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
 8001e88:	e6f4      	b.n	8001c74 <HAL_ADC_Init+0x164>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
 8001e8a:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
 8001e8e:	4864      	ldr	r0, [pc, #400]	; (8002020 <HAL_ADC_Init+0x510>)
 8001e90:	f011 fd1e 	bl	80138d0 <assert_failed>
 8001e94:	e681      	b.n	8001b9a <HAL_ADC_Init+0x8a>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8001e96:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
 8001e9a:	4861      	ldr	r0, [pc, #388]	; (8002020 <HAL_ADC_Init+0x510>)
 8001e9c:	f011 fd18 	bl	80138d0 <assert_failed>
 8001ea0:	e649      	b.n	8001b36 <HAL_ADC_Init+0x26>
    assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
 8001ea2:	f44f 71db 	mov.w	r1, #438	; 0x1b6
 8001ea6:	485e      	ldr	r0, [pc, #376]	; (8002020 <HAL_ADC_Init+0x510>)
 8001ea8:	f011 fd12 	bl	80138d0 <assert_failed>
 8001eac:	7f23      	ldrb	r3, [r4, #28]
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001eae:	2b01      	cmp	r3, #1
 8001eb0:	f47f aedc 	bne.w	8001c6c <HAL_ADC_Init+0x15c>
 8001eb4:	e724      	b.n	8001d00 <HAL_ADC_Init+0x1f0>
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8001eb6:	68d9      	ldr	r1, [r3, #12]
 8001eb8:	4a5a      	ldr	r2, [pc, #360]	; (8002024 <HAL_ADC_Init+0x514>)
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8001eba:	7d20      	ldrb	r0, [r4, #20]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8001ebc:	400a      	ands	r2, r1
 8001ebe:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8001ec0:	ea42 3280 	orr.w	r2, r2, r0, lsl #14
 8001ec4:	430a      	orrs	r2, r1
 8001ec6:	60da      	str	r2, [r3, #12]
      if (hadc->Init.OversamplingMode == ENABLE)
 8001ec8:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8001ecc:	2b01      	cmp	r3, #1
 8001ece:	d047      	beq.n	8001f60 <HAL_ADC_Init+0x450>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8001ed0:	6822      	ldr	r2, [r4, #0]
 8001ed2:	6913      	ldr	r3, [r2, #16]
 8001ed4:	f023 0301 	bic.w	r3, r3, #1
 8001ed8:	6113      	str	r3, [r2, #16]
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
 8001eda:	6822      	ldr	r2, [r4, #0]
      ADC_ConfigureBoostMode(hadc);
 8001edc:	4620      	mov	r0, r4
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
 8001ede:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8001ee0:	6913      	ldr	r3, [r2, #16]
 8001ee2:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8001ee6:	430b      	orrs	r3, r1
 8001ee8:	6113      	str	r3, [r2, #16]
      ADC_ConfigureBoostMode(hadc);
 8001eea:	f7ff fd5d 	bl	80019a8 <ADC_ConfigureBoostMode>
 8001eee:	6823      	ldr	r3, [r4, #0]
 8001ef0:	e7ae      	b.n	8001e50 <HAL_ADC_Init+0x340>
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
 8001ef2:	f240 11b5 	movw	r1, #437	; 0x1b5
 8001ef6:	484a      	ldr	r0, [pc, #296]	; (8002020 <HAL_ADC_Init+0x510>)
 8001ef8:	f011 fcea 	bl	80138d0 <assert_failed>
 8001efc:	e6fa      	b.n	8001cf4 <HAL_ADC_Init+0x1e4>
  assert_param(IS_ADC_CONVERSIONDATAMGT(hadc->Init.ConversionDataManagement));
 8001efe:	f240 11ad 	movw	r1, #429	; 0x1ad
 8001f02:	4847      	ldr	r0, [pc, #284]	; (8002020 <HAL_ADC_Init+0x510>)
 8001f04:	f011 fce4 	bl	80138d0 <assert_failed>
 8001f08:	e694      	b.n	8001c34 <HAL_ADC_Init+0x124>
 8001f0a:	7d62      	ldrb	r2, [r4, #21]
 8001f0c:	7f20      	ldrb	r0, [r4, #28]
 8001f0e:	0351      	lsls	r1, r2, #13
 8001f10:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8001f12:	68a2      	ldr	r2, [r4, #8]
 8001f14:	0403      	lsls	r3, r0, #16
 8001f16:	e77d      	b.n	8001e14 <HAL_ADC_Init+0x304>
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8001f18:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001f1a:	69a2      	ldr	r2, [r4, #24]
 8001f1c:	f021 010f 	bic.w	r1, r1, #15
 8001f20:	3a01      	subs	r2, #1
 8001f22:	430a      	orrs	r2, r1
 8001f24:	631a      	str	r2, [r3, #48]	; 0x30
 8001f26:	e79a      	b.n	8001e5e <HAL_ADC_Init+0x34e>
      assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
 8001f28:	f44f 71dd 	mov.w	r1, #442	; 0x1ba
 8001f2c:	483c      	ldr	r0, [pc, #240]	; (8002020 <HAL_ADC_Init+0x510>)
 8001f2e:	f011 fccf 	bl	80138d0 <assert_failed>
 8001f32:	e698      	b.n	8001c66 <HAL_ADC_Init+0x156>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8001f34:	4a36      	ldr	r2, [pc, #216]	; (8002010 <HAL_ADC_Init+0x500>)
 8001f36:	4b3c      	ldr	r3, [pc, #240]	; (8002028 <HAL_ADC_Init+0x518>)
 8001f38:	6892      	ldr	r2, [r2, #8]
 8001f3a:	689b      	ldr	r3, [r3, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8001f3c:	4313      	orrs	r3, r2
 8001f3e:	07d8      	lsls	r0, r3, #31
 8001f40:	f53f af56 	bmi.w	8001df0 <HAL_ADC_Init+0x2e0>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8001f44:	4a39      	ldr	r2, [pc, #228]	; (800202c <HAL_ADC_Init+0x51c>)
 8001f46:	e74d      	b.n	8001de4 <HAL_ADC_Init+0x2d4>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
 8001f48:	f240 11a7 	movw	r1, #423	; 0x1a7
 8001f4c:	4834      	ldr	r0, [pc, #208]	; (8002020 <HAL_ADC_Init+0x510>)
 8001f4e:	f011 fcbf 	bl	80138d0 <assert_failed>
 8001f52:	e619      	b.n	8001b88 <HAL_ADC_Init+0x78>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
 8001f54:	f44f 71d6 	mov.w	r1, #428	; 0x1ac
 8001f58:	4831      	ldr	r0, [pc, #196]	; (8002020 <HAL_ADC_Init+0x510>)
 8001f5a:	f011 fcb9 	bl	80138d0 <assert_failed>
 8001f5e:	e665      	b.n	8001c2c <HAL_ADC_Init+0x11c>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
 8001f60:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001f62:	3b01      	subs	r3, #1
 8001f64:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8001f68:	d245      	bcs.n	8001ff6 <HAL_ADC_Init+0x4e6>
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
 8001f6a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001f6c:	f032 0160 	bics.w	r1, r2, #96	; 0x60
 8001f70:	bf14      	ite	ne
 8001f72:	2301      	movne	r3, #1
 8001f74:	2300      	moveq	r3, #0
 8001f76:	2980      	cmp	r1, #128	; 0x80
 8001f78:	bf0c      	ite	eq
 8001f7a:	2300      	moveq	r3, #0
 8001f7c:	f003 0301 	andne.w	r3, r3, #1
 8001f80:	b113      	cbz	r3, 8001f88 <HAL_ADC_Init+0x478>
 8001f82:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8001f86:	d13c      	bne.n	8002002 <HAL_ADC_Init+0x4f2>
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
 8001f88:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001f8a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 8001f8e:	d12c      	bne.n	8001fea <HAL_ADC_Init+0x4da>
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
 8001f90:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001f92:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001f96:	2b01      	cmp	r3, #1
 8001f98:	d121      	bne.n	8001fde <HAL_ADC_Init+0x4ce>
      if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
 8001f9a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001f9c:	6c66      	ldr	r6, [r4, #68]	; 0x44
 8001f9e:	b10b      	cbz	r3, 8001fa4 <HAL_ADC_Init+0x494>
            || (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE))
 8001fa0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001fa2:	b933      	cbnz	r3, 8001fb2 <HAL_ADC_Init+0x4a2>
          assert_param((hadc->Init.Oversampling.TriggeredMode == ADC_TRIGGEREDMODE_SINGLE_TRIGGER));
 8001fa4:	b12e      	cbz	r6, 8001fb2 <HAL_ADC_Init+0x4a2>
 8001fa6:	f240 218b 	movw	r1, #651	; 0x28b
 8001faa:	481d      	ldr	r0, [pc, #116]	; (8002020 <HAL_ADC_Init+0x510>)
 8001fac:	f011 fc90 	bl	80138d0 <assert_failed>
 8001fb0:	6c66      	ldr	r6, [r4, #68]	; 0x44
       MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
 8001fb2:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8001fb4:	6820      	ldr	r0, [r4, #0]
 8001fb6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001fb8:	6907      	ldr	r7, [r0, #16]
 8001fba:	4313      	orrs	r3, r2
 8001fbc:	491c      	ldr	r1, [pc, #112]	; (8002030 <HAL_ADC_Init+0x520>)
 8001fbe:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001fc0:	4039      	ands	r1, r7
 8001fc2:	f043 0301 	orr.w	r3, r3, #1
 8001fc6:	3a01      	subs	r2, #1
 8001fc8:	430b      	orrs	r3, r1
 8001fca:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001fce:	4333      	orrs	r3, r6
 8001fd0:	6103      	str	r3, [r0, #16]
 8001fd2:	e782      	b.n	8001eda <HAL_ADC_Init+0x3ca>
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8001fd4:	f046 021c 	orr.w	r2, r6, #28
 8001fd8:	430a      	orrs	r2, r1
 8001fda:	431a      	orrs	r2, r3
 8001fdc:	e71d      	b.n	8001e1a <HAL_ADC_Init+0x30a>
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
 8001fde:	f240 2185 	movw	r1, #645	; 0x285
 8001fe2:	480f      	ldr	r0, [pc, #60]	; (8002020 <HAL_ADC_Init+0x510>)
 8001fe4:	f011 fc74 	bl	80138d0 <assert_failed>
 8001fe8:	e7d7      	b.n	8001f9a <HAL_ADC_Init+0x48a>
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
 8001fea:	f44f 7121 	mov.w	r1, #644	; 0x284
 8001fee:	480c      	ldr	r0, [pc, #48]	; (8002020 <HAL_ADC_Init+0x510>)
 8001ff0:	f011 fc6e 	bl	80138d0 <assert_failed>
 8001ff4:	e7cc      	b.n	8001f90 <HAL_ADC_Init+0x480>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
 8001ff6:	f240 2182 	movw	r1, #642	; 0x282
 8001ffa:	4809      	ldr	r0, [pc, #36]	; (8002020 <HAL_ADC_Init+0x510>)
 8001ffc:	f011 fc68 	bl	80138d0 <assert_failed>
 8002000:	e7b3      	b.n	8001f6a <HAL_ADC_Init+0x45a>
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
 8002002:	f240 2183 	movw	r1, #643	; 0x283
 8002006:	4806      	ldr	r0, [pc, #24]	; (8002020 <HAL_ADC_Init+0x510>)
 8002008:	f011 fc62 	bl	80138d0 <assert_failed>
 800200c:	e7bc      	b.n	8001f88 <HAL_ADC_Init+0x478>
 800200e:	bf00      	nop
 8002010:	40022000 	.word	0x40022000
 8002014:	58026000 	.word	0x58026000
 8002018:	58026300 	.word	0x58026300
 800201c:	fff0c003 	.word	0xfff0c003
 8002020:	08029080 	.word	0x08029080
 8002024:	ffffbffc 	.word	0xffffbffc
 8002028:	40022100 	.word	0x40022100
 800202c:	40022300 	.word	0x40022300
 8002030:	fc00f81e 	.word	0xfc00f81e

08002034 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t CalibrationMode, uint32_t SingleDiff)
{
 8002034:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002036:	4604      	mov	r4, r0
 8002038:	4616      	mov	r6, r2
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 800203a:	4835      	ldr	r0, [pc, #212]	; (8002110 <HAL_ADCEx_Calibration_Start+0xdc>)
{
 800203c:	b083      	sub	sp, #12
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 800203e:	6823      	ldr	r3, [r4, #0]
  __IO uint32_t wait_loop_index = 0UL;
 8002040:	2700      	movs	r7, #0
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8002042:	4a34      	ldr	r2, [pc, #208]	; (8002114 <HAL_ADCEx_Calibration_Start+0xe0>)
{
 8002044:	460d      	mov	r5, r1
  __IO uint32_t wait_loop_index = 0UL;
 8002046:	9701      	str	r7, [sp, #4]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8002048:	4283      	cmp	r3, r0
 800204a:	bf18      	it	ne
 800204c:	4293      	cmpne	r3, r2
 800204e:	d002      	beq.n	8002056 <HAL_ADCEx_Calibration_Start+0x22>
 8002050:	4a31      	ldr	r2, [pc, #196]	; (8002118 <HAL_ADCEx_Calibration_Start+0xe4>)
 8002052:	4293      	cmp	r3, r2
 8002054:	d14b      	bne.n	80020ee <HAL_ADCEx_Calibration_Start+0xba>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
 8002056:	f240 73ff 	movw	r3, #2047	; 0x7ff
 800205a:	429e      	cmp	r6, r3
 800205c:	d002      	beq.n	8002064 <HAL_ADCEx_Calibration_Start+0x30>
 800205e:	4b2f      	ldr	r3, [pc, #188]	; (800211c <HAL_ADCEx_Calibration_Start+0xe8>)
 8002060:	429e      	cmp	r6, r3
 8002062:	d139      	bne.n	80020d8 <HAL_ADCEx_Calibration_Start+0xa4>

  /* Process locked */
  __HAL_LOCK(hadc);
 8002064:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 8002068:	2b01      	cmp	r3, #1
 800206a:	d03d      	beq.n	80020e8 <HAL_ADCEx_Calibration_Start+0xb4>
 800206c:	2301      	movs	r3, #1

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 800206e:	4620      	mov	r0, r4
  __HAL_LOCK(hadc);
 8002070:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  tmp_hal_status = ADC_Disable(hadc);
 8002074:	f7ff fc64 	bl	8001940 <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
 8002078:	bb28      	cbnz	r0, 80020c6 <HAL_ADCEx_Calibration_Start+0x92>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800207a:	6d61      	ldr	r1, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
 800207c:	f405 3380 	and.w	r3, r5, #65536	; 0x10000
 8002080:	4a27      	ldr	r2, [pc, #156]	; (8002120 <HAL_ADCEx_Calibration_Start+0xec>)
 8002082:	f006 4680 	and.w	r6, r6, #1073741824	; 0x40000000
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);

    /* Start ADC calibration in mode single-ended or differential */
    LL_ADC_StartCalibration(hadc->Instance , CalibrationMode, SingleDiff );
 8002086:	6827      	ldr	r7, [r4, #0]
 8002088:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    ADC_STATE_CLR_SET(hadc->State,
 800208c:	400a      	ands	r2, r1
 800208e:	4d25      	ldr	r5, [pc, #148]	; (8002124 <HAL_ADCEx_Calibration_Start+0xf0>)
 8002090:	4333      	orrs	r3, r6

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 8002092:	4925      	ldr	r1, [pc, #148]	; (8002128 <HAL_ADCEx_Calibration_Start+0xf4>)
    ADC_STATE_CLR_SET(hadc->State,
 8002094:	f042 0202 	orr.w	r2, r2, #2
 8002098:	6562      	str	r2, [r4, #84]	; 0x54
 800209a:	68ba      	ldr	r2, [r7, #8]
 800209c:	4015      	ands	r5, r2
 800209e:	432b      	orrs	r3, r5
 80020a0:	60bb      	str	r3, [r7, #8]
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
 80020a2:	6822      	ldr	r2, [r4, #0]
 80020a4:	e005      	b.n	80020b2 <HAL_ADCEx_Calibration_Start+0x7e>
      wait_loop_index++;
 80020a6:	9b01      	ldr	r3, [sp, #4]
 80020a8:	3301      	adds	r3, #1
 80020aa:	9301      	str	r3, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 80020ac:	9b01      	ldr	r3, [sp, #4]
 80020ae:	428b      	cmp	r3, r1
 80020b0:	d822      	bhi.n	80020f8 <HAL_ADCEx_Calibration_Start+0xc4>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 80020b2:	6893      	ldr	r3, [r2, #8]
 80020b4:	2b00      	cmp	r3, #0
 80020b6:	dbf6      	blt.n	80020a6 <HAL_ADCEx_Calibration_Start+0x72>
        return HAL_ERROR;
      }
    }

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80020b8:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80020ba:	f023 0303 	bic.w	r3, r3, #3
 80020be:	f043 0301 	orr.w	r3, r3, #1
 80020c2:	6563      	str	r3, [r4, #84]	; 0x54
 80020c4:	e003      	b.n	80020ce <HAL_ADCEx_Calibration_Start+0x9a>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80020c6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80020c8:	f043 0310 	orr.w	r3, r3, #16
 80020cc:	6563      	str	r3, [r4, #84]	; 0x54
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80020ce:	2300      	movs	r3, #0
 80020d0:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50

  /* Return function status */
  return tmp_hal_status;
}
 80020d4:	b003      	add	sp, #12
 80020d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
 80020d8:	218f      	movs	r1, #143	; 0x8f
 80020da:	4814      	ldr	r0, [pc, #80]	; (800212c <HAL_ADCEx_Calibration_Start+0xf8>)
 80020dc:	f011 fbf8 	bl	80138d0 <assert_failed>
  __HAL_LOCK(hadc);
 80020e0:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 80020e4:	2b01      	cmp	r3, #1
 80020e6:	d1c1      	bne.n	800206c <HAL_ADCEx_Calibration_Start+0x38>
 80020e8:	2002      	movs	r0, #2
}
 80020ea:	b003      	add	sp, #12
 80020ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80020ee:	218e      	movs	r1, #142	; 0x8e
 80020f0:	480e      	ldr	r0, [pc, #56]	; (800212c <HAL_ADCEx_Calibration_Start+0xf8>)
 80020f2:	f011 fbed 	bl	80138d0 <assert_failed>
 80020f6:	e7ae      	b.n	8002056 <HAL_ADCEx_Calibration_Start+0x22>
        ADC_STATE_CLR_SET(hadc->State,
 80020f8:	6d63      	ldr	r3, [r4, #84]	; 0x54
        __HAL_UNLOCK(hadc);
 80020fa:	2200      	movs	r2, #0
        return HAL_ERROR;
 80020fc:	2001      	movs	r0, #1
        ADC_STATE_CLR_SET(hadc->State,
 80020fe:	f023 0312 	bic.w	r3, r3, #18
        __HAL_UNLOCK(hadc);
 8002102:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
        ADC_STATE_CLR_SET(hadc->State,
 8002106:	f043 0310 	orr.w	r3, r3, #16
 800210a:	6563      	str	r3, [r4, #84]	; 0x54
}
 800210c:	b003      	add	sp, #12
 800210e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002110:	40022000 	.word	0x40022000
 8002114:	40022100 	.word	0x40022100
 8002118:	58026000 	.word	0x58026000
 800211c:	47ff0000 	.word	0x47ff0000
 8002120:	ffffeefd 	.word	0xffffeefd
 8002124:	3ffeffc0 	.word	0x3ffeffc0
 8002128:	25c3f7ff 	.word	0x25c3f7ff
 800212c:	080290b8 	.word	0x080290b8

08002130 <HAL_ADCEx_InjectedConvCpltCallback>:
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_InjectedConvCpltCallback must be implemented in the user file.
  */
}
 8002130:	4770      	bx	lr
 8002132:	bf00      	nop

08002134 <HAL_ADCEx_InjectedQueueOverflowCallback>:
 8002134:	4770      	bx	lr
 8002136:	bf00      	nop

08002138 <HAL_ADCEx_LevelOutOfWindow2Callback>:
 8002138:	4770      	bx	lr
 800213a:	bf00      	nop

0800213c <HAL_ADCEx_LevelOutOfWindow3Callback>:
 800213c:	4770      	bx	lr
 800213e:	bf00      	nop

08002140 <HAL_ADCEx_EndOfSamplingCallback>:
 8002140:	4770      	bx	lr
 8002142:	bf00      	nop

08002144 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param multimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, ADC_MultiModeTypeDef *multimode)
{
 8002144:	b570      	push	{r4, r5, r6, lr}
  ADC_Common_TypeDef *tmpADC_Common;
  ADC_HandleTypeDef  tmphadcSlave;
  uint32_t tmphadcSlave_conversion_on_going;

  /* Check the parameters */
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
 8002146:	4b58      	ldr	r3, [pc, #352]	; (80022a8 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
{
 8002148:	4604      	mov	r4, r0
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
 800214a:	6802      	ldr	r2, [r0, #0]
{
 800214c:	460d      	mov	r5, r1
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
 800214e:	429a      	cmp	r2, r3
 8002150:	d004      	beq.n	800215c <HAL_ADCEx_MultiModeConfigChannel+0x18>
 8002152:	f640 01bd 	movw	r1, #2237	; 0x8bd
 8002156:	4855      	ldr	r0, [pc, #340]	; (80022ac <HAL_ADCEx_MultiModeConfigChannel+0x168>)
 8002158:	f011 fbba 	bl	80138d0 <assert_failed>
  assert_param(IS_ADC_MULTIMODE(multimode->Mode));
 800215c:	682b      	ldr	r3, [r5, #0]
 800215e:	2b09      	cmp	r3, #9
 8002160:	d933      	bls.n	80021ca <HAL_ADCEx_MultiModeConfigChannel+0x86>
 8002162:	f640 01be 	movw	r1, #2238	; 0x8be
 8002166:	4851      	ldr	r0, [pc, #324]	; (80022ac <HAL_ADCEx_MultiModeConfigChannel+0x168>)
 8002168:	f011 fbb2 	bl	80138d0 <assert_failed>
 800216c:	682b      	ldr	r3, [r5, #0]
  if (multimode->Mode != ADC_MODE_INDEPENDENT)
 800216e:	b1cb      	cbz	r3, 80021a4 <HAL_ADCEx_MultiModeConfigChannel+0x60>
  {
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
 8002170:	686b      	ldr	r3, [r5, #4]
 8002172:	f433 4200 	bics.w	r2, r3, #32768	; 0x8000
 8002176:	d002      	beq.n	800217e <HAL_ADCEx_MultiModeConfigChannel+0x3a>
 8002178:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800217c:	d15c      	bne.n	8002238 <HAL_ADCEx_MultiModeConfigChannel+0xf4>
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
 800217e:	68ab      	ldr	r3, [r5, #8]
 8002180:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8002184:	bf18      	it	ne
 8002186:	f5b3 6fe0 	cmpne.w	r3, #1792	; 0x700
 800218a:	bf14      	ite	ne
 800218c:	2201      	movne	r2, #1
 800218e:	2200      	moveq	r2, #0
 8002190:	f433 7140 	bics.w	r1, r3, #768	; 0x300
 8002194:	bf08      	it	eq
 8002196:	2200      	moveq	r2, #0
 8002198:	b122      	cbz	r2, 80021a4 <HAL_ADCEx_MultiModeConfigChannel+0x60>
 800219a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800219e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80021a2:	d179      	bne.n	8002298 <HAL_ADCEx_MultiModeConfigChannel+0x154>
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 80021a4:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 80021a8:	2b01      	cmp	r3, #1
 80021aa:	d04b      	beq.n	8002244 <HAL_ADCEx_MultiModeConfigChannel+0x100>

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 80021ac:	4a3e      	ldr	r2, [pc, #248]	; (80022a8 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
  __HAL_LOCK(hadc);
 80021ae:	2001      	movs	r0, #1
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 80021b0:	6823      	ldr	r3, [r4, #0]
  __HAL_LOCK(hadc);
 80021b2:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 80021b6:	4293      	cmp	r3, r2
 80021b8:	d00d      	beq.n	80021d6 <HAL_ADCEx_MultiModeConfigChannel+0x92>

  if (tmphadcSlave.Instance == NULL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80021ba:	6d63      	ldr	r3, [r4, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 80021bc:	2200      	movs	r2, #0
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80021be:	f043 0320 	orr.w	r3, r3, #32
    __HAL_UNLOCK(hadc);
 80021c2:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80021c6:	6563      	str	r3, [r4, #84]	; 0x54
  /* Process unlocked */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return tmp_hal_status;
}
 80021c8:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_ADC_MULTIMODE(multimode->Mode));
 80021ca:	f240 22ef 	movw	r2, #751	; 0x2ef
 80021ce:	40da      	lsrs	r2, r3
 80021d0:	07d6      	lsls	r6, r2, #31
 80021d2:	d4cc      	bmi.n	800216e <HAL_ADCEx_MultiModeConfigChannel+0x2a>
 80021d4:	e7c5      	b.n	8002162 <HAL_ADCEx_MultiModeConfigChannel+0x1e>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80021d6:	4a36      	ldr	r2, [pc, #216]	; (80022b0 <HAL_ADCEx_MultiModeConfigChannel+0x16c>)
 80021d8:	6891      	ldr	r1, [r2, #8]
 80021da:	0749      	lsls	r1, r1, #29
 80021dc:	d509      	bpl.n	80021f2 <HAL_ADCEx_MultiModeConfigChannel+0xae>
 80021de:	689b      	ldr	r3, [r3, #8]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80021e0:	6d63      	ldr	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
 80021e2:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80021e4:	f043 0320 	orr.w	r3, r3, #32
 80021e8:	6563      	str	r3, [r4, #84]	; 0x54
  __HAL_UNLOCK(hadc);
 80021ea:	2300      	movs	r3, #0
 80021ec:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
}
 80021f0:	bd70      	pop	{r4, r5, r6, pc}
 80021f2:	6899      	ldr	r1, [r3, #8]
 80021f4:	0748      	lsls	r0, r1, #29
 80021f6:	d4f3      	bmi.n	80021e0 <HAL_ADCEx_MultiModeConfigChannel+0x9c>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80021f8:	6829      	ldr	r1, [r5, #0]
    MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, multimode->DualModeData);
 80021fa:	482e      	ldr	r0, [pc, #184]	; (80022b4 <HAL_ADCEx_MultiModeConfigChannel+0x170>)
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80021fc:	b321      	cbz	r1, 8002248 <HAL_ADCEx_MultiModeConfigChannel+0x104>
    MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, multimode->DualModeData);
 80021fe:	6881      	ldr	r1, [r0, #8]
 8002200:	686e      	ldr	r6, [r5, #4]
 8002202:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
 8002206:	4331      	orrs	r1, r6
 8002208:	6081      	str	r1, [r0, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 800220a:	6821      	ldr	r1, [r4, #0]
 800220c:	4299      	cmp	r1, r3
 800220e:	d03a      	beq.n	8002286 <HAL_ADCEx_MultiModeConfigChannel+0x142>
 8002210:	4291      	cmp	r1, r2
 8002212:	d038      	beq.n	8002286 <HAL_ADCEx_MultiModeConfigChannel+0x142>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8002214:	4b28      	ldr	r3, [pc, #160]	; (80022b8 <HAL_ADCEx_MultiModeConfigChannel+0x174>)
 8002216:	689b      	ldr	r3, [r3, #8]
 8002218:	43db      	mvns	r3, r3
 800221a:	f003 0301 	and.w	r3, r3, #1
 800221e:	2b00      	cmp	r3, #0
 8002220:	d040      	beq.n	80022a4 <HAL_ADCEx_MultiModeConfigChannel+0x160>
        MODIFY_REG(tmpADC_Common->CCR,
 8002222:	4924      	ldr	r1, [pc, #144]	; (80022b4 <HAL_ADCEx_MultiModeConfigChannel+0x170>)
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8002224:	2000      	movs	r0, #0
        MODIFY_REG(tmpADC_Common->CCR,
 8002226:	682b      	ldr	r3, [r5, #0]
 8002228:	688e      	ldr	r6, [r1, #8]
 800222a:	68ad      	ldr	r5, [r5, #8]
 800222c:	4a23      	ldr	r2, [pc, #140]	; (80022bc <HAL_ADCEx_MultiModeConfigChannel+0x178>)
 800222e:	432b      	orrs	r3, r5
 8002230:	4032      	ands	r2, r6
 8002232:	4313      	orrs	r3, r2
 8002234:	608b      	str	r3, [r1, #8]
 8002236:	e7d8      	b.n	80021ea <HAL_ADCEx_MultiModeConfigChannel+0xa6>
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
 8002238:	f640 01c1 	movw	r1, #2241	; 0x8c1
 800223c:	481b      	ldr	r0, [pc, #108]	; (80022ac <HAL_ADCEx_MultiModeConfigChannel+0x168>)
 800223e:	f011 fb47 	bl	80138d0 <assert_failed>
 8002242:	e79c      	b.n	800217e <HAL_ADCEx_MultiModeConfigChannel+0x3a>
  __HAL_LOCK(hadc);
 8002244:	2002      	movs	r0, #2
}
 8002246:	bd70      	pop	{r4, r5, r6, pc}
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DAMDF);
 8002248:	6881      	ldr	r1, [r0, #8]
 800224a:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
 800224e:	6081      	str	r1, [r0, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8002250:	6821      	ldr	r1, [r4, #0]
 8002252:	4299      	cmp	r1, r3
 8002254:	d00e      	beq.n	8002274 <HAL_ADCEx_MultiModeConfigChannel+0x130>
 8002256:	4291      	cmp	r1, r2
 8002258:	d00c      	beq.n	8002274 <HAL_ADCEx_MultiModeConfigChannel+0x130>
 800225a:	4b17      	ldr	r3, [pc, #92]	; (80022b8 <HAL_ADCEx_MultiModeConfigChannel+0x174>)
 800225c:	689b      	ldr	r3, [r3, #8]
 800225e:	43db      	mvns	r3, r3
 8002260:	f003 0301 	and.w	r3, r3, #1
 8002264:	b1f3      	cbz	r3, 80022a4 <HAL_ADCEx_MultiModeConfigChannel+0x160>
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 8002266:	4a13      	ldr	r2, [pc, #76]	; (80022b4 <HAL_ADCEx_MultiModeConfigChannel+0x170>)
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8002268:	2000      	movs	r0, #0
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 800226a:	4b14      	ldr	r3, [pc, #80]	; (80022bc <HAL_ADCEx_MultiModeConfigChannel+0x178>)
 800226c:	6891      	ldr	r1, [r2, #8]
 800226e:	400b      	ands	r3, r1
 8002270:	6093      	str	r3, [r2, #8]
 8002272:	e7ba      	b.n	80021ea <HAL_ADCEx_MultiModeConfigChannel+0xa6>
 8002274:	4a0c      	ldr	r2, [pc, #48]	; (80022a8 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
 8002276:	4b0e      	ldr	r3, [pc, #56]	; (80022b0 <HAL_ADCEx_MultiModeConfigChannel+0x16c>)
 8002278:	6892      	ldr	r2, [r2, #8]
 800227a:	689b      	ldr	r3, [r3, #8]
 800227c:	4313      	orrs	r3, r2
 800227e:	43db      	mvns	r3, r3
 8002280:	f003 0301 	and.w	r3, r3, #1
 8002284:	e7ee      	b.n	8002264 <HAL_ADCEx_MultiModeConfigChannel+0x120>
 8002286:	4a08      	ldr	r2, [pc, #32]	; (80022a8 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
 8002288:	4b09      	ldr	r3, [pc, #36]	; (80022b0 <HAL_ADCEx_MultiModeConfigChannel+0x16c>)
 800228a:	6892      	ldr	r2, [r2, #8]
 800228c:	689b      	ldr	r3, [r3, #8]
 800228e:	4313      	orrs	r3, r2
 8002290:	43db      	mvns	r3, r3
 8002292:	f003 0301 	and.w	r3, r3, #1
 8002296:	e7c2      	b.n	800221e <HAL_ADCEx_MultiModeConfigChannel+0xda>
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
 8002298:	f640 01c2 	movw	r1, #2242	; 0x8c2
 800229c:	4803      	ldr	r0, [pc, #12]	; (80022ac <HAL_ADCEx_MultiModeConfigChannel+0x168>)
 800229e:	f011 fb17 	bl	80138d0 <assert_failed>
 80022a2:	e77f      	b.n	80021a4 <HAL_ADCEx_MultiModeConfigChannel+0x60>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80022a4:	2000      	movs	r0, #0
 80022a6:	e7a0      	b.n	80021ea <HAL_ADCEx_MultiModeConfigChannel+0xa6>
 80022a8:	40022000 	.word	0x40022000
 80022ac:	080290b8 	.word	0x080290b8
 80022b0:	40022100 	.word	0x40022100
 80022b4:	40022300 	.word	0x40022300
 80022b8:	58026000 	.word	0x58026000
 80022bc:	fffff0e0 	.word	0xfffff0e0

080022c0 <HAL_NVIC_SetPriorityGrouping>:
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 80022c0:	1ec3      	subs	r3, r0, #3
 80022c2:	2b04      	cmp	r3, #4
{
 80022c4:	b510      	push	{r4, lr}
 80022c6:	4604      	mov	r4, r0
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 80022c8:	d903      	bls.n	80022d2 <HAL_NVIC_SetPriorityGrouping+0x12>
 80022ca:	2192      	movs	r1, #146	; 0x92
 80022cc:	4807      	ldr	r0, [pc, #28]	; (80022ec <HAL_NVIC_SetPriorityGrouping+0x2c>)
 80022ce:	f011 faff 	bl	80138d0 <assert_failed>
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80022d2:	4907      	ldr	r1, [pc, #28]	; (80022f0 <HAL_NVIC_SetPriorityGrouping+0x30>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80022d4:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80022d8:	0224      	lsls	r4, r4, #8
 80022da:	4b06      	ldr	r3, [pc, #24]	; (80022f4 <HAL_NVIC_SetPriorityGrouping+0x34>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80022dc:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80022de:	f404 64e0 	and.w	r4, r4, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80022e2:	4002      	ands	r2, r0
 80022e4:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80022e6:	431c      	orrs	r4, r3
  SCB->AIRCR =  reg_value;
 80022e8:	60cc      	str	r4, [r1, #12]

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80022ea:	bd10      	pop	{r4, pc}
 80022ec:	080290f4 	.word	0x080290f4
 80022f0:	e000ed00 	.word	0xe000ed00
 80022f4:	05fa0000 	.word	0x05fa0000

080022f8 <HAL_NVIC_SetPriority>:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 80022f8:	2a0f      	cmp	r2, #15
{
 80022fa:	b570      	push	{r4, r5, r6, lr}
 80022fc:	4616      	mov	r6, r2
 80022fe:	4605      	mov	r5, r0
 8002300:	460c      	mov	r4, r1
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 8002302:	d832      	bhi.n	800236a <HAL_NVIC_SetPriority+0x72>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 8002304:	2c0f      	cmp	r4, #15
 8002306:	d82b      	bhi.n	8002360 <HAL_NVIC_SetPriority+0x68>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8002308:	4b1a      	ldr	r3, [pc, #104]	; (8002374 <HAL_NVIC_SetPriority+0x7c>)
 800230a:	68db      	ldr	r3, [r3, #12]
 800230c:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8002310:	f1c3 0107 	rsb	r1, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002314:	1d1a      	adds	r2, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8002316:	2904      	cmp	r1, #4
 8002318:	bf28      	it	cs
 800231a:	2104      	movcs	r1, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800231c:	2a06      	cmp	r2, #6
 800231e:	d917      	bls.n	8002350 <HAL_NVIC_SetPriority+0x58>
 8002320:	3b03      	subs	r3, #3
 8002322:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002326:	409a      	lsls	r2, r3
 8002328:	ea26 0602 	bic.w	r6, r6, r2

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800232c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  if ((int32_t)(IRQn) >= 0)
 8002330:	2d00      	cmp	r5, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002332:	fa02 f201 	lsl.w	r2, r2, r1
 8002336:	ea24 0202 	bic.w	r2, r4, r2
 800233a:	fa02 f203 	lsl.w	r2, r2, r3
 800233e:	ea42 0206 	orr.w	r2, r2, r6
 8002342:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8002346:	b2d2      	uxtb	r2, r2
  if ((int32_t)(IRQn) >= 0)
 8002348:	db05      	blt.n	8002356 <HAL_NVIC_SetPriority+0x5e>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800234a:	4b0b      	ldr	r3, [pc, #44]	; (8002378 <HAL_NVIC_SetPriority+0x80>)
 800234c:	555a      	strb	r2, [r3, r5]

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800234e:	bd70      	pop	{r4, r5, r6, pc}
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002350:	2600      	movs	r6, #0
 8002352:	4633      	mov	r3, r6
 8002354:	e7ea      	b.n	800232c <HAL_NVIC_SetPriority+0x34>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002356:	f005 050f 	and.w	r5, r5, #15
 800235a:	4b08      	ldr	r3, [pc, #32]	; (800237c <HAL_NVIC_SetPriority+0x84>)
 800235c:	555a      	strb	r2, [r3, r5]
 800235e:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 8002360:	21ab      	movs	r1, #171	; 0xab
 8002362:	4807      	ldr	r0, [pc, #28]	; (8002380 <HAL_NVIC_SetPriority+0x88>)
 8002364:	f011 fab4 	bl	80138d0 <assert_failed>
 8002368:	e7ce      	b.n	8002308 <HAL_NVIC_SetPriority+0x10>
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 800236a:	21aa      	movs	r1, #170	; 0xaa
 800236c:	4804      	ldr	r0, [pc, #16]	; (8002380 <HAL_NVIC_SetPriority+0x88>)
 800236e:	f011 faaf 	bl	80138d0 <assert_failed>
 8002372:	e7c7      	b.n	8002304 <HAL_NVIC_SetPriority+0xc>
 8002374:	e000ed00 	.word	0xe000ed00
 8002378:	e000e400 	.word	0xe000e400
 800237c:	e000ed14 	.word	0xe000ed14
 8002380:	080290f4 	.word	0x080290f4

08002384 <HAL_NVIC_EnableIRQ>:
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8002384:	2800      	cmp	r0, #0
 8002386:	db08      	blt.n	800239a <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002388:	f000 011f 	and.w	r1, r0, #31
 800238c:	2301      	movs	r3, #1
 800238e:	0940      	lsrs	r0, r0, #5
 8002390:	4a04      	ldr	r2, [pc, #16]	; (80023a4 <HAL_NVIC_EnableIRQ+0x20>)
 8002392:	408b      	lsls	r3, r1
 8002394:	f842 3020 	str.w	r3, [r2, r0, lsl #2]

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8002398:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 800239a:	21be      	movs	r1, #190	; 0xbe
 800239c:	4802      	ldr	r0, [pc, #8]	; (80023a8 <HAL_NVIC_EnableIRQ+0x24>)
 800239e:	f011 ba97 	b.w	80138d0 <assert_failed>
 80023a2:	bf00      	nop
 80023a4:	e000e100 	.word	0xe000e100
 80023a8:	080290f4 	.word	0x080290f4

080023ac <HAL_NVIC_DisableIRQ>:
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 80023ac:	2800      	cmp	r0, #0
 80023ae:	db0e      	blt.n	80023ce <HAL_NVIC_DisableIRQ+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80023b0:	0943      	lsrs	r3, r0, #5
 80023b2:	2201      	movs	r2, #1
 80023b4:	f000 001f 	and.w	r0, r0, #31
 80023b8:	4907      	ldr	r1, [pc, #28]	; (80023d8 <HAL_NVIC_DisableIRQ+0x2c>)
 80023ba:	3320      	adds	r3, #32
 80023bc:	fa02 f000 	lsl.w	r0, r2, r0
 80023c0:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 80023c4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80023c8:	f3bf 8f6f 	isb	sy

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 80023cc:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 80023ce:	21ce      	movs	r1, #206	; 0xce
 80023d0:	4802      	ldr	r0, [pc, #8]	; (80023dc <HAL_NVIC_DisableIRQ+0x30>)
 80023d2:	f011 ba7d 	b.w	80138d0 <assert_failed>
 80023d6:	bf00      	nop
 80023d8:	e000e100 	.word	0xe000e100
 80023dc:	080290f4 	.word	0x080290f4

080023e0 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80023e0:	3801      	subs	r0, #1
 80023e2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80023e6:	d20d      	bcs.n	8002404 <HAL_SYSTICK_Config+0x24>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80023e8:	4b07      	ldr	r3, [pc, #28]	; (8002408 <HAL_SYSTICK_Config+0x28>)
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80023ea:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80023ec:	2107      	movs	r1, #7
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80023ee:	b430      	push	{r4, r5}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80023f0:	25f0      	movs	r5, #240	; 0xf0
 80023f2:	4c06      	ldr	r4, [pc, #24]	; (800240c <HAL_SYSTICK_Config+0x2c>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80023f4:	6058      	str	r0, [r3, #4]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80023f6:	4610      	mov	r0, r2
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80023f8:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80023fc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80023fe:	6019      	str	r1, [r3, #0]
   return SysTick_Config(TicksNumb);
}
 8002400:	bc30      	pop	{r4, r5}
 8002402:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8002404:	2001      	movs	r0, #1
 8002406:	4770      	bx	lr
 8002408:	e000e010 	.word	0xe000e010
 800240c:	e000ed00 	.word	0xe000ed00

08002410 <HAL_MPU_Disable>:
  __ASM volatile ("dmb 0xF":::"memory");
 8002410:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8002414:	4a04      	ldr	r2, [pc, #16]	; (8002428 <HAL_MPU_Disable+0x18>)

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 8002416:	2000      	movs	r0, #0
 8002418:	4904      	ldr	r1, [pc, #16]	; (800242c <HAL_MPU_Disable+0x1c>)
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800241a:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800241c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8002420:	6253      	str	r3, [r2, #36]	; 0x24
  MPU->CTRL = 0;
 8002422:	6048      	str	r0, [r1, #4]
}
 8002424:	4770      	bx	lr
 8002426:	bf00      	nop
 8002428:	e000ed00 	.word	0xe000ed00
 800242c:	e000ed90 	.word	0xe000ed90

08002430 <HAL_MPU_Enable>:
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 8002430:	4a06      	ldr	r2, [pc, #24]	; (800244c <HAL_MPU_Enable+0x1c>)
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 8002432:	f040 0001 	orr.w	r0, r0, #1
 8002436:	4b06      	ldr	r3, [pc, #24]	; (8002450 <HAL_MPU_Enable+0x20>)
 8002438:	6058      	str	r0, [r3, #4]
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 800243a:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800243c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002440:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 8002442:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8002446:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 800244a:	4770      	bx	lr
 800244c:	e000ed00 	.word	0xe000ed00
 8002450:	e000ed90 	.word	0xe000ed90

08002454 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 8002454:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 8002456:	7843      	ldrb	r3, [r0, #1]
{
 8002458:	4604      	mov	r4, r0
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 800245a:	2b0f      	cmp	r3, #15
 800245c:	d86f      	bhi.n	800253e <HAL_MPU_ConfigRegion+0xea>
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
 800245e:	7823      	ldrb	r3, [r4, #0]
 8002460:	2b01      	cmp	r3, #1
 8002462:	d904      	bls.n	800246e <HAL_MPU_ConfigRegion+0x1a>
 8002464:	f44f 7197 	mov.w	r1, #302	; 0x12e
 8002468:	4849      	ldr	r0, [pc, #292]	; (8002590 <HAL_MPU_ConfigRegion+0x13c>)
 800246a:	f011 fa31 	bl	80138d0 <assert_failed>

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 800246e:	7862      	ldrb	r2, [r4, #1]
 8002470:	4b48      	ldr	r3, [pc, #288]	; (8002594 <HAL_MPU_ConfigRegion+0x140>)
 8002472:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
 8002474:	7822      	ldrb	r2, [r4, #0]
 8002476:	2a00      	cmp	r2, #0
 8002478:	d039      	beq.n	80024ee <HAL_MPU_ConfigRegion+0x9a>
  {
    /* Check the parameters */
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
 800247a:	7b23      	ldrb	r3, [r4, #12]
 800247c:	2b01      	cmp	r3, #1
 800247e:	d839      	bhi.n	80024f4 <HAL_MPU_ConfigRegion+0xa0>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 8002480:	7ae3      	ldrb	r3, [r4, #11]
 8002482:	1f5a      	subs	r2, r3, #5
 8002484:	2a01      	cmp	r2, #1
 8002486:	d901      	bls.n	800248c <HAL_MPU_ConfigRegion+0x38>
 8002488:	2b03      	cmp	r3, #3
 800248a:	d86d      	bhi.n	8002568 <HAL_MPU_ConfigRegion+0x114>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 800248c:	7aa3      	ldrb	r3, [r4, #10]
 800248e:	2b02      	cmp	r3, #2
 8002490:	d861      	bhi.n	8002556 <HAL_MPU_ConfigRegion+0x102>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 8002492:	7b63      	ldrb	r3, [r4, #13]
 8002494:	2b01      	cmp	r3, #1
 8002496:	d849      	bhi.n	800252c <HAL_MPU_ConfigRegion+0xd8>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 8002498:	7ba3      	ldrb	r3, [r4, #14]
 800249a:	2b01      	cmp	r3, #1
 800249c:	d83d      	bhi.n	800251a <HAL_MPU_ConfigRegion+0xc6>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 800249e:	7be3      	ldrb	r3, [r4, #15]
 80024a0:	2b01      	cmp	r3, #1
 80024a2:	d831      	bhi.n	8002508 <HAL_MPU_ConfigRegion+0xb4>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 80024a4:	7a63      	ldrb	r3, [r4, #9]
 80024a6:	2bff      	cmp	r3, #255	; 0xff
 80024a8:	d067      	beq.n	800257a <HAL_MPU_ConfigRegion+0x126>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 80024aa:	7a23      	ldrb	r3, [r4, #8]
 80024ac:	3b04      	subs	r3, #4
 80024ae:	2b1b      	cmp	r3, #27
 80024b0:	d84b      	bhi.n	800254a <HAL_MPU_ConfigRegion+0xf6>

    MPU->RBAR = MPU_Init->BaseAddress;
 80024b2:	6863      	ldr	r3, [r4, #4]
 80024b4:	4a37      	ldr	r2, [pc, #220]	; (8002594 <HAL_MPU_ConfigRegion+0x140>)
 80024b6:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 80024b8:	7ae3      	ldrb	r3, [r4, #11]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80024ba:	7b21      	ldrb	r1, [r4, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 80024bc:	061b      	lsls	r3, r3, #24
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 80024be:	7825      	ldrb	r5, [r4, #0]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 80024c0:	7aa0      	ldrb	r0, [r4, #10]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80024c2:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 80024c6:	7b61      	ldrb	r1, [r4, #13]
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 80024c8:	7ba6      	ldrb	r6, [r4, #14]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80024ca:	432b      	orrs	r3, r5
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 80024cc:	7be5      	ldrb	r5, [r4, #15]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80024ce:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 80024d2:	7a60      	ldrb	r0, [r4, #9]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80024d4:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 80024d8:	7a21      	ldrb	r1, [r4, #8]
 80024da:	ea43 4346 	orr.w	r3, r3, r6, lsl #17
 80024de:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
 80024e2:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80024e6:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80024ea:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
 80024ec:	bd70      	pop	{r4, r5, r6, pc}
    MPU->RBAR = 0x00;
 80024ee:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
 80024f0:	611a      	str	r2, [r3, #16]
}
 80024f2:	bd70      	pop	{r4, r5, r6, pc}
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
 80024f4:	f44f 719b 	mov.w	r1, #310	; 0x136
 80024f8:	4825      	ldr	r0, [pc, #148]	; (8002590 <HAL_MPU_ConfigRegion+0x13c>)
 80024fa:	f011 f9e9 	bl	80138d0 <assert_failed>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 80024fe:	7ae3      	ldrb	r3, [r4, #11]
 8002500:	1f5a      	subs	r2, r3, #5
 8002502:	2a01      	cmp	r2, #1
 8002504:	d8c0      	bhi.n	8002488 <HAL_MPU_ConfigRegion+0x34>
 8002506:	e7c1      	b.n	800248c <HAL_MPU_ConfigRegion+0x38>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 8002508:	f240 113b 	movw	r1, #315	; 0x13b
 800250c:	4820      	ldr	r0, [pc, #128]	; (8002590 <HAL_MPU_ConfigRegion+0x13c>)
 800250e:	f011 f9df 	bl	80138d0 <assert_failed>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 8002512:	7a63      	ldrb	r3, [r4, #9]
 8002514:	2bff      	cmp	r3, #255	; 0xff
 8002516:	d1c8      	bne.n	80024aa <HAL_MPU_ConfigRegion+0x56>
 8002518:	e02f      	b.n	800257a <HAL_MPU_ConfigRegion+0x126>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 800251a:	f44f 719d 	mov.w	r1, #314	; 0x13a
 800251e:	481c      	ldr	r0, [pc, #112]	; (8002590 <HAL_MPU_ConfigRegion+0x13c>)
 8002520:	f011 f9d6 	bl	80138d0 <assert_failed>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 8002524:	7be3      	ldrb	r3, [r4, #15]
 8002526:	2b01      	cmp	r3, #1
 8002528:	d9bc      	bls.n	80024a4 <HAL_MPU_ConfigRegion+0x50>
 800252a:	e7ed      	b.n	8002508 <HAL_MPU_ConfigRegion+0xb4>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 800252c:	f240 1139 	movw	r1, #313	; 0x139
 8002530:	4817      	ldr	r0, [pc, #92]	; (8002590 <HAL_MPU_ConfigRegion+0x13c>)
 8002532:	f011 f9cd 	bl	80138d0 <assert_failed>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 8002536:	7ba3      	ldrb	r3, [r4, #14]
 8002538:	2b01      	cmp	r3, #1
 800253a:	d9b0      	bls.n	800249e <HAL_MPU_ConfigRegion+0x4a>
 800253c:	e7ed      	b.n	800251a <HAL_MPU_ConfigRegion+0xc6>
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 800253e:	f240 112d 	movw	r1, #301	; 0x12d
 8002542:	4813      	ldr	r0, [pc, #76]	; (8002590 <HAL_MPU_ConfigRegion+0x13c>)
 8002544:	f011 f9c4 	bl	80138d0 <assert_failed>
 8002548:	e789      	b.n	800245e <HAL_MPU_ConfigRegion+0xa>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 800254a:	f240 113d 	movw	r1, #317	; 0x13d
 800254e:	4810      	ldr	r0, [pc, #64]	; (8002590 <HAL_MPU_ConfigRegion+0x13c>)
 8002550:	f011 f9be 	bl	80138d0 <assert_failed>
 8002554:	e7ad      	b.n	80024b2 <HAL_MPU_ConfigRegion+0x5e>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 8002556:	f44f 719c 	mov.w	r1, #312	; 0x138
 800255a:	480d      	ldr	r0, [pc, #52]	; (8002590 <HAL_MPU_ConfigRegion+0x13c>)
 800255c:	f011 f9b8 	bl	80138d0 <assert_failed>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 8002560:	7b63      	ldrb	r3, [r4, #13]
 8002562:	2b01      	cmp	r3, #1
 8002564:	d998      	bls.n	8002498 <HAL_MPU_ConfigRegion+0x44>
 8002566:	e7e1      	b.n	800252c <HAL_MPU_ConfigRegion+0xd8>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 8002568:	f240 1137 	movw	r1, #311	; 0x137
 800256c:	4808      	ldr	r0, [pc, #32]	; (8002590 <HAL_MPU_ConfigRegion+0x13c>)
 800256e:	f011 f9af 	bl	80138d0 <assert_failed>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 8002572:	7aa3      	ldrb	r3, [r4, #10]
 8002574:	2b02      	cmp	r3, #2
 8002576:	d98c      	bls.n	8002492 <HAL_MPU_ConfigRegion+0x3e>
 8002578:	e7ed      	b.n	8002556 <HAL_MPU_ConfigRegion+0x102>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 800257a:	f44f 719e 	mov.w	r1, #316	; 0x13c
 800257e:	4804      	ldr	r0, [pc, #16]	; (8002590 <HAL_MPU_ConfigRegion+0x13c>)
 8002580:	f011 f9a6 	bl	80138d0 <assert_failed>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 8002584:	7a23      	ldrb	r3, [r4, #8]
 8002586:	3b04      	subs	r3, #4
 8002588:	2b1b      	cmp	r3, #27
 800258a:	d992      	bls.n	80024b2 <HAL_MPU_ConfigRegion+0x5e>
 800258c:	e7dd      	b.n	800254a <HAL_MPU_ConfigRegion+0xf6>
 800258e:	bf00      	nop
 8002590:	080290f4 	.word	0x080290f4
 8002594:	e000ed90 	.word	0xe000ed90

08002598 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8002598:	4b35      	ldr	r3, [pc, #212]	; (8002670 <DMA_CalcBaseAndBitshift+0xd8>)
{
 800259a:	4601      	mov	r1, r0
 800259c:	b430      	push	{r4, r5}
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800259e:	4c35      	ldr	r4, [pc, #212]	; (8002674 <DMA_CalcBaseAndBitshift+0xdc>)
 80025a0:	6802      	ldr	r2, [r0, #0]
 80025a2:	4835      	ldr	r0, [pc, #212]	; (8002678 <DMA_CalcBaseAndBitshift+0xe0>)
 80025a4:	42a2      	cmp	r2, r4
 80025a6:	bf18      	it	ne
 80025a8:	429a      	cmpne	r2, r3
 80025aa:	4d34      	ldr	r5, [pc, #208]	; (800267c <DMA_CalcBaseAndBitshift+0xe4>)
 80025ac:	f104 0448 	add.w	r4, r4, #72	; 0x48
 80025b0:	bf0c      	ite	eq
 80025b2:	2301      	moveq	r3, #1
 80025b4:	2300      	movne	r3, #0
 80025b6:	4282      	cmp	r2, r0
 80025b8:	bf08      	it	eq
 80025ba:	f043 0301 	orreq.w	r3, r3, #1
 80025be:	3048      	adds	r0, #72	; 0x48
 80025c0:	42aa      	cmp	r2, r5
 80025c2:	bf08      	it	eq
 80025c4:	f043 0301 	orreq.w	r3, r3, #1
 80025c8:	3548      	adds	r5, #72	; 0x48
 80025ca:	42a2      	cmp	r2, r4
 80025cc:	bf08      	it	eq
 80025ce:	f043 0301 	orreq.w	r3, r3, #1
 80025d2:	3448      	adds	r4, #72	; 0x48
 80025d4:	4282      	cmp	r2, r0
 80025d6:	bf08      	it	eq
 80025d8:	f043 0301 	orreq.w	r3, r3, #1
 80025dc:	f500 7062 	add.w	r0, r0, #904	; 0x388
 80025e0:	42aa      	cmp	r2, r5
 80025e2:	bf08      	it	eq
 80025e4:	f043 0301 	orreq.w	r3, r3, #1
 80025e8:	f505 7562 	add.w	r5, r5, #904	; 0x388
 80025ec:	42a2      	cmp	r2, r4
 80025ee:	bf08      	it	eq
 80025f0:	f043 0301 	orreq.w	r3, r3, #1
 80025f4:	f504 7462 	add.w	r4, r4, #904	; 0x388
 80025f8:	4282      	cmp	r2, r0
 80025fa:	bf08      	it	eq
 80025fc:	f043 0301 	orreq.w	r3, r3, #1
 8002600:	3048      	adds	r0, #72	; 0x48
 8002602:	42aa      	cmp	r2, r5
 8002604:	bf08      	it	eq
 8002606:	f043 0301 	orreq.w	r3, r3, #1
 800260a:	3548      	adds	r5, #72	; 0x48
 800260c:	42a2      	cmp	r2, r4
 800260e:	bf08      	it	eq
 8002610:	f043 0301 	orreq.w	r3, r3, #1
 8002614:	3448      	adds	r4, #72	; 0x48
 8002616:	4282      	cmp	r2, r0
 8002618:	bf08      	it	eq
 800261a:	f043 0301 	orreq.w	r3, r3, #1
 800261e:	3048      	adds	r0, #72	; 0x48
 8002620:	42aa      	cmp	r2, r5
 8002622:	bf08      	it	eq
 8002624:	f043 0301 	orreq.w	r3, r3, #1
 8002628:	42a2      	cmp	r2, r4
 800262a:	bf08      	it	eq
 800262c:	f043 0301 	orreq.w	r3, r3, #1
 8002630:	4282      	cmp	r2, r0
 8002632:	bf08      	it	eq
 8002634:	f043 0301 	orreq.w	r3, r3, #1
 8002638:	b913      	cbnz	r3, 8002640 <DMA_CalcBaseAndBitshift+0xa8>
 800263a:	4b11      	ldr	r3, [pc, #68]	; (8002680 <DMA_CalcBaseAndBitshift+0xe8>)
 800263c:	429a      	cmp	r2, r3
 800263e:	d112      	bne.n	8002666 <DMA_CalcBaseAndBitshift+0xce>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8002640:	b2d3      	uxtb	r3, r2
 8002642:	4d10      	ldr	r5, [pc, #64]	; (8002684 <DMA_CalcBaseAndBitshift+0xec>)
 8002644:	4810      	ldr	r0, [pc, #64]	; (8002688 <DMA_CalcBaseAndBitshift+0xf0>)
 8002646:	3b10      	subs	r3, #16

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 8002648:	4c10      	ldr	r4, [pc, #64]	; (800268c <DMA_CalcBaseAndBitshift+0xf4>)
 800264a:	4010      	ands	r0, r2
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800264c:	fba5 5303 	umull	r5, r3, r5, r3
 8002650:	091b      	lsrs	r3, r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 8002652:	f003 0207 	and.w	r2, r3, #7

    if (stream_number > 3U)
 8002656:	2b03      	cmp	r3, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 8002658:	5ca2      	ldrb	r2, [r4, r2]
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
 800265a:	bf88      	it	hi
 800265c:	3004      	addhi	r0, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 800265e:	65ca      	str	r2, [r1, #92]	; 0x5c
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
 8002660:	6588      	str	r0, [r1, #88]	; 0x58
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
  }

  return hdma->StreamBaseAddress;
}
 8002662:	bc30      	pop	{r4, r5}
 8002664:	4770      	bx	lr
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
 8002666:	f022 00ff 	bic.w	r0, r2, #255	; 0xff
 800266a:	6588      	str	r0, [r1, #88]	; 0x58
 800266c:	e7f9      	b.n	8002662 <DMA_CalcBaseAndBitshift+0xca>
 800266e:	bf00      	nop
 8002670:	40020010 	.word	0x40020010
 8002674:	40020028 	.word	0x40020028
 8002678:	40020040 	.word	0x40020040
 800267c:	40020058 	.word	0x40020058
 8002680:	400204b8 	.word	0x400204b8
 8002684:	aaaaaaab 	.word	0xaaaaaaab
 8002688:	fffffc00 	.word	0xfffffc00
 800268c:	08029168 	.word	0x08029168

08002690 <HAL_DMA_Init>:
{
 8002690:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002694:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 8002696:	f7fe f9c7 	bl	8000a28 <HAL_GetTick>
  if(hdma == NULL)
 800269a:	2d00      	cmp	r5, #0
 800269c:	f000 82ba 	beq.w	8002c14 <HAL_DMA_Init+0x584>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
 80026a0:	682a      	ldr	r2, [r5, #0]
 80026a2:	4604      	mov	r4, r0
 80026a4:	4b9e      	ldr	r3, [pc, #632]	; (8002920 <HAL_DMA_Init+0x290>)
 80026a6:	489f      	ldr	r0, [pc, #636]	; (8002924 <HAL_DMA_Init+0x294>)
 80026a8:	499f      	ldr	r1, [pc, #636]	; (8002928 <HAL_DMA_Init+0x298>)
 80026aa:	429a      	cmp	r2, r3
 80026ac:	bf18      	it	ne
 80026ae:	4282      	cmpne	r2, r0
 80026b0:	f100 0030 	add.w	r0, r0, #48	; 0x30
 80026b4:	bf14      	ite	ne
 80026b6:	2301      	movne	r3, #1
 80026b8:	2300      	moveq	r3, #0
 80026ba:	428a      	cmp	r2, r1
 80026bc:	bf0c      	ite	eq
 80026be:	2300      	moveq	r3, #0
 80026c0:	f003 0301 	andne.w	r3, r3, #1
 80026c4:	3130      	adds	r1, #48	; 0x30
 80026c6:	4282      	cmp	r2, r0
 80026c8:	bf0c      	ite	eq
 80026ca:	2300      	moveq	r3, #0
 80026cc:	f003 0301 	andne.w	r3, r3, #1
 80026d0:	3030      	adds	r0, #48	; 0x30
 80026d2:	428a      	cmp	r2, r1
 80026d4:	bf0c      	ite	eq
 80026d6:	2300      	moveq	r3, #0
 80026d8:	f003 0301 	andne.w	r3, r3, #1
 80026dc:	3130      	adds	r1, #48	; 0x30
 80026de:	4282      	cmp	r2, r0
 80026e0:	bf0c      	ite	eq
 80026e2:	2300      	moveq	r3, #0
 80026e4:	f003 0301 	andne.w	r3, r3, #1
 80026e8:	3030      	adds	r0, #48	; 0x30
 80026ea:	428a      	cmp	r2, r1
 80026ec:	bf0c      	ite	eq
 80026ee:	2300      	moveq	r3, #0
 80026f0:	f003 0301 	andne.w	r3, r3, #1
 80026f4:	f501 715c 	add.w	r1, r1, #880	; 0x370
 80026f8:	4282      	cmp	r2, r0
 80026fa:	bf0c      	ite	eq
 80026fc:	2300      	moveq	r3, #0
 80026fe:	f003 0301 	andne.w	r3, r3, #1
 8002702:	f500 705c 	add.w	r0, r0, #880	; 0x370
 8002706:	428a      	cmp	r2, r1
 8002708:	bf0c      	ite	eq
 800270a:	2300      	moveq	r3, #0
 800270c:	f003 0301 	andne.w	r3, r3, #1
 8002710:	3130      	adds	r1, #48	; 0x30
 8002712:	4282      	cmp	r2, r0
 8002714:	bf0c      	ite	eq
 8002716:	2300      	moveq	r3, #0
 8002718:	f003 0301 	andne.w	r3, r3, #1
 800271c:	3030      	adds	r0, #48	; 0x30
 800271e:	428a      	cmp	r2, r1
 8002720:	bf0c      	ite	eq
 8002722:	2300      	moveq	r3, #0
 8002724:	f003 0301 	andne.w	r3, r3, #1
 8002728:	3130      	adds	r1, #48	; 0x30
 800272a:	4282      	cmp	r2, r0
 800272c:	bf0c      	ite	eq
 800272e:	2300      	moveq	r3, #0
 8002730:	f003 0301 	andne.w	r3, r3, #1
 8002734:	3030      	adds	r0, #48	; 0x30
 8002736:	428a      	cmp	r2, r1
 8002738:	bf0c      	ite	eq
 800273a:	2300      	moveq	r3, #0
 800273c:	f003 0301 	andne.w	r3, r3, #1
 8002740:	3130      	adds	r1, #48	; 0x30
 8002742:	4282      	cmp	r2, r0
 8002744:	bf0c      	ite	eq
 8002746:	2300      	moveq	r3, #0
 8002748:	f003 0301 	andne.w	r3, r3, #1
 800274c:	3030      	adds	r0, #48	; 0x30
 800274e:	428a      	cmp	r2, r1
 8002750:	bf0c      	ite	eq
 8002752:	2300      	moveq	r3, #0
 8002754:	f003 0301 	andne.w	r3, r3, #1
 8002758:	4974      	ldr	r1, [pc, #464]	; (800292c <HAL_DMA_Init+0x29c>)
 800275a:	4282      	cmp	r2, r0
 800275c:	bf0c      	ite	eq
 800275e:	2300      	moveq	r3, #0
 8002760:	f003 0301 	andne.w	r3, r3, #1
 8002764:	4872      	ldr	r0, [pc, #456]	; (8002930 <HAL_DMA_Init+0x2a0>)
 8002766:	428a      	cmp	r2, r1
 8002768:	bf0c      	ite	eq
 800276a:	2300      	moveq	r3, #0
 800276c:	f003 0301 	andne.w	r3, r3, #1
 8002770:	3128      	adds	r1, #40	; 0x28
 8002772:	4282      	cmp	r2, r0
 8002774:	bf0c      	ite	eq
 8002776:	2300      	moveq	r3, #0
 8002778:	f003 0301 	andne.w	r3, r3, #1
 800277c:	3028      	adds	r0, #40	; 0x28
 800277e:	428a      	cmp	r2, r1
 8002780:	bf0c      	ite	eq
 8002782:	2300      	moveq	r3, #0
 8002784:	f003 0301 	andne.w	r3, r3, #1
 8002788:	3128      	adds	r1, #40	; 0x28
 800278a:	4282      	cmp	r2, r0
 800278c:	bf0c      	ite	eq
 800278e:	2300      	moveq	r3, #0
 8002790:	f003 0301 	andne.w	r3, r3, #1
 8002794:	3028      	adds	r0, #40	; 0x28
 8002796:	428a      	cmp	r2, r1
 8002798:	bf0c      	ite	eq
 800279a:	2300      	moveq	r3, #0
 800279c:	f003 0301 	andne.w	r3, r3, #1
 80027a0:	3128      	adds	r1, #40	; 0x28
 80027a2:	4282      	cmp	r2, r0
 80027a4:	bf0c      	ite	eq
 80027a6:	2300      	moveq	r3, #0
 80027a8:	f003 0301 	andne.w	r3, r3, #1
 80027ac:	428a      	cmp	r2, r1
 80027ae:	bf0c      	ite	eq
 80027b0:	2300      	moveq	r3, #0
 80027b2:	f003 0301 	andne.w	r3, r3, #1
 80027b6:	b11b      	cbz	r3, 80027c0 <HAL_DMA_Init+0x130>
 80027b8:	4b5e      	ldr	r3, [pc, #376]	; (8002934 <HAL_DMA_Init+0x2a4>)
 80027ba:	429a      	cmp	r2, r3
 80027bc:	f040 836b 	bne.w	8002e96 <HAL_DMA_Init+0x806>
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
 80027c0:	68ab      	ldr	r3, [r5, #8]
 80027c2:	f033 0240 	bics.w	r2, r3, #64	; 0x40
 80027c6:	d002      	beq.n	80027ce <HAL_DMA_Init+0x13e>
 80027c8:	2b80      	cmp	r3, #128	; 0x80
 80027ca:	f040 8226 	bne.w	8002c1a <HAL_DMA_Init+0x58a>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 80027ce:	68eb      	ldr	r3, [r5, #12]
 80027d0:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 80027d4:	f040 8114 	bne.w	8002a00 <HAL_DMA_Init+0x370>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 80027d8:	692b      	ldr	r3, [r5, #16]
 80027da:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
 80027de:	f040 8105 	bne.w	80029ec <HAL_DMA_Init+0x35c>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 80027e2:	696b      	ldr	r3, [r5, #20]
 80027e4:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
 80027e8:	d003      	beq.n	80027f2 <HAL_DMA_Init+0x162>
 80027ea:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80027ee:	f040 821e 	bne.w	8002c2e <HAL_DMA_Init+0x59e>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
 80027f2:	69ab      	ldr	r3, [r5, #24]
 80027f4:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
 80027f8:	d003      	beq.n	8002802 <HAL_DMA_Init+0x172>
 80027fa:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80027fe:	f040 8220 	bne.w	8002c42 <HAL_DMA_Init+0x5b2>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
 8002802:	69ea      	ldr	r2, [r5, #28]
 8002804:	f032 0320 	bics.w	r3, r2, #32
 8002808:	f422 2100 	bic.w	r1, r2, #524288	; 0x80000
 800280c:	bf14      	ite	ne
 800280e:	2301      	movne	r3, #1
 8002810:	2300      	moveq	r3, #0
 8002812:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 8002816:	bf0c      	ite	eq
 8002818:	2300      	moveq	r3, #0
 800281a:	f003 0301 	andne.w	r3, r3, #1
 800281e:	b11b      	cbz	r3, 8002828 <HAL_DMA_Init+0x198>
 8002820:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8002824:	f040 8212 	bne.w	8002c4c <HAL_DMA_Init+0x5bc>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
 8002828:	6a2b      	ldr	r3, [r5, #32]
 800282a:	f433 3340 	bics.w	r3, r3, #196608	; 0x30000
 800282e:	f040 824e 	bne.w	8002cce <HAL_DMA_Init+0x63e>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8002832:	682a      	ldr	r2, [r5, #0]
 8002834:	4b3a      	ldr	r3, [pc, #232]	; (8002920 <HAL_DMA_Init+0x290>)
 8002836:	483b      	ldr	r0, [pc, #236]	; (8002924 <HAL_DMA_Init+0x294>)
 8002838:	493b      	ldr	r1, [pc, #236]	; (8002928 <HAL_DMA_Init+0x298>)
 800283a:	4282      	cmp	r2, r0
 800283c:	bf18      	it	ne
 800283e:	429a      	cmpne	r2, r3
 8002840:	f100 0030 	add.w	r0, r0, #48	; 0x30
 8002844:	bf0c      	ite	eq
 8002846:	2301      	moveq	r3, #1
 8002848:	2300      	movne	r3, #0
 800284a:	428a      	cmp	r2, r1
 800284c:	bf08      	it	eq
 800284e:	f043 0301 	orreq.w	r3, r3, #1
 8002852:	3130      	adds	r1, #48	; 0x30
 8002854:	4282      	cmp	r2, r0
 8002856:	bf08      	it	eq
 8002858:	f043 0301 	orreq.w	r3, r3, #1
 800285c:	3030      	adds	r0, #48	; 0x30
 800285e:	428a      	cmp	r2, r1
 8002860:	bf08      	it	eq
 8002862:	f043 0301 	orreq.w	r3, r3, #1
 8002866:	3130      	adds	r1, #48	; 0x30
 8002868:	4282      	cmp	r2, r0
 800286a:	bf08      	it	eq
 800286c:	f043 0301 	orreq.w	r3, r3, #1
 8002870:	3030      	adds	r0, #48	; 0x30
 8002872:	428a      	cmp	r2, r1
 8002874:	bf08      	it	eq
 8002876:	f043 0301 	orreq.w	r3, r3, #1
 800287a:	f501 715c 	add.w	r1, r1, #880	; 0x370
 800287e:	4282      	cmp	r2, r0
 8002880:	bf08      	it	eq
 8002882:	f043 0301 	orreq.w	r3, r3, #1
 8002886:	f500 705c 	add.w	r0, r0, #880	; 0x370
 800288a:	428a      	cmp	r2, r1
 800288c:	bf08      	it	eq
 800288e:	f043 0301 	orreq.w	r3, r3, #1
 8002892:	3130      	adds	r1, #48	; 0x30
 8002894:	4282      	cmp	r2, r0
 8002896:	bf08      	it	eq
 8002898:	f043 0301 	orreq.w	r3, r3, #1
 800289c:	3030      	adds	r0, #48	; 0x30
 800289e:	428a      	cmp	r2, r1
 80028a0:	bf08      	it	eq
 80028a2:	f043 0301 	orreq.w	r3, r3, #1
 80028a6:	3130      	adds	r1, #48	; 0x30
 80028a8:	4282      	cmp	r2, r0
 80028aa:	bf08      	it	eq
 80028ac:	f043 0301 	orreq.w	r3, r3, #1
 80028b0:	3030      	adds	r0, #48	; 0x30
 80028b2:	428a      	cmp	r2, r1
 80028b4:	bf08      	it	eq
 80028b6:	f043 0301 	orreq.w	r3, r3, #1
 80028ba:	3130      	adds	r1, #48	; 0x30
 80028bc:	4282      	cmp	r2, r0
 80028be:	bf08      	it	eq
 80028c0:	f043 0301 	orreq.w	r3, r3, #1
 80028c4:	428a      	cmp	r2, r1
 80028c6:	bf08      	it	eq
 80028c8:	f043 0301 	orreq.w	r3, r3, #1
 80028cc:	b91b      	cbnz	r3, 80028d6 <HAL_DMA_Init+0x246>
 80028ce:	4b1a      	ldr	r3, [pc, #104]	; (8002938 <HAL_DMA_Init+0x2a8>)
 80028d0:	429a      	cmp	r2, r3
 80028d2:	f040 8259 	bne.w	8002d88 <HAL_DMA_Init+0x6f8>
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
 80028d6:	686b      	ldr	r3, [r5, #4]
 80028d8:	2b73      	cmp	r3, #115	; 0x73
 80028da:	f200 809b 	bhi.w	8002a14 <HAL_DMA_Init+0x384>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
 80028de:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80028e0:	f033 0204 	bics.w	r2, r3, #4
 80028e4:	f040 809f 	bne.w	8002a26 <HAL_DMA_Init+0x396>
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
 80028e8:	b16b      	cbz	r3, 8002906 <HAL_DMA_Init+0x276>
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
 80028ea:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80028ec:	2b03      	cmp	r3, #3
 80028ee:	f200 81e9 	bhi.w	8002cc4 <HAL_DMA_Init+0x634>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
 80028f2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80028f4:	f033 73c0 	bics.w	r3, r3, #25165824	; 0x1800000
 80028f8:	f040 822a 	bne.w	8002d50 <HAL_DMA_Init+0x6c0>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
 80028fc:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80028fe:	f433 03c0 	bics.w	r3, r3, #6291456	; 0x600000
 8002902:	f040 81a8 	bne.w	8002c56 <HAL_DMA_Init+0x5c6>
    __HAL_UNLOCK(hdma);
 8002906:	2000      	movs	r0, #0
    __HAL_DMA_DISABLE(hdma);
 8002908:	682a      	ldr	r2, [r5, #0]
    __HAL_UNLOCK(hdma);
 800290a:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_BUSY;
 800290e:	2002      	movs	r0, #2
 8002910:	f885 0035 	strb.w	r0, [r5, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8002914:	6813      	ldr	r3, [r2, #0]
 8002916:	f023 0301 	bic.w	r3, r3, #1
 800291a:	6013      	str	r3, [r2, #0]
 800291c:	e014      	b.n	8002948 <HAL_DMA_Init+0x2b8>
 800291e:	bf00      	nop
 8002920:	40020010 	.word	0x40020010
 8002924:	40020028 	.word	0x40020028
 8002928:	40020040 	.word	0x40020040
 800292c:	58025408 	.word	0x58025408
 8002930:	5802541c 	.word	0x5802541c
 8002934:	58025494 	.word	0x58025494
 8002938:	400204b8 	.word	0x400204b8
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 800293c:	f7fe f874 	bl	8000a28 <HAL_GetTick>
 8002940:	1b00      	subs	r0, r0, r4
 8002942:	2805      	cmp	r0, #5
 8002944:	f200 815e 	bhi.w	8002c04 <HAL_DMA_Init+0x574>
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 8002948:	682b      	ldr	r3, [r5, #0]
 800294a:	681a      	ldr	r2, [r3, #0]
 800294c:	07d0      	lsls	r0, r2, #31
 800294e:	d4f5      	bmi.n	800293c <HAL_DMA_Init+0x2ac>
    registerValue |=  hdma->Init.Direction           |
 8002950:	e9d5 2002 	ldrd	r2, r0, [r5, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002954:	6929      	ldr	r1, [r5, #16]
    registerValue |=  hdma->Init.Direction           |
 8002956:	4302      	orrs	r2, r0
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002958:	e9d5 4005 	ldrd	r4, r0, [r5, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800295c:	430a      	orrs	r2, r1
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800295e:	69e9      	ldr	r1, [r5, #28]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002960:	4322      	orrs	r2, r4
            hdma->Init.Mode                | hdma->Init.Priority;
 8002962:	6a2c      	ldr	r4, [r5, #32]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002964:	4302      	orrs	r2, r0
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
 8002966:	6818      	ldr	r0, [r3, #0]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002968:	430a      	orrs	r2, r1
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800296a:	49bd      	ldr	r1, [pc, #756]	; (8002c60 <HAL_DMA_Init+0x5d0>)
 800296c:	4001      	ands	r1, r0
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800296e:	6a68      	ldr	r0, [r5, #36]	; 0x24
            hdma->Init.Mode                | hdma->Init.Priority;
 8002970:	4322      	orrs	r2, r4
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002972:	2804      	cmp	r0, #4
    registerValue |=  hdma->Init.Direction           |
 8002974:	ea42 0201 	orr.w	r2, r2, r1
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002978:	d103      	bne.n	8002982 <HAL_DMA_Init+0x2f2>
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800297a:	e9d5 100b 	ldrd	r1, r0, [r5, #44]	; 0x2c
 800297e:	4301      	orrs	r1, r0
 8002980:	430a      	orrs	r2, r1
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
 8002982:	48b8      	ldr	r0, [pc, #736]	; (8002c64 <HAL_DMA_Init+0x5d4>)
 8002984:	49b8      	ldr	r1, [pc, #736]	; (8002c68 <HAL_DMA_Init+0x5d8>)
 8002986:	6800      	ldr	r0, [r0, #0]
 8002988:	4001      	ands	r1, r0
 800298a:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 800298e:	d30a      	bcc.n	80029a6 <HAL_DMA_Init+0x316>
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
 8002990:	6868      	ldr	r0, [r5, #4]
 8002992:	f1a0 0429 	sub.w	r4, r0, #41	; 0x29
 8002996:	2c1f      	cmp	r4, #31
 8002998:	f240 818c 	bls.w	8002cb4 <HAL_DMA_Init+0x624>
 800299c:	384f      	subs	r0, #79	; 0x4f
 800299e:	2803      	cmp	r0, #3
 80029a0:	d801      	bhi.n	80029a6 <HAL_DMA_Init+0x316>
        registerValue |= DMA_SxCR_TRBUFF;
 80029a2:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
 80029a6:	601a      	str	r2, [r3, #0]
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
 80029a8:	6829      	ldr	r1, [r5, #0]
    registerValue |= hdma->Init.FIFOMode;
 80029aa:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
 80029ac:	694b      	ldr	r3, [r1, #20]
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80029ae:	2a04      	cmp	r2, #4
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80029b0:	f023 0307 	bic.w	r3, r3, #7
    registerValue |= hdma->Init.FIFOMode;
 80029b4:	ea43 0302 	orr.w	r3, r3, r2
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80029b8:	d144      	bne.n	8002a44 <HAL_DMA_Init+0x3b4>
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 80029ba:	e9d5 200a 	ldrd	r2, r0, [r5, #40]	; 0x28
      registerValue |= hdma->Init.FIFOThreshold;
 80029be:	4313      	orrs	r3, r2
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 80029c0:	2800      	cmp	r0, #0
 80029c2:	d03f      	beq.n	8002a44 <HAL_DMA_Init+0x3b4>
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 80029c4:	69ac      	ldr	r4, [r5, #24]
 80029c6:	2c00      	cmp	r4, #0
 80029c8:	d036      	beq.n	8002a38 <HAL_DMA_Init+0x3a8>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80029ca:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
 80029ce:	f000 823e 	beq.w	8002e4e <HAL_DMA_Init+0x7be>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
 80029d2:	2a02      	cmp	r2, #2
 80029d4:	d903      	bls.n	80029de <HAL_DMA_Init+0x34e>
 80029d6:	2a03      	cmp	r2, #3
 80029d8:	d134      	bne.n	8002a44 <HAL_DMA_Init+0x3b4>
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
        break;

      case DMA_FIFO_THRESHOLD_FULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80029da:	01c2      	lsls	r2, r0, #7
 80029dc:	d532      	bpl.n	8002a44 <HAL_DMA_Init+0x3b4>
          hdma->State = HAL_DMA_STATE_READY;
 80029de:	2301      	movs	r3, #1
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80029e0:	2240      	movs	r2, #64	; 0x40
          return HAL_ERROR;
 80029e2:	4618      	mov	r0, r3
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80029e4:	656a      	str	r2, [r5, #84]	; 0x54
          hdma->State = HAL_DMA_STATE_READY;
 80029e6:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
          return HAL_ERROR;
 80029ea:	e109      	b.n	8002c00 <HAL_DMA_Init+0x570>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 80029ec:	21e4      	movs	r1, #228	; 0xe4
 80029ee:	489f      	ldr	r0, [pc, #636]	; (8002c6c <HAL_DMA_Init+0x5dc>)
 80029f0:	f010 ff6e 	bl	80138d0 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 80029f4:	696b      	ldr	r3, [r5, #20]
 80029f6:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
 80029fa:	f47f aef6 	bne.w	80027ea <HAL_DMA_Init+0x15a>
 80029fe:	e6f8      	b.n	80027f2 <HAL_DMA_Init+0x162>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 8002a00:	21e3      	movs	r1, #227	; 0xe3
 8002a02:	489a      	ldr	r0, [pc, #616]	; (8002c6c <HAL_DMA_Init+0x5dc>)
 8002a04:	f010 ff64 	bl	80138d0 <assert_failed>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 8002a08:	692b      	ldr	r3, [r5, #16]
 8002a0a:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
 8002a0e:	f43f aee8 	beq.w	80027e2 <HAL_DMA_Init+0x152>
 8002a12:	e7eb      	b.n	80029ec <HAL_DMA_Init+0x35c>
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
 8002a14:	21ec      	movs	r1, #236	; 0xec
 8002a16:	4895      	ldr	r0, [pc, #596]	; (8002c6c <HAL_DMA_Init+0x5dc>)
 8002a18:	f010 ff5a 	bl	80138d0 <assert_failed>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
 8002a1c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8002a1e:	f033 0204 	bics.w	r2, r3, #4
 8002a22:	f43f af61 	beq.w	80028e8 <HAL_DMA_Init+0x258>
 8002a26:	21ed      	movs	r1, #237	; 0xed
 8002a28:	4890      	ldr	r0, [pc, #576]	; (8002c6c <HAL_DMA_Init+0x5dc>)
 8002a2a:	f010 ff51 	bl	80138d0 <assert_failed>
 8002a2e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
 8002a30:	2b00      	cmp	r3, #0
 8002a32:	f43f af68 	beq.w	8002906 <HAL_DMA_Init+0x276>
 8002a36:	e758      	b.n	80028ea <HAL_DMA_Init+0x25a>
    switch (hdma->Init.FIFOThreshold)
 8002a38:	2a01      	cmp	r2, #1
 8002a3a:	f000 8203 	beq.w	8002e44 <HAL_DMA_Init+0x7b4>
 8002a3e:	d3cc      	bcc.n	80029da <HAL_DMA_Init+0x34a>
 8002a40:	2a02      	cmp	r2, #2
 8002a42:	d0ca      	beq.n	80029da <HAL_DMA_Init+0x34a>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
 8002a44:	614b      	str	r3, [r1, #20]
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8002a46:	4628      	mov	r0, r5
 8002a48:	f7ff fda6 	bl	8002598 <DMA_CalcBaseAndBitshift>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8002a4c:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8002a4e:	233f      	movs	r3, #63	; 0x3f
 8002a50:	f002 021f 	and.w	r2, r2, #31
 8002a54:	4093      	lsls	r3, r2
 8002a56:	6083      	str	r3, [r0, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8002a58:	682a      	ldr	r2, [r5, #0]
 8002a5a:	4b85      	ldr	r3, [pc, #532]	; (8002c70 <HAL_DMA_Init+0x5e0>)
 8002a5c:	4885      	ldr	r0, [pc, #532]	; (8002c74 <HAL_DMA_Init+0x5e4>)
 8002a5e:	4986      	ldr	r1, [pc, #536]	; (8002c78 <HAL_DMA_Init+0x5e8>)
 8002a60:	4282      	cmp	r2, r0
 8002a62:	bf18      	it	ne
 8002a64:	429a      	cmpne	r2, r3
 8002a66:	4e85      	ldr	r6, [pc, #532]	; (8002c7c <HAL_DMA_Init+0x5ec>)
 8002a68:	4c85      	ldr	r4, [pc, #532]	; (8002c80 <HAL_DMA_Init+0x5f0>)
 8002a6a:	f100 0060 	add.w	r0, r0, #96	; 0x60
 8002a6e:	bf0c      	ite	eq
 8002a70:	2301      	moveq	r3, #1
 8002a72:	2300      	movne	r3, #0
 8002a74:	f8df e21c 	ldr.w	lr, [pc, #540]	; 8002c94 <HAL_DMA_Init+0x604>
 8002a78:	428a      	cmp	r2, r1
 8002a7a:	bf08      	it	eq
 8002a7c:	f043 0301 	orreq.w	r3, r3, #1
 8002a80:	3160      	adds	r1, #96	; 0x60
 8002a82:	f8df c214 	ldr.w	ip, [pc, #532]	; 8002c98 <HAL_DMA_Init+0x608>
 8002a86:	42b2      	cmp	r2, r6
 8002a88:	bf08      	it	eq
 8002a8a:	f043 0301 	orreq.w	r3, r3, #1
 8002a8e:	4f7d      	ldr	r7, [pc, #500]	; (8002c84 <HAL_DMA_Init+0x5f4>)
 8002a90:	f506 767a 	add.w	r6, r6, #1000	; 0x3e8
 8002a94:	f8df 8204 	ldr.w	r8, [pc, #516]	; 8002c9c <HAL_DMA_Init+0x60c>
 8002a98:	42a2      	cmp	r2, r4
 8002a9a:	bf08      	it	eq
 8002a9c:	f043 0301 	orreq.w	r3, r3, #1
 8002aa0:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
 8002aa4:	f8df a1f8 	ldr.w	sl, [pc, #504]	; 8002ca0 <HAL_DMA_Init+0x610>
 8002aa8:	4282      	cmp	r2, r0
 8002aaa:	bf08      	it	eq
 8002aac:	f043 0301 	orreq.w	r3, r3, #1
 8002ab0:	f500 707a 	add.w	r0, r0, #1000	; 0x3e8
 8002ab4:	f8df 91ec 	ldr.w	r9, [pc, #492]	; 8002ca4 <HAL_DMA_Init+0x614>
 8002ab8:	428a      	cmp	r2, r1
 8002aba:	bf08      	it	eq
 8002abc:	f043 0301 	orreq.w	r3, r3, #1
 8002ac0:	f501 717a 	add.w	r1, r1, #1000	; 0x3e8
 8002ac4:	4572      	cmp	r2, lr
 8002ac6:	bf08      	it	eq
 8002ac8:	f043 0301 	orreq.w	r3, r3, #1
 8002acc:	f8df e1d8 	ldr.w	lr, [pc, #472]	; 8002ca8 <HAL_DMA_Init+0x618>
 8002ad0:	4562      	cmp	r2, ip
 8002ad2:	bf08      	it	eq
 8002ad4:	f043 0301 	orreq.w	r3, r3, #1
 8002ad8:	eba2 0e0e 	sub.w	lr, r2, lr
 8002adc:	f8df c1cc 	ldr.w	ip, [pc, #460]	; 8002cac <HAL_DMA_Init+0x61c>
 8002ae0:	42ba      	cmp	r2, r7
 8002ae2:	bf08      	it	eq
 8002ae4:	f043 0301 	orreq.w	r3, r3, #1
 8002ae8:	fabe fe8e 	clz	lr, lr
 8002aec:	eba2 070c 	sub.w	r7, r2, ip
 8002af0:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
 8002af4:	42b2      	cmp	r2, r6
 8002af6:	bf08      	it	eq
 8002af8:	f043 0301 	orreq.w	r3, r3, #1
 8002afc:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 8002b00:	eba2 060a 	sub.w	r6, r2, sl
 8002b04:	fab7 f787 	clz	r7, r7
 8002b08:	42a2      	cmp	r2, r4
 8002b0a:	bf08      	it	eq
 8002b0c:	f043 0301 	orreq.w	r3, r3, #1
 8002b10:	f10a 0a28 	add.w	sl, sl, #40	; 0x28
 8002b14:	eba2 040c 	sub.w	r4, r2, ip
 8002b18:	097f      	lsrs	r7, r7, #5
 8002b1a:	4282      	cmp	r2, r0
 8002b1c:	bf08      	it	eq
 8002b1e:	f043 0301 	orreq.w	r3, r3, #1
 8002b22:	fab6 f686 	clz	r6, r6
 8002b26:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
 8002b2a:	fab4 f484 	clz	r4, r4
 8002b2e:	428a      	cmp	r2, r1
 8002b30:	bf08      	it	eq
 8002b32:	f043 0301 	orreq.w	r3, r3, #1
 8002b36:	0976      	lsrs	r6, r6, #5
 8002b38:	eba2 000a 	sub.w	r0, r2, sl
 8002b3c:	eba2 010c 	sub.w	r1, r2, ip
 8002b40:	4542      	cmp	r2, r8
 8002b42:	bf08      	it	eq
 8002b44:	f043 0301 	orreq.w	r3, r3, #1
 8002b48:	0964      	lsrs	r4, r4, #5
 8002b4a:	fab0 f080 	clz	r0, r0
 8002b4e:	f10c 0c14 	add.w	ip, ip, #20
 8002b52:	454a      	cmp	r2, r9
 8002b54:	bf08      	it	eq
 8002b56:	f043 0301 	orreq.w	r3, r3, #1
 8002b5a:	fab1 f181 	clz	r1, r1
 8002b5e:	0940      	lsrs	r0, r0, #5
 8002b60:	eba2 0c0c 	sub.w	ip, r2, ip
 8002b64:	ea4e 0303 	orr.w	r3, lr, r3
 8002b68:	0949      	lsrs	r1, r1, #5
 8002b6a:	f8df 8144 	ldr.w	r8, [pc, #324]	; 8002cb0 <HAL_DMA_Init+0x620>
 8002b6e:	fabc fc8c 	clz	ip, ip
 8002b72:	433b      	orrs	r3, r7
 8002b74:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
 8002b78:	eba2 0808 	sub.w	r8, r2, r8
 8002b7c:	4333      	orrs	r3, r6
 8002b7e:	fab8 f888 	clz	r8, r8
 8002b82:	4323      	orrs	r3, r4
 8002b84:	ea4f 1858 	mov.w	r8, r8, lsr #5
 8002b88:	4303      	orrs	r3, r0
 8002b8a:	430b      	orrs	r3, r1
 8002b8c:	ea5c 0303 	orrs.w	r3, ip, r3
 8002b90:	d102      	bne.n	8002b98 <HAL_DMA_Init+0x508>
 8002b92:	f1b8 0f00 	cmp.w	r8, #0
 8002b96:	d02e      	beq.n	8002bf6 <HAL_DMA_Init+0x566>
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 8002b98:	ea47 070e 	orr.w	r7, r7, lr
 8002b9c:	b2d3      	uxtb	r3, r2
 8002b9e:	433e      	orrs	r6, r7
 8002ba0:	4334      	orrs	r4, r6
 8002ba2:	4320      	orrs	r0, r4
 8002ba4:	4301      	orrs	r1, r0
 8002ba6:	ea5c 0101 	orrs.w	r1, ip, r1
 8002baa:	d103      	bne.n	8002bb4 <HAL_DMA_Init+0x524>
 8002bac:	f1b8 0f00 	cmp.w	r8, #0
 8002bb0:	f000 80d3 	beq.w	8002d5a <HAL_DMA_Init+0x6ca>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 8002bb4:	4834      	ldr	r0, [pc, #208]	; (8002c88 <HAL_DMA_Init+0x5f8>)
 8002bb6:	3b08      	subs	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8002bb8:	4a34      	ldr	r2, [pc, #208]	; (8002c8c <HAL_DMA_Init+0x5fc>)
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8002bba:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 8002bbc:	fba0 0303 	umull	r0, r3, r0, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 8002bc0:	4833      	ldr	r0, [pc, #204]	; (8002c90 <HAL_DMA_Init+0x600>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 8002bc2:	091b      	lsrs	r3, r3, #4
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 8002bc4:	6668      	str	r0, [r5, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8002bc6:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8002bc8:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8002bcc:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8002bce:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8002bd2:	662a      	str	r2, [r5, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8002bd4:	66ab      	str	r3, [r5, #104]	; 0x68
    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8002bd6:	68ab      	ldr	r3, [r5, #8]
 8002bd8:	2b80      	cmp	r3, #128	; 0x80
 8002bda:	d07d      	beq.n	8002cd8 <HAL_DMA_Init+0x648>
 8002bdc:	792b      	ldrb	r3, [r5, #4]
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8002bde:	6013      	str	r3, [r2, #0]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8002be0:	e9d5 3219 	ldrd	r3, r2, [r5, #100]	; 0x64
 8002be4:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 8002be6:	6868      	ldr	r0, [r5, #4]
 8002be8:	1e41      	subs	r1, r0, #1
 8002bea:	2907      	cmp	r1, #7
 8002bec:	d978      	bls.n	8002ce0 <HAL_DMA_Init+0x650>
      hdma->DMAmuxRequestGen = 0U;
 8002bee:	2300      	movs	r3, #0
      hdma->DMAmuxRequestGenStatus = 0U;
 8002bf0:	e9c5 331b 	strd	r3, r3, [r5, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatusMask = 0U;
 8002bf4:	676b      	str	r3, [r5, #116]	; 0x74
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8002bf6:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 8002bf8:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8002bfa:	6568      	str	r0, [r5, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 8002bfc:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
}
 8002c00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8002c04:	2220      	movs	r2, #32
        hdma->State = HAL_DMA_STATE_ERROR;
 8002c06:	2303      	movs	r3, #3
        return HAL_ERROR;
 8002c08:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8002c0a:	656a      	str	r2, [r5, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_ERROR;
 8002c0c:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
}
 8002c10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return HAL_ERROR;
 8002c14:	2001      	movs	r0, #1
}
 8002c16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
 8002c1a:	21e2      	movs	r1, #226	; 0xe2
 8002c1c:	4813      	ldr	r0, [pc, #76]	; (8002c6c <HAL_DMA_Init+0x5dc>)
 8002c1e:	f010 fe57 	bl	80138d0 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 8002c22:	68eb      	ldr	r3, [r5, #12]
 8002c24:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 8002c28:	f43f add6 	beq.w	80027d8 <HAL_DMA_Init+0x148>
 8002c2c:	e6e8      	b.n	8002a00 <HAL_DMA_Init+0x370>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 8002c2e:	21e5      	movs	r1, #229	; 0xe5
 8002c30:	480e      	ldr	r0, [pc, #56]	; (8002c6c <HAL_DMA_Init+0x5dc>)
 8002c32:	f010 fe4d 	bl	80138d0 <assert_failed>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
 8002c36:	69ab      	ldr	r3, [r5, #24]
 8002c38:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
 8002c3c:	f47f addd 	bne.w	80027fa <HAL_DMA_Init+0x16a>
 8002c40:	e5df      	b.n	8002802 <HAL_DMA_Init+0x172>
 8002c42:	21e6      	movs	r1, #230	; 0xe6
 8002c44:	4809      	ldr	r0, [pc, #36]	; (8002c6c <HAL_DMA_Init+0x5dc>)
 8002c46:	f010 fe43 	bl	80138d0 <assert_failed>
 8002c4a:	e5da      	b.n	8002802 <HAL_DMA_Init+0x172>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
 8002c4c:	21e7      	movs	r1, #231	; 0xe7
 8002c4e:	4807      	ldr	r0, [pc, #28]	; (8002c6c <HAL_DMA_Init+0x5dc>)
 8002c50:	f010 fe3e 	bl	80138d0 <assert_failed>
 8002c54:	e5e8      	b.n	8002828 <HAL_DMA_Init+0x198>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
 8002c56:	21f4      	movs	r1, #244	; 0xf4
 8002c58:	4804      	ldr	r0, [pc, #16]	; (8002c6c <HAL_DMA_Init+0x5dc>)
 8002c5a:	f010 fe39 	bl	80138d0 <assert_failed>
 8002c5e:	e652      	b.n	8002906 <HAL_DMA_Init+0x276>
 8002c60:	fe10803f 	.word	0xfe10803f
 8002c64:	5c001000 	.word	0x5c001000
 8002c68:	ffff0000 	.word	0xffff0000
 8002c6c:	08029130 	.word	0x08029130
 8002c70:	40020010 	.word	0x40020010
 8002c74:	40020028 	.word	0x40020028
 8002c78:	40020040 	.word	0x40020040
 8002c7c:	40020058 	.word	0x40020058
 8002c80:	40020070 	.word	0x40020070
 8002c84:	40020428 	.word	0x40020428
 8002c88:	cccccccd 	.word	0xcccccccd
 8002c8c:	16009600 	.word	0x16009600
 8002c90:	58025880 	.word	0x58025880
 8002c94:	400200b8 	.word	0x400200b8
 8002c98:	40020410 	.word	0x40020410
 8002c9c:	400204a0 	.word	0x400204a0
 8002ca0:	58025430 	.word	0x58025430
 8002ca4:	400204b8 	.word	0x400204b8
 8002ca8:	58025408 	.word	0x58025408
 8002cac:	5802541c 	.word	0x5802541c
 8002cb0:	58025494 	.word	0x58025494
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
 8002cb4:	497a      	ldr	r1, [pc, #488]	; (8002ea0 <HAL_DMA_Init+0x810>)
 8002cb6:	40e1      	lsrs	r1, r4
 8002cb8:	07c9      	lsls	r1, r1, #31
 8002cba:	f57f ae6f 	bpl.w	800299c <HAL_DMA_Init+0x30c>
        registerValue |= DMA_SxCR_TRBUFF;
 8002cbe:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8002cc2:	e670      	b.n	80029a6 <HAL_DMA_Init+0x316>
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
 8002cc4:	21f2      	movs	r1, #242	; 0xf2
 8002cc6:	4877      	ldr	r0, [pc, #476]	; (8002ea4 <HAL_DMA_Init+0x814>)
 8002cc8:	f010 fe02 	bl	80138d0 <assert_failed>
 8002ccc:	e611      	b.n	80028f2 <HAL_DMA_Init+0x262>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
 8002cce:	21e8      	movs	r1, #232	; 0xe8
 8002cd0:	4874      	ldr	r0, [pc, #464]	; (8002ea4 <HAL_DMA_Init+0x814>)
 8002cd2:	f010 fdfd 	bl	80138d0 <assert_failed>
 8002cd6:	e5ac      	b.n	8002832 <HAL_DMA_Init+0x1a2>
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 8002cd8:	2100      	movs	r1, #0
 8002cda:	460b      	mov	r3, r1
 8002cdc:	6069      	str	r1, [r5, #4]
 8002cde:	e77e      	b.n	8002bde <HAL_DMA_Init+0x54e>
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 8002ce0:	682a      	ldr	r2, [r5, #0]
 8002ce2:	4b71      	ldr	r3, [pc, #452]	; (8002ea8 <HAL_DMA_Init+0x818>)
 8002ce4:	4e71      	ldr	r6, [pc, #452]	; (8002eac <HAL_DMA_Init+0x81c>)
 8002ce6:	4c72      	ldr	r4, [pc, #456]	; (8002eb0 <HAL_DMA_Init+0x820>)
 8002ce8:	42b2      	cmp	r2, r6
 8002cea:	bf18      	it	ne
 8002cec:	429a      	cmpne	r2, r3
 8002cee:	f106 0628 	add.w	r6, r6, #40	; 0x28
 8002cf2:	bf0c      	ite	eq
 8002cf4:	2301      	moveq	r3, #1
 8002cf6:	2300      	movne	r3, #0
 8002cf8:	42a2      	cmp	r2, r4
 8002cfa:	bf08      	it	eq
 8002cfc:	f043 0301 	orreq.w	r3, r3, #1
 8002d00:	3428      	adds	r4, #40	; 0x28
 8002d02:	42b2      	cmp	r2, r6
 8002d04:	bf08      	it	eq
 8002d06:	f043 0301 	orreq.w	r3, r3, #1
 8002d0a:	3628      	adds	r6, #40	; 0x28
 8002d0c:	42a2      	cmp	r2, r4
 8002d0e:	bf08      	it	eq
 8002d10:	f043 0301 	orreq.w	r3, r3, #1
 8002d14:	3428      	adds	r4, #40	; 0x28
 8002d16:	42b2      	cmp	r2, r6
 8002d18:	bf08      	it	eq
 8002d1a:	f043 0301 	orreq.w	r3, r3, #1
 8002d1e:	42a2      	cmp	r2, r4
 8002d20:	bf08      	it	eq
 8002d22:	f043 0301 	orreq.w	r3, r3, #1
 8002d26:	b91b      	cbnz	r3, 8002d30 <HAL_DMA_Init+0x6a0>
 8002d28:	4b62      	ldr	r3, [pc, #392]	; (8002eb4 <HAL_DMA_Init+0x824>)
 8002d2a:	429a      	cmp	r2, r3
 8002d2c:	f040 809e 	bne.w	8002e6c <HAL_DMA_Init+0x7dc>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 8002d30:	4b61      	ldr	r3, [pc, #388]	; (8002eb8 <HAL_DMA_Init+0x828>)

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 8002d32:	4c62      	ldr	r4, [pc, #392]	; (8002ebc <HAL_DMA_Init+0x82c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 8002d34:	4403      	add	r3, r0
 8002d36:	009b      	lsls	r3, r3, #2
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 8002d38:	2201      	movs	r2, #1
      hdma->DMAmuxRequestGen->RGCR = 0U;
 8002d3a:	2000      	movs	r0, #0
 8002d3c:	672c      	str	r4, [r5, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 8002d3e:	fa02 f101 	lsl.w	r1, r2, r1
 8002d42:	66eb      	str	r3, [r5, #108]	; 0x6c
 8002d44:	6769      	str	r1, [r5, #116]	; 0x74
      hdma->DMAmuxRequestGen->RGCR = 0U;
 8002d46:	6018      	str	r0, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8002d48:	e9d5 321c 	ldrd	r3, r2, [r5, #112]	; 0x70
 8002d4c:	605a      	str	r2, [r3, #4]
 8002d4e:	e752      	b.n	8002bf6 <HAL_DMA_Init+0x566>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
 8002d50:	21f3      	movs	r1, #243	; 0xf3
 8002d52:	4854      	ldr	r0, [pc, #336]	; (8002ea4 <HAL_DMA_Init+0x814>)
 8002d54:	f010 fdbc 	bl	80138d0 <assert_failed>
 8002d58:	e5d0      	b.n	80028fc <HAL_DMA_Init+0x26c>
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8002d5a:	4959      	ldr	r1, [pc, #356]	; (8002ec0 <HAL_DMA_Init+0x830>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8002d5c:	3b10      	subs	r3, #16
 8002d5e:	4859      	ldr	r0, [pc, #356]	; (8002ec4 <HAL_DMA_Init+0x834>)
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8002d60:	4411      	add	r1, r2
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8002d62:	fba0 0303 	umull	r0, r3, r0, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8002d66:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8002d68:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8002d6c:	d800      	bhi.n	8002d70 <HAL_DMA_Init+0x6e0>
      stream_number += 8U;
 8002d6e:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8002d70:	4a55      	ldr	r2, [pc, #340]	; (8002ec8 <HAL_DMA_Init+0x838>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8002d72:	f003 041f 	and.w	r4, r3, #31
 8002d76:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8002d78:	4854      	ldr	r0, [pc, #336]	; (8002ecc <HAL_DMA_Init+0x83c>)
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8002d7a:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8002d7c:	40a1      	lsls	r1, r4
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8002d7e:	6668      	str	r0, [r5, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8002d80:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8002d82:	66a9      	str	r1, [r5, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8002d84:	662a      	str	r2, [r5, #96]	; 0x60
 8002d86:	e726      	b.n	8002bd6 <HAL_DMA_Init+0x546>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 8002d88:	4b47      	ldr	r3, [pc, #284]	; (8002ea8 <HAL_DMA_Init+0x818>)
 8002d8a:	429a      	cmp	r2, r3
 8002d8c:	d01e      	beq.n	8002dcc <HAL_DMA_Init+0x73c>
 8002d8e:	3314      	adds	r3, #20
 8002d90:	429a      	cmp	r2, r3
 8002d92:	d01b      	beq.n	8002dcc <HAL_DMA_Init+0x73c>
 8002d94:	4b46      	ldr	r3, [pc, #280]	; (8002eb0 <HAL_DMA_Init+0x820>)
 8002d96:	494e      	ldr	r1, [pc, #312]	; (8002ed0 <HAL_DMA_Init+0x840>)
 8002d98:	4c4e      	ldr	r4, [pc, #312]	; (8002ed4 <HAL_DMA_Init+0x844>)
 8002d9a:	428a      	cmp	r2, r1
 8002d9c:	bf18      	it	ne
 8002d9e:	429a      	cmpne	r2, r3
 8002da0:	484d      	ldr	r0, [pc, #308]	; (8002ed8 <HAL_DMA_Init+0x848>)
 8002da2:	f101 013c 	add.w	r1, r1, #60	; 0x3c
 8002da6:	bf0c      	ite	eq
 8002da8:	2301      	moveq	r3, #1
 8002daa:	2300      	movne	r3, #0
 8002dac:	42a2      	cmp	r2, r4
 8002dae:	bf08      	it	eq
 8002db0:	f043 0301 	orreq.w	r3, r3, #1
 8002db4:	4282      	cmp	r2, r0
 8002db6:	bf08      	it	eq
 8002db8:	f043 0301 	orreq.w	r3, r3, #1
 8002dbc:	428a      	cmp	r2, r1
 8002dbe:	bf08      	it	eq
 8002dc0:	f043 0301 	orreq.w	r3, r3, #1
 8002dc4:	b913      	cbnz	r3, 8002dcc <HAL_DMA_Init+0x73c>
 8002dc6:	4b3b      	ldr	r3, [pc, #236]	; (8002eb4 <HAL_DMA_Init+0x824>)
 8002dc8:	429a      	cmp	r2, r3
 8002dca:	d15d      	bne.n	8002e88 <HAL_DMA_Init+0x7f8>
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
 8002dcc:	686b      	ldr	r3, [r5, #4]
 8002dce:	2b11      	cmp	r3, #17
 8002dd0:	d853      	bhi.n	8002e7a <HAL_DMA_Init+0x7ea>
    hdma->State = HAL_DMA_STATE_BUSY;
 8002dd2:	2302      	movs	r3, #2
    __HAL_UNLOCK(hdma);
 8002dd4:	2100      	movs	r1, #0
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
 8002dd6:	4f41      	ldr	r7, [pc, #260]	; (8002edc <HAL_DMA_Init+0x84c>)
    hdma->State = HAL_DMA_STATE_BUSY;
 8002dd8:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 8002ddc:	68ab      	ldr	r3, [r5, #8]
    __HAL_UNLOCK(hdma);
 8002dde:	f885 1034 	strb.w	r1, [r5, #52]	; 0x34
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 8002de2:	2b40      	cmp	r3, #64	; 0x40
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
 8002de4:	6811      	ldr	r1, [r2, #0]
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
 8002de6:	ea07 0701 	and.w	r7, r7, r1
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 8002dea:	d044      	beq.n	8002e76 <HAL_DMA_Init+0x7e6>
 8002dec:	2b80      	cmp	r3, #128	; 0x80
 8002dee:	bf14      	ite	ne
 8002df0:	2100      	movne	r1, #0
 8002df2:	f44f 4180 	moveq.w	r1, #16384	; 0x4000
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 8002df6:	692b      	ldr	r3, [r5, #16]
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8002df8:	4628      	mov	r0, r5
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
 8002dfa:	68ec      	ldr	r4, [r5, #12]
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 8002dfc:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
 8002dfe:	696e      	ldr	r6, [r5, #20]
 8002e00:	ea43 03d4 	orr.w	r3, r3, r4, lsr #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
 8002e04:	69ac      	ldr	r4, [r5, #24]
 8002e06:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
 8002e0a:	69ee      	ldr	r6, [r5, #28]
 8002e0c:	ea43 03d4 	orr.w	r3, r3, r4, lsr #3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
 8002e10:	6a2c      	ldr	r4, [r5, #32]
 8002e12:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 8002e16:	4e32      	ldr	r6, [pc, #200]	; (8002ee0 <HAL_DMA_Init+0x850>)
 8002e18:	ea43 1314 	orr.w	r3, r3, r4, lsr #4
 8002e1c:	4c31      	ldr	r4, [pc, #196]	; (8002ee4 <HAL_DMA_Init+0x854>)
 8002e1e:	433b      	orrs	r3, r7
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 8002e20:	430b      	orrs	r3, r1
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
 8002e22:	6013      	str	r3, [r2, #0]
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 8002e24:	682b      	ldr	r3, [r5, #0]
 8002e26:	441e      	add	r6, r3
 8002e28:	fba4 2306 	umull	r2, r3, r4, r6
 8002e2c:	091b      	lsrs	r3, r3, #4
 8002e2e:	009b      	lsls	r3, r3, #2
 8002e30:	65eb      	str	r3, [r5, #92]	; 0x5c
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8002e32:	f7ff fbb1 	bl	8002598 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 8002e36:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8002e38:	2301      	movs	r3, #1
 8002e3a:	f002 021f 	and.w	r2, r2, #31
 8002e3e:	4093      	lsls	r3, r2
 8002e40:	6043      	str	r3, [r0, #4]
 8002e42:	e609      	b.n	8002a58 <HAL_DMA_Init+0x3c8>
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8002e44:	f1b0 7fc0 	cmp.w	r0, #25165824	; 0x1800000
 8002e48:	f47f adfc 	bne.w	8002a44 <HAL_DMA_Init+0x3b4>
 8002e4c:	e5c7      	b.n	80029de <HAL_DMA_Init+0x34e>
    switch (hdma->Init.FIFOThreshold)
 8002e4e:	2a03      	cmp	r2, #3
 8002e50:	f63f adf8 	bhi.w	8002a44 <HAL_DMA_Init+0x3b4>
 8002e54:	a401      	add	r4, pc, #4	; (adr r4, 8002e5c <HAL_DMA_Init+0x7cc>)
 8002e56:	f854 f022 	ldr.w	pc, [r4, r2, lsl #2]
 8002e5a:	bf00      	nop
 8002e5c:	080029df 	.word	0x080029df
 8002e60:	080029db 	.word	0x080029db
 8002e64:	080029df 	.word	0x080029df
 8002e68:	08002e45 	.word	0x08002e45
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8002e6c:	4b1e      	ldr	r3, [pc, #120]	; (8002ee8 <HAL_DMA_Init+0x858>)
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8002e6e:	4c1f      	ldr	r4, [pc, #124]	; (8002eec <HAL_DMA_Init+0x85c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8002e70:	4403      	add	r3, r0
 8002e72:	009b      	lsls	r3, r3, #2
 8002e74:	e760      	b.n	8002d38 <HAL_DMA_Init+0x6a8>
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 8002e76:	2110      	movs	r1, #16
 8002e78:	e7bd      	b.n	8002df6 <HAL_DMA_Init+0x766>
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
 8002e7a:	f44f 71b3 	mov.w	r1, #358	; 0x166
 8002e7e:	4809      	ldr	r0, [pc, #36]	; (8002ea4 <HAL_DMA_Init+0x814>)
 8002e80:	f010 fd26 	bl	80138d0 <assert_failed>
 8002e84:	682a      	ldr	r2, [r5, #0]
 8002e86:	e7a4      	b.n	8002dd2 <HAL_DMA_Init+0x742>
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8002e88:	2240      	movs	r2, #64	; 0x40
    hdma->State     = HAL_DMA_STATE_ERROR;
 8002e8a:	2303      	movs	r3, #3
    return HAL_ERROR;
 8002e8c:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8002e8e:	656a      	str	r2, [r5, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
 8002e90:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
    return HAL_ERROR;
 8002e94:	e6b4      	b.n	8002c00 <HAL_DMA_Init+0x570>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
 8002e96:	21e1      	movs	r1, #225	; 0xe1
 8002e98:	4802      	ldr	r0, [pc, #8]	; (8002ea4 <HAL_DMA_Init+0x814>)
 8002e9a:	f010 fd19 	bl	80138d0 <assert_failed>
 8002e9e:	e48f      	b.n	80027c0 <HAL_DMA_Init+0x130>
 8002ea0:	c3c0003f 	.word	0xc3c0003f
 8002ea4:	08029130 	.word	0x08029130
 8002ea8:	58025408 	.word	0x58025408
 8002eac:	5802541c 	.word	0x5802541c
 8002eb0:	58025430 	.word	0x58025430
 8002eb4:	58025494 	.word	0x58025494
 8002eb8:	1600963f 	.word	0x1600963f
 8002ebc:	58025940 	.word	0x58025940
 8002ec0:	bffdfbf0 	.word	0xbffdfbf0
 8002ec4:	aaaaaaab 	.word	0xaaaaaaab
 8002ec8:	10008200 	.word	0x10008200
 8002ecc:	40020880 	.word	0x40020880
 8002ed0:	58025444 	.word	0x58025444
 8002ed4:	58025458 	.word	0x58025458
 8002ed8:	5802546c 	.word	0x5802546c
 8002edc:	fffe000f 	.word	0xfffe000f
 8002ee0:	a7fdabf8 	.word	0xa7fdabf8
 8002ee4:	cccccccd 	.word	0xcccccccd
 8002ee8:	1000823f 	.word	0x1000823f
 8002eec:	40020940 	.word	0x40020940

08002ef0 <HAL_DMA_DeInit>:
  if(hdma == NULL)
 8002ef0:	2800      	cmp	r0, #0
 8002ef2:	f000 821c 	beq.w	800332e <HAL_DMA_DeInit+0x43e>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8002ef6:	49a7      	ldr	r1, [pc, #668]	; (8003194 <HAL_DMA_DeInit+0x2a4>)
{
 8002ef8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_DMA_DISABLE(hdma);
 8002efc:	6802      	ldr	r2, [r0, #0]
 8002efe:	4604      	mov	r4, r0
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8002f00:	4da5      	ldr	r5, [pc, #660]	; (8003198 <HAL_DMA_DeInit+0x2a8>)
  __HAL_DMA_DISABLE(hdma);
 8002f02:	6813      	ldr	r3, [r2, #0]
 8002f04:	f023 0301 	bic.w	r3, r3, #1
 8002f08:	6013      	str	r3, [r2, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8002f0a:	4ba4      	ldr	r3, [pc, #656]	; (800319c <HAL_DMA_DeInit+0x2ac>)
 8002f0c:	6802      	ldr	r2, [r0, #0]
 8002f0e:	48a4      	ldr	r0, [pc, #656]	; (80031a0 <HAL_DMA_DeInit+0x2b0>)
 8002f10:	4282      	cmp	r2, r0
 8002f12:	bf18      	it	ne
 8002f14:	429a      	cmpne	r2, r3
 8002f16:	f100 0048 	add.w	r0, r0, #72	; 0x48
 8002f1a:	bf0c      	ite	eq
 8002f1c:	2301      	moveq	r3, #1
 8002f1e:	2300      	movne	r3, #0
 8002f20:	428a      	cmp	r2, r1
 8002f22:	bf08      	it	eq
 8002f24:	f043 0301 	orreq.w	r3, r3, #1
 8002f28:	3148      	adds	r1, #72	; 0x48
 8002f2a:	42aa      	cmp	r2, r5
 8002f2c:	bf08      	it	eq
 8002f2e:	f043 0301 	orreq.w	r3, r3, #1
 8002f32:	3548      	adds	r5, #72	; 0x48
 8002f34:	4282      	cmp	r2, r0
 8002f36:	bf08      	it	eq
 8002f38:	f043 0301 	orreq.w	r3, r3, #1
 8002f3c:	3048      	adds	r0, #72	; 0x48
 8002f3e:	428a      	cmp	r2, r1
 8002f40:	bf08      	it	eq
 8002f42:	f043 0301 	orreq.w	r3, r3, #1
 8002f46:	f501 7162 	add.w	r1, r1, #904	; 0x388
 8002f4a:	42aa      	cmp	r2, r5
 8002f4c:	bf08      	it	eq
 8002f4e:	f043 0301 	orreq.w	r3, r3, #1
 8002f52:	f505 7562 	add.w	r5, r5, #904	; 0x388
 8002f56:	4282      	cmp	r2, r0
 8002f58:	bf08      	it	eq
 8002f5a:	f043 0301 	orreq.w	r3, r3, #1
 8002f5e:	f500 7062 	add.w	r0, r0, #904	; 0x388
 8002f62:	428a      	cmp	r2, r1
 8002f64:	bf08      	it	eq
 8002f66:	f043 0301 	orreq.w	r3, r3, #1
 8002f6a:	3148      	adds	r1, #72	; 0x48
 8002f6c:	42aa      	cmp	r2, r5
 8002f6e:	bf08      	it	eq
 8002f70:	f043 0301 	orreq.w	r3, r3, #1
 8002f74:	3548      	adds	r5, #72	; 0x48
 8002f76:	4282      	cmp	r2, r0
 8002f78:	bf08      	it	eq
 8002f7a:	f043 0301 	orreq.w	r3, r3, #1
 8002f7e:	3048      	adds	r0, #72	; 0x48
 8002f80:	428a      	cmp	r2, r1
 8002f82:	bf08      	it	eq
 8002f84:	f043 0301 	orreq.w	r3, r3, #1
 8002f88:	3148      	adds	r1, #72	; 0x48
 8002f8a:	42aa      	cmp	r2, r5
 8002f8c:	bf08      	it	eq
 8002f8e:	f043 0301 	orreq.w	r3, r3, #1
 8002f92:	4282      	cmp	r2, r0
 8002f94:	bf08      	it	eq
 8002f96:	f043 0301 	orreq.w	r3, r3, #1
 8002f9a:	428a      	cmp	r2, r1
 8002f9c:	bf08      	it	eq
 8002f9e:	f043 0301 	orreq.w	r3, r3, #1
 8002fa2:	b91b      	cbnz	r3, 8002fac <HAL_DMA_DeInit+0xbc>
 8002fa4:	4b7f      	ldr	r3, [pc, #508]	; (80031a4 <HAL_DMA_DeInit+0x2b4>)
 8002fa6:	429a      	cmp	r2, r3
 8002fa8:	f040 81c3 	bne.w	8003332 <HAL_DMA_DeInit+0x442>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
 8002fac:	2100      	movs	r1, #0
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
 8002fae:	2521      	movs	r5, #33	; 0x21
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8002fb0:	4b7a      	ldr	r3, [pc, #488]	; (800319c <HAL_DMA_DeInit+0x2ac>)
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
 8002fb2:	6011      	str	r1, [r2, #0]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
 8002fb4:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8002fb6:	487a      	ldr	r0, [pc, #488]	; (80031a0 <HAL_DMA_DeInit+0x2b0>)
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
 8002fb8:	6051      	str	r1, [r2, #4]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
 8002fba:	6822      	ldr	r2, [r4, #0]
 8002fbc:	6091      	str	r1, [r2, #8]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
 8002fbe:	6822      	ldr	r2, [r4, #0]
 8002fc0:	60d1      	str	r1, [r2, #12]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
 8002fc2:	6822      	ldr	r2, [r4, #0]
 8002fc4:	6111      	str	r1, [r2, #16]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
 8002fc6:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8002fc8:	4972      	ldr	r1, [pc, #456]	; (8003194 <HAL_DMA_DeInit+0x2a4>)
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
 8002fca:	6155      	str	r5, [r2, #20]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8002fcc:	6822      	ldr	r2, [r4, #0]
 8002fce:	4d72      	ldr	r5, [pc, #456]	; (8003198 <HAL_DMA_DeInit+0x2a8>)
 8002fd0:	4282      	cmp	r2, r0
 8002fd2:	bf18      	it	ne
 8002fd4:	429a      	cmpne	r2, r3
 8002fd6:	f100 0048 	add.w	r0, r0, #72	; 0x48
 8002fda:	bf0c      	ite	eq
 8002fdc:	2301      	moveq	r3, #1
 8002fde:	2300      	movne	r3, #0
 8002fe0:	428a      	cmp	r2, r1
 8002fe2:	bf08      	it	eq
 8002fe4:	f043 0301 	orreq.w	r3, r3, #1
 8002fe8:	3148      	adds	r1, #72	; 0x48
 8002fea:	42aa      	cmp	r2, r5
 8002fec:	bf08      	it	eq
 8002fee:	f043 0301 	orreq.w	r3, r3, #1
 8002ff2:	3548      	adds	r5, #72	; 0x48
 8002ff4:	4282      	cmp	r2, r0
 8002ff6:	bf08      	it	eq
 8002ff8:	f043 0301 	orreq.w	r3, r3, #1
 8002ffc:	3048      	adds	r0, #72	; 0x48
 8002ffe:	428a      	cmp	r2, r1
 8003000:	bf08      	it	eq
 8003002:	f043 0301 	orreq.w	r3, r3, #1
 8003006:	f501 7162 	add.w	r1, r1, #904	; 0x388
 800300a:	42aa      	cmp	r2, r5
 800300c:	bf08      	it	eq
 800300e:	f043 0301 	orreq.w	r3, r3, #1
 8003012:	f505 7562 	add.w	r5, r5, #904	; 0x388
 8003016:	4282      	cmp	r2, r0
 8003018:	bf08      	it	eq
 800301a:	f043 0301 	orreq.w	r3, r3, #1
 800301e:	f500 7062 	add.w	r0, r0, #904	; 0x388
 8003022:	428a      	cmp	r2, r1
 8003024:	bf08      	it	eq
 8003026:	f043 0301 	orreq.w	r3, r3, #1
 800302a:	3148      	adds	r1, #72	; 0x48
 800302c:	42aa      	cmp	r2, r5
 800302e:	bf08      	it	eq
 8003030:	f043 0301 	orreq.w	r3, r3, #1
 8003034:	3548      	adds	r5, #72	; 0x48
 8003036:	4282      	cmp	r2, r0
 8003038:	bf08      	it	eq
 800303a:	f043 0301 	orreq.w	r3, r3, #1
 800303e:	3048      	adds	r0, #72	; 0x48
 8003040:	428a      	cmp	r2, r1
 8003042:	bf08      	it	eq
 8003044:	f043 0301 	orreq.w	r3, r3, #1
 8003048:	3148      	adds	r1, #72	; 0x48
 800304a:	42aa      	cmp	r2, r5
 800304c:	bf08      	it	eq
 800304e:	f043 0301 	orreq.w	r3, r3, #1
 8003052:	4282      	cmp	r2, r0
 8003054:	bf08      	it	eq
 8003056:	f043 0301 	orreq.w	r3, r3, #1
 800305a:	428a      	cmp	r2, r1
 800305c:	bf08      	it	eq
 800305e:	f043 0301 	orreq.w	r3, r3, #1
 8003062:	b91b      	cbnz	r3, 800306c <HAL_DMA_DeInit+0x17c>
 8003064:	4b4f      	ldr	r3, [pc, #316]	; (80031a4 <HAL_DMA_DeInit+0x2b4>)
 8003066:	429a      	cmp	r2, r3
 8003068:	f040 819d 	bne.w	80033a6 <HAL_DMA_DeInit+0x4b6>
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800306c:	b2d3      	uxtb	r3, r2
 800306e:	4d4e      	ldr	r5, [pc, #312]	; (80031a8 <HAL_DMA_DeInit+0x2b8>)
 8003070:	494e      	ldr	r1, [pc, #312]	; (80031ac <HAL_DMA_DeInit+0x2bc>)
 8003072:	3b10      	subs	r3, #16
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 8003074:	484e      	ldr	r0, [pc, #312]	; (80031b0 <HAL_DMA_DeInit+0x2c0>)
 8003076:	4011      	ands	r1, r2
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8003078:	fba5 5303 	umull	r5, r3, r5, r3
 800307c:	091b      	lsrs	r3, r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 800307e:	f003 0207 	and.w	r2, r3, #7
    if (stream_number > 3U)
 8003082:	2b03      	cmp	r3, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 8003084:	5c82      	ldrb	r2, [r0, r2]
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
 8003086:	bf88      	it	hi
 8003088:	3104      	addhi	r1, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 800308a:	65e2      	str	r2, [r4, #92]	; 0x5c
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
 800308c:	65a1      	str	r1, [r4, #88]	; 0x58
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800308e:	f002 021f 	and.w	r2, r2, #31
 8003092:	233f      	movs	r3, #63	; 0x3f
 8003094:	fa03 f202 	lsl.w	r2, r3, r2
 8003098:	608a      	str	r2, [r1, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800309a:	6822      	ldr	r2, [r4, #0]
 800309c:	4b3f      	ldr	r3, [pc, #252]	; (800319c <HAL_DMA_DeInit+0x2ac>)
 800309e:	4840      	ldr	r0, [pc, #256]	; (80031a0 <HAL_DMA_DeInit+0x2b0>)
 80030a0:	493c      	ldr	r1, [pc, #240]	; (8003194 <HAL_DMA_DeInit+0x2a4>)
 80030a2:	4282      	cmp	r2, r0
 80030a4:	bf18      	it	ne
 80030a6:	429a      	cmpne	r2, r3
 80030a8:	4e3b      	ldr	r6, [pc, #236]	; (8003198 <HAL_DMA_DeInit+0x2a8>)
 80030aa:	4d42      	ldr	r5, [pc, #264]	; (80031b4 <HAL_DMA_DeInit+0x2c4>)
 80030ac:	f100 0060 	add.w	r0, r0, #96	; 0x60
 80030b0:	bf0c      	ite	eq
 80030b2:	2301      	moveq	r3, #1
 80030b4:	2300      	movne	r3, #0
 80030b6:	f8df e104 	ldr.w	lr, [pc, #260]	; 80031bc <HAL_DMA_DeInit+0x2cc>
 80030ba:	428a      	cmp	r2, r1
 80030bc:	bf08      	it	eq
 80030be:	f043 0301 	orreq.w	r3, r3, #1
 80030c2:	3160      	adds	r1, #96	; 0x60
 80030c4:	f8df c0f8 	ldr.w	ip, [pc, #248]	; 80031c0 <HAL_DMA_DeInit+0x2d0>
 80030c8:	42b2      	cmp	r2, r6
 80030ca:	bf08      	it	eq
 80030cc:	f043 0301 	orreq.w	r3, r3, #1
 80030d0:	4f39      	ldr	r7, [pc, #228]	; (80031b8 <HAL_DMA_DeInit+0x2c8>)
 80030d2:	f506 767a 	add.w	r6, r6, #1000	; 0x3e8
 80030d6:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 80031c4 <HAL_DMA_DeInit+0x2d4>
 80030da:	42aa      	cmp	r2, r5
 80030dc:	bf08      	it	eq
 80030de:	f043 0301 	orreq.w	r3, r3, #1
 80030e2:	f505 757a 	add.w	r5, r5, #1000	; 0x3e8
 80030e6:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 80031c8 <HAL_DMA_DeInit+0x2d8>
 80030ea:	4282      	cmp	r2, r0
 80030ec:	bf08      	it	eq
 80030ee:	f043 0301 	orreq.w	r3, r3, #1
 80030f2:	f500 707a 	add.w	r0, r0, #1000	; 0x3e8
 80030f6:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 80031a4 <HAL_DMA_DeInit+0x2b4>
 80030fa:	428a      	cmp	r2, r1
 80030fc:	bf08      	it	eq
 80030fe:	f043 0301 	orreq.w	r3, r3, #1
 8003102:	f501 717a 	add.w	r1, r1, #1000	; 0x3e8
 8003106:	4572      	cmp	r2, lr
 8003108:	bf08      	it	eq
 800310a:	f043 0301 	orreq.w	r3, r3, #1
 800310e:	f8df e0bc 	ldr.w	lr, [pc, #188]	; 80031cc <HAL_DMA_DeInit+0x2dc>
 8003112:	4562      	cmp	r2, ip
 8003114:	bf08      	it	eq
 8003116:	f043 0301 	orreq.w	r3, r3, #1
 800311a:	eba2 0e0e 	sub.w	lr, r2, lr
 800311e:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 80031d0 <HAL_DMA_DeInit+0x2e0>
 8003122:	42ba      	cmp	r2, r7
 8003124:	bf08      	it	eq
 8003126:	f043 0301 	orreq.w	r3, r3, #1
 800312a:	fabe fe8e 	clz	lr, lr
 800312e:	eba2 070c 	sub.w	r7, r2, ip
 8003132:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
 8003136:	42b2      	cmp	r2, r6
 8003138:	bf08      	it	eq
 800313a:	f043 0301 	orreq.w	r3, r3, #1
 800313e:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 8003142:	eba2 060a 	sub.w	r6, r2, sl
 8003146:	fab7 f787 	clz	r7, r7
 800314a:	42aa      	cmp	r2, r5
 800314c:	bf08      	it	eq
 800314e:	f043 0301 	orreq.w	r3, r3, #1
 8003152:	f10a 0a28 	add.w	sl, sl, #40	; 0x28
 8003156:	eba2 050c 	sub.w	r5, r2, ip
 800315a:	097f      	lsrs	r7, r7, #5
 800315c:	4282      	cmp	r2, r0
 800315e:	bf08      	it	eq
 8003160:	f043 0301 	orreq.w	r3, r3, #1
 8003164:	fab6 f686 	clz	r6, r6
 8003168:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
 800316c:	fab5 f585 	clz	r5, r5
 8003170:	428a      	cmp	r2, r1
 8003172:	bf08      	it	eq
 8003174:	f043 0301 	orreq.w	r3, r3, #1
 8003178:	0976      	lsrs	r6, r6, #5
 800317a:	eba2 000a 	sub.w	r0, r2, sl
 800317e:	eba2 010c 	sub.w	r1, r2, ip
 8003182:	4542      	cmp	r2, r8
 8003184:	bf08      	it	eq
 8003186:	f043 0301 	orreq.w	r3, r3, #1
 800318a:	096d      	lsrs	r5, r5, #5
 800318c:	fab0 f080 	clz	r0, r0
 8003190:	e020      	b.n	80031d4 <HAL_DMA_DeInit+0x2e4>
 8003192:	bf00      	nop
 8003194:	40020040 	.word	0x40020040
 8003198:	40020058 	.word	0x40020058
 800319c:	40020010 	.word	0x40020010
 80031a0:	40020028 	.word	0x40020028
 80031a4:	400204b8 	.word	0x400204b8
 80031a8:	aaaaaaab 	.word	0xaaaaaaab
 80031ac:	fffffc00 	.word	0xfffffc00
 80031b0:	08029168 	.word	0x08029168
 80031b4:	40020070 	.word	0x40020070
 80031b8:	40020428 	.word	0x40020428
 80031bc:	400200b8 	.word	0x400200b8
 80031c0:	40020410 	.word	0x40020410
 80031c4:	400204a0 	.word	0x400204a0
 80031c8:	58025430 	.word	0x58025430
 80031cc:	58025408 	.word	0x58025408
 80031d0:	5802541c 	.word	0x5802541c
 80031d4:	f10c 0c14 	add.w	ip, ip, #20
 80031d8:	454a      	cmp	r2, r9
 80031da:	bf08      	it	eq
 80031dc:	f043 0301 	orreq.w	r3, r3, #1
 80031e0:	fab1 f181 	clz	r1, r1
 80031e4:	0940      	lsrs	r0, r0, #5
 80031e6:	eba2 0c0c 	sub.w	ip, r2, ip
 80031ea:	ea4e 0303 	orr.w	r3, lr, r3
 80031ee:	0949      	lsrs	r1, r1, #5
 80031f0:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 80033d8 <HAL_DMA_DeInit+0x4e8>
 80031f4:	fabc fc8c 	clz	ip, ip
 80031f8:	433b      	orrs	r3, r7
 80031fa:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
 80031fe:	eba2 0808 	sub.w	r8, r2, r8
 8003202:	4333      	orrs	r3, r6
 8003204:	fab8 f888 	clz	r8, r8
 8003208:	432b      	orrs	r3, r5
 800320a:	ea4f 1858 	mov.w	r8, r8, lsr #5
 800320e:	4303      	orrs	r3, r0
 8003210:	430b      	orrs	r3, r1
 8003212:	ea5c 0303 	orrs.w	r3, ip, r3
 8003216:	d102      	bne.n	800321e <HAL_DMA_DeInit+0x32e>
 8003218:	f1b8 0f00 	cmp.w	r8, #0
 800321c:	d02b      	beq.n	8003276 <HAL_DMA_DeInit+0x386>
  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 800321e:	ea47 070e 	orr.w	r7, r7, lr
 8003222:	b2d3      	uxtb	r3, r2
 8003224:	433e      	orrs	r6, r7
 8003226:	4335      	orrs	r5, r6
 8003228:	4328      	orrs	r0, r5
 800322a:	4301      	orrs	r1, r0
 800322c:	ea5c 0101 	orrs.w	r1, ip, r1
 8003230:	d102      	bne.n	8003238 <HAL_DMA_DeInit+0x348>
 8003232:	f1b8 0f00 	cmp.w	r8, #0
 8003236:	d063      	beq.n	8003300 <HAL_DMA_DeInit+0x410>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 8003238:	4861      	ldr	r0, [pc, #388]	; (80033c0 <HAL_DMA_DeInit+0x4d0>)
 800323a:	3b08      	subs	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 800323c:	4a61      	ldr	r2, [pc, #388]	; (80033c4 <HAL_DMA_DeInit+0x4d4>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800323e:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 8003240:	fba0 0303 	umull	r0, r3, r0, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 8003244:	4860      	ldr	r0, [pc, #384]	; (80033c8 <HAL_DMA_DeInit+0x4d8>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 8003246:	091b      	lsrs	r3, r3, #4
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 8003248:	6660      	str	r0, [r4, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 800324a:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800324c:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8003250:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003252:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8003256:	6622      	str	r2, [r4, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003258:	66a3      	str	r3, [r4, #104]	; 0x68
    if(hdma->DMAmuxChannel != 0U)
 800325a:	b122      	cbz	r2, 8003266 <HAL_DMA_DeInit+0x376>
      hdma->DMAmuxChannel->CCR = 0U;
 800325c:	2300      	movs	r3, #0
 800325e:	6013      	str	r3, [r2, #0]
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8003260:	e9d4 3219 	ldrd	r3, r2, [r4, #100]	; 0x64
 8003264:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 8003266:	6860      	ldr	r0, [r4, #4]
 8003268:	1e41      	subs	r1, r0, #1
 800326a:	2907      	cmp	r1, #7
 800326c:	d912      	bls.n	8003294 <HAL_DMA_DeInit+0x3a4>
    hdma->DMAmuxRequestGen = 0U;
 800326e:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
 8003270:	e9c4 331b 	strd	r3, r3, [r4, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatusMask = 0U;
 8003274:	6763      	str	r3, [r4, #116]	; 0x74
  hdma->XferCpltCallback       = NULL;
 8003276:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003278:	6563      	str	r3, [r4, #84]	; 0x54
  return HAL_OK;
 800327a:	4618      	mov	r0, r3
  hdma->State = HAL_DMA_STATE_RESET;
 800327c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_UNLOCK(hdma);
 8003280:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  hdma->XferHalfCpltCallback   = NULL;
 8003284:	e9c4 330f 	strd	r3, r3, [r4, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
 8003288:	e9c4 3311 	strd	r3, r3, [r4, #68]	; 0x44
  hdma->XferAbortCallback      = NULL;
 800328c:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
}
 8003290:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 8003294:	6822      	ldr	r2, [r4, #0]
 8003296:	4b4d      	ldr	r3, [pc, #308]	; (80033cc <HAL_DMA_DeInit+0x4dc>)
 8003298:	4e4d      	ldr	r6, [pc, #308]	; (80033d0 <HAL_DMA_DeInit+0x4e0>)
 800329a:	4d4e      	ldr	r5, [pc, #312]	; (80033d4 <HAL_DMA_DeInit+0x4e4>)
 800329c:	42b2      	cmp	r2, r6
 800329e:	bf18      	it	ne
 80032a0:	429a      	cmpne	r2, r3
 80032a2:	f106 0628 	add.w	r6, r6, #40	; 0x28
 80032a6:	bf0c      	ite	eq
 80032a8:	2301      	moveq	r3, #1
 80032aa:	2300      	movne	r3, #0
 80032ac:	42aa      	cmp	r2, r5
 80032ae:	bf08      	it	eq
 80032b0:	f043 0301 	orreq.w	r3, r3, #1
 80032b4:	3528      	adds	r5, #40	; 0x28
 80032b6:	42b2      	cmp	r2, r6
 80032b8:	bf08      	it	eq
 80032ba:	f043 0301 	orreq.w	r3, r3, #1
 80032be:	3628      	adds	r6, #40	; 0x28
 80032c0:	42aa      	cmp	r2, r5
 80032c2:	bf08      	it	eq
 80032c4:	f043 0301 	orreq.w	r3, r3, #1
 80032c8:	3528      	adds	r5, #40	; 0x28
 80032ca:	42b2      	cmp	r2, r6
 80032cc:	bf08      	it	eq
 80032ce:	f043 0301 	orreq.w	r3, r3, #1
 80032d2:	42aa      	cmp	r2, r5
 80032d4:	bf08      	it	eq
 80032d6:	f043 0301 	orreq.w	r3, r3, #1
 80032da:	b913      	cbnz	r3, 80032e2 <HAL_DMA_DeInit+0x3f2>
 80032dc:	4b3e      	ldr	r3, [pc, #248]	; (80033d8 <HAL_DMA_DeInit+0x4e8>)
 80032de:	429a      	cmp	r2, r3
 80032e0:	d169      	bne.n	80033b6 <HAL_DMA_DeInit+0x4c6>
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 80032e2:	4a3e      	ldr	r2, [pc, #248]	; (80033dc <HAL_DMA_DeInit+0x4ec>)
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 80032e4:	4d3e      	ldr	r5, [pc, #248]	; (80033e0 <HAL_DMA_DeInit+0x4f0>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 80032e6:	4402      	add	r2, r0
 80032e8:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 80032ea:	2301      	movs	r3, #1
      hdma->DMAmuxRequestGen->RGCR = 0U;
 80032ec:	2000      	movs	r0, #0
 80032ee:	6725      	str	r5, [r4, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 80032f0:	fa03 f101 	lsl.w	r1, r3, r1
 80032f4:	6761      	str	r1, [r4, #116]	; 0x74
      hdma->DMAmuxRequestGen->RGCR = 0U;
 80032f6:	6010      	str	r0, [r2, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80032f8:	e9d4 321c 	ldrd	r3, r2, [r4, #112]	; 0x70
 80032fc:	605a      	str	r2, [r3, #4]
 80032fe:	e7b6      	b.n	800326e <HAL_DMA_DeInit+0x37e>
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8003300:	4938      	ldr	r1, [pc, #224]	; (80033e4 <HAL_DMA_DeInit+0x4f4>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8003302:	3b10      	subs	r3, #16
 8003304:	4838      	ldr	r0, [pc, #224]	; (80033e8 <HAL_DMA_DeInit+0x4f8>)
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8003306:	4411      	add	r1, r2
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8003308:	fba0 0303 	umull	r0, r3, r0, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 800330c:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800330e:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8003312:	d800      	bhi.n	8003316 <HAL_DMA_DeInit+0x426>
      stream_number += 8U;
 8003314:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8003316:	4a35      	ldr	r2, [pc, #212]	; (80033ec <HAL_DMA_DeInit+0x4fc>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003318:	f003 051f 	and.w	r5, r3, #31
 800331c:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 800331e:	4834      	ldr	r0, [pc, #208]	; (80033f0 <HAL_DMA_DeInit+0x500>)
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8003320:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003322:	40a9      	lsls	r1, r5
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8003324:	6660      	str	r0, [r4, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8003326:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003328:	66a1      	str	r1, [r4, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 800332a:	6622      	str	r2, [r4, #96]	; 0x60
 800332c:	e795      	b.n	800325a <HAL_DMA_DeInit+0x36a>
    return HAL_ERROR;
 800332e:	2001      	movs	r0, #1
}
 8003330:	4770      	bx	lr
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 8003332:	4b26      	ldr	r3, [pc, #152]	; (80033cc <HAL_DMA_DeInit+0x4dc>)
 8003334:	4926      	ldr	r1, [pc, #152]	; (80033d0 <HAL_DMA_DeInit+0x4e0>)
 8003336:	4827      	ldr	r0, [pc, #156]	; (80033d4 <HAL_DMA_DeInit+0x4e4>)
 8003338:	428a      	cmp	r2, r1
 800333a:	bf18      	it	ne
 800333c:	429a      	cmpne	r2, r3
 800333e:	f101 0128 	add.w	r1, r1, #40	; 0x28
 8003342:	4d2c      	ldr	r5, [pc, #176]	; (80033f4 <HAL_DMA_DeInit+0x504>)
 8003344:	bf0c      	ite	eq
 8003346:	2301      	moveq	r3, #1
 8003348:	2300      	movne	r3, #0
 800334a:	4282      	cmp	r2, r0
 800334c:	bf08      	it	eq
 800334e:	f043 0301 	orreq.w	r3, r3, #1
 8003352:	303c      	adds	r0, #60	; 0x3c
 8003354:	428a      	cmp	r2, r1
 8003356:	bf08      	it	eq
 8003358:	f043 0301 	orreq.w	r3, r3, #1
 800335c:	313c      	adds	r1, #60	; 0x3c
 800335e:	42aa      	cmp	r2, r5
 8003360:	bf08      	it	eq
 8003362:	f043 0301 	orreq.w	r3, r3, #1
 8003366:	4282      	cmp	r2, r0
 8003368:	bf08      	it	eq
 800336a:	f043 0301 	orreq.w	r3, r3, #1
 800336e:	428a      	cmp	r2, r1
 8003370:	bf08      	it	eq
 8003372:	f043 0301 	orreq.w	r3, r3, #1
 8003376:	b913      	cbnz	r3, 800337e <HAL_DMA_DeInit+0x48e>
 8003378:	4b17      	ldr	r3, [pc, #92]	; (80033d8 <HAL_DMA_DeInit+0x4e8>)
 800337a:	429a      	cmp	r2, r3
 800337c:	d118      	bne.n	80033b0 <HAL_DMA_DeInit+0x4c0>
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
 800337e:	2300      	movs	r3, #0
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8003380:	4620      	mov	r0, r4
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
 8003382:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
 8003384:	6822      	ldr	r2, [r4, #0]
 8003386:	6053      	str	r3, [r2, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
 8003388:	6822      	ldr	r2, [r4, #0]
 800338a:	6093      	str	r3, [r2, #8]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
 800338c:	6822      	ldr	r2, [r4, #0]
 800338e:	60d3      	str	r3, [r2, #12]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
 8003390:	6822      	ldr	r2, [r4, #0]
 8003392:	6113      	str	r3, [r2, #16]
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8003394:	f7ff f900 	bl	8002598 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 8003398:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800339a:	2301      	movs	r3, #1
 800339c:	f002 021f 	and.w	r2, r2, #31
 80033a0:	4093      	lsls	r3, r2
 80033a2:	6043      	str	r3, [r0, #4]
 80033a4:	e679      	b.n	800309a <HAL_DMA_DeInit+0x1aa>
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
 80033a6:	f022 01ff 	bic.w	r1, r2, #255	; 0xff
 80033aa:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80033ac:	65a1      	str	r1, [r4, #88]	; 0x58
 80033ae:	e66e      	b.n	800308e <HAL_DMA_DeInit+0x19e>
    return HAL_ERROR;
 80033b0:	2001      	movs	r0, #1
}
 80033b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80033b6:	4a10      	ldr	r2, [pc, #64]	; (80033f8 <HAL_DMA_DeInit+0x508>)
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 80033b8:	4d10      	ldr	r5, [pc, #64]	; (80033fc <HAL_DMA_DeInit+0x50c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80033ba:	4402      	add	r2, r0
 80033bc:	0092      	lsls	r2, r2, #2
 80033be:	e794      	b.n	80032ea <HAL_DMA_DeInit+0x3fa>
 80033c0:	cccccccd 	.word	0xcccccccd
 80033c4:	16009600 	.word	0x16009600
 80033c8:	58025880 	.word	0x58025880
 80033cc:	58025408 	.word	0x58025408
 80033d0:	5802541c 	.word	0x5802541c
 80033d4:	58025430 	.word	0x58025430
 80033d8:	58025494 	.word	0x58025494
 80033dc:	1600963f 	.word	0x1600963f
 80033e0:	58025940 	.word	0x58025940
 80033e4:	bffdfbf0 	.word	0xbffdfbf0
 80033e8:	aaaaaaab 	.word	0xaaaaaaab
 80033ec:	10008200 	.word	0x10008200
 80033f0:	40020880 	.word	0x40020880
 80033f4:	58025458 	.word	0x58025458
 80033f8:	1000823f 	.word	0x1000823f
 80033fc:	40020940 	.word	0x40020940

08003400 <HAL_DMA_Start_IT>:
{
 8003400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003402:	461d      	mov	r5, r3
 8003404:	460e      	mov	r6, r1
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 8003406:	f64f 73fe 	movw	r3, #65534	; 0xfffe
{
 800340a:	4604      	mov	r4, r0
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 800340c:	1e69      	subs	r1, r5, #1
{
 800340e:	4617      	mov	r7, r2
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 8003410:	4299      	cmp	r1, r3
 8003412:	d813      	bhi.n	800343c <HAL_DMA_Start_IT+0x3c>
  if(hdma == NULL)
 8003414:	b1cc      	cbz	r4, 800344a <HAL_DMA_Start_IT+0x4a>
  __HAL_LOCK(hdma);
 8003416:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800341a:	2b01      	cmp	r3, #1
 800341c:	f000 826f 	beq.w	80038fe <HAL_DMA_Start_IT+0x4fe>
 8003420:	2001      	movs	r0, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 8003422:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 8003426:	4283      	cmp	r3, r0
  __HAL_LOCK(hdma);
 8003428:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 800342c:	d012      	beq.n	8003454 <HAL_DMA_Start_IT+0x54>
    __HAL_UNLOCK(hdma);
 800342e:	2200      	movs	r2, #0
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8003430:	f44f 6300 	mov.w	r3, #2048	; 0x800
    __HAL_UNLOCK(hdma);
 8003434:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8003438:	6563      	str	r3, [r4, #84]	; 0x54
}
 800343a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 800343c:	f240 21a7 	movw	r1, #679	; 0x2a7
 8003440:	4803      	ldr	r0, [pc, #12]	; (8003450 <HAL_DMA_Start_IT+0x50>)
 8003442:	f010 fa45 	bl	80138d0 <assert_failed>
  if(hdma == NULL)
 8003446:	2c00      	cmp	r4, #0
 8003448:	d1e5      	bne.n	8003416 <HAL_DMA_Start_IT+0x16>
    return HAL_ERROR;
 800344a:	2001      	movs	r0, #1
}
 800344c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800344e:	bf00      	nop
 8003450:	08029130 	.word	0x08029130
    hdma->State = HAL_DMA_STATE_BUSY;
 8003454:	2002      	movs	r0, #2
    __HAL_DMA_DISABLE(hdma);
 8003456:	6822      	ldr	r2, [r4, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
 8003458:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800345c:	2000      	movs	r0, #0
 800345e:	6560      	str	r0, [r4, #84]	; 0x54
    __HAL_DMA_DISABLE(hdma);
 8003460:	6813      	ldr	r3, [r2, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003462:	489e      	ldr	r0, [pc, #632]	; (80036dc <HAL_DMA_Start_IT+0x2dc>)
    __HAL_DMA_DISABLE(hdma);
 8003464:	f023 0301 	bic.w	r3, r3, #1
 8003468:	6013      	str	r3, [r2, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800346a:	4a9d      	ldr	r2, [pc, #628]	; (80036e0 <HAL_DMA_Start_IT+0x2e0>)
 800346c:	6821      	ldr	r1, [r4, #0]
 800346e:	4b9d      	ldr	r3, [pc, #628]	; (80036e4 <HAL_DMA_Start_IT+0x2e4>)
 8003470:	4291      	cmp	r1, r2
 8003472:	bf18      	it	ne
 8003474:	4281      	cmpne	r1, r0
 8003476:	f102 0230 	add.w	r2, r2, #48	; 0x30
 800347a:	bf0c      	ite	eq
 800347c:	2001      	moveq	r0, #1
 800347e:	2000      	movne	r0, #0
 8003480:	4299      	cmp	r1, r3
 8003482:	bf08      	it	eq
 8003484:	f040 0001 	orreq.w	r0, r0, #1
 8003488:	3330      	adds	r3, #48	; 0x30
 800348a:	4291      	cmp	r1, r2
 800348c:	bf08      	it	eq
 800348e:	f040 0001 	orreq.w	r0, r0, #1
 8003492:	3230      	adds	r2, #48	; 0x30
 8003494:	4299      	cmp	r1, r3
 8003496:	bf08      	it	eq
 8003498:	f040 0001 	orreq.w	r0, r0, #1
 800349c:	3330      	adds	r3, #48	; 0x30
 800349e:	4291      	cmp	r1, r2
 80034a0:	bf08      	it	eq
 80034a2:	f040 0001 	orreq.w	r0, r0, #1
 80034a6:	3230      	adds	r2, #48	; 0x30
 80034a8:	4299      	cmp	r1, r3
 80034aa:	bf08      	it	eq
 80034ac:	f040 0001 	orreq.w	r0, r0, #1
 80034b0:	f503 735c 	add.w	r3, r3, #880	; 0x370
 80034b4:	4291      	cmp	r1, r2
 80034b6:	bf08      	it	eq
 80034b8:	f040 0001 	orreq.w	r0, r0, #1
 80034bc:	f502 725c 	add.w	r2, r2, #880	; 0x370
 80034c0:	4299      	cmp	r1, r3
 80034c2:	bf08      	it	eq
 80034c4:	f040 0001 	orreq.w	r0, r0, #1
 80034c8:	3330      	adds	r3, #48	; 0x30
 80034ca:	4291      	cmp	r1, r2
 80034cc:	bf08      	it	eq
 80034ce:	f040 0001 	orreq.w	r0, r0, #1
 80034d2:	3230      	adds	r2, #48	; 0x30
 80034d4:	4299      	cmp	r1, r3
 80034d6:	bf08      	it	eq
 80034d8:	f040 0001 	orreq.w	r0, r0, #1
 80034dc:	3330      	adds	r3, #48	; 0x30
 80034de:	4291      	cmp	r1, r2
 80034e0:	bf08      	it	eq
 80034e2:	f040 0001 	orreq.w	r0, r0, #1
 80034e6:	3230      	adds	r2, #48	; 0x30
 80034e8:	4299      	cmp	r1, r3
 80034ea:	bf08      	it	eq
 80034ec:	f040 0001 	orreq.w	r0, r0, #1
 80034f0:	3330      	adds	r3, #48	; 0x30
 80034f2:	4291      	cmp	r1, r2
 80034f4:	bf08      	it	eq
 80034f6:	f040 0001 	orreq.w	r0, r0, #1
 80034fa:	3230      	adds	r2, #48	; 0x30
 80034fc:	4299      	cmp	r1, r3
 80034fe:	bf08      	it	eq
 8003500:	f040 0001 	orreq.w	r0, r0, #1
 8003504:	4b78      	ldr	r3, [pc, #480]	; (80036e8 <HAL_DMA_Start_IT+0x2e8>)
 8003506:	4291      	cmp	r1, r2
 8003508:	bf08      	it	eq
 800350a:	f040 0001 	orreq.w	r0, r0, #1
 800350e:	4a77      	ldr	r2, [pc, #476]	; (80036ec <HAL_DMA_Start_IT+0x2ec>)
 8003510:	4299      	cmp	r1, r3
 8003512:	bf08      	it	eq
 8003514:	f040 0001 	orreq.w	r0, r0, #1
 8003518:	3328      	adds	r3, #40	; 0x28
 800351a:	4291      	cmp	r1, r2
 800351c:	bf08      	it	eq
 800351e:	f040 0001 	orreq.w	r0, r0, #1
 8003522:	3228      	adds	r2, #40	; 0x28
 8003524:	4299      	cmp	r1, r3
 8003526:	bf08      	it	eq
 8003528:	f040 0001 	orreq.w	r0, r0, #1
 800352c:	3328      	adds	r3, #40	; 0x28
 800352e:	4291      	cmp	r1, r2
 8003530:	bf08      	it	eq
 8003532:	f040 0001 	orreq.w	r0, r0, #1
 8003536:	3228      	adds	r2, #40	; 0x28
 8003538:	4299      	cmp	r1, r3
 800353a:	bf08      	it	eq
 800353c:	f040 0001 	orreq.w	r0, r0, #1
 8003540:	3328      	adds	r3, #40	; 0x28
 8003542:	4291      	cmp	r1, r2
 8003544:	bf08      	it	eq
 8003546:	f040 0001 	orreq.w	r0, r0, #1
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800354a:	6da2      	ldr	r2, [r4, #88]	; 0x58
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800354c:	4299      	cmp	r1, r3
 800354e:	bf08      	it	eq
 8003550:	f040 0001 	orreq.w	r0, r0, #1
 8003554:	b910      	cbnz	r0, 800355c <HAL_DMA_Start_IT+0x15c>
 8003556:	3314      	adds	r3, #20
 8003558:	4299      	cmp	r1, r3
 800355a:	d108      	bne.n	800356e <HAL_DMA_Start_IT+0x16e>
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800355c:	e9d4 3119 	ldrd	r3, r1, [r4, #100]	; 0x64
 8003560:	6059      	str	r1, [r3, #4]
    if(hdma->DMAmuxRequestGen != 0U)
 8003562:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8003564:	b113      	cbz	r3, 800356c <HAL_DMA_Start_IT+0x16c>
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8003566:	e9d4 311c 	ldrd	r3, r1, [r4, #112]	; 0x70
 800356a:	6059      	str	r1, [r3, #4]
 800356c:	6821      	ldr	r1, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800356e:	4b5b      	ldr	r3, [pc, #364]	; (80036dc <HAL_DMA_Start_IT+0x2dc>)
 8003570:	f8df c16c 	ldr.w	ip, [pc, #364]	; 80036e0 <HAL_DMA_Start_IT+0x2e0>
 8003574:	485b      	ldr	r0, [pc, #364]	; (80036e4 <HAL_DMA_Start_IT+0x2e4>)
 8003576:	4561      	cmp	r1, ip
 8003578:	bf18      	it	ne
 800357a:	4299      	cmpne	r1, r3
 800357c:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 8003580:	bf0c      	ite	eq
 8003582:	2301      	moveq	r3, #1
 8003584:	2300      	movne	r3, #0
 8003586:	4281      	cmp	r1, r0
 8003588:	bf08      	it	eq
 800358a:	f043 0301 	orreq.w	r3, r3, #1
 800358e:	3030      	adds	r0, #48	; 0x30
 8003590:	4561      	cmp	r1, ip
 8003592:	bf08      	it	eq
 8003594:	f043 0301 	orreq.w	r3, r3, #1
 8003598:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 800359c:	4281      	cmp	r1, r0
 800359e:	bf08      	it	eq
 80035a0:	f043 0301 	orreq.w	r3, r3, #1
 80035a4:	3030      	adds	r0, #48	; 0x30
 80035a6:	4561      	cmp	r1, ip
 80035a8:	bf08      	it	eq
 80035aa:	f043 0301 	orreq.w	r3, r3, #1
 80035ae:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80035b2:	4281      	cmp	r1, r0
 80035b4:	bf08      	it	eq
 80035b6:	f043 0301 	orreq.w	r3, r3, #1
 80035ba:	f500 705c 	add.w	r0, r0, #880	; 0x370
 80035be:	4561      	cmp	r1, ip
 80035c0:	bf08      	it	eq
 80035c2:	f043 0301 	orreq.w	r3, r3, #1
 80035c6:	f50c 7c5c 	add.w	ip, ip, #880	; 0x370
 80035ca:	4281      	cmp	r1, r0
 80035cc:	bf08      	it	eq
 80035ce:	f043 0301 	orreq.w	r3, r3, #1
 80035d2:	3030      	adds	r0, #48	; 0x30
 80035d4:	4561      	cmp	r1, ip
 80035d6:	bf08      	it	eq
 80035d8:	f043 0301 	orreq.w	r3, r3, #1
 80035dc:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80035e0:	4281      	cmp	r1, r0
 80035e2:	bf08      	it	eq
 80035e4:	f043 0301 	orreq.w	r3, r3, #1
 80035e8:	3030      	adds	r0, #48	; 0x30
 80035ea:	4561      	cmp	r1, ip
 80035ec:	bf08      	it	eq
 80035ee:	f043 0301 	orreq.w	r3, r3, #1
 80035f2:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80035f6:	4281      	cmp	r1, r0
 80035f8:	bf08      	it	eq
 80035fa:	f043 0301 	orreq.w	r3, r3, #1
 80035fe:	3030      	adds	r0, #48	; 0x30
 8003600:	4561      	cmp	r1, ip
 8003602:	bf08      	it	eq
 8003604:	f043 0301 	orreq.w	r3, r3, #1
 8003608:	4281      	cmp	r1, r0
 800360a:	bf08      	it	eq
 800360c:	f043 0301 	orreq.w	r3, r3, #1
 8003610:	b91b      	cbnz	r3, 800361a <HAL_DMA_Start_IT+0x21a>
 8003612:	4b37      	ldr	r3, [pc, #220]	; (80036f0 <HAL_DMA_Start_IT+0x2f0>)
 8003614:	4299      	cmp	r1, r3
 8003616:	f040 8174 	bne.w	8003902 <HAL_DMA_Start_IT+0x502>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800361a:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 800361c:	233f      	movs	r3, #63	; 0x3f
 800361e:	f001 011f 	and.w	r1, r1, #31
 8003622:	408b      	lsls	r3, r1
 8003624:	6093      	str	r3, [r2, #8]
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8003626:	6822      	ldr	r2, [r4, #0]
 8003628:	6813      	ldr	r3, [r2, #0]
 800362a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800362e:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
 8003630:	6823      	ldr	r3, [r4, #0]
 8003632:	605d      	str	r5, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8003634:	68a3      	ldr	r3, [r4, #8]
 8003636:	2b40      	cmp	r3, #64	; 0x40
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
 8003638:	6823      	ldr	r3, [r4, #0]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800363a:	f000 815b 	beq.w	80038f4 <HAL_DMA_Start_IT+0x4f4>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
 800363e:	609e      	str	r6, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
 8003640:	6823      	ldr	r3, [r4, #0]
 8003642:	60df      	str	r7, [r3, #12]
 8003644:	6821      	ldr	r1, [r4, #0]
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003646:	4b25      	ldr	r3, [pc, #148]	; (80036dc <HAL_DMA_Start_IT+0x2dc>)
 8003648:	4825      	ldr	r0, [pc, #148]	; (80036e0 <HAL_DMA_Start_IT+0x2e0>)
 800364a:	4a26      	ldr	r2, [pc, #152]	; (80036e4 <HAL_DMA_Start_IT+0x2e4>)
 800364c:	4281      	cmp	r1, r0
 800364e:	bf18      	it	ne
 8003650:	4299      	cmpne	r1, r3
 8003652:	4d28      	ldr	r5, [pc, #160]	; (80036f4 <HAL_DMA_Start_IT+0x2f4>)
 8003654:	f100 0048 	add.w	r0, r0, #72	; 0x48
 8003658:	bf0c      	ite	eq
 800365a:	2301      	moveq	r3, #1
 800365c:	2300      	movne	r3, #0
 800365e:	4291      	cmp	r1, r2
 8003660:	bf08      	it	eq
 8003662:	f043 0301 	orreq.w	r3, r3, #1
 8003666:	3248      	adds	r2, #72	; 0x48
 8003668:	42a9      	cmp	r1, r5
 800366a:	bf08      	it	eq
 800366c:	f043 0301 	orreq.w	r3, r3, #1
 8003670:	3548      	adds	r5, #72	; 0x48
 8003672:	4281      	cmp	r1, r0
 8003674:	bf08      	it	eq
 8003676:	f043 0301 	orreq.w	r3, r3, #1
 800367a:	3048      	adds	r0, #72	; 0x48
 800367c:	4291      	cmp	r1, r2
 800367e:	bf08      	it	eq
 8003680:	f043 0301 	orreq.w	r3, r3, #1
 8003684:	f502 7262 	add.w	r2, r2, #904	; 0x388
 8003688:	42a9      	cmp	r1, r5
 800368a:	bf08      	it	eq
 800368c:	f043 0301 	orreq.w	r3, r3, #1
 8003690:	f505 7562 	add.w	r5, r5, #904	; 0x388
 8003694:	4281      	cmp	r1, r0
 8003696:	bf08      	it	eq
 8003698:	f043 0301 	orreq.w	r3, r3, #1
 800369c:	f500 7062 	add.w	r0, r0, #904	; 0x388
 80036a0:	4291      	cmp	r1, r2
 80036a2:	bf08      	it	eq
 80036a4:	f043 0301 	orreq.w	r3, r3, #1
 80036a8:	3248      	adds	r2, #72	; 0x48
 80036aa:	42a9      	cmp	r1, r5
 80036ac:	bf08      	it	eq
 80036ae:	f043 0301 	orreq.w	r3, r3, #1
 80036b2:	3548      	adds	r5, #72	; 0x48
 80036b4:	4281      	cmp	r1, r0
 80036b6:	bf08      	it	eq
 80036b8:	f043 0301 	orreq.w	r3, r3, #1
 80036bc:	3048      	adds	r0, #72	; 0x48
 80036be:	4291      	cmp	r1, r2
 80036c0:	bf08      	it	eq
 80036c2:	f043 0301 	orreq.w	r3, r3, #1
 80036c6:	3248      	adds	r2, #72	; 0x48
 80036c8:	42a9      	cmp	r1, r5
 80036ca:	bf08      	it	eq
 80036cc:	f043 0301 	orreq.w	r3, r3, #1
 80036d0:	4281      	cmp	r1, r0
 80036d2:	bf08      	it	eq
 80036d4:	f043 0301 	orreq.w	r3, r3, #1
 80036d8:	e00e      	b.n	80036f8 <HAL_DMA_Start_IT+0x2f8>
 80036da:	bf00      	nop
 80036dc:	40020010 	.word	0x40020010
 80036e0:	40020028 	.word	0x40020028
 80036e4:	40020040 	.word	0x40020040
 80036e8:	58025408 	.word	0x58025408
 80036ec:	5802541c 	.word	0x5802541c
 80036f0:	400204b8 	.word	0x400204b8
 80036f4:	40020058 	.word	0x40020058
 80036f8:	4291      	cmp	r1, r2
 80036fa:	bf08      	it	eq
 80036fc:	f043 0301 	orreq.w	r3, r3, #1
 8003700:	b91b      	cbnz	r3, 800370a <HAL_DMA_Start_IT+0x30a>
 8003702:	4b9a      	ldr	r3, [pc, #616]	; (800396c <HAL_DMA_Start_IT+0x56c>)
 8003704:	4299      	cmp	r1, r3
 8003706:	f040 8145 	bne.w	8003994 <HAL_DMA_Start_IT+0x594>
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
 800370a:	680b      	ldr	r3, [r1, #0]
 800370c:	f023 031e 	bic.w	r3, r3, #30
 8003710:	f043 0316 	orr.w	r3, r3, #22
 8003714:	600b      	str	r3, [r1, #0]
      if(hdma->XferHalfCpltCallback != NULL)
 8003716:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8003718:	b123      	cbz	r3, 8003724 <HAL_DMA_Start_IT+0x324>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
 800371a:	6822      	ldr	r2, [r4, #0]
 800371c:	6813      	ldr	r3, [r2, #0]
 800371e:	f043 0308 	orr.w	r3, r3, #8
 8003722:	6013      	str	r3, [r2, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003724:	6821      	ldr	r1, [r4, #0]
 8003726:	4b92      	ldr	r3, [pc, #584]	; (8003970 <HAL_DMA_Start_IT+0x570>)
 8003728:	4a92      	ldr	r2, [pc, #584]	; (8003974 <HAL_DMA_Start_IT+0x574>)
 800372a:	4d93      	ldr	r5, [pc, #588]	; (8003978 <HAL_DMA_Start_IT+0x578>)
 800372c:	4291      	cmp	r1, r2
 800372e:	bf18      	it	ne
 8003730:	4299      	cmpne	r1, r3
 8003732:	4892      	ldr	r0, [pc, #584]	; (800397c <HAL_DMA_Start_IT+0x57c>)
 8003734:	f102 0248 	add.w	r2, r2, #72	; 0x48
 8003738:	bf0c      	ite	eq
 800373a:	2301      	moveq	r3, #1
 800373c:	2300      	movne	r3, #0
 800373e:	42a9      	cmp	r1, r5
 8003740:	bf08      	it	eq
 8003742:	f043 0301 	orreq.w	r3, r3, #1
 8003746:	3548      	adds	r5, #72	; 0x48
 8003748:	4281      	cmp	r1, r0
 800374a:	bf08      	it	eq
 800374c:	f043 0301 	orreq.w	r3, r3, #1
 8003750:	3048      	adds	r0, #72	; 0x48
 8003752:	4291      	cmp	r1, r2
 8003754:	bf08      	it	eq
 8003756:	f043 0301 	orreq.w	r3, r3, #1
 800375a:	3248      	adds	r2, #72	; 0x48
 800375c:	42a9      	cmp	r1, r5
 800375e:	bf08      	it	eq
 8003760:	f043 0301 	orreq.w	r3, r3, #1
 8003764:	f505 7562 	add.w	r5, r5, #904	; 0x388
 8003768:	4281      	cmp	r1, r0
 800376a:	bf08      	it	eq
 800376c:	f043 0301 	orreq.w	r3, r3, #1
 8003770:	f500 7062 	add.w	r0, r0, #904	; 0x388
 8003774:	4291      	cmp	r1, r2
 8003776:	bf08      	it	eq
 8003778:	f043 0301 	orreq.w	r3, r3, #1
 800377c:	f502 7262 	add.w	r2, r2, #904	; 0x388
 8003780:	42a9      	cmp	r1, r5
 8003782:	bf08      	it	eq
 8003784:	f043 0301 	orreq.w	r3, r3, #1
 8003788:	3548      	adds	r5, #72	; 0x48
 800378a:	4281      	cmp	r1, r0
 800378c:	bf08      	it	eq
 800378e:	f043 0301 	orreq.w	r3, r3, #1
 8003792:	3048      	adds	r0, #72	; 0x48
 8003794:	4291      	cmp	r1, r2
 8003796:	bf08      	it	eq
 8003798:	f043 0301 	orreq.w	r3, r3, #1
 800379c:	3248      	adds	r2, #72	; 0x48
 800379e:	42a9      	cmp	r1, r5
 80037a0:	bf08      	it	eq
 80037a2:	f043 0301 	orreq.w	r3, r3, #1
 80037a6:	3548      	adds	r5, #72	; 0x48
 80037a8:	4281      	cmp	r1, r0
 80037aa:	bf08      	it	eq
 80037ac:	f043 0301 	orreq.w	r3, r3, #1
 80037b0:	3048      	adds	r0, #72	; 0x48
 80037b2:	4291      	cmp	r1, r2
 80037b4:	bf08      	it	eq
 80037b6:	f043 0301 	orreq.w	r3, r3, #1
 80037ba:	f102 52c0 	add.w	r2, r2, #402653184	; 0x18000000
 80037be:	42a9      	cmp	r1, r5
 80037c0:	bf08      	it	eq
 80037c2:	f043 0301 	orreq.w	r3, r3, #1
 80037c6:	f502 429f 	add.w	r2, r2, #20352	; 0x4f80
 80037ca:	4d6d      	ldr	r5, [pc, #436]	; (8003980 <HAL_DMA_Start_IT+0x580>)
 80037cc:	4281      	cmp	r1, r0
 80037ce:	bf08      	it	eq
 80037d0:	f043 0301 	orreq.w	r3, r3, #1
 80037d4:	486b      	ldr	r0, [pc, #428]	; (8003984 <HAL_DMA_Start_IT+0x584>)
 80037d6:	4291      	cmp	r1, r2
 80037d8:	bf08      	it	eq
 80037da:	f043 0301 	orreq.w	r3, r3, #1
 80037de:	323c      	adds	r2, #60	; 0x3c
 80037e0:	42a9      	cmp	r1, r5
 80037e2:	bf08      	it	eq
 80037e4:	f043 0301 	orreq.w	r3, r3, #1
 80037e8:	353c      	adds	r5, #60	; 0x3c
 80037ea:	4281      	cmp	r1, r0
 80037ec:	bf08      	it	eq
 80037ee:	f043 0301 	orreq.w	r3, r3, #1
 80037f2:	303c      	adds	r0, #60	; 0x3c
 80037f4:	4291      	cmp	r1, r2
 80037f6:	bf08      	it	eq
 80037f8:	f043 0301 	orreq.w	r3, r3, #1
 80037fc:	323c      	adds	r2, #60	; 0x3c
 80037fe:	42a9      	cmp	r1, r5
 8003800:	bf08      	it	eq
 8003802:	f043 0301 	orreq.w	r3, r3, #1
 8003806:	4281      	cmp	r1, r0
 8003808:	bf08      	it	eq
 800380a:	f043 0301 	orreq.w	r3, r3, #1
 800380e:	4291      	cmp	r1, r2
 8003810:	bf08      	it	eq
 8003812:	f043 0301 	orreq.w	r3, r3, #1
 8003816:	b913      	cbnz	r3, 800381e <HAL_DMA_Start_IT+0x41e>
 8003818:	4b5b      	ldr	r3, [pc, #364]	; (8003988 <HAL_DMA_Start_IT+0x588>)
 800381a:	4299      	cmp	r1, r3
 800381c:	d10e      	bne.n	800383c <HAL_DMA_Start_IT+0x43c>
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 800381e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8003820:	681a      	ldr	r2, [r3, #0]
 8003822:	03d2      	lsls	r2, r2, #15
 8003824:	d503      	bpl.n	800382e <HAL_DMA_Start_IT+0x42e>
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 8003826:	681a      	ldr	r2, [r3, #0]
 8003828:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800382c:	601a      	str	r2, [r3, #0]
      if(hdma->DMAmuxRequestGen != 0U)
 800382e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8003830:	b11b      	cbz	r3, 800383a <HAL_DMA_Start_IT+0x43a>
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 8003832:	681a      	ldr	r2, [r3, #0]
 8003834:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8003838:	601a      	str	r2, [r3, #0]
 800383a:	6821      	ldr	r1, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 800383c:	4b4c      	ldr	r3, [pc, #304]	; (8003970 <HAL_DMA_Start_IT+0x570>)
 800383e:	484d      	ldr	r0, [pc, #308]	; (8003974 <HAL_DMA_Start_IT+0x574>)
 8003840:	4a4d      	ldr	r2, [pc, #308]	; (8003978 <HAL_DMA_Start_IT+0x578>)
 8003842:	4281      	cmp	r1, r0
 8003844:	bf18      	it	ne
 8003846:	4299      	cmpne	r1, r3
 8003848:	4d4c      	ldr	r5, [pc, #304]	; (800397c <HAL_DMA_Start_IT+0x57c>)
 800384a:	4c50      	ldr	r4, [pc, #320]	; (800398c <HAL_DMA_Start_IT+0x58c>)
 800384c:	f100 0060 	add.w	r0, r0, #96	; 0x60
 8003850:	bf0c      	ite	eq
 8003852:	2301      	moveq	r3, #1
 8003854:	2300      	movne	r3, #0
 8003856:	4291      	cmp	r1, r2
 8003858:	bf08      	it	eq
 800385a:	f043 0301 	orreq.w	r3, r3, #1
 800385e:	3260      	adds	r2, #96	; 0x60
 8003860:	42a9      	cmp	r1, r5
 8003862:	bf08      	it	eq
 8003864:	f043 0301 	orreq.w	r3, r3, #1
 8003868:	3560      	adds	r5, #96	; 0x60
 800386a:	42a1      	cmp	r1, r4
 800386c:	bf08      	it	eq
 800386e:	f043 0301 	orreq.w	r3, r3, #1
 8003872:	f504 7468 	add.w	r4, r4, #928	; 0x3a0
 8003876:	4281      	cmp	r1, r0
 8003878:	bf08      	it	eq
 800387a:	f043 0301 	orreq.w	r3, r3, #1
 800387e:	f500 7068 	add.w	r0, r0, #928	; 0x3a0
 8003882:	4291      	cmp	r1, r2
 8003884:	bf08      	it	eq
 8003886:	f043 0301 	orreq.w	r3, r3, #1
 800388a:	f502 7268 	add.w	r2, r2, #928	; 0x3a0
 800388e:	42a9      	cmp	r1, r5
 8003890:	bf08      	it	eq
 8003892:	f043 0301 	orreq.w	r3, r3, #1
 8003896:	f505 7568 	add.w	r5, r5, #928	; 0x3a0
 800389a:	42a1      	cmp	r1, r4
 800389c:	bf08      	it	eq
 800389e:	f043 0301 	orreq.w	r3, r3, #1
 80038a2:	3460      	adds	r4, #96	; 0x60
 80038a4:	4281      	cmp	r1, r0
 80038a6:	bf08      	it	eq
 80038a8:	f043 0301 	orreq.w	r3, r3, #1
 80038ac:	3060      	adds	r0, #96	; 0x60
 80038ae:	4291      	cmp	r1, r2
 80038b0:	bf08      	it	eq
 80038b2:	f043 0301 	orreq.w	r3, r3, #1
 80038b6:	3260      	adds	r2, #96	; 0x60
 80038b8:	42a9      	cmp	r1, r5
 80038ba:	bf08      	it	eq
 80038bc:	f043 0301 	orreq.w	r3, r3, #1
 80038c0:	42a1      	cmp	r1, r4
 80038c2:	bf08      	it	eq
 80038c4:	f043 0301 	orreq.w	r3, r3, #1
 80038c8:	4281      	cmp	r1, r0
 80038ca:	bf08      	it	eq
 80038cc:	f043 0301 	orreq.w	r3, r3, #1
 80038d0:	4291      	cmp	r1, r2
 80038d2:	bf08      	it	eq
 80038d4:	f043 0301 	orreq.w	r3, r3, #1
 80038d8:	b933      	cbnz	r3, 80038e8 <HAL_DMA_Start_IT+0x4e8>
 80038da:	3030      	adds	r0, #48	; 0x30
 80038dc:	1a08      	subs	r0, r1, r0
 80038de:	fab0 f080 	clz	r0, r0
 80038e2:	0940      	lsrs	r0, r0, #5
 80038e4:	2800      	cmp	r0, #0
 80038e6:	d03c      	beq.n	8003962 <HAL_DMA_Start_IT+0x562>
 80038e8:	680b      	ldr	r3, [r1, #0]
  HAL_StatusTypeDef status = HAL_OK;
 80038ea:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
 80038ec:	f043 0301 	orr.w	r3, r3, #1
 80038f0:	600b      	str	r3, [r1, #0]
}
 80038f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
 80038f4:	609f      	str	r7, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
 80038f6:	6823      	ldr	r3, [r4, #0]
 80038f8:	60de      	str	r6, [r3, #12]
 80038fa:	6821      	ldr	r1, [r4, #0]
 80038fc:	e6a3      	b.n	8003646 <HAL_DMA_Start_IT+0x246>
  __HAL_LOCK(hdma);
 80038fe:	2002      	movs	r0, #2
}
 8003900:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 8003902:	4b23      	ldr	r3, [pc, #140]	; (8003990 <HAL_DMA_Start_IT+0x590>)
 8003904:	f8df c078 	ldr.w	ip, [pc, #120]	; 8003980 <HAL_DMA_Start_IT+0x580>
 8003908:	481e      	ldr	r0, [pc, #120]	; (8003984 <HAL_DMA_Start_IT+0x584>)
 800390a:	4561      	cmp	r1, ip
 800390c:	bf18      	it	ne
 800390e:	4299      	cmpne	r1, r3
 8003910:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
 8003914:	bf0c      	ite	eq
 8003916:	2301      	moveq	r3, #1
 8003918:	2300      	movne	r3, #0
 800391a:	4281      	cmp	r1, r0
 800391c:	bf08      	it	eq
 800391e:	f043 0301 	orreq.w	r3, r3, #1
 8003922:	3028      	adds	r0, #40	; 0x28
 8003924:	4561      	cmp	r1, ip
 8003926:	bf08      	it	eq
 8003928:	f043 0301 	orreq.w	r3, r3, #1
 800392c:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
 8003930:	4281      	cmp	r1, r0
 8003932:	bf08      	it	eq
 8003934:	f043 0301 	orreq.w	r3, r3, #1
 8003938:	3028      	adds	r0, #40	; 0x28
 800393a:	4561      	cmp	r1, ip
 800393c:	bf08      	it	eq
 800393e:	f043 0301 	orreq.w	r3, r3, #1
 8003942:	4281      	cmp	r1, r0
 8003944:	bf08      	it	eq
 8003946:	f043 0301 	orreq.w	r3, r3, #1
 800394a:	b91b      	cbnz	r3, 8003954 <HAL_DMA_Start_IT+0x554>
 800394c:	4b0e      	ldr	r3, [pc, #56]	; (8003988 <HAL_DMA_Start_IT+0x588>)
 800394e:	4299      	cmp	r1, r3
 8003950:	f47f ae79 	bne.w	8003646 <HAL_DMA_Start_IT+0x246>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 8003954:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8003956:	2301      	movs	r3, #1
 8003958:	f001 011f 	and.w	r1, r1, #31
 800395c:	408b      	lsls	r3, r1
 800395e:	6053      	str	r3, [r2, #4]
 8003960:	e666      	b.n	8003630 <HAL_DMA_Start_IT+0x230>
    __HAL_DMA_ENABLE(hdma);
 8003962:	680b      	ldr	r3, [r1, #0]
 8003964:	f043 0301 	orr.w	r3, r3, #1
 8003968:	600b      	str	r3, [r1, #0]
}
 800396a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800396c:	400204b8 	.word	0x400204b8
 8003970:	40020010 	.word	0x40020010
 8003974:	40020028 	.word	0x40020028
 8003978:	40020040 	.word	0x40020040
 800397c:	40020058 	.word	0x40020058
 8003980:	5802541c 	.word	0x5802541c
 8003984:	58025430 	.word	0x58025430
 8003988:	58025494 	.word	0x58025494
 800398c:	40020070 	.word	0x40020070
 8003990:	58025408 	.word	0x58025408
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
 8003994:	680b      	ldr	r3, [r1, #0]
 8003996:	f023 030e 	bic.w	r3, r3, #14
 800399a:	f043 030a 	orr.w	r3, r3, #10
 800399e:	600b      	str	r3, [r1, #0]
      if(hdma->XferHalfCpltCallback != NULL)
 80039a0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80039a2:	2b00      	cmp	r3, #0
 80039a4:	f43f aebe 	beq.w	8003724 <HAL_DMA_Start_IT+0x324>
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
 80039a8:	6822      	ldr	r2, [r4, #0]
 80039aa:	6813      	ldr	r3, [r2, #0]
 80039ac:	f043 0304 	orr.w	r3, r3, #4
 80039b0:	6013      	str	r3, [r2, #0]
 80039b2:	e6b7      	b.n	8003724 <HAL_DMA_Start_IT+0x324>

080039b4 <HAL_DMA_Abort>:
{
 80039b4:	b570      	push	{r4, r5, r6, lr}
 80039b6:	4606      	mov	r6, r0
  uint32_t tickstart = HAL_GetTick();
 80039b8:	f7fd f836 	bl	8000a28 <HAL_GetTick>
  if(hdma == NULL)
 80039bc:	2e00      	cmp	r6, #0
 80039be:	f000 81ef 	beq.w	8003da0 <HAL_DMA_Abort+0x3ec>
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80039c2:	f896 3035 	ldrb.w	r3, [r6, #53]	; 0x35
 80039c6:	2b02      	cmp	r3, #2
 80039c8:	d006      	beq.n	80039d8 <HAL_DMA_Abort+0x24>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80039ca:	2280      	movs	r2, #128	; 0x80
    __HAL_UNLOCK(hdma);
 80039cc:	2300      	movs	r3, #0
    return HAL_ERROR;
 80039ce:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80039d0:	6572      	str	r2, [r6, #84]	; 0x54
    __HAL_UNLOCK(hdma);
 80039d2:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
}
 80039d6:	bd70      	pop	{r4, r5, r6, pc}
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80039d8:	6832      	ldr	r2, [r6, #0]
 80039da:	4604      	mov	r4, r0
 80039dc:	4b6f      	ldr	r3, [pc, #444]	; (8003b9c <HAL_DMA_Abort+0x1e8>)
 80039de:	4870      	ldr	r0, [pc, #448]	; (8003ba0 <HAL_DMA_Abort+0x1ec>)
 80039e0:	4970      	ldr	r1, [pc, #448]	; (8003ba4 <HAL_DMA_Abort+0x1f0>)
 80039e2:	4282      	cmp	r2, r0
 80039e4:	bf18      	it	ne
 80039e6:	429a      	cmpne	r2, r3
 80039e8:	f100 0030 	add.w	r0, r0, #48	; 0x30
 80039ec:	bf0c      	ite	eq
 80039ee:	2301      	moveq	r3, #1
 80039f0:	2300      	movne	r3, #0
 80039f2:	428a      	cmp	r2, r1
 80039f4:	bf08      	it	eq
 80039f6:	f043 0301 	orreq.w	r3, r3, #1
 80039fa:	3130      	adds	r1, #48	; 0x30
 80039fc:	4282      	cmp	r2, r0
 80039fe:	bf08      	it	eq
 8003a00:	f043 0301 	orreq.w	r3, r3, #1
 8003a04:	3030      	adds	r0, #48	; 0x30
 8003a06:	428a      	cmp	r2, r1
 8003a08:	bf08      	it	eq
 8003a0a:	f043 0301 	orreq.w	r3, r3, #1
 8003a0e:	3130      	adds	r1, #48	; 0x30
 8003a10:	4282      	cmp	r2, r0
 8003a12:	bf08      	it	eq
 8003a14:	f043 0301 	orreq.w	r3, r3, #1
 8003a18:	3030      	adds	r0, #48	; 0x30
 8003a1a:	428a      	cmp	r2, r1
 8003a1c:	bf08      	it	eq
 8003a1e:	f043 0301 	orreq.w	r3, r3, #1
 8003a22:	f501 715c 	add.w	r1, r1, #880	; 0x370
 8003a26:	4282      	cmp	r2, r0
 8003a28:	bf08      	it	eq
 8003a2a:	f043 0301 	orreq.w	r3, r3, #1
 8003a2e:	f500 705c 	add.w	r0, r0, #880	; 0x370
 8003a32:	428a      	cmp	r2, r1
 8003a34:	bf08      	it	eq
 8003a36:	f043 0301 	orreq.w	r3, r3, #1
 8003a3a:	3130      	adds	r1, #48	; 0x30
 8003a3c:	4282      	cmp	r2, r0
 8003a3e:	bf08      	it	eq
 8003a40:	f043 0301 	orreq.w	r3, r3, #1
 8003a44:	3030      	adds	r0, #48	; 0x30
 8003a46:	428a      	cmp	r2, r1
 8003a48:	bf08      	it	eq
 8003a4a:	f043 0301 	orreq.w	r3, r3, #1
 8003a4e:	3130      	adds	r1, #48	; 0x30
 8003a50:	4282      	cmp	r2, r0
 8003a52:	bf08      	it	eq
 8003a54:	f043 0301 	orreq.w	r3, r3, #1
 8003a58:	3030      	adds	r0, #48	; 0x30
 8003a5a:	428a      	cmp	r2, r1
 8003a5c:	bf08      	it	eq
 8003a5e:	f043 0301 	orreq.w	r3, r3, #1
 8003a62:	3130      	adds	r1, #48	; 0x30
 8003a64:	4282      	cmp	r2, r0
 8003a66:	bf08      	it	eq
 8003a68:	f043 0301 	orreq.w	r3, r3, #1
 8003a6c:	428a      	cmp	r2, r1
 8003a6e:	bf08      	it	eq
 8003a70:	f043 0301 	orreq.w	r3, r3, #1
 8003a74:	b91b      	cbnz	r3, 8003a7e <HAL_DMA_Abort+0xca>
 8003a76:	4b4c      	ldr	r3, [pc, #304]	; (8003ba8 <HAL_DMA_Abort+0x1f4>)
 8003a78:	429a      	cmp	r2, r3
 8003a7a:	f040 819d 	bne.w	8003db8 <HAL_DMA_Abort+0x404>
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
 8003a7e:	6813      	ldr	r3, [r2, #0]
 8003a80:	f023 031e 	bic.w	r3, r3, #30
 8003a84:	6013      	str	r3, [r2, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
 8003a86:	6832      	ldr	r2, [r6, #0]
 8003a88:	6953      	ldr	r3, [r2, #20]
 8003a8a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8003a8e:	6153      	str	r3, [r2, #20]
      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));
 8003a90:	6832      	ldr	r2, [r6, #0]
 8003a92:	4615      	mov	r5, r2
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003a94:	4b41      	ldr	r3, [pc, #260]	; (8003b9c <HAL_DMA_Abort+0x1e8>)
 8003a96:	4842      	ldr	r0, [pc, #264]	; (8003ba0 <HAL_DMA_Abort+0x1ec>)
 8003a98:	4942      	ldr	r1, [pc, #264]	; (8003ba4 <HAL_DMA_Abort+0x1f0>)
 8003a9a:	4282      	cmp	r2, r0
 8003a9c:	bf18      	it	ne
 8003a9e:	429a      	cmpne	r2, r3
 8003aa0:	f100 0030 	add.w	r0, r0, #48	; 0x30
 8003aa4:	bf0c      	ite	eq
 8003aa6:	2301      	moveq	r3, #1
 8003aa8:	2300      	movne	r3, #0
 8003aaa:	428a      	cmp	r2, r1
 8003aac:	bf08      	it	eq
 8003aae:	f043 0301 	orreq.w	r3, r3, #1
 8003ab2:	3130      	adds	r1, #48	; 0x30
 8003ab4:	4282      	cmp	r2, r0
 8003ab6:	bf08      	it	eq
 8003ab8:	f043 0301 	orreq.w	r3, r3, #1
 8003abc:	3030      	adds	r0, #48	; 0x30
 8003abe:	428a      	cmp	r2, r1
 8003ac0:	bf08      	it	eq
 8003ac2:	f043 0301 	orreq.w	r3, r3, #1
 8003ac6:	3130      	adds	r1, #48	; 0x30
 8003ac8:	4282      	cmp	r2, r0
 8003aca:	bf08      	it	eq
 8003acc:	f043 0301 	orreq.w	r3, r3, #1
 8003ad0:	3030      	adds	r0, #48	; 0x30
 8003ad2:	428a      	cmp	r2, r1
 8003ad4:	bf08      	it	eq
 8003ad6:	f043 0301 	orreq.w	r3, r3, #1
 8003ada:	f501 715c 	add.w	r1, r1, #880	; 0x370
 8003ade:	4282      	cmp	r2, r0
 8003ae0:	bf08      	it	eq
 8003ae2:	f043 0301 	orreq.w	r3, r3, #1
 8003ae6:	f500 705c 	add.w	r0, r0, #880	; 0x370
 8003aea:	428a      	cmp	r2, r1
 8003aec:	bf08      	it	eq
 8003aee:	f043 0301 	orreq.w	r3, r3, #1
 8003af2:	3130      	adds	r1, #48	; 0x30
 8003af4:	4282      	cmp	r2, r0
 8003af6:	bf08      	it	eq
 8003af8:	f043 0301 	orreq.w	r3, r3, #1
 8003afc:	3030      	adds	r0, #48	; 0x30
 8003afe:	428a      	cmp	r2, r1
 8003b00:	bf08      	it	eq
 8003b02:	f043 0301 	orreq.w	r3, r3, #1
 8003b06:	3130      	adds	r1, #48	; 0x30
 8003b08:	4282      	cmp	r2, r0
 8003b0a:	bf08      	it	eq
 8003b0c:	f043 0301 	orreq.w	r3, r3, #1
 8003b10:	3030      	adds	r0, #48	; 0x30
 8003b12:	428a      	cmp	r2, r1
 8003b14:	bf08      	it	eq
 8003b16:	f043 0301 	orreq.w	r3, r3, #1
 8003b1a:	3130      	adds	r1, #48	; 0x30
 8003b1c:	4282      	cmp	r2, r0
 8003b1e:	bf08      	it	eq
 8003b20:	f043 0301 	orreq.w	r3, r3, #1
 8003b24:	3030      	adds	r0, #48	; 0x30
 8003b26:	428a      	cmp	r2, r1
 8003b28:	bf08      	it	eq
 8003b2a:	f043 0301 	orreq.w	r3, r3, #1
 8003b2e:	491f      	ldr	r1, [pc, #124]	; (8003bac <HAL_DMA_Abort+0x1f8>)
 8003b30:	4282      	cmp	r2, r0
 8003b32:	bf08      	it	eq
 8003b34:	f043 0301 	orreq.w	r3, r3, #1
 8003b38:	481d      	ldr	r0, [pc, #116]	; (8003bb0 <HAL_DMA_Abort+0x1fc>)
 8003b3a:	428a      	cmp	r2, r1
 8003b3c:	bf08      	it	eq
 8003b3e:	f043 0301 	orreq.w	r3, r3, #1
 8003b42:	3128      	adds	r1, #40	; 0x28
 8003b44:	4282      	cmp	r2, r0
 8003b46:	bf08      	it	eq
 8003b48:	f043 0301 	orreq.w	r3, r3, #1
 8003b4c:	3028      	adds	r0, #40	; 0x28
 8003b4e:	428a      	cmp	r2, r1
 8003b50:	bf08      	it	eq
 8003b52:	f043 0301 	orreq.w	r3, r3, #1
 8003b56:	3128      	adds	r1, #40	; 0x28
 8003b58:	4282      	cmp	r2, r0
 8003b5a:	bf08      	it	eq
 8003b5c:	f043 0301 	orreq.w	r3, r3, #1
 8003b60:	3028      	adds	r0, #40	; 0x28
 8003b62:	428a      	cmp	r2, r1
 8003b64:	bf08      	it	eq
 8003b66:	f043 0301 	orreq.w	r3, r3, #1
 8003b6a:	3128      	adds	r1, #40	; 0x28
 8003b6c:	4282      	cmp	r2, r0
 8003b6e:	bf08      	it	eq
 8003b70:	f043 0301 	orreq.w	r3, r3, #1
 8003b74:	428a      	cmp	r2, r1
 8003b76:	bf08      	it	eq
 8003b78:	f043 0301 	orreq.w	r3, r3, #1
 8003b7c:	b913      	cbnz	r3, 8003b84 <HAL_DMA_Abort+0x1d0>
 8003b7e:	4b0d      	ldr	r3, [pc, #52]	; (8003bb4 <HAL_DMA_Abort+0x200>)
 8003b80:	429a      	cmp	r2, r3
 8003b82:	d105      	bne.n	8003b90 <HAL_DMA_Abort+0x1dc>
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8003b84:	6e32      	ldr	r2, [r6, #96]	; 0x60
 8003b86:	6813      	ldr	r3, [r2, #0]
 8003b88:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003b8c:	6013      	str	r3, [r2, #0]
 8003b8e:	6832      	ldr	r2, [r6, #0]
    __HAL_DMA_DISABLE(hdma);
 8003b90:	6813      	ldr	r3, [r2, #0]
 8003b92:	f023 0301 	bic.w	r3, r3, #1
 8003b96:	6013      	str	r3, [r2, #0]
 8003b98:	e014      	b.n	8003bc4 <HAL_DMA_Abort+0x210>
 8003b9a:	bf00      	nop
 8003b9c:	40020010 	.word	0x40020010
 8003ba0:	40020028 	.word	0x40020028
 8003ba4:	40020040 	.word	0x40020040
 8003ba8:	400204b8 	.word	0x400204b8
 8003bac:	58025408 	.word	0x58025408
 8003bb0:	5802541c 	.word	0x5802541c
 8003bb4:	58025494 	.word	0x58025494
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8003bb8:	f7fc ff36 	bl	8000a28 <HAL_GetTick>
 8003bbc:	1b00      	subs	r0, r0, r4
 8003bbe:	2805      	cmp	r0, #5
 8003bc0:	f200 80f0 	bhi.w	8003da4 <HAL_DMA_Abort+0x3f0>
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
 8003bc4:	682b      	ldr	r3, [r5, #0]
 8003bc6:	07db      	lsls	r3, r3, #31
 8003bc8:	d4f6      	bmi.n	8003bb8 <HAL_DMA_Abort+0x204>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003bca:	6832      	ldr	r2, [r6, #0]
 8003bcc:	4b80      	ldr	r3, [pc, #512]	; (8003dd0 <HAL_DMA_Abort+0x41c>)
 8003bce:	4981      	ldr	r1, [pc, #516]	; (8003dd4 <HAL_DMA_Abort+0x420>)
 8003bd0:	4c81      	ldr	r4, [pc, #516]	; (8003dd8 <HAL_DMA_Abort+0x424>)
 8003bd2:	428a      	cmp	r2, r1
 8003bd4:	bf18      	it	ne
 8003bd6:	429a      	cmpne	r2, r3
 8003bd8:	f101 0130 	add.w	r1, r1, #48	; 0x30
 8003bdc:	487f      	ldr	r0, [pc, #508]	; (8003ddc <HAL_DMA_Abort+0x428>)
 8003bde:	bf0c      	ite	eq
 8003be0:	2301      	moveq	r3, #1
 8003be2:	2300      	movne	r3, #0
 8003be4:	42a2      	cmp	r2, r4
 8003be6:	bf08      	it	eq
 8003be8:	f043 0301 	orreq.w	r3, r3, #1
 8003bec:	3448      	adds	r4, #72	; 0x48
 8003bee:	428a      	cmp	r2, r1
 8003bf0:	bf08      	it	eq
 8003bf2:	f043 0301 	orreq.w	r3, r3, #1
 8003bf6:	3148      	adds	r1, #72	; 0x48
 8003bf8:	4282      	cmp	r2, r0
 8003bfa:	bf08      	it	eq
 8003bfc:	f043 0301 	orreq.w	r3, r3, #1
 8003c00:	3048      	adds	r0, #72	; 0x48
 8003c02:	42a2      	cmp	r2, r4
 8003c04:	bf08      	it	eq
 8003c06:	f043 0301 	orreq.w	r3, r3, #1
 8003c0a:	f504 7462 	add.w	r4, r4, #904	; 0x388
 8003c0e:	428a      	cmp	r2, r1
 8003c10:	bf08      	it	eq
 8003c12:	f043 0301 	orreq.w	r3, r3, #1
 8003c16:	f501 7162 	add.w	r1, r1, #904	; 0x388
 8003c1a:	4282      	cmp	r2, r0
 8003c1c:	bf08      	it	eq
 8003c1e:	f043 0301 	orreq.w	r3, r3, #1
 8003c22:	f500 7062 	add.w	r0, r0, #904	; 0x388
 8003c26:	42a2      	cmp	r2, r4
 8003c28:	bf08      	it	eq
 8003c2a:	f043 0301 	orreq.w	r3, r3, #1
 8003c2e:	3448      	adds	r4, #72	; 0x48
 8003c30:	428a      	cmp	r2, r1
 8003c32:	bf08      	it	eq
 8003c34:	f043 0301 	orreq.w	r3, r3, #1
 8003c38:	3148      	adds	r1, #72	; 0x48
 8003c3a:	4282      	cmp	r2, r0
 8003c3c:	bf08      	it	eq
 8003c3e:	f043 0301 	orreq.w	r3, r3, #1
 8003c42:	3048      	adds	r0, #72	; 0x48
 8003c44:	42a2      	cmp	r2, r4
 8003c46:	bf08      	it	eq
 8003c48:	f043 0301 	orreq.w	r3, r3, #1
 8003c4c:	3448      	adds	r4, #72	; 0x48
 8003c4e:	428a      	cmp	r2, r1
 8003c50:	bf08      	it	eq
 8003c52:	f043 0301 	orreq.w	r3, r3, #1
 8003c56:	6df1      	ldr	r1, [r6, #92]	; 0x5c
 8003c58:	4282      	cmp	r2, r0
 8003c5a:	bf08      	it	eq
 8003c5c:	f043 0301 	orreq.w	r3, r3, #1
 8003c60:	f001 011f 	and.w	r1, r1, #31
 8003c64:	6db0      	ldr	r0, [r6, #88]	; 0x58
 8003c66:	42a2      	cmp	r2, r4
 8003c68:	bf08      	it	eq
 8003c6a:	f043 0301 	orreq.w	r3, r3, #1
 8003c6e:	b91b      	cbnz	r3, 8003c78 <HAL_DMA_Abort+0x2c4>
 8003c70:	4b5b      	ldr	r3, [pc, #364]	; (8003de0 <HAL_DMA_Abort+0x42c>)
 8003c72:	429a      	cmp	r2, r3
 8003c74:	f040 80a7 	bne.w	8003dc6 <HAL_DMA_Abort+0x412>
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8003c78:	233f      	movs	r3, #63	; 0x3f
 8003c7a:	fa03 f101 	lsl.w	r1, r3, r1
 8003c7e:	6081      	str	r1, [r0, #8]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003c80:	6832      	ldr	r2, [r6, #0]
 8003c82:	4b53      	ldr	r3, [pc, #332]	; (8003dd0 <HAL_DMA_Abort+0x41c>)
 8003c84:	4953      	ldr	r1, [pc, #332]	; (8003dd4 <HAL_DMA_Abort+0x420>)
 8003c86:	4c54      	ldr	r4, [pc, #336]	; (8003dd8 <HAL_DMA_Abort+0x424>)
 8003c88:	428a      	cmp	r2, r1
 8003c8a:	bf18      	it	ne
 8003c8c:	429a      	cmpne	r2, r3
 8003c8e:	4855      	ldr	r0, [pc, #340]	; (8003de4 <HAL_DMA_Abort+0x430>)
 8003c90:	f101 0148 	add.w	r1, r1, #72	; 0x48
 8003c94:	bf0c      	ite	eq
 8003c96:	2301      	moveq	r3, #1
 8003c98:	2300      	movne	r3, #0
 8003c9a:	42a2      	cmp	r2, r4
 8003c9c:	bf08      	it	eq
 8003c9e:	f043 0301 	orreq.w	r3, r3, #1
 8003ca2:	3448      	adds	r4, #72	; 0x48
 8003ca4:	4282      	cmp	r2, r0
 8003ca6:	bf08      	it	eq
 8003ca8:	f043 0301 	orreq.w	r3, r3, #1
 8003cac:	3048      	adds	r0, #72	; 0x48
 8003cae:	428a      	cmp	r2, r1
 8003cb0:	bf08      	it	eq
 8003cb2:	f043 0301 	orreq.w	r3, r3, #1
 8003cb6:	3148      	adds	r1, #72	; 0x48
 8003cb8:	42a2      	cmp	r2, r4
 8003cba:	bf08      	it	eq
 8003cbc:	f043 0301 	orreq.w	r3, r3, #1
 8003cc0:	f504 7462 	add.w	r4, r4, #904	; 0x388
 8003cc4:	4282      	cmp	r2, r0
 8003cc6:	bf08      	it	eq
 8003cc8:	f043 0301 	orreq.w	r3, r3, #1
 8003ccc:	f500 7062 	add.w	r0, r0, #904	; 0x388
 8003cd0:	428a      	cmp	r2, r1
 8003cd2:	bf08      	it	eq
 8003cd4:	f043 0301 	orreq.w	r3, r3, #1
 8003cd8:	f501 7162 	add.w	r1, r1, #904	; 0x388
 8003cdc:	42a2      	cmp	r2, r4
 8003cde:	bf08      	it	eq
 8003ce0:	f043 0301 	orreq.w	r3, r3, #1
 8003ce4:	3448      	adds	r4, #72	; 0x48
 8003ce6:	4282      	cmp	r2, r0
 8003ce8:	bf08      	it	eq
 8003cea:	f043 0301 	orreq.w	r3, r3, #1
 8003cee:	3048      	adds	r0, #72	; 0x48
 8003cf0:	428a      	cmp	r2, r1
 8003cf2:	bf08      	it	eq
 8003cf4:	f043 0301 	orreq.w	r3, r3, #1
 8003cf8:	3148      	adds	r1, #72	; 0x48
 8003cfa:	42a2      	cmp	r2, r4
 8003cfc:	bf08      	it	eq
 8003cfe:	f043 0301 	orreq.w	r3, r3, #1
 8003d02:	3448      	adds	r4, #72	; 0x48
 8003d04:	4282      	cmp	r2, r0
 8003d06:	bf08      	it	eq
 8003d08:	f043 0301 	orreq.w	r3, r3, #1
 8003d0c:	3048      	adds	r0, #72	; 0x48
 8003d0e:	428a      	cmp	r2, r1
 8003d10:	bf08      	it	eq
 8003d12:	f043 0301 	orreq.w	r3, r3, #1
 8003d16:	f101 51c0 	add.w	r1, r1, #402653184	; 0x18000000
 8003d1a:	42a2      	cmp	r2, r4
 8003d1c:	bf08      	it	eq
 8003d1e:	f043 0301 	orreq.w	r3, r3, #1
 8003d22:	f501 419f 	add.w	r1, r1, #20352	; 0x4f80
 8003d26:	4c30      	ldr	r4, [pc, #192]	; (8003de8 <HAL_DMA_Abort+0x434>)
 8003d28:	4282      	cmp	r2, r0
 8003d2a:	bf08      	it	eq
 8003d2c:	f043 0301 	orreq.w	r3, r3, #1
 8003d30:	482e      	ldr	r0, [pc, #184]	; (8003dec <HAL_DMA_Abort+0x438>)
 8003d32:	428a      	cmp	r2, r1
 8003d34:	bf08      	it	eq
 8003d36:	f043 0301 	orreq.w	r3, r3, #1
 8003d3a:	313c      	adds	r1, #60	; 0x3c
 8003d3c:	42a2      	cmp	r2, r4
 8003d3e:	bf08      	it	eq
 8003d40:	f043 0301 	orreq.w	r3, r3, #1
 8003d44:	343c      	adds	r4, #60	; 0x3c
 8003d46:	4282      	cmp	r2, r0
 8003d48:	bf08      	it	eq
 8003d4a:	f043 0301 	orreq.w	r3, r3, #1
 8003d4e:	303c      	adds	r0, #60	; 0x3c
 8003d50:	428a      	cmp	r2, r1
 8003d52:	bf08      	it	eq
 8003d54:	f043 0301 	orreq.w	r3, r3, #1
 8003d58:	313c      	adds	r1, #60	; 0x3c
 8003d5a:	42a2      	cmp	r2, r4
 8003d5c:	bf08      	it	eq
 8003d5e:	f043 0301 	orreq.w	r3, r3, #1
 8003d62:	4282      	cmp	r2, r0
 8003d64:	bf08      	it	eq
 8003d66:	f043 0301 	orreq.w	r3, r3, #1
 8003d6a:	428a      	cmp	r2, r1
 8003d6c:	bf08      	it	eq
 8003d6e:	f043 0301 	orreq.w	r3, r3, #1
 8003d72:	b913      	cbnz	r3, 8003d7a <HAL_DMA_Abort+0x3c6>
 8003d74:	4b1e      	ldr	r3, [pc, #120]	; (8003df0 <HAL_DMA_Abort+0x43c>)
 8003d76:	429a      	cmp	r2, r3
 8003d78:	d10b      	bne.n	8003d92 <HAL_DMA_Abort+0x3de>
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8003d7a:	e9d6 3219 	ldrd	r3, r2, [r6, #100]	; 0x64
 8003d7e:	605a      	str	r2, [r3, #4]
      if(hdma->DMAmuxRequestGen != 0U)
 8003d80:	6ef3      	ldr	r3, [r6, #108]	; 0x6c
 8003d82:	b133      	cbz	r3, 8003d92 <HAL_DMA_Abort+0x3de>
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8003d84:	681a      	ldr	r2, [r3, #0]
 8003d86:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8003d8a:	601a      	str	r2, [r3, #0]
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8003d8c:	e9d6 321c 	ldrd	r3, r2, [r6, #112]	; 0x70
 8003d90:	605a      	str	r2, [r3, #4]
    __HAL_UNLOCK(hdma);
 8003d92:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_READY;
 8003d94:	2301      	movs	r3, #1
    __HAL_UNLOCK(hdma);
 8003d96:	f886 0034 	strb.w	r0, [r6, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_READY;
 8003d9a:	f886 3035 	strb.w	r3, [r6, #53]	; 0x35
}
 8003d9e:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8003da0:	2001      	movs	r0, #1
}
 8003da2:	bd70      	pop	{r4, r5, r6, pc}
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8003da4:	2120      	movs	r1, #32
        __HAL_UNLOCK(hdma);
 8003da6:	2200      	movs	r2, #0
        hdma->State = HAL_DMA_STATE_ERROR;
 8003da8:	2303      	movs	r3, #3
        return HAL_ERROR;
 8003daa:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8003dac:	6571      	str	r1, [r6, #84]	; 0x54
        __HAL_UNLOCK(hdma);
 8003dae:	f886 2034 	strb.w	r2, [r6, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_ERROR;
 8003db2:	f886 3035 	strb.w	r3, [r6, #53]	; 0x35
}
 8003db6:	bd70      	pop	{r4, r5, r6, pc}
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 8003db8:	6813      	ldr	r3, [r2, #0]
 8003dba:	f023 030e 	bic.w	r3, r3, #14
 8003dbe:	6013      	str	r3, [r2, #0]
      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));
 8003dc0:	6832      	ldr	r2, [r6, #0]
 8003dc2:	4615      	mov	r5, r2
 8003dc4:	e666      	b.n	8003a94 <HAL_DMA_Abort+0xe0>
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 8003dc6:	2301      	movs	r3, #1
 8003dc8:	fa03 f101 	lsl.w	r1, r3, r1
 8003dcc:	6041      	str	r1, [r0, #4]
 8003dce:	e757      	b.n	8003c80 <HAL_DMA_Abort+0x2cc>
 8003dd0:	40020010 	.word	0x40020010
 8003dd4:	40020028 	.word	0x40020028
 8003dd8:	40020040 	.word	0x40020040
 8003ddc:	40020070 	.word	0x40020070
 8003de0:	400204b8 	.word	0x400204b8
 8003de4:	40020058 	.word	0x40020058
 8003de8:	5802541c 	.word	0x5802541c
 8003dec:	58025430 	.word	0x58025430
 8003df0:	58025494 	.word	0x58025494

08003df4 <HAL_DMA_Abort_IT>:
  if(hdma == NULL)
 8003df4:	2800      	cmp	r0, #0
 8003df6:	d06a      	beq.n	8003ece <HAL_DMA_Abort_IT+0xda>
{
 8003df8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8003dfc:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
 8003e00:	4603      	mov	r3, r0
 8003e02:	2a02      	cmp	r2, #2
 8003e04:	d004      	beq.n	8003e10 <HAL_DMA_Abort_IT+0x1c>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8003e06:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
 8003e08:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8003e0a:	655a      	str	r2, [r3, #84]	; 0x54
}
 8003e0c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003e10:	6802      	ldr	r2, [r0, #0]
 8003e12:	4986      	ldr	r1, [pc, #536]	; (800402c <HAL_DMA_Abort_IT+0x238>)
 8003e14:	428a      	cmp	r2, r1
 8003e16:	d050      	beq.n	8003eba <HAL_DMA_Abort_IT+0xc6>
 8003e18:	4885      	ldr	r0, [pc, #532]	; (8004030 <HAL_DMA_Abort_IT+0x23c>)
 8003e1a:	4282      	cmp	r2, r0
 8003e1c:	d04d      	beq.n	8003eba <HAL_DMA_Abort_IT+0xc6>
 8003e1e:	f8df 8228 	ldr.w	r8, [pc, #552]	; 8004048 <HAL_DMA_Abort_IT+0x254>
 8003e22:	f8df 9220 	ldr.w	r9, [pc, #544]	; 8004044 <HAL_DMA_Abort_IT+0x250>
 8003e26:	f8df e230 	ldr.w	lr, [pc, #560]	; 8004058 <HAL_DMA_Abort_IT+0x264>
 8003e2a:	454a      	cmp	r2, r9
 8003e2c:	bf18      	it	ne
 8003e2e:	4542      	cmpne	r2, r8
 8003e30:	f8df c228 	ldr.w	ip, [pc, #552]	; 800405c <HAL_DMA_Abort_IT+0x268>
 8003e34:	4f7f      	ldr	r7, [pc, #508]	; (8004034 <HAL_DMA_Abort_IT+0x240>)
 8003e36:	bf0c      	ite	eq
 8003e38:	f04f 0a01 	moveq.w	sl, #1
 8003e3c:	f04f 0a00 	movne.w	sl, #0
 8003e40:	4c7d      	ldr	r4, [pc, #500]	; (8004038 <HAL_DMA_Abort_IT+0x244>)
 8003e42:	4572      	cmp	r2, lr
 8003e44:	bf08      	it	eq
 8003e46:	f04a 0a01 	orreq.w	sl, sl, #1
 8003e4a:	f8df b214 	ldr.w	fp, [pc, #532]	; 8004060 <HAL_DMA_Abort_IT+0x26c>
 8003e4e:	4e7b      	ldr	r6, [pc, #492]	; (800403c <HAL_DMA_Abort_IT+0x248>)
 8003e50:	4562      	cmp	r2, ip
 8003e52:	bf08      	it	eq
 8003e54:	f04a 0a01 	orreq.w	sl, sl, #1
 8003e58:	4d79      	ldr	r5, [pc, #484]	; (8004040 <HAL_DMA_Abort_IT+0x24c>)
 8003e5a:	42ba      	cmp	r2, r7
 8003e5c:	bf08      	it	eq
 8003e5e:	f04a 0a01 	orreq.w	sl, sl, #1
 8003e62:	42a2      	cmp	r2, r4
 8003e64:	bf08      	it	eq
 8003e66:	f04a 0a01 	orreq.w	sl, sl, #1
 8003e6a:	f504 7456 	add.w	r4, r4, #856	; 0x358
 8003e6e:	42a2      	cmp	r2, r4
 8003e70:	bf08      	it	eq
 8003e72:	f04a 0a01 	orreq.w	sl, sl, #1
 8003e76:	3418      	adds	r4, #24
 8003e78:	42a2      	cmp	r2, r4
 8003e7a:	bf08      	it	eq
 8003e7c:	f04a 0a01 	orreq.w	sl, sl, #1
 8003e80:	3418      	adds	r4, #24
 8003e82:	42a2      	cmp	r2, r4
 8003e84:	bf08      	it	eq
 8003e86:	f04a 0a01 	orreq.w	sl, sl, #1
 8003e8a:	3460      	adds	r4, #96	; 0x60
 8003e8c:	455a      	cmp	r2, fp
 8003e8e:	bf08      	it	eq
 8003e90:	f04a 0a01 	orreq.w	sl, sl, #1
 8003e94:	42b2      	cmp	r2, r6
 8003e96:	bf08      	it	eq
 8003e98:	f04a 0a01 	orreq.w	sl, sl, #1
 8003e9c:	42aa      	cmp	r2, r5
 8003e9e:	bf08      	it	eq
 8003ea0:	f04a 0a01 	orreq.w	sl, sl, #1
 8003ea4:	42a2      	cmp	r2, r4
 8003ea6:	bf08      	it	eq
 8003ea8:	f04a 0a01 	orreq.w	sl, sl, #1
 8003eac:	f1ba 0f00 	cmp.w	sl, #0
 8003eb0:	d103      	bne.n	8003eba <HAL_DMA_Abort_IT+0xc6>
 8003eb2:	f8df a1b0 	ldr.w	sl, [pc, #432]	; 8004064 <HAL_DMA_Abort_IT+0x270>
 8003eb6:	4552      	cmp	r2, sl
 8003eb8:	d10b      	bne.n	8003ed2 <HAL_DMA_Abort_IT+0xde>
      hdma->State = HAL_DMA_STATE_ABORT;
 8003eba:	2104      	movs	r1, #4
  return HAL_OK;
 8003ebc:	2000      	movs	r0, #0
      hdma->State = HAL_DMA_STATE_ABORT;
 8003ebe:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 8003ec2:	6813      	ldr	r3, [r2, #0]
 8003ec4:	f023 0301 	bic.w	r3, r3, #1
 8003ec8:	6013      	str	r3, [r2, #0]
}
 8003eca:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return HAL_ERROR;
 8003ece:	2001      	movs	r0, #1
}
 8003ed0:	4770      	bx	lr
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 8003ed2:	6814      	ldr	r4, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003ed4:	4856      	ldr	r0, [pc, #344]	; (8004030 <HAL_DMA_Abort_IT+0x23c>)
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 8003ed6:	f024 040e 	bic.w	r4, r4, #14
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003eda:	4d5a      	ldr	r5, [pc, #360]	; (8004044 <HAL_DMA_Abort_IT+0x250>)
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 8003edc:	6014      	str	r4, [r2, #0]
      __HAL_DMA_DISABLE(hdma);
 8003ede:	681a      	ldr	r2, [r3, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003ee0:	4c59      	ldr	r4, [pc, #356]	; (8004048 <HAL_DMA_Abort_IT+0x254>)
      __HAL_DMA_DISABLE(hdma);
 8003ee2:	6811      	ldr	r1, [r2, #0]
 8003ee4:	f021 0101 	bic.w	r1, r1, #1
 8003ee8:	6011      	str	r1, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003eea:	4a50      	ldr	r2, [pc, #320]	; (800402c <HAL_DMA_Abort_IT+0x238>)
 8003eec:	6819      	ldr	r1, [r3, #0]
 8003eee:	4281      	cmp	r1, r0
 8003ef0:	bf18      	it	ne
 8003ef2:	4291      	cmpne	r1, r2
 8003ef4:	f100 0048 	add.w	r0, r0, #72	; 0x48
 8003ef8:	bf0c      	ite	eq
 8003efa:	2201      	moveq	r2, #1
 8003efc:	2200      	movne	r2, #0
 8003efe:	42a9      	cmp	r1, r5
 8003f00:	bf08      	it	eq
 8003f02:	f042 0201 	orreq.w	r2, r2, #1
 8003f06:	3548      	adds	r5, #72	; 0x48
 8003f08:	42a1      	cmp	r1, r4
 8003f0a:	bf08      	it	eq
 8003f0c:	f042 0201 	orreq.w	r2, r2, #1
 8003f10:	3448      	adds	r4, #72	; 0x48
 8003f12:	4281      	cmp	r1, r0
 8003f14:	bf08      	it	eq
 8003f16:	f042 0201 	orreq.w	r2, r2, #1
 8003f1a:	3048      	adds	r0, #72	; 0x48
 8003f1c:	42a9      	cmp	r1, r5
 8003f1e:	bf08      	it	eq
 8003f20:	f042 0201 	orreq.w	r2, r2, #1
 8003f24:	f505 7562 	add.w	r5, r5, #904	; 0x388
 8003f28:	42a1      	cmp	r1, r4
 8003f2a:	bf08      	it	eq
 8003f2c:	f042 0201 	orreq.w	r2, r2, #1
 8003f30:	f504 7462 	add.w	r4, r4, #904	; 0x388
 8003f34:	4281      	cmp	r1, r0
 8003f36:	bf08      	it	eq
 8003f38:	f042 0201 	orreq.w	r2, r2, #1
 8003f3c:	f500 7062 	add.w	r0, r0, #904	; 0x388
 8003f40:	42a9      	cmp	r1, r5
 8003f42:	bf08      	it	eq
 8003f44:	f042 0201 	orreq.w	r2, r2, #1
 8003f48:	3548      	adds	r5, #72	; 0x48
 8003f4a:	42a1      	cmp	r1, r4
 8003f4c:	bf08      	it	eq
 8003f4e:	f042 0201 	orreq.w	r2, r2, #1
 8003f52:	3448      	adds	r4, #72	; 0x48
 8003f54:	4281      	cmp	r1, r0
 8003f56:	bf08      	it	eq
 8003f58:	f042 0201 	orreq.w	r2, r2, #1
 8003f5c:	3048      	adds	r0, #72	; 0x48
 8003f5e:	42a9      	cmp	r1, r5
 8003f60:	bf08      	it	eq
 8003f62:	f042 0201 	orreq.w	r2, r2, #1
 8003f66:	3548      	adds	r5, #72	; 0x48
 8003f68:	42a1      	cmp	r1, r4
 8003f6a:	bf08      	it	eq
 8003f6c:	f042 0201 	orreq.w	r2, r2, #1
 8003f70:	3448      	adds	r4, #72	; 0x48
 8003f72:	4281      	cmp	r1, r0
 8003f74:	bf08      	it	eq
 8003f76:	f042 0201 	orreq.w	r2, r2, #1
 8003f7a:	f100 50c0 	add.w	r0, r0, #402653184	; 0x18000000
 8003f7e:	42a9      	cmp	r1, r5
 8003f80:	bf08      	it	eq
 8003f82:	f042 0201 	orreq.w	r2, r2, #1
 8003f86:	f500 409f 	add.w	r0, r0, #20352	; 0x4f80
 8003f8a:	4d30      	ldr	r5, [pc, #192]	; (800404c <HAL_DMA_Abort_IT+0x258>)
 8003f8c:	42a1      	cmp	r1, r4
 8003f8e:	bf08      	it	eq
 8003f90:	f042 0201 	orreq.w	r2, r2, #1
 8003f94:	4c2e      	ldr	r4, [pc, #184]	; (8004050 <HAL_DMA_Abort_IT+0x25c>)
 8003f96:	4281      	cmp	r1, r0
 8003f98:	bf08      	it	eq
 8003f9a:	f042 0201 	orreq.w	r2, r2, #1
 8003f9e:	303c      	adds	r0, #60	; 0x3c
 8003fa0:	42a9      	cmp	r1, r5
 8003fa2:	bf08      	it	eq
 8003fa4:	f042 0201 	orreq.w	r2, r2, #1
 8003fa8:	353c      	adds	r5, #60	; 0x3c
 8003faa:	42a1      	cmp	r1, r4
 8003fac:	bf08      	it	eq
 8003fae:	f042 0201 	orreq.w	r2, r2, #1
 8003fb2:	343c      	adds	r4, #60	; 0x3c
 8003fb4:	4281      	cmp	r1, r0
 8003fb6:	bf08      	it	eq
 8003fb8:	f042 0201 	orreq.w	r2, r2, #1
 8003fbc:	303c      	adds	r0, #60	; 0x3c
 8003fbe:	42a9      	cmp	r1, r5
 8003fc0:	bf08      	it	eq
 8003fc2:	f042 0201 	orreq.w	r2, r2, #1
 8003fc6:	42a1      	cmp	r1, r4
 8003fc8:	bf08      	it	eq
 8003fca:	f042 0201 	orreq.w	r2, r2, #1
 8003fce:	4281      	cmp	r1, r0
 8003fd0:	bf08      	it	eq
 8003fd2:	f042 0201 	orreq.w	r2, r2, #1
 8003fd6:	b912      	cbnz	r2, 8003fde <HAL_DMA_Abort_IT+0x1ea>
 8003fd8:	4a1e      	ldr	r2, [pc, #120]	; (8004054 <HAL_DMA_Abort_IT+0x260>)
 8003fda:	4291      	cmp	r1, r2
 8003fdc:	d117      	bne.n	800400e <HAL_DMA_Abort_IT+0x21a>
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8003fde:	6e18      	ldr	r0, [r3, #96]	; 0x60
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 8003fe0:	2201      	movs	r2, #1
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8003fe2:	6801      	ldr	r1, [r0, #0]
 8003fe4:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 8003fe8:	6001      	str	r1, [r0, #0]
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 8003fea:	e9d3 0116 	ldrd	r0, r1, [r3, #88]	; 0x58
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 8003fee:	f001 011f 	and.w	r1, r1, #31
 8003ff2:	408a      	lsls	r2, r1
 8003ff4:	6042      	str	r2, [r0, #4]
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8003ff6:	e9d3 2119 	ldrd	r2, r1, [r3, #100]	; 0x64
 8003ffa:	6051      	str	r1, [r2, #4]
        if(hdma->DMAmuxRequestGen != 0U)
 8003ffc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8003ffe:	b132      	cbz	r2, 800400e <HAL_DMA_Abort_IT+0x21a>
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8004000:	6811      	ldr	r1, [r2, #0]
 8004002:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 8004006:	6011      	str	r1, [r2, #0]
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8004008:	e9d3 211c 	ldrd	r2, r1, [r3, #112]	; 0x70
 800400c:	6051      	str	r1, [r2, #4]
      __HAL_UNLOCK(hdma);
 800400e:	2400      	movs	r4, #0
      hdma->State = HAL_DMA_STATE_READY;
 8004010:	2101      	movs	r1, #1
      if(hdma->XferAbortCallback != NULL)
 8004012:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      __HAL_UNLOCK(hdma);
 8004014:	f883 4034 	strb.w	r4, [r3, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 8004018:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      if(hdma->XferAbortCallback != NULL)
 800401c:	b11a      	cbz	r2, 8004026 <HAL_DMA_Abort_IT+0x232>
 800401e:	4618      	mov	r0, r3
        hdma->XferAbortCallback(hdma);
 8004020:	4790      	blx	r2
  return HAL_OK;
 8004022:	4620      	mov	r0, r4
 8004024:	e6f2      	b.n	8003e0c <HAL_DMA_Abort_IT+0x18>
 8004026:	4610      	mov	r0, r2
 8004028:	e6f0      	b.n	8003e0c <HAL_DMA_Abort_IT+0x18>
 800402a:	bf00      	nop
 800402c:	40020010 	.word	0x40020010
 8004030:	40020028 	.word	0x40020028
 8004034:	400200a0 	.word	0x400200a0
 8004038:	400200b8 	.word	0x400200b8
 800403c:	40020470 	.word	0x40020470
 8004040:	40020488 	.word	0x40020488
 8004044:	40020040 	.word	0x40020040
 8004048:	40020058 	.word	0x40020058
 800404c:	5802541c 	.word	0x5802541c
 8004050:	58025430 	.word	0x58025430
 8004054:	58025494 	.word	0x58025494
 8004058:	40020070 	.word	0x40020070
 800405c:	40020088 	.word	0x40020088
 8004060:	40020458 	.word	0x40020458
 8004064:	400204b8 	.word	0x400204b8

08004068 <HAL_DMA_IRQHandler>:
{
 8004068:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 800406a:	4ba5      	ldr	r3, [pc, #660]	; (8004300 <HAL_DMA_IRQHandler+0x298>)
{
 800406c:	b083      	sub	sp, #12
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 800406e:	6804      	ldr	r4, [r0, #0]
  __IO uint32_t count = 0U;
 8004070:	2100      	movs	r1, #0
  uint32_t timeout = SystemCoreClock / 9600U;
 8004072:	4aa4      	ldr	r2, [pc, #656]	; (8004304 <HAL_DMA_IRQHandler+0x29c>)
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8004074:	6d85      	ldr	r5, [r0, #88]	; 0x58
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 8004076:	429c      	cmp	r4, r3
  __IO uint32_t count = 0U;
 8004078:	9101      	str	r1, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600U;
 800407a:	6816      	ldr	r6, [r2, #0]
  tmpisr_dma  = regs_dma->ISR;
 800407c:	682f      	ldr	r7, [r5, #0]
  tmpisr_bdma = regs_bdma->ISR;
 800407e:	682a      	ldr	r2, [r5, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 8004080:	d04d      	beq.n	800411e <HAL_DMA_IRQHandler+0xb6>
 8004082:	3318      	adds	r3, #24
 8004084:	429c      	cmp	r4, r3
 8004086:	d04a      	beq.n	800411e <HAL_DMA_IRQHandler+0xb6>
 8004088:	3330      	adds	r3, #48	; 0x30
 800408a:	f8df c284 	ldr.w	ip, [pc, #644]	; 8004310 <HAL_DMA_IRQHandler+0x2a8>
 800408e:	499e      	ldr	r1, [pc, #632]	; (8004308 <HAL_DMA_IRQHandler+0x2a0>)
 8004090:	4564      	cmp	r4, ip
 8004092:	bf18      	it	ne
 8004094:	429c      	cmpne	r4, r3
 8004096:	f10c 0c48 	add.w	ip, ip, #72	; 0x48
 800409a:	bf0c      	ite	eq
 800409c:	2301      	moveq	r3, #1
 800409e:	2300      	movne	r3, #0
 80040a0:	428c      	cmp	r4, r1
 80040a2:	bf08      	it	eq
 80040a4:	f043 0301 	orreq.w	r3, r3, #1
 80040a8:	3130      	adds	r1, #48	; 0x30
 80040aa:	4564      	cmp	r4, ip
 80040ac:	bf08      	it	eq
 80040ae:	f043 0301 	orreq.w	r3, r3, #1
 80040b2:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80040b6:	428c      	cmp	r4, r1
 80040b8:	bf08      	it	eq
 80040ba:	f043 0301 	orreq.w	r3, r3, #1
 80040be:	f501 715c 	add.w	r1, r1, #880	; 0x370
 80040c2:	4564      	cmp	r4, ip
 80040c4:	bf08      	it	eq
 80040c6:	f043 0301 	orreq.w	r3, r3, #1
 80040ca:	f50c 7c5c 	add.w	ip, ip, #880	; 0x370
 80040ce:	428c      	cmp	r4, r1
 80040d0:	bf08      	it	eq
 80040d2:	f043 0301 	orreq.w	r3, r3, #1
 80040d6:	3130      	adds	r1, #48	; 0x30
 80040d8:	4564      	cmp	r4, ip
 80040da:	bf08      	it	eq
 80040dc:	f043 0301 	orreq.w	r3, r3, #1
 80040e0:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80040e4:	428c      	cmp	r4, r1
 80040e6:	bf08      	it	eq
 80040e8:	f043 0301 	orreq.w	r3, r3, #1
 80040ec:	3130      	adds	r1, #48	; 0x30
 80040ee:	4564      	cmp	r4, ip
 80040f0:	bf08      	it	eq
 80040f2:	f043 0301 	orreq.w	r3, r3, #1
 80040f6:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80040fa:	428c      	cmp	r4, r1
 80040fc:	bf08      	it	eq
 80040fe:	f043 0301 	orreq.w	r3, r3, #1
 8004102:	3130      	adds	r1, #48	; 0x30
 8004104:	4564      	cmp	r4, ip
 8004106:	bf08      	it	eq
 8004108:	f043 0301 	orreq.w	r3, r3, #1
 800410c:	428c      	cmp	r4, r1
 800410e:	bf08      	it	eq
 8004110:	f043 0301 	orreq.w	r3, r3, #1
 8004114:	b91b      	cbnz	r3, 800411e <HAL_DMA_IRQHandler+0xb6>
 8004116:	4b7d      	ldr	r3, [pc, #500]	; (800430c <HAL_DMA_IRQHandler+0x2a4>)
 8004118:	429c      	cmp	r4, r3
 800411a:	f040 821e 	bne.w	800455a <HAL_DMA_IRQHandler+0x4f2>
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800411e:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 8004120:	2308      	movs	r3, #8
 8004122:	f001 021f 	and.w	r2, r1, #31
 8004126:	4093      	lsls	r3, r2
 8004128:	423b      	tst	r3, r7
 800412a:	f040 81fb 	bne.w	8004524 <HAL_DMA_IRQHandler+0x4bc>
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800412e:	fa27 f302 	lsr.w	r3, r7, r2
 8004132:	07dc      	lsls	r4, r3, #31
 8004134:	d563      	bpl.n	80041fe <HAL_DMA_IRQHandler+0x196>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
 8004136:	6801      	ldr	r1, [r0, #0]
 8004138:	4b71      	ldr	r3, [pc, #452]	; (8004300 <HAL_DMA_IRQHandler+0x298>)
 800413a:	f8df c1d8 	ldr.w	ip, [pc, #472]	; 8004314 <HAL_DMA_IRQHandler+0x2ac>
 800413e:	4c74      	ldr	r4, [pc, #464]	; (8004310 <HAL_DMA_IRQHandler+0x2a8>)
 8004140:	4561      	cmp	r1, ip
 8004142:	bf18      	it	ne
 8004144:	4299      	cmpne	r1, r3
 8004146:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 800414a:	bf0c      	ite	eq
 800414c:	2301      	moveq	r3, #1
 800414e:	2300      	movne	r3, #0
 8004150:	42a1      	cmp	r1, r4
 8004152:	bf08      	it	eq
 8004154:	f043 0301 	orreq.w	r3, r3, #1
 8004158:	3430      	adds	r4, #48	; 0x30
 800415a:	4561      	cmp	r1, ip
 800415c:	bf08      	it	eq
 800415e:	f043 0301 	orreq.w	r3, r3, #1
 8004162:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 8004166:	42a1      	cmp	r1, r4
 8004168:	bf08      	it	eq
 800416a:	f043 0301 	orreq.w	r3, r3, #1
 800416e:	3430      	adds	r4, #48	; 0x30
 8004170:	4561      	cmp	r1, ip
 8004172:	bf08      	it	eq
 8004174:	f043 0301 	orreq.w	r3, r3, #1
 8004178:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 800417c:	42a1      	cmp	r1, r4
 800417e:	bf08      	it	eq
 8004180:	f043 0301 	orreq.w	r3, r3, #1
 8004184:	f504 745c 	add.w	r4, r4, #880	; 0x370
 8004188:	4561      	cmp	r1, ip
 800418a:	bf08      	it	eq
 800418c:	f043 0301 	orreq.w	r3, r3, #1
 8004190:	f50c 7c5c 	add.w	ip, ip, #880	; 0x370
 8004194:	42a1      	cmp	r1, r4
 8004196:	bf08      	it	eq
 8004198:	f043 0301 	orreq.w	r3, r3, #1
 800419c:	3430      	adds	r4, #48	; 0x30
 800419e:	4561      	cmp	r1, ip
 80041a0:	bf08      	it	eq
 80041a2:	f043 0301 	orreq.w	r3, r3, #1
 80041a6:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80041aa:	42a1      	cmp	r1, r4
 80041ac:	bf08      	it	eq
 80041ae:	f043 0301 	orreq.w	r3, r3, #1
 80041b2:	3430      	adds	r4, #48	; 0x30
 80041b4:	4561      	cmp	r1, ip
 80041b6:	bf08      	it	eq
 80041b8:	f043 0301 	orreq.w	r3, r3, #1
 80041bc:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80041c0:	42a1      	cmp	r1, r4
 80041c2:	bf08      	it	eq
 80041c4:	f043 0301 	orreq.w	r3, r3, #1
 80041c8:	3430      	adds	r4, #48	; 0x30
 80041ca:	4561      	cmp	r1, ip
 80041cc:	bf08      	it	eq
 80041ce:	f043 0301 	orreq.w	r3, r3, #1
 80041d2:	42a1      	cmp	r1, r4
 80041d4:	bf08      	it	eq
 80041d6:	f043 0301 	orreq.w	r3, r3, #1
 80041da:	b91b      	cbnz	r3, 80041e4 <HAL_DMA_IRQHandler+0x17c>
 80041dc:	4b4b      	ldr	r3, [pc, #300]	; (800430c <HAL_DMA_IRQHandler+0x2a4>)
 80041de:	4299      	cmp	r1, r3
 80041e0:	f040 8285 	bne.w	80046ee <HAL_DMA_IRQHandler+0x686>
 80041e4:	694b      	ldr	r3, [r1, #20]
 80041e6:	0619      	lsls	r1, r3, #24
 80041e8:	d509      	bpl.n	80041fe <HAL_DMA_IRQHandler+0x196>
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
 80041ea:	2101      	movs	r1, #1
 80041ec:	4091      	lsls	r1, r2
 80041ee:	60a9      	str	r1, [r5, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 80041f0:	6d43      	ldr	r3, [r0, #84]	; 0x54
 80041f2:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 80041f4:	f043 0302 	orr.w	r3, r3, #2
 80041f8:	f001 021f 	and.w	r2, r1, #31
 80041fc:	6543      	str	r3, [r0, #84]	; 0x54
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 80041fe:	2404      	movs	r4, #4
 8004200:	4094      	lsls	r4, r2
 8004202:	423c      	tst	r4, r7
 8004204:	d067      	beq.n	80042d6 <HAL_DMA_IRQHandler+0x26e>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
 8004206:	6801      	ldr	r1, [r0, #0]
 8004208:	4b3d      	ldr	r3, [pc, #244]	; (8004300 <HAL_DMA_IRQHandler+0x298>)
 800420a:	f8df e108 	ldr.w	lr, [pc, #264]	; 8004314 <HAL_DMA_IRQHandler+0x2ac>
 800420e:	f8df c100 	ldr.w	ip, [pc, #256]	; 8004310 <HAL_DMA_IRQHandler+0x2a8>
 8004212:	4571      	cmp	r1, lr
 8004214:	bf18      	it	ne
 8004216:	4299      	cmpne	r1, r3
 8004218:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 800421c:	bf0c      	ite	eq
 800421e:	2301      	moveq	r3, #1
 8004220:	2300      	movne	r3, #0
 8004222:	4561      	cmp	r1, ip
 8004224:	bf08      	it	eq
 8004226:	f043 0301 	orreq.w	r3, r3, #1
 800422a:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 800422e:	4571      	cmp	r1, lr
 8004230:	bf08      	it	eq
 8004232:	f043 0301 	orreq.w	r3, r3, #1
 8004236:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 800423a:	4561      	cmp	r1, ip
 800423c:	bf08      	it	eq
 800423e:	f043 0301 	orreq.w	r3, r3, #1
 8004242:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 8004246:	4571      	cmp	r1, lr
 8004248:	bf08      	it	eq
 800424a:	f043 0301 	orreq.w	r3, r3, #1
 800424e:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8004252:	4561      	cmp	r1, ip
 8004254:	bf08      	it	eq
 8004256:	f043 0301 	orreq.w	r3, r3, #1
 800425a:	f50c 7c5c 	add.w	ip, ip, #880	; 0x370
 800425e:	4571      	cmp	r1, lr
 8004260:	bf08      	it	eq
 8004262:	f043 0301 	orreq.w	r3, r3, #1
 8004266:	f50e 7e5c 	add.w	lr, lr, #880	; 0x370
 800426a:	4561      	cmp	r1, ip
 800426c:	bf08      	it	eq
 800426e:	f043 0301 	orreq.w	r3, r3, #1
 8004272:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 8004276:	4571      	cmp	r1, lr
 8004278:	bf08      	it	eq
 800427a:	f043 0301 	orreq.w	r3, r3, #1
 800427e:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8004282:	4561      	cmp	r1, ip
 8004284:	bf08      	it	eq
 8004286:	f043 0301 	orreq.w	r3, r3, #1
 800428a:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 800428e:	4571      	cmp	r1, lr
 8004290:	bf08      	it	eq
 8004292:	f043 0301 	orreq.w	r3, r3, #1
 8004296:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 800429a:	4561      	cmp	r1, ip
 800429c:	bf08      	it	eq
 800429e:	f043 0301 	orreq.w	r3, r3, #1
 80042a2:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80042a6:	4571      	cmp	r1, lr
 80042a8:	bf08      	it	eq
 80042aa:	f043 0301 	orreq.w	r3, r3, #1
 80042ae:	4561      	cmp	r1, ip
 80042b0:	bf08      	it	eq
 80042b2:	f043 0301 	orreq.w	r3, r3, #1
 80042b6:	b91b      	cbnz	r3, 80042c0 <HAL_DMA_IRQHandler+0x258>
 80042b8:	4b14      	ldr	r3, [pc, #80]	; (800430c <HAL_DMA_IRQHandler+0x2a4>)
 80042ba:	4299      	cmp	r1, r3
 80042bc:	f040 8215 	bne.w	80046ea <HAL_DMA_IRQHandler+0x682>
 80042c0:	680b      	ldr	r3, [r1, #0]
 80042c2:	079b      	lsls	r3, r3, #30
 80042c4:	d507      	bpl.n	80042d6 <HAL_DMA_IRQHandler+0x26e>
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
 80042c6:	60ac      	str	r4, [r5, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 80042c8:	6d43      	ldr	r3, [r0, #84]	; 0x54
 80042ca:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 80042cc:	f043 0304 	orr.w	r3, r3, #4
 80042d0:	f001 021f 	and.w	r2, r1, #31
 80042d4:	6543      	str	r3, [r0, #84]	; 0x54
 80042d6:	4604      	mov	r4, r0
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 80042d8:	2010      	movs	r0, #16
 80042da:	4090      	lsls	r0, r2
 80042dc:	4238      	tst	r0, r7
 80042de:	f000 8086 	beq.w	80043ee <HAL_DMA_IRQHandler+0x386>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
 80042e2:	6821      	ldr	r1, [r4, #0]
 80042e4:	4b06      	ldr	r3, [pc, #24]	; (8004300 <HAL_DMA_IRQHandler+0x298>)
 80042e6:	f8df e02c 	ldr.w	lr, [pc, #44]	; 8004314 <HAL_DMA_IRQHandler+0x2ac>
 80042ea:	f8df c024 	ldr.w	ip, [pc, #36]	; 8004310 <HAL_DMA_IRQHandler+0x2a8>
 80042ee:	4571      	cmp	r1, lr
 80042f0:	bf18      	it	ne
 80042f2:	4299      	cmpne	r1, r3
 80042f4:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 80042f8:	bf08      	it	eq
 80042fa:	2301      	moveq	r3, #1
 80042fc:	e00c      	b.n	8004318 <HAL_DMA_IRQHandler+0x2b0>
 80042fe:	bf00      	nop
 8004300:	40020010 	.word	0x40020010
 8004304:	200002bc 	.word	0x200002bc
 8004308:	40020070 	.word	0x40020070
 800430c:	400204b8 	.word	0x400204b8
 8004310:	40020040 	.word	0x40020040
 8004314:	40020028 	.word	0x40020028
 8004318:	bf18      	it	ne
 800431a:	2300      	movne	r3, #0
 800431c:	4561      	cmp	r1, ip
 800431e:	bf08      	it	eq
 8004320:	f043 0301 	orreq.w	r3, r3, #1
 8004324:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 8004328:	4571      	cmp	r1, lr
 800432a:	bf08      	it	eq
 800432c:	f043 0301 	orreq.w	r3, r3, #1
 8004330:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8004334:	4561      	cmp	r1, ip
 8004336:	bf08      	it	eq
 8004338:	f043 0301 	orreq.w	r3, r3, #1
 800433c:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 8004340:	4571      	cmp	r1, lr
 8004342:	bf08      	it	eq
 8004344:	f043 0301 	orreq.w	r3, r3, #1
 8004348:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 800434c:	4561      	cmp	r1, ip
 800434e:	bf08      	it	eq
 8004350:	f043 0301 	orreq.w	r3, r3, #1
 8004354:	f50c 7c5c 	add.w	ip, ip, #880	; 0x370
 8004358:	4571      	cmp	r1, lr
 800435a:	bf08      	it	eq
 800435c:	f043 0301 	orreq.w	r3, r3, #1
 8004360:	f50e 7e5c 	add.w	lr, lr, #880	; 0x370
 8004364:	4561      	cmp	r1, ip
 8004366:	bf08      	it	eq
 8004368:	f043 0301 	orreq.w	r3, r3, #1
 800436c:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 8004370:	4571      	cmp	r1, lr
 8004372:	bf08      	it	eq
 8004374:	f043 0301 	orreq.w	r3, r3, #1
 8004378:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 800437c:	4561      	cmp	r1, ip
 800437e:	bf08      	it	eq
 8004380:	f043 0301 	orreq.w	r3, r3, #1
 8004384:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 8004388:	4571      	cmp	r1, lr
 800438a:	bf08      	it	eq
 800438c:	f043 0301 	orreq.w	r3, r3, #1
 8004390:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8004394:	4561      	cmp	r1, ip
 8004396:	bf08      	it	eq
 8004398:	f043 0301 	orreq.w	r3, r3, #1
 800439c:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 80043a0:	4571      	cmp	r1, lr
 80043a2:	bf08      	it	eq
 80043a4:	f043 0301 	orreq.w	r3, r3, #1
 80043a8:	4561      	cmp	r1, ip
 80043aa:	bf08      	it	eq
 80043ac:	f043 0301 	orreq.w	r3, r3, #1
 80043b0:	b91b      	cbnz	r3, 80043ba <HAL_DMA_IRQHandler+0x352>
 80043b2:	4b9f      	ldr	r3, [pc, #636]	; (8004630 <HAL_DMA_IRQHandler+0x5c8>)
 80043b4:	4299      	cmp	r1, r3
 80043b6:	f040 8194 	bne.w	80046e2 <HAL_DMA_IRQHandler+0x67a>
 80043ba:	680b      	ldr	r3, [r1, #0]
 80043bc:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 80043c0:	b1ab      	cbz	r3, 80043ee <HAL_DMA_IRQHandler+0x386>
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
 80043c2:	60a8      	str	r0, [r5, #8]
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 80043c4:	6823      	ldr	r3, [r4, #0]
 80043c6:	681a      	ldr	r2, [r3, #0]
 80043c8:	0350      	lsls	r0, r2, #13
 80043ca:	f100 8102 	bmi.w	80045d2 <HAL_DMA_IRQHandler+0x56a>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 80043ce:	681a      	ldr	r2, [r3, #0]
 80043d0:	05d2      	lsls	r2, r2, #23
 80043d2:	d403      	bmi.n	80043dc <HAL_DMA_IRQHandler+0x374>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 80043d4:	681a      	ldr	r2, [r3, #0]
 80043d6:	f022 0208 	bic.w	r2, r2, #8
 80043da:	601a      	str	r2, [r3, #0]
          if(hdma->XferHalfCpltCallback != NULL)
 80043dc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80043de:	2b00      	cmp	r3, #0
 80043e0:	f000 80ff 	beq.w	80045e2 <HAL_DMA_IRQHandler+0x57a>
            hdma->XferHalfCpltCallback(hdma);
 80043e4:	4620      	mov	r0, r4
 80043e6:	4798      	blx	r3
 80043e8:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 80043ea:	f001 021f 	and.w	r2, r1, #31
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 80043ee:	2120      	movs	r1, #32
 80043f0:	4091      	lsls	r1, r2
 80043f2:	4239      	tst	r1, r7
 80043f4:	d068      	beq.n	80044c8 <HAL_DMA_IRQHandler+0x460>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
 80043f6:	6822      	ldr	r2, [r4, #0]
 80043f8:	4b8e      	ldr	r3, [pc, #568]	; (8004634 <HAL_DMA_IRQHandler+0x5cc>)
 80043fa:	4f8f      	ldr	r7, [pc, #572]	; (8004638 <HAL_DMA_IRQHandler+0x5d0>)
 80043fc:	488f      	ldr	r0, [pc, #572]	; (800463c <HAL_DMA_IRQHandler+0x5d4>)
 80043fe:	42ba      	cmp	r2, r7
 8004400:	bf18      	it	ne
 8004402:	429a      	cmpne	r2, r3
 8004404:	f107 0730 	add.w	r7, r7, #48	; 0x30
 8004408:	bf0c      	ite	eq
 800440a:	2301      	moveq	r3, #1
 800440c:	2300      	movne	r3, #0
 800440e:	4282      	cmp	r2, r0
 8004410:	bf08      	it	eq
 8004412:	f043 0301 	orreq.w	r3, r3, #1
 8004416:	3030      	adds	r0, #48	; 0x30
 8004418:	42ba      	cmp	r2, r7
 800441a:	bf08      	it	eq
 800441c:	f043 0301 	orreq.w	r3, r3, #1
 8004420:	3730      	adds	r7, #48	; 0x30
 8004422:	4282      	cmp	r2, r0
 8004424:	bf08      	it	eq
 8004426:	f043 0301 	orreq.w	r3, r3, #1
 800442a:	3030      	adds	r0, #48	; 0x30
 800442c:	42ba      	cmp	r2, r7
 800442e:	bf08      	it	eq
 8004430:	f043 0301 	orreq.w	r3, r3, #1
 8004434:	3730      	adds	r7, #48	; 0x30
 8004436:	4282      	cmp	r2, r0
 8004438:	bf08      	it	eq
 800443a:	f043 0301 	orreq.w	r3, r3, #1
 800443e:	f500 705c 	add.w	r0, r0, #880	; 0x370
 8004442:	42ba      	cmp	r2, r7
 8004444:	bf08      	it	eq
 8004446:	f043 0301 	orreq.w	r3, r3, #1
 800444a:	f507 775c 	add.w	r7, r7, #880	; 0x370
 800444e:	4282      	cmp	r2, r0
 8004450:	bf08      	it	eq
 8004452:	f043 0301 	orreq.w	r3, r3, #1
 8004456:	3030      	adds	r0, #48	; 0x30
 8004458:	42ba      	cmp	r2, r7
 800445a:	bf08      	it	eq
 800445c:	f043 0301 	orreq.w	r3, r3, #1
 8004460:	3730      	adds	r7, #48	; 0x30
 8004462:	4282      	cmp	r2, r0
 8004464:	bf08      	it	eq
 8004466:	f043 0301 	orreq.w	r3, r3, #1
 800446a:	3030      	adds	r0, #48	; 0x30
 800446c:	42ba      	cmp	r2, r7
 800446e:	bf08      	it	eq
 8004470:	f043 0301 	orreq.w	r3, r3, #1
 8004474:	3730      	adds	r7, #48	; 0x30
 8004476:	4282      	cmp	r2, r0
 8004478:	bf08      	it	eq
 800447a:	f043 0301 	orreq.w	r3, r3, #1
 800447e:	3030      	adds	r0, #48	; 0x30
 8004480:	42ba      	cmp	r2, r7
 8004482:	bf08      	it	eq
 8004484:	f043 0301 	orreq.w	r3, r3, #1
 8004488:	4282      	cmp	r2, r0
 800448a:	bf08      	it	eq
 800448c:	f043 0301 	orreq.w	r3, r3, #1
 8004490:	b91b      	cbnz	r3, 800449a <HAL_DMA_IRQHandler+0x432>
 8004492:	4b67      	ldr	r3, [pc, #412]	; (8004630 <HAL_DMA_IRQHandler+0x5c8>)
 8004494:	429a      	cmp	r2, r3
 8004496:	f040 812c 	bne.w	80046f2 <HAL_DMA_IRQHandler+0x68a>
 800449a:	6813      	ldr	r3, [r2, #0]
 800449c:	f3c3 1300 	ubfx	r3, r3, #4, #1
 80044a0:	b193      	cbz	r3, 80044c8 <HAL_DMA_IRQHandler+0x460>
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
 80044a2:	60a9      	str	r1, [r5, #8]
        if(HAL_DMA_STATE_ABORT == hdma->State)
 80044a4:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 80044a8:	2b04      	cmp	r3, #4
 80044aa:	f000 809e 	beq.w	80045ea <HAL_DMA_IRQHandler+0x582>
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 80044ae:	6823      	ldr	r3, [r4, #0]
 80044b0:	681a      	ldr	r2, [r3, #0]
 80044b2:	0357      	lsls	r7, r2, #13
 80044b4:	f140 80ce 	bpl.w	8004654 <HAL_DMA_IRQHandler+0x5ec>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 80044b8:	681b      	ldr	r3, [r3, #0]
 80044ba:	031d      	lsls	r5, r3, #12
 80044bc:	f140 80d9 	bpl.w	8004672 <HAL_DMA_IRQHandler+0x60a>
          if(hdma->XferCpltCallback != NULL)
 80044c0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80044c2:	b10b      	cbz	r3, 80044c8 <HAL_DMA_IRQHandler+0x460>
            hdma->XferCpltCallback(hdma);
 80044c4:	4620      	mov	r0, r4
 80044c6:	4798      	blx	r3
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 80044c8:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80044ca:	2b00      	cmp	r3, #0
 80044cc:	d07f      	beq.n	80045ce <HAL_DMA_IRQHandler+0x566>
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
 80044ce:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80044d0:	07d8      	lsls	r0, r3, #31
 80044d2:	d51f      	bpl.n	8004514 <HAL_DMA_IRQHandler+0x4ac>
        __HAL_DMA_DISABLE(hdma);
 80044d4:	6822      	ldr	r2, [r4, #0]
        hdma->State = HAL_DMA_STATE_ABORT;
 80044d6:	2004      	movs	r0, #4
 80044d8:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
        __HAL_DMA_DISABLE(hdma);
 80044dc:	6813      	ldr	r3, [r2, #0]
 80044de:	f023 0301 	bic.w	r3, r3, #1
 80044e2:	6013      	str	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
 80044e4:	4b56      	ldr	r3, [pc, #344]	; (8004640 <HAL_DMA_IRQHandler+0x5d8>)
 80044e6:	6822      	ldr	r2, [r4, #0]
 80044e8:	fba3 3606 	umull	r3, r6, r3, r6
 80044ec:	0ab6      	lsrs	r6, r6, #10
 80044ee:	e002      	b.n	80044f6 <HAL_DMA_IRQHandler+0x48e>
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
 80044f0:	6813      	ldr	r3, [r2, #0]
 80044f2:	07d9      	lsls	r1, r3, #31
 80044f4:	d504      	bpl.n	8004500 <HAL_DMA_IRQHandler+0x498>
          if (++count > timeout)
 80044f6:	9b01      	ldr	r3, [sp, #4]
 80044f8:	3301      	adds	r3, #1
 80044fa:	42b3      	cmp	r3, r6
 80044fc:	9301      	str	r3, [sp, #4]
 80044fe:	d9f7      	bls.n	80044f0 <HAL_DMA_IRQHandler+0x488>
        __HAL_UNLOCK(hdma);
 8004500:	2300      	movs	r3, #0
 8004502:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 8004506:	6813      	ldr	r3, [r2, #0]
 8004508:	07db      	lsls	r3, r3, #31
          hdma->State = HAL_DMA_STATE_ERROR;
 800450a:	bf4c      	ite	mi
 800450c:	2303      	movmi	r3, #3
          hdma->State = HAL_DMA_STATE_READY;
 800450e:	2301      	movpl	r3, #1
 8004510:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      if(hdma->XferErrorCallback != NULL)
 8004514:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8004516:	2b00      	cmp	r3, #0
 8004518:	d059      	beq.n	80045ce <HAL_DMA_IRQHandler+0x566>
        hdma->XferErrorCallback(hdma);
 800451a:	4620      	mov	r0, r4
}
 800451c:	b003      	add	sp, #12
 800451e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        hdma->XferErrorCallback(hdma);
 8004522:	4718      	bx	r3
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
 8004524:	6823      	ldr	r3, [r4, #0]
 8004526:	075b      	lsls	r3, r3, #29
 8004528:	f57f ae01 	bpl.w	800412e <HAL_DMA_IRQHandler+0xc6>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
 800452c:	6822      	ldr	r2, [r4, #0]
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
 800452e:	2308      	movs	r3, #8
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
 8004530:	f022 0204 	bic.w	r2, r2, #4
 8004534:	6022      	str	r2, [r4, #0]
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8004536:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8004538:	f002 021f 	and.w	r2, r2, #31
 800453c:	4093      	lsls	r3, r2
 800453e:	60ab      	str	r3, [r5, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8004540:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8004542:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 8004544:	f043 0301 	orr.w	r3, r3, #1
 8004548:	f001 021f 	and.w	r2, r1, #31
 800454c:	6543      	str	r3, [r0, #84]	; 0x54
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800454e:	fa27 f302 	lsr.w	r3, r7, r2
 8004552:	07dc      	lsls	r4, r3, #31
 8004554:	f57f ae53 	bpl.w	80041fe <HAL_DMA_IRQHandler+0x196>
 8004558:	e5ed      	b.n	8004136 <HAL_DMA_IRQHandler+0xce>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
 800455a:	4b3a      	ldr	r3, [pc, #232]	; (8004644 <HAL_DMA_IRQHandler+0x5dc>)
 800455c:	4e3a      	ldr	r6, [pc, #232]	; (8004648 <HAL_DMA_IRQHandler+0x5e0>)
 800455e:	493b      	ldr	r1, [pc, #236]	; (800464c <HAL_DMA_IRQHandler+0x5e4>)
 8004560:	42b4      	cmp	r4, r6
 8004562:	bf18      	it	ne
 8004564:	429c      	cmpne	r4, r3
 8004566:	f106 0628 	add.w	r6, r6, #40	; 0x28
 800456a:	bf0c      	ite	eq
 800456c:	2301      	moveq	r3, #1
 800456e:	2300      	movne	r3, #0
 8004570:	428c      	cmp	r4, r1
 8004572:	bf08      	it	eq
 8004574:	f043 0301 	orreq.w	r3, r3, #1
 8004578:	3128      	adds	r1, #40	; 0x28
 800457a:	42b4      	cmp	r4, r6
 800457c:	bf08      	it	eq
 800457e:	f043 0301 	orreq.w	r3, r3, #1
 8004582:	3628      	adds	r6, #40	; 0x28
 8004584:	428c      	cmp	r4, r1
 8004586:	bf08      	it	eq
 8004588:	f043 0301 	orreq.w	r3, r3, #1
 800458c:	3128      	adds	r1, #40	; 0x28
 800458e:	42b4      	cmp	r4, r6
 8004590:	bf08      	it	eq
 8004592:	f043 0301 	orreq.w	r3, r3, #1
 8004596:	428c      	cmp	r4, r1
 8004598:	bf08      	it	eq
 800459a:	f043 0301 	orreq.w	r3, r3, #1
 800459e:	b913      	cbnz	r3, 80045a6 <HAL_DMA_IRQHandler+0x53e>
 80045a0:	4b2b      	ldr	r3, [pc, #172]	; (8004650 <HAL_DMA_IRQHandler+0x5e8>)
 80045a2:	429c      	cmp	r4, r3
 80045a4:	d113      	bne.n	80045ce <HAL_DMA_IRQHandler+0x566>
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
 80045a6:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 80045a8:	2604      	movs	r6, #4
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
 80045aa:	6823      	ldr	r3, [r4, #0]
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
 80045ac:	f001 011f 	and.w	r1, r1, #31
 80045b0:	408e      	lsls	r6, r1
 80045b2:	4216      	tst	r6, r2
 80045b4:	d066      	beq.n	8004684 <HAL_DMA_IRQHandler+0x61c>
 80045b6:	075f      	lsls	r7, r3, #29
 80045b8:	d564      	bpl.n	8004684 <HAL_DMA_IRQHandler+0x61c>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80045ba:	0419      	lsls	r1, r3, #16
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
 80045bc:	606e      	str	r6, [r5, #4]
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80045be:	f140 809c 	bpl.w	80046fa <HAL_DMA_IRQHandler+0x692>
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 80045c2:	03da      	lsls	r2, r3, #15
 80045c4:	f100 80f1 	bmi.w	80047aa <HAL_DMA_IRQHandler+0x742>
          if(hdma->XferM1HalfCpltCallback != NULL)
 80045c8:	6c83      	ldr	r3, [r0, #72]	; 0x48
 80045ca:	2b00      	cmp	r3, #0
 80045cc:	d1a6      	bne.n	800451c <HAL_DMA_IRQHandler+0x4b4>
}
 80045ce:	b003      	add	sp, #12
 80045d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 80045d2:	681b      	ldr	r3, [r3, #0]
 80045d4:	0319      	lsls	r1, r3, #12
 80045d6:	f57f af01 	bpl.w	80043dc <HAL_DMA_IRQHandler+0x374>
            if(hdma->XferM1HalfCpltCallback != NULL)
 80045da:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80045dc:	2b00      	cmp	r3, #0
 80045de:	f47f af01 	bne.w	80043e4 <HAL_DMA_IRQHandler+0x37c>
 80045e2:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80045e4:	f002 021f 	and.w	r2, r2, #31
 80045e8:	e701      	b.n	80043ee <HAL_DMA_IRQHandler+0x386>
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 80045ea:	6822      	ldr	r2, [r4, #0]
 80045ec:	6813      	ldr	r3, [r2, #0]
 80045ee:	f023 0316 	bic.w	r3, r3, #22
 80045f2:	6013      	str	r3, [r2, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
 80045f4:	6822      	ldr	r2, [r4, #0]
 80045f6:	6953      	ldr	r3, [r2, #20]
 80045f8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80045fc:	6153      	str	r3, [r2, #20]
          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 80045fe:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8004600:	2b00      	cmp	r3, #0
 8004602:	d03b      	beq.n	800467c <HAL_DMA_IRQHandler+0x614>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 8004604:	6822      	ldr	r2, [r4, #0]
 8004606:	6813      	ldr	r3, [r2, #0]
 8004608:	f023 0308 	bic.w	r3, r3, #8
 800460c:	6013      	str	r3, [r2, #0]
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800460e:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8004610:	233f      	movs	r3, #63	; 0x3f
          __HAL_UNLOCK(hdma);
 8004612:	2000      	movs	r0, #0
          hdma->State = HAL_DMA_STATE_READY;
 8004614:	2101      	movs	r1, #1
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8004616:	f002 021f 	and.w	r2, r2, #31
 800461a:	4093      	lsls	r3, r2
 800461c:	60ab      	str	r3, [r5, #8]
          if(hdma->XferAbortCallback != NULL)
 800461e:	6d23      	ldr	r3, [r4, #80]	; 0x50
          __HAL_UNLOCK(hdma);
 8004620:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8004624:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
          if(hdma->XferAbortCallback != NULL)
 8004628:	2b00      	cmp	r3, #0
 800462a:	f47f af76 	bne.w	800451a <HAL_DMA_IRQHandler+0x4b2>
 800462e:	e7ce      	b.n	80045ce <HAL_DMA_IRQHandler+0x566>
 8004630:	400204b8 	.word	0x400204b8
 8004634:	40020010 	.word	0x40020010
 8004638:	40020028 	.word	0x40020028
 800463c:	40020040 	.word	0x40020040
 8004640:	1b4e81b5 	.word	0x1b4e81b5
 8004644:	58025408 	.word	0x58025408
 8004648:	5802541c 	.word	0x5802541c
 800464c:	58025430 	.word	0x58025430
 8004650:	58025494 	.word	0x58025494
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 8004654:	681a      	ldr	r2, [r3, #0]
 8004656:	f412 7280 	ands.w	r2, r2, #256	; 0x100
 800465a:	f47f af31 	bne.w	80044c0 <HAL_DMA_IRQHandler+0x458>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
 800465e:	6819      	ldr	r1, [r3, #0]
            hdma->State = HAL_DMA_STATE_READY;
 8004660:	2001      	movs	r0, #1
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
 8004662:	f021 0110 	bic.w	r1, r1, #16
 8004666:	6019      	str	r1, [r3, #0]
            __HAL_UNLOCK(hdma);
 8004668:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
            hdma->State = HAL_DMA_STATE_READY;
 800466c:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
 8004670:	e726      	b.n	80044c0 <HAL_DMA_IRQHandler+0x458>
            if(hdma->XferM1CpltCallback != NULL)
 8004672:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8004674:	2b00      	cmp	r3, #0
 8004676:	f47f af25 	bne.w	80044c4 <HAL_DMA_IRQHandler+0x45c>
 800467a:	e725      	b.n	80044c8 <HAL_DMA_IRQHandler+0x460>
          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 800467c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800467e:	2b00      	cmp	r3, #0
 8004680:	d1c0      	bne.n	8004604 <HAL_DMA_IRQHandler+0x59c>
 8004682:	e7c4      	b.n	800460e <HAL_DMA_IRQHandler+0x5a6>
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
 8004684:	2602      	movs	r6, #2
 8004686:	408e      	lsls	r6, r1
 8004688:	4216      	tst	r6, r2
 800468a:	d00d      	beq.n	80046a8 <HAL_DMA_IRQHandler+0x640>
 800468c:	079f      	lsls	r7, r3, #30
 800468e:	d50b      	bpl.n	80046a8 <HAL_DMA_IRQHandler+0x640>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8004690:	041c      	lsls	r4, r3, #16
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
 8004692:	606e      	str	r6, [r5, #4]
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8004694:	f140 808e 	bpl.w	80047b4 <HAL_DMA_IRQHandler+0x74c>
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 8004698:	03d9      	lsls	r1, r3, #15
 800469a:	f100 80e9 	bmi.w	8004870 <HAL_DMA_IRQHandler+0x808>
          if(hdma->XferM1CpltCallback != NULL)
 800469e:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80046a0:	2b00      	cmp	r3, #0
 80046a2:	f47f af3b 	bne.w	800451c <HAL_DMA_IRQHandler+0x4b4>
 80046a6:	e792      	b.n	80045ce <HAL_DMA_IRQHandler+0x566>
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
 80046a8:	2608      	movs	r6, #8
 80046aa:	fa06 f101 	lsl.w	r1, r6, r1
 80046ae:	4211      	tst	r1, r2
 80046b0:	d08d      	beq.n	80045ce <HAL_DMA_IRQHandler+0x566>
 80046b2:	071b      	lsls	r3, r3, #28
 80046b4:	d58b      	bpl.n	80045ce <HAL_DMA_IRQHandler+0x566>
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80046b6:	6823      	ldr	r3, [r4, #0]
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 80046b8:	2201      	movs	r2, #1
      __HAL_UNLOCK(hdma);
 80046ba:	2100      	movs	r1, #0
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80046bc:	f023 030e 	bic.w	r3, r3, #14
 80046c0:	6023      	str	r3, [r4, #0]
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 80046c2:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 80046c4:	f003 031f 	and.w	r3, r3, #31
 80046c8:	fa02 f303 	lsl.w	r3, r2, r3
 80046cc:	606b      	str	r3, [r5, #4]
      if (hdma->XferErrorCallback != NULL)
 80046ce:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
 80046d0:	6542      	str	r2, [r0, #84]	; 0x54
      __HAL_UNLOCK(hdma);
 80046d2:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 80046d6:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
      if (hdma->XferErrorCallback != NULL)
 80046da:	2b00      	cmp	r3, #0
 80046dc:	f47f af1e 	bne.w	800451c <HAL_DMA_IRQHandler+0x4b4>
 80046e0:	e775      	b.n	80045ce <HAL_DMA_IRQHandler+0x566>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
 80046e2:	680b      	ldr	r3, [r1, #0]
 80046e4:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80046e8:	e66a      	b.n	80043c0 <HAL_DMA_IRQHandler+0x358>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
 80046ea:	680b      	ldr	r3, [r1, #0]
 80046ec:	e5f3      	b.n	80042d6 <HAL_DMA_IRQHandler+0x26e>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
 80046ee:	680b      	ldr	r3, [r1, #0]
 80046f0:	e585      	b.n	80041fe <HAL_DMA_IRQHandler+0x196>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
 80046f2:	6813      	ldr	r3, [r2, #0]
 80046f4:	f3c3 0340 	ubfx	r3, r3, #1, #1
 80046f8:	e6d2      	b.n	80044a0 <HAL_DMA_IRQHandler+0x438>
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 80046fa:	069b      	lsls	r3, r3, #26
 80046fc:	d455      	bmi.n	80047aa <HAL_DMA_IRQHandler+0x742>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 80046fe:	6802      	ldr	r2, [r0, #0]
 8004700:	4b63      	ldr	r3, [pc, #396]	; (8004890 <HAL_DMA_IRQHandler+0x828>)
 8004702:	4c64      	ldr	r4, [pc, #400]	; (8004894 <HAL_DMA_IRQHandler+0x82c>)
 8004704:	4964      	ldr	r1, [pc, #400]	; (8004898 <HAL_DMA_IRQHandler+0x830>)
 8004706:	42a2      	cmp	r2, r4
 8004708:	bf18      	it	ne
 800470a:	429a      	cmpne	r2, r3
 800470c:	4d63      	ldr	r5, [pc, #396]	; (800489c <HAL_DMA_IRQHandler+0x834>)
 800470e:	f104 0448 	add.w	r4, r4, #72	; 0x48
 8004712:	bf0c      	ite	eq
 8004714:	2301      	moveq	r3, #1
 8004716:	2300      	movne	r3, #0
 8004718:	428a      	cmp	r2, r1
 800471a:	bf08      	it	eq
 800471c:	f043 0301 	orreq.w	r3, r3, #1
 8004720:	3148      	adds	r1, #72	; 0x48
 8004722:	42aa      	cmp	r2, r5
 8004724:	bf08      	it	eq
 8004726:	f043 0301 	orreq.w	r3, r3, #1
 800472a:	3548      	adds	r5, #72	; 0x48
 800472c:	42a2      	cmp	r2, r4
 800472e:	bf08      	it	eq
 8004730:	f043 0301 	orreq.w	r3, r3, #1
 8004734:	3448      	adds	r4, #72	; 0x48
 8004736:	428a      	cmp	r2, r1
 8004738:	bf08      	it	eq
 800473a:	f043 0301 	orreq.w	r3, r3, #1
 800473e:	f501 7162 	add.w	r1, r1, #904	; 0x388
 8004742:	42aa      	cmp	r2, r5
 8004744:	bf08      	it	eq
 8004746:	f043 0301 	orreq.w	r3, r3, #1
 800474a:	f505 7562 	add.w	r5, r5, #904	; 0x388
 800474e:	42a2      	cmp	r2, r4
 8004750:	bf08      	it	eq
 8004752:	f043 0301 	orreq.w	r3, r3, #1
 8004756:	f504 7462 	add.w	r4, r4, #904	; 0x388
 800475a:	428a      	cmp	r2, r1
 800475c:	bf08      	it	eq
 800475e:	f043 0301 	orreq.w	r3, r3, #1
 8004762:	3148      	adds	r1, #72	; 0x48
 8004764:	42aa      	cmp	r2, r5
 8004766:	bf08      	it	eq
 8004768:	f043 0301 	orreq.w	r3, r3, #1
 800476c:	3548      	adds	r5, #72	; 0x48
 800476e:	42a2      	cmp	r2, r4
 8004770:	bf08      	it	eq
 8004772:	f043 0301 	orreq.w	r3, r3, #1
 8004776:	3448      	adds	r4, #72	; 0x48
 8004778:	428a      	cmp	r2, r1
 800477a:	bf08      	it	eq
 800477c:	f043 0301 	orreq.w	r3, r3, #1
 8004780:	3148      	adds	r1, #72	; 0x48
 8004782:	42aa      	cmp	r2, r5
 8004784:	bf08      	it	eq
 8004786:	f043 0301 	orreq.w	r3, r3, #1
 800478a:	42a2      	cmp	r2, r4
 800478c:	bf08      	it	eq
 800478e:	f043 0301 	orreq.w	r3, r3, #1
 8004792:	428a      	cmp	r2, r1
 8004794:	bf08      	it	eq
 8004796:	f043 0301 	orreq.w	r3, r3, #1
 800479a:	b913      	cbnz	r3, 80047a2 <HAL_DMA_IRQHandler+0x73a>
 800479c:	4b40      	ldr	r3, [pc, #256]	; (80048a0 <HAL_DMA_IRQHandler+0x838>)
 800479e:	429a      	cmp	r2, r3
 80047a0:	d16b      	bne.n	800487a <HAL_DMA_IRQHandler+0x812>
 80047a2:	6813      	ldr	r3, [r2, #0]
 80047a4:	f023 0308 	bic.w	r3, r3, #8
 80047a8:	6013      	str	r3, [r2, #0]
       if(hdma->XferHalfCpltCallback != NULL)
 80047aa:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80047ac:	2b00      	cmp	r3, #0
 80047ae:	f47f aeb5 	bne.w	800451c <HAL_DMA_IRQHandler+0x4b4>
 80047b2:	e70c      	b.n	80045ce <HAL_DMA_IRQHandler+0x566>
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 80047b4:	069a      	lsls	r2, r3, #26
 80047b6:	d45b      	bmi.n	8004870 <HAL_DMA_IRQHandler+0x808>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 80047b8:	6802      	ldr	r2, [r0, #0]
 80047ba:	4b35      	ldr	r3, [pc, #212]	; (8004890 <HAL_DMA_IRQHandler+0x828>)
 80047bc:	4c35      	ldr	r4, [pc, #212]	; (8004894 <HAL_DMA_IRQHandler+0x82c>)
 80047be:	4936      	ldr	r1, [pc, #216]	; (8004898 <HAL_DMA_IRQHandler+0x830>)
 80047c0:	42a2      	cmp	r2, r4
 80047c2:	bf18      	it	ne
 80047c4:	429a      	cmpne	r2, r3
 80047c6:	4d35      	ldr	r5, [pc, #212]	; (800489c <HAL_DMA_IRQHandler+0x834>)
 80047c8:	f104 0448 	add.w	r4, r4, #72	; 0x48
 80047cc:	bf0c      	ite	eq
 80047ce:	2301      	moveq	r3, #1
 80047d0:	2300      	movne	r3, #0
 80047d2:	428a      	cmp	r2, r1
 80047d4:	bf08      	it	eq
 80047d6:	f043 0301 	orreq.w	r3, r3, #1
 80047da:	3148      	adds	r1, #72	; 0x48
 80047dc:	42aa      	cmp	r2, r5
 80047de:	bf08      	it	eq
 80047e0:	f043 0301 	orreq.w	r3, r3, #1
 80047e4:	3548      	adds	r5, #72	; 0x48
 80047e6:	42a2      	cmp	r2, r4
 80047e8:	bf08      	it	eq
 80047ea:	f043 0301 	orreq.w	r3, r3, #1
 80047ee:	3448      	adds	r4, #72	; 0x48
 80047f0:	428a      	cmp	r2, r1
 80047f2:	bf08      	it	eq
 80047f4:	f043 0301 	orreq.w	r3, r3, #1
 80047f8:	f501 7162 	add.w	r1, r1, #904	; 0x388
 80047fc:	42aa      	cmp	r2, r5
 80047fe:	bf08      	it	eq
 8004800:	f043 0301 	orreq.w	r3, r3, #1
 8004804:	f505 7562 	add.w	r5, r5, #904	; 0x388
 8004808:	42a2      	cmp	r2, r4
 800480a:	bf08      	it	eq
 800480c:	f043 0301 	orreq.w	r3, r3, #1
 8004810:	f504 7462 	add.w	r4, r4, #904	; 0x388
 8004814:	428a      	cmp	r2, r1
 8004816:	bf08      	it	eq
 8004818:	f043 0301 	orreq.w	r3, r3, #1
 800481c:	3148      	adds	r1, #72	; 0x48
 800481e:	42aa      	cmp	r2, r5
 8004820:	bf08      	it	eq
 8004822:	f043 0301 	orreq.w	r3, r3, #1
 8004826:	3548      	adds	r5, #72	; 0x48
 8004828:	42a2      	cmp	r2, r4
 800482a:	bf08      	it	eq
 800482c:	f043 0301 	orreq.w	r3, r3, #1
 8004830:	3448      	adds	r4, #72	; 0x48
 8004832:	428a      	cmp	r2, r1
 8004834:	bf08      	it	eq
 8004836:	f043 0301 	orreq.w	r3, r3, #1
 800483a:	3148      	adds	r1, #72	; 0x48
 800483c:	42aa      	cmp	r2, r5
 800483e:	bf08      	it	eq
 8004840:	f043 0301 	orreq.w	r3, r3, #1
 8004844:	42a2      	cmp	r2, r4
 8004846:	bf08      	it	eq
 8004848:	f043 0301 	orreq.w	r3, r3, #1
 800484c:	428a      	cmp	r2, r1
 800484e:	bf08      	it	eq
 8004850:	f043 0301 	orreq.w	r3, r3, #1
 8004854:	b913      	cbnz	r3, 800485c <HAL_DMA_IRQHandler+0x7f4>
 8004856:	4b12      	ldr	r3, [pc, #72]	; (80048a0 <HAL_DMA_IRQHandler+0x838>)
 8004858:	429a      	cmp	r2, r3
 800485a:	d113      	bne.n	8004884 <HAL_DMA_IRQHandler+0x81c>
 800485c:	6813      	ldr	r3, [r2, #0]
 800485e:	f023 0314 	bic.w	r3, r3, #20
 8004862:	6013      	str	r3, [r2, #0]
          __HAL_UNLOCK(hdma);
 8004864:	2200      	movs	r2, #0
          hdma->State = HAL_DMA_STATE_READY;
 8004866:	2301      	movs	r3, #1
          __HAL_UNLOCK(hdma);
 8004868:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 800486c:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
        if(hdma->XferCpltCallback != NULL)
 8004870:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8004872:	2b00      	cmp	r3, #0
 8004874:	f47f ae52 	bne.w	800451c <HAL_DMA_IRQHandler+0x4b4>
 8004878:	e6a9      	b.n	80045ce <HAL_DMA_IRQHandler+0x566>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 800487a:	6813      	ldr	r3, [r2, #0]
 800487c:	f023 0304 	bic.w	r3, r3, #4
 8004880:	6013      	str	r3, [r2, #0]
 8004882:	e792      	b.n	80047aa <HAL_DMA_IRQHandler+0x742>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8004884:	6813      	ldr	r3, [r2, #0]
 8004886:	f023 030a 	bic.w	r3, r3, #10
 800488a:	6013      	str	r3, [r2, #0]
 800488c:	e7ea      	b.n	8004864 <HAL_DMA_IRQHandler+0x7fc>
 800488e:	bf00      	nop
 8004890:	40020010 	.word	0x40020010
 8004894:	40020028 	.word	0x40020028
 8004898:	40020040 	.word	0x40020040
 800489c:	40020058 	.word	0x40020058
 80048a0:	400204b8 	.word	0x400204b8

080048a4 <HAL_DMA_GetState>:
  return hdma->State;
 80048a4:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
 80048a8:	4770      	bx	lr
 80048aa:	bf00      	nop

080048ac <HAL_DMA_GetError>:
  return hdma->ErrorCode;
 80048ac:	6d40      	ldr	r0, [r0, #84]	; 0x54
}
 80048ae:	4770      	bx	lr

080048b0 <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA Stream.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
 80048b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80048b2:	4605      	mov	r5, r0
  uint32_t syncSignalID = 0;
  uint32_t syncPolarity = 0;

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
 80048b4:	4baa      	ldr	r3, [pc, #680]	; (8004b60 <HAL_DMAEx_ConfigMuxSync+0x2b0>)
 80048b6:	48ab      	ldr	r0, [pc, #684]	; (8004b64 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
{
 80048b8:	460c      	mov	r4, r1
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
 80048ba:	682a      	ldr	r2, [r5, #0]
 80048bc:	49aa      	ldr	r1, [pc, #680]	; (8004b68 <HAL_DMAEx_ConfigMuxSync+0x2b8>)
 80048be:	429a      	cmp	r2, r3
 80048c0:	bf18      	it	ne
 80048c2:	4282      	cmpne	r2, r0
 80048c4:	f100 0030 	add.w	r0, r0, #48	; 0x30
 80048c8:	bf14      	ite	ne
 80048ca:	2301      	movne	r3, #1
 80048cc:	2300      	moveq	r3, #0
 80048ce:	428a      	cmp	r2, r1
 80048d0:	bf0c      	ite	eq
 80048d2:	2300      	moveq	r3, #0
 80048d4:	f003 0301 	andne.w	r3, r3, #1
 80048d8:	3130      	adds	r1, #48	; 0x30
 80048da:	4282      	cmp	r2, r0
 80048dc:	bf0c      	ite	eq
 80048de:	2300      	moveq	r3, #0
 80048e0:	f003 0301 	andne.w	r3, r3, #1
 80048e4:	3030      	adds	r0, #48	; 0x30
 80048e6:	428a      	cmp	r2, r1
 80048e8:	bf0c      	ite	eq
 80048ea:	2300      	moveq	r3, #0
 80048ec:	f003 0301 	andne.w	r3, r3, #1
 80048f0:	3130      	adds	r1, #48	; 0x30
 80048f2:	4282      	cmp	r2, r0
 80048f4:	bf0c      	ite	eq
 80048f6:	2300      	moveq	r3, #0
 80048f8:	f003 0301 	andne.w	r3, r3, #1
 80048fc:	3030      	adds	r0, #48	; 0x30
 80048fe:	428a      	cmp	r2, r1
 8004900:	bf0c      	ite	eq
 8004902:	2300      	moveq	r3, #0
 8004904:	f003 0301 	andne.w	r3, r3, #1
 8004908:	f501 715c 	add.w	r1, r1, #880	; 0x370
 800490c:	4282      	cmp	r2, r0
 800490e:	bf0c      	ite	eq
 8004910:	2300      	moveq	r3, #0
 8004912:	f003 0301 	andne.w	r3, r3, #1
 8004916:	f500 705c 	add.w	r0, r0, #880	; 0x370
 800491a:	428a      	cmp	r2, r1
 800491c:	bf0c      	ite	eq
 800491e:	2300      	moveq	r3, #0
 8004920:	f003 0301 	andne.w	r3, r3, #1
 8004924:	3130      	adds	r1, #48	; 0x30
 8004926:	4282      	cmp	r2, r0
 8004928:	bf0c      	ite	eq
 800492a:	2300      	moveq	r3, #0
 800492c:	f003 0301 	andne.w	r3, r3, #1
 8004930:	3030      	adds	r0, #48	; 0x30
 8004932:	428a      	cmp	r2, r1
 8004934:	bf0c      	ite	eq
 8004936:	2300      	moveq	r3, #0
 8004938:	f003 0301 	andne.w	r3, r3, #1
 800493c:	3130      	adds	r1, #48	; 0x30
 800493e:	4282      	cmp	r2, r0
 8004940:	bf0c      	ite	eq
 8004942:	2300      	moveq	r3, #0
 8004944:	f003 0301 	andne.w	r3, r3, #1
 8004948:	3030      	adds	r0, #48	; 0x30
 800494a:	428a      	cmp	r2, r1
 800494c:	bf0c      	ite	eq
 800494e:	2300      	moveq	r3, #0
 8004950:	f003 0301 	andne.w	r3, r3, #1
 8004954:	3130      	adds	r1, #48	; 0x30
 8004956:	4282      	cmp	r2, r0
 8004958:	bf0c      	ite	eq
 800495a:	2300      	moveq	r3, #0
 800495c:	f003 0301 	andne.w	r3, r3, #1
 8004960:	3030      	adds	r0, #48	; 0x30
 8004962:	428a      	cmp	r2, r1
 8004964:	bf0c      	ite	eq
 8004966:	2300      	moveq	r3, #0
 8004968:	f003 0301 	andne.w	r3, r3, #1
 800496c:	497f      	ldr	r1, [pc, #508]	; (8004b6c <HAL_DMAEx_ConfigMuxSync+0x2bc>)
 800496e:	4282      	cmp	r2, r0
 8004970:	bf0c      	ite	eq
 8004972:	2300      	moveq	r3, #0
 8004974:	f003 0301 	andne.w	r3, r3, #1
 8004978:	487d      	ldr	r0, [pc, #500]	; (8004b70 <HAL_DMAEx_ConfigMuxSync+0x2c0>)
 800497a:	428a      	cmp	r2, r1
 800497c:	bf0c      	ite	eq
 800497e:	2300      	moveq	r3, #0
 8004980:	f003 0301 	andne.w	r3, r3, #1
 8004984:	3128      	adds	r1, #40	; 0x28
 8004986:	4282      	cmp	r2, r0
 8004988:	bf0c      	ite	eq
 800498a:	2300      	moveq	r3, #0
 800498c:	f003 0301 	andne.w	r3, r3, #1
 8004990:	3028      	adds	r0, #40	; 0x28
 8004992:	428a      	cmp	r2, r1
 8004994:	bf0c      	ite	eq
 8004996:	2300      	moveq	r3, #0
 8004998:	f003 0301 	andne.w	r3, r3, #1
 800499c:	3128      	adds	r1, #40	; 0x28
 800499e:	4282      	cmp	r2, r0
 80049a0:	bf0c      	ite	eq
 80049a2:	2300      	moveq	r3, #0
 80049a4:	f003 0301 	andne.w	r3, r3, #1
 80049a8:	3028      	adds	r0, #40	; 0x28
 80049aa:	428a      	cmp	r2, r1
 80049ac:	bf0c      	ite	eq
 80049ae:	2300      	moveq	r3, #0
 80049b0:	f003 0301 	andne.w	r3, r3, #1
 80049b4:	3128      	adds	r1, #40	; 0x28
 80049b6:	4282      	cmp	r2, r0
 80049b8:	bf0c      	ite	eq
 80049ba:	2300      	moveq	r3, #0
 80049bc:	f003 0301 	andne.w	r3, r3, #1
 80049c0:	428a      	cmp	r2, r1
 80049c2:	bf0c      	ite	eq
 80049c4:	2300      	moveq	r3, #0
 80049c6:	f003 0301 	andne.w	r3, r3, #1
 80049ca:	b11b      	cbz	r3, 80049d4 <HAL_DMAEx_ConfigMuxSync+0x124>
 80049cc:	4b69      	ldr	r3, [pc, #420]	; (8004b74 <HAL_DMAEx_ConfigMuxSync+0x2c4>)
 80049ce:	429a      	cmp	r2, r3
 80049d0:	f040 80c0 	bne.w	8004b54 <HAL_DMAEx_ConfigMuxSync+0x2a4>
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
 80049d4:	7a23      	ldrb	r3, [r4, #8]
 80049d6:	2b01      	cmp	r3, #1
 80049d8:	d904      	bls.n	80049e4 <HAL_DMAEx_ConfigMuxSync+0x134>
 80049da:	f44f 71ca 	mov.w	r1, #404	; 0x194
 80049de:	4866      	ldr	r0, [pc, #408]	; (8004b78 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
 80049e0:	f00e ff76 	bl	80138d0 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
 80049e4:	7a63      	ldrb	r3, [r4, #9]
 80049e6:	2b01      	cmp	r3, #1
 80049e8:	d904      	bls.n	80049f4 <HAL_DMAEx_ConfigMuxSync+0x144>
 80049ea:	f240 1195 	movw	r1, #405	; 0x195
 80049ee:	4862      	ldr	r0, [pc, #392]	; (8004b78 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
 80049f0:	f00e ff6e 	bl	80138d0 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
 80049f4:	68e3      	ldr	r3, [r4, #12]
 80049f6:	3b01      	subs	r3, #1
 80049f8:	2b1f      	cmp	r3, #31
 80049fa:	f200 808d 	bhi.w	8004b18 <HAL_DMAEx_ConfigMuxSync+0x268>

  if(pSyncConfig->SyncEnable == ENABLE)
 80049fe:	7a23      	ldrb	r3, [r4, #8]
 8004a00:	2b01      	cmp	r3, #1
 8004a02:	d02f      	beq.n	8004a64 <HAL_DMAEx_ConfigMuxSync+0x1b4>
  uint32_t syncPolarity = 0;
 8004a04:	2200      	movs	r2, #0
  uint32_t syncSignalID = 0;
 8004a06:	4611      	mov	r1, r2
    syncSignalID = pSyncConfig->SyncSignalID;
    syncPolarity = pSyncConfig->SyncPolarity;
  }

  /*Check if the DMA state is ready */
  if(hdma->State == HAL_DMA_STATE_READY)
 8004a08:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
 8004a0c:	b2db      	uxtb	r3, r3
 8004a0e:	2b01      	cmp	r3, #1
 8004a10:	d004      	beq.n	8004a1c <HAL_DMAEx_ConfigMuxSync+0x16c>
    return HAL_OK;
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8004a12:	f44f 6300 	mov.w	r3, #2048	; 0x800

    /* Return error status */
    return HAL_ERROR;
 8004a16:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8004a18:	656b      	str	r3, [r5, #84]	; 0x54
  }
}
 8004a1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hdma);
 8004a1c:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
 8004a20:	2801      	cmp	r0, #1
 8004a22:	f000 8086 	beq.w	8004b32 <HAL_DMAEx_ConfigMuxSync+0x282>
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
 8004a26:	6e2f      	ldr	r7, [r5, #96]	; 0x60
    __HAL_UNLOCK(hdma);
 8004a28:	2600      	movs	r6, #0
    __HAL_LOCK(hdma);
 8004a2a:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
 8004a2e:	683b      	ldr	r3, [r7, #0]
    return HAL_OK;
 8004a30:	4630      	mov	r0, r6
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
 8004a32:	f423 3381 	bic.w	r3, r3, #66048	; 0x10200
 8004a36:	603b      	str	r3, [r7, #0]
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
 8004a38:	68e7      	ldr	r7, [r4, #12]
 8004a3a:	7a23      	ldrb	r3, [r4, #8]
 8004a3c:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 8004a40:	6e2f      	ldr	r7, [r5, #96]	; 0x60
 8004a42:	041b      	lsls	r3, r3, #16
 8004a44:	f894 e009 	ldrb.w	lr, [r4, #9]
 8004a48:	683c      	ldr	r4, [r7, #0]
 8004a4a:	ea43 43cc 	orr.w	r3, r3, ip, lsl #19
 8004a4e:	b2e4      	uxtb	r4, r4
 8004a50:	ea43 234e 	orr.w	r3, r3, lr, lsl #9
 8004a54:	4323      	orrs	r3, r4
 8004a56:	4313      	orrs	r3, r2
 8004a58:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8004a5c:	603b      	str	r3, [r7, #0]
    __HAL_UNLOCK(hdma);
 8004a5e:	f885 6034 	strb.w	r6, [r5, #52]	; 0x34
}
 8004a62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
 8004a64:	6863      	ldr	r3, [r4, #4]
 8004a66:	f433 23c0 	bics.w	r3, r3, #393216	; 0x60000
 8004a6a:	d164      	bne.n	8004b36 <HAL_DMAEx_ConfigMuxSync+0x286>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8004a6c:	682a      	ldr	r2, [r5, #0]
 8004a6e:	4b3c      	ldr	r3, [pc, #240]	; (8004b60 <HAL_DMAEx_ConfigMuxSync+0x2b0>)
 8004a70:	493c      	ldr	r1, [pc, #240]	; (8004b64 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
 8004a72:	483d      	ldr	r0, [pc, #244]	; (8004b68 <HAL_DMAEx_ConfigMuxSync+0x2b8>)
 8004a74:	428a      	cmp	r2, r1
 8004a76:	bf18      	it	ne
 8004a78:	429a      	cmpne	r2, r3
 8004a7a:	f101 0130 	add.w	r1, r1, #48	; 0x30
 8004a7e:	bf0c      	ite	eq
 8004a80:	2301      	moveq	r3, #1
 8004a82:	2300      	movne	r3, #0
 8004a84:	4282      	cmp	r2, r0
 8004a86:	bf08      	it	eq
 8004a88:	f043 0301 	orreq.w	r3, r3, #1
 8004a8c:	3030      	adds	r0, #48	; 0x30
 8004a8e:	428a      	cmp	r2, r1
 8004a90:	bf08      	it	eq
 8004a92:	f043 0301 	orreq.w	r3, r3, #1
 8004a96:	3130      	adds	r1, #48	; 0x30
 8004a98:	4282      	cmp	r2, r0
 8004a9a:	bf08      	it	eq
 8004a9c:	f043 0301 	orreq.w	r3, r3, #1
 8004aa0:	3030      	adds	r0, #48	; 0x30
 8004aa2:	428a      	cmp	r2, r1
 8004aa4:	bf08      	it	eq
 8004aa6:	f043 0301 	orreq.w	r3, r3, #1
 8004aaa:	3130      	adds	r1, #48	; 0x30
 8004aac:	4282      	cmp	r2, r0
 8004aae:	bf08      	it	eq
 8004ab0:	f043 0301 	orreq.w	r3, r3, #1
 8004ab4:	f500 705c 	add.w	r0, r0, #880	; 0x370
 8004ab8:	428a      	cmp	r2, r1
 8004aba:	bf08      	it	eq
 8004abc:	f043 0301 	orreq.w	r3, r3, #1
 8004ac0:	f501 715c 	add.w	r1, r1, #880	; 0x370
 8004ac4:	4282      	cmp	r2, r0
 8004ac6:	bf08      	it	eq
 8004ac8:	f043 0301 	orreq.w	r3, r3, #1
 8004acc:	3030      	adds	r0, #48	; 0x30
 8004ace:	428a      	cmp	r2, r1
 8004ad0:	bf08      	it	eq
 8004ad2:	f043 0301 	orreq.w	r3, r3, #1
 8004ad6:	3130      	adds	r1, #48	; 0x30
 8004ad8:	4282      	cmp	r2, r0
 8004ada:	bf08      	it	eq
 8004adc:	f043 0301 	orreq.w	r3, r3, #1
 8004ae0:	3030      	adds	r0, #48	; 0x30
 8004ae2:	428a      	cmp	r2, r1
 8004ae4:	bf08      	it	eq
 8004ae6:	f043 0301 	orreq.w	r3, r3, #1
 8004aea:	3130      	adds	r1, #48	; 0x30
 8004aec:	4282      	cmp	r2, r0
 8004aee:	bf08      	it	eq
 8004af0:	f043 0301 	orreq.w	r3, r3, #1
 8004af4:	3030      	adds	r0, #48	; 0x30
 8004af6:	428a      	cmp	r2, r1
 8004af8:	bf08      	it	eq
 8004afa:	f043 0301 	orreq.w	r3, r3, #1
 8004afe:	6821      	ldr	r1, [r4, #0]
 8004b00:	4282      	cmp	r2, r0
 8004b02:	bf08      	it	eq
 8004b04:	f043 0301 	orreq.w	r3, r3, #1
 8004b08:	b913      	cbnz	r3, 8004b10 <HAL_DMAEx_ConfigMuxSync+0x260>
 8004b0a:	4b1c      	ldr	r3, [pc, #112]	; (8004b7c <HAL_DMAEx_ConfigMuxSync+0x2cc>)
 8004b0c:	429a      	cmp	r2, r3
 8004b0e:	d118      	bne.n	8004b42 <HAL_DMAEx_ConfigMuxSync+0x292>
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
 8004b10:	2907      	cmp	r1, #7
 8004b12:	d807      	bhi.n	8004b24 <HAL_DMAEx_ConfigMuxSync+0x274>
    syncPolarity = pSyncConfig->SyncPolarity;
 8004b14:	6862      	ldr	r2, [r4, #4]
 8004b16:	e777      	b.n	8004a08 <HAL_DMAEx_ConfigMuxSync+0x158>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
 8004b18:	f44f 71cb 	mov.w	r1, #406	; 0x196
 8004b1c:	4816      	ldr	r0, [pc, #88]	; (8004b78 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
 8004b1e:	f00e fed7 	bl	80138d0 <assert_failed>
 8004b22:	e76c      	b.n	80049fe <HAL_DMAEx_ConfigMuxSync+0x14e>
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
 8004b24:	f44f 71cf 	mov.w	r1, #414	; 0x19e
 8004b28:	4813      	ldr	r0, [pc, #76]	; (8004b78 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
 8004b2a:	f00e fed1 	bl	80138d0 <assert_failed>
 8004b2e:	6821      	ldr	r1, [r4, #0]
 8004b30:	e7f0      	b.n	8004b14 <HAL_DMAEx_ConfigMuxSync+0x264>
    __HAL_LOCK(hdma);
 8004b32:	2002      	movs	r0, #2
}
 8004b34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
 8004b36:	f44f 71cd 	mov.w	r1, #410	; 0x19a
 8004b3a:	480f      	ldr	r0, [pc, #60]	; (8004b78 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
 8004b3c:	f00e fec8 	bl	80138d0 <assert_failed>
 8004b40:	e794      	b.n	8004a6c <HAL_DMAEx_ConfigMuxSync+0x1bc>
      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
 8004b42:	290f      	cmp	r1, #15
 8004b44:	d9e6      	bls.n	8004b14 <HAL_DMAEx_ConfigMuxSync+0x264>
 8004b46:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
 8004b4a:	480b      	ldr	r0, [pc, #44]	; (8004b78 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
 8004b4c:	f00e fec0 	bl	80138d0 <assert_failed>
 8004b50:	6821      	ldr	r1, [r4, #0]
 8004b52:	e7df      	b.n	8004b14 <HAL_DMAEx_ConfigMuxSync+0x264>
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
 8004b54:	f240 1193 	movw	r1, #403	; 0x193
 8004b58:	4807      	ldr	r0, [pc, #28]	; (8004b78 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
 8004b5a:	f00e feb9 	bl	80138d0 <assert_failed>
 8004b5e:	e739      	b.n	80049d4 <HAL_DMAEx_ConfigMuxSync+0x124>
 8004b60:	40020010 	.word	0x40020010
 8004b64:	40020028 	.word	0x40020028
 8004b68:	40020040 	.word	0x40020040
 8004b6c:	58025408 	.word	0x58025408
 8004b70:	5802541c 	.word	0x5802541c
 8004b74:	58025494 	.word	0x58025494
 8004b78:	08029170 	.word	0x08029170
 8004b7c:	400204b8 	.word	0x400204b8

08004b80 <HAL_DMAEx_MUX_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMAEx_MUX_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8004b80:	b510      	push	{r4, lr}
  /* Check for DMAMUX Synchronization overrun */
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
 8004b82:	e9d0 2319 	ldrd	r2, r3, [r0, #100]	; 0x64
{
 8004b86:	4604      	mov	r4, r0
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
 8004b88:	6812      	ldr	r2, [r2, #0]
 8004b8a:	421a      	tst	r2, r3
 8004b8c:	d00e      	beq.n	8004bac <HAL_DMAEx_MUX_IRQHandler+0x2c>
  {
    /* Disable the synchro overrun interrupt */
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8004b8e:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8004b90:	6813      	ldr	r3, [r2, #0]
 8004b92:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004b96:	6013      	str	r3, [r2, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8004b98:	e9d0 3219 	ldrd	r3, r2, [r0, #100]	; 0x64
 8004b9c:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
 8004b9e:	6d43      	ldr	r3, [r0, #84]	; 0x54

    if(hdma->XferErrorCallback != NULL)
 8004ba0:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
 8004ba2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8004ba6:	6543      	str	r3, [r0, #84]	; 0x54
    if(hdma->XferErrorCallback != NULL)
 8004ba8:	b102      	cbz	r2, 8004bac <HAL_DMAEx_MUX_IRQHandler+0x2c>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 8004baa:	4790      	blx	r2
    }
  }

  if(hdma->DMAmuxRequestGen != 0)
 8004bac:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8004bae:	b1ab      	cbz	r3, 8004bdc <HAL_DMAEx_MUX_IRQHandler+0x5c>
  {
   /* if using a DMAMUX request generator block Check for DMAMUX request generator overrun */
    if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
 8004bb0:	e9d4 121c 	ldrd	r1, r2, [r4, #112]	; 0x70
 8004bb4:	6809      	ldr	r1, [r1, #0]
 8004bb6:	4211      	tst	r1, r2
 8004bb8:	d010      	beq.n	8004bdc <HAL_DMAEx_MUX_IRQHandler+0x5c>
    {
      /* Disable the request gen overrun interrupt */
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8004bba:	681a      	ldr	r2, [r3, #0]
 8004bbc:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8004bc0:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8004bc2:	e9d4 321c 	ldrd	r3, r2, [r4, #112]	; 0x70
 8004bc6:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
 8004bc8:	6d63      	ldr	r3, [r4, #84]	; 0x54

      if(hdma->XferErrorCallback != NULL)
 8004bca:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
 8004bcc:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8004bd0:	6563      	str	r3, [r4, #84]	; 0x54
      if(hdma->XferErrorCallback != NULL)
 8004bd2:	b11a      	cbz	r2, 8004bdc <HAL_DMAEx_MUX_IRQHandler+0x5c>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8004bd4:	4620      	mov	r0, r4
      }
    }
  }
}
 8004bd6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        hdma->XferErrorCallback(hdma);
 8004bda:	4710      	bx	r2
}
 8004bdc:	bd10      	pop	{r4, pc}
 8004bde:	bf00      	nop

08004be0 <FLASH_WaitForLastOperation.constprop.3>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
 8004be0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004be2:	4605      	mov	r5, r0
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag, errorflag;
  uint32_t tickstart = HAL_GetTick();
 8004be4:	f7fb ff20 	bl	8000a28 <HAL_GetTick>
 8004be8:	4606      	mov	r6, r0

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
 8004bea:	1e6b      	subs	r3, r5, #1
 8004bec:	2b01      	cmp	r3, #1
 8004bee:	d80e      	bhi.n	8004c0e <FLASH_WaitForLastOperation.constprop.3+0x2e>

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
 8004bf0:	2d01      	cmp	r5, #1
 8004bf2:	d111      	bne.n	8004c18 <FLASH_WaitForLastOperation.constprop.3+0x38>
  else
  {
    bsyflag = FLASH_FLAG_QW_BANK2;
  }

  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8004bf4:	4c2b      	ldr	r4, [pc, #172]	; (8004ca4 <FLASH_WaitForLastOperation.constprop.3+0xc4>)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8004bf6:	f24c 3550 	movw	r5, #50000	; 0xc350
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8004bfa:	6923      	ldr	r3, [r4, #16]
 8004bfc:	075b      	lsls	r3, r3, #29
 8004bfe:	d53a      	bpl.n	8004c76 <FLASH_WaitForLastOperation.constprop.3+0x96>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8004c00:	f7fb ff12 	bl	8000a28 <HAL_GetTick>
 8004c04:	1b80      	subs	r0, r0, r6
 8004c06:	42a8      	cmp	r0, r5
 8004c08:	d9f7      	bls.n	8004bfa <FLASH_WaitForLastOperation.constprop.3+0x1a>
      {
        return HAL_TIMEOUT;
 8004c0a:	2003      	movs	r0, #3
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    }
  }

  return HAL_OK;
}
 8004c0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
 8004c0e:	f240 3192 	movw	r1, #914	; 0x392
 8004c12:	4825      	ldr	r0, [pc, #148]	; (8004ca8 <FLASH_WaitForLastOperation.constprop.3+0xc8>)
 8004c14:	f00e fe5c 	bl	80138d0 <assert_failed>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8004c18:	4c22      	ldr	r4, [pc, #136]	; (8004ca4 <FLASH_WaitForLastOperation.constprop.3+0xc4>)
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8004c1a:	f24c 3750 	movw	r7, #50000	; 0xc350
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8004c1e:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 8004c22:	075a      	lsls	r2, r3, #29
 8004c24:	d508      	bpl.n	8004c38 <FLASH_WaitForLastOperation.constprop.3+0x58>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8004c26:	f7fb feff 	bl	8000a28 <HAL_GetTick>
 8004c2a:	1b80      	subs	r0, r0, r6
 8004c2c:	42b8      	cmp	r0, r7
 8004c2e:	d8ec      	bhi.n	8004c0a <FLASH_WaitForLastOperation.constprop.3+0x2a>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8004c30:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 8004c34:	075a      	lsls	r2, r3, #29
 8004c36:	d4f6      	bmi.n	8004c26 <FLASH_WaitForLastOperation.constprop.3+0x46>
  if (Bank == FLASH_BANK_1)
 8004c38:	2d01      	cmp	r5, #1
 8004c3a:	d01c      	beq.n	8004c76 <FLASH_WaitForLastOperation.constprop.3+0x96>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8004c3c:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8004c40:	481a      	ldr	r0, [pc, #104]	; (8004cac <FLASH_WaitForLastOperation.constprop.3+0xcc>)
 8004c42:	4018      	ands	r0, r3
 8004c44:	d00b      	beq.n	8004c5e <FLASH_WaitForLastOperation.constprop.3+0x7e>
    pFlash.ErrorCode |= errorflag;
 8004c46:	491a      	ldr	r1, [pc, #104]	; (8004cb0 <FLASH_WaitForLastOperation.constprop.3+0xd0>)
    return HAL_ERROR;
 8004c48:	2001      	movs	r0, #1
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8004c4a:	4d1a      	ldr	r5, [pc, #104]	; (8004cb4 <FLASH_WaitForLastOperation.constprop.3+0xd4>)
    pFlash.ErrorCode |= errorflag;
 8004c4c:	698a      	ldr	r2, [r1, #24]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8004c4e:	402b      	ands	r3, r5
    pFlash.ErrorCode |= errorflag;
 8004c50:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8004c54:	431a      	orrs	r2, r3
 8004c56:	618a      	str	r2, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 8004c58:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
}
 8004c5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
 8004c5e:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 8004c62:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
 8004c66:	d004      	beq.n	8004c72 <FLASH_WaitForLastOperation.constprop.3+0x92>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
 8004c68:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8004c6c:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
}
 8004c70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
 8004c72:	4618      	mov	r0, r3
}
 8004c74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8004c76:	4a0b      	ldr	r2, [pc, #44]	; (8004ca4 <FLASH_WaitForLastOperation.constprop.3+0xc4>)
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8004c78:	480c      	ldr	r0, [pc, #48]	; (8004cac <FLASH_WaitForLastOperation.constprop.3+0xcc>)
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8004c7a:	6913      	ldr	r3, [r2, #16]
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8004c7c:	4018      	ands	r0, r3
 8004c7e:	d107      	bne.n	8004c90 <FLASH_WaitForLastOperation.constprop.3+0xb0>
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
 8004c80:	6913      	ldr	r3, [r2, #16]
 8004c82:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
 8004c86:	d0f4      	beq.n	8004c72 <FLASH_WaitForLastOperation.constprop.3+0x92>
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
 8004c88:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8004c8c:	6153      	str	r3, [r2, #20]
}
 8004c8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pFlash.ErrorCode |= errorflag;
 8004c90:	4c07      	ldr	r4, [pc, #28]	; (8004cb0 <FLASH_WaitForLastOperation.constprop.3+0xd0>)
    return HAL_ERROR;
 8004c92:	2001      	movs	r0, #1
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8004c94:	4907      	ldr	r1, [pc, #28]	; (8004cb4 <FLASH_WaitForLastOperation.constprop.3+0xd4>)
 8004c96:	400b      	ands	r3, r1
    pFlash.ErrorCode |= errorflag;
 8004c98:	69a1      	ldr	r1, [r4, #24]
 8004c9a:	4319      	orrs	r1, r3
 8004c9c:	61a1      	str	r1, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 8004c9e:	6153      	str	r3, [r2, #20]
}
 8004ca0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004ca2:	bf00      	nop
 8004ca4:	52002000 	.word	0x52002000
 8004ca8:	080291ac 	.word	0x080291ac
 8004cac:	15ee0000 	.word	0x15ee0000
 8004cb0:	20000678 	.word	0x20000678
 8004cb4:	17ee0000 	.word	0x17ee0000

08004cb8 <HAL_FLASH_Program>:
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
 8004cb8:	2801      	cmp	r0, #1
{
 8004cba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004cbe:	460c      	mov	r4, r1
 8004cc0:	4616      	mov	r6, r2
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
 8004cc2:	d003      	beq.n	8004ccc <HAL_FLASH_Program+0x14>
 8004cc4:	219b      	movs	r1, #155	; 0x9b
 8004cc6:	4834      	ldr	r0, [pc, #208]	; (8004d98 <HAL_FLASH_Program+0xe0>)
 8004cc8:	f00e fe02 	bl	80138d0 <assert_failed>
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
 8004ccc:	f104 4778 	add.w	r7, r4, #4160749568	; 0xf8000000
 8004cd0:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
 8004cd4:	d24f      	bcs.n	8004d76 <HAL_FLASH_Program+0xbe>
  __HAL_LOCK(&pFlash);
 8004cd6:	4d31      	ldr	r5, [pc, #196]	; (8004d9c <HAL_FLASH_Program+0xe4>)
 8004cd8:	7d2b      	ldrb	r3, [r5, #20]
 8004cda:	2b01      	cmp	r3, #1
 8004cdc:	d053      	beq.n	8004d86 <HAL_FLASH_Program+0xce>
 8004cde:	f04f 0801 	mov.w	r8, #1
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
 8004ce2:	f5b7 1f80 	cmp.w	r7, #1048576	; 0x100000
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8004ce6:	f04f 0300 	mov.w	r3, #0
  __HAL_LOCK(&pFlash);
 8004cea:	f885 8014 	strb.w	r8, [r5, #20]
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
 8004cee:	d336      	bcc.n	8004d5e <HAL_FLASH_Program+0xa6>
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 8004cf0:	2002      	movs	r0, #2
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8004cf2:	61ab      	str	r3, [r5, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 8004cf4:	f7ff ff74 	bl	8004be0 <FLASH_WaitForLastOperation.constprop.3>
  if(status == HAL_OK)
 8004cf8:	bb68      	cbnz	r0, 8004d56 <HAL_FLASH_Program+0x9e>
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
 8004cfa:	4a29      	ldr	r2, [pc, #164]	; (8004da0 <HAL_FLASH_Program+0xe8>)
    bank = FLASH_BANK_2;
 8004cfc:	f04f 0802 	mov.w	r8, #2
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
 8004d00:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
 8004d04:	ea43 0308 	orr.w	r3, r3, r8
 8004d08:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
 8004d0c:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 8004d10:	f3bf 8f4f 	dsb	sy
        *dest_addr = *src_addr;
 8004d14:	6833      	ldr	r3, [r6, #0]
 8004d16:	6023      	str	r3, [r4, #0]
 8004d18:	6873      	ldr	r3, [r6, #4]
 8004d1a:	6063      	str	r3, [r4, #4]
 8004d1c:	68b3      	ldr	r3, [r6, #8]
 8004d1e:	60a3      	str	r3, [r4, #8]
 8004d20:	68f3      	ldr	r3, [r6, #12]
 8004d22:	60e3      	str	r3, [r4, #12]
 8004d24:	6933      	ldr	r3, [r6, #16]
 8004d26:	6123      	str	r3, [r4, #16]
 8004d28:	6973      	ldr	r3, [r6, #20]
 8004d2a:	6163      	str	r3, [r4, #20]
 8004d2c:	69b3      	ldr	r3, [r6, #24]
 8004d2e:	61a3      	str	r3, [r4, #24]
 8004d30:	69f3      	ldr	r3, [r6, #28]
 8004d32:	61e3      	str	r3, [r4, #28]
  __ASM volatile ("isb 0xF":::"memory");
 8004d34:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 8004d38:	f3bf 8f4f 	dsb	sy
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 8004d3c:	4640      	mov	r0, r8
 8004d3e:	f7ff ff4f 	bl	8004be0 <FLASH_WaitForLastOperation.constprop.3>
      if(bank == FLASH_BANK_1)
 8004d42:	f1b8 0f01 	cmp.w	r8, #1
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
 8004d46:	4a16      	ldr	r2, [pc, #88]	; (8004da0 <HAL_FLASH_Program+0xe8>)
      if(bank == FLASH_BANK_1)
 8004d48:	d020      	beq.n	8004d8c <HAL_FLASH_Program+0xd4>
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
 8004d4a:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
 8004d4e:	f023 0302 	bic.w	r3, r3, #2
 8004d52:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
  __HAL_UNLOCK(&pFlash);
 8004d56:	2300      	movs	r3, #0
 8004d58:	752b      	strb	r3, [r5, #20]
}
 8004d5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 8004d5e:	4640      	mov	r0, r8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8004d60:	61ab      	str	r3, [r5, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 8004d62:	f7ff ff3d 	bl	8004be0 <FLASH_WaitForLastOperation.constprop.3>
  if(status == HAL_OK)
 8004d66:	2800      	cmp	r0, #0
 8004d68:	d1f5      	bne.n	8004d56 <HAL_FLASH_Program+0x9e>
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
 8004d6a:	4a0d      	ldr	r2, [pc, #52]	; (8004da0 <HAL_FLASH_Program+0xe8>)
 8004d6c:	68d3      	ldr	r3, [r2, #12]
 8004d6e:	f043 0302 	orr.w	r3, r3, #2
 8004d72:	60d3      	str	r3, [r2, #12]
 8004d74:	e7ca      	b.n	8004d0c <HAL_FLASH_Program+0x54>
  __HAL_LOCK(&pFlash);
 8004d76:	4d09      	ldr	r5, [pc, #36]	; (8004d9c <HAL_FLASH_Program+0xe4>)
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
 8004d78:	219c      	movs	r1, #156	; 0x9c
 8004d7a:	4807      	ldr	r0, [pc, #28]	; (8004d98 <HAL_FLASH_Program+0xe0>)
 8004d7c:	f00e fda8 	bl	80138d0 <assert_failed>
  __HAL_LOCK(&pFlash);
 8004d80:	7d2b      	ldrb	r3, [r5, #20]
 8004d82:	2b01      	cmp	r3, #1
 8004d84:	d1ab      	bne.n	8004cde <HAL_FLASH_Program+0x26>
 8004d86:	2002      	movs	r0, #2
}
 8004d88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
 8004d8c:	68d3      	ldr	r3, [r2, #12]
 8004d8e:	f023 0302 	bic.w	r3, r3, #2
 8004d92:	60d3      	str	r3, [r2, #12]
 8004d94:	e7df      	b.n	8004d56 <HAL_FLASH_Program+0x9e>
 8004d96:	bf00      	nop
 8004d98:	080291ac 	.word	0x080291ac
 8004d9c:	20000678 	.word	0x20000678
 8004da0:	52002000 	.word	0x52002000

08004da4 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
 8004da4:	4b0f      	ldr	r3, [pc, #60]	; (8004de4 <HAL_FLASH_Unlock+0x40>)
 8004da6:	68da      	ldr	r2, [r3, #12]
 8004da8:	07d2      	lsls	r2, r2, #31
 8004daa:	d506      	bpl.n	8004dba <HAL_FLASH_Unlock+0x16>
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
 8004dac:	490e      	ldr	r1, [pc, #56]	; (8004de8 <HAL_FLASH_Unlock+0x44>)
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
 8004dae:	4a0f      	ldr	r2, [pc, #60]	; (8004dec <HAL_FLASH_Unlock+0x48>)
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
 8004db0:	6059      	str	r1, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
 8004db2:	605a      	str	r2, [r3, #4]
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
 8004db4:	68db      	ldr	r3, [r3, #12]
 8004db6:	07db      	lsls	r3, r3, #31
 8004db8:	d411      	bmi.n	8004dde <HAL_FLASH_Unlock+0x3a>
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
 8004dba:	4b0a      	ldr	r3, [pc, #40]	; (8004de4 <HAL_FLASH_Unlock+0x40>)
 8004dbc:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
 8004dc0:	f010 0001 	ands.w	r0, r0, #1
 8004dc4:	d00a      	beq.n	8004ddc <HAL_FLASH_Unlock+0x38>
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
 8004dc6:	4908      	ldr	r1, [pc, #32]	; (8004de8 <HAL_FLASH_Unlock+0x44>)
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
 8004dc8:	4a08      	ldr	r2, [pc, #32]	; (8004dec <HAL_FLASH_Unlock+0x48>)
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
 8004dca:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
 8004dce:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
 8004dd2:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
      return HAL_ERROR;
 8004dd6:	f000 0001 	and.w	r0, r0, #1
 8004dda:	4770      	bx	lr
 8004ddc:	4770      	bx	lr
 8004dde:	2001      	movs	r0, #1
}
 8004de0:	4770      	bx	lr
 8004de2:	bf00      	nop
 8004de4:	52002000 	.word	0x52002000
 8004de8:	45670123 	.word	0x45670123
 8004dec:	cdef89ab 	.word	0xcdef89ab

08004df0 <FLASH_WaitForLastOperation>:
{
 8004df0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004df4:	460d      	mov	r5, r1
 8004df6:	4606      	mov	r6, r0
  uint32_t tickstart = HAL_GetTick();
 8004df8:	f7fb fe16 	bl	8000a28 <HAL_GetTick>
 8004dfc:	4680      	mov	r8, r0
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
 8004dfe:	1e6b      	subs	r3, r5, #1
 8004e00:	2b01      	cmp	r3, #1
 8004e02:	d857      	bhi.n	8004eb4 <FLASH_WaitForLastOperation+0xc4>
    bsyflag = FLASH_FLAG_QW_BANK2;
 8004e04:	2d01      	cmp	r5, #1
 8004e06:	4c36      	ldr	r4, [pc, #216]	; (8004ee0 <FLASH_WaitForLastOperation+0xf0>)
 8004e08:	bf08      	it	eq
 8004e0a:	2404      	moveq	r4, #4
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8004e0c:	4f35      	ldr	r7, [pc, #212]	; (8004ee4 <FLASH_WaitForLastOperation+0xf4>)
 8004e0e:	2c04      	cmp	r4, #4
 8004e10:	d02d      	beq.n	8004e6e <FLASH_WaitForLastOperation+0x7e>
 8004e12:	1c70      	adds	r0, r6, #1
 8004e14:	d11b      	bne.n	8004e4e <FLASH_WaitForLastOperation+0x5e>
 8004e16:	4a33      	ldr	r2, [pc, #204]	; (8004ee4 <FLASH_WaitForLastOperation+0xf4>)
 8004e18:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
 8004e1c:	ea24 0303 	bic.w	r3, r4, r3
 8004e20:	0759      	lsls	r1, r3, #29
 8004e22:	d5f9      	bpl.n	8004e18 <FLASH_WaitForLastOperation+0x28>
  if (Bank == FLASH_BANK_1)
 8004e24:	2d01      	cmp	r5, #1
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8004e26:	4a2f      	ldr	r2, [pc, #188]	; (8004ee4 <FLASH_WaitForLastOperation+0xf4>)
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8004e28:	482f      	ldr	r0, [pc, #188]	; (8004ee8 <FLASH_WaitForLastOperation+0xf8>)
  if (Bank == FLASH_BANK_1)
 8004e2a:	d02a      	beq.n	8004e82 <FLASH_WaitForLastOperation+0x92>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8004e2c:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8004e30:	4018      	ands	r0, r3
 8004e32:	d031      	beq.n	8004e98 <FLASH_WaitForLastOperation+0xa8>
    pFlash.ErrorCode |= errorflag;
 8004e34:	4c2d      	ldr	r4, [pc, #180]	; (8004eec <FLASH_WaitForLastOperation+0xfc>)
    return HAL_ERROR;
 8004e36:	2001      	movs	r0, #1
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8004e38:	4d2d      	ldr	r5, [pc, #180]	; (8004ef0 <FLASH_WaitForLastOperation+0x100>)
    pFlash.ErrorCode |= errorflag;
 8004e3a:	69a1      	ldr	r1, [r4, #24]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8004e3c:	402b      	ands	r3, r5
    pFlash.ErrorCode |= errorflag;
 8004e3e:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 8004e42:	4319      	orrs	r1, r3
 8004e44:	61a1      	str	r1, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 8004e46:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
}
 8004e4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8004e4e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8004e52:	ea24 0303 	bic.w	r3, r4, r3
 8004e56:	075b      	lsls	r3, r3, #29
 8004e58:	d4e4      	bmi.n	8004e24 <FLASH_WaitForLastOperation+0x34>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8004e5a:	f7fb fde5 	bl	8000a28 <HAL_GetTick>
 8004e5e:	eba0 0008 	sub.w	r0, r0, r8
 8004e62:	42b0      	cmp	r0, r6
 8004e64:	d801      	bhi.n	8004e6a <FLASH_WaitForLastOperation+0x7a>
 8004e66:	2e00      	cmp	r6, #0
 8004e68:	d1d1      	bne.n	8004e0e <FLASH_WaitForLastOperation+0x1e>
        return HAL_TIMEOUT;
 8004e6a:	2003      	movs	r0, #3
 8004e6c:	e7ed      	b.n	8004e4a <FLASH_WaitForLastOperation+0x5a>
 8004e6e:	1c70      	adds	r0, r6, #1
 8004e70:	d127      	bne.n	8004ec2 <FLASH_WaitForLastOperation+0xd2>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8004e72:	4a1c      	ldr	r2, [pc, #112]	; (8004ee4 <FLASH_WaitForLastOperation+0xf4>)
 8004e74:	6913      	ldr	r3, [r2, #16]
 8004e76:	0759      	lsls	r1, r3, #29
 8004e78:	d4fc      	bmi.n	8004e74 <FLASH_WaitForLastOperation+0x84>
  if (Bank == FLASH_BANK_1)
 8004e7a:	2d01      	cmp	r5, #1
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8004e7c:	4a19      	ldr	r2, [pc, #100]	; (8004ee4 <FLASH_WaitForLastOperation+0xf4>)
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8004e7e:	481a      	ldr	r0, [pc, #104]	; (8004ee8 <FLASH_WaitForLastOperation+0xf8>)
  if (Bank == FLASH_BANK_1)
 8004e80:	d1d4      	bne.n	8004e2c <FLASH_WaitForLastOperation+0x3c>
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8004e82:	6913      	ldr	r3, [r2, #16]
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8004e84:	4018      	ands	r0, r3
 8004e86:	d120      	bne.n	8004eca <FLASH_WaitForLastOperation+0xda>
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
 8004e88:	6915      	ldr	r5, [r2, #16]
 8004e8a:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
 8004e8e:	d00e      	beq.n	8004eae <FLASH_WaitForLastOperation+0xbe>
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
 8004e90:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8004e94:	6153      	str	r3, [r2, #20]
 8004e96:	e7d8      	b.n	8004e4a <FLASH_WaitForLastOperation+0x5a>
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
 8004e98:	f8d2 5110 	ldr.w	r5, [r2, #272]	; 0x110
 8004e9c:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
 8004ea0:	d005      	beq.n	8004eae <FLASH_WaitForLastOperation+0xbe>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
 8004ea2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8004ea6:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
}
 8004eaa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return HAL_OK;
 8004eae:	4628      	mov	r0, r5
}
 8004eb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
 8004eb4:	f240 3192 	movw	r1, #914	; 0x392
 8004eb8:	480e      	ldr	r0, [pc, #56]	; (8004ef4 <FLASH_WaitForLastOperation+0x104>)
 8004eba:	f00e fd09 	bl	80138d0 <assert_failed>
    bsyflag = FLASH_FLAG_QW_BANK2;
 8004ebe:	4c08      	ldr	r4, [pc, #32]	; (8004ee0 <FLASH_WaitForLastOperation+0xf0>)
 8004ec0:	e7a4      	b.n	8004e0c <FLASH_WaitForLastOperation+0x1c>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8004ec2:	693b      	ldr	r3, [r7, #16]
 8004ec4:	075b      	lsls	r3, r3, #29
 8004ec6:	d4c8      	bmi.n	8004e5a <FLASH_WaitForLastOperation+0x6a>
 8004ec8:	e7ac      	b.n	8004e24 <FLASH_WaitForLastOperation+0x34>
    pFlash.ErrorCode |= errorflag;
 8004eca:	4c08      	ldr	r4, [pc, #32]	; (8004eec <FLASH_WaitForLastOperation+0xfc>)
    return HAL_ERROR;
 8004ecc:	4628      	mov	r0, r5
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8004ece:	4908      	ldr	r1, [pc, #32]	; (8004ef0 <FLASH_WaitForLastOperation+0x100>)
 8004ed0:	400b      	ands	r3, r1
    pFlash.ErrorCode |= errorflag;
 8004ed2:	69a1      	ldr	r1, [r4, #24]
 8004ed4:	4319      	orrs	r1, r3
 8004ed6:	61a1      	str	r1, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 8004ed8:	6153      	str	r3, [r2, #20]
}
 8004eda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004ede:	bf00      	nop
 8004ee0:	80000004 	.word	0x80000004
 8004ee4:	52002000 	.word	0x52002000
 8004ee8:	15ee0000 	.word	0x15ee0000
 8004eec:	20000678 	.word	0x20000678
 8004ef0:	17ee0000 	.word	0x17ee0000
 8004ef4:	080291ac 	.word	0x080291ac

08004ef8 <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)
{
 8004ef8:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
#if defined (FLASH_CR_PSIZE)
  assert_param(IS_VOLTAGERANGE(VoltageRange));
 8004efa:	f030 0330 	bics.w	r3, r0, #48	; 0x30
{
 8004efe:	4605      	mov	r5, r0
 8004f00:	460c      	mov	r4, r1
  assert_param(IS_VOLTAGERANGE(VoltageRange));
 8004f02:	d004      	beq.n	8004f0e <FLASH_MassErase+0x16>
 8004f04:	f44f 7144 	mov.w	r1, #784	; 0x310
 8004f08:	4826      	ldr	r0, [pc, #152]	; (8004fa4 <FLASH_MassErase+0xac>)
 8004f0a:	f00e fce1 	bl	80138d0 <assert_failed>
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));
 8004f0e:	1e63      	subs	r3, r4, #1
 8004f10:	2b02      	cmp	r3, #2
 8004f12:	d826      	bhi.n	8004f62 <FLASH_MassErase+0x6a>

  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
 8004f14:	f004 0303 	and.w	r3, r4, #3
 8004f18:	2b03      	cmp	r3, #3
 8004f1a:	d02b      	beq.n	8004f74 <FLASH_MassErase+0x7c>
    FLASH->OPTCR |= FLASH_OPTCR_MER;
  }
  else
  {
    /* Proceed to erase Flash Bank  */
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 8004f1c:	07e2      	lsls	r2, r4, #31
 8004f1e:	d50b      	bpl.n	8004f38 <FLASH_MassErase+0x40>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank1 */
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
 8004f20:	4b21      	ldr	r3, [pc, #132]	; (8004fa8 <FLASH_MassErase+0xb0>)
 8004f22:	68da      	ldr	r2, [r3, #12]
 8004f24:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8004f28:	60da      	str	r2, [r3, #12]
      FLASH->CR1 |=  VoltageRange;
 8004f2a:	68da      	ldr	r2, [r3, #12]
 8004f2c:	432a      	orrs	r2, r5
 8004f2e:	60da      	str	r2, [r3, #12]
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank1 */
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
 8004f30:	68da      	ldr	r2, [r3, #12]
 8004f32:	f042 0288 	orr.w	r2, r2, #136	; 0x88
 8004f36:	60da      	str	r2, [r3, #12]
    }
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 8004f38:	07a3      	lsls	r3, r4, #30
 8004f3a:	d511      	bpl.n	8004f60 <FLASH_MassErase+0x68>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank2 */
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
 8004f3c:	4b1a      	ldr	r3, [pc, #104]	; (8004fa8 <FLASH_MassErase+0xb0>)
 8004f3e:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8004f42:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8004f46:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
      FLASH->CR2 |= VoltageRange;
 8004f4a:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8004f4e:	4315      	orrs	r5, r2
 8004f50:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
 8004f54:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8004f58:	f042 0288 	orr.w	r2, r2, #136	; 0x88
 8004f5c:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    }
  }
}
 8004f60:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_FLASH_BANK(Banks));
 8004f62:	f44f 7145 	mov.w	r1, #788	; 0x314
 8004f66:	480f      	ldr	r0, [pc, #60]	; (8004fa4 <FLASH_MassErase+0xac>)
 8004f68:	f00e fcb2 	bl	80138d0 <assert_failed>
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
 8004f6c:	f004 0303 	and.w	r3, r4, #3
 8004f70:	2b03      	cmp	r3, #3
 8004f72:	d1d3      	bne.n	8004f1c <FLASH_MassErase+0x24>
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
 8004f74:	4b0c      	ldr	r3, [pc, #48]	; (8004fa8 <FLASH_MassErase+0xb0>)
 8004f76:	68da      	ldr	r2, [r3, #12]
 8004f78:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8004f7c:	60da      	str	r2, [r3, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
 8004f7e:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8004f82:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8004f86:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    FLASH->CR1 |= VoltageRange;
 8004f8a:	68da      	ldr	r2, [r3, #12]
 8004f8c:	432a      	orrs	r2, r5
 8004f8e:	60da      	str	r2, [r3, #12]
    FLASH->CR2 |= VoltageRange;
 8004f90:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8004f94:	4315      	orrs	r5, r2
 8004f96:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
    FLASH->OPTCR |= FLASH_OPTCR_MER;
 8004f9a:	699a      	ldr	r2, [r3, #24]
 8004f9c:	f042 0210 	orr.w	r2, r2, #16
 8004fa0:	619a      	str	r2, [r3, #24]
}
 8004fa2:	bd38      	pop	{r3, r4, r5, pc}
 8004fa4:	080291e8 	.word	0x080291e8
 8004fa8:	52002000 	.word	0x52002000

08004fac <HAL_FLASHEx_Erase>:
{
 8004fac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
 8004fb0:	6803      	ldr	r3, [r0, #0]
{
 8004fb2:	b083      	sub	sp, #12
 8004fb4:	4604      	mov	r4, r0
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
 8004fb6:	2b01      	cmp	r3, #1
{
 8004fb8:	9101      	str	r1, [sp, #4]
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
 8004fba:	d903      	bls.n	8004fc4 <HAL_FLASHEx_Erase+0x18>
 8004fbc:	21ac      	movs	r1, #172	; 0xac
 8004fbe:	487d      	ldr	r0, [pc, #500]	; (80051b4 <HAL_FLASHEx_Erase+0x208>)
 8004fc0:	f00e fc86 	bl	80138d0 <assert_failed>
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
 8004fc4:	6863      	ldr	r3, [r4, #4]
 8004fc6:	3b01      	subs	r3, #1
 8004fc8:	2b02      	cmp	r3, #2
 8004fca:	f200 80a1 	bhi.w	8005110 <HAL_FLASHEx_Erase+0x164>
  __HAL_LOCK(&pFlash);
 8004fce:	f8df 81ec 	ldr.w	r8, [pc, #492]	; 80051bc <HAL_FLASHEx_Erase+0x210>
 8004fd2:	f898 3014 	ldrb.w	r3, [r8, #20]
 8004fd6:	2b01      	cmp	r3, #1
 8004fd8:	f000 80a5 	beq.w	8005126 <HAL_FLASHEx_Erase+0x17a>
 8004fdc:	2501      	movs	r5, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8004fde:	2300      	movs	r3, #0
  __HAL_LOCK(&pFlash);
 8004fe0:	f888 5014 	strb.w	r5, [r8, #20]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8004fe4:	f8c8 3018 	str.w	r3, [r8, #24]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 8004fe8:	6862      	ldr	r2, [r4, #4]
 8004fea:	07d0      	lsls	r0, r2, #31
 8004fec:	f100 80a0 	bmi.w	8005130 <HAL_FLASHEx_Erase+0x184>
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 8004ff0:	0793      	lsls	r3, r2, #30
 8004ff2:	d50d      	bpl.n	8005010 <HAL_FLASHEx_Erase+0x64>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 8004ff4:	2102      	movs	r1, #2
 8004ff6:	f24c 3050 	movw	r0, #50000	; 0xc350
 8004ffa:	f7ff fef9 	bl	8004df0 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 8004ffe:	b138      	cbz	r0, 8005010 <HAL_FLASHEx_Erase+0x64>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 8005000:	2301      	movs	r3, #1
  __HAL_UNLOCK(&pFlash);
 8005002:	2200      	movs	r2, #0
}
 8005004:	4618      	mov	r0, r3
  __HAL_UNLOCK(&pFlash);
 8005006:	f888 2014 	strb.w	r2, [r8, #20]
}
 800500a:	b003      	add	sp, #12
 800500c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8005010:	6825      	ldr	r5, [r4, #0]
 8005012:	2d01      	cmp	r5, #1
 8005014:	f000 80a2 	beq.w	800515c <HAL_FLASHEx_Erase+0x1b0>
      *SectorError = 0xFFFFFFFFU;
 8005018:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800501c:	9a01      	ldr	r2, [sp, #4]
 800501e:	6013      	str	r3, [r2, #0]
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
 8005020:	e9d4 6302 	ldrd	r6, r3, [r4, #8]
 8005024:	4433      	add	r3, r6
 8005026:	42b3      	cmp	r3, r6
 8005028:	f240 8096 	bls.w	8005158 <HAL_FLASHEx_Erase+0x1ac>
 800502c:	0237      	lsls	r7, r6, #8
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)
{
  assert_param(IS_FLASH_SECTOR(Sector));
 800502e:	f8df 9184 	ldr.w	r9, [pc, #388]	; 80051b4 <HAL_FLASHEx_Erase+0x208>

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 8005032:	4d61      	ldr	r5, [pc, #388]	; (80051b8 <HAL_FLASHEx_Erase+0x20c>)
 8005034:	e03d      	b.n	80050b2 <HAL_FLASHEx_Erase+0x106>
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));
 8005036:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
 800503a:	2901      	cmp	r1, #1
 800503c:	d904      	bls.n	8005048 <HAL_FLASHEx_Erase+0x9c>
 800503e:	f240 3157 	movw	r1, #855	; 0x357
 8005042:	4648      	mov	r0, r9
 8005044:	f00e fc44 	bl	80138d0 <assert_failed>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
 8005048:	f03b 0330 	bics.w	r3, fp, #48	; 0x30
 800504c:	d004      	beq.n	8005058 <HAL_FLASHEx_Erase+0xac>
 800504e:	f240 3159 	movw	r1, #857	; 0x359
 8005052:	4648      	mov	r0, r9
 8005054:	f00e fc3c 	bl	80138d0 <assert_failed>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 8005058:	f01a 0f01 	tst.w	sl, #1
 800505c:	d00a      	beq.n	8005074 <HAL_FLASHEx_Erase+0xc8>
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 800505e:	68e9      	ldr	r1, [r5, #12]
 8005060:	f421 61e6 	bic.w	r1, r1, #1840	; 0x730
 8005064:	60e9      	str	r1, [r5, #12]

    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
 8005066:	68e9      	ldr	r1, [r5, #12]
 8005068:	f041 0184 	orr.w	r1, r1, #132	; 0x84
 800506c:	ea41 010b 	orr.w	r1, r1, fp
 8005070:	4339      	orrs	r1, r7
 8005072:	60e9      	str	r1, [r5, #12]

    FLASH->CR1 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 8005074:	f01a 0f02 	tst.w	sl, #2
 8005078:	d00e      	beq.n	8005098 <HAL_FLASHEx_Erase+0xec>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank2 */
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 800507a:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
 800507e:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
 8005082:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c

    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
 8005086:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
 800508a:	f043 0384 	orr.w	r3, r3, #132	; 0x84
 800508e:	ea43 030b 	orr.w	r3, r3, fp
 8005092:	433b      	orrs	r3, r7
 8005094:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 8005098:	6863      	ldr	r3, [r4, #4]
 800509a:	07da      	lsls	r2, r3, #31
 800509c:	d415      	bmi.n	80050ca <HAL_FLASHEx_Erase+0x11e>
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800509e:	0798      	lsls	r0, r3, #30
 80050a0:	d427      	bmi.n	80050f2 <HAL_FLASHEx_Erase+0x146>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
 80050a2:	68e3      	ldr	r3, [r4, #12]
 80050a4:	3601      	adds	r6, #1
 80050a6:	68a2      	ldr	r2, [r4, #8]
 80050a8:	f507 7780 	add.w	r7, r7, #256	; 0x100
 80050ac:	4413      	add	r3, r2
 80050ae:	42b3      	cmp	r3, r6
 80050b0:	d952      	bls.n	8005158 <HAL_FLASHEx_Erase+0x1ac>
  assert_param(IS_FLASH_SECTOR(Sector));
 80050b2:	2e07      	cmp	r6, #7
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
 80050b4:	f8d4 a004 	ldr.w	sl, [r4, #4]
 80050b8:	f8d4 b010 	ldr.w	fp, [r4, #16]
  assert_param(IS_FLASH_SECTOR(Sector));
 80050bc:	d9bb      	bls.n	8005036 <HAL_FLASHEx_Erase+0x8a>
 80050be:	f240 3156 	movw	r1, #854	; 0x356
 80050c2:	4648      	mov	r0, r9
 80050c4:	f00e fc04 	bl	80138d0 <assert_failed>
 80050c8:	e7b5      	b.n	8005036 <HAL_FLASHEx_Erase+0x8a>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
 80050ca:	2101      	movs	r1, #1
 80050cc:	f24c 3050 	movw	r0, #50000	; 0xc350
 80050d0:	f7ff fe8e 	bl	8004df0 <FLASH_WaitForLastOperation>
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 80050d4:	68ea      	ldr	r2, [r5, #12]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
 80050d6:	4603      	mov	r3, r0
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 80050d8:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 80050dc:	f022 0204 	bic.w	r2, r2, #4
 80050e0:	60ea      	str	r2, [r5, #12]
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 80050e2:	6862      	ldr	r2, [r4, #4]
 80050e4:	0791      	lsls	r1, r2, #30
 80050e6:	d404      	bmi.n	80050f2 <HAL_FLASHEx_Erase+0x146>
        if(status != HAL_OK)
 80050e8:	2b00      	cmp	r3, #0
 80050ea:	d0da      	beq.n	80050a2 <HAL_FLASHEx_Erase+0xf6>
          *SectorError = sector_index;
 80050ec:	9a01      	ldr	r2, [sp, #4]
 80050ee:	6016      	str	r6, [r2, #0]
          break;
 80050f0:	e787      	b.n	8005002 <HAL_FLASHEx_Erase+0x56>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
 80050f2:	2102      	movs	r1, #2
 80050f4:	f24c 3050 	movw	r0, #50000	; 0xc350
 80050f8:	f7ff fe7a 	bl	8004df0 <FLASH_WaitForLastOperation>
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 80050fc:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
 8005100:	4603      	mov	r3, r0
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 8005102:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8005106:	f022 0204 	bic.w	r2, r2, #4
 800510a:	f8c5 210c 	str.w	r2, [r5, #268]	; 0x10c
 800510e:	e7eb      	b.n	80050e8 <HAL_FLASHEx_Erase+0x13c>
  __HAL_LOCK(&pFlash);
 8005110:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80051bc <HAL_FLASHEx_Erase+0x210>
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
 8005114:	21ad      	movs	r1, #173	; 0xad
 8005116:	4827      	ldr	r0, [pc, #156]	; (80051b4 <HAL_FLASHEx_Erase+0x208>)
 8005118:	f00e fbda 	bl	80138d0 <assert_failed>
  __HAL_LOCK(&pFlash);
 800511c:	f898 3014 	ldrb.w	r3, [r8, #20]
 8005120:	2b01      	cmp	r3, #1
 8005122:	f47f af5b 	bne.w	8004fdc <HAL_FLASHEx_Erase+0x30>
 8005126:	2302      	movs	r3, #2
}
 8005128:	4618      	mov	r0, r3
 800512a:	b003      	add	sp, #12
 800512c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 8005130:	4629      	mov	r1, r5
 8005132:	f24c 3050 	movw	r0, #50000	; 0xc350
 8005136:	f7ff fe5b 	bl	8004df0 <FLASH_WaitForLastOperation>
 800513a:	b158      	cbz	r0, 8005154 <HAL_FLASHEx_Erase+0x1a8>
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800513c:	6863      	ldr	r3, [r4, #4]
 800513e:	079a      	lsls	r2, r3, #30
 8005140:	f57f af5e 	bpl.w	8005000 <HAL_FLASHEx_Erase+0x54>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 8005144:	2102      	movs	r1, #2
 8005146:	f24c 3050 	movw	r0, #50000	; 0xc350
 800514a:	9501      	str	r5, [sp, #4]
 800514c:	f7ff fe50 	bl	8004df0 <FLASH_WaitForLastOperation>
 8005150:	9b01      	ldr	r3, [sp, #4]
 8005152:	e756      	b.n	8005002 <HAL_FLASHEx_Erase+0x56>
 8005154:	6862      	ldr	r2, [r4, #4]
 8005156:	e74b      	b.n	8004ff0 <HAL_FLASHEx_Erase+0x44>
 8005158:	2300      	movs	r3, #0
 800515a:	e752      	b.n	8005002 <HAL_FLASHEx_Erase+0x56>
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
 800515c:	6861      	ldr	r1, [r4, #4]
 800515e:	6920      	ldr	r0, [r4, #16]
 8005160:	f7ff feca 	bl	8004ef8 <FLASH_MassErase>
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 8005164:	6862      	ldr	r2, [r4, #4]
 8005166:	f012 0301 	ands.w	r3, r2, #1
 800516a:	d114      	bne.n	8005196 <HAL_FLASHEx_Erase+0x1ea>
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 800516c:	0791      	lsls	r1, r2, #30
 800516e:	f57f af48 	bpl.w	8005002 <HAL_FLASHEx_Erase+0x56>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 8005172:	2102      	movs	r1, #2
 8005174:	f24c 3050 	movw	r0, #50000	; 0xc350
 8005178:	9301      	str	r3, [sp, #4]
 800517a:	f7ff fe39 	bl	8004df0 <FLASH_WaitForLastOperation>
        FLASH->CR2 &= (~FLASH_CR_BER);
 800517e:	490e      	ldr	r1, [pc, #56]	; (80051b8 <HAL_FLASHEx_Erase+0x20c>)
          status = HAL_ERROR;
 8005180:	2800      	cmp	r0, #0
 8005182:	9b01      	ldr	r3, [sp, #4]
        FLASH->CR2 &= (~FLASH_CR_BER);
 8005184:	f8d1 210c 	ldr.w	r2, [r1, #268]	; 0x10c
          status = HAL_ERROR;
 8005188:	bf18      	it	ne
 800518a:	2301      	movne	r3, #1
        FLASH->CR2 &= (~FLASH_CR_BER);
 800518c:	f022 0208 	bic.w	r2, r2, #8
 8005190:	f8c1 210c 	str.w	r2, [r1, #268]	; 0x10c
 8005194:	e735      	b.n	8005002 <HAL_FLASHEx_Erase+0x56>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 8005196:	4629      	mov	r1, r5
 8005198:	f24c 3050 	movw	r0, #50000	; 0xc350
 800519c:	f7ff fe28 	bl	8004df0 <FLASH_WaitForLastOperation>
        FLASH->CR1 &= (~FLASH_CR_BER);
 80051a0:	4905      	ldr	r1, [pc, #20]	; (80051b8 <HAL_FLASHEx_Erase+0x20c>)
          status = HAL_ERROR;
 80051a2:	1c03      	adds	r3, r0, #0
        FLASH->CR1 &= (~FLASH_CR_BER);
 80051a4:	68ca      	ldr	r2, [r1, #12]
          status = HAL_ERROR;
 80051a6:	bf18      	it	ne
 80051a8:	2301      	movne	r3, #1
        FLASH->CR1 &= (~FLASH_CR_BER);
 80051aa:	f022 0208 	bic.w	r2, r2, #8
 80051ae:	60ca      	str	r2, [r1, #12]
 80051b0:	6862      	ldr	r2, [r4, #4]
 80051b2:	e7db      	b.n	800516c <HAL_FLASHEx_Erase+0x1c0>
 80051b4:	080291e8 	.word	0x080291e8
 80051b8:	52002000 	.word	0x52002000
 80051bc:	20000678 	.word	0x20000678

080051c0 <HAL_GPIO_Init>:
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 80051c0:	4abf      	ldr	r2, [pc, #764]	; (80054c0 <HAL_GPIO_Init+0x300>)
 80051c2:	4bc0      	ldr	r3, [pc, #768]	; (80054c4 <HAL_GPIO_Init+0x304>)
 80051c4:	4290      	cmp	r0, r2
 80051c6:	bf18      	it	ne
 80051c8:	4298      	cmpne	r0, r3
{
 80051ca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80051ce:	4607      	mov	r7, r0
 80051d0:	b089      	sub	sp, #36	; 0x24
 80051d2:	4689      	mov	r9, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 80051d4:	bf14      	ite	ne
 80051d6:	f04f 0b01 	movne.w	fp, #1
 80051da:	f04f 0b00 	moveq.w	fp, #0
 80051de:	d027      	beq.n	8005230 <HAL_GPIO_Init+0x70>
 80051e0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80051e4:	4298      	cmp	r0, r3
 80051e6:	d023      	beq.n	8005230 <HAL_GPIO_Init+0x70>
 80051e8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80051ec:	4298      	cmp	r0, r3
 80051ee:	d01f      	beq.n	8005230 <HAL_GPIO_Init+0x70>
 80051f0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80051f4:	4298      	cmp	r0, r3
 80051f6:	d01b      	beq.n	8005230 <HAL_GPIO_Init+0x70>
 80051f8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80051fc:	4298      	cmp	r0, r3
 80051fe:	d017      	beq.n	8005230 <HAL_GPIO_Init+0x70>
 8005200:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005204:	4298      	cmp	r0, r3
 8005206:	d013      	beq.n	8005230 <HAL_GPIO_Init+0x70>
 8005208:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800520c:	4298      	cmp	r0, r3
 800520e:	d00f      	beq.n	8005230 <HAL_GPIO_Init+0x70>
 8005210:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
 8005214:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005218:	4290      	cmp	r0, r2
 800521a:	bf18      	it	ne
 800521c:	4298      	cmpne	r0, r3
 800521e:	d007      	beq.n	8005230 <HAL_GPIO_Init+0x70>
 8005220:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005224:	4298      	cmp	r0, r3
 8005226:	d003      	beq.n	8005230 <HAL_GPIO_Init+0x70>
 8005228:	21bb      	movs	r1, #187	; 0xbb
 800522a:	48a7      	ldr	r0, [pc, #668]	; (80054c8 <HAL_GPIO_Init+0x308>)
 800522c:	f00e fb50 	bl	80138d0 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 8005230:	f8d9 2000 	ldr.w	r2, [r9]
 8005234:	b293      	uxth	r3, r2
 8005236:	2b00      	cmp	r3, #0
 8005238:	f000 8168 	beq.w	800550c <HAL_GPIO_Init+0x34c>
 800523c:	4ba3      	ldr	r3, [pc, #652]	; (80054cc <HAL_GPIO_Init+0x30c>)
 800523e:	4013      	ands	r3, r2
 8005240:	2b00      	cmp	r3, #0
 8005242:	f040 8163 	bne.w	800550c <HAL_GPIO_Init+0x34c>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 8005246:	f8d9 2004 	ldr.w	r2, [r9, #4]
 800524a:	4ba1      	ldr	r3, [pc, #644]	; (80054d0 <HAL_GPIO_Init+0x310>)
 800524c:	4ca1      	ldr	r4, [pc, #644]	; (80054d4 <HAL_GPIO_Init+0x314>)
 800524e:	f1a2 0011 	sub.w	r0, r2, #17
 8005252:	429a      	cmp	r2, r3
 8005254:	bf18      	it	ne
 8005256:	2a03      	cmpne	r2, #3
 8005258:	f422 1100 	bic.w	r1, r2, #2097152	; 0x200000
 800525c:	bf8c      	ite	hi
 800525e:	2301      	movhi	r3, #1
 8005260:	2300      	movls	r3, #0
 8005262:	42a2      	cmp	r2, r4
 8005264:	bf0c      	ite	eq
 8005266:	2300      	moveq	r3, #0
 8005268:	f003 0301 	andne.w	r3, r3, #1
 800526c:	4a9a      	ldr	r2, [pc, #616]	; (80054d8 <HAL_GPIO_Init+0x318>)
 800526e:	2801      	cmp	r0, #1
 8005270:	bf94      	ite	ls
 8005272:	2300      	movls	r3, #0
 8005274:	f003 0301 	andhi.w	r3, r3, #1
 8005278:	4291      	cmp	r1, r2
 800527a:	bf0c      	ite	eq
 800527c:	2300      	moveq	r3, #0
 800527e:	f003 0301 	andne.w	r3, r3, #1
 8005282:	b11b      	cbz	r3, 800528c <HAL_GPIO_Init+0xcc>
 8005284:	4b95      	ldr	r3, [pc, #596]	; (80054dc <HAL_GPIO_Init+0x31c>)
 8005286:	4299      	cmp	r1, r3
 8005288:	f040 8193 	bne.w	80055b2 <HAL_GPIO_Init+0x3f2>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 800528c:	f8d9 3008 	ldr.w	r3, [r9, #8]
 8005290:	2b02      	cmp	r3, #2
 8005292:	f200 8170 	bhi.w	8005576 <HAL_GPIO_Init+0x3b6>

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8005296:	f8d9 1000 	ldr.w	r1, [r9]
 800529a:	2900      	cmp	r1, #0
 800529c:	f000 810d 	beq.w	80054ba <HAL_GPIO_Init+0x2fa>

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 80052a0:	4b8f      	ldr	r3, [pc, #572]	; (80054e0 <HAL_GPIO_Init+0x320>)
 80052a2:	f04f 0800 	mov.w	r8, #0
 80052a6:	4a8f      	ldr	r2, [pc, #572]	; (80054e4 <HAL_GPIO_Init+0x324>)
 80052a8:	488f      	ldr	r0, [pc, #572]	; (80054e8 <HAL_GPIO_Init+0x328>)
 80052aa:	429f      	cmp	r7, r3
 80052ac:	bf18      	it	ne
 80052ae:	4297      	cmpne	r7, r2
 80052b0:	4d8e      	ldr	r5, [pc, #568]	; (80054ec <HAL_GPIO_Init+0x32c>)
 80052b2:	f5a2 52c0 	sub.w	r2, r2, #6144	; 0x1800
 80052b6:	4c8e      	ldr	r4, [pc, #568]	; (80054f0 <HAL_GPIO_Init+0x330>)
 80052b8:	bf14      	ite	ne
 80052ba:	2301      	movne	r3, #1
 80052bc:	2300      	moveq	r3, #0
 80052be:	42af      	cmp	r7, r5
 80052c0:	bf0c      	ite	eq
 80052c2:	2300      	moveq	r3, #0
 80052c4:	f003 0301 	andne.w	r3, r3, #1
 80052c8:	4287      	cmp	r7, r0
 80052ca:	bf18      	it	ne
 80052cc:	4297      	cmpne	r7, r2
 80052ce:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 80052d2:	bf14      	ite	ne
 80052d4:	2201      	movne	r2, #1
 80052d6:	2200      	moveq	r2, #0
 80052d8:	9305      	str	r3, [sp, #20]
 80052da:	4b86      	ldr	r3, [pc, #536]	; (80054f4 <HAL_GPIO_Init+0x334>)
 80052dc:	9200      	str	r2, [sp, #0]
 80052de:	42a7      	cmp	r7, r4
 80052e0:	bf18      	it	ne
 80052e2:	429f      	cmpne	r7, r3
 80052e4:	4a84      	ldr	r2, [pc, #528]	; (80054f8 <HAL_GPIO_Init+0x338>)
 80052e6:	bf14      	ite	ne
 80052e8:	2301      	movne	r3, #1
 80052ea:	2300      	moveq	r3, #0
 80052ec:	4287      	cmp	r7, r0
 80052ee:	bf18      	it	ne
 80052f0:	4297      	cmpne	r7, r2
 80052f2:	9301      	str	r3, [sp, #4]
 80052f4:	bf14      	ite	ne
 80052f6:	2201      	movne	r2, #1
 80052f8:	2200      	moveq	r2, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80052fa:	4b80      	ldr	r3, [pc, #512]	; (80054fc <HAL_GPIO_Init+0x33c>)
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 80052fc:	9204      	str	r2, [sp, #16]
 80052fe:	4a80      	ldr	r2, [pc, #512]	; (8005500 <HAL_GPIO_Init+0x340>)
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8005300:	2401      	movs	r4, #1
 8005302:	fa04 f408 	lsl.w	r4, r4, r8
    if (iocurrent != 0x00U)
 8005306:	ea14 0a01 	ands.w	sl, r4, r1
 800530a:	f000 80d0 	beq.w	80054ae <HAL_GPIO_Init+0x2ee>
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800530e:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8005312:	ea4f 0648 	mov.w	r6, r8, lsl #1
 8005316:	2503      	movs	r5, #3
 8005318:	f021 0110 	bic.w	r1, r1, #16
 800531c:	40b5      	lsls	r5, r6
 800531e:	3901      	subs	r1, #1
 8005320:	43ed      	mvns	r5, r5
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8005322:	2901      	cmp	r1, #1
 8005324:	d814      	bhi.n	8005350 <HAL_GPIO_Init+0x190>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8005326:	f8d9 100c 	ldr.w	r1, [r9, #12]
 800532a:	2903      	cmp	r1, #3
 800532c:	f200 80f3 	bhi.w	8005516 <HAL_GPIO_Init+0x356>
        temp = GPIOx->OSPEEDR;
 8005330:	68b8      	ldr	r0, [r7, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8005332:	40b1      	lsls	r1, r6
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8005334:	4028      	ands	r0, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 8005336:	4301      	orrs	r1, r0
        GPIOx->OSPEEDR = temp;
 8005338:	60b9      	str	r1, [r7, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 800533a:	f8d9 1004 	ldr.w	r1, [r9, #4]
        temp = GPIOx->OTYPER;
 800533e:	6878      	ldr	r0, [r7, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8005340:	f3c1 1100 	ubfx	r1, r1, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8005344:	ea20 0004 	bic.w	r0, r0, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8005348:	fa01 f408 	lsl.w	r4, r1, r8
 800534c:	4304      	orrs	r4, r0
        GPIOx->OTYPER = temp;
 800534e:	607c      	str	r4, [r7, #4]
      temp = GPIOx->PUPDR;
 8005350:	68f8      	ldr	r0, [r7, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8005352:	f8d9 1008 	ldr.w	r1, [r9, #8]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8005356:	4028      	ands	r0, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8005358:	40b1      	lsls	r1, r6
 800535a:	4301      	orrs	r1, r0
      GPIOx->PUPDR = temp;
 800535c:	60f9      	str	r1, [r7, #12]
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800535e:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8005362:	f021 0010 	bic.w	r0, r1, #16
 8005366:	2802      	cmp	r0, #2
 8005368:	d120      	bne.n	80053ac <HAL_GPIO_Init+0x1ec>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 800536a:	f1bb 0f00 	cmp.w	fp, #0
 800536e:	d003      	beq.n	8005378 <HAL_GPIO_Init+0x1b8>
 8005370:	9900      	ldr	r1, [sp, #0]
 8005372:	2900      	cmp	r1, #0
 8005374:	f040 80da 	bne.w	800552c <HAL_GPIO_Init+0x36c>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 8005378:	f8d9 e010 	ldr.w	lr, [r9, #16]
 800537c:	f1be 0f0f 	cmp.w	lr, #15
 8005380:	f200 80ee 	bhi.w	8005560 <HAL_GPIO_Init+0x3a0>
        temp = GPIOx->AFR[position >> 3U];
 8005384:	ea4f 00d8 	mov.w	r0, r8, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8005388:	f008 0107 	and.w	r1, r8, #7
 800538c:	f04f 0c0f 	mov.w	ip, #15
 8005390:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8005394:	0089      	lsls	r1, r1, #2
        temp = GPIOx->AFR[position >> 3U];
 8005396:	6a04      	ldr	r4, [r0, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8005398:	fa0c fc01 	lsl.w	ip, ip, r1
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800539c:	fa0e f101 	lsl.w	r1, lr, r1
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80053a0:	ea24 040c 	bic.w	r4, r4, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80053a4:	4321      	orrs	r1, r4
        GPIOx->AFR[position >> 3U] = temp;
 80053a6:	6201      	str	r1, [r0, #32]
 80053a8:	f8d9 1004 	ldr.w	r1, [r9, #4]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80053ac:	f001 0103 	and.w	r1, r1, #3
      temp = GPIOx->MODER;
 80053b0:	6838      	ldr	r0, [r7, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80053b2:	fa01 f606 	lsl.w	r6, r1, r6
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 80053b6:	4005      	ands	r5, r0
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80053b8:	4335      	orrs	r5, r6
      GPIOx->MODER = temp;
 80053ba:	603d      	str	r5, [r7, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80053bc:	f8d9 1004 	ldr.w	r1, [r9, #4]
 80053c0:	00cc      	lsls	r4, r1, #3
 80053c2:	d572      	bpl.n	80054aa <HAL_GPIO_Init+0x2ea>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80053c4:	f8d3 40f4 	ldr.w	r4, [r3, #244]	; 0xf4
 80053c8:	f028 0503 	bic.w	r5, r8, #3

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80053cc:	f008 0103 	and.w	r1, r8, #3
 80053d0:	200f      	movs	r0, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80053d2:	f044 0402 	orr.w	r4, r4, #2
 80053d6:	4415      	add	r5, r2
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80053d8:	0089      	lsls	r1, r1, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80053da:	f8c3 40f4 	str.w	r4, [r3, #244]	; 0xf4
 80053de:	f8d3 40f4 	ldr.w	r4, [r3, #244]	; 0xf4
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80053e2:	fa00 f601 	lsl.w	r6, r0, r1
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80053e6:	f004 0402 	and.w	r4, r4, #2
 80053ea:	9407      	str	r4, [sp, #28]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80053ec:	4c34      	ldr	r4, [pc, #208]	; (80054c0 <HAL_GPIO_Init+0x300>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80053ee:	9807      	ldr	r0, [sp, #28]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80053f0:	42a7      	cmp	r7, r4
        temp = SYSCFG->EXTICR[position >> 2U];
 80053f2:	68a8      	ldr	r0, [r5, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80053f4:	ea20 0006 	bic.w	r0, r0, r6
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80053f8:	d027      	beq.n	800544a <HAL_GPIO_Init+0x28a>
 80053fa:	f1bb 0f00 	cmp.w	fp, #0
 80053fe:	f000 80bf 	beq.w	8005580 <HAL_GPIO_Init+0x3c0>
 8005402:	4c39      	ldr	r4, [pc, #228]	; (80054e8 <HAL_GPIO_Init+0x328>)
 8005404:	42a7      	cmp	r7, r4
 8005406:	f000 80a6 	beq.w	8005556 <HAL_GPIO_Init+0x396>
 800540a:	9c00      	ldr	r4, [sp, #0]
 800540c:	2c00      	cmp	r4, #0
 800540e:	f000 80c1 	beq.w	8005594 <HAL_GPIO_Init+0x3d4>
 8005412:	4c37      	ldr	r4, [pc, #220]	; (80054f0 <HAL_GPIO_Init+0x330>)
 8005414:	42a7      	cmp	r7, r4
 8005416:	f000 80c2 	beq.w	800559e <HAL_GPIO_Init+0x3de>
 800541a:	9c01      	ldr	r4, [sp, #4]
 800541c:	2c00      	cmp	r4, #0
 800541e:	f000 80b4 	beq.w	800558a <HAL_GPIO_Init+0x3ca>
 8005422:	4c38      	ldr	r4, [pc, #224]	; (8005504 <HAL_GPIO_Init+0x344>)
 8005424:	42a7      	cmp	r7, r4
 8005426:	f000 80bf 	beq.w	80055a8 <HAL_GPIO_Init+0x3e8>
 800542a:	9c04      	ldr	r4, [sp, #16]
 800542c:	2c00      	cmp	r4, #0
 800542e:	f000 80c5 	beq.w	80055bc <HAL_GPIO_Init+0x3fc>
 8005432:	4c2b      	ldr	r4, [pc, #172]	; (80054e0 <HAL_GPIO_Init+0x320>)
 8005434:	42a7      	cmp	r7, r4
 8005436:	f000 80c6 	beq.w	80055c6 <HAL_GPIO_Init+0x406>
 800543a:	4c2a      	ldr	r4, [pc, #168]	; (80054e4 <HAL_GPIO_Init+0x324>)
 800543c:	42a7      	cmp	r7, r4
 800543e:	bf0c      	ite	eq
 8005440:	2409      	moveq	r4, #9
 8005442:	240a      	movne	r4, #10
 8005444:	fa04 f101 	lsl.w	r1, r4, r1
 8005448:	4308      	orrs	r0, r1
        SYSCFG->EXTICR[position >> 2U] = temp;
 800544a:	60a8      	str	r0, [r5, #8]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
        temp &= ~(iocurrent);
 800544c:	ea6f 050a 	mvn.w	r5, sl
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8005450:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI_CurrentCPU->IMR1;
 8005454:	492c      	ldr	r1, [pc, #176]	; (8005508 <HAL_GPIO_Init+0x348>)
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8005456:	03c0      	lsls	r0, r0, #15
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8005458:	4c2b      	ldr	r4, [pc, #172]	; (8005508 <HAL_GPIO_Init+0x348>)
        temp = EXTI_CurrentCPU->IMR1;
 800545a:	6809      	ldr	r1, [r1, #0]
        temp &= ~(iocurrent);
 800545c:	bf54      	ite	pl
 800545e:	4029      	andpl	r1, r5
          temp |= iocurrent;
 8005460:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI_CurrentCPU->IMR1 = temp;
 8005464:	6021      	str	r1, [r4, #0]

        temp = EXTI_CurrentCPU->EMR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8005466:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI_CurrentCPU->EMR1;
 800546a:	6861      	ldr	r1, [r4, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800546c:	0386      	lsls	r6, r0, #14
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->EMR1 = temp;
 800546e:	4c26      	ldr	r4, [pc, #152]	; (8005508 <HAL_GPIO_Init+0x348>)

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8005470:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 8005474:	bf54      	ite	pl
 8005476:	4029      	andpl	r1, r5
          temp |= iocurrent;
 8005478:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI_CurrentCPU->EMR1 = temp;
 800547c:	6061      	str	r1, [r4, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 800547e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8005482:	f8d9 4004 	ldr.w	r4, [r9, #4]
        temp = EXTI->RTSR1;
 8005486:	6800      	ldr	r0, [r0, #0]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8005488:	02e4      	lsls	r4, r4, #11
        temp &= ~(iocurrent);
 800548a:	bf54      	ite	pl
 800548c:	4028      	andpl	r0, r5
          temp |= iocurrent;
 800548e:	ea4a 0000 	orrmi.w	r0, sl, r0
        EXTI->RTSR1 = temp;
 8005492:	6008      	str	r0, [r1, #0]

        temp = EXTI->FTSR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8005494:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI->FTSR1;
 8005498:	6849      	ldr	r1, [r1, #4]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800549a:	0280      	lsls	r0, r0, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 800549c:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 80054a0:	bf54      	ite	pl
 80054a2:	4029      	andpl	r1, r5
          temp |= iocurrent;
 80054a4:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI->FTSR1 = temp;
 80054a8:	6041      	str	r1, [r0, #4]
 80054aa:	f8d9 1000 	ldr.w	r1, [r9]
      }
    }

    position++;
 80054ae:	f108 0801 	add.w	r8, r8, #1
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 80054b2:	fa31 f008 	lsrs.w	r0, r1, r8
 80054b6:	f47f af23 	bne.w	8005300 <HAL_GPIO_Init+0x140>
  }
}
 80054ba:	b009      	add	sp, #36	; 0x24
 80054bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80054c0:	58020000 	.word	0x58020000
 80054c4:	58020400 	.word	0x58020400
 80054c8:	08029228 	.word	0x08029228
 80054cc:	ffff0000 	.word	0xffff0000
 80054d0:	11210000 	.word	0x11210000
 80054d4:	11220000 	.word	0x11220000
 80054d8:	11110000 	.word	0x11110000
 80054dc:	11120000 	.word	0x11120000
 80054e0:	58022000 	.word	0x58022000
 80054e4:	58022400 	.word	0x58022400
 80054e8:	58020800 	.word	0x58020800
 80054ec:	58022800 	.word	0x58022800
 80054f0:	58021000 	.word	0x58021000
 80054f4:	58021400 	.word	0x58021400
 80054f8:	58021c00 	.word	0x58021c00
 80054fc:	58024400 	.word	0x58024400
 8005500:	58000400 	.word	0x58000400
 8005504:	58021800 	.word	0x58021800
 8005508:	58000080 	.word	0x58000080
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 800550c:	21bc      	movs	r1, #188	; 0xbc
 800550e:	4830      	ldr	r0, [pc, #192]	; (80055d0 <HAL_GPIO_Init+0x410>)
 8005510:	f00e f9de 	bl	80138d0 <assert_failed>
 8005514:	e697      	b.n	8005246 <HAL_GPIO_Init+0x86>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8005516:	21ce      	movs	r1, #206	; 0xce
 8005518:	482d      	ldr	r0, [pc, #180]	; (80055d0 <HAL_GPIO_Init+0x410>)
 800551a:	e9cd 3202 	strd	r3, r2, [sp, #8]
 800551e:	f00e f9d7 	bl	80138d0 <assert_failed>
 8005522:	f8d9 100c 	ldr.w	r1, [r9, #12]
 8005526:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 800552a:	e701      	b.n	8005330 <HAL_GPIO_Init+0x170>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 800552c:	9901      	ldr	r1, [sp, #4]
 800552e:	2900      	cmp	r1, #0
 8005530:	f43f af22 	beq.w	8005378 <HAL_GPIO_Init+0x1b8>
 8005534:	9904      	ldr	r1, [sp, #16]
 8005536:	2900      	cmp	r1, #0
 8005538:	f43f af1e 	beq.w	8005378 <HAL_GPIO_Init+0x1b8>
 800553c:	9905      	ldr	r1, [sp, #20]
 800553e:	2900      	cmp	r1, #0
 8005540:	f43f af1a 	beq.w	8005378 <HAL_GPIO_Init+0x1b8>
 8005544:	21e6      	movs	r1, #230	; 0xe6
 8005546:	4822      	ldr	r0, [pc, #136]	; (80055d0 <HAL_GPIO_Init+0x410>)
 8005548:	e9cd 3202 	strd	r3, r2, [sp, #8]
 800554c:	f00e f9c0 	bl	80138d0 <assert_failed>
 8005550:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 8005554:	e710      	b.n	8005378 <HAL_GPIO_Init+0x1b8>
 8005556:	2402      	movs	r4, #2
 8005558:	fa04 f101 	lsl.w	r1, r4, r1
 800555c:	4308      	orrs	r0, r1
 800555e:	e774      	b.n	800544a <HAL_GPIO_Init+0x28a>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 8005560:	21e7      	movs	r1, #231	; 0xe7
 8005562:	481b      	ldr	r0, [pc, #108]	; (80055d0 <HAL_GPIO_Init+0x410>)
 8005564:	e9cd 3202 	strd	r3, r2, [sp, #8]
 8005568:	f00e f9b2 	bl	80138d0 <assert_failed>
 800556c:	f8d9 e010 	ldr.w	lr, [r9, #16]
 8005570:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 8005574:	e706      	b.n	8005384 <HAL_GPIO_Init+0x1c4>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 8005576:	21be      	movs	r1, #190	; 0xbe
 8005578:	4815      	ldr	r0, [pc, #84]	; (80055d0 <HAL_GPIO_Init+0x410>)
 800557a:	f00e f9a9 	bl	80138d0 <assert_failed>
 800557e:	e68a      	b.n	8005296 <HAL_GPIO_Init+0xd6>
 8005580:	2401      	movs	r4, #1
 8005582:	fa04 f101 	lsl.w	r1, r4, r1
 8005586:	4308      	orrs	r0, r1
 8005588:	e75f      	b.n	800544a <HAL_GPIO_Init+0x28a>
 800558a:	2405      	movs	r4, #5
 800558c:	fa04 f101 	lsl.w	r1, r4, r1
 8005590:	4308      	orrs	r0, r1
 8005592:	e75a      	b.n	800544a <HAL_GPIO_Init+0x28a>
 8005594:	2403      	movs	r4, #3
 8005596:	fa04 f101 	lsl.w	r1, r4, r1
 800559a:	4308      	orrs	r0, r1
 800559c:	e755      	b.n	800544a <HAL_GPIO_Init+0x28a>
 800559e:	2404      	movs	r4, #4
 80055a0:	fa04 f101 	lsl.w	r1, r4, r1
 80055a4:	4308      	orrs	r0, r1
 80055a6:	e750      	b.n	800544a <HAL_GPIO_Init+0x28a>
 80055a8:	2406      	movs	r4, #6
 80055aa:	fa04 f101 	lsl.w	r1, r4, r1
 80055ae:	4308      	orrs	r0, r1
 80055b0:	e74b      	b.n	800544a <HAL_GPIO_Init+0x28a>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 80055b2:	21bd      	movs	r1, #189	; 0xbd
 80055b4:	4806      	ldr	r0, [pc, #24]	; (80055d0 <HAL_GPIO_Init+0x410>)
 80055b6:	f00e f98b 	bl	80138d0 <assert_failed>
 80055ba:	e667      	b.n	800528c <HAL_GPIO_Init+0xcc>
 80055bc:	2407      	movs	r4, #7
 80055be:	fa04 f101 	lsl.w	r1, r4, r1
 80055c2:	4308      	orrs	r0, r1
 80055c4:	e741      	b.n	800544a <HAL_GPIO_Init+0x28a>
 80055c6:	2408      	movs	r4, #8
 80055c8:	fa04 f101 	lsl.w	r1, r4, r1
 80055cc:	4308      	orrs	r0, r1
 80055ce:	e73c      	b.n	800544a <HAL_GPIO_Init+0x28a>
 80055d0:	08029228 	.word	0x08029228

080055d4 <HAL_GPIO_DeInit>:
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 80055d4:	4a80      	ldr	r2, [pc, #512]	; (80057d8 <HAL_GPIO_DeInit+0x204>)
 80055d6:	4b81      	ldr	r3, [pc, #516]	; (80057dc <HAL_GPIO_DeInit+0x208>)
 80055d8:	4290      	cmp	r0, r2
 80055da:	bf18      	it	ne
 80055dc:	4298      	cmpne	r0, r3
{
 80055de:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80055e2:	4604      	mov	r4, r0
 80055e4:	b083      	sub	sp, #12
 80055e6:	460d      	mov	r5, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 80055e8:	bf14      	ite	ne
 80055ea:	f04f 0801 	movne.w	r8, #1
 80055ee:	f04f 0800 	moveq.w	r8, #0
 80055f2:	d028      	beq.n	8005646 <HAL_GPIO_DeInit+0x72>
 80055f4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80055f8:	4298      	cmp	r0, r3
 80055fa:	d024      	beq.n	8005646 <HAL_GPIO_DeInit+0x72>
 80055fc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005600:	4298      	cmp	r0, r3
 8005602:	d020      	beq.n	8005646 <HAL_GPIO_DeInit+0x72>
 8005604:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005608:	4298      	cmp	r0, r3
 800560a:	d01c      	beq.n	8005646 <HAL_GPIO_DeInit+0x72>
 800560c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005610:	4298      	cmp	r0, r3
 8005612:	d018      	beq.n	8005646 <HAL_GPIO_DeInit+0x72>
 8005614:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005618:	4298      	cmp	r0, r3
 800561a:	d014      	beq.n	8005646 <HAL_GPIO_DeInit+0x72>
 800561c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005620:	4298      	cmp	r0, r3
 8005622:	d010      	beq.n	8005646 <HAL_GPIO_DeInit+0x72>
 8005624:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
 8005628:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 800562c:	4290      	cmp	r0, r2
 800562e:	bf18      	it	ne
 8005630:	4298      	cmpne	r0, r3
 8005632:	d008      	beq.n	8005646 <HAL_GPIO_DeInit+0x72>
 8005634:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005638:	4298      	cmp	r0, r3
 800563a:	d004      	beq.n	8005646 <HAL_GPIO_DeInit+0x72>
 800563c:	f240 113f 	movw	r1, #319	; 0x13f
 8005640:	4867      	ldr	r0, [pc, #412]	; (80057e0 <HAL_GPIO_DeInit+0x20c>)
 8005642:	f00e f945 	bl	80138d0 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8005646:	b2ab      	uxth	r3, r5
 8005648:	2b00      	cmp	r3, #0
 800564a:	d046      	beq.n	80056da <HAL_GPIO_DeInit+0x106>
 800564c:	4b65      	ldr	r3, [pc, #404]	; (80057e4 <HAL_GPIO_DeInit+0x210>)
 800564e:	402b      	ands	r3, r5
 8005650:	2b00      	cmp	r3, #0
 8005652:	d142      	bne.n	80056da <HAL_GPIO_DeInit+0x106>
{
 8005654:	2300      	movs	r3, #0
 8005656:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 8005800 <HAL_GPIO_DeInit+0x22c>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 800565a:	f8df a17c 	ldr.w	sl, [pc, #380]	; 80057d8 <HAL_GPIO_DeInit+0x204>
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
 800565e:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 8005804 <HAL_GPIO_DeInit+0x230>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8005662:	f8cd 8004 	str.w	r8, [sp, #4]
    iocurrent = GPIO_Pin & (1UL << position) ;
 8005666:	f04f 0801 	mov.w	r8, #1
 800566a:	fa08 f003 	lsl.w	r0, r8, r3
    if (iocurrent != 0x00U)
 800566e:	ea10 0105 	ands.w	r1, r0, r5
 8005672:	f000 8081 	beq.w	8005778 <HAL_GPIO_DeInit+0x1a4>
 8005676:	f023 0703 	bic.w	r7, r3, #3
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
 800567a:	f003 0203 	and.w	r2, r3, #3
 800567e:	f04f 0c0f 	mov.w	ip, #15
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8005682:	4554      	cmp	r4, sl
 8005684:	445f      	add	r7, fp
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
 8005686:	ea4f 0282 	mov.w	r2, r2, lsl #2
      tmp = SYSCFG->EXTICR[position >> 2U];
 800568a:	f8d7 e008 	ldr.w	lr, [r7, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
 800568e:	fa0c fc02 	lsl.w	ip, ip, r2
 8005692:	ea0c 0e0e 	and.w	lr, ip, lr
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8005696:	d02a      	beq.n	80056ee <HAL_GPIO_DeInit+0x11a>
 8005698:	9e01      	ldr	r6, [sp, #4]
 800569a:	b1de      	cbz	r6, 80056d4 <HAL_GPIO_DeInit+0x100>
 800569c:	4e52      	ldr	r6, [pc, #328]	; (80057e8 <HAL_GPIO_DeInit+0x214>)
 800569e:	42b4      	cmp	r4, r6
 80056a0:	d077      	beq.n	8005792 <HAL_GPIO_DeInit+0x1be>
 80056a2:	4e52      	ldr	r6, [pc, #328]	; (80057ec <HAL_GPIO_DeInit+0x218>)
 80056a4:	42b4      	cmp	r4, r6
 80056a6:	d079      	beq.n	800579c <HAL_GPIO_DeInit+0x1c8>
 80056a8:	4e51      	ldr	r6, [pc, #324]	; (80057f0 <HAL_GPIO_DeInit+0x21c>)
 80056aa:	42b4      	cmp	r4, r6
 80056ac:	d06c      	beq.n	8005788 <HAL_GPIO_DeInit+0x1b4>
 80056ae:	4e51      	ldr	r6, [pc, #324]	; (80057f4 <HAL_GPIO_DeInit+0x220>)
 80056b0:	42b4      	cmp	r4, r6
 80056b2:	d07d      	beq.n	80057b0 <HAL_GPIO_DeInit+0x1dc>
 80056b4:	4e50      	ldr	r6, [pc, #320]	; (80057f8 <HAL_GPIO_DeInit+0x224>)
 80056b6:	42b4      	cmp	r4, r6
 80056b8:	d07f      	beq.n	80057ba <HAL_GPIO_DeInit+0x1e6>
 80056ba:	4e50      	ldr	r6, [pc, #320]	; (80057fc <HAL_GPIO_DeInit+0x228>)
 80056bc:	42b4      	cmp	r4, r6
 80056be:	d072      	beq.n	80057a6 <HAL_GPIO_DeInit+0x1d2>
 80056c0:	f8df 8144 	ldr.w	r8, [pc, #324]	; 8005808 <HAL_GPIO_DeInit+0x234>
 80056c4:	4544      	cmp	r4, r8
 80056c6:	d07d      	beq.n	80057c4 <HAL_GPIO_DeInit+0x1f0>
 80056c8:	f8df 8140 	ldr.w	r8, [pc, #320]	; 800580c <HAL_GPIO_DeInit+0x238>
 80056cc:	4544      	cmp	r4, r8
 80056ce:	d07e      	beq.n	80057ce <HAL_GPIO_DeInit+0x1fa>
 80056d0:	f04f 080a 	mov.w	r8, #10
 80056d4:	fa08 f202 	lsl.w	r2, r8, r2
 80056d8:	e00a      	b.n	80056f0 <HAL_GPIO_DeInit+0x11c>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 80056da:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80056de:	4840      	ldr	r0, [pc, #256]	; (80057e0 <HAL_GPIO_DeInit+0x20c>)
 80056e0:	f00e f8f6 	bl	80138d0 <assert_failed>
  while ((GPIO_Pin >> position) != 0x00U)
 80056e4:	2d00      	cmp	r5, #0
 80056e6:	d1b5      	bne.n	8005654 <HAL_GPIO_DeInit+0x80>
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    }

    position++;
  }
}
 80056e8:	b003      	add	sp, #12
 80056ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80056ee:	2200      	movs	r2, #0
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 80056f0:	4596      	cmp	lr, r2
 80056f2:	d11d      	bne.n	8005730 <HAL_GPIO_DeInit+0x15c>
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
 80056f4:	f8d9 e000 	ldr.w	lr, [r9]
 80056f8:	43c9      	mvns	r1, r1
        EXTI->RTSR1 &= ~(iocurrent);
 80056fa:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
 80056fe:	ea0e 0e01 	and.w	lr, lr, r1
 8005702:	f8c9 e000 	str.w	lr, [r9]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
 8005706:	f8d9 e004 	ldr.w	lr, [r9, #4]
 800570a:	ea01 0e0e 	and.w	lr, r1, lr
 800570e:	f8c9 e004 	str.w	lr, [r9, #4]
        EXTI->RTSR1 &= ~(iocurrent);
 8005712:	f8d2 e000 	ldr.w	lr, [r2]
 8005716:	ea01 0e0e 	and.w	lr, r1, lr
 800571a:	f8c2 e000 	str.w	lr, [r2]
        EXTI->FTSR1 &= ~(iocurrent);
 800571e:	f8d2 e004 	ldr.w	lr, [r2, #4]
 8005722:	ea01 010e 	and.w	r1, r1, lr
 8005726:	6051      	str	r1, [r2, #4]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
 8005728:	68ba      	ldr	r2, [r7, #8]
 800572a:	ea22 020c 	bic.w	r2, r2, ip
 800572e:	60ba      	str	r2, [r7, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 8005730:	2103      	movs	r1, #3
 8005732:	005a      	lsls	r2, r3, #1
 8005734:	f8d4 e000 	ldr.w	lr, [r4]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8005738:	f04f 0c0f 	mov.w	ip, #15
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 800573c:	fa01 f202 	lsl.w	r2, r1, r2
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8005740:	fa23 f701 	lsr.w	r7, r3, r1
 8005744:	f003 0107 	and.w	r1, r3, #7
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 8005748:	ea4e 0e02 	orr.w	lr, lr, r2
 800574c:	eb04 0787 	add.w	r7, r4, r7, lsl #2
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8005750:	0089      	lsls	r1, r1, #2
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8005752:	43d2      	mvns	r2, r2
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 8005754:	f8c4 e000 	str.w	lr, [r4]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8005758:	fa0c fc01 	lsl.w	ip, ip, r1
 800575c:	6a39      	ldr	r1, [r7, #32]
 800575e:	ea21 010c 	bic.w	r1, r1, ip
 8005762:	6239      	str	r1, [r7, #32]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8005764:	68e1      	ldr	r1, [r4, #12]
 8005766:	4011      	ands	r1, r2
 8005768:	60e1      	str	r1, [r4, #12]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 800576a:	6861      	ldr	r1, [r4, #4]
 800576c:	ea21 0000 	bic.w	r0, r1, r0
 8005770:	6060      	str	r0, [r4, #4]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8005772:	68a1      	ldr	r1, [r4, #8]
 8005774:	400a      	ands	r2, r1
 8005776:	60a2      	str	r2, [r4, #8]
    position++;
 8005778:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00U)
 800577a:	fa35 f203 	lsrs.w	r2, r5, r3
 800577e:	f47f af72 	bne.w	8005666 <HAL_GPIO_DeInit+0x92>
}
 8005782:	b003      	add	sp, #12
 8005784:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005788:	f04f 0804 	mov.w	r8, #4
 800578c:	fa08 f202 	lsl.w	r2, r8, r2
 8005790:	e7ae      	b.n	80056f0 <HAL_GPIO_DeInit+0x11c>
 8005792:	f04f 0802 	mov.w	r8, #2
 8005796:	fa08 f202 	lsl.w	r2, r8, r2
 800579a:	e7a9      	b.n	80056f0 <HAL_GPIO_DeInit+0x11c>
 800579c:	f04f 0803 	mov.w	r8, #3
 80057a0:	fa08 f202 	lsl.w	r2, r8, r2
 80057a4:	e7a4      	b.n	80056f0 <HAL_GPIO_DeInit+0x11c>
 80057a6:	f04f 0807 	mov.w	r8, #7
 80057aa:	fa08 f202 	lsl.w	r2, r8, r2
 80057ae:	e79f      	b.n	80056f0 <HAL_GPIO_DeInit+0x11c>
 80057b0:	f04f 0805 	mov.w	r8, #5
 80057b4:	fa08 f202 	lsl.w	r2, r8, r2
 80057b8:	e79a      	b.n	80056f0 <HAL_GPIO_DeInit+0x11c>
 80057ba:	f04f 0806 	mov.w	r8, #6
 80057be:	fa08 f202 	lsl.w	r2, r8, r2
 80057c2:	e795      	b.n	80056f0 <HAL_GPIO_DeInit+0x11c>
 80057c4:	f04f 0808 	mov.w	r8, #8
 80057c8:	fa08 f202 	lsl.w	r2, r8, r2
 80057cc:	e790      	b.n	80056f0 <HAL_GPIO_DeInit+0x11c>
 80057ce:	f04f 0809 	mov.w	r8, #9
 80057d2:	fa08 f202 	lsl.w	r2, r8, r2
 80057d6:	e78b      	b.n	80056f0 <HAL_GPIO_DeInit+0x11c>
 80057d8:	58020000 	.word	0x58020000
 80057dc:	58020400 	.word	0x58020400
 80057e0:	08029228 	.word	0x08029228
 80057e4:	ffff0000 	.word	0xffff0000
 80057e8:	58020800 	.word	0x58020800
 80057ec:	58020c00 	.word	0x58020c00
 80057f0:	58021000 	.word	0x58021000
 80057f4:	58021400 	.word	0x58021400
 80057f8:	58021800 	.word	0x58021800
 80057fc:	58021c00 	.word	0x58021c00
 8005800:	58000400 	.word	0x58000400
 8005804:	58000080 	.word	0x58000080
 8005808:	58022000 	.word	0x58022000
 800580c:	58022400 	.word	0x58022400

08005810 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 8005810:	b538      	push	{r3, r4, r5, lr}
 8005812:	4605      	mov	r5, r0
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8005814:	460c      	mov	r4, r1
 8005816:	b129      	cbz	r1, 8005824 <HAL_GPIO_ReadPin+0x14>

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
 8005818:	692b      	ldr	r3, [r5, #16]
 800581a:	421c      	tst	r4, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 800581c:	bf14      	ite	ne
 800581e:	2001      	movne	r0, #1
 8005820:	2000      	moveq	r0, #0
 8005822:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8005824:	f240 118d 	movw	r1, #397	; 0x18d
 8005828:	4801      	ldr	r0, [pc, #4]	; (8005830 <HAL_GPIO_ReadPin+0x20>)
 800582a:	f00e f851 	bl	80138d0 <assert_failed>
 800582e:	e7f3      	b.n	8005818 <HAL_GPIO_ReadPin+0x8>
 8005830:	08029228 	.word	0x08029228

08005834 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8005834:	b570      	push	{r4, r5, r6, lr}
 8005836:	4606      	mov	r6, r0
 8005838:	4615      	mov	r5, r2
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 800583a:	460c      	mov	r4, r1
 800583c:	b161      	cbz	r1, 8005858 <HAL_GPIO_WritePin+0x24>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 800583e:	2d01      	cmp	r5, #1
 8005840:	d803      	bhi.n	800584a <HAL_GPIO_WritePin+0x16>

  if (PinState != GPIO_PIN_RESET)
 8005842:	b905      	cbnz	r5, 8005846 <HAL_GPIO_WritePin+0x12>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8005844:	0424      	lsls	r4, r4, #16
 8005846:	61b4      	str	r4, [r6, #24]
  }
}
 8005848:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 800584a:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 800584e:	4805      	ldr	r0, [pc, #20]	; (8005864 <HAL_GPIO_WritePin+0x30>)
 8005850:	f00e f83e 	bl	80138d0 <assert_failed>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8005854:	61b4      	str	r4, [r6, #24]
}
 8005856:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8005858:	f240 11ad 	movw	r1, #429	; 0x1ad
 800585c:	4801      	ldr	r0, [pc, #4]	; (8005864 <HAL_GPIO_WritePin+0x30>)
 800585e:	f00e f837 	bl	80138d0 <assert_failed>
 8005862:	e7ec      	b.n	800583e <HAL_GPIO_WritePin+0xa>
 8005864:	08029228 	.word	0x08029228

08005868 <HAL_HCD_HC_Init>:
                                  uint8_t epnum,
                                  uint8_t dev_address,
                                  uint8_t speed,
                                  uint8_t ep_type,
                                  uint16_t mps)
{
 8005868:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef status;

  __HAL_LOCK(hhcd);
 800586c:	f890 42b8 	ldrb.w	r4, [r0, #696]	; 0x2b8
{
 8005870:	b085      	sub	sp, #20
  __HAL_LOCK(hhcd);
 8005872:	2c01      	cmp	r4, #1
{
 8005874:	f89d c038 	ldrb.w	ip, [sp, #56]	; 0x38
 8005878:	f89d e03c 	ldrb.w	lr, [sp, #60]	; 0x3c
 800587c:	f8bd 9040 	ldrh.w	r9, [sp, #64]	; 0x40
  __HAL_LOCK(hhcd);
 8005880:	d029      	beq.n	80058d6 <HAL_HCD_HC_Init+0x6e>
 8005882:	4605      	mov	r5, r0
  hhcd->hc[ch_num].do_ping = 0U;
 8005884:	eb01 0481 	add.w	r4, r1, r1, lsl #2
  __HAL_LOCK(hhcd);
 8005888:	f04f 0801 	mov.w	r8, #1
  hhcd->hc[ch_num].max_packet = mps;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].ep_type = ep_type;
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;

  if ((epnum & 0x80U) == 0x80U)
 800588c:	09d0      	lsrs	r0, r2, #7
  hhcd->hc[ch_num].do_ping = 0U;
 800588e:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 8005892:	f002 0a7f 	and.w	sl, r2, #127	; 0x7f
  __HAL_LOCK(hhcd);
 8005896:	f885 82b8 	strb.w	r8, [r5, #696]	; 0x2b8
  hhcd->hc[ch_num].do_ping = 0U;
 800589a:	f04f 0800 	mov.w	r8, #0
  hhcd->hc[ch_num].dev_addr = dev_address;
 800589e:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  hhcd->hc[ch_num].max_packet = mps;
 80058a2:	f8a4 9040 	strh.w	r9, [r4, #64]	; 0x40
  hhcd->hc[ch_num].ch_num = ch_num;
 80058a6:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  hhcd->hc[ch_num].ep_type = ep_type;
 80058aa:	f884 e03f 	strb.w	lr, [r4, #63]	; 0x3f
  else
  {
    hhcd->hc[ch_num].ep_is_in = 0U;
  }

  hhcd->hc[ch_num].speed = speed;
 80058ae:	f884 c03c 	strb.w	ip, [r4, #60]	; 0x3c
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 80058b2:	f884 a03a 	strb.w	sl, [r4, #58]	; 0x3a
 80058b6:	f884 003b 	strb.w	r0, [r4, #59]	; 0x3b
  hhcd->hc[ch_num].do_ping = 0U;
 80058ba:	f884 803d 	strb.w	r8, [r4, #61]	; 0x3d

  status =  USB_HC_Init(hhcd->Instance,
 80058be:	6828      	ldr	r0, [r5, #0]
 80058c0:	f8cd c000 	str.w	ip, [sp]
 80058c4:	e9cd e901 	strd	lr, r9, [sp, #4]
 80058c8:	f009 f9bc 	bl	800ec44 <USB_HC_Init>
                        epnum,
                        dev_address,
                        speed,
                        ep_type,
                        mps);
  __HAL_UNLOCK(hhcd);
 80058cc:	f885 82b8 	strb.w	r8, [r5, #696]	; 0x2b8

  return status;
}
 80058d0:	b005      	add	sp, #20
 80058d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __HAL_LOCK(hhcd);
 80058d6:	2002      	movs	r0, #2
}
 80058d8:	b005      	add	sp, #20
 80058da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80058de:	bf00      	nop

080058e0 <HAL_HCD_HC_Halt>:
  */
HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
  HAL_StatusTypeDef status = HAL_OK;

  __HAL_LOCK(hhcd);
 80058e0:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
 80058e4:	2b01      	cmp	r3, #1
 80058e6:	d00b      	beq.n	8005900 <HAL_HCD_HC_Halt+0x20>
 80058e8:	2301      	movs	r3, #1
{
 80058ea:	b510      	push	{r4, lr}
 80058ec:	4604      	mov	r4, r0
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80058ee:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 80058f0:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80058f4:	f009 fb02 	bl	800eefc <USB_HC_Halt>
  __HAL_UNLOCK(hhcd);
 80058f8:	2000      	movs	r0, #0
 80058fa:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return status;
}
 80058fe:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 8005900:	2002      	movs	r0, #2
}
 8005902:	4770      	bx	lr

08005904 <HAL_HCD_Init>:
  if (hhcd == NULL)
 8005904:	2800      	cmp	r0, #0
 8005906:	d057      	beq.n	80059b8 <HAL_HCD_Init+0xb4>
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
 8005908:	4b2c      	ldr	r3, [pc, #176]	; (80059bc <HAL_HCD_Init+0xb8>)
{
 800590a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
 800590e:	6804      	ldr	r4, [r0, #0]
{
 8005910:	b08a      	sub	sp, #40	; 0x28
 8005912:	4607      	mov	r7, r0
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
 8005914:	429c      	cmp	r4, r3
 8005916:	d008      	beq.n	800592a <HAL_HCD_Init+0x26>
 8005918:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
 800591c:	429c      	cmp	r4, r3
 800591e:	d004      	beq.n	800592a <HAL_HCD_Init+0x26>
 8005920:	217a      	movs	r1, #122	; 0x7a
 8005922:	4827      	ldr	r0, [pc, #156]	; (80059c0 <HAL_HCD_Init+0xbc>)
 8005924:	f00d ffd4 	bl	80138d0 <assert_failed>
 8005928:	683c      	ldr	r4, [r7, #0]
  if (hhcd->State == HAL_HCD_STATE_RESET)
 800592a:	f897 32b9 	ldrb.w	r3, [r7, #697]	; 0x2b9
 800592e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8005932:	2b00      	cmp	r3, #0
 8005934:	d039      	beq.n	80059aa <HAL_HCD_Init+0xa6>
 8005936:	4620      	mov	r0, r4
  hhcd->State = HAL_HCD_STATE_BUSY;
 8005938:	2303      	movs	r3, #3
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 800593a:	466d      	mov	r5, sp
 800593c:	f107 0804 	add.w	r8, r7, #4
  hhcd->State = HAL_HCD_STATE_BUSY;
 8005940:	f887 32b9 	strb.w	r3, [r7, #697]	; 0x2b9
  if ((USBx->CID & (0x1U << 8)) == 0U)
 8005944:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 8005946:	463c      	mov	r4, r7
  if ((USBx->CID & (0x1U << 8)) == 0U)
 8005948:	f413 7380 	ands.w	r3, r3, #256	; 0x100
    hhcd->Init.dma_enable = 0U;
 800594c:	bf08      	it	eq
 800594e:	613b      	streq	r3, [r7, #16]
  __HAL_HCD_DISABLE(hhcd);
 8005950:	f009 f82e 	bl	800e9b0 <USB_DisableGlobalInt>
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 8005954:	f854 6b10 	ldr.w	r6, [r4], #16
 8005958:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800595a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800595c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800595e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8005960:	e894 0003 	ldmia.w	r4, {r0, r1}
 8005964:	e885 0003 	stmia.w	r5, {r0, r1}
 8005968:	4630      	mov	r0, r6
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
 800596a:	463e      	mov	r6, r7
 800596c:	466d      	mov	r5, sp
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 800596e:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 8005972:	f008 ffab 	bl	800e8cc <USB_CoreInit>
  (void)USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE);
 8005976:	2101      	movs	r1, #1
 8005978:	6838      	ldr	r0, [r7, #0]
 800597a:	f009 f821 	bl	800e9c0 <USB_SetCurrentMode>
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
 800597e:	f856 cb10 	ldr.w	ip, [r6], #16
 8005982:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005984:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8005986:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005988:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800598a:	e894 0003 	ldmia.w	r4, {r0, r1}
 800598e:	e885 0003 	stmia.w	r5, {r0, r1}
 8005992:	4660      	mov	r0, ip
 8005994:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 8005998:	f009 f846 	bl	800ea28 <USB_HostInit>
  hhcd->State = HAL_HCD_STATE_READY;
 800599c:	2301      	movs	r3, #1
  return HAL_OK;
 800599e:	2000      	movs	r0, #0
  hhcd->State = HAL_HCD_STATE_READY;
 80059a0:	f887 32b9 	strb.w	r3, [r7, #697]	; 0x2b9
}
 80059a4:	b00a      	add	sp, #40	; 0x28
 80059a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    HAL_HCD_MspInit(hhcd);
 80059aa:	4638      	mov	r0, r7
    hhcd->Lock = HAL_UNLOCKED;
 80059ac:	f887 22b8 	strb.w	r2, [r7, #696]	; 0x2b8
    HAL_HCD_MspInit(hhcd);
 80059b0:	f018 fb7c 	bl	801e0ac <HAL_HCD_MspInit>
 80059b4:	6838      	ldr	r0, [r7, #0]
 80059b6:	e7bf      	b.n	8005938 <HAL_HCD_Init+0x34>
    return HAL_ERROR;
 80059b8:	2001      	movs	r0, #1
}
 80059ba:	4770      	bx	lr
 80059bc:	40080000 	.word	0x40080000
 80059c0:	08029264 	.word	0x08029264

080059c4 <HAL_HCD_HC_SubmitRequest>:
                                           uint8_t ep_type,
                                           uint8_t token,
                                           uint8_t *pbuff,
                                           uint16_t length,
                                           uint8_t do_ping)
{
 80059c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80059c6:	460c      	mov	r4, r1
  hhcd->hc[ch_num].ep_is_in = direction;
 80059c8:	0089      	lsls	r1, r1, #2
{
 80059ca:	f89d c014 	ldrb.w	ip, [sp, #20]
  hhcd->hc[ch_num].ep_is_in = direction;
 80059ce:	190d      	adds	r5, r1, r4
{
 80059d0:	9f06      	ldr	r7, [sp, #24]
 80059d2:	f8bd 601c 	ldrh.w	r6, [sp, #28]
  hhcd->hc[ch_num].ep_is_in = direction;
 80059d6:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
{
 80059da:	f89d e020 	ldrb.w	lr, [sp, #32]
  hhcd->hc[ch_num].ep_is_in = direction;
 80059de:	f885 203b 	strb.w	r2, [r5, #59]	; 0x3b
  hhcd->hc[ch_num].ep_type  = ep_type;
 80059e2:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f

  if (token == 0U)
 80059e6:	f1bc 0f00 	cmp.w	ip, #0
 80059ea:	d137      	bne.n	8005a5c <HAL_HCD_HC_SubmitRequest+0x98>
  {
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
    hhcd->hc[ch_num].do_ping = do_ping;
 80059ec:	f885 e03d 	strb.w	lr, [r5, #61]	; 0x3d
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
 80059f0:	f04f 0e03 	mov.w	lr, #3
 80059f4:	190d      	adds	r5, r1, r4
 80059f6:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
 80059fa:	f885 e042 	strb.w	lr, [r5, #66]	; 0x42
  {
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
  }

  /* Manage Data Toggle */
  switch (ep_type)
 80059fe:	2b03      	cmp	r3, #3
 8005a00:	d815      	bhi.n	8005a2e <HAL_HCD_HC_SubmitRequest+0x6a>
 8005a02:	e8df f003 	tbb	[pc, r3]
 8005a06:	3902      	.short	0x3902
 8005a08:	2e2e      	.short	0x2e2e
  {
    case EP_TYPE_CTRL:
      if ((token == 1U) && (direction == 0U)) /*send data */
 8005a0a:	f1bc 0f01 	cmp.w	ip, #1
 8005a0e:	d10e      	bne.n	8005a2e <HAL_HCD_HC_SubmitRequest+0x6a>
 8005a10:	b96a      	cbnz	r2, 8005a2e <HAL_HCD_HC_SubmitRequest+0x6a>
      {
        if (length == 0U)
        {
          /* For Status OUT stage, Length==0, Status Out PID = 1 */
          hhcd->hc[ch_num].toggle_out = 1U;
 8005a12:	190b      	adds	r3, r1, r4
        if (length == 0U)
 8005a14:	2e00      	cmp	r6, #0
 8005a16:	d13e      	bne.n	8005a96 <HAL_HCD_HC_SubmitRequest+0xd2>
          hhcd->hc[ch_num].toggle_out = 1U;
 8005a18:	2201      	movs	r2, #1
 8005a1a:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 8005a1e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
        }
        else
        {
          /* Put the PID 1 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8005a22:	190b      	adds	r3, r1, r4
 8005a24:	2202      	movs	r2, #2
 8005a26:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 8005a2a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    default:
      break;
  }

  hhcd->hc[ch_num].xfer_buff = pbuff;
 8005a2e:	190b      	adds	r3, r1, r4
  hhcd->hc[ch_num].urb_state = URB_IDLE;
  hhcd->hc[ch_num].xfer_count = 0U;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].state = HC_IDLE;

  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8005a30:	2128      	movs	r1, #40	; 0x28
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 8005a32:	2200      	movs	r2, #0
  hhcd->hc[ch_num].xfer_buff = pbuff;
 8005a34:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8005a38:	fb01 0104 	mla	r1, r1, r4, r0
  hhcd->hc[ch_num].xfer_buff = pbuff;
 8005a3c:	645f      	str	r7, [r3, #68]	; 0x44
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8005a3e:	3138      	adds	r1, #56	; 0x38
  hhcd->hc[ch_num].xfer_len  = length;
 8005a40:	649e      	str	r6, [r3, #72]	; 0x48
  hhcd->hc[ch_num].ch_num = ch_num;
 8005a42:	f883 4039 	strb.w	r4, [r3, #57]	; 0x39
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 8005a46:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  hhcd->hc[ch_num].xfer_count = 0U;
 8005a4a:	64da      	str	r2, [r3, #76]	; 0x4c
  hhcd->hc[ch_num].state = HC_IDLE;
 8005a4c:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8005a50:	7c02      	ldrb	r2, [r0, #16]
 8005a52:	6800      	ldr	r0, [r0, #0]
}
 8005a54:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8005a58:	f009 b990 	b.w	800ed7c <USB_HC_StartXfer>
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8005a5c:	f04f 0e02 	mov.w	lr, #2
 8005a60:	e7c8      	b.n	80059f4 <HAL_HCD_HC_SubmitRequest+0x30>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 8005a62:	190b      	adds	r3, r1, r4
 8005a64:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
      if (direction == 0U)
 8005a68:	b96a      	cbnz	r2, 8005a86 <HAL_HCD_HC_SubmitRequest+0xc2>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 8005a6a:	f893 5051 	ldrb.w	r5, [r3, #81]	; 0x51
 8005a6e:	b13d      	cbz	r5, 8005a80 <HAL_HCD_HC_SubmitRequest+0xbc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8005a70:	2202      	movs	r2, #2
 8005a72:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8005a76:	e7da      	b.n	8005a2e <HAL_HCD_HC_SubmitRequest+0x6a>
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8005a78:	190b      	adds	r3, r1, r4
 8005a7a:	2200      	movs	r2, #0
 8005a7c:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 8005a80:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      break;
 8005a84:	e7d3      	b.n	8005a2e <HAL_HCD_HC_SubmitRequest+0x6a>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 8005a86:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
 8005a8a:	2a00      	cmp	r2, #0
 8005a8c:	d0f8      	beq.n	8005a80 <HAL_HCD_HC_SubmitRequest+0xbc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8005a8e:	2202      	movs	r2, #2
 8005a90:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8005a94:	e7cb      	b.n	8005a2e <HAL_HCD_HC_SubmitRequest+0x6a>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 8005a96:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 8005a9a:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
 8005a9e:	2a00      	cmp	r2, #0
 8005aa0:	d0ee      	beq.n	8005a80 <HAL_HCD_HC_SubmitRequest+0xbc>
 8005aa2:	e7be      	b.n	8005a22 <HAL_HCD_HC_SubmitRequest+0x5e>

08005aa4 <HAL_HCD_IRQHandler>:




void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 8005aa4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8005aa8:	6805      	ldr	r5, [r0, #0]
{
 8005aaa:	b085      	sub	sp, #20
 8005aac:	4604      	mov	r4, r0
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t i, interrupt;


  /* Ensure that we are in device mode */
  if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
 8005aae:	4628      	mov	r0, r5
 8005ab0:	f008 ffb6 	bl	800ea20 <USB_GetMode>
 8005ab4:	2801      	cmp	r0, #1
 8005ab6:	d002      	beq.n	8005abe <HAL_HCD_IRQHandler+0x1a>
      HCD_RXQLVL_IRQHandler(hhcd);

      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
    }
  }
}
 8005ab8:	b005      	add	sp, #20
 8005aba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (__HAL_HCD_IS_INVALID_INTERRUPT(hhcd))
 8005abe:	6820      	ldr	r0, [r4, #0]
 8005ac0:	f008 ffaa 	bl	800ea18 <USB_ReadInterrupts>
 8005ac4:	2800      	cmp	r0, #0
 8005ac6:	d0f7      	beq.n	8005ab8 <HAL_HCD_IRQHandler+0x14>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8005ac8:	6820      	ldr	r0, [r4, #0]
 8005aca:	f008 ffa5 	bl	800ea18 <USB_ReadInterrupts>
 8005ace:	0286      	lsls	r6, r0, #10
 8005ad0:	d503      	bpl.n	8005ada <HAL_HCD_IRQHandler+0x36>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8005ad2:	6823      	ldr	r3, [r4, #0]
 8005ad4:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8005ad8:	615a      	str	r2, [r3, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
 8005ada:	6820      	ldr	r0, [r4, #0]
 8005adc:	f008 ff9c 	bl	800ea18 <USB_ReadInterrupts>
 8005ae0:	02c0      	lsls	r0, r0, #11
 8005ae2:	d503      	bpl.n	8005aec <HAL_HCD_IRQHandler+0x48>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
 8005ae4:	6823      	ldr	r3, [r4, #0]
 8005ae6:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8005aea:	615a      	str	r2, [r3, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
 8005aec:	6820      	ldr	r0, [r4, #0]
 8005aee:	f008 ff93 	bl	800ea18 <USB_ReadInterrupts>
 8005af2:	0141      	lsls	r1, r0, #5
 8005af4:	d503      	bpl.n	8005afe <HAL_HCD_IRQHandler+0x5a>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
 8005af6:	6823      	ldr	r3, [r4, #0]
 8005af8:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8005afc:	615a      	str	r2, [r3, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
 8005afe:	6820      	ldr	r0, [r4, #0]
 8005b00:	f008 ff8a 	bl	800ea18 <USB_ReadInterrupts>
 8005b04:	0782      	lsls	r2, r0, #30
 8005b06:	d502      	bpl.n	8005b0e <HAL_HCD_IRQHandler+0x6a>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
 8005b08:	6823      	ldr	r3, [r4, #0]
 8005b0a:	2202      	movs	r2, #2
 8005b0c:	615a      	str	r2, [r3, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
 8005b0e:	6820      	ldr	r0, [r4, #0]
 8005b10:	f008 ff82 	bl	800ea18 <USB_ReadInterrupts>
 8005b14:	0083      	lsls	r3, r0, #2
 8005b16:	d452      	bmi.n	8005bbe <HAL_HCD_IRQHandler+0x11a>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
 8005b18:	6820      	ldr	r0, [r4, #0]
 8005b1a:	f008 ff7d 	bl	800ea18 <USB_ReadInterrupts>
 8005b1e:	01c6      	lsls	r6, r0, #7
 8005b20:	f100 80d9 	bmi.w	8005cd6 <HAL_HCD_IRQHandler+0x232>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
 8005b24:	6820      	ldr	r0, [r4, #0]
 8005b26:	f008 ff77 	bl	800ea18 <USB_ReadInterrupts>
 8005b2a:	0700      	lsls	r0, r0, #28
 8005b2c:	f100 80cc 	bmi.w	8005cc8 <HAL_HCD_IRQHandler+0x224>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
 8005b30:	6820      	ldr	r0, [r4, #0]
 8005b32:	f008 ff71 	bl	800ea18 <USB_ReadInterrupts>
 8005b36:	0181      	lsls	r1, r0, #6
 8005b38:	d451      	bmi.n	8005bde <HAL_HCD_IRQHandler+0x13a>
    if ((__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL)) != 0U)
 8005b3a:	6820      	ldr	r0, [r4, #0]
 8005b3c:	f008 ff6c 	bl	800ea18 <USB_ReadInterrupts>
 8005b40:	06c3      	lsls	r3, r0, #27
 8005b42:	d5b9      	bpl.n	8005ab8 <HAL_HCD_IRQHandler+0x14>
      USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8005b44:	6822      	ldr	r2, [r4, #0]
 8005b46:	6993      	ldr	r3, [r2, #24]
 8005b48:	f023 0310 	bic.w	r3, r3, #16
 8005b4c:	6193      	str	r3, [r2, #24]
  * @param  hhcd HCD handle
  * @retval none
  */
static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd)
{
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8005b4e:	6825      	ldr	r5, [r4, #0]
  uint32_t pktcnt;
  uint32_t temp;
  uint32_t tmpreg;
  uint32_t ch_num;

  temp = hhcd->Instance->GRXSTSP;
 8005b50:	6a2e      	ldr	r6, [r5, #32]
  ch_num = temp & USB_OTG_GRXSTSP_EPNUM;
  pktsts = (temp & USB_OTG_GRXSTSP_PKTSTS) >> 17;
 8005b52:	f3c6 4243 	ubfx	r2, r6, #17, #4
  pktcnt = (temp & USB_OTG_GRXSTSP_BCNT) >> 4;

  switch (pktsts)
 8005b56:	2a02      	cmp	r2, #2
 8005b58:	d12c      	bne.n	8005bb4 <HAL_HCD_IRQHandler+0x110>
  pktcnt = (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8005b5a:	f3c6 180a 	ubfx	r8, r6, #4, #11
  {
    case GRXSTS_PKTSTS_IN:
      /* Read the data into the host buffer. */
      if ((pktcnt > 0U) && (hhcd->hc[ch_num].xfer_buff != (void *)0))
 8005b5e:	f1b8 0f00 	cmp.w	r8, #0
 8005b62:	d027      	beq.n	8005bb4 <HAL_HCD_IRQHandler+0x110>
  ch_num = temp & USB_OTG_GRXSTSP_EPNUM;
 8005b64:	f006 060f 	and.w	r6, r6, #15
      if ((pktcnt > 0U) && (hhcd->hc[ch_num].xfer_buff != (void *)0))
 8005b68:	eb06 0786 	add.w	r7, r6, r6, lsl #2
 8005b6c:	eb04 07c7 	add.w	r7, r4, r7, lsl #3
 8005b70:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8005b72:	b1f9      	cbz	r1, 8005bb4 <HAL_HCD_IRQHandler+0x110>
      {
        (void)USB_ReadPacket(hhcd->Instance, hhcd->hc[ch_num].xfer_buff, (uint16_t)pktcnt);
 8005b74:	4642      	mov	r2, r8
 8005b76:	4628      	mov	r0, r5
 8005b78:	f008 ff3a 	bl	800e9f0 <USB_ReadPacket>

        /*manage multiple Xfer */
        hhcd->hc[ch_num].xfer_buff += pktcnt;
        hhcd->hc[ch_num].xfer_count  += pktcnt;

        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 8005b7c:	f505 65a0 	add.w	r5, r5, #1280	; 0x500
        hhcd->hc[ch_num].xfer_buff += pktcnt;
 8005b80:	6c7a      	ldr	r2, [r7, #68]	; 0x44
        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 8005b82:	0173      	lsls	r3, r6, #5
        hhcd->hc[ch_num].xfer_count  += pktcnt;
 8005b84:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
        hhcd->hc[ch_num].xfer_buff += pktcnt;
 8005b86:	eb02 0008 	add.w	r0, r2, r8
        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 8005b8a:	18ee      	adds	r6, r5, r3
        hhcd->hc[ch_num].xfer_count  += pktcnt;
 8005b8c:	4441      	add	r1, r8
        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 8005b8e:	4ab1      	ldr	r2, [pc, #708]	; (8005e54 <HAL_HCD_IRQHandler+0x3b0>)
        hhcd->hc[ch_num].xfer_buff += pktcnt;
 8005b90:	6478      	str	r0, [r7, #68]	; 0x44
        hhcd->hc[ch_num].xfer_count  += pktcnt;
 8005b92:	64f9      	str	r1, [r7, #76]	; 0x4c
        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 8005b94:	6931      	ldr	r1, [r6, #16]
 8005b96:	400a      	ands	r2, r1
 8005b98:	b15a      	cbz	r2, 8005bb2 <HAL_HCD_IRQHandler+0x10e>
        {
          /* re-activate the channel when more packets are expected */
          tmpreg = USBx_HC(ch_num)->HCCHAR;
 8005b9a:	58ea      	ldr	r2, [r5, r3]
          tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8005b9c:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
          tmpreg |= USB_OTG_HCCHAR_CHENA;
 8005ba0:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
          USBx_HC(ch_num)->HCCHAR = tmpreg;
 8005ba4:	50ea      	str	r2, [r5, r3]
          hhcd->hc[ch_num].toggle_in ^= 1U;
 8005ba6:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 8005baa:	f083 0301 	eor.w	r3, r3, #1
 8005bae:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
 8005bb2:	6825      	ldr	r5, [r4, #0]
      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8005bb4:	69ab      	ldr	r3, [r5, #24]
 8005bb6:	f043 0310 	orr.w	r3, r3, #16
 8005bba:	61ab      	str	r3, [r5, #24]
 8005bbc:	e77c      	b.n	8005ab8 <HAL_HCD_IRQHandler+0x14>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
 8005bbe:	6823      	ldr	r3, [r4, #0]
 8005bc0:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 8005bc4:	615a      	str	r2, [r3, #20]
      if ((USBx_HPRT0 & USB_OTG_HPRT_PCSTS) == 0U)
 8005bc6:	f8d5 3440 	ldr.w	r3, [r5, #1088]	; 0x440
 8005bca:	07df      	lsls	r7, r3, #31
 8005bcc:	d4a4      	bmi.n	8005b18 <HAL_HCD_IRQHandler+0x74>
        HAL_HCD_Disconnect_Callback(hhcd);
 8005bce:	4620      	mov	r0, r4
 8005bd0:	f018 fab8 	bl	801e144 <HAL_HCD_Disconnect_Callback>
        (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 8005bd4:	2101      	movs	r1, #1
 8005bd6:	6820      	ldr	r0, [r4, #0]
 8005bd8:	f008 ffb6 	bl	800eb48 <USB_InitFSLSPClkSel>
 8005bdc:	e79c      	b.n	8005b18 <HAL_HCD_IRQHandler+0x74>
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 8005bde:	6820      	ldr	r0, [r4, #0]
 8005be0:	f009 f986 	bl	800eef0 <USB_HC_ReadInterrupt>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8005be4:	68a1      	ldr	r1, [r4, #8]
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 8005be6:	4681      	mov	r9, r0
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8005be8:	2900      	cmp	r1, #0
 8005bea:	f000 80ae 	beq.w	8005d4a <HAL_HCD_IRQHandler+0x2a6>
 8005bee:	f505 65a0 	add.w	r5, r5, #1280	; 0x500
 8005bf2:	6820      	ldr	r0, [r4, #0]
 8005bf4:	2600      	movs	r6, #0
 8005bf6:	e03d      	b.n	8005c74 <HAL_HCD_IRQHandler+0x1d0>
  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
 8005bf8:	075b      	lsls	r3, r3, #29
 8005bfa:	f140 80ab 	bpl.w	8005d54 <HAL_HCD_IRQHandler+0x2b0>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 8005bfe:	2304      	movs	r3, #4
 8005c00:	60bb      	str	r3, [r7, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005c02:	68fb      	ldr	r3, [r7, #12]
 8005c04:	f043 0302 	orr.w	r3, r3, #2
 8005c08:	60fb      	str	r3, [r7, #12]
  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_FRMOR) == USB_OTG_HCINT_FRMOR)
 8005c0a:	68bb      	ldr	r3, [r7, #8]
 8005c0c:	059b      	lsls	r3, r3, #22
 8005c0e:	f100 80dd 	bmi.w	8005dcc <HAL_HCD_IRQHandler+0x328>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_XFRC) == USB_OTG_HCINT_XFRC)
 8005c12:	68bb      	ldr	r3, [r7, #8]
 8005c14:	07d8      	lsls	r0, r3, #31
 8005c16:	f140 80ac 	bpl.w	8005d72 <HAL_HCD_IRQHandler+0x2ce>
    if (hhcd->Init.dma_enable != 0U)
 8005c1a:	6923      	ldr	r3, [r4, #16]
 8005c1c:	2b00      	cmp	r3, #0
 8005c1e:	f040 8137 	bne.w	8005e90 <HAL_HCD_IRQHandler+0x3ec>
 8005c22:	ea4f 0388 	mov.w	r3, r8, lsl #2
    hhcd->hc[ch_num].state = HC_XFRC;
 8005c26:	eb03 0c08 	add.w	ip, r3, r8
    hhcd->hc[ch_num].ErrCnt = 0U;
 8005c2a:	2200      	movs	r2, #0
    hhcd->hc[ch_num].state = HC_XFRC;
 8005c2c:	f04f 0e01 	mov.w	lr, #1
 8005c30:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
    hhcd->hc[ch_num].ErrCnt = 0U;
 8005c34:	f8cc 2058 	str.w	r2, [ip, #88]	; 0x58
    hhcd->hc[ch_num].state = HC_XFRC;
 8005c38:	f88c e05d 	strb.w	lr, [ip, #93]	; 0x5d
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 8005c3c:	f8c7 e008 	str.w	lr, [r7, #8]
    if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8005c40:	f89c 203f 	ldrb.w	r2, [ip, #63]	; 0x3f
 8005c44:	f012 0ffd 	tst.w	r2, #253	; 0xfd
 8005c48:	f000 815d 	beq.w	8005f06 <HAL_HCD_IRQHandler+0x462>
    else if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
 8005c4c:	2a03      	cmp	r2, #3
 8005c4e:	f000 81cc 	beq.w	8005fea <HAL_HCD_IRQHandler+0x546>
    else if (hhcd->hc[ch_num].ep_type == EP_TYPE_ISOC)
 8005c52:	2a01      	cmp	r2, #1
 8005c54:	f000 81d9 	beq.w	800600a <HAL_HCD_IRQHandler+0x566>
    hhcd->hc[ch_num].toggle_in ^= 1U;
 8005c58:	4443      	add	r3, r8
 8005c5a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8005c5e:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
 8005c62:	f082 0201 	eor.w	r2, r2, #1
 8005c66:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
 8005c6a:	68a1      	ldr	r1, [r4, #8]
 8005c6c:	6820      	ldr	r0, [r4, #0]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8005c6e:	3601      	adds	r6, #1
 8005c70:	428e      	cmp	r6, r1
 8005c72:	d26b      	bcs.n	8005d4c <HAL_HCD_IRQHandler+0x2a8>
        if ((interrupt & (1UL << (i & 0xFU))) != 0U)
 8005c74:	f006 030f 	and.w	r3, r6, #15
 8005c78:	fa29 f303 	lsr.w	r3, r9, r3
 8005c7c:	07da      	lsls	r2, r3, #31
 8005c7e:	d5f6      	bpl.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
 8005c80:	fa5f f886 	uxtb.w	r8, r6
 8005c84:	f500 6aa0 	add.w	sl, r0, #1280	; 0x500
 8005c88:	0173      	lsls	r3, r6, #5
 8005c8a:	ea4f 1b48 	mov.w	fp, r8, lsl #5
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 8005c8e:	58eb      	ldr	r3, [r5, r3]
 8005c90:	eb0b 070a 	add.w	r7, fp, sl
 8005c94:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
 8005c98:	68bb      	ldr	r3, [r7, #8]
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 8005c9a:	d1ad      	bne.n	8005bf8 <HAL_HCD_IRQHandler+0x154>
  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
 8005c9c:	f013 0304 	ands.w	r3, r3, #4
 8005ca0:	d15e      	bne.n	8005d60 <HAL_HCD_IRQHandler+0x2bc>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_ACK) == USB_OTG_HCINT_ACK)
 8005ca2:	68ba      	ldr	r2, [r7, #8]
 8005ca4:	f012 0220 	ands.w	r2, r2, #32
 8005ca8:	f000 809e 	beq.w	8005de8 <HAL_HCD_IRQHandler+0x344>
    if (hhcd->hc[ch_num].do_ping == 1U)
 8005cac:	eb08 0288 	add.w	r2, r8, r8, lsl #2
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 8005cb0:	2120      	movs	r1, #32
    if (hhcd->hc[ch_num].do_ping == 1U)
 8005cb2:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 8005cb6:	60b9      	str	r1, [r7, #8]
    if (hhcd->hc[ch_num].do_ping == 1U)
 8005cb8:	f892 103d 	ldrb.w	r1, [r2, #61]	; 0x3d
 8005cbc:	2901      	cmp	r1, #1
 8005cbe:	f000 816c 	beq.w	8005f9a <HAL_HCD_IRQHandler+0x4f6>
 8005cc2:	68a1      	ldr	r1, [r4, #8]
 8005cc4:	6820      	ldr	r0, [r4, #0]
 8005cc6:	e7d2      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
      HAL_HCD_SOF_Callback(hhcd);
 8005cc8:	4620      	mov	r0, r4
 8005cca:	f018 fa33 	bl	801e134 <HAL_HCD_SOF_Callback>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
 8005cce:	6823      	ldr	r3, [r4, #0]
 8005cd0:	2208      	movs	r2, #8
 8005cd2:	615a      	str	r2, [r3, #20]
 8005cd4:	e72c      	b.n	8005b30 <HAL_HCD_IRQHandler+0x8c>
  * @retval None
  */
static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd)
{
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005cd6:	6826      	ldr	r6, [r4, #0]
  __IO uint32_t hprt0, hprt0_dup;

  /* Handle Host Port Interrupts */
  hprt0 = USBx_HPRT0;
 8005cd8:	f8d6 3440 	ldr.w	r3, [r6, #1088]	; 0x440
 8005cdc:	9302      	str	r3, [sp, #8]
  hprt0_dup = USBx_HPRT0;
 8005cde:	f8d6 3440 	ldr.w	r3, [r6, #1088]	; 0x440
 8005ce2:	9303      	str	r3, [sp, #12]

  hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
 8005ce4:	9b03      	ldr	r3, [sp, #12]
 8005ce6:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 8005cea:	9303      	str	r3, [sp, #12]
                 USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  /* Check whether Port Connect detected */
  if ((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
 8005cec:	9b02      	ldr	r3, [sp, #8]
 8005cee:	0798      	lsls	r0, r3, #30
 8005cf0:	d507      	bpl.n	8005d02 <HAL_HCD_IRQHandler+0x25e>
  {
    if ((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
 8005cf2:	9b02      	ldr	r3, [sp, #8]
 8005cf4:	07d9      	lsls	r1, r3, #31
 8005cf6:	f100 80fe 	bmi.w	8005ef6 <HAL_HCD_IRQHandler+0x452>
      hhcd->ConnectCallback(hhcd);
#else
      HAL_HCD_Connect_Callback(hhcd);
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
    hprt0_dup  |= USB_OTG_HPRT_PCDET;
 8005cfa:	9b03      	ldr	r3, [sp, #12]
 8005cfc:	f043 0302 	orr.w	r3, r3, #2
 8005d00:	9303      	str	r3, [sp, #12]
  }

  /* Check whether Port Enable Changed */
  if ((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
 8005d02:	9b02      	ldr	r3, [sp, #8]
 8005d04:	071a      	lsls	r2, r3, #28
 8005d06:	d515      	bpl.n	8005d34 <HAL_HCD_IRQHandler+0x290>
  {
    hprt0_dup |= USB_OTG_HPRT_PENCHNG;
 8005d08:	9b03      	ldr	r3, [sp, #12]
 8005d0a:	f043 0308 	orr.w	r3, r3, #8
 8005d0e:	9303      	str	r3, [sp, #12]

    if ((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
 8005d10:	9b02      	ldr	r3, [sp, #8]
 8005d12:	075b      	lsls	r3, r3, #29
 8005d14:	f140 80f3 	bpl.w	8005efe <HAL_HCD_IRQHandler+0x45a>
    {
      if (hhcd->Init.phy_itface  == USB_OTG_EMBEDDED_PHY)
 8005d18:	69a1      	ldr	r1, [r4, #24]
 8005d1a:	2902      	cmp	r1, #2
 8005d1c:	f000 8103 	beq.w	8005f26 <HAL_HCD_IRQHandler+0x482>
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
        }
      }
      else
      {
        if (hhcd->Init.speed == HCD_SPEED_FULL)
 8005d20:	68e3      	ldr	r3, [r4, #12]
 8005d22:	2b01      	cmp	r3, #1
 8005d24:	d103      	bne.n	8005d2e <HAL_HCD_IRQHandler+0x28a>
        {
          USBx_HOST->HFIR = 60000U;
 8005d26:	f64e 2260 	movw	r2, #60000	; 0xea60
 8005d2a:	f8c6 2404 	str.w	r2, [r6, #1028]	; 0x404
        }
      }
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortEnabledCallback(hhcd);
#else
      HAL_HCD_PortEnabled_Callback(hhcd);
 8005d2e:	4620      	mov	r0, r4
 8005d30:	f018 fa0e 	bl	801e150 <HAL_HCD_PortEnabled_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
  }

  /* Check for an overcurrent */
  if ((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
 8005d34:	9b02      	ldr	r3, [sp, #8]
 8005d36:	069f      	lsls	r7, r3, #26
 8005d38:	d503      	bpl.n	8005d42 <HAL_HCD_IRQHandler+0x29e>
  {
    hprt0_dup |= USB_OTG_HPRT_POCCHNG;
 8005d3a:	9b03      	ldr	r3, [sp, #12]
 8005d3c:	f043 0320 	orr.w	r3, r3, #32
 8005d40:	9303      	str	r3, [sp, #12]
  }

  /* Clear Port Interrupts */
  USBx_HPRT0 = hprt0_dup;
 8005d42:	9b03      	ldr	r3, [sp, #12]
 8005d44:	f8c6 3440 	str.w	r3, [r6, #1088]	; 0x440
 8005d48:	e6ec      	b.n	8005b24 <HAL_HCD_IRQHandler+0x80>
 8005d4a:	6820      	ldr	r0, [r4, #0]
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
 8005d4c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8005d50:	6143      	str	r3, [r0, #20]
 8005d52:	e6f2      	b.n	8005b3a <HAL_HCD_IRQHandler+0x96>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_ACK) == USB_OTG_HCINT_ACK)
 8005d54:	68bb      	ldr	r3, [r7, #8]
 8005d56:	0698      	lsls	r0, r3, #26
 8005d58:	d57e      	bpl.n	8005e58 <HAL_HCD_IRQHandler+0x3b4>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 8005d5a:	2320      	movs	r3, #32
 8005d5c:	60bb      	str	r3, [r7, #8]
 8005d5e:	e754      	b.n	8005c0a <HAL_HCD_IRQHandler+0x166>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 8005d60:	2304      	movs	r3, #4
 8005d62:	60bb      	str	r3, [r7, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005d64:	68fb      	ldr	r3, [r7, #12]
 8005d66:	f043 0302 	orr.w	r3, r3, #2
 8005d6a:	60fb      	str	r3, [r7, #12]
 8005d6c:	68a1      	ldr	r1, [r4, #8]
 8005d6e:	6820      	ldr	r0, [r4, #0]
 8005d70:	e77d      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_CHH) == USB_OTG_HCINT_CHH)
 8005d72:	68bb      	ldr	r3, [r7, #8]
 8005d74:	0799      	lsls	r1, r3, #30
 8005d76:	f140 8098 	bpl.w	8005eaa <HAL_HCD_IRQHandler+0x406>
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8005d7a:	ea4f 0388 	mov.w	r3, r8, lsl #2
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8005d7e:	68f9      	ldr	r1, [r7, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8005d80:	eb03 0208 	add.w	r2, r3, r8
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8005d84:	f021 0102 	bic.w	r1, r1, #2
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8005d88:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8005d8c:	60f9      	str	r1, [r7, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8005d8e:	f892 105d 	ldrb.w	r1, [r2, #93]	; 0x5d
 8005d92:	2901      	cmp	r1, #1
 8005d94:	f000 80c4 	beq.w	8005f20 <HAL_HCD_IRQHandler+0x47c>
    else if (hhcd->hc[ch_num].state == HC_STALL)
 8005d98:	2905      	cmp	r1, #5
 8005d9a:	f000 80c1 	beq.w	8005f20 <HAL_HCD_IRQHandler+0x47c>
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 8005d9e:	2906      	cmp	r1, #6
 8005da0:	f000 8151 	beq.w	8006046 <HAL_HCD_IRQHandler+0x5a2>
 8005da4:	2908      	cmp	r1, #8
 8005da6:	f000 814e 	beq.w	8006046 <HAL_HCD_IRQHandler+0x5a2>
    else if (hhcd->hc[ch_num].state == HC_NAK)
 8005daa:	2903      	cmp	r1, #3
 8005dac:	f000 81ae 	beq.w	800610c <HAL_HCD_IRQHandler+0x668>
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8005db0:	4443      	add	r3, r8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 8005db2:	2202      	movs	r2, #2
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8005db4:	4641      	mov	r1, r8
 8005db6:	4620      	mov	r0, r4
 8005db8:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 8005dbc:	60ba      	str	r2, [r7, #8]
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8005dbe:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
 8005dc2:	f018 f9c3 	bl	801e14c <HAL_HCD_HC_NotifyURBChange_Callback>
 8005dc6:	68a1      	ldr	r1, [r4, #8]
 8005dc8:	6820      	ldr	r0, [r4, #0]
 8005dca:	e750      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005dcc:	68fb      	ldr	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005dce:	4641      	mov	r1, r8
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005dd0:	f043 0302 	orr.w	r3, r3, #2
 8005dd4:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005dd6:	6820      	ldr	r0, [r4, #0]
 8005dd8:	f009 f890 	bl	800eefc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
 8005ddc:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005de0:	60bb      	str	r3, [r7, #8]
 8005de2:	68a1      	ldr	r1, [r4, #8]
 8005de4:	6820      	ldr	r0, [r4, #0]
 8005de6:	e742      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NYET) == USB_OTG_HCINT_NYET)
 8005de8:	68bb      	ldr	r3, [r7, #8]
 8005dea:	065b      	lsls	r3, r3, #25
 8005dec:	f100 80bc 	bmi.w	8005f68 <HAL_HCD_IRQHandler+0x4c4>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_FRMOR) == USB_OTG_HCINT_FRMOR)
 8005df0:	68bb      	ldr	r3, [r7, #8]
 8005df2:	f413 7300 	ands.w	r3, r3, #512	; 0x200
 8005df6:	d1e9      	bne.n	8005dcc <HAL_HCD_IRQHandler+0x328>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_XFRC) == USB_OTG_HCINT_XFRC)
 8005df8:	68ba      	ldr	r2, [r7, #8]
 8005dfa:	07d2      	lsls	r2, r2, #31
 8005dfc:	f100 810e 	bmi.w	800601c <HAL_HCD_IRQHandler+0x578>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_STALL) == USB_OTG_HCINT_STALL)
 8005e00:	68bb      	ldr	r3, [r7, #8]
 8005e02:	f013 0308 	ands.w	r3, r3, #8
 8005e06:	f040 8166 	bne.w	80060d6 <HAL_HCD_IRQHandler+0x632>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NAK) == USB_OTG_HCINT_NAK)
 8005e0a:	68ba      	ldr	r2, [r7, #8]
 8005e0c:	06d2      	lsls	r2, r2, #27
 8005e0e:	f140 8136 	bpl.w	800607e <HAL_HCD_IRQHandler+0x5da>
    hhcd->hc[ch_num].ErrCnt = 0U;
 8005e12:	eb08 0288 	add.w	r2, r8, r8, lsl #2
    hhcd->hc[ch_num].state = HC_NAK;
 8005e16:	2103      	movs	r1, #3
    hhcd->hc[ch_num].ErrCnt = 0U;
 8005e18:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8005e1c:	6593      	str	r3, [r2, #88]	; 0x58
    if (hhcd->hc[ch_num].do_ping == 0U)
 8005e1e:	f892 303d 	ldrb.w	r3, [r2, #61]	; 0x3d
    hhcd->hc[ch_num].state = HC_NAK;
 8005e22:	f882 105d 	strb.w	r1, [r2, #93]	; 0x5d
    if (hhcd->hc[ch_num].do_ping == 0U)
 8005e26:	b943      	cbnz	r3, 8005e3a <HAL_HCD_IRQHandler+0x396>
      if (hhcd->hc[ch_num].speed == HCD_SPEED_HIGH)
 8005e28:	2328      	movs	r3, #40	; 0x28
 8005e2a:	fb03 4308 	mla	r3, r3, r8, r4
 8005e2e:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 8005e32:	b912      	cbnz	r2, 8005e3a <HAL_HCD_IRQHandler+0x396>
        hhcd->hc[ch_num].do_ping = 1U;
 8005e34:	2201      	movs	r2, #1
 8005e36:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005e3a:	68fb      	ldr	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005e3c:	4641      	mov	r1, r8
        __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005e3e:	f043 0302 	orr.w	r3, r3, #2
 8005e42:	60fb      	str	r3, [r7, #12]
        (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005e44:	6820      	ldr	r0, [r4, #0]
 8005e46:	f009 f859 	bl	800eefc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8005e4a:	2310      	movs	r3, #16
 8005e4c:	60bb      	str	r3, [r7, #8]
 8005e4e:	68a1      	ldr	r1, [r4, #8]
 8005e50:	6820      	ldr	r0, [r4, #0]
 8005e52:	e70c      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
 8005e54:	1ff80000 	.word	0x1ff80000
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_STALL) == USB_OTG_HCINT_STALL)
 8005e58:	68bb      	ldr	r3, [r7, #8]
 8005e5a:	0719      	lsls	r1, r3, #28
 8005e5c:	d46e      	bmi.n	8005f3c <HAL_HCD_IRQHandler+0x498>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_DTERR) == USB_OTG_HCINT_DTERR)
 8005e5e:	68bb      	ldr	r3, [r7, #8]
 8005e60:	055a      	lsls	r2, r3, #21
 8005e62:	f57f aed2 	bpl.w	8005c0a <HAL_HCD_IRQHandler+0x166>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005e66:	68fb      	ldr	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005e68:	4641      	mov	r1, r8
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005e6a:	f043 0302 	orr.w	r3, r3, #2
 8005e6e:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005e70:	6820      	ldr	r0, [r4, #0]
 8005e72:	f009 f843 	bl	800eefc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8005e76:	2210      	movs	r2, #16
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8005e78:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8005e7c:	2108      	movs	r1, #8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8005e7e:	60ba      	str	r2, [r7, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8005e80:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8005e84:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8005e88:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8005e8c:	60ba      	str	r2, [r7, #8]
 8005e8e:	e6bc      	b.n	8005c0a <HAL_HCD_IRQHandler+0x166>
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].xfer_len - \
 8005e90:	ea4f 0388 	mov.w	r3, r8, lsl #2
                                    (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 8005e94:	6938      	ldr	r0, [r7, #16]
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].xfer_len - \
 8005e96:	eb03 0208 	add.w	r2, r3, r8
                                    (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 8005e9a:	f3c0 0012 	ubfx	r0, r0, #0, #19
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].xfer_len - \
 8005e9e:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8005ea2:	6c91      	ldr	r1, [r2, #72]	; 0x48
 8005ea4:	1a09      	subs	r1, r1, r0
 8005ea6:	64d1      	str	r1, [r2, #76]	; 0x4c
 8005ea8:	e6bd      	b.n	8005c26 <HAL_HCD_IRQHandler+0x182>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_TXERR) == USB_OTG_HCINT_TXERR)
 8005eaa:	68bb      	ldr	r3, [r7, #8]
 8005eac:	f013 0380 	ands.w	r3, r3, #128	; 0x80
 8005eb0:	f040 8084 	bne.w	8005fbc <HAL_HCD_IRQHandler+0x518>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NAK) == USB_OTG_HCINT_NAK)
 8005eb4:	68ba      	ldr	r2, [r7, #8]
 8005eb6:	06d2      	lsls	r2, r2, #27
 8005eb8:	f57f af03 	bpl.w	8005cc2 <HAL_HCD_IRQHandler+0x21e>
    if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
 8005ebc:	eb08 0188 	add.w	r1, r8, r8, lsl #2
 8005ec0:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 8005ec4:	f891 203f 	ldrb.w	r2, [r1, #63]	; 0x3f
 8005ec8:	2a03      	cmp	r2, #3
 8005eca:	f000 8125 	beq.w	8006118 <HAL_HCD_IRQHandler+0x674>
    else if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8005ece:	f012 02fd 	ands.w	r2, r2, #253	; 0xfd
 8005ed2:	d1ba      	bne.n	8005e4a <HAL_HCD_IRQHandler+0x3a6>
      hhcd->hc[ch_num].ErrCnt = 0U;
 8005ed4:	658a      	str	r2, [r1, #88]	; 0x58
      __HAL_HCD_MASK_NAK_HC_INT(ch_num);
 8005ed6:	68fb      	ldr	r3, [r7, #12]
 8005ed8:	f023 0310 	bic.w	r3, r3, #16
 8005edc:	60fb      	str	r3, [r7, #12]
      if (hhcd->Init.dma_enable == 0U)
 8005ede:	6923      	ldr	r3, [r4, #16]
 8005ee0:	2b00      	cmp	r3, #0
 8005ee2:	d1b2      	bne.n	8005e4a <HAL_HCD_IRQHandler+0x3a6>
        hhcd->hc[ch_num].state = HC_NAK;
 8005ee4:	2328      	movs	r3, #40	; 0x28
 8005ee6:	2203      	movs	r2, #3
        (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005ee8:	4641      	mov	r1, r8
        hhcd->hc[ch_num].state = HC_NAK;
 8005eea:	fb03 4308 	mla	r3, r3, r8, r4
 8005eee:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
        __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005ef2:	68fb      	ldr	r3, [r7, #12]
 8005ef4:	e7a3      	b.n	8005e3e <HAL_HCD_IRQHandler+0x39a>
      HAL_HCD_Connect_Callback(hhcd);
 8005ef6:	4620      	mov	r0, r4
 8005ef8:	f018 f920 	bl	801e13c <HAL_HCD_Connect_Callback>
 8005efc:	e6fd      	b.n	8005cfa <HAL_HCD_IRQHandler+0x256>
      HAL_HCD_PortDisabled_Callback(hhcd);
 8005efe:	4620      	mov	r0, r4
 8005f00:	f018 f92a 	bl	801e158 <HAL_HCD_PortDisabled_Callback>
 8005f04:	e716      	b.n	8005d34 <HAL_HCD_IRQHandler+0x290>
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005f06:	68fa      	ldr	r2, [r7, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005f08:	4641      	mov	r1, r8
 8005f0a:	9301      	str	r3, [sp, #4]
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005f0c:	f042 0202 	orr.w	r2, r2, #2
 8005f10:	60fa      	str	r2, [r7, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005f12:	6820      	ldr	r0, [r4, #0]
 8005f14:	f008 fff2 	bl	800eefc <USB_HC_Halt>
      __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8005f18:	2210      	movs	r2, #16
 8005f1a:	9b01      	ldr	r3, [sp, #4]
 8005f1c:	60ba      	str	r2, [r7, #8]
 8005f1e:	e69b      	b.n	8005c58 <HAL_HCD_IRQHandler+0x1b4>
      hhcd->hc[ch_num].urb_state  = URB_STALL;
 8005f20:	f882 105c 	strb.w	r1, [r2, #92]	; 0x5c
 8005f24:	e744      	b.n	8005db0 <HAL_HCD_IRQHandler+0x30c>
        if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
 8005f26:	9b02      	ldr	r3, [sp, #8]
 8005f28:	6820      	ldr	r0, [r4, #0]
 8005f2a:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
 8005f2e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 8005f32:	bf18      	it	ne
 8005f34:	2101      	movne	r1, #1
 8005f36:	f008 fe07 	bl	800eb48 <USB_InitFSLSPClkSel>
 8005f3a:	e6f8      	b.n	8005d2e <HAL_HCD_IRQHandler+0x28a>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005f3c:	68fa      	ldr	r2, [r7, #12]
    hhcd->hc[ch_num].state = HC_STALL;
 8005f3e:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8005f42:	2105      	movs	r1, #5
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8005f44:	2010      	movs	r0, #16
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005f46:	f042 0202 	orr.w	r2, r2, #2
    hhcd->hc[ch_num].state = HC_STALL;
 8005f4a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8005f4e:	f04f 0c08 	mov.w	ip, #8
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005f52:	60fa      	str	r2, [r7, #12]
    hhcd->hc[ch_num].state = HC_STALL;
 8005f54:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005f58:	4641      	mov	r1, r8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8005f5a:	60b8      	str	r0, [r7, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8005f5c:	f8c7 c008 	str.w	ip, [r7, #8]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005f60:	6820      	ldr	r0, [r4, #0]
 8005f62:	f008 ffcb 	bl	800eefc <USB_HC_Halt>
 8005f66:	e650      	b.n	8005c0a <HAL_HCD_IRQHandler+0x166>
    hhcd->hc[ch_num].state = HC_NYET;
 8005f68:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8005f6c:	f04f 0c04 	mov.w	ip, #4
    hhcd->hc[ch_num].do_ping = 1U;
 8005f70:	2001      	movs	r0, #1
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005f72:	4641      	mov	r1, r8
    hhcd->hc[ch_num].state = HC_NYET;
 8005f74:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    hhcd->hc[ch_num].ErrCnt = 0U;
 8005f78:	659a      	str	r2, [r3, #88]	; 0x58
    hhcd->hc[ch_num].state = HC_NYET;
 8005f7a:	f883 c05d 	strb.w	ip, [r3, #93]	; 0x5d
    hhcd->hc[ch_num].do_ping = 1U;
 8005f7e:	f883 003d 	strb.w	r0, [r3, #61]	; 0x3d
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005f82:	68fb      	ldr	r3, [r7, #12]
 8005f84:	f043 0302 	orr.w	r3, r3, #2
 8005f88:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005f8a:	6820      	ldr	r0, [r4, #0]
 8005f8c:	f008 ffb6 	bl	800eefc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 8005f90:	2340      	movs	r3, #64	; 0x40
 8005f92:	60bb      	str	r3, [r7, #8]
 8005f94:	68a1      	ldr	r1, [r4, #8]
 8005f96:	6820      	ldr	r0, [r4, #0]
 8005f98:	e669      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
      hhcd->hc[ch_num].do_ping = 0U;
 8005f9a:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8005f9e:	f04f 0302 	mov.w	r3, #2
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005fa2:	4641      	mov	r1, r8
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8005fa4:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005fa8:	68fb      	ldr	r3, [r7, #12]
 8005faa:	f043 0302 	orr.w	r3, r3, #2
 8005fae:	60fb      	str	r3, [r7, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005fb0:	6820      	ldr	r0, [r4, #0]
 8005fb2:	f008 ffa3 	bl	800eefc <USB_HC_Halt>
 8005fb6:	68a1      	ldr	r1, [r4, #8]
 8005fb8:	6820      	ldr	r0, [r4, #0]
 8005fba:	e658      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005fbc:	68fa      	ldr	r2, [r7, #12]
    hhcd->hc[ch_num].ErrCnt++;
 8005fbe:	eb08 0388 	add.w	r3, r8, r8, lsl #2
    hhcd->hc[ch_num].state = HC_XACTERR;
 8005fc2:	2006      	movs	r0, #6
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005fc4:	4641      	mov	r1, r8
    hhcd->hc[ch_num].ErrCnt++;
 8005fc6:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8005fca:	f042 0202 	orr.w	r2, r2, #2
 8005fce:	60fa      	str	r2, [r7, #12]
    hhcd->hc[ch_num].ErrCnt++;
 8005fd0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    hhcd->hc[ch_num].state = HC_XACTERR;
 8005fd2:	f883 005d 	strb.w	r0, [r3, #93]	; 0x5d
    hhcd->hc[ch_num].ErrCnt++;
 8005fd6:	3201      	adds	r2, #1
 8005fd8:	659a      	str	r2, [r3, #88]	; 0x58
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8005fda:	6820      	ldr	r0, [r4, #0]
 8005fdc:	f008 ff8e 	bl	800eefc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 8005fe0:	2380      	movs	r3, #128	; 0x80
 8005fe2:	60bb      	str	r3, [r7, #8]
 8005fe4:	68a1      	ldr	r1, [r4, #8]
 8005fe6:	6820      	ldr	r0, [r4, #0]
 8005fe8:	e641      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
      USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8005fea:	f85b 000a 	ldr.w	r0, [fp, sl]
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8005fee:	4672      	mov	r2, lr
 8005ff0:	4641      	mov	r1, r8
 8005ff2:	9301      	str	r3, [sp, #4]
      USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8005ff4:	f040 5000 	orr.w	r0, r0, #536870912	; 0x20000000
 8005ff8:	f84b 000a 	str.w	r0, [fp, sl]
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8005ffc:	4620      	mov	r0, r4
      hhcd->hc[ch_num].urb_state = URB_DONE;
 8005ffe:	f88c e05c 	strb.w	lr, [ip, #92]	; 0x5c
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006002:	f018 f8a3 	bl	801e14c <HAL_HCD_HC_NotifyURBChange_Callback>
 8006006:	9b01      	ldr	r3, [sp, #4]
 8006008:	e626      	b.n	8005c58 <HAL_HCD_IRQHandler+0x1b4>
      hhcd->hc[ch_num].urb_state = URB_DONE;
 800600a:	f88c 205c 	strb.w	r2, [ip, #92]	; 0x5c
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 800600e:	4641      	mov	r1, r8
 8006010:	4620      	mov	r0, r4
 8006012:	9301      	str	r3, [sp, #4]
 8006014:	f018 f89a 	bl	801e14c <HAL_HCD_HC_NotifyURBChange_Callback>
 8006018:	9b01      	ldr	r3, [sp, #4]
 800601a:	e61d      	b.n	8005c58 <HAL_HCD_IRQHandler+0x1b4>
    hhcd->hc[ch_num].ErrCnt = 0U;
 800601c:	eb08 0288 	add.w	r2, r8, r8, lsl #2
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006020:	4641      	mov	r1, r8
    hhcd->hc[ch_num].ErrCnt = 0U;
 8006022:	eb04 08c2 	add.w	r8, r4, r2, lsl #3
 8006026:	f8c8 3058 	str.w	r3, [r8, #88]	; 0x58
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 800602a:	68fb      	ldr	r3, [r7, #12]
 800602c:	f043 0302 	orr.w	r3, r3, #2
 8006030:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006032:	6820      	ldr	r0, [r4, #0]
 8006034:	f008 ff62 	bl	800eefc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 8006038:	2301      	movs	r3, #1
 800603a:	60bb      	str	r3, [r7, #8]
    hhcd->hc[ch_num].state = HC_XFRC;
 800603c:	f888 305d 	strb.w	r3, [r8, #93]	; 0x5d
 8006040:	68a1      	ldr	r1, [r4, #8]
 8006042:	6820      	ldr	r0, [r4, #0]
 8006044:	e613      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
      hhcd->hc[ch_num].ErrCnt++;
 8006046:	eb03 0208 	add.w	r2, r3, r8
 800604a:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 800604e:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8006050:	3201      	adds	r2, #1
      if (hhcd->hc[ch_num].ErrCnt > 3U)
 8006052:	2a03      	cmp	r2, #3
 8006054:	d853      	bhi.n	80060fe <HAL_HCD_IRQHandler+0x65a>
      hhcd->hc[ch_num].ErrCnt++;
 8006056:	2128      	movs	r1, #40	; 0x28
 8006058:	fb01 4008 	mla	r0, r1, r8, r4
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 800605c:	2102      	movs	r1, #2
      hhcd->hc[ch_num].ErrCnt++;
 800605e:	6582      	str	r2, [r0, #88]	; 0x58
 8006060:	eb03 0208 	add.w	r2, r3, r8
 8006064:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8006068:	f882 105c 	strb.w	r1, [r2, #92]	; 0x5c
      tmpreg = USBx_HC(ch_num)->HCCHAR;
 800606c:	f85b 200a 	ldr.w	r2, [fp, sl]
      tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8006070:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
      tmpreg |= USB_OTG_HCCHAR_CHENA;
 8006074:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
      USBx_HC(ch_num)->HCCHAR = tmpreg;
 8006078:	f84b 200a 	str.w	r2, [fp, sl]
 800607c:	e698      	b.n	8005db0 <HAL_HCD_IRQHandler+0x30c>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_TXERR) == USB_OTG_HCINT_TXERR)
 800607e:	68bb      	ldr	r3, [r7, #8]
 8006080:	061a      	lsls	r2, r3, #24
 8006082:	d44f      	bmi.n	8006124 <HAL_HCD_IRQHandler+0x680>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_DTERR) == USB_OTG_HCINT_DTERR)
 8006084:	68bb      	ldr	r3, [r7, #8]
 8006086:	055b      	lsls	r3, r3, #21
 8006088:	d45f      	bmi.n	800614a <HAL_HCD_IRQHandler+0x6a6>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_CHH) == USB_OTG_HCINT_CHH)
 800608a:	68bb      	ldr	r3, [r7, #8]
 800608c:	079a      	lsls	r2, r3, #30
 800608e:	f57f adee 	bpl.w	8005c6e <HAL_HCD_IRQHandler+0x1ca>
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8006092:	68fb      	ldr	r3, [r7, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8006094:	2228      	movs	r2, #40	; 0x28
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8006096:	f023 0302 	bic.w	r3, r3, #2
    if (hhcd->hc[ch_num].state == HC_XFRC)
 800609a:	fb02 4208 	mla	r2, r2, r8, r4
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 800609e:	60fb      	str	r3, [r7, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 80060a0:	f892 305d 	ldrb.w	r3, [r2, #93]	; 0x5d
 80060a4:	2b01      	cmp	r3, #1
 80060a6:	d06b      	beq.n	8006180 <HAL_HCD_IRQHandler+0x6dc>
    else if (hhcd->hc[ch_num].state == HC_NAK)
 80060a8:	2b03      	cmp	r3, #3
 80060aa:	d064      	beq.n	8006176 <HAL_HCD_IRQHandler+0x6d2>
    else if (hhcd->hc[ch_num].state == HC_NYET)
 80060ac:	2b04      	cmp	r3, #4
 80060ae:	d062      	beq.n	8006176 <HAL_HCD_IRQHandler+0x6d2>
    else if (hhcd->hc[ch_num].state == HC_STALL)
 80060b0:	2b05      	cmp	r3, #5
 80060b2:	f000 808c 	beq.w	80061ce <HAL_HCD_IRQHandler+0x72a>
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 80060b6:	2b06      	cmp	r3, #6
 80060b8:	d070      	beq.n	800619c <HAL_HCD_IRQHandler+0x6f8>
 80060ba:	2b08      	cmp	r3, #8
 80060bc:	d06e      	beq.n	800619c <HAL_HCD_IRQHandler+0x6f8>
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 80060be:	2328      	movs	r3, #40	; 0x28
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 80060c0:	2202      	movs	r2, #2
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 80060c2:	4641      	mov	r1, r8
 80060c4:	4620      	mov	r0, r4
 80060c6:	fb03 4308 	mla	r3, r3, r8, r4
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 80060ca:	60ba      	str	r2, [r7, #8]
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 80060cc:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
 80060d0:	f018 f83c 	bl	801e14c <HAL_HCD_HC_NotifyURBChange_Callback>
 80060d4:	e5f5      	b.n	8005cc2 <HAL_HCD_IRQHandler+0x21e>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 80060d6:	2308      	movs	r3, #8
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80060d8:	4641      	mov	r1, r8
    hhcd->hc[ch_num].state = HC_STALL;
 80060da:	eb08 0888 	add.w	r8, r8, r8, lsl #2
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 80060de:	60bb      	str	r3, [r7, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 80060e0:	68fb      	ldr	r3, [r7, #12]
 80060e2:	f043 0302 	orr.w	r3, r3, #2
 80060e6:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80060e8:	6820      	ldr	r0, [r4, #0]
 80060ea:	f008 ff07 	bl	800eefc <USB_HC_Halt>
    hhcd->hc[ch_num].state = HC_STALL;
 80060ee:	2205      	movs	r2, #5
 80060f0:	eb04 03c8 	add.w	r3, r4, r8, lsl #3
 80060f4:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
 80060f8:	68a1      	ldr	r1, [r4, #8]
 80060fa:	6820      	ldr	r0, [r4, #0]
 80060fc:	e5b7      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
        hhcd->hc[ch_num].ErrCnt = 0U;
 80060fe:	2228      	movs	r2, #40	; 0x28
 8006100:	2000      	movs	r0, #0
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 8006102:	2104      	movs	r1, #4
        hhcd->hc[ch_num].ErrCnt = 0U;
 8006104:	fb02 4208 	mla	r2, r2, r8, r4
 8006108:	6590      	str	r0, [r2, #88]	; 0x58
 800610a:	e7a9      	b.n	8006060 <HAL_HCD_IRQHandler+0x5bc>
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 800610c:	2228      	movs	r2, #40	; 0x28
 800610e:	f04f 0102 	mov.w	r1, #2
 8006112:	fb02 4208 	mla	r2, r2, r8, r4
 8006116:	e7a7      	b.n	8006068 <HAL_HCD_IRQHandler+0x5c4>
      hhcd->hc[ch_num].ErrCnt = 0U;
 8006118:	2228      	movs	r2, #40	; 0x28
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800611a:	4641      	mov	r1, r8
      hhcd->hc[ch_num].ErrCnt = 0U;
 800611c:	fb02 4208 	mla	r2, r2, r8, r4
 8006120:	6593      	str	r3, [r2, #88]	; 0x58
 8006122:	e6e6      	b.n	8005ef2 <HAL_HCD_IRQHandler+0x44e>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006124:	68fb      	ldr	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006126:	4641      	mov	r1, r8
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006128:	f043 0302 	orr.w	r3, r3, #2
 800612c:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800612e:	6820      	ldr	r0, [r4, #0]
 8006130:	f008 fee4 	bl	800eefc <USB_HC_Halt>
    hhcd->hc[ch_num].state = HC_XACTERR;
 8006134:	2328      	movs	r3, #40	; 0x28
 8006136:	2206      	movs	r2, #6
 8006138:	fb03 4808 	mla	r8, r3, r8, r4
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 800613c:	2380      	movs	r3, #128	; 0x80
    hhcd->hc[ch_num].state = HC_XACTERR;
 800613e:	f888 205d 	strb.w	r2, [r8, #93]	; 0x5d
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 8006142:	60bb      	str	r3, [r7, #8]
 8006144:	68a1      	ldr	r1, [r4, #8]
 8006146:	6820      	ldr	r0, [r4, #0]
 8006148:	e591      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 800614a:	68fb      	ldr	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800614c:	4641      	mov	r1, r8
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 800614e:	f043 0302 	orr.w	r3, r3, #2
 8006152:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006154:	6820      	ldr	r0, [r4, #0]
 8006156:	f008 fed1 	bl	800eefc <USB_HC_Halt>
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 800615a:	2328      	movs	r3, #40	; 0x28
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 800615c:	2110      	movs	r1, #16
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 800615e:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8006162:	fb03 4808 	mla	r8, r3, r8, r4
 8006166:	2308      	movs	r3, #8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8006168:	60b9      	str	r1, [r7, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 800616a:	60ba      	str	r2, [r7, #8]
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 800616c:	f888 305d 	strb.w	r3, [r8, #93]	; 0x5d
 8006170:	68a1      	ldr	r1, [r4, #8]
 8006172:	6820      	ldr	r0, [r4, #0]
 8006174:	e57b      	b.n	8005c6e <HAL_HCD_IRQHandler+0x1ca>
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8006176:	f04f 0302 	mov.w	r3, #2
 800617a:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
 800617e:	e79e      	b.n	80060be <HAL_HCD_IRQHandler+0x61a>
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_BULK) ||
 8006180:	f892 103f 	ldrb.w	r1, [r2, #63]	; 0x3f
      hhcd->hc[ch_num].urb_state  = URB_DONE;
 8006184:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_BULK) ||
 8006188:	1e8b      	subs	r3, r1, #2
 800618a:	2b01      	cmp	r3, #1
 800618c:	d897      	bhi.n	80060be <HAL_HCD_IRQHandler+0x61a>
        hhcd->hc[ch_num].toggle_out ^= 1U;
 800618e:	f892 3051 	ldrb.w	r3, [r2, #81]	; 0x51
 8006192:	f083 0301 	eor.w	r3, r3, #1
 8006196:	f882 3051 	strb.w	r3, [r2, #81]	; 0x51
 800619a:	e790      	b.n	80060be <HAL_HCD_IRQHandler+0x61a>
      hhcd->hc[ch_num].ErrCnt++;
 800619c:	2328      	movs	r3, #40	; 0x28
 800619e:	fb03 4208 	mla	r2, r3, r8, r4
 80061a2:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80061a4:	3301      	adds	r3, #1
      if (hhcd->hc[ch_num].ErrCnt > 3U)
 80061a6:	2b03      	cmp	r3, #3
      hhcd->hc[ch_num].ErrCnt++;
 80061a8:	6593      	str	r3, [r2, #88]	; 0x58
      if (hhcd->hc[ch_num].ErrCnt > 3U)
 80061aa:	d913      	bls.n	80061d4 <HAL_HCD_IRQHandler+0x730>
        hhcd->hc[ch_num].ErrCnt = 0U;
 80061ac:	2100      	movs	r1, #0
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 80061ae:	2304      	movs	r3, #4
        hhcd->hc[ch_num].ErrCnt = 0U;
 80061b0:	6591      	str	r1, [r2, #88]	; 0x58
 80061b2:	2228      	movs	r2, #40	; 0x28
 80061b4:	fb02 4208 	mla	r2, r2, r8, r4
 80061b8:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
      tmpreg = USBx_HC(ch_num)->HCCHAR;
 80061bc:	f85b 300a 	ldr.w	r3, [fp, sl]
      tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 80061c0:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
      tmpreg |= USB_OTG_HCCHAR_CHENA;
 80061c4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
      USBx_HC(ch_num)->HCCHAR = tmpreg;
 80061c8:	f84b 300a 	str.w	r3, [fp, sl]
 80061cc:	e777      	b.n	80060be <HAL_HCD_IRQHandler+0x61a>
      hhcd->hc[ch_num].urb_state  = URB_STALL;
 80061ce:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
 80061d2:	e774      	b.n	80060be <HAL_HCD_IRQHandler+0x61a>
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 80061d4:	2302      	movs	r3, #2
 80061d6:	e7ec      	b.n	80061b2 <HAL_HCD_IRQHandler+0x70e>

080061d8 <HAL_HCD_Start>:
{
 80061d8:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(hhcd);
 80061da:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
 80061de:	2b01      	cmp	r3, #1
 80061e0:	d00e      	beq.n	8006200 <HAL_HCD_Start+0x28>
 80061e2:	4604      	mov	r4, r0
 80061e4:	2501      	movs	r5, #1
  __HAL_HCD_ENABLE(hhcd);
 80061e6:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 80061e8:	f884 52b8 	strb.w	r5, [r4, #696]	; 0x2b8
  __HAL_HCD_ENABLE(hhcd);
 80061ec:	f008 fbd8 	bl	800e9a0 <USB_EnableGlobalInt>
  (void)USB_DriveVbus(hhcd->Instance, 1U);
 80061f0:	4629      	mov	r1, r5
 80061f2:	6820      	ldr	r0, [r4, #0]
 80061f4:	f008 fcf0 	bl	800ebd8 <USB_DriveVbus>
  __HAL_UNLOCK(hhcd);
 80061f8:	2000      	movs	r0, #0
 80061fa:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8
}
 80061fe:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hhcd);
 8006200:	2002      	movs	r0, #2
}
 8006202:	bd38      	pop	{r3, r4, r5, pc}

08006204 <HAL_HCD_Stop>:
  __HAL_LOCK(hhcd);
 8006204:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
 8006208:	2b01      	cmp	r3, #1
 800620a:	d00b      	beq.n	8006224 <HAL_HCD_Stop+0x20>
 800620c:	2301      	movs	r3, #1
{
 800620e:	b510      	push	{r4, lr}
 8006210:	4604      	mov	r4, r0
  (void)USB_StopHost(hhcd->Instance);
 8006212:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 8006214:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
  (void)USB_StopHost(hhcd->Instance);
 8006218:	f008 fec8 	bl	800efac <USB_StopHost>
  __HAL_UNLOCK(hhcd);
 800621c:	2000      	movs	r0, #0
 800621e:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8
}
 8006222:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 8006224:	2002      	movs	r0, #2
}
 8006226:	4770      	bx	lr

08006228 <HAL_HCD_ResetPort>:
  return (USB_ResetPort(hhcd->Instance));
 8006228:	6800      	ldr	r0, [r0, #0]
 800622a:	f008 bcb5 	b.w	800eb98 <USB_ResetPort>
 800622e:	bf00      	nop

08006230 <HAL_HCD_HC_GetURBState>:
  return hhcd->hc[chnum].urb_state;
 8006230:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8006234:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
 8006238:	f891 005c 	ldrb.w	r0, [r1, #92]	; 0x5c
 800623c:	4770      	bx	lr
 800623e:	bf00      	nop

08006240 <HAL_HCD_HC_GetXferCount>:
  return hhcd->hc[chnum].xfer_count;
 8006240:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8006244:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
 8006248:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
 800624a:	4770      	bx	lr

0800624c <HAL_HCD_GetCurrentFrame>:
  return (USB_GetCurrentFrame(hhcd->Instance));
 800624c:	6800      	ldr	r0, [r0, #0]
 800624e:	f008 bcf3 	b.w	800ec38 <USB_GetCurrentFrame>
 8006252:	bf00      	nop

08006254 <HAL_HCD_GetCurrentSpeed>:
  return (USB_GetHostSpeed(hhcd->Instance));
 8006254:	6800      	ldr	r0, [r0, #0]
 8006256:	f008 bce3 	b.w	800ec20 <USB_GetHostSpeed>
 800625a:	bf00      	nop

0800625c <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800625c:	b570      	push	{r4, r5, r6, lr}
 800625e:	4604      	mov	r4, r0
 8006260:	460d      	mov	r5, r1
 8006262:	4616      	mov	r6, r2
 8006264:	1c6b      	adds	r3, r5, #1
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8006266:	6822      	ldr	r2, [r4, #0]
 8006268:	d12e      	bne.n	80062c8 <I2C_WaitOnTXISFlagUntilTimeout+0x6c>
 800626a:	6993      	ldr	r3, [r2, #24]
 800626c:	0798      	lsls	r0, r3, #30
 800626e:	d42e      	bmi.n	80062ce <I2C_WaitOnTXISFlagUntilTimeout+0x72>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8006270:	6993      	ldr	r3, [r2, #24]
 8006272:	06d9      	lsls	r1, r3, #27
 8006274:	d5f9      	bpl.n	800626a <I2C_WaitOnTXISFlagUntilTimeout+0xe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8006276:	6993      	ldr	r3, [r2, #24]
 8006278:	069d      	lsls	r5, r3, #26
 800627a:	d5fc      	bpl.n	8006276 <I2C_WaitOnTXISFlagUntilTimeout+0x1a>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800627c:	2310      	movs	r3, #16

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800627e:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8006280:	61d3      	str	r3, [r2, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006282:	6823      	ldr	r3, [r4, #0]
 8006284:	61d9      	str	r1, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8006286:	6823      	ldr	r3, [r4, #0]
 8006288:	699a      	ldr	r2, [r3, #24]
 800628a:	0791      	lsls	r1, r2, #30
 800628c:	d502      	bpl.n	8006294 <I2C_WaitOnTXISFlagUntilTimeout+0x38>
    hi2c->Instance->TXDR = 0x00U;
 800628e:	2200      	movs	r2, #0
 8006290:	629a      	str	r2, [r3, #40]	; 0x28
 8006292:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8006294:	699a      	ldr	r2, [r3, #24]
 8006296:	07d2      	lsls	r2, r2, #31
 8006298:	d404      	bmi.n	80062a4 <I2C_WaitOnTXISFlagUntilTimeout+0x48>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800629a:	699a      	ldr	r2, [r3, #24]
 800629c:	f042 0201 	orr.w	r2, r2, #1
 80062a0:	619a      	str	r2, [r3, #24]
 80062a2:	6823      	ldr	r3, [r4, #0]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80062a4:	685a      	ldr	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80062a6:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
 80062a8:	4e1b      	ldr	r6, [pc, #108]	; (8006318 <I2C_WaitOnTXISFlagUntilTimeout+0xbc>)
    hi2c->State = HAL_I2C_STATE_READY;
 80062aa:	2520      	movs	r5, #32
      return HAL_ERROR;
 80062ac:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 80062ae:	4032      	ands	r2, r6
 80062b0:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80062b2:	6c63      	ldr	r3, [r4, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80062b4:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80062b8:	f043 0304 	orr.w	r3, r3, #4
 80062bc:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80062be:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80062c2:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
 80062c6:	bd70      	pop	{r4, r5, r6, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 80062c8:	6993      	ldr	r3, [r2, #24]
 80062ca:	079b      	lsls	r3, r3, #30
 80062cc:	d501      	bpl.n	80062d2 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  return HAL_OK;
 80062ce:	2000      	movs	r0, #0
}
 80062d0:	bd70      	pop	{r4, r5, r6, pc}
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 80062d2:	6993      	ldr	r3, [r2, #24]
 80062d4:	06db      	lsls	r3, r3, #27
 80062d6:	d407      	bmi.n	80062e8 <I2C_WaitOnTXISFlagUntilTimeout+0x8c>
 80062d8:	e00a      	b.n	80062f0 <I2C_WaitOnTXISFlagUntilTimeout+0x94>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80062da:	f7fa fba5 	bl	8000a28 <HAL_GetTick>
 80062de:	1b80      	subs	r0, r0, r6
 80062e0:	4285      	cmp	r5, r0
 80062e2:	d30c      	bcc.n	80062fe <I2C_WaitOnTXISFlagUntilTimeout+0xa2>
 80062e4:	b15d      	cbz	r5, 80062fe <I2C_WaitOnTXISFlagUntilTimeout+0xa2>
 80062e6:	6822      	ldr	r2, [r4, #0]
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80062e8:	6993      	ldr	r3, [r2, #24]
 80062ea:	0698      	lsls	r0, r3, #26
 80062ec:	d5f5      	bpl.n	80062da <I2C_WaitOnTXISFlagUntilTimeout+0x7e>
 80062ee:	e7c5      	b.n	800627c <I2C_WaitOnTXISFlagUntilTimeout+0x20>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80062f0:	f7fa fb9a 	bl	8000a28 <HAL_GetTick>
 80062f4:	1b80      	subs	r0, r0, r6
 80062f6:	42a8      	cmp	r0, r5
 80062f8:	d801      	bhi.n	80062fe <I2C_WaitOnTXISFlagUntilTimeout+0xa2>
 80062fa:	2d00      	cmp	r5, #0
 80062fc:	d1b2      	bne.n	8006264 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80062fe:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8006300:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006302:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
 8006304:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006306:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 8006308:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800630c:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800630e:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006312:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 8006316:	bd70      	pop	{r4, r5, r6, pc}
 8006318:	fe00e800 	.word	0xfe00e800

0800631c <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 800631c:	b570      	push	{r4, r5, r6, lr}
 800631e:	4604      	mov	r4, r0
 8006320:	460d      	mov	r5, r1
 8006322:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8006324:	6822      	ldr	r2, [r4, #0]
 8006326:	6993      	ldr	r3, [r2, #24]
 8006328:	069b      	lsls	r3, r3, #26
 800632a:	d44d      	bmi.n	80063c8 <I2C_WaitOnSTOPFlagUntilTimeout+0xac>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800632c:	6993      	ldr	r3, [r2, #24]
 800632e:	06d9      	lsls	r1, r3, #27
 8006330:	d52a      	bpl.n	8006388 <I2C_WaitOnSTOPFlagUntilTimeout+0x6c>
 8006332:	1c6b      	adds	r3, r5, #1
 8006334:	d13c      	bne.n	80063b0 <I2C_WaitOnSTOPFlagUntilTimeout+0x94>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8006336:	6993      	ldr	r3, [r2, #24]
 8006338:	069d      	lsls	r5, r3, #26
 800633a:	d5fc      	bpl.n	8006336 <I2C_WaitOnSTOPFlagUntilTimeout+0x1a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800633c:	2310      	movs	r3, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800633e:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8006340:	61d3      	str	r3, [r2, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006342:	6823      	ldr	r3, [r4, #0]
 8006344:	61d9      	str	r1, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8006346:	6823      	ldr	r3, [r4, #0]
 8006348:	699a      	ldr	r2, [r3, #24]
 800634a:	0791      	lsls	r1, r2, #30
 800634c:	d502      	bpl.n	8006354 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
    hi2c->Instance->TXDR = 0x00U;
 800634e:	2200      	movs	r2, #0
 8006350:	629a      	str	r2, [r3, #40]	; 0x28
 8006352:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8006354:	699a      	ldr	r2, [r3, #24]
 8006356:	07d2      	lsls	r2, r2, #31
 8006358:	d404      	bmi.n	8006364 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800635a:	699a      	ldr	r2, [r3, #24]
 800635c:	f042 0201 	orr.w	r2, r2, #1
 8006360:	619a      	str	r2, [r3, #24]
 8006362:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8006364:	685a      	ldr	r2, [r3, #4]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8006366:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
 8006368:	4e18      	ldr	r6, [pc, #96]	; (80063cc <I2C_WaitOnSTOPFlagUntilTimeout+0xb0>)
    hi2c->State = HAL_I2C_STATE_READY;
 800636a:	2520      	movs	r5, #32
      return HAL_ERROR;
 800636c:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 800636e:	4032      	ands	r2, r6
 8006370:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8006372:	6c63      	ldr	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(hi2c);
 8006374:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8006378:	f043 0304 	orr.w	r3, r3, #4
 800637c:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 800637e:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8006382:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
 8006386:	bd70      	pop	{r4, r5, r6, pc}
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006388:	f7fa fb4e 	bl	8000a28 <HAL_GetTick>
 800638c:	1b80      	subs	r0, r0, r6
 800638e:	42a8      	cmp	r0, r5
 8006390:	d801      	bhi.n	8006396 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
 8006392:	2d00      	cmp	r5, #0
 8006394:	d1c6      	bne.n	8006324 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006396:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8006398:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800639a:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
 800639c:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800639e:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 80063a0:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80063a4:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80063a6:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80063aa:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 80063ae:	bd70      	pop	{r4, r5, r6, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80063b0:	6993      	ldr	r3, [r2, #24]
 80063b2:	0698      	lsls	r0, r3, #26
 80063b4:	d4c2      	bmi.n	800633c <I2C_WaitOnSTOPFlagUntilTimeout+0x20>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80063b6:	f7fa fb37 	bl	8000a28 <HAL_GetTick>
 80063ba:	1b80      	subs	r0, r0, r6
 80063bc:	4285      	cmp	r5, r0
 80063be:	d3ea      	bcc.n	8006396 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
 80063c0:	2d00      	cmp	r5, #0
 80063c2:	d0e8      	beq.n	8006396 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
 80063c4:	6822      	ldr	r2, [r4, #0]
 80063c6:	e7b4      	b.n	8006332 <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
 80063c8:	2000      	movs	r0, #0
}
 80063ca:	bd70      	pop	{r4, r5, r6, pc}
 80063cc:	fe00e800 	.word	0xfe00e800

080063d0 <HAL_I2C_Init>:
  if (hi2c == NULL)
 80063d0:	2800      	cmp	r0, #0
 80063d2:	f000 80d2 	beq.w	800657a <HAL_I2C_Init+0x1aa>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80063d6:	496f      	ldr	r1, [pc, #444]	; (8006594 <HAL_I2C_Init+0x1c4>)
{
 80063d8:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80063da:	4b6f      	ldr	r3, [pc, #444]	; (8006598 <HAL_I2C_Init+0x1c8>)
 80063dc:	4604      	mov	r4, r0
 80063de:	6802      	ldr	r2, [r0, #0]
 80063e0:	486e      	ldr	r0, [pc, #440]	; (800659c <HAL_I2C_Init+0x1cc>)
 80063e2:	429a      	cmp	r2, r3
 80063e4:	bf18      	it	ne
 80063e6:	4282      	cmpne	r2, r0
 80063e8:	bf14      	ite	ne
 80063ea:	2301      	movne	r3, #1
 80063ec:	2300      	moveq	r3, #0
 80063ee:	428a      	cmp	r2, r1
 80063f0:	bf0c      	ite	eq
 80063f2:	2300      	moveq	r3, #0
 80063f4:	f003 0301 	andne.w	r3, r3, #1
 80063f8:	b11b      	cbz	r3, 8006402 <HAL_I2C_Init+0x32>
 80063fa:	4b69      	ldr	r3, [pc, #420]	; (80065a0 <HAL_I2C_Init+0x1d0>)
 80063fc:	429a      	cmp	r2, r3
 80063fe:	f040 80be 	bne.w	800657e <HAL_I2C_Init+0x1ae>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 8006402:	68a3      	ldr	r3, [r4, #8]
 8006404:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8006408:	d271      	bcs.n	80064ee <HAL_I2C_Init+0x11e>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 800640a:	68e3      	ldr	r3, [r4, #12]
 800640c:	3b01      	subs	r3, #1
 800640e:	2b01      	cmp	r3, #1
 8006410:	d85e      	bhi.n	80064d0 <HAL_I2C_Init+0x100>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 8006412:	6923      	ldr	r3, [r4, #16]
 8006414:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
 8006418:	d17c      	bne.n	8006514 <HAL_I2C_Init+0x144>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 800641a:	6963      	ldr	r3, [r4, #20]
 800641c:	2bff      	cmp	r3, #255	; 0xff
 800641e:	d870      	bhi.n	8006502 <HAL_I2C_Init+0x132>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
 8006420:	69a3      	ldr	r3, [r4, #24]
 8006422:	2b07      	cmp	r3, #7
 8006424:	f200 809e 	bhi.w	8006564 <HAL_I2C_Init+0x194>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 8006428:	69e3      	ldr	r3, [r4, #28]
 800642a:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
 800642e:	f040 808e 	bne.w	800654e <HAL_I2C_Init+0x17e>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 8006432:	6a23      	ldr	r3, [r4, #32]
 8006434:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 8006438:	d17c      	bne.n	8006534 <HAL_I2C_Init+0x164>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 800643a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800643e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8006442:	2b00      	cmp	r3, #0
 8006444:	d070      	beq.n	8006528 <HAL_I2C_Init+0x158>
  __HAL_I2C_DISABLE(hi2c);
 8006446:	6822      	ldr	r2, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8006448:	2324      	movs	r3, #36	; 0x24
 800644a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 800644e:	6813      	ldr	r3, [r2, #0]
 8006450:	f023 0301 	bic.w	r3, r3, #1
 8006454:	6013      	str	r3, [r2, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8006456:	e9d4 2300 	ldrd	r2, r3, [r4]
 800645a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 800645e:	6113      	str	r3, [r2, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8006460:	6822      	ldr	r2, [r4, #0]
 8006462:	6893      	ldr	r3, [r2, #8]
 8006464:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8006468:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800646a:	68e3      	ldr	r3, [r4, #12]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800646c:	6822      	ldr	r2, [r4, #0]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800646e:	2b01      	cmp	r3, #1
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8006470:	68a3      	ldr	r3, [r4, #8]
 8006472:	bf0c      	ite	eq
 8006474:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8006478:	f443 4304 	orrne.w	r3, r3, #33792	; 0x8400
 800647c:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800647e:	68e3      	ldr	r3, [r4, #12]
 8006480:	6825      	ldr	r5, [r4, #0]
 8006482:	2b02      	cmp	r3, #2
 8006484:	d02e      	beq.n	80064e4 <HAL_I2C_Init+0x114>
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8006486:	6868      	ldr	r0, [r5, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8006488:	2200      	movs	r2, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800648a:	4b46      	ldr	r3, [pc, #280]	; (80065a4 <HAL_I2C_Init+0x1d4>)
  hi2c->State = HAL_I2C_STATE_READY;
 800648c:	2120      	movs	r1, #32
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800648e:	4303      	orrs	r3, r0
  return HAL_OK;
 8006490:	4610      	mov	r0, r2
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8006492:	606b      	str	r3, [r5, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8006494:	6825      	ldr	r5, [r4, #0]
 8006496:	68eb      	ldr	r3, [r5, #12]
 8006498:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800649c:	60eb      	str	r3, [r5, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800649e:	e9d4 3504 	ldrd	r3, r5, [r4, #16]
 80064a2:	432b      	orrs	r3, r5
 80064a4:	69a5      	ldr	r5, [r4, #24]
 80064a6:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 80064aa:	6825      	ldr	r5, [r4, #0]
 80064ac:	60eb      	str	r3, [r5, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 80064ae:	e9d4 3507 	ldrd	r3, r5, [r4, #28]
 80064b2:	432b      	orrs	r3, r5
 80064b4:	6825      	ldr	r5, [r4, #0]
 80064b6:	602b      	str	r3, [r5, #0]
  __HAL_I2C_ENABLE(hi2c);
 80064b8:	6825      	ldr	r5, [r4, #0]
 80064ba:	682b      	ldr	r3, [r5, #0]
 80064bc:	f043 0301 	orr.w	r3, r3, #1
 80064c0:	602b      	str	r3, [r5, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80064c2:	6462      	str	r2, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 80064c4:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 80064c8:	6322      	str	r2, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80064ca:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 80064ce:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 80064d0:	f240 11e3 	movw	r1, #483	; 0x1e3
 80064d4:	4834      	ldr	r0, [pc, #208]	; (80065a8 <HAL_I2C_Init+0x1d8>)
 80064d6:	f00d f9fb 	bl	80138d0 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 80064da:	6923      	ldr	r3, [r4, #16]
 80064dc:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
 80064e0:	d09b      	beq.n	800641a <HAL_I2C_Init+0x4a>
 80064e2:	e017      	b.n	8006514 <HAL_I2C_Init+0x144>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 80064e4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80064e8:	606b      	str	r3, [r5, #4]
 80064ea:	6825      	ldr	r5, [r4, #0]
 80064ec:	e7cb      	b.n	8006486 <HAL_I2C_Init+0xb6>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 80064ee:	f44f 71f1 	mov.w	r1, #482	; 0x1e2
 80064f2:	482d      	ldr	r0, [pc, #180]	; (80065a8 <HAL_I2C_Init+0x1d8>)
 80064f4:	f00d f9ec 	bl	80138d0 <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 80064f8:	68e3      	ldr	r3, [r4, #12]
 80064fa:	3b01      	subs	r3, #1
 80064fc:	2b01      	cmp	r3, #1
 80064fe:	d988      	bls.n	8006412 <HAL_I2C_Init+0x42>
 8006500:	e7e6      	b.n	80064d0 <HAL_I2C_Init+0x100>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 8006502:	f240 11e5 	movw	r1, #485	; 0x1e5
 8006506:	4828      	ldr	r0, [pc, #160]	; (80065a8 <HAL_I2C_Init+0x1d8>)
 8006508:	f00d f9e2 	bl	80138d0 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
 800650c:	69a3      	ldr	r3, [r4, #24]
 800650e:	2b07      	cmp	r3, #7
 8006510:	d98a      	bls.n	8006428 <HAL_I2C_Init+0x58>
 8006512:	e027      	b.n	8006564 <HAL_I2C_Init+0x194>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 8006514:	f44f 71f2 	mov.w	r1, #484	; 0x1e4
 8006518:	4823      	ldr	r0, [pc, #140]	; (80065a8 <HAL_I2C_Init+0x1d8>)
 800651a:	f00d f9d9 	bl	80138d0 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 800651e:	6963      	ldr	r3, [r4, #20]
 8006520:	2bff      	cmp	r3, #255	; 0xff
 8006522:	f67f af7d 	bls.w	8006420 <HAL_I2C_Init+0x50>
 8006526:	e7ec      	b.n	8006502 <HAL_I2C_Init+0x132>
    hi2c->Lock = HAL_UNLOCKED;
 8006528:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 800652c:	4620      	mov	r0, r4
 800652e:	f00c fe47 	bl	80131c0 <HAL_I2C_MspInit>
 8006532:	e788      	b.n	8006446 <HAL_I2C_Init+0x76>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 8006534:	f44f 71f4 	mov.w	r1, #488	; 0x1e8
 8006538:	481b      	ldr	r0, [pc, #108]	; (80065a8 <HAL_I2C_Init+0x1d8>)
 800653a:	f00d f9c9 	bl	80138d0 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 800653e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006542:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8006546:	2b00      	cmp	r3, #0
 8006548:	f47f af7d 	bne.w	8006446 <HAL_I2C_Init+0x76>
 800654c:	e7ec      	b.n	8006528 <HAL_I2C_Init+0x158>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 800654e:	f240 11e7 	movw	r1, #487	; 0x1e7
 8006552:	4815      	ldr	r0, [pc, #84]	; (80065a8 <HAL_I2C_Init+0x1d8>)
 8006554:	f00d f9bc 	bl	80138d0 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 8006558:	6a23      	ldr	r3, [r4, #32]
 800655a:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 800655e:	f43f af6c 	beq.w	800643a <HAL_I2C_Init+0x6a>
 8006562:	e7e7      	b.n	8006534 <HAL_I2C_Init+0x164>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
 8006564:	f44f 71f3 	mov.w	r1, #486	; 0x1e6
 8006568:	480f      	ldr	r0, [pc, #60]	; (80065a8 <HAL_I2C_Init+0x1d8>)
 800656a:	f00d f9b1 	bl	80138d0 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 800656e:	69e3      	ldr	r3, [r4, #28]
 8006570:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
 8006574:	f43f af5d 	beq.w	8006432 <HAL_I2C_Init+0x62>
 8006578:	e7e9      	b.n	800654e <HAL_I2C_Init+0x17e>
    return HAL_ERROR;
 800657a:	2001      	movs	r0, #1
}
 800657c:	4770      	bx	lr
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800657e:	f240 11e1 	movw	r1, #481	; 0x1e1
 8006582:	4809      	ldr	r0, [pc, #36]	; (80065a8 <HAL_I2C_Init+0x1d8>)
 8006584:	f00d f9a4 	bl	80138d0 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 8006588:	68a3      	ldr	r3, [r4, #8]
 800658a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800658e:	f4ff af3c 	bcc.w	800640a <HAL_I2C_Init+0x3a>
 8006592:	e7ac      	b.n	80064ee <HAL_I2C_Init+0x11e>
 8006594:	40005c00 	.word	0x40005c00
 8006598:	40005400 	.word	0x40005400
 800659c:	40005800 	.word	0x40005800
 80065a0:	58001c00 	.word	0x58001c00
 80065a4:	02008000 	.word	0x02008000
 80065a8:	0802929c 	.word	0x0802929c

080065ac <HAL_I2C_Master_Transmit>:
{
 80065ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 80065b0:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
{
 80065b4:	9e08      	ldr	r6, [sp, #32]
  if (hi2c->State == HAL_I2C_STATE_READY)
 80065b6:	2c20      	cmp	r4, #32
 80065b8:	f040 80a1 	bne.w	80066fe <HAL_I2C_Master_Transmit+0x152>
    __HAL_LOCK(hi2c);
 80065bc:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
 80065c0:	2c01      	cmp	r4, #1
 80065c2:	f000 809c 	beq.w	80066fe <HAL_I2C_Master_Transmit+0x152>
 80065c6:	4698      	mov	r8, r3
 80065c8:	2301      	movs	r3, #1
 80065ca:	4691      	mov	r9, r2
 80065cc:	460f      	mov	r7, r1
 80065ce:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
 80065d2:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
 80065d4:	f7fa fa28 	bl	8000a28 <HAL_GetTick>
 80065d8:	4605      	mov	r5, r0
 80065da:	e005      	b.n	80065e8 <HAL_I2C_Master_Transmit+0x3c>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80065dc:	f7fa fa24 	bl	8000a28 <HAL_GetTick>
 80065e0:	1b40      	subs	r0, r0, r5
 80065e2:	2819      	cmp	r0, #25
 80065e4:	f200 80a6 	bhi.w	8006734 <HAL_I2C_Master_Transmit+0x188>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80065e8:	6823      	ldr	r3, [r4, #0]
 80065ea:	6998      	ldr	r0, [r3, #24]
 80065ec:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
 80065f0:	d1f4      	bne.n	80065dc <HAL_I2C_Master_Transmit+0x30>
 80065f2:	4a78      	ldr	r2, [pc, #480]	; (80067d4 <HAL_I2C_Master_Transmit+0x228>)
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 80065f4:	f04f 0c21 	mov.w	ip, #33	; 0x21
 80065f8:	4977      	ldr	r1, [pc, #476]	; (80067d8 <HAL_I2C_Master_Transmit+0x22c>)
 80065fa:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
 80065fe:	4293      	cmp	r3, r2
 8006600:	bf18      	it	ne
 8006602:	428b      	cmpne	r3, r1
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8006604:	f04f 0110 	mov.w	r1, #16
 8006608:	f8df c1dc 	ldr.w	ip, [pc, #476]	; 80067e8 <HAL_I2C_Master_Transmit+0x23c>
 800660c:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 8006610:	bf14      	ite	ne
 8006612:	2201      	movne	r2, #1
 8006614:	2200      	moveq	r2, #0
 8006616:	4971      	ldr	r1, [pc, #452]	; (80067dc <HAL_I2C_Master_Transmit+0x230>)
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8006618:	6460      	str	r0, [r4, #68]	; 0x44
 800661a:	428b      	cmp	r3, r1
 800661c:	bf0c      	ite	eq
 800661e:	2200      	moveq	r2, #0
 8006620:	f002 0201 	andne.w	r2, r2, #1
    hi2c->XferCount = Size;
 8006624:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006628:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 800662a:	4563      	cmp	r3, ip
 800662c:	bf0c      	ite	eq
 800662e:	2200      	moveq	r2, #0
 8006630:	f002 0201 	andne.w	r2, r2, #1
    hi2c->pBuffPtr  = pData;
 8006634:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006638:	29ff      	cmp	r1, #255	; 0xff
    hi2c->XferISR   = NULL;
 800663a:	6360      	str	r0, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800663c:	d862      	bhi.n	8006704 <HAL_I2C_Master_Transmit+0x158>
      hi2c->XferSize = hi2c->XferCount;
 800663e:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 8006640:	b289      	uxth	r1, r1
 8006642:	8521      	strh	r1, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
 8006644:	fa5f f881 	uxtb.w	r8, r1
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8006648:	2a00      	cmp	r2, #0
 800664a:	f040 80b5 	bne.w	80067b8 <HAL_I2C_Master_Transmit+0x20c>
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800664e:	f3c7 0709 	ubfx	r7, r7, #0, #10
 8006652:	4a63      	ldr	r2, [pc, #396]	; (80067e0 <HAL_I2C_Master_Transmit+0x234>)
 8006654:	6859      	ldr	r1, [r3, #4]
 8006656:	433a      	orrs	r2, r7
 8006658:	4862      	ldr	r0, [pc, #392]	; (80067e4 <HAL_I2C_Master_Transmit+0x238>)
 800665a:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
 800665e:	4001      	ands	r1, r0
 8006660:	430a      	orrs	r2, r1
 8006662:	605a      	str	r2, [r3, #4]
 8006664:	f8df 8194 	ldr.w	r8, [pc, #404]	; 80067fc <HAL_I2C_Master_Transmit+0x250>
 8006668:	f8df 916c 	ldr.w	r9, [pc, #364]	; 80067d8 <HAL_I2C_Master_Transmit+0x22c>
 800666c:	ea47 0808 	orr.w	r8, r7, r8
    while (hi2c->XferCount > 0U)
 8006670:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8006672:	462a      	mov	r2, r5
 8006674:	4631      	mov	r1, r6
 8006676:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 8006678:	b29b      	uxth	r3, r3
 800667a:	2b00      	cmp	r3, #0
 800667c:	d07b      	beq.n	8006776 <HAL_I2C_Master_Transmit+0x1ca>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800667e:	f7ff fded 	bl	800625c <I2C_WaitOnTXISFlagUntilTimeout>
 8006682:	2800      	cmp	r0, #0
 8006684:	d174      	bne.n	8006770 <HAL_I2C_Master_Transmit+0x1c4>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8006686:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006688:	6823      	ldr	r3, [r4, #0]
 800668a:	7812      	ldrb	r2, [r2, #0]
 800668c:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 800668e:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8006690:	8d23      	ldrh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8006692:	3901      	subs	r1, #1
      hi2c->pBuffPtr++;
 8006694:	6a62      	ldr	r2, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8006696:	3b01      	subs	r3, #1
      hi2c->XferCount--;
 8006698:	b289      	uxth	r1, r1
      hi2c->pBuffPtr++;
 800669a:	3201      	adds	r2, #1
      hi2c->XferSize--;
 800669c:	b29b      	uxth	r3, r3
      hi2c->XferCount--;
 800669e:	8561      	strh	r1, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80066a0:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80066a2:	8523      	strh	r3, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80066a4:	b289      	uxth	r1, r1
      hi2c->pBuffPtr++;
 80066a6:	6262      	str	r2, [r4, #36]	; 0x24
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80066a8:	2b00      	cmp	r3, #0
 80066aa:	d1e1      	bne.n	8006670 <HAL_I2C_Master_Transmit+0xc4>
 80066ac:	2900      	cmp	r1, #0
 80066ae:	d0df      	beq.n	8006670 <HAL_I2C_Master_Transmit+0xc4>
 80066b0:	1c70      	adds	r0, r6, #1
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80066b2:	6822      	ldr	r2, [r4, #0]
 80066b4:	d134      	bne.n	8006720 <HAL_I2C_Master_Transmit+0x174>
 80066b6:	6993      	ldr	r3, [r2, #24]
 80066b8:	0619      	lsls	r1, r3, #24
 80066ba:	d5fc      	bpl.n	80066b6 <HAL_I2C_Master_Transmit+0x10a>
 80066bc:	4b4a      	ldr	r3, [pc, #296]	; (80067e8 <HAL_I2C_Master_Transmit+0x23c>)
 80066be:	4947      	ldr	r1, [pc, #284]	; (80067dc <HAL_I2C_Master_Transmit+0x230>)
 80066c0:	454a      	cmp	r2, r9
 80066c2:	bf18      	it	ne
 80066c4:	429a      	cmpne	r2, r3
 80066c6:	4843      	ldr	r0, [pc, #268]	; (80067d4 <HAL_I2C_Master_Transmit+0x228>)
 80066c8:	bf14      	ite	ne
 80066ca:	2301      	movne	r3, #1
 80066cc:	2300      	moveq	r3, #0
 80066ce:	428a      	cmp	r2, r1
 80066d0:	bf0c      	ite	eq
 80066d2:	2300      	moveq	r3, #0
 80066d4:	f003 0301 	andne.w	r3, r3, #1
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80066d8:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 80066da:	4282      	cmp	r2, r0
 80066dc:	bf0c      	ite	eq
 80066de:	2300      	moveq	r3, #0
 80066e0:	f003 0301 	andne.w	r3, r3, #1
 80066e4:	29ff      	cmp	r1, #255	; 0xff
 80066e6:	d933      	bls.n	8006750 <HAL_I2C_Master_Transmit+0x1a4>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80066e8:	21ff      	movs	r1, #255	; 0xff
 80066ea:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80066ec:	2b00      	cmp	r3, #0
 80066ee:	d155      	bne.n	800679c <HAL_I2C_Master_Transmit+0x1f0>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80066f0:	6853      	ldr	r3, [r2, #4]
 80066f2:	493e      	ldr	r1, [pc, #248]	; (80067ec <HAL_I2C_Master_Transmit+0x240>)
 80066f4:	400b      	ands	r3, r1
 80066f6:	ea43 0308 	orr.w	r3, r3, r8
 80066fa:	6053      	str	r3, [r2, #4]
 80066fc:	e7b8      	b.n	8006670 <HAL_I2C_Master_Transmit+0xc4>
    return HAL_BUSY;
 80066fe:	2002      	movs	r0, #2
}
 8006700:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8006704:	21ff      	movs	r1, #255	; 0xff
 8006706:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8006708:	2a00      	cmp	r2, #0
 800670a:	d15c      	bne.n	80067c6 <HAL_I2C_Master_Transmit+0x21a>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800670c:	685a      	ldr	r2, [r3, #4]
 800670e:	f3c7 0709 	ubfx	r7, r7, #0, #10
 8006712:	4937      	ldr	r1, [pc, #220]	; (80067f0 <HAL_I2C_Master_Transmit+0x244>)
 8006714:	4833      	ldr	r0, [pc, #204]	; (80067e4 <HAL_I2C_Master_Transmit+0x238>)
 8006716:	4339      	orrs	r1, r7
 8006718:	4002      	ands	r2, r0
 800671a:	430a      	orrs	r2, r1
 800671c:	605a      	str	r2, [r3, #4]
 800671e:	e7a1      	b.n	8006664 <HAL_I2C_Master_Transmit+0xb8>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8006720:	6993      	ldr	r3, [r2, #24]
 8006722:	061b      	lsls	r3, r3, #24
 8006724:	d4ca      	bmi.n	80066bc <HAL_I2C_Master_Transmit+0x110>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006726:	f7fa f97f 	bl	8000a28 <HAL_GetTick>
 800672a:	1b40      	subs	r0, r0, r5
 800672c:	4286      	cmp	r6, r0
 800672e:	d301      	bcc.n	8006734 <HAL_I2C_Master_Transmit+0x188>
 8006730:	2e00      	cmp	r6, #0
 8006732:	d1bd      	bne.n	80066b0 <HAL_I2C_Master_Transmit+0x104>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006734:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8006736:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006738:	2200      	movs	r2, #0
          return HAL_ERROR;
 800673a:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800673c:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 800673e:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006742:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8006744:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006748:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 800674c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          hi2c->XferSize = hi2c->XferCount;
 8006750:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 8006752:	b289      	uxth	r1, r1
 8006754:	8521      	strh	r1, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8006756:	fa5f fa81 	uxtb.w	sl, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800675a:	bb33      	cbnz	r3, 80067aa <HAL_I2C_Master_Transmit+0x1fe>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800675c:	6851      	ldr	r1, [r2, #4]
 800675e:	ea47 430a 	orr.w	r3, r7, sl, lsl #16
 8006762:	4822      	ldr	r0, [pc, #136]	; (80067ec <HAL_I2C_Master_Transmit+0x240>)
 8006764:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8006768:	4001      	ands	r1, r0
 800676a:	430b      	orrs	r3, r1
 800676c:	6053      	str	r3, [r2, #4]
 800676e:	e77f      	b.n	8006670 <HAL_I2C_Master_Transmit+0xc4>
        return HAL_ERROR;
 8006770:	2001      	movs	r0, #1
}
 8006772:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8006776:	f7ff fdd1 	bl	800631c <I2C_WaitOnSTOPFlagUntilTimeout>
 800677a:	2800      	cmp	r0, #0
 800677c:	d1f8      	bne.n	8006770 <HAL_I2C_Master_Transmit+0x1c4>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800677e:	6823      	ldr	r3, [r4, #0]
 8006780:	2220      	movs	r2, #32
    I2C_RESET_CR2(hi2c);
 8006782:	4d1c      	ldr	r5, [pc, #112]	; (80067f4 <HAL_I2C_Master_Transmit+0x248>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006784:	61da      	str	r2, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8006786:	6821      	ldr	r1, [r4, #0]
 8006788:	684b      	ldr	r3, [r1, #4]
 800678a:	402b      	ands	r3, r5
 800678c:	604b      	str	r3, [r1, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 800678e:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8006792:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8006796:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 800679a:	e7b1      	b.n	8006700 <HAL_I2C_Master_Transmit+0x154>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800679c:	f641 1131 	movw	r1, #6449	; 0x1931
 80067a0:	4815      	ldr	r0, [pc, #84]	; (80067f8 <HAL_I2C_Master_Transmit+0x24c>)
 80067a2:	f00d f895 	bl	80138d0 <assert_failed>
 80067a6:	6822      	ldr	r2, [r4, #0]
 80067a8:	e7a2      	b.n	80066f0 <HAL_I2C_Master_Transmit+0x144>
 80067aa:	f641 1131 	movw	r1, #6449	; 0x1931
 80067ae:	4812      	ldr	r0, [pc, #72]	; (80067f8 <HAL_I2C_Master_Transmit+0x24c>)
 80067b0:	f00d f88e 	bl	80138d0 <assert_failed>
 80067b4:	6822      	ldr	r2, [r4, #0]
 80067b6:	e7d1      	b.n	800675c <HAL_I2C_Master_Transmit+0x1b0>
 80067b8:	f641 1131 	movw	r1, #6449	; 0x1931
 80067bc:	480e      	ldr	r0, [pc, #56]	; (80067f8 <HAL_I2C_Master_Transmit+0x24c>)
 80067be:	f00d f887 	bl	80138d0 <assert_failed>
 80067c2:	6823      	ldr	r3, [r4, #0]
 80067c4:	e743      	b.n	800664e <HAL_I2C_Master_Transmit+0xa2>
 80067c6:	f641 1131 	movw	r1, #6449	; 0x1931
 80067ca:	480b      	ldr	r0, [pc, #44]	; (80067f8 <HAL_I2C_Master_Transmit+0x24c>)
 80067cc:	f00d f880 	bl	80138d0 <assert_failed>
 80067d0:	6823      	ldr	r3, [r4, #0]
 80067d2:	e79b      	b.n	800670c <HAL_I2C_Master_Transmit+0x160>
 80067d4:	40005c00 	.word	0x40005c00
 80067d8:	40005400 	.word	0x40005400
 80067dc:	40005800 	.word	0x40005800
 80067e0:	82002000 	.word	0x82002000
 80067e4:	fc009800 	.word	0xfc009800
 80067e8:	58001c00 	.word	0x58001c00
 80067ec:	fc009c00 	.word	0xfc009c00
 80067f0:	81ff2000 	.word	0x81ff2000
 80067f4:	fe00e800 	.word	0xfe00e800
 80067f8:	0802929c 	.word	0x0802929c
 80067fc:	01ff0000 	.word	0x01ff0000

08006800 <HAL_I2C_Master_Transmit_DMA>:
{
 8006800:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8006804:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
 8006808:	2c20      	cmp	r4, #32
 800680a:	d148      	bne.n	800689e <HAL_I2C_Master_Transmit_DMA+0x9e>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 800680c:	6807      	ldr	r7, [r0, #0]
 800680e:	69bd      	ldr	r5, [r7, #24]
 8006810:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
 8006814:	d143      	bne.n	800689e <HAL_I2C_Master_Transmit_DMA+0x9e>
    __HAL_LOCK(hi2c);
 8006816:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
 800681a:	2c01      	cmp	r4, #1
 800681c:	d03f      	beq.n	800689e <HAL_I2C_Master_Transmit_DMA+0x9e>
 800681e:	4604      	mov	r4, r0
 8006820:	460e      	mov	r6, r1
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
 8006822:	f04f 0c21 	mov.w	ip, #33	; 0x21
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
 8006826:	2110      	movs	r1, #16
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8006828:	4868      	ldr	r0, [pc, #416]	; (80069cc <HAL_I2C_Master_Transmit_DMA+0x1cc>)
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
 800682a:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
 800682e:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    __HAL_LOCK(hi2c);
 8006832:	2101      	movs	r1, #1
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8006834:	6465      	str	r5, [r4, #68]	; 0x44
    hi2c->XferCount   = Size;
 8006836:	8563      	strh	r3, [r4, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8006838:	62e0      	str	r0, [r4, #44]	; 0x2c
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800683a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->XferISR     = I2C_Master_ISR_DMA;
 800683c:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 8006a00 <HAL_I2C_Master_Transmit_DMA+0x200>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006840:	2bff      	cmp	r3, #255	; 0xff
    hi2c->pBuffPtr    = pData;
 8006842:	6262      	str	r2, [r4, #36]	; 0x24
    __HAL_LOCK(hi2c);
 8006844:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->XferISR     = I2C_Master_ISR_DMA;
 8006848:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800684c:	d92b      	bls.n	80068a6 <HAL_I2C_Master_Transmit_DMA+0xa6>
 800684e:	23ff      	movs	r3, #255	; 0xff
      xfermode = I2C_RELOAD_MODE;
 8006850:	f04f 7980 	mov.w	r9, #16777216	; 0x1000000
 8006854:	8523      	strh	r3, [r4, #40]	; 0x28
      if (hi2c->hdmatx != NULL)
 8006856:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006858:	2b00      	cmp	r3, #0
 800685a:	d058      	beq.n	800690e <HAL_I2C_Master_Transmit_DMA+0x10e>
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
 800685c:	4d5c      	ldr	r5, [pc, #368]	; (80069d0 <HAL_I2C_Master_Transmit_DMA+0x1d0>)
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
 800685e:	2700      	movs	r7, #0
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
 8006860:	485c      	ldr	r0, [pc, #368]	; (80069d4 <HAL_I2C_Master_Transmit_DMA+0x1d4>)
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 8006862:	4611      	mov	r1, r2
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
 8006864:	63dd      	str	r5, [r3, #60]	; 0x3c
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
 8006866:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006868:	64d8      	str	r0, [r3, #76]	; 0x4c
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
 800686a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800686c:	641f      	str	r7, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
 800686e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006870:	651f      	str	r7, [r3, #80]	; 0x50
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 8006872:	6822      	ldr	r2, [r4, #0]
 8006874:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8006876:	3228      	adds	r2, #40	; 0x28
 8006878:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800687a:	f7fc fdc1 	bl	8003400 <HAL_DMA_Start_IT>
      if (dmaxferstatus == HAL_OK)
 800687e:	4605      	mov	r5, r0
 8006880:	2800      	cmp	r0, #0
 8006882:	d05b      	beq.n	800693c <HAL_I2C_Master_Transmit_DMA+0x13c>
        hi2c->State     = HAL_I2C_STATE_READY;
 8006884:	2320      	movs	r3, #32
        __HAL_UNLOCK(hi2c);
 8006886:	f884 7040 	strb.w	r7, [r4, #64]	; 0x40
        return HAL_ERROR;
 800688a:	2501      	movs	r5, #1
        hi2c->State     = HAL_I2C_STATE_READY;
 800688c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
 8006890:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
 8006894:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8006896:	f043 0310 	orr.w	r3, r3, #16
 800689a:	6463      	str	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
 800689c:	e000      	b.n	80068a0 <HAL_I2C_Master_Transmit_DMA+0xa0>
    return HAL_BUSY;
 800689e:	2502      	movs	r5, #2
}
 80068a0:	4628      	mov	r0, r5
 80068a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      hi2c->XferSize = hi2c->XferCount;
 80068a6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80068a8:	b29b      	uxth	r3, r3
 80068aa:	8523      	strh	r3, [r4, #40]	; 0x28
    if (hi2c->XferSize > 0U)
 80068ac:	2b00      	cmp	r3, #0
 80068ae:	d13b      	bne.n	8006928 <HAL_I2C_Master_Transmit_DMA+0x128>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80068b0:	4b49      	ldr	r3, [pc, #292]	; (80069d8 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
 80068b2:	4a4a      	ldr	r2, [pc, #296]	; (80069dc <HAL_I2C_Master_Transmit_DMA+0x1dc>)
 80068b4:	494a      	ldr	r1, [pc, #296]	; (80069e0 <HAL_I2C_Master_Transmit_DMA+0x1e0>)
 80068b6:	429f      	cmp	r7, r3
 80068b8:	bf18      	it	ne
 80068ba:	4297      	cmpne	r7, r2
      hi2c->XferISR = I2C_Master_ISR_IT;
 80068bc:	4a49      	ldr	r2, [pc, #292]	; (80069e4 <HAL_I2C_Master_Transmit_DMA+0x1e4>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80068be:	bf14      	ite	ne
 80068c0:	2301      	movne	r3, #1
 80068c2:	2300      	moveq	r3, #0
      hi2c->XferISR = I2C_Master_ISR_IT;
 80068c4:	6362      	str	r2, [r4, #52]	; 0x34
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80068c6:	428f      	cmp	r7, r1
 80068c8:	bf0c      	ite	eq
 80068ca:	2300      	moveq	r3, #0
 80068cc:	f003 0301 	andne.w	r3, r3, #1
 80068d0:	b113      	cbz	r3, 80068d8 <HAL_I2C_Master_Transmit_DMA+0xd8>
 80068d2:	4b45      	ldr	r3, [pc, #276]	; (80069e8 <HAL_I2C_Master_Transmit_DMA+0x1e8>)
 80068d4:	429f      	cmp	r7, r3
 80068d6:	d12a      	bne.n	800692e <HAL_I2C_Master_Transmit_DMA+0x12e>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80068d8:	f3c6 0109 	ubfx	r1, r6, #0, #10
 80068dc:	4b43      	ldr	r3, [pc, #268]	; (80069ec <HAL_I2C_Master_Transmit_DMA+0x1ec>)
 80068de:	687a      	ldr	r2, [r7, #4]
      __HAL_UNLOCK(hi2c);
 80068e0:	2000      	movs	r0, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80068e2:	430b      	orrs	r3, r1
 80068e4:	4942      	ldr	r1, [pc, #264]	; (80069f0 <HAL_I2C_Master_Transmit_DMA+0x1f0>)
 80068e6:	400a      	ands	r2, r1
 80068e8:	4313      	orrs	r3, r2
 80068ea:	607b      	str	r3, [r7, #4]
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
  uint32_t tmpisr = 0U;

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 80068ec:	6b63      	ldr	r3, [r4, #52]	; 0x34
      __HAL_UNLOCK(hi2c);
 80068ee:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 80068f2:	4543      	cmp	r3, r8
 80068f4:	d004      	beq.n	8006900 <HAL_I2C_Master_Transmit_DMA+0x100>
 80068f6:	4a3f      	ldr	r2, [pc, #252]	; (80069f4 <HAL_I2C_Master_Transmit_DMA+0x1f4>)
 80068f8:	4293      	cmp	r3, r2
 80068fa:	d001      	beq.n	8006900 <HAL_I2C_Master_Transmit_DMA+0x100>
 80068fc:	21f2      	movs	r1, #242	; 0xf2
 80068fe:	e000      	b.n	8006902 <HAL_I2C_Master_Transmit_DMA+0x102>
 8006900:	2100      	movs	r1, #0
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 8006902:	6822      	ldr	r2, [r4, #0]
    return HAL_OK;
 8006904:	2500      	movs	r5, #0
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 8006906:	6813      	ldr	r3, [r2, #0]
 8006908:	430b      	orrs	r3, r1
 800690a:	6013      	str	r3, [r2, #0]
 800690c:	e7c8      	b.n	80068a0 <HAL_I2C_Master_Transmit_DMA+0xa0>
        hi2c->State     = HAL_I2C_STATE_READY;
 800690e:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
 8006910:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        return HAL_ERROR;
 8006914:	2501      	movs	r5, #1
        hi2c->State     = HAL_I2C_STATE_READY;
 8006916:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
 800691a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
 800691e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8006920:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006924:	6463      	str	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
 8006926:	e7bb      	b.n	80068a0 <HAL_I2C_Master_Transmit_DMA+0xa0>
      xfermode = I2C_AUTOEND_MODE;
 8006928:	f04f 7900 	mov.w	r9, #33554432	; 0x2000000
 800692c:	e793      	b.n	8006856 <HAL_I2C_Master_Transmit_DMA+0x56>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800692e:	f641 1131 	movw	r1, #6449	; 0x1931
 8006932:	4831      	ldr	r0, [pc, #196]	; (80069f8 <HAL_I2C_Master_Transmit_DMA+0x1f8>)
 8006934:	f00c ffcc 	bl	80138d0 <assert_failed>
 8006938:	6827      	ldr	r7, [r4, #0]
 800693a:	e7cd      	b.n	80068d8 <HAL_I2C_Master_Transmit_DMA+0xd8>
 800693c:	4b26      	ldr	r3, [pc, #152]	; (80069d8 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
 800693e:	6822      	ldr	r2, [r4, #0]
 8006940:	4826      	ldr	r0, [pc, #152]	; (80069dc <HAL_I2C_Master_Transmit_DMA+0x1dc>)
 8006942:	4927      	ldr	r1, [pc, #156]	; (80069e0 <HAL_I2C_Master_Transmit_DMA+0x1e0>)
 8006944:	429a      	cmp	r2, r3
 8006946:	bf18      	it	ne
 8006948:	4282      	cmpne	r2, r0
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
 800694a:	f894 7028 	ldrb.w	r7, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800694e:	bf14      	ite	ne
 8006950:	2301      	movne	r3, #1
 8006952:	2300      	moveq	r3, #0
 8006954:	428a      	cmp	r2, r1
 8006956:	bf0c      	ite	eq
 8006958:	2300      	moveq	r3, #0
 800695a:	f003 0301 	andne.w	r3, r3, #1
 800695e:	b113      	cbz	r3, 8006966 <HAL_I2C_Master_Transmit_DMA+0x166>
 8006960:	4b21      	ldr	r3, [pc, #132]	; (80069e8 <HAL_I2C_Master_Transmit_DMA+0x1e8>)
 8006962:	429a      	cmp	r2, r3
 8006964:	d12a      	bne.n	80069bc <HAL_I2C_Master_Transmit_DMA+0x1bc>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8006966:	f3c6 0109 	ubfx	r1, r6, #0, #10
 800696a:	4b24      	ldr	r3, [pc, #144]	; (80069fc <HAL_I2C_Master_Transmit_DMA+0x1fc>)
 800696c:	6856      	ldr	r6, [r2, #4]
        __HAL_UNLOCK(hi2c);
 800696e:	2000      	movs	r0, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8006970:	430b      	orrs	r3, r1
 8006972:	491f      	ldr	r1, [pc, #124]	; (80069f0 <HAL_I2C_Master_Transmit_DMA+0x1f0>)
 8006974:	400e      	ands	r6, r1
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8006976:	491f      	ldr	r1, [pc, #124]	; (80069f4 <HAL_I2C_Master_Transmit_DMA+0x1f4>)
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8006978:	4333      	orrs	r3, r6
 800697a:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 800697e:	ea43 0309 	orr.w	r3, r3, r9
 8006982:	6053      	str	r3, [r2, #4]
        hi2c->XferCount -= hi2c->XferSize;
 8006984:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8006986:	8d26      	ldrh	r6, [r4, #40]	; 0x28
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8006988:	6b63      	ldr	r3, [r4, #52]	; 0x34
        hi2c->XferCount -= hi2c->XferSize;
 800698a:	1b92      	subs	r2, r2, r6
        __HAL_UNLOCK(hi2c);
 800698c:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8006990:	428b      	cmp	r3, r1
        hi2c->XferCount -= hi2c->XferSize;
 8006992:	b292      	uxth	r2, r2
 8006994:	8562      	strh	r2, [r4, #42]	; 0x2a
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8006996:	d00f      	beq.n	80069b8 <HAL_I2C_Master_Transmit_DMA+0x1b8>
 8006998:	eba3 0308 	sub.w	r3, r3, r8
 800699c:	fab3 f383 	clz	r3, r3
 80069a0:	095b      	lsrs	r3, r3, #5
 80069a2:	b94b      	cbnz	r3, 80069b8 <HAL_I2C_Master_Transmit_DMA+0x1b8>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 80069a4:	6821      	ldr	r1, [r4, #0]
 80069a6:	680a      	ldr	r2, [r1, #0]
 80069a8:	4313      	orrs	r3, r2
 80069aa:	600b      	str	r3, [r1, #0]
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
 80069ac:	6822      	ldr	r2, [r4, #0]
 80069ae:	6813      	ldr	r3, [r2, #0]
 80069b0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80069b4:	6013      	str	r3, [r2, #0]
 80069b6:	e773      	b.n	80068a0 <HAL_I2C_Master_Transmit_DMA+0xa0>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 80069b8:	2390      	movs	r3, #144	; 0x90
 80069ba:	e7f3      	b.n	80069a4 <HAL_I2C_Master_Transmit_DMA+0x1a4>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80069bc:	f641 1131 	movw	r1, #6449	; 0x1931
 80069c0:	480d      	ldr	r0, [pc, #52]	; (80069f8 <HAL_I2C_Master_Transmit_DMA+0x1f8>)
 80069c2:	f00c ff85 	bl	80138d0 <assert_failed>
 80069c6:	6822      	ldr	r2, [r4, #0]
 80069c8:	e7cd      	b.n	8006966 <HAL_I2C_Master_Transmit_DMA+0x166>
 80069ca:	bf00      	nop
 80069cc:	ffff0000 	.word	0xffff0000
 80069d0:	08007211 	.word	0x08007211
 80069d4:	08007c61 	.word	0x08007c61
 80069d8:	40005400 	.word	0x40005400
 80069dc:	40005800 	.word	0x40005800
 80069e0:	40005c00 	.word	0x40005c00
 80069e4:	0800751d 	.word	0x0800751d
 80069e8:	58001c00 	.word	0x58001c00
 80069ec:	82002000 	.word	0x82002000
 80069f0:	fc009800 	.word	0xfc009800
 80069f4:	08007045 	.word	0x08007045
 80069f8:	0802929c 	.word	0x0802929c
 80069fc:	80002000 	.word	0x80002000
 8006a00:	080077f1 	.word	0x080077f1

08006a04 <HAL_I2C_EV_IRQHandler>:
{
 8006a04:	b410      	push	{r4}
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 8006a06:	6803      	ldr	r3, [r0, #0]
  if (hi2c->XferISR != NULL)
 8006a08:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 8006a0a:	6999      	ldr	r1, [r3, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 8006a0c:	681a      	ldr	r2, [r3, #0]
  if (hi2c->XferISR != NULL)
 8006a0e:	b11c      	cbz	r4, 8006a18 <HAL_I2C_EV_IRQHandler+0x14>
    hi2c->XferISR(hi2c, itflags, itsources);
 8006a10:	4623      	mov	r3, r4
}
 8006a12:	f85d 4b04 	ldr.w	r4, [sp], #4
    hi2c->XferISR(hi2c, itflags, itsources);
 8006a16:	4718      	bx	r3
}
 8006a18:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006a1c:	4770      	bx	lr
 8006a1e:	bf00      	nop

08006a20 <HAL_I2C_MasterTxCpltCallback>:
 8006a20:	4770      	bx	lr
 8006a22:	bf00      	nop

08006a24 <HAL_I2C_MasterRxCpltCallback>:
 8006a24:	4770      	bx	lr
 8006a26:	bf00      	nop

08006a28 <HAL_I2C_SlaveTxCpltCallback>:
 8006a28:	4770      	bx	lr
 8006a2a:	bf00      	nop

08006a2c <HAL_I2C_SlaveRxCpltCallback>:
 8006a2c:	4770      	bx	lr
 8006a2e:	bf00      	nop

08006a30 <I2C_ITSlaveSeqCplt>:
{
 8006a30:	b538      	push	{r3, r4, r5, lr}
 8006a32:	4603      	mov	r3, r0
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8006a34:	2000      	movs	r0, #0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 8006a36:	681a      	ldr	r2, [r3, #0]
 8006a38:	6811      	ldr	r1, [r2, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8006a3a:	f883 0042 	strb.w	r0, [r3, #66]	; 0x42
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 8006a3e:	0448      	lsls	r0, r1, #17
 8006a40:	d50c      	bpl.n	8006a5c <I2C_ITSlaveSeqCplt+0x2c>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8006a42:	6811      	ldr	r1, [r2, #0]
 8006a44:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8006a48:	6011      	str	r1, [r2, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 8006a4a:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
 8006a4e:	2a29      	cmp	r2, #41	; 0x29
 8006a50:	d00e      	beq.n	8006a70 <I2C_ITSlaveSeqCplt+0x40>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
 8006a52:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
 8006a56:	2a2a      	cmp	r2, #42	; 0x2a
 8006a58:	d024      	beq.n	8006aa4 <I2C_ITSlaveSeqCplt+0x74>
}
 8006a5a:	bd38      	pop	{r3, r4, r5, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 8006a5c:	0409      	lsls	r1, r1, #16
 8006a5e:	d5f4      	bpl.n	8006a4a <I2C_ITSlaveSeqCplt+0x1a>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8006a60:	6811      	ldr	r1, [r2, #0]
 8006a62:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 8006a66:	6011      	str	r1, [r2, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 8006a68:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
 8006a6c:	2a29      	cmp	r2, #41	; 0x29
 8006a6e:	d1f0      	bne.n	8006a52 <I2C_ITSlaveSeqCplt+0x22>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8006a70:	2128      	movs	r1, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8006a72:	2221      	movs	r2, #33	; 0x21
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006a74:	681c      	ldr	r4, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8006a76:	2500      	movs	r5, #0
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8006a78:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8006a7c:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8006a7e:	631a      	str	r2, [r3, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006a80:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006a84:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006a86:	f001 0128 	and.w	r1, r1, #40	; 0x28
 8006a8a:	2928      	cmp	r1, #40	; 0x28
 8006a8c:	bf14      	ite	ne
 8006a8e:	f06f 01f2 	mvnne.w	r1, #242	; 0xf2
 8006a92:	f06f 0142 	mvneq.w	r1, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006a96:	400a      	ands	r2, r1
 8006a98:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
 8006a9a:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8006a9e:	f7ff ffc3 	bl	8006a28 <HAL_I2C_SlaveTxCpltCallback>
}
 8006aa2:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8006aa4:	2128      	movs	r1, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8006aa6:	2222      	movs	r2, #34	; 0x22
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006aa8:	681c      	ldr	r4, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8006aaa:	2500      	movs	r5, #0
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8006aac:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8006ab0:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8006ab2:	631a      	str	r2, [r3, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006ab4:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006ab8:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006aba:	f001 0128 	and.w	r1, r1, #40	; 0x28
 8006abe:	2928      	cmp	r1, #40	; 0x28
 8006ac0:	bf14      	ite	ne
 8006ac2:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
 8006ac6:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006aca:	400a      	ands	r2, r1
 8006acc:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
 8006ace:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8006ad2:	f7ff ffab 	bl	8006a2c <HAL_I2C_SlaveRxCpltCallback>
}
 8006ad6:	bd38      	pop	{r3, r4, r5, pc}

08006ad8 <HAL_I2C_AddrCallback>:
}
 8006ad8:	4770      	bx	lr
 8006ada:	bf00      	nop

08006adc <I2C_ITAddrCplt.isra.9.part.10>:
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
 8006adc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    transferdirection = I2C_GET_DIR(hi2c);
 8006ade:	6804      	ldr	r4, [r0, #0]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8006ae0:	68c3      	ldr	r3, [r0, #12]
    transferdirection = I2C_GET_DIR(hi2c);
 8006ae2:	69a1      	ldr	r1, [r4, #24]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 8006ae4:	69a2      	ldr	r2, [r4, #24]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8006ae6:	2b02      	cmp	r3, #2
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 8006ae8:	68a6      	ldr	r6, [r4, #8]
    transferdirection = I2C_GET_DIR(hi2c);
 8006aea:	f3c1 4100 	ubfx	r1, r1, #16, #1
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 8006aee:	ea4f 4212 	mov.w	r2, r2, lsr #16
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
 8006af2:	68e7      	ldr	r7, [r4, #12]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 8006af4:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8006af8:	d10d      	bne.n	8006b16 <I2C_ITAddrCplt.isra.9.part.10+0x3a>
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 8006afa:	f3c6 0609 	ubfx	r6, r6, #0, #10
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
 8006afe:	ea82 13d6 	eor.w	r3, r2, r6, lsr #7
 8006b02:	f013 0306 	ands.w	r3, r3, #6
 8006b06:	d110      	bne.n	8006b2a <I2C_ITAddrCplt.isra.9.part.10+0x4e>
        hi2c->AddrEventCount++;
 8006b08:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8006b0a:	3201      	adds	r2, #1
 8006b0c:	6482      	str	r2, [r0, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
 8006b0e:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8006b10:	2a02      	cmp	r2, #2
 8006b12:	d016      	beq.n	8006b42 <I2C_ITAddrCplt.isra.9.part.10+0x66>
}
 8006b14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006b16:	6823      	ldr	r3, [r4, #0]
      __HAL_UNLOCK(hi2c);
 8006b18:	2600      	movs	r6, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006b1a:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
 8006b1e:	6023      	str	r3, [r4, #0]
      __HAL_UNLOCK(hi2c);
 8006b20:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8006b24:	f7ff ffd8 	bl	8006ad8 <HAL_I2C_AddrCallback>
}
 8006b28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006b2a:	6823      	ldr	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
 8006b2c:	2600      	movs	r6, #0
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8006b2e:	f007 02fe 	and.w	r2, r7, #254	; 0xfe
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006b32:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
 8006b36:	6023      	str	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
 8006b38:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8006b3c:	f7ff ffcc 	bl	8006ad8 <HAL_I2C_AddrCallback>
}
 8006b40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8006b42:	2708      	movs	r7, #8
          hi2c->AddrEventCount = 0U;
 8006b44:	6483      	str	r3, [r0, #72]	; 0x48
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8006b46:	4632      	mov	r2, r6
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8006b48:	61e7      	str	r7, [r4, #28]
          __HAL_UNLOCK(hi2c);
 8006b4a:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8006b4e:	f7ff ffc3 	bl	8006ad8 <HAL_I2C_AddrCallback>
}
 8006b52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006b54 <HAL_I2C_ListenCpltCallback>:
 8006b54:	4770      	bx	lr
 8006b56:	bf00      	nop

08006b58 <HAL_I2C_MemTxCpltCallback>:
 8006b58:	4770      	bx	lr
 8006b5a:	bf00      	nop

08006b5c <HAL_I2C_MemRxCpltCallback>:
 8006b5c:	4770      	bx	lr
 8006b5e:	bf00      	nop

08006b60 <HAL_I2C_ErrorCallback>:
 8006b60:	4770      	bx	lr
 8006b62:	bf00      	nop

08006b64 <HAL_I2C_AbortCpltCallback>:
 8006b64:	4770      	bx	lr
 8006b66:	bf00      	nop

08006b68 <I2C_DMAAbort>:
{
 8006b68:	b508      	push	{r3, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8006b6a:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if (hi2c->hdmatx != NULL)
 8006b6c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8006b6e:	b10a      	cbz	r2, 8006b74 <I2C_DMAAbort+0xc>
    hi2c->hdmatx->XferAbortCallback = NULL;
 8006b70:	2100      	movs	r1, #0
 8006b72:	6511      	str	r1, [r2, #80]	; 0x50
  if (hi2c->hdmarx != NULL)
 8006b74:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8006b76:	b10a      	cbz	r2, 8006b7c <I2C_DMAAbort+0x14>
    hi2c->hdmarx->XferAbortCallback = NULL;
 8006b78:	2100      	movs	r1, #0
 8006b7a:	6511      	str	r1, [r2, #80]	; 0x50
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8006b7c:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
 8006b80:	2a60      	cmp	r2, #96	; 0x60
 8006b82:	d007      	beq.n	8006b94 <I2C_DMAAbort+0x2c>
    hi2c->PreviousState = I2C_STATE_NONE;
 8006b84:	2200      	movs	r2, #0
    HAL_I2C_ErrorCallback(hi2c);
 8006b86:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_NONE;
 8006b88:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8006b8a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 8006b8e:	f7ff ffe7 	bl	8006b60 <HAL_I2C_ErrorCallback>
}
 8006b92:	bd08      	pop	{r3, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
 8006b94:	2200      	movs	r2, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8006b96:	2120      	movs	r1, #32
    HAL_I2C_AbortCpltCallback(hi2c);
 8006b98:	4618      	mov	r0, r3
    hi2c->State = HAL_I2C_STATE_READY;
 8006b9a:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8006b9e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 8006ba2:	631a      	str	r2, [r3, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
 8006ba4:	f7ff ffde 	bl	8006b64 <HAL_I2C_AbortCpltCallback>
}
 8006ba8:	bd08      	pop	{r3, pc}
 8006baa:	bf00      	nop

08006bac <I2C_ITError>:
{
 8006bac:	b570      	push	{r4, r5, r6, lr}
 8006bae:	4604      	mov	r4, r0
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8006bb0:	2200      	movs	r2, #0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8006bb2:	484c      	ldr	r0, [pc, #304]	; (8006ce4 <I2C_ITError+0x138>)
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8006bb4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8006bb8:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8006bbc:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8006bbe:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->XferCount     = 0U;
 8006bc0:	8562      	strh	r2, [r4, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
 8006bc2:	6c62      	ldr	r2, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8006bc4:	2b02      	cmp	r3, #2
 8006bc6:	6820      	ldr	r0, [r4, #0]
  hi2c->ErrorCode |= ErrorCode;
 8006bc8:	ea41 0102 	orr.w	r1, r1, r2
 8006bcc:	6461      	str	r1, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8006bce:	d830      	bhi.n	8006c32 <I2C_ITError+0x86>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006bd0:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8006bd4:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006bd6:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006bda:	4032      	ands	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006bdc:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006bde:	4031      	ands	r1, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8006be0:	4d41      	ldr	r5, [pc, #260]	; (8006ce8 <I2C_ITError+0x13c>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006be2:	42b2      	cmp	r2, r6
 8006be4:	bf14      	ite	ne
 8006be6:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
 8006bea:	f06f 0246 	mvneq.w	r2, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006bee:	42b1      	cmp	r1, r6
 8006bf0:	bf18      	it	ne
 8006bf2:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006bf6:	4013      	ands	r3, r2
 8006bf8:	6003      	str	r3, [r0, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8006bfa:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8006bfe:	6365      	str	r5, [r4, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8006c00:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
 8006c02:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8006c04:	b118      	cbz	r0, 8006c0e <I2C_ITError+0x62>
 8006c06:	2b11      	cmp	r3, #17
 8006c08:	d025      	beq.n	8006c56 <I2C_ITError+0xaa>
 8006c0a:	2b21      	cmp	r3, #33	; 0x21
 8006c0c:	d023      	beq.n	8006c56 <I2C_ITError+0xaa>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
 8006c0e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8006c10:	b118      	cbz	r0, 8006c1a <I2C_ITError+0x6e>
 8006c12:	2b12      	cmp	r3, #18
 8006c14:	d037      	beq.n	8006c86 <I2C_ITError+0xda>
 8006c16:	2b22      	cmp	r3, #34	; 0x22
 8006c18:	d035      	beq.n	8006c86 <I2C_ITError+0xda>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8006c1a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006c1e:	2b60      	cmp	r3, #96	; 0x60
 8006c20:	d054      	beq.n	8006ccc <I2C_ITError+0x120>
    hi2c->PreviousState = I2C_STATE_NONE;
 8006c22:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
 8006c24:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
 8006c26:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8006c28:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 8006c2c:	f7ff ff98 	bl	8006b60 <HAL_I2C_ErrorCallback>
}
 8006c30:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006c32:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006c36:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006c3a:	6803      	ldr	r3, [r0, #0]
 8006c3c:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8006c40:	6003      	str	r3, [r0, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 8006c42:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006c46:	2b60      	cmp	r3, #96	; 0x60
 8006c48:	d002      	beq.n	8006c50 <I2C_ITError+0xa4>
      hi2c->State         = HAL_I2C_STATE_READY;
 8006c4a:	2320      	movs	r3, #32
 8006c4c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8006c50:	2300      	movs	r3, #0
 8006c52:	6363      	str	r3, [r4, #52]	; 0x34
 8006c54:	e7d4      	b.n	8006c00 <I2C_ITError+0x54>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8006c56:	6823      	ldr	r3, [r4, #0]
 8006c58:	681a      	ldr	r2, [r3, #0]
 8006c5a:	0451      	lsls	r1, r2, #17
 8006c5c:	d430      	bmi.n	8006cc0 <I2C_ITError+0x114>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8006c5e:	f7fd fe21 	bl	80048a4 <HAL_DMA_GetState>
 8006c62:	2801      	cmp	r0, #1
 8006c64:	d0d9      	beq.n	8006c1a <I2C_ITError+0x6e>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8006c66:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
 8006c68:	2300      	movs	r3, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8006c6a:	4920      	ldr	r1, [pc, #128]	; (8006cec <I2C_ITError+0x140>)
 8006c6c:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8006c6e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8006c72:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8006c74:	f7fd f8be 	bl	8003df4 <HAL_DMA_Abort_IT>
 8006c78:	2800      	cmp	r0, #0
 8006c7a:	d0d9      	beq.n	8006c30 <I2C_ITError+0x84>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8006c7c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
 8006c7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8006c82:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8006c84:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 8006c86:	6823      	ldr	r3, [r4, #0]
 8006c88:	681a      	ldr	r2, [r3, #0]
 8006c8a:	0412      	lsls	r2, r2, #16
 8006c8c:	d504      	bpl.n	8006c98 <I2C_ITError+0xec>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8006c8e:	681a      	ldr	r2, [r3, #0]
 8006c90:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8006c94:	601a      	str	r2, [r3, #0]
 8006c96:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8006c98:	f7fd fe04 	bl	80048a4 <HAL_DMA_GetState>
 8006c9c:	2801      	cmp	r0, #1
 8006c9e:	d0bc      	beq.n	8006c1a <I2C_ITError+0x6e>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8006ca0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
 8006ca2:	2300      	movs	r3, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8006ca4:	4911      	ldr	r1, [pc, #68]	; (8006cec <I2C_ITError+0x140>)
 8006ca6:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8006ca8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8006cac:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8006cae:	f7fd f8a1 	bl	8003df4 <HAL_DMA_Abort_IT>
 8006cb2:	2800      	cmp	r0, #0
 8006cb4:	d0bc      	beq.n	8006c30 <I2C_ITError+0x84>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8006cb6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
 8006cb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8006cbc:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8006cbe:	4718      	bx	r3
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8006cc0:	681a      	ldr	r2, [r3, #0]
 8006cc2:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8006cc6:	601a      	str	r2, [r3, #0]
 8006cc8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8006cca:	e7c8      	b.n	8006c5e <I2C_ITError+0xb2>
    hi2c->PreviousState = I2C_STATE_NONE;
 8006ccc:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8006cce:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
 8006cd0:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 8006cd2:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8006cd6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 8006cda:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
 8006cdc:	f7ff ff42 	bl	8006b64 <HAL_I2C_AbortCpltCallback>
}
 8006ce0:	bd70      	pop	{r4, r5, r6, pc}
 8006ce2:	bf00      	nop
 8006ce4:	ffff0000 	.word	0xffff0000
 8006ce8:	08006e9d 	.word	0x08006e9d
 8006cec:	08006b69 	.word	0x08006b69

08006cf0 <I2C_ITSlaveCplt>:
{
 8006cf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006cf2:	4604      	mov	r4, r0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 8006cf4:	6802      	ldr	r2, [r0, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006cf6:	2620      	movs	r6, #32
{
 8006cf8:	460d      	mov	r5, r1
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 8006cfa:	6810      	ldr	r0, [r2, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8006cfc:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006d00:	61d6      	str	r6, [r2, #28]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8006d02:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006d06:	6821      	ldr	r1, [r4, #0]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8006d08:	2b21      	cmp	r3, #33	; 0x21
 8006d0a:	d165      	bne.n	8006dd8 <I2C_ITSlaveCplt+0xe8>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006d0c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006d10:	680a      	ldr	r2, [r1, #0]
 8006d12:	f022 02fa 	bic.w	r2, r2, #250	; 0xfa
 8006d16:	600a      	str	r2, [r1, #0]
 8006d18:	6821      	ldr	r1, [r4, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8006d1a:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8006d1c:	684a      	ldr	r2, [r1, #4]
  I2C_RESET_CR2(hi2c);
 8006d1e:	4e5d      	ldr	r6, [pc, #372]	; (8006e94 <I2C_ITSlaveCplt+0x1a4>)
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8006d20:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8006d24:	604a      	str	r2, [r1, #4]
  I2C_RESET_CR2(hi2c);
 8006d26:	6822      	ldr	r2, [r4, #0]
 8006d28:	6853      	ldr	r3, [r2, #4]
 8006d2a:	4033      	ands	r3, r6
 8006d2c:	6053      	str	r3, [r2, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8006d2e:	6823      	ldr	r3, [r4, #0]
 8006d30:	699a      	ldr	r2, [r3, #24]
 8006d32:	0792      	lsls	r2, r2, #30
 8006d34:	d502      	bpl.n	8006d3c <I2C_ITSlaveCplt+0x4c>
    hi2c->Instance->TXDR = 0x00U;
 8006d36:	2200      	movs	r2, #0
 8006d38:	629a      	str	r2, [r3, #40]	; 0x28
 8006d3a:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8006d3c:	699a      	ldr	r2, [r3, #24]
 8006d3e:	07d7      	lsls	r7, r2, #31
 8006d40:	d403      	bmi.n	8006d4a <I2C_ITSlaveCplt+0x5a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8006d42:	699a      	ldr	r2, [r3, #24]
 8006d44:	f042 0201 	orr.w	r2, r2, #1
 8006d48:	619a      	str	r2, [r3, #24]
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 8006d4a:	0446      	lsls	r6, r0, #17
 8006d4c:	d539      	bpl.n	8006dc2 <I2C_ITSlaveCplt+0xd2>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8006d4e:	6822      	ldr	r2, [r4, #0]
 8006d50:	6813      	ldr	r3, [r2, #0]
 8006d52:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8006d56:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmatx != NULL)
 8006d58:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006d5a:	b11b      	cbz	r3, 8006d64 <I2C_ITSlaveCplt+0x74>
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
 8006d5c:	681a      	ldr	r2, [r3, #0]
 8006d5e:	6853      	ldr	r3, [r2, #4]
 8006d60:	b29b      	uxth	r3, r3
 8006d62:	8563      	strh	r3, [r4, #42]	; 0x2a
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
 8006d64:	0769      	lsls	r1, r5, #29
 8006d66:	d50b      	bpl.n	8006d80 <I2C_ITSlaveCplt+0x90>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8006d68:	6822      	ldr	r2, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
 8006d6a:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8006d6e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006d70:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8006d72:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8006d74:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8006d76:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
 8006d78:	3301      	adds	r3, #1
 8006d7a:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8006d7c:	2a00      	cmp	r2, #0
 8006d7e:	d144      	bne.n	8006e0a <I2C_ITSlaveCplt+0x11a>
  if (hi2c->XferCount != 0U)
 8006d80:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006d82:	b29b      	uxth	r3, r3
 8006d84:	b11b      	cbz	r3, 8006d8e <I2C_ITSlaveCplt+0x9e>
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8006d86:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8006d88:	f043 0304 	orr.w	r3, r3, #4
 8006d8c:	6463      	str	r3, [r4, #68]	; 0x44
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8006d8e:	2700      	movs	r7, #0
 8006d90:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8006d94:	6c66      	ldr	r6, [r4, #68]	; 0x44
  hi2c->XferISR = NULL;
 8006d96:	6367      	str	r7, [r4, #52]	; 0x34
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8006d98:	2e00      	cmp	r6, #0
 8006d9a:	d13d      	bne.n	8006e18 <I2C_ITSlaveCplt+0x128>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 8006d9c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006d9e:	4d3e      	ldr	r5, [pc, #248]	; (8006e98 <I2C_ITSlaveCplt+0x1a8>)
 8006da0:	42ab      	cmp	r3, r5
 8006da2:	d124      	bne.n	8006dee <I2C_ITSlaveCplt+0xfe>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8006da4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8006da8:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
 8006daa:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8006dae:	2b22      	cmp	r3, #34	; 0x22
    hi2c->State = HAL_I2C_STATE_READY;
 8006db0:	f04f 0320 	mov.w	r3, #32
 8006db4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 8006db8:	6326      	str	r6, [r4, #48]	; 0x30
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8006dba:	d066      	beq.n	8006e8a <I2C_ITSlaveCplt+0x19a>
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8006dbc:	f7ff fe34 	bl	8006a28 <HAL_I2C_SlaveTxCpltCallback>
}
 8006dc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 8006dc2:	0400      	lsls	r0, r0, #16
 8006dc4:	d5ce      	bpl.n	8006d64 <I2C_ITSlaveCplt+0x74>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8006dc6:	6822      	ldr	r2, [r4, #0]
 8006dc8:	6813      	ldr	r3, [r2, #0]
 8006dca:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8006dce:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmarx != NULL)
 8006dd0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8006dd2:	2b00      	cmp	r3, #0
 8006dd4:	d1c2      	bne.n	8006d5c <I2C_ITSlaveCplt+0x6c>
 8006dd6:	e7c5      	b.n	8006d64 <I2C_ITSlaveCplt+0x74>
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8006dd8:	2b22      	cmp	r3, #34	; 0x22
 8006dda:	d19f      	bne.n	8006d1c <I2C_ITSlaveCplt+0x2c>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006ddc:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006de0:	680a      	ldr	r2, [r1, #0]
 8006de2:	f022 02fc 	bic.w	r2, r2, #252	; 0xfc
 8006de6:	600a      	str	r2, [r1, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8006de8:	6323      	str	r3, [r4, #48]	; 0x30
 8006dea:	6821      	ldr	r1, [r4, #0]
 8006dec:	e796      	b.n	8006d1c <I2C_ITSlaveCplt+0x2c>
    I2C_ITSlaveSeqCplt(hi2c);
 8006dee:	4620      	mov	r0, r4
 8006df0:	f7ff fe1e 	bl	8006a30 <I2C_ITSlaveSeqCplt>
    hi2c->State = HAL_I2C_STATE_READY;
 8006df4:	2320      	movs	r3, #32
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8006df6:	62e5      	str	r5, [r4, #44]	; 0x2c
    HAL_I2C_ListenCpltCallback(hi2c);
 8006df8:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 8006dfa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8006dfe:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 8006e02:	6326      	str	r6, [r4, #48]	; 0x30
    HAL_I2C_ListenCpltCallback(hi2c);
 8006e04:	f7ff fea6 	bl	8006b54 <HAL_I2C_ListenCpltCallback>
}
 8006e08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hi2c->XferCount--;
 8006e0a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8006e0c:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8006e0e:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8006e10:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8006e12:	b29b      	uxth	r3, r3
 8006e14:	8563      	strh	r3, [r4, #42]	; 0x2a
 8006e16:	e7b3      	b.n	8006d80 <I2C_ITSlaveCplt+0x90>
    I2C_ITError(hi2c, hi2c->ErrorCode);
 8006e18:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8006e1a:	4620      	mov	r0, r4
 8006e1c:	f7ff fec6 	bl	8006bac <I2C_ITError>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 8006e20:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006e24:	2b28      	cmp	r3, #40	; 0x28
 8006e26:	d1cb      	bne.n	8006dc0 <I2C_ITSlaveCplt+0xd0>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8006e28:	4b1b      	ldr	r3, [pc, #108]	; (8006e98 <I2C_ITSlaveCplt+0x1a8>)
  hi2c->State = HAL_I2C_STATE_READY;
 8006e2a:	2220      	movs	r2, #32
  hi2c->XferISR = NULL;
 8006e2c:	6367      	str	r7, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8006e2e:	62e3      	str	r3, [r4, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
 8006e30:	6327      	str	r7, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
 8006e32:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8006e36:	076a      	lsls	r2, r5, #29
 8006e38:	6823      	ldr	r3, [r4, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8006e3a:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8006e3e:	d512      	bpl.n	8006e66 <I2C_ITSlaveCplt+0x176>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8006e40:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006e42:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006e44:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8006e46:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8006e48:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
 8006e4a:	3301      	adds	r3, #1
 8006e4c:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8006e4e:	b1fa      	cbz	r2, 8006e90 <I2C_ITSlaveCplt+0x1a0>
      hi2c->XferCount--;
 8006e50:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8006e52:	3a01      	subs	r2, #1
 8006e54:	6823      	ldr	r3, [r4, #0]
      hi2c->XferCount--;
 8006e56:	3901      	subs	r1, #1
      hi2c->XferSize--;
 8006e58:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8006e5a:	b28a      	uxth	r2, r1
 8006e5c:	8562      	strh	r2, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8006e5e:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8006e60:	f042 0204 	orr.w	r2, r2, #4
 8006e64:	6462      	str	r2, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006e66:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8006e6a:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006e6c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
 8006e70:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006e72:	681a      	ldr	r2, [r3, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
 8006e74:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006e76:	f022 02fe 	bic.w	r2, r2, #254	; 0xfe
 8006e7a:	601a      	str	r2, [r3, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8006e7c:	6823      	ldr	r3, [r4, #0]
 8006e7e:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
 8006e80:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
 8006e84:	f7ff fe66 	bl	8006b54 <HAL_I2C_ListenCpltCallback>
}
 8006e88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8006e8a:	f7ff fdcf 	bl	8006a2c <HAL_I2C_SlaveRxCpltCallback>
}
 8006e8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006e90:	6823      	ldr	r3, [r4, #0]
 8006e92:	e7e8      	b.n	8006e66 <I2C_ITSlaveCplt+0x176>
 8006e94:	fe00e800 	.word	0xfe00e800
 8006e98:	ffff0000 	.word	0xffff0000

08006e9c <I2C_Slave_ISR_IT>:
{
 8006e9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
 8006e9e:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
 8006ea2:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
 8006ea4:	2b01      	cmp	r3, #1
 8006ea6:	d07f      	beq.n	8006fa8 <I2C_Slave_ISR_IT+0x10c>
 8006ea8:	4616      	mov	r6, r2
 8006eaa:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8006eac:	068a      	lsls	r2, r1, #26
 8006eae:	4604      	mov	r4, r0
 8006eb0:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
 8006eb2:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8006eb6:	d501      	bpl.n	8006ebc <I2C_Slave_ISR_IT+0x20>
 8006eb8:	06b3      	lsls	r3, r6, #26
 8006eba:	d462      	bmi.n	8006f82 <I2C_Slave_ISR_IT+0xe6>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8006ebc:	06ea      	lsls	r2, r5, #27
 8006ebe:	d51b      	bpl.n	8006ef8 <I2C_Slave_ISR_IT+0x5c>
 8006ec0:	06f3      	lsls	r3, r6, #27
 8006ec2:	d519      	bpl.n	8006ef8 <I2C_Slave_ISR_IT+0x5c>
    if (hi2c->XferCount == 0U)
 8006ec4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006ec6:	6822      	ldr	r2, [r4, #0]
 8006ec8:	b29b      	uxth	r3, r3
 8006eca:	2b00      	cmp	r3, #0
 8006ecc:	d15e      	bne.n	8006f8c <I2C_Slave_ISR_IT+0xf0>
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
 8006ece:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
 8006ed2:	2928      	cmp	r1, #40	; 0x28
 8006ed4:	d102      	bne.n	8006edc <I2C_Slave_ISR_IT+0x40>
 8006ed6:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
 8006eda:	d07a      	beq.n	8006fd2 <I2C_Slave_ISR_IT+0x136>
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 8006edc:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006ee0:	2b29      	cmp	r3, #41	; 0x29
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8006ee2:	f04f 0310 	mov.w	r3, #16
 8006ee6:	61d3      	str	r3, [r2, #28]
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 8006ee8:	d102      	bne.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
 8006eea:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
 8006eee:	d161      	bne.n	8006fb4 <I2C_Slave_ISR_IT+0x118>
  __HAL_UNLOCK(hi2c);
 8006ef0:	2000      	movs	r0, #0
 8006ef2:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 8006ef6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 8006ef8:	076a      	lsls	r2, r5, #29
 8006efa:	d40e      	bmi.n	8006f1a <I2C_Slave_ISR_IT+0x7e>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
 8006efc:	0728      	lsls	r0, r5, #28
 8006efe:	d52a      	bpl.n	8006f56 <I2C_Slave_ISR_IT+0xba>
 8006f00:	0731      	lsls	r1, r6, #28
 8006f02:	d528      	bpl.n	8006f56 <I2C_Slave_ISR_IT+0xba>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8006f04:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006f08:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8006f0c:	2b28      	cmp	r3, #40	; 0x28
 8006f0e:	f000 8090 	beq.w	8007032 <I2C_Slave_ISR_IT+0x196>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8006f12:	6823      	ldr	r3, [r4, #0]
 8006f14:	2208      	movs	r2, #8
 8006f16:	61da      	str	r2, [r3, #28]
 8006f18:	e7ea      	b.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 8006f1a:	0773      	lsls	r3, r6, #29
 8006f1c:	d5ee      	bpl.n	8006efc <I2C_Slave_ISR_IT+0x60>
    if (hi2c->XferCount > 0U)
 8006f1e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006f20:	b29b      	uxth	r3, r3
 8006f22:	b16b      	cbz	r3, 8006f40 <I2C_Slave_ISR_IT+0xa4>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8006f24:	6822      	ldr	r2, [r4, #0]
 8006f26:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006f28:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8006f2a:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
 8006f2c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
 8006f2e:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8006f30:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8006f32:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
 8006f34:	3101      	adds	r1, #1
      hi2c->XferCount--;
 8006f36:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8006f38:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
 8006f3a:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8006f3c:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8006f3e:	8522      	strh	r2, [r4, #40]	; 0x28
    if ((hi2c->XferCount == 0U) && \
 8006f40:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006f42:	b29b      	uxth	r3, r3
 8006f44:	2b00      	cmp	r3, #0
 8006f46:	d1d3      	bne.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
 8006f48:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
 8006f4c:	d0d0      	beq.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
        I2C_ITSlaveSeqCplt(hi2c);
 8006f4e:	4620      	mov	r0, r4
 8006f50:	f7ff fd6e 	bl	8006a30 <I2C_ITSlaveSeqCplt>
 8006f54:	e7cc      	b.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
 8006f56:	07aa      	lsls	r2, r5, #30
 8006f58:	d5ca      	bpl.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
 8006f5a:	07b3      	lsls	r3, r6, #30
 8006f5c:	d5c8      	bpl.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
    if (hi2c->XferCount > 0U)
 8006f5e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006f60:	b29b      	uxth	r3, r3
 8006f62:	b31b      	cbz	r3, 8006fac <I2C_Slave_ISR_IT+0x110>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8006f64:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006f66:	6823      	ldr	r3, [r4, #0]
 8006f68:	7812      	ldrb	r2, [r2, #0]
 8006f6a:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 8006f6c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
 8006f6e:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8006f70:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8006f72:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
 8006f74:	3101      	adds	r1, #1
      hi2c->XferCount--;
 8006f76:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8006f78:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
 8006f7a:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8006f7c:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8006f7e:	8522      	strh	r2, [r4, #40]	; 0x28
 8006f80:	e7b6      	b.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
 8006f82:	f7ff feb5 	bl	8006cf0 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8006f86:	06ea      	lsls	r2, r5, #27
 8006f88:	d5b6      	bpl.n	8006ef8 <I2C_Slave_ISR_IT+0x5c>
 8006f8a:	e799      	b.n	8006ec0 <I2C_Slave_ISR_IT+0x24>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8006f8c:	2310      	movs	r3, #16
 8006f8e:	61d3      	str	r3, [r2, #28]
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8006f90:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8006f92:	f043 0304 	orr.w	r3, r3, #4
 8006f96:	6463      	str	r3, [r4, #68]	; 0x44
      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 8006f98:	f037 7380 	bics.w	r3, r7, #16777216	; 0x1000000
 8006f9c:	d1a8      	bne.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
        I2C_ITError(hi2c, hi2c->ErrorCode);
 8006f9e:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8006fa0:	4620      	mov	r0, r4
 8006fa2:	f7ff fe03 	bl	8006bac <I2C_ITError>
 8006fa6:	e7a3      	b.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
  __HAL_LOCK(hi2c);
 8006fa8:	2002      	movs	r0, #2
}
 8006faa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
 8006fac:	f037 7380 	bics.w	r3, r7, #16777216	; 0x1000000
 8006fb0:	d19e      	bne.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
 8006fb2:	e7cc      	b.n	8006f4e <I2C_Slave_ISR_IT+0xb2>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8006fb4:	6823      	ldr	r3, [r4, #0]
 8006fb6:	699a      	ldr	r2, [r3, #24]
 8006fb8:	0790      	lsls	r0, r2, #30
 8006fba:	d502      	bpl.n	8006fc2 <I2C_Slave_ISR_IT+0x126>
    hi2c->Instance->TXDR = 0x00U;
 8006fbc:	2200      	movs	r2, #0
 8006fbe:	629a      	str	r2, [r3, #40]	; 0x28
 8006fc0:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8006fc2:	699a      	ldr	r2, [r3, #24]
 8006fc4:	07d1      	lsls	r1, r2, #31
 8006fc6:	d4c2      	bmi.n	8006f4e <I2C_Slave_ISR_IT+0xb2>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8006fc8:	699a      	ldr	r2, [r3, #24]
 8006fca:	f042 0201 	orr.w	r2, r2, #1
 8006fce:	619a      	str	r2, [r3, #24]
 8006fd0:	e7bd      	b.n	8006f4e <I2C_Slave_ISR_IT+0xb2>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8006fd2:	481b      	ldr	r0, [pc, #108]	; (8007040 <I2C_Slave_ISR_IT+0x1a4>)
  hi2c->State = HAL_I2C_STATE_READY;
 8006fd4:	2120      	movs	r1, #32
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8006fd6:	076d      	lsls	r5, r5, #29
  hi2c->XferISR = NULL;
 8006fd8:	6363      	str	r3, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8006fda:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
 8006fdc:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
 8006fde:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8006fe2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8006fe6:	d512      	bpl.n	800700e <I2C_Slave_ISR_IT+0x172>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8006fe8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006fea:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8006fec:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8006fee:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8006ff0:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
 8006ff2:	3301      	adds	r3, #1
 8006ff4:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8006ff6:	b301      	cbz	r1, 800703a <I2C_Slave_ISR_IT+0x19e>
      hi2c->XferCount--;
 8006ff8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8006ffa:	3901      	subs	r1, #1
 8006ffc:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount--;
 8006ffe:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8007000:	8521      	strh	r1, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007002:	b29b      	uxth	r3, r3
 8007004:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007006:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007008:	f043 0304 	orr.w	r3, r3, #4
 800700c:	6463      	str	r3, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800700e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007012:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007014:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
 8007018:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800701a:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
 800701c:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800701e:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8007022:	6013      	str	r3, [r2, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007024:	6823      	ldr	r3, [r4, #0]
 8007026:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
 8007028:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
 800702c:	f7ff fd92 	bl	8006b54 <HAL_I2C_ListenCpltCallback>
 8007030:	e75e      	b.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
 8007032:	4620      	mov	r0, r4
 8007034:	f7ff fd52 	bl	8006adc <I2C_ITAddrCplt.isra.9.part.10>
 8007038:	e75a      	b.n	8006ef0 <I2C_Slave_ISR_IT+0x54>
 800703a:	6822      	ldr	r2, [r4, #0]
 800703c:	e7e7      	b.n	800700e <I2C_Slave_ISR_IT+0x172>
 800703e:	bf00      	nop
 8007040:	ffff0000 	.word	0xffff0000

08007044 <I2C_Slave_ISR_DMA>:
{
 8007044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
 8007046:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
 800704a:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
 800704c:	2b01      	cmp	r3, #1
 800704e:	f000 80b0 	beq.w	80071b2 <I2C_Slave_ISR_DMA+0x16e>
 8007052:	4615      	mov	r5, r2
 8007054:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8007056:	068a      	lsls	r2, r1, #26
 8007058:	4604      	mov	r4, r0
 800705a:	460e      	mov	r6, r1
  __HAL_LOCK(hi2c);
 800705c:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8007060:	d502      	bpl.n	8007068 <I2C_Slave_ISR_DMA+0x24>
 8007062:	06ab      	lsls	r3, r5, #26
 8007064:	f100 8081 	bmi.w	800716a <I2C_Slave_ISR_DMA+0x126>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8007068:	06f1      	lsls	r1, r6, #27
 800706a:	d56d      	bpl.n	8007148 <I2C_Slave_ISR_DMA+0x104>
 800706c:	06ea      	lsls	r2, r5, #27
 800706e:	d56b      	bpl.n	8007148 <I2C_Slave_ISR_DMA+0x104>
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
 8007070:	0bab      	lsrs	r3, r5, #14
 8007072:	6822      	ldr	r2, [r4, #0]
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
 8007074:	0bed      	lsrs	r5, r5, #15
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
 8007076:	f003 0001 	and.w	r0, r3, #1
 800707a:	432b      	orrs	r3, r5
 800707c:	07db      	lsls	r3, r3, #31
 800707e:	d579      	bpl.n	8007174 <I2C_Slave_ISR_DMA+0x130>
 8007080:	e9d4 130e 	ldrd	r1, r3, [r4, #56]	; 0x38
      if (hi2c->hdmarx != NULL)
 8007084:	b1bb      	cbz	r3, 80070b6 <I2C_Slave_ISR_DMA+0x72>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
 8007086:	07ed      	lsls	r5, r5, #31
 8007088:	d515      	bpl.n	80070b6 <I2C_Slave_ISR_DMA+0x72>
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
 800708a:	f8df e180 	ldr.w	lr, [pc, #384]	; 800720c <I2C_Slave_ISR_DMA+0x1c8>
 800708e:	681d      	ldr	r5, [r3, #0]
 8007090:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8007094:	686b      	ldr	r3, [r5, #4]
 8007096:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 800709a:	fab3 f383 	clz	r3, r3
 800709e:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 80070a2:	095b      	lsrs	r3, r3, #5
 80070a4:	f50e 7e5c 	add.w	lr, lr, #880	; 0x370
 80070a8:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 80070ac:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 80070b0:	2b00      	cmp	r3, #0
 80070b2:	f040 809a 	bne.w	80071ea <I2C_Slave_ISR_DMA+0x1a6>
      if (hi2c->hdmatx != NULL)
 80070b6:	2900      	cmp	r1, #0
 80070b8:	d07f      	beq.n	80071ba <I2C_Slave_ISR_DMA+0x176>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
 80070ba:	2800      	cmp	r0, #0
 80070bc:	d07d      	beq.n	80071ba <I2C_Slave_ISR_DMA+0x176>
 80070be:	2000      	movs	r0, #0
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
 80070c0:	6809      	ldr	r1, [r1, #0]
 80070c2:	684b      	ldr	r3, [r1, #4]
 80070c4:	fab3 f383 	clz	r3, r3
 80070c8:	095b      	lsrs	r3, r3, #5
 80070ca:	2b00      	cmp	r3, #0
 80070cc:	d073      	beq.n	80071b6 <I2C_Slave_ISR_DMA+0x172>
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
 80070ce:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80070d2:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
 80070d6:	b2db      	uxtb	r3, r3
 80070d8:	d14f      	bne.n	800717a <I2C_Slave_ISR_DMA+0x136>
 80070da:	2b28      	cmp	r3, #40	; 0x28
 80070dc:	d14d      	bne.n	800717a <I2C_Slave_ISR_DMA+0x136>
  hi2c->PreviousState = I2C_STATE_NONE;
 80070de:	2300      	movs	r3, #0
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80070e0:	4849      	ldr	r0, [pc, #292]	; (8007208 <I2C_Slave_ISR_DMA+0x1c4>)
  hi2c->State = HAL_I2C_STATE_READY;
 80070e2:	2120      	movs	r1, #32
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 80070e4:	0775      	lsls	r5, r6, #29
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80070e6:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->XferISR = NULL;
 80070e8:	6363      	str	r3, [r4, #52]	; 0x34
  hi2c->PreviousState = I2C_STATE_NONE;
 80070ea:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
 80070ec:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80070f0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 80070f4:	d513      	bpl.n	800711e <I2C_Slave_ISR_DMA+0xda>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 80070f6:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80070f8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80070fa:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 80070fc:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 80070fe:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
 8007100:	3301      	adds	r3, #1
 8007102:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8007104:	2a00      	cmp	r2, #0
 8007106:	d07c      	beq.n	8007202 <I2C_Slave_ISR_DMA+0x1be>
      hi2c->XferCount--;
 8007108:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 800710a:	1e53      	subs	r3, r2, #1
 800710c:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount--;
 800710e:	3901      	subs	r1, #1
      hi2c->XferSize--;
 8007110:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007112:	b28b      	uxth	r3, r1
 8007114:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007116:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007118:	f043 0304 	orr.w	r3, r3, #4
 800711c:	6463      	str	r3, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800711e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007122:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007124:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
 8007128:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800712a:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
 800712c:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800712e:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8007132:	6013      	str	r3, [r2, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007134:	6823      	ldr	r3, [r4, #0]
 8007136:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
 8007138:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
 800713c:	f7ff fd0a 	bl	8006b54 <HAL_I2C_ListenCpltCallback>
  __HAL_UNLOCK(hi2c);
 8007140:	2000      	movs	r0, #0
 8007142:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 8007146:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
 8007148:	0732      	lsls	r2, r6, #28
 800714a:	d5f9      	bpl.n	8007140 <I2C_Slave_ISR_DMA+0xfc>
 800714c:	072b      	lsls	r3, r5, #28
 800714e:	d5f7      	bpl.n	8007140 <I2C_Slave_ISR_DMA+0xfc>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8007150:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007154:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8007158:	2b28      	cmp	r3, #40	; 0x28
 800715a:	d04e      	beq.n	80071fa <I2C_Slave_ISR_DMA+0x1b6>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 800715c:	6823      	ldr	r3, [r4, #0]
 800715e:	2208      	movs	r2, #8
  __HAL_UNLOCK(hi2c);
 8007160:	2000      	movs	r0, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8007162:	61da      	str	r2, [r3, #28]
  __HAL_UNLOCK(hi2c);
 8007164:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
 8007168:	e7ed      	b.n	8007146 <I2C_Slave_ISR_DMA+0x102>
    I2C_ITSlaveCplt(hi2c, ITFlags);
 800716a:	f7ff fdc1 	bl	8006cf0 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 800716e:	06f1      	lsls	r1, r6, #27
 8007170:	d5ea      	bpl.n	8007148 <I2C_Slave_ISR_DMA+0x104>
 8007172:	e77b      	b.n	800706c <I2C_Slave_ISR_DMA+0x28>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007174:	2310      	movs	r3, #16
 8007176:	61d3      	str	r3, [r2, #28]
 8007178:	e7e2      	b.n	8007140 <I2C_Slave_ISR_DMA+0xfc>
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 800717a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800717e:	2b29      	cmp	r3, #41	; 0x29
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007180:	f04f 0310 	mov.w	r3, #16
 8007184:	61d3      	str	r3, [r2, #28]
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 8007186:	d1db      	bne.n	8007140 <I2C_Slave_ISR_DMA+0xfc>
 8007188:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
 800718c:	d0d8      	beq.n	8007140 <I2C_Slave_ISR_DMA+0xfc>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 800718e:	6823      	ldr	r3, [r4, #0]
 8007190:	699a      	ldr	r2, [r3, #24]
 8007192:	0790      	lsls	r0, r2, #30
 8007194:	d502      	bpl.n	800719c <I2C_Slave_ISR_DMA+0x158>
    hi2c->Instance->TXDR = 0x00U;
 8007196:	2200      	movs	r2, #0
 8007198:	629a      	str	r2, [r3, #40]	; 0x28
 800719a:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800719c:	699a      	ldr	r2, [r3, #24]
 800719e:	07d1      	lsls	r1, r2, #31
 80071a0:	d403      	bmi.n	80071aa <I2C_Slave_ISR_DMA+0x166>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80071a2:	699a      	ldr	r2, [r3, #24]
 80071a4:	f042 0201 	orr.w	r2, r2, #1
 80071a8:	619a      	str	r2, [r3, #24]
          I2C_ITSlaveSeqCplt(hi2c);
 80071aa:	4620      	mov	r0, r4
 80071ac:	f7ff fc40 	bl	8006a30 <I2C_ITSlaveSeqCplt>
 80071b0:	e7c6      	b.n	8007140 <I2C_Slave_ISR_DMA+0xfc>
  __HAL_LOCK(hi2c);
 80071b2:	2002      	movs	r0, #2
}
 80071b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (treatdmanack == 1U)
 80071b6:	2800      	cmp	r0, #0
 80071b8:	d189      	bne.n	80070ce <I2C_Slave_ISR_DMA+0x8a>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80071ba:	2310      	movs	r3, #16
 80071bc:	61d3      	str	r3, [r2, #28]
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 80071be:	f037 7280 	bics.w	r2, r7, #16777216	; 0x1000000
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80071c2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80071c4:	f043 0304 	orr.w	r3, r3, #4
 80071c8:	6463      	str	r3, [r4, #68]	; 0x44
        tmpstate = hi2c->State;
 80071ca:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80071ce:	b2db      	uxtb	r3, r3
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 80071d0:	d1b6      	bne.n	8007140 <I2C_Slave_ISR_DMA+0xfc>
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
 80071d2:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
 80071d6:	2b21      	cmp	r3, #33	; 0x21
 80071d8:	d001      	beq.n	80071de <I2C_Slave_ISR_DMA+0x19a>
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
 80071da:	2b22      	cmp	r3, #34	; 0x22
 80071dc:	d100      	bne.n	80071e0 <I2C_Slave_ISR_DMA+0x19c>
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 80071de:	6323      	str	r3, [r4, #48]	; 0x30
          I2C_ITError(hi2c, hi2c->ErrorCode);
 80071e0:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80071e2:	4620      	mov	r0, r4
 80071e4:	f7ff fce2 	bl	8006bac <I2C_ITError>
 80071e8:	e7aa      	b.n	8007140 <I2C_Slave_ISR_DMA+0xfc>
      if (hi2c->hdmatx != NULL)
 80071ea:	2900      	cmp	r1, #0
 80071ec:	f43f af6f 	beq.w	80070ce <I2C_Slave_ISR_DMA+0x8a>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
 80071f0:	2800      	cmp	r0, #0
 80071f2:	f43f af6c 	beq.w	80070ce <I2C_Slave_ISR_DMA+0x8a>
            treatdmanack = 1U;
 80071f6:	2001      	movs	r0, #1
 80071f8:	e762      	b.n	80070c0 <I2C_Slave_ISR_DMA+0x7c>
 80071fa:	4620      	mov	r0, r4
 80071fc:	f7ff fc6e 	bl	8006adc <I2C_ITAddrCplt.isra.9.part.10>
 8007200:	e79e      	b.n	8007140 <I2C_Slave_ISR_DMA+0xfc>
 8007202:	6822      	ldr	r2, [r4, #0]
 8007204:	e78b      	b.n	800711e <I2C_Slave_ISR_DMA+0xda>
 8007206:	bf00      	nop
 8007208:	ffff0000 	.word	0xffff0000
 800720c:	40020028 	.word	0x40020028

08007210 <I2C_DMAMasterTransmitCplt>:
{
 8007210:	b510      	push	{r4, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8007212:	6b84      	ldr	r4, [r0, #56]	; 0x38
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8007214:	6822      	ldr	r2, [r4, #0]
 8007216:	6813      	ldr	r3, [r2, #0]
 8007218:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800721c:	6013      	str	r3, [r2, #0]
  if (hi2c->XferCount == 0U)
 800721e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007220:	b29b      	uxth	r3, r3
 8007222:	b963      	cbnz	r3, 800723e <I2C_DMAMasterTransmitCplt+0x2e>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8007224:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8007226:	4a1e      	ldr	r2, [pc, #120]	; (80072a0 <I2C_DMAMasterTransmitCplt+0x90>)
 8007228:	4293      	cmp	r3, r2
 800722a:	d02b      	beq.n	8007284 <I2C_DMAMasterTransmitCplt+0x74>
 800722c:	4a1d      	ldr	r2, [pc, #116]	; (80072a4 <I2C_DMAMasterTransmitCplt+0x94>)
 800722e:	4293      	cmp	r3, r2
 8007230:	d028      	beq.n	8007284 <I2C_DMAMasterTransmitCplt+0x74>
      tmpisr |= I2C_IT_STOPI;
 8007232:	2120      	movs	r1, #32
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 8007234:	6822      	ldr	r2, [r4, #0]
 8007236:	6813      	ldr	r3, [r2, #0]
 8007238:	430b      	orrs	r3, r1
 800723a:	6013      	str	r3, [r2, #0]
}
 800723c:	bd10      	pop	{r4, pc}
    hi2c->pBuffPtr += hi2c->XferSize;
 800723e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8007240:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8007242:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr += hi2c->XferSize;
 8007244:	4411      	add	r1, r2
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8007246:	2bff      	cmp	r3, #255	; 0xff
    hi2c->pBuffPtr += hi2c->XferSize;
 8007248:	6261      	str	r1, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800724a:	d818      	bhi.n	800727e <I2C_DMAMasterTransmitCplt+0x6e>
      hi2c->XferSize = hi2c->XferCount;
 800724c:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
 800724e:	b280      	uxth	r0, r0
 8007250:	4603      	mov	r3, r0
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
 8007252:	6822      	ldr	r2, [r4, #0]
 8007254:	8520      	strh	r0, [r4, #40]	; 0x28
 8007256:	3228      	adds	r2, #40	; 0x28
 8007258:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800725a:	f7fc f8d1 	bl	8003400 <HAL_DMA_Start_IT>
 800725e:	b9c8      	cbnz	r0, 8007294 <I2C_DMAMasterTransmitCplt+0x84>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8007260:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8007262:	4a10      	ldr	r2, [pc, #64]	; (80072a4 <I2C_DMAMasterTransmitCplt+0x94>)
 8007264:	4293      	cmp	r3, r2
 8007266:	d00f      	beq.n	8007288 <I2C_DMAMasterTransmitCplt+0x78>
 8007268:	4a0d      	ldr	r2, [pc, #52]	; (80072a0 <I2C_DMAMasterTransmitCplt+0x90>)
 800726a:	1a9b      	subs	r3, r3, r2
 800726c:	fab3 f383 	clz	r3, r3
 8007270:	095b      	lsrs	r3, r3, #5
 8007272:	b94b      	cbnz	r3, 8007288 <I2C_DMAMasterTransmitCplt+0x78>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 8007274:	6821      	ldr	r1, [r4, #0]
 8007276:	680a      	ldr	r2, [r1, #0]
 8007278:	4313      	orrs	r3, r2
 800727a:	600b      	str	r3, [r1, #0]
}
 800727c:	bd10      	pop	{r4, pc}
 800727e:	23ff      	movs	r3, #255	; 0xff
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007280:	4618      	mov	r0, r3
 8007282:	e7e6      	b.n	8007252 <I2C_DMAMasterTransmitCplt+0x42>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8007284:	2160      	movs	r1, #96	; 0x60
 8007286:	e7d5      	b.n	8007234 <I2C_DMAMasterTransmitCplt+0x24>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 8007288:	6821      	ldr	r1, [r4, #0]
      tmpisr |= I2C_IT_TCI;
 800728a:	2340      	movs	r3, #64	; 0x40
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 800728c:	680a      	ldr	r2, [r1, #0]
 800728e:	4313      	orrs	r3, r2
 8007290:	600b      	str	r3, [r1, #0]
 8007292:	e7f3      	b.n	800727c <I2C_DMAMasterTransmitCplt+0x6c>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
 8007294:	4620      	mov	r0, r4
 8007296:	2110      	movs	r1, #16
}
 8007298:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
 800729c:	f7ff bc86 	b.w	8006bac <I2C_ITError>
 80072a0:	08007045 	.word	0x08007045
 80072a4:	080077f1 	.word	0x080077f1

080072a8 <I2C_ITMasterCplt>:
{
 80072a8:	b570      	push	{r4, r5, r6, lr}
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80072aa:	2220      	movs	r2, #32
 80072ac:	6803      	ldr	r3, [r0, #0]
{
 80072ae:	4604      	mov	r4, r0
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80072b0:	61da      	str	r2, [r3, #28]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 80072b2:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80072b6:	2b21      	cmp	r3, #33	; 0x21
 80072b8:	f000 80a8 	beq.w	800740c <I2C_ITMasterCplt+0x164>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 80072bc:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80072c0:	2b22      	cmp	r3, #34	; 0x22
 80072c2:	f000 808d 	beq.w	80073e0 <I2C_ITMasterCplt+0x138>
  I2C_RESET_CR2(hi2c);
 80072c6:	6822      	ldr	r2, [r4, #0]
  hi2c->XferISR       = NULL;
 80072c8:	2500      	movs	r5, #0
  I2C_RESET_CR2(hi2c);
 80072ca:	4890      	ldr	r0, [pc, #576]	; (800750c <I2C_ITMasterCplt+0x264>)
 80072cc:	6853      	ldr	r3, [r2, #4]
 80072ce:	4003      	ands	r3, r0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 80072d0:	488f      	ldr	r0, [pc, #572]	; (8007510 <I2C_ITMasterCplt+0x268>)
  I2C_RESET_CR2(hi2c);
 80072d2:	6053      	str	r3, [r2, #4]
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
 80072d4:	06cb      	lsls	r3, r1, #27
  hi2c->XferISR       = NULL;
 80072d6:	6365      	str	r5, [r4, #52]	; 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 80072d8:	62e0      	str	r0, [r4, #44]	; 0x2c
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
 80072da:	d506      	bpl.n	80072ea <I2C_ITMasterCplt+0x42>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80072dc:	6823      	ldr	r3, [r4, #0]
 80072de:	2210      	movs	r2, #16
 80072e0:	61da      	str	r2, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80072e2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80072e4:	f043 0304 	orr.w	r3, r3, #4
 80072e8:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
 80072ea:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 80072ee:	6823      	ldr	r3, [r4, #0]
 80072f0:	2a60      	cmp	r2, #96	; 0x60
 80072f2:	f000 8086 	beq.w	8007402 <I2C_ITMasterCplt+0x15a>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80072f6:	699a      	ldr	r2, [r3, #24]
 80072f8:	0795      	lsls	r5, r2, #30
 80072fa:	d502      	bpl.n	8007302 <I2C_ITMasterCplt+0x5a>
    hi2c->Instance->TXDR = 0x00U;
 80072fc:	2200      	movs	r2, #0
 80072fe:	629a      	str	r2, [r3, #40]	; 0x28
 8007300:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8007302:	699a      	ldr	r2, [r3, #24]
 8007304:	07d0      	lsls	r0, r2, #31
 8007306:	d403      	bmi.n	8007310 <I2C_ITMasterCplt+0x68>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8007308:	699a      	ldr	r2, [r3, #24]
 800730a:	f042 0201 	orr.w	r2, r2, #1
 800730e:	619a      	str	r2, [r3, #24]
  tmperror = hi2c->ErrorCode;
 8007310:	6c63      	ldr	r3, [r4, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
 8007312:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8007316:	2a60      	cmp	r2, #96	; 0x60
 8007318:	d00d      	beq.n	8007336 <I2C_ITMasterCplt+0x8e>
 800731a:	3300      	adds	r3, #0
 800731c:	bf18      	it	ne
 800731e:	2301      	movne	r3, #1
 8007320:	b94b      	cbnz	r3, 8007336 <I2C_ITMasterCplt+0x8e>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8007322:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8007326:	2a21      	cmp	r2, #33	; 0x21
 8007328:	f000 80ce 	beq.w	80074c8 <I2C_ITMasterCplt+0x220>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 800732c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8007330:	2a22      	cmp	r2, #34	; 0x22
 8007332:	d07c      	beq.n	800742e <I2C_ITMasterCplt+0x186>
}
 8007334:	bd70      	pop	{r4, r5, r6, pc}
    I2C_ITError(hi2c, hi2c->ErrorCode);
 8007336:	6c62      	ldr	r2, [r4, #68]	; 0x44
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8007338:	2100      	movs	r1, #0
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 800733a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 800733e:	4874      	ldr	r0, [pc, #464]	; (8007510 <I2C_ITMasterCplt+0x268>)
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8007340:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007344:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8007346:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->XferCount     = 0U;
 8007348:	8561      	strh	r1, [r4, #42]	; 0x2a
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 800734a:	2b02      	cmp	r3, #2
  hi2c->ErrorCode |= ErrorCode;
 800734c:	6c60      	ldr	r0, [r4, #68]	; 0x44
 800734e:	6821      	ldr	r1, [r4, #0]
 8007350:	ea42 0200 	orr.w	r2, r2, r0
 8007354:	6462      	str	r2, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007356:	d831      	bhi.n	80073bc <I2C_ITMasterCplt+0x114>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007358:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 800735c:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800735e:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007362:	4032      	ands	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007364:	680b      	ldr	r3, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007366:	4030      	ands	r0, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8007368:	4d6a      	ldr	r5, [pc, #424]	; (8007514 <I2C_ITMasterCplt+0x26c>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800736a:	42b2      	cmp	r2, r6
 800736c:	bf14      	ite	ne
 800736e:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
 8007372:	f06f 0246 	mvneq.w	r2, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007376:	42b0      	cmp	r0, r6
 8007378:	bf18      	it	ne
 800737a:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800737e:	4013      	ands	r3, r2
 8007380:	600b      	str	r3, [r1, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8007382:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8007386:	6365      	str	r5, [r4, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8007388:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
 800738a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 800738c:	b118      	cbz	r0, 8007396 <I2C_ITMasterCplt+0xee>
 800738e:	2b11      	cmp	r3, #17
 8007390:	d05d      	beq.n	800744e <I2C_ITMasterCplt+0x1a6>
 8007392:	2b21      	cmp	r3, #33	; 0x21
 8007394:	d05b      	beq.n	800744e <I2C_ITMasterCplt+0x1a6>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
 8007396:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8007398:	b118      	cbz	r0, 80073a2 <I2C_ITMasterCplt+0xfa>
 800739a:	2b12      	cmp	r3, #18
 800739c:	d075      	beq.n	800748a <I2C_ITMasterCplt+0x1e2>
 800739e:	2b22      	cmp	r3, #34	; 0x22
 80073a0:	d073      	beq.n	800748a <I2C_ITMasterCplt+0x1e2>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 80073a2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80073a6:	2b60      	cmp	r3, #96	; 0x60
 80073a8:	f000 809e 	beq.w	80074e8 <I2C_ITMasterCplt+0x240>
    hi2c->PreviousState = I2C_STATE_NONE;
 80073ac:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
 80073ae:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
 80073b0:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 80073b2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 80073b6:	f7ff fbd3 	bl	8006b60 <HAL_I2C_ErrorCallback>
}
 80073ba:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80073bc:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80073c0:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80073c4:	680b      	ldr	r3, [r1, #0]
 80073c6:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 80073ca:	600b      	str	r3, [r1, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 80073cc:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80073d0:	2b60      	cmp	r3, #96	; 0x60
 80073d2:	d002      	beq.n	80073da <I2C_ITMasterCplt+0x132>
      hi2c->State         = HAL_I2C_STATE_READY;
 80073d4:	2320      	movs	r3, #32
 80073d6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 80073da:	2300      	movs	r3, #0
 80073dc:	6363      	str	r3, [r4, #52]	; 0x34
 80073de:	e7d3      	b.n	8007388 <I2C_ITMasterCplt+0xe0>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80073e0:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 80073e4:	2512      	movs	r5, #18
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80073e6:	6800      	ldr	r0, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80073e8:	f002 0228 	and.w	r2, r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80073ec:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80073ee:	2a28      	cmp	r2, #40	; 0x28
 80073f0:	bf14      	ite	ne
 80073f2:	f06f 02f4 	mvnne.w	r2, #244	; 0xf4
 80073f6:	f06f 0244 	mvneq.w	r2, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80073fa:	4013      	ands	r3, r2
 80073fc:	6003      	str	r3, [r0, #0]
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 80073fe:	6325      	str	r5, [r4, #48]	; 0x30
 8007400:	e761      	b.n	80072c6 <I2C_ITMasterCplt+0x1e>
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
 8007402:	074e      	lsls	r6, r1, #29
 8007404:	f57f af77 	bpl.w	80072f6 <I2C_ITMasterCplt+0x4e>
    tmp = (uint8_t)hi2c->Instance->RXDR;
 8007408:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800740a:	e774      	b.n	80072f6 <I2C_ITMasterCplt+0x4e>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800740c:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8007410:	2511      	movs	r5, #17
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007412:	6800      	ldr	r0, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007414:	f002 0228 	and.w	r2, r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007418:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800741a:	2a28      	cmp	r2, #40	; 0x28
 800741c:	bf14      	ite	ne
 800741e:	f06f 02f2 	mvnne.w	r2, #242	; 0xf2
 8007422:	f06f 0242 	mvneq.w	r2, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007426:	4013      	ands	r3, r2
 8007428:	6003      	str	r3, [r0, #0]
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 800742a:	6325      	str	r5, [r4, #48]	; 0x30
 800742c:	e74b      	b.n	80072c6 <I2C_ITMasterCplt+0x1e>
    hi2c->State = HAL_I2C_STATE_READY;
 800742e:	2220      	movs	r2, #32
      HAL_I2C_MemRxCpltCallback(hi2c);
 8007430:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
 8007432:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
 8007436:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 800743a:	6323      	str	r3, [r4, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 800743c:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8007440:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8007444:	2a40      	cmp	r2, #64	; 0x40
 8007446:	d05d      	beq.n	8007504 <I2C_ITMasterCplt+0x25c>
      HAL_I2C_MasterRxCpltCallback(hi2c);
 8007448:	f7ff faec 	bl	8006a24 <HAL_I2C_MasterRxCpltCallback>
}
 800744c:	bd70      	pop	{r4, r5, r6, pc}
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 800744e:	6823      	ldr	r3, [r4, #0]
 8007450:	681a      	ldr	r2, [r3, #0]
 8007452:	0451      	lsls	r1, r2, #17
 8007454:	d504      	bpl.n	8007460 <I2C_ITMasterCplt+0x1b8>
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8007456:	681a      	ldr	r2, [r3, #0]
 8007458:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800745c:	601a      	str	r2, [r3, #0]
 800745e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8007460:	f7fd fa20 	bl	80048a4 <HAL_DMA_GetState>
 8007464:	2801      	cmp	r0, #1
 8007466:	d09c      	beq.n	80073a2 <I2C_ITMasterCplt+0xfa>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8007468:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
 800746a:	2300      	movs	r3, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 800746c:	492a      	ldr	r1, [pc, #168]	; (8007518 <I2C_ITMasterCplt+0x270>)
 800746e:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8007470:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8007474:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8007476:	f7fc fcbd 	bl	8003df4 <HAL_DMA_Abort_IT>
 800747a:	2800      	cmp	r0, #0
 800747c:	f43f af5a 	beq.w	8007334 <I2C_ITMasterCplt+0x8c>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8007480:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
 8007482:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8007486:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8007488:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 800748a:	6823      	ldr	r3, [r4, #0]
 800748c:	681a      	ldr	r2, [r3, #0]
 800748e:	0412      	lsls	r2, r2, #16
 8007490:	d504      	bpl.n	800749c <I2C_ITMasterCplt+0x1f4>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8007492:	681a      	ldr	r2, [r3, #0]
 8007494:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007498:	601a      	str	r2, [r3, #0]
 800749a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 800749c:	f7fd fa02 	bl	80048a4 <HAL_DMA_GetState>
 80074a0:	2801      	cmp	r0, #1
 80074a2:	f43f af7e 	beq.w	80073a2 <I2C_ITMasterCplt+0xfa>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 80074a6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
 80074a8:	2300      	movs	r3, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 80074aa:	491b      	ldr	r1, [pc, #108]	; (8007518 <I2C_ITMasterCplt+0x270>)
 80074ac:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 80074ae:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 80074b2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80074b4:	f7fc fc9e 	bl	8003df4 <HAL_DMA_Abort_IT>
 80074b8:	2800      	cmp	r0, #0
 80074ba:	f43f af3b 	beq.w	8007334 <I2C_ITMasterCplt+0x8c>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 80074be:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
 80074c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 80074c4:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80074c6:	4718      	bx	r3
    hi2c->State = HAL_I2C_STATE_READY;
 80074c8:	2220      	movs	r2, #32
      HAL_I2C_MemTxCpltCallback(hi2c);
 80074ca:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
 80074cc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
 80074d0:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 80074d4:	6323      	str	r3, [r4, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 80074d6:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
 80074da:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 80074de:	2a40      	cmp	r2, #64	; 0x40
 80074e0:	d00d      	beq.n	80074fe <I2C_ITMasterCplt+0x256>
      HAL_I2C_MasterTxCpltCallback(hi2c);
 80074e2:	f7ff fa9d 	bl	8006a20 <HAL_I2C_MasterTxCpltCallback>
}
 80074e6:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
 80074e8:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 80074ea:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
 80074ec:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 80074ee:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 80074f2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 80074f6:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
 80074f8:	f7ff fb34 	bl	8006b64 <HAL_I2C_AbortCpltCallback>
}
 80074fc:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MemTxCpltCallback(hi2c);
 80074fe:	f7ff fb2b 	bl	8006b58 <HAL_I2C_MemTxCpltCallback>
}
 8007502:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MemRxCpltCallback(hi2c);
 8007504:	f7ff fb2a 	bl	8006b5c <HAL_I2C_MemRxCpltCallback>
}
 8007508:	bd70      	pop	{r4, r5, r6, pc}
 800750a:	bf00      	nop
 800750c:	fe00e800 	.word	0xfe00e800
 8007510:	ffff0000 	.word	0xffff0000
 8007514:	08006e9d 	.word	0x08006e9d
 8007518:	08006b69 	.word	0x08006b69

0800751c <I2C_Master_ISR_IT>:
  __HAL_LOCK(hi2c);
 800751c:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8007520:	2b01      	cmp	r3, #1
 8007522:	f000 80d8 	beq.w	80076d6 <I2C_Master_ISR_IT+0x1ba>
 8007526:	2301      	movs	r3, #1
{
 8007528:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 800752c:	06cf      	lsls	r7, r1, #27
{
 800752e:	b082      	sub	sp, #8
 8007530:	4604      	mov	r4, r0
 8007532:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
 8007534:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8007538:	d51e      	bpl.n	8007578 <I2C_Master_ISR_IT+0x5c>
 800753a:	06d6      	lsls	r6, r2, #27
 800753c:	d51c      	bpl.n	8007578 <I2C_Master_ISR_IT+0x5c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800753e:	6803      	ldr	r3, [r0, #0]
 8007540:	2110      	movs	r1, #16
 8007542:	61d9      	str	r1, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007544:	6c41      	ldr	r1, [r0, #68]	; 0x44
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007546:	6803      	ldr	r3, [r0, #0]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007548:	f041 0104 	orr.w	r1, r1, #4
 800754c:	6441      	str	r1, [r0, #68]	; 0x44
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 800754e:	6999      	ldr	r1, [r3, #24]
 8007550:	0788      	lsls	r0, r1, #30
 8007552:	d502      	bpl.n	800755a <I2C_Master_ISR_IT+0x3e>
    hi2c->Instance->TXDR = 0x00U;
 8007554:	2100      	movs	r1, #0
 8007556:	6299      	str	r1, [r3, #40]	; 0x28
 8007558:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800755a:	6999      	ldr	r1, [r3, #24]
 800755c:	07c9      	lsls	r1, r1, #31
 800755e:	f140 8087 	bpl.w	8007670 <I2C_Master_ISR_IT+0x154>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8007562:	06a9      	lsls	r1, r5, #26
 8007564:	d502      	bpl.n	800756c <I2C_Master_ISR_IT+0x50>
 8007566:	0693      	lsls	r3, r2, #26
 8007568:	f100 80b7 	bmi.w	80076da <I2C_Master_ISR_IT+0x1be>
  __HAL_UNLOCK(hi2c);
 800756c:	2000      	movs	r0, #0
 800756e:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 8007572:	b002      	add	sp, #8
 8007574:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 8007578:	076f      	lsls	r7, r5, #29
 800757a:	d408      	bmi.n	800758e <I2C_Master_ISR_IT+0x72>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
 800757c:	07a8      	lsls	r0, r5, #30
 800757e:	d519      	bpl.n	80075b4 <I2C_Master_ISR_IT+0x98>
 8007580:	0791      	lsls	r1, r2, #30
 8007582:	d517      	bpl.n	80075b4 <I2C_Master_ISR_IT+0x98>
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8007584:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8007586:	6823      	ldr	r3, [r4, #0]
 8007588:	7809      	ldrb	r1, [r1, #0]
 800758a:	6299      	str	r1, [r3, #40]	; 0x28
 800758c:	e007      	b.n	800759e <I2C_Master_ISR_IT+0x82>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 800758e:	0756      	lsls	r6, r2, #29
 8007590:	d5f4      	bpl.n	800757c <I2C_Master_ISR_IT+0x60>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8007592:	6821      	ldr	r1, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
 8007594:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8007598:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800759a:	6a49      	ldr	r1, [r1, #36]	; 0x24
 800759c:	7019      	strb	r1, [r3, #0]
    hi2c->XferCount--;
 800759e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr++;
 80075a0:	6a60      	ldr	r0, [r4, #36]	; 0x24
    hi2c->XferSize--;
 80075a2:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    hi2c->XferCount--;
 80075a4:	3b01      	subs	r3, #1
    hi2c->pBuffPtr++;
 80075a6:	3001      	adds	r0, #1
    hi2c->XferCount--;
 80075a8:	b29b      	uxth	r3, r3
    hi2c->XferSize--;
 80075aa:	3901      	subs	r1, #1
    hi2c->pBuffPtr++;
 80075ac:	6260      	str	r0, [r4, #36]	; 0x24
    hi2c->XferCount--;
 80075ae:	8563      	strh	r3, [r4, #42]	; 0x2a
    hi2c->XferSize--;
 80075b0:	8521      	strh	r1, [r4, #40]	; 0x28
    hi2c->XferCount--;
 80075b2:	e7d6      	b.n	8007562 <I2C_Master_ISR_IT+0x46>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
 80075b4:	062b      	lsls	r3, r5, #24
 80075b6:	d416      	bmi.n	80075e6 <I2C_Master_ISR_IT+0xca>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
 80075b8:	066e      	lsls	r6, r5, #25
 80075ba:	d5d2      	bpl.n	8007562 <I2C_Master_ISR_IT+0x46>
 80075bc:	0650      	lsls	r0, r2, #25
 80075be:	d5d0      	bpl.n	8007562 <I2C_Master_ISR_IT+0x46>
    if (hi2c->XferCount == 0U)
 80075c0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80075c2:	b29b      	uxth	r3, r3
 80075c4:	2b00      	cmp	r3, #0
 80075c6:	d17f      	bne.n	80076c8 <I2C_Master_ISR_IT+0x1ac>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
 80075c8:	6821      	ldr	r1, [r4, #0]
 80075ca:	684b      	ldr	r3, [r1, #4]
 80075cc:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
 80075d0:	d1c7      	bne.n	8007562 <I2C_Master_ISR_IT+0x46>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
 80075d2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80075d4:	f510 3f80 	cmn.w	r0, #65536	; 0x10000
 80075d8:	f040 80a2 	bne.w	8007720 <I2C_Master_ISR_IT+0x204>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
 80075dc:	684b      	ldr	r3, [r1, #4]
 80075de:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80075e2:	604b      	str	r3, [r1, #4]
 80075e4:	e7bd      	b.n	8007562 <I2C_Master_ISR_IT+0x46>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
 80075e6:	0657      	lsls	r7, r2, #25
 80075e8:	d5bb      	bpl.n	8007562 <I2C_Master_ISR_IT+0x46>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80075ea:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80075ec:	6821      	ldr	r1, [r4, #0]
 80075ee:	b29b      	uxth	r3, r3
 80075f0:	2b00      	cmp	r3, #0
 80075f2:	d042      	beq.n	800767a <I2C_Master_ISR_IT+0x15e>
 80075f4:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 80075f6:	2b00      	cmp	r3, #0
 80075f8:	d13f      	bne.n	800767a <I2C_Master_ISR_IT+0x15e>
 80075fa:	4b76      	ldr	r3, [pc, #472]	; (80077d4 <I2C_Master_ISR_IT+0x2b8>)
 80075fc:	4e76      	ldr	r6, [pc, #472]	; (80077d8 <I2C_Master_ISR_IT+0x2bc>)
 80075fe:	4877      	ldr	r0, [pc, #476]	; (80077dc <I2C_Master_ISR_IT+0x2c0>)
 8007600:	4299      	cmp	r1, r3
 8007602:	bf18      	it	ne
 8007604:	42b1      	cmpne	r1, r6
 8007606:	4f76      	ldr	r7, [pc, #472]	; (80077e0 <I2C_Master_ISR_IT+0x2c4>)
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
 8007608:	684e      	ldr	r6, [r1, #4]
 800760a:	bf14      	ite	ne
 800760c:	2301      	movne	r3, #1
 800760e:	2300      	moveq	r3, #0
 8007610:	f3c6 0609 	ubfx	r6, r6, #0, #10
 8007614:	4281      	cmp	r1, r0
 8007616:	bf0c      	ite	eq
 8007618:	2300      	moveq	r3, #0
 800761a:	f003 0301 	andne.w	r3, r3, #1
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800761e:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
 8007620:	42b9      	cmp	r1, r7
 8007622:	bf0c      	ite	eq
 8007624:	2300      	moveq	r3, #0
 8007626:	f003 0301 	andne.w	r3, r3, #1
 800762a:	28ff      	cmp	r0, #255	; 0xff
 800762c:	f200 8099 	bhi.w	8007762 <I2C_Master_ISR_IT+0x246>
        hi2c->XferSize = hi2c->XferCount;
 8007630:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 8007632:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
        hi2c->XferSize = hi2c->XferCount;
 8007634:	b280      	uxth	r0, r0
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 8007636:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
        hi2c->XferSize = hi2c->XferCount;
 800763a:	8520      	strh	r0, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
 800763c:	b2c7      	uxtb	r7, r0
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 800763e:	f000 809b 	beq.w	8007778 <I2C_Master_ISR_IT+0x25c>
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
 8007642:	f8d4 802c 	ldr.w	r8, [r4, #44]	; 0x2c
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007646:	2b00      	cmp	r3, #0
 8007648:	f040 80a1 	bne.w	800778e <I2C_Master_ISR_IT+0x272>
  assert_param(IS_TRANSFER_MODE(Mode));
 800764c:	f038 7380 	bics.w	r3, r8, #16777216	; 0x1000000
 8007650:	d003      	beq.n	800765a <I2C_Master_ISR_IT+0x13e>
 8007652:	f1b8 7f00 	cmp.w	r8, #33554432	; 0x2000000
 8007656:	f040 80a2 	bne.w	800779e <I2C_Master_ISR_IT+0x282>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800765a:	6823      	ldr	r3, [r4, #0]
 800765c:	4961      	ldr	r1, [pc, #388]	; (80077e4 <I2C_Master_ISR_IT+0x2c8>)
 800765e:	6858      	ldr	r0, [r3, #4]
 8007660:	4008      	ands	r0, r1
 8007662:	ea40 0008 	orr.w	r0, r0, r8
 8007666:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 800766a:	4306      	orrs	r6, r0
 800766c:	605e      	str	r6, [r3, #4]
 800766e:	e778      	b.n	8007562 <I2C_Master_ISR_IT+0x46>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8007670:	6999      	ldr	r1, [r3, #24]
 8007672:	f041 0101 	orr.w	r1, r1, #1
 8007676:	6199      	str	r1, [r3, #24]
 8007678:	e773      	b.n	8007562 <I2C_Master_ISR_IT+0x46>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
 800767a:	684b      	ldr	r3, [r1, #4]
 800767c:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
 8007680:	d122      	bne.n	80076c8 <I2C_Master_ISR_IT+0x1ac>
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007682:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
 8007686:	2720      	movs	r7, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8007688:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
 800768c:	9201      	str	r2, [sp, #4]
 800768e:	2821      	cmp	r0, #33	; 0x21
 8007690:	d02d      	beq.n	80076ee <I2C_Master_ISR_IT+0x1d2>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8007692:	2612      	movs	r6, #18
    hi2c->State         = HAL_I2C_STATE_READY;
 8007694:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8007698:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
 800769a:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 800769c:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800769e:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80076a2:	f8d1 c000 	ldr.w	ip, [r1]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80076a6:	f007 0728 	and.w	r7, r7, #40	; 0x28
 80076aa:	2f28      	cmp	r7, #40	; 0x28
 80076ac:	bf14      	ite	ne
 80076ae:	f06f 06f4 	mvnne.w	r6, #244	; 0xf4
 80076b2:	f06f 0644 	mvneq.w	r6, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80076b6:	ea06 060c 	and.w	r6, r6, ip
 80076ba:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
 80076bc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
 80076c0:	f7ff f9b0 	bl	8006a24 <HAL_I2C_MasterRxCpltCallback>
 80076c4:	9a01      	ldr	r2, [sp, #4]
 80076c6:	e74c      	b.n	8007562 <I2C_Master_ISR_IT+0x46>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
 80076c8:	2140      	movs	r1, #64	; 0x40
 80076ca:	4620      	mov	r0, r4
 80076cc:	9201      	str	r2, [sp, #4]
 80076ce:	f7ff fa6d 	bl	8006bac <I2C_ITError>
 80076d2:	9a01      	ldr	r2, [sp, #4]
 80076d4:	e745      	b.n	8007562 <I2C_Master_ISR_IT+0x46>
  __HAL_LOCK(hi2c);
 80076d6:	2002      	movs	r0, #2
}
 80076d8:	4770      	bx	lr
    I2C_ITMasterCplt(hi2c, tmpITFlags);
 80076da:	4620      	mov	r0, r4
 80076dc:	4629      	mov	r1, r5
 80076de:	f7ff fde3 	bl	80072a8 <I2C_ITMasterCplt>
  __HAL_UNLOCK(hi2c);
 80076e2:	2000      	movs	r0, #0
 80076e4:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 80076e8:	b002      	add	sp, #8
 80076ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 80076ee:	2611      	movs	r6, #17
    hi2c->State         = HAL_I2C_STATE_READY;
 80076f0:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 80076f4:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterTxCpltCallback(hi2c);
 80076f6:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 80076f8:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80076fa:	f894 6041 	ldrb.w	r6, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80076fe:	680f      	ldr	r7, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007700:	f006 0628 	and.w	r6, r6, #40	; 0x28
 8007704:	2e28      	cmp	r6, #40	; 0x28
 8007706:	bf14      	ite	ne
 8007708:	f06f 06f2 	mvnne.w	r6, #242	; 0xf2
 800770c:	f06f 0642 	mvneq.w	r6, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007710:	403e      	ands	r6, r7
 8007712:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
 8007714:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
 8007718:	f7ff f982 	bl	8006a20 <HAL_I2C_MasterTxCpltCallback>
 800771c:	9a01      	ldr	r2, [sp, #4]
 800771e:	e720      	b.n	8007562 <I2C_Master_ISR_IT+0x46>
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007720:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
 8007724:	2720      	movs	r7, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8007726:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
 800772a:	9201      	str	r2, [sp, #4]
 800772c:	2821      	cmp	r0, #33	; 0x21
 800772e:	d0de      	beq.n	80076ee <I2C_Master_ISR_IT+0x1d2>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8007730:	2612      	movs	r6, #18
    hi2c->State         = HAL_I2C_STATE_READY;
 8007732:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8007736:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
 8007738:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 800773a:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800773c:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007740:	680e      	ldr	r6, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007742:	f007 0728 	and.w	r7, r7, #40	; 0x28
 8007746:	2f28      	cmp	r7, #40	; 0x28
 8007748:	bf14      	ite	ne
 800774a:	f06f 07f4 	mvnne.w	r7, #244	; 0xf4
 800774e:	f06f 0744 	mvneq.w	r7, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007752:	403e      	ands	r6, r7
 8007754:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
 8007756:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
 800775a:	f7ff f963 	bl	8006a24 <HAL_I2C_MasterRxCpltCallback>
 800775e:	9a01      	ldr	r2, [sp, #4]
 8007760:	e6ff      	b.n	8007562 <I2C_Master_ISR_IT+0x46>
        hi2c->XferSize = MAX_NBYTE_SIZE;
 8007762:	20ff      	movs	r0, #255	; 0xff
 8007764:	8520      	strh	r0, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007766:	bb13      	cbnz	r3, 80077ae <I2C_Master_ISR_IT+0x292>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8007768:	684b      	ldr	r3, [r1, #4]
 800776a:	4f1e      	ldr	r7, [pc, #120]	; (80077e4 <I2C_Master_ISR_IT+0x2c8>)
 800776c:	481e      	ldr	r0, [pc, #120]	; (80077e8 <I2C_Master_ISR_IT+0x2cc>)
 800776e:	403b      	ands	r3, r7
 8007770:	4330      	orrs	r0, r6
 8007772:	4303      	orrs	r3, r0
 8007774:	604b      	str	r3, [r1, #4]
 8007776:	e6f4      	b.n	8007562 <I2C_Master_ISR_IT+0x46>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007778:	bb13      	cbnz	r3, 80077c0 <I2C_Master_ISR_IT+0x2a4>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800777a:	ea46 4307 	orr.w	r3, r6, r7, lsl #16
 800777e:	6848      	ldr	r0, [r1, #4]
 8007780:	4e18      	ldr	r6, [pc, #96]	; (80077e4 <I2C_Master_ISR_IT+0x2c8>)
 8007782:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8007786:	4030      	ands	r0, r6
 8007788:	4303      	orrs	r3, r0
 800778a:	604b      	str	r3, [r1, #4]
 800778c:	e6e9      	b.n	8007562 <I2C_Master_ISR_IT+0x46>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800778e:	f641 1131 	movw	r1, #6449	; 0x1931
 8007792:	4816      	ldr	r0, [pc, #88]	; (80077ec <I2C_Master_ISR_IT+0x2d0>)
 8007794:	9201      	str	r2, [sp, #4]
 8007796:	f00c f89b 	bl	80138d0 <assert_failed>
 800779a:	9a01      	ldr	r2, [sp, #4]
 800779c:	e756      	b.n	800764c <I2C_Master_ISR_IT+0x130>
  assert_param(IS_TRANSFER_MODE(Mode));
 800779e:	f641 1132 	movw	r1, #6450	; 0x1932
 80077a2:	4812      	ldr	r0, [pc, #72]	; (80077ec <I2C_Master_ISR_IT+0x2d0>)
 80077a4:	9201      	str	r2, [sp, #4]
 80077a6:	f00c f893 	bl	80138d0 <assert_failed>
 80077aa:	9a01      	ldr	r2, [sp, #4]
 80077ac:	e755      	b.n	800765a <I2C_Master_ISR_IT+0x13e>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80077ae:	f641 1131 	movw	r1, #6449	; 0x1931
 80077b2:	480e      	ldr	r0, [pc, #56]	; (80077ec <I2C_Master_ISR_IT+0x2d0>)
 80077b4:	9201      	str	r2, [sp, #4]
 80077b6:	f00c f88b 	bl	80138d0 <assert_failed>
 80077ba:	6821      	ldr	r1, [r4, #0]
 80077bc:	9a01      	ldr	r2, [sp, #4]
 80077be:	e7d3      	b.n	8007768 <I2C_Master_ISR_IT+0x24c>
 80077c0:	f641 1131 	movw	r1, #6449	; 0x1931
 80077c4:	4809      	ldr	r0, [pc, #36]	; (80077ec <I2C_Master_ISR_IT+0x2d0>)
 80077c6:	9201      	str	r2, [sp, #4]
 80077c8:	f00c f882 	bl	80138d0 <assert_failed>
 80077cc:	6821      	ldr	r1, [r4, #0]
 80077ce:	9a01      	ldr	r2, [sp, #4]
 80077d0:	e7d3      	b.n	800777a <I2C_Master_ISR_IT+0x25e>
 80077d2:	bf00      	nop
 80077d4:	40005400 	.word	0x40005400
 80077d8:	40005800 	.word	0x40005800
 80077dc:	40005c00 	.word	0x40005c00
 80077e0:	58001c00 	.word	0x58001c00
 80077e4:	fc009c00 	.word	0xfc009c00
 80077e8:	01ff0000 	.word	0x01ff0000
 80077ec:	0802929c 	.word	0x0802929c

080077f0 <I2C_Master_ISR_DMA>:
  __HAL_LOCK(hi2c);
 80077f0:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 80077f4:	2b01      	cmp	r3, #1
 80077f6:	f000 80a8 	beq.w	800794a <I2C_Master_ISR_DMA+0x15a>
 80077fa:	2301      	movs	r3, #1
{
 80077fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8007800:	06cd      	lsls	r5, r1, #27
 8007802:	4604      	mov	r4, r0
  __HAL_LOCK(hi2c);
 8007804:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8007808:	d529      	bpl.n	800785e <I2C_Master_ISR_DMA+0x6e>
 800780a:	06d0      	lsls	r0, r2, #27
 800780c:	d527      	bpl.n	800785e <I2C_Master_ISR_DMA+0x6e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800780e:	6823      	ldr	r3, [r4, #0]
 8007810:	2210      	movs	r2, #16
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8007812:	4998      	ldr	r1, [pc, #608]	; (8007a74 <I2C_Master_ISR_DMA+0x284>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007814:	61da      	str	r2, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007816:	6c63      	ldr	r3, [r4, #68]	; 0x44
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8007818:	6b62      	ldr	r2, [r4, #52]	; 0x34
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800781a:	f043 0304 	orr.w	r3, r3, #4
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 800781e:	428a      	cmp	r2, r1
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007820:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8007822:	f000 8090 	beq.w	8007946 <I2C_Master_ISR_DMA+0x156>
 8007826:	4b94      	ldr	r3, [pc, #592]	; (8007a78 <I2C_Master_ISR_DMA+0x288>)
 8007828:	429a      	cmp	r2, r3
 800782a:	f000 808c 	beq.w	8007946 <I2C_Master_ISR_DMA+0x156>
      tmpisr |= I2C_IT_STOPI;
 800782e:	2120      	movs	r1, #32
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 8007830:	6822      	ldr	r2, [r4, #0]
 8007832:	6813      	ldr	r3, [r2, #0]
 8007834:	430b      	orrs	r3, r1
 8007836:	6013      	str	r3, [r2, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007838:	6823      	ldr	r3, [r4, #0]
 800783a:	699a      	ldr	r2, [r3, #24]
 800783c:	0791      	lsls	r1, r2, #30
 800783e:	d502      	bpl.n	8007846 <I2C_Master_ISR_DMA+0x56>
    hi2c->Instance->TXDR = 0x00U;
 8007840:	2200      	movs	r2, #0
 8007842:	629a      	str	r2, [r3, #40]	; 0x28
 8007844:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8007846:	699a      	ldr	r2, [r3, #24]
 8007848:	07d2      	lsls	r2, r2, #31
 800784a:	d403      	bmi.n	8007854 <I2C_Master_ISR_DMA+0x64>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800784c:	699a      	ldr	r2, [r3, #24]
 800784e:	f042 0201 	orr.w	r2, r2, #1
 8007852:	619a      	str	r2, [r3, #24]
  __HAL_UNLOCK(hi2c);
 8007854:	2000      	movs	r0, #0
 8007856:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 800785a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
 800785e:	060f      	lsls	r7, r1, #24
 8007860:	d553      	bpl.n	800790a <I2C_Master_ISR_DMA+0x11a>
 8007862:	0656      	lsls	r6, r2, #25
 8007864:	d567      	bpl.n	8007936 <I2C_Master_ISR_DMA+0x146>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
 8007866:	6822      	ldr	r2, [r4, #0]
 8007868:	6813      	ldr	r3, [r2, #0]
 800786a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800786e:	6013      	str	r3, [r2, #0]
    if (hi2c->XferCount != 0U)
 8007870:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
 8007872:	6822      	ldr	r2, [r4, #0]
    if (hi2c->XferCount != 0U)
 8007874:	b29b      	uxth	r3, r3
 8007876:	2b00      	cmp	r3, #0
 8007878:	d069      	beq.n	800794e <I2C_Master_ISR_DMA+0x15e>
 800787a:	4980      	ldr	r1, [pc, #512]	; (8007a7c <I2C_Master_ISR_DMA+0x28c>)
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
 800787c:	4610      	mov	r0, r2
 800787e:	4e80      	ldr	r6, [pc, #512]	; (8007a80 <I2C_Master_ISR_DMA+0x290>)
 8007880:	6855      	ldr	r5, [r2, #4]
 8007882:	42b2      	cmp	r2, r6
 8007884:	bf18      	it	ne
 8007886:	428a      	cmpne	r2, r1
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8007888:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
 800788a:	f3c5 0609 	ubfx	r6, r5, #0, #10
 800788e:	bf14      	ite	ne
 8007890:	2101      	movne	r1, #1
 8007892:	2100      	moveq	r1, #0
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8007894:	2bff      	cmp	r3, #255	; 0xff
 8007896:	f200 8082 	bhi.w	800799e <I2C_Master_ISR_DMA+0x1ae>
        hi2c->XferSize = hi2c->XferCount;
 800789a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 800789c:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
        hi2c->XferSize = hi2c->XferCount;
 800789e:	b29b      	uxth	r3, r3
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 80078a0:	f515 3f80 	cmn.w	r5, #65536	; 0x10000
        hi2c->XferSize = hi2c->XferCount;
 80078a4:	8523      	strh	r3, [r4, #40]	; 0x28
 80078a6:	b2db      	uxtb	r3, r3
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 80078a8:	f000 80c6 	beq.w	8007a38 <I2C_Master_ISR_DMA+0x248>
          xfermode = hi2c->XferOptions;
 80078ac:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 80078ae:	041d      	lsls	r5, r3, #16
 80078b0:	f027 7880 	bic.w	r8, r7, #16777216	; 0x1000000
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80078b4:	2900      	cmp	r1, #0
 80078b6:	f040 80ca 	bne.w	8007a4e <I2C_Master_ISR_DMA+0x25e>
 80078ba:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
 80078be:	bf18      	it	ne
 80078c0:	f1b8 0f00 	cmpne.w	r8, #0
 80078c4:	bf14      	ite	ne
 80078c6:	f04f 0801 	movne.w	r8, #1
 80078ca:	f04f 0800 	moveq.w	r8, #0
  assert_param(IS_TRANSFER_MODE(Mode));
 80078ce:	f1b8 0f00 	cmp.w	r8, #0
 80078d2:	f040 80b5 	bne.w	8007a40 <I2C_Master_ISR_DMA+0x250>
 80078d6:	6822      	ldr	r2, [r4, #0]
 80078d8:	4610      	mov	r0, r2
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80078da:	6843      	ldr	r3, [r0, #4]
 80078dc:	433d      	orrs	r5, r7
 80078de:	4a69      	ldr	r2, [pc, #420]	; (8007a84 <I2C_Master_ISR_DMA+0x294>)
 80078e0:	4335      	orrs	r5, r6
 80078e2:	4013      	ands	r3, r2
 80078e4:	431d      	orrs	r5, r3
 80078e6:	6045      	str	r5, [r0, #4]
      hi2c->XferCount -= hi2c->XferSize;
 80078e8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80078ea:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 80078ec:	1a9b      	subs	r3, r3, r2
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
 80078ee:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount -= hi2c->XferSize;
 80078f0:	b29b      	uxth	r3, r3
 80078f2:	8563      	strh	r3, [r4, #42]	; 0x2a
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 80078f4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80078f8:	2b22      	cmp	r3, #34	; 0x22
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
 80078fa:	6813      	ldr	r3, [r2, #0]
 80078fc:	bf0c      	ite	eq
 80078fe:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
 8007902:	f443 4380 	orrne.w	r3, r3, #16384	; 0x4000
 8007906:	6013      	str	r3, [r2, #0]
 8007908:	e7a4      	b.n	8007854 <I2C_Master_ISR_DMA+0x64>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
 800790a:	064d      	lsls	r5, r1, #25
 800790c:	d513      	bpl.n	8007936 <I2C_Master_ISR_DMA+0x146>
 800790e:	0650      	lsls	r0, r2, #25
 8007910:	d511      	bpl.n	8007936 <I2C_Master_ISR_DMA+0x146>
    if (hi2c->XferCount == 0U)
 8007912:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007914:	b29b      	uxth	r3, r3
 8007916:	2b00      	cmp	r3, #0
 8007918:	d13c      	bne.n	8007994 <I2C_Master_ISR_DMA+0x1a4>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
 800791a:	6822      	ldr	r2, [r4, #0]
 800791c:	6853      	ldr	r3, [r2, #4]
 800791e:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
 8007922:	d197      	bne.n	8007854 <I2C_Master_ISR_DMA+0x64>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
 8007924:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8007926:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 800792a:	d166      	bne.n	80079fa <I2C_Master_ISR_DMA+0x20a>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
 800792c:	6853      	ldr	r3, [r2, #4]
 800792e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8007932:	6053      	str	r3, [r2, #4]
 8007934:	e78e      	b.n	8007854 <I2C_Master_ISR_DMA+0x64>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8007936:	068b      	lsls	r3, r1, #26
 8007938:	d58c      	bpl.n	8007854 <I2C_Master_ISR_DMA+0x64>
 800793a:	0692      	lsls	r2, r2, #26
 800793c:	d58a      	bpl.n	8007854 <I2C_Master_ISR_DMA+0x64>
    I2C_ITMasterCplt(hi2c, ITFlags);
 800793e:	4620      	mov	r0, r4
 8007940:	f7ff fcb2 	bl	80072a8 <I2C_ITMasterCplt>
 8007944:	e786      	b.n	8007854 <I2C_Master_ISR_DMA+0x64>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8007946:	2160      	movs	r1, #96	; 0x60
 8007948:	e772      	b.n	8007830 <I2C_Master_ISR_DMA+0x40>
  __HAL_LOCK(hi2c);
 800794a:	2002      	movs	r0, #2
}
 800794c:	4770      	bx	lr
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
 800794e:	6853      	ldr	r3, [r2, #4]
 8007950:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
 8007954:	d11e      	bne.n	8007994 <I2C_Master_ISR_DMA+0x1a4>
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007956:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
 800795a:	2520      	movs	r5, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 800795c:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
 8007960:	2921      	cmp	r1, #33	; 0x21
 8007962:	d032      	beq.n	80079ca <I2C_Master_ISR_DMA+0x1da>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8007964:	2112      	movs	r1, #18
    hi2c->State         = HAL_I2C_STATE_READY;
 8007966:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 800796a:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
 800796c:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 800796e:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007970:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007974:	6816      	ldr	r6, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007976:	f005 0528 	and.w	r5, r5, #40	; 0x28
 800797a:	2d28      	cmp	r5, #40	; 0x28
 800797c:	bf14      	ite	ne
 800797e:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
 8007982:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007986:	4031      	ands	r1, r6
 8007988:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
 800798a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
 800798e:	f7ff f849 	bl	8006a24 <HAL_I2C_MasterRxCpltCallback>
 8007992:	e75f      	b.n	8007854 <I2C_Master_ISR_DMA+0x64>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
 8007994:	2140      	movs	r1, #64	; 0x40
 8007996:	4620      	mov	r0, r4
 8007998:	f7ff f908 	bl	8006bac <I2C_ITError>
 800799c:	e75a      	b.n	8007854 <I2C_Master_ISR_DMA+0x64>
        hi2c->XferSize = MAX_NBYTE_SIZE;
 800799e:	23ff      	movs	r3, #255	; 0xff
 80079a0:	f44f 057f 	mov.w	r5, #16711680	; 0xff0000
        xfermode = I2C_RELOAD_MODE;
 80079a4:	f04f 7780 	mov.w	r7, #16777216	; 0x1000000
        hi2c->XferSize = MAX_NBYTE_SIZE;
 80079a8:	8523      	strh	r3, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80079aa:	2900      	cmp	r1, #0
 80079ac:	d095      	beq.n	80078da <I2C_Master_ISR_DMA+0xea>
 80079ae:	4b36      	ldr	r3, [pc, #216]	; (8007a88 <I2C_Master_ISR_DMA+0x298>)
 80079b0:	429a      	cmp	r2, r3
 80079b2:	d091      	beq.n	80078d8 <I2C_Master_ISR_DMA+0xe8>
 80079b4:	4b35      	ldr	r3, [pc, #212]	; (8007a8c <I2C_Master_ISR_DMA+0x29c>)
 80079b6:	429a      	cmp	r2, r3
 80079b8:	d08e      	beq.n	80078d8 <I2C_Master_ISR_DMA+0xe8>
 80079ba:	f04f 0800 	mov.w	r8, #0
 80079be:	f641 1131 	movw	r1, #6449	; 0x1931
 80079c2:	4833      	ldr	r0, [pc, #204]	; (8007a90 <I2C_Master_ISR_DMA+0x2a0>)
 80079c4:	f00b ff84 	bl	80138d0 <assert_failed>
 80079c8:	e781      	b.n	80078ce <I2C_Master_ISR_DMA+0xde>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 80079ca:	2111      	movs	r1, #17
    hi2c->State         = HAL_I2C_STATE_READY;
 80079cc:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 80079d0:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterTxCpltCallback(hi2c);
 80079d2:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 80079d4:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80079d6:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80079da:	6815      	ldr	r5, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80079dc:	f001 0128 	and.w	r1, r1, #40	; 0x28
 80079e0:	2928      	cmp	r1, #40	; 0x28
 80079e2:	bf14      	ite	ne
 80079e4:	f06f 01f2 	mvnne.w	r1, #242	; 0xf2
 80079e8:	f06f 0142 	mvneq.w	r1, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80079ec:	4029      	ands	r1, r5
 80079ee:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
 80079f0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
 80079f4:	f7ff f814 	bl	8006a20 <HAL_I2C_MasterTxCpltCallback>
 80079f8:	e72c      	b.n	8007854 <I2C_Master_ISR_DMA+0x64>
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80079fa:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
 80079fe:	2520      	movs	r5, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8007a00:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
 8007a04:	2921      	cmp	r1, #33	; 0x21
 8007a06:	d0e0      	beq.n	80079ca <I2C_Master_ISR_DMA+0x1da>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8007a08:	2112      	movs	r1, #18
    hi2c->State         = HAL_I2C_STATE_READY;
 8007a0a:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8007a0e:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
 8007a10:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8007a12:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007a14:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007a18:	6815      	ldr	r5, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007a1a:	f001 0128 	and.w	r1, r1, #40	; 0x28
 8007a1e:	2928      	cmp	r1, #40	; 0x28
 8007a20:	bf14      	ite	ne
 8007a22:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
 8007a26:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007a2a:	4029      	ands	r1, r5
 8007a2c:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
 8007a2e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
 8007a32:	f7fe fff7 	bl	8006a24 <HAL_I2C_MasterRxCpltCallback>
 8007a36:	e70d      	b.n	8007854 <I2C_Master_ISR_DMA+0x64>
          xfermode = I2C_AUTOEND_MODE;
 8007a38:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
 8007a3c:	041d      	lsls	r5, r3, #16
 8007a3e:	e7b4      	b.n	80079aa <I2C_Master_ISR_DMA+0x1ba>
  assert_param(IS_TRANSFER_MODE(Mode));
 8007a40:	4813      	ldr	r0, [pc, #76]	; (8007a90 <I2C_Master_ISR_DMA+0x2a0>)
 8007a42:	f641 1132 	movw	r1, #6450	; 0x1932
 8007a46:	f00b ff43 	bl	80138d0 <assert_failed>
 8007a4a:	6820      	ldr	r0, [r4, #0]
 8007a4c:	e745      	b.n	80078da <I2C_Master_ISR_DMA+0xea>
 8007a4e:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
 8007a52:	bf18      	it	ne
 8007a54:	f1b8 0f00 	cmpne.w	r8, #0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007a58:	4b0b      	ldr	r3, [pc, #44]	; (8007a88 <I2C_Master_ISR_DMA+0x298>)
 8007a5a:	bf14      	ite	ne
 8007a5c:	f04f 0801 	movne.w	r8, #1
 8007a60:	f04f 0800 	moveq.w	r8, #0
 8007a64:	429a      	cmp	r2, r3
 8007a66:	f43f af32 	beq.w	80078ce <I2C_Master_ISR_DMA+0xde>
 8007a6a:	4b08      	ldr	r3, [pc, #32]	; (8007a8c <I2C_Master_ISR_DMA+0x29c>)
 8007a6c:	429a      	cmp	r2, r3
 8007a6e:	d1a6      	bne.n	80079be <I2C_Master_ISR_DMA+0x1ce>
 8007a70:	e72d      	b.n	80078ce <I2C_Master_ISR_DMA+0xde>
 8007a72:	bf00      	nop
 8007a74:	08007045 	.word	0x08007045
 8007a78:	080077f1 	.word	0x080077f1
 8007a7c:	40005800 	.word	0x40005800
 8007a80:	40005400 	.word	0x40005400
 8007a84:	fc009c00 	.word	0xfc009c00
 8007a88:	58001c00 	.word	0x58001c00
 8007a8c:	40005c00 	.word	0x40005c00
 8007a90:	0802929c 	.word	0x0802929c

08007a94 <HAL_I2C_ER_IRQHandler>:
{
 8007a94:	b570      	push	{r4, r5, r6, lr}
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 8007a96:	6803      	ldr	r3, [r0, #0]
 8007a98:	699a      	ldr	r2, [r3, #24]
 8007a9a:	461e      	mov	r6, r3
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 8007a9c:	681c      	ldr	r4, [r3, #0]
 8007a9e:	f3c2 2180 	ubfx	r1, r2, #10, #1
 8007aa2:	f3c2 2540 	ubfx	r5, r2, #9, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8007aa6:	05d2      	lsls	r2, r2, #23
 8007aa8:	d518      	bpl.n	8007adc <HAL_I2C_ER_IRQHandler+0x48>
 8007aaa:	0622      	lsls	r2, r4, #24
 8007aac:	d51e      	bpl.n	8007aec <HAL_I2C_ER_IRQHandler+0x58>
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 8007aae:	6c42      	ldr	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8007ab0:	f44f 7480 	mov.w	r4, #256	; 0x100
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 8007ab4:	f042 0201 	orr.w	r2, r2, #1
 8007ab8:	6442      	str	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8007aba:	61dc      	str	r4, [r3, #28]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8007abc:	b139      	cbz	r1, 8007ace <HAL_I2C_ER_IRQHandler+0x3a>
 8007abe:	6803      	ldr	r3, [r0, #0]
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8007ac0:	6c42      	ldr	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8007ac2:	f44f 6180 	mov.w	r1, #1024	; 0x400
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8007ac6:	f042 0208 	orr.w	r2, r2, #8
 8007aca:	6442      	str	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8007acc:	61d9      	str	r1, [r3, #28]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8007ace:	2d00      	cmp	r5, #0
 8007ad0:	d151      	bne.n	8007b76 <HAL_I2C_ER_IRQHandler+0xe2>
  tmperror = hi2c->ErrorCode;
 8007ad2:	6c43      	ldr	r3, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 8007ad4:	f013 0f0b 	tst.w	r3, #11
 8007ad8:	d112      	bne.n	8007b00 <HAL_I2C_ER_IRQHandler+0x6c>
}
 8007ada:	bd70      	pop	{r4, r5, r6, pc}
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8007adc:	b141      	cbz	r1, 8007af0 <HAL_I2C_ER_IRQHandler+0x5c>
 8007ade:	0626      	lsls	r6, r4, #24
 8007ae0:	d4ee      	bmi.n	8007ac0 <HAL_I2C_ER_IRQHandler+0x2c>
  tmperror = hi2c->ErrorCode;
 8007ae2:	6c43      	ldr	r3, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 8007ae4:	f013 0f0b 	tst.w	r3, #11
 8007ae8:	d0f7      	beq.n	8007ada <HAL_I2C_ER_IRQHandler+0x46>
 8007aea:	e009      	b.n	8007b00 <HAL_I2C_ER_IRQHandler+0x6c>
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8007aec:	2900      	cmp	r1, #0
 8007aee:	d1f0      	bne.n	8007ad2 <HAL_I2C_ER_IRQHandler+0x3e>
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8007af0:	2d00      	cmp	r5, #0
 8007af2:	d0ee      	beq.n	8007ad2 <HAL_I2C_ER_IRQHandler+0x3e>
 8007af4:	0624      	lsls	r4, r4, #24
 8007af6:	d43f      	bmi.n	8007b78 <HAL_I2C_ER_IRQHandler+0xe4>
  tmperror = hi2c->ErrorCode;
 8007af8:	6c43      	ldr	r3, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 8007afa:	f013 0f0b 	tst.w	r3, #11
 8007afe:	d0ec      	beq.n	8007ada <HAL_I2C_ER_IRQHandler+0x46>
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8007b00:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8007b04:	2100      	movs	r1, #0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8007b06:	4c53      	ldr	r4, [pc, #332]	; (8007c54 <HAL_I2C_ER_IRQHandler+0x1c0>)
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8007b08:	f880 1042 	strb.w	r1, [r0, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007b0c:	3a28      	subs	r2, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8007b0e:	62c4      	str	r4, [r0, #44]	; 0x2c
  hi2c->XferCount     = 0U;
 8007b10:	8541      	strh	r1, [r0, #42]	; 0x2a
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007b12:	2a02      	cmp	r2, #2
  hi2c->ErrorCode |= ErrorCode;
 8007b14:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8007b16:	6801      	ldr	r1, [r0, #0]
 8007b18:	ea43 0304 	orr.w	r3, r3, r4
 8007b1c:	6443      	str	r3, [r0, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007b1e:	d937      	bls.n	8007b90 <HAL_I2C_ER_IRQHandler+0xfc>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007b20:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007b24:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007b28:	680b      	ldr	r3, [r1, #0]
 8007b2a:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8007b2e:	600b      	str	r3, [r1, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 8007b30:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8007b34:	2b60      	cmp	r3, #96	; 0x60
 8007b36:	d002      	beq.n	8007b3e <HAL_I2C_ER_IRQHandler+0xaa>
      hi2c->State         = HAL_I2C_STATE_READY;
 8007b38:	2320      	movs	r3, #32
 8007b3a:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8007b3e:	2300      	movs	r3, #0
 8007b40:	6343      	str	r3, [r0, #52]	; 0x34
 8007b42:	4604      	mov	r4, r0
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8007b44:	6b80      	ldr	r0, [r0, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
 8007b46:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8007b48:	b118      	cbz	r0, 8007b52 <HAL_I2C_ER_IRQHandler+0xbe>
 8007b4a:	2b11      	cmp	r3, #17
 8007b4c:	d039      	beq.n	8007bc2 <HAL_I2C_ER_IRQHandler+0x12e>
 8007b4e:	2b21      	cmp	r3, #33	; 0x21
 8007b50:	d037      	beq.n	8007bc2 <HAL_I2C_ER_IRQHandler+0x12e>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
 8007b52:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8007b54:	b118      	cbz	r0, 8007b5e <HAL_I2C_ER_IRQHandler+0xca>
 8007b56:	2b12      	cmp	r3, #18
 8007b58:	d051      	beq.n	8007bfe <HAL_I2C_ER_IRQHandler+0x16a>
 8007b5a:	2b22      	cmp	r3, #34	; 0x22
 8007b5c:	d04f      	beq.n	8007bfe <HAL_I2C_ER_IRQHandler+0x16a>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8007b5e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007b62:	2b60      	cmp	r3, #96	; 0x60
 8007b64:	d064      	beq.n	8007c30 <HAL_I2C_ER_IRQHandler+0x19c>
    hi2c->PreviousState = I2C_STATE_NONE;
 8007b66:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
 8007b68:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
 8007b6a:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8007b6c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 8007b70:	f7fe fff6 	bl	8006b60 <HAL_I2C_ErrorCallback>
}
 8007b74:	bd70      	pop	{r4, r5, r6, pc}
 8007b76:	6806      	ldr	r6, [r0, #0]
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 8007b78:	6c43      	ldr	r3, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8007b7a:	f44f 7200 	mov.w	r2, #512	; 0x200
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 8007b7e:	f043 0302 	orr.w	r3, r3, #2
 8007b82:	6443      	str	r3, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8007b84:	61f2      	str	r2, [r6, #28]
  tmperror = hi2c->ErrorCode;
 8007b86:	6c43      	ldr	r3, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 8007b88:	f013 0f0b 	tst.w	r3, #11
 8007b8c:	d0a5      	beq.n	8007ada <HAL_I2C_ER_IRQHandler+0x46>
 8007b8e:	e7b7      	b.n	8007b00 <HAL_I2C_ER_IRQHandler+0x6c>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007b90:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8007b94:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007b96:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007b9a:	4032      	ands	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007b9c:	680b      	ldr	r3, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007b9e:	4034      	ands	r4, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8007ba0:	4d2d      	ldr	r5, [pc, #180]	; (8007c58 <HAL_I2C_ER_IRQHandler+0x1c4>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007ba2:	42b2      	cmp	r2, r6
 8007ba4:	bf14      	ite	ne
 8007ba6:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
 8007baa:	f06f 0246 	mvneq.w	r2, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007bae:	42b4      	cmp	r4, r6
 8007bb0:	bf18      	it	ne
 8007bb2:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007bb6:	4013      	ands	r3, r2
 8007bb8:	600b      	str	r3, [r1, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8007bba:	f880 6041 	strb.w	r6, [r0, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8007bbe:	6345      	str	r5, [r0, #52]	; 0x34
 8007bc0:	e7bf      	b.n	8007b42 <HAL_I2C_ER_IRQHandler+0xae>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8007bc2:	6823      	ldr	r3, [r4, #0]
 8007bc4:	681a      	ldr	r2, [r3, #0]
 8007bc6:	0451      	lsls	r1, r2, #17
 8007bc8:	d504      	bpl.n	8007bd4 <HAL_I2C_ER_IRQHandler+0x140>
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8007bca:	681a      	ldr	r2, [r3, #0]
 8007bcc:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8007bd0:	601a      	str	r2, [r3, #0]
 8007bd2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8007bd4:	f7fc fe66 	bl	80048a4 <HAL_DMA_GetState>
 8007bd8:	2801      	cmp	r0, #1
 8007bda:	d0c0      	beq.n	8007b5e <HAL_I2C_ER_IRQHandler+0xca>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8007bdc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
 8007bde:	2300      	movs	r3, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8007be0:	491e      	ldr	r1, [pc, #120]	; (8007c5c <HAL_I2C_ER_IRQHandler+0x1c8>)
 8007be2:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8007be4:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8007be8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8007bea:	f7fc f903 	bl	8003df4 <HAL_DMA_Abort_IT>
 8007bee:	2800      	cmp	r0, #0
 8007bf0:	f43f af73 	beq.w	8007ada <HAL_I2C_ER_IRQHandler+0x46>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8007bf4:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
 8007bf6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8007bfa:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8007bfc:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 8007bfe:	6823      	ldr	r3, [r4, #0]
 8007c00:	681a      	ldr	r2, [r3, #0]
 8007c02:	0412      	lsls	r2, r2, #16
 8007c04:	d41f      	bmi.n	8007c46 <HAL_I2C_ER_IRQHandler+0x1b2>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8007c06:	f7fc fe4d 	bl	80048a4 <HAL_DMA_GetState>
 8007c0a:	2801      	cmp	r0, #1
 8007c0c:	d0a7      	beq.n	8007b5e <HAL_I2C_ER_IRQHandler+0xca>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8007c0e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
 8007c10:	2300      	movs	r3, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8007c12:	4912      	ldr	r1, [pc, #72]	; (8007c5c <HAL_I2C_ER_IRQHandler+0x1c8>)
 8007c14:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8007c16:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8007c1a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8007c1c:	f7fc f8ea 	bl	8003df4 <HAL_DMA_Abort_IT>
 8007c20:	2800      	cmp	r0, #0
 8007c22:	f43f af5a 	beq.w	8007ada <HAL_I2C_ER_IRQHandler+0x46>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8007c26:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
 8007c28:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8007c2c:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8007c2e:	4718      	bx	r3
    hi2c->PreviousState = I2C_STATE_NONE;
 8007c30:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8007c32:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
 8007c34:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 8007c36:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8007c3a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 8007c3e:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
 8007c40:	f7fe ff90 	bl	8006b64 <HAL_I2C_AbortCpltCallback>
}
 8007c44:	bd70      	pop	{r4, r5, r6, pc}
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8007c46:	681a      	ldr	r2, [r3, #0]
 8007c48:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007c4c:	601a      	str	r2, [r3, #0]
 8007c4e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8007c50:	e7d9      	b.n	8007c06 <HAL_I2C_ER_IRQHandler+0x172>
 8007c52:	bf00      	nop
 8007c54:	ffff0000 	.word	0xffff0000
 8007c58:	08006e9d 	.word	0x08006e9d
 8007c5c:	08006b69 	.word	0x08006b69

08007c60 <I2C_DMAError>:
{
 8007c60:	b570      	push	{r4, r5, r6, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8007c62:	6b85      	ldr	r5, [r0, #56]	; 0x38
  if (hi2c->hdmatx != NULL)
 8007c64:	6bac      	ldr	r4, [r5, #56]	; 0x38
 8007c66:	b124      	cbz	r4, 8007c72 <I2C_DMAError+0x12>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
 8007c68:	6822      	ldr	r2, [r4, #0]
 8007c6a:	6854      	ldr	r4, [r2, #4]
 8007c6c:	fab4 f484 	clz	r4, r4
 8007c70:	0964      	lsrs	r4, r4, #5
  if (hi2c->hdmarx != NULL)
 8007c72:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8007c74:	2b00      	cmp	r3, #0
 8007c76:	d049      	beq.n	8007d0c <I2C_DMAError+0xac>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
 8007c78:	681a      	ldr	r2, [r3, #0]
 8007c7a:	6853      	ldr	r3, [r2, #4]
 8007c7c:	fab3 f383 	clz	r3, r3
 8007c80:	095b      	lsrs	r3, r3, #5
 8007c82:	2b00      	cmp	r3, #0
 8007c84:	d042      	beq.n	8007d0c <I2C_DMAError+0xac>
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
 8007c86:	f7fc fe11 	bl	80048ac <HAL_DMA_GetError>
 8007c8a:	2802      	cmp	r0, #2
 8007c8c:	d03d      	beq.n	8007d0a <I2C_DMAError+0xaa>
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8007c8e:	6829      	ldr	r1, [r5, #0]
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8007c90:	2200      	movs	r2, #0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8007c92:	4852      	ldr	r0, [pc, #328]	; (8007ddc <I2C_DMAError+0x17c>)
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8007c94:	684b      	ldr	r3, [r1, #4]
 8007c96:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8007c9a:	604b      	str	r3, [r1, #4]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8007c9c:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8007ca0:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007ca4:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8007ca6:	62e8      	str	r0, [r5, #44]	; 0x2c
  hi2c->XferCount     = 0U;
 8007ca8:	856a      	strh	r2, [r5, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
 8007caa:	6c6a      	ldr	r2, [r5, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007cac:	2b02      	cmp	r3, #2
  hi2c->ErrorCode |= ErrorCode;
 8007cae:	f042 0210 	orr.w	r2, r2, #16
 8007cb2:	646a      	str	r2, [r5, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007cb4:	d931      	bls.n	8007d1a <I2C_DMAError+0xba>
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007cb6:	682a      	ldr	r2, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007cb8:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007cbc:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007cc0:	6813      	ldr	r3, [r2, #0]
 8007cc2:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8007cc6:	6013      	str	r3, [r2, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 8007cc8:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8007ccc:	2b60      	cmp	r3, #96	; 0x60
 8007cce:	d002      	beq.n	8007cd6 <I2C_DMAError+0x76>
      hi2c->State         = HAL_I2C_STATE_READY;
 8007cd0:	2320      	movs	r3, #32
 8007cd2:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8007cd6:	2300      	movs	r3, #0
 8007cd8:	636b      	str	r3, [r5, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8007cda:	6ba8      	ldr	r0, [r5, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
 8007cdc:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8007cde:	b118      	cbz	r0, 8007ce8 <I2C_DMAError+0x88>
 8007ce0:	2b11      	cmp	r3, #17
 8007ce2:	d034      	beq.n	8007d4e <I2C_DMAError+0xee>
 8007ce4:	2b21      	cmp	r3, #33	; 0x21
 8007ce6:	d032      	beq.n	8007d4e <I2C_DMAError+0xee>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
 8007ce8:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8007cea:	b118      	cbz	r0, 8007cf4 <I2C_DMAError+0x94>
 8007cec:	2b12      	cmp	r3, #18
 8007cee:	d046      	beq.n	8007d7e <I2C_DMAError+0x11e>
 8007cf0:	2b22      	cmp	r3, #34	; 0x22
 8007cf2:	d044      	beq.n	8007d7e <I2C_DMAError+0x11e>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8007cf4:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8007cf8:	2b60      	cmp	r3, #96	; 0x60
 8007cfa:	d063      	beq.n	8007dc4 <I2C_DMAError+0x164>
    hi2c->PreviousState = I2C_STATE_NONE;
 8007cfc:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
 8007cfe:	4628      	mov	r0, r5
    hi2c->PreviousState = I2C_STATE_NONE;
 8007d00:	632b      	str	r3, [r5, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8007d02:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 8007d06:	f7fe ff2b 	bl	8006b60 <HAL_I2C_ErrorCallback>
}
 8007d0a:	bd70      	pop	{r4, r5, r6, pc}
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
 8007d0c:	f7fc fdce 	bl	80048ac <HAL_DMA_GetError>
 8007d10:	2802      	cmp	r0, #2
 8007d12:	d0fa      	beq.n	8007d0a <I2C_DMAError+0xaa>
 8007d14:	07e0      	lsls	r0, r4, #31
 8007d16:	d4ba      	bmi.n	8007c8e <I2C_DMAError+0x2e>
}
 8007d18:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007d1a:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8007d1e:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007d20:	f895 1041 	ldrb.w	r1, [r5, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007d24:	4033      	ands	r3, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007d26:	6828      	ldr	r0, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007d28:	4031      	ands	r1, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8007d2a:	4c2d      	ldr	r4, [pc, #180]	; (8007de0 <I2C_DMAError+0x180>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007d2c:	42b3      	cmp	r3, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007d2e:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007d30:	bf14      	ite	ne
 8007d32:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
 8007d36:	f06f 0246 	mvneq.w	r2, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007d3a:	42b1      	cmp	r1, r6
 8007d3c:	bf18      	it	ne
 8007d3e:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007d42:	4013      	ands	r3, r2
 8007d44:	6003      	str	r3, [r0, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8007d46:	f885 6041 	strb.w	r6, [r5, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8007d4a:	636c      	str	r4, [r5, #52]	; 0x34
 8007d4c:	e7c5      	b.n	8007cda <I2C_DMAError+0x7a>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8007d4e:	682b      	ldr	r3, [r5, #0]
 8007d50:	681a      	ldr	r2, [r3, #0]
 8007d52:	0451      	lsls	r1, r2, #17
 8007d54:	d430      	bmi.n	8007db8 <I2C_DMAError+0x158>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8007d56:	f7fc fda5 	bl	80048a4 <HAL_DMA_GetState>
 8007d5a:	2801      	cmp	r0, #1
 8007d5c:	d0ca      	beq.n	8007cf4 <I2C_DMAError+0x94>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8007d5e:	6baa      	ldr	r2, [r5, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
 8007d60:	2300      	movs	r3, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8007d62:	4920      	ldr	r1, [pc, #128]	; (8007de4 <I2C_DMAError+0x184>)
 8007d64:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8007d66:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8007d6a:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8007d6c:	f7fc f842 	bl	8003df4 <HAL_DMA_Abort_IT>
 8007d70:	2800      	cmp	r0, #0
 8007d72:	d0ca      	beq.n	8007d0a <I2C_DMAError+0xaa>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8007d74:	6ba8      	ldr	r0, [r5, #56]	; 0x38
}
 8007d76:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8007d7a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8007d7c:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 8007d7e:	682b      	ldr	r3, [r5, #0]
 8007d80:	681a      	ldr	r2, [r3, #0]
 8007d82:	0412      	lsls	r2, r2, #16
 8007d84:	d504      	bpl.n	8007d90 <I2C_DMAError+0x130>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8007d86:	681a      	ldr	r2, [r3, #0]
 8007d88:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007d8c:	601a      	str	r2, [r3, #0]
 8007d8e:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8007d90:	f7fc fd88 	bl	80048a4 <HAL_DMA_GetState>
 8007d94:	2801      	cmp	r0, #1
 8007d96:	d0ad      	beq.n	8007cf4 <I2C_DMAError+0x94>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8007d98:	6bea      	ldr	r2, [r5, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
 8007d9a:	2300      	movs	r3, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8007d9c:	4911      	ldr	r1, [pc, #68]	; (8007de4 <I2C_DMAError+0x184>)
 8007d9e:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8007da0:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8007da4:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8007da6:	f7fc f825 	bl	8003df4 <HAL_DMA_Abort_IT>
 8007daa:	2800      	cmp	r0, #0
 8007dac:	d0ad      	beq.n	8007d0a <I2C_DMAError+0xaa>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8007dae:	6be8      	ldr	r0, [r5, #60]	; 0x3c
}
 8007db0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8007db4:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8007db6:	4718      	bx	r3
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8007db8:	681a      	ldr	r2, [r3, #0]
 8007dba:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8007dbe:	601a      	str	r2, [r3, #0]
 8007dc0:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8007dc2:	e7c8      	b.n	8007d56 <I2C_DMAError+0xf6>
    hi2c->PreviousState = I2C_STATE_NONE;
 8007dc4:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8007dc6:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
 8007dc8:	4628      	mov	r0, r5
    hi2c->State = HAL_I2C_STATE_READY;
 8007dca:	f885 2041 	strb.w	r2, [r5, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8007dce:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 8007dd2:	632b      	str	r3, [r5, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
 8007dd4:	f7fe fec6 	bl	8006b64 <HAL_I2C_AbortCpltCallback>
}
 8007dd8:	bd70      	pop	{r4, r5, r6, pc}
 8007dda:	bf00      	nop
 8007ddc:	ffff0000 	.word	0xffff0000
 8007de0:	08006e9d 	.word	0x08006e9d
 8007de4:	08006b69 	.word	0x08006b69

08007de8 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8007de8:	b570      	push	{r4, r5, r6, lr}
 8007dea:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007dec:	4b25      	ldr	r3, [pc, #148]	; (8007e84 <HAL_I2CEx_ConfigAnalogFilter+0x9c>)
 8007dee:	4826      	ldr	r0, [pc, #152]	; (8007e88 <HAL_I2CEx_ConfigAnalogFilter+0xa0>)
{
 8007df0:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007df2:	6822      	ldr	r2, [r4, #0]
 8007df4:	4925      	ldr	r1, [pc, #148]	; (8007e8c <HAL_I2CEx_ConfigAnalogFilter+0xa4>)
 8007df6:	429a      	cmp	r2, r3
 8007df8:	bf18      	it	ne
 8007dfa:	4282      	cmpne	r2, r0
 8007dfc:	bf14      	ite	ne
 8007dfe:	2301      	movne	r3, #1
 8007e00:	2300      	moveq	r3, #0
 8007e02:	428a      	cmp	r2, r1
 8007e04:	bf0c      	ite	eq
 8007e06:	2300      	moveq	r3, #0
 8007e08:	f003 0301 	andne.w	r3, r3, #1
 8007e0c:	b113      	cbz	r3, 8007e14 <HAL_I2CEx_ConfigAnalogFilter+0x2c>
 8007e0e:	4b20      	ldr	r3, [pc, #128]	; (8007e90 <HAL_I2CEx_ConfigAnalogFilter+0xa8>)
 8007e10:	429a      	cmp	r2, r3
 8007e12:	d132      	bne.n	8007e7a <HAL_I2CEx_ConfigAnalogFilter+0x92>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
 8007e14:	f435 5380 	bics.w	r3, r5, #4096	; 0x1000
 8007e18:	d12a      	bne.n	8007e70 <HAL_I2CEx_ConfigAnalogFilter+0x88>

  if (hi2c->State == HAL_I2C_STATE_READY)
 8007e1a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007e1e:	b2db      	uxtb	r3, r3
 8007e20:	2b20      	cmp	r3, #32
 8007e22:	d123      	bne.n	8007e6c <HAL_I2CEx_ConfigAnalogFilter+0x84>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8007e24:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8007e28:	2a01      	cmp	r2, #1
 8007e2a:	d01f      	beq.n	8007e6c <HAL_I2CEx_ConfigAnalogFilter+0x84>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8007e2c:	6826      	ldr	r6, [r4, #0]
    __HAL_LOCK(hi2c);
 8007e2e:	2101      	movs	r1, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
 8007e30:	2224      	movs	r2, #36	; 0x24
    __HAL_LOCK(hi2c);
 8007e32:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8007e36:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
 8007e38:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
 8007e3c:	6832      	ldr	r2, [r6, #0]

    return HAL_OK;
 8007e3e:	4608      	mov	r0, r1
    __HAL_I2C_DISABLE(hi2c);
 8007e40:	f022 0201 	bic.w	r2, r2, #1
 8007e44:	6032      	str	r2, [r6, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8007e46:	6826      	ldr	r6, [r4, #0]
 8007e48:	6832      	ldr	r2, [r6, #0]
 8007e4a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8007e4e:	6032      	str	r2, [r6, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
 8007e50:	6826      	ldr	r6, [r4, #0]
 8007e52:	6832      	ldr	r2, [r6, #0]
 8007e54:	4315      	orrs	r5, r2
 8007e56:	6035      	str	r5, [r6, #0]
    __HAL_I2C_ENABLE(hi2c);
 8007e58:	6825      	ldr	r5, [r4, #0]
 8007e5a:	682a      	ldr	r2, [r5, #0]
 8007e5c:	f042 0201 	orr.w	r2, r2, #1
 8007e60:	602a      	str	r2, [r5, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8007e62:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8007e66:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
 8007e6a:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 8007e6c:	2002      	movs	r0, #2
}
 8007e6e:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
 8007e70:	2165      	movs	r1, #101	; 0x65
 8007e72:	4808      	ldr	r0, [pc, #32]	; (8007e94 <HAL_I2CEx_ConfigAnalogFilter+0xac>)
 8007e74:	f00b fd2c 	bl	80138d0 <assert_failed>
 8007e78:	e7cf      	b.n	8007e1a <HAL_I2CEx_ConfigAnalogFilter+0x32>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007e7a:	2164      	movs	r1, #100	; 0x64
 8007e7c:	4805      	ldr	r0, [pc, #20]	; (8007e94 <HAL_I2CEx_ConfigAnalogFilter+0xac>)
 8007e7e:	f00b fd27 	bl	80138d0 <assert_failed>
 8007e82:	e7c7      	b.n	8007e14 <HAL_I2CEx_ConfigAnalogFilter+0x2c>
 8007e84:	40005400 	.word	0x40005400
 8007e88:	40005800 	.word	0x40005800
 8007e8c:	40005c00 	.word	0x40005c00
 8007e90:	58001c00 	.word	0x58001c00
 8007e94:	080292d4 	.word	0x080292d4

08007e98 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 8007e98:	b570      	push	{r4, r5, r6, lr}
 8007e9a:	4604      	mov	r4, r0
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007e9c:	4b24      	ldr	r3, [pc, #144]	; (8007f30 <HAL_I2CEx_ConfigDigitalFilter+0x98>)
 8007e9e:	4825      	ldr	r0, [pc, #148]	; (8007f34 <HAL_I2CEx_ConfigDigitalFilter+0x9c>)
{
 8007ea0:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007ea2:	6822      	ldr	r2, [r4, #0]
 8007ea4:	4924      	ldr	r1, [pc, #144]	; (8007f38 <HAL_I2CEx_ConfigDigitalFilter+0xa0>)
 8007ea6:	429a      	cmp	r2, r3
 8007ea8:	bf18      	it	ne
 8007eaa:	4282      	cmpne	r2, r0
 8007eac:	bf14      	ite	ne
 8007eae:	2301      	movne	r3, #1
 8007eb0:	2300      	moveq	r3, #0
 8007eb2:	428a      	cmp	r2, r1
 8007eb4:	bf0c      	ite	eq
 8007eb6:	2300      	moveq	r3, #0
 8007eb8:	f003 0301 	andne.w	r3, r3, #1
 8007ebc:	b113      	cbz	r3, 8007ec4 <HAL_I2CEx_ConfigDigitalFilter+0x2c>
 8007ebe:	4b1f      	ldr	r3, [pc, #124]	; (8007f3c <HAL_I2CEx_ConfigDigitalFilter+0xa4>)
 8007ec0:	429a      	cmp	r2, r3
 8007ec2:	d12f      	bne.n	8007f24 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
 8007ec4:	2d0f      	cmp	r5, #15
 8007ec6:	d828      	bhi.n	8007f1a <HAL_I2CEx_ConfigDigitalFilter+0x82>

  if (hi2c->State == HAL_I2C_STATE_READY)
 8007ec8:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007ecc:	b2db      	uxtb	r3, r3
 8007ece:	2b20      	cmp	r3, #32
 8007ed0:	d121      	bne.n	8007f16 <HAL_I2CEx_ConfigDigitalFilter+0x7e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8007ed2:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8007ed6:	2a01      	cmp	r2, #1
 8007ed8:	d01d      	beq.n	8007f16 <HAL_I2CEx_ConfigDigitalFilter+0x7e>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8007eda:	6821      	ldr	r1, [r4, #0]
    __HAL_LOCK(hi2c);
 8007edc:	2001      	movs	r0, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
 8007ede:	2224      	movs	r2, #36	; 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8007ee0:	2600      	movs	r6, #0
    __HAL_LOCK(hi2c);
 8007ee2:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_BUSY;
 8007ee6:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41

    return HAL_OK;
 8007eea:	4630      	mov	r0, r6
    __HAL_I2C_DISABLE(hi2c);
 8007eec:	680a      	ldr	r2, [r1, #0]
 8007eee:	f022 0201 	bic.w	r2, r2, #1
 8007ef2:	600a      	str	r2, [r1, #0]
    tmpreg = hi2c->Instance->CR1;
 8007ef4:	6822      	ldr	r2, [r4, #0]
 8007ef6:	6811      	ldr	r1, [r2, #0]
    tmpreg &= ~(I2C_CR1_DNF);
 8007ef8:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00
    tmpreg |= DigitalFilter << 8U;
 8007efc:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
    hi2c->Instance->CR1 = tmpreg;
 8007f00:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
 8007f02:	6821      	ldr	r1, [r4, #0]
 8007f04:	680a      	ldr	r2, [r1, #0]
 8007f06:	f042 0201 	orr.w	r2, r2, #1
 8007f0a:	600a      	str	r2, [r1, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8007f0c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8007f10:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
 8007f14:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 8007f16:	2002      	movs	r0, #2
}
 8007f18:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
 8007f1a:	2193      	movs	r1, #147	; 0x93
 8007f1c:	4808      	ldr	r0, [pc, #32]	; (8007f40 <HAL_I2CEx_ConfigDigitalFilter+0xa8>)
 8007f1e:	f00b fcd7 	bl	80138d0 <assert_failed>
 8007f22:	e7d1      	b.n	8007ec8 <HAL_I2CEx_ConfigDigitalFilter+0x30>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007f24:	2192      	movs	r1, #146	; 0x92
 8007f26:	4806      	ldr	r0, [pc, #24]	; (8007f40 <HAL_I2CEx_ConfigDigitalFilter+0xa8>)
 8007f28:	f00b fcd2 	bl	80138d0 <assert_failed>
 8007f2c:	e7ca      	b.n	8007ec4 <HAL_I2CEx_ConfigDigitalFilter+0x2c>
 8007f2e:	bf00      	nop
 8007f30:	40005400 	.word	0x40005400
 8007f34:	40005800 	.word	0x40005800
 8007f38:	40005c00 	.word	0x40005c00
 8007f3c:	58001c00 	.word	0x58001c00
 8007f40:	080292d4 	.word	0x080292d4

08007f44 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 8007f44:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));
 8007f46:	1e43      	subs	r3, r0, #1
{
 8007f48:	4604      	mov	r4, r0
  assert_param (IS_PWR_SUPPLY (SupplySource));
 8007f4a:	2b01      	cmp	r3, #1
 8007f4c:	d904      	bls.n	8007f58 <HAL_PWREx_ConfigSupply+0x14>
 8007f4e:	f44f 719d 	mov.w	r1, #314	; 0x13a
 8007f52:	4812      	ldr	r0, [pc, #72]	; (8007f9c <HAL_PWREx_ConfigSupply+0x58>)
 8007f54:	f00b fcbc 	bl	80138d0 <assert_failed>

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 8007f58:	4b11      	ldr	r3, [pc, #68]	; (8007fa0 <HAL_PWREx_ConfigSupply+0x5c>)
 8007f5a:	68da      	ldr	r2, [r3, #12]
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 8007f5c:	68d8      	ldr	r0, [r3, #12]
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 8007f5e:	0752      	lsls	r2, r2, #29
 8007f60:	d405      	bmi.n	8007f6e <HAL_PWREx_ConfigSupply+0x2a>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 8007f62:	f000 0007 	and.w	r0, r0, #7
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
 8007f66:	1b00      	subs	r0, r0, r4
 8007f68:	bf18      	it	ne
 8007f6a:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
 8007f6c:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 8007f6e:	f020 0007 	bic.w	r0, r0, #7
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8007f72:	461d      	mov	r5, r3
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 8007f74:	4320      	orrs	r0, r4
 8007f76:	60d8      	str	r0, [r3, #12]
  tickstart = HAL_GetTick ();
 8007f78:	f7f8 fd56 	bl	8000a28 <HAL_GetTick>
 8007f7c:	4604      	mov	r4, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8007f7e:	e005      	b.n	8007f8c <HAL_PWREx_ConfigSupply+0x48>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 8007f80:	f7f8 fd52 	bl	8000a28 <HAL_GetTick>
 8007f84:	1b00      	subs	r0, r0, r4
 8007f86:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8007f8a:	d804      	bhi.n	8007f96 <HAL_PWREx_ConfigSupply+0x52>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8007f8c:	686b      	ldr	r3, [r5, #4]
 8007f8e:	049b      	lsls	r3, r3, #18
 8007f90:	d5f6      	bpl.n	8007f80 <HAL_PWREx_ConfigSupply+0x3c>
  return HAL_OK;
 8007f92:	2000      	movs	r0, #0
}
 8007f94:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_ERROR;
 8007f96:	2001      	movs	r0, #1
}
 8007f98:	bd38      	pop	{r3, r4, r5, pc}
 8007f9a:	bf00      	nop
 8007f9c:	08029310 	.word	0x08029310
 8007fa0:	58024800 	.word	0x58024800

08007fa4 <HAL_PWREx_EnableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
 8007fa4:	4a02      	ldr	r2, [pc, #8]	; (8007fb0 <HAL_PWREx_EnableUSBVoltageDetector+0xc>)
 8007fa6:	68d3      	ldr	r3, [r2, #12]
 8007fa8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8007fac:	60d3      	str	r3, [r2, #12]
}
 8007fae:	4770      	bx	lr
 8007fb0:	58024800 	.word	0x58024800

08007fb4 <HAL_PWREx_DisableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
 8007fb4:	4a02      	ldr	r2, [pc, #8]	; (8007fc0 <HAL_PWREx_DisableUSBVoltageDetector+0xc>)
 8007fb6:	68d3      	ldr	r3, [r2, #12]
 8007fb8:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8007fbc:	60d3      	str	r3, [r2, #12]
}
 8007fbe:	4770      	bx	lr
 8007fc0:	58024800 	.word	0x58024800

08007fc4 <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8007fc4:	2800      	cmp	r0, #0
 8007fc6:	f000 823c 	beq.w	8008442 <HAL_RCC_OscConfig+0x47e>
{
 8007fca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8007fcc:	6803      	ldr	r3, [r0, #0]
 8007fce:	4604      	mov	r4, r0
 8007fd0:	2b00      	cmp	r3, #0
 8007fd2:	f000 80a6 	beq.w	8008122 <HAL_RCC_OscConfig+0x15e>
 8007fd6:	0698      	lsls	r0, r3, #26
 8007fd8:	f000 821e 	beq.w	8008418 <HAL_RCC_OscConfig+0x454>
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8007fdc:	07d9      	lsls	r1, r3, #31
 8007fde:	d536      	bpl.n	800804e <HAL_RCC_OscConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 8007fe0:	6863      	ldr	r3, [r4, #4]
 8007fe2:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
 8007fe6:	d003      	beq.n	8007ff0 <HAL_RCC_OscConfig+0x2c>
 8007fe8:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8007fec:	f040 81e8 	bne.w	80083c0 <HAL_RCC_OscConfig+0x3fc>

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8007ff0:	4aa7      	ldr	r2, [pc, #668]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 8007ff2:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8007ff4:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8007ff6:	f003 0338 	and.w	r3, r3, #56	; 0x38
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 8007ffa:	2b10      	cmp	r3, #16
 8007ffc:	f000 81f2 	beq.w	80083e4 <HAL_RCC_OscConfig+0x420>
 8008000:	2b18      	cmp	r3, #24
 8008002:	f000 81ea 	beq.w	80083da <HAL_RCC_OscConfig+0x416>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8008006:	6863      	ldr	r3, [r4, #4]
 8008008:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800800c:	f000 81f5 	beq.w	80083fa <HAL_RCC_OscConfig+0x436>
 8008010:	2b00      	cmp	r3, #0
 8008012:	f040 8267 	bne.w	80084e4 <HAL_RCC_OscConfig+0x520>
 8008016:	4b9e      	ldr	r3, [pc, #632]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 8008018:	681a      	ldr	r2, [r3, #0]
 800801a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800801e:	601a      	str	r2, [r3, #0]
 8008020:	681a      	ldr	r2, [r3, #0]
 8008022:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8008026:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8008028:	6863      	ldr	r3, [r4, #4]
 800802a:	2b00      	cmp	r3, #0
 800802c:	f000 81fb 	beq.w	8008426 <HAL_RCC_OscConfig+0x462>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008030:	f7f8 fcfa 	bl	8000a28 <HAL_GetTick>

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8008034:	4d96      	ldr	r5, [pc, #600]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
        tickstart = HAL_GetTick();
 8008036:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8008038:	e005      	b.n	8008046 <HAL_RCC_OscConfig+0x82>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800803a:	f7f8 fcf5 	bl	8000a28 <HAL_GetTick>
 800803e:	1b80      	subs	r0, r0, r6
 8008040:	2864      	cmp	r0, #100	; 0x64
 8008042:	f200 81e7 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8008046:	682b      	ldr	r3, [r5, #0]
 8008048:	039b      	lsls	r3, r3, #14
 800804a:	d5f6      	bpl.n	800803a <HAL_RCC_OscConfig+0x76>
 800804c:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800804e:	0798      	lsls	r0, r3, #30
 8008050:	d52b      	bpl.n	80080aa <HAL_RCC_OscConfig+0xe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 8008052:	68e2      	ldr	r2, [r4, #12]
 8008054:	2a19      	cmp	r2, #25
 8008056:	f200 8288 	bhi.w	800856a <HAL_RCC_OscConfig+0x5a6>
 800805a:	4b8e      	ldr	r3, [pc, #568]	; (8008294 <HAL_RCC_OscConfig+0x2d0>)
 800805c:	40d3      	lsrs	r3, r2
 800805e:	07d9      	lsls	r1, r3, #31
 8008060:	f140 8283 	bpl.w	800856a <HAL_RCC_OscConfig+0x5a6>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 8008064:	6923      	ldr	r3, [r4, #16]
 8008066:	2b7f      	cmp	r3, #127	; 0x7f
 8008068:	f200 81a4 	bhi.w	80083b4 <HAL_RCC_OscConfig+0x3f0>

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800806c:	4a88      	ldr	r2, [pc, #544]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 800806e:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8008070:	6a92      	ldr	r2, [r2, #40]	; 0x28
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 8008072:	f013 0338 	ands.w	r3, r3, #56	; 0x38
 8008076:	f040 8173 	bne.w	8008360 <HAL_RCC_OscConfig+0x39c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800807a:	4b85      	ldr	r3, [pc, #532]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 800807c:	681b      	ldr	r3, [r3, #0]
 800807e:	075b      	lsls	r3, r3, #29
 8008080:	d503      	bpl.n	800808a <HAL_RCC_OscConfig+0xc6>
 8008082:	68e3      	ldr	r3, [r4, #12]
 8008084:	2b00      	cmp	r3, #0
 8008086:	f000 81b6 	beq.w	80083f6 <HAL_RCC_OscConfig+0x432>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800808a:	f7f8 fce5 	bl	8000a58 <HAL_GetREVID>
 800808e:	f241 0303 	movw	r3, #4099	; 0x1003
 8008092:	4a7f      	ldr	r2, [pc, #508]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 8008094:	4298      	cmp	r0, r3
 8008096:	6921      	ldr	r1, [r4, #16]
 8008098:	6853      	ldr	r3, [r2, #4]
 800809a:	f200 825b 	bhi.w	8008554 <HAL_RCC_OscConfig+0x590>
 800809e:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 80080a2:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
 80080a6:	6053      	str	r3, [r2, #4]
 80080a8:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 80080aa:	06d9      	lsls	r1, r3, #27
 80080ac:	d539      	bpl.n	8008122 <HAL_RCC_OscConfig+0x15e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
 80080ae:	69e3      	ldr	r3, [r4, #28]
 80080b0:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 80080b4:	f040 81fd 	bne.w	80084b2 <HAL_RCC_OscConfig+0x4ee>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
 80080b8:	6a23      	ldr	r3, [r4, #32]
 80080ba:	2b3f      	cmp	r3, #63	; 0x3f
 80080bc:	f200 81f3 	bhi.w	80084a6 <HAL_RCC_OscConfig+0x4e2>

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80080c0:	4a73      	ldr	r2, [pc, #460]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 80080c2:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 80080c4:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80080c6:	f003 0338 	and.w	r3, r3, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 80080ca:	2b08      	cmp	r3, #8
 80080cc:	f000 81c0 	beq.w	8008450 <HAL_RCC_OscConfig+0x48c>
 80080d0:	2b18      	cmp	r3, #24
 80080d2:	f000 81b8 	beq.w	8008446 <HAL_RCC_OscConfig+0x482>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
 80080d6:	69e3      	ldr	r3, [r4, #28]
 80080d8:	2b00      	cmp	r3, #0
 80080da:	f000 8211 	beq.w	8008500 <HAL_RCC_OscConfig+0x53c>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
 80080de:	4b6c      	ldr	r3, [pc, #432]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 80080e0:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80080e2:	461d      	mov	r5, r3
        __HAL_RCC_CSI_ENABLE();
 80080e4:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80080e8:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80080ea:	f7f8 fc9d 	bl	8000a28 <HAL_GetTick>
 80080ee:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80080f0:	e005      	b.n	80080fe <HAL_RCC_OscConfig+0x13a>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 80080f2:	f7f8 fc99 	bl	8000a28 <HAL_GetTick>
 80080f6:	1b80      	subs	r0, r0, r6
 80080f8:	2802      	cmp	r0, #2
 80080fa:	f200 818b 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80080fe:	682b      	ldr	r3, [r5, #0]
 8008100:	05db      	lsls	r3, r3, #23
 8008102:	d5f6      	bpl.n	80080f2 <HAL_RCC_OscConfig+0x12e>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8008104:	f7f8 fca8 	bl	8000a58 <HAL_GetREVID>
 8008108:	f241 0303 	movw	r3, #4099	; 0x1003
 800810c:	4298      	cmp	r0, r3
 800810e:	f200 82b5 	bhi.w	800867c <HAL_RCC_OscConfig+0x6b8>
 8008112:	686b      	ldr	r3, [r5, #4]
 8008114:	6a22      	ldr	r2, [r4, #32]
 8008116:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 800811a:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
 800811e:	606b      	str	r3, [r5, #4]
 8008120:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8008122:	071d      	lsls	r5, r3, #28
 8008124:	d51a      	bpl.n	800815c <HAL_RCC_OscConfig+0x198>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 8008126:	6963      	ldr	r3, [r4, #20]
 8008128:	2b01      	cmp	r3, #1
 800812a:	f200 814f 	bhi.w	80083cc <HAL_RCC_OscConfig+0x408>

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800812e:	2b00      	cmp	r3, #0
 8008130:	f000 81a6 	beq.w	8008480 <HAL_RCC_OscConfig+0x4bc>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8008134:	4b56      	ldr	r3, [pc, #344]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 8008136:	6f5a      	ldr	r2, [r3, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8008138:	461d      	mov	r5, r3
      __HAL_RCC_LSI_ENABLE();
 800813a:	f042 0201 	orr.w	r2, r2, #1
 800813e:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 8008140:	f7f8 fc72 	bl	8000a28 <HAL_GetTick>
 8008144:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8008146:	e005      	b.n	8008154 <HAL_RCC_OscConfig+0x190>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8008148:	f7f8 fc6e 	bl	8000a28 <HAL_GetTick>
 800814c:	1b80      	subs	r0, r0, r6
 800814e:	2802      	cmp	r0, #2
 8008150:	f200 8160 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8008154:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8008156:	0798      	lsls	r0, r3, #30
 8008158:	d5f6      	bpl.n	8008148 <HAL_RCC_OscConfig+0x184>
 800815a:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800815c:	069a      	lsls	r2, r3, #26
 800815e:	d51a      	bpl.n	8008196 <HAL_RCC_OscConfig+0x1d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
 8008160:	69a3      	ldr	r3, [r4, #24]
 8008162:	2b01      	cmp	r3, #1
 8008164:	f200 814f 	bhi.w	8008406 <HAL_RCC_OscConfig+0x442>

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
 8008168:	2b00      	cmp	r3, #0
 800816a:	f000 81a8 	beq.w	80084be <HAL_RCC_OscConfig+0x4fa>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 800816e:	4b48      	ldr	r3, [pc, #288]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 8008170:	681a      	ldr	r2, [r3, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 8008172:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_ENABLE();
 8008174:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008178:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 800817a:	f7f8 fc55 	bl	8000a28 <HAL_GetTick>
 800817e:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 8008180:	e005      	b.n	800818e <HAL_RCC_OscConfig+0x1ca>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 8008182:	f7f8 fc51 	bl	8000a28 <HAL_GetTick>
 8008186:	1b80      	subs	r0, r0, r6
 8008188:	2802      	cmp	r0, #2
 800818a:	f200 8143 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800818e:	682b      	ldr	r3, [r5, #0]
 8008190:	049f      	lsls	r7, r3, #18
 8008192:	d5f6      	bpl.n	8008182 <HAL_RCC_OscConfig+0x1be>
 8008194:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8008196:	0759      	lsls	r1, r3, #29
 8008198:	d53c      	bpl.n	8008214 <HAL_RCC_OscConfig+0x250>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 800819a:	68a3      	ldr	r3, [r4, #8]
 800819c:	2b01      	cmp	r3, #1
 800819e:	d902      	bls.n	80081a6 <HAL_RCC_OscConfig+0x1e2>
 80081a0:	2b05      	cmp	r3, #5
 80081a2:	f040 81f8 	bne.w	8008596 <HAL_RCC_OscConfig+0x5d2>

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 80081a6:	4b3c      	ldr	r3, [pc, #240]	; (8008298 <HAL_RCC_OscConfig+0x2d4>)
 80081a8:	681a      	ldr	r2, [r3, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80081aa:	461d      	mov	r5, r3
    PWR->CR1 |= PWR_CR1_DBP;
 80081ac:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80081b0:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80081b2:	f7f8 fc39 	bl	8000a28 <HAL_GetTick>
 80081b6:	4606      	mov	r6, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80081b8:	e005      	b.n	80081c6 <HAL_RCC_OscConfig+0x202>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80081ba:	f7f8 fc35 	bl	8000a28 <HAL_GetTick>
 80081be:	1b80      	subs	r0, r0, r6
 80081c0:	2864      	cmp	r0, #100	; 0x64
 80081c2:	f200 8127 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80081c6:	682b      	ldr	r3, [r5, #0]
 80081c8:	05da      	lsls	r2, r3, #23
 80081ca:	d5f6      	bpl.n	80081ba <HAL_RCC_OscConfig+0x1f6>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80081cc:	68a3      	ldr	r3, [r4, #8]
 80081ce:	2b01      	cmp	r3, #1
 80081d0:	f000 821d 	beq.w	800860e <HAL_RCC_OscConfig+0x64a>
 80081d4:	2b00      	cmp	r3, #0
 80081d6:	f040 8244 	bne.w	8008662 <HAL_RCC_OscConfig+0x69e>
 80081da:	4b2d      	ldr	r3, [pc, #180]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 80081dc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80081de:	f022 0201 	bic.w	r2, r2, #1
 80081e2:	671a      	str	r2, [r3, #112]	; 0x70
 80081e4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80081e6:	f022 0204 	bic.w	r2, r2, #4
 80081ea:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80081ec:	68a3      	ldr	r3, [r4, #8]
 80081ee:	2b00      	cmp	r3, #0
 80081f0:	f000 8213 	beq.w	800861a <HAL_RCC_OscConfig+0x656>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80081f4:	f7f8 fc18 	bl	8000a28 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 80081f8:	4d25      	ldr	r5, [pc, #148]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
      tickstart = HAL_GetTick();
 80081fa:	4607      	mov	r7, r0
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80081fc:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8008200:	e005      	b.n	800820e <HAL_RCC_OscConfig+0x24a>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8008202:	f7f8 fc11 	bl	8000a28 <HAL_GetTick>
 8008206:	1bc0      	subs	r0, r0, r7
 8008208:	42b0      	cmp	r0, r6
 800820a:	f200 8103 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800820e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8008210:	079b      	lsls	r3, r3, #30
 8008212:	d5f6      	bpl.n	8008202 <HAL_RCC_OscConfig+0x23e>
      }
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 8008214:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8008216:	2802      	cmp	r0, #2
 8008218:	f200 81b6 	bhi.w	8008588 <HAL_RCC_OscConfig+0x5c4>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800821c:	2800      	cmp	r0, #0
 800821e:	f000 809d 	beq.w	800835c <HAL_RCC_OscConfig+0x398>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 8008222:	4a1b      	ldr	r2, [pc, #108]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 8008224:	6913      	ldr	r3, [r2, #16]
 8008226:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800822a:	2b18      	cmp	r3, #24
 800822c:	f000 81c1 	beq.w	80085b2 <HAL_RCC_OscConfig+0x5ee>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8008230:	2802      	cmp	r0, #2
 8008232:	f040 8203 	bne.w	800863c <HAL_RCC_OscConfig+0x678>
      {
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 8008236:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8008238:	2b03      	cmp	r3, #3
 800823a:	f200 8253 	bhi.w	80086e4 <HAL_RCC_OscConfig+0x720>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 800823e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008240:	3b01      	subs	r3, #1
 8008242:	2b3e      	cmp	r3, #62	; 0x3e
 8008244:	f200 8230 	bhi.w	80086a8 <HAL_RCC_OscConfig+0x6e4>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 8008248:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800824a:	3b04      	subs	r3, #4
 800824c:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
 8008250:	f200 8224 	bhi.w	800869c <HAL_RCC_OscConfig+0x6d8>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
 8008254:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8008256:	3b01      	subs	r3, #1
 8008258:	2b7f      	cmp	r3, #127	; 0x7f
 800825a:	f200 823d 	bhi.w	80086d8 <HAL_RCC_OscConfig+0x714>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 800825e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8008260:	3b01      	subs	r3, #1
 8008262:	2b7f      	cmp	r3, #127	; 0x7f
 8008264:	f200 8232 	bhi.w	80086cc <HAL_RCC_OscConfig+0x708>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
 8008268:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800826a:	3b01      	subs	r3, #1
 800826c:	2b7f      	cmp	r3, #127	; 0x7f
 800826e:	f200 8227 	bhi.w	80086c0 <HAL_RCC_OscConfig+0x6fc>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
 8008272:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8008274:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8008278:	f080 821c 	bcs.w	80086b4 <HAL_RCC_OscConfig+0x6f0>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800827c:	4b04      	ldr	r3, [pc, #16]	; (8008290 <HAL_RCC_OscConfig+0x2cc>)
 800827e:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 8008280:	461d      	mov	r5, r3
        __HAL_RCC_PLL_DISABLE();
 8008282:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8008286:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8008288:	f7f8 fbce 	bl	8000a28 <HAL_GetTick>
 800828c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800828e:	e00b      	b.n	80082a8 <HAL_RCC_OscConfig+0x2e4>
 8008290:	58024400 	.word	0x58024400
 8008294:	02020203 	.word	0x02020203
 8008298:	58024800 	.word	0x58024800
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800829c:	f7f8 fbc4 	bl	8000a28 <HAL_GetTick>
 80082a0:	1b80      	subs	r0, r0, r6
 80082a2:	2802      	cmp	r0, #2
 80082a4:	f200 80b6 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80082a8:	682b      	ldr	r3, [r5, #0]
 80082aa:	0199      	lsls	r1, r3, #6
 80082ac:	d4f6      	bmi.n	800829c <HAL_RCC_OscConfig+0x2d8>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80082ae:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 80082b0:	4bb1      	ldr	r3, [pc, #708]	; (8008578 <HAL_RCC_OscConfig+0x5b4>)
 80082b2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80082b4:	4013      	ands	r3, r2
 80082b6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 80082b8:	49b0      	ldr	r1, [pc, #704]	; (800857c <HAL_RCC_OscConfig+0x5b8>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80082ba:	4303      	orrs	r3, r0

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80082bc:	4eb0      	ldr	r6, [pc, #704]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80082be:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 80082c2:	62ab      	str	r3, [r5, #40]	; 0x28
 80082c4:	6b27      	ldr	r7, [r4, #48]	; 0x30
 80082c6:	e9d4 320d 	ldrd	r3, r2, [r4, #52]	; 0x34
 80082ca:	3f01      	subs	r7, #1
 80082cc:	1e50      	subs	r0, r2, #1
 80082ce:	3b01      	subs	r3, #1
 80082d0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80082d2:	f3c7 0708 	ubfx	r7, r7, #0, #9
 80082d6:	025b      	lsls	r3, r3, #9
 80082d8:	0400      	lsls	r0, r0, #16
 80082da:	3a01      	subs	r2, #1
 80082dc:	b29b      	uxth	r3, r3
 80082de:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
 80082e2:	0612      	lsls	r2, r2, #24
 80082e4:	4303      	orrs	r3, r0
 80082e6:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 80082ea:	433b      	orrs	r3, r7
 80082ec:	4313      	orrs	r3, r2
 80082ee:	632b      	str	r3, [r5, #48]	; 0x30
         __HAL_RCC_PLLFRACN_DISABLE();
 80082f0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80082f2:	f023 0301 	bic.w	r3, r3, #1
 80082f6:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 80082f8:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80082fa:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80082fc:	4011      	ands	r1, r2
 80082fe:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
 8008302:	6369      	str	r1, [r5, #52]	; 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 8008304:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008306:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8008308:	f023 030c 	bic.w	r3, r3, #12
 800830c:	4313      	orrs	r3, r2
 800830e:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 8008310:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008312:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8008314:	f023 0302 	bic.w	r3, r3, #2
 8008318:	4313      	orrs	r3, r2
 800831a:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 800831c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800831e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8008322:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8008324:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008326:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800832a:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 800832c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800832e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8008332:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_ENABLE();
 8008334:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008336:	f043 0301 	orr.w	r3, r3, #1
 800833a:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_ENABLE();
 800833c:	682b      	ldr	r3, [r5, #0]
 800833e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008342:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8008344:	f7f8 fb70 	bl	8000a28 <HAL_GetTick>
 8008348:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800834a:	e004      	b.n	8008356 <HAL_RCC_OscConfig+0x392>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800834c:	f7f8 fb6c 	bl	8000a28 <HAL_GetTick>
 8008350:	1b00      	subs	r0, r0, r4
 8008352:	2802      	cmp	r0, #2
 8008354:	d85e      	bhi.n	8008414 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8008356:	6833      	ldr	r3, [r6, #0]
 8008358:	019a      	lsls	r2, r3, #6
 800835a:	d5f7      	bpl.n	800834c <HAL_RCC_OscConfig+0x388>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 800835c:	2000      	movs	r0, #0
}
 800835e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 8008360:	2b18      	cmp	r3, #24
 8008362:	f000 80fe 	beq.w	8008562 <HAL_RCC_OscConfig+0x59e>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8008366:	68e2      	ldr	r2, [r4, #12]
 8008368:	2a00      	cmp	r2, #0
 800836a:	f000 80de 	beq.w	800852a <HAL_RCC_OscConfig+0x566>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800836e:	4984      	ldr	r1, [pc, #528]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
 8008370:	680b      	ldr	r3, [r1, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8008372:	460d      	mov	r5, r1
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8008374:	f023 0319 	bic.w	r3, r3, #25
 8008378:	4313      	orrs	r3, r2
 800837a:	600b      	str	r3, [r1, #0]
        tickstart = HAL_GetTick();
 800837c:	f7f8 fb54 	bl	8000a28 <HAL_GetTick>
 8008380:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8008382:	e004      	b.n	800838e <HAL_RCC_OscConfig+0x3ca>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8008384:	f7f8 fb50 	bl	8000a28 <HAL_GetTick>
 8008388:	1b80      	subs	r0, r0, r6
 800838a:	2802      	cmp	r0, #2
 800838c:	d842      	bhi.n	8008414 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800838e:	682b      	ldr	r3, [r5, #0]
 8008390:	075f      	lsls	r7, r3, #29
 8008392:	d5f7      	bpl.n	8008384 <HAL_RCC_OscConfig+0x3c0>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8008394:	f7f8 fb60 	bl	8000a58 <HAL_GetREVID>
 8008398:	f241 0303 	movw	r3, #4099	; 0x1003
 800839c:	6922      	ldr	r2, [r4, #16]
 800839e:	4298      	cmp	r0, r3
 80083a0:	686b      	ldr	r3, [r5, #4]
 80083a2:	f200 8174 	bhi.w	800868e <HAL_RCC_OscConfig+0x6ca>
 80083a6:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 80083aa:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
 80083ae:	606b      	str	r3, [r5, #4]
 80083b0:	6823      	ldr	r3, [r4, #0]
 80083b2:	e67a      	b.n	80080aa <HAL_RCC_OscConfig+0xe6>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 80083b4:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
 80083b8:	4872      	ldr	r0, [pc, #456]	; (8008584 <HAL_RCC_OscConfig+0x5c0>)
 80083ba:	f00b fa89 	bl	80138d0 <assert_failed>
 80083be:	e655      	b.n	800806c <HAL_RCC_OscConfig+0xa8>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 80083c0:	f240 11a3 	movw	r1, #419	; 0x1a3
 80083c4:	486f      	ldr	r0, [pc, #444]	; (8008584 <HAL_RCC_OscConfig+0x5c0>)
 80083c6:	f00b fa83 	bl	80138d0 <assert_failed>
 80083ca:	e611      	b.n	8007ff0 <HAL_RCC_OscConfig+0x2c>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 80083cc:	f44f 7117 	mov.w	r1, #604	; 0x25c
 80083d0:	486c      	ldr	r0, [pc, #432]	; (8008584 <HAL_RCC_OscConfig+0x5c0>)
 80083d2:	f00b fa7d 	bl	80138d0 <assert_failed>
 80083d6:	6963      	ldr	r3, [r4, #20]
 80083d8:	e6a9      	b.n	800812e <HAL_RCC_OscConfig+0x16a>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 80083da:	f002 0203 	and.w	r2, r2, #3
 80083de:	2a02      	cmp	r2, #2
 80083e0:	f47f ae11 	bne.w	8008006 <HAL_RCC_OscConfig+0x42>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80083e4:	4b66      	ldr	r3, [pc, #408]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
 80083e6:	681b      	ldr	r3, [r3, #0]
 80083e8:	039a      	lsls	r2, r3, #14
 80083ea:	f57f ae2f 	bpl.w	800804c <HAL_RCC_OscConfig+0x88>
 80083ee:	6863      	ldr	r3, [r4, #4]
 80083f0:	2b00      	cmp	r3, #0
 80083f2:	f47f ae2b 	bne.w	800804c <HAL_RCC_OscConfig+0x88>
        return HAL_ERROR;
 80083f6:	2001      	movs	r0, #1
}
 80083f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80083fa:	4a61      	ldr	r2, [pc, #388]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
 80083fc:	6813      	ldr	r3, [r2, #0]
 80083fe:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8008402:	6013      	str	r3, [r2, #0]
 8008404:	e610      	b.n	8008028 <HAL_RCC_OscConfig+0x64>
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
 8008406:	f240 2187 	movw	r1, #647	; 0x287
 800840a:	485e      	ldr	r0, [pc, #376]	; (8008584 <HAL_RCC_OscConfig+0x5c0>)
 800840c:	f00b fa60 	bl	80138d0 <assert_failed>
 8008410:	69a3      	ldr	r3, [r4, #24]
 8008412:	e6a9      	b.n	8008168 <HAL_RCC_OscConfig+0x1a4>
            return HAL_TIMEOUT;
 8008414:	2003      	movs	r0, #3
}
 8008416:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8008418:	f44f 71cf 	mov.w	r1, #414	; 0x19e
 800841c:	4859      	ldr	r0, [pc, #356]	; (8008584 <HAL_RCC_OscConfig+0x5c0>)
 800841e:	f00b fa57 	bl	80138d0 <assert_failed>
 8008422:	6823      	ldr	r3, [r4, #0]
 8008424:	e5da      	b.n	8007fdc <HAL_RCC_OscConfig+0x18>
        tickstart = HAL_GetTick();
 8008426:	f7f8 faff 	bl	8000a28 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800842a:	4d55      	ldr	r5, [pc, #340]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
        tickstart = HAL_GetTick();
 800842c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800842e:	e004      	b.n	800843a <HAL_RCC_OscConfig+0x476>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8008430:	f7f8 fafa 	bl	8000a28 <HAL_GetTick>
 8008434:	1b80      	subs	r0, r0, r6
 8008436:	2864      	cmp	r0, #100	; 0x64
 8008438:	d8ec      	bhi.n	8008414 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800843a:	682b      	ldr	r3, [r5, #0]
 800843c:	039f      	lsls	r7, r3, #14
 800843e:	d4f7      	bmi.n	8008430 <HAL_RCC_OscConfig+0x46c>
 8008440:	e604      	b.n	800804c <HAL_RCC_OscConfig+0x88>
    return HAL_ERROR;
 8008442:	2001      	movs	r0, #1
}
 8008444:	4770      	bx	lr
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 8008446:	f002 0203 	and.w	r2, r2, #3
 800844a:	2a01      	cmp	r2, #1
 800844c:	f47f ae43 	bne.w	80080d6 <HAL_RCC_OscConfig+0x112>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8008450:	4b4b      	ldr	r3, [pc, #300]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
 8008452:	681b      	ldr	r3, [r3, #0]
 8008454:	05da      	lsls	r2, r3, #23
 8008456:	d502      	bpl.n	800845e <HAL_RCC_OscConfig+0x49a>
 8008458:	69e3      	ldr	r3, [r4, #28]
 800845a:	2b80      	cmp	r3, #128	; 0x80
 800845c:	d1cb      	bne.n	80083f6 <HAL_RCC_OscConfig+0x432>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800845e:	f7f8 fafb 	bl	8000a58 <HAL_GetREVID>
 8008462:	f241 0303 	movw	r3, #4099	; 0x1003
 8008466:	4a46      	ldr	r2, [pc, #280]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
 8008468:	4298      	cmp	r0, r3
 800846a:	6a21      	ldr	r1, [r4, #32]
 800846c:	f200 8099 	bhi.w	80085a2 <HAL_RCC_OscConfig+0x5de>
 8008470:	6853      	ldr	r3, [r2, #4]
 8008472:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 8008476:	ea43 6381 	orr.w	r3, r3, r1, lsl #26
 800847a:	6053      	str	r3, [r2, #4]
 800847c:	6823      	ldr	r3, [r4, #0]
 800847e:	e650      	b.n	8008122 <HAL_RCC_OscConfig+0x15e>
      __HAL_RCC_LSI_DISABLE();
 8008480:	4b3f      	ldr	r3, [pc, #252]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
 8008482:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8008484:	461d      	mov	r5, r3
      __HAL_RCC_LSI_DISABLE();
 8008486:	f022 0201 	bic.w	r2, r2, #1
 800848a:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 800848c:	f7f8 facc 	bl	8000a28 <HAL_GetTick>
 8008490:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8008492:	e004      	b.n	800849e <HAL_RCC_OscConfig+0x4da>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8008494:	f7f8 fac8 	bl	8000a28 <HAL_GetTick>
 8008498:	1b80      	subs	r0, r0, r6
 800849a:	2802      	cmp	r0, #2
 800849c:	d8ba      	bhi.n	8008414 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800849e:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80084a0:	0799      	lsls	r1, r3, #30
 80084a2:	d4f7      	bmi.n	8008494 <HAL_RCC_OscConfig+0x4d0>
 80084a4:	e659      	b.n	800815a <HAL_RCC_OscConfig+0x196>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
 80084a6:	f240 211b 	movw	r1, #539	; 0x21b
 80084aa:	4836      	ldr	r0, [pc, #216]	; (8008584 <HAL_RCC_OscConfig+0x5c0>)
 80084ac:	f00b fa10 	bl	80138d0 <assert_failed>
 80084b0:	e606      	b.n	80080c0 <HAL_RCC_OscConfig+0xfc>
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
 80084b2:	f240 211a 	movw	r1, #538	; 0x21a
 80084b6:	4833      	ldr	r0, [pc, #204]	; (8008584 <HAL_RCC_OscConfig+0x5c0>)
 80084b8:	f00b fa0a 	bl	80138d0 <assert_failed>
 80084bc:	e5fc      	b.n	80080b8 <HAL_RCC_OscConfig+0xf4>
      __HAL_RCC_HSI48_DISABLE();
 80084be:	4b30      	ldr	r3, [pc, #192]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
 80084c0:	681a      	ldr	r2, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 80084c2:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_DISABLE();
 80084c4:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80084c8:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80084ca:	f7f8 faad 	bl	8000a28 <HAL_GetTick>
 80084ce:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 80084d0:	e004      	b.n	80084dc <HAL_RCC_OscConfig+0x518>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 80084d2:	f7f8 faa9 	bl	8000a28 <HAL_GetTick>
 80084d6:	1b80      	subs	r0, r0, r6
 80084d8:	2802      	cmp	r0, #2
 80084da:	d89b      	bhi.n	8008414 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 80084dc:	682b      	ldr	r3, [r5, #0]
 80084de:	0498      	lsls	r0, r3, #18
 80084e0:	d4f7      	bmi.n	80084d2 <HAL_RCC_OscConfig+0x50e>
 80084e2:	e657      	b.n	8008194 <HAL_RCC_OscConfig+0x1d0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80084e4:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80084e8:	4b25      	ldr	r3, [pc, #148]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
 80084ea:	681a      	ldr	r2, [r3, #0]
 80084ec:	f47f ad95 	bne.w	800801a <HAL_RCC_OscConfig+0x56>
 80084f0:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80084f4:	601a      	str	r2, [r3, #0]
 80084f6:	681a      	ldr	r2, [r3, #0]
 80084f8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80084fc:	601a      	str	r2, [r3, #0]
 80084fe:	e593      	b.n	8008028 <HAL_RCC_OscConfig+0x64>
        __HAL_RCC_CSI_DISABLE();
 8008500:	4b1f      	ldr	r3, [pc, #124]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
 8008502:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8008504:	461d      	mov	r5, r3
        __HAL_RCC_CSI_DISABLE();
 8008506:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800850a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800850c:	f7f8 fa8c 	bl	8000a28 <HAL_GetTick>
 8008510:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8008512:	e005      	b.n	8008520 <HAL_RCC_OscConfig+0x55c>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 8008514:	f7f8 fa88 	bl	8000a28 <HAL_GetTick>
 8008518:	1b80      	subs	r0, r0, r6
 800851a:	2802      	cmp	r0, #2
 800851c:	f63f af7a 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8008520:	682b      	ldr	r3, [r5, #0]
 8008522:	05df      	lsls	r7, r3, #23
 8008524:	d4f6      	bmi.n	8008514 <HAL_RCC_OscConfig+0x550>
 8008526:	6823      	ldr	r3, [r4, #0]
 8008528:	e5fb      	b.n	8008122 <HAL_RCC_OscConfig+0x15e>
        __HAL_RCC_HSI_DISABLE();
 800852a:	4b15      	ldr	r3, [pc, #84]	; (8008580 <HAL_RCC_OscConfig+0x5bc>)
 800852c:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800852e:	461d      	mov	r5, r3
        __HAL_RCC_HSI_DISABLE();
 8008530:	f022 0201 	bic.w	r2, r2, #1
 8008534:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8008536:	f7f8 fa77 	bl	8000a28 <HAL_GetTick>
 800853a:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800853c:	e005      	b.n	800854a <HAL_RCC_OscConfig+0x586>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800853e:	f7f8 fa73 	bl	8000a28 <HAL_GetTick>
 8008542:	1b80      	subs	r0, r0, r6
 8008544:	2802      	cmp	r0, #2
 8008546:	f63f af65 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800854a:	682b      	ldr	r3, [r5, #0]
 800854c:	0758      	lsls	r0, r3, #29
 800854e:	d4f6      	bmi.n	800853e <HAL_RCC_OscConfig+0x57a>
 8008550:	6823      	ldr	r3, [r4, #0]
 8008552:	e5aa      	b.n	80080aa <HAL_RCC_OscConfig+0xe6>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8008554:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8008558:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800855c:	6053      	str	r3, [r2, #4]
 800855e:	6823      	ldr	r3, [r4, #0]
 8008560:	e5a3      	b.n	80080aa <HAL_RCC_OscConfig+0xe6>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 8008562:	0792      	lsls	r2, r2, #30
 8008564:	f47f aeff 	bne.w	8008366 <HAL_RCC_OscConfig+0x3a2>
 8008568:	e587      	b.n	800807a <HAL_RCC_OscConfig+0xb6>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 800856a:	f240 11d7 	movw	r1, #471	; 0x1d7
 800856e:	4805      	ldr	r0, [pc, #20]	; (8008584 <HAL_RCC_OscConfig+0x5c0>)
 8008570:	f00b f9ae 	bl	80138d0 <assert_failed>
 8008574:	e576      	b.n	8008064 <HAL_RCC_OscConfig+0xa0>
 8008576:	bf00      	nop
 8008578:	fffffc0c 	.word	0xfffffc0c
 800857c:	ffff0007 	.word	0xffff0007
 8008580:	58024400 	.word	0x58024400
 8008584:	0802934c 	.word	0x0802934c
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 8008588:	4859      	ldr	r0, [pc, #356]	; (80086f0 <HAL_RCC_OscConfig+0x72c>)
 800858a:	f240 21e3 	movw	r1, #739	; 0x2e3
 800858e:	f00b f99f 	bl	80138d0 <assert_failed>
 8008592:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8008594:	e642      	b.n	800821c <HAL_RCC_OscConfig+0x258>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 8008596:	f240 21b1 	movw	r1, #689	; 0x2b1
 800859a:	4855      	ldr	r0, [pc, #340]	; (80086f0 <HAL_RCC_OscConfig+0x72c>)
 800859c:	f00b f998 	bl	80138d0 <assert_failed>
 80085a0:	e601      	b.n	80081a6 <HAL_RCC_OscConfig+0x1e2>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 80085a2:	68d3      	ldr	r3, [r2, #12]
 80085a4:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
 80085a8:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 80085ac:	60d3      	str	r3, [r2, #12]
 80085ae:	6823      	ldr	r3, [r4, #0]
 80085b0:	e5b7      	b.n	8008122 <HAL_RCC_OscConfig+0x15e>
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80085b2:	2801      	cmp	r0, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
 80085b4:	6a91      	ldr	r1, [r2, #40]	; 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
 80085b6:	6b15      	ldr	r5, [r2, #48]	; 0x30
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80085b8:	f43f aed1 	beq.w	800835e <HAL_RCC_OscConfig+0x39a>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80085bc:	f001 0303 	and.w	r3, r1, #3
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80085c0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80085c2:	4293      	cmp	r3, r2
 80085c4:	f47f af17 	bne.w	80083f6 <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 80085c8:	f3c1 1105 	ubfx	r1, r1, #4, #6
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80085cc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80085ce:	4299      	cmp	r1, r3
 80085d0:	f47f af11 	bne.w	80083f6 <HAL_RCC_OscConfig+0x432>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 80085d4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80085d6:	f3c5 0208 	ubfx	r2, r5, #0, #9
 80085da:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 80085dc:	429a      	cmp	r2, r3
 80085de:	f47f af0a 	bne.w	80083f6 <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 80085e2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80085e4:	f3c5 2246 	ubfx	r2, r5, #9, #7
 80085e8:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 80085ea:	429a      	cmp	r2, r3
 80085ec:	f47f af03 	bne.w	80083f6 <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 80085f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80085f2:	f3c5 4206 	ubfx	r2, r5, #16, #7
 80085f6:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 80085f8:	429a      	cmp	r2, r3
 80085fa:	f47f aefc 	bne.w	80083f6 <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 80085fe:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8008600:	f3c5 6506 	ubfx	r5, r5, #24, #7
 8008604:	3801      	subs	r0, #1
    return HAL_ERROR;
 8008606:	1a28      	subs	r0, r5, r0
 8008608:	bf18      	it	ne
 800860a:	2001      	movne	r0, #1
 800860c:	e6a7      	b.n	800835e <HAL_RCC_OscConfig+0x39a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800860e:	4a39      	ldr	r2, [pc, #228]	; (80086f4 <HAL_RCC_OscConfig+0x730>)
 8008610:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8008612:	f043 0301 	orr.w	r3, r3, #1
 8008616:	6713      	str	r3, [r2, #112]	; 0x70
 8008618:	e5e8      	b.n	80081ec <HAL_RCC_OscConfig+0x228>
      tickstart = HAL_GetTick();
 800861a:	f7f8 fa05 	bl	8000a28 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800861e:	4d35      	ldr	r5, [pc, #212]	; (80086f4 <HAL_RCC_OscConfig+0x730>)
      tickstart = HAL_GetTick();
 8008620:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8008622:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8008626:	e005      	b.n	8008634 <HAL_RCC_OscConfig+0x670>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8008628:	f7f8 f9fe 	bl	8000a28 <HAL_GetTick>
 800862c:	1bc0      	subs	r0, r0, r7
 800862e:	42b0      	cmp	r0, r6
 8008630:	f63f aef0 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8008634:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8008636:	0798      	lsls	r0, r3, #30
 8008638:	d4f6      	bmi.n	8008628 <HAL_RCC_OscConfig+0x664>
 800863a:	e5eb      	b.n	8008214 <HAL_RCC_OscConfig+0x250>
        __HAL_RCC_PLL_DISABLE();
 800863c:	6813      	ldr	r3, [r2, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800863e:	4614      	mov	r4, r2
        __HAL_RCC_PLL_DISABLE();
 8008640:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8008644:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8008646:	f7f8 f9ef 	bl	8000a28 <HAL_GetTick>
 800864a:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800864c:	e005      	b.n	800865a <HAL_RCC_OscConfig+0x696>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800864e:	f7f8 f9eb 	bl	8000a28 <HAL_GetTick>
 8008652:	1b40      	subs	r0, r0, r5
 8008654:	2802      	cmp	r0, #2
 8008656:	f63f aedd 	bhi.w	8008414 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800865a:	6823      	ldr	r3, [r4, #0]
 800865c:	019b      	lsls	r3, r3, #6
 800865e:	d4f6      	bmi.n	800864e <HAL_RCC_OscConfig+0x68a>
 8008660:	e67c      	b.n	800835c <HAL_RCC_OscConfig+0x398>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8008662:	2b05      	cmp	r3, #5
 8008664:	4b23      	ldr	r3, [pc, #140]	; (80086f4 <HAL_RCC_OscConfig+0x730>)
 8008666:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8008668:	f47f adb9 	bne.w	80081de <HAL_RCC_OscConfig+0x21a>
 800866c:	f042 0204 	orr.w	r2, r2, #4
 8008670:	671a      	str	r2, [r3, #112]	; 0x70
 8008672:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8008674:	f042 0201 	orr.w	r2, r2, #1
 8008678:	671a      	str	r2, [r3, #112]	; 0x70
 800867a:	e5b7      	b.n	80081ec <HAL_RCC_OscConfig+0x228>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800867c:	68eb      	ldr	r3, [r5, #12]
 800867e:	6a22      	ldr	r2, [r4, #32]
 8008680:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
 8008684:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8008688:	60eb      	str	r3, [r5, #12]
 800868a:	6823      	ldr	r3, [r4, #0]
 800868c:	e549      	b.n	8008122 <HAL_RCC_OscConfig+0x15e>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800868e:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8008692:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8008696:	606b      	str	r3, [r5, #4]
 8008698:	6823      	ldr	r3, [r4, #0]
 800869a:	e506      	b.n	80080aa <HAL_RCC_OscConfig+0xe6>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 800869c:	f240 21ee 	movw	r1, #750	; 0x2ee
 80086a0:	4813      	ldr	r0, [pc, #76]	; (80086f0 <HAL_RCC_OscConfig+0x72c>)
 80086a2:	f00b f915 	bl	80138d0 <assert_failed>
 80086a6:	e5d5      	b.n	8008254 <HAL_RCC_OscConfig+0x290>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 80086a8:	f240 21ed 	movw	r1, #749	; 0x2ed
 80086ac:	4810      	ldr	r0, [pc, #64]	; (80086f0 <HAL_RCC_OscConfig+0x72c>)
 80086ae:	f00b f90f 	bl	80138d0 <assert_failed>
 80086b2:	e5c9      	b.n	8008248 <HAL_RCC_OscConfig+0x284>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
 80086b4:	f240 21f2 	movw	r1, #754	; 0x2f2
 80086b8:	480d      	ldr	r0, [pc, #52]	; (80086f0 <HAL_RCC_OscConfig+0x72c>)
 80086ba:	f00b f909 	bl	80138d0 <assert_failed>
 80086be:	e5dd      	b.n	800827c <HAL_RCC_OscConfig+0x2b8>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
 80086c0:	f240 21f1 	movw	r1, #753	; 0x2f1
 80086c4:	480a      	ldr	r0, [pc, #40]	; (80086f0 <HAL_RCC_OscConfig+0x72c>)
 80086c6:	f00b f903 	bl	80138d0 <assert_failed>
 80086ca:	e5d2      	b.n	8008272 <HAL_RCC_OscConfig+0x2ae>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 80086cc:	f44f 713c 	mov.w	r1, #752	; 0x2f0
 80086d0:	4807      	ldr	r0, [pc, #28]	; (80086f0 <HAL_RCC_OscConfig+0x72c>)
 80086d2:	f00b f8fd 	bl	80138d0 <assert_failed>
 80086d6:	e5c7      	b.n	8008268 <HAL_RCC_OscConfig+0x2a4>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
 80086d8:	f240 21ef 	movw	r1, #751	; 0x2ef
 80086dc:	4804      	ldr	r0, [pc, #16]	; (80086f0 <HAL_RCC_OscConfig+0x72c>)
 80086de:	f00b f8f7 	bl	80138d0 <assert_failed>
 80086e2:	e5bc      	b.n	800825e <HAL_RCC_OscConfig+0x29a>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 80086e4:	f44f 713b 	mov.w	r1, #748	; 0x2ec
 80086e8:	4801      	ldr	r0, [pc, #4]	; (80086f0 <HAL_RCC_OscConfig+0x72c>)
 80086ea:	f00b f8f1 	bl	80138d0 <assert_failed>
 80086ee:	e5a6      	b.n	800823e <HAL_RCC_OscConfig+0x27a>
 80086f0:	0802934c 	.word	0x0802934c
 80086f4:	58024400 	.word	0x58024400

080086f8 <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 80086f8:	4a3e      	ldr	r2, [pc, #248]	; (80087f4 <HAL_RCC_GetSysClockFreq+0xfc>)
 80086fa:	6913      	ldr	r3, [r2, #16]
 80086fc:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8008700:	2b10      	cmp	r3, #16
 8008702:	d04f      	beq.n	80087a4 <HAL_RCC_GetSysClockFreq+0xac>
 8008704:	2b18      	cmp	r3, #24
 8008706:	d00b      	beq.n	8008720 <HAL_RCC_GetSysClockFreq+0x28>
 8008708:	b10b      	cbz	r3, 800870e <HAL_RCC_GetSysClockFreq+0x16>
      }

    break;

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
 800870a:	483b      	ldr	r0, [pc, #236]	; (80087f8 <HAL_RCC_GetSysClockFreq+0x100>)
 800870c:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800870e:	6813      	ldr	r3, [r2, #0]
 8008710:	0699      	lsls	r1, r3, #26
 8008712:	d549      	bpl.n	80087a8 <HAL_RCC_GetSysClockFreq+0xb0>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8008714:	6813      	ldr	r3, [r2, #0]
 8008716:	4839      	ldr	r0, [pc, #228]	; (80087fc <HAL_RCC_GetSysClockFreq+0x104>)
 8008718:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 800871c:	40d8      	lsrs	r0, r3
 800871e:	4770      	bx	lr
{
 8008720:	b410      	push	{r4}
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8008722:	6a91      	ldr	r1, [r2, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 8008724:	6a90      	ldr	r0, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 8008726:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 8008728:	f3c0 1005 	ubfx	r0, r0, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800872c:	6b54      	ldr	r4, [r2, #52]	; 0x34

    if (pllm != 0U)
 800872e:	b3b0      	cbz	r0, 800879e <HAL_RCC_GetSysClockFreq+0xa6>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8008730:	f3c4 04cc 	ubfx	r4, r4, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 8008734:	f003 0301 	and.w	r3, r3, #1
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8008738:	f001 0103 	and.w	r1, r1, #3
 800873c:	ee07 0a90 	vmov	s15, r0
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8008740:	fb03 f304 	mul.w	r3, r3, r4
    {
      switch (pllsource)
 8008744:	2901      	cmp	r1, #1
 8008746:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800874a:	ee07 3a10 	vmov	s14, r3
 800874e:	eeba 7ae9 	vcvt.f32.s32	s14, s14, #13
      switch (pllsource)
 8008752:	d002      	beq.n	800875a <HAL_RCC_GetSysClockFreq+0x62>
 8008754:	d32d      	bcc.n	80087b2 <HAL_RCC_GetSysClockFreq+0xba>
 8008756:	2902      	cmp	r1, #2
 8008758:	d028      	beq.n	80087ac <HAL_RCC_GetSysClockFreq+0xb4>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800875a:	eddf 5a29 	vldr	s11, [pc, #164]	; 8008800 <HAL_RCC_GetSysClockFreq+0x108>
 800875e:	eec5 6aa7 	vdiv.f32	s13, s11, s15
 8008762:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8008764:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8008768:	ee07 3a90 	vmov	s15, r3
 800876c:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8008770:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008774:	ee77 7a86 	vadd.f32	s15, s15, s12
 8008778:	ee37 7a87 	vadd.f32	s14, s15, s14
 800877c:	ee27 7a26 	vmul.f32	s14, s14, s13
        break;
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 8008780:	4b1c      	ldr	r3, [pc, #112]	; (80087f4 <HAL_RCC_GetSysClockFreq+0xfc>)
 8008782:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008784:	f3c3 2346 	ubfx	r3, r3, #9, #7
 8008788:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
 800878a:	ee07 3a90 	vmov	s15, r3
 800878e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8008792:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8008796:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800879a:	ee17 0a90 	vmov	r0, s15
    sysclockfreq = CSI_VALUE;
    break;
  }

  return sysclockfreq;
}
 800879e:	f85d 4b04 	ldr.w	r4, [sp], #4
 80087a2:	4770      	bx	lr
    sysclockfreq = HSE_VALUE;
 80087a4:	4817      	ldr	r0, [pc, #92]	; (8008804 <HAL_RCC_GetSysClockFreq+0x10c>)
 80087a6:	4770      	bx	lr
        sysclockfreq = (uint32_t) HSI_VALUE;
 80087a8:	4814      	ldr	r0, [pc, #80]	; (80087fc <HAL_RCC_GetSysClockFreq+0x104>)
}
 80087aa:	4770      	bx	lr
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80087ac:	eddf 5a16 	vldr	s11, [pc, #88]	; 8008808 <HAL_RCC_GetSysClockFreq+0x110>
 80087b0:	e7d5      	b.n	800875e <HAL_RCC_GetSysClockFreq+0x66>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80087b2:	6813      	ldr	r3, [r2, #0]
 80087b4:	069b      	lsls	r3, r3, #26
 80087b6:	d51a      	bpl.n	80087ee <HAL_RCC_GetSysClockFreq+0xf6>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 80087b8:	6810      	ldr	r0, [r2, #0]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80087ba:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 80087be:	490f      	ldr	r1, [pc, #60]	; (80087fc <HAL_RCC_GetSysClockFreq+0x104>)
 80087c0:	f3c0 00c1 	ubfx	r0, r0, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80087c4:	6b13      	ldr	r3, [r2, #48]	; 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 80087c6:	40c1      	lsrs	r1, r0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80087c8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80087cc:	ee06 1a90 	vmov	s13, r1
 80087d0:	eef8 5ae6 	vcvt.f32.s32	s11, s13
 80087d4:	ee06 3a90 	vmov	s13, r3
 80087d8:	eeb8 6ae6 	vcvt.f32.s32	s12, s13
 80087dc:	eec5 6aa7 	vdiv.f32	s13, s11, s15
 80087e0:	ee76 7a05 	vadd.f32	s15, s12, s10
 80087e4:	ee37 7a87 	vadd.f32	s14, s15, s14
 80087e8:	ee26 7a87 	vmul.f32	s14, s13, s14
 80087ec:	e7c8      	b.n	8008780 <HAL_RCC_GetSysClockFreq+0x88>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80087ee:	eddf 5a07 	vldr	s11, [pc, #28]	; 800880c <HAL_RCC_GetSysClockFreq+0x114>
 80087f2:	e7b4      	b.n	800875e <HAL_RCC_GetSysClockFreq+0x66>
 80087f4:	58024400 	.word	0x58024400
 80087f8:	003d0900 	.word	0x003d0900
 80087fc:	03d09000 	.word	0x03d09000
 8008800:	4a742400 	.word	0x4a742400
 8008804:	017d7840 	.word	0x017d7840
 8008808:	4bbebc20 	.word	0x4bbebc20
 800880c:	4c742400 	.word	0x4c742400

08008810 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8008810:	2800      	cmp	r0, #0
 8008812:	f000 81bd 	beq.w	8008b90 <HAL_RCC_ClockConfig+0x380>
{
 8008816:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 800881a:	6803      	ldr	r3, [r0, #0]
 800881c:	4604      	mov	r4, r0
 800881e:	460d      	mov	r5, r1
 8008820:	3b01      	subs	r3, #1
 8008822:	2b3e      	cmp	r3, #62	; 0x3e
 8008824:	f200 81a1 	bhi.w	8008b6a <HAL_RCC_ClockConfig+0x35a>
  assert_param(IS_FLASH_LATENCY(FLatency));
 8008828:	2d0f      	cmp	r5, #15
 800882a:	f200 818e 	bhi.w	8008b4a <HAL_RCC_ClockConfig+0x33a>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800882e:	4a5e      	ldr	r2, [pc, #376]	; (80089a8 <HAL_RCC_ClockConfig+0x198>)
 8008830:	6813      	ldr	r3, [r2, #0]
 8008832:	f003 030f 	and.w	r3, r3, #15
 8008836:	42ab      	cmp	r3, r5
 8008838:	f0c0 81ac 	bcc.w	8008b94 <HAL_RCC_ClockConfig+0x384>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 800883c:	6823      	ldr	r3, [r4, #0]
 800883e:	075e      	lsls	r6, r3, #29
 8008840:	d512      	bpl.n	8008868 <HAL_RCC_ClockConfig+0x58>
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 8008842:	4a5a      	ldr	r2, [pc, #360]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 8008844:	6921      	ldr	r1, [r4, #16]
 8008846:	6992      	ldr	r2, [r2, #24]
 8008848:	f002 0270 	and.w	r2, r2, #112	; 0x70
 800884c:	4291      	cmp	r1, r2
 800884e:	d90b      	bls.n	8008868 <HAL_RCC_ClockConfig+0x58>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
 8008850:	f021 0330 	bic.w	r3, r1, #48	; 0x30
 8008854:	2b40      	cmp	r3, #64	; 0x40
 8008856:	f040 81c0 	bne.w	8008bda <HAL_RCC_ClockConfig+0x3ca>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 800885a:	4a54      	ldr	r2, [pc, #336]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 800885c:	6993      	ldr	r3, [r2, #24]
 800885e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8008862:	4319      	orrs	r1, r3
 8008864:	6191      	str	r1, [r2, #24]
 8008866:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8008868:	0718      	lsls	r0, r3, #28
 800886a:	d512      	bpl.n	8008892 <HAL_RCC_ClockConfig+0x82>
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 800886c:	4a4f      	ldr	r2, [pc, #316]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 800886e:	6961      	ldr	r1, [r4, #20]
 8008870:	69d2      	ldr	r2, [r2, #28]
 8008872:	f002 0270 	and.w	r2, r2, #112	; 0x70
 8008876:	4291      	cmp	r1, r2
 8008878:	d90b      	bls.n	8008892 <HAL_RCC_ClockConfig+0x82>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
 800887a:	f021 0330 	bic.w	r3, r1, #48	; 0x30
 800887e:	2b40      	cmp	r3, #64	; 0x40
 8008880:	f040 81b2 	bne.w	8008be8 <HAL_RCC_ClockConfig+0x3d8>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8008884:	4a49      	ldr	r2, [pc, #292]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 8008886:	69d3      	ldr	r3, [r2, #28]
 8008888:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800888c:	4319      	orrs	r1, r3
 800888e:	61d1      	str	r1, [r2, #28]
 8008890:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8008892:	06d9      	lsls	r1, r3, #27
 8008894:	d513      	bpl.n	80088be <HAL_RCC_ClockConfig+0xae>
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8008896:	4a45      	ldr	r2, [pc, #276]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 8008898:	69a1      	ldr	r1, [r4, #24]
 800889a:	69d2      	ldr	r2, [r2, #28]
 800889c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80088a0:	4291      	cmp	r1, r2
 80088a2:	d90c      	bls.n	80088be <HAL_RCC_ClockConfig+0xae>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
 80088a4:	f421 7340 	bic.w	r3, r1, #768	; 0x300
 80088a8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80088ac:	f040 81a3 	bne.w	8008bf6 <HAL_RCC_ClockConfig+0x3e6>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 80088b0:	4a3e      	ldr	r2, [pc, #248]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 80088b2:	69d3      	ldr	r3, [r2, #28]
 80088b4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80088b8:	4319      	orrs	r1, r3
 80088ba:	61d1      	str	r1, [r2, #28]
 80088bc:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 80088be:	069a      	lsls	r2, r3, #26
 80088c0:	d512      	bpl.n	80088e8 <HAL_RCC_ClockConfig+0xd8>
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 80088c2:	4a3a      	ldr	r2, [pc, #232]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 80088c4:	69e1      	ldr	r1, [r4, #28]
 80088c6:	6a12      	ldr	r2, [r2, #32]
 80088c8:	f002 0270 	and.w	r2, r2, #112	; 0x70
 80088cc:	4291      	cmp	r1, r2
 80088ce:	d90b      	bls.n	80088e8 <HAL_RCC_ClockConfig+0xd8>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
 80088d0:	f021 0330 	bic.w	r3, r1, #48	; 0x30
 80088d4:	2b40      	cmp	r3, #64	; 0x40
 80088d6:	f040 8179 	bne.w	8008bcc <HAL_RCC_ClockConfig+0x3bc>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 80088da:	4a34      	ldr	r2, [pc, #208]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 80088dc:	6a13      	ldr	r3, [r2, #32]
 80088de:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80088e2:	4319      	orrs	r1, r3
 80088e4:	6211      	str	r1, [r2, #32]
 80088e6:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80088e8:	079f      	lsls	r7, r3, #30
 80088ea:	d512      	bpl.n	8008912 <HAL_RCC_ClockConfig+0x102>
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 80088ec:	4a2f      	ldr	r2, [pc, #188]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 80088ee:	68e1      	ldr	r1, [r4, #12]
 80088f0:	6992      	ldr	r2, [r2, #24]
 80088f2:	f002 020f 	and.w	r2, r2, #15
 80088f6:	4291      	cmp	r1, r2
 80088f8:	d90b      	bls.n	8008912 <HAL_RCC_ClockConfig+0x102>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 80088fa:	f1a1 0308 	sub.w	r3, r1, #8
 80088fe:	2b07      	cmp	r3, #7
 8008900:	f200 8180 	bhi.w	8008c04 <HAL_RCC_ClockConfig+0x3f4>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8008904:	4a29      	ldr	r2, [pc, #164]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 8008906:	6993      	ldr	r3, [r2, #24]
 8008908:	f023 030f 	bic.w	r3, r3, #15
 800890c:	4319      	orrs	r1, r3
 800890e:	6191      	str	r1, [r2, #24]
 8008910:	6823      	ldr	r3, [r4, #0]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8008912:	07de      	lsls	r6, r3, #31
 8008914:	d55a      	bpl.n	80089cc <HAL_RCC_ClockConfig+0x1bc>
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
 8008916:	68a2      	ldr	r2, [r4, #8]
 8008918:	f432 6300 	bics.w	r3, r2, #2048	; 0x800
 800891c:	f422 7000 	bic.w	r0, r2, #512	; 0x200
 8008920:	f422 6180 	bic.w	r1, r2, #1024	; 0x400
 8008924:	bf14      	ite	ne
 8008926:	2301      	movne	r3, #1
 8008928:	2300      	moveq	r3, #0
 800892a:	f5b0 6f10 	cmp.w	r0, #2304	; 0x900
 800892e:	bf0c      	ite	eq
 8008930:	2300      	moveq	r3, #0
 8008932:	f003 0301 	andne.w	r3, r3, #1
 8008936:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 800893a:	bf0c      	ite	eq
 800893c:	2300      	moveq	r3, #0
 800893e:	f003 0301 	andne.w	r3, r3, #1
 8008942:	f5b1 6f20 	cmp.w	r1, #2560	; 0xa00
 8008946:	bf0c      	ite	eq
 8008948:	2300      	moveq	r3, #0
 800894a:	f003 0301 	andne.w	r3, r3, #1
 800894e:	b12b      	cbz	r3, 800895c <HAL_RCC_ClockConfig+0x14c>
 8008950:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8008954:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 8008958:	f040 812e 	bne.w	8008bb8 <HAL_RCC_ClockConfig+0x3a8>
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 800895c:	6863      	ldr	r3, [r4, #4]
 800895e:	2b03      	cmp	r3, #3
 8008960:	f200 8110 	bhi.w	8008b84 <HAL_RCC_ClockConfig+0x374>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
 8008964:	4a11      	ldr	r2, [pc, #68]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
 8008966:	68a1      	ldr	r1, [r4, #8]
 8008968:	6993      	ldr	r3, [r2, #24]
 800896a:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 800896e:	430b      	orrs	r3, r1
 8008970:	6193      	str	r3, [r2, #24]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008972:	6863      	ldr	r3, [r4, #4]
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8008974:	6812      	ldr	r2, [r2, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008976:	2b02      	cmp	r3, #2
 8008978:	f000 8100 	beq.w	8008b7c <HAL_RCC_ClockConfig+0x36c>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800897c:	2b03      	cmp	r3, #3
 800897e:	f000 8117 	beq.w	8008bb0 <HAL_RCC_ClockConfig+0x3a0>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 8008982:	2b01      	cmp	r3, #1
 8008984:	f000 811e 	beq.w	8008bc4 <HAL_RCC_ClockConfig+0x3b4>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8008988:	0757      	lsls	r7, r2, #29
 800898a:	f140 80eb 	bpl.w	8008b64 <HAL_RCC_ClockConfig+0x354>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800898e:	4907      	ldr	r1, [pc, #28]	; (80089ac <HAL_RCC_ClockConfig+0x19c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008990:	f241 3888 	movw	r8, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8008994:	690a      	ldr	r2, [r1, #16]
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8008996:	460e      	mov	r6, r1
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8008998:	f022 0207 	bic.w	r2, r2, #7
 800899c:	4313      	orrs	r3, r2
 800899e:	610b      	str	r3, [r1, #16]
      tickstart = HAL_GetTick();
 80089a0:	f7f8 f842 	bl	8000a28 <HAL_GetTick>
 80089a4:	4607      	mov	r7, r0
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80089a6:	e009      	b.n	80089bc <HAL_RCC_ClockConfig+0x1ac>
 80089a8:	52002000 	.word	0x52002000
 80089ac:	58024400 	.word	0x58024400
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80089b0:	f7f8 f83a 	bl	8000a28 <HAL_GetTick>
 80089b4:	1bc0      	subs	r0, r0, r7
 80089b6:	4540      	cmp	r0, r8
 80089b8:	f200 80f8 	bhi.w	8008bac <HAL_RCC_ClockConfig+0x39c>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80089bc:	6933      	ldr	r3, [r6, #16]
 80089be:	6862      	ldr	r2, [r4, #4]
 80089c0:	f003 0338 	and.w	r3, r3, #56	; 0x38
 80089c4:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
 80089c8:	d1f2      	bne.n	80089b0 <HAL_RCC_ClockConfig+0x1a0>
 80089ca:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80089cc:	079e      	lsls	r6, r3, #30
 80089ce:	d517      	bpl.n	8008a00 <HAL_RCC_ClockConfig+0x1f0>
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 80089d0:	4b90      	ldr	r3, [pc, #576]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 80089d2:	68e2      	ldr	r2, [r4, #12]
 80089d4:	699b      	ldr	r3, [r3, #24]
 80089d6:	f003 030f 	and.w	r3, r3, #15
 80089da:	429a      	cmp	r2, r3
 80089dc:	d210      	bcs.n	8008a00 <HAL_RCC_ClockConfig+0x1f0>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 80089de:	f1a2 0308 	sub.w	r3, r2, #8
 80089e2:	2b06      	cmp	r3, #6
 80089e4:	d906      	bls.n	80089f4 <HAL_RCC_ClockConfig+0x1e4>
 80089e6:	b12a      	cbz	r2, 80089f4 <HAL_RCC_ClockConfig+0x1e4>
 80089e8:	f240 4136 	movw	r1, #1078	; 0x436
 80089ec:	488a      	ldr	r0, [pc, #552]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 80089ee:	f00a ff6f 	bl	80138d0 <assert_failed>
 80089f2:	68e2      	ldr	r2, [r4, #12]
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80089f4:	4987      	ldr	r1, [pc, #540]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 80089f6:	698b      	ldr	r3, [r1, #24]
 80089f8:	f023 030f 	bic.w	r3, r3, #15
 80089fc:	431a      	orrs	r2, r3
 80089fe:	618a      	str	r2, [r1, #24]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8008a00:	4a86      	ldr	r2, [pc, #536]	; (8008c1c <HAL_RCC_ClockConfig+0x40c>)
 8008a02:	6813      	ldr	r3, [r2, #0]
 8008a04:	f003 030f 	and.w	r3, r3, #15
 8008a08:	42ab      	cmp	r3, r5
 8008a0a:	d90a      	bls.n	8008a22 <HAL_RCC_ClockConfig+0x212>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008a0c:	6813      	ldr	r3, [r2, #0]
 8008a0e:	f023 030f 	bic.w	r3, r3, #15
 8008a12:	432b      	orrs	r3, r5
 8008a14:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008a16:	6813      	ldr	r3, [r2, #0]
 8008a18:	f003 030f 	and.w	r3, r3, #15
 8008a1c:	42ab      	cmp	r3, r5
 8008a1e:	f040 80a1 	bne.w	8008b64 <HAL_RCC_ClockConfig+0x354>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 8008a22:	6823      	ldr	r3, [r4, #0]
 8008a24:	0758      	lsls	r0, r3, #29
 8008a26:	d51a      	bpl.n	8008a5e <HAL_RCC_ClockConfig+0x24e>
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 8008a28:	4a7a      	ldr	r2, [pc, #488]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 8008a2a:	6921      	ldr	r1, [r4, #16]
 8008a2c:	6992      	ldr	r2, [r2, #24]
 8008a2e:	f002 0270 	and.w	r2, r2, #112	; 0x70
 8008a32:	4291      	cmp	r1, r2
 8008a34:	d213      	bcs.n	8008a5e <HAL_RCC_ClockConfig+0x24e>
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
 8008a36:	2950      	cmp	r1, #80	; 0x50
 8008a38:	bf18      	it	ne
 8008a3a:	2960      	cmpne	r1, #96	; 0x60
 8008a3c:	d008      	beq.n	8008a50 <HAL_RCC_ClockConfig+0x240>
 8008a3e:	f031 0340 	bics.w	r3, r1, #64	; 0x40
 8008a42:	d005      	beq.n	8008a50 <HAL_RCC_ClockConfig+0x240>
 8008a44:	f240 4157 	movw	r1, #1111	; 0x457
 8008a48:	4873      	ldr	r0, [pc, #460]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008a4a:	f00a ff41 	bl	80138d0 <assert_failed>
 8008a4e:	6921      	ldr	r1, [r4, #16]
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 8008a50:	4a70      	ldr	r2, [pc, #448]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 8008a52:	6993      	ldr	r3, [r2, #24]
 8008a54:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8008a58:	4319      	orrs	r1, r3
 8008a5a:	6191      	str	r1, [r2, #24]
 8008a5c:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8008a5e:	0719      	lsls	r1, r3, #28
 8008a60:	d51a      	bpl.n	8008a98 <HAL_RCC_ClockConfig+0x288>
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8008a62:	4a6c      	ldr	r2, [pc, #432]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 8008a64:	6961      	ldr	r1, [r4, #20]
 8008a66:	69d2      	ldr	r2, [r2, #28]
 8008a68:	f002 0270 	and.w	r2, r2, #112	; 0x70
 8008a6c:	4291      	cmp	r1, r2
 8008a6e:	d213      	bcs.n	8008a98 <HAL_RCC_ClockConfig+0x288>
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
 8008a70:	2950      	cmp	r1, #80	; 0x50
 8008a72:	bf18      	it	ne
 8008a74:	2960      	cmpne	r1, #96	; 0x60
 8008a76:	d008      	beq.n	8008a8a <HAL_RCC_ClockConfig+0x27a>
 8008a78:	f031 0340 	bics.w	r3, r1, #64	; 0x40
 8008a7c:	d005      	beq.n	8008a8a <HAL_RCC_ClockConfig+0x27a>
 8008a7e:	f240 4169 	movw	r1, #1129	; 0x469
 8008a82:	4865      	ldr	r0, [pc, #404]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008a84:	f00a ff24 	bl	80138d0 <assert_failed>
 8008a88:	6961      	ldr	r1, [r4, #20]
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8008a8a:	4a62      	ldr	r2, [pc, #392]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 8008a8c:	69d3      	ldr	r3, [r2, #28]
 8008a8e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8008a92:	4319      	orrs	r1, r3
 8008a94:	61d1      	str	r1, [r2, #28]
 8008a96:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8008a98:	06da      	lsls	r2, r3, #27
 8008a9a:	d51c      	bpl.n	8008ad6 <HAL_RCC_ClockConfig+0x2c6>
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8008a9c:	4a5d      	ldr	r2, [pc, #372]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 8008a9e:	69a1      	ldr	r1, [r4, #24]
 8008aa0:	69d2      	ldr	r2, [r2, #28]
 8008aa2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8008aa6:	4291      	cmp	r1, r2
 8008aa8:	d215      	bcs.n	8008ad6 <HAL_RCC_ClockConfig+0x2c6>
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
 8008aaa:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
 8008aae:	bf18      	it	ne
 8008ab0:	f5b1 6fa0 	cmpne.w	r1, #1280	; 0x500
 8008ab4:	d008      	beq.n	8008ac8 <HAL_RCC_ClockConfig+0x2b8>
 8008ab6:	f431 6380 	bics.w	r3, r1, #1024	; 0x400
 8008aba:	d005      	beq.n	8008ac8 <HAL_RCC_ClockConfig+0x2b8>
 8008abc:	f240 417b 	movw	r1, #1147	; 0x47b
 8008ac0:	4855      	ldr	r0, [pc, #340]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008ac2:	f00a ff05 	bl	80138d0 <assert_failed>
 8008ac6:	69a1      	ldr	r1, [r4, #24]
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8008ac8:	4a52      	ldr	r2, [pc, #328]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 8008aca:	69d3      	ldr	r3, [r2, #28]
 8008acc:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8008ad0:	4319      	orrs	r1, r3
 8008ad2:	61d1      	str	r1, [r2, #28]
 8008ad4:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 8008ad6:	069b      	lsls	r3, r3, #26
 8008ad8:	d519      	bpl.n	8008b0e <HAL_RCC_ClockConfig+0x2fe>
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 8008ada:	4b4e      	ldr	r3, [pc, #312]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 8008adc:	69e2      	ldr	r2, [r4, #28]
 8008ade:	6a1b      	ldr	r3, [r3, #32]
 8008ae0:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8008ae4:	429a      	cmp	r2, r3
 8008ae6:	d212      	bcs.n	8008b0e <HAL_RCC_ClockConfig+0x2fe>
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
 8008ae8:	2a50      	cmp	r2, #80	; 0x50
 8008aea:	bf18      	it	ne
 8008aec:	2a60      	cmpne	r2, #96	; 0x60
 8008aee:	d008      	beq.n	8008b02 <HAL_RCC_ClockConfig+0x2f2>
 8008af0:	f032 0340 	bics.w	r3, r2, #64	; 0x40
 8008af4:	d005      	beq.n	8008b02 <HAL_RCC_ClockConfig+0x2f2>
 8008af6:	f240 418d 	movw	r1, #1165	; 0x48d
 8008afa:	4847      	ldr	r0, [pc, #284]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008afc:	f00a fee8 	bl	80138d0 <assert_failed>
 8008b00:	69e2      	ldr	r2, [r4, #28]
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 8008b02:	4944      	ldr	r1, [pc, #272]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 8008b04:	6a0b      	ldr	r3, [r1, #32]
 8008b06:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8008b0a:	431a      	orrs	r2, r3
 8008b0c:	620a      	str	r2, [r1, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8008b0e:	f7ff fdf3 	bl	80086f8 <HAL_RCC_GetSysClockFreq>
 8008b12:	4a40      	ldr	r2, [pc, #256]	; (8008c14 <HAL_RCC_ClockConfig+0x404>)
 8008b14:	4942      	ldr	r1, [pc, #264]	; (8008c20 <HAL_RCC_ClockConfig+0x410>)
 8008b16:	6993      	ldr	r3, [r2, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008b18:	6992      	ldr	r2, [r2, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8008b1a:	f3c3 2303 	ubfx	r3, r3, #8, #4
  halstatus = HAL_InitTick (uwTickPrio);
 8008b1e:	4d41      	ldr	r5, [pc, #260]	; (8008c24 <HAL_RCC_ClockConfig+0x414>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008b20:	f002 020f 	and.w	r2, r2, #15
 8008b24:	4c40      	ldr	r4, [pc, #256]	; (8008c28 <HAL_RCC_ClockConfig+0x418>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8008b26:	5ccb      	ldrb	r3, [r1, r3]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008b28:	5c8a      	ldrb	r2, [r1, r2]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8008b2a:	f003 031f 	and.w	r3, r3, #31
  SystemCoreClock = common_system_clock;
 8008b2e:	493f      	ldr	r1, [pc, #252]	; (8008c2c <HAL_RCC_ClockConfig+0x41c>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008b30:	f002 021f 	and.w	r2, r2, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8008b34:	fa20 f303 	lsr.w	r3, r0, r3
  halstatus = HAL_InitTick (uwTickPrio);
 8008b38:	6828      	ldr	r0, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008b3a:	fa23 f202 	lsr.w	r2, r3, r2
  SystemCoreClock = common_system_clock;
 8008b3e:	600b      	str	r3, [r1, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008b40:	6022      	str	r2, [r4, #0]
}
 8008b42:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick (uwTickPrio);
 8008b46:	f7f7 bf0b 	b.w	8000960 <HAL_InitTick>
  assert_param(IS_FLASH_LATENCY(FLatency));
 8008b4a:	f44f 7160 	mov.w	r1, #896	; 0x380
 8008b4e:	4832      	ldr	r0, [pc, #200]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008b50:	f00a febe 	bl	80138d0 <assert_failed>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8008b54:	4b31      	ldr	r3, [pc, #196]	; (8008c1c <HAL_RCC_ClockConfig+0x40c>)
 8008b56:	681a      	ldr	r2, [r3, #0]
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008b58:	6819      	ldr	r1, [r3, #0]
 8008b5a:	f021 010f 	bic.w	r1, r1, #15
 8008b5e:	430d      	orrs	r5, r1
 8008b60:	601d      	str	r5, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008b62:	681b      	ldr	r3, [r3, #0]
    return HAL_ERROR;
 8008b64:	2001      	movs	r0, #1
}
 8008b66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 8008b6a:	f240 317f 	movw	r1, #895	; 0x37f
 8008b6e:	482a      	ldr	r0, [pc, #168]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008b70:	f00a feae 	bl	80138d0 <assert_failed>
  assert_param(IS_FLASH_LATENCY(FLatency));
 8008b74:	2d0f      	cmp	r5, #15
 8008b76:	f67f ae5a 	bls.w	800882e <HAL_RCC_ClockConfig+0x1e>
 8008b7a:	e7e6      	b.n	8008b4a <HAL_RCC_ClockConfig+0x33a>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8008b7c:	0390      	lsls	r0, r2, #14
 8008b7e:	f53f af06 	bmi.w	800898e <HAL_RCC_ClockConfig+0x17e>
 8008b82:	e7ef      	b.n	8008b64 <HAL_RCC_ClockConfig+0x354>
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 8008b84:	f240 31f5 	movw	r1, #1013	; 0x3f5
 8008b88:	4823      	ldr	r0, [pc, #140]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008b8a:	f00a fea1 	bl	80138d0 <assert_failed>
 8008b8e:	e6e9      	b.n	8008964 <HAL_RCC_ClockConfig+0x154>
    return HAL_ERROR;
 8008b90:	2001      	movs	r0, #1
}
 8008b92:	4770      	bx	lr
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008b94:	6813      	ldr	r3, [r2, #0]
 8008b96:	f023 030f 	bic.w	r3, r3, #15
 8008b9a:	432b      	orrs	r3, r5
 8008b9c:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008b9e:	6813      	ldr	r3, [r2, #0]
 8008ba0:	f003 030f 	and.w	r3, r3, #15
 8008ba4:	42ab      	cmp	r3, r5
 8008ba6:	f43f ae49 	beq.w	800883c <HAL_RCC_ClockConfig+0x2c>
 8008baa:	e7db      	b.n	8008b64 <HAL_RCC_ClockConfig+0x354>
            return HAL_TIMEOUT;
 8008bac:	2003      	movs	r0, #3
 8008bae:	e7da      	b.n	8008b66 <HAL_RCC_ClockConfig+0x356>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8008bb0:	0191      	lsls	r1, r2, #6
 8008bb2:	f53f aeec 	bmi.w	800898e <HAL_RCC_ClockConfig+0x17e>
 8008bb6:	e7d5      	b.n	8008b64 <HAL_RCC_ClockConfig+0x354>
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
 8008bb8:	f44f 717d 	mov.w	r1, #1012	; 0x3f4
 8008bbc:	4816      	ldr	r0, [pc, #88]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008bbe:	f00a fe87 	bl	80138d0 <assert_failed>
 8008bc2:	e6cb      	b.n	800895c <HAL_RCC_ClockConfig+0x14c>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 8008bc4:	05d2      	lsls	r2, r2, #23
 8008bc6:	f53f aee2 	bmi.w	800898e <HAL_RCC_ClockConfig+0x17e>
 8008bca:	e7cb      	b.n	8008b64 <HAL_RCC_ClockConfig+0x354>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
 8008bcc:	f240 31d1 	movw	r1, #977	; 0x3d1
 8008bd0:	4811      	ldr	r0, [pc, #68]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008bd2:	f00a fe7d 	bl	80138d0 <assert_failed>
 8008bd6:	69e1      	ldr	r1, [r4, #28]
 8008bd8:	e67f      	b.n	80088da <HAL_RCC_ClockConfig+0xca>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
 8008bda:	f44f 7167 	mov.w	r1, #924	; 0x39c
 8008bde:	480e      	ldr	r0, [pc, #56]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008be0:	f00a fe76 	bl	80138d0 <assert_failed>
 8008be4:	6921      	ldr	r1, [r4, #16]
 8008be6:	e638      	b.n	800885a <HAL_RCC_ClockConfig+0x4a>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
 8008be8:	f240 31ae 	movw	r1, #942	; 0x3ae
 8008bec:	480a      	ldr	r0, [pc, #40]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008bee:	f00a fe6f 	bl	80138d0 <assert_failed>
 8008bf2:	6961      	ldr	r1, [r4, #20]
 8008bf4:	e646      	b.n	8008884 <HAL_RCC_ClockConfig+0x74>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
 8008bf6:	f240 31bf 	movw	r1, #959	; 0x3bf
 8008bfa:	4807      	ldr	r0, [pc, #28]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008bfc:	f00a fe68 	bl	80138d0 <assert_failed>
 8008c00:	69a1      	ldr	r1, [r4, #24]
 8008c02:	e655      	b.n	80088b0 <HAL_RCC_ClockConfig+0xa0>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8008c04:	f44f 7179 	mov.w	r1, #996	; 0x3e4
 8008c08:	4803      	ldr	r0, [pc, #12]	; (8008c18 <HAL_RCC_ClockConfig+0x408>)
 8008c0a:	f00a fe61 	bl	80138d0 <assert_failed>
 8008c0e:	68e1      	ldr	r1, [r4, #12]
 8008c10:	e678      	b.n	8008904 <HAL_RCC_ClockConfig+0xf4>
 8008c12:	bf00      	nop
 8008c14:	58024400 	.word	0x58024400
 8008c18:	0802934c 	.word	0x0802934c
 8008c1c:	52002000 	.word	0x52002000
 8008c20:	0802a1f8 	.word	0x0802a1f8
 8008c24:	20000004 	.word	0x20000004
 8008c28:	200002c0 	.word	0x200002c0
 8008c2c:	200002bc 	.word	0x200002bc

08008c30 <HAL_RCC_GetHCLKFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8008c30:	4a49      	ldr	r2, [pc, #292]	; (8008d58 <HAL_RCC_GetHCLKFreq+0x128>)
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8008c32:	b430      	push	{r4, r5}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8008c34:	6913      	ldr	r3, [r2, #16]
 8008c36:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8008c3a:	2b10      	cmp	r3, #16
 8008c3c:	d064      	beq.n	8008d08 <HAL_RCC_GetHCLKFreq+0xd8>
 8008c3e:	2b18      	cmp	r3, #24
 8008c40:	d022      	beq.n	8008c88 <HAL_RCC_GetHCLKFreq+0x58>
 8008c42:	b1bb      	cbz	r3, 8008c74 <HAL_RCC_GetHCLKFreq+0x44>
    sysclockfreq = CSI_VALUE;
 8008c44:	4b45      	ldr	r3, [pc, #276]	; (8008d5c <HAL_RCC_GetHCLKFreq+0x12c>)
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8008c46:	4944      	ldr	r1, [pc, #272]	; (8008d58 <HAL_RCC_GetHCLKFreq+0x128>)
 8008c48:	4845      	ldr	r0, [pc, #276]	; (8008d60 <HAL_RCC_GetHCLKFreq+0x130>)
 8008c4a:	698a      	ldr	r2, [r1, #24]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008c4c:	6989      	ldr	r1, [r1, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8008c4e:	f3c2 2203 	ubfx	r2, r2, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008c52:	4c44      	ldr	r4, [pc, #272]	; (8008d64 <HAL_RCC_GetHCLKFreq+0x134>)
 8008c54:	f001 010f 	and.w	r1, r1, #15
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 8008c58:	4d43      	ldr	r5, [pc, #268]	; (8008d68 <HAL_RCC_GetHCLKFreq+0x138>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8008c5a:	5c82      	ldrb	r2, [r0, r2]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008c5c:	5c40      	ldrb	r0, [r0, r1]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8008c5e:	f002 021f 	and.w	r2, r2, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008c62:	f000 001f 	and.w	r0, r0, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8008c66:	40d3      	lsrs	r3, r2
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008c68:	fa23 f000 	lsr.w	r0, r3, r0
  SystemCoreClock = common_system_clock;
 8008c6c:	602b      	str	r3, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008c6e:	6020      	str	r0, [r4, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
 8008c70:	bc30      	pop	{r4, r5}
 8008c72:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8008c74:	6813      	ldr	r3, [r2, #0]
 8008c76:	0699      	lsls	r1, r3, #26
 8008c78:	d548      	bpl.n	8008d0c <HAL_RCC_GetHCLKFreq+0xdc>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8008c7a:	6813      	ldr	r3, [r2, #0]
 8008c7c:	4a3b      	ldr	r2, [pc, #236]	; (8008d6c <HAL_RCC_GetHCLKFreq+0x13c>)
 8008c7e:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 8008c82:	fa22 f303 	lsr.w	r3, r2, r3
 8008c86:	e7de      	b.n	8008c46 <HAL_RCC_GetHCLKFreq+0x16>
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8008c88:	6a90      	ldr	r0, [r2, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 8008c8a:	6a93      	ldr	r3, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 8008c8c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 8008c8e:	f3c3 1305 	ubfx	r3, r3, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8008c92:	6b54      	ldr	r4, [r2, #52]	; 0x34
    if (pllm != 0U)
 8008c94:	2b00      	cmp	r3, #0
 8008c96:	d0d6      	beq.n	8008c46 <HAL_RCC_GetHCLKFreq+0x16>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8008c98:	f3c4 04cc 	ubfx	r4, r4, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 8008c9c:	f001 0101 	and.w	r1, r1, #1
 8008ca0:	ee07 3a90 	vmov	s15, r3
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8008ca4:	f000 0003 	and.w	r0, r0, #3
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8008ca8:	fb01 f304 	mul.w	r3, r1, r4
 8008cac:	eef8 6ae7 	vcvt.f32.s32	s13, s15
      switch (pllsource)
 8008cb0:	2801      	cmp	r0, #1
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8008cb2:	ee07 3a90 	vmov	s15, r3
 8008cb6:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
      switch (pllsource)
 8008cba:	d002      	beq.n	8008cc2 <HAL_RCC_GetHCLKFreq+0x92>
 8008cbc:	d32b      	bcc.n	8008d16 <HAL_RCC_GetHCLKFreq+0xe6>
 8008cbe:	2802      	cmp	r0, #2
 8008cc0:	d026      	beq.n	8008d10 <HAL_RCC_GetHCLKFreq+0xe0>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8008cc2:	ed9f 7a2b 	vldr	s14, [pc, #172]	; 8008d70 <HAL_RCC_GetHCLKFreq+0x140>
 8008cc6:	ee87 6a26 	vdiv.f32	s12, s14, s13
 8008cca:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8008ccc:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8008cd0:	ee07 3a10 	vmov	s14, r3
 8008cd4:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 8008cd8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8008cdc:	ee37 7a25 	vadd.f32	s14, s14, s11
 8008ce0:	ee77 7a27 	vadd.f32	s15, s14, s15
 8008ce4:	ee67 7a86 	vmul.f32	s15, s15, s12
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 8008ce8:	4b1b      	ldr	r3, [pc, #108]	; (8008d58 <HAL_RCC_GetHCLKFreq+0x128>)
 8008cea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008cec:	f3c3 2346 	ubfx	r3, r3, #9, #7
 8008cf0:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
 8008cf2:	ee07 3a10 	vmov	s14, r3
 8008cf6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8008cfa:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8008cfe:	eefc 7ae6 	vcvt.u32.f32	s15, s13
 8008d02:	ee17 3a90 	vmov	r3, s15
 8008d06:	e79e      	b.n	8008c46 <HAL_RCC_GetHCLKFreq+0x16>
    sysclockfreq = HSE_VALUE;
 8008d08:	4b1a      	ldr	r3, [pc, #104]	; (8008d74 <HAL_RCC_GetHCLKFreq+0x144>)
 8008d0a:	e79c      	b.n	8008c46 <HAL_RCC_GetHCLKFreq+0x16>
        sysclockfreq = (uint32_t) HSI_VALUE;
 8008d0c:	4b17      	ldr	r3, [pc, #92]	; (8008d6c <HAL_RCC_GetHCLKFreq+0x13c>)
 8008d0e:	e79a      	b.n	8008c46 <HAL_RCC_GetHCLKFreq+0x16>
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8008d10:	ed9f 7a19 	vldr	s14, [pc, #100]	; 8008d78 <HAL_RCC_GetHCLKFreq+0x148>
 8008d14:	e7d7      	b.n	8008cc6 <HAL_RCC_GetHCLKFreq+0x96>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8008d16:	6813      	ldr	r3, [r2, #0]
 8008d18:	069b      	lsls	r3, r3, #26
 8008d1a:	d51a      	bpl.n	8008d52 <HAL_RCC_GetHCLKFreq+0x122>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8008d1c:	6810      	ldr	r0, [r2, #0]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8008d1e:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8008d22:	4912      	ldr	r1, [pc, #72]	; (8008d6c <HAL_RCC_GetHCLKFreq+0x13c>)
 8008d24:	f3c0 00c1 	ubfx	r0, r0, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8008d28:	6b13      	ldr	r3, [r2, #48]	; 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8008d2a:	40c1      	lsrs	r1, r0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8008d2c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8008d30:	ee07 1a10 	vmov	s14, r1
 8008d34:	eef8 5ac7 	vcvt.f32.s32	s11, s14
 8008d38:	ee07 3a10 	vmov	s14, r3
 8008d3c:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
 8008d40:	ee85 7aa6 	vdiv.f32	s14, s11, s13
 8008d44:	ee76 6a05 	vadd.f32	s13, s12, s10
 8008d48:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8008d4c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8008d50:	e7ca      	b.n	8008ce8 <HAL_RCC_GetHCLKFreq+0xb8>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8008d52:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 8008d7c <HAL_RCC_GetHCLKFreq+0x14c>
 8008d56:	e7b6      	b.n	8008cc6 <HAL_RCC_GetHCLKFreq+0x96>
 8008d58:	58024400 	.word	0x58024400
 8008d5c:	003d0900 	.word	0x003d0900
 8008d60:	0802a1f8 	.word	0x0802a1f8
 8008d64:	200002c0 	.word	0x200002c0
 8008d68:	200002bc 	.word	0x200002bc
 8008d6c:	03d09000 	.word	0x03d09000
 8008d70:	4a742400 	.word	0x4a742400
 8008d74:	017d7840 	.word	0x017d7840
 8008d78:	4bbebc20 	.word	0x4bbebc20
 8008d7c:	4c742400 	.word	0x4c742400

08008d80 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 8008d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
 8008d82:	6803      	ldr	r3, [r0, #0]
{
 8008d84:	4604      	mov	r4, r0
 8008d86:	460e      	mov	r6, r1
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
 8008d88:	3b01      	subs	r3, #1
 8008d8a:	2b3e      	cmp	r3, #62	; 0x3e
 8008d8c:	f200 809a 	bhi.w	8008ec4 <RCCEx_PLL2_Config+0x144>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
 8008d90:	6863      	ldr	r3, [r4, #4]
 8008d92:	3b04      	subs	r3, #4
 8008d94:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
 8008d98:	f200 809f 	bhi.w	8008eda <RCCEx_PLL2_Config+0x15a>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
 8008d9c:	68a3      	ldr	r3, [r4, #8]
 8008d9e:	3b01      	subs	r3, #1
 8008da0:	2b7f      	cmp	r3, #127	; 0x7f
 8008da2:	f200 80a4 	bhi.w	8008eee <RCCEx_PLL2_Config+0x16e>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
 8008da6:	6923      	ldr	r3, [r4, #16]
 8008da8:	3b01      	subs	r3, #1
 8008daa:	2b7f      	cmp	r3, #127	; 0x7f
 8008dac:	f200 80a9 	bhi.w	8008f02 <RCCEx_PLL2_Config+0x182>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
 8008db0:	68e3      	ldr	r3, [r4, #12]
 8008db2:	3b01      	subs	r3, #1
 8008db4:	2b7f      	cmp	r3, #127	; 0x7f
 8008db6:	f200 80ae 	bhi.w	8008f16 <RCCEx_PLL2_Config+0x196>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
 8008dba:	6963      	ldr	r3, [r4, #20]
 8008dbc:	f033 03c0 	bics.w	r3, r3, #192	; 0xc0
 8008dc0:	f040 80b3 	bne.w	8008f2a <RCCEx_PLL2_Config+0x1aa>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
 8008dc4:	69a3      	ldr	r3, [r4, #24]
 8008dc6:	f033 0320 	bics.w	r3, r3, #32
 8008dca:	f040 80b8 	bne.w	8008f3e <RCCEx_PLL2_Config+0x1be>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
 8008dce:	69e3      	ldr	r3, [r4, #28]
 8008dd0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8008dd4:	d270      	bcs.n	8008eb8 <RCCEx_PLL2_Config+0x138>

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 8008dd6:	4a5f      	ldr	r2, [pc, #380]	; (8008f54 <RCCEx_PLL2_Config+0x1d4>)
 8008dd8:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8008dda:	f003 0303 	and.w	r3, r3, #3
 8008dde:	2b03      	cmp	r3, #3
 8008de0:	d066      	beq.n	8008eb0 <RCCEx_PLL2_Config+0x130>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 8008de2:	6813      	ldr	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8008de4:	4615      	mov	r5, r2
    __HAL_RCC_PLL2_DISABLE();
 8008de6:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8008dea:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8008dec:	f7f7 fe1c 	bl	8000a28 <HAL_GetTick>
 8008df0:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8008df2:	e004      	b.n	8008dfe <RCCEx_PLL2_Config+0x7e>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
 8008df4:	f7f7 fe18 	bl	8000a28 <HAL_GetTick>
 8008df8:	1bc0      	subs	r0, r0, r7
 8008dfa:	2802      	cmp	r0, #2
 8008dfc:	d85a      	bhi.n	8008eb4 <RCCEx_PLL2_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8008dfe:	682b      	ldr	r3, [r5, #0]
 8008e00:	011a      	lsls	r2, r3, #4
 8008e02:	d4f7      	bmi.n	8008df4 <RCCEx_PLL2_Config+0x74>
        return HAL_TIMEOUT;
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 8008e04:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8008e06:	6822      	ldr	r2, [r4, #0]
 8008e08:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 8008e0c:	4952      	ldr	r1, [pc, #328]	; (8008f58 <RCCEx_PLL2_Config+0x1d8>)
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 8008e0e:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
 8008e12:	62ab      	str	r3, [r5, #40]	; 0x28
 8008e14:	6867      	ldr	r7, [r4, #4]
 8008e16:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 8008e1a:	3f01      	subs	r7, #1
 8008e1c:	1e50      	subs	r0, r2, #1
 8008e1e:	3b01      	subs	r3, #1
 8008e20:	6922      	ldr	r2, [r4, #16]
 8008e22:	f3c7 0708 	ubfx	r7, r7, #0, #9
 8008e26:	025b      	lsls	r3, r3, #9
 8008e28:	0400      	lsls	r0, r0, #16
 8008e2a:	3a01      	subs	r2, #1
 8008e2c:	b29b      	uxth	r3, r3
 8008e2e:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
 8008e32:	0612      	lsls	r2, r2, #24
 8008e34:	4303      	orrs	r3, r0
 8008e36:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 8008e3a:	433b      	orrs	r3, r7
 8008e3c:	4313      	orrs	r3, r2
 8008e3e:	63ab      	str	r3, [r5, #56]	; 0x38
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 8008e40:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008e42:	6962      	ldr	r2, [r4, #20]
 8008e44:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8008e48:	4313      	orrs	r3, r2
 8008e4a:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 8008e4c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008e4e:	69a2      	ldr	r2, [r4, #24]
 8008e50:	f023 0320 	bic.w	r3, r3, #32
 8008e54:	4313      	orrs	r3, r2
 8008e56:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_DISABLE();
 8008e58:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008e5a:	f023 0310 	bic.w	r3, r3, #16
 8008e5e:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 8008e60:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8008e62:	69e3      	ldr	r3, [r4, #28]
 8008e64:	4011      	ands	r1, r2
 8008e66:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
 8008e6a:	63e9      	str	r1, [r5, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 8008e6c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008e6e:	f043 0310 	orr.w	r3, r3, #16
 8008e72:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 8008e74:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
 8008e76:	2e00      	cmp	r6, #0
 8008e78:	d067      	beq.n	8008f4a <RCCEx_PLL2_Config+0x1ca>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
 8008e7a:	2e01      	cmp	r6, #1
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 8008e7c:	bf0c      	ite	eq
 8008e7e:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 8008e82:	f443 1300 	orrne.w	r3, r3, #2097152	; 0x200000
 8008e86:	62eb      	str	r3, [r5, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 8008e88:	4b32      	ldr	r3, [pc, #200]	; (8008f54 <RCCEx_PLL2_Config+0x1d4>)
 8008e8a:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8008e8c:	461c      	mov	r4, r3
    __HAL_RCC_PLL2_ENABLE();
 8008e8e:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8008e92:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8008e94:	f7f7 fdc8 	bl	8000a28 <HAL_GetTick>
 8008e98:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8008e9a:	e004      	b.n	8008ea6 <RCCEx_PLL2_Config+0x126>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
 8008e9c:	f7f7 fdc4 	bl	8000a28 <HAL_GetTick>
 8008ea0:	1b40      	subs	r0, r0, r5
 8008ea2:	2802      	cmp	r0, #2
 8008ea4:	d806      	bhi.n	8008eb4 <RCCEx_PLL2_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8008ea6:	6823      	ldr	r3, [r4, #0]
 8008ea8:	011b      	lsls	r3, r3, #4
 8008eaa:	d5f7      	bpl.n	8008e9c <RCCEx_PLL2_Config+0x11c>
    }

  }


  return status;
 8008eac:	2000      	movs	r0, #0
}
 8008eae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 8008eb0:	2001      	movs	r0, #1
}
 8008eb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
 8008eb4:	2003      	movs	r0, #3
}
 8008eb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
 8008eb8:	f640 4186 	movw	r1, #3206	; 0xc86
 8008ebc:	4827      	ldr	r0, [pc, #156]	; (8008f5c <RCCEx_PLL2_Config+0x1dc>)
 8008ebe:	f00a fd07 	bl	80138d0 <assert_failed>
 8008ec2:	e788      	b.n	8008dd6 <RCCEx_PLL2_Config+0x56>
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
 8008ec4:	f640 417f 	movw	r1, #3199	; 0xc7f
 8008ec8:	4824      	ldr	r0, [pc, #144]	; (8008f5c <RCCEx_PLL2_Config+0x1dc>)
 8008eca:	f00a fd01 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
 8008ece:	6863      	ldr	r3, [r4, #4]
 8008ed0:	3b04      	subs	r3, #4
 8008ed2:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
 8008ed6:	f67f af61 	bls.w	8008d9c <RCCEx_PLL2_Config+0x1c>
 8008eda:	f44f 6148 	mov.w	r1, #3200	; 0xc80
 8008ede:	481f      	ldr	r0, [pc, #124]	; (8008f5c <RCCEx_PLL2_Config+0x1dc>)
 8008ee0:	f00a fcf6 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
 8008ee4:	68a3      	ldr	r3, [r4, #8]
 8008ee6:	3b01      	subs	r3, #1
 8008ee8:	2b7f      	cmp	r3, #127	; 0x7f
 8008eea:	f67f af5c 	bls.w	8008da6 <RCCEx_PLL2_Config+0x26>
 8008eee:	f640 4181 	movw	r1, #3201	; 0xc81
 8008ef2:	481a      	ldr	r0, [pc, #104]	; (8008f5c <RCCEx_PLL2_Config+0x1dc>)
 8008ef4:	f00a fcec 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
 8008ef8:	6923      	ldr	r3, [r4, #16]
 8008efa:	3b01      	subs	r3, #1
 8008efc:	2b7f      	cmp	r3, #127	; 0x7f
 8008efe:	f67f af57 	bls.w	8008db0 <RCCEx_PLL2_Config+0x30>
 8008f02:	f640 4182 	movw	r1, #3202	; 0xc82
 8008f06:	4815      	ldr	r0, [pc, #84]	; (8008f5c <RCCEx_PLL2_Config+0x1dc>)
 8008f08:	f00a fce2 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
 8008f0c:	68e3      	ldr	r3, [r4, #12]
 8008f0e:	3b01      	subs	r3, #1
 8008f10:	2b7f      	cmp	r3, #127	; 0x7f
 8008f12:	f67f af52 	bls.w	8008dba <RCCEx_PLL2_Config+0x3a>
 8008f16:	f640 4183 	movw	r1, #3203	; 0xc83
 8008f1a:	4810      	ldr	r0, [pc, #64]	; (8008f5c <RCCEx_PLL2_Config+0x1dc>)
 8008f1c:	f00a fcd8 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
 8008f20:	6963      	ldr	r3, [r4, #20]
 8008f22:	f033 03c0 	bics.w	r3, r3, #192	; 0xc0
 8008f26:	f43f af4d 	beq.w	8008dc4 <RCCEx_PLL2_Config+0x44>
 8008f2a:	f640 4184 	movw	r1, #3204	; 0xc84
 8008f2e:	480b      	ldr	r0, [pc, #44]	; (8008f5c <RCCEx_PLL2_Config+0x1dc>)
 8008f30:	f00a fcce 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
 8008f34:	69a3      	ldr	r3, [r4, #24]
 8008f36:	f033 0320 	bics.w	r3, r3, #32
 8008f3a:	f43f af48 	beq.w	8008dce <RCCEx_PLL2_Config+0x4e>
 8008f3e:	f640 4185 	movw	r1, #3205	; 0xc85
 8008f42:	4806      	ldr	r0, [pc, #24]	; (8008f5c <RCCEx_PLL2_Config+0x1dc>)
 8008f44:	f00a fcc4 	bl	80138d0 <assert_failed>
 8008f48:	e741      	b.n	8008dce <RCCEx_PLL2_Config+0x4e>
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 8008f4a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8008f4e:	62eb      	str	r3, [r5, #44]	; 0x2c
 8008f50:	e79a      	b.n	8008e88 <RCCEx_PLL2_Config+0x108>
 8008f52:	bf00      	nop
 8008f54:	58024400 	.word	0x58024400
 8008f58:	ffff0007 	.word	0xffff0007
 8008f5c:	08029384 	.word	0x08029384

08008f60 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 8008f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
 8008f62:	6803      	ldr	r3, [r0, #0]
{
 8008f64:	4604      	mov	r4, r0
 8008f66:	460e      	mov	r6, r1
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
 8008f68:	3b01      	subs	r3, #1
 8008f6a:	2b3e      	cmp	r3, #62	; 0x3e
 8008f6c:	f200 809a 	bhi.w	80090a4 <RCCEx_PLL3_Config+0x144>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
 8008f70:	6863      	ldr	r3, [r4, #4]
 8008f72:	3b04      	subs	r3, #4
 8008f74:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
 8008f78:	f200 809f 	bhi.w	80090ba <RCCEx_PLL3_Config+0x15a>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
 8008f7c:	68a3      	ldr	r3, [r4, #8]
 8008f7e:	3b01      	subs	r3, #1
 8008f80:	2b7f      	cmp	r3, #127	; 0x7f
 8008f82:	f200 80a4 	bhi.w	80090ce <RCCEx_PLL3_Config+0x16e>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
 8008f86:	6923      	ldr	r3, [r4, #16]
 8008f88:	3b01      	subs	r3, #1
 8008f8a:	2b7f      	cmp	r3, #127	; 0x7f
 8008f8c:	f200 80a9 	bhi.w	80090e2 <RCCEx_PLL3_Config+0x182>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
 8008f90:	68e3      	ldr	r3, [r4, #12]
 8008f92:	3b01      	subs	r3, #1
 8008f94:	2b7f      	cmp	r3, #127	; 0x7f
 8008f96:	f200 80ae 	bhi.w	80090f6 <RCCEx_PLL3_Config+0x196>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
 8008f9a:	6963      	ldr	r3, [r4, #20]
 8008f9c:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
 8008fa0:	f040 80b3 	bne.w	800910a <RCCEx_PLL3_Config+0x1aa>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
 8008fa4:	69a3      	ldr	r3, [r4, #24]
 8008fa6:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 8008faa:	f040 80b8 	bne.w	800911e <RCCEx_PLL3_Config+0x1be>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
 8008fae:	69e3      	ldr	r3, [r4, #28]
 8008fb0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8008fb4:	d270      	bcs.n	8009098 <RCCEx_PLL3_Config+0x138>

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 8008fb6:	4a5f      	ldr	r2, [pc, #380]	; (8009134 <RCCEx_PLL3_Config+0x1d4>)
 8008fb8:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8008fba:	f003 0303 	and.w	r3, r3, #3
 8008fbe:	2b03      	cmp	r3, #3
 8008fc0:	d066      	beq.n	8009090 <RCCEx_PLL3_Config+0x130>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 8008fc2:	6813      	ldr	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8008fc4:	4615      	mov	r5, r2
    __HAL_RCC_PLL3_DISABLE();
 8008fc6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8008fca:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8008fcc:	f7f7 fd2c 	bl	8000a28 <HAL_GetTick>
 8008fd0:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8008fd2:	e004      	b.n	8008fde <RCCEx_PLL3_Config+0x7e>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
 8008fd4:	f7f7 fd28 	bl	8000a28 <HAL_GetTick>
 8008fd8:	1bc0      	subs	r0, r0, r7
 8008fda:	2802      	cmp	r0, #2
 8008fdc:	d85a      	bhi.n	8009094 <RCCEx_PLL3_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8008fde:	682b      	ldr	r3, [r5, #0]
 8008fe0:	009a      	lsls	r2, r3, #2
 8008fe2:	d4f7      	bmi.n	8008fd4 <RCCEx_PLL3_Config+0x74>
        return HAL_TIMEOUT;
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 8008fe4:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8008fe6:	6822      	ldr	r2, [r4, #0]
 8008fe8:	f023 737c 	bic.w	r3, r3, #66060288	; 0x3f00000

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 8008fec:	4952      	ldr	r1, [pc, #328]	; (8009138 <RCCEx_PLL3_Config+0x1d8>)
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 8008fee:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
 8008ff2:	62ab      	str	r3, [r5, #40]	; 0x28
 8008ff4:	6867      	ldr	r7, [r4, #4]
 8008ff6:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 8008ffa:	3f01      	subs	r7, #1
 8008ffc:	1e50      	subs	r0, r2, #1
 8008ffe:	3b01      	subs	r3, #1
 8009000:	6922      	ldr	r2, [r4, #16]
 8009002:	f3c7 0708 	ubfx	r7, r7, #0, #9
 8009006:	025b      	lsls	r3, r3, #9
 8009008:	0400      	lsls	r0, r0, #16
 800900a:	3a01      	subs	r2, #1
 800900c:	b29b      	uxth	r3, r3
 800900e:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
 8009012:	0612      	lsls	r2, r2, #24
 8009014:	4303      	orrs	r3, r0
 8009016:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 800901a:	433b      	orrs	r3, r7
 800901c:	4313      	orrs	r3, r2
 800901e:	642b      	str	r3, [r5, #64]	; 0x40
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 8009020:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8009022:	6962      	ldr	r2, [r4, #20]
 8009024:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8009028:	4313      	orrs	r3, r2
 800902a:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 800902c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800902e:	69a2      	ldr	r2, [r4, #24]
 8009030:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8009034:	4313      	orrs	r3, r2
 8009036:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_DISABLE();
 8009038:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800903a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800903e:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 8009040:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8009042:	69e3      	ldr	r3, [r4, #28]
 8009044:	4011      	ands	r1, r2
 8009046:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
 800904a:	6469      	str	r1, [r5, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 800904c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800904e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8009052:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 8009054:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
 8009056:	2e00      	cmp	r6, #0
 8009058:	d067      	beq.n	800912a <RCCEx_PLL3_Config+0x1ca>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
 800905a:	2e01      	cmp	r6, #1
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 800905c:	bf0c      	ite	eq
 800905e:	f443 0300 	orreq.w	r3, r3, #8388608	; 0x800000
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 8009062:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
 8009066:	62eb      	str	r3, [r5, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 8009068:	4b32      	ldr	r3, [pc, #200]	; (8009134 <RCCEx_PLL3_Config+0x1d4>)
 800906a:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800906c:	461c      	mov	r4, r3
    __HAL_RCC_PLL3_ENABLE();
 800906e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8009072:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8009074:	f7f7 fcd8 	bl	8000a28 <HAL_GetTick>
 8009078:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800907a:	e004      	b.n	8009086 <RCCEx_PLL3_Config+0x126>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
 800907c:	f7f7 fcd4 	bl	8000a28 <HAL_GetTick>
 8009080:	1b40      	subs	r0, r0, r5
 8009082:	2802      	cmp	r0, #2
 8009084:	d806      	bhi.n	8009094 <RCCEx_PLL3_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8009086:	6823      	ldr	r3, [r4, #0]
 8009088:	009b      	lsls	r3, r3, #2
 800908a:	d5f7      	bpl.n	800907c <RCCEx_PLL3_Config+0x11c>
    }

  }


  return status;
 800908c:	2000      	movs	r0, #0
}
 800908e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 8009090:	2001      	movs	r0, #1
}
 8009092:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
 8009094:	2003      	movs	r0, #3
}
 8009096:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
 8009098:	f640 41ee 	movw	r1, #3310	; 0xcee
 800909c:	4827      	ldr	r0, [pc, #156]	; (800913c <RCCEx_PLL3_Config+0x1dc>)
 800909e:	f00a fc17 	bl	80138d0 <assert_failed>
 80090a2:	e788      	b.n	8008fb6 <RCCEx_PLL3_Config+0x56>
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
 80090a4:	f640 41e7 	movw	r1, #3303	; 0xce7
 80090a8:	4824      	ldr	r0, [pc, #144]	; (800913c <RCCEx_PLL3_Config+0x1dc>)
 80090aa:	f00a fc11 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
 80090ae:	6863      	ldr	r3, [r4, #4]
 80090b0:	3b04      	subs	r3, #4
 80090b2:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
 80090b6:	f67f af61 	bls.w	8008f7c <RCCEx_PLL3_Config+0x1c>
 80090ba:	f640 41e8 	movw	r1, #3304	; 0xce8
 80090be:	481f      	ldr	r0, [pc, #124]	; (800913c <RCCEx_PLL3_Config+0x1dc>)
 80090c0:	f00a fc06 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
 80090c4:	68a3      	ldr	r3, [r4, #8]
 80090c6:	3b01      	subs	r3, #1
 80090c8:	2b7f      	cmp	r3, #127	; 0x7f
 80090ca:	f67f af5c 	bls.w	8008f86 <RCCEx_PLL3_Config+0x26>
 80090ce:	f640 41e9 	movw	r1, #3305	; 0xce9
 80090d2:	481a      	ldr	r0, [pc, #104]	; (800913c <RCCEx_PLL3_Config+0x1dc>)
 80090d4:	f00a fbfc 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
 80090d8:	6923      	ldr	r3, [r4, #16]
 80090da:	3b01      	subs	r3, #1
 80090dc:	2b7f      	cmp	r3, #127	; 0x7f
 80090de:	f67f af57 	bls.w	8008f90 <RCCEx_PLL3_Config+0x30>
 80090e2:	f640 41ea 	movw	r1, #3306	; 0xcea
 80090e6:	4815      	ldr	r0, [pc, #84]	; (800913c <RCCEx_PLL3_Config+0x1dc>)
 80090e8:	f00a fbf2 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
 80090ec:	68e3      	ldr	r3, [r4, #12]
 80090ee:	3b01      	subs	r3, #1
 80090f0:	2b7f      	cmp	r3, #127	; 0x7f
 80090f2:	f67f af52 	bls.w	8008f9a <RCCEx_PLL3_Config+0x3a>
 80090f6:	f640 41eb 	movw	r1, #3307	; 0xceb
 80090fa:	4810      	ldr	r0, [pc, #64]	; (800913c <RCCEx_PLL3_Config+0x1dc>)
 80090fc:	f00a fbe8 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
 8009100:	6963      	ldr	r3, [r4, #20]
 8009102:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
 8009106:	f43f af4d 	beq.w	8008fa4 <RCCEx_PLL3_Config+0x44>
 800910a:	f640 41ec 	movw	r1, #3308	; 0xcec
 800910e:	480b      	ldr	r0, [pc, #44]	; (800913c <RCCEx_PLL3_Config+0x1dc>)
 8009110:	f00a fbde 	bl	80138d0 <assert_failed>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
 8009114:	69a3      	ldr	r3, [r4, #24]
 8009116:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800911a:	f43f af48 	beq.w	8008fae <RCCEx_PLL3_Config+0x4e>
 800911e:	f640 41ed 	movw	r1, #3309	; 0xced
 8009122:	4806      	ldr	r0, [pc, #24]	; (800913c <RCCEx_PLL3_Config+0x1dc>)
 8009124:	f00a fbd4 	bl	80138d0 <assert_failed>
 8009128:	e741      	b.n	8008fae <RCCEx_PLL3_Config+0x4e>
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 800912a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800912e:	62eb      	str	r3, [r5, #44]	; 0x2c
 8009130:	e79a      	b.n	8009068 <RCCEx_PLL3_Config+0x108>
 8009132:	bf00      	nop
 8009134:	58024400 	.word	0x58024400
 8009138:	ffff0007 	.word	0xffff0007
 800913c:	08029384 	.word	0x08029384

08009140 <HAL_RCCEx_PeriphCLKConfig>:
{
 8009140:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8009144:	6803      	ldr	r3, [r0, #0]
{
 8009146:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8009148:	f013 6600 	ands.w	r6, r3, #134217728	; 0x8000000
 800914c:	d016      	beq.n	800917c <HAL_RCCEx_PeriphCLKConfig+0x3c>
    switch(PeriphClkInit->SpdifrxClockSelection)
 800914e:	6e42      	ldr	r2, [r0, #100]	; 0x64
 8009150:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 8009154:	f000 8527 	beq.w	8009ba6 <HAL_RCCEx_PeriphCLKConfig+0xa66>
 8009158:	f240 861b 	bls.w	8009d92 <HAL_RCCEx_PeriphCLKConfig+0xc52>
 800915c:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 8009160:	f000 855b 	beq.w	8009c1a <HAL_RCCEx_PeriphCLKConfig+0xada>
 8009164:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
 8009168:	f040 8639 	bne.w	8009dde <HAL_RCCEx_PeriphCLKConfig+0xc9e>
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 800916c:	49b7      	ldr	r1, [pc, #732]	; (800944c <HAL_RCCEx_PeriphCLKConfig+0x30c>)
 800916e:	2600      	movs	r6, #0
 8009170:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 8009172:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8009176:	431a      	orrs	r2, r3
 8009178:	650a      	str	r2, [r1, #80]	; 0x50
 800917a:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 800917c:	05dd      	lsls	r5, r3, #23
 800917e:	d50a      	bpl.n	8009196 <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch(PeriphClkInit->Sai1ClockSelection)
 8009180:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8009182:	2a04      	cmp	r2, #4
 8009184:	d806      	bhi.n	8009194 <HAL_RCCEx_PeriphCLKConfig+0x54>
 8009186:	e8df f012 	tbh	[pc, r2, lsl #1]
 800918a:	04ac      	.short	0x04ac
 800918c:	04c404be 	.word	0x04c404be
 8009190:	04880488 	.word	0x04880488
      ret = HAL_ERROR;
 8009194:	2601      	movs	r6, #1
 8009196:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 8009198:	0598      	lsls	r0, r3, #22
 800919a:	d515      	bpl.n	80091c8 <HAL_RCCEx_PeriphCLKConfig+0x88>
    switch(PeriphClkInit->Sai23ClockSelection)
 800919c:	6da2      	ldr	r2, [r4, #88]	; 0x58
 800919e:	2a80      	cmp	r2, #128	; 0x80
 80091a0:	f000 850c 	beq.w	8009bbc <HAL_RCCEx_PeriphCLKConfig+0xa7c>
 80091a4:	f200 85ea 	bhi.w	8009d7c <HAL_RCCEx_PeriphCLKConfig+0xc3c>
 80091a8:	2a00      	cmp	r2, #0
 80091aa:	f000 853c 	beq.w	8009c26 <HAL_RCCEx_PeriphCLKConfig+0xae6>
 80091ae:	2a40      	cmp	r2, #64	; 0x40
 80091b0:	f040 85eb 	bne.w	8009d8a <HAL_RCCEx_PeriphCLKConfig+0xc4a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 80091b4:	2100      	movs	r1, #0
 80091b6:	1d20      	adds	r0, r4, #4
 80091b8:	f7ff fde2 	bl	8008d80 <RCCEx_PLL2_Config>
 80091bc:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 80091be:	2d00      	cmp	r5, #0
 80091c0:	f000 8505 	beq.w	8009bce <HAL_RCCEx_PeriphCLKConfig+0xa8e>
 80091c4:	6823      	ldr	r3, [r4, #0]
 80091c6:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 80091c8:	0559      	lsls	r1, r3, #21
 80091ca:	d518      	bpl.n	80091fe <HAL_RCCEx_PeriphCLKConfig+0xbe>
    switch(PeriphClkInit->Sai4AClockSelection)
 80091cc:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
 80091d0:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 80091d4:	f000 8505 	beq.w	8009be2 <HAL_RCCEx_PeriphCLKConfig+0xaa2>
 80091d8:	f200 85c4 	bhi.w	8009d64 <HAL_RCCEx_PeriphCLKConfig+0xc24>
 80091dc:	2a00      	cmp	r2, #0
 80091de:	f000 8530 	beq.w	8009c42 <HAL_RCCEx_PeriphCLKConfig+0xb02>
 80091e2:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 80091e6:	f040 85c5 	bne.w	8009d74 <HAL_RCCEx_PeriphCLKConfig+0xc34>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 80091ea:	2100      	movs	r1, #0
 80091ec:	1d20      	adds	r0, r4, #4
 80091ee:	f7ff fdc7 	bl	8008d80 <RCCEx_PLL2_Config>
 80091f2:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 80091f4:	2d00      	cmp	r5, #0
 80091f6:	f000 84fd 	beq.w	8009bf4 <HAL_RCCEx_PeriphCLKConfig+0xab4>
 80091fa:	6823      	ldr	r3, [r4, #0]
 80091fc:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 80091fe:	051a      	lsls	r2, r3, #20
 8009200:	d518      	bpl.n	8009234 <HAL_RCCEx_PeriphCLKConfig+0xf4>
    switch(PeriphClkInit->Sai4BClockSelection)
 8009202:	f8d4 20a8 	ldr.w	r2, [r4, #168]	; 0xa8
 8009206:	f1b2 7f00 	cmp.w	r2, #33554432	; 0x2000000
 800920a:	f000 84fe 	beq.w	8009c0a <HAL_RCCEx_PeriphCLKConfig+0xaca>
 800920e:	f200 85d5 	bhi.w	8009dbc <HAL_RCCEx_PeriphCLKConfig+0xc7c>
 8009212:	2a00      	cmp	r2, #0
 8009214:	f000 84b4 	beq.w	8009b80 <HAL_RCCEx_PeriphCLKConfig+0xa40>
 8009218:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
 800921c:	f040 85d6 	bne.w	8009dcc <HAL_RCCEx_PeriphCLKConfig+0xc8c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8009220:	2100      	movs	r1, #0
 8009222:	1d20      	adds	r0, r4, #4
 8009224:	f7ff fdac 	bl	8008d80 <RCCEx_PLL2_Config>
 8009228:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800922a:	2d00      	cmp	r5, #0
 800922c:	f000 84b0 	beq.w	8009b90 <HAL_RCCEx_PeriphCLKConfig+0xa50>
 8009230:	6823      	ldr	r3, [r4, #0]
 8009232:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 8009234:	019f      	lsls	r7, r3, #6
 8009236:	d50d      	bpl.n	8009254 <HAL_RCCEx_PeriphCLKConfig+0x114>
    switch(PeriphClkInit->QspiClockSelection)
 8009238:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800923a:	2a10      	cmp	r2, #16
 800923c:	f000 83f6 	beq.w	8009a2c <HAL_RCCEx_PeriphCLKConfig+0x8ec>
 8009240:	f240 85c8 	bls.w	8009dd4 <HAL_RCCEx_PeriphCLKConfig+0xc94>
 8009244:	2a20      	cmp	r2, #32
 8009246:	f000 83fa 	beq.w	8009a3e <HAL_RCCEx_PeriphCLKConfig+0x8fe>
 800924a:	2a30      	cmp	r2, #48	; 0x30
 800924c:	f000 83f3 	beq.w	8009a36 <HAL_RCCEx_PeriphCLKConfig+0x8f6>
      ret = HAL_ERROR;
 8009250:	2601      	movs	r6, #1
 8009252:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 8009254:	04d8      	lsls	r0, r3, #19
 8009256:	d517      	bpl.n	8009288 <HAL_RCCEx_PeriphCLKConfig+0x148>
    switch(PeriphClkInit->Spi123ClockSelection)
 8009258:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800925a:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 800925e:	f000 8477 	beq.w	8009b50 <HAL_RCCEx_PeriphCLKConfig+0xa10>
 8009262:	f200 859f 	bhi.w	8009da4 <HAL_RCCEx_PeriphCLKConfig+0xc64>
 8009266:	2a00      	cmp	r2, #0
 8009268:	f000 84e4 	beq.w	8009c34 <HAL_RCCEx_PeriphCLKConfig+0xaf4>
 800926c:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8009270:	f040 85a0 	bne.w	8009db4 <HAL_RCCEx_PeriphCLKConfig+0xc74>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8009274:	2100      	movs	r1, #0
 8009276:	1d20      	adds	r0, r4, #4
 8009278:	f7ff fd82 	bl	8008d80 <RCCEx_PLL2_Config>
 800927c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800927e:	2d00      	cmp	r5, #0
 8009280:	f000 846f 	beq.w	8009b62 <HAL_RCCEx_PeriphCLKConfig+0xa22>
 8009284:	6823      	ldr	r3, [r4, #0]
 8009286:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 8009288:	0499      	lsls	r1, r3, #18
 800928a:	d51b      	bpl.n	80092c4 <HAL_RCCEx_PeriphCLKConfig+0x184>
    switch(PeriphClkInit->Spi45ClockSelection)
 800928c:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800928e:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
 8009292:	f000 83e5 	beq.w	8009a60 <HAL_RCCEx_PeriphCLKConfig+0x920>
 8009296:	f200 8527 	bhi.w	8009ce8 <HAL_RCCEx_PeriphCLKConfig+0xba8>
 800929a:	b142      	cbz	r2, 80092ae <HAL_RCCEx_PeriphCLKConfig+0x16e>
 800929c:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 80092a0:	f040 852e 	bne.w	8009d00 <HAL_RCCEx_PeriphCLKConfig+0xbc0>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 80092a4:	2101      	movs	r1, #1
 80092a6:	1d20      	adds	r0, r4, #4
 80092a8:	f7ff fd6a 	bl	8008d80 <RCCEx_PLL2_Config>
 80092ac:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 80092ae:	2d00      	cmp	r5, #0
 80092b0:	f040 833b 	bne.w	800992a <HAL_RCCEx_PeriphCLKConfig+0x7ea>
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 80092b4:	4a65      	ldr	r2, [pc, #404]	; (800944c <HAL_RCCEx_PeriphCLKConfig+0x30c>)
 80092b6:	6e21      	ldr	r1, [r4, #96]	; 0x60
 80092b8:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80092ba:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
 80092be:	430b      	orrs	r3, r1
 80092c0:	6513      	str	r3, [r2, #80]	; 0x50
 80092c2:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 80092c4:	045a      	lsls	r2, r3, #17
 80092c6:	d51d      	bpl.n	8009304 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    switch(PeriphClkInit->Spi6ClockSelection)
 80092c8:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 80092cc:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 80092d0:	f000 83d0 	beq.w	8009a74 <HAL_RCCEx_PeriphCLKConfig+0x934>
 80092d4:	f200 8527 	bhi.w	8009d26 <HAL_RCCEx_PeriphCLKConfig+0xbe6>
 80092d8:	b142      	cbz	r2, 80092ec <HAL_RCCEx_PeriphCLKConfig+0x1ac>
 80092da:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 80092de:	f040 852e 	bne.w	8009d3e <HAL_RCCEx_PeriphCLKConfig+0xbfe>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 80092e2:	2101      	movs	r1, #1
 80092e4:	1d20      	adds	r0, r4, #4
 80092e6:	f7ff fd4b 	bl	8008d80 <RCCEx_PLL2_Config>
 80092ea:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 80092ec:	2d00      	cmp	r5, #0
 80092ee:	f040 8319 	bne.w	8009924 <HAL_RCCEx_PeriphCLKConfig+0x7e4>
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 80092f2:	4a56      	ldr	r2, [pc, #344]	; (800944c <HAL_RCCEx_PeriphCLKConfig+0x30c>)
 80092f4:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
 80092f8:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80092fa:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
 80092fe:	430b      	orrs	r3, r1
 8009300:	6593      	str	r3, [r2, #88]	; 0x58
 8009302:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 8009304:	041f      	lsls	r7, r3, #16
 8009306:	d50d      	bpl.n	8009324 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
    switch(PeriphClkInit->FdcanClockSelection)
 8009308:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800930a:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800930e:	f000 83bb 	beq.w	8009a88 <HAL_RCCEx_PeriphCLKConfig+0x948>
 8009312:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 8009316:	f000 8298 	beq.w	800984a <HAL_RCCEx_PeriphCLKConfig+0x70a>
 800931a:	2a00      	cmp	r2, #0
 800931c:	f000 829a 	beq.w	8009854 <HAL_RCCEx_PeriphCLKConfig+0x714>
      ret = HAL_ERROR;
 8009320:	2601      	movs	r6, #1
 8009322:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 8009324:	01d8      	lsls	r0, r3, #7
 8009326:	d50a      	bpl.n	800933e <HAL_RCCEx_PeriphCLKConfig+0x1fe>
    switch(PeriphClkInit->FmcClockSelection)
 8009328:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800932a:	2a03      	cmp	r2, #3
 800932c:	d805      	bhi.n	800933a <HAL_RCCEx_PeriphCLKConfig+0x1fa>
 800932e:	e8df f012 	tbh	[pc, r2, lsl #1]
 8009332:	0270      	.short	0x0270
 8009334:	026b033c 	.word	0x026b033c
 8009338:	0270      	.short	0x0270
      ret = HAL_ERROR;
 800933a:	2601      	movs	r6, #1
 800933c:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800933e:	0259      	lsls	r1, r3, #9
 8009340:	f140 80c9 	bpl.w	80094d6 <HAL_RCCEx_PeriphCLKConfig+0x396>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 8009344:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 8009348:	4f41      	ldr	r7, [pc, #260]	; (8009450 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 800934a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800934e:	bf18      	it	ne
 8009350:	f5b2 7f00 	cmpne.w	r2, #512	; 0x200
 8009354:	f422 4ca0 	bic.w	ip, r2, #20480	; 0x5000
 8009358:	f422 4010 	bic.w	r0, r2, #36864	; 0x9000
 800935c:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
 8009360:	bf14      	ite	ne
 8009362:	2301      	movne	r3, #1
 8009364:	2300      	moveq	r3, #0
 8009366:	f422 3e88 	bic.w	lr, r2, #69632	; 0x11000
 800936a:	f5bc 5f0c 	cmp.w	ip, #8960	; 0x2300
 800936e:	bf0c      	ite	eq
 8009370:	2300      	moveq	r3, #0
 8009372:	f003 0301 	andne.w	r3, r3, #1
 8009376:	f8df c0e4 	ldr.w	ip, [pc, #228]	; 800945c <HAL_RCCEx_PeriphCLKConfig+0x31c>
 800937a:	f5b0 4f86 	cmp.w	r0, #17152	; 0x4300
 800937e:	bf0c      	ite	eq
 8009380:	2300      	moveq	r3, #0
 8009382:	f003 0301 	andne.w	r3, r3, #1
 8009386:	4833      	ldr	r0, [pc, #204]	; (8009454 <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8009388:	f5b1 4f03 	cmp.w	r1, #33536	; 0x8300
 800938c:	bf0c      	ite	eq
 800938e:	2300      	moveq	r3, #0
 8009390:	f003 0301 	andne.w	r3, r3, #1
 8009394:	f5be 4f63 	cmp.w	lr, #58112	; 0xe300
 8009398:	bf0c      	ite	eq
 800939a:	2300      	moveq	r3, #0
 800939c:	f003 0301 	andne.w	r3, r3, #1
 80093a0:	f422 3e04 	bic.w	lr, r2, #135168	; 0x21000
 80093a4:	42b9      	cmp	r1, r7
 80093a6:	bf0c      	ite	eq
 80093a8:	2300      	moveq	r3, #0
 80093aa:	f003 0301 	andne.w	r3, r3, #1
 80093ae:	f507 4740 	add.w	r7, r7, #49152	; 0xc000
 80093b2:	4281      	cmp	r1, r0
 80093b4:	bf0c      	ite	eq
 80093b6:	2300      	moveq	r3, #0
 80093b8:	f003 0301 	andne.w	r3, r3, #1
 80093bc:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
 80093c0:	4561      	cmp	r1, ip
 80093c2:	bf0c      	ite	eq
 80093c4:	2300      	moveq	r3, #0
 80093c6:	f003 0301 	andne.w	r3, r3, #1
 80093ca:	f50c 4c40 	add.w	ip, ip, #49152	; 0xc000
 80093ce:	45be      	cmp	lr, r7
 80093d0:	bf0c      	ite	eq
 80093d2:	2300      	moveq	r3, #0
 80093d4:	f003 0301 	andne.w	r3, r3, #1
 80093d8:	f507 4740 	add.w	r7, r7, #49152	; 0xc000
 80093dc:	4281      	cmp	r1, r0
 80093de:	bf0c      	ite	eq
 80093e0:	2300      	moveq	r3, #0
 80093e2:	f003 0301 	andne.w	r3, r3, #1
 80093e6:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
 80093ea:	4561      	cmp	r1, ip
 80093ec:	bf0c      	ite	eq
 80093ee:	2300      	moveq	r3, #0
 80093f0:	f003 0301 	andne.w	r3, r3, #1
 80093f4:	f50c 4c40 	add.w	ip, ip, #49152	; 0xc000
 80093f8:	42b9      	cmp	r1, r7
 80093fa:	bf0c      	ite	eq
 80093fc:	2300      	moveq	r3, #0
 80093fe:	f003 0301 	andne.w	r3, r3, #1
 8009402:	f507 4740 	add.w	r7, r7, #49152	; 0xc000
 8009406:	4281      	cmp	r1, r0
 8009408:	bf0c      	ite	eq
 800940a:	2300      	moveq	r3, #0
 800940c:	f003 0301 	andne.w	r3, r3, #1
 8009410:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
 8009414:	4561      	cmp	r1, ip
 8009416:	bf0c      	ite	eq
 8009418:	2300      	moveq	r3, #0
 800941a:	f003 0301 	andne.w	r3, r3, #1
 800941e:	42b9      	cmp	r1, r7
 8009420:	bf0c      	ite	eq
 8009422:	2300      	moveq	r3, #0
 8009424:	f003 0301 	andne.w	r3, r3, #1
 8009428:	4281      	cmp	r1, r0
 800942a:	bf0c      	ite	eq
 800942c:	2300      	moveq	r3, #0
 800942e:	f003 0301 	andne.w	r3, r3, #1
 8009432:	2b00      	cmp	r3, #0
 8009434:	f040 81b7 	bne.w	80097a6 <HAL_RCCEx_PeriphCLKConfig+0x666>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8009438:	4b07      	ldr	r3, [pc, #28]	; (8009458 <HAL_RCCEx_PeriphCLKConfig+0x318>)
 800943a:	681a      	ldr	r2, [r3, #0]
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800943c:	461f      	mov	r7, r3
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800943e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8009442:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8009444:	f7f7 faf0 	bl	8000a28 <HAL_GetTick>
 8009448:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800944a:	e010      	b.n	800946e <HAL_RCCEx_PeriphCLKConfig+0x32e>
 800944c:	58024400 	.word	0x58024400
 8009450:	00010300 	.word	0x00010300
 8009454:	00014300 	.word	0x00014300
 8009458:	58024800 	.word	0x58024800
 800945c:	00018300 	.word	0x00018300
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8009460:	f7f7 fae2 	bl	8000a28 <HAL_GetTick>
 8009464:	eba0 0008 	sub.w	r0, r0, r8
 8009468:	2864      	cmp	r0, #100	; 0x64
 800946a:	f200 8245 	bhi.w	80098f8 <HAL_RCCEx_PeriphCLKConfig+0x7b8>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800946e:	683b      	ldr	r3, [r7, #0]
 8009470:	05da      	lsls	r2, r3, #23
 8009472:	d5f5      	bpl.n	8009460 <HAL_RCCEx_PeriphCLKConfig+0x320>
    if(ret == HAL_OK)
 8009474:	2d00      	cmp	r5, #0
 8009476:	f040 84c0 	bne.w	8009dfa <HAL_RCCEx_PeriphCLKConfig+0xcba>
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 800947a:	4b3e      	ldr	r3, [pc, #248]	; (8009574 <HAL_RCCEx_PeriphCLKConfig+0x434>)
 800947c:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 8009480:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8009482:	4051      	eors	r1, r2
 8009484:	f411 7f40 	tst.w	r1, #768	; 0x300
 8009488:	d00d      	beq.n	80094a6 <HAL_RCCEx_PeriphCLKConfig+0x366>
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800948a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_FORCE();
 800948c:	6f19      	ldr	r1, [r3, #112]	; 0x70
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800948e:	f422 7240 	bic.w	r2, r2, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
 8009492:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8009496:	6719      	str	r1, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 8009498:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800949a:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800949e:	6719      	str	r1, [r3, #112]	; 0x70
        RCC->BDCR = tmpreg;
 80094a0:	671a      	str	r2, [r3, #112]	; 0x70
 80094a2:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 80094a6:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80094aa:	f000 83f9 	beq.w	8009ca0 <HAL_RCCEx_PeriphCLKConfig+0xb60>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80094ae:	f402 7340 	and.w	r3, r2, #768	; 0x300
 80094b2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80094b6:	f000 8495 	beq.w	8009de4 <HAL_RCCEx_PeriphCLKConfig+0xca4>
 80094ba:	4a2e      	ldr	r2, [pc, #184]	; (8009574 <HAL_RCCEx_PeriphCLKConfig+0x434>)
 80094bc:	6913      	ldr	r3, [r2, #16]
 80094be:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 80094c2:	6113      	str	r3, [r2, #16]
 80094c4:	4a2b      	ldr	r2, [pc, #172]	; (8009574 <HAL_RCCEx_PeriphCLKConfig+0x434>)
 80094c6:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 80094ca:	6f11      	ldr	r1, [r2, #112]	; 0x70
 80094cc:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80094d0:	430b      	orrs	r3, r1
 80094d2:	6713      	str	r3, [r2, #112]	; 0x70
 80094d4:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 80094d6:	07df      	lsls	r7, r3, #31
 80094d8:	d52f      	bpl.n	800953a <HAL_RCCEx_PeriphCLKConfig+0x3fa>
    switch(PeriphClkInit->Usart16ClockSelection)
 80094da:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 80094dc:	2a28      	cmp	r2, #40	; 0x28
 80094de:	d82a      	bhi.n	8009536 <HAL_RCCEx_PeriphCLKConfig+0x3f6>
 80094e0:	e8df f012 	tbh	[pc, r2, lsl #1]
 80094e4:	002901a8 	.word	0x002901a8
 80094e8:	00290029 	.word	0x00290029
 80094ec:	00290029 	.word	0x00290029
 80094f0:	00290029 	.word	0x00290029
 80094f4:	0029028a 	.word	0x0029028a
 80094f8:	00290029 	.word	0x00290029
 80094fc:	00290029 	.word	0x00290029
 8009500:	00290029 	.word	0x00290029
 8009504:	002901a2 	.word	0x002901a2
 8009508:	00290029 	.word	0x00290029
 800950c:	00290029 	.word	0x00290029
 8009510:	00290029 	.word	0x00290029
 8009514:	002901a8 	.word	0x002901a8
 8009518:	00290029 	.word	0x00290029
 800951c:	00290029 	.word	0x00290029
 8009520:	00290029 	.word	0x00290029
 8009524:	002901a8 	.word	0x002901a8
 8009528:	00290029 	.word	0x00290029
 800952c:	00290029 	.word	0x00290029
 8009530:	00290029 	.word	0x00290029
 8009534:	01a8      	.short	0x01a8
      ret = HAL_ERROR;
 8009536:	2601      	movs	r6, #1
 8009538:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 800953a:	0798      	lsls	r0, r3, #30
 800953c:	d50c      	bpl.n	8009558 <HAL_RCCEx_PeriphCLKConfig+0x418>
    switch(PeriphClkInit->Usart234578ClockSelection)
 800953e:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8009540:	2a05      	cmp	r2, #5
 8009542:	d807      	bhi.n	8009554 <HAL_RCCEx_PeriphCLKConfig+0x414>
 8009544:	e8df f012 	tbh	[pc, r2, lsl #1]
 8009548:	021f0154 	.word	0x021f0154
 800954c:	0154014e 	.word	0x0154014e
 8009550:	01540154 	.word	0x01540154
      ret = HAL_ERROR;
 8009554:	2601      	movs	r6, #1
 8009556:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8009558:	0759      	lsls	r1, r3, #29
 800955a:	d50f      	bpl.n	800957c <HAL_RCCEx_PeriphCLKConfig+0x43c>
    switch(PeriphClkInit->Lpuart1ClockSelection)
 800955c:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8009560:	2a05      	cmp	r2, #5
 8009562:	d809      	bhi.n	8009578 <HAL_RCCEx_PeriphCLKConfig+0x438>
 8009564:	e8df f012 	tbh	[pc, r2, lsl #1]
 8009568:	02180131 	.word	0x02180131
 800956c:	0131012b 	.word	0x0131012b
 8009570:	01310131 	.word	0x01310131
 8009574:	58024400 	.word	0x58024400
      ret = HAL_ERROR;
 8009578:	2601      	movs	r6, #1
 800957a:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800957c:	069a      	lsls	r2, r3, #26
 800957e:	d51d      	bpl.n	80095bc <HAL_RCCEx_PeriphCLKConfig+0x47c>
    switch(PeriphClkInit->Lptim1ClockSelection)
 8009580:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8009584:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 8009588:	f000 82a1 	beq.w	8009ace <HAL_RCCEx_PeriphCLKConfig+0x98e>
 800958c:	f200 83bc 	bhi.w	8009d08 <HAL_RCCEx_PeriphCLKConfig+0xbc8>
 8009590:	b142      	cbz	r2, 80095a4 <HAL_RCCEx_PeriphCLKConfig+0x464>
 8009592:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 8009596:	f040 83c3 	bne.w	8009d20 <HAL_RCCEx_PeriphCLKConfig+0xbe0>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800959a:	2100      	movs	r1, #0
 800959c:	1d20      	adds	r0, r4, #4
 800959e:	f7ff fbef 	bl	8008d80 <RCCEx_PLL2_Config>
 80095a2:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 80095a4:	2d00      	cmp	r5, #0
 80095a6:	f040 81c9 	bne.w	800993c <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80095aa:	4ab9      	ldr	r2, [pc, #740]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 80095ac:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 80095b0:	6d53      	ldr	r3, [r2, #84]	; 0x54
 80095b2:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
 80095b6:	430b      	orrs	r3, r1
 80095b8:	6553      	str	r3, [r2, #84]	; 0x54
 80095ba:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 80095bc:	065f      	lsls	r7, r3, #25
 80095be:	d51d      	bpl.n	80095fc <HAL_RCCEx_PeriphCLKConfig+0x4bc>
    switch(PeriphClkInit->Lptim2ClockSelection)
 80095c0:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 80095c4:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 80095c8:	f000 8277 	beq.w	8009aba <HAL_RCCEx_PeriphCLKConfig+0x97a>
 80095cc:	f200 83bb 	bhi.w	8009d46 <HAL_RCCEx_PeriphCLKConfig+0xc06>
 80095d0:	b142      	cbz	r2, 80095e4 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
 80095d2:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 80095d6:	f040 83c2 	bne.w	8009d5e <HAL_RCCEx_PeriphCLKConfig+0xc1e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 80095da:	2100      	movs	r1, #0
 80095dc:	1d20      	adds	r0, r4, #4
 80095de:	f7ff fbcf 	bl	8008d80 <RCCEx_PLL2_Config>
 80095e2:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 80095e4:	2d00      	cmp	r5, #0
 80095e6:	f040 81a6 	bne.w	8009936 <HAL_RCCEx_PeriphCLKConfig+0x7f6>
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 80095ea:	4aa9      	ldr	r2, [pc, #676]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 80095ec:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
 80095f0:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80095f2:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 80095f6:	430b      	orrs	r3, r1
 80095f8:	6593      	str	r3, [r2, #88]	; 0x58
 80095fa:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 80095fc:	0618      	lsls	r0, r3, #24
 80095fe:	d51d      	bpl.n	800963c <HAL_RCCEx_PeriphCLKConfig+0x4fc>
    switch(PeriphClkInit->Lptim345ClockSelection)
 8009600:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
 8009604:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 8009608:	f000 824d 	beq.w	8009aa6 <HAL_RCCEx_PeriphCLKConfig+0x966>
 800960c:	f200 835d 	bhi.w	8009cca <HAL_RCCEx_PeriphCLKConfig+0xb8a>
 8009610:	b142      	cbz	r2, 8009624 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
 8009612:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8009616:	f040 8364 	bne.w	8009ce2 <HAL_RCCEx_PeriphCLKConfig+0xba2>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800961a:	2100      	movs	r1, #0
 800961c:	1d20      	adds	r0, r4, #4
 800961e:	f7ff fbaf 	bl	8008d80 <RCCEx_PLL2_Config>
 8009622:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009624:	2d00      	cmp	r5, #0
 8009626:	f040 8183 	bne.w	8009930 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 800962a:	4a99      	ldr	r2, [pc, #612]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 800962c:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
 8009630:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8009632:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8009636:	430b      	orrs	r3, r1
 8009638:	6593      	str	r3, [r2, #88]	; 0x58
 800963a:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 800963c:	0719      	lsls	r1, r3, #28
 800963e:	d510      	bpl.n	8009662 <HAL_RCCEx_PeriphCLKConfig+0x522>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
 8009640:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8009644:	f432 5340 	bics.w	r3, r2, #12288	; 0x3000
 8009648:	f040 831a 	bne.w	8009c80 <HAL_RCCEx_PeriphCLKConfig+0xb40>
    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
 800964c:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8009650:	f000 8266 	beq.w	8009b20 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 8009654:	498e      	ldr	r1, [pc, #568]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 8009656:	6d4b      	ldr	r3, [r1, #84]	; 0x54
 8009658:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800965c:	4313      	orrs	r3, r2
 800965e:	654b      	str	r3, [r1, #84]	; 0x54
 8009660:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8009662:	06da      	lsls	r2, r3, #27
 8009664:	d516      	bpl.n	8009694 <HAL_RCCEx_PeriphCLKConfig+0x554>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
 8009666:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 800966a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 800966e:	bf18      	it	ne
 8009670:	f5b2 5f40 	cmpne.w	r2, #12288	; 0x3000
 8009674:	d003      	beq.n	800967e <HAL_RCCEx_PeriphCLKConfig+0x53e>
 8009676:	f432 7380 	bics.w	r3, r2, #256	; 0x100
 800967a:	f040 8309 	bne.w	8009c90 <HAL_RCCEx_PeriphCLKConfig+0xb50>
    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
 800967e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8009682:	f000 8259 	beq.w	8009b38 <HAL_RCCEx_PeriphCLKConfig+0x9f8>
      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8009686:	4982      	ldr	r1, [pc, #520]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 8009688:	6d8b      	ldr	r3, [r1, #88]	; 0x58
 800968a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800968e:	4313      	orrs	r3, r2
 8009690:	658b      	str	r3, [r1, #88]	; 0x58
 8009692:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8009694:	031f      	lsls	r7, r3, #12
 8009696:	d50e      	bpl.n	80096b6 <HAL_RCCEx_PeriphCLKConfig+0x576>
    switch(PeriphClkInit->AdcClockSelection)
 8009698:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 800969c:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 80096a0:	f000 80e3 	beq.w	800986a <HAL_RCCEx_PeriphCLKConfig+0x72a>
 80096a4:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
 80096a8:	f000 80e5 	beq.w	8009876 <HAL_RCCEx_PeriphCLKConfig+0x736>
 80096ac:	2900      	cmp	r1, #0
 80096ae:	f000 82d6 	beq.w	8009c5e <HAL_RCCEx_PeriphCLKConfig+0xb1e>
      ret = HAL_ERROR;
 80096b2:	2601      	movs	r6, #1
 80096b4:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 80096b6:	0358      	lsls	r0, r3, #13
 80096b8:	d50f      	bpl.n	80096da <HAL_RCCEx_PeriphCLKConfig+0x59a>
    switch(PeriphClkInit->UsbClockSelection)
 80096ba:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 80096be:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 80096c2:	f000 80eb 	beq.w	800989c <HAL_RCCEx_PeriphCLKConfig+0x75c>
 80096c6:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
 80096ca:	f000 80ed 	beq.w	80098a8 <HAL_RCCEx_PeriphCLKConfig+0x768>
 80096ce:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 80096d2:	f000 82cc 	beq.w	8009c6e <HAL_RCCEx_PeriphCLKConfig+0xb2e>
      ret = HAL_ERROR;
 80096d6:	2601      	movs	r6, #1
 80096d8:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 80096da:	03d9      	lsls	r1, r3, #15
 80096dc:	d515      	bpl.n	800970a <HAL_RCCEx_PeriphCLKConfig+0x5ca>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
 80096de:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80096e0:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
 80096e4:	f040 8171 	bne.w	80099ca <HAL_RCCEx_PeriphCLKConfig+0x88a>
    switch(PeriphClkInit->SdmmcClockSelection)
 80096e8:	2b00      	cmp	r3, #0
 80096ea:	f000 813b 	beq.w	8009964 <HAL_RCCEx_PeriphCLKConfig+0x824>
 80096ee:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80096f2:	f040 8129 	bne.w	8009948 <HAL_RCCEx_PeriphCLKConfig+0x808>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 80096f6:	2102      	movs	r1, #2
 80096f8:	1d20      	adds	r0, r4, #4
 80096fa:	f7ff fb41 	bl	8008d80 <RCCEx_PLL2_Config>
 80096fe:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009700:	2d00      	cmp	r5, #0
 8009702:	f000 8137 	beq.w	8009974 <HAL_RCCEx_PeriphCLKConfig+0x834>
 8009706:	6823      	ldr	r3, [r4, #0]
 8009708:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 800970a:	009a      	lsls	r2, r3, #2
 800970c:	f100 80e9 	bmi.w	80098e2 <HAL_RCCEx_PeriphCLKConfig+0x7a2>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 8009710:	039f      	lsls	r7, r3, #14
 8009712:	d437      	bmi.n	8009784 <HAL_RCCEx_PeriphCLKConfig+0x644>
 8009714:	3600      	adds	r6, #0
 8009716:	bf18      	it	ne
 8009718:	2601      	movne	r6, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 800971a:	02d8      	lsls	r0, r3, #11
 800971c:	d50b      	bpl.n	8009736 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
 800971e:	6f22      	ldr	r2, [r4, #112]	; 0x70
 8009720:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 8009724:	f040 814a 	bne.w	80099bc <HAL_RCCEx_PeriphCLKConfig+0x87c>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 8009728:	4959      	ldr	r1, [pc, #356]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 800972a:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 800972c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009730:	4313      	orrs	r3, r2
 8009732:	650b      	str	r3, [r1, #80]	; 0x50
 8009734:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8009736:	0299      	lsls	r1, r3, #10
 8009738:	d50b      	bpl.n	8009752 <HAL_RCCEx_PeriphCLKConfig+0x612>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
 800973a:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 800973c:	f032 7380 	bics.w	r3, r2, #16777216	; 0x1000000
 8009740:	f040 814d 	bne.w	80099de <HAL_RCCEx_PeriphCLKConfig+0x89e>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8009744:	4952      	ldr	r1, [pc, #328]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 8009746:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 8009748:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800974c:	4313      	orrs	r3, r2
 800974e:	650b      	str	r3, [r1, #80]	; 0x50
 8009750:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 8009752:	005a      	lsls	r2, r3, #1
 8009754:	d510      	bpl.n	8009778 <HAL_RCCEx_PeriphCLKConfig+0x638>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
 8009756:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
 800975a:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
 800975e:	f040 8145 	bne.w	80099ec <HAL_RCCEx_PeriphCLKConfig+0x8ac>
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8009762:	4b4b      	ldr	r3, [pc, #300]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 8009764:	691a      	ldr	r2, [r3, #16]
 8009766:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800976a:	611a      	str	r2, [r3, #16]
 800976c:	691a      	ldr	r2, [r3, #16]
 800976e:	f8d4 10b8 	ldr.w	r1, [r4, #184]	; 0xb8
 8009772:	430a      	orrs	r2, r1
 8009774:	611a      	str	r2, [r3, #16]
 8009776:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 8009778:	2b00      	cmp	r3, #0
 800977a:	f2c0 80a1 	blt.w	80098c0 <HAL_RCCEx_PeriphCLKConfig+0x780>
}
 800977e:	4630      	mov	r0, r6
 8009780:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    switch(PeriphClkInit->RngClockSelection)
 8009784:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 8009786:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800978a:	f000 80e1 	beq.w	8009950 <HAL_RCCEx_PeriphCLKConfig+0x810>
 800978e:	f240 813c 	bls.w	8009a0a <HAL_RCCEx_PeriphCLKConfig+0x8ca>
 8009792:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8009796:	f000 80e0 	beq.w	800995a <HAL_RCCEx_PeriphCLKConfig+0x81a>
 800979a:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 800979e:	f000 80dc 	beq.w	800995a <HAL_RCCEx_PeriphCLKConfig+0x81a>
 80097a2:	2601      	movs	r6, #1
 80097a4:	e7b9      	b.n	800971a <HAL_RCCEx_PeriphCLKConfig+0x5da>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 80097a6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80097aa:	4b3a      	ldr	r3, [pc, #232]	; (8009894 <HAL_RCCEx_PeriphCLKConfig+0x754>)
 80097ac:	429a      	cmp	r2, r3
 80097ae:	f43f ae43 	beq.w	8009438 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
 80097b2:	f44f 715a 	mov.w	r1, #872	; 0x368
 80097b6:	4838      	ldr	r0, [pc, #224]	; (8009898 <HAL_RCCEx_PeriphCLKConfig+0x758>)
 80097b8:	f00a f88a 	bl	80138d0 <assert_failed>
 80097bc:	e63c      	b.n	8009438 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 80097be:	2101      	movs	r1, #1
 80097c0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80097c4:	f7ff fbcc 	bl	8008f60 <RCCEx_PLL3_Config>
 80097c8:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 80097ca:	2d00      	cmp	r5, #0
 80097cc:	f040 809e 	bne.w	800990c <HAL_RCCEx_PeriphCLKConfig+0x7cc>
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80097d0:	4a2f      	ldr	r2, [pc, #188]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 80097d2:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 80097d6:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80097d8:	f023 0307 	bic.w	r3, r3, #7
 80097dc:	430b      	orrs	r3, r1
 80097de:	6593      	str	r3, [r2, #88]	; 0x58
 80097e0:	6823      	ldr	r3, [r4, #0]
 80097e2:	e6cb      	b.n	800957c <HAL_RCCEx_PeriphCLKConfig+0x43c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 80097e4:	2101      	movs	r1, #1
 80097e6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80097ea:	f7ff fbb9 	bl	8008f60 <RCCEx_PLL3_Config>
 80097ee:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 80097f0:	2d00      	cmp	r5, #0
 80097f2:	f040 808e 	bne.w	8009912 <HAL_RCCEx_PeriphCLKConfig+0x7d2>
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 80097f6:	4a26      	ldr	r2, [pc, #152]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 80097f8:	6f61      	ldr	r1, [r4, #116]	; 0x74
 80097fa:	6d53      	ldr	r3, [r2, #84]	; 0x54
 80097fc:	f023 0307 	bic.w	r3, r3, #7
 8009800:	430b      	orrs	r3, r1
 8009802:	6553      	str	r3, [r2, #84]	; 0x54
 8009804:	6823      	ldr	r3, [r4, #0]
 8009806:	e6a7      	b.n	8009558 <HAL_RCCEx_PeriphCLKConfig+0x418>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 8009808:	2102      	movs	r1, #2
 800980a:	1d20      	adds	r0, r4, #4
 800980c:	f7ff fab8 	bl	8008d80 <RCCEx_PLL2_Config>
 8009810:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009812:	2d00      	cmp	r5, #0
 8009814:	d177      	bne.n	8009906 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 8009816:	4a1e      	ldr	r2, [pc, #120]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 8009818:	6c61      	ldr	r1, [r4, #68]	; 0x44
 800981a:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 800981c:	f023 0303 	bic.w	r3, r3, #3
 8009820:	430b      	orrs	r3, r1
 8009822:	64d3      	str	r3, [r2, #76]	; 0x4c
 8009824:	6823      	ldr	r3, [r4, #0]
 8009826:	e58a      	b.n	800933e <HAL_RCCEx_PeriphCLKConfig+0x1fe>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8009828:	2101      	movs	r1, #1
 800982a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800982e:	f7ff fb97 	bl	8008f60 <RCCEx_PLL3_Config>
 8009832:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009834:	2d00      	cmp	r5, #0
 8009836:	d163      	bne.n	8009900 <HAL_RCCEx_PeriphCLKConfig+0x7c0>
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 8009838:	4a15      	ldr	r2, [pc, #84]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 800983a:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 800983c:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800983e:	f023 0338 	bic.w	r3, r3, #56	; 0x38
 8009842:	430b      	orrs	r3, r1
 8009844:	6553      	str	r3, [r2, #84]	; 0x54
 8009846:	6823      	ldr	r3, [r4, #0]
 8009848:	e677      	b.n	800953a <HAL_RCCEx_PeriphCLKConfig+0x3fa>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800984a:	2101      	movs	r1, #1
 800984c:	1d20      	adds	r0, r4, #4
 800984e:	f7ff fa97 	bl	8008d80 <RCCEx_PLL2_Config>
 8009852:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009854:	2d00      	cmp	r5, #0
 8009856:	d174      	bne.n	8009942 <HAL_RCCEx_PeriphCLKConfig+0x802>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8009858:	4a0d      	ldr	r2, [pc, #52]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 800985a:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 800985c:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800985e:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8009862:	430b      	orrs	r3, r1
 8009864:	6513      	str	r3, [r2, #80]	; 0x50
 8009866:	6823      	ldr	r3, [r4, #0]
 8009868:	e55c      	b.n	8009324 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800986a:	2102      	movs	r1, #2
 800986c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009870:	f7ff fb76 	bl	8008f60 <RCCEx_PLL3_Config>
 8009874:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009876:	2d00      	cmp	r5, #0
 8009878:	d151      	bne.n	800991e <HAL_RCCEx_PeriphCLKConfig+0x7de>
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800987a:	4a05      	ldr	r2, [pc, #20]	; (8009890 <HAL_RCCEx_PeriphCLKConfig+0x750>)
 800987c:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 8009880:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8009882:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8009886:	430b      	orrs	r3, r1
 8009888:	6593      	str	r3, [r2, #88]	; 0x58
 800988a:	6823      	ldr	r3, [r4, #0]
 800988c:	e713      	b.n	80096b6 <HAL_RCCEx_PeriphCLKConfig+0x576>
 800988e:	bf00      	nop
 8009890:	58024400 	.word	0x58024400
 8009894:	0003e300 	.word	0x0003e300
 8009898:	08029384 	.word	0x08029384
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800989c:	2101      	movs	r1, #1
 800989e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80098a2:	f7ff fb5d 	bl	8008f60 <RCCEx_PLL3_Config>
 80098a6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 80098a8:	2d00      	cmp	r5, #0
 80098aa:	d135      	bne.n	8009918 <HAL_RCCEx_PeriphCLKConfig+0x7d8>
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 80098ac:	4ab2      	ldr	r2, [pc, #712]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 80098ae:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
 80098b2:	6d53      	ldr	r3, [r2, #84]	; 0x54
 80098b4:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80098b8:	430b      	orrs	r3, r1
 80098ba:	6553      	str	r3, [r2, #84]	; 0x54
 80098bc:	6823      	ldr	r3, [r4, #0]
 80098be:	e70c      	b.n	80096da <HAL_RCCEx_PeriphCLKConfig+0x59a>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
 80098c0:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80098c2:	f032 5380 	bics.w	r3, r2, #268435456	; 0x10000000
 80098c6:	d003      	beq.n	80098d0 <HAL_RCCEx_PeriphCLKConfig+0x790>
 80098c8:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 80098cc:	f040 81c0 	bne.w	8009c50 <HAL_RCCEx_PeriphCLKConfig+0xb10>
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 80098d0:	49a9      	ldr	r1, [pc, #676]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
}
 80098d2:	4630      	mov	r0, r6
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 80098d4:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
 80098d6:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 80098da:	4313      	orrs	r3, r2
 80098dc:	64cb      	str	r3, [r1, #76]	; 0x4c
}
 80098de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
 80098e2:	2102      	movs	r1, #2
 80098e4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80098e8:	f7ff fb3a 	bl	8008f60 <RCCEx_PLL3_Config>
 80098ec:	6823      	ldr	r3, [r4, #0]
 80098ee:	2800      	cmp	r0, #0
 80098f0:	f43f af0e 	beq.w	8009710 <HAL_RCCEx_PeriphCLKConfig+0x5d0>
      status=HAL_ERROR;
 80098f4:	2601      	movs	r6, #1
 80098f6:	e70b      	b.n	8009710 <HAL_RCCEx_PeriphCLKConfig+0x5d0>
            ret = HAL_TIMEOUT;
 80098f8:	2603      	movs	r6, #3
 80098fa:	6823      	ldr	r3, [r4, #0]
 80098fc:	4635      	mov	r5, r6
 80098fe:	e5ea      	b.n	80094d6 <HAL_RCCEx_PeriphCLKConfig+0x396>
 8009900:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8009902:	462e      	mov	r6, r5
 8009904:	e619      	b.n	800953a <HAL_RCCEx_PeriphCLKConfig+0x3fa>
 8009906:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8009908:	462e      	mov	r6, r5
 800990a:	e518      	b.n	800933e <HAL_RCCEx_PeriphCLKConfig+0x1fe>
 800990c:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800990e:	462e      	mov	r6, r5
 8009910:	e634      	b.n	800957c <HAL_RCCEx_PeriphCLKConfig+0x43c>
 8009912:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8009914:	462e      	mov	r6, r5
 8009916:	e61f      	b.n	8009558 <HAL_RCCEx_PeriphCLKConfig+0x418>
 8009918:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800991a:	462e      	mov	r6, r5
 800991c:	e6dd      	b.n	80096da <HAL_RCCEx_PeriphCLKConfig+0x59a>
 800991e:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8009920:	462e      	mov	r6, r5
 8009922:	e6c8      	b.n	80096b6 <HAL_RCCEx_PeriphCLKConfig+0x576>
 8009924:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8009926:	462e      	mov	r6, r5
 8009928:	e4ec      	b.n	8009304 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
 800992a:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800992c:	462e      	mov	r6, r5
 800992e:	e4c9      	b.n	80092c4 <HAL_RCCEx_PeriphCLKConfig+0x184>
 8009930:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8009932:	462e      	mov	r6, r5
 8009934:	e682      	b.n	800963c <HAL_RCCEx_PeriphCLKConfig+0x4fc>
 8009936:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8009938:	462e      	mov	r6, r5
 800993a:	e65f      	b.n	80095fc <HAL_RCCEx_PeriphCLKConfig+0x4bc>
 800993c:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800993e:	462e      	mov	r6, r5
 8009940:	e63c      	b.n	80095bc <HAL_RCCEx_PeriphCLKConfig+0x47c>
 8009942:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8009944:	462e      	mov	r6, r5
 8009946:	e4ed      	b.n	8009324 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
      ret = HAL_ERROR;
 8009948:	2601      	movs	r6, #1
 800994a:	6823      	ldr	r3, [r4, #0]
 800994c:	4635      	mov	r5, r6
 800994e:	e6dc      	b.n	800970a <HAL_RCCEx_PeriphCLKConfig+0x5ca>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009950:	4a89      	ldr	r2, [pc, #548]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 8009952:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009954:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009958:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
 800995a:	2d00      	cmp	r5, #0
 800995c:	d05a      	beq.n	8009a14 <HAL_RCCEx_PeriphCLKConfig+0x8d4>
 800995e:	6823      	ldr	r3, [r4, #0]
 8009960:	2601      	movs	r6, #1
 8009962:	e6da      	b.n	800971a <HAL_RCCEx_PeriphCLKConfig+0x5da>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009964:	4a84      	ldr	r2, [pc, #528]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 8009966:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009968:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800996c:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
 800996e:	2d00      	cmp	r5, #0
 8009970:	f47f aec9 	bne.w	8009706 <HAL_RCCEx_PeriphCLKConfig+0x5c6>
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 8009974:	4a80      	ldr	r2, [pc, #512]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 8009976:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8009978:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 800997a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800997e:	430b      	orrs	r3, r1
 8009980:	64d3      	str	r3, [r2, #76]	; 0x4c
 8009982:	6823      	ldr	r3, [r4, #0]
 8009984:	e6c1      	b.n	800970a <HAL_RCCEx_PeriphCLKConfig+0x5ca>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8009986:	2101      	movs	r1, #1
 8009988:	1d20      	adds	r0, r4, #4
 800998a:	f7ff f9f9 	bl	8008d80 <RCCEx_PLL2_Config>
 800998e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009990:	2d00      	cmp	r5, #0
 8009992:	f43f af30 	beq.w	80097f6 <HAL_RCCEx_PeriphCLKConfig+0x6b6>
 8009996:	e7bc      	b.n	8009912 <HAL_RCCEx_PeriphCLKConfig+0x7d2>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8009998:	2101      	movs	r1, #1
 800999a:	1d20      	adds	r0, r4, #4
 800999c:	f7ff f9f0 	bl	8008d80 <RCCEx_PLL2_Config>
 80099a0:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 80099a2:	2d00      	cmp	r5, #0
 80099a4:	f43f af14 	beq.w	80097d0 <HAL_RCCEx_PeriphCLKConfig+0x690>
 80099a8:	e7b0      	b.n	800990c <HAL_RCCEx_PeriphCLKConfig+0x7cc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80099aa:	4a73      	ldr	r2, [pc, #460]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 80099ac:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80099ae:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80099b2:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
 80099b4:	2d00      	cmp	r5, #0
 80099b6:	f43f af2e 	beq.w	8009816 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
 80099ba:	e7a4      	b.n	8009906 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
 80099bc:	f240 51bd 	movw	r1, #1469	; 0x5bd
 80099c0:	486e      	ldr	r0, [pc, #440]	; (8009b7c <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
 80099c2:	f009 ff85 	bl	80138d0 <assert_failed>
 80099c6:	6f22      	ldr	r2, [r4, #112]	; 0x70
 80099c8:	e6ae      	b.n	8009728 <HAL_RCCEx_PeriphCLKConfig+0x5e8>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
 80099ca:	f240 515e 	movw	r1, #1374	; 0x55e
 80099ce:	486b      	ldr	r0, [pc, #428]	; (8009b7c <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
 80099d0:	f009 ff7e 	bl	80138d0 <assert_failed>
 80099d4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    switch(PeriphClkInit->SdmmcClockSelection)
 80099d6:	2b00      	cmp	r3, #0
 80099d8:	f47f ae89 	bne.w	80096ee <HAL_RCCEx_PeriphCLKConfig+0x5ae>
 80099dc:	e7c2      	b.n	8009964 <HAL_RCCEx_PeriphCLKConfig+0x824>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
 80099de:	f240 51d1 	movw	r1, #1489	; 0x5d1
 80099e2:	4866      	ldr	r0, [pc, #408]	; (8009b7c <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
 80099e4:	f009 ff74 	bl	80138d0 <assert_failed>
 80099e8:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 80099ea:	e6ab      	b.n	8009744 <HAL_RCCEx_PeriphCLKConfig+0x604>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
 80099ec:	f240 51e7 	movw	r1, #1511	; 0x5e7
 80099f0:	4862      	ldr	r0, [pc, #392]	; (8009b7c <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
 80099f2:	f009 ff6d 	bl	80138d0 <assert_failed>
 80099f6:	e6b4      	b.n	8009762 <HAL_RCCEx_PeriphCLKConfig+0x622>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 80099f8:	2101      	movs	r1, #1
 80099fa:	1d20      	adds	r0, r4, #4
 80099fc:	f7ff f9c0 	bl	8008d80 <RCCEx_PLL2_Config>
 8009a00:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009a02:	2d00      	cmp	r5, #0
 8009a04:	f43f af18 	beq.w	8009838 <HAL_RCCEx_PeriphCLKConfig+0x6f8>
 8009a08:	e77a      	b.n	8009900 <HAL_RCCEx_PeriphCLKConfig+0x7c0>
    switch(PeriphClkInit->RngClockSelection)
 8009a0a:	2a00      	cmp	r2, #0
 8009a0c:	f47f aec9 	bne.w	80097a2 <HAL_RCCEx_PeriphCLKConfig+0x662>
    if(ret == HAL_OK)
 8009a10:	2d00      	cmp	r5, #0
 8009a12:	d1a4      	bne.n	800995e <HAL_RCCEx_PeriphCLKConfig+0x81e>
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8009a14:	4a58      	ldr	r2, [pc, #352]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 8009a16:	3600      	adds	r6, #0
 8009a18:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8009a1a:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009a1c:	bf18      	it	ne
 8009a1e:	2601      	movne	r6, #1
 8009a20:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8009a24:	430b      	orrs	r3, r1
 8009a26:	6553      	str	r3, [r2, #84]	; 0x54
 8009a28:	6823      	ldr	r3, [r4, #0]
 8009a2a:	e676      	b.n	800971a <HAL_RCCEx_PeriphCLKConfig+0x5da>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009a2c:	4a52      	ldr	r2, [pc, #328]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 8009a2e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009a30:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009a34:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
 8009a36:	b14d      	cbz	r5, 8009a4c <HAL_RCCEx_PeriphCLKConfig+0x90c>
 8009a38:	6823      	ldr	r3, [r4, #0]
 8009a3a:	462e      	mov	r6, r5
 8009a3c:	e40a      	b.n	8009254 <HAL_RCCEx_PeriphCLKConfig+0x114>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 8009a3e:	2102      	movs	r1, #2
 8009a40:	1d20      	adds	r0, r4, #4
 8009a42:	f7ff f99d 	bl	8008d80 <RCCEx_PLL2_Config>
 8009a46:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009a48:	2d00      	cmp	r5, #0
 8009a4a:	d1f5      	bne.n	8009a38 <HAL_RCCEx_PeriphCLKConfig+0x8f8>
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 8009a4c:	4a4a      	ldr	r2, [pc, #296]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 8009a4e:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8009a50:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8009a52:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8009a56:	430b      	orrs	r3, r1
 8009a58:	64d3      	str	r3, [r2, #76]	; 0x4c
 8009a5a:	6823      	ldr	r3, [r4, #0]
 8009a5c:	f7ff bbfa 	b.w	8009254 <HAL_RCCEx_PeriphCLKConfig+0x114>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8009a60:	2101      	movs	r1, #1
 8009a62:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009a66:	f7ff fa7b 	bl	8008f60 <RCCEx_PLL3_Config>
 8009a6a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009a6c:	2d00      	cmp	r5, #0
 8009a6e:	f43f ac21 	beq.w	80092b4 <HAL_RCCEx_PeriphCLKConfig+0x174>
 8009a72:	e75a      	b.n	800992a <HAL_RCCEx_PeriphCLKConfig+0x7ea>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8009a74:	2101      	movs	r1, #1
 8009a76:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009a7a:	f7ff fa71 	bl	8008f60 <RCCEx_PLL3_Config>
 8009a7e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009a80:	2d00      	cmp	r5, #0
 8009a82:	f43f ac36 	beq.w	80092f2 <HAL_RCCEx_PeriphCLKConfig+0x1b2>
 8009a86:	e74d      	b.n	8009924 <HAL_RCCEx_PeriphCLKConfig+0x7e4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009a88:	4a3b      	ldr	r2, [pc, #236]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 8009a8a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009a8c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009a90:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
 8009a92:	2d00      	cmp	r5, #0
 8009a94:	f43f aee0 	beq.w	8009858 <HAL_RCCEx_PeriphCLKConfig+0x718>
 8009a98:	e753      	b.n	8009942 <HAL_RCCEx_PeriphCLKConfig+0x802>
    switch(PeriphClkInit->Sai1ClockSelection)
 8009a9a:	4635      	mov	r5, r6
    if(ret == HAL_OK)
 8009a9c:	b34d      	cbz	r5, 8009af2 <HAL_RCCEx_PeriphCLKConfig+0x9b2>
 8009a9e:	6823      	ldr	r3, [r4, #0]
 8009aa0:	462e      	mov	r6, r5
 8009aa2:	f7ff bb79 	b.w	8009198 <HAL_RCCEx_PeriphCLKConfig+0x58>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 8009aa6:	2102      	movs	r1, #2
 8009aa8:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009aac:	f7ff fa58 	bl	8008f60 <RCCEx_PLL3_Config>
 8009ab0:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009ab2:	2d00      	cmp	r5, #0
 8009ab4:	f43f adb9 	beq.w	800962a <HAL_RCCEx_PeriphCLKConfig+0x4ea>
 8009ab8:	e73a      	b.n	8009930 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 8009aba:	2102      	movs	r1, #2
 8009abc:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009ac0:	f7ff fa4e 	bl	8008f60 <RCCEx_PLL3_Config>
 8009ac4:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009ac6:	2d00      	cmp	r5, #0
 8009ac8:	f43f ad8f 	beq.w	80095ea <HAL_RCCEx_PeriphCLKConfig+0x4aa>
 8009acc:	e733      	b.n	8009936 <HAL_RCCEx_PeriphCLKConfig+0x7f6>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 8009ace:	2102      	movs	r1, #2
 8009ad0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009ad4:	f7ff fa44 	bl	8008f60 <RCCEx_PLL3_Config>
 8009ad8:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009ada:	2d00      	cmp	r5, #0
 8009adc:	f43f ad65 	beq.w	80095aa <HAL_RCCEx_PeriphCLKConfig+0x46a>
 8009ae0:	e72c      	b.n	800993c <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009ae2:	4a25      	ldr	r2, [pc, #148]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
      break;
 8009ae4:	4635      	mov	r5, r6
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009ae6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009ae8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009aec:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
 8009aee:	2d00      	cmp	r5, #0
 8009af0:	d1d5      	bne.n	8009a9e <HAL_RCCEx_PeriphCLKConfig+0x95e>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8009af2:	4a21      	ldr	r2, [pc, #132]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 8009af4:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8009af6:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8009af8:	f023 0307 	bic.w	r3, r3, #7
 8009afc:	430b      	orrs	r3, r1
 8009afe:	6513      	str	r3, [r2, #80]	; 0x50
 8009b00:	6823      	ldr	r3, [r4, #0]
 8009b02:	f7ff bb49 	b.w	8009198 <HAL_RCCEx_PeriphCLKConfig+0x58>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8009b06:	2100      	movs	r1, #0
 8009b08:	1d20      	adds	r0, r4, #4
 8009b0a:	f7ff f939 	bl	8008d80 <RCCEx_PLL2_Config>
 8009b0e:	4605      	mov	r5, r0
      break;
 8009b10:	e7c4      	b.n	8009a9c <HAL_RCCEx_PeriphCLKConfig+0x95c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 8009b12:	2100      	movs	r1, #0
 8009b14:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009b18:	f7ff fa22 	bl	8008f60 <RCCEx_PLL3_Config>
 8009b1c:	4605      	mov	r5, r0
      break;
 8009b1e:	e7bd      	b.n	8009a9c <HAL_RCCEx_PeriphCLKConfig+0x95c>
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 8009b20:	2102      	movs	r1, #2
 8009b22:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009b26:	f7ff fa1b 	bl	8008f60 <RCCEx_PLL3_Config>
 8009b2a:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8009b2e:	2800      	cmp	r0, #0
 8009b30:	f43f ad90 	beq.w	8009654 <HAL_RCCEx_PeriphCLKConfig+0x514>
          status = HAL_ERROR;
 8009b34:	2601      	movs	r6, #1
 8009b36:	e58d      	b.n	8009654 <HAL_RCCEx_PeriphCLKConfig+0x514>
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 8009b38:	2102      	movs	r1, #2
 8009b3a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009b3e:	f7ff fa0f 	bl	8008f60 <RCCEx_PLL3_Config>
 8009b42:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 8009b46:	2800      	cmp	r0, #0
 8009b48:	f43f ad9d 	beq.w	8009686 <HAL_RCCEx_PeriphCLKConfig+0x546>
        status = HAL_ERROR;
 8009b4c:	2601      	movs	r6, #1
 8009b4e:	e59a      	b.n	8009686 <HAL_RCCEx_PeriphCLKConfig+0x546>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 8009b50:	2100      	movs	r1, #0
 8009b52:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009b56:	f7ff fa03 	bl	8008f60 <RCCEx_PLL3_Config>
 8009b5a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009b5c:	2d00      	cmp	r5, #0
 8009b5e:	f47f ab91 	bne.w	8009284 <HAL_RCCEx_PeriphCLKConfig+0x144>
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 8009b62:	4a05      	ldr	r2, [pc, #20]	; (8009b78 <HAL_RCCEx_PeriphCLKConfig+0xa38>)
 8009b64:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8009b66:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8009b68:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8009b6c:	430b      	orrs	r3, r1
 8009b6e:	6513      	str	r3, [r2, #80]	; 0x50
 8009b70:	6823      	ldr	r3, [r4, #0]
 8009b72:	f7ff bb89 	b.w	8009288 <HAL_RCCEx_PeriphCLKConfig+0x148>
 8009b76:	bf00      	nop
 8009b78:	58024400 	.word	0x58024400
 8009b7c:	08029384 	.word	0x08029384
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009b80:	4aa0      	ldr	r2, [pc, #640]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
 8009b82:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009b84:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009b88:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
 8009b8a:	2d00      	cmp	r5, #0
 8009b8c:	f47f ab50 	bne.w	8009230 <HAL_RCCEx_PeriphCLKConfig+0xf0>
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
 8009b90:	4a9c      	ldr	r2, [pc, #624]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
 8009b92:	f8d4 10a8 	ldr.w	r1, [r4, #168]	; 0xa8
 8009b96:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8009b98:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8009b9c:	430b      	orrs	r3, r1
 8009b9e:	6593      	str	r3, [r2, #88]	; 0x58
 8009ba0:	6823      	ldr	r3, [r4, #0]
 8009ba2:	f7ff bb47 	b.w	8009234 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 8009ba6:	2102      	movs	r1, #2
 8009ba8:	3004      	adds	r0, #4
 8009baa:	f7ff f8e9 	bl	8008d80 <RCCEx_PLL2_Config>
 8009bae:	4606      	mov	r6, r0
    if(ret == HAL_OK)
 8009bb0:	2e00      	cmp	r6, #0
 8009bb2:	f47f aae2 	bne.w	800917a <HAL_RCCEx_PeriphCLKConfig+0x3a>
 8009bb6:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8009bb8:	f7ff bad8 	b.w	800916c <HAL_RCCEx_PeriphCLKConfig+0x2c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 8009bbc:	2100      	movs	r1, #0
 8009bbe:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009bc2:	f7ff f9cd 	bl	8008f60 <RCCEx_PLL3_Config>
 8009bc6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009bc8:	2d00      	cmp	r5, #0
 8009bca:	f47f aafb 	bne.w	80091c4 <HAL_RCCEx_PeriphCLKConfig+0x84>
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
 8009bce:	4a8d      	ldr	r2, [pc, #564]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
 8009bd0:	6da1      	ldr	r1, [r4, #88]	; 0x58
 8009bd2:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8009bd4:	f423 73e0 	bic.w	r3, r3, #448	; 0x1c0
 8009bd8:	430b      	orrs	r3, r1
 8009bda:	6513      	str	r3, [r2, #80]	; 0x50
 8009bdc:	6823      	ldr	r3, [r4, #0]
 8009bde:	f7ff baf3 	b.w	80091c8 <HAL_RCCEx_PeriphCLKConfig+0x88>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 8009be2:	2100      	movs	r1, #0
 8009be4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009be8:	f7ff f9ba 	bl	8008f60 <RCCEx_PLL3_Config>
 8009bec:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009bee:	2d00      	cmp	r5, #0
 8009bf0:	f47f ab03 	bne.w	80091fa <HAL_RCCEx_PeriphCLKConfig+0xba>
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
 8009bf4:	4a83      	ldr	r2, [pc, #524]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
 8009bf6:	f8d4 10a4 	ldr.w	r1, [r4, #164]	; 0xa4
 8009bfa:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8009bfc:	f423 0360 	bic.w	r3, r3, #14680064	; 0xe00000
 8009c00:	430b      	orrs	r3, r1
 8009c02:	6593      	str	r3, [r2, #88]	; 0x58
 8009c04:	6823      	ldr	r3, [r4, #0]
 8009c06:	f7ff bafa 	b.w	80091fe <HAL_RCCEx_PeriphCLKConfig+0xbe>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8009c0a:	2100      	movs	r1, #0
 8009c0c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009c10:	f7ff f9a6 	bl	8008f60 <RCCEx_PLL3_Config>
 8009c14:	4605      	mov	r5, r0
      break;
 8009c16:	f7ff bb08 	b.w	800922a <HAL_RCCEx_PeriphCLKConfig+0xea>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 8009c1a:	2102      	movs	r1, #2
 8009c1c:	3024      	adds	r0, #36	; 0x24
 8009c1e:	f7ff f99f 	bl	8008f60 <RCCEx_PLL3_Config>
 8009c22:	4606      	mov	r6, r0
      break;
 8009c24:	e7c4      	b.n	8009bb0 <HAL_RCCEx_PeriphCLKConfig+0xa70>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009c26:	4a77      	ldr	r2, [pc, #476]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
 8009c28:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009c2a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009c2e:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
 8009c30:	f7ff bac5 	b.w	80091be <HAL_RCCEx_PeriphCLKConfig+0x7e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009c34:	4a73      	ldr	r2, [pc, #460]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
 8009c36:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009c38:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009c3c:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
 8009c3e:	f7ff bb1e 	b.w	800927e <HAL_RCCEx_PeriphCLKConfig+0x13e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009c42:	4a70      	ldr	r2, [pc, #448]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
 8009c44:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009c46:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009c4a:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
 8009c4c:	f7ff bad2 	b.w	80091f4 <HAL_RCCEx_PeriphCLKConfig+0xb4>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
 8009c50:	f240 51f1 	movw	r1, #1521	; 0x5f1
 8009c54:	486c      	ldr	r0, [pc, #432]	; (8009e08 <HAL_RCCEx_PeriphCLKConfig+0xcc8>)
 8009c56:	f009 fe3b 	bl	80138d0 <assert_failed>
 8009c5a:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8009c5c:	e638      	b.n	80098d0 <HAL_RCCEx_PeriphCLKConfig+0x790>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8009c5e:	1d20      	adds	r0, r4, #4
 8009c60:	f7ff f88e 	bl	8008d80 <RCCEx_PLL2_Config>
 8009c64:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8009c66:	2d00      	cmp	r5, #0
 8009c68:	f43f ae07 	beq.w	800987a <HAL_RCCEx_PeriphCLKConfig+0x73a>
 8009c6c:	e657      	b.n	800991e <HAL_RCCEx_PeriphCLKConfig+0x7de>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009c6e:	4a65      	ldr	r2, [pc, #404]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
 8009c70:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009c72:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009c76:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
 8009c78:	2d00      	cmp	r5, #0
 8009c7a:	f43f ae17 	beq.w	80098ac <HAL_RCCEx_PeriphCLKConfig+0x76c>
 8009c7e:	e64b      	b.n	8009918 <HAL_RCCEx_PeriphCLKConfig+0x7d8>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
 8009c80:	f240 41e6 	movw	r1, #1254	; 0x4e6
 8009c84:	4860      	ldr	r0, [pc, #384]	; (8009e08 <HAL_RCCEx_PeriphCLKConfig+0xcc8>)
 8009c86:	f009 fe23 	bl	80138d0 <assert_failed>
 8009c8a:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8009c8e:	e4dd      	b.n	800964c <HAL_RCCEx_PeriphCLKConfig+0x50c>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
 8009c90:	f44f 619f 	mov.w	r1, #1272	; 0x4f8
 8009c94:	485c      	ldr	r0, [pc, #368]	; (8009e08 <HAL_RCCEx_PeriphCLKConfig+0xcc8>)
 8009c96:	f009 fe1b 	bl	80138d0 <assert_failed>
 8009c9a:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 8009c9e:	e4ee      	b.n	800967e <HAL_RCCEx_PeriphCLKConfig+0x53e>
        tickstart = HAL_GetTick();
 8009ca0:	f7f6 fec2 	bl	8000a28 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8009ca4:	4f57      	ldr	r7, [pc, #348]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
        tickstart = HAL_GetTick();
 8009ca6:	4681      	mov	r9, r0
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8009ca8:	f241 3888 	movw	r8, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8009cac:	e006      	b.n	8009cbc <HAL_RCCEx_PeriphCLKConfig+0xb7c>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8009cae:	f7f6 febb 	bl	8000a28 <HAL_GetTick>
 8009cb2:	eba0 0009 	sub.w	r0, r0, r9
 8009cb6:	4540      	cmp	r0, r8
 8009cb8:	f63f ae1e 	bhi.w	80098f8 <HAL_RCCEx_PeriphCLKConfig+0x7b8>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8009cbc:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8009cbe:	079b      	lsls	r3, r3, #30
 8009cc0:	d5f5      	bpl.n	8009cae <HAL_RCCEx_PeriphCLKConfig+0xb6e>
 8009cc2:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 8009cc6:	f7ff bbf2 	b.w	80094ae <HAL_RCCEx_PeriphCLKConfig+0x36e>
    switch(PeriphClkInit->Lptim345ClockSelection)
 8009cca:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8009cce:	f43f aca9 	beq.w	8009624 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
 8009cd2:	f5b2 4f20 	cmp.w	r2, #40960	; 0xa000
 8009cd6:	f43f aca5 	beq.w	8009624 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
 8009cda:	f5b2 4fc0 	cmp.w	r2, #24576	; 0x6000
 8009cde:	f43f aca1 	beq.w	8009624 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
      ret = HAL_ERROR;
 8009ce2:	2601      	movs	r6, #1
 8009ce4:	4635      	mov	r5, r6
 8009ce6:	e4a9      	b.n	800963c <HAL_RCCEx_PeriphCLKConfig+0x4fc>
    switch(PeriphClkInit->Spi45ClockSelection)
 8009ce8:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 8009cec:	f43f aadf 	beq.w	80092ae <HAL_RCCEx_PeriphCLKConfig+0x16e>
 8009cf0:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
 8009cf4:	f43f aadb 	beq.w	80092ae <HAL_RCCEx_PeriphCLKConfig+0x16e>
 8009cf8:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
 8009cfc:	f43f aad7 	beq.w	80092ae <HAL_RCCEx_PeriphCLKConfig+0x16e>
      ret = HAL_ERROR;
 8009d00:	2601      	movs	r6, #1
 8009d02:	4635      	mov	r5, r6
 8009d04:	f7ff bade 	b.w	80092c4 <HAL_RCCEx_PeriphCLKConfig+0x184>
    switch(PeriphClkInit->Lptim1ClockSelection)
 8009d08:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8009d0c:	f43f ac4a 	beq.w	80095a4 <HAL_RCCEx_PeriphCLKConfig+0x464>
 8009d10:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 8009d14:	f43f ac46 	beq.w	80095a4 <HAL_RCCEx_PeriphCLKConfig+0x464>
 8009d18:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
 8009d1c:	f43f ac42 	beq.w	80095a4 <HAL_RCCEx_PeriphCLKConfig+0x464>
      ret = HAL_ERROR;
 8009d20:	2601      	movs	r6, #1
 8009d22:	4635      	mov	r5, r6
 8009d24:	e44a      	b.n	80095bc <HAL_RCCEx_PeriphCLKConfig+0x47c>
    switch(PeriphClkInit->Spi6ClockSelection)
 8009d26:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8009d2a:	f43f aadf 	beq.w	80092ec <HAL_RCCEx_PeriphCLKConfig+0x1ac>
 8009d2e:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 8009d32:	f43f aadb 	beq.w	80092ec <HAL_RCCEx_PeriphCLKConfig+0x1ac>
 8009d36:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
 8009d3a:	f43f aad7 	beq.w	80092ec <HAL_RCCEx_PeriphCLKConfig+0x1ac>
      ret = HAL_ERROR;
 8009d3e:	2601      	movs	r6, #1
 8009d40:	4635      	mov	r5, r6
 8009d42:	f7ff badf 	b.w	8009304 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    switch(PeriphClkInit->Lptim2ClockSelection)
 8009d46:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8009d4a:	f43f ac4b 	beq.w	80095e4 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
 8009d4e:	f5b2 5fa0 	cmp.w	r2, #5120	; 0x1400
 8009d52:	f43f ac47 	beq.w	80095e4 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
 8009d56:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 8009d5a:	f43f ac43 	beq.w	80095e4 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
      ret = HAL_ERROR;
 8009d5e:	2601      	movs	r6, #1
 8009d60:	4635      	mov	r5, r6
 8009d62:	e44b      	b.n	80095fc <HAL_RCCEx_PeriphCLKConfig+0x4bc>
    switch(PeriphClkInit->Sai4AClockSelection)
 8009d64:	f5b2 0fc0 	cmp.w	r2, #6291456	; 0x600000
 8009d68:	f43f aa44 	beq.w	80091f4 <HAL_RCCEx_PeriphCLKConfig+0xb4>
 8009d6c:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 8009d70:	f43f aa40 	beq.w	80091f4 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      ret = HAL_ERROR;
 8009d74:	2601      	movs	r6, #1
 8009d76:	4635      	mov	r5, r6
 8009d78:	f7ff ba41 	b.w	80091fe <HAL_RCCEx_PeriphCLKConfig+0xbe>
    switch(PeriphClkInit->Sai23ClockSelection)
 8009d7c:	2ac0      	cmp	r2, #192	; 0xc0
 8009d7e:	f43f aa1e 	beq.w	80091be <HAL_RCCEx_PeriphCLKConfig+0x7e>
 8009d82:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8009d86:	f43f aa1a 	beq.w	80091be <HAL_RCCEx_PeriphCLKConfig+0x7e>
      ret = HAL_ERROR;
 8009d8a:	2601      	movs	r6, #1
 8009d8c:	4635      	mov	r5, r6
 8009d8e:	f7ff ba1b 	b.w	80091c8 <HAL_RCCEx_PeriphCLKConfig+0x88>
    switch(PeriphClkInit->SpdifrxClockSelection)
 8009d92:	bb22      	cbnz	r2, 8009dde <HAL_RCCEx_PeriphCLKConfig+0xc9e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009d94:	4a1b      	ldr	r2, [pc, #108]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
 8009d96:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8009d98:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009d9c:	62d3      	str	r3, [r2, #44]	; 0x2c
 8009d9e:	6e42      	ldr	r2, [r0, #100]	; 0x64
 8009da0:	f7ff b9e4 	b.w	800916c <HAL_RCCEx_PeriphCLKConfig+0x2c>
    switch(PeriphClkInit->Spi123ClockSelection)
 8009da4:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 8009da8:	f43f aa69 	beq.w	800927e <HAL_RCCEx_PeriphCLKConfig+0x13e>
 8009dac:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 8009db0:	f43f aa65 	beq.w	800927e <HAL_RCCEx_PeriphCLKConfig+0x13e>
      ret = HAL_ERROR;
 8009db4:	2601      	movs	r6, #1
 8009db6:	4635      	mov	r5, r6
 8009db8:	f7ff ba66 	b.w	8009288 <HAL_RCCEx_PeriphCLKConfig+0x148>
    switch(PeriphClkInit->Sai4BClockSelection)
 8009dbc:	f1b2 7f40 	cmp.w	r2, #50331648	; 0x3000000
 8009dc0:	f43f aa33 	beq.w	800922a <HAL_RCCEx_PeriphCLKConfig+0xea>
 8009dc4:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 8009dc8:	f43f aa2f 	beq.w	800922a <HAL_RCCEx_PeriphCLKConfig+0xea>
      ret = HAL_ERROR;
 8009dcc:	2601      	movs	r6, #1
 8009dce:	4635      	mov	r5, r6
 8009dd0:	f7ff ba30 	b.w	8009234 <HAL_RCCEx_PeriphCLKConfig+0xf4>
    switch(PeriphClkInit->QspiClockSelection)
 8009dd4:	2a00      	cmp	r2, #0
 8009dd6:	f43f ae2e 	beq.w	8009a36 <HAL_RCCEx_PeriphCLKConfig+0x8f6>
 8009dda:	f7ff ba39 	b.w	8009250 <HAL_RCCEx_PeriphCLKConfig+0x110>
      ret = HAL_ERROR;
 8009dde:	2601      	movs	r6, #1
 8009de0:	f7ff b9cc 	b.w	800917c <HAL_RCCEx_PeriphCLKConfig+0x3c>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8009de4:	4807      	ldr	r0, [pc, #28]	; (8009e04 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
 8009de6:	4b09      	ldr	r3, [pc, #36]	; (8009e0c <HAL_RCCEx_PeriphCLKConfig+0xccc>)
 8009de8:	6901      	ldr	r1, [r0, #16]
 8009dea:	ea03 1312 	and.w	r3, r3, r2, lsr #4
 8009dee:	f421 527c 	bic.w	r2, r1, #16128	; 0x3f00
 8009df2:	4313      	orrs	r3, r2
 8009df4:	6103      	str	r3, [r0, #16]
 8009df6:	f7ff bb65 	b.w	80094c4 <HAL_RCCEx_PeriphCLKConfig+0x384>
 8009dfa:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8009dfc:	462e      	mov	r6, r5
 8009dfe:	f7ff bb6a 	b.w	80094d6 <HAL_RCCEx_PeriphCLKConfig+0x396>
 8009e02:	bf00      	nop
 8009e04:	58024400 	.word	0x58024400
 8009e08:	08029384 	.word	0x08029384
 8009e0c:	00ffffcf 	.word	0x00ffffcf

08009e10 <HAL_RCCEx_GetPLL2ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8009e10:	4a46      	ldr	r2, [pc, #280]	; (8009f2c <HAL_RCCEx_GetPLL2ClockFreq+0x11c>)
{
 8009e12:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8009e14:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
 8009e16:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 8009e18:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
 8009e1a:	f3c3 3305 	ubfx	r3, r3, #12, #6
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 8009e1e:	6bd5      	ldr	r5, [r2, #60]	; 0x3c
  if (pll2m != 0U)
 8009e20:	2b00      	cmp	r3, #0
 8009e22:	d059      	beq.n	8009ed8 <HAL_RCCEx_GetPLL2ClockFreq+0xc8>
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 8009e24:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 8009e28:	f3c1 1100 	ubfx	r1, r1, #4, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8009e2c:	f004 0403 	and.w	r4, r4, #3
 8009e30:	ee07 3a90 	vmov	s15, r3
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 8009e34:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
 8009e38:	2c01      	cmp	r4, #1
 8009e3a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8009e3e:	ee06 1a90 	vmov	s13, r1
 8009e42:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
 8009e46:	d002      	beq.n	8009e4e <HAL_RCCEx_GetPLL2ClockFreq+0x3e>
 8009e48:	d34e      	bcc.n	8009ee8 <HAL_RCCEx_GetPLL2ClockFreq+0xd8>
 8009e4a:	2c02      	cmp	r4, #2
 8009e4c:	d049      	beq.n	8009ee2 <HAL_RCCEx_GetPLL2ClockFreq+0xd2>
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8009e4e:	ed9f 7a38 	vldr	s14, [pc, #224]	; 8009f30 <HAL_RCCEx_GetPLL2ClockFreq+0x120>
 8009e52:	ee87 6a27 	vdiv.f32	s12, s14, s15
 8009e56:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8009e58:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009e5c:	ee07 3a10 	vmov	s14, r3
 8009e60:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 8009e64:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8009e68:	ee37 7a25 	vadd.f32	s14, s14, s11
 8009e6c:	ee77 7a26 	vadd.f32	s15, s14, s13
 8009e70:	ee67 7a86 	vmul.f32	s15, s15, s12
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
 8009e74:	4a2d      	ldr	r2, [pc, #180]	; (8009f2c <HAL_RCCEx_GetPLL2ClockFreq+0x11c>)
 8009e76:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8009e7a:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8009e7c:	f3c3 2346 	ubfx	r3, r3, #9, #7
 8009e80:	ee06 3a90 	vmov	s13, r3
 8009e84:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
 8009e88:	bc30      	pop	{r4, r5}
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
 8009e8a:	ee76 6a86 	vadd.f32	s13, s13, s12
 8009e8e:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8009e92:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8009e96:	ed80 7a00 	vstr	s14, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
 8009e9a:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8009e9c:	f3c3 4306 	ubfx	r3, r3, #16, #7
 8009ea0:	ee06 3a90 	vmov	s13, r3
 8009ea4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8009ea8:	ee76 6a86 	vadd.f32	s13, s13, s12
 8009eac:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8009eb0:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8009eb4:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
 8009eb8:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8009eba:	f3c3 6306 	ubfx	r3, r3, #24, #7
 8009ebe:	ee07 3a10 	vmov	s14, r3
 8009ec2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8009ec6:	ee37 7a06 	vadd.f32	s14, s14, s12
 8009eca:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8009ece:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 8009ed2:	edc0 6a02 	vstr	s13, [r0, #8]
}
 8009ed6:	4770      	bx	lr
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 8009ed8:	e9c0 3300 	strd	r3, r3, [r0]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 8009edc:	6083      	str	r3, [r0, #8]
}
 8009ede:	bc30      	pop	{r4, r5}
 8009ee0:	4770      	bx	lr
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8009ee2:	ed9f 7a14 	vldr	s14, [pc, #80]	; 8009f34 <HAL_RCCEx_GetPLL2ClockFreq+0x124>
 8009ee6:	e7b4      	b.n	8009e52 <HAL_RCCEx_GetPLL2ClockFreq+0x42>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8009ee8:	6813      	ldr	r3, [r2, #0]
 8009eea:	069b      	lsls	r3, r3, #26
 8009eec:	d51a      	bpl.n	8009f24 <HAL_RCCEx_GetPLL2ClockFreq+0x114>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8009eee:	6814      	ldr	r4, [r2, #0]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8009ef0:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8009ef4:	4910      	ldr	r1, [pc, #64]	; (8009f38 <HAL_RCCEx_GetPLL2ClockFreq+0x128>)
 8009ef6:	f3c4 04c1 	ubfx	r4, r4, #3, #2
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8009efa:	6b93      	ldr	r3, [r2, #56]	; 0x38
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8009efc:	40e1      	lsrs	r1, r4
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8009efe:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009f02:	ee07 1a10 	vmov	s14, r1
 8009f06:	eef8 5ac7 	vcvt.f32.s32	s11, s14
 8009f0a:	ee07 3a10 	vmov	s14, r3
 8009f0e:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
 8009f12:	ee85 7aa7 	vdiv.f32	s14, s11, s15
 8009f16:	ee76 7a05 	vadd.f32	s15, s12, s10
 8009f1a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8009f1e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8009f22:	e7a7      	b.n	8009e74 <HAL_RCCEx_GetPLL2ClockFreq+0x64>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8009f24:	ed9f 7a05 	vldr	s14, [pc, #20]	; 8009f3c <HAL_RCCEx_GetPLL2ClockFreq+0x12c>
 8009f28:	e793      	b.n	8009e52 <HAL_RCCEx_GetPLL2ClockFreq+0x42>
 8009f2a:	bf00      	nop
 8009f2c:	58024400 	.word	0x58024400
 8009f30:	4a742400 	.word	0x4a742400
 8009f34:	4bbebc20 	.word	0x4bbebc20
 8009f38:	03d09000 	.word	0x03d09000
 8009f3c:	4c742400 	.word	0x4c742400

08009f40 <HAL_RCCEx_GetPLL3ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8009f40:	4a46      	ldr	r2, [pc, #280]	; (800a05c <HAL_RCCEx_GetPLL3ClockFreq+0x11c>)
{
 8009f42:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8009f44:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
 8009f46:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 8009f48:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
 8009f4a:	f3c3 5305 	ubfx	r3, r3, #20, #6
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 8009f4e:	6c55      	ldr	r5, [r2, #68]	; 0x44
  if (pll3m != 0U)
 8009f50:	2b00      	cmp	r3, #0
 8009f52:	d059      	beq.n	800a008 <HAL_RCCEx_GetPLL3ClockFreq+0xc8>
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 8009f54:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 8009f58:	f3c1 2100 	ubfx	r1, r1, #8, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8009f5c:	f004 0403 	and.w	r4, r4, #3
 8009f60:	ee07 3a90 	vmov	s15, r3
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 8009f64:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
 8009f68:	2c01      	cmp	r4, #1
 8009f6a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8009f6e:	ee06 1a90 	vmov	s13, r1
 8009f72:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
 8009f76:	d002      	beq.n	8009f7e <HAL_RCCEx_GetPLL3ClockFreq+0x3e>
 8009f78:	d34e      	bcc.n	800a018 <HAL_RCCEx_GetPLL3ClockFreq+0xd8>
 8009f7a:	2c02      	cmp	r4, #2
 8009f7c:	d049      	beq.n	800a012 <HAL_RCCEx_GetPLL3ClockFreq+0xd2>
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 8009f7e:	ed9f 7a38 	vldr	s14, [pc, #224]	; 800a060 <HAL_RCCEx_GetPLL3ClockFreq+0x120>
 8009f82:	ee87 6a27 	vdiv.f32	s12, s14, s15
 8009f86:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009f88:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009f8c:	ee07 3a10 	vmov	s14, r3
 8009f90:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 8009f94:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8009f98:	ee37 7a25 	vadd.f32	s14, s14, s11
 8009f9c:	ee77 7a26 	vadd.f32	s15, s14, s13
 8009fa0:	ee67 7a86 	vmul.f32	s15, s15, s12
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
 8009fa4:	4a2d      	ldr	r2, [pc, #180]	; (800a05c <HAL_RCCEx_GetPLL3ClockFreq+0x11c>)
 8009fa6:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8009faa:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009fac:	f3c3 2346 	ubfx	r3, r3, #9, #7
 8009fb0:	ee06 3a90 	vmov	s13, r3
 8009fb4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
 8009fb8:	bc30      	pop	{r4, r5}
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
 8009fba:	ee76 6a86 	vadd.f32	s13, s13, s12
 8009fbe:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8009fc2:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8009fc6:	ed80 7a00 	vstr	s14, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
 8009fca:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009fcc:	f3c3 4306 	ubfx	r3, r3, #16, #7
 8009fd0:	ee06 3a90 	vmov	s13, r3
 8009fd4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8009fd8:	ee76 6a86 	vadd.f32	s13, s13, s12
 8009fdc:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8009fe0:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8009fe4:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
 8009fe8:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009fea:	f3c3 6306 	ubfx	r3, r3, #24, #7
 8009fee:	ee07 3a10 	vmov	s14, r3
 8009ff2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8009ff6:	ee37 7a06 	vadd.f32	s14, s14, s12
 8009ffa:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8009ffe:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800a002:	edc0 6a02 	vstr	s13, [r0, #8]
}
 800a006:	4770      	bx	lr
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 800a008:	e9c0 3300 	strd	r3, r3, [r0]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 800a00c:	6083      	str	r3, [r0, #8]
}
 800a00e:	bc30      	pop	{r4, r5}
 800a010:	4770      	bx	lr
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800a012:	ed9f 7a14 	vldr	s14, [pc, #80]	; 800a064 <HAL_RCCEx_GetPLL3ClockFreq+0x124>
 800a016:	e7b4      	b.n	8009f82 <HAL_RCCEx_GetPLL3ClockFreq+0x42>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800a018:	6813      	ldr	r3, [r2, #0]
 800a01a:	069b      	lsls	r3, r3, #26
 800a01c:	d51a      	bpl.n	800a054 <HAL_RCCEx_GetPLL3ClockFreq+0x114>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800a01e:	6814      	ldr	r4, [r2, #0]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800a020:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800a024:	4910      	ldr	r1, [pc, #64]	; (800a068 <HAL_RCCEx_GetPLL3ClockFreq+0x128>)
 800a026:	f3c4 04c1 	ubfx	r4, r4, #3, #2
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800a02a:	6c13      	ldr	r3, [r2, #64]	; 0x40
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800a02c:	40e1      	lsrs	r1, r4
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800a02e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a032:	ee07 1a10 	vmov	s14, r1
 800a036:	eef8 5ac7 	vcvt.f32.s32	s11, s14
 800a03a:	ee07 3a10 	vmov	s14, r3
 800a03e:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
 800a042:	ee85 7aa7 	vdiv.f32	s14, s11, s15
 800a046:	ee76 7a05 	vadd.f32	s15, s12, s10
 800a04a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a04e:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a052:	e7a7      	b.n	8009fa4 <HAL_RCCEx_GetPLL3ClockFreq+0x64>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800a054:	ed9f 7a05 	vldr	s14, [pc, #20]	; 800a06c <HAL_RCCEx_GetPLL3ClockFreq+0x12c>
 800a058:	e793      	b.n	8009f82 <HAL_RCCEx_GetPLL3ClockFreq+0x42>
 800a05a:	bf00      	nop
 800a05c:	58024400 	.word	0x58024400
 800a060:	4a742400 	.word	0x4a742400
 800a064:	4bbebc20 	.word	0x4bbebc20
 800a068:	03d09000 	.word	0x03d09000
 800a06c:	4c742400 	.word	0x4c742400

0800a070 <HAL_RCCEx_GetPLL1ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800a070:	4a46      	ldr	r2, [pc, #280]	; (800a18c <HAL_RCCEx_GetPLL1ClockFreq+0x11c>)
{
 800a072:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800a074:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
 800a076:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
 800a078:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
 800a07a:	f3c3 1305 	ubfx	r3, r3, #4, #6
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800a07e:	6b55      	ldr	r5, [r2, #52]	; 0x34
  if (pll1m != 0U)
 800a080:	2b00      	cmp	r3, #0
 800a082:	d059      	beq.n	800a138 <HAL_RCCEx_GetPLL1ClockFreq+0xc8>
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800a084:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
 800a088:	f001 0101 	and.w	r1, r1, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800a08c:	f004 0403 	and.w	r4, r4, #3
 800a090:	ee07 3a90 	vmov	s15, r3
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800a094:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
 800a098:	2c01      	cmp	r4, #1
 800a09a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800a09e:	ee06 1a90 	vmov	s13, r1
 800a0a2:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
 800a0a6:	d002      	beq.n	800a0ae <HAL_RCCEx_GetPLL1ClockFreq+0x3e>
 800a0a8:	d34e      	bcc.n	800a148 <HAL_RCCEx_GetPLL1ClockFreq+0xd8>
 800a0aa:	2c02      	cmp	r4, #2
 800a0ac:	d049      	beq.n	800a142 <HAL_RCCEx_GetPLL1ClockFreq+0xd2>
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800a0ae:	ed9f 7a38 	vldr	s14, [pc, #224]	; 800a190 <HAL_RCCEx_GetPLL1ClockFreq+0x120>
 800a0b2:	ee87 6a27 	vdiv.f32	s12, s14, s15
 800a0b6:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800a0b8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a0bc:	ee07 3a10 	vmov	s14, r3
 800a0c0:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 800a0c4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800a0c8:	ee37 7a25 	vadd.f32	s14, s14, s11
 800a0cc:	ee77 7a26 	vadd.f32	s15, s14, s13
 800a0d0:	ee67 7a86 	vmul.f32	s15, s15, s12
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
 800a0d4:	4a2d      	ldr	r2, [pc, #180]	; (800a18c <HAL_RCCEx_GetPLL1ClockFreq+0x11c>)
 800a0d6:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 800a0da:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800a0dc:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800a0e0:	ee06 3a90 	vmov	s13, r3
 800a0e4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
 800a0e8:	bc30      	pop	{r4, r5}
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
 800a0ea:	ee76 6a86 	vadd.f32	s13, s13, s12
 800a0ee:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800a0f2:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800a0f6:	ed80 7a00 	vstr	s14, [r0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
 800a0fa:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800a0fc:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800a100:	ee06 3a90 	vmov	s13, r3
 800a104:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800a108:	ee76 6a86 	vadd.f32	s13, s13, s12
 800a10c:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800a110:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800a114:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
 800a118:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800a11a:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800a11e:	ee07 3a10 	vmov	s14, r3
 800a122:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800a126:	ee37 7a06 	vadd.f32	s14, s14, s12
 800a12a:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800a12e:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800a132:	edc0 6a02 	vstr	s13, [r0, #8]
}
 800a136:	4770      	bx	lr
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
 800a138:	e9c0 3300 	strd	r3, r3, [r0]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
 800a13c:	6083      	str	r3, [r0, #8]
}
 800a13e:	bc30      	pop	{r4, r5}
 800a140:	4770      	bx	lr
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800a142:	ed9f 7a14 	vldr	s14, [pc, #80]	; 800a194 <HAL_RCCEx_GetPLL1ClockFreq+0x124>
 800a146:	e7b4      	b.n	800a0b2 <HAL_RCCEx_GetPLL1ClockFreq+0x42>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800a148:	6813      	ldr	r3, [r2, #0]
 800a14a:	069b      	lsls	r3, r3, #26
 800a14c:	d51a      	bpl.n	800a184 <HAL_RCCEx_GetPLL1ClockFreq+0x114>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800a14e:	6814      	ldr	r4, [r2, #0]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800a150:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800a154:	4910      	ldr	r1, [pc, #64]	; (800a198 <HAL_RCCEx_GetPLL1ClockFreq+0x128>)
 800a156:	f3c4 04c1 	ubfx	r4, r4, #3, #2
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800a15a:	6b13      	ldr	r3, [r2, #48]	; 0x30
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800a15c:	40e1      	lsrs	r1, r4
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800a15e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a162:	ee07 1a10 	vmov	s14, r1
 800a166:	eef8 5ac7 	vcvt.f32.s32	s11, s14
 800a16a:	ee07 3a10 	vmov	s14, r3
 800a16e:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
 800a172:	ee85 7aa7 	vdiv.f32	s14, s11, s15
 800a176:	ee76 7a05 	vadd.f32	s15, s12, s10
 800a17a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a17e:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a182:	e7a7      	b.n	800a0d4 <HAL_RCCEx_GetPLL1ClockFreq+0x64>
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800a184:	ed9f 7a05 	vldr	s14, [pc, #20]	; 800a19c <HAL_RCCEx_GetPLL1ClockFreq+0x12c>
 800a188:	e793      	b.n	800a0b2 <HAL_RCCEx_GetPLL1ClockFreq+0x42>
 800a18a:	bf00      	nop
 800a18c:	58024400 	.word	0x58024400
 800a190:	4a742400 	.word	0x4a742400
 800a194:	4bbebc20 	.word	0x4bbebc20
 800a198:	03d09000 	.word	0x03d09000
 800a19c:	4c742400 	.word	0x4c742400

0800a1a0 <HAL_RCCEx_GetPeriphCLKFreq>:
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 800a1a0:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
{
 800a1a4:	b500      	push	{lr}
 800a1a6:	b085      	sub	sp, #20
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 800a1a8:	d02d      	beq.n	800a206 <HAL_RCCEx_GetPeriphCLKFreq+0x66>
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
 800a1aa:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800a1ae:	d018      	beq.n	800a1e2 <HAL_RCCEx_GetPeriphCLKFreq+0x42>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
 800a1b0:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 800a1b4:	d04e      	beq.n	800a254 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
 800a1b6:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 800a1ba:	d037      	beq.n	800a22c <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
 800a1bc:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 800a1c0:	f000 808b 	beq.w	800a2da <HAL_RCCEx_GetPeriphCLKFreq+0x13a>
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
 800a1c4:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 800a1c8:	f000 80ac 	beq.w	800a324 <HAL_RCCEx_GetPeriphCLKFreq+0x184>
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
 800a1cc:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 800a1d0:	f000 80b6 	beq.w	800a340 <HAL_RCCEx_GetPeriphCLKFreq+0x1a0>
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
 800a1d4:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
 800a1d8:	d062      	beq.n	800a2a0 <HAL_RCCEx_GetPeriphCLKFreq+0x100>
          frequency = 0;
 800a1da:	2000      	movs	r0, #0
}
 800a1dc:	b005      	add	sp, #20
 800a1de:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
 800a1e2:	4a70      	ldr	r2, [pc, #448]	; (800a3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
 800a1e4:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800a1e6:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
      switch (saiclocksource)
 800a1ea:	2b80      	cmp	r3, #128	; 0x80
 800a1ec:	d043      	beq.n	800a276 <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
 800a1ee:	d86a      	bhi.n	800a2c6 <HAL_RCCEx_GetPeriphCLKFreq+0x126>
 800a1f0:	2b00      	cmp	r3, #0
 800a1f2:	d039      	beq.n	800a268 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
 800a1f4:	2b40      	cmp	r3, #64	; 0x40
 800a1f6:	d1f0      	bne.n	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800a1f8:	a801      	add	r0, sp, #4
 800a1fa:	f7ff fe09 	bl	8009e10 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 800a1fe:	9801      	ldr	r0, [sp, #4]
}
 800a200:	b005      	add	sp, #20
 800a202:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
 800a206:	4b67      	ldr	r3, [pc, #412]	; (800a3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
 800a208:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800a20a:	f003 0307 	and.w	r3, r3, #7
      switch (saiclocksource)
 800a20e:	2b04      	cmp	r3, #4
 800a210:	d8e3      	bhi.n	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
 800a212:	a201      	add	r2, pc, #4	; (adr r2, 800a218 <HAL_RCCEx_GetPeriphCLKFreq+0x78>)
 800a214:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a218:	0800a269 	.word	0x0800a269
 800a21c:	0800a1f9 	.word	0x0800a1f9
 800a220:	0800a277 	.word	0x0800a277
 800a224:	0800a24d 	.word	0x0800a24d
 800a228:	0800a285 	.word	0x0800a285
      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
 800a22c:	4a5d      	ldr	r2, [pc, #372]	; (800a3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
 800a22e:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800a230:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
      switch (saiclocksource)
 800a234:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800a238:	d01d      	beq.n	800a276 <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
 800a23a:	d85c      	bhi.n	800a2f6 <HAL_RCCEx_GetPeriphCLKFreq+0x156>
 800a23c:	b1a3      	cbz	r3, 800a268 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
 800a23e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800a242:	d0d9      	beq.n	800a1f8 <HAL_RCCEx_GetPeriphCLKFreq+0x58>
 800a244:	e7c9      	b.n	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
 800a246:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 800a24a:	d15b      	bne.n	800a304 <HAL_RCCEx_GetPeriphCLKFreq+0x164>
          frequency = EXTERNAL_CLOCK_VALUE;
 800a24c:	4856      	ldr	r0, [pc, #344]	; (800a3a8 <HAL_RCCEx_GetPeriphCLKFreq+0x208>)
}
 800a24e:	b005      	add	sp, #20
 800a250:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
 800a254:	4a53      	ldr	r2, [pc, #332]	; (800a3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
 800a256:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800a258:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
      switch (saiclocksource)
 800a25c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800a260:	d009      	beq.n	800a276 <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
 800a262:	d8f0      	bhi.n	800a246 <HAL_RCCEx_GetPeriphCLKFreq+0xa6>
 800a264:	2b00      	cmp	r3, #0
 800a266:	d151      	bne.n	800a30c <HAL_RCCEx_GetPeriphCLKFreq+0x16c>
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800a268:	a801      	add	r0, sp, #4
 800a26a:	f7ff ff01 	bl	800a070 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 800a26e:	9802      	ldr	r0, [sp, #8]
}
 800a270:	b005      	add	sp, #20
 800a272:	f85d fb04 	ldr.w	pc, [sp], #4
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800a276:	a801      	add	r0, sp, #4
 800a278:	f7ff fe62 	bl	8009f40 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 800a27c:	9801      	ldr	r0, [sp, #4]
}
 800a27e:	b005      	add	sp, #20
 800a280:	f85d fb04 	ldr.w	pc, [sp], #4
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
 800a284:	4b47      	ldr	r3, [pc, #284]	; (800a3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
 800a286:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
 800a288:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
 800a28c:	d019      	beq.n	800a2c2 <HAL_RCCEx_GetPeriphCLKFreq+0x122>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
 800a28e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800a292:	d062      	beq.n	800a35a <HAL_RCCEx_GetPeriphCLKFreq+0x1ba>
            frequency = HSE_VALUE;
 800a294:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800a298:	4844      	ldr	r0, [pc, #272]	; (800a3ac <HAL_RCCEx_GetPeriphCLKFreq+0x20c>)
 800a29a:	bf18      	it	ne
 800a29c:	2000      	movne	r0, #0
 800a29e:	e79d      	b.n	800a1dc <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
 800a2a0:	4b40      	ldr	r3, [pc, #256]	; (800a3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
 800a2a2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800a2a4:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
      switch (srcclk)
 800a2a8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800a2ac:	d068      	beq.n	800a380 <HAL_RCCEx_GetPeriphCLKFreq+0x1e0>
 800a2ae:	d95b      	bls.n	800a368 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>
 800a2b0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800a2b4:	d051      	beq.n	800a35a <HAL_RCCEx_GetPeriphCLKFreq+0x1ba>
 800a2b6:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 800a2ba:	d05f      	beq.n	800a37c <HAL_RCCEx_GetPeriphCLKFreq+0x1dc>
 800a2bc:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 800a2c0:	d18b      	bne.n	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
            frequency = HSI_VALUE;
 800a2c2:	483b      	ldr	r0, [pc, #236]	; (800a3b0 <HAL_RCCEx_GetPeriphCLKFreq+0x210>)
 800a2c4:	e78a      	b.n	800a1dc <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      switch (saiclocksource)
 800a2c6:	2bc0      	cmp	r3, #192	; 0xc0
 800a2c8:	d0c0      	beq.n	800a24c <HAL_RCCEx_GetPeriphCLKFreq+0xac>
 800a2ca:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a2ce:	d184      	bne.n	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
 800a2d0:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
 800a2d2:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
 800a2d6:	d1da      	bne.n	800a28e <HAL_RCCEx_GetPeriphCLKFreq+0xee>
 800a2d8:	e7f3      	b.n	800a2c2 <HAL_RCCEx_GetPeriphCLKFreq+0x122>
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
 800a2da:	4a32      	ldr	r2, [pc, #200]	; (800a3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
 800a2dc:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800a2de:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
      switch (srcclk)
 800a2e2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a2e6:	d0c6      	beq.n	800a276 <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
 800a2e8:	d815      	bhi.n	800a316 <HAL_RCCEx_GetPeriphCLKFreq+0x176>
 800a2ea:	2b00      	cmp	r3, #0
 800a2ec:	d0bc      	beq.n	800a268 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
 800a2ee:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a2f2:	d081      	beq.n	800a1f8 <HAL_RCCEx_GetPeriphCLKFreq+0x58>
 800a2f4:	e771      	b.n	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
 800a2f6:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 800a2fa:	d0a7      	beq.n	800a24c <HAL_RCCEx_GetPeriphCLKFreq+0xac>
 800a2fc:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800a300:	d0e6      	beq.n	800a2d0 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
 800a302:	e76a      	b.n	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
 800a304:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800a308:	d0e2      	beq.n	800a2d0 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
 800a30a:	e766      	b.n	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
 800a30c:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800a310:	f43f af72 	beq.w	800a1f8 <HAL_RCCEx_GetPeriphCLKFreq+0x58>
 800a314:	e761      	b.n	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (srcclk)
 800a316:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800a31a:	d097      	beq.n	800a24c <HAL_RCCEx_GetPeriphCLKFreq+0xac>
 800a31c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800a320:	d0d6      	beq.n	800a2d0 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
 800a322:	e75a      	b.n	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
 800a324:	4a1f      	ldr	r2, [pc, #124]	; (800a3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
 800a326:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800a328:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
      switch (srcclk)
 800a32c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a330:	d015      	beq.n	800a35e <HAL_RCCEx_GetPeriphCLKFreq+0x1be>
 800a332:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800a336:	d0cb      	beq.n	800a2d0 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
 800a338:	2b00      	cmp	r3, #0
 800a33a:	f47f af4e 	bne.w	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
 800a33e:	e75b      	b.n	800a1f8 <HAL_RCCEx_GetPeriphCLKFreq+0x58>
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
 800a340:	4b18      	ldr	r3, [pc, #96]	; (800a3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
 800a342:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
      switch (srcclk)
 800a344:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
 800a348:	d08e      	beq.n	800a268 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
 800a34a:	2b00      	cmp	r3, #0
 800a34c:	f43f af45 	beq.w	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800a350:	a801      	add	r0, sp, #4
 800a352:	f7ff fd5d 	bl	8009e10 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
 800a356:	9803      	ldr	r0, [sp, #12]
          break;
 800a358:	e740      	b.n	800a1dc <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
            frequency = CSI_VALUE;
 800a35a:	4816      	ldr	r0, [pc, #88]	; (800a3b4 <HAL_RCCEx_GetPeriphCLKFreq+0x214>)
 800a35c:	e73e      	b.n	800a1dc <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800a35e:	a801      	add	r0, sp, #4
 800a360:	f7ff fdee 	bl	8009f40 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 800a364:	9803      	ldr	r0, [sp, #12]
          break;
 800a366:	e739      	b.n	800a1dc <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      switch (srcclk)
 800a368:	b17b      	cbz	r3, 800a38a <HAL_RCCEx_GetPeriphCLKFreq+0x1ea>
 800a36a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800a36e:	f47f af34 	bne.w	800a1da <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800a372:	a801      	add	r0, sp, #4
 800a374:	f7ff fd4c 	bl	8009e10 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 800a378:	9802      	ldr	r0, [sp, #8]
          break;
 800a37a:	e72f      	b.n	800a1dc <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          frequency = HSE_VALUE;
 800a37c:	480b      	ldr	r0, [pc, #44]	; (800a3ac <HAL_RCCEx_GetPeriphCLKFreq+0x20c>)
          break;
 800a37e:	e72d      	b.n	800a1dc <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800a380:	a801      	add	r0, sp, #4
 800a382:	f7ff fddd 	bl	8009f40 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 800a386:	9802      	ldr	r0, [sp, #8]
          break;
 800a388:	e728      	b.n	800a1dc <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 800a38a:	f7fe fc51 	bl	8008c30 <HAL_RCC_GetHCLKFreq>
 800a38e:	4b05      	ldr	r3, [pc, #20]	; (800a3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
 800a390:	4a09      	ldr	r2, [pc, #36]	; (800a3b8 <HAL_RCCEx_GetPeriphCLKFreq+0x218>)
 800a392:	6a1b      	ldr	r3, [r3, #32]
 800a394:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800a398:	5cd3      	ldrb	r3, [r2, r3]
 800a39a:	f003 031f 	and.w	r3, r3, #31
 800a39e:	40d8      	lsrs	r0, r3
          break;
 800a3a0:	e71c      	b.n	800a1dc <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
 800a3a2:	bf00      	nop
 800a3a4:	58024400 	.word	0x58024400
 800a3a8:	00bb8000 	.word	0x00bb8000
 800a3ac:	017d7840 	.word	0x017d7840
 800a3b0:	03d09000 	.word	0x03d09000
 800a3b4:	003d0900 	.word	0x003d0900
 800a3b8:	0802a1f8 	.word	0x0802a1f8

0800a3bc <HAL_RNG_Init>:
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
  uint32_t tickstart;
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 800a3bc:	2800      	cmp	r0, #0
 800a3be:	d049      	beq.n	800a454 <HAL_RNG_Init+0x98>
{
 800a3c0:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }
  /* Check the parameters */
  assert_param(IS_RNG_ALL_INSTANCE(hrng->Instance));
 800a3c2:	4b28      	ldr	r3, [pc, #160]	; (800a464 <HAL_RNG_Init+0xa8>)
 800a3c4:	4604      	mov	r4, r0
 800a3c6:	6802      	ldr	r2, [r0, #0]
 800a3c8:	429a      	cmp	r2, r3
 800a3ca:	d003      	beq.n	800a3d4 <HAL_RNG_Init+0x18>
 800a3cc:	21b1      	movs	r1, #177	; 0xb1
 800a3ce:	4826      	ldr	r0, [pc, #152]	; (800a468 <HAL_RNG_Init+0xac>)
 800a3d0:	f009 fa7e 	bl	80138d0 <assert_failed>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
 800a3d4:	6863      	ldr	r3, [r4, #4]
 800a3d6:	f033 0320 	bics.w	r3, r3, #32
 800a3da:	d131      	bne.n	800a440 <HAL_RNG_Init+0x84>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 800a3dc:	7a63      	ldrb	r3, [r4, #9]
 800a3de:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800a3e2:	b343      	cbz	r3, 800a436 <HAL_RNG_Init+0x7a>
    HAL_RNG_MspInit(hrng);
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 800a3e4:	2302      	movs	r3, #2
      return HAL_ERROR;
    }
  }
#else
  /* Clock Error Detection Configuration */
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
 800a3e6:	e9d4 2100 	ldrd	r2, r1, [r4]
  hrng->State = HAL_RNG_STATE_BUSY;
 800a3ea:	7263      	strb	r3, [r4, #9]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
 800a3ec:	6813      	ldr	r3, [r2, #0]
 800a3ee:	f023 0320 	bic.w	r3, r3, #32
 800a3f2:	430b      	orrs	r3, r1
 800a3f4:	6013      	str	r3, [r2, #0]
#endif /* end of RNG_CR_CONDRST */

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 800a3f6:	6822      	ldr	r2, [r4, #0]
 800a3f8:	6813      	ldr	r3, [r2, #0]
 800a3fa:	f043 0304 	orr.w	r3, r3, #4
 800a3fe:	6013      	str	r3, [r2, #0]

  /* verify that no seed error */
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 800a400:	6823      	ldr	r3, [r4, #0]
 800a402:	685b      	ldr	r3, [r3, #4]
 800a404:	065b      	lsls	r3, r3, #25
 800a406:	d503      	bpl.n	800a410 <HAL_RNG_Init+0x54>
  {
    hrng->State = HAL_RNG_STATE_ERROR;
 800a408:	2304      	movs	r3, #4
    return HAL_ERROR;
 800a40a:	2001      	movs	r0, #1
    hrng->State = HAL_RNG_STATE_ERROR;
 800a40c:	7263      	strb	r3, [r4, #9]
  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
 800a40e:	bd38      	pop	{r3, r4, r5, pc}
  tickstart = HAL_GetTick();
 800a410:	f7f6 fb0a 	bl	8000a28 <HAL_GetTick>
 800a414:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 800a416:	e004      	b.n	800a422 <HAL_RNG_Init+0x66>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 800a418:	f7f6 fb06 	bl	8000a28 <HAL_GetTick>
 800a41c:	1b40      	subs	r0, r0, r5
 800a41e:	2802      	cmp	r0, #2
 800a420:	d81a      	bhi.n	800a458 <HAL_RNG_Init+0x9c>
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 800a422:	6823      	ldr	r3, [r4, #0]
 800a424:	685b      	ldr	r3, [r3, #4]
 800a426:	f013 0304 	ands.w	r3, r3, #4
 800a42a:	d1f5      	bne.n	800a418 <HAL_RNG_Init+0x5c>
  hrng->State = HAL_RNG_STATE_READY;
 800a42c:	2201      	movs	r2, #1
  return HAL_OK;
 800a42e:	4618      	mov	r0, r3
  hrng->State = HAL_RNG_STATE_READY;
 800a430:	7262      	strb	r2, [r4, #9]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 800a432:	60e3      	str	r3, [r4, #12]
}
 800a434:	bd38      	pop	{r3, r4, r5, pc}
    hrng->Lock = HAL_UNLOCKED;
 800a436:	7222      	strb	r2, [r4, #8]
    HAL_RNG_MspInit(hrng);
 800a438:	4620      	mov	r0, r4
 800a43a:	f009 ff63 	bl	8014304 <HAL_RNG_MspInit>
 800a43e:	e7d1      	b.n	800a3e4 <HAL_RNG_Init+0x28>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
 800a440:	21b2      	movs	r1, #178	; 0xb2
 800a442:	4809      	ldr	r0, [pc, #36]	; (800a468 <HAL_RNG_Init+0xac>)
 800a444:	f009 fa44 	bl	80138d0 <assert_failed>
  if (hrng->State == HAL_RNG_STATE_RESET)
 800a448:	7a63      	ldrb	r3, [r4, #9]
 800a44a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800a44e:	2b00      	cmp	r3, #0
 800a450:	d1c8      	bne.n	800a3e4 <HAL_RNG_Init+0x28>
 800a452:	e7f0      	b.n	800a436 <HAL_RNG_Init+0x7a>
    return HAL_ERROR;
 800a454:	2001      	movs	r0, #1
}
 800a456:	4770      	bx	lr
      hrng->State = HAL_RNG_STATE_ERROR;
 800a458:	2204      	movs	r2, #4
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800a45a:	2302      	movs	r3, #2
      return HAL_ERROR;
 800a45c:	2001      	movs	r0, #1
      hrng->State = HAL_RNG_STATE_ERROR;
 800a45e:	7262      	strb	r2, [r4, #9]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800a460:	60e3      	str	r3, [r4, #12]
}
 800a462:	bd38      	pop	{r3, r4, r5, pc}
 800a464:	48021800 	.word	0x48021800
 800a468:	080293c0 	.word	0x080293c0

0800a46c <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 800a46c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
 800a46e:	7a03      	ldrb	r3, [r0, #8]
 800a470:	2b01      	cmp	r3, #1
 800a472:	d00b      	beq.n	800a48c <HAL_RNG_GenerateRandomNumber+0x20>
 800a474:	4604      	mov	r4, r0
 800a476:	2001      	movs	r0, #1
 800a478:	460e      	mov	r6, r1

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
 800a47a:	7a63      	ldrb	r3, [r4, #9]
  __HAL_LOCK(hrng);
 800a47c:	7220      	strb	r0, [r4, #8]
  if (hrng->State == HAL_RNG_STATE_READY)
 800a47e:	4283      	cmp	r3, r0
 800a480:	d006      	beq.n	800a490 <HAL_RNG_GenerateRandomNumber+0x24>

    hrng->State = HAL_RNG_STATE_READY;
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 800a482:	2304      	movs	r3, #4
 800a484:	60e3      	str	r3, [r4, #12]
    status = HAL_ERROR;
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 800a486:	2300      	movs	r3, #0
 800a488:	7223      	strb	r3, [r4, #8]

  return status;
}
 800a48a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hrng);
 800a48c:	2002      	movs	r0, #2
}
 800a48e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->State = HAL_RNG_STATE_BUSY;
 800a490:	2302      	movs	r3, #2
 800a492:	7263      	strb	r3, [r4, #9]
    tickstart = HAL_GetTick();
 800a494:	f7f6 fac8 	bl	8000a28 <HAL_GetTick>
 800a498:	4607      	mov	r7, r0
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 800a49a:	e004      	b.n	800a4a6 <HAL_RNG_GenerateRandomNumber+0x3a>
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 800a49c:	f7f6 fac4 	bl	8000a28 <HAL_GetTick>
 800a4a0:	1bc0      	subs	r0, r0, r7
 800a4a2:	2802      	cmp	r0, #2
 800a4a4:	d80b      	bhi.n	800a4be <HAL_RNG_GenerateRandomNumber+0x52>
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 800a4a6:	6822      	ldr	r2, [r4, #0]
 800a4a8:	6855      	ldr	r5, [r2, #4]
 800a4aa:	f015 0501 	ands.w	r5, r5, #1
 800a4ae:	d0f5      	beq.n	800a49c <HAL_RNG_GenerateRandomNumber+0x30>
    hrng->RandomNumber = hrng->Instance->DR;
 800a4b0:	6893      	ldr	r3, [r2, #8]
    hrng->State = HAL_RNG_STATE_READY;
 800a4b2:	2201      	movs	r2, #1
  HAL_StatusTypeDef status = HAL_OK;
 800a4b4:	2000      	movs	r0, #0
    hrng->RandomNumber = hrng->Instance->DR;
 800a4b6:	6123      	str	r3, [r4, #16]
    *random32bit = hrng->RandomNumber;
 800a4b8:	6033      	str	r3, [r6, #0]
    hrng->State = HAL_RNG_STATE_READY;
 800a4ba:	7262      	strb	r2, [r4, #9]
 800a4bc:	e7e3      	b.n	800a486 <HAL_RNG_GenerateRandomNumber+0x1a>
        hrng->State = HAL_RNG_STATE_READY;
 800a4be:	2001      	movs	r0, #1
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800a4c0:	2302      	movs	r3, #2
        __HAL_UNLOCK(hrng);
 800a4c2:	7225      	strb	r5, [r4, #8]
        hrng->State = HAL_RNG_STATE_READY;
 800a4c4:	7260      	strb	r0, [r4, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800a4c6:	60e3      	str	r3, [r4, #12]
}
 800a4c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a4ca:	bf00      	nop

0800a4cc <HAL_SAI_InitProtocol>:
HAL_StatusTypeDef HAL_SAI_InitProtocol(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
  HAL_StatusTypeDef status;

  /* Check the parameters */
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
 800a4cc:	2904      	cmp	r1, #4
{
 800a4ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a4d0:	460d      	mov	r5, r1
 800a4d2:	4604      	mov	r4, r0
 800a4d4:	4617      	mov	r7, r2
 800a4d6:	461e      	mov	r6, r3
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
 800a4d8:	d87c      	bhi.n	800a5d4 <HAL_SAI_InitProtocol+0x108>
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
 800a4da:	2f03      	cmp	r7, #3
 800a4dc:	d874      	bhi.n	800a5c8 <HAL_SAI_InitProtocol+0xfc>

  switch (protocol)
 800a4de:	2d04      	cmp	r5, #4
 800a4e0:	d828      	bhi.n	800a534 <HAL_SAI_InitProtocol+0x68>
 800a4e2:	e8df f005 	tbb	[pc, r5]
 800a4e6:	4c4c      	.short	0x4c4c
 800a4e8:	294c      	.short	0x294c
 800a4ea:	29          	.byte	0x29
 800a4eb:	00          	.byte	0x00

  /* Check the SAI PDM parameters */
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
  if (hsai->Init.PdmInit.Activation == ENABLE)
  {
    assert_param(IS_SAI_PDM_MIC_PAIRS_NUMBER(hsai->Init.PdmInit.MicPairsNbr));
 800a4ec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800a4ee:	3b01      	subs	r3, #1
 800a4f0:	2b02      	cmp	r3, #2
 800a4f2:	d904      	bls.n	800a4fe <HAL_SAI_InitProtocol+0x32>
 800a4f4:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 800a4f8:	4839      	ldr	r0, [pc, #228]	; (800a5e0 <HAL_SAI_InitProtocol+0x114>)
 800a4fa:	f009 f9e9 	bl	80138d0 <assert_failed>
    assert_param(IS_SAI_PDM_CLOCK_ENABLE(hsai->Init.PdmInit.ClockEnable));
 800a4fe:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800a500:	b113      	cbz	r3, 800a508 <HAL_SAI_InitProtocol+0x3c>
 800a502:	f433 7340 	bics.w	r3, r3, #768	; 0x300
 800a506:	d004      	beq.n	800a512 <HAL_SAI_InitProtocol+0x46>
 800a508:	f240 11af 	movw	r1, #431	; 0x1af
 800a50c:	4834      	ldr	r0, [pc, #208]	; (800a5e0 <HAL_SAI_InitProtocol+0x114>)
 800a50e:	f009 f9df 	bl	80138d0 <assert_failed>
    /* Check that SAI sub-block is SAI1 or SAI4 sub-block A, in master RX mode with free protocol */
#if defined(SAI4)
    if (((hsai->Instance != SAI1_Block_A) && (hsai->Instance != SAI4_Block_A)) ||
 800a512:	6823      	ldr	r3, [r4, #0]
 800a514:	4a33      	ldr	r2, [pc, #204]	; (800a5e4 <HAL_SAI_InitProtocol+0x118>)
 800a516:	4293      	cmp	r3, r2
 800a518:	d005      	beq.n	800a526 <HAL_SAI_InitProtocol+0x5a>
 800a51a:	f102 52c0 	add.w	r2, r2, #402653184	; 0x18000000
 800a51e:	f5a2 3282 	sub.w	r2, r2, #66560	; 0x10400
 800a522:	4293      	cmp	r3, r2
 800a524:	d106      	bne.n	800a534 <HAL_SAI_InitProtocol+0x68>
 800a526:	6862      	ldr	r2, [r4, #4]
 800a528:	2a01      	cmp	r2, #1
 800a52a:	d103      	bne.n	800a534 <HAL_SAI_InitProtocol+0x68>
         (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
 800a52c:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800a52e:	2a00      	cmp	r2, #0
 800a530:	f000 816d 	beq.w	800a80e <HAL_SAI_InitProtocol+0x342>
  hsai->SlotInit.SlotNumber      = nbslot;

  /* in IS2 the number of slot must be even */
  if ((nbslot & 0x1U) != 0U)
  {
    return HAL_ERROR;
 800a534:	2001      	movs	r0, #1
}
 800a536:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  HAL_StatusTypeDef status = HAL_OK;

  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
  /* Compute ClockStrobing according AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800a538:	6862      	ldr	r2, [r4, #4]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 800a53a:	2300      	movs	r3, #0
  {
    /* Receive */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_FALLINGEDGE;
  }
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
  hsai->FrameInit.FSPolarity     = SAI_FS_ACTIVE_HIGH;
 800a53c:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
 800a540:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800a544:	f032 0202 	bics.w	r2, r2, #2
  hsai->SlotInit.FirstBitOffset  = 0;
  hsai->SlotInit.SlotNumber      = nbslot;
 800a548:	6726      	str	r6, [r4, #112]	; 0x70
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 800a54a:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800a54c:	bf0c      	ite	eq
 800a54e:	2201      	moveq	r2, #1
 800a550:	461a      	movne	r2, r3
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;

  if (protocol == SAI_PCM_SHORT)
  {
      hsai->FrameInit.ActiveFrameLength = 1;
 800a552:	2d04      	cmp	r5, #4
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
 800a554:	64e3      	str	r3, [r4, #76]	; 0x4c
 800a556:	6522      	str	r2, [r4, #80]	; 0x50
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 800a558:	f64f 72ff 	movw	r2, #65535	; 0xffff
      hsai->FrameInit.ActiveFrameLength = 1;
 800a55c:	bf14      	ite	ne
 800a55e:	250d      	movne	r5, #13
 800a560:	2501      	moveq	r5, #1
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
 800a562:	65e3      	str	r3, [r4, #92]	; 0x5c
 800a564:	65a5      	str	r5, [r4, #88]	; 0x58
  hsai->SlotInit.FirstBitOffset  = 0;
 800a566:	66a3      	str	r3, [r4, #104]	; 0x68
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 800a568:	6762      	str	r2, [r4, #116]	; 0x74
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
 800a56a:	e9c4 0118 	strd	r0, r1, [r4, #96]	; 0x60
  {
    /* SAI_PCM_LONG */
      hsai->FrameInit.ActiveFrameLength = 13;
  }

  switch (datasize)
 800a56e:	2f03      	cmp	r7, #3
 800a570:	d8e0      	bhi.n	800a534 <HAL_SAI_InitProtocol+0x68>
 800a572:	e8df f017 	tbh	[pc, r7, lsl #1]
 800a576:	0173      	.short	0x0173
 800a578:	017a016d 	.word	0x017a016d
 800a57c:	0039      	.short	0x0039
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800a57e:	6862      	ldr	r2, [r4, #4]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 800a580:	2300      	movs	r3, #0
  hsai->SlotInit.SlotNumber      = nbslot;
 800a582:	6726      	str	r6, [r4, #112]	; 0x70
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800a584:	f032 0202 	bics.w	r2, r2, #2
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 800a588:	6463      	str	r3, [r4, #68]	; 0x44
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
 800a58a:	64e3      	str	r3, [r4, #76]	; 0x4c
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
 800a58c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800a590:	bf08      	it	eq
 800a592:	4619      	moveq	r1, r3
  hsai->SlotInit.FirstBitOffset  = 0;
 800a594:	66a3      	str	r3, [r4, #104]	; 0x68
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 800a596:	f64f 73ff 	movw	r3, #65535	; 0xffff
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800a59a:	bf18      	it	ne
 800a59c:	2101      	movne	r1, #1
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
 800a59e:	65e2      	str	r2, [r4, #92]	; 0x5c
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 800a5a0:	6763      	str	r3, [r4, #116]	; 0x74
  if ((nbslot & 0x1U) != 0U)
 800a5a2:	f016 0301 	ands.w	r3, r6, #1
 800a5a6:	6521      	str	r1, [r4, #80]	; 0x50
 800a5a8:	d1c4      	bne.n	800a534 <HAL_SAI_InitProtocol+0x68>
  if (protocol == SAI_I2S_STANDARD)
 800a5aa:	2d00      	cmp	r5, #0
 800a5ac:	f000 8164 	beq.w	800a878 <HAL_SAI_InitProtocol+0x3ac>
 800a5b0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800a5b4:	e9c4 2318 	strd	r2, r3, [r4, #96]	; 0x60
  switch (datasize)
 800a5b8:	2f03      	cmp	r7, #3
 800a5ba:	d8bb      	bhi.n	800a534 <HAL_SAI_InitProtocol+0x68>
 800a5bc:	e8df f017 	tbh	[pc, r7, lsl #1]
 800a5c0:	02490259 	.word	0x02490259
 800a5c4:	022e0238 	.word	0x022e0238
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
 800a5c8:	f44f 71a9 	mov.w	r1, #338	; 0x152
 800a5cc:	4804      	ldr	r0, [pc, #16]	; (800a5e0 <HAL_SAI_InitProtocol+0x114>)
 800a5ce:	f009 f97f 	bl	80138d0 <assert_failed>
 800a5d2:	e784      	b.n	800a4de <HAL_SAI_InitProtocol+0x12>
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
 800a5d4:	f240 1151 	movw	r1, #337	; 0x151
 800a5d8:	4801      	ldr	r0, [pc, #4]	; (800a5e0 <HAL_SAI_InitProtocol+0x114>)
 800a5da:	f009 f979 	bl	80138d0 <assert_failed>
 800a5de:	e77c      	b.n	800a4da <HAL_SAI_InitProtocol+0xe>
 800a5e0:	080293f8 	.word	0x080293f8
 800a5e4:	40015804 	.word	0x40015804
      hsai->FrameInit.FrameLength = 32U * nbslot;
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
      break;
    case SAI_PROTOCOL_DATASIZE_32BIT:
      hsai->Init.DataSize = SAI_DATASIZE_32;
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800a5e8:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_32;
 800a5ea:	21e0      	movs	r1, #224	; 0xe0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800a5ec:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800a5ee:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_32;
 800a5f0:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800a5f2:	66e2      	str	r2, [r4, #108]	; 0x6c
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
 800a5f4:	6822      	ldr	r2, [r4, #0]
 800a5f6:	4ba7      	ldr	r3, [pc, #668]	; (800a894 <HAL_SAI_InitProtocol+0x3c8>)
 800a5f8:	49a7      	ldr	r1, [pc, #668]	; (800a898 <HAL_SAI_InitProtocol+0x3cc>)
 800a5fa:	48a8      	ldr	r0, [pc, #672]	; (800a89c <HAL_SAI_InitProtocol+0x3d0>)
 800a5fc:	429a      	cmp	r2, r3
 800a5fe:	bf18      	it	ne
 800a600:	428a      	cmpne	r2, r1
 800a602:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800a606:	4da6      	ldr	r5, [pc, #664]	; (800a8a0 <HAL_SAI_InitProtocol+0x3d4>)
 800a608:	bf14      	ite	ne
 800a60a:	2301      	movne	r3, #1
 800a60c:	2300      	moveq	r3, #0
 800a60e:	4282      	cmp	r2, r0
 800a610:	bf0c      	ite	eq
 800a612:	2300      	moveq	r3, #0
 800a614:	f003 0301 	andne.w	r3, r3, #1
 800a618:	f500 6084 	add.w	r0, r0, #1056	; 0x420
 800a61c:	428a      	cmp	r2, r1
 800a61e:	bf0c      	ite	eq
 800a620:	2300      	moveq	r3, #0
 800a622:	f003 0301 	andne.w	r3, r3, #1
 800a626:	499f      	ldr	r1, [pc, #636]	; (800a8a4 <HAL_SAI_InitProtocol+0x3d8>)
 800a628:	42aa      	cmp	r2, r5
 800a62a:	bf0c      	ite	eq
 800a62c:	2300      	moveq	r3, #0
 800a62e:	f003 0301 	andne.w	r3, r3, #1
 800a632:	4282      	cmp	r2, r0
 800a634:	bf0c      	ite	eq
 800a636:	2300      	moveq	r3, #0
 800a638:	f003 0301 	andne.w	r3, r3, #1
 800a63c:	428a      	cmp	r2, r1
 800a63e:	bf0c      	ite	eq
 800a640:	2300      	moveq	r3, #0
 800a642:	f003 0301 	andne.w	r3, r3, #1
 800a646:	b11b      	cbz	r3, 800a650 <HAL_SAI_InitProtocol+0x184>
 800a648:	4b97      	ldr	r3, [pc, #604]	; (800a8a8 <HAL_SAI_InitProtocol+0x3dc>)
 800a64a:	429a      	cmp	r2, r3
 800a64c:	f040 835d 	bne.w	800ad0a <HAL_SAI_InitProtocol+0x83e>
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
 800a650:	6a22      	ldr	r2, [r4, #32]
 800a652:	f64b 3680 	movw	r6, #48000	; 0xbb80
 800a656:	4b95      	ldr	r3, [pc, #596]	; (800a8ac <HAL_SAI_InitProtocol+0x3e0>)
 800a658:	f64a 4544 	movw	r5, #44100	; 0xac44
 800a65c:	4994      	ldr	r1, [pc, #592]	; (800a8b0 <HAL_SAI_InitProtocol+0x3e4>)
 800a65e:	f245 6022 	movw	r0, #22050	; 0x5622
 800a662:	429a      	cmp	r2, r3
 800a664:	bf18      	it	ne
 800a666:	428a      	cmpne	r2, r1
 800a668:	f642 3111 	movw	r1, #11025	; 0x2b11
 800a66c:	bf14      	ite	ne
 800a66e:	2301      	movne	r3, #1
 800a670:	2300      	moveq	r3, #0
 800a672:	42b2      	cmp	r2, r6
 800a674:	bf0c      	ite	eq
 800a676:	2300      	moveq	r3, #0
 800a678:	f003 0301 	andne.w	r3, r3, #1
 800a67c:	42aa      	cmp	r2, r5
 800a67e:	bf0c      	ite	eq
 800a680:	2300      	moveq	r3, #0
 800a682:	f003 0301 	andne.w	r3, r3, #1
 800a686:	f5b2 4ffa 	cmp.w	r2, #32000	; 0x7d00
 800a68a:	bf0c      	ite	eq
 800a68c:	2300      	moveq	r3, #0
 800a68e:	f003 0301 	andne.w	r3, r3, #1
 800a692:	4282      	cmp	r2, r0
 800a694:	bf0c      	ite	eq
 800a696:	2300      	moveq	r3, #0
 800a698:	f003 0301 	andne.w	r3, r3, #1
 800a69c:	f5b2 5f7a 	cmp.w	r2, #16000	; 0x3e80
 800a6a0:	bf0c      	ite	eq
 800a6a2:	2300      	moveq	r3, #0
 800a6a4:	f003 0301 	andne.w	r3, r3, #1
 800a6a8:	428a      	cmp	r2, r1
 800a6aa:	bf0c      	ite	eq
 800a6ac:	2300      	moveq	r3, #0
 800a6ae:	f003 0301 	andne.w	r3, r3, #1
 800a6b2:	f5b2 5ffa 	cmp.w	r2, #8000	; 0x1f40
 800a6b6:	bf0c      	ite	eq
 800a6b8:	2300      	moveq	r3, #0
 800a6ba:	f003 0301 	andne.w	r3, r3, #1
 800a6be:	b113      	cbz	r3, 800a6c6 <HAL_SAI_InitProtocol+0x1fa>
 800a6c0:	2a00      	cmp	r2, #0
 800a6c2:	f040 8333 	bne.w	800ad2c <HAL_SAI_InitProtocol+0x860>
  assert_param(IS_SAI_BLOCK_PROTOCOL(hsai->Init.Protocol));
 800a6c6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800a6c8:	f033 0204 	bics.w	r2, r3, #4
 800a6cc:	d006      	beq.n	800a6dc <HAL_SAI_InitProtocol+0x210>
 800a6ce:	2b08      	cmp	r3, #8
 800a6d0:	d004      	beq.n	800a6dc <HAL_SAI_InitProtocol+0x210>
 800a6d2:	f240 1185 	movw	r1, #389	; 0x185
 800a6d6:	4877      	ldr	r0, [pc, #476]	; (800a8b4 <HAL_SAI_InitProtocol+0x3e8>)
 800a6d8:	f009 f8fa 	bl	80138d0 <assert_failed>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
 800a6dc:	6863      	ldr	r3, [r4, #4]
 800a6de:	2b03      	cmp	r3, #3
 800a6e0:	f200 8166 	bhi.w	800a9b0 <HAL_SAI_InitProtocol+0x4e4>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
 800a6e4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800a6e6:	f023 0220 	bic.w	r2, r3, #32
 800a6ea:	2a80      	cmp	r2, #128	; 0x80
 800a6ec:	d004      	beq.n	800a6f8 <HAL_SAI_InitProtocol+0x22c>
 800a6ee:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 800a6f2:	2b40      	cmp	r3, #64	; 0x40
 800a6f4:	f040 82e7 	bne.w	800acc6 <HAL_SAI_InitProtocol+0x7fa>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
 800a6f8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800a6fa:	f433 7380 	bics.w	r3, r3, #256	; 0x100
 800a6fe:	f040 8151 	bne.w	800a9a4 <HAL_SAI_InitProtocol+0x4d8>
  assert_param(IS_SAI_BLOCK_CLOCK_STROBING(hsai->Init.ClockStrobing));
 800a702:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800a704:	2b01      	cmp	r3, #1
 800a706:	d904      	bls.n	800a712 <HAL_SAI_InitProtocol+0x246>
 800a708:	f240 1189 	movw	r1, #393	; 0x189
 800a70c:	4869      	ldr	r0, [pc, #420]	; (800a8b4 <HAL_SAI_InitProtocol+0x3e8>)
 800a70e:	f009 f8df 	bl	80138d0 <assert_failed>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
 800a712:	68a3      	ldr	r3, [r4, #8]
 800a714:	2b05      	cmp	r3, #5
 800a716:	f200 813f 	bhi.w	800a998 <HAL_SAI_InitProtocol+0x4cc>
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
 800a71a:	f7f6 f99d 	bl	8000a58 <HAL_GetREVID>
 800a71e:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 800a722:	d304      	bcc.n	800a72e <HAL_SAI_InitProtocol+0x262>
    assert_param(IS_SAI_BLOCK_MCK_OUTPUT(hsai->Init.MckOutput));
 800a724:	6923      	ldr	r3, [r4, #16]
 800a726:	f033 6300 	bics.w	r3, r3, #134217728	; 0x8000000
 800a72a:	f040 8294 	bne.w	800ac56 <HAL_SAI_InitProtocol+0x78a>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
 800a72e:	6963      	ldr	r3, [r4, #20]
 800a730:	f433 5300 	bics.w	r3, r3, #8192	; 0x2000
 800a734:	f040 812a 	bne.w	800a98c <HAL_SAI_InitProtocol+0x4c0>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
 800a738:	69a3      	ldr	r3, [r4, #24]
 800a73a:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
 800a73e:	f040 8167 	bne.w	800aa10 <HAL_SAI_InitProtocol+0x544>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
 800a742:	69e3      	ldr	r3, [r4, #28]
 800a744:	2b04      	cmp	r3, #4
 800a746:	f200 815d 	bhi.w	800aa04 <HAL_SAI_InitProtocol+0x538>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
 800a74a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800a74c:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 800a750:	f040 8152 	bne.w	800a9f8 <HAL_SAI_InitProtocol+0x52c>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
 800a754:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800a756:	f423 4180 	bic.w	r1, r3, #16384	; 0x4000
 800a75a:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 800a75e:	f5b1 4f20 	cmp.w	r1, #40960	; 0xa000
 800a762:	bf18      	it	ne
 800a764:	2a00      	cmpne	r2, #0
 800a766:	d003      	beq.n	800a770 <HAL_SAI_InitProtocol+0x2a4>
 800a768:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800a76c:	f040 82a3 	bne.w	800acb6 <HAL_SAI_InitProtocol+0x7ea>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
 800a770:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800a772:	f033 0310 	bics.w	r3, r3, #16
 800a776:	f040 8139 	bne.w	800a9ec <HAL_SAI_InitProtocol+0x520>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
 800a77a:	68e3      	ldr	r3, [r4, #12]
 800a77c:	2b02      	cmp	r3, #2
 800a77e:	f200 812f 	bhi.w	800a9e0 <HAL_SAI_InitProtocol+0x514>
  assert_param(IS_SAI_BLOCK_MCK_OVERSAMPLING(hsai->Init.MckOverSampling));
 800a782:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a784:	f033 6380 	bics.w	r3, r3, #67108864	; 0x4000000
 800a788:	f040 8124 	bne.w	800a9d4 <HAL_SAI_InitProtocol+0x508>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
 800a78c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800a78e:	3b08      	subs	r3, #8
 800a790:	2bf8      	cmp	r3, #248	; 0xf8
 800a792:	f200 8119 	bhi.w	800a9c8 <HAL_SAI_InitProtocol+0x4fc>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
 800a796:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800a798:	3b01      	subs	r3, #1
 800a79a:	2b7f      	cmp	r3, #127	; 0x7f
 800a79c:	f200 810e 	bhi.w	800a9bc <HAL_SAI_InitProtocol+0x4f0>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
 800a7a0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800a7a2:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
 800a7a6:	f040 80eb 	bne.w	800a980 <HAL_SAI_InitProtocol+0x4b4>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
 800a7aa:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800a7ac:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 800a7b0:	f040 80e0 	bne.w	800a974 <HAL_SAI_InitProtocol+0x4a8>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
 800a7b4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800a7b6:	f433 2380 	bics.w	r3, r3, #262144	; 0x40000
 800a7ba:	f040 80d5 	bne.w	800a968 <HAL_SAI_InitProtocol+0x49c>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
 800a7be:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800a7c0:	2b18      	cmp	r3, #24
 800a7c2:	f200 80cb 	bhi.w	800a95c <HAL_SAI_InitProtocol+0x490>
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
 800a7c6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800a7c8:	f033 0240 	bics.w	r2, r3, #64	; 0x40
 800a7cc:	d006      	beq.n	800a7dc <HAL_SAI_InitProtocol+0x310>
 800a7ce:	2b80      	cmp	r3, #128	; 0x80
 800a7d0:	d004      	beq.n	800a7dc <HAL_SAI_InitProtocol+0x310>
 800a7d2:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
 800a7d6:	4837      	ldr	r0, [pc, #220]	; (800a8b4 <HAL_SAI_InitProtocol+0x3e8>)
 800a7d8:	f009 f87a 	bl	80138d0 <assert_failed>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
 800a7dc:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800a7de:	3b01      	subs	r3, #1
 800a7e0:	2b0f      	cmp	r3, #15
 800a7e2:	f200 80b5 	bhi.w	800a950 <HAL_SAI_InitProtocol+0x484>
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
 800a7e6:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800a7e8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a7ec:	f080 80aa 	bcs.w	800a944 <HAL_SAI_InitProtocol+0x478>
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
 800a7f0:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 800a7f4:	2b01      	cmp	r3, #1
 800a7f6:	d906      	bls.n	800a806 <HAL_SAI_InitProtocol+0x33a>
 800a7f8:	f240 11ab 	movw	r1, #427	; 0x1ab
 800a7fc:	482d      	ldr	r0, [pc, #180]	; (800a8b4 <HAL_SAI_InitProtocol+0x3e8>)
 800a7fe:	f009 f867 	bl	80138d0 <assert_failed>
 800a802:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
  if (hsai->Init.PdmInit.Activation == ENABLE)
 800a806:	2b01      	cmp	r3, #1
 800a808:	f43f ae70 	beq.w	800a4ec <HAL_SAI_InitProtocol+0x20>
 800a80c:	6823      	ldr	r3, [r4, #0]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 800a80e:	4a21      	ldr	r2, [pc, #132]	; (800a894 <HAL_SAI_InitProtocol+0x3c8>)
 800a810:	4293      	cmp	r3, r2
 800a812:	d053      	beq.n	800a8bc <HAL_SAI_InitProtocol+0x3f0>
 800a814:	3220      	adds	r2, #32
 800a816:	4293      	cmp	r3, r2
 800a818:	d050      	beq.n	800a8bc <HAL_SAI_InitProtocol+0x3f0>
  else if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
 800a81a:	f502 7278 	add.w	r2, r2, #992	; 0x3e0
 800a81e:	4293      	cmp	r3, r2
 800a820:	f000 8136 	beq.w	800aa90 <HAL_SAI_InitProtocol+0x5c4>
 800a824:	3220      	adds	r2, #32
 800a826:	4293      	cmp	r3, r2
 800a828:	f000 8132 	beq.w	800aa90 <HAL_SAI_InitProtocol+0x5c4>
  else if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
 800a82c:	f502 7278 	add.w	r2, r2, #992	; 0x3e0
 800a830:	4293      	cmp	r3, r2
 800a832:	f000 8246 	beq.w	800acc2 <HAL_SAI_InitProtocol+0x7f6>
 800a836:	3220      	adds	r2, #32
 800a838:	4293      	cmp	r3, r2
 800a83a:	f000 8242 	beq.w	800acc2 <HAL_SAI_InitProtocol+0x7f6>
  else if ((hsai->Instance == SAI4_Block_A) || (hsai->Instance == SAI4_Block_B))
 800a83e:	4a19      	ldr	r2, [pc, #100]	; (800a8a4 <HAL_SAI_InitProtocol+0x3d8>)
 800a840:	4293      	cmp	r3, r2
 800a842:	d003      	beq.n	800a84c <HAL_SAI_InitProtocol+0x380>
 800a844:	3220      	adds	r2, #32
 800a846:	4293      	cmp	r3, r2
 800a848:	f47f ae74 	bne.w	800a534 <HAL_SAI_InitProtocol+0x68>
    SaiBaseAddress = SAI4;
 800a84c:	4d1a      	ldr	r5, [pc, #104]	; (800a8b8 <HAL_SAI_InitProtocol+0x3ec>)
 800a84e:	e036      	b.n	800a8be <HAL_SAI_InitProtocol+0x3f2>
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800a850:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800a852:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800a854:	64a2      	str	r2, [r4, #72]	; 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800a856:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800a858:	66e2      	str	r2, [r4, #108]	; 0x6c
 800a85a:	e6cb      	b.n	800a5f4 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 16U * nbslot;
 800a85c:	0136      	lsls	r6, r6, #4
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800a85e:	2180      	movs	r1, #128	; 0x80
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 800a860:	2240      	movs	r2, #64	; 0x40
      hsai->FrameInit.FrameLength = 16U * nbslot;
 800a862:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800a864:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 800a866:	66e2      	str	r2, [r4, #108]	; 0x6c
 800a868:	e6c4      	b.n	800a5f4 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800a86a:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_24;
 800a86c:	21c0      	movs	r1, #192	; 0xc0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800a86e:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800a870:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_24;
 800a872:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800a874:	66e2      	str	r2, [r4, #108]	; 0x6c
 800a876:	e6bd      	b.n	800a5f4 <HAL_SAI_InitProtocol+0x128>
 800a878:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800a87c:	e9c4 5318 	strd	r5, r3, [r4, #96]	; 0x60
  switch (datasize)
 800a880:	2f03      	cmp	r7, #3
 800a882:	f63f ae57 	bhi.w	800a534 <HAL_SAI_InitProtocol+0x68>
 800a886:	e8df f017 	tbh	[pc, r7, lsl #1]
 800a88a:	00f4      	.short	0x00f4
 800a88c:	00d300e4 	.word	0x00d300e4
 800a890:	00c9      	.short	0x00c9
 800a892:	bf00      	nop
 800a894:	40015804 	.word	0x40015804
 800a898:	40015824 	.word	0x40015824
 800a89c:	40015c04 	.word	0x40015c04
 800a8a0:	40016004 	.word	0x40016004
 800a8a4:	58005404 	.word	0x58005404
 800a8a8:	58005424 	.word	0x58005424
 800a8ac:	0002ee00 	.word	0x0002ee00
 800a8b0:	00017700 	.word	0x00017700
 800a8b4:	080293f8 	.word	0x080293f8
 800a8b8:	58005400 	.word	0x58005400
    SaiBaseAddress = SAI1;
 800a8bc:	4d75      	ldr	r5, [pc, #468]	; (800aa94 <HAL_SAI_InitProtocol+0x5c8>)
  if (hsai->State == HAL_SAI_STATE_RESET)
 800a8be:	f894 2091 	ldrb.w	r2, [r4, #145]	; 0x91
 800a8c2:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 800a8c6:	2a00      	cmp	r2, #0
 800a8c8:	f000 81be 	beq.w	800ac48 <HAL_SAI_InitProtocol+0x77c>
  *              the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800a8cc:	4a72      	ldr	r2, [pc, #456]	; (800aa98 <HAL_SAI_InitProtocol+0x5cc>)
 800a8ce:	4873      	ldr	r0, [pc, #460]	; (800aa9c <HAL_SAI_InitProtocol+0x5d0>)
 800a8d0:	6812      	ldr	r2, [r2, #0]
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
 800a8d2:	6819      	ldr	r1, [r3, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800a8d4:	fba0 0202 	umull	r0, r2, r0, r2
  __HAL_SAI_DISABLE(hsai);
 800a8d8:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800a8dc:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
 800a8de:	6019      	str	r1, [r3, #0]

  do
  {
    /* Check for the Timeout */
    if (count == 0U)
 800a8e0:	0093      	lsls	r3, r2, #2
 800a8e2:	b33a      	cbz	r2, 800a934 <HAL_SAI_InitProtocol+0x468>
      status = HAL_TIMEOUT;
      break;
    }
    count--;
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800a8e4:	6821      	ldr	r1, [r4, #0]
    count--;
 800a8e6:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800a8e8:	680a      	ldr	r2, [r1, #0]
 800a8ea:	03d7      	lsls	r7, r2, #15
 800a8ec:	d504      	bpl.n	800a8f8 <HAL_SAI_InitProtocol+0x42c>
    if (count == 0U)
 800a8ee:	b30b      	cbz	r3, 800a934 <HAL_SAI_InitProtocol+0x468>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800a8f0:	680a      	ldr	r2, [r1, #0]
    count--;
 800a8f2:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800a8f4:	03d2      	lsls	r2, r2, #15
 800a8f6:	d4fa      	bmi.n	800a8ee <HAL_SAI_InitProtocol+0x422>
  switch (hsai->Init.SynchroExt)
 800a8f8:	68e3      	ldr	r3, [r4, #12]
  hsai->State = HAL_SAI_STATE_BUSY;
 800a8fa:	2202      	movs	r2, #2
  switch (hsai->Init.SynchroExt)
 800a8fc:	2b01      	cmp	r3, #1
  hsai->State = HAL_SAI_STATE_BUSY;
 800a8fe:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
  switch (hsai->Init.SynchroExt)
 800a902:	f000 80c0 	beq.w	800aa86 <HAL_SAI_InitProtocol+0x5ba>
 800a906:	4293      	cmp	r3, r2
 800a908:	bf15      	itete	ne
 800a90a:	4610      	movne	r0, r2
 800a90c:	2123      	moveq	r1, #35	; 0x23
 800a90e:	2103      	movne	r1, #3
 800a910:	2022      	moveq	r0, #34	; 0x22
 800a912:	bf0b      	itete	eq
 800a914:	2621      	moveq	r6, #33	; 0x21
 800a916:	2601      	movne	r6, #1
 800a918:	2220      	moveq	r2, #32
 800a91a:	2200      	movne	r2, #0
  switch (hsai->Init.Synchro)
 800a91c:	68a3      	ldr	r3, [r4, #8]
 800a91e:	3b01      	subs	r3, #1
 800a920:	2b04      	cmp	r3, #4
 800a922:	f200 818b 	bhi.w	800ac3c <HAL_SAI_InitProtocol+0x770>
 800a926:	e8df f013 	tbh	[pc, r3, lsl #1]
 800a92a:	0186      	.short	0x0186
 800a92c:	018b00c0 	.word	0x018b00c0
 800a930:	01da00bf 	.word	0x01da00bf
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800a934:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    return HAL_ERROR;
 800a938:	2001      	movs	r0, #1
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800a93a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800a93e:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
}
 800a942:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
 800a944:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
 800a948:	4855      	ldr	r0, [pc, #340]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a94a:	f008 ffc1 	bl	80138d0 <assert_failed>
 800a94e:	e74f      	b.n	800a7f0 <HAL_SAI_InitProtocol+0x324>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
 800a950:	f240 11a7 	movw	r1, #423	; 0x1a7
 800a954:	4852      	ldr	r0, [pc, #328]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a956:	f008 ffbb 	bl	80138d0 <assert_failed>
 800a95a:	e744      	b.n	800a7e6 <HAL_SAI_InitProtocol+0x31a>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
 800a95c:	f240 11a5 	movw	r1, #421	; 0x1a5
 800a960:	484f      	ldr	r0, [pc, #316]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a962:	f008 ffb5 	bl	80138d0 <assert_failed>
 800a966:	e72e      	b.n	800a7c6 <HAL_SAI_InitProtocol+0x2fa>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
 800a968:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
 800a96c:	484c      	ldr	r0, [pc, #304]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a96e:	f008 ffaf 	bl	80138d0 <assert_failed>
 800a972:	e724      	b.n	800a7be <HAL_SAI_InitProtocol+0x2f2>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
 800a974:	f240 11a1 	movw	r1, #417	; 0x1a1
 800a978:	4849      	ldr	r0, [pc, #292]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a97a:	f008 ffa9 	bl	80138d0 <assert_failed>
 800a97e:	e719      	b.n	800a7b4 <HAL_SAI_InitProtocol+0x2e8>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
 800a980:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 800a984:	4846      	ldr	r0, [pc, #280]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a986:	f008 ffa3 	bl	80138d0 <assert_failed>
 800a98a:	e70e      	b.n	800a7aa <HAL_SAI_InitProtocol+0x2de>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
 800a98c:	f44f 71ca 	mov.w	r1, #404	; 0x194
 800a990:	4843      	ldr	r0, [pc, #268]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a992:	f008 ff9d 	bl	80138d0 <assert_failed>
 800a996:	e6cf      	b.n	800a738 <HAL_SAI_InitProtocol+0x26c>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
 800a998:	f44f 71c5 	mov.w	r1, #394	; 0x18a
 800a99c:	4840      	ldr	r0, [pc, #256]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a99e:	f008 ff97 	bl	80138d0 <assert_failed>
 800a9a2:	e6ba      	b.n	800a71a <HAL_SAI_InitProtocol+0x24e>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
 800a9a4:	f44f 71c4 	mov.w	r1, #392	; 0x188
 800a9a8:	483d      	ldr	r0, [pc, #244]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a9aa:	f008 ff91 	bl	80138d0 <assert_failed>
 800a9ae:	e6a8      	b.n	800a702 <HAL_SAI_InitProtocol+0x236>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
 800a9b0:	f44f 71c3 	mov.w	r1, #390	; 0x186
 800a9b4:	483a      	ldr	r0, [pc, #232]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a9b6:	f008 ff8b 	bl	80138d0 <assert_failed>
 800a9ba:	e693      	b.n	800a6e4 <HAL_SAI_InitProtocol+0x218>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
 800a9bc:	f240 119f 	movw	r1, #415	; 0x19f
 800a9c0:	4837      	ldr	r0, [pc, #220]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a9c2:	f008 ff85 	bl	80138d0 <assert_failed>
 800a9c6:	e6eb      	b.n	800a7a0 <HAL_SAI_InitProtocol+0x2d4>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
 800a9c8:	f44f 71cf 	mov.w	r1, #414	; 0x19e
 800a9cc:	4834      	ldr	r0, [pc, #208]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a9ce:	f008 ff7f 	bl	80138d0 <assert_failed>
 800a9d2:	e6e0      	b.n	800a796 <HAL_SAI_InitProtocol+0x2ca>
  assert_param(IS_SAI_BLOCK_MCK_OVERSAMPLING(hsai->Init.MckOverSampling));
 800a9d4:	f240 119b 	movw	r1, #411	; 0x19b
 800a9d8:	4831      	ldr	r0, [pc, #196]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a9da:	f008 ff79 	bl	80138d0 <assert_failed>
 800a9de:	e6d5      	b.n	800a78c <HAL_SAI_InitProtocol+0x2c0>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
 800a9e0:	f44f 71cd 	mov.w	r1, #410	; 0x19a
 800a9e4:	482e      	ldr	r0, [pc, #184]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a9e6:	f008 ff73 	bl	80138d0 <assert_failed>
 800a9ea:	e6ca      	b.n	800a782 <HAL_SAI_InitProtocol+0x2b6>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
 800a9ec:	f240 1199 	movw	r1, #409	; 0x199
 800a9f0:	482b      	ldr	r0, [pc, #172]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a9f2:	f008 ff6d 	bl	80138d0 <assert_failed>
 800a9f6:	e6c0      	b.n	800a77a <HAL_SAI_InitProtocol+0x2ae>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
 800a9f8:	f240 1197 	movw	r1, #407	; 0x197
 800a9fc:	4828      	ldr	r0, [pc, #160]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800a9fe:	f008 ff67 	bl	80138d0 <assert_failed>
 800aa02:	e6a7      	b.n	800a754 <HAL_SAI_InitProtocol+0x288>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
 800aa04:	f44f 71cb 	mov.w	r1, #406	; 0x196
 800aa08:	4825      	ldr	r0, [pc, #148]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800aa0a:	f008 ff61 	bl	80138d0 <assert_failed>
 800aa0e:	e69c      	b.n	800a74a <HAL_SAI_InitProtocol+0x27e>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
 800aa10:	f240 1195 	movw	r1, #405	; 0x195
 800aa14:	4822      	ldr	r0, [pc, #136]	; (800aaa0 <HAL_SAI_InitProtocol+0x5d4>)
 800aa16:	f008 ff5b 	bl	80138d0 <assert_failed>
 800aa1a:	e692      	b.n	800a742 <HAL_SAI_InitProtocol+0x276>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800aa1c:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_32;
 800aa1e:	21e0      	movs	r1, #224	; 0xe0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800aa20:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800aa22:	01b3      	lsls	r3, r6, #6
      hsai->Init.DataSize = SAI_DATASIZE_32;
 800aa24:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800aa26:	0176      	lsls	r6, r6, #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800aa28:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800aa2a:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
 800aa2e:	e5e1      	b.n	800a5f4 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800aa30:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_24;
 800aa32:	21c0      	movs	r1, #192	; 0xc0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800aa34:	2280      	movs	r2, #128	; 0x80
  if (protocol == SAI_I2S_LSBJUSTIFIED)
 800aa36:	2d02      	cmp	r5, #2
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800aa38:	ea4f 1386 	mov.w	r3, r6, lsl #6
      hsai->Init.DataSize = SAI_DATASIZE_24;
 800aa3c:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800aa3e:	ea4f 1646 	mov.w	r6, r6, lsl #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800aa42:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800aa44:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
  if (protocol == SAI_I2S_LSBJUSTIFIED)
 800aa48:	f47f add4 	bne.w	800a5f4 <HAL_SAI_InitProtocol+0x128>
      hsai->SlotInit.FirstBitOffset = 8;
 800aa4c:	2308      	movs	r3, #8
 800aa4e:	66a3      	str	r3, [r4, #104]	; 0x68
 800aa50:	e5d0      	b.n	800a5f4 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800aa52:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800aa54:	2380      	movs	r3, #128	; 0x80
  if (protocol == SAI_I2S_LSBJUSTIFIED)
 800aa56:	2d02      	cmp	r5, #2
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800aa58:	ea4f 1286 	mov.w	r2, r6, lsl #6
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800aa5c:	64a3      	str	r3, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800aa5e:	ea4f 1646 	mov.w	r6, r6, lsl #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800aa62:	66e3      	str	r3, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800aa64:	e9c4 2615 	strd	r2, r6, [r4, #84]	; 0x54
  if (protocol == SAI_I2S_LSBJUSTIFIED)
 800aa68:	f47f adc4 	bne.w	800a5f4 <HAL_SAI_InitProtocol+0x128>
      hsai->SlotInit.FirstBitOffset = 16;
 800aa6c:	2310      	movs	r3, #16
 800aa6e:	66a3      	str	r3, [r4, #104]	; 0x68
 800aa70:	e5c0      	b.n	800a5f4 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
 800aa72:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800aa74:	2180      	movs	r1, #128	; 0x80
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 800aa76:	2240      	movs	r2, #64	; 0x40
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
 800aa78:	0173      	lsls	r3, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800aa7a:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
 800aa7c:	0136      	lsls	r6, r6, #4
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 800aa7e:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
 800aa80:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
 800aa84:	e5b6      	b.n	800a5f4 <HAL_SAI_InitProtocol+0x128>
  switch (hsai->Init.SynchroExt)
 800aa86:	2113      	movs	r1, #19
 800aa88:	2012      	movs	r0, #18
 800aa8a:	2611      	movs	r6, #17
      tmpregisterGCR = SAI_GCR_SYNCOUT_0;
 800aa8c:	2210      	movs	r2, #16
 800aa8e:	e745      	b.n	800a91c <HAL_SAI_InitProtocol+0x450>
    SaiBaseAddress = SAI2;
 800aa90:	4d04      	ldr	r5, [pc, #16]	; (800aaa4 <HAL_SAI_InitProtocol+0x5d8>)
 800aa92:	e714      	b.n	800a8be <HAL_SAI_InitProtocol+0x3f2>
 800aa94:	40015800 	.word	0x40015800
 800aa98:	200002bc 	.word	0x200002bc
 800aa9c:	95cbec1b 	.word	0x95cbec1b
 800aaa0:	080293f8 	.word	0x080293f8
 800aaa4:	40015c00 	.word	0x40015c00
      tmpregisterGCR |= SAI_GCR_SYNCIN_1;
 800aaa8:	4602      	mov	r2, r0
      syncen_bits = SAI_xCR1_SYNCEN_1;
 800aaaa:	f44f 6600 	mov.w	r6, #2048	; 0x800
  SaiBaseAddress->GCR = tmpregisterGCR;
 800aaae:	602a      	str	r2, [r5, #0]
  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 800aab0:	6a23      	ldr	r3, [r4, #32]
 800aab2:	2b00      	cmp	r3, #0
 800aab4:	d045      	beq.n	800ab42 <HAL_SAI_InitProtocol+0x676>
    if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 800aab6:	6823      	ldr	r3, [r4, #0]
 800aab8:	4a9f      	ldr	r2, [pc, #636]	; (800ad38 <HAL_SAI_InitProtocol+0x86c>)
 800aaba:	4293      	cmp	r3, r2
 800aabc:	f000 811f 	beq.w	800acfe <HAL_SAI_InitProtocol+0x832>
 800aac0:	489e      	ldr	r0, [pc, #632]	; (800ad3c <HAL_SAI_InitProtocol+0x870>)
 800aac2:	1a18      	subs	r0, r3, r0
 800aac4:	fab0 f080 	clz	r0, r0
 800aac8:	0940      	lsrs	r0, r0, #5
 800aaca:	2800      	cmp	r0, #0
 800aacc:	f040 8117 	bne.w	800acfe <HAL_SAI_InitProtocol+0x832>
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
 800aad0:	4a9b      	ldr	r2, [pc, #620]	; (800ad40 <HAL_SAI_InitProtocol+0x874>)
 800aad2:	4293      	cmp	r3, r2
 800aad4:	f000 810d 	beq.w	800acf2 <HAL_SAI_InitProtocol+0x826>
 800aad8:	3220      	adds	r2, #32
 800aada:	4293      	cmp	r3, r2
 800aadc:	f000 8109 	beq.w	800acf2 <HAL_SAI_InitProtocol+0x826>
    if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
 800aae0:	4a98      	ldr	r2, [pc, #608]	; (800ad44 <HAL_SAI_InitProtocol+0x878>)
 800aae2:	4293      	cmp	r3, r2
 800aae4:	f000 80ff 	beq.w	800ace6 <HAL_SAI_InitProtocol+0x81a>
 800aae8:	3220      	adds	r2, #32
 800aaea:	4293      	cmp	r3, r2
 800aaec:	f000 80fb 	beq.w	800ace6 <HAL_SAI_InitProtocol+0x81a>
    if (hsai->Instance == SAI4_Block_A)
 800aaf0:	4a95      	ldr	r2, [pc, #596]	; (800ad48 <HAL_SAI_InitProtocol+0x87c>)
 800aaf2:	4293      	cmp	r3, r2
 800aaf4:	f000 8114 	beq.w	800ad20 <HAL_SAI_InitProtocol+0x854>
    if (hsai->Instance == SAI4_Block_B)
 800aaf8:	4a94      	ldr	r2, [pc, #592]	; (800ad4c <HAL_SAI_InitProtocol+0x880>)
 800aafa:	4293      	cmp	r3, r2
 800aafc:	f000 810b 	beq.w	800ad16 <HAL_SAI_InitProtocol+0x84a>
    if (hsai->Init.NoDivider == SAI_MASTERDIVIDER_DISABLE)
 800ab00:	69a2      	ldr	r2, [r4, #24]
 800ab02:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800ab06:	6a23      	ldr	r3, [r4, #32]
 800ab08:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
 800ab0c:	ea4f 0040 	mov.w	r0, r0, lsl #1
 800ab10:	f000 80df 	beq.w	800acd2 <HAL_SAI_InitProtocol+0x806>
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
 800ab14:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
 800ab16:	021b      	lsls	r3, r3, #8
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
 800ab18:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 800ab1c:	bf14      	ite	ne
 800ab1e:	2201      	movne	r2, #1
 800ab20:	2202      	moveq	r2, #2
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
 800ab22:	fb02 f303 	mul.w	r3, r2, r3
 800ab26:	fbb0 f3f3 	udiv	r3, r0, r3
    hsai->Init.Mckdiv = tmpval / 10U;
 800ab2a:	4a89      	ldr	r2, [pc, #548]	; (800ad50 <HAL_SAI_InitProtocol+0x884>)
 800ab2c:	fba2 1203 	umull	r1, r2, r2, r3
 800ab30:	08d2      	lsrs	r2, r2, #3
    if ((tmpval % 10U) > 8U)
 800ab32:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800ab36:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
 800ab3a:	2b09      	cmp	r3, #9
      hsai->Init.Mckdiv += 1U;
 800ab3c:	bf08      	it	eq
 800ab3e:	3201      	addeq	r2, #1
 800ab40:	6262      	str	r2, [r4, #36]	; 0x24
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800ab42:	6863      	ldr	r3, [r4, #4]
 800ab44:	6d22      	ldr	r2, [r4, #80]	; 0x50
 800ab46:	f033 0702 	bics.w	r7, r3, #2
 800ab4a:	f040 80ae 	bne.w	800acaa <HAL_SAI_InitProtocol+0x7de>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
 800ab4e:	2a01      	cmp	r2, #1
 800ab50:	bf18      	it	ne
 800ab52:	f44f 7700 	movne.w	r7, #512	; 0x200
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
 800ab56:	f7f5 ff7f 	bl	8000a58 <HAL_GetREVID>
 800ab5a:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 800ab5e:	6822      	ldr	r2, [r4, #0]
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
 800ab60:	f0c0 8092 	bcc.w	800ac88 <HAL_SAI_InitProtocol+0x7bc>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 800ab64:	6811      	ldr	r1, [r2, #0]
 800ab66:	4b7b      	ldr	r3, [pc, #492]	; (800ad54 <HAL_SAI_InitProtocol+0x888>)
 800ab68:	400b      	ands	r3, r1
 800ab6a:	6013      	str	r3, [r2, #0]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800ab6c:	6863      	ldr	r3, [r4, #4]
 800ab6e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 800ab70:	e9d4 1211 	ldrd	r1, r2, [r4, #68]	; 0x44
 800ab74:	430b      	orrs	r3, r1
 800ab76:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800ab78:	4313      	orrs	r3, r2
 800ab7a:	6962      	ldr	r2, [r4, #20]
 800ab7c:	4303      	orrs	r3, r0
 800ab7e:	69a0      	ldr	r0, [r4, #24]
 800ab80:	430b      	orrs	r3, r1
 800ab82:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800ab84:	4313      	orrs	r3, r2
 800ab86:	6922      	ldr	r2, [r4, #16]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800ab88:	4303      	orrs	r3, r0
 800ab8a:	6820      	ldr	r0, [r4, #0]
 800ab8c:	430b      	orrs	r3, r1
 800ab8e:	6801      	ldr	r1, [r0, #0]
 800ab90:	4313      	orrs	r3, r2
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
 800ab92:	6a62      	ldr	r2, [r4, #36]	; 0x24
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800ab94:	430b      	orrs	r3, r1
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
 800ab96:	f24f 0120 	movw	r1, #61472	; 0xf020
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800ab9a:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
 800ab9e:	4333      	orrs	r3, r6
 800aba0:	433b      	orrs	r3, r7
 800aba2:	6003      	str	r3, [r0, #0]
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 800aba4:	6826      	ldr	r6, [r4, #0]
 800aba6:	4b6c      	ldr	r3, [pc, #432]	; (800ad58 <HAL_SAI_InitProtocol+0x88c>)
 800aba8:	6872      	ldr	r2, [r6, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 800abaa:	486c      	ldr	r0, [pc, #432]	; (800ad5c <HAL_SAI_InitProtocol+0x890>)
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 800abac:	4013      	ands	r3, r2
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
 800abae:	4a62      	ldr	r2, [pc, #392]	; (800ad38 <HAL_SAI_InitProtocol+0x86c>)
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 800abb0:	6073      	str	r3, [r6, #4]
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 800abb2:	69e3      	ldr	r3, [r4, #28]
 800abb4:	e9d4 760c 	ldrd	r7, r6, [r4, #48]	; 0x30
 800abb8:	433b      	orrs	r3, r7
 800abba:	6827      	ldr	r7, [r4, #0]
 800abbc:	4333      	orrs	r3, r6
 800abbe:	687e      	ldr	r6, [r7, #4]
 800abc0:	4333      	orrs	r3, r6
 800abc2:	607b      	str	r3, [r7, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 800abc4:	6823      	ldr	r3, [r4, #0]
 800abc6:	689e      	ldr	r6, [r3, #8]
 800abc8:	4030      	ands	r0, r6
 800abca:	6098      	str	r0, [r3, #8]
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 800abcc:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800abce:	6827      	ldr	r7, [r4, #0]
 800abd0:	e9d4 6017 	ldrd	r6, r0, [r4, #92]	; 0x5c
 800abd4:	4333      	orrs	r3, r6
 800abd6:	6d66      	ldr	r6, [r4, #84]	; 0x54
 800abd8:	4303      	orrs	r3, r0
 800abda:	68b8      	ldr	r0, [r7, #8]
 800abdc:	3e01      	subs	r6, #1
 800abde:	4303      	orrs	r3, r0
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
 800abe0:	6da0      	ldr	r0, [r4, #88]	; 0x58
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 800abe2:	4333      	orrs	r3, r6
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
 800abe4:	3801      	subs	r0, #1
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 800abe6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800abea:	60bb      	str	r3, [r7, #8]
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
 800abec:	6820      	ldr	r0, [r4, #0]
 800abee:	68c3      	ldr	r3, [r0, #12]
 800abf0:	400b      	ands	r3, r1
 800abf2:	60c3      	str	r3, [r0, #12]
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800abf4:	6820      	ldr	r0, [r4, #0]
 800abf6:	e9d4 361a 	ldrd	r3, r6, [r4, #104]	; 0x68
 800abfa:	68c1      	ldr	r1, [r0, #12]
 800abfc:	4333      	orrs	r3, r6
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
 800abfe:	6f66      	ldr	r6, [r4, #116]	; 0x74
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800ac00:	430b      	orrs	r3, r1
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
 800ac02:	6f21      	ldr	r1, [r4, #112]	; 0x70
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800ac04:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
 800ac08:	3901      	subs	r1, #1
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800ac0a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800ac0e:	60c3      	str	r3, [r0, #12]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
 800ac10:	6823      	ldr	r3, [r4, #0]
 800ac12:	4293      	cmp	r3, r2
 800ac14:	d025      	beq.n	800ac62 <HAL_SAI_InitProtocol+0x796>
 800ac16:	f102 52c0 	add.w	r2, r2, #402653184	; 0x18000000
 800ac1a:	f5a2 3282 	sub.w	r2, r2, #66560	; 0x10400
 800ac1e:	4293      	cmp	r3, r2
 800ac20:	d01f      	beq.n	800ac62 <HAL_SAI_InitProtocol+0x796>
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800ac22:	2300      	movs	r3, #0
  hsai->State = HAL_SAI_STATE_READY;
 800ac24:	2201      	movs	r2, #1
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800ac26:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
  return HAL_OK;
 800ac2a:	4618      	mov	r0, r3
  __HAL_UNLOCK(hsai);
 800ac2c:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
  hsai->State = HAL_SAI_STATE_READY;
 800ac30:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
}
 800ac34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      syncen_bits = SAI_xCR1_SYNCEN_0;
 800ac36:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800ac3a:	e738      	b.n	800aaae <HAL_SAI_InitProtocol+0x5e2>
      syncen_bits = 0;
 800ac3c:	2600      	movs	r6, #0
 800ac3e:	e736      	b.n	800aaae <HAL_SAI_InitProtocol+0x5e2>
      tmpregisterGCR |= SAI_GCR_SYNCIN_0;
 800ac40:	4632      	mov	r2, r6
      syncen_bits = SAI_xCR1_SYNCEN_1;
 800ac42:	f44f 6600 	mov.w	r6, #2048	; 0x800
 800ac46:	e732      	b.n	800aaae <HAL_SAI_InitProtocol+0x5e2>
    hsai->Lock = HAL_UNLOCKED;
 800ac48:	f884 1090 	strb.w	r1, [r4, #144]	; 0x90
    HAL_SAI_MspInit(hsai);
 800ac4c:	4620      	mov	r0, r4
 800ac4e:	f009 fbb1 	bl	80143b4 <HAL_SAI_MspInit>
 800ac52:	6823      	ldr	r3, [r4, #0]
 800ac54:	e63a      	b.n	800a8cc <HAL_SAI_InitProtocol+0x400>
    assert_param(IS_SAI_BLOCK_MCK_OUTPUT(hsai->Init.MckOutput));
 800ac56:	f240 118f 	movw	r1, #399	; 0x18f
 800ac5a:	4841      	ldr	r0, [pc, #260]	; (800ad60 <HAL_SAI_InitProtocol+0x894>)
 800ac5c:	f008 fe38 	bl	80138d0 <assert_failed>
 800ac60:	e565      	b.n	800a72e <HAL_SAI_InitProtocol+0x262>
    SaiBaseAddress->PDMCR &= ~(SAI_PDMCR_PDMEN);
 800ac62:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800ac64:	f023 0301 	bic.w	r3, r3, #1
 800ac68:	646b      	str	r3, [r5, #68]	; 0x44
    if (hsai->Init.PdmInit.Activation == ENABLE)
 800ac6a:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 800ac6e:	2b01      	cmp	r3, #1
 800ac70:	d1d7      	bne.n	800ac22 <HAL_SAI_InitProtocol+0x756>
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
 800ac72:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
                               ((hsai->Init.PdmInit.MicPairsNbr - 1U) << SAI_PDMCR_MICNBR_Pos));
 800ac76:	3a01      	subs	r2, #1
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
 800ac78:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 800ac7c:	646b      	str	r3, [r5, #68]	; 0x44
      SaiBaseAddress->PDMCR |= SAI_PDMCR_PDMEN;
 800ac7e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800ac80:	f043 0301 	orr.w	r3, r3, #1
 800ac84:	646b      	str	r3, [r5, #68]	; 0x44
 800ac86:	e7cc      	b.n	800ac22 <HAL_SAI_InitProtocol+0x756>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 800ac88:	6811      	ldr	r1, [r2, #0]
 800ac8a:	4b36      	ldr	r3, [pc, #216]	; (800ad64 <HAL_SAI_InitProtocol+0x898>)
 800ac8c:	400b      	ands	r3, r1
 800ac8e:	6013      	str	r3, [r2, #0]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800ac90:	6863      	ldr	r3, [r4, #4]
 800ac92:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 800ac94:	e9d4 2011 	ldrd	r2, r0, [r4, #68]	; 0x44
 800ac98:	4313      	orrs	r3, r2
 800ac9a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800ac9c:	4303      	orrs	r3, r0
 800ac9e:	6960      	ldr	r0, [r4, #20]
 800aca0:	430b      	orrs	r3, r1
 800aca2:	69a1      	ldr	r1, [r4, #24]
 800aca4:	4313      	orrs	r3, r2
 800aca6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800aca8:	e76e      	b.n	800ab88 <HAL_SAI_InitProtocol+0x6bc>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
 800acaa:	2a01      	cmp	r2, #1
 800acac:	bf14      	ite	ne
 800acae:	2700      	movne	r7, #0
 800acb0:	f44f 7700 	moveq.w	r7, #512	; 0x200
 800acb4:	e74f      	b.n	800ab56 <HAL_SAI_InitProtocol+0x68a>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
 800acb6:	f44f 71cc 	mov.w	r1, #408	; 0x198
 800acba:	4829      	ldr	r0, [pc, #164]	; (800ad60 <HAL_SAI_InitProtocol+0x894>)
 800acbc:	f008 fe08 	bl	80138d0 <assert_failed>
 800acc0:	e556      	b.n	800a770 <HAL_SAI_InitProtocol+0x2a4>
    SaiBaseAddress = SAI3;
 800acc2:	4d29      	ldr	r5, [pc, #164]	; (800ad68 <HAL_SAI_InitProtocol+0x89c>)
 800acc4:	e5fb      	b.n	800a8be <HAL_SAI_InitProtocol+0x3f2>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
 800acc6:	f240 1187 	movw	r1, #391	; 0x187
 800acca:	4825      	ldr	r0, [pc, #148]	; (800ad60 <HAL_SAI_InitProtocol+0x894>)
 800accc:	f008 fe00 	bl	80138d0 <assert_failed>
 800acd0:	e512      	b.n	800a6f8 <HAL_SAI_InitProtocol+0x22c>
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * hsai->FrameInit.FrameLength);
 800acd2:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800acd4:	fb02 f303 	mul.w	r3, r2, r3
 800acd8:	fbb0 f3f3 	udiv	r3, r0, r3
 800acdc:	e725      	b.n	800ab2a <HAL_SAI_InitProtocol+0x65e>
      tmpregisterGCR |= (SAI_GCR_SYNCIN_1 | SAI_GCR_SYNCIN_0);
 800acde:	460a      	mov	r2, r1
      syncen_bits = SAI_xCR1_SYNCEN_1;
 800ace0:	f44f 6600 	mov.w	r6, #2048	; 0x800
 800ace4:	e6e3      	b.n	800aaae <HAL_SAI_InitProtocol+0x5e2>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI3);
 800ace6:	f44f 7000 	mov.w	r0, #512	; 0x200
 800acea:	f7ff fa59 	bl	800a1a0 <HAL_RCCEx_GetPeriphCLKFreq>
 800acee:	6823      	ldr	r3, [r4, #0]
 800acf0:	e6fe      	b.n	800aaf0 <HAL_SAI_InitProtocol+0x624>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
 800acf2:	f44f 7000 	mov.w	r0, #512	; 0x200
 800acf6:	f7ff fa53 	bl	800a1a0 <HAL_RCCEx_GetPeriphCLKFreq>
 800acfa:	6823      	ldr	r3, [r4, #0]
 800acfc:	e6f0      	b.n	800aae0 <HAL_SAI_InitProtocol+0x614>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
 800acfe:	f44f 7080 	mov.w	r0, #256	; 0x100
 800ad02:	f7ff fa4d 	bl	800a1a0 <HAL_RCCEx_GetPeriphCLKFreq>
 800ad06:	6823      	ldr	r3, [r4, #0]
 800ad08:	e6e2      	b.n	800aad0 <HAL_SAI_InitProtocol+0x604>
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
 800ad0a:	f240 1181 	movw	r1, #385	; 0x181
 800ad0e:	4814      	ldr	r0, [pc, #80]	; (800ad60 <HAL_SAI_InitProtocol+0x894>)
 800ad10:	f008 fdde 	bl	80138d0 <assert_failed>
 800ad14:	e49c      	b.n	800a650 <HAL_SAI_InitProtocol+0x184>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4B);
 800ad16:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800ad1a:	f7ff fa41 	bl	800a1a0 <HAL_RCCEx_GetPeriphCLKFreq>
 800ad1e:	e6ef      	b.n	800ab00 <HAL_SAI_InitProtocol+0x634>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4A);
 800ad20:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800ad24:	f7ff fa3c 	bl	800a1a0 <HAL_RCCEx_GetPeriphCLKFreq>
 800ad28:	6823      	ldr	r3, [r4, #0]
 800ad2a:	e6e5      	b.n	800aaf8 <HAL_SAI_InitProtocol+0x62c>
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
 800ad2c:	f44f 71c2 	mov.w	r1, #388	; 0x184
 800ad30:	480b      	ldr	r0, [pc, #44]	; (800ad60 <HAL_SAI_InitProtocol+0x894>)
 800ad32:	f008 fdcd 	bl	80138d0 <assert_failed>
 800ad36:	e4c6      	b.n	800a6c6 <HAL_SAI_InitProtocol+0x1fa>
 800ad38:	40015804 	.word	0x40015804
 800ad3c:	40015824 	.word	0x40015824
 800ad40:	40015c04 	.word	0x40015c04
 800ad44:	40016004 	.word	0x40016004
 800ad48:	58005404 	.word	0x58005404
 800ad4c:	58005424 	.word	0x58005424
 800ad50:	cccccccd 	.word	0xcccccccd
 800ad54:	f005c010 	.word	0xf005c010
 800ad58:	ffff1ff0 	.word	0xffff1ff0
 800ad5c:	fff88000 	.word	0xfff88000
 800ad60:	080293f8 	.word	0x080293f8
 800ad64:	f805c010 	.word	0xf805c010
 800ad68:	40016000 	.word	0x40016000

0800ad6c <HAL_SAI_Abort>:
{
 800ad6c:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hsai);
 800ad6e:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
 800ad72:	2b01      	cmp	r3, #1
 800ad74:	d047      	beq.n	800ae06 <HAL_SAI_Abort+0x9a>
 800ad76:	2601      	movs	r6, #1
  if ((hsai->Instance->CR1 & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800ad78:	6803      	ldr	r3, [r0, #0]
 800ad7a:	4604      	mov	r4, r0
  __HAL_LOCK(hsai);
 800ad7c:	f880 6090 	strb.w	r6, [r0, #144]	; 0x90
  if ((hsai->Instance->CR1 & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800ad80:	681d      	ldr	r5, [r3, #0]
 800ad82:	f415 3500 	ands.w	r5, r5, #131072	; 0x20000
 800ad86:	d00d      	beq.n	800ada4 <HAL_SAI_Abort+0x38>
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 800ad88:	681a      	ldr	r2, [r3, #0]
 800ad8a:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800ad8e:	601a      	str	r2, [r3, #0]
    if ((hsai->State == HAL_SAI_STATE_BUSY_TX)&& (hsai->hdmatx != NULL))
 800ad90:	f890 3091 	ldrb.w	r3, [r0, #145]	; 0x91
 800ad94:	2b12      	cmp	r3, #18
 800ad96:	d04f      	beq.n	800ae38 <HAL_SAI_Abort+0xcc>
  HAL_StatusTypeDef status = HAL_OK;
 800ad98:	2500      	movs	r5, #0
    if ((hsai->State == HAL_SAI_STATE_BUSY_RX) && (hsai->hdmarx != NULL))
 800ad9a:	f894 3091 	ldrb.w	r3, [r4, #145]	; 0x91
 800ad9e:	2b22      	cmp	r3, #34	; 0x22
 800ada0:	d034      	beq.n	800ae0c <HAL_SAI_Abort+0xa0>
 800ada2:	6823      	ldr	r3, [r4, #0]
  hsai->Instance->IMR = 0;
 800ada4:	2000      	movs	r0, #0
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800ada6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800adaa:	4a2e      	ldr	r2, [pc, #184]	; (800ae64 <HAL_SAI_Abort+0xf8>)
  hsai->Instance->IMR = 0;
 800adac:	6118      	str	r0, [r3, #16]
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800adae:	6823      	ldr	r3, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800adb0:	6812      	ldr	r2, [r2, #0]
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800adb2:	6199      	str	r1, [r3, #24]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800adb4:	482c      	ldr	r0, [pc, #176]	; (800ae68 <HAL_SAI_Abort+0xfc>)
  __HAL_SAI_DISABLE(hsai);
 800adb6:	6821      	ldr	r1, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800adb8:	fba0 0202 	umull	r0, r2, r0, r2
  __HAL_SAI_DISABLE(hsai);
 800adbc:	680b      	ldr	r3, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800adbe:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
 800adc0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800adc4:	600b      	str	r3, [r1, #0]
    if (count == 0U)
 800adc6:	0093      	lsls	r3, r2, #2
 800adc8:	6821      	ldr	r1, [r4, #0]
 800adca:	b1a2      	cbz	r2, 800adf6 <HAL_SAI_Abort+0x8a>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800adcc:	680a      	ldr	r2, [r1, #0]
    count--;
 800adce:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800add0:	03d0      	lsls	r0, r2, #15
 800add2:	d504      	bpl.n	800adde <HAL_SAI_Abort+0x72>
    if (count == 0U)
 800add4:	b17b      	cbz	r3, 800adf6 <HAL_SAI_Abort+0x8a>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800add6:	680a      	ldr	r2, [r1, #0]
    count--;
 800add8:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800adda:	03d2      	lsls	r2, r2, #15
 800addc:	d4fa      	bmi.n	800add4 <HAL_SAI_Abort+0x68>
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 800adde:	684b      	ldr	r3, [r1, #4]
  hsai->State = HAL_SAI_STATE_READY;
 800ade0:	2001      	movs	r0, #1
  __HAL_UNLOCK(hsai);
 800ade2:	2200      	movs	r2, #0
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 800ade4:	f043 0308 	orr.w	r3, r3, #8
 800ade8:	604b      	str	r3, [r1, #4]
  hsai->State = HAL_SAI_STATE_READY;
 800adea:	f884 0091 	strb.w	r0, [r4, #145]	; 0x91
}
 800adee:	4628      	mov	r0, r5
  __HAL_UNLOCK(hsai);
 800adf0:	f884 2090 	strb.w	r2, [r4, #144]	; 0x90
}
 800adf4:	bd70      	pop	{r4, r5, r6, pc}
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800adf6:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    status = HAL_ERROR;
 800adfa:	2501      	movs	r5, #1
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800adfc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ae00:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 800ae04:	e7eb      	b.n	800adde <HAL_SAI_Abort+0x72>
  __HAL_LOCK(hsai);
 800ae06:	2502      	movs	r5, #2
}
 800ae08:	4628      	mov	r0, r5
 800ae0a:	bd70      	pop	{r4, r5, r6, pc}
    if ((hsai->State == HAL_SAI_STATE_BUSY_RX) && (hsai->hdmarx != NULL))
 800ae0c:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 800ae10:	2800      	cmp	r0, #0
 800ae12:	d0c6      	beq.n	800ada2 <HAL_SAI_Abort+0x36>
      if (HAL_DMA_Abort(hsai->hdmarx) != HAL_OK)
 800ae14:	f7f8 fdce 	bl	80039b4 <HAL_DMA_Abort>
 800ae18:	2800      	cmp	r0, #0
 800ae1a:	d0c2      	beq.n	800ada2 <HAL_SAI_Abort+0x36>
        if (hsai->hdmarx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
 800ae1c:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800ae20:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ae22:	2b80      	cmp	r3, #128	; 0x80
 800ae24:	d0bd      	beq.n	800ada2 <HAL_SAI_Abort+0x36>
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800ae26:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
          status = HAL_ERROR;
 800ae2a:	2501      	movs	r5, #1
 800ae2c:	6823      	ldr	r3, [r4, #0]
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800ae2e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800ae32:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
 800ae36:	e7b5      	b.n	800ada4 <HAL_SAI_Abort+0x38>
    if ((hsai->State == HAL_SAI_STATE_BUSY_TX)&& (hsai->hdmatx != NULL))
 800ae38:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 800ae3c:	2800      	cmp	r0, #0
 800ae3e:	d0ab      	beq.n	800ad98 <HAL_SAI_Abort+0x2c>
      if (HAL_DMA_Abort(hsai->hdmatx) != HAL_OK)
 800ae40:	f7f8 fdb8 	bl	80039b4 <HAL_DMA_Abort>
 800ae44:	2800      	cmp	r0, #0
 800ae46:	d0a7      	beq.n	800ad98 <HAL_SAI_Abort+0x2c>
        if (hsai->hdmatx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
 800ae48:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800ae4c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ae4e:	2b80      	cmp	r3, #128	; 0x80
 800ae50:	d0a2      	beq.n	800ad98 <HAL_SAI_Abort+0x2c>
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800ae52:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
          status = HAL_ERROR;
 800ae56:	4635      	mov	r5, r6
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800ae58:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ae5c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 800ae60:	e79b      	b.n	800ad9a <HAL_SAI_Abort+0x2e>
 800ae62:	bf00      	nop
 800ae64:	200002bc 	.word	0x200002bc
 800ae68:	95cbec1b 	.word	0x95cbec1b

0800ae6c <HAL_SAI_Transmit_DMA>:
{
 800ae6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800ae70:	460f      	mov	r7, r1
 800ae72:	4604      	mov	r4, r0
 800ae74:	4690      	mov	r8, r2
  uint32_t tickstart = HAL_GetTick();
 800ae76:	f7f5 fdd7 	bl	8000a28 <HAL_GetTick>
  if ((pData == NULL) || (Size == 0U))
 800ae7a:	2f00      	cmp	r7, #0
 800ae7c:	d064      	beq.n	800af48 <HAL_SAI_Transmit_DMA+0xdc>
 800ae7e:	fab8 f588 	clz	r5, r8
 800ae82:	096d      	lsrs	r5, r5, #5
 800ae84:	2d00      	cmp	r5, #0
 800ae86:	d15f      	bne.n	800af48 <HAL_SAI_Transmit_DMA+0xdc>
  if (hsai->State == HAL_SAI_STATE_READY)
 800ae88:	f894 6091 	ldrb.w	r6, [r4, #145]	; 0x91
 800ae8c:	b2f6      	uxtb	r6, r6
 800ae8e:	2e01      	cmp	r6, #1
 800ae90:	d156      	bne.n	800af40 <HAL_SAI_Transmit_DMA+0xd4>
    __HAL_LOCK(hsai);
 800ae92:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
 800ae96:	2b01      	cmp	r3, #1
 800ae98:	d052      	beq.n	800af40 <HAL_SAI_Transmit_DMA+0xd4>
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 800ae9a:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    hsai->State = HAL_SAI_STATE_BUSY_TX;
 800ae9e:	2112      	movs	r1, #18
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 800aea0:	4a37      	ldr	r2, [pc, #220]	; (800af80 <HAL_SAI_Transmit_DMA+0x114>)
 800aea2:	4681      	mov	r9, r0
    hsai->pBuffPtr = pData;
 800aea4:	67a7      	str	r7, [r4, #120]	; 0x78
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800aea6:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    hsai->XferSize = Size;
 800aeaa:	f8a4 807c 	strh.w	r8, [r4, #124]	; 0x7c
    hsai->State = HAL_SAI_STATE_BUSY_TX;
 800aeae:	f884 1091 	strb.w	r1, [r4, #145]	; 0x91
    __HAL_LOCK(hsai);
 800aeb2:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
    hsai->XferCount = Size;
 800aeb6:	f8a4 807e 	strh.w	r8, [r4, #126]	; 0x7e
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 800aeba:	4932      	ldr	r1, [pc, #200]	; (800af84 <HAL_SAI_Transmit_DMA+0x118>)
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 800aebc:	641a      	str	r2, [r3, #64]	; 0x40
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 800aebe:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 800aec2:	4a31      	ldr	r2, [pc, #196]	; (800af88 <HAL_SAI_Transmit_DMA+0x11c>)
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 800aec4:	63d9      	str	r1, [r3, #60]	; 0x3c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 800aec6:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800aeca:	64da      	str	r2, [r3, #76]	; 0x4c
    hsai->hdmatx->XferAbortCallback = NULL;
 800aecc:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800aed0:	651d      	str	r5, [r3, #80]	; 0x50
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 800aed2:	6822      	ldr	r2, [r4, #0]
 800aed4:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
 800aed8:	321c      	adds	r2, #28
 800aeda:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 800aedc:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 800aee0:	f7f8 fa8e 	bl	8003400 <HAL_DMA_Start_IT>
 800aee4:	4607      	mov	r7, r0
 800aee6:	2800      	cmp	r0, #0
 800aee8:	d132      	bne.n	800af50 <HAL_SAI_Transmit_DMA+0xe4>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800aeea:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800aeec:	6863      	ldr	r3, [r4, #4]
 800aeee:	2a08      	cmp	r2, #8
 800aef0:	d03c      	beq.n	800af6c <HAL_SAI_Transmit_DMA+0x100>
 800aef2:	2005      	movs	r0, #5
 800aef4:	2261      	movs	r2, #97	; 0x61
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800aef6:	6821      	ldr	r1, [r4, #0]
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800aef8:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_WCKCFG;
 800aefa:	2b01      	cmp	r3, #1
 800aefc:	bf88      	it	hi
 800aefe:	4602      	movhi	r2, r0
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800af00:	690b      	ldr	r3, [r1, #16]
 800af02:	4313      	orrs	r3, r2
 800af04:	610b      	str	r3, [r1, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 800af06:	6822      	ldr	r2, [r4, #0]
 800af08:	6813      	ldr	r3, [r2, #0]
 800af0a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800af0e:	6013      	str	r3, [r2, #0]
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
 800af10:	e006      	b.n	800af20 <HAL_SAI_Transmit_DMA+0xb4>
      if ((HAL_GetTick() - tickstart) > SAI_LONG_TIMEOUT)
 800af12:	f7f5 fd89 	bl	8000a28 <HAL_GetTick>
 800af16:	eba0 0009 	sub.w	r0, r0, r9
 800af1a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800af1e:	d81b      	bhi.n	800af58 <HAL_SAI_Transmit_DMA+0xec>
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
 800af20:	6822      	ldr	r2, [r4, #0]
 800af22:	6955      	ldr	r5, [r2, #20]
 800af24:	f415 25e0 	ands.w	r5, r5, #458752	; 0x70000
 800af28:	d0f3      	beq.n	800af12 <HAL_SAI_Transmit_DMA+0xa6>
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
 800af2a:	6813      	ldr	r3, [r2, #0]
 800af2c:	03db      	lsls	r3, r3, #15
 800af2e:	d403      	bmi.n	800af38 <HAL_SAI_Transmit_DMA+0xcc>
      __HAL_SAI_ENABLE(hsai);
 800af30:	6813      	ldr	r3, [r2, #0]
 800af32:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800af36:	6013      	str	r3, [r2, #0]
    __HAL_UNLOCK(hsai);
 800af38:	2300      	movs	r3, #0
 800af3a:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
    return HAL_OK;
 800af3e:	e000      	b.n	800af42 <HAL_SAI_Transmit_DMA+0xd6>
    return HAL_BUSY;
 800af40:	2702      	movs	r7, #2
}
 800af42:	4638      	mov	r0, r7
 800af44:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return  HAL_ERROR;
 800af48:	2701      	movs	r7, #1
}
 800af4a:	4638      	mov	r0, r7
 800af4c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      __HAL_UNLOCK(hsai);
 800af50:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
      return  HAL_ERROR;
 800af54:	4637      	mov	r7, r6
 800af56:	e7f4      	b.n	800af42 <HAL_SAI_Transmit_DMA+0xd6>
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800af58:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
        return HAL_TIMEOUT;
 800af5c:	2703      	movs	r7, #3
        __HAL_UNLOCK(hsai);
 800af5e:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800af62:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800af66:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
        return HAL_TIMEOUT;
 800af6a:	e7ea      	b.n	800af42 <HAL_SAI_Transmit_DMA+0xd6>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800af6c:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800af70:	2a01      	cmp	r2, #1
 800af72:	bf0b      	itete	eq
 800af74:	2015      	moveq	r0, #21
 800af76:	2005      	movne	r0, #5
 800af78:	2271      	moveq	r2, #113	; 0x71
 800af7a:	2261      	movne	r2, #97	; 0x61
 800af7c:	e7bb      	b.n	800aef6 <HAL_SAI_Transmit_DMA+0x8a>
 800af7e:	bf00      	nop
 800af80:	0800b0d1 	.word	0x0800b0d1
 800af84:	0800b06d 	.word	0x0800b06d
 800af88:	0800b14d 	.word	0x0800b14d

0800af8c <HAL_SAI_Receive_DMA>:
  if ((pData == NULL) || (Size == 0U))
 800af8c:	2900      	cmp	r1, #0
 800af8e:	d057      	beq.n	800b040 <HAL_SAI_Receive_DMA+0xb4>
{
 800af90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((pData == NULL) || (Size == 0U))
 800af92:	fab2 f582 	clz	r5, r2
 800af96:	096d      	lsrs	r5, r5, #5
 800af98:	2d00      	cmp	r5, #0
 800af9a:	d14f      	bne.n	800b03c <HAL_SAI_Receive_DMA+0xb0>
  if (hsai->State == HAL_SAI_STATE_READY)
 800af9c:	f890 6091 	ldrb.w	r6, [r0, #145]	; 0x91
 800afa0:	b2f6      	uxtb	r6, r6
 800afa2:	2e01      	cmp	r6, #1
 800afa4:	d148      	bne.n	800b038 <HAL_SAI_Receive_DMA+0xac>
    __HAL_LOCK(hsai);
 800afa6:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
 800afaa:	2b01      	cmp	r3, #1
 800afac:	d044      	beq.n	800b038 <HAL_SAI_Receive_DMA+0xac>
 800afae:	4604      	mov	r4, r0
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 800afb0:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
    hsai->State = HAL_SAI_STATE_BUSY_RX;
 800afb4:	2722      	movs	r7, #34	; 0x22
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 800afb6:	482a      	ldr	r0, [pc, #168]	; (800b060 <HAL_SAI_Receive_DMA+0xd4>)
    hsai->pBuffPtr = pData;
 800afb8:	67a1      	str	r1, [r4, #120]	; 0x78
    hsai->XferSize = Size;
 800afba:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800afbe:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    hsai->XferCount = Size;
 800afc2:	f8a4 207e 	strh.w	r2, [r4, #126]	; 0x7e
    __HAL_LOCK(hsai);
 800afc6:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
    hsai->State = HAL_SAI_STATE_BUSY_RX;
 800afca:	f884 7091 	strb.w	r7, [r4, #145]	; 0x91
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
 800afce:	4925      	ldr	r1, [pc, #148]	; (800b064 <HAL_SAI_Receive_DMA+0xd8>)
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 800afd0:	6418      	str	r0, [r3, #64]	; 0x40
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
 800afd2:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
 800afd6:	4a24      	ldr	r2, [pc, #144]	; (800b068 <HAL_SAI_Receive_DMA+0xdc>)
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
 800afd8:	63d9      	str	r1, [r3, #60]	; 0x3c
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
 800afda:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800afde:	64da      	str	r2, [r3, #76]	; 0x4c
    hsai->hdmarx->XferAbortCallback = NULL;
 800afe0:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800afe4:	651d      	str	r5, [r3, #80]	; 0x50
    if (HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
 800afe6:	6821      	ldr	r1, [r4, #0]
 800afe8:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
 800afec:	311c      	adds	r1, #28
 800afee:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 800aff0:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 800aff4:	f7f8 fa04 	bl	8003400 <HAL_DMA_Start_IT>
 800aff8:	bb20      	cbnz	r0, 800b044 <HAL_SAI_Receive_DMA+0xb8>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800affa:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800affc:	6863      	ldr	r3, [r4, #4]
 800affe:	2a08      	cmp	r2, #8
 800b000:	d024      	beq.n	800b04c <HAL_SAI_Receive_DMA+0xc0>
 800b002:	2505      	movs	r5, #5
 800b004:	2261      	movs	r2, #97	; 0x61
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800b006:	6821      	ldr	r1, [r4, #0]
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b008:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_WCKCFG;
 800b00a:	2b01      	cmp	r3, #1
 800b00c:	bf88      	it	hi
 800b00e:	462a      	movhi	r2, r5
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800b010:	690b      	ldr	r3, [r1, #16]
 800b012:	4313      	orrs	r3, r2
 800b014:	610b      	str	r3, [r1, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 800b016:	6822      	ldr	r2, [r4, #0]
 800b018:	6813      	ldr	r3, [r2, #0]
 800b01a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800b01e:	6013      	str	r3, [r2, #0]
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
 800b020:	6823      	ldr	r3, [r4, #0]
 800b022:	681a      	ldr	r2, [r3, #0]
 800b024:	03d2      	lsls	r2, r2, #15
 800b026:	d403      	bmi.n	800b030 <HAL_SAI_Receive_DMA+0xa4>
      __HAL_SAI_ENABLE(hsai);
 800b028:	681a      	ldr	r2, [r3, #0]
 800b02a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800b02e:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(hsai);
 800b030:	2300      	movs	r3, #0
 800b032:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
}
 800b036:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 800b038:	2002      	movs	r0, #2
}
 800b03a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
 800b03c:	2001      	movs	r0, #1
}
 800b03e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
 800b040:	2001      	movs	r0, #1
}
 800b042:	4770      	bx	lr
      __HAL_UNLOCK(hsai);
 800b044:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
      return  HAL_ERROR;
 800b048:	4630      	mov	r0, r6
}
 800b04a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800b04c:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800b050:	2a01      	cmp	r2, #1
 800b052:	bf0b      	itete	eq
 800b054:	2515      	moveq	r5, #21
 800b056:	2505      	movne	r5, #5
 800b058:	2271      	moveq	r2, #113	; 0x71
 800b05a:	2261      	movne	r2, #97	; 0x61
 800b05c:	e7d3      	b.n	800b006 <HAL_SAI_Receive_DMA+0x7a>
 800b05e:	bf00      	nop
 800b060:	0800b141 	.word	0x0800b141
 800b064:	0800b0dd 	.word	0x0800b0dd
 800b068:	0800b14d 	.word	0x0800b14d

0800b06c <SAI_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
 800b06c:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
 800b06e:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800b070:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
 800b072:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800b076:	d01a      	beq.n	800b0ae <SAI_DMATxCplt+0x42>
  {
    hsai->XferCount = 0;
 800b078:	2300      	movs	r3, #0

    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800b07a:	6802      	ldr	r2, [r0, #0]
    hsai->XferCount = 0;
 800b07c:	f8a0 307e 	strh.w	r3, [r0, #126]	; 0x7e
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800b080:	6813      	ldr	r3, [r2, #0]
 800b082:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800b086:	6013      	str	r3, [r2, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800b088:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800b08a:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800b08c:	6843      	ldr	r3, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800b08e:	d011      	beq.n	800b0b4 <SAI_DMATxCplt+0x48>
 800b090:	f06f 0261 	mvn.w	r2, #97	; 0x61
 800b094:	f06f 0505 	mvn.w	r5, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b098:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800b09a:	6801      	ldr	r1, [r0, #0]

    hsai->State = HAL_SAI_STATE_READY;
 800b09c:	2401      	movs	r4, #1
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b09e:	42a3      	cmp	r3, r4
 800b0a0:	bf88      	it	hi
 800b0a2:	462a      	movhi	r2, r5
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800b0a4:	690b      	ldr	r3, [r1, #16]
 800b0a6:	4013      	ands	r3, r2
 800b0a8:	610b      	str	r3, [r1, #16]
    hsai->State = HAL_SAI_STATE_READY;
 800b0aa:	f880 4091 	strb.w	r4, [r0, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxCpltCallback(hsai);
#else
  HAL_SAI_TxCpltCallback(hsai);
 800b0ae:	f006 fa99 	bl	80115e4 <HAL_SAI_TxCpltCallback>
#endif
}
 800b0b2:	bd38      	pop	{r3, r4, r5, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800b0b4:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800b0b8:	2a01      	cmp	r2, #1
 800b0ba:	bf0b      	itete	eq
 800b0bc:	f06f 0271 	mvneq.w	r2, #113	; 0x71
 800b0c0:	f06f 0261 	mvnne.w	r2, #97	; 0x61
 800b0c4:	f06f 0515 	mvneq.w	r5, #21
 800b0c8:	f06f 0505 	mvnne.w	r5, #5
 800b0cc:	e7e4      	b.n	800b098 <SAI_DMATxCplt+0x2c>
 800b0ce:	bf00      	nop

0800b0d0 <SAI_DMATxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800b0d0:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxHalfCpltCallback(hsai);
#else
  HAL_SAI_TxHalfCpltCallback(hsai);
 800b0d2:	6b80      	ldr	r0, [r0, #56]	; 0x38
 800b0d4:	f006 fa88 	bl	80115e8 <HAL_SAI_TxHalfCpltCallback>
#endif
}
 800b0d8:	bd08      	pop	{r3, pc}
 800b0da:	bf00      	nop

0800b0dc <SAI_DMARxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)
{
 800b0dc:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
 800b0de:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800b0e0:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
 800b0e2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800b0e6:	d01a      	beq.n	800b11e <SAI_DMARxCplt+0x42>
  {
    /* Disable Rx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800b0e8:	6802      	ldr	r2, [r0, #0]
    hsai->XferCount = 0;
 800b0ea:	2100      	movs	r1, #0
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800b0ec:	6813      	ldr	r3, [r2, #0]
 800b0ee:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800b0f2:	6013      	str	r3, [r2, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800b0f4:	6c43      	ldr	r3, [r0, #68]	; 0x44
    hsai->XferCount = 0;
 800b0f6:	f8a0 107e 	strh.w	r1, [r0, #126]	; 0x7e
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800b0fa:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800b0fc:	6843      	ldr	r3, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800b0fe:	d011      	beq.n	800b124 <SAI_DMARxCplt+0x48>
 800b100:	f06f 0261 	mvn.w	r2, #97	; 0x61
 800b104:	f06f 0505 	mvn.w	r5, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b108:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800b10a:	6801      	ldr	r1, [r0, #0]

    hsai->State = HAL_SAI_STATE_READY;
 800b10c:	2401      	movs	r4, #1
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b10e:	42a3      	cmp	r3, r4
 800b110:	bf88      	it	hi
 800b112:	462a      	movhi	r2, r5
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800b114:	690b      	ldr	r3, [r1, #16]
 800b116:	4013      	ands	r3, r2
 800b118:	610b      	str	r3, [r1, #16]
    hsai->State = HAL_SAI_STATE_READY;
 800b11a:	f880 4091 	strb.w	r4, [r0, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxCpltCallback(hsai);
#else
  HAL_SAI_RxCpltCallback(hsai);
 800b11e:	f006 fa65 	bl	80115ec <HAL_SAI_RxCpltCallback>
#endif
}
 800b122:	bd38      	pop	{r3, r4, r5, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800b124:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800b128:	2a01      	cmp	r2, #1
 800b12a:	bf0b      	itete	eq
 800b12c:	f06f 0271 	mvneq.w	r2, #113	; 0x71
 800b130:	f06f 0261 	mvnne.w	r2, #97	; 0x61
 800b134:	f06f 0515 	mvneq.w	r5, #21
 800b138:	f06f 0505 	mvnne.w	r5, #5
 800b13c:	e7e4      	b.n	800b108 <SAI_DMARxCplt+0x2c>
 800b13e:	bf00      	nop

0800b140 <SAI_DMARxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800b140:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxHalfCpltCallback(hsai);
#else
  HAL_SAI_RxHalfCpltCallback(hsai);
 800b142:	6b80      	ldr	r0, [r0, #56]	; 0x38
 800b144:	f006 fa56 	bl	80115f4 <HAL_SAI_RxHalfCpltCallback>
#endif
}
 800b148:	bd08      	pop	{r3, pc}
 800b14a:	bf00      	nop

0800b14c <SAI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
 800b14c:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800b14e:	6b84      	ldr	r4, [r0, #56]	; 0x38

  /* Ignore DMA FIFO error */
  if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
 800b150:	f7f9 fbac 	bl	80048ac <HAL_DMA_GetError>
 800b154:	2802      	cmp	r0, #2
 800b156:	d02a      	beq.n	800b1ae <SAI_DMAError+0x62>
  {
    /* Set SAI error code */
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800b158:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94

    /* Disable the SAI DMA request */
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 800b15c:	6821      	ldr	r1, [r4, #0]
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800b15e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800b162:	4a17      	ldr	r2, [pc, #92]	; (800b1c0 <SAI_DMAError+0x74>)
 800b164:	4d17      	ldr	r5, [pc, #92]	; (800b1c4 <SAI_DMAError+0x78>)
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800b166:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 800b16a:	680b      	ldr	r3, [r1, #0]
 800b16c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800b170:	600b      	str	r3, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800b172:	6812      	ldr	r2, [r2, #0]
  __HAL_SAI_DISABLE(hsai);
 800b174:	6820      	ldr	r0, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800b176:	fba5 3202 	umull	r3, r2, r5, r2
  __HAL_SAI_DISABLE(hsai);
 800b17a:	6801      	ldr	r1, [r0, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800b17c:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
 800b17e:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    if (count == 0U)
 800b182:	0093      	lsls	r3, r2, #2
  __HAL_SAI_DISABLE(hsai);
 800b184:	6001      	str	r1, [r0, #0]
    if (count == 0U)
 800b186:	b19a      	cbz	r2, 800b1b0 <SAI_DMAError+0x64>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800b188:	6821      	ldr	r1, [r4, #0]
    count--;
 800b18a:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800b18c:	680a      	ldr	r2, [r1, #0]
 800b18e:	03d0      	lsls	r0, r2, #15
 800b190:	d504      	bpl.n	800b19c <SAI_DMAError+0x50>
    if (count == 0U)
 800b192:	b16b      	cbz	r3, 800b1b0 <SAI_DMAError+0x64>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800b194:	680a      	ldr	r2, [r1, #0]
    count--;
 800b196:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800b198:	03d2      	lsls	r2, r2, #15
 800b19a:	d4fa      	bmi.n	800b192 <SAI_DMAError+0x46>
    /* Disable SAI peripheral */
    /* No need to check return value because state will be updated and HAL_SAI_ErrorCallback will be called later */
    (void) SAI_Disable(hsai);

    /* Set the SAI state ready to be able to start again the process */
    hsai->State = HAL_SAI_STATE_READY;
 800b19c:	2201      	movs	r2, #1

    /* Initialize XferCount */
    hsai->XferCount = 0U;
 800b19e:	2300      	movs	r3, #0

    /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
    hsai->ErrorCallback(hsai);
#else
    HAL_SAI_ErrorCallback(hsai);
 800b1a0:	4620      	mov	r0, r4
    hsai->State = HAL_SAI_STATE_READY;
 800b1a2:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
    hsai->XferCount = 0U;
 800b1a6:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    HAL_SAI_ErrorCallback(hsai);
 800b1aa:	f006 fa17 	bl	80115dc <HAL_SAI_ErrorCallback>
#endif
  }
}
 800b1ae:	bd38      	pop	{r3, r4, r5, pc}
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800b1b0:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800b1b4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b1b8:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 800b1bc:	e7ee      	b.n	800b19c <SAI_DMAError+0x50>
 800b1be:	bf00      	nop
 800b1c0:	200002bc 	.word	0x200002bc
 800b1c4:	95cbec1b 	.word	0x95cbec1b

0800b1c8 <HAL_SAI_IRQHandler>:
  if (hsai->State != HAL_SAI_STATE_RESET)
 800b1c8:	f890 2091 	ldrb.w	r2, [r0, #145]	; 0x91
 800b1cc:	2a00      	cmp	r2, #0
 800b1ce:	d030      	beq.n	800b232 <HAL_SAI_IRQHandler+0x6a>
{
 800b1d0:	b570      	push	{r4, r5, r6, lr}
    uint32_t itflags = hsai->Instance->SR;
 800b1d2:	6802      	ldr	r2, [r0, #0]
 800b1d4:	4604      	mov	r4, r0
 800b1d6:	6951      	ldr	r1, [r2, #20]
    uint32_t itsources = hsai->Instance->IMR;
 800b1d8:	6915      	ldr	r5, [r2, #16]
    if (((itflags & SAI_xSR_FREQ) == SAI_xSR_FREQ) && ((itsources & SAI_IT_FREQ) == SAI_IT_FREQ))
 800b1da:	070b      	lsls	r3, r1, #28
    uint32_t cr1config = hsai->Instance->CR1;
 800b1dc:	6816      	ldr	r6, [r2, #0]
    if (((itflags & SAI_xSR_FREQ) == SAI_xSR_FREQ) && ((itsources & SAI_IT_FREQ) == SAI_IT_FREQ))
 800b1de:	d506      	bpl.n	800b1ee <HAL_SAI_IRQHandler+0x26>
 800b1e0:	072b      	lsls	r3, r5, #28
 800b1e2:	d504      	bpl.n	800b1ee <HAL_SAI_IRQHandler+0x26>
      hsai->InterruptServiceRoutine(hsai);
 800b1e4:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
}
 800b1e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      hsai->InterruptServiceRoutine(hsai);
 800b1ec:	4718      	bx	r3
    else if (((itflags & SAI_FLAG_OVRUDR) == SAI_FLAG_OVRUDR) && ((itsources & SAI_IT_OVRUDR) == SAI_IT_OVRUDR))
 800b1ee:	07cb      	lsls	r3, r1, #31
 800b1f0:	d512      	bpl.n	800b218 <HAL_SAI_IRQHandler+0x50>
 800b1f2:	07e8      	lsls	r0, r5, #31
 800b1f4:	d510      	bpl.n	800b218 <HAL_SAI_IRQHandler+0x50>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
 800b1f6:	2301      	movs	r3, #1
      HAL_SAI_ErrorCallback(hsai);
 800b1f8:	4620      	mov	r0, r4
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
 800b1fa:	6193      	str	r3, [r2, #24]
      tmperror = ((hsai->State == HAL_SAI_STATE_BUSY_RX) ? HAL_SAI_ERROR_OVR : HAL_SAI_ERROR_UDR);
 800b1fc:	f894 2091 	ldrb.w	r2, [r4, #145]	; 0x91
      hsai->ErrorCode |= tmperror;
 800b200:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
      tmperror = ((hsai->State == HAL_SAI_STATE_BUSY_RX) ? HAL_SAI_ERROR_OVR : HAL_SAI_ERROR_UDR);
 800b204:	2a22      	cmp	r2, #34	; 0x22
 800b206:	bf0c      	ite	eq
 800b208:	2201      	moveq	r2, #1
 800b20a:	2202      	movne	r2, #2
      hsai->ErrorCode |= tmperror;
 800b20c:	4313      	orrs	r3, r2
 800b20e:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      HAL_SAI_ErrorCallback(hsai);
 800b212:	f006 f9e3 	bl	80115dc <HAL_SAI_ErrorCallback>
}
 800b216:	bd70      	pop	{r4, r5, r6, pc}
    else if (((itflags & SAI_FLAG_MUTEDET) == SAI_FLAG_MUTEDET) && ((itsources & SAI_IT_MUTEDET) == SAI_IT_MUTEDET))
 800b218:	078b      	lsls	r3, r1, #30
 800b21a:	d50b      	bpl.n	800b234 <HAL_SAI_IRQHandler+0x6c>
 800b21c:	07a8      	lsls	r0, r5, #30
 800b21e:	d509      	bpl.n	800b234 <HAL_SAI_IRQHandler+0x6c>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_MUTEDET);
 800b220:	2302      	movs	r3, #2
 800b222:	6193      	str	r3, [r2, #24]
      if (hsai->mutecallback != NULL)
 800b224:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 800b228:	2b00      	cmp	r3, #0
 800b22a:	d0f4      	beq.n	800b216 <HAL_SAI_IRQHandler+0x4e>
}
 800b22c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hsai->mutecallback();
 800b230:	4718      	bx	r3
 800b232:	4770      	bx	lr
    else if (((itflags & SAI_FLAG_AFSDET) == SAI_FLAG_AFSDET) && ((itsources & SAI_IT_AFSDET) == SAI_IT_AFSDET))
 800b234:	068b      	lsls	r3, r1, #26
 800b236:	d512      	bpl.n	800b25e <HAL_SAI_IRQHandler+0x96>
 800b238:	06a8      	lsls	r0, r5, #26
 800b23a:	d510      	bpl.n	800b25e <HAL_SAI_IRQHandler+0x96>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_AFSDET);
 800b23c:	2320      	movs	r3, #32
 800b23e:	6193      	str	r3, [r2, #24]
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800b240:	03b2      	lsls	r2, r6, #14
      hsai->ErrorCode |= HAL_SAI_ERROR_AFSDET;
 800b242:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800b246:	f043 0304 	orr.w	r3, r3, #4
 800b24a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800b24e:	d424      	bmi.n	800b29a <HAL_SAI_IRQHandler+0xd2>
        (void) HAL_SAI_Abort(hsai);
 800b250:	4620      	mov	r0, r4
 800b252:	f7ff fd8b 	bl	800ad6c <HAL_SAI_Abort>
        HAL_SAI_ErrorCallback(hsai);
 800b256:	4620      	mov	r0, r4
 800b258:	f006 f9c0 	bl	80115dc <HAL_SAI_ErrorCallback>
}
 800b25c:	bd70      	pop	{r4, r5, r6, pc}
    else if (((itflags & SAI_FLAG_LFSDET) == SAI_FLAG_LFSDET) && ((itsources & SAI_IT_LFSDET) == SAI_IT_LFSDET))
 800b25e:	064b      	lsls	r3, r1, #25
 800b260:	d50c      	bpl.n	800b27c <HAL_SAI_IRQHandler+0xb4>
 800b262:	0668      	lsls	r0, r5, #25
 800b264:	d50a      	bpl.n	800b27c <HAL_SAI_IRQHandler+0xb4>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_LFSDET);
 800b266:	2340      	movs	r3, #64	; 0x40
 800b268:	6193      	str	r3, [r2, #24]
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800b26a:	03b2      	lsls	r2, r6, #14
      hsai->ErrorCode |= HAL_SAI_ERROR_LFSDET;
 800b26c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800b270:	f043 0308 	orr.w	r3, r3, #8
 800b274:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800b278:	d5ea      	bpl.n	800b250 <HAL_SAI_IRQHandler+0x88>
 800b27a:	e00e      	b.n	800b29a <HAL_SAI_IRQHandler+0xd2>
    else if (((itflags & SAI_FLAG_WCKCFG) == SAI_FLAG_WCKCFG) && ((itsources & SAI_IT_WCKCFG) == SAI_IT_WCKCFG))
 800b27c:	074b      	lsls	r3, r1, #29
 800b27e:	d52c      	bpl.n	800b2da <HAL_SAI_IRQHandler+0x112>
 800b280:	0768      	lsls	r0, r5, #29
 800b282:	d52a      	bpl.n	800b2da <HAL_SAI_IRQHandler+0x112>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_WCKCFG);
 800b284:	2304      	movs	r3, #4
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800b286:	f416 3600 	ands.w	r6, r6, #131072	; 0x20000
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_WCKCFG);
 800b28a:	6193      	str	r3, [r2, #24]
      hsai->ErrorCode |= HAL_SAI_ERROR_WCKCFG;
 800b28c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800b290:	f043 0320 	orr.w	r3, r3, #32
 800b294:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800b298:	d039      	beq.n	800b30e <HAL_SAI_IRQHandler+0x146>
        if (hsai->hdmatx != NULL)
 800b29a:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800b29e:	b133      	cbz	r3, 800b2ae <HAL_SAI_IRQHandler+0xe6>
          hsai->hdmatx->XferAbortCallback = SAI_DMAAbort;
 800b2a0:	4a22      	ldr	r2, [pc, #136]	; (800b32c <HAL_SAI_IRQHandler+0x164>)
 800b2a2:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_DMA_Abort_IT(hsai->hdmatx) != HAL_OK)
 800b2a4:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 800b2a8:	f7f8 fda4 	bl	8003df4 <HAL_DMA_Abort_IT>
 800b2ac:	bb28      	cbnz	r0, 800b2fa <HAL_SAI_IRQHandler+0x132>
        if (hsai->hdmarx != NULL)
 800b2ae:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800b2b2:	2b00      	cmp	r3, #0
 800b2b4:	d0af      	beq.n	800b216 <HAL_SAI_IRQHandler+0x4e>
          hsai->hdmarx->XferAbortCallback = SAI_DMAAbort;
 800b2b6:	4a1d      	ldr	r2, [pc, #116]	; (800b32c <HAL_SAI_IRQHandler+0x164>)
 800b2b8:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_DMA_Abort_IT(hsai->hdmarx) != HAL_OK)
 800b2ba:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 800b2be:	f7f8 fd99 	bl	8003df4 <HAL_DMA_Abort_IT>
 800b2c2:	2800      	cmp	r0, #0
 800b2c4:	d0a7      	beq.n	800b216 <HAL_SAI_IRQHandler+0x4e>
            hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800b2c6:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
            HAL_SAI_ErrorCallback(hsai);
 800b2ca:	4620      	mov	r0, r4
            hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800b2cc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b2d0:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
            HAL_SAI_ErrorCallback(hsai);
 800b2d4:	f006 f982 	bl	80115dc <HAL_SAI_ErrorCallback>
}
 800b2d8:	bd70      	pop	{r4, r5, r6, pc}
    else if (((itflags & SAI_FLAG_CNRDY) == SAI_FLAG_CNRDY) && ((itsources & SAI_IT_CNRDY) == SAI_IT_CNRDY))
 800b2da:	06c9      	lsls	r1, r1, #27
 800b2dc:	d59b      	bpl.n	800b216 <HAL_SAI_IRQHandler+0x4e>
 800b2de:	06eb      	lsls	r3, r5, #27
 800b2e0:	d599      	bpl.n	800b216 <HAL_SAI_IRQHandler+0x4e>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_CNRDY);
 800b2e2:	2310      	movs	r3, #16
      HAL_SAI_ErrorCallback(hsai);
 800b2e4:	4620      	mov	r0, r4
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_CNRDY);
 800b2e6:	6193      	str	r3, [r2, #24]
      hsai->ErrorCode |= HAL_SAI_ERROR_CNREADY;
 800b2e8:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800b2ec:	f043 0310 	orr.w	r3, r3, #16
 800b2f0:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      HAL_SAI_ErrorCallback(hsai);
 800b2f4:	f006 f972 	bl	80115dc <HAL_SAI_ErrorCallback>
}
 800b2f8:	bd70      	pop	{r4, r5, r6, pc}
            hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800b2fa:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
            HAL_SAI_ErrorCallback(hsai);
 800b2fe:	4620      	mov	r0, r4
            hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800b300:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b304:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
            HAL_SAI_ErrorCallback(hsai);
 800b308:	f006 f968 	bl	80115dc <HAL_SAI_ErrorCallback>
 800b30c:	e7cf      	b.n	800b2ae <HAL_SAI_IRQHandler+0xe6>
        hsai->Instance->IMR = 0U;
 800b30e:	6822      	ldr	r2, [r4, #0]
        hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800b310:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
        hsai->State = HAL_SAI_STATE_READY;
 800b314:	2301      	movs	r3, #1
        HAL_SAI_ErrorCallback(hsai);
 800b316:	4620      	mov	r0, r4
        hsai->Instance->IMR = 0U;
 800b318:	6116      	str	r6, [r2, #16]
        hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800b31a:	6822      	ldr	r2, [r4, #0]
 800b31c:	6191      	str	r1, [r2, #24]
        hsai->XferCount = 0U;
 800b31e:	f8a4 607e 	strh.w	r6, [r4, #126]	; 0x7e
        hsai->State = HAL_SAI_STATE_READY;
 800b322:	f884 3091 	strb.w	r3, [r4, #145]	; 0x91
        HAL_SAI_ErrorCallback(hsai);
 800b326:	f006 f959 	bl	80115dc <HAL_SAI_ErrorCallback>
}
 800b32a:	bd70      	pop	{r4, r5, r6, pc}
 800b32c:	0800b331 	.word	0x0800b331

0800b330 <SAI_DMAAbort>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAAbort(DMA_HandleTypeDef *hdma)
{
 800b330:	b510      	push	{r4, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800b332:	6b82      	ldr	r2, [r0, #56]	; 0x38

  /* Disable DMA request */
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;

  /* Disable all interrupts and clear all flags */
  hsai->Instance->IMR = 0U;
 800b334:	2400      	movs	r4, #0
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800b336:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 800b33a:	6811      	ldr	r1, [r2, #0]
 800b33c:	680b      	ldr	r3, [r1, #0]
 800b33e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800b342:	600b      	str	r3, [r1, #0]
  hsai->Instance->IMR = 0U;
 800b344:	6813      	ldr	r3, [r2, #0]
 800b346:	611c      	str	r4, [r3, #16]
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800b348:	6813      	ldr	r3, [r2, #0]
 800b34a:	6198      	str	r0, [r3, #24]

  if (hsai->ErrorCode != HAL_SAI_ERROR_WCKCFG)
 800b34c:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 800b350:	2b20      	cmp	r3, #32
 800b352:	d01a      	beq.n	800b38a <SAI_DMAAbort+0x5a>
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800b354:	4915      	ldr	r1, [pc, #84]	; (800b3ac <SAI_DMAAbort+0x7c>)
 800b356:	4b16      	ldr	r3, [pc, #88]	; (800b3b0 <SAI_DMAAbort+0x80>)
 800b358:	6809      	ldr	r1, [r1, #0]
  __HAL_SAI_DISABLE(hsai);
 800b35a:	6814      	ldr	r4, [r2, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800b35c:	fba3 3101 	umull	r3, r1, r3, r1
  __HAL_SAI_DISABLE(hsai);
 800b360:	6820      	ldr	r0, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800b362:	0b09      	lsrs	r1, r1, #12
  __HAL_SAI_DISABLE(hsai);
 800b364:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
    if (count == 0U)
 800b368:	008b      	lsls	r3, r1, #2
  __HAL_SAI_DISABLE(hsai);
 800b36a:	6020      	str	r0, [r4, #0]
 800b36c:	6810      	ldr	r0, [r2, #0]
    if (count == 0U)
 800b36e:	b1b1      	cbz	r1, 800b39e <SAI_DMAAbort+0x6e>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800b370:	6801      	ldr	r1, [r0, #0]
    count--;
 800b372:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800b374:	03cc      	lsls	r4, r1, #15
 800b376:	d504      	bpl.n	800b382 <SAI_DMAAbort+0x52>
    if (count == 0U)
 800b378:	b18b      	cbz	r3, 800b39e <SAI_DMAAbort+0x6e>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800b37a:	6801      	ldr	r1, [r0, #0]
    count--;
 800b37c:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800b37e:	03c9      	lsls	r1, r1, #15
 800b380:	d4fa      	bmi.n	800b378 <SAI_DMAAbort+0x48>
    /* Disable SAI peripheral */
    /* No need to check return value because state will be updated and HAL_SAI_ErrorCallback will be called later */
    (void) SAI_Disable(hsai);

    /* Flush the fifo */
    SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 800b382:	6843      	ldr	r3, [r0, #4]
 800b384:	f043 0308 	orr.w	r3, r3, #8
 800b388:	6043      	str	r3, [r0, #4]
  }
  /* Set the SAI state to ready to be able to start again the process */
  hsai->State = HAL_SAI_STATE_READY;
 800b38a:	2101      	movs	r1, #1

  /* Initialize XferCount */
  hsai->XferCount = 0U;
 800b38c:	2300      	movs	r3, #0

  /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->ErrorCallback(hsai);
#else
  HAL_SAI_ErrorCallback(hsai);
 800b38e:	4610      	mov	r0, r2
  hsai->State = HAL_SAI_STATE_READY;
 800b390:	f882 1091 	strb.w	r1, [r2, #145]	; 0x91
  hsai->XferCount = 0U;
 800b394:	f8a2 307e 	strh.w	r3, [r2, #126]	; 0x7e
  HAL_SAI_ErrorCallback(hsai);
 800b398:	f006 f920 	bl	80115dc <HAL_SAI_ErrorCallback>
#endif
}
 800b39c:	bd10      	pop	{r4, pc}
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800b39e:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 800b3a2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b3a6:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 800b3aa:	e7ea      	b.n	800b382 <SAI_DMAAbort+0x52>
 800b3ac:	200002bc 	.word	0x200002bc
 800b3b0:	95cbec1b 	.word	0x95cbec1b

0800b3b4 <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 800b3b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b3b8:	4605      	mov	r5, r0
 800b3ba:	b087      	sub	sp, #28
 800b3bc:	460f      	mov	r7, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800b3be:	f7f5 fb33 	bl	8000a28 <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0UL, 0UL};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 800b3c2:	2108      	movs	r1, #8
  uint32_t tickstart = HAL_GetTick();
 800b3c4:	4606      	mov	r6, r0
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 800b3c6:	6828      	ldr	r0, [r5, #0]
 800b3c8:	f002 fd82 	bl	800ded0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800b3cc:	4604      	mov	r4, r0
 800b3ce:	b118      	cbz	r0, 800b3d8 <SD_FindSCR+0x24>
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
 800b3d0:	4620      	mov	r0, r4
 800b3d2:	b007      	add	sp, #28
 800b3d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 800b3d8:	6ca9      	ldr	r1, [r5, #72]	; 0x48
 800b3da:	6828      	ldr	r0, [r5, #0]
 800b3dc:	0409      	lsls	r1, r1, #16
 800b3de:	f002 ffe1 	bl	800e3a4 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 800b3e2:	4604      	mov	r4, r0
 800b3e4:	2800      	cmp	r0, #0
 800b3e6:	d1f3      	bne.n	800b3d0 <SD_FindSCR+0x1c>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800b3e8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 8U;
 800b3ec:	2308      	movs	r3, #8
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
 800b3ee:	2130      	movs	r1, #48	; 0x30
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800b3f0:	9004      	str	r0, [sp, #16]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800b3f2:	9200      	str	r2, [sp, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800b3f4:	2202      	movs	r2, #2
  config.DataLength    = 8U;
 800b3f6:	9301      	str	r3, [sp, #4]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800b3f8:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
 800b3fa:	9102      	str	r1, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800b3fc:	4669      	mov	r1, sp
 800b3fe:	6828      	ldr	r0, [r5, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800b400:	9203      	str	r2, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800b402:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800b404:	f002 fd06 	bl	800de14 <SDMMC_ConfigData>
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 800b408:	6828      	ldr	r0, [r5, #0]
 800b40a:	f003 f887 	bl	800e51c <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800b40e:	4604      	mov	r4, r0
 800b410:	2800      	cmp	r0, #0
 800b412:	d1dd      	bne.n	800b3d0 <SD_FindSCR+0x1c>
  uint32_t index = 0U;
 800b414:	4681      	mov	r9, r0
  uint32_t tempscr[2U] = {0UL, 0UL};
 800b416:	4683      	mov	fp, r0
 800b418:	4682      	mov	sl, r0
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 800b41a:	f240 582a 	movw	r8, #1322	; 0x52a
 800b41e:	e004      	b.n	800b42a <SD_FindSCR+0x76>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800b420:	f7f5 fb02 	bl	8000a28 <HAL_GetTick>
 800b424:	1b80      	subs	r0, r0, r6
 800b426:	3001      	adds	r0, #1
 800b428:	d025      	beq.n	800b476 <SD_FindSCR+0xc2>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 800b42a:	6828      	ldr	r0, [r5, #0]
 800b42c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b42e:	ea13 0f08 	tst.w	r3, r8
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
 800b432:	6b43      	ldr	r3, [r0, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 800b434:	d10e      	bne.n	800b454 <SD_FindSCR+0xa0>
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
 800b436:	031b      	lsls	r3, r3, #12
 800b438:	d4f2      	bmi.n	800b420 <SD_FindSCR+0x6c>
 800b43a:	f1b9 0f00 	cmp.w	r9, #0
 800b43e:	d1ef      	bne.n	800b420 <SD_FindSCR+0x6c>
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
 800b440:	f002 fcc2 	bl	800ddc8 <SDMMC_ReadFIFO>
 800b444:	4682      	mov	sl, r0
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
 800b446:	6828      	ldr	r0, [r5, #0]
      index++;
 800b448:	f04f 0901 	mov.w	r9, #1
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
 800b44c:	f002 fcbc 	bl	800ddc8 <SDMMC_ReadFIFO>
 800b450:	4683      	mov	fp, r0
 800b452:	e7e5      	b.n	800b420 <SD_FindSCR+0x6c>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800b454:	0719      	lsls	r1, r3, #28
 800b456:	d411      	bmi.n	800b47c <SD_FindSCR+0xc8>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800b458:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b45a:	079a      	lsls	r2, r3, #30
 800b45c:	d411      	bmi.n	800b482 <SD_FindSCR+0xce>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800b45e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b460:	069b      	lsls	r3, r3, #26
 800b462:	d411      	bmi.n	800b488 <SD_FindSCR+0xd4>
 800b464:	fa9b f28b 	rev.w	r2, fp
 800b468:	fa9a f38a 	rev.w	r3, sl
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800b46c:	4908      	ldr	r1, [pc, #32]	; (800b490 <SD_FindSCR+0xdc>)
 800b46e:	6381      	str	r1, [r0, #56]	; 0x38
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 800b470:	e9c7 2300 	strd	r2, r3, [r7]
  return HAL_SD_ERROR_NONE;
 800b474:	e7ac      	b.n	800b3d0 <SD_FindSCR+0x1c>
      return HAL_SD_ERROR_TIMEOUT;
 800b476:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 800b47a:	e7a9      	b.n	800b3d0 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 800b47c:	2408      	movs	r4, #8
 800b47e:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_TIMEOUT;
 800b480:	e7a6      	b.n	800b3d0 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800b482:	2402      	movs	r4, #2
 800b484:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 800b486:	e7a3      	b.n	800b3d0 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 800b488:	2420      	movs	r4, #32
 800b48a:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
 800b48c:	e7a0      	b.n	800b3d0 <SD_FindSCR+0x1c>
 800b48e:	bf00      	nop
 800b490:	18000f3a 	.word	0x18000f3a

0800b494 <HAL_SD_ReadBlocks>:
{
 800b494:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800b498:	460d      	mov	r5, r1
 800b49a:	b086      	sub	sp, #24
 800b49c:	4604      	mov	r4, r0
 800b49e:	4690      	mov	r8, r2
 800b4a0:	461e      	mov	r6, r3
  uint32_t tickstart = HAL_GetTick();
 800b4a2:	f7f5 fac1 	bl	8000a28 <HAL_GetTick>
  if(NULL == pData)
 800b4a6:	2d00      	cmp	r5, #0
 800b4a8:	d070      	beq.n	800b58c <HAL_SD_ReadBlocks+0xf8>
 800b4aa:	4607      	mov	r7, r0
  if(hsd->State == HAL_SD_STATE_READY)
 800b4ac:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800b4b0:	b2c0      	uxtb	r0, r0
 800b4b2:	2801      	cmp	r0, #1
 800b4b4:	d007      	beq.n	800b4c6 <HAL_SD_ReadBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800b4b6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800b4b8:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800b4ba:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800b4be:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800b4c0:	b006      	add	sp, #24
 800b4c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800b4c6:	eb08 0306 	add.w	r3, r8, r6
 800b4ca:	6d62      	ldr	r2, [r4, #84]	; 0x54
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800b4cc:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800b4ce:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800b4d0:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800b4d2:	d863      	bhi.n	800b59c <HAL_SD_ReadBlocks+0x108>
    hsd->Instance->DCTRL = 0U;
 800b4d4:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
 800b4d6:	2203      	movs	r2, #3
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800b4d8:	f04f 0902 	mov.w	r9, #2
    hsd->State = HAL_SD_STATE_BUSY;
 800b4dc:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800b4e0:	2290      	movs	r2, #144	; 0x90
    hsd->Instance->DCTRL = 0U;
 800b4e2:	62d9      	str	r1, [r3, #44]	; 0x2c
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800b4e4:	0271      	lsls	r1, r6, #9
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800b4e6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800b4e8:	9101      	str	r1, [sp, #4]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800b4ea:	4669      	mov	r1, sp
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800b4ec:	2b01      	cmp	r3, #1
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800b4ee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800b4f2:	6820      	ldr	r0, [r4, #0]
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800b4f4:	9300      	str	r3, [sp, #0]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800b4f6:	f04f 0300 	mov.w	r3, #0
      add *= 512U;
 800b4fa:	bf18      	it	ne
 800b4fc:	ea4f 2848 	movne.w	r8, r8, lsl #9
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800b500:	9202      	str	r2, [sp, #8]
    config.DPSM          = SDMMC_DPSM_DISABLE;
 800b502:	9305      	str	r3, [sp, #20]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800b504:	e9cd 9303 	strd	r9, r3, [sp, #12]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800b508:	f002 fc84 	bl	800de14 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800b50c:	6822      	ldr	r2, [r4, #0]
    if(NumberOfBlocks > 1U)
 800b50e:	2e01      	cmp	r6, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800b510:	68d3      	ldr	r3, [r2, #12]
 800b512:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b516:	60d3      	str	r3, [r2, #12]
    if(NumberOfBlocks > 1U)
 800b518:	d953      	bls.n	800b5c2 <HAL_SD_ReadBlocks+0x12e>
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
 800b51a:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 800b51e:	4641      	mov	r1, r8
 800b520:	6820      	ldr	r0, [r4, #0]
 800b522:	f002 fd5d 	bl	800dfe0 <SDMMC_CmdReadMultiBlock>
 800b526:	4603      	mov	r3, r0
 800b528:	6820      	ldr	r0, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
 800b52a:	2b00      	cmp	r3, #0
 800b52c:	d13d      	bne.n	800b5aa <HAL_SD_ReadBlocks+0x116>
    dataremaining = config.DataLength;
 800b52e:	f8dd 9004 	ldr.w	r9, [sp, #4]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800b532:	e006      	b.n	800b542 <HAL_SD_ReadBlocks+0xae>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 800b534:	f7f5 fa78 	bl	8000a28 <HAL_GetTick>
 800b538:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b53a:	1bc0      	subs	r0, r0, r7
 800b53c:	4298      	cmp	r0, r3
 800b53e:	d274      	bcs.n	800b62a <HAL_SD_ReadBlocks+0x196>
 800b540:	6820      	ldr	r0, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800b542:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b544:	f413 7f95 	tst.w	r3, #298	; 0x12a
 800b548:	d143      	bne.n	800b5d2 <HAL_SD_ReadBlocks+0x13e>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining >= 32U))
 800b54a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b54c:	0419      	lsls	r1, r3, #16
 800b54e:	d5f1      	bpl.n	800b534 <HAL_SD_ReadBlocks+0xa0>
 800b550:	f1b9 0f1f 	cmp.w	r9, #31
 800b554:	d9ee      	bls.n	800b534 <HAL_SD_ReadBlocks+0xa0>
 800b556:	f105 0a04 	add.w	sl, r5, #4
 800b55a:	f105 0824 	add.w	r8, r5, #36	; 0x24
 800b55e:	e000      	b.n	800b562 <HAL_SD_ReadBlocks+0xce>
 800b560:	6820      	ldr	r0, [r4, #0]
          data = SDMMC_ReadFIFO(hsd->Instance);
 800b562:	f002 fc31 	bl	800ddc8 <SDMMC_ReadFIFO>
          *tempbuff = (uint8_t)(data & 0xFFU);
 800b566:	f80a 0c04 	strb.w	r0, [sl, #-4]
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 800b56a:	0a02      	lsrs	r2, r0, #8
 800b56c:	f10a 0a04 	add.w	sl, sl, #4
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 800b570:	0c03      	lsrs	r3, r0, #16
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 800b572:	0e00      	lsrs	r0, r0, #24
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 800b574:	f80a 2c07 	strb.w	r2, [sl, #-7]
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 800b578:	f80a 3c06 	strb.w	r3, [sl, #-6]
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 800b57c:	f80a 0c05 	strb.w	r0, [sl, #-5]
        for(count = 0U; count < 8U; count++)
 800b580:	45c2      	cmp	sl, r8
 800b582:	d1ed      	bne.n	800b560 <HAL_SD_ReadBlocks+0xcc>
 800b584:	3520      	adds	r5, #32
        dataremaining -= 32U;
 800b586:	f1a9 0920 	sub.w	r9, r9, #32
 800b58a:	e7d3      	b.n	800b534 <HAL_SD_ReadBlocks+0xa0>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800b58c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800b58e:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800b590:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800b594:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800b596:	b006      	add	sp, #24
 800b598:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800b59c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b59e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800b5a2:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800b5a4:	b006      	add	sp, #24
 800b5a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b5aa:	4a39      	ldr	r2, [pc, #228]	; (800b690 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
 800b5ac:	2101      	movs	r1, #1
      hsd->Context = SD_CONTEXT_NONE;
 800b5ae:	2500      	movs	r5, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b5b0:	6382      	str	r2, [r0, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
 800b5b2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          return HAL_ERROR;
 800b5b4:	4608      	mov	r0, r1
          hsd->ErrorCode |= errorstate;
 800b5b6:	4313      	orrs	r3, r2
 800b5b8:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
 800b5ba:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
 800b5be:	6325      	str	r5, [r4, #48]	; 0x30
          return HAL_ERROR;
 800b5c0:	e77e      	b.n	800b4c0 <HAL_SD_ReadBlocks+0x2c>
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
 800b5c2:	2301      	movs	r3, #1
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 800b5c4:	4641      	mov	r1, r8
 800b5c6:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
 800b5c8:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 800b5ca:	f002 fcc5 	bl	800df58 <SDMMC_CmdReadSingleBlock>
 800b5ce:	4603      	mov	r3, r0
 800b5d0:	e7aa      	b.n	800b528 <HAL_SD_ReadBlocks+0x94>
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 800b5d2:	68c3      	ldr	r3, [r0, #12]
 800b5d4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800b5d8:	60c3      	str	r3, [r0, #12]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800b5da:	6823      	ldr	r3, [r4, #0]
 800b5dc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800b5de:	05d2      	lsls	r2, r2, #23
 800b5e0:	d50b      	bpl.n	800b5fa <HAL_SD_ReadBlocks+0x166>
 800b5e2:	2e01      	cmp	r6, #1
 800b5e4:	d909      	bls.n	800b5fa <HAL_SD_ReadBlocks+0x166>
      if(hsd->SdCard.CardType != CARD_SECURED)
 800b5e6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800b5e8:	2a03      	cmp	r2, #3
 800b5ea:	d006      	beq.n	800b5fa <HAL_SD_ReadBlocks+0x166>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800b5ec:	4618      	mov	r0, r3
 800b5ee:	f002 fdc3 	bl	800e178 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 800b5f2:	4603      	mov	r3, r0
 800b5f4:	2800      	cmp	r0, #0
 800b5f6:	d145      	bne.n	800b684 <HAL_SD_ReadBlocks+0x1f0>
 800b5f8:	6823      	ldr	r3, [r4, #0]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800b5fa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800b5fc:	f012 0208 	ands.w	r2, r2, #8
 800b600:	d121      	bne.n	800b646 <HAL_SD_ReadBlocks+0x1b2>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800b602:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800b604:	f011 0102 	ands.w	r1, r1, #2
 800b608:	d12a      	bne.n	800b660 <HAL_SD_ReadBlocks+0x1cc>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800b60a:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800b60c:	f010 0020 	ands.w	r0, r0, #32
 800b610:	d032      	beq.n	800b678 <HAL_SD_ReadBlocks+0x1e4>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b612:	481f      	ldr	r0, [pc, #124]	; (800b690 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
 800b614:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b616:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
 800b618:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 800b61a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b61c:	f043 0320 	orr.w	r3, r3, #32
 800b620:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800b622:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800b626:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800b628:	e74a      	b.n	800b4c0 <HAL_SD_ReadBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b62a:	6823      	ldr	r3, [r4, #0]
        hsd->State= HAL_SD_STATE_READY;
 800b62c:	2101      	movs	r1, #1
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b62e:	4d18      	ldr	r5, [pc, #96]	; (800b690 <HAL_SD_ReadBlocks+0x1fc>)
        hsd->Context = SD_CONTEXT_NONE;
 800b630:	2200      	movs	r2, #0
        return HAL_TIMEOUT;
 800b632:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b634:	639d      	str	r5, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 800b636:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b638:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800b63c:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800b63e:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 800b642:	6322      	str	r2, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
 800b644:	e73c      	b.n	800b4c0 <HAL_SD_ReadBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b646:	4812      	ldr	r0, [pc, #72]	; (800b690 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
 800b648:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 800b64a:	2100      	movs	r1, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b64c:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
 800b64e:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 800b650:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b652:	f043 0308 	orr.w	r3, r3, #8
 800b656:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800b658:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800b65c:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800b65e:	e72f      	b.n	800b4c0 <HAL_SD_ReadBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b660:	480b      	ldr	r0, [pc, #44]	; (800b690 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
 800b662:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b664:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
 800b666:	4608      	mov	r0, r1
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800b668:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b66a:	f043 0302 	orr.w	r3, r3, #2
 800b66e:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800b670:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800b674:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
 800b676:	e723      	b.n	800b4c0 <HAL_SD_ReadBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800b678:	4906      	ldr	r1, [pc, #24]	; (800b694 <HAL_SD_ReadBlocks+0x200>)
    hsd->State = HAL_SD_STATE_READY;
 800b67a:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800b67c:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800b67e:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_OK;
 800b682:	e71d      	b.n	800b4c0 <HAL_SD_ReadBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b684:	6822      	ldr	r2, [r4, #0]
          hsd->State = HAL_SD_STATE_READY;
 800b686:	2101      	movs	r1, #1
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b688:	4801      	ldr	r0, [pc, #4]	; (800b690 <HAL_SD_ReadBlocks+0x1fc>)
          hsd->Context = SD_CONTEXT_NONE;
 800b68a:	2500      	movs	r5, #0
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b68c:	6390      	str	r0, [r2, #56]	; 0x38
 800b68e:	e790      	b.n	800b5b2 <HAL_SD_ReadBlocks+0x11e>
 800b690:	1fe00fff 	.word	0x1fe00fff
 800b694:	18000f3a 	.word	0x18000f3a

0800b698 <HAL_SD_WriteBlocks>:
{
 800b698:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b69c:	460d      	mov	r5, r1
 800b69e:	b089      	sub	sp, #36	; 0x24
 800b6a0:	4604      	mov	r4, r0
 800b6a2:	4616      	mov	r6, r2
 800b6a4:	461f      	mov	r7, r3
  uint32_t tickstart = HAL_GetTick();
 800b6a6:	f7f5 f9bf 	bl	8000a28 <HAL_GetTick>
  if(NULL == pData)
 800b6aa:	2d00      	cmp	r5, #0
 800b6ac:	d05d      	beq.n	800b76a <HAL_SD_WriteBlocks+0xd2>
 800b6ae:	4680      	mov	r8, r0
  if(hsd->State == HAL_SD_STATE_READY)
 800b6b0:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800b6b4:	b2c0      	uxtb	r0, r0
 800b6b6:	2801      	cmp	r0, #1
 800b6b8:	d007      	beq.n	800b6ca <HAL_SD_WriteBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800b6ba:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800b6bc:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800b6be:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800b6c2:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800b6c4:	b009      	add	sp, #36	; 0x24
 800b6c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800b6ca:	19f3      	adds	r3, r6, r7
 800b6cc:	6d62      	ldr	r2, [r4, #84]	; 0x54
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800b6ce:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800b6d0:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800b6d2:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800b6d4:	d851      	bhi.n	800b77a <HAL_SD_WriteBlocks+0xe2>
    hsd->Instance->DCTRL = 0U;
 800b6d6:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
 800b6d8:	2203      	movs	r2, #3
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800b6da:	0278      	lsls	r0, r7, #9
    hsd->State = HAL_SD_STATE_BUSY;
 800b6dc:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800b6e0:	2290      	movs	r2, #144	; 0x90
    hsd->Instance->DCTRL = 0U;
 800b6e2:	62d9      	str	r1, [r3, #44]	; 0x2c
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800b6e4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800b6e8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800b6ea:	9102      	str	r1, [sp, #8]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800b6ec:	a902      	add	r1, sp, #8
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800b6ee:	2b01      	cmp	r3, #1
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 800b6f0:	f04f 0300 	mov.w	r3, #0
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800b6f4:	e9cd 0203 	strd	r0, r2, [sp, #12]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800b6f8:	6820      	ldr	r0, [r4, #0]
      add *= 512U;
 800b6fa:	bf18      	it	ne
 800b6fc:	0276      	lslne	r6, r6, #9
    config.DPSM          = SDMMC_DPSM_DISABLE;
 800b6fe:	9307      	str	r3, [sp, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800b700:	e9cd 3305 	strd	r3, r3, [sp, #20]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800b704:	f002 fb86 	bl	800de14 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800b708:	6822      	ldr	r2, [r4, #0]
    if(NumberOfBlocks > 1U)
 800b70a:	2f01      	cmp	r7, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800b70c:	68d3      	ldr	r3, [r2, #12]
 800b70e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b712:	60d3      	str	r3, [r2, #12]
    if(NumberOfBlocks > 1U)
 800b714:	d944      	bls.n	800b7a0 <HAL_SD_WriteBlocks+0x108>
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
 800b716:	2320      	movs	r3, #32
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 800b718:	4631      	mov	r1, r6
 800b71a:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
 800b71c:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 800b71e:	f002 fce7 	bl	800e0f0 <SDMMC_CmdWriteMultiBlock>
 800b722:	4603      	mov	r3, r0
 800b724:	6820      	ldr	r0, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
 800b726:	bb7b      	cbnz	r3, 800b788 <HAL_SD_WriteBlocks+0xf0>
    dataremaining = config.DataLength;
 800b728:	9e03      	ldr	r6, [sp, #12]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800b72a:	e007      	b.n	800b73c <HAL_SD_WriteBlocks+0xa4>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 800b72c:	f7f5 f97c 	bl	8000a28 <HAL_GetTick>
 800b730:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800b732:	eba0 0008 	sub.w	r0, r0, r8
 800b736:	4298      	cmp	r0, r3
 800b738:	d266      	bcs.n	800b808 <HAL_SD_WriteBlocks+0x170>
 800b73a:	6820      	ldr	r0, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800b73c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b73e:	f413 7f8d 	tst.w	r3, #282	; 0x11a
 800b742:	d135      	bne.n	800b7b0 <HAL_SD_WriteBlocks+0x118>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining >= 32U))
 800b744:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b746:	0459      	lsls	r1, r3, #17
 800b748:	d5f0      	bpl.n	800b72c <HAL_SD_WriteBlocks+0x94>
 800b74a:	2e1f      	cmp	r6, #31
 800b74c:	d9ee      	bls.n	800b72c <HAL_SD_WriteBlocks+0x94>
 800b74e:	f105 0920 	add.w	r9, r5, #32
 800b752:	e000      	b.n	800b756 <HAL_SD_WriteBlocks+0xbe>
 800b754:	6820      	ldr	r0, [r4, #0]
          data |= ((uint32_t)(*tempbuff) << 24U);
 800b756:	f855 3b04 	ldr.w	r3, [r5], #4
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 800b75a:	a901      	add	r1, sp, #4
          data |= ((uint32_t)(*tempbuff) << 24U);
 800b75c:	9301      	str	r3, [sp, #4]
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 800b75e:	f002 fb37 	bl	800ddd0 <SDMMC_WriteFIFO>
        for(count = 0U; count < 8U; count++)
 800b762:	454d      	cmp	r5, r9
 800b764:	d1f6      	bne.n	800b754 <HAL_SD_WriteBlocks+0xbc>
        dataremaining -= 32U;
 800b766:	3e20      	subs	r6, #32
 800b768:	e7e0      	b.n	800b72c <HAL_SD_WriteBlocks+0x94>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800b76a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800b76c:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800b76e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800b772:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800b774:	b009      	add	sp, #36	; 0x24
 800b776:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800b77a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b77c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800b780:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800b782:	b009      	add	sp, #36	; 0x24
 800b784:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b788:	4a38      	ldr	r2, [pc, #224]	; (800b86c <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
 800b78a:	2101      	movs	r1, #1
      hsd->Context = SD_CONTEXT_NONE;
 800b78c:	2500      	movs	r5, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b78e:	6382      	str	r2, [r0, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
 800b790:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          return HAL_ERROR;
 800b792:	4608      	mov	r0, r1
          hsd->ErrorCode |= errorstate;
 800b794:	4313      	orrs	r3, r2
 800b796:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
 800b798:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
 800b79c:	6325      	str	r5, [r4, #48]	; 0x30
          return HAL_ERROR;
 800b79e:	e791      	b.n	800b6c4 <HAL_SD_WriteBlocks+0x2c>
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
 800b7a0:	2310      	movs	r3, #16
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 800b7a2:	4631      	mov	r1, r6
 800b7a4:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
 800b7a6:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 800b7a8:	f002 fc5e 	bl	800e068 <SDMMC_CmdWriteSingleBlock>
 800b7ac:	4603      	mov	r3, r0
 800b7ae:	e7b9      	b.n	800b724 <HAL_SD_WriteBlocks+0x8c>
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 800b7b0:	68c3      	ldr	r3, [r0, #12]
 800b7b2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800b7b6:	60c3      	str	r3, [r0, #12]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800b7b8:	6823      	ldr	r3, [r4, #0]
 800b7ba:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800b7bc:	05d2      	lsls	r2, r2, #23
 800b7be:	d50b      	bpl.n	800b7d8 <HAL_SD_WriteBlocks+0x140>
 800b7c0:	2f01      	cmp	r7, #1
 800b7c2:	d909      	bls.n	800b7d8 <HAL_SD_WriteBlocks+0x140>
      if(hsd->SdCard.CardType != CARD_SECURED)
 800b7c4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800b7c6:	2a03      	cmp	r2, #3
 800b7c8:	d006      	beq.n	800b7d8 <HAL_SD_WriteBlocks+0x140>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800b7ca:	4618      	mov	r0, r3
 800b7cc:	f002 fcd4 	bl	800e178 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 800b7d0:	4603      	mov	r3, r0
 800b7d2:	2800      	cmp	r0, #0
 800b7d4:	d143      	bne.n	800b85e <HAL_SD_WriteBlocks+0x1c6>
 800b7d6:	6823      	ldr	r3, [r4, #0]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800b7d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800b7da:	f012 0208 	ands.w	r2, r2, #8
 800b7de:	d11f      	bne.n	800b820 <HAL_SD_WriteBlocks+0x188>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800b7e0:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800b7e2:	f011 0102 	ands.w	r1, r1, #2
 800b7e6:	d128      	bne.n	800b83a <HAL_SD_WriteBlocks+0x1a2>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
 800b7e8:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800b7ea:	f010 0010 	ands.w	r0, r0, #16
 800b7ee:	d030      	beq.n	800b852 <HAL_SD_WriteBlocks+0x1ba>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b7f0:	481e      	ldr	r0, [pc, #120]	; (800b86c <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
 800b7f2:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b7f4:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
 800b7f6:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 800b7f8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b7fa:	f043 0310 	orr.w	r3, r3, #16
 800b7fe:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800b800:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800b804:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800b806:	e75d      	b.n	800b6c4 <HAL_SD_WriteBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b808:	6821      	ldr	r1, [r4, #0]
        hsd->State = HAL_SD_STATE_READY;
 800b80a:	2201      	movs	r2, #1
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b80c:	4d17      	ldr	r5, [pc, #92]	; (800b86c <HAL_SD_WriteBlocks+0x1d4>)
        hsd->Context = SD_CONTEXT_NONE;
 800b80e:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
 800b810:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b812:	638d      	str	r5, [r1, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
 800b814:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800b816:	63a1      	str	r1, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 800b818:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 800b81c:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
 800b81e:	e751      	b.n	800b6c4 <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b820:	4812      	ldr	r0, [pc, #72]	; (800b86c <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
 800b822:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 800b824:	2100      	movs	r1, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b826:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
 800b828:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 800b82a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b82c:	f043 0308 	orr.w	r3, r3, #8
 800b830:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800b832:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800b836:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800b838:	e744      	b.n	800b6c4 <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b83a:	480c      	ldr	r0, [pc, #48]	; (800b86c <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
 800b83c:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b83e:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
 800b840:	4608      	mov	r0, r1
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800b842:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b844:	f043 0302 	orr.w	r3, r3, #2
 800b848:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800b84a:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800b84e:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
 800b850:	e738      	b.n	800b6c4 <HAL_SD_WriteBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800b852:	4907      	ldr	r1, [pc, #28]	; (800b870 <HAL_SD_WriteBlocks+0x1d8>)
    hsd->State = HAL_SD_STATE_READY;
 800b854:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800b856:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800b858:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_OK;
 800b85c:	e732      	b.n	800b6c4 <HAL_SD_WriteBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b85e:	6822      	ldr	r2, [r4, #0]
          hsd->State = HAL_SD_STATE_READY;
 800b860:	2101      	movs	r1, #1
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b862:	4802      	ldr	r0, [pc, #8]	; (800b86c <HAL_SD_WriteBlocks+0x1d4>)
          hsd->Context = SD_CONTEXT_NONE;
 800b864:	2500      	movs	r5, #0
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b866:	6390      	str	r0, [r2, #56]	; 0x38
 800b868:	e792      	b.n	800b790 <HAL_SD_WriteBlocks+0xf8>
 800b86a:	bf00      	nop
 800b86c:	1fe00fff 	.word	0x1fe00fff
 800b870:	18000f3a 	.word	0x18000f3a

0800b874 <HAL_SD_DriveTransceiver_1_8V_Callback>:
}
 800b874:	4770      	bx	lr
 800b876:	bf00      	nop

0800b878 <HAL_SD_GetCardCSD>:
{
 800b878:	4603      	mov	r3, r0
  pCSD->Reserved2 = 0U; /*!< Reserved */
 800b87a:	2000      	movs	r0, #0
{
 800b87c:	b430      	push	{r4, r5}
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 800b87e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800b880:	0f92      	lsrs	r2, r2, #30
 800b882:	700a      	strb	r2, [r1, #0]
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 800b884:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800b886:	f3c2 6283 	ubfx	r2, r2, #26, #4
 800b88a:	704a      	strb	r2, [r1, #1]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 800b88c:	f893 2063 	ldrb.w	r2, [r3, #99]	; 0x63
 800b890:	f002 0203 	and.w	r2, r2, #3
 800b894:	708a      	strb	r2, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 800b896:	f893 2062 	ldrb.w	r2, [r3, #98]	; 0x62
 800b89a:	70ca      	strb	r2, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 800b89c:	f893 2061 	ldrb.w	r2, [r3, #97]	; 0x61
 800b8a0:	710a      	strb	r2, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 800b8a2:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
 800b8a6:	714a      	strb	r2, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 800b8a8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800b8aa:	0d12      	lsrs	r2, r2, #20
 800b8ac:	80ca      	strh	r2, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 800b8ae:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
 800b8b2:	f002 020f 	and.w	r2, r2, #15
 800b8b6:	720a      	strb	r2, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 800b8b8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800b8ba:	f3c2 32c0 	ubfx	r2, r2, #15, #1
 800b8be:	724a      	strb	r2, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 800b8c0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800b8c2:	f3c2 3280 	ubfx	r2, r2, #14, #1
 800b8c6:	728a      	strb	r2, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 800b8c8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800b8ca:	f3c2 3240 	ubfx	r2, r2, #13, #1
 800b8ce:	72ca      	strb	r2, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 800b8d0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800b8d2:	f3c2 3200 	ubfx	r2, r2, #12, #1
 800b8d6:	730a      	strb	r2, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
 800b8d8:	7348      	strb	r0, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
 800b8da:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800b8dc:	2a00      	cmp	r2, #0
 800b8de:	f040 8086 	bne.w	800b9ee <HAL_SD_GetCardCSD+0x176>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 800b8e2:	6e5d      	ldr	r5, [r3, #100]	; 0x64
 800b8e4:	f640 72fc 	movw	r2, #4092	; 0xffc
 800b8e8:	6e98      	ldr	r0, [r3, #104]	; 0x68
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 800b8ea:	2401      	movs	r4, #1
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 800b8ec:	ea02 0285 	and.w	r2, r2, r5, lsl #2
    hsd->SdCard.LogBlockSize = 512U;
 800b8f0:	f44f 7500 	mov.w	r5, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 800b8f4:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
 800b8f8:	610a      	str	r2, [r1, #16]
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 800b8fa:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800b8fc:	f3c2 62c2 	ubfx	r2, r2, #27, #3
 800b900:	750a      	strb	r2, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 800b902:	f893 206b 	ldrb.w	r2, [r3, #107]	; 0x6b
 800b906:	f002 0207 	and.w	r2, r2, #7
 800b90a:	754a      	strb	r2, [r1, #21]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 800b90c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800b90e:	f3c2 5242 	ubfx	r2, r2, #21, #3
 800b912:	758a      	strb	r2, [r1, #22]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 800b914:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800b916:	f3c2 4282 	ubfx	r2, r2, #18, #3
 800b91a:	75ca      	strb	r2, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 800b91c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800b91e:	f3c2 32c2 	ubfx	r2, r2, #15, #3
 800b922:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 800b924:	690a      	ldr	r2, [r1, #16]
 800b926:	4422      	add	r2, r4
 800b928:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 800b92a:	7e08      	ldrb	r0, [r1, #24]
 800b92c:	f000 0007 	and.w	r0, r0, #7
 800b930:	3002      	adds	r0, #2
 800b932:	4082      	lsls	r2, r0
 800b934:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 800b936:	7a08      	ldrb	r0, [r1, #8]
    hsd->SdCard.LogBlockSize = 512U;
 800b938:	659d      	str	r5, [r3, #88]	; 0x58
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 800b93a:	f000 000f 	and.w	r0, r0, #15
 800b93e:	fa04 f000 	lsl.w	r0, r4, r0
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 800b942:	0a44      	lsrs	r4, r0, #9
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 800b944:	6518      	str	r0, [r3, #80]	; 0x50
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 800b946:	fb02 f204 	mul.w	r2, r2, r4
 800b94a:	655a      	str	r2, [r3, #84]	; 0x54
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 800b94c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  pCSD->Reserved3 = 0;
 800b94e:	2500      	movs	r5, #0
  pCSD->Reserved4 = 1;
 800b950:	2401      	movs	r4, #1
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 800b952:	f3c2 3280 	ubfx	r2, r2, #14, #1
  return HAL_OK;
 800b956:	4628      	mov	r0, r5
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 800b958:	764a      	strb	r2, [r1, #25]
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 800b95a:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800b95c:	f3c2 12c6 	ubfx	r2, r2, #7, #7
 800b960:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 800b962:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800b964:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800b968:	76ca      	strb	r2, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 800b96a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b96c:	0fd2      	lsrs	r2, r2, #31
 800b96e:	770a      	strb	r2, [r1, #28]
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 800b970:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b972:	f3c2 7241 	ubfx	r2, r2, #29, #2
 800b976:	774a      	strb	r2, [r1, #29]
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 800b978:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b97a:	f3c2 6282 	ubfx	r2, r2, #26, #3
 800b97e:	778a      	strb	r2, [r1, #30]
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 800b980:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b982:	f3c2 5283 	ubfx	r2, r2, #22, #4
 800b986:	77ca      	strb	r2, [r1, #31]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 800b988:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b98a:	f3c2 5240 	ubfx	r2, r2, #21, #1
 800b98e:	f881 2020 	strb.w	r2, [r1, #32]
  pCSD->Reserved3 = 0;
 800b992:	f881 5021 	strb.w	r5, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 800b996:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
 800b99a:	4022      	ands	r2, r4
 800b99c:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 800b9a0:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b9a2:	f3c2 32c0 	ubfx	r2, r2, #15, #1
 800b9a6:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 800b9aa:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b9ac:	f3c2 3280 	ubfx	r2, r2, #14, #1
 800b9b0:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 800b9b4:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b9b6:	f3c2 3240 	ubfx	r2, r2, #13, #1
 800b9ba:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 800b9be:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b9c0:	f3c2 3200 	ubfx	r2, r2, #12, #1
 800b9c4:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 800b9c8:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b9ca:	f3c2 2281 	ubfx	r2, r2, #10, #2
 800b9ce:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 800b9d2:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800b9d4:	f3c2 2201 	ubfx	r2, r2, #8, #2
 800b9d8:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 800b9dc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800b9de:	f3c3 0346 	ubfx	r3, r3, #1, #7
 800b9e2:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
 800b9e6:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
}
 800b9ea:	bc30      	pop	{r4, r5}
 800b9ec:	4770      	bx	lr
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 800b9ee:	2a01      	cmp	r2, #1
 800b9f0:	d00c      	beq.n	800ba0c <HAL_SD_GetCardCSD+0x194>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b9f2:	681a      	ldr	r2, [r3, #0]
    hsd->State = HAL_SD_STATE_READY;
 800b9f4:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b9f6:	4c0e      	ldr	r4, [pc, #56]	; (800ba30 <HAL_SD_GetCardCSD+0x1b8>)
    return HAL_ERROR;
 800b9f8:	4608      	mov	r0, r1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800b9fa:	6394      	str	r4, [r2, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800b9fc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b9fe:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800ba02:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800ba04:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
}
 800ba08:	bc30      	pop	{r4, r5}
 800ba0a:	4770      	bx	lr
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 800ba0c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    hsd->SdCard.BlockSize = 512U;
 800ba0e:	f44f 7000 	mov.w	r0, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 800ba12:	f8b3 406a 	ldrh.w	r4, [r3, #106]	; 0x6a
 800ba16:	0412      	lsls	r2, r2, #16
 800ba18:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
 800ba1c:	4322      	orrs	r2, r4
 800ba1e:	610a      	str	r2, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 800ba20:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockSize = 512U;
 800ba22:	6518      	str	r0, [r3, #80]	; 0x50
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 800ba24:	3201      	adds	r2, #1
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 800ba26:	6598      	str	r0, [r3, #88]	; 0x58
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 800ba28:	0292      	lsls	r2, r2, #10
 800ba2a:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
 800ba2c:	655a      	str	r2, [r3, #84]	; 0x54
 800ba2e:	e78d      	b.n	800b94c <HAL_SD_GetCardCSD+0xd4>
 800ba30:	1fe00fff 	.word	0x1fe00fff

0800ba34 <HAL_SD_InitCard>:
{
 800ba34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800ba38:	6982      	ldr	r2, [r0, #24]
{
 800ba3a:	b098      	sub	sp, #96	; 0x60
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 800ba3c:	2300      	movs	r3, #0
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
 800ba3e:	21fa      	movs	r1, #250	; 0xfa
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800ba40:	2a02      	cmp	r2, #2
{
 800ba42:	4604      	mov	r4, r0
 800ba44:	6805      	ldr	r5, [r0, #0]
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
 800ba46:	910b      	str	r1, [sp, #44]	; 0x2c
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 800ba48:	e9cd 3307 	strd	r3, r3, [sp, #28]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 800ba4c:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800ba50:	d104      	bne.n	800ba5c <HAL_SD_InitCard+0x28>
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
 800ba52:	682b      	ldr	r3, [r5, #0]
 800ba54:	f043 0310 	orr.w	r3, r3, #16
 800ba58:	602b      	str	r3, [r5, #0]
 800ba5a:	6805      	ldr	r5, [r0, #0]
  (void)SDMMC_Init(hsd->Instance, Init);
 800ba5c:	aa0a      	add	r2, sp, #40	; 0x28
 800ba5e:	ab07      	add	r3, sp, #28
 800ba60:	ca07      	ldmia	r2, {r0, r1, r2}
 800ba62:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800ba66:	4628      	mov	r0, r5
 800ba68:	cb0e      	ldmia	r3, {r1, r2, r3}
 800ba6a:	f002 f94d 	bl	800dd08 <SDMMC_Init>
  (void)SDMMC_PowerState_ON(hsd->Instance);
 800ba6e:	6820      	ldr	r0, [r4, #0]
 800ba70:	f002 f9b4 	bl	800dddc <SDMMC_PowerState_ON>
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC)/(2U*SDMMC_INIT_CLK_DIV);
 800ba74:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800ba78:	f7fe fb92 	bl	800a1a0 <HAL_RCCEx_GetPeriphCLKFreq>
 800ba7c:	4ba3      	ldr	r3, [pc, #652]	; (800bd0c <HAL_SD_InitCard+0x2d8>)
 800ba7e:	fba3 3000 	umull	r3, r0, r3, r0
  if(sdmmc_clk != 0U)
 800ba82:	0940      	lsrs	r0, r0, #5
 800ba84:	d019      	beq.n	800baba <HAL_SD_InitCard+0x86>
    HAL_Delay(1U+ (74U*1000U/(sdmmc_clk)));
 800ba86:	4ba2      	ldr	r3, [pc, #648]	; (800bd10 <HAL_SD_InitCard+0x2dc>)
 800ba88:	fbb3 f0f0 	udiv	r0, r3, r0
 800ba8c:	3001      	adds	r0, #1
 800ba8e:	f7f4 ffd1 	bl	8000a34 <HAL_Delay>
  __IO uint32_t count = 0U;
 800ba92:	2300      	movs	r3, #0
 800ba94:	9306      	str	r3, [sp, #24]
  uint32_t tickstart = HAL_GetTick();
 800ba96:	f7f4 ffc7 	bl	8000a28 <HAL_GetTick>
 800ba9a:	4680      	mov	r8, r0
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800ba9c:	6820      	ldr	r0, [r4, #0]
 800ba9e:	f002 fc13 	bl	800e2c8 <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 800baa2:	4605      	mov	r5, r0
 800baa4:	b168      	cbz	r0, 800bac2 <HAL_SD_InitCard+0x8e>
    hsd->State = HAL_SD_STATE_READY;
 800baa6:	2601      	movs	r6, #1
 800baa8:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800baac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800baae:	431d      	orrs	r5, r3
 800bab0:	63a5      	str	r5, [r4, #56]	; 0x38
}
 800bab2:	4630      	mov	r0, r6
 800bab4:	b018      	add	sp, #96	; 0x60
 800bab6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    HAL_Delay(2U);
 800baba:	2002      	movs	r0, #2
 800babc:	f7f4 ffba 	bl	8000a34 <HAL_Delay>
 800bac0:	e7e7      	b.n	800ba92 <HAL_SD_InitCard+0x5e>
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 800bac2:	6820      	ldr	r0, [r4, #0]
 800bac4:	f002 fc2e 	bl	800e324 <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bac8:	2800      	cmp	r0, #0
 800baca:	d179      	bne.n	800bbc0 <HAL_SD_InitCard+0x18c>
    hsd->SdCard.CardVersion = CARD_V2_X;
 800bacc:	2301      	movs	r3, #1
 800bace:	6423      	str	r3, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 800bad0:	2100      	movs	r1, #0
 800bad2:	6820      	ldr	r0, [r4, #0]
 800bad4:	f002 fc66 	bl	800e3a4 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800bad8:	bb08      	cbnz	r0, 800bb1e <HAL_SD_InitCard+0xea>
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800bada:	9b06      	ldr	r3, [sp, #24]
 800badc:	f64f 76fe 	movw	r6, #65534	; 0xfffe
 800bae0:	42b3      	cmp	r3, r6
 800bae2:	f200 8109 	bhi.w	800bcf8 <HAL_SD_InitCard+0x2c4>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 800bae6:	4f8b      	ldr	r7, [pc, #556]	; (800bd14 <HAL_SD_InitCard+0x2e0>)
 800bae8:	e00c      	b.n	800bb04 <HAL_SD_InitCard+0xd0>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800baea:	4601      	mov	r1, r0
 800baec:	6820      	ldr	r0, [r4, #0]
 800baee:	f002 f981 	bl	800ddf4 <SDMMC_GetResponse>
    count++;
 800baf2:	9b06      	ldr	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800baf4:	1e02      	subs	r2, r0, #0
    count++;
 800baf6:	f103 0301 	add.w	r3, r3, #1
 800bafa:	9306      	str	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800bafc:	9b06      	ldr	r3, [sp, #24]
 800bafe:	db11      	blt.n	800bb24 <HAL_SD_InitCard+0xf0>
 800bb00:	42b3      	cmp	r3, r6
 800bb02:	d80f      	bhi.n	800bb24 <HAL_SD_InitCard+0xf0>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 800bb04:	2100      	movs	r1, #0
 800bb06:	6820      	ldr	r0, [r4, #0]
 800bb08:	f002 fc4c 	bl	800e3a4 <SDMMC_CmdAppCommand>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 800bb0c:	4639      	mov	r1, r7
    if(errorstate != HAL_SD_ERROR_NONE)
 800bb0e:	4605      	mov	r5, r0
 800bb10:	2800      	cmp	r0, #0
 800bb12:	d1c8      	bne.n	800baa6 <HAL_SD_InitCard+0x72>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 800bb14:	6820      	ldr	r0, [r4, #0]
 800bb16:	f002 fc89 	bl	800e42c <SDMMC_CmdAppOperCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800bb1a:	2800      	cmp	r0, #0
 800bb1c:	d0e5      	beq.n	800baea <HAL_SD_InitCard+0xb6>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800bb1e:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800bb22:	e7c0      	b.n	800baa6 <HAL_SD_InitCard+0x72>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
 800bb24:	9906      	ldr	r1, [sp, #24]
 800bb26:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 800bb2a:	4299      	cmp	r1, r3
 800bb2c:	f200 809d 	bhi.w	800bc6a <HAL_SD_InitCard+0x236>
  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 800bb30:	0057      	lsls	r7, r2, #1
 800bb32:	6820      	ldr	r0, [r4, #0]
 800bb34:	d504      	bpl.n	800bb40 <HAL_SD_InitCard+0x10c>
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800bb36:	69a3      	ldr	r3, [r4, #24]
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 800bb38:	2101      	movs	r1, #1
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800bb3a:	2b02      	cmp	r3, #2
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 800bb3c:	63e1      	str	r1, [r4, #60]	; 0x3c
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800bb3e:	d051      	beq.n	800bbe4 <HAL_SD_InitCard+0x1b0>
  uint16_t sd_rca = 1U;
 800bb40:	2301      	movs	r3, #1
 800bb42:	f8ad 3016 	strh.w	r3, [sp, #22]
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 800bb46:	f002 f951 	bl	800ddec <SDMMC_GetPowerState>
 800bb4a:	2800      	cmp	r0, #0
 800bb4c:	d044      	beq.n	800bbd8 <HAL_SD_InitCard+0x1a4>
  if(hsd->SdCard.CardType != CARD_SECURED)
 800bb4e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800bb50:	6823      	ldr	r3, [r4, #0]
 800bb52:	2a03      	cmp	r2, #3
 800bb54:	d125      	bne.n	800bba2 <HAL_SD_InitCard+0x16e>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800bb56:	4618      	mov	r0, r3
 800bb58:	2104      	movs	r1, #4
 800bb5a:	f002 f94b 	bl	800ddf4 <SDMMC_GetResponse>
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 800bb5e:	a90d      	add	r1, sp, #52	; 0x34
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800bb60:	0d03      	lsrs	r3, r0, #20
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 800bb62:	4620      	mov	r0, r4
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800bb64:	6463      	str	r3, [r4, #68]	; 0x44
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 800bb66:	f7ff fe87 	bl	800b878 <HAL_SD_GetCardCSD>
 800bb6a:	4606      	mov	r6, r0
 800bb6c:	2800      	cmp	r0, #0
 800bb6e:	d136      	bne.n	800bbde <HAL_SD_InitCard+0x1aa>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 800bb70:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800bb72:	4603      	mov	r3, r0
 800bb74:	6820      	ldr	r0, [r4, #0]
 800bb76:	0412      	lsls	r2, r2, #16
 800bb78:	f002 fb62 	bl	800e240 <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bb7c:	b9b0      	cbnz	r0, 800bbac <HAL_SD_InitCard+0x178>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800bb7e:	f44f 7100 	mov.w	r1, #512	; 0x200
 800bb82:	6820      	ldr	r0, [r4, #0]
 800bb84:	f002 f9a4 	bl	800ded0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bb88:	2800      	cmp	r0, #0
 800bb8a:	d092      	beq.n	800bab2 <HAL_SD_InitCard+0x7e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bb8c:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_READY;
 800bb8e:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bb90:	4961      	ldr	r1, [pc, #388]	; (800bd18 <HAL_SD_InitCard+0x2e4>)
    return HAL_ERROR;
 800bb92:	4616      	mov	r6, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bb94:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800bb96:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bb98:	4318      	orrs	r0, r3
 800bb9a:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800bb9c:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_ERROR;
 800bba0:	e787      	b.n	800bab2 <HAL_SD_InitCard+0x7e>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 800bba2:	4618      	mov	r0, r3
 800bba4:	f002 fcfe 	bl	800e5a4 <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 800bba8:	2800      	cmp	r0, #0
 800bbaa:	d061      	beq.n	800bc70 <HAL_SD_InitCard+0x23c>
    hsd->State = HAL_SD_STATE_READY;
 800bbac:	2601      	movs	r6, #1
 800bbae:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800bbb2:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800bbb4:	4308      	orrs	r0, r1
 800bbb6:	63a0      	str	r0, [r4, #56]	; 0x38
}
 800bbb8:	4630      	mov	r0, r6
 800bbba:	b018      	add	sp, #96	; 0x60
 800bbbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hsd->SdCard.CardVersion = CARD_V1_X;
 800bbc0:	6425      	str	r5, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800bbc2:	6820      	ldr	r0, [r4, #0]
 800bbc4:	f002 fb80 	bl	800e2c8 <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
 800bbc8:	4605      	mov	r5, r0
 800bbca:	2800      	cmp	r0, #0
 800bbcc:	f47f af6b 	bne.w	800baa6 <HAL_SD_InitCard+0x72>
  if( hsd->SdCard.CardVersion == CARD_V2_X)
 800bbd0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800bbd2:	2b01      	cmp	r3, #1
 800bbd4:	d181      	bne.n	800bada <HAL_SD_InitCard+0xa6>
 800bbd6:	e77b      	b.n	800bad0 <HAL_SD_InitCard+0x9c>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800bbd8:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 800bbdc:	e7e6      	b.n	800bbac <HAL_SD_InitCard+0x178>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800bbde:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 800bbe2:	e7e3      	b.n	800bbac <HAL_SD_InitCard+0x178>
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
 800bbe4:	01d6      	lsls	r6, r2, #7
 800bbe6:	d5ab      	bpl.n	800bb40 <HAL_SD_InitCard+0x10c>
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 800bbe8:	f44f 7300 	mov.w	r3, #512	; 0x200
 800bbec:	65e3      	str	r3, [r4, #92]	; 0x5c
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
 800bbee:	6803      	ldr	r3, [r0, #0]
 800bbf0:	f043 0308 	orr.w	r3, r3, #8
 800bbf4:	6003      	str	r3, [r0, #0]
        errorstate = SDMMC_CmdVoltageSwitch(hsd->Instance);
 800bbf6:	6820      	ldr	r0, [r4, #0]
 800bbf8:	f002 fe24 	bl	800e844 <SDMMC_CmdVoltageSwitch>
        if(errorstate != HAL_SD_ERROR_NONE)
 800bbfc:	4605      	mov	r5, r0
 800bbfe:	b130      	cbz	r0, 800bc0e <HAL_SD_InitCard+0x1da>
 800bc00:	e751      	b.n	800baa6 <HAL_SD_InitCard+0x72>
          if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800bc02:	f7f4 ff11 	bl	8000a28 <HAL_GetTick>
 800bc06:	eba0 0008 	sub.w	r0, r0, r8
 800bc0a:	3001      	adds	r0, #1
 800bc0c:	d079      	beq.n	800bd02 <HAL_SD_InitCard+0x2ce>
        while(( hsd->Instance->STA & SDMMC_FLAG_CKSTOP) != SDMMC_FLAG_CKSTOP)
 800bc0e:	6823      	ldr	r3, [r4, #0]
 800bc10:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bc12:	0155      	lsls	r5, r2, #5
 800bc14:	d5f5      	bpl.n	800bc02 <HAL_SD_InitCard+0x1ce>
        hsd->Instance->ICR = SDMMC_FLAG_CKSTOP;
 800bc16:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 800bc1a:	639a      	str	r2, [r3, #56]	; 0x38
        if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) != SDMMC_FLAG_BUSYD0)
 800bc1c:	6823      	ldr	r3, [r4, #0]
 800bc1e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bc20:	02d8      	lsls	r0, r3, #11
 800bc22:	f57f af7c 	bpl.w	800bb1e <HAL_SD_InitCard+0xea>
          HAL_SD_DriveTransceiver_1_8V_Callback(SET);
 800bc26:	2001      	movs	r0, #1
 800bc28:	f7ff fe24 	bl	800b874 <HAL_SD_DriveTransceiver_1_8V_Callback>
          hsd->Instance->POWER |= SDMMC_POWER_VSWITCH;
 800bc2c:	6822      	ldr	r2, [r4, #0]
 800bc2e:	6813      	ldr	r3, [r2, #0]
 800bc30:	f043 0304 	orr.w	r3, r3, #4
 800bc34:	6013      	str	r3, [r2, #0]
 800bc36:	e005      	b.n	800bc44 <HAL_SD_InitCard+0x210>
            if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800bc38:	f7f4 fef6 	bl	8000a28 <HAL_GetTick>
 800bc3c:	eba0 0008 	sub.w	r0, r0, r8
 800bc40:	3001      	adds	r0, #1
 800bc42:	d05e      	beq.n	800bd02 <HAL_SD_InitCard+0x2ce>
          while(( hsd->Instance->STA & SDMMC_FLAG_VSWEND) != SDMMC_FLAG_VSWEND)
 800bc44:	6823      	ldr	r3, [r4, #0]
 800bc46:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bc48:	0191      	lsls	r1, r2, #6
 800bc4a:	d5f5      	bpl.n	800bc38 <HAL_SD_InitCard+0x204>
          hsd->Instance->ICR = SDMMC_FLAG_VSWEND;
 800bc4c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 800bc50:	639a      	str	r2, [r3, #56]	; 0x38
          if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) == SDMMC_FLAG_BUSYD0)
 800bc52:	6823      	ldr	r3, [r4, #0]
 800bc54:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bc56:	02d2      	lsls	r2, r2, #11
 800bc58:	d407      	bmi.n	800bc6a <HAL_SD_InitCard+0x236>
          hsd->Instance->POWER = 0x13U;
 800bc5a:	2113      	movs	r1, #19
          hsd->Instance->ICR = 0xFFFFFFFFU;
 800bc5c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
          hsd->Instance->POWER = 0x13U;
 800bc60:	6019      	str	r1, [r3, #0]
          hsd->Instance->ICR = 0xFFFFFFFFU;
 800bc62:	6823      	ldr	r3, [r4, #0]
 800bc64:	639a      	str	r2, [r3, #56]	; 0x38
 800bc66:	6820      	ldr	r0, [r4, #0]
 800bc68:	e76a      	b.n	800bb40 <HAL_SD_InitCard+0x10c>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
 800bc6a:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
 800bc6e:	e71a      	b.n	800baa6 <HAL_SD_InitCard+0x72>
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800bc70:	4601      	mov	r1, r0
 800bc72:	6820      	ldr	r0, [r4, #0]
 800bc74:	f002 f8be 	bl	800ddf4 <SDMMC_GetResponse>
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800bc78:	2104      	movs	r1, #4
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800bc7a:	6720      	str	r0, [r4, #112]	; 0x70
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800bc7c:	6820      	ldr	r0, [r4, #0]
 800bc7e:	f002 f8b9 	bl	800ddf4 <SDMMC_GetResponse>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800bc82:	2108      	movs	r1, #8
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800bc84:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800bc86:	6820      	ldr	r0, [r4, #0]
 800bc88:	f002 f8b4 	bl	800ddf4 <SDMMC_GetResponse>
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800bc8c:	210c      	movs	r1, #12
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800bc8e:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800bc90:	6820      	ldr	r0, [r4, #0]
 800bc92:	f002 f8af 	bl	800ddf4 <SDMMC_GetResponse>
  if(hsd->SdCard.CardType != CARD_SECURED)
 800bc96:	6be3      	ldr	r3, [r4, #60]	; 0x3c
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800bc98:	67e0      	str	r0, [r4, #124]	; 0x7c
  if(hsd->SdCard.CardType != CARD_SECURED)
 800bc9a:	2b03      	cmp	r3, #3
 800bc9c:	d034      	beq.n	800bd08 <HAL_SD_InitCard+0x2d4>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 800bc9e:	f10d 0116 	add.w	r1, sp, #22
 800bca2:	6820      	ldr	r0, [r4, #0]
 800bca4:	f002 fcf2 	bl	800e68c <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 800bca8:	2800      	cmp	r0, #0
 800bcaa:	f47f af7f 	bne.w	800bbac <HAL_SD_InitCard+0x178>
  if(hsd->SdCard.CardType != CARD_SECURED)
 800bcae:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800bcb0:	6823      	ldr	r3, [r4, #0]
 800bcb2:	2a03      	cmp	r2, #3
 800bcb4:	f43f af4f 	beq.w	800bb56 <HAL_SD_InitCard+0x122>
    hsd->SdCard.RelCardAdd = sd_rca;
 800bcb8:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800bcbc:	4618      	mov	r0, r3
    hsd->SdCard.RelCardAdd = sd_rca;
 800bcbe:	64a1      	str	r1, [r4, #72]	; 0x48
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800bcc0:	0409      	lsls	r1, r1, #16
 800bcc2:	f002 fca9 	bl	800e618 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 800bcc6:	2800      	cmp	r0, #0
 800bcc8:	f47f af70 	bne.w	800bbac <HAL_SD_InitCard+0x178>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800bccc:	4601      	mov	r1, r0
 800bcce:	6820      	ldr	r0, [r4, #0]
 800bcd0:	f002 f890 	bl	800ddf4 <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800bcd4:	2104      	movs	r1, #4
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800bcd6:	6620      	str	r0, [r4, #96]	; 0x60
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800bcd8:	6820      	ldr	r0, [r4, #0]
 800bcda:	f002 f88b 	bl	800ddf4 <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800bcde:	2108      	movs	r1, #8
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800bce0:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800bce2:	6820      	ldr	r0, [r4, #0]
 800bce4:	f002 f886 	bl	800ddf4 <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800bce8:	210c      	movs	r1, #12
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800bcea:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800bcec:	6820      	ldr	r0, [r4, #0]
 800bcee:	f002 f881 	bl	800ddf4 <SDMMC_GetResponse>
 800bcf2:	6823      	ldr	r3, [r4, #0]
 800bcf4:	66e0      	str	r0, [r4, #108]	; 0x6c
 800bcf6:	e72e      	b.n	800bb56 <HAL_SD_InitCard+0x122>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
 800bcf8:	9b06      	ldr	r3, [sp, #24]
 800bcfa:	42b3      	cmp	r3, r6
 800bcfc:	d8b5      	bhi.n	800bc6a <HAL_SD_InitCard+0x236>
 800bcfe:	6820      	ldr	r0, [r4, #0]
 800bd00:	e71e      	b.n	800bb40 <HAL_SD_InitCard+0x10c>
            return HAL_SD_ERROR_TIMEOUT;
 800bd02:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
 800bd06:	e6ce      	b.n	800baa6 <HAL_SD_InitCard+0x72>
 800bd08:	6823      	ldr	r3, [r4, #0]
 800bd0a:	e724      	b.n	800bb56 <HAL_SD_InitCard+0x122>
 800bd0c:	10624dd3 	.word	0x10624dd3
 800bd10:	00012110 	.word	0x00012110
 800bd14:	c1100000 	.word	0xc1100000
 800bd18:	1fe00fff 	.word	0x1fe00fff

0800bd1c <HAL_SD_GetCardStatus>:
{
 800bd1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800bd20:	4604      	mov	r4, r0
 800bd22:	b097      	sub	sp, #92	; 0x5c
 800bd24:	460d      	mov	r5, r1
  uint32_t tickstart = HAL_GetTick();
 800bd26:	f7f4 fe7f 	bl	8000a28 <HAL_GetTick>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800bd2a:	2100      	movs	r1, #0
  uint32_t tickstart = HAL_GetTick();
 800bd2c:	4680      	mov	r8, r0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800bd2e:	6820      	ldr	r0, [r4, #0]
 800bd30:	f002 f860 	bl	800ddf4 <SDMMC_GetResponse>
 800bd34:	0187      	lsls	r7, r0, #6
 800bd36:	d422      	bmi.n	800bd7e <HAL_SD_GetCardStatus+0x62>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800bd38:	2140      	movs	r1, #64	; 0x40
 800bd3a:	6820      	ldr	r0, [r4, #0]
 800bd3c:	f002 f8c8 	bl	800ded0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bd40:	b308      	cbz	r0, 800bd86 <HAL_SD_GetCardStatus+0x6a>
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
 800bd42:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bd44:	63a3      	str	r3, [r4, #56]	; 0x38
 800bd46:	6823      	ldr	r3, [r4, #0]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bd48:	495b      	ldr	r1, [pc, #364]	; (800beb8 <HAL_SD_GetCardStatus+0x19c>)
    hsd->State = HAL_SD_STATE_READY;
 800bd4a:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bd4c:	6399      	str	r1, [r3, #56]	; 0x38
    status = HAL_ERROR;
 800bd4e:	4616      	mov	r6, r2
    hsd->ErrorCode |= errorstate;
 800bd50:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bd52:	4318      	orrs	r0, r3
 800bd54:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800bd56:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800bd5a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800bd5e:	6820      	ldr	r0, [r4, #0]
 800bd60:	f002 f8b6 	bl	800ded0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bd64:	b138      	cbz	r0, 800bd76 <HAL_SD_GetCardStatus+0x5a>
    hsd->State = HAL_SD_STATE_READY;
 800bd66:	2301      	movs	r3, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bd68:	6822      	ldr	r2, [r4, #0]
 800bd6a:	4953      	ldr	r1, [pc, #332]	; (800beb8 <HAL_SD_GetCardStatus+0x19c>)
    status = HAL_ERROR;
 800bd6c:	461e      	mov	r6, r3
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bd6e:	6391      	str	r1, [r2, #56]	; 0x38
    hsd->ErrorCode = errorstate;
 800bd70:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800bd72:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800bd76:	4630      	mov	r0, r6
 800bd78:	b017      	add	sp, #92	; 0x5c
 800bd7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800bd7e:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800bd80:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800bd84:	e7e0      	b.n	800bd48 <HAL_SD_GetCardStatus+0x2c>
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800bd86:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800bd88:	6820      	ldr	r0, [r4, #0]
 800bd8a:	0409      	lsls	r1, r1, #16
 800bd8c:	f002 fb0a 	bl	800e3a4 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bd90:	2800      	cmp	r0, #0
 800bd92:	d1d6      	bne.n	800bd42 <HAL_SD_GetCardStatus+0x26>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800bd94:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 64U;
 800bd98:	2340      	movs	r3, #64	; 0x40
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
 800bd9a:	2160      	movs	r1, #96	; 0x60
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800bd9c:	9004      	str	r0, [sp, #16]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800bd9e:	9200      	str	r2, [sp, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800bda0:	2202      	movs	r2, #2
  config.DataLength    = 64U;
 800bda2:	9301      	str	r3, [sp, #4]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800bda4:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
 800bda6:	9102      	str	r1, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800bda8:	4669      	mov	r1, sp
 800bdaa:	6820      	ldr	r0, [r4, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800bdac:	9203      	str	r2, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800bdae:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800bdb0:	f002 f830 	bl	800de14 <SDMMC_ConfigData>
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
 800bdb4:	6820      	ldr	r0, [r4, #0]
 800bdb6:	f002 fd01 	bl	800e7bc <SDMMC_CmdStatusRegister>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bdba:	2800      	cmp	r0, #0
 800bdbc:	d1c1      	bne.n	800bd42 <HAL_SD_GetCardStatus+0x26>
  uint32_t *pData = pSDstatus;
 800bdbe:	af06      	add	r7, sp, #24
 800bdc0:	e005      	b.n	800bdce <HAL_SD_GetCardStatus+0xb2>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800bdc2:	f7f4 fe31 	bl	8000a28 <HAL_GetTick>
 800bdc6:	eba0 0008 	sub.w	r0, r0, r8
 800bdca:	3001      	adds	r0, #1
 800bdcc:	d013      	beq.n	800bdf6 <HAL_SD_GetCardStatus+0xda>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800bdce:	6823      	ldr	r3, [r4, #0]
 800bdd0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bdd2:	f412 7f95 	tst.w	r2, #298	; 0x12a
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800bdd6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800bdd8:	d110      	bne.n	800bdfc <HAL_SD_GetCardStatus+0xe0>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800bdda:	0416      	lsls	r6, r2, #16
 800bddc:	d5f1      	bpl.n	800bdc2 <HAL_SD_GetCardStatus+0xa6>
 800bdde:	f107 0620 	add.w	r6, r7, #32
 800bde2:	e000      	b.n	800bde6 <HAL_SD_GetCardStatus+0xca>
 800bde4:	6823      	ldr	r3, [r4, #0]
        *pData = SDMMC_ReadFIFO(hsd->Instance);
 800bde6:	4618      	mov	r0, r3
 800bde8:	f001 ffee 	bl	800ddc8 <SDMMC_ReadFIFO>
 800bdec:	f847 0b04 	str.w	r0, [r7], #4
      for(count = 0U; count < 8U; count++)
 800bdf0:	42b7      	cmp	r7, r6
 800bdf2:	d1f7      	bne.n	800bde4 <HAL_SD_GetCardStatus+0xc8>
 800bdf4:	e7e5      	b.n	800bdc2 <HAL_SD_GetCardStatus+0xa6>
      return HAL_SD_ERROR_TIMEOUT;
 800bdf6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800bdfa:	e7a4      	b.n	800bd46 <HAL_SD_GetCardStatus+0x2a>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800bdfc:	0710      	lsls	r0, r2, #28
 800bdfe:	d455      	bmi.n	800beac <HAL_SD_GetCardStatus+0x190>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800be00:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800be02:	0791      	lsls	r1, r2, #30
 800be04:	d454      	bmi.n	800beb0 <HAL_SD_GetCardStatus+0x194>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800be06:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800be08:	0692      	lsls	r2, r2, #26
 800be0a:	d50b      	bpl.n	800be24 <HAL_SD_GetCardStatus+0x108>
 800be0c:	e052      	b.n	800beb4 <HAL_SD_GetCardStatus+0x198>
    *pData = SDMMC_ReadFIFO(hsd->Instance);
 800be0e:	f001 ffdb 	bl	800ddc8 <SDMMC_ReadFIFO>
 800be12:	f847 0b04 	str.w	r0, [r7], #4
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800be16:	f7f4 fe07 	bl	8000a28 <HAL_GetTick>
 800be1a:	eba0 0008 	sub.w	r0, r0, r8
 800be1e:	3001      	adds	r0, #1
 800be20:	d0e9      	beq.n	800bdf6 <HAL_SD_GetCardStatus+0xda>
 800be22:	6823      	ldr	r3, [r4, #0]
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
 800be24:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    *pData = SDMMC_ReadFIFO(hsd->Instance);
 800be26:	4618      	mov	r0, r3
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
 800be28:	f416 5680 	ands.w	r6, r6, #4096	; 0x1000
 800be2c:	d1ef      	bne.n	800be0e <HAL_SD_GetCardStatus+0xf2>
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 800be2e:	9f06      	ldr	r7, [sp, #24]
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 800be30:	9808      	ldr	r0, [sp, #32]
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800be32:	0a39      	lsrs	r1, r7, #8
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 800be34:	f3c7 1e81 	ubfx	lr, r7, #6, #2
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800be38:	ea4f 4810 	mov.w	r8, r0, lsr #16
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
 800be3c:	f3c7 1c40 	ubfx	ip, r7, #5, #1
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800be40:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800be44:	9a09      	ldr	r2, [sp, #36]	; 0x24
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800be46:	ea41 6117 	orr.w	r1, r1, r7, lsr #24
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800be4a:	f028 07ff 	bic.w	r7, r8, #255	; 0xff
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800be4e:	f8df 806c 	ldr.w	r8, [pc, #108]	; 800bebc <HAL_SD_GetCardStatus+0x1a0>
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800be52:	fa5f f982 	uxtb.w	r9, r2
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800be56:	b289      	uxth	r1, r1
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800be58:	f8c3 8038 	str.w	r8, [r3, #56]	; 0x38
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 800be5c:	fa5f f880 	uxtb.w	r8, r0
 800be60:	9b07      	ldr	r3, [sp, #28]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800be62:	ea47 0709 	orr.w	r7, r7, r9
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 800be66:	f885 e000 	strb.w	lr, [r5]
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
 800be6a:	f885 c001 	strb.w	ip, [r5, #1]
 800be6e:	fa93 fe83 	rev.w	lr, r3
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800be72:	8069      	strh	r1, [r5, #2]
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
 800be74:	f3c0 5303 	ubfx	r3, r0, #20, #4
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
 800be78:	f3c0 2107 	ubfx	r1, r0, #8, #8
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
 800be7c:	f8c5 e004 	str.w	lr, [r5, #4]
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
 800be80:	f3c2 2c85 	ubfx	ip, r2, #10, #6
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 800be84:	f885 8008 	strb.w	r8, [r5, #8]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
 800be88:	f3c2 2001 	ubfx	r0, r2, #8, #2
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
 800be8c:	7269      	strb	r1, [r5, #9]
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
 800be8e:	72ab      	strb	r3, [r5, #10]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
 800be90:	f3c2 1103 	ubfx	r1, r2, #4, #4
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 800be94:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 800be98:	f002 020f 	and.w	r2, r2, #15
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800be9c:	81af      	strh	r7, [r5, #12]
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
 800be9e:	f885 c00e 	strb.w	ip, [r5, #14]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
 800bea2:	73e8      	strb	r0, [r5, #15]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
 800bea4:	7429      	strb	r1, [r5, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 800bea6:	746a      	strb	r2, [r5, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 800bea8:	74ab      	strb	r3, [r5, #18]
 800beaa:	e756      	b.n	800bd5a <HAL_SD_GetCardStatus+0x3e>
    return HAL_SD_ERROR_DATA_TIMEOUT;
 800beac:	2008      	movs	r0, #8
 800beae:	e74b      	b.n	800bd48 <HAL_SD_GetCardStatus+0x2c>
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 800beb0:	2002      	movs	r0, #2
 800beb2:	e749      	b.n	800bd48 <HAL_SD_GetCardStatus+0x2c>
    return HAL_SD_ERROR_RX_OVERRUN;
 800beb4:	2020      	movs	r0, #32
 800beb6:	e747      	b.n	800bd48 <HAL_SD_GetCardStatus+0x2c>
 800beb8:	1fe00fff 	.word	0x1fe00fff
 800bebc:	18000f3a 	.word	0x18000f3a

0800bec0 <HAL_SD_GetCardInfo>:
{
 800bec0:	4603      	mov	r3, r0
}
 800bec2:	2000      	movs	r0, #0
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 800bec4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800bec6:	600a      	str	r2, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
 800bec8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800beca:	604a      	str	r2, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
 800becc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800bece:	608a      	str	r2, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
 800bed0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800bed2:	60ca      	str	r2, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
 800bed4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800bed6:	610a      	str	r2, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
 800bed8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800beda:	614a      	str	r2, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
 800bedc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800bede:	618a      	str	r2, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
 800bee0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800bee2:	61cb      	str	r3, [r1, #28]
}
 800bee4:	4770      	bx	lr
 800bee6:	bf00      	nop

0800bee8 <HAL_SD_ConfigWideBusOperation>:
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
 800bee8:	f431 4380 	bics.w	r3, r1, #16384	; 0x4000
{
 800beec:	b570      	push	{r4, r5, r6, lr}
 800beee:	460d      	mov	r5, r1
 800bef0:	b08a      	sub	sp, #40	; 0x28
 800bef2:	4604      	mov	r4, r0
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
 800bef4:	d002      	beq.n	800befc <HAL_SD_ConfigWideBusOperation+0x14>
 800bef6:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800befa:	d152      	bne.n	800bfa2 <HAL_SD_ConfigWideBusOperation+0xba>
  hsd->State = HAL_SD_STATE_BUSY;
 800befc:	2103      	movs	r1, #3
  if(hsd->SdCard.CardType != CARD_SECURED)
 800befe:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800bf00:	6823      	ldr	r3, [r4, #0]
 800bf02:	428a      	cmp	r2, r1
  hsd->State = HAL_SD_STATE_BUSY;
 800bf04:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  if(hsd->SdCard.CardType != CARD_SECURED)
 800bf08:	d025      	beq.n	800bf56 <HAL_SD_ConfigWideBusOperation+0x6e>
    if(WideMode == SDMMC_BUS_WIDE_8B)
 800bf0a:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 800bf0e:	d022      	beq.n	800bf56 <HAL_SD_ConfigWideBusOperation+0x6e>
    else if(WideMode == SDMMC_BUS_WIDE_4B)
 800bf10:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
 800bf14:	d06b      	beq.n	800bfee <HAL_SD_ConfigWideBusOperation+0x106>
    else if(WideMode == SDMMC_BUS_WIDE_1B)
 800bf16:	2d00      	cmp	r5, #0
 800bf18:	d049      	beq.n	800bfae <HAL_SD_ConfigWideBusOperation+0xc6>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800bf1a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800bf1c:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800bf20:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 800bf22:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800bf24:	b9f2      	cbnz	r2, 800bf64 <HAL_SD_ConfigWideBusOperation+0x7c>
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
 800bf26:	6962      	ldr	r2, [r4, #20]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 800bf28:	6921      	ldr	r1, [r4, #16]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
 800bf2a:	2a03      	cmp	r2, #3
    Init.BusWide             = WideMode;
 800bf2c:	9506      	str	r5, [sp, #24]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 800bf2e:	9107      	str	r1, [sp, #28]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 800bf30:	e9d4 6001 	ldrd	r6, r0, [r4, #4]
 800bf34:	e9cd 6004 	strd	r6, r0, [sp, #16]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
 800bf38:	d92a      	bls.n	800bf90 <HAL_SD_ConfigWideBusOperation+0xa8>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
 800bf3a:	9208      	str	r2, [sp, #32]
    (void)SDMMC_Init(hsd->Instance, Init);
 800bf3c:	aa0a      	add	r2, sp, #40	; 0x28
 800bf3e:	ae04      	add	r6, sp, #16
  HAL_StatusTypeDef status = HAL_OK;
 800bf40:	2500      	movs	r5, #0
    (void)SDMMC_Init(hsd->Instance, Init);
 800bf42:	e912 0007 	ldmdb	r2, {r0, r1, r2}
 800bf46:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800bf4a:	4618      	mov	r0, r3
 800bf4c:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
 800bf50:	f001 feda 	bl	800dd08 <SDMMC_Init>
 800bf54:	e009      	b.n	800bf6a <HAL_SD_ConfigWideBusOperation+0x82>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800bf56:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800bf58:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800bf5c:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 800bf5e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800bf60:	2a00      	cmp	r2, #0
 800bf62:	d0e0      	beq.n	800bf26 <HAL_SD_ConfigWideBusOperation+0x3e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf64:	4a36      	ldr	r2, [pc, #216]	; (800c040 <HAL_SD_ConfigWideBusOperation+0x158>)
    status = HAL_ERROR;
 800bf66:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf68:	639a      	str	r2, [r3, #56]	; 0x38
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800bf6a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800bf6e:	6820      	ldr	r0, [r4, #0]
 800bf70:	f001 ffae 	bl	800ded0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bf74:	b130      	cbz	r0, 800bf84 <HAL_SD_ConfigWideBusOperation+0x9c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf76:	6823      	ldr	r3, [r4, #0]
    status = HAL_ERROR;
 800bf78:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf7a:	4a31      	ldr	r2, [pc, #196]	; (800c040 <HAL_SD_ConfigWideBusOperation+0x158>)
 800bf7c:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800bf7e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bf80:	4318      	orrs	r0, r3
 800bf82:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_READY;
 800bf84:	2301      	movs	r3, #1
}
 800bf86:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
 800bf88:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800bf8c:	b00a      	add	sp, #40	; 0x28
 800bf8e:	bd70      	pop	{r4, r5, r6, pc}
    else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
 800bf90:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 800bf92:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800bf96:	d0d0      	beq.n	800bf3a <HAL_SD_ConfigWideBusOperation+0x52>
    else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
 800bf98:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 800bf9c:	d034      	beq.n	800c008 <HAL_SD_ConfigWideBusOperation+0x120>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
 800bf9e:	2204      	movs	r2, #4
 800bfa0:	e7cb      	b.n	800bf3a <HAL_SD_ConfigWideBusOperation+0x52>
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
 800bfa2:	f640 1149 	movw	r1, #2377	; 0x949
 800bfa6:	4827      	ldr	r0, [pc, #156]	; (800c044 <HAL_SD_ConfigWideBusOperation+0x15c>)
 800bfa8:	f007 fc92 	bl	80138d0 <assert_failed>
 800bfac:	e7a6      	b.n	800befc <HAL_SD_ConfigWideBusOperation+0x14>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800bfae:	4629      	mov	r1, r5
 800bfb0:	4618      	mov	r0, r3
  uint32_t scr[2U] = {0UL, 0UL};
 800bfb2:	e9cd 5504 	strd	r5, r5, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800bfb6:	f001 ff1d 	bl	800ddf4 <SDMMC_GetResponse>
 800bfba:	0181      	lsls	r1, r0, #6
 800bfbc:	d420      	bmi.n	800c000 <HAL_SD_ConfigWideBusOperation+0x118>
  errorstate = SD_FindSCR(hsd, scr);
 800bfbe:	a904      	add	r1, sp, #16
 800bfc0:	4620      	mov	r0, r4
 800bfc2:	f7ff f9f7 	bl	800b3b4 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bfc6:	b968      	cbnz	r0, 800bfe4 <HAL_SD_ConfigWideBusOperation+0xfc>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 800bfc8:	9a05      	ldr	r2, [sp, #20]
 800bfca:	6823      	ldr	r3, [r4, #0]
 800bfcc:	03d2      	lsls	r2, r2, #15
 800bfce:	d534      	bpl.n	800c03a <HAL_SD_ConfigWideBusOperation+0x152>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800bfd0:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800bfd2:	4618      	mov	r0, r3
 800bfd4:	0409      	lsls	r1, r1, #16
 800bfd6:	f002 f9e5 	bl	800e3a4 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800bfda:	b918      	cbnz	r0, 800bfe4 <HAL_SD_ConfigWideBusOperation+0xfc>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 800bfdc:	4629      	mov	r1, r5
 800bfde:	6820      	ldr	r0, [r4, #0]
 800bfe0:	f002 fa58 	bl	800e494 <SDMMC_CmdBusWidth>
 800bfe4:	6823      	ldr	r3, [r4, #0]
      hsd->ErrorCode |= errorstate;
 800bfe6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800bfe8:	4310      	orrs	r0, r2
 800bfea:	63a0      	str	r0, [r4, #56]	; 0x38
 800bfec:	e7b7      	b.n	800bf5e <HAL_SD_ConfigWideBusOperation+0x76>
  uint32_t scr[2U] = {0UL, 0UL};
 800bfee:	2200      	movs	r2, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800bff0:	4618      	mov	r0, r3
 800bff2:	4611      	mov	r1, r2
  uint32_t scr[2U] = {0UL, 0UL};
 800bff4:	e9cd 2204 	strd	r2, r2, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800bff8:	f001 fefc 	bl	800ddf4 <SDMMC_GetResponse>
 800bffc:	0186      	lsls	r6, r0, #6
 800bffe:	d506      	bpl.n	800c00e <HAL_SD_ConfigWideBusOperation+0x126>
 800c000:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800c002:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800c006:	e7ee      	b.n	800bfe6 <HAL_SD_ConfigWideBusOperation+0xfe>
      Init.ClockDiv = SDMMC_HSpeed_CLK_DIV;
 800c008:	2202      	movs	r2, #2
 800c00a:	9208      	str	r2, [sp, #32]
 800c00c:	e796      	b.n	800bf3c <HAL_SD_ConfigWideBusOperation+0x54>
  errorstate = SD_FindSCR(hsd, scr);
 800c00e:	a904      	add	r1, sp, #16
 800c010:	4620      	mov	r0, r4
 800c012:	f7ff f9cf 	bl	800b3b4 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c016:	2800      	cmp	r0, #0
 800c018:	d1e4      	bne.n	800bfe4 <HAL_SD_ConfigWideBusOperation+0xfc>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 800c01a:	9a05      	ldr	r2, [sp, #20]
 800c01c:	6823      	ldr	r3, [r4, #0]
 800c01e:	0350      	lsls	r0, r2, #13
 800c020:	d50b      	bpl.n	800c03a <HAL_SD_ConfigWideBusOperation+0x152>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c022:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800c024:	4618      	mov	r0, r3
 800c026:	0409      	lsls	r1, r1, #16
 800c028:	f002 f9bc 	bl	800e3a4 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c02c:	2800      	cmp	r0, #0
 800c02e:	d1d9      	bne.n	800bfe4 <HAL_SD_ConfigWideBusOperation+0xfc>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 800c030:	2102      	movs	r1, #2
 800c032:	6820      	ldr	r0, [r4, #0]
 800c034:	f002 fa2e 	bl	800e494 <SDMMC_CmdBusWidth>
 800c038:	e7d4      	b.n	800bfe4 <HAL_SD_ConfigWideBusOperation+0xfc>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800c03a:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 800c03e:	e7d2      	b.n	800bfe6 <HAL_SD_ConfigWideBusOperation+0xfe>
 800c040:	1fe00fff 	.word	0x1fe00fff
 800c044:	08029430 	.word	0x08029430

0800c048 <HAL_SD_Init>:
{
 800c048:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c04a:	b087      	sub	sp, #28
  if(hsd == NULL)
 800c04c:	2800      	cmp	r0, #0
 800c04e:	d038      	beq.n	800c0c2 <HAL_SD_Init+0x7a>
  assert_param(IS_SDMMC_ALL_INSTANCE(hsd->Instance));
 800c050:	6803      	ldr	r3, [r0, #0]
 800c052:	4604      	mov	r4, r0
 800c054:	4a5c      	ldr	r2, [pc, #368]	; (800c1c8 <HAL_SD_Init+0x180>)
 800c056:	4293      	cmp	r3, r2
 800c058:	d007      	beq.n	800c06a <HAL_SD_Init+0x22>
 800c05a:	4a5c      	ldr	r2, [pc, #368]	; (800c1cc <HAL_SD_Init+0x184>)
 800c05c:	4293      	cmp	r3, r2
 800c05e:	d004      	beq.n	800c06a <HAL_SD_Init+0x22>
 800c060:	f240 115b 	movw	r1, #347	; 0x15b
 800c064:	485a      	ldr	r0, [pc, #360]	; (800c1d0 <HAL_SD_Init+0x188>)
 800c066:	f007 fc33 	bl	80138d0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_EDGE(hsd->Init.ClockEdge));
 800c06a:	6863      	ldr	r3, [r4, #4]
 800c06c:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
 800c070:	d17a      	bne.n	800c168 <HAL_SD_Init+0x120>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
 800c072:	68a3      	ldr	r3, [r4, #8]
 800c074:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 800c078:	d16c      	bne.n	800c154 <HAL_SD_Init+0x10c>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
 800c07a:	68e3      	ldr	r3, [r4, #12]
 800c07c:	f433 4280 	bics.w	r2, r3, #16384	; 0x4000
 800c080:	d003      	beq.n	800c08a <HAL_SD_Init+0x42>
 800c082:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800c086:	f040 8084 	bne.w	800c192 <HAL_SD_Init+0x14a>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
 800c08a:	6923      	ldr	r3, [r4, #16]
 800c08c:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 800c090:	d175      	bne.n	800c17e <HAL_SD_Init+0x136>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
 800c092:	6963      	ldr	r3, [r4, #20]
 800c094:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800c098:	d250      	bcs.n	800c13c <HAL_SD_Init+0xf4>
  if(hsd->State == HAL_SD_STATE_RESET)
 800c09a:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800c09e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800c0a2:	b93b      	cbnz	r3, 800c0b4 <HAL_SD_Init+0x6c>
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_UNKNOWN)
 800c0a4:	69a3      	ldr	r3, [r4, #24]
    hsd->Lock = HAL_UNLOCKED;
 800c0a6:	7722      	strb	r2, [r4, #28]
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_UNKNOWN)
 800c0a8:	b90b      	cbnz	r3, 800c0ae <HAL_SD_Init+0x66>
      hsd->Init.TranceiverPresent = SDMMC_TRANSCEIVER_PRESENT;
 800c0aa:	2302      	movs	r3, #2
 800c0ac:	61a3      	str	r3, [r4, #24]
    HAL_SD_MspInit(hsd);
 800c0ae:	4620      	mov	r0, r4
 800c0b0:	f008 fae0 	bl	8014674 <HAL_SD_MspInit>
  hsd->State = HAL_SD_STATE_BUSY;
 800c0b4:	2303      	movs	r3, #3
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 800c0b6:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_BUSY;
 800c0b8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 800c0bc:	f7ff fcba 	bl	800ba34 <HAL_SD_InitCard>
 800c0c0:	b118      	cbz	r0, 800c0ca <HAL_SD_Init+0x82>
    return HAL_ERROR;
 800c0c2:	2501      	movs	r5, #1
}
 800c0c4:	4628      	mov	r0, r5
 800c0c6:	b007      	add	sp, #28
 800c0c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
 800c0ca:	a901      	add	r1, sp, #4
 800c0cc:	4620      	mov	r0, r4
 800c0ce:	f7ff fe25 	bl	800bd1c <HAL_SD_GetCardStatus>
 800c0d2:	2800      	cmp	r0, #0
 800c0d4:	d1f5      	bne.n	800c0c2 <HAL_SD_Init+0x7a>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800c0d6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  speedgrade = CardStatus.UhsSpeedGrade;
 800c0d8:	f89d 2014 	ldrb.w	r2, [sp, #20]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800c0dc:	2901      	cmp	r1, #1
  unitsize = CardStatus.UhsAllocationUnitSize;
 800c0de:	f89d 3015 	ldrb.w	r3, [sp, #21]
  speedgrade = CardStatus.UhsSpeedGrade;
 800c0e2:	b2d2      	uxtb	r2, r2
  unitsize = CardStatus.UhsAllocationUnitSize;
 800c0e4:	b2db      	uxtb	r3, r3
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800c0e6:	d05f      	beq.n	800c1a8 <HAL_SD_Init+0x160>
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
 800c0e8:	65e0      	str	r0, [r4, #92]	; 0x5c
  if(HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
 800c0ea:	68e1      	ldr	r1, [r4, #12]
 800c0ec:	4620      	mov	r0, r4
 800c0ee:	f7ff fefb 	bl	800bee8 <HAL_SD_ConfigWideBusOperation>
 800c0f2:	4605      	mov	r5, r0
 800c0f4:	2800      	cmp	r0, #0
 800c0f6:	d1e4      	bne.n	800c0c2 <HAL_SD_Init+0x7a>
  tickstart = HAL_GetTick();
 800c0f8:	f7f4 fc96 	bl	8000a28 <HAL_GetTick>
 800c0fc:	4607      	mov	r7, r0
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 800c0fe:	e007      	b.n	800c110 <HAL_SD_Init+0xc8>
    hsd->ErrorCode |= errorstate;
 800c100:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c102:	431e      	orrs	r6, r3
 800c104:	63a6      	str	r6, [r4, #56]	; 0x38
    if((HAL_GetTick()-tickstart) >=  SDMMC_DATATIMEOUT)
 800c106:	f7f4 fc8f 	bl	8000a28 <HAL_GetTick>
 800c10a:	1bc0      	subs	r0, r0, r7
 800c10c:	3001      	adds	r0, #1
 800c10e:	d053      	beq.n	800c1b8 <HAL_SD_Init+0x170>
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c110:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800c112:	6820      	ldr	r0, [r4, #0]
 800c114:	0409      	lsls	r1, r1, #16
 800c116:	f002 fb0d 	bl	800e734 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c11a:	4606      	mov	r6, r0
 800c11c:	2800      	cmp	r0, #0
 800c11e:	d1ef      	bne.n	800c100 <HAL_SD_Init+0xb8>
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c120:	4601      	mov	r1, r0
 800c122:	6820      	ldr	r0, [r4, #0]
 800c124:	f001 fe66 	bl	800ddf4 <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
 800c128:	f3c0 2043 	ubfx	r0, r0, #9, #4
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 800c12c:	2804      	cmp	r0, #4
 800c12e:	d1ea      	bne.n	800c106 <HAL_SD_Init+0xbe>
  hsd->State = HAL_SD_STATE_READY;
 800c130:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800c132:	63a6      	str	r6, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
 800c134:	6326      	str	r6, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
 800c136:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
 800c13a:	e7c3      	b.n	800c0c4 <HAL_SD_Init+0x7c>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
 800c13c:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800c140:	4823      	ldr	r0, [pc, #140]	; (800c1d0 <HAL_SD_Init+0x188>)
 800c142:	f007 fbc5 	bl	80138d0 <assert_failed>
  if(hsd->State == HAL_SD_STATE_RESET)
 800c146:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800c14a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800c14e:	2b00      	cmp	r3, #0
 800c150:	d1b0      	bne.n	800c0b4 <HAL_SD_Init+0x6c>
 800c152:	e7a7      	b.n	800c0a4 <HAL_SD_Init+0x5c>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
 800c154:	f240 115d 	movw	r1, #349	; 0x15d
 800c158:	481d      	ldr	r0, [pc, #116]	; (800c1d0 <HAL_SD_Init+0x188>)
 800c15a:	f007 fbb9 	bl	80138d0 <assert_failed>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
 800c15e:	68e3      	ldr	r3, [r4, #12]
 800c160:	f433 4280 	bics.w	r2, r3, #16384	; 0x4000
 800c164:	d18d      	bne.n	800c082 <HAL_SD_Init+0x3a>
 800c166:	e790      	b.n	800c08a <HAL_SD_Init+0x42>
  assert_param(IS_SDMMC_CLOCK_EDGE(hsd->Init.ClockEdge));
 800c168:	f44f 71ae 	mov.w	r1, #348	; 0x15c
 800c16c:	4818      	ldr	r0, [pc, #96]	; (800c1d0 <HAL_SD_Init+0x188>)
 800c16e:	f007 fbaf 	bl	80138d0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
 800c172:	68a3      	ldr	r3, [r4, #8]
 800c174:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 800c178:	f43f af7f 	beq.w	800c07a <HAL_SD_Init+0x32>
 800c17c:	e7ea      	b.n	800c154 <HAL_SD_Init+0x10c>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
 800c17e:	f240 115f 	movw	r1, #351	; 0x15f
 800c182:	4813      	ldr	r0, [pc, #76]	; (800c1d0 <HAL_SD_Init+0x188>)
 800c184:	f007 fba4 	bl	80138d0 <assert_failed>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
 800c188:	6963      	ldr	r3, [r4, #20]
 800c18a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800c18e:	d384      	bcc.n	800c09a <HAL_SD_Init+0x52>
 800c190:	e7d4      	b.n	800c13c <HAL_SD_Init+0xf4>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
 800c192:	f44f 71af 	mov.w	r1, #350	; 0x15e
 800c196:	480e      	ldr	r0, [pc, #56]	; (800c1d0 <HAL_SD_Init+0x188>)
 800c198:	f007 fb9a 	bl	80138d0 <assert_failed>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
 800c19c:	6923      	ldr	r3, [r4, #16]
 800c19e:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 800c1a2:	f43f af76 	beq.w	800c092 <HAL_SD_Init+0x4a>
 800c1a6:	e7ea      	b.n	800c17e <HAL_SD_Init+0x136>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800c1a8:	4313      	orrs	r3, r2
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 800c1aa:	bf14      	ite	ne
 800c1ac:	f44f 7300 	movne.w	r3, #512	; 0x200
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
 800c1b0:	f44f 7380 	moveq.w	r3, #256	; 0x100
 800c1b4:	65e3      	str	r3, [r4, #92]	; 0x5c
 800c1b6:	e798      	b.n	800c0ea <HAL_SD_Init+0xa2>
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800c1b8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
      hsd->State= HAL_SD_STATE_READY;
 800c1bc:	2301      	movs	r3, #1
      return HAL_TIMEOUT;
 800c1be:	2503      	movs	r5, #3
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800c1c0:	63a2      	str	r2, [r4, #56]	; 0x38
      hsd->State= HAL_SD_STATE_READY;
 800c1c2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return HAL_TIMEOUT;
 800c1c6:	e77d      	b.n	800c0c4 <HAL_SD_Init+0x7c>
 800c1c8:	52007000 	.word	0x52007000
 800c1cc:	48022400 	.word	0x48022400
 800c1d0:	08029430 	.word	0x08029430

0800c1d4 <HAL_SD_GetCardState>:
{
 800c1d4:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c1d6:	6c81      	ldr	r1, [r0, #72]	; 0x48
{
 800c1d8:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c1da:	6800      	ldr	r0, [r0, #0]
 800c1dc:	0409      	lsls	r1, r1, #16
 800c1de:	f002 faa9 	bl	800e734 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c1e2:	4601      	mov	r1, r0
 800c1e4:	b120      	cbz	r0, 800c1f0 <HAL_SD_GetCardState+0x1c>
    hsd->ErrorCode |= errorstate;
 800c1e6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c1e8:	2000      	movs	r0, #0
 800c1ea:	4319      	orrs	r1, r3
 800c1ec:	63a1      	str	r1, [r4, #56]	; 0x38
}
 800c1ee:	bd10      	pop	{r4, pc}
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c1f0:	6820      	ldr	r0, [r4, #0]
 800c1f2:	f001 fdff 	bl	800ddf4 <SDMMC_GetResponse>
 800c1f6:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
 800c1fa:	bd10      	pop	{r4, pc}

0800c1fc <HAL_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{
  /* Check the SDRAM handle parameter */
  if (hsdram == NULL)
 800c1fc:	b310      	cbz	r0, 800c244 <HAL_SDRAM_Init+0x48>
{
 800c1fe:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }

  if (hsdram->State == HAL_SDRAM_STATE_RESET)
 800c200:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800c204:	4604      	mov	r4, r0
 800c206:	460d      	mov	r5, r1
 800c208:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800c20c:	b1ab      	cbz	r3, 800c23a <HAL_SDRAM_Init+0x3e>
    HAL_SDRAM_MspInit(hsdram);
#endif
  }

  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800c20e:	2302      	movs	r3, #2

  /* Initialize SDRAM control Interface */
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800c210:	1d21      	adds	r1, r4, #4
 800c212:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800c214:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800c218:	f001 fb3a 	bl	800d890 <FMC_SDRAM_Init>

  /* Initialize SDRAM timing Interface */
  (void)FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
 800c21c:	4629      	mov	r1, r5
 800c21e:	e9d4 0200 	ldrd	r0, r2, [r4]
 800c222:	f001 fbf9 	bl	800da18 <FMC_SDRAM_Timing_Init>

  /* Enable FMC Peripheral */
  __FMC_ENABLE();
 800c226:	4a08      	ldr	r2, [pc, #32]	; (800c248 <HAL_SDRAM_Init+0x4c>)
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 800c228:	2101      	movs	r1, #1

  return HAL_OK;
 800c22a:	2000      	movs	r0, #0
  __FMC_ENABLE();
 800c22c:	6813      	ldr	r3, [r2, #0]
 800c22e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800c232:	6013      	str	r3, [r2, #0]
  hsdram->State = HAL_SDRAM_STATE_READY;
 800c234:	f884 102c 	strb.w	r1, [r4, #44]	; 0x2c
}
 800c238:	bd38      	pop	{r3, r4, r5, pc}
    hsdram->Lock = HAL_UNLOCKED;
 800c23a:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    HAL_SDRAM_MspInit(hsdram);
 800c23e:	f005 fee7 	bl	8012010 <HAL_SDRAM_MspInit>
 800c242:	e7e4      	b.n	800c20e <HAL_SDRAM_Init+0x12>
    return HAL_ERROR;
 800c244:	2001      	movs	r0, #1
}
 800c246:	4770      	bx	lr
 800c248:	52004000 	.word	0x52004000

0800c24c <HAL_SDRAM_SendCommand>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  HAL_SDRAM_StateTypeDef state = hsdram->State;
 800c24c:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800c250:	b2db      	uxtb	r3, r3
  
  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
 800c252:	2b02      	cmp	r3, #2
 800c254:	d015      	beq.n	800c282 <HAL_SDRAM_SendCommand+0x36>
{
 800c256:	b570      	push	{r4, r5, r6, lr}
  {
    return HAL_BUSY;
  }
  else if((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_PRECHARGED))
 800c258:	f003 04fb 	and.w	r4, r3, #251	; 0xfb
 800c25c:	2c01      	cmp	r4, #1
 800c25e:	d001      	beq.n	800c264 <HAL_SDRAM_SendCommand+0x18>
      hsdram->State = HAL_SDRAM_STATE_READY;
    }
  }
  else
  {
    return HAL_ERROR;
 800c260:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
 800c262:	bd70      	pop	{r4, r5, r6, pc}
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800c264:	2302      	movs	r3, #2
 800c266:	4605      	mov	r5, r0
 800c268:	460e      	mov	r6, r1
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800c26a:	6800      	ldr	r0, [r0, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800c26c:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800c270:	f001 fc7a 	bl	800db68 <FMC_SDRAM_SendCommand>
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800c274:	6833      	ldr	r3, [r6, #0]
 800c276:	2b02      	cmp	r3, #2
 800c278:	d005      	beq.n	800c286 <HAL_SDRAM_SendCommand+0x3a>
      hsdram->State = HAL_SDRAM_STATE_READY;
 800c27a:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
  return HAL_OK;
 800c27e:	2000      	movs	r0, #0
}
 800c280:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 800c282:	4618      	mov	r0, r3
}
 800c284:	4770      	bx	lr
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800c286:	2305      	movs	r3, #5
  return HAL_OK;
 800c288:	2000      	movs	r0, #0
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800c28a:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
}
 800c28e:	bd70      	pop	{r4, r5, r6, pc}

0800c290 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 800c290:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
 800c292:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800c296:	b2db      	uxtb	r3, r3
 800c298:	2b02      	cmp	r3, #2
 800c29a:	d006      	beq.n	800c2aa <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
 800c29c:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
 800c2a0:	b2ed      	uxtb	r5, r5
 800c2a2:	2d01      	cmp	r5, #1
 800c2a4:	d003      	beq.n	800c2ae <HAL_SDRAM_ProgramRefreshRate+0x1e>
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_READY;
  }
  else
  {
    return HAL_ERROR;
 800c2a6:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
 800c2a8:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_BUSY;
 800c2aa:	4618      	mov	r0, r3
}
 800c2ac:	bd38      	pop	{r3, r4, r5, pc}
 800c2ae:	4604      	mov	r4, r0
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800c2b0:	2302      	movs	r3, #2
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
 800c2b2:	6800      	ldr	r0, [r0, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800c2b4:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
 800c2b8:	f001 fca0 	bl	800dbfc <FMC_SDRAM_ProgramRefreshRate>
    hsdram->State = HAL_SDRAM_STATE_READY;
 800c2bc:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
  return HAL_OK;
 800c2c0:	2000      	movs	r0, #0
}
 800c2c2:	bd38      	pop	{r3, r4, r5, pc}

0800c2c4 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800c2c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800c2c8:	6a02      	ldr	r2, [r0, #32]
{
 800c2ca:	460f      	mov	r7, r1
 800c2cc:	4604      	mov	r4, r0
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800c2ce:	4b3b      	ldr	r3, [pc, #236]	; (800c3bc <TIM_OC1_SetConfig+0xf8>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800c2d0:	f022 0201 	bic.w	r2, r2, #1
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800c2d4:	493a      	ldr	r1, [pc, #232]	; (800c3c0 <TIM_OC1_SetConfig+0xfc>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800c2d6:	6202      	str	r2, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800c2d8:	428c      	cmp	r4, r1
  tmpccer = TIMx->CCER;
 800c2da:	6a05      	ldr	r5, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 800c2dc:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 800c2e0:	6980      	ldr	r0, [r0, #24]
  tmpccer &= ~TIM_CCER_CC1P;
 800c2e2:	f025 0502 	bic.w	r5, r5, #2
  tmpccer |= OC_Config->OCPolarity;
 800c2e6:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800c2e8:	ea03 0300 	and.w	r3, r3, r0
  tmpccmrx |= OC_Config->OCMode;
 800c2ec:	683e      	ldr	r6, [r7, #0]
  tmpccer |= OC_Config->OCPolarity;
 800c2ee:	ea45 0502 	orr.w	r5, r5, r2
  tmpccmrx |= OC_Config->OCMode;
 800c2f2:	ea46 0603 	orr.w	r6, r6, r3
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800c2f6:	d03a      	beq.n	800c36e <TIM_OC1_SetConfig+0xaa>
 800c2f8:	4b32      	ldr	r3, [pc, #200]	; (800c3c4 <TIM_OC1_SetConfig+0x100>)
 800c2fa:	429c      	cmp	r4, r3
 800c2fc:	d037      	beq.n	800c36e <TIM_OC1_SetConfig+0xaa>
 800c2fe:	4a32      	ldr	r2, [pc, #200]	; (800c3c8 <TIM_OC1_SetConfig+0x104>)
 800c300:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 800c304:	429c      	cmp	r4, r3
 800c306:	bf18      	it	ne
 800c308:	4294      	cmpne	r4, r2
 800c30a:	d003      	beq.n	800c314 <TIM_OC1_SetConfig+0x50>
 800c30c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c310:	429c      	cmp	r4, r3
 800c312:	d144      	bne.n	800c39e <TIM_OC1_SetConfig+0xda>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800c314:	68fb      	ldr	r3, [r7, #12]
 800c316:	f025 0508 	bic.w	r5, r5, #8
 800c31a:	f033 0208 	bics.w	r2, r3, #8
 800c31e:	d02c      	beq.n	800c37a <TIM_OC1_SetConfig+0xb6>
 800c320:	f641 0106 	movw	r1, #6150	; 0x1806
 800c324:	4829      	ldr	r0, [pc, #164]	; (800c3cc <TIM_OC1_SetConfig+0x108>)
 800c326:	f007 fad3 	bl	80138d0 <assert_failed>

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 800c32a:	68fb      	ldr	r3, [r7, #12]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800c32c:	4a26      	ldr	r2, [pc, #152]	; (800c3c8 <TIM_OC1_SetConfig+0x104>)
    tmpccer |= OC_Config->OCNPolarity;
 800c32e:	431d      	orrs	r5, r3
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800c330:	4b27      	ldr	r3, [pc, #156]	; (800c3d0 <TIM_OC1_SetConfig+0x10c>)
 800c332:	429c      	cmp	r4, r3
 800c334:	bf18      	it	ne
 800c336:	4294      	cmpne	r4, r2
    tmpccer &= ~TIM_CCER_CC1NE;
 800c338:	f025 0504 	bic.w	r5, r5, #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800c33c:	d020      	beq.n	800c380 <TIM_OC1_SetConfig+0xbc>
 800c33e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c342:	429c      	cmp	r4, r3
 800c344:	d12b      	bne.n	800c39e <TIM_OC1_SetConfig+0xda>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800c346:	69bb      	ldr	r3, [r7, #24]
 800c348:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800c34c:	d01c      	beq.n	800c388 <TIM_OC1_SetConfig+0xc4>
 800c34e:	f641 0113 	movw	r1, #6163	; 0x1813
 800c352:	481e      	ldr	r0, [pc, #120]	; (800c3cc <TIM_OC1_SetConfig+0x108>)
 800c354:	f007 fabc 	bl	80138d0 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800c358:	697b      	ldr	r3, [r7, #20]
 800c35a:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800c35e:	d017      	beq.n	800c390 <TIM_OC1_SetConfig+0xcc>
 800c360:	f641 0114 	movw	r1, #6164	; 0x1814
 800c364:	4819      	ldr	r0, [pc, #100]	; (800c3cc <TIM_OC1_SetConfig+0x108>)
 800c366:	f007 fab3 	bl	80138d0 <assert_failed>
 800c36a:	697b      	ldr	r3, [r7, #20]
 800c36c:	e010      	b.n	800c390 <TIM_OC1_SetConfig+0xcc>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800c36e:	68fb      	ldr	r3, [r7, #12]
 800c370:	f025 0508 	bic.w	r5, r5, #8
 800c374:	f033 0208 	bics.w	r2, r3, #8
 800c378:	d119      	bne.n	800c3ae <TIM_OC1_SetConfig+0xea>
    tmpccer |= OC_Config->OCNPolarity;
 800c37a:	431d      	orrs	r5, r3
    tmpccer &= ~TIM_CCER_CC1NE;
 800c37c:	f025 0504 	bic.w	r5, r5, #4
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800c380:	69bb      	ldr	r3, [r7, #24]
 800c382:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800c386:	d1e2      	bne.n	800c34e <TIM_OC1_SetConfig+0x8a>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800c388:	697b      	ldr	r3, [r7, #20]
 800c38a:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800c38e:	d1e7      	bne.n	800c360 <TIM_OC1_SetConfig+0x9c>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 800c390:	f428 7840 	bic.w	r8, r8, #768	; 0x300
 800c394:	69ba      	ldr	r2, [r7, #24]
 800c396:	ea48 0802 	orr.w	r8, r8, r2
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800c39a:	ea48 0803 	orr.w	r8, r8, r3
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c39e:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800c3a2:	61a6      	str	r6, [r4, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800c3a4:	687b      	ldr	r3, [r7, #4]
 800c3a6:	6363      	str	r3, [r4, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c3a8:	6225      	str	r5, [r4, #32]
}
 800c3aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800c3ae:	f641 0106 	movw	r1, #6150	; 0x1806
 800c3b2:	4806      	ldr	r0, [pc, #24]	; (800c3cc <TIM_OC1_SetConfig+0x108>)
 800c3b4:	f007 fa8c 	bl	80138d0 <assert_failed>
    tmpccer |= OC_Config->OCNPolarity;
 800c3b8:	68fb      	ldr	r3, [r7, #12]
 800c3ba:	e7de      	b.n	800c37a <TIM_OC1_SetConfig+0xb6>
 800c3bc:	fffeff8c 	.word	0xfffeff8c
 800c3c0:	40010000 	.word	0x40010000
 800c3c4:	40010400 	.word	0x40010400
 800c3c8:	40014000 	.word	0x40014000
 800c3cc:	08029468 	.word	0x08029468
 800c3d0:	40014400 	.word	0x40014400

0800c3d4 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800c3d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800c3d8:	6a03      	ldr	r3, [r0, #32]
{
 800c3da:	460f      	mov	r7, r1
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800c3dc:	4931      	ldr	r1, [pc, #196]	; (800c4a4 <TIM_OC3_SetConfig+0xd0>)
{
 800c3de:	4604      	mov	r4, r0
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800c3e0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800c3e4:	4288      	cmp	r0, r1
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800c3e6:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 800c3e8:	6a05      	ldr	r5, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 800c3ea:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 800c3ee:	69c6      	ldr	r6, [r0, #28]
  tmpccer &= ~TIM_CCER_CC3P;
 800c3f0:	f425 7500 	bic.w	r5, r5, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800c3f4:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 800c3f6:	f026 0673 	bic.w	r6, r6, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 800c3fa:	683b      	ldr	r3, [r7, #0]
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800c3fc:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
  tmpccmrx |= OC_Config->OCMode;
 800c400:	ea46 0603 	orr.w	r6, r6, r3
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800c404:	d023      	beq.n	800c44e <TIM_OC3_SetConfig+0x7a>
 800c406:	4b28      	ldr	r3, [pc, #160]	; (800c4a8 <TIM_OC3_SetConfig+0xd4>)
 800c408:	4298      	cmp	r0, r3
 800c40a:	d020      	beq.n	800c44e <TIM_OC3_SetConfig+0x7a>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800c40c:	4a27      	ldr	r2, [pc, #156]	; (800c4ac <TIM_OC3_SetConfig+0xd8>)
 800c40e:	4b28      	ldr	r3, [pc, #160]	; (800c4b0 <TIM_OC3_SetConfig+0xdc>)
 800c410:	4298      	cmp	r0, r3
 800c412:	bf18      	it	ne
 800c414:	4290      	cmpne	r0, r2
 800c416:	d003      	beq.n	800c420 <TIM_OC3_SetConfig+0x4c>
 800c418:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c41c:	4298      	cmp	r0, r3
 800c41e:	d10e      	bne.n	800c43e <TIM_OC3_SetConfig+0x6a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800c420:	69bb      	ldr	r3, [r7, #24]
 800c422:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800c426:	d120      	bne.n	800c46a <TIM_OC3_SetConfig+0x96>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800c428:	697b      	ldr	r3, [r7, #20]
 800c42a:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800c42e:	d125      	bne.n	800c47c <TIM_OC3_SetConfig+0xa8>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800c430:	f428 5840 	bic.w	r8, r8, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800c434:	69ba      	ldr	r2, [r7, #24]
 800c436:	ea48 1802 	orr.w	r8, r8, r2, lsl #4
 800c43a:	ea48 1803 	orr.w	r8, r8, r3, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c43e:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800c442:	61e6      	str	r6, [r4, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800c444:	687b      	ldr	r3, [r7, #4]
 800c446:	63e3      	str	r3, [r4, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c448:	6225      	str	r5, [r4, #32]
}
 800c44a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800c44e:	68fb      	ldr	r3, [r7, #12]
 800c450:	f033 0208 	bics.w	r2, r3, #8
 800c454:	d119      	bne.n	800c48a <TIM_OC3_SetConfig+0xb6>
    tmpccer &= ~TIM_CCER_CC3NP;
 800c456:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800c45a:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 800c45e:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800c462:	69bb      	ldr	r3, [r7, #24]
 800c464:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800c468:	d0de      	beq.n	800c428 <TIM_OC3_SetConfig+0x54>
 800c46a:	f641 01a9 	movw	r1, #6313	; 0x18a9
 800c46e:	4811      	ldr	r0, [pc, #68]	; (800c4b4 <TIM_OC3_SetConfig+0xe0>)
 800c470:	f007 fa2e 	bl	80138d0 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800c474:	697b      	ldr	r3, [r7, #20]
 800c476:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800c47a:	d0d9      	beq.n	800c430 <TIM_OC3_SetConfig+0x5c>
 800c47c:	f641 01aa 	movw	r1, #6314	; 0x18aa
 800c480:	480c      	ldr	r0, [pc, #48]	; (800c4b4 <TIM_OC3_SetConfig+0xe0>)
 800c482:	f007 fa25 	bl	80138d0 <assert_failed>
 800c486:	697b      	ldr	r3, [r7, #20]
 800c488:	e7d2      	b.n	800c430 <TIM_OC3_SetConfig+0x5c>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800c48a:	f641 019c 	movw	r1, #6300	; 0x189c
 800c48e:	4809      	ldr	r0, [pc, #36]	; (800c4b4 <TIM_OC3_SetConfig+0xe0>)
 800c490:	f007 fa1e 	bl	80138d0 <assert_failed>
    tmpccer &= ~TIM_CCER_CC3NP;
 800c494:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
 800c498:	68fb      	ldr	r3, [r7, #12]
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800c49a:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 800c49e:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
 800c4a2:	e7de      	b.n	800c462 <TIM_OC3_SetConfig+0x8e>
 800c4a4:	40010000 	.word	0x40010000
 800c4a8:	40010400 	.word	0x40010400
 800c4ac:	40014000 	.word	0x40014000
 800c4b0:	40014400 	.word	0x40014400
 800c4b4:	08029468 	.word	0x08029468

0800c4b8 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 800c4b8:	2800      	cmp	r0, #0
 800c4ba:	f000 80dd 	beq.w	800c678 <HAL_TIM_Base_Init+0x1c0>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c4be:	4b80      	ldr	r3, [pc, #512]	; (800c6c0 <HAL_TIM_Base_Init+0x208>)
 800c4c0:	4980      	ldr	r1, [pc, #512]	; (800c6c4 <HAL_TIM_Base_Init+0x20c>)
{
 800c4c2:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c4c4:	6802      	ldr	r2, [r0, #0]
 800c4c6:	4604      	mov	r4, r0
 800c4c8:	487f      	ldr	r0, [pc, #508]	; (800c6c8 <HAL_TIM_Base_Init+0x210>)
 800c4ca:	429a      	cmp	r2, r3
 800c4cc:	bf18      	it	ne
 800c4ce:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800c4d2:	4d7e      	ldr	r5, [pc, #504]	; (800c6cc <HAL_TIM_Base_Init+0x214>)
 800c4d4:	bf14      	ite	ne
 800c4d6:	2301      	movne	r3, #1
 800c4d8:	2300      	moveq	r3, #0
 800c4da:	4282      	cmp	r2, r0
 800c4dc:	bf0c      	ite	eq
 800c4de:	2300      	moveq	r3, #0
 800c4e0:	f003 0301 	andne.w	r3, r3, #1
 800c4e4:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
 800c4e8:	428a      	cmp	r2, r1
 800c4ea:	bf0c      	ite	eq
 800c4ec:	2300      	moveq	r3, #0
 800c4ee:	f003 0301 	andne.w	r3, r3, #1
 800c4f2:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
 800c4f6:	42aa      	cmp	r2, r5
 800c4f8:	bf0c      	ite	eq
 800c4fa:	2300      	moveq	r3, #0
 800c4fc:	f003 0301 	andne.w	r3, r3, #1
 800c500:	f505 4578 	add.w	r5, r5, #63488	; 0xf800
 800c504:	4282      	cmp	r2, r0
 800c506:	bf0c      	ite	eq
 800c508:	2300      	moveq	r3, #0
 800c50a:	f003 0301 	andne.w	r3, r3, #1
 800c50e:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 800c512:	428a      	cmp	r2, r1
 800c514:	bf0c      	ite	eq
 800c516:	2300      	moveq	r3, #0
 800c518:	f003 0301 	andne.w	r3, r3, #1
 800c51c:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 800c520:	42aa      	cmp	r2, r5
 800c522:	bf0c      	ite	eq
 800c524:	2300      	moveq	r3, #0
 800c526:	f003 0301 	andne.w	r3, r3, #1
 800c52a:	f5a5 4564 	sub.w	r5, r5, #58368	; 0xe400
 800c52e:	4282      	cmp	r2, r0
 800c530:	bf0c      	ite	eq
 800c532:	2300      	moveq	r3, #0
 800c534:	f003 0301 	andne.w	r3, r3, #1
 800c538:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
 800c53c:	428a      	cmp	r2, r1
 800c53e:	bf0c      	ite	eq
 800c540:	2300      	moveq	r3, #0
 800c542:	f003 0301 	andne.w	r3, r3, #1
 800c546:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
 800c54a:	42aa      	cmp	r2, r5
 800c54c:	bf0c      	ite	eq
 800c54e:	2300      	moveq	r3, #0
 800c550:	f003 0301 	andne.w	r3, r3, #1
 800c554:	4282      	cmp	r2, r0
 800c556:	bf0c      	ite	eq
 800c558:	2300      	moveq	r3, #0
 800c55a:	f003 0301 	andne.w	r3, r3, #1
 800c55e:	428a      	cmp	r2, r1
 800c560:	bf0c      	ite	eq
 800c562:	2300      	moveq	r3, #0
 800c564:	f003 0301 	andne.w	r3, r3, #1
 800c568:	b11b      	cbz	r3, 800c572 <HAL_TIM_Base_Init+0xba>
 800c56a:	4b59      	ldr	r3, [pc, #356]	; (800c6d0 <HAL_TIM_Base_Init+0x218>)
 800c56c:	429a      	cmp	r2, r3
 800c56e:	f040 80a0 	bne.w	800c6b2 <HAL_TIM_Base_Init+0x1fa>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800c572:	68a3      	ldr	r3, [r4, #8]
 800c574:	f023 0140 	bic.w	r1, r3, #64	; 0x40
 800c578:	f023 0210 	bic.w	r2, r3, #16
 800c57c:	2920      	cmp	r1, #32
 800c57e:	bf18      	it	ne
 800c580:	2a00      	cmpne	r2, #0
 800c582:	d002      	beq.n	800c58a <HAL_TIM_Base_Init+0xd2>
 800c584:	2b40      	cmp	r3, #64	; 0x40
 800c586:	f040 8083 	bne.w	800c690 <HAL_TIM_Base_Init+0x1d8>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800c58a:	6923      	ldr	r3, [r4, #16]
 800c58c:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800c590:	d002      	beq.n	800c598 <HAL_TIM_Base_Init+0xe0>
 800c592:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c596:	d171      	bne.n	800c67c <HAL_TIM_Base_Init+0x1c4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800c598:	69a3      	ldr	r3, [r4, #24]
 800c59a:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800c59e:	d15f      	bne.n	800c660 <HAL_TIM_Base_Init+0x1a8>
  if (htim->State == HAL_TIM_STATE_RESET)
 800c5a0:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800c5a4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800c5a8:	2b00      	cmp	r3, #0
 800c5aa:	d053      	beq.n	800c654 <HAL_TIM_Base_Init+0x19c>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800c5ac:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 800c5ae:	2302      	movs	r3, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800c5b0:	4943      	ldr	r1, [pc, #268]	; (800c6c0 <HAL_TIM_Base_Init+0x208>)
 800c5b2:	4d48      	ldr	r5, [pc, #288]	; (800c6d4 <HAL_TIM_Base_Init+0x21c>)
 800c5b4:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800c5b8:	eba2 0101 	sub.w	r1, r2, r1
  htim->State = HAL_TIM_STATE_BUSY;
 800c5bc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
 800c5c0:	eba2 0505 	sub.w	r5, r2, r5
  tmpcr1 = TIMx->CR1;
 800c5c4:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800c5c6:	fab1 f181 	clz	r1, r1
 800c5ca:	fab5 f585 	clz	r5, r5
 800c5ce:	ea4f 1151 	mov.w	r1, r1, lsr #5
 800c5d2:	ea4f 1555 	mov.w	r5, r5, lsr #5
 800c5d6:	d018      	beq.n	800c60a <HAL_TIM_Base_Init+0x152>
 800c5d8:	b9b9      	cbnz	r1, 800c60a <HAL_TIM_Base_Init+0x152>
 800c5da:	483b      	ldr	r0, [pc, #236]	; (800c6c8 <HAL_TIM_Base_Init+0x210>)
 800c5dc:	4282      	cmp	r2, r0
 800c5de:	d014      	beq.n	800c60a <HAL_TIM_Base_Init+0x152>
 800c5e0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800c5e4:	4282      	cmp	r2, r0
 800c5e6:	d010      	beq.n	800c60a <HAL_TIM_Base_Init+0x152>
 800c5e8:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800c5ec:	4282      	cmp	r2, r0
 800c5ee:	d055      	beq.n	800c69c <HAL_TIM_Base_Init+0x1e4>
 800c5f0:	2d00      	cmp	r5, #0
 800c5f2:	d153      	bne.n	800c69c <HAL_TIM_Base_Init+0x1e4>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c5f4:	4e38      	ldr	r6, [pc, #224]	; (800c6d8 <HAL_TIM_Base_Init+0x220>)
 800c5f6:	4839      	ldr	r0, [pc, #228]	; (800c6dc <HAL_TIM_Base_Init+0x224>)
 800c5f8:	4282      	cmp	r2, r0
 800c5fa:	bf18      	it	ne
 800c5fc:	42b2      	cmpne	r2, r6
 800c5fe:	d008      	beq.n	800c612 <HAL_TIM_Base_Init+0x15a>
 800c600:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800c604:	4282      	cmp	r2, r0
 800c606:	d108      	bne.n	800c61a <HAL_TIM_Base_Init+0x162>
 800c608:	e003      	b.n	800c612 <HAL_TIM_Base_Init+0x15a>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800c60a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800c60e:	68a0      	ldr	r0, [r4, #8]
 800c610:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 800c612:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800c616:	6920      	ldr	r0, [r4, #16]
 800c618:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800c61a:	69a0      	ldr	r0, [r4, #24]
 800c61c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800c620:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 800c622:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800c624:	68e3      	ldr	r3, [r4, #12]
 800c626:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800c628:	6863      	ldr	r3, [r4, #4]
 800c62a:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800c62c:	b951      	cbnz	r1, 800c644 <HAL_TIM_Base_Init+0x18c>
 800c62e:	b94d      	cbnz	r5, 800c644 <HAL_TIM_Base_Init+0x18c>
 800c630:	4929      	ldr	r1, [pc, #164]	; (800c6d8 <HAL_TIM_Base_Init+0x220>)
 800c632:	4b2a      	ldr	r3, [pc, #168]	; (800c6dc <HAL_TIM_Base_Init+0x224>)
 800c634:	429a      	cmp	r2, r3
 800c636:	bf18      	it	ne
 800c638:	428a      	cmpne	r2, r1
 800c63a:	d003      	beq.n	800c644 <HAL_TIM_Base_Init+0x18c>
 800c63c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c640:	429a      	cmp	r2, r3
 800c642:	d101      	bne.n	800c648 <HAL_TIM_Base_Init+0x190>
    TIMx->RCR = Structure->RepetitionCounter;
 800c644:	6963      	ldr	r3, [r4, #20]
 800c646:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 800c648:	2301      	movs	r3, #1
  return HAL_OK;
 800c64a:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 800c64c:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 800c64e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 800c652:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
 800c654:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 800c658:	4620      	mov	r0, r4
 800c65a:	f00f fe95 	bl	801c388 <HAL_TIM_Base_MspInit>
 800c65e:	e7a5      	b.n	800c5ac <HAL_TIM_Base_Init+0xf4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800c660:	f44f 718c 	mov.w	r1, #280	; 0x118
 800c664:	481e      	ldr	r0, [pc, #120]	; (800c6e0 <HAL_TIM_Base_Init+0x228>)
 800c666:	f007 f933 	bl	80138d0 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
 800c66a:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800c66e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800c672:	2b00      	cmp	r3, #0
 800c674:	d19a      	bne.n	800c5ac <HAL_TIM_Base_Init+0xf4>
 800c676:	e7ed      	b.n	800c654 <HAL_TIM_Base_Init+0x19c>
    return HAL_ERROR;
 800c678:	2001      	movs	r0, #1
}
 800c67a:	4770      	bx	lr
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800c67c:	f240 1117 	movw	r1, #279	; 0x117
 800c680:	4817      	ldr	r0, [pc, #92]	; (800c6e0 <HAL_TIM_Base_Init+0x228>)
 800c682:	f007 f925 	bl	80138d0 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800c686:	69a3      	ldr	r3, [r4, #24]
 800c688:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800c68c:	d088      	beq.n	800c5a0 <HAL_TIM_Base_Init+0xe8>
 800c68e:	e7e7      	b.n	800c660 <HAL_TIM_Base_Init+0x1a8>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800c690:	f44f 718b 	mov.w	r1, #278	; 0x116
 800c694:	4812      	ldr	r0, [pc, #72]	; (800c6e0 <HAL_TIM_Base_Init+0x228>)
 800c696:	f007 f91b 	bl	80138d0 <assert_failed>
 800c69a:	e776      	b.n	800c58a <HAL_TIM_Base_Init+0xd2>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c69c:	480b      	ldr	r0, [pc, #44]	; (800c6cc <HAL_TIM_Base_Init+0x214>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800c69e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800c6a2:	68a6      	ldr	r6, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c6a4:	4282      	cmp	r2, r0
    tmpcr1 |= Structure->CounterMode;
 800c6a6:	ea43 0306 	orr.w	r3, r3, r6
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c6aa:	d0b2      	beq.n	800c612 <HAL_TIM_Base_Init+0x15a>
 800c6ac:	2d00      	cmp	r5, #0
 800c6ae:	d1b0      	bne.n	800c612 <HAL_TIM_Base_Init+0x15a>
 800c6b0:	e7a0      	b.n	800c5f4 <HAL_TIM_Base_Init+0x13c>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c6b2:	f240 1115 	movw	r1, #277	; 0x115
 800c6b6:	480a      	ldr	r0, [pc, #40]	; (800c6e0 <HAL_TIM_Base_Init+0x228>)
 800c6b8:	f007 f90a 	bl	80138d0 <assert_failed>
 800c6bc:	e759      	b.n	800c572 <HAL_TIM_Base_Init+0xba>
 800c6be:	bf00      	nop
 800c6c0:	40010000 	.word	0x40010000
 800c6c4:	40000800 	.word	0x40000800
 800c6c8:	40000400 	.word	0x40000400
 800c6cc:	40000c00 	.word	0x40000c00
 800c6d0:	40014800 	.word	0x40014800
 800c6d4:	40010400 	.word	0x40010400
 800c6d8:	40014000 	.word	0x40014000
 800c6dc:	40014400 	.word	0x40014400
 800c6e0:	08029468 	.word	0x08029468

0800c6e4 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 800c6e4:	2800      	cmp	r0, #0
 800c6e6:	f000 80dd 	beq.w	800c8a4 <HAL_TIM_PWM_Init+0x1c0>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c6ea:	4b80      	ldr	r3, [pc, #512]	; (800c8ec <HAL_TIM_PWM_Init+0x208>)
 800c6ec:	4980      	ldr	r1, [pc, #512]	; (800c8f0 <HAL_TIM_PWM_Init+0x20c>)
{
 800c6ee:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c6f0:	6802      	ldr	r2, [r0, #0]
 800c6f2:	4604      	mov	r4, r0
 800c6f4:	487f      	ldr	r0, [pc, #508]	; (800c8f4 <HAL_TIM_PWM_Init+0x210>)
 800c6f6:	429a      	cmp	r2, r3
 800c6f8:	bf18      	it	ne
 800c6fa:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800c6fe:	4d7e      	ldr	r5, [pc, #504]	; (800c8f8 <HAL_TIM_PWM_Init+0x214>)
 800c700:	bf14      	ite	ne
 800c702:	2301      	movne	r3, #1
 800c704:	2300      	moveq	r3, #0
 800c706:	4282      	cmp	r2, r0
 800c708:	bf0c      	ite	eq
 800c70a:	2300      	moveq	r3, #0
 800c70c:	f003 0301 	andne.w	r3, r3, #1
 800c710:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
 800c714:	428a      	cmp	r2, r1
 800c716:	bf0c      	ite	eq
 800c718:	2300      	moveq	r3, #0
 800c71a:	f003 0301 	andne.w	r3, r3, #1
 800c71e:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
 800c722:	42aa      	cmp	r2, r5
 800c724:	bf0c      	ite	eq
 800c726:	2300      	moveq	r3, #0
 800c728:	f003 0301 	andne.w	r3, r3, #1
 800c72c:	f505 4578 	add.w	r5, r5, #63488	; 0xf800
 800c730:	4282      	cmp	r2, r0
 800c732:	bf0c      	ite	eq
 800c734:	2300      	moveq	r3, #0
 800c736:	f003 0301 	andne.w	r3, r3, #1
 800c73a:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 800c73e:	428a      	cmp	r2, r1
 800c740:	bf0c      	ite	eq
 800c742:	2300      	moveq	r3, #0
 800c744:	f003 0301 	andne.w	r3, r3, #1
 800c748:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 800c74c:	42aa      	cmp	r2, r5
 800c74e:	bf0c      	ite	eq
 800c750:	2300      	moveq	r3, #0
 800c752:	f003 0301 	andne.w	r3, r3, #1
 800c756:	f5a5 4564 	sub.w	r5, r5, #58368	; 0xe400
 800c75a:	4282      	cmp	r2, r0
 800c75c:	bf0c      	ite	eq
 800c75e:	2300      	moveq	r3, #0
 800c760:	f003 0301 	andne.w	r3, r3, #1
 800c764:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
 800c768:	428a      	cmp	r2, r1
 800c76a:	bf0c      	ite	eq
 800c76c:	2300      	moveq	r3, #0
 800c76e:	f003 0301 	andne.w	r3, r3, #1
 800c772:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
 800c776:	42aa      	cmp	r2, r5
 800c778:	bf0c      	ite	eq
 800c77a:	2300      	moveq	r3, #0
 800c77c:	f003 0301 	andne.w	r3, r3, #1
 800c780:	4282      	cmp	r2, r0
 800c782:	bf0c      	ite	eq
 800c784:	2300      	moveq	r3, #0
 800c786:	f003 0301 	andne.w	r3, r3, #1
 800c78a:	428a      	cmp	r2, r1
 800c78c:	bf0c      	ite	eq
 800c78e:	2300      	moveq	r3, #0
 800c790:	f003 0301 	andne.w	r3, r3, #1
 800c794:	b11b      	cbz	r3, 800c79e <HAL_TIM_PWM_Init+0xba>
 800c796:	4b59      	ldr	r3, [pc, #356]	; (800c8fc <HAL_TIM_PWM_Init+0x218>)
 800c798:	429a      	cmp	r2, r3
 800c79a:	f040 80a0 	bne.w	800c8de <HAL_TIM_PWM_Init+0x1fa>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800c79e:	68a3      	ldr	r3, [r4, #8]
 800c7a0:	f023 0140 	bic.w	r1, r3, #64	; 0x40
 800c7a4:	f023 0210 	bic.w	r2, r3, #16
 800c7a8:	2920      	cmp	r1, #32
 800c7aa:	bf18      	it	ne
 800c7ac:	2a00      	cmpne	r2, #0
 800c7ae:	d002      	beq.n	800c7b6 <HAL_TIM_PWM_Init+0xd2>
 800c7b0:	2b40      	cmp	r3, #64	; 0x40
 800c7b2:	f040 8083 	bne.w	800c8bc <HAL_TIM_PWM_Init+0x1d8>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800c7b6:	6923      	ldr	r3, [r4, #16]
 800c7b8:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800c7bc:	d002      	beq.n	800c7c4 <HAL_TIM_PWM_Init+0xe0>
 800c7be:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c7c2:	d171      	bne.n	800c8a8 <HAL_TIM_PWM_Init+0x1c4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800c7c4:	69a3      	ldr	r3, [r4, #24]
 800c7c6:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800c7ca:	d15f      	bne.n	800c88c <HAL_TIM_PWM_Init+0x1a8>
  if (htim->State == HAL_TIM_STATE_RESET)
 800c7cc:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800c7d0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800c7d4:	2b00      	cmp	r3, #0
 800c7d6:	d053      	beq.n	800c880 <HAL_TIM_PWM_Init+0x19c>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800c7d8:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 800c7da:	2302      	movs	r3, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800c7dc:	4943      	ldr	r1, [pc, #268]	; (800c8ec <HAL_TIM_PWM_Init+0x208>)
 800c7de:	4d48      	ldr	r5, [pc, #288]	; (800c900 <HAL_TIM_PWM_Init+0x21c>)
 800c7e0:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800c7e4:	eba2 0101 	sub.w	r1, r2, r1
  htim->State = HAL_TIM_STATE_BUSY;
 800c7e8:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
 800c7ec:	eba2 0505 	sub.w	r5, r2, r5
  tmpcr1 = TIMx->CR1;
 800c7f0:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800c7f2:	fab1 f181 	clz	r1, r1
 800c7f6:	fab5 f585 	clz	r5, r5
 800c7fa:	ea4f 1151 	mov.w	r1, r1, lsr #5
 800c7fe:	ea4f 1555 	mov.w	r5, r5, lsr #5
 800c802:	d018      	beq.n	800c836 <HAL_TIM_PWM_Init+0x152>
 800c804:	b9b9      	cbnz	r1, 800c836 <HAL_TIM_PWM_Init+0x152>
 800c806:	483b      	ldr	r0, [pc, #236]	; (800c8f4 <HAL_TIM_PWM_Init+0x210>)
 800c808:	4282      	cmp	r2, r0
 800c80a:	d014      	beq.n	800c836 <HAL_TIM_PWM_Init+0x152>
 800c80c:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800c810:	4282      	cmp	r2, r0
 800c812:	d010      	beq.n	800c836 <HAL_TIM_PWM_Init+0x152>
 800c814:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800c818:	4282      	cmp	r2, r0
 800c81a:	d055      	beq.n	800c8c8 <HAL_TIM_PWM_Init+0x1e4>
 800c81c:	2d00      	cmp	r5, #0
 800c81e:	d153      	bne.n	800c8c8 <HAL_TIM_PWM_Init+0x1e4>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c820:	4e38      	ldr	r6, [pc, #224]	; (800c904 <HAL_TIM_PWM_Init+0x220>)
 800c822:	4839      	ldr	r0, [pc, #228]	; (800c908 <HAL_TIM_PWM_Init+0x224>)
 800c824:	4282      	cmp	r2, r0
 800c826:	bf18      	it	ne
 800c828:	42b2      	cmpne	r2, r6
 800c82a:	d008      	beq.n	800c83e <HAL_TIM_PWM_Init+0x15a>
 800c82c:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800c830:	4282      	cmp	r2, r0
 800c832:	d108      	bne.n	800c846 <HAL_TIM_PWM_Init+0x162>
 800c834:	e003      	b.n	800c83e <HAL_TIM_PWM_Init+0x15a>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800c836:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800c83a:	68a0      	ldr	r0, [r4, #8]
 800c83c:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 800c83e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800c842:	6920      	ldr	r0, [r4, #16]
 800c844:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800c846:	69a0      	ldr	r0, [r4, #24]
 800c848:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800c84c:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 800c84e:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800c850:	68e3      	ldr	r3, [r4, #12]
 800c852:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800c854:	6863      	ldr	r3, [r4, #4]
 800c856:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800c858:	b951      	cbnz	r1, 800c870 <HAL_TIM_PWM_Init+0x18c>
 800c85a:	b94d      	cbnz	r5, 800c870 <HAL_TIM_PWM_Init+0x18c>
 800c85c:	4929      	ldr	r1, [pc, #164]	; (800c904 <HAL_TIM_PWM_Init+0x220>)
 800c85e:	4b2a      	ldr	r3, [pc, #168]	; (800c908 <HAL_TIM_PWM_Init+0x224>)
 800c860:	429a      	cmp	r2, r3
 800c862:	bf18      	it	ne
 800c864:	428a      	cmpne	r2, r1
 800c866:	d003      	beq.n	800c870 <HAL_TIM_PWM_Init+0x18c>
 800c868:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c86c:	429a      	cmp	r2, r3
 800c86e:	d101      	bne.n	800c874 <HAL_TIM_PWM_Init+0x190>
    TIMx->RCR = Structure->RepetitionCounter;
 800c870:	6963      	ldr	r3, [r4, #20]
 800c872:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 800c874:	2301      	movs	r3, #1
  return HAL_OK;
 800c876:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 800c878:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 800c87a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 800c87e:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
 800c880:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 800c884:	4620      	mov	r0, r4
 800c886:	f00f fd65 	bl	801c354 <HAL_TIM_PWM_MspInit>
 800c88a:	e7a5      	b.n	800c7d8 <HAL_TIM_PWM_Init+0xf4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800c88c:	f240 41a5 	movw	r1, #1189	; 0x4a5
 800c890:	481e      	ldr	r0, [pc, #120]	; (800c90c <HAL_TIM_PWM_Init+0x228>)
 800c892:	f007 f81d 	bl	80138d0 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
 800c896:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800c89a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800c89e:	2b00      	cmp	r3, #0
 800c8a0:	d19a      	bne.n	800c7d8 <HAL_TIM_PWM_Init+0xf4>
 800c8a2:	e7ed      	b.n	800c880 <HAL_TIM_PWM_Init+0x19c>
    return HAL_ERROR;
 800c8a4:	2001      	movs	r0, #1
}
 800c8a6:	4770      	bx	lr
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800c8a8:	f240 41a4 	movw	r1, #1188	; 0x4a4
 800c8ac:	4817      	ldr	r0, [pc, #92]	; (800c90c <HAL_TIM_PWM_Init+0x228>)
 800c8ae:	f007 f80f 	bl	80138d0 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800c8b2:	69a3      	ldr	r3, [r4, #24]
 800c8b4:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800c8b8:	d088      	beq.n	800c7cc <HAL_TIM_PWM_Init+0xe8>
 800c8ba:	e7e7      	b.n	800c88c <HAL_TIM_PWM_Init+0x1a8>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800c8bc:	f240 41a3 	movw	r1, #1187	; 0x4a3
 800c8c0:	4812      	ldr	r0, [pc, #72]	; (800c90c <HAL_TIM_PWM_Init+0x228>)
 800c8c2:	f007 f805 	bl	80138d0 <assert_failed>
 800c8c6:	e776      	b.n	800c7b6 <HAL_TIM_PWM_Init+0xd2>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c8c8:	480b      	ldr	r0, [pc, #44]	; (800c8f8 <HAL_TIM_PWM_Init+0x214>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800c8ca:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800c8ce:	68a6      	ldr	r6, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c8d0:	4282      	cmp	r2, r0
    tmpcr1 |= Structure->CounterMode;
 800c8d2:	ea43 0306 	orr.w	r3, r3, r6
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c8d6:	d0b2      	beq.n	800c83e <HAL_TIM_PWM_Init+0x15a>
 800c8d8:	2d00      	cmp	r5, #0
 800c8da:	d1b0      	bne.n	800c83e <HAL_TIM_PWM_Init+0x15a>
 800c8dc:	e7a0      	b.n	800c820 <HAL_TIM_PWM_Init+0x13c>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c8de:	f240 41a2 	movw	r1, #1186	; 0x4a2
 800c8e2:	480a      	ldr	r0, [pc, #40]	; (800c90c <HAL_TIM_PWM_Init+0x228>)
 800c8e4:	f006 fff4 	bl	80138d0 <assert_failed>
 800c8e8:	e759      	b.n	800c79e <HAL_TIM_PWM_Init+0xba>
 800c8ea:	bf00      	nop
 800c8ec:	40010000 	.word	0x40010000
 800c8f0:	40000800 	.word	0x40000800
 800c8f4:	40000400 	.word	0x40000400
 800c8f8:	40000c00 	.word	0x40000c00
 800c8fc:	40014800 	.word	0x40014800
 800c900:	40010400 	.word	0x40010400
 800c904:	40014000 	.word	0x40014000
 800c908:	40014400 	.word	0x40014400
 800c90c:	08029468 	.word	0x08029468

0800c910 <HAL_TIM_PWM_Start>:
{
 800c910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800c912:	4b66      	ldr	r3, [pc, #408]	; (800caac <HAL_TIM_PWM_Start+0x19c>)
{
 800c914:	4606      	mov	r6, r0
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800c916:	6804      	ldr	r4, [r0, #0]
{
 800c918:	460d      	mov	r5, r1
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800c91a:	429c      	cmp	r4, r3
 800c91c:	f000 8093 	beq.w	800ca46 <HAL_TIM_PWM_Start+0x136>
 800c920:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 800c924:	f000 8089 	beq.w	800ca3a <HAL_TIM_PWM_Start+0x12a>
 800c928:	4b61      	ldr	r3, [pc, #388]	; (800cab0 <HAL_TIM_PWM_Start+0x1a0>)
 800c92a:	429c      	cmp	r4, r3
 800c92c:	f000 8085 	beq.w	800ca3a <HAL_TIM_PWM_Start+0x12a>
 800c930:	4b60      	ldr	r3, [pc, #384]	; (800cab4 <HAL_TIM_PWM_Start+0x1a4>)
 800c932:	429c      	cmp	r4, r3
 800c934:	f000 8081 	beq.w	800ca3a <HAL_TIM_PWM_Start+0x12a>
 800c938:	4b5f      	ldr	r3, [pc, #380]	; (800cab8 <HAL_TIM_PWM_Start+0x1a8>)
 800c93a:	429c      	cmp	r4, r3
 800c93c:	d07d      	beq.n	800ca3a <HAL_TIM_PWM_Start+0x12a>
 800c93e:	4b5f      	ldr	r3, [pc, #380]	; (800cabc <HAL_TIM_PWM_Start+0x1ac>)
 800c940:	429c      	cmp	r4, r3
 800c942:	f000 8092 	beq.w	800ca6a <HAL_TIM_PWM_Start+0x15a>
 800c946:	4b5e      	ldr	r3, [pc, #376]	; (800cac0 <HAL_TIM_PWM_Start+0x1b0>)
 800c948:	429c      	cmp	r4, r3
 800c94a:	f000 8096 	beq.w	800ca7a <HAL_TIM_PWM_Start+0x16a>
 800c94e:	4b5d      	ldr	r3, [pc, #372]	; (800cac4 <HAL_TIM_PWM_Start+0x1b4>)
 800c950:	429c      	cmp	r4, r3
 800c952:	f040 8097 	bne.w	800ca84 <HAL_TIM_PWM_Start+0x174>
 800c956:	b1d5      	cbz	r5, 800c98e <HAL_TIM_PWM_Start+0x7e>
 800c958:	f240 511c 	movw	r1, #1308	; 0x51c
 800c95c:	485a      	ldr	r0, [pc, #360]	; (800cac8 <HAL_TIM_PWM_Start+0x1b8>)
 800c95e:	f006 ffb7 	bl	80138d0 <assert_failed>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 800c962:	6834      	ldr	r4, [r6, #0]
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
 800c964:	4b51      	ldr	r3, [pc, #324]	; (800caac <HAL_TIM_PWM_Start+0x19c>)
 800c966:	429c      	cmp	r4, r3
 800c968:	d02d      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c96a:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 800c96e:	d02a      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c970:	f5a3 437c 	sub.w	r3, r3, #64512	; 0xfc00
 800c974:	429c      	cmp	r4, r3
 800c976:	d026      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c978:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c97c:	429c      	cmp	r4, r3
 800c97e:	d022      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c980:	4b4d      	ldr	r3, [pc, #308]	; (800cab8 <HAL_TIM_PWM_Start+0x1a8>)
 800c982:	429c      	cmp	r4, r3
 800c984:	d01f      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c986:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 800c98a:	429c      	cmp	r4, r3
 800c98c:	d01b      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c98e:	4b4c      	ldr	r3, [pc, #304]	; (800cac0 <HAL_TIM_PWM_Start+0x1b0>)
 800c990:	429c      	cmp	r4, r3
 800c992:	d018      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c994:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c998:	429c      	cmp	r4, r3
 800c99a:	d014      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c99c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c9a0:	429c      	cmp	r4, r3
 800c9a2:	d010      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c9a4:	f503 3390 	add.w	r3, r3, #73728	; 0x12000
 800c9a8:	429c      	cmp	r4, r3
 800c9aa:	d00c      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c9ac:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c9b0:	429c      	cmp	r4, r3
 800c9b2:	d008      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c9b4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c9b8:	429c      	cmp	r4, r3
 800c9ba:	d004      	beq.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800c9bc:	f641 3154 	movw	r1, #6996	; 0x1b54
 800c9c0:	4841      	ldr	r0, [pc, #260]	; (800cac8 <HAL_TIM_PWM_Start+0x1b8>)
 800c9c2:	f006 ff85 	bl	80138d0 <assert_failed>
  assert_param(IS_TIM_CHANNELS(Channel));
 800c9c6:	2d14      	cmp	r5, #20
 800c9c8:	d943      	bls.n	800ca52 <HAL_TIM_PWM_Start+0x142>
 800c9ca:	2d3c      	cmp	r5, #60	; 0x3c
 800c9cc:	d147      	bne.n	800ca5e <HAL_TIM_PWM_Start+0x14e>

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800c9ce:	2301      	movs	r3, #1
 800c9d0:	f005 051f 	and.w	r5, r5, #31

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 800c9d4:	6a21      	ldr	r1, [r4, #32]
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800c9d6:	fa03 f505 	lsl.w	r5, r3, r5
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800c9da:	4a34      	ldr	r2, [pc, #208]	; (800caac <HAL_TIM_PWM_Start+0x19c>)
 800c9dc:	4f37      	ldr	r7, [pc, #220]	; (800cabc <HAL_TIM_PWM_Start+0x1ac>)
  TIMx->CCER &= ~tmp;
 800c9de:	ea21 0105 	bic.w	r1, r1, r5
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800c9e2:	483a      	ldr	r0, [pc, #232]	; (800cacc <HAL_TIM_PWM_Start+0x1bc>)
  TIMx->CCER &= ~tmp;
 800c9e4:	6221      	str	r1, [r4, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 800c9e6:	6a23      	ldr	r3, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800c9e8:	4939      	ldr	r1, [pc, #228]	; (800cad0 <HAL_TIM_PWM_Start+0x1c0>)
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 800c9ea:	431d      	orrs	r5, r3
 800c9ec:	6225      	str	r5, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800c9ee:	6833      	ldr	r3, [r6, #0]
 800c9f0:	42bb      	cmp	r3, r7
 800c9f2:	bf18      	it	ne
 800c9f4:	4293      	cmpne	r3, r2
 800c9f6:	bf0c      	ite	eq
 800c9f8:	2201      	moveq	r2, #1
 800c9fa:	2200      	movne	r2, #0
 800c9fc:	4283      	cmp	r3, r0
 800c9fe:	bf08      	it	eq
 800ca00:	f042 0201 	orreq.w	r2, r2, #1
 800ca04:	428b      	cmp	r3, r1
 800ca06:	bf08      	it	eq
 800ca08:	f042 0201 	orreq.w	r2, r2, #1
 800ca0c:	b912      	cbnz	r2, 800ca14 <HAL_TIM_PWM_Start+0x104>
 800ca0e:	4a31      	ldr	r2, [pc, #196]	; (800cad4 <HAL_TIM_PWM_Start+0x1c4>)
 800ca10:	4293      	cmp	r3, r2
 800ca12:	d104      	bne.n	800ca1e <HAL_TIM_PWM_Start+0x10e>
    __HAL_TIM_MOE_ENABLE(htim);
 800ca14:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800ca16:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800ca1a:	645a      	str	r2, [r3, #68]	; 0x44
 800ca1c:	6833      	ldr	r3, [r6, #0]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800ca1e:	6899      	ldr	r1, [r3, #8]
 800ca20:	4a2d      	ldr	r2, [pc, #180]	; (800cad8 <HAL_TIM_PWM_Start+0x1c8>)
 800ca22:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800ca24:	2a06      	cmp	r2, #6
 800ca26:	d006      	beq.n	800ca36 <HAL_TIM_PWM_Start+0x126>
 800ca28:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800ca2c:	d003      	beq.n	800ca36 <HAL_TIM_PWM_Start+0x126>
    __HAL_TIM_ENABLE(htim);
 800ca2e:	681a      	ldr	r2, [r3, #0]
 800ca30:	f042 0201 	orr.w	r2, r2, #1
 800ca34:	601a      	str	r2, [r3, #0]
}
 800ca36:	2000      	movs	r0, #0
 800ca38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800ca3a:	f035 030c 	bics.w	r3, r5, #12
 800ca3e:	d18b      	bne.n	800c958 <HAL_TIM_PWM_Start+0x48>
  assert_param(IS_TIM_CHANNELS(Channel));
 800ca40:	2d14      	cmp	r5, #20
 800ca42:	d8c2      	bhi.n	800c9ca <HAL_TIM_PWM_Start+0xba>
 800ca44:	e005      	b.n	800ca52 <HAL_TIM_PWM_Start+0x142>
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800ca46:	2914      	cmp	r1, #20
 800ca48:	d886      	bhi.n	800c958 <HAL_TIM_PWM_Start+0x48>
 800ca4a:	4b24      	ldr	r3, [pc, #144]	; (800cadc <HAL_TIM_PWM_Start+0x1cc>)
 800ca4c:	40cb      	lsrs	r3, r1
 800ca4e:	07d9      	lsls	r1, r3, #31
 800ca50:	d582      	bpl.n	800c958 <HAL_TIM_PWM_Start+0x48>
  assert_param(IS_TIM_CHANNELS(Channel));
 800ca52:	4b22      	ldr	r3, [pc, #136]	; (800cadc <HAL_TIM_PWM_Start+0x1cc>)
 800ca54:	40eb      	lsrs	r3, r5
 800ca56:	07db      	lsls	r3, r3, #31
 800ca58:	d4b9      	bmi.n	800c9ce <HAL_TIM_PWM_Start+0xbe>
 800ca5a:	2d3c      	cmp	r5, #60	; 0x3c
 800ca5c:	d0b7      	beq.n	800c9ce <HAL_TIM_PWM_Start+0xbe>
 800ca5e:	f641 3155 	movw	r1, #6997	; 0x1b55
 800ca62:	4819      	ldr	r0, [pc, #100]	; (800cac8 <HAL_TIM_PWM_Start+0x1b8>)
 800ca64:	f006 ff34 	bl	80138d0 <assert_failed>
 800ca68:	e7b1      	b.n	800c9ce <HAL_TIM_PWM_Start+0xbe>
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800ca6a:	2914      	cmp	r1, #20
 800ca6c:	f63f af74 	bhi.w	800c958 <HAL_TIM_PWM_Start+0x48>
 800ca70:	4b1a      	ldr	r3, [pc, #104]	; (800cadc <HAL_TIM_PWM_Start+0x1cc>)
 800ca72:	40cb      	lsrs	r3, r1
 800ca74:	07da      	lsls	r2, r3, #31
 800ca76:	d4a6      	bmi.n	800c9c6 <HAL_TIM_PWM_Start+0xb6>
 800ca78:	e76e      	b.n	800c958 <HAL_TIM_PWM_Start+0x48>
 800ca7a:	f035 0304 	bics.w	r3, r5, #4
 800ca7e:	f47f af6b 	bne.w	800c958 <HAL_TIM_PWM_Start+0x48>
 800ca82:	e784      	b.n	800c98e <HAL_TIM_PWM_Start+0x7e>
 800ca84:	4b16      	ldr	r3, [pc, #88]	; (800cae0 <HAL_TIM_PWM_Start+0x1d0>)
 800ca86:	429c      	cmp	r4, r3
 800ca88:	f43f af65 	beq.w	800c956 <HAL_TIM_PWM_Start+0x46>
 800ca8c:	4b0f      	ldr	r3, [pc, #60]	; (800cacc <HAL_TIM_PWM_Start+0x1bc>)
 800ca8e:	429c      	cmp	r4, r3
 800ca90:	d0f3      	beq.n	800ca7a <HAL_TIM_PWM_Start+0x16a>
 800ca92:	4b0f      	ldr	r3, [pc, #60]	; (800cad0 <HAL_TIM_PWM_Start+0x1c0>)
 800ca94:	429c      	cmp	r4, r3
 800ca96:	f43f af5e 	beq.w	800c956 <HAL_TIM_PWM_Start+0x46>
 800ca9a:	4b0e      	ldr	r3, [pc, #56]	; (800cad4 <HAL_TIM_PWM_Start+0x1c4>)
 800ca9c:	429c      	cmp	r4, r3
 800ca9e:	f47f af5b 	bne.w	800c958 <HAL_TIM_PWM_Start+0x48>
 800caa2:	2900      	cmp	r1, #0
 800caa4:	f47f af58 	bne.w	800c958 <HAL_TIM_PWM_Start+0x48>
 800caa8:	461c      	mov	r4, r3
 800caaa:	e769      	b.n	800c980 <HAL_TIM_PWM_Start+0x70>
 800caac:	40010000 	.word	0x40010000
 800cab0:	40000400 	.word	0x40000400
 800cab4:	40000800 	.word	0x40000800
 800cab8:	40000c00 	.word	0x40000c00
 800cabc:	40010400 	.word	0x40010400
 800cac0:	40001800 	.word	0x40001800
 800cac4:	40001c00 	.word	0x40001c00
 800cac8:	08029468 	.word	0x08029468
 800cacc:	40014000 	.word	0x40014000
 800cad0:	40014400 	.word	0x40014400
 800cad4:	40014800 	.word	0x40014800
 800cad8:	00010007 	.word	0x00010007
 800cadc:	00111111 	.word	0x00111111
 800cae0:	40002000 	.word	0x40002000

0800cae4 <HAL_TIM_ConfigClockSource>:
{
 800cae4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
 800cae6:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800caea:	2b01      	cmp	r3, #1
 800caec:	f000 8186 	beq.w	800cdfc <HAL_TIM_ConfigClockSource+0x318>
 800caf0:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800caf2:	2302      	movs	r3, #2
 800caf4:	460d      	mov	r5, r1
 800caf6:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
 800caf8:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 800cafc:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
 800cb00:	680b      	ldr	r3, [r1, #0]
 800cb02:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800cb06:	bf18      	it	ne
 800cb08:	f5b3 5f00 	cmpne.w	r3, #8192	; 0x2000
 800cb0c:	bf14      	ite	ne
 800cb0e:	2201      	movne	r2, #1
 800cb10:	2200      	moveq	r2, #0
 800cb12:	f033 0330 	bics.w	r3, r3, #48	; 0x30
 800cb16:	bf08      	it	eq
 800cb18:	2200      	moveq	r2, #0
 800cb1a:	b112      	cbz	r2, 800cb22 <HAL_TIM_ConfigClockSource+0x3e>
 800cb1c:	2b40      	cmp	r3, #64	; 0x40
 800cb1e:	f040 8262 	bne.w	800cfe6 <HAL_TIM_ConfigClockSource+0x502>
  tmpsmcr = htim->Instance->SMCR;
 800cb22:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800cb24:	4bb6      	ldr	r3, [pc, #728]	; (800ce00 <HAL_TIM_ConfigClockSource+0x31c>)
  tmpsmcr = htim->Instance->SMCR;
 800cb26:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800cb28:	400b      	ands	r3, r1
  htim->Instance->SMCR = tmpsmcr;
 800cb2a:	6093      	str	r3, [r2, #8]
  switch (sClockSourceConfig->ClockSource)
 800cb2c:	682b      	ldr	r3, [r5, #0]
 800cb2e:	2b70      	cmp	r3, #112	; 0x70
 800cb30:	f000 8178 	beq.w	800ce24 <HAL_TIM_ConfigClockSource+0x340>
 800cb34:	d85c      	bhi.n	800cbf0 <HAL_TIM_ConfigClockSource+0x10c>
 800cb36:	2b30      	cmp	r3, #48	; 0x30
 800cb38:	f000 820f 	beq.w	800cf5a <HAL_TIM_ConfigClockSource+0x476>
 800cb3c:	f240 8206 	bls.w	800cf4c <HAL_TIM_ConfigClockSource+0x468>
 800cb40:	2b50      	cmp	r3, #80	; 0x50
 800cb42:	f000 81b4 	beq.w	800ceae <HAL_TIM_ConfigClockSource+0x3ca>
 800cb46:	2b60      	cmp	r3, #96	; 0x60
 800cb48:	f000 80c3 	beq.w	800ccd2 <HAL_TIM_ConfigClockSource+0x1ee>
 800cb4c:	2b40      	cmp	r3, #64	; 0x40
 800cb4e:	f040 80b8 	bne.w	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800cb52:	6822      	ldr	r2, [r4, #0]
 800cb54:	4bab      	ldr	r3, [pc, #684]	; (800ce04 <HAL_TIM_ConfigClockSource+0x320>)
 800cb56:	48ac      	ldr	r0, [pc, #688]	; (800ce08 <HAL_TIM_ConfigClockSource+0x324>)
 800cb58:	429a      	cmp	r2, r3
 800cb5a:	bf18      	it	ne
 800cb5c:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800cb60:	49aa      	ldr	r1, [pc, #680]	; (800ce0c <HAL_TIM_ConfigClockSource+0x328>)
 800cb62:	bf14      	ite	ne
 800cb64:	2301      	movne	r3, #1
 800cb66:	2300      	moveq	r3, #0
 800cb68:	4282      	cmp	r2, r0
 800cb6a:	bf0c      	ite	eq
 800cb6c:	2300      	moveq	r3, #0
 800cb6e:	f003 0301 	andne.w	r3, r3, #1
 800cb72:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 800cb76:	428a      	cmp	r2, r1
 800cb78:	bf0c      	ite	eq
 800cb7a:	2300      	moveq	r3, #0
 800cb7c:	f003 0301 	andne.w	r3, r3, #1
 800cb80:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
 800cb84:	4282      	cmp	r2, r0
 800cb86:	bf0c      	ite	eq
 800cb88:	2300      	moveq	r3, #0
 800cb8a:	f003 0301 	andne.w	r3, r3, #1
 800cb8e:	428a      	cmp	r2, r1
 800cb90:	bf0c      	ite	eq
 800cb92:	2300      	moveq	r3, #0
 800cb94:	f003 0301 	andne.w	r3, r3, #1
 800cb98:	b11b      	cbz	r3, 800cba2 <HAL_TIM_ConfigClockSource+0xbe>
 800cb9a:	4b9d      	ldr	r3, [pc, #628]	; (800ce10 <HAL_TIM_ConfigClockSource+0x32c>)
 800cb9c:	429a      	cmp	r2, r3
 800cb9e:	f040 825a 	bne.w	800d056 <HAL_TIM_ConfigClockSource+0x572>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800cba2:	686b      	ldr	r3, [r5, #4]
 800cba4:	2b0a      	cmp	r3, #10
 800cba6:	bf18      	it	ne
 800cba8:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800cbac:	d003      	beq.n	800cbb6 <HAL_TIM_ConfigClockSource+0xd2>
 800cbae:	f033 0302 	bics.w	r3, r3, #2
 800cbb2:	f040 821e 	bne.w	800cff2 <HAL_TIM_ConfigClockSource+0x50e>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800cbb6:	68ee      	ldr	r6, [r5, #12]
 800cbb8:	2e0f      	cmp	r6, #15
 800cbba:	f200 826e 	bhi.w	800d09a <HAL_TIM_ConfigClockSource+0x5b6>
      TIM_TI1_ConfigInputStage(htim->Instance,
 800cbbe:	6823      	ldr	r3, [r4, #0]
 800cbc0:	6868      	ldr	r0, [r5, #4]
  tmpccer = TIMx->CCER;
 800cbc2:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800cbc4:	6a1d      	ldr	r5, [r3, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800cbc6:	f022 020a 	bic.w	r2, r2, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800cbca:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
 800cbce:	4310      	orrs	r0, r2
  tmpsmcr &= ~TIM_SMCR_TS;
 800cbd0:	4a90      	ldr	r2, [pc, #576]	; (800ce14 <HAL_TIM_ConfigClockSource+0x330>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800cbd2:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800cbd4:	6999      	ldr	r1, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800cbd6:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800cbda:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 800cbde:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 800cbe0:	6218      	str	r0, [r3, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 800cbe2:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = TIMx->SMCR;
 800cbe4:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800cbe6:	400a      	ands	r2, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800cbe8:	f042 0247 	orr.w	r2, r2, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
 800cbec:	609a      	str	r2, [r3, #8]
 800cbee:	e068      	b.n	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
  switch (sClockSourceConfig->ClockSource)
 800cbf0:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
 800cbf4:	f000 81b1 	beq.w	800cf5a <HAL_TIM_ConfigClockSource+0x476>
 800cbf8:	f200 81de 	bhi.w	800cfb8 <HAL_TIM_ConfigClockSource+0x4d4>
 800cbfc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800cc00:	f000 80b7 	beq.w	800cd72 <HAL_TIM_ConfigClockSource+0x28e>
 800cc04:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800cc08:	f000 81a7 	beq.w	800cf5a <HAL_TIM_ConfigClockSource+0x476>
 800cc0c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800cc10:	d157      	bne.n	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
 800cc12:	6822      	ldr	r2, [r4, #0]
 800cc14:	4b7b      	ldr	r3, [pc, #492]	; (800ce04 <HAL_TIM_ConfigClockSource+0x320>)
 800cc16:	487c      	ldr	r0, [pc, #496]	; (800ce08 <HAL_TIM_ConfigClockSource+0x324>)
 800cc18:	429a      	cmp	r2, r3
 800cc1a:	bf18      	it	ne
 800cc1c:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800cc20:	497a      	ldr	r1, [pc, #488]	; (800ce0c <HAL_TIM_ConfigClockSource+0x328>)
 800cc22:	4d7d      	ldr	r5, [pc, #500]	; (800ce18 <HAL_TIM_ConfigClockSource+0x334>)
 800cc24:	bf14      	ite	ne
 800cc26:	2301      	movne	r3, #1
 800cc28:	2300      	moveq	r3, #0
 800cc2a:	4282      	cmp	r2, r0
 800cc2c:	bf0c      	ite	eq
 800cc2e:	2300      	moveq	r3, #0
 800cc30:	f003 0301 	andne.w	r3, r3, #1
 800cc34:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
 800cc38:	428a      	cmp	r2, r1
 800cc3a:	bf0c      	ite	eq
 800cc3c:	2300      	moveq	r3, #0
 800cc3e:	f003 0301 	andne.w	r3, r3, #1
 800cc42:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
 800cc46:	42aa      	cmp	r2, r5
 800cc48:	bf0c      	ite	eq
 800cc4a:	2300      	moveq	r3, #0
 800cc4c:	f003 0301 	andne.w	r3, r3, #1
 800cc50:	f505 4578 	add.w	r5, r5, #63488	; 0xf800
 800cc54:	4282      	cmp	r2, r0
 800cc56:	bf0c      	ite	eq
 800cc58:	2300      	moveq	r3, #0
 800cc5a:	f003 0301 	andne.w	r3, r3, #1
 800cc5e:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 800cc62:	428a      	cmp	r2, r1
 800cc64:	bf0c      	ite	eq
 800cc66:	2300      	moveq	r3, #0
 800cc68:	f003 0301 	andne.w	r3, r3, #1
 800cc6c:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 800cc70:	42aa      	cmp	r2, r5
 800cc72:	bf0c      	ite	eq
 800cc74:	2300      	moveq	r3, #0
 800cc76:	f003 0301 	andne.w	r3, r3, #1
 800cc7a:	f5a5 4564 	sub.w	r5, r5, #58368	; 0xe400
 800cc7e:	4282      	cmp	r2, r0
 800cc80:	bf0c      	ite	eq
 800cc82:	2300      	moveq	r3, #0
 800cc84:	f003 0301 	andne.w	r3, r3, #1
 800cc88:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
 800cc8c:	428a      	cmp	r2, r1
 800cc8e:	bf0c      	ite	eq
 800cc90:	2300      	moveq	r3, #0
 800cc92:	f003 0301 	andne.w	r3, r3, #1
 800cc96:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
 800cc9a:	42aa      	cmp	r2, r5
 800cc9c:	bf0c      	ite	eq
 800cc9e:	2300      	moveq	r3, #0
 800cca0:	f003 0301 	andne.w	r3, r3, #1
 800cca4:	4282      	cmp	r2, r0
 800cca6:	bf0c      	ite	eq
 800cca8:	2300      	moveq	r3, #0
 800ccaa:	f003 0301 	andne.w	r3, r3, #1
 800ccae:	428a      	cmp	r2, r1
 800ccb0:	bf0c      	ite	eq
 800ccb2:	2300      	moveq	r3, #0
 800ccb4:	f003 0301 	andne.w	r3, r3, #1
 800ccb8:	b11b      	cbz	r3, 800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
 800ccba:	4b58      	ldr	r3, [pc, #352]	; (800ce1c <HAL_TIM_ConfigClockSource+0x338>)
 800ccbc:	429a      	cmp	r2, r3
 800ccbe:	f040 81ff 	bne.w	800d0c0 <HAL_TIM_ConfigClockSource+0x5dc>
  __HAL_UNLOCK(htim);
 800ccc2:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 800ccc4:	2201      	movs	r2, #1
  return HAL_OK;
 800ccc6:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 800ccc8:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800cccc:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800ccd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800ccd2:	6822      	ldr	r2, [r4, #0]
 800ccd4:	4b4b      	ldr	r3, [pc, #300]	; (800ce04 <HAL_TIM_ConfigClockSource+0x320>)
 800ccd6:	484c      	ldr	r0, [pc, #304]	; (800ce08 <HAL_TIM_ConfigClockSource+0x324>)
 800ccd8:	429a      	cmp	r2, r3
 800ccda:	bf18      	it	ne
 800ccdc:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800cce0:	494a      	ldr	r1, [pc, #296]	; (800ce0c <HAL_TIM_ConfigClockSource+0x328>)
 800cce2:	bf14      	ite	ne
 800cce4:	2301      	movne	r3, #1
 800cce6:	2300      	moveq	r3, #0
 800cce8:	4282      	cmp	r2, r0
 800ccea:	bf0c      	ite	eq
 800ccec:	2300      	moveq	r3, #0
 800ccee:	f003 0301 	andne.w	r3, r3, #1
 800ccf2:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 800ccf6:	428a      	cmp	r2, r1
 800ccf8:	bf0c      	ite	eq
 800ccfa:	2300      	moveq	r3, #0
 800ccfc:	f003 0301 	andne.w	r3, r3, #1
 800cd00:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
 800cd04:	4282      	cmp	r2, r0
 800cd06:	bf0c      	ite	eq
 800cd08:	2300      	moveq	r3, #0
 800cd0a:	f003 0301 	andne.w	r3, r3, #1
 800cd0e:	428a      	cmp	r2, r1
 800cd10:	bf0c      	ite	eq
 800cd12:	2300      	moveq	r3, #0
 800cd14:	f003 0301 	andne.w	r3, r3, #1
 800cd18:	b11b      	cbz	r3, 800cd22 <HAL_TIM_ConfigClockSource+0x23e>
 800cd1a:	4b3d      	ldr	r3, [pc, #244]	; (800ce10 <HAL_TIM_ConfigClockSource+0x32c>)
 800cd1c:	429a      	cmp	r2, r3
 800cd1e:	f040 8194 	bne.w	800d04a <HAL_TIM_ConfigClockSource+0x566>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800cd22:	686b      	ldr	r3, [r5, #4]
 800cd24:	2b0a      	cmp	r3, #10
 800cd26:	bf18      	it	ne
 800cd28:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800cd2c:	d003      	beq.n	800cd36 <HAL_TIM_ConfigClockSource+0x252>
 800cd2e:	f033 0302 	bics.w	r3, r3, #2
 800cd32:	f040 8164 	bne.w	800cffe <HAL_TIM_ConfigClockSource+0x51a>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800cd36:	68ee      	ldr	r6, [r5, #12]
 800cd38:	2e0f      	cmp	r6, #15
 800cd3a:	f200 81a7 	bhi.w	800d08c <HAL_TIM_ConfigClockSource+0x5a8>
      TIM_TI2_ConfigInputStage(htim->Instance,
 800cd3e:	6823      	ldr	r3, [r4, #0]
 800cd40:	686f      	ldr	r7, [r5, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800cd42:	6a1d      	ldr	r5, [r3, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
 800cd44:	4a33      	ldr	r2, [pc, #204]	; (800ce14 <HAL_TIM_ConfigClockSource+0x330>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800cd46:	f025 0510 	bic.w	r5, r5, #16
 800cd4a:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800cd4c:	6998      	ldr	r0, [r3, #24]
  tmpccer = TIMx->CCER;
 800cd4e:	6a19      	ldr	r1, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800cd50:	f420 4070 	bic.w	r0, r0, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800cd54:	f021 01a0 	bic.w	r1, r1, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800cd58:	ea40 3006 	orr.w	r0, r0, r6, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
 800cd5c:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
 800cd60:	6198      	str	r0, [r3, #24]
  TIMx->CCER = tmpccer;
 800cd62:	6219      	str	r1, [r3, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 800cd64:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = TIMx->SMCR;
 800cd66:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800cd68:	400a      	ands	r2, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800cd6a:	f042 0267 	orr.w	r2, r2, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
 800cd6e:	609a      	str	r2, [r3, #8]
 800cd70:	e7a7      	b.n	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
 800cd72:	6822      	ldr	r2, [r4, #0]
 800cd74:	4b23      	ldr	r3, [pc, #140]	; (800ce04 <HAL_TIM_ConfigClockSource+0x320>)
 800cd76:	4924      	ldr	r1, [pc, #144]	; (800ce08 <HAL_TIM_ConfigClockSource+0x324>)
 800cd78:	429a      	cmp	r2, r3
 800cd7a:	bf18      	it	ne
 800cd7c:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800cd80:	4822      	ldr	r0, [pc, #136]	; (800ce0c <HAL_TIM_ConfigClockSource+0x328>)
 800cd82:	bf14      	ite	ne
 800cd84:	2301      	movne	r3, #1
 800cd86:	2300      	moveq	r3, #0
 800cd88:	428a      	cmp	r2, r1
 800cd8a:	bf0c      	ite	eq
 800cd8c:	2300      	moveq	r3, #0
 800cd8e:	f003 0301 	andne.w	r3, r3, #1
 800cd92:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 800cd96:	4282      	cmp	r2, r0
 800cd98:	bf0c      	ite	eq
 800cd9a:	2300      	moveq	r3, #0
 800cd9c:	f003 0301 	andne.w	r3, r3, #1
 800cda0:	428a      	cmp	r2, r1
 800cda2:	bf0c      	ite	eq
 800cda4:	2300      	moveq	r3, #0
 800cda6:	f003 0301 	andne.w	r3, r3, #1
 800cdaa:	b11b      	cbz	r3, 800cdb4 <HAL_TIM_ConfigClockSource+0x2d0>
 800cdac:	4b1c      	ldr	r3, [pc, #112]	; (800ce20 <HAL_TIM_ConfigClockSource+0x33c>)
 800cdae:	429a      	cmp	r2, r3
 800cdb0:	f040 810d 	bne.w	800cfce <HAL_TIM_ConfigClockSource+0x4ea>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800cdb4:	68ab      	ldr	r3, [r5, #8]
 800cdb6:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
 800cdba:	f040 8175 	bne.w	800d0a8 <HAL_TIM_ConfigClockSource+0x5c4>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800cdbe:	686b      	ldr	r3, [r5, #4]
 800cdc0:	2b0a      	cmp	r3, #10
 800cdc2:	bf18      	it	ne
 800cdc4:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800cdc8:	d003      	beq.n	800cdd2 <HAL_TIM_ConfigClockSource+0x2ee>
 800cdca:	f033 0302 	bics.w	r3, r3, #2
 800cdce:	f040 8122 	bne.w	800d016 <HAL_TIM_ConfigClockSource+0x532>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800cdd2:	68e9      	ldr	r1, [r5, #12]
 800cdd4:	290f      	cmp	r1, #15
 800cdd6:	f200 8144 	bhi.w	800d062 <HAL_TIM_ConfigClockSource+0x57e>
      TIM_ETR_SetConfig(htim->Instance,
 800cdda:	6820      	ldr	r0, [r4, #0]
 800cddc:	68ab      	ldr	r3, [r5, #8]
  tmpsmcr = TIMx->SMCR;
 800cdde:	6882      	ldr	r2, [r0, #8]
 800cde0:	686d      	ldr	r5, [r5, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800cde2:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 800cde6:	432b      	orrs	r3, r5
 800cde8:	4313      	orrs	r3, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800cdea:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  TIMx->SMCR = tmpsmcr;
 800cdee:	6083      	str	r3, [r0, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800cdf0:	6822      	ldr	r2, [r4, #0]
 800cdf2:	6893      	ldr	r3, [r2, #8]
 800cdf4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800cdf8:	6093      	str	r3, [r2, #8]
      break;
 800cdfa:	e762      	b.n	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
  __HAL_LOCK(htim);
 800cdfc:	2002      	movs	r0, #2
}
 800cdfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ce00:	ffce0088 	.word	0xffce0088
 800ce04:	40010000 	.word	0x40010000
 800ce08:	40000400 	.word	0x40000400
 800ce0c:	40000800 	.word	0x40000800
 800ce10:	40014000 	.word	0x40014000
 800ce14:	ffcfff8f 	.word	0xffcfff8f
 800ce18:	40000c00 	.word	0x40000c00
 800ce1c:	40014800 	.word	0x40014800
 800ce20:	40010400 	.word	0x40010400
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
 800ce24:	6822      	ldr	r2, [r4, #0]
 800ce26:	4ba9      	ldr	r3, [pc, #676]	; (800d0cc <HAL_TIM_ConfigClockSource+0x5e8>)
 800ce28:	49a9      	ldr	r1, [pc, #676]	; (800d0d0 <HAL_TIM_ConfigClockSource+0x5ec>)
 800ce2a:	429a      	cmp	r2, r3
 800ce2c:	bf18      	it	ne
 800ce2e:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800ce32:	48a8      	ldr	r0, [pc, #672]	; (800d0d4 <HAL_TIM_ConfigClockSource+0x5f0>)
 800ce34:	bf14      	ite	ne
 800ce36:	2301      	movne	r3, #1
 800ce38:	2300      	moveq	r3, #0
 800ce3a:	428a      	cmp	r2, r1
 800ce3c:	bf0c      	ite	eq
 800ce3e:	2300      	moveq	r3, #0
 800ce40:	f003 0301 	andne.w	r3, r3, #1
 800ce44:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 800ce48:	4282      	cmp	r2, r0
 800ce4a:	bf0c      	ite	eq
 800ce4c:	2300      	moveq	r3, #0
 800ce4e:	f003 0301 	andne.w	r3, r3, #1
 800ce52:	428a      	cmp	r2, r1
 800ce54:	bf0c      	ite	eq
 800ce56:	2300      	moveq	r3, #0
 800ce58:	f003 0301 	andne.w	r3, r3, #1
 800ce5c:	b11b      	cbz	r3, 800ce66 <HAL_TIM_ConfigClockSource+0x382>
 800ce5e:	4b9e      	ldr	r3, [pc, #632]	; (800d0d8 <HAL_TIM_ConfigClockSource+0x5f4>)
 800ce60:	429a      	cmp	r2, r3
 800ce62:	f040 80ba 	bne.w	800cfda <HAL_TIM_ConfigClockSource+0x4f6>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800ce66:	68ab      	ldr	r3, [r5, #8]
 800ce68:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
 800ce6c:	f040 8122 	bne.w	800d0b4 <HAL_TIM_ConfigClockSource+0x5d0>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800ce70:	686b      	ldr	r3, [r5, #4]
 800ce72:	2b0a      	cmp	r3, #10
 800ce74:	bf18      	it	ne
 800ce76:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800ce7a:	d003      	beq.n	800ce84 <HAL_TIM_ConfigClockSource+0x3a0>
 800ce7c:	f033 0302 	bics.w	r3, r3, #2
 800ce80:	f040 80c3 	bne.w	800d00a <HAL_TIM_ConfigClockSource+0x526>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800ce84:	68e9      	ldr	r1, [r5, #12]
 800ce86:	290f      	cmp	r1, #15
 800ce88:	f200 80f9 	bhi.w	800d07e <HAL_TIM_ConfigClockSource+0x59a>
      TIM_ETR_SetConfig(htim->Instance,
 800ce8c:	6820      	ldr	r0, [r4, #0]
 800ce8e:	68ab      	ldr	r3, [r5, #8]
  tmpsmcr = TIMx->SMCR;
 800ce90:	6882      	ldr	r2, [r0, #8]
 800ce92:	686d      	ldr	r5, [r5, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800ce94:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 800ce98:	432b      	orrs	r3, r5
 800ce9a:	4313      	orrs	r3, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800ce9c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  TIMx->SMCR = tmpsmcr;
 800cea0:	6083      	str	r3, [r0, #8]
      tmpsmcr = htim->Instance->SMCR;
 800cea2:	6822      	ldr	r2, [r4, #0]
 800cea4:	6893      	ldr	r3, [r2, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800cea6:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
 800ceaa:	6093      	str	r3, [r2, #8]
      break;
 800ceac:	e709      	b.n	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800ceae:	6822      	ldr	r2, [r4, #0]
 800ceb0:	4b86      	ldr	r3, [pc, #536]	; (800d0cc <HAL_TIM_ConfigClockSource+0x5e8>)
 800ceb2:	4887      	ldr	r0, [pc, #540]	; (800d0d0 <HAL_TIM_ConfigClockSource+0x5ec>)
 800ceb4:	429a      	cmp	r2, r3
 800ceb6:	bf18      	it	ne
 800ceb8:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800cebc:	4985      	ldr	r1, [pc, #532]	; (800d0d4 <HAL_TIM_ConfigClockSource+0x5f0>)
 800cebe:	bf14      	ite	ne
 800cec0:	2301      	movne	r3, #1
 800cec2:	2300      	moveq	r3, #0
 800cec4:	4282      	cmp	r2, r0
 800cec6:	bf0c      	ite	eq
 800cec8:	2300      	moveq	r3, #0
 800ceca:	f003 0301 	andne.w	r3, r3, #1
 800cece:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 800ced2:	428a      	cmp	r2, r1
 800ced4:	bf0c      	ite	eq
 800ced6:	2300      	moveq	r3, #0
 800ced8:	f003 0301 	andne.w	r3, r3, #1
 800cedc:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
 800cee0:	4282      	cmp	r2, r0
 800cee2:	bf0c      	ite	eq
 800cee4:	2300      	moveq	r3, #0
 800cee6:	f003 0301 	andne.w	r3, r3, #1
 800ceea:	428a      	cmp	r2, r1
 800ceec:	bf0c      	ite	eq
 800ceee:	2300      	moveq	r3, #0
 800cef0:	f003 0301 	andne.w	r3, r3, #1
 800cef4:	b11b      	cbz	r3, 800cefe <HAL_TIM_ConfigClockSource+0x41a>
 800cef6:	4b79      	ldr	r3, [pc, #484]	; (800d0dc <HAL_TIM_ConfigClockSource+0x5f8>)
 800cef8:	429a      	cmp	r2, r3
 800cefa:	f040 8098 	bne.w	800d02e <HAL_TIM_ConfigClockSource+0x54a>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800cefe:	686b      	ldr	r3, [r5, #4]
 800cf00:	2b0a      	cmp	r3, #10
 800cf02:	bf18      	it	ne
 800cf04:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800cf08:	d003      	beq.n	800cf12 <HAL_TIM_ConfigClockSource+0x42e>
 800cf0a:	f033 0302 	bics.w	r3, r3, #2
 800cf0e:	f040 8088 	bne.w	800d022 <HAL_TIM_ConfigClockSource+0x53e>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800cf12:	68ee      	ldr	r6, [r5, #12]
 800cf14:	2e0f      	cmp	r6, #15
 800cf16:	f200 80ab 	bhi.w	800d070 <HAL_TIM_ConfigClockSource+0x58c>
      TIM_TI1_ConfigInputStage(htim->Instance,
 800cf1a:	6823      	ldr	r3, [r4, #0]
 800cf1c:	6868      	ldr	r0, [r5, #4]
  tmpccer = TIMx->CCER;
 800cf1e:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800cf20:	6a1d      	ldr	r5, [r3, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800cf22:	f022 020a 	bic.w	r2, r2, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800cf26:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
 800cf2a:	4310      	orrs	r0, r2
  tmpsmcr &= ~TIM_SMCR_TS;
 800cf2c:	4a6c      	ldr	r2, [pc, #432]	; (800d0e0 <HAL_TIM_ConfigClockSource+0x5fc>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800cf2e:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800cf30:	6999      	ldr	r1, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800cf32:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800cf36:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 800cf3a:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 800cf3c:	6218      	str	r0, [r3, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 800cf3e:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = TIMx->SMCR;
 800cf40:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800cf42:	400a      	ands	r2, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800cf44:	f042 0257 	orr.w	r2, r2, #87	; 0x57
  TIMx->SMCR = tmpsmcr;
 800cf48:	609a      	str	r2, [r3, #8]
 800cf4a:	e6ba      	b.n	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
  switch (sClockSourceConfig->ClockSource)
 800cf4c:	2b10      	cmp	r3, #16
 800cf4e:	d004      	beq.n	800cf5a <HAL_TIM_ConfigClockSource+0x476>
 800cf50:	2b20      	cmp	r3, #32
 800cf52:	d002      	beq.n	800cf5a <HAL_TIM_ConfigClockSource+0x476>
 800cf54:	2b00      	cmp	r3, #0
 800cf56:	f47f aeb4 	bne.w	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
 800cf5a:	6821      	ldr	r1, [r4, #0]
 800cf5c:	4a5b      	ldr	r2, [pc, #364]	; (800d0cc <HAL_TIM_ConfigClockSource+0x5e8>)
 800cf5e:	4e5c      	ldr	r6, [pc, #368]	; (800d0d0 <HAL_TIM_ConfigClockSource+0x5ec>)
 800cf60:	4291      	cmp	r1, r2
 800cf62:	bf18      	it	ne
 800cf64:	f1b1 4f80 	cmpne.w	r1, #1073741824	; 0x40000000
 800cf68:	485a      	ldr	r0, [pc, #360]	; (800d0d4 <HAL_TIM_ConfigClockSource+0x5f0>)
 800cf6a:	bf14      	ite	ne
 800cf6c:	2201      	movne	r2, #1
 800cf6e:	2200      	moveq	r2, #0
 800cf70:	42b1      	cmp	r1, r6
 800cf72:	bf0c      	ite	eq
 800cf74:	2200      	moveq	r2, #0
 800cf76:	f002 0201 	andne.w	r2, r2, #1
 800cf7a:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 800cf7e:	4281      	cmp	r1, r0
 800cf80:	bf0c      	ite	eq
 800cf82:	2200      	moveq	r2, #0
 800cf84:	f002 0201 	andne.w	r2, r2, #1
 800cf88:	f500 407c 	add.w	r0, r0, #64512	; 0xfc00
 800cf8c:	42b1      	cmp	r1, r6
 800cf8e:	bf0c      	ite	eq
 800cf90:	2200      	moveq	r2, #0
 800cf92:	f002 0201 	andne.w	r2, r2, #1
 800cf96:	4281      	cmp	r1, r0
 800cf98:	bf0c      	ite	eq
 800cf9a:	2200      	moveq	r2, #0
 800cf9c:	f002 0201 	andne.w	r2, r2, #1
 800cfa0:	b112      	cbz	r2, 800cfa8 <HAL_TIM_ConfigClockSource+0x4c4>
 800cfa2:	4a4e      	ldr	r2, [pc, #312]	; (800d0dc <HAL_TIM_ConfigClockSource+0x5f8>)
 800cfa4:	4291      	cmp	r1, r2
 800cfa6:	d148      	bne.n	800d03a <HAL_TIM_ConfigClockSource+0x556>
  tmpsmcr = TIMx->SMCR;
 800cfa8:	6888      	ldr	r0, [r1, #8]
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800cfaa:	f043 0307 	orr.w	r3, r3, #7
  tmpsmcr &= ~TIM_SMCR_TS;
 800cfae:	4a4c      	ldr	r2, [pc, #304]	; (800d0e0 <HAL_TIM_ConfigClockSource+0x5fc>)
 800cfb0:	4002      	ands	r2, r0
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800cfb2:	4313      	orrs	r3, r2
  TIMx->SMCR = tmpsmcr;
 800cfb4:	608b      	str	r3, [r1, #8]
 800cfb6:	e684      	b.n	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
  switch (sClockSourceConfig->ClockSource)
 800cfb8:	4a4a      	ldr	r2, [pc, #296]	; (800d0e4 <HAL_TIM_ConfigClockSource+0x600>)
 800cfba:	4293      	cmp	r3, r2
 800cfbc:	d0cd      	beq.n	800cf5a <HAL_TIM_ConfigClockSource+0x476>
 800cfbe:	3210      	adds	r2, #16
 800cfc0:	4293      	cmp	r3, r2
 800cfc2:	d0ca      	beq.n	800cf5a <HAL_TIM_ConfigClockSource+0x476>
 800cfc4:	3a20      	subs	r2, #32
 800cfc6:	4293      	cmp	r3, r2
 800cfc8:	f47f ae7b 	bne.w	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
 800cfcc:	e7c5      	b.n	800cf5a <HAL_TIM_ConfigClockSource+0x476>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
 800cfce:	f241 21ab 	movw	r1, #4779	; 0x12ab
 800cfd2:	4845      	ldr	r0, [pc, #276]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800cfd4:	f006 fc7c 	bl	80138d0 <assert_failed>
 800cfd8:	e6ec      	b.n	800cdb4 <HAL_TIM_ConfigClockSource+0x2d0>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
 800cfda:	f241 2193 	movw	r1, #4755	; 0x1293
 800cfde:	4842      	ldr	r0, [pc, #264]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800cfe0:	f006 fc76 	bl	80138d0 <assert_failed>
 800cfe4:	e73f      	b.n	800ce66 <HAL_TIM_ConfigClockSource+0x382>
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
 800cfe6:	f44f 5194 	mov.w	r1, #4736	; 0x1280
 800cfea:	483f      	ldr	r0, [pc, #252]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800cfec:	f006 fc70 	bl	80138d0 <assert_failed>
 800cff0:	e597      	b.n	800cb22 <HAL_TIM_ConfigClockSource+0x3e>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800cff2:	f241 21e2 	movw	r1, #4834	; 0x12e2
 800cff6:	483c      	ldr	r0, [pc, #240]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800cff8:	f006 fc6a 	bl	80138d0 <assert_failed>
 800cffc:	e5db      	b.n	800cbb6 <HAL_TIM_ConfigClockSource+0xd2>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800cffe:	f241 21d2 	movw	r1, #4818	; 0x12d2
 800d002:	4839      	ldr	r0, [pc, #228]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d004:	f006 fc64 	bl	80138d0 <assert_failed>
 800d008:	e695      	b.n	800cd36 <HAL_TIM_ConfigClockSource+0x252>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800d00a:	f241 2197 	movw	r1, #4759	; 0x1297
 800d00e:	4836      	ldr	r0, [pc, #216]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d010:	f006 fc5e 	bl	80138d0 <assert_failed>
 800d014:	e736      	b.n	800ce84 <HAL_TIM_ConfigClockSource+0x3a0>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800d016:	f241 21af 	movw	r1, #4783	; 0x12af
 800d01a:	4833      	ldr	r0, [pc, #204]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d01c:	f006 fc58 	bl	80138d0 <assert_failed>
 800d020:	e6d7      	b.n	800cdd2 <HAL_TIM_ConfigClockSource+0x2ee>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800d022:	f241 21c2 	movw	r1, #4802	; 0x12c2
 800d026:	4830      	ldr	r0, [pc, #192]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d028:	f006 fc52 	bl	80138d0 <assert_failed>
 800d02c:	e771      	b.n	800cf12 <HAL_TIM_ConfigClockSource+0x42e>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800d02e:	f241 21bf 	movw	r1, #4799	; 0x12bf
 800d032:	482d      	ldr	r0, [pc, #180]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d034:	f006 fc4c 	bl	80138d0 <assert_failed>
 800d038:	e761      	b.n	800cefe <HAL_TIM_ConfigClockSource+0x41a>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
 800d03a:	f241 21f7 	movw	r1, #4855	; 0x12f7
 800d03e:	482a      	ldr	r0, [pc, #168]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d040:	f006 fc46 	bl	80138d0 <assert_failed>
 800d044:	682b      	ldr	r3, [r5, #0]
 800d046:	6821      	ldr	r1, [r4, #0]
 800d048:	e7ae      	b.n	800cfa8 <HAL_TIM_ConfigClockSource+0x4c4>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800d04a:	f241 21cf 	movw	r1, #4815	; 0x12cf
 800d04e:	4826      	ldr	r0, [pc, #152]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d050:	f006 fc3e 	bl	80138d0 <assert_failed>
 800d054:	e665      	b.n	800cd22 <HAL_TIM_ConfigClockSource+0x23e>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800d056:	f241 21df 	movw	r1, #4831	; 0x12df
 800d05a:	4823      	ldr	r0, [pc, #140]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d05c:	f006 fc38 	bl	80138d0 <assert_failed>
 800d060:	e59f      	b.n	800cba2 <HAL_TIM_ConfigClockSource+0xbe>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800d062:	f241 21b0 	movw	r1, #4784	; 0x12b0
 800d066:	4820      	ldr	r0, [pc, #128]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d068:	f006 fc32 	bl	80138d0 <assert_failed>
 800d06c:	68e9      	ldr	r1, [r5, #12]
 800d06e:	e6b4      	b.n	800cdda <HAL_TIM_ConfigClockSource+0x2f6>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800d070:	f241 21c3 	movw	r1, #4803	; 0x12c3
 800d074:	481c      	ldr	r0, [pc, #112]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d076:	f006 fc2b 	bl	80138d0 <assert_failed>
 800d07a:	68ee      	ldr	r6, [r5, #12]
 800d07c:	e74d      	b.n	800cf1a <HAL_TIM_ConfigClockSource+0x436>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800d07e:	f241 2198 	movw	r1, #4760	; 0x1298
 800d082:	4819      	ldr	r0, [pc, #100]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d084:	f006 fc24 	bl	80138d0 <assert_failed>
 800d088:	68e9      	ldr	r1, [r5, #12]
 800d08a:	e6ff      	b.n	800ce8c <HAL_TIM_ConfigClockSource+0x3a8>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800d08c:	f241 21d3 	movw	r1, #4819	; 0x12d3
 800d090:	4815      	ldr	r0, [pc, #84]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d092:	f006 fc1d 	bl	80138d0 <assert_failed>
 800d096:	68ee      	ldr	r6, [r5, #12]
 800d098:	e651      	b.n	800cd3e <HAL_TIM_ConfigClockSource+0x25a>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800d09a:	f241 21e3 	movw	r1, #4835	; 0x12e3
 800d09e:	4812      	ldr	r0, [pc, #72]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d0a0:	f006 fc16 	bl	80138d0 <assert_failed>
 800d0a4:	68ee      	ldr	r6, [r5, #12]
 800d0a6:	e58a      	b.n	800cbbe <HAL_TIM_ConfigClockSource+0xda>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800d0a8:	f241 21ae 	movw	r1, #4782	; 0x12ae
 800d0ac:	480e      	ldr	r0, [pc, #56]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d0ae:	f006 fc0f 	bl	80138d0 <assert_failed>
 800d0b2:	e684      	b.n	800cdbe <HAL_TIM_ConfigClockSource+0x2da>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800d0b4:	f241 2196 	movw	r1, #4758	; 0x1296
 800d0b8:	480b      	ldr	r0, [pc, #44]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d0ba:	f006 fc09 	bl	80138d0 <assert_failed>
 800d0be:	e6d7      	b.n	800ce70 <HAL_TIM_ConfigClockSource+0x38c>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
 800d0c0:	f241 218c 	movw	r1, #4748	; 0x128c
 800d0c4:	4808      	ldr	r0, [pc, #32]	; (800d0e8 <HAL_TIM_ConfigClockSource+0x604>)
 800d0c6:	f006 fc03 	bl	80138d0 <assert_failed>
 800d0ca:	e5fa      	b.n	800ccc2 <HAL_TIM_ConfigClockSource+0x1de>
 800d0cc:	40010000 	.word	0x40010000
 800d0d0:	40000400 	.word	0x40000400
 800d0d4:	40000800 	.word	0x40000800
 800d0d8:	40010400 	.word	0x40010400
 800d0dc:	40014000 	.word	0x40014000
 800d0e0:	ffcfff8f 	.word	0xffcfff8f
 800d0e4:	00100030 	.word	0x00100030
 800d0e8:	08029468 	.word	0x08029468

0800d0ec <TIM_OC2_SetConfig>:
{
 800d0ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800d0f0:	6a02      	ldr	r2, [r0, #32]
{
 800d0f2:	460e      	mov	r6, r1
 800d0f4:	4604      	mov	r4, r0
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800d0f6:	4b31      	ldr	r3, [pc, #196]	; (800d1bc <TIM_OC2_SetConfig+0xd0>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800d0f8:	f022 0210 	bic.w	r2, r2, #16
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800d0fc:	4930      	ldr	r1, [pc, #192]	; (800d1c0 <TIM_OC2_SetConfig+0xd4>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800d0fe:	6202      	str	r2, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800d100:	428c      	cmp	r4, r1
  tmpccer = TIMx->CCER;
 800d102:	6a05      	ldr	r5, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 800d104:	6847      	ldr	r7, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 800d106:	6982      	ldr	r2, [r0, #24]
  tmpccer &= ~TIM_CCER_CC2P;
 800d108:	f025 0520 	bic.w	r5, r5, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 800d10c:	68b0      	ldr	r0, [r6, #8]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800d10e:	ea03 0302 	and.w	r3, r3, r2
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800d112:	6832      	ldr	r2, [r6, #0]
  tmpccer |= (OC_Config->OCPolarity << 4U);
 800d114:	ea45 1500 	orr.w	r5, r5, r0, lsl #4
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800d118:	ea43 2802 	orr.w	r8, r3, r2, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800d11c:	d023      	beq.n	800d166 <TIM_OC2_SetConfig+0x7a>
 800d11e:	4b29      	ldr	r3, [pc, #164]	; (800d1c4 <TIM_OC2_SetConfig+0xd8>)
 800d120:	429c      	cmp	r4, r3
 800d122:	d020      	beq.n	800d166 <TIM_OC2_SetConfig+0x7a>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d124:	4a28      	ldr	r2, [pc, #160]	; (800d1c8 <TIM_OC2_SetConfig+0xdc>)
 800d126:	4b29      	ldr	r3, [pc, #164]	; (800d1cc <TIM_OC2_SetConfig+0xe0>)
 800d128:	429c      	cmp	r4, r3
 800d12a:	bf18      	it	ne
 800d12c:	4294      	cmpne	r4, r2
 800d12e:	d003      	beq.n	800d138 <TIM_OC2_SetConfig+0x4c>
 800d130:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800d134:	429c      	cmp	r4, r3
 800d136:	d10e      	bne.n	800d156 <TIM_OC2_SetConfig+0x6a>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800d138:	69b3      	ldr	r3, [r6, #24]
 800d13a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800d13e:	d120      	bne.n	800d182 <TIM_OC2_SetConfig+0x96>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800d140:	6971      	ldr	r1, [r6, #20]
 800d142:	f431 7380 	bics.w	r3, r1, #256	; 0x100
 800d146:	d125      	bne.n	800d194 <TIM_OC2_SetConfig+0xa8>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 800d148:	f427 6240 	bic.w	r2, r7, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 800d14c:	69b3      	ldr	r3, [r6, #24]
 800d14e:	ea42 0283 	orr.w	r2, r2, r3, lsl #2
 800d152:	ea42 0781 	orr.w	r7, r2, r1, lsl #2
  TIMx->CR2 = tmpcr2;
 800d156:	6067      	str	r7, [r4, #4]
  TIMx->CCMR1 = tmpccmrx;
 800d158:	f8c4 8018 	str.w	r8, [r4, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 800d15c:	6873      	ldr	r3, [r6, #4]
 800d15e:	63a3      	str	r3, [r4, #56]	; 0x38
  TIMx->CCER = tmpccer;
 800d160:	6225      	str	r5, [r4, #32]
}
 800d162:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800d166:	68f3      	ldr	r3, [r6, #12]
 800d168:	f033 0208 	bics.w	r2, r3, #8
 800d16c:	d119      	bne.n	800d1a2 <TIM_OC2_SetConfig+0xb6>
    tmpccer &= ~TIM_CCER_CC2NP;
 800d16e:	f025 0580 	bic.w	r5, r5, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800d172:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 800d176:	f025 0540 	bic.w	r5, r5, #64	; 0x40
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800d17a:	69b3      	ldr	r3, [r6, #24]
 800d17c:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800d180:	d0de      	beq.n	800d140 <TIM_OC2_SetConfig+0x54>
 800d182:	f641 015f 	movw	r1, #6239	; 0x185f
 800d186:	4812      	ldr	r0, [pc, #72]	; (800d1d0 <TIM_OC2_SetConfig+0xe4>)
 800d188:	f006 fba2 	bl	80138d0 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800d18c:	6971      	ldr	r1, [r6, #20]
 800d18e:	f431 7380 	bics.w	r3, r1, #256	; 0x100
 800d192:	d0d9      	beq.n	800d148 <TIM_OC2_SetConfig+0x5c>
 800d194:	f44f 51c3 	mov.w	r1, #6240	; 0x1860
 800d198:	480d      	ldr	r0, [pc, #52]	; (800d1d0 <TIM_OC2_SetConfig+0xe4>)
 800d19a:	f006 fb99 	bl	80138d0 <assert_failed>
 800d19e:	6971      	ldr	r1, [r6, #20]
 800d1a0:	e7d2      	b.n	800d148 <TIM_OC2_SetConfig+0x5c>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800d1a2:	f641 0151 	movw	r1, #6225	; 0x1851
 800d1a6:	480a      	ldr	r0, [pc, #40]	; (800d1d0 <TIM_OC2_SetConfig+0xe4>)
 800d1a8:	f006 fb92 	bl	80138d0 <assert_failed>
    tmpccer &= ~TIM_CCER_CC2NP;
 800d1ac:	f025 0580 	bic.w	r5, r5, #128	; 0x80
 800d1b0:	68f3      	ldr	r3, [r6, #12]
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800d1b2:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 800d1b6:	f025 0540 	bic.w	r5, r5, #64	; 0x40
 800d1ba:	e7de      	b.n	800d17a <TIM_OC2_SetConfig+0x8e>
 800d1bc:	feff8cff 	.word	0xfeff8cff
 800d1c0:	40010000 	.word	0x40010000
 800d1c4:	40010400 	.word	0x40010400
 800d1c8:	40014000 	.word	0x40014000
 800d1cc:	40014400 	.word	0x40014400
 800d1d0:	08029468 	.word	0x08029468

0800d1d4 <HAL_TIM_PWM_ConfigChannel>:
  assert_param(IS_TIM_CHANNELS(Channel));
 800d1d4:	2a14      	cmp	r2, #20
{
 800d1d6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d1da:	4616      	mov	r6, r2
 800d1dc:	4604      	mov	r4, r0
 800d1de:	460d      	mov	r5, r1
  assert_param(IS_TIM_CHANNELS(Channel));
 800d1e0:	f240 80a2 	bls.w	800d328 <HAL_TIM_PWM_ConfigChannel+0x154>
 800d1e4:	2a3c      	cmp	r2, #60	; 0x3c
 800d1e6:	f040 80a4 	bne.w	800d332 <HAL_TIM_PWM_ConfigChannel+0x15e>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
 800d1ea:	682b      	ldr	r3, [r5, #0]
 800d1ec:	4a9b      	ldr	r2, [pc, #620]	; (800d45c <HAL_TIM_PWM_ConfigChannel+0x288>)
 800d1ee:	f023 0110 	bic.w	r1, r3, #16
 800d1f2:	4291      	cmp	r1, r2
 800d1f4:	d004      	beq.n	800d200 <HAL_TIM_PWM_ConfigChannel+0x2c>
 800d1f6:	4a9a      	ldr	r2, [pc, #616]	; (800d460 <HAL_TIM_PWM_ConfigChannel+0x28c>)
 800d1f8:	401a      	ands	r2, r3
 800d1fa:	2a60      	cmp	r2, #96	; 0x60
 800d1fc:	f040 8235 	bne.w	800d66a <HAL_TIM_PWM_ConfigChannel+0x496>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
 800d200:	68ab      	ldr	r3, [r5, #8]
 800d202:	f033 0302 	bics.w	r3, r3, #2
 800d206:	f040 809a 	bne.w	800d33e <HAL_TIM_PWM_ConfigChannel+0x16a>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
 800d20a:	692b      	ldr	r3, [r5, #16]
 800d20c:	f033 0304 	bics.w	r3, r3, #4
 800d210:	f040 809f 	bne.w	800d352 <HAL_TIM_PWM_ConfigChannel+0x17e>
  __HAL_LOCK(htim);
 800d214:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 800d218:	2b01      	cmp	r3, #1
 800d21a:	f000 80a4 	beq.w	800d366 <HAL_TIM_PWM_ConfigChannel+0x192>
 800d21e:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800d220:	2302      	movs	r3, #2
  __HAL_LOCK(htim);
 800d222:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 800d226:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  switch (Channel)
 800d22a:	2e14      	cmp	r6, #20
 800d22c:	d873      	bhi.n	800d316 <HAL_TIM_PWM_ConfigChannel+0x142>
 800d22e:	e8df f016 	tbh	[pc, r6, lsl #1]
 800d232:	0015      	.short	0x0015
 800d234:	00720072 	.word	0x00720072
 800d238:	009d0072 	.word	0x009d0072
 800d23c:	00720072 	.word	0x00720072
 800d240:	00e00072 	.word	0x00e00072
 800d244:	00720072 	.word	0x00720072
 800d248:	01290072 	.word	0x01290072
 800d24c:	00720072 	.word	0x00720072
 800d250:	018e0072 	.word	0x018e0072
 800d254:	00720072 	.word	0x00720072
 800d258:	01d50072 	.word	0x01d50072
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
 800d25c:	6820      	ldr	r0, [r4, #0]
 800d25e:	4b81      	ldr	r3, [pc, #516]	; (800d464 <HAL_TIM_PWM_ConfigChannel+0x290>)
 800d260:	4a81      	ldr	r2, [pc, #516]	; (800d468 <HAL_TIM_PWM_ConfigChannel+0x294>)
 800d262:	4298      	cmp	r0, r3
 800d264:	bf18      	it	ne
 800d266:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
 800d26a:	4980      	ldr	r1, [pc, #512]	; (800d46c <HAL_TIM_PWM_ConfigChannel+0x298>)
 800d26c:	bf14      	ite	ne
 800d26e:	2301      	movne	r3, #1
 800d270:	2300      	moveq	r3, #0
 800d272:	4290      	cmp	r0, r2
 800d274:	bf0c      	ite	eq
 800d276:	2300      	moveq	r3, #0
 800d278:	f003 0301 	andne.w	r3, r3, #1
 800d27c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800d280:	4288      	cmp	r0, r1
 800d282:	bf0c      	ite	eq
 800d284:	2300      	moveq	r3, #0
 800d286:	f003 0301 	andne.w	r3, r3, #1
 800d28a:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
 800d28e:	4290      	cmp	r0, r2
 800d290:	bf0c      	ite	eq
 800d292:	2300      	moveq	r3, #0
 800d294:	f003 0301 	andne.w	r3, r3, #1
 800d298:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
 800d29c:	4288      	cmp	r0, r1
 800d29e:	bf0c      	ite	eq
 800d2a0:	2300      	moveq	r3, #0
 800d2a2:	f003 0301 	andne.w	r3, r3, #1
 800d2a6:	f5a1 4168 	sub.w	r1, r1, #59392	; 0xe800
 800d2aa:	4290      	cmp	r0, r2
 800d2ac:	bf0c      	ite	eq
 800d2ae:	2300      	moveq	r3, #0
 800d2b0:	f003 0301 	andne.w	r3, r3, #1
 800d2b4:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800d2b8:	4288      	cmp	r0, r1
 800d2ba:	bf0c      	ite	eq
 800d2bc:	2300      	moveq	r3, #0
 800d2be:	f003 0301 	andne.w	r3, r3, #1
 800d2c2:	f501 3192 	add.w	r1, r1, #74752	; 0x12400
 800d2c6:	4290      	cmp	r0, r2
 800d2c8:	bf0c      	ite	eq
 800d2ca:	2300      	moveq	r3, #0
 800d2cc:	f003 0301 	andne.w	r3, r3, #1
 800d2d0:	f502 3292 	add.w	r2, r2, #74752	; 0x12400
 800d2d4:	4288      	cmp	r0, r1
 800d2d6:	bf0c      	ite	eq
 800d2d8:	2300      	moveq	r3, #0
 800d2da:	f003 0301 	andne.w	r3, r3, #1
 800d2de:	4290      	cmp	r0, r2
 800d2e0:	bf0c      	ite	eq
 800d2e2:	2300      	moveq	r3, #0
 800d2e4:	f003 0301 	andne.w	r3, r3, #1
 800d2e8:	b11b      	cbz	r3, 800d2f2 <HAL_TIM_PWM_ConfigChannel+0x11e>
 800d2ea:	4b61      	ldr	r3, [pc, #388]	; (800d470 <HAL_TIM_PWM_ConfigChannel+0x29c>)
 800d2ec:	4298      	cmp	r0, r3
 800d2ee:	f040 81ec 	bne.w	800d6ca <HAL_TIM_PWM_ConfigChannel+0x4f6>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 800d2f2:	4629      	mov	r1, r5
 800d2f4:	f7fe ffe6 	bl	800c2c4 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800d2f8:	6822      	ldr	r2, [r4, #0]
 800d2fa:	6993      	ldr	r3, [r2, #24]
 800d2fc:	f043 0308 	orr.w	r3, r3, #8
 800d300:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 800d302:	6822      	ldr	r2, [r4, #0]
 800d304:	6993      	ldr	r3, [r2, #24]
 800d306:	f023 0304 	bic.w	r3, r3, #4
 800d30a:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 800d30c:	6822      	ldr	r2, [r4, #0]
 800d30e:	6929      	ldr	r1, [r5, #16]
 800d310:	6993      	ldr	r3, [r2, #24]
 800d312:	430b      	orrs	r3, r1
 800d314:	6193      	str	r3, [r2, #24]
  __HAL_UNLOCK(htim);
 800d316:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 800d318:	2201      	movs	r2, #1
  return HAL_OK;
 800d31a:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 800d31c:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800d320:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800d324:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_TIM_CHANNELS(Channel));
 800d328:	4b52      	ldr	r3, [pc, #328]	; (800d474 <HAL_TIM_PWM_ConfigChannel+0x2a0>)
 800d32a:	40d3      	lsrs	r3, r2
 800d32c:	07db      	lsls	r3, r3, #31
 800d32e:	f53f af5c 	bmi.w	800d1ea <HAL_TIM_PWM_ConfigChannel+0x16>
 800d332:	f640 611c 	movw	r1, #3612	; 0xe1c
 800d336:	4850      	ldr	r0, [pc, #320]	; (800d478 <HAL_TIM_PWM_ConfigChannel+0x2a4>)
 800d338:	f006 faca 	bl	80138d0 <assert_failed>
 800d33c:	e755      	b.n	800d1ea <HAL_TIM_PWM_ConfigChannel+0x16>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
 800d33e:	f640 611e 	movw	r1, #3614	; 0xe1e
 800d342:	484d      	ldr	r0, [pc, #308]	; (800d478 <HAL_TIM_PWM_ConfigChannel+0x2a4>)
 800d344:	f006 fac4 	bl	80138d0 <assert_failed>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
 800d348:	692b      	ldr	r3, [r5, #16]
 800d34a:	f033 0304 	bics.w	r3, r3, #4
 800d34e:	f43f af61 	beq.w	800d214 <HAL_TIM_PWM_ConfigChannel+0x40>
 800d352:	f640 611f 	movw	r1, #3615	; 0xe1f
 800d356:	4848      	ldr	r0, [pc, #288]	; (800d478 <HAL_TIM_PWM_ConfigChannel+0x2a4>)
 800d358:	f006 faba 	bl	80138d0 <assert_failed>
  __HAL_LOCK(htim);
 800d35c:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 800d360:	2b01      	cmp	r3, #1
 800d362:	f47f af5c 	bne.w	800d21e <HAL_TIM_PWM_ConfigChannel+0x4a>
 800d366:	2002      	movs	r0, #2
}
 800d368:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
 800d36c:	6820      	ldr	r0, [r4, #0]
 800d36e:	4b3d      	ldr	r3, [pc, #244]	; (800d464 <HAL_TIM_PWM_ConfigChannel+0x290>)
 800d370:	4a3d      	ldr	r2, [pc, #244]	; (800d468 <HAL_TIM_PWM_ConfigChannel+0x294>)
 800d372:	4298      	cmp	r0, r3
 800d374:	bf18      	it	ne
 800d376:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
 800d37a:	493c      	ldr	r1, [pc, #240]	; (800d46c <HAL_TIM_PWM_ConfigChannel+0x298>)
 800d37c:	bf14      	ite	ne
 800d37e:	2301      	movne	r3, #1
 800d380:	2300      	moveq	r3, #0
 800d382:	4290      	cmp	r0, r2
 800d384:	bf0c      	ite	eq
 800d386:	2300      	moveq	r3, #0
 800d388:	f003 0301 	andne.w	r3, r3, #1
 800d38c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800d390:	4288      	cmp	r0, r1
 800d392:	bf0c      	ite	eq
 800d394:	2300      	moveq	r3, #0
 800d396:	f003 0301 	andne.w	r3, r3, #1
 800d39a:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
 800d39e:	4290      	cmp	r0, r2
 800d3a0:	bf0c      	ite	eq
 800d3a2:	2300      	moveq	r3, #0
 800d3a4:	f003 0301 	andne.w	r3, r3, #1
 800d3a8:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
 800d3ac:	4288      	cmp	r0, r1
 800d3ae:	bf0c      	ite	eq
 800d3b0:	2300      	moveq	r3, #0
 800d3b2:	f003 0301 	andne.w	r3, r3, #1
 800d3b6:	4290      	cmp	r0, r2
 800d3b8:	bf0c      	ite	eq
 800d3ba:	2300      	moveq	r3, #0
 800d3bc:	f003 0301 	andne.w	r3, r3, #1
 800d3c0:	b11b      	cbz	r3, 800d3ca <HAL_TIM_PWM_ConfigChannel+0x1f6>
 800d3c2:	4b2e      	ldr	r3, [pc, #184]	; (800d47c <HAL_TIM_PWM_ConfigChannel+0x2a8>)
 800d3c4:	4298      	cmp	r0, r3
 800d3c6:	f040 8179 	bne.w	800d6bc <HAL_TIM_PWM_ConfigChannel+0x4e8>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 800d3ca:	4629      	mov	r1, r5
 800d3cc:	f7ff fe8e 	bl	800d0ec <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 800d3d0:	6822      	ldr	r2, [r4, #0]
 800d3d2:	6993      	ldr	r3, [r2, #24]
 800d3d4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800d3d8:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 800d3da:	6822      	ldr	r2, [r4, #0]
 800d3dc:	6993      	ldr	r3, [r2, #24]
 800d3de:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800d3e2:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 800d3e4:	6822      	ldr	r2, [r4, #0]
 800d3e6:	6929      	ldr	r1, [r5, #16]
 800d3e8:	6993      	ldr	r3, [r2, #24]
 800d3ea:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800d3ee:	6193      	str	r3, [r2, #24]
      break;
 800d3f0:	e791      	b.n	800d316 <HAL_TIM_PWM_ConfigChannel+0x142>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
 800d3f2:	6820      	ldr	r0, [r4, #0]
 800d3f4:	4b1b      	ldr	r3, [pc, #108]	; (800d464 <HAL_TIM_PWM_ConfigChannel+0x290>)
 800d3f6:	4a1c      	ldr	r2, [pc, #112]	; (800d468 <HAL_TIM_PWM_ConfigChannel+0x294>)
 800d3f8:	4298      	cmp	r0, r3
 800d3fa:	bf18      	it	ne
 800d3fc:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
 800d400:	491a      	ldr	r1, [pc, #104]	; (800d46c <HAL_TIM_PWM_ConfigChannel+0x298>)
 800d402:	bf14      	ite	ne
 800d404:	2301      	movne	r3, #1
 800d406:	2300      	moveq	r3, #0
 800d408:	4290      	cmp	r0, r2
 800d40a:	bf0c      	ite	eq
 800d40c:	2300      	moveq	r3, #0
 800d40e:	f003 0301 	andne.w	r3, r3, #1
 800d412:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800d416:	4288      	cmp	r0, r1
 800d418:	bf0c      	ite	eq
 800d41a:	2300      	moveq	r3, #0
 800d41c:	f003 0301 	andne.w	r3, r3, #1
 800d420:	4290      	cmp	r0, r2
 800d422:	bf0c      	ite	eq
 800d424:	2300      	moveq	r3, #0
 800d426:	f003 0301 	andne.w	r3, r3, #1
 800d42a:	b11b      	cbz	r3, 800d434 <HAL_TIM_PWM_ConfigChannel+0x260>
 800d42c:	4b14      	ldr	r3, [pc, #80]	; (800d480 <HAL_TIM_PWM_ConfigChannel+0x2ac>)
 800d42e:	4298      	cmp	r0, r3
 800d430:	f040 813d 	bne.w	800d6ae <HAL_TIM_PWM_ConfigChannel+0x4da>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800d434:	4629      	mov	r1, r5
 800d436:	f7fe ffcd 	bl	800c3d4 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 800d43a:	6822      	ldr	r2, [r4, #0]
 800d43c:	69d3      	ldr	r3, [r2, #28]
 800d43e:	f043 0308 	orr.w	r3, r3, #8
 800d442:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 800d444:	6822      	ldr	r2, [r4, #0]
 800d446:	69d3      	ldr	r3, [r2, #28]
 800d448:	f023 0304 	bic.w	r3, r3, #4
 800d44c:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 800d44e:	6822      	ldr	r2, [r4, #0]
 800d450:	6929      	ldr	r1, [r5, #16]
 800d452:	69d3      	ldr	r3, [r2, #28]
 800d454:	430b      	orrs	r3, r1
 800d456:	61d3      	str	r3, [r2, #28]
      break;
 800d458:	e75d      	b.n	800d316 <HAL_TIM_PWM_ConfigChannel+0x142>
 800d45a:	bf00      	nop
 800d45c:	00010040 	.word	0x00010040
 800d460:	fffeffef 	.word	0xfffeffef
 800d464:	40010000 	.word	0x40010000
 800d468:	40000400 	.word	0x40000400
 800d46c:	40000800 	.word	0x40000800
 800d470:	40014800 	.word	0x40014800
 800d474:	00111111 	.word	0x00111111
 800d478:	08029468 	.word	0x08029468
 800d47c:	40014000 	.word	0x40014000
 800d480:	40010400 	.word	0x40010400
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
 800d484:	6826      	ldr	r6, [r4, #0]
 800d486:	4b94      	ldr	r3, [pc, #592]	; (800d6d8 <HAL_TIM_PWM_ConfigChannel+0x504>)
 800d488:	4a94      	ldr	r2, [pc, #592]	; (800d6dc <HAL_TIM_PWM_ConfigChannel+0x508>)
 800d48a:	429e      	cmp	r6, r3
 800d48c:	bf18      	it	ne
 800d48e:	f1b6 4f80 	cmpne.w	r6, #1073741824	; 0x40000000
 800d492:	4993      	ldr	r1, [pc, #588]	; (800d6e0 <HAL_TIM_PWM_ConfigChannel+0x50c>)
 800d494:	bf14      	ite	ne
 800d496:	2301      	movne	r3, #1
 800d498:	2300      	moveq	r3, #0
 800d49a:	4296      	cmp	r6, r2
 800d49c:	bf0c      	ite	eq
 800d49e:	2300      	moveq	r3, #0
 800d4a0:	f003 0301 	andne.w	r3, r3, #1
 800d4a4:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800d4a8:	428e      	cmp	r6, r1
 800d4aa:	bf0c      	ite	eq
 800d4ac:	2300      	moveq	r3, #0
 800d4ae:	f003 0301 	andne.w	r3, r3, #1
 800d4b2:	4296      	cmp	r6, r2
 800d4b4:	bf0c      	ite	eq
 800d4b6:	2300      	moveq	r3, #0
 800d4b8:	f003 0301 	andne.w	r3, r3, #1
 800d4bc:	b11b      	cbz	r3, 800d4c6 <HAL_TIM_PWM_ConfigChannel+0x2f2>
 800d4be:	4b89      	ldr	r3, [pc, #548]	; (800d6e4 <HAL_TIM_PWM_ConfigChannel+0x510>)
 800d4c0:	429e      	cmp	r6, r3
 800d4c2:	f040 80ed 	bne.w	800d6a0 <HAL_TIM_PWM_ConfigChannel+0x4cc>
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800d4c6:	6a33      	ldr	r3, [r6, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d4c8:	4983      	ldr	r1, [pc, #524]	; (800d6d8 <HAL_TIM_PWM_ConfigChannel+0x504>)
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800d4ca:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d4ce:	428e      	cmp	r6, r1
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800d4d0:	6233      	str	r3, [r6, #32]
  tmpccer = TIMx->CCER;
 800d4d2:	6a33      	ldr	r3, [r6, #32]
  tmpcr2 =  TIMx->CR2;
 800d4d4:	f8d6 9004 	ldr.w	r9, [r6, #4]
  tmpccmrx = TIMx->CCMR2;
 800d4d8:	69f7      	ldr	r7, [r6, #28]
  tmpccer &= ~TIM_CCER_CC4P;
 800d4da:	f423 5800 	bic.w	r8, r3, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800d4de:	68aa      	ldr	r2, [r5, #8]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800d4e0:	f427 47e6 	bic.w	r7, r7, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800d4e4:	682b      	ldr	r3, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800d4e6:	ea48 3802 	orr.w	r8, r8, r2, lsl #12
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800d4ea:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d4ee:	d00d      	beq.n	800d50c <HAL_TIM_PWM_ConfigChannel+0x338>
 800d4f0:	4b7c      	ldr	r3, [pc, #496]	; (800d6e4 <HAL_TIM_PWM_ConfigChannel+0x510>)
 800d4f2:	429e      	cmp	r6, r3
 800d4f4:	d00a      	beq.n	800d50c <HAL_TIM_PWM_ConfigChannel+0x338>
 800d4f6:	4a7c      	ldr	r2, [pc, #496]	; (800d6e8 <HAL_TIM_PWM_ConfigChannel+0x514>)
 800d4f8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 800d4fc:	429e      	cmp	r6, r3
 800d4fe:	bf18      	it	ne
 800d500:	4296      	cmpne	r6, r2
 800d502:	d003      	beq.n	800d50c <HAL_TIM_PWM_ConfigChannel+0x338>
 800d504:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800d508:	429e      	cmp	r6, r3
 800d50a:	d108      	bne.n	800d51e <HAL_TIM_PWM_ConfigChannel+0x34a>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800d50c:	696b      	ldr	r3, [r5, #20]
 800d50e:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800d512:	f040 80be 	bne.w	800d692 <HAL_TIM_PWM_ConfigChannel+0x4be>
    tmpcr2 &= ~TIM_CR2_OIS4;
 800d516:	f429 4980 	bic.w	r9, r9, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 800d51a:	ea49 1983 	orr.w	r9, r9, r3, lsl #6
  TIMx->CR2 = tmpcr2;
 800d51e:	f8c6 9004 	str.w	r9, [r6, #4]
  TIMx->CCMR2 = tmpccmrx;
 800d522:	61f7      	str	r7, [r6, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 800d524:	686b      	ldr	r3, [r5, #4]
 800d526:	6433      	str	r3, [r6, #64]	; 0x40
  TIMx->CCER = tmpccer;
 800d528:	f8c6 8020 	str.w	r8, [r6, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 800d52c:	6822      	ldr	r2, [r4, #0]
 800d52e:	69d3      	ldr	r3, [r2, #28]
 800d530:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800d534:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 800d536:	6822      	ldr	r2, [r4, #0]
 800d538:	69d3      	ldr	r3, [r2, #28]
 800d53a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800d53e:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 800d540:	6822      	ldr	r2, [r4, #0]
 800d542:	6929      	ldr	r1, [r5, #16]
 800d544:	69d3      	ldr	r3, [r2, #28]
 800d546:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800d54a:	61d3      	str	r3, [r2, #28]
      break;
 800d54c:	e6e3      	b.n	800d316 <HAL_TIM_PWM_ConfigChannel+0x142>
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
 800d54e:	6823      	ldr	r3, [r4, #0]
 800d550:	4a61      	ldr	r2, [pc, #388]	; (800d6d8 <HAL_TIM_PWM_ConfigChannel+0x504>)
 800d552:	4293      	cmp	r3, r2
 800d554:	d004      	beq.n	800d560 <HAL_TIM_PWM_ConfigChannel+0x38c>
 800d556:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800d55a:	4293      	cmp	r3, r2
 800d55c:	f040 8092 	bne.w	800d684 <HAL_TIM_PWM_ConfigChannel+0x4b0>
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800d560:	6a1a      	ldr	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d562:	4f5d      	ldr	r7, [pc, #372]	; (800d6d8 <HAL_TIM_PWM_ConfigChannel+0x504>)
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800d564:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d568:	42bb      	cmp	r3, r7
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800d56a:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 800d56c:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 800d56e:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 800d572:	6d59      	ldr	r1, [r3, #84]	; 0x54
  tmpccer &= ~TIM_CCER_CC5P;
 800d574:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
 800d578:	68ae      	ldr	r6, [r5, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 800d57a:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpccmrx |= OC_Config->OCMode;
 800d57e:	6828      	ldr	r0, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 16U);
 800d580:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
  tmpccmrx |= OC_Config->OCMode;
 800d584:	ea41 0100 	orr.w	r1, r1, r0
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d588:	d00d      	beq.n	800d5a6 <HAL_TIM_PWM_ConfigChannel+0x3d2>
 800d58a:	4856      	ldr	r0, [pc, #344]	; (800d6e4 <HAL_TIM_PWM_ConfigChannel+0x510>)
 800d58c:	4283      	cmp	r3, r0
 800d58e:	d00a      	beq.n	800d5a6 <HAL_TIM_PWM_ConfigChannel+0x3d2>
 800d590:	4e55      	ldr	r6, [pc, #340]	; (800d6e8 <HAL_TIM_PWM_ConfigChannel+0x514>)
 800d592:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
 800d596:	4283      	cmp	r3, r0
 800d598:	bf18      	it	ne
 800d59a:	42b3      	cmpne	r3, r6
 800d59c:	d003      	beq.n	800d5a6 <HAL_TIM_PWM_ConfigChannel+0x3d2>
 800d59e:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800d5a2:	4283      	cmp	r3, r0
 800d5a4:	d104      	bne.n	800d5b0 <HAL_TIM_PWM_ConfigChannel+0x3dc>
    tmpcr2 &= ~TIM_CR2_OIS5;
 800d5a6:	f42c 3c80 	bic.w	ip, ip, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 800d5aa:	6968      	ldr	r0, [r5, #20]
 800d5ac:	ea4c 2c00 	orr.w	ip, ip, r0, lsl #8
  TIMx->CR2 = tmpcr2;
 800d5b0:	f8c3 c004 	str.w	ip, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 800d5b4:	6559      	str	r1, [r3, #84]	; 0x54
  TIMx->CCR5 = OC_Config->Pulse;
 800d5b6:	6869      	ldr	r1, [r5, #4]
 800d5b8:	6599      	str	r1, [r3, #88]	; 0x58
  TIMx->CCER = tmpccer;
 800d5ba:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 800d5bc:	6822      	ldr	r2, [r4, #0]
 800d5be:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800d5c0:	f043 0308 	orr.w	r3, r3, #8
 800d5c4:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 800d5c6:	6822      	ldr	r2, [r4, #0]
 800d5c8:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800d5ca:	f023 0304 	bic.w	r3, r3, #4
 800d5ce:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 800d5d0:	6822      	ldr	r2, [r4, #0]
 800d5d2:	6929      	ldr	r1, [r5, #16]
 800d5d4:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800d5d6:	430b      	orrs	r3, r1
 800d5d8:	6553      	str	r3, [r2, #84]	; 0x54
      break;
 800d5da:	e69c      	b.n	800d316 <HAL_TIM_PWM_ConfigChannel+0x142>
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
 800d5dc:	6823      	ldr	r3, [r4, #0]
 800d5de:	4a3e      	ldr	r2, [pc, #248]	; (800d6d8 <HAL_TIM_PWM_ConfigChannel+0x504>)
 800d5e0:	4293      	cmp	r3, r2
 800d5e2:	d003      	beq.n	800d5ec <HAL_TIM_PWM_ConfigChannel+0x418>
 800d5e4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800d5e8:	4293      	cmp	r3, r2
 800d5ea:	d144      	bne.n	800d676 <HAL_TIM_PWM_ConfigChannel+0x4a2>
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800d5ec:	6a1a      	ldr	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d5ee:	4f3a      	ldr	r7, [pc, #232]	; (800d6d8 <HAL_TIM_PWM_ConfigChannel+0x504>)
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800d5f0:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d5f4:	42bb      	cmp	r3, r7
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800d5f6:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 800d5f8:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 800d5fa:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 800d5fe:	6d59      	ldr	r1, [r3, #84]	; 0x54
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800d600:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800d604:	68ae      	ldr	r6, [r5, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 800d606:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800d60a:	6828      	ldr	r0, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800d60c:	ea42 5206 	orr.w	r2, r2, r6, lsl #20
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800d610:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d614:	d00d      	beq.n	800d632 <HAL_TIM_PWM_ConfigChannel+0x45e>
 800d616:	4833      	ldr	r0, [pc, #204]	; (800d6e4 <HAL_TIM_PWM_ConfigChannel+0x510>)
 800d618:	4283      	cmp	r3, r0
 800d61a:	d00a      	beq.n	800d632 <HAL_TIM_PWM_ConfigChannel+0x45e>
 800d61c:	4e32      	ldr	r6, [pc, #200]	; (800d6e8 <HAL_TIM_PWM_ConfigChannel+0x514>)
 800d61e:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
 800d622:	4283      	cmp	r3, r0
 800d624:	bf18      	it	ne
 800d626:	42b3      	cmpne	r3, r6
 800d628:	d003      	beq.n	800d632 <HAL_TIM_PWM_ConfigChannel+0x45e>
 800d62a:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800d62e:	4283      	cmp	r3, r0
 800d630:	d104      	bne.n	800d63c <HAL_TIM_PWM_ConfigChannel+0x468>
    tmpcr2 &= ~TIM_CR2_OIS6;
 800d632:	f42c 3c00 	bic.w	ip, ip, #131072	; 0x20000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 800d636:	6968      	ldr	r0, [r5, #20]
 800d638:	ea4c 2c80 	orr.w	ip, ip, r0, lsl #10
  TIMx->CR2 = tmpcr2;
 800d63c:	f8c3 c004 	str.w	ip, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 800d640:	6559      	str	r1, [r3, #84]	; 0x54
  TIMx->CCR6 = OC_Config->Pulse;
 800d642:	6869      	ldr	r1, [r5, #4]
 800d644:	65d9      	str	r1, [r3, #92]	; 0x5c
  TIMx->CCER = tmpccer;
 800d646:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 800d648:	6822      	ldr	r2, [r4, #0]
 800d64a:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800d64c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800d650:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 800d652:	6822      	ldr	r2, [r4, #0]
 800d654:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800d656:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800d65a:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 800d65c:	6822      	ldr	r2, [r4, #0]
 800d65e:	6929      	ldr	r1, [r5, #16]
 800d660:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800d662:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800d666:	6553      	str	r3, [r2, #84]	; 0x54
      break;
 800d668:	e655      	b.n	800d316 <HAL_TIM_PWM_ConfigChannel+0x142>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
 800d66a:	f640 611d 	movw	r1, #3613	; 0xe1d
 800d66e:	481f      	ldr	r0, [pc, #124]	; (800d6ec <HAL_TIM_PWM_ConfigChannel+0x518>)
 800d670:	f006 f92e 	bl	80138d0 <assert_failed>
 800d674:	e5c4      	b.n	800d200 <HAL_TIM_PWM_ConfigChannel+0x2c>
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
 800d676:	f44f 6168 	mov.w	r1, #3712	; 0xe80
 800d67a:	481c      	ldr	r0, [pc, #112]	; (800d6ec <HAL_TIM_PWM_ConfigChannel+0x518>)
 800d67c:	f006 f928 	bl	80138d0 <assert_failed>
 800d680:	6823      	ldr	r3, [r4, #0]
 800d682:	e7b3      	b.n	800d5ec <HAL_TIM_PWM_ConfigChannel+0x418>
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
 800d684:	f640 616f 	movw	r1, #3695	; 0xe6f
 800d688:	4818      	ldr	r0, [pc, #96]	; (800d6ec <HAL_TIM_PWM_ConfigChannel+0x518>)
 800d68a:	f006 f921 	bl	80138d0 <assert_failed>
 800d68e:	6823      	ldr	r3, [r4, #0]
 800d690:	e766      	b.n	800d560 <HAL_TIM_PWM_ConfigChannel+0x38c>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800d692:	f641 01e8 	movw	r1, #6376	; 0x18e8
 800d696:	4815      	ldr	r0, [pc, #84]	; (800d6ec <HAL_TIM_PWM_ConfigChannel+0x518>)
 800d698:	f006 f91a 	bl	80138d0 <assert_failed>
 800d69c:	696b      	ldr	r3, [r5, #20]
 800d69e:	e73a      	b.n	800d516 <HAL_TIM_PWM_ConfigChannel+0x342>
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
 800d6a0:	f640 615e 	movw	r1, #3678	; 0xe5e
 800d6a4:	4811      	ldr	r0, [pc, #68]	; (800d6ec <HAL_TIM_PWM_ConfigChannel+0x518>)
 800d6a6:	f006 f913 	bl	80138d0 <assert_failed>
 800d6aa:	6826      	ldr	r6, [r4, #0]
 800d6ac:	e70b      	b.n	800d4c6 <HAL_TIM_PWM_ConfigChannel+0x2f2>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
 800d6ae:	480f      	ldr	r0, [pc, #60]	; (800d6ec <HAL_TIM_PWM_ConfigChannel+0x518>)
 800d6b0:	f640 614d 	movw	r1, #3661	; 0xe4d
 800d6b4:	f006 f90c 	bl	80138d0 <assert_failed>
 800d6b8:	6820      	ldr	r0, [r4, #0]
 800d6ba:	e6bb      	b.n	800d434 <HAL_TIM_PWM_ConfigChannel+0x260>
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
 800d6bc:	480b      	ldr	r0, [pc, #44]	; (800d6ec <HAL_TIM_PWM_ConfigChannel+0x518>)
 800d6be:	f640 613c 	movw	r1, #3644	; 0xe3c
 800d6c2:	f006 f905 	bl	80138d0 <assert_failed>
 800d6c6:	6820      	ldr	r0, [r4, #0]
 800d6c8:	e67f      	b.n	800d3ca <HAL_TIM_PWM_ConfigChannel+0x1f6>
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
 800d6ca:	4808      	ldr	r0, [pc, #32]	; (800d6ec <HAL_TIM_PWM_ConfigChannel+0x518>)
 800d6cc:	f640 612b 	movw	r1, #3627	; 0xe2b
 800d6d0:	f006 f8fe 	bl	80138d0 <assert_failed>
 800d6d4:	6820      	ldr	r0, [r4, #0]
 800d6d6:	e60c      	b.n	800d2f2 <HAL_TIM_PWM_ConfigChannel+0x11e>
 800d6d8:	40010000 	.word	0x40010000
 800d6dc:	40000400 	.word	0x40000400
 800d6e0:	40000800 	.word	0x40000800
 800d6e4:	40010400 	.word	0x40010400
 800d6e8:	40014000 	.word	0x40014000
 800d6ec:	08029468 	.word	0x08029468

0800d6f0 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 800d6f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmpcr2;
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800d6f2:	4b60      	ldr	r3, [pc, #384]	; (800d874 <HAL_TIMEx_MasterConfigSynchronization+0x184>)
{
 800d6f4:	4604      	mov	r4, r0
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800d6f6:	6802      	ldr	r2, [r0, #0]
{
 800d6f8:	460d      	mov	r5, r1
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800d6fa:	4e5f      	ldr	r6, [pc, #380]	; (800d878 <HAL_TIMEx_MasterConfigSynchronization+0x188>)
 800d6fc:	429a      	cmp	r2, r3
 800d6fe:	bf18      	it	ne
 800d700:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800d704:	485d      	ldr	r0, [pc, #372]	; (800d87c <HAL_TIMEx_MasterConfigSynchronization+0x18c>)
 800d706:	495e      	ldr	r1, [pc, #376]	; (800d880 <HAL_TIMEx_MasterConfigSynchronization+0x190>)
 800d708:	bf14      	ite	ne
 800d70a:	2301      	movne	r3, #1
 800d70c:	2300      	moveq	r3, #0
 800d70e:	42b2      	cmp	r2, r6
 800d710:	bf0c      	ite	eq
 800d712:	2300      	moveq	r3, #0
 800d714:	f003 0301 	andne.w	r3, r3, #1
 800d718:	f506 6640 	add.w	r6, r6, #3072	; 0xc00
 800d71c:	4282      	cmp	r2, r0
 800d71e:	bf0c      	ite	eq
 800d720:	2300      	moveq	r3, #0
 800d722:	f003 0301 	andne.w	r3, r3, #1
 800d726:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
 800d72a:	428a      	cmp	r2, r1
 800d72c:	bf0c      	ite	eq
 800d72e:	2300      	moveq	r3, #0
 800d730:	f003 0301 	andne.w	r3, r3, #1
 800d734:	f501 4178 	add.w	r1, r1, #63488	; 0xf800
 800d738:	42b2      	cmp	r2, r6
 800d73a:	bf0c      	ite	eq
 800d73c:	2300      	moveq	r3, #0
 800d73e:	f003 0301 	andne.w	r3, r3, #1
 800d742:	4282      	cmp	r2, r0
 800d744:	bf0c      	ite	eq
 800d746:	2300      	moveq	r3, #0
 800d748:	f003 0301 	andne.w	r3, r3, #1
 800d74c:	428a      	cmp	r2, r1
 800d74e:	bf0c      	ite	eq
 800d750:	2300      	moveq	r3, #0
 800d752:	f003 0301 	andne.w	r3, r3, #1
 800d756:	b113      	cbz	r3, 800d75e <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 800d758:	4b4a      	ldr	r3, [pc, #296]	; (800d884 <HAL_TIMEx_MasterConfigSynchronization+0x194>)
 800d75a:	429a      	cmp	r2, r3
 800d75c:	d175      	bne.n	800d84a <HAL_TIMEx_MasterConfigSynchronization+0x15a>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
 800d75e:	682b      	ldr	r3, [r5, #0]
 800d760:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 800d764:	2b40      	cmp	r3, #64	; 0x40
 800d766:	d001      	beq.n	800d76c <HAL_TIMEx_MasterConfigSynchronization+0x7c>
 800d768:	2b00      	cmp	r3, #0
 800d76a:	d174      	bne.n	800d856 <HAL_TIMEx_MasterConfigSynchronization+0x166>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
 800d76c:	68ab      	ldr	r3, [r5, #8]
 800d76e:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800d772:	d15f      	bne.n	800d834 <HAL_TIMEx_MasterConfigSynchronization+0x144>

  /* Check input state */
  __HAL_LOCK(htim);
 800d774:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 800d778:	2b01      	cmp	r3, #1
 800d77a:	d064      	beq.n	800d846 <HAL_TIMEx_MasterConfigSynchronization+0x156>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800d77c:	6822      	ldr	r2, [r4, #0]
  __HAL_LOCK(htim);
 800d77e:	2001      	movs	r0, #1

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800d780:	4b3c      	ldr	r3, [pc, #240]	; (800d874 <HAL_TIMEx_MasterConfigSynchronization+0x184>)
  htim->State = HAL_TIM_STATE_BUSY;
 800d782:	2102      	movs	r1, #2
  __HAL_LOCK(htim);
 800d784:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800d788:	429a      	cmp	r2, r3
  htim->State = HAL_TIM_STATE_BUSY;
 800d78a:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
  tmpcr2 = htim->Instance->CR2;
 800d78e:	6857      	ldr	r7, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
 800d790:	6896      	ldr	r6, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800d792:	d037      	beq.n	800d804 <HAL_TIMEx_MasterConfigSynchronization+0x114>
 800d794:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800d798:	429a      	cmp	r2, r3
 800d79a:	d033      	beq.n	800d804 <HAL_TIMEx_MasterConfigSynchronization+0x114>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800d79c:	6829      	ldr	r1, [r5, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
 800d79e:	f027 0770 	bic.w	r7, r7, #112	; 0x70

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800d7a2:	4b34      	ldr	r3, [pc, #208]	; (800d874 <HAL_TIMEx_MasterConfigSynchronization+0x184>)
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800d7a4:	430f      	orrs	r7, r1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800d7a6:	4934      	ldr	r1, [pc, #208]	; (800d878 <HAL_TIMEx_MasterConfigSynchronization+0x188>)
 800d7a8:	4835      	ldr	r0, [pc, #212]	; (800d880 <HAL_TIMEx_MasterConfigSynchronization+0x190>)
  htim->Instance->CR2 = tmpcr2;
 800d7aa:	6057      	str	r7, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800d7ac:	6822      	ldr	r2, [r4, #0]
 800d7ae:	4f33      	ldr	r7, [pc, #204]	; (800d87c <HAL_TIMEx_MasterConfigSynchronization+0x18c>)
 800d7b0:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800d7b4:	bf18      	it	ne
 800d7b6:	429a      	cmpne	r2, r3
 800d7b8:	bf0c      	ite	eq
 800d7ba:	2301      	moveq	r3, #1
 800d7bc:	2300      	movne	r3, #0
 800d7be:	428a      	cmp	r2, r1
 800d7c0:	bf08      	it	eq
 800d7c2:	f043 0301 	orreq.w	r3, r3, #1
 800d7c6:	f501 3180 	add.w	r1, r1, #65536	; 0x10000
 800d7ca:	42ba      	cmp	r2, r7
 800d7cc:	bf08      	it	eq
 800d7ce:	f043 0301 	orreq.w	r3, r3, #1
 800d7d2:	4282      	cmp	r2, r0
 800d7d4:	bf08      	it	eq
 800d7d6:	f043 0301 	orreq.w	r3, r3, #1
 800d7da:	428a      	cmp	r2, r1
 800d7dc:	bf08      	it	eq
 800d7de:	f043 0301 	orreq.w	r3, r3, #1
 800d7e2:	b913      	cbnz	r3, 800d7ea <HAL_TIMEx_MasterConfigSynchronization+0xfa>
 800d7e4:	4b28      	ldr	r3, [pc, #160]	; (800d888 <HAL_TIMEx_MasterConfigSynchronization+0x198>)
 800d7e6:	429a      	cmp	r2, r3
 800d7e8:	d104      	bne.n	800d7f4 <HAL_TIMEx_MasterConfigSynchronization+0x104>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800d7ea:	68ab      	ldr	r3, [r5, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
 800d7ec:	f026 0680 	bic.w	r6, r6, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800d7f0:	431e      	orrs	r6, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800d7f2:	6096      	str	r6, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 800d7f4:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 800d7f6:	2201      	movs	r2, #1

  return HAL_OK;
 800d7f8:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 800d7fa:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800d7fe:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800d802:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
 800d804:	6868      	ldr	r0, [r5, #4]
 800d806:	f420 1340 	bic.w	r3, r0, #3145728	; 0x300000
 800d80a:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800d80e:	bf18      	it	ne
 800d810:	2b00      	cmpne	r3, #0
 800d812:	bf14      	ite	ne
 800d814:	2101      	movne	r1, #1
 800d816:	2100      	moveq	r1, #0
 800d818:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800d81c:	bf0c      	ite	eq
 800d81e:	2100      	moveq	r1, #0
 800d820:	f001 0101 	andne.w	r1, r1, #1
 800d824:	b111      	cbz	r1, 800d82c <HAL_TIMEx_MasterConfigSynchronization+0x13c>
 800d826:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 800d82a:	d11a      	bne.n	800d862 <HAL_TIMEx_MasterConfigSynchronization+0x172>
    tmpcr2 &= ~TIM_CR2_MMS2;
 800d82c:	f427 0770 	bic.w	r7, r7, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800d830:	4307      	orrs	r7, r0
 800d832:	e7b3      	b.n	800d79c <HAL_TIMEx_MasterConfigSynchronization+0xac>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
 800d834:	f240 6175 	movw	r1, #1653	; 0x675
 800d838:	4814      	ldr	r0, [pc, #80]	; (800d88c <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
 800d83a:	f006 f849 	bl	80138d0 <assert_failed>
  __HAL_LOCK(htim);
 800d83e:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 800d842:	2b01      	cmp	r3, #1
 800d844:	d19a      	bne.n	800d77c <HAL_TIMEx_MasterConfigSynchronization+0x8c>
 800d846:	2002      	movs	r0, #2
}
 800d848:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800d84a:	f240 6173 	movw	r1, #1651	; 0x673
 800d84e:	480f      	ldr	r0, [pc, #60]	; (800d88c <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
 800d850:	f006 f83e 	bl	80138d0 <assert_failed>
 800d854:	e783      	b.n	800d75e <HAL_TIMEx_MasterConfigSynchronization+0x6e>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
 800d856:	f240 6174 	movw	r1, #1652	; 0x674
 800d85a:	480c      	ldr	r0, [pc, #48]	; (800d88c <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
 800d85c:	f006 f838 	bl	80138d0 <assert_failed>
 800d860:	e784      	b.n	800d76c <HAL_TIMEx_MasterConfigSynchronization+0x7c>
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
 800d862:	480a      	ldr	r0, [pc, #40]	; (800d88c <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
 800d864:	f240 6187 	movw	r1, #1671	; 0x687
 800d868:	f006 f832 	bl	80138d0 <assert_failed>
 800d86c:	6868      	ldr	r0, [r5, #4]
 800d86e:	6822      	ldr	r2, [r4, #0]
 800d870:	e7dc      	b.n	800d82c <HAL_TIMEx_MasterConfigSynchronization+0x13c>
 800d872:	bf00      	nop
 800d874:	40010000 	.word	0x40010000
 800d878:	40000400 	.word	0x40000400
 800d87c:	40000800 	.word	0x40000800
 800d880:	40000c00 	.word	0x40000c00
 800d884:	40014000 	.word	0x40014000
 800d888:	40001800 	.word	0x40001800
 800d88c:	080294a0 	.word	0x080294a0

0800d890 <FMC_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800d890:	4b5e      	ldr	r3, [pc, #376]	; (800da0c <FMC_SDRAM_Init+0x17c>)
 800d892:	4298      	cmp	r0, r3
{
 800d894:	b570      	push	{r4, r5, r6, lr}
 800d896:	4605      	mov	r5, r0
 800d898:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800d89a:	d004      	beq.n	800d8a6 <FMC_SDRAM_Init+0x16>
 800d89c:	f240 311a 	movw	r1, #794	; 0x31a
 800d8a0:	485b      	ldr	r0, [pc, #364]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800d8a2:	f006 f815 	bl	80138d0 <assert_failed>
  assert_param(IS_FMC_SDRAM_BANK(Init->SDBank));
 800d8a6:	6823      	ldr	r3, [r4, #0]
 800d8a8:	2b01      	cmp	r3, #1
 800d8aa:	d904      	bls.n	800d8b6 <FMC_SDRAM_Init+0x26>
 800d8ac:	f240 311b 	movw	r1, #795	; 0x31b
 800d8b0:	4857      	ldr	r0, [pc, #348]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800d8b2:	f006 f80d 	bl	80138d0 <assert_failed>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
 800d8b6:	6863      	ldr	r3, [r4, #4]
 800d8b8:	2b03      	cmp	r3, #3
 800d8ba:	f200 80a1 	bhi.w	800da00 <FMC_SDRAM_Init+0x170>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
 800d8be:	68a3      	ldr	r3, [r4, #8]
 800d8c0:	f033 0204 	bics.w	r2, r3, #4
 800d8c4:	d002      	beq.n	800d8cc <FMC_SDRAM_Init+0x3c>
 800d8c6:	2b08      	cmp	r3, #8
 800d8c8:	f040 8094 	bne.w	800d9f4 <FMC_SDRAM_Init+0x164>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
 800d8cc:	68e3      	ldr	r3, [r4, #12]
 800d8ce:	f033 0210 	bics.w	r2, r3, #16
 800d8d2:	d001      	beq.n	800d8d8 <FMC_SDRAM_Init+0x48>
 800d8d4:	2b20      	cmp	r3, #32
 800d8d6:	d17d      	bne.n	800d9d4 <FMC_SDRAM_Init+0x144>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
 800d8d8:	6923      	ldr	r3, [r4, #16]
 800d8da:	f033 0340 	bics.w	r3, r3, #64	; 0x40
 800d8de:	f040 8083 	bne.w	800d9e8 <FMC_SDRAM_Init+0x158>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
 800d8e2:	6963      	ldr	r3, [r4, #20]
 800d8e4:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 800d8e8:	2a80      	cmp	r2, #128	; 0x80
 800d8ea:	d002      	beq.n	800d8f2 <FMC_SDRAM_Init+0x62>
 800d8ec:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d8f0:	d161      	bne.n	800d9b6 <FMC_SDRAM_Init+0x126>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
 800d8f2:	69a3      	ldr	r3, [r4, #24]
 800d8f4:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800d8f8:	d166      	bne.n	800d9c8 <FMC_SDRAM_Init+0x138>
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
 800d8fa:	69e3      	ldr	r3, [r4, #28]
 800d8fc:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
 800d900:	d002      	beq.n	800d908 <FMC_SDRAM_Init+0x78>
 800d902:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800d906:	d147      	bne.n	800d998 <FMC_SDRAM_Init+0x108>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
 800d908:	6a23      	ldr	r3, [r4, #32]
 800d90a:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 800d90e:	d14c      	bne.n	800d9aa <FMC_SDRAM_Init+0x11a>
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));
 800d910:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800d912:	f432 5300 	bics.w	r3, r2, #8192	; 0x2000
 800d916:	d002      	beq.n	800d91e <FMC_SDRAM_Init+0x8e>
 800d918:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 800d91c:	d11c      	bne.n	800d958 <FMC_SDRAM_Init+0xc8>

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank == FMC_SDRAM_BANK1)
 800d91e:	6821      	ldr	r1, [r4, #0]
 800d920:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
 800d924:	b319      	cbz	r1, 800d96e <FMC_SDRAM_Init+0xde>
                Init->ReadBurst          |
                Init->ReadPipeDelay));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800d926:	6829      	ldr	r1, [r5, #0]
 800d928:	4303      	orrs	r3, r0
               FMC_SDCRx_RPIPE,
               (Init->SDClockPeriod      |
                Init->ReadBurst          |
                Init->ReadPipeDelay));

    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 800d92a:	483a      	ldr	r0, [pc, #232]	; (800da14 <FMC_SDRAM_Init+0x184>)
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800d92c:	f421 41f8 	bic.w	r1, r1, #31744	; 0x7c00
 800d930:	430b      	orrs	r3, r1
 800d932:	4313      	orrs	r3, r2
 800d934:	602b      	str	r3, [r5, #0]
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 800d936:	68e2      	ldr	r2, [r4, #12]
 800d938:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
 800d93c:	430b      	orrs	r3, r1
 800d93e:	6921      	ldr	r1, [r4, #16]
 800d940:	4313      	orrs	r3, r2
 800d942:	e9d4 6205 	ldrd	r6, r2, [r4, #20]
 800d946:	430b      	orrs	r3, r1
 800d948:	6869      	ldr	r1, [r5, #4]
 800d94a:	4333      	orrs	r3, r6
 800d94c:	4008      	ands	r0, r1
 800d94e:	4313      	orrs	r3, r2
 800d950:	4303      	orrs	r3, r0
                Init->CASLatency         |
                Init->WriteProtection));
  }

  return HAL_OK;
}
 800d952:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 800d954:	606b      	str	r3, [r5, #4]
}
 800d956:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));
 800d958:	f44f 7149 	mov.w	r1, #804	; 0x324
 800d95c:	482c      	ldr	r0, [pc, #176]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800d95e:	f005 ffb7 	bl	80138d0 <assert_failed>
  if (Init->SDBank == FMC_SDRAM_BANK1)
 800d962:	6821      	ldr	r1, [r4, #0]
 800d964:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800d966:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
 800d96a:	2900      	cmp	r1, #0
 800d96c:	d1db      	bne.n	800d926 <FMC_SDRAM_Init+0x96>
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800d96e:	4303      	orrs	r3, r0
 800d970:	e9d4 1001 	ldrd	r1, r0, [r4, #4]
 800d974:	430b      	orrs	r3, r1
 800d976:	68e1      	ldr	r1, [r4, #12]
 800d978:	4303      	orrs	r3, r0
 800d97a:	6920      	ldr	r0, [r4, #16]
 800d97c:	430b      	orrs	r3, r1
 800d97e:	e9d4 1405 	ldrd	r1, r4, [r4, #20]
 800d982:	4303      	orrs	r3, r0
 800d984:	6828      	ldr	r0, [r5, #0]
 800d986:	430b      	orrs	r3, r1
 800d988:	4922      	ldr	r1, [pc, #136]	; (800da14 <FMC_SDRAM_Init+0x184>)
 800d98a:	4323      	orrs	r3, r4
 800d98c:	4001      	ands	r1, r0
}
 800d98e:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800d990:	430b      	orrs	r3, r1
 800d992:	4313      	orrs	r3, r2
 800d994:	602b      	str	r3, [r5, #0]
}
 800d996:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
 800d998:	f240 3122 	movw	r1, #802	; 0x322
 800d99c:	481c      	ldr	r0, [pc, #112]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800d99e:	f005 ff97 	bl	80138d0 <assert_failed>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
 800d9a2:	6a23      	ldr	r3, [r4, #32]
 800d9a4:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 800d9a8:	d0b2      	beq.n	800d910 <FMC_SDRAM_Init+0x80>
 800d9aa:	f240 3123 	movw	r1, #803	; 0x323
 800d9ae:	4818      	ldr	r0, [pc, #96]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800d9b0:	f005 ff8e 	bl	80138d0 <assert_failed>
 800d9b4:	e7ac      	b.n	800d910 <FMC_SDRAM_Init+0x80>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
 800d9b6:	f44f 7148 	mov.w	r1, #800	; 0x320
 800d9ba:	4815      	ldr	r0, [pc, #84]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800d9bc:	f005 ff88 	bl	80138d0 <assert_failed>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
 800d9c0:	69a3      	ldr	r3, [r4, #24]
 800d9c2:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800d9c6:	d098      	beq.n	800d8fa <FMC_SDRAM_Init+0x6a>
 800d9c8:	f240 3121 	movw	r1, #801	; 0x321
 800d9cc:	4810      	ldr	r0, [pc, #64]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800d9ce:	f005 ff7f 	bl	80138d0 <assert_failed>
 800d9d2:	e792      	b.n	800d8fa <FMC_SDRAM_Init+0x6a>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
 800d9d4:	f240 311e 	movw	r1, #798	; 0x31e
 800d9d8:	480d      	ldr	r0, [pc, #52]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800d9da:	f005 ff79 	bl	80138d0 <assert_failed>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
 800d9de:	6923      	ldr	r3, [r4, #16]
 800d9e0:	f033 0340 	bics.w	r3, r3, #64	; 0x40
 800d9e4:	f43f af7d 	beq.w	800d8e2 <FMC_SDRAM_Init+0x52>
 800d9e8:	f240 311f 	movw	r1, #799	; 0x31f
 800d9ec:	4808      	ldr	r0, [pc, #32]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800d9ee:	f005 ff6f 	bl	80138d0 <assert_failed>
 800d9f2:	e776      	b.n	800d8e2 <FMC_SDRAM_Init+0x52>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
 800d9f4:	f240 311d 	movw	r1, #797	; 0x31d
 800d9f8:	4805      	ldr	r0, [pc, #20]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800d9fa:	f005 ff69 	bl	80138d0 <assert_failed>
 800d9fe:	e765      	b.n	800d8cc <FMC_SDRAM_Init+0x3c>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
 800da00:	f44f 7147 	mov.w	r1, #796	; 0x31c
 800da04:	4802      	ldr	r0, [pc, #8]	; (800da10 <FMC_SDRAM_Init+0x180>)
 800da06:	f005 ff63 	bl	80138d0 <assert_failed>
 800da0a:	e758      	b.n	800d8be <FMC_SDRAM_Init+0x2e>
 800da0c:	52004140 	.word	0x52004140
 800da10:	080294dc 	.word	0x080294dc
 800da14:	ffff8000 	.word	0xffff8000

0800da18 <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 800da18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800da1a:	4b50      	ldr	r3, [pc, #320]	; (800db5c <FMC_SDRAM_Timing_Init+0x144>)
{
 800da1c:	4605      	mov	r5, r0
 800da1e:	460c      	mov	r4, r1
 800da20:	4616      	mov	r6, r2
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800da22:	4298      	cmp	r0, r3
 800da24:	d004      	beq.n	800da30 <FMC_SDRAM_Timing_Init+0x18>
 800da26:	f44f 7156 	mov.w	r1, #856	; 0x358
 800da2a:	484d      	ldr	r0, [pc, #308]	; (800db60 <FMC_SDRAM_Timing_Init+0x148>)
 800da2c:	f005 ff50 	bl	80138d0 <assert_failed>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
 800da30:	6823      	ldr	r3, [r4, #0]
 800da32:	3b01      	subs	r3, #1
 800da34:	2b0f      	cmp	r3, #15
 800da36:	f200 808a 	bhi.w	800db4e <FMC_SDRAM_Timing_Init+0x136>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
 800da3a:	6863      	ldr	r3, [r4, #4]
 800da3c:	3b01      	subs	r3, #1
 800da3e:	2b0f      	cmp	r3, #15
 800da40:	d87f      	bhi.n	800db42 <FMC_SDRAM_Timing_Init+0x12a>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
 800da42:	68a3      	ldr	r3, [r4, #8]
 800da44:	3b01      	subs	r3, #1
 800da46:	2b0f      	cmp	r3, #15
 800da48:	d875      	bhi.n	800db36 <FMC_SDRAM_Timing_Init+0x11e>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
 800da4a:	68e3      	ldr	r3, [r4, #12]
 800da4c:	3b01      	subs	r3, #1
 800da4e:	2b0f      	cmp	r3, #15
 800da50:	d86b      	bhi.n	800db2a <FMC_SDRAM_Timing_Init+0x112>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
 800da52:	6923      	ldr	r3, [r4, #16]
 800da54:	3b01      	subs	r3, #1
 800da56:	2b0f      	cmp	r3, #15
 800da58:	d861      	bhi.n	800db1e <FMC_SDRAM_Timing_Init+0x106>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
 800da5a:	6963      	ldr	r3, [r4, #20]
 800da5c:	3b01      	subs	r3, #1
 800da5e:	2b0f      	cmp	r3, #15
 800da60:	d857      	bhi.n	800db12 <FMC_SDRAM_Timing_Init+0xfa>
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
 800da62:	69a3      	ldr	r3, [r4, #24]
 800da64:	3b01      	subs	r3, #1
 800da66:	2b0f      	cmp	r3, #15
 800da68:	d84d      	bhi.n	800db06 <FMC_SDRAM_Timing_Init+0xee>
  assert_param(IS_FMC_SDRAM_BANK(Bank));
 800da6a:	2e01      	cmp	r6, #1
 800da6c:	d821      	bhi.n	800dab2 <FMC_SDRAM_Timing_Init+0x9a>
 800da6e:	68e3      	ldr	r3, [r4, #12]
 800da70:	6961      	ldr	r1, [r4, #20]
 800da72:	3b01      	subs	r3, #1
 800da74:	3901      	subs	r1, #1
 800da76:	031b      	lsls	r3, r3, #12
 800da78:	0509      	lsls	r1, r1, #20

  /* Set SDRAM device timing parameters */
  if (Bank == FMC_SDRAM_BANK1)
 800da7a:	bb2e      	cbnz	r6, 800dac8 <FMC_SDRAM_Timing_Init+0xb0>
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 800da7c:	6822      	ldr	r2, [r4, #0]
 800da7e:	430b      	orrs	r3, r1
 800da80:	6860      	ldr	r0, [r4, #4]
 800da82:	3a01      	subs	r2, #1
 800da84:	68a1      	ldr	r1, [r4, #8]
 800da86:	1e47      	subs	r7, r0, #1
 800da88:	6920      	ldr	r0, [r4, #16]
 800da8a:	4313      	orrs	r3, r2
 800da8c:	1e4e      	subs	r6, r1, #1
 800da8e:	3801      	subs	r0, #1
 800da90:	69a1      	ldr	r1, [r4, #24]
 800da92:	ea43 1307 	orr.w	r3, r3, r7, lsl #4
 800da96:	68aa      	ldr	r2, [r5, #8]
 800da98:	3901      	subs	r1, #1
 800da9a:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 800da9e:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 800daa2:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
                (((Timing->WriteRecoveryTime) - 1U)    << FMC_SDTRx_TWR_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTRx_TRCD_Pos)));
  }

  return HAL_OK;
}
 800daa6:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 800daa8:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800daac:	4313      	orrs	r3, r2
 800daae:	60ab      	str	r3, [r5, #8]
}
 800dab0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FMC_SDRAM_BANK(Bank));
 800dab2:	f44f 7158 	mov.w	r1, #864	; 0x360
 800dab6:	482a      	ldr	r0, [pc, #168]	; (800db60 <FMC_SDRAM_Timing_Init+0x148>)
 800dab8:	f005 ff0a 	bl	80138d0 <assert_failed>
 800dabc:	68e3      	ldr	r3, [r4, #12]
 800dabe:	6961      	ldr	r1, [r4, #20]
 800dac0:	3b01      	subs	r3, #1
 800dac2:	3901      	subs	r1, #1
 800dac4:	031b      	lsls	r3, r3, #12
 800dac6:	0509      	lsls	r1, r1, #20
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 800dac8:	68a8      	ldr	r0, [r5, #8]
 800daca:	430b      	orrs	r3, r1
 800dacc:	4a25      	ldr	r2, [pc, #148]	; (800db64 <FMC_SDRAM_Timing_Init+0x14c>)
 800dace:	4002      	ands	r2, r0
 800dad0:	4313      	orrs	r3, r2
 800dad2:	60ab      	str	r3, [r5, #8]
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
 800dad4:	6820      	ldr	r0, [r4, #0]
 800dad6:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
 800dada:	1e46      	subs	r6, r0, #1
 800dadc:	1e5a      	subs	r2, r3, #1
 800dade:	1e4b      	subs	r3, r1, #1
 800dae0:	6921      	ldr	r1, [r4, #16]
 800dae2:	0212      	lsls	r2, r2, #8
 800dae4:	1e48      	subs	r0, r1, #1
 800dae6:	69a1      	ldr	r1, [r4, #24]
 800dae8:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 800daec:	68ea      	ldr	r2, [r5, #12]
 800daee:	3901      	subs	r1, #1
 800daf0:	4333      	orrs	r3, r6
 800daf2:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 800daf6:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
}
 800dafa:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
 800dafc:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800db00:	4313      	orrs	r3, r2
 800db02:	60eb      	str	r3, [r5, #12]
}
 800db04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
 800db06:	f240 315f 	movw	r1, #863	; 0x35f
 800db0a:	4815      	ldr	r0, [pc, #84]	; (800db60 <FMC_SDRAM_Timing_Init+0x148>)
 800db0c:	f005 fee0 	bl	80138d0 <assert_failed>
 800db10:	e7ab      	b.n	800da6a <FMC_SDRAM_Timing_Init+0x52>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
 800db12:	f240 315e 	movw	r1, #862	; 0x35e
 800db16:	4812      	ldr	r0, [pc, #72]	; (800db60 <FMC_SDRAM_Timing_Init+0x148>)
 800db18:	f005 feda 	bl	80138d0 <assert_failed>
 800db1c:	e7a1      	b.n	800da62 <FMC_SDRAM_Timing_Init+0x4a>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
 800db1e:	f240 315d 	movw	r1, #861	; 0x35d
 800db22:	480f      	ldr	r0, [pc, #60]	; (800db60 <FMC_SDRAM_Timing_Init+0x148>)
 800db24:	f005 fed4 	bl	80138d0 <assert_failed>
 800db28:	e797      	b.n	800da5a <FMC_SDRAM_Timing_Init+0x42>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
 800db2a:	f44f 7157 	mov.w	r1, #860	; 0x35c
 800db2e:	480c      	ldr	r0, [pc, #48]	; (800db60 <FMC_SDRAM_Timing_Init+0x148>)
 800db30:	f005 fece 	bl	80138d0 <assert_failed>
 800db34:	e78d      	b.n	800da52 <FMC_SDRAM_Timing_Init+0x3a>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
 800db36:	f240 315b 	movw	r1, #859	; 0x35b
 800db3a:	4809      	ldr	r0, [pc, #36]	; (800db60 <FMC_SDRAM_Timing_Init+0x148>)
 800db3c:	f005 fec8 	bl	80138d0 <assert_failed>
 800db40:	e783      	b.n	800da4a <FMC_SDRAM_Timing_Init+0x32>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
 800db42:	f240 315a 	movw	r1, #858	; 0x35a
 800db46:	4806      	ldr	r0, [pc, #24]	; (800db60 <FMC_SDRAM_Timing_Init+0x148>)
 800db48:	f005 fec2 	bl	80138d0 <assert_failed>
 800db4c:	e779      	b.n	800da42 <FMC_SDRAM_Timing_Init+0x2a>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
 800db4e:	f240 3159 	movw	r1, #857	; 0x359
 800db52:	4803      	ldr	r0, [pc, #12]	; (800db60 <FMC_SDRAM_Timing_Init+0x148>)
 800db54:	f005 febc 	bl	80138d0 <assert_failed>
 800db58:	e76f      	b.n	800da3a <FMC_SDRAM_Timing_Init+0x22>
 800db5a:	bf00      	nop
 800db5c:	52004140 	.word	0x52004140
 800db60:	080294dc 	.word	0x080294dc
 800db64:	ff0f0fff 	.word	0xff0f0fff

0800db68 <FMC_SDRAM_SendCommand>:
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800db68:	4b22      	ldr	r3, [pc, #136]	; (800dbf4 <FMC_SDRAM_SendCommand+0x8c>)
 800db6a:	4298      	cmp	r0, r3
{
 800db6c:	b570      	push	{r4, r5, r6, lr}
 800db6e:	4605      	mov	r5, r0
 800db70:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800db72:	d004      	beq.n	800db7e <FMC_SDRAM_SendCommand+0x16>
 800db74:	f240 31d9 	movw	r1, #985	; 0x3d9
 800db78:	481f      	ldr	r0, [pc, #124]	; (800dbf8 <FMC_SDRAM_SendCommand+0x90>)
 800db7a:	f005 fea9 	bl	80138d0 <assert_failed>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
 800db7e:	6823      	ldr	r3, [r4, #0]
 800db80:	2b06      	cmp	r3, #6
 800db82:	d831      	bhi.n	800dbe8 <FMC_SDRAM_SendCommand+0x80>
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
 800db84:	6863      	ldr	r3, [r4, #4]
 800db86:	f023 0210 	bic.w	r2, r3, #16
 800db8a:	2a08      	cmp	r2, #8
 800db8c:	d001      	beq.n	800db92 <FMC_SDRAM_SendCommand+0x2a>
 800db8e:	2b10      	cmp	r3, #16
 800db90:	d11b      	bne.n	800dbca <FMC_SDRAM_SendCommand+0x62>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
 800db92:	68a3      	ldr	r3, [r4, #8]
 800db94:	3b01      	subs	r3, #1
 800db96:	2b0e      	cmp	r3, #14
 800db98:	d820      	bhi.n	800dbdc <FMC_SDRAM_SendCommand+0x74>
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));
 800db9a:	68e1      	ldr	r1, [r4, #12]
 800db9c:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 800dba0:	d305      	bcc.n	800dbae <FMC_SDRAM_SendCommand+0x46>
 800dba2:	f240 31dd 	movw	r1, #989	; 0x3dd
 800dba6:	4814      	ldr	r0, [pc, #80]	; (800dbf8 <FMC_SDRAM_SendCommand+0x90>)
 800dba8:	f005 fe92 	bl	80138d0 <assert_failed>
 800dbac:	68e1      	ldr	r1, [r4, #12]

  /* Set command register */
  SET_BIT(Device->SDCMR, ((Command->CommandMode)                                                 |
 800dbae:	6823      	ldr	r3, [r4, #0]
                          (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos)   |
                          ((Command->ModeRegisterDefinition)   << FMC_SDCMR_MRD_Pos)));
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Timeout);
  return HAL_OK;
}
 800dbb0:	2000      	movs	r0, #0
  SET_BIT(Device->SDCMR, ((Command->CommandMode)                                                 |
 800dbb2:	e9d4 6201 	ldrd	r6, r2, [r4, #4]
 800dbb6:	692c      	ldr	r4, [r5, #16]
 800dbb8:	4333      	orrs	r3, r6
 800dbba:	3a01      	subs	r2, #1
 800dbbc:	4323      	orrs	r3, r4
 800dbbe:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
 800dbc2:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
 800dbc6:	612b      	str	r3, [r5, #16]
}
 800dbc8:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
 800dbca:	f240 31db 	movw	r1, #987	; 0x3db
 800dbce:	480a      	ldr	r0, [pc, #40]	; (800dbf8 <FMC_SDRAM_SendCommand+0x90>)
 800dbd0:	f005 fe7e 	bl	80138d0 <assert_failed>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
 800dbd4:	68a3      	ldr	r3, [r4, #8]
 800dbd6:	3b01      	subs	r3, #1
 800dbd8:	2b0e      	cmp	r3, #14
 800dbda:	d9de      	bls.n	800db9a <FMC_SDRAM_SendCommand+0x32>
 800dbdc:	f44f 7177 	mov.w	r1, #988	; 0x3dc
 800dbe0:	4805      	ldr	r0, [pc, #20]	; (800dbf8 <FMC_SDRAM_SendCommand+0x90>)
 800dbe2:	f005 fe75 	bl	80138d0 <assert_failed>
 800dbe6:	e7d8      	b.n	800db9a <FMC_SDRAM_SendCommand+0x32>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
 800dbe8:	f240 31da 	movw	r1, #986	; 0x3da
 800dbec:	4802      	ldr	r0, [pc, #8]	; (800dbf8 <FMC_SDRAM_SendCommand+0x90>)
 800dbee:	f005 fe6f 	bl	80138d0 <assert_failed>
 800dbf2:	e7c7      	b.n	800db84 <FMC_SDRAM_SendCommand+0x1c>
 800dbf4:	52004140 	.word	0x52004140
 800dbf8:	080294dc 	.word	0x080294dc

0800dbfc <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 800dbfc:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800dbfe:	4b0d      	ldr	r3, [pc, #52]	; (800dc34 <FMC_SDRAM_ProgramRefreshRate+0x38>)
{
 800dc00:	4604      	mov	r4, r0
 800dc02:	460d      	mov	r5, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800dc04:	4298      	cmp	r0, r3
 800dc06:	d004      	beq.n	800dc12 <FMC_SDRAM_ProgramRefreshRate+0x16>
 800dc08:	f240 31f2 	movw	r1, #1010	; 0x3f2
 800dc0c:	480a      	ldr	r0, [pc, #40]	; (800dc38 <FMC_SDRAM_ProgramRefreshRate+0x3c>)
 800dc0e:	f005 fe5f 	bl	80138d0 <assert_failed>
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
 800dc12:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
 800dc16:	d304      	bcc.n	800dc22 <FMC_SDRAM_ProgramRefreshRate+0x26>
 800dc18:	f240 31f3 	movw	r1, #1011	; 0x3f3
 800dc1c:	4806      	ldr	r0, [pc, #24]	; (800dc38 <FMC_SDRAM_ProgramRefreshRate+0x3c>)
 800dc1e:	f005 fe57 	bl	80138d0 <assert_failed>

  /* Set the refresh rate in command register */
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
 800dc22:	6963      	ldr	r3, [r4, #20]

  return HAL_OK;
}
 800dc24:	2000      	movs	r0, #0
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
 800dc26:	4905      	ldr	r1, [pc, #20]	; (800dc3c <FMC_SDRAM_ProgramRefreshRate+0x40>)
 800dc28:	4019      	ands	r1, r3
 800dc2a:	ea41 0145 	orr.w	r1, r1, r5, lsl #1
 800dc2e:	6161      	str	r1, [r4, #20]
}
 800dc30:	bd38      	pop	{r3, r4, r5, pc}
 800dc32:	bf00      	nop
 800dc34:	52004140 	.word	0x52004140
 800dc38:	080294dc 	.word	0x080294dc
 800dc3c:	ffffc001 	.word	0xffffc001

0800dc40 <SDMMC_GetCmdResp1.part.2>:
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);

  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800dc40:	4b30      	ldr	r3, [pc, #192]	; (800dd04 <SDMMC_GetCmdResp1.part.2+0xc4>)
  return (*(__IO uint32_t *) tmp);
 800dc42:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800dc44:	4013      	ands	r3, r2
 800dc46:	b34b      	cbz	r3, 800dc9c <SDMMC_GetCmdResp1.part.2+0x5c>
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800dc48:	2a00      	cmp	r2, #0
 800dc4a:	db29      	blt.n	800dca0 <SDMMC_GetCmdResp1.part.2+0x60>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800dc4c:	0051      	lsls	r1, r2, #1
 800dc4e:	d42d      	bmi.n	800dcac <SDMMC_GetCmdResp1.part.2+0x6c>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800dc50:	0093      	lsls	r3, r2, #2
 800dc52:	d42d      	bmi.n	800dcb0 <SDMMC_GetCmdResp1.part.2+0x70>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800dc54:	00d1      	lsls	r1, r2, #3
 800dc56:	d426      	bmi.n	800dca6 <SDMMC_GetCmdResp1.part.2+0x66>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800dc58:	0113      	lsls	r3, r2, #4
 800dc5a:	d42e      	bmi.n	800dcba <SDMMC_GetCmdResp1.part.2+0x7a>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800dc5c:	0151      	lsls	r1, r2, #5
 800dc5e:	d42f      	bmi.n	800dcc0 <SDMMC_GetCmdResp1.part.2+0x80>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800dc60:	01d3      	lsls	r3, r2, #7
 800dc62:	d427      	bmi.n	800dcb4 <SDMMC_GetCmdResp1.part.2+0x74>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800dc64:	0211      	lsls	r1, r2, #8
 800dc66:	d42e      	bmi.n	800dcc6 <SDMMC_GetCmdResp1.part.2+0x86>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800dc68:	0253      	lsls	r3, r2, #9
 800dc6a:	d42f      	bmi.n	800dccc <SDMMC_GetCmdResp1.part.2+0x8c>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800dc6c:	0291      	lsls	r1, r2, #10
 800dc6e:	d430      	bmi.n	800dcd2 <SDMMC_GetCmdResp1.part.2+0x92>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800dc70:	02d3      	lsls	r3, r2, #11
 800dc72:	d431      	bmi.n	800dcd8 <SDMMC_GetCmdResp1.part.2+0x98>
  {
    return SDMMC_ERROR_CC_ERR;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800dc74:	0351      	lsls	r1, r2, #13
 800dc76:	d432      	bmi.n	800dcde <SDMMC_GetCmdResp1.part.2+0x9e>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800dc78:	0393      	lsls	r3, r2, #14
 800dc7a:	d433      	bmi.n	800dce4 <SDMMC_GetCmdResp1.part.2+0xa4>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800dc7c:	03d1      	lsls	r1, r2, #15
 800dc7e:	d434      	bmi.n	800dcea <SDMMC_GetCmdResp1.part.2+0xaa>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800dc80:	0413      	lsls	r3, r2, #16
 800dc82:	d435      	bmi.n	800dcf0 <SDMMC_GetCmdResp1.part.2+0xb0>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800dc84:	0451      	lsls	r1, r2, #17
 800dc86:	d436      	bmi.n	800dcf6 <SDMMC_GetCmdResp1.part.2+0xb6>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800dc88:	0493      	lsls	r3, r2, #18
 800dc8a:	d437      	bmi.n	800dcfc <SDMMC_GetCmdResp1.part.2+0xbc>
  {
    return SDMMC_ERROR_ERASE_RESET;
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
 800dc8c:	f012 0f08 	tst.w	r2, #8
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800dc90:	bf14      	ite	ne
 800dc92:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
 800dc96:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800dc9a:	4770      	bx	lr
    return SDMMC_ERROR_NONE;
 800dc9c:	4618      	mov	r0, r3
 800dc9e:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800dca0:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 800dca4:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800dca6:	f44f 7080 	mov.w	r0, #256	; 0x100
 800dcaa:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800dcac:	2040      	movs	r0, #64	; 0x40
 800dcae:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800dcb0:	2080      	movs	r0, #128	; 0x80
 800dcb2:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800dcb4:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800dcb8:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800dcba:	f44f 7000 	mov.w	r0, #512	; 0x200
 800dcbe:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800dcc0:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800dcc4:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
 800dcc6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800dcca:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
 800dccc:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800dcd0:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800dcd2:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800dcd6:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
 800dcd8:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800dcdc:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800dcde:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800dce2:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800dce4:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800dce8:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800dcea:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800dcee:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800dcf0:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800dcf4:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800dcf6:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800dcfa:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
 800dcfc:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  }
}
 800dd00:	4770      	bx	lr
 800dd02:	bf00      	nop
 800dd04:	fdffe008 	.word	0xfdffe008

0800dd08 <SDMMC_Init>:
{
 800dd08:	b084      	sub	sp, #16
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
 800dd0a:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 800ddc4 <SDMMC_Init+0xbc>
{
 800dd0e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800dd12:	4605      	mov	r5, r0
 800dd14:	a809      	add	r0, sp, #36	; 0x24
 800dd16:	460c      	mov	r4, r1
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
 800dd18:	4565      	cmp	r5, ip
 800dd1a:	e9dd 760c 	ldrd	r7, r6, [sp, #48]	; 0x30
{
 800dd1e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
 800dd22:	e9dd 980a 	ldrd	r9, r8, [sp, #40]	; 0x28
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
 800dd26:	d002      	beq.n	800dd2e <SDMMC_Init+0x26>
 800dd28:	4b23      	ldr	r3, [pc, #140]	; (800ddb8 <SDMMC_Init+0xb0>)
 800dd2a:	429d      	cmp	r5, r3
 800dd2c:	d125      	bne.n	800dd7a <SDMMC_Init+0x72>
  assert_param(IS_SDMMC_CLOCK_EDGE(Init.ClockEdge));
 800dd2e:	f434 3380 	bics.w	r3, r4, #65536	; 0x10000
 800dd32:	d129      	bne.n	800dd88 <SDMMC_Init+0x80>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(Init.ClockPowerSave));
 800dd34:	f439 5380 	bics.w	r3, r9, #4096	; 0x1000
 800dd38:	d12d      	bne.n	800dd96 <SDMMC_Init+0x8e>
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
 800dd3a:	f438 4380 	bics.w	r3, r8, #16384	; 0x4000
 800dd3e:	d002      	beq.n	800dd46 <SDMMC_Init+0x3e>
 800dd40:	f5b8 4f00 	cmp.w	r8, #32768	; 0x8000
 800dd44:	d12c      	bne.n	800dda0 <SDMMC_Init+0x98>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
 800dd46:	f437 3300 	bics.w	r3, r7, #131072	; 0x20000
 800dd4a:	d130      	bne.n	800ddae <SDMMC_Init+0xa6>
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));
 800dd4c:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 800dd50:	d303      	bcc.n	800dd5a <SDMMC_Init+0x52>
 800dd52:	21d7      	movs	r1, #215	; 0xd7
 800dd54:	4819      	ldr	r0, [pc, #100]	; (800ddbc <SDMMC_Init+0xb4>)
 800dd56:	f005 fdbb 	bl	80138d0 <assert_failed>
  tmpreg |= (Init.ClockEdge           |\
 800dd5a:	ea44 0309 	orr.w	r3, r4, r9
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800dd5e:	6869      	ldr	r1, [r5, #4]
 800dd60:	4a17      	ldr	r2, [pc, #92]	; (800ddc0 <SDMMC_Init+0xb8>)
}
 800dd62:	2000      	movs	r0, #0
             Init.ClockPowerSave      |\
 800dd64:	ea43 0308 	orr.w	r3, r3, r8
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800dd68:	400a      	ands	r2, r1
             Init.BusWide             |\
 800dd6a:	433b      	orrs	r3, r7
             Init.HardwareFlowControl |\
 800dd6c:	4333      	orrs	r3, r6
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800dd6e:	4313      	orrs	r3, r2
 800dd70:	606b      	str	r3, [r5, #4]
}
 800dd72:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800dd76:	b004      	add	sp, #16
 800dd78:	4770      	bx	lr
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
 800dd7a:	21d2      	movs	r1, #210	; 0xd2
 800dd7c:	480f      	ldr	r0, [pc, #60]	; (800ddbc <SDMMC_Init+0xb4>)
 800dd7e:	f005 fda7 	bl	80138d0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_EDGE(Init.ClockEdge));
 800dd82:	f434 3380 	bics.w	r3, r4, #65536	; 0x10000
 800dd86:	d0d5      	beq.n	800dd34 <SDMMC_Init+0x2c>
 800dd88:	21d3      	movs	r1, #211	; 0xd3
 800dd8a:	480c      	ldr	r0, [pc, #48]	; (800ddbc <SDMMC_Init+0xb4>)
 800dd8c:	f005 fda0 	bl	80138d0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(Init.ClockPowerSave));
 800dd90:	f439 5380 	bics.w	r3, r9, #4096	; 0x1000
 800dd94:	d0d1      	beq.n	800dd3a <SDMMC_Init+0x32>
 800dd96:	21d4      	movs	r1, #212	; 0xd4
 800dd98:	4808      	ldr	r0, [pc, #32]	; (800ddbc <SDMMC_Init+0xb4>)
 800dd9a:	f005 fd99 	bl	80138d0 <assert_failed>
 800dd9e:	e7cc      	b.n	800dd3a <SDMMC_Init+0x32>
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
 800dda0:	21d5      	movs	r1, #213	; 0xd5
 800dda2:	4806      	ldr	r0, [pc, #24]	; (800ddbc <SDMMC_Init+0xb4>)
 800dda4:	f005 fd94 	bl	80138d0 <assert_failed>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
 800dda8:	f437 3300 	bics.w	r3, r7, #131072	; 0x20000
 800ddac:	d0ce      	beq.n	800dd4c <SDMMC_Init+0x44>
 800ddae:	21d6      	movs	r1, #214	; 0xd6
 800ddb0:	4802      	ldr	r0, [pc, #8]	; (800ddbc <SDMMC_Init+0xb4>)
 800ddb2:	f005 fd8d 	bl	80138d0 <assert_failed>
 800ddb6:	e7c9      	b.n	800dd4c <SDMMC_Init+0x44>
 800ddb8:	48022400 	.word	0x48022400
 800ddbc:	08029514 	.word	0x08029514
 800ddc0:	ffc02c00 	.word	0xffc02c00
 800ddc4:	52007000 	.word	0x52007000

0800ddc8 <SDMMC_ReadFIFO>:
  return (SDMMCx->FIFO);
 800ddc8:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
 800ddcc:	4770      	bx	lr
 800ddce:	bf00      	nop

0800ddd0 <SDMMC_WriteFIFO>:
{
 800ddd0:	4603      	mov	r3, r0
  SDMMCx->FIFO = *pWriteData;
 800ddd2:	680a      	ldr	r2, [r1, #0]
}
 800ddd4:	2000      	movs	r0, #0
  SDMMCx->FIFO = *pWriteData;
 800ddd6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 800ddda:	4770      	bx	lr

0800dddc <SDMMC_PowerState_ON>:
{
 800dddc:	4602      	mov	r2, r0
}
 800ddde:	2000      	movs	r0, #0
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
 800dde0:	6813      	ldr	r3, [r2, #0]
 800dde2:	f043 0303 	orr.w	r3, r3, #3
 800dde6:	6013      	str	r3, [r2, #0]
}
 800dde8:	4770      	bx	lr
 800ddea:	bf00      	nop

0800ddec <SDMMC_GetPowerState>:
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 800ddec:	6800      	ldr	r0, [r0, #0]
}
 800ddee:	f000 0003 	and.w	r0, r0, #3
 800ddf2:	4770      	bx	lr

0800ddf4 <SDMMC_GetResponse>:
{
 800ddf4:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_SDMMC_RESP(Response));
 800ddf6:	f031 030c 	bics.w	r3, r1, #12
{
 800ddfa:	460d      	mov	r5, r1
 800ddfc:	4604      	mov	r4, r0
  assert_param(IS_SDMMC_RESP(Response));
 800ddfe:	d004      	beq.n	800de0a <SDMMC_GetResponse+0x16>
 800de00:	f44f 71cc 	mov.w	r1, #408	; 0x198
 800de04:	4802      	ldr	r0, [pc, #8]	; (800de10 <SDMMC_GetResponse+0x1c>)
 800de06:	f005 fd63 	bl	80138d0 <assert_failed>
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
 800de0a:	3414      	adds	r4, #20
  return (*(__IO uint32_t *) tmp);
 800de0c:	5960      	ldr	r0, [r4, r5]
}
 800de0e:	bd38      	pop	{r3, r4, r5, pc}
 800de10:	08029514 	.word	0x08029514

0800de14 <SDMMC_ConfigData>:
{
 800de14:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
 800de16:	684b      	ldr	r3, [r1, #4]
{
 800de18:	460c      	mov	r4, r1
 800de1a:	4605      	mov	r5, r0
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
 800de1c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800de20:	d23b      	bcs.n	800de9a <SDMMC_ConfigData+0x86>
  assert_param(IS_SDMMC_BLOCK_SIZE(Data->DataBlockSize));
 800de22:	68a2      	ldr	r2, [r4, #8]
 800de24:	f032 0130 	bics.w	r1, r2, #48	; 0x30
 800de28:	bf14      	ite	ne
 800de2a:	2301      	movne	r3, #1
 800de2c:	2300      	moveq	r3, #0
 800de2e:	2940      	cmp	r1, #64	; 0x40
 800de30:	bf0c      	ite	eq
 800de32:	2300      	moveq	r3, #0
 800de34:	f003 0301 	andne.w	r3, r3, #1
 800de38:	2ae0      	cmp	r2, #224	; 0xe0
 800de3a:	bf0c      	ite	eq
 800de3c:	2300      	moveq	r3, #0
 800de3e:	f003 0301 	andne.w	r3, r3, #1
 800de42:	2980      	cmp	r1, #128	; 0x80
 800de44:	bf0c      	ite	eq
 800de46:	2300      	moveq	r3, #0
 800de48:	f003 0301 	andne.w	r3, r3, #1
 800de4c:	b11b      	cbz	r3, 800de56 <SDMMC_ConfigData+0x42>
 800de4e:	f022 0210 	bic.w	r2, r2, #16
 800de52:	2ac0      	cmp	r2, #192	; 0xc0
 800de54:	d133      	bne.n	800debe <SDMMC_ConfigData+0xaa>
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
 800de56:	68e3      	ldr	r3, [r4, #12]
 800de58:	f033 0302 	bics.w	r3, r3, #2
 800de5c:	d129      	bne.n	800deb2 <SDMMC_ConfigData+0x9e>
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
 800de5e:	6923      	ldr	r3, [r4, #16]
 800de60:	f033 0308 	bics.w	r3, r3, #8
 800de64:	d11f      	bne.n	800dea6 <SDMMC_ConfigData+0x92>
  assert_param(IS_SDMMC_DPSM(Data->DPSM));
 800de66:	6963      	ldr	r3, [r4, #20]
 800de68:	2b01      	cmp	r3, #1
 800de6a:	d904      	bls.n	800de76 <SDMMC_ConfigData+0x62>
 800de6c:	f240 11b1 	movw	r1, #433	; 0x1b1
 800de70:	4816      	ldr	r0, [pc, #88]	; (800decc <SDMMC_ConfigData+0xb8>)
 800de72:	f005 fd2d 	bl	80138d0 <assert_failed>
  SDMMCx->DTIMER = Data->DataTimeOut;
 800de76:	6823      	ldr	r3, [r4, #0]
}
 800de78:	2000      	movs	r0, #0
  SDMMCx->DTIMER = Data->DataTimeOut;
 800de7a:	626b      	str	r3, [r5, #36]	; 0x24
  SDMMCx->DLEN = Data->DataLength;
 800de7c:	6863      	ldr	r3, [r4, #4]
 800de7e:	62ab      	str	r3, [r5, #40]	; 0x28
                       Data->TransferDir   |\
 800de80:	6926      	ldr	r6, [r4, #16]
                       Data->TransferMode  |\
 800de82:	6961      	ldr	r1, [r4, #20]
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 800de84:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 800de88:	4313      	orrs	r3, r2
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800de8a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
                       Data->TransferDir   |\
 800de8c:	4333      	orrs	r3, r6
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800de8e:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
                       Data->TransferMode  |\
 800de92:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800de94:	4313      	orrs	r3, r2
 800de96:	62eb      	str	r3, [r5, #44]	; 0x2c
}
 800de98:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
 800de9a:	f240 11ad 	movw	r1, #429	; 0x1ad
 800de9e:	480b      	ldr	r0, [pc, #44]	; (800decc <SDMMC_ConfigData+0xb8>)
 800dea0:	f005 fd16 	bl	80138d0 <assert_failed>
 800dea4:	e7bd      	b.n	800de22 <SDMMC_ConfigData+0xe>
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
 800dea6:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 800deaa:	4808      	ldr	r0, [pc, #32]	; (800decc <SDMMC_ConfigData+0xb8>)
 800deac:	f005 fd10 	bl	80138d0 <assert_failed>
 800deb0:	e7d9      	b.n	800de66 <SDMMC_ConfigData+0x52>
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
 800deb2:	f240 11af 	movw	r1, #431	; 0x1af
 800deb6:	4805      	ldr	r0, [pc, #20]	; (800decc <SDMMC_ConfigData+0xb8>)
 800deb8:	f005 fd0a 	bl	80138d0 <assert_failed>
 800debc:	e7cf      	b.n	800de5e <SDMMC_ConfigData+0x4a>
  assert_param(IS_SDMMC_BLOCK_SIZE(Data->DataBlockSize));
 800debe:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 800dec2:	4802      	ldr	r0, [pc, #8]	; (800decc <SDMMC_ConfigData+0xb8>)
 800dec4:	f005 fd04 	bl	80138d0 <assert_failed>
 800dec8:	e7c5      	b.n	800de56 <SDMMC_ConfigData+0x42>
 800deca:	bf00      	nop
 800decc:	08029514 	.word	0x08029514

0800ded0 <SDMMC_CmdBlockLength>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800ded0:	4a1c      	ldr	r2, [pc, #112]	; (800df44 <SDMMC_CmdBlockLength+0x74>)
 800ded2:	4b1d      	ldr	r3, [pc, #116]	; (800df48 <SDMMC_CmdBlockLength+0x78>)
{
 800ded4:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800ded6:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ded8:	f241 1410 	movw	r4, #4368	; 0x1110
  SDMMCx->ARG = Command->Argument;
 800dedc:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800dede:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800dee2:	68c1      	ldr	r1, [r0, #12]
 800dee4:	4d19      	ldr	r5, [pc, #100]	; (800df4c <SDMMC_CmdBlockLength+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800dee6:	f241 3388 	movw	r3, #5000	; 0x1388
 800deea:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800deec:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800deee:	4918      	ldr	r1, [pc, #96]	; (800df50 <SDMMC_CmdBlockLength+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800def0:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800def4:	432c      	orrs	r4, r5
 800def6:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800def8:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800defc:	d312      	bcc.n	800df24 <SDMMC_CmdBlockLength+0x54>
    sta_reg = SDMMCx->STA;
 800defe:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800df00:	420a      	tst	r2, r1
 800df02:	d0f9      	beq.n	800def8 <SDMMC_CmdBlockLength+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800df04:	0494      	lsls	r4, r2, #18
 800df06:	d4f7      	bmi.n	800def8 <SDMMC_CmdBlockLength+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800df08:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800df0a:	075a      	lsls	r2, r3, #29
 800df0c:	d40e      	bmi.n	800df2c <SDMMC_CmdBlockLength+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800df0e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800df10:	07db      	lsls	r3, r3, #31
 800df12:	d40f      	bmi.n	800df34 <SDMMC_CmdBlockLength+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800df14:	4b0f      	ldr	r3, [pc, #60]	; (800df54 <SDMMC_CmdBlockLength+0x84>)
 800df16:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800df18:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800df1a:	b2db      	uxtb	r3, r3
 800df1c:	2b10      	cmp	r3, #16
 800df1e:	d00d      	beq.n	800df3c <SDMMC_CmdBlockLength+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800df20:	2001      	movs	r0, #1
  return errorstate;
 800df22:	e001      	b.n	800df28 <SDMMC_CmdBlockLength+0x58>
      return SDMMC_ERROR_TIMEOUT;
 800df24:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800df28:	bc30      	pop	{r4, r5}
 800df2a:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800df2c:	2304      	movs	r3, #4
 800df2e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800df30:	4618      	mov	r0, r3
 800df32:	e7f9      	b.n	800df28 <SDMMC_CmdBlockLength+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800df34:	2301      	movs	r3, #1
 800df36:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800df38:	4618      	mov	r0, r3
 800df3a:	e7f5      	b.n	800df28 <SDMMC_CmdBlockLength+0x58>
}
 800df3c:	bc30      	pop	{r4, r5}
 800df3e:	f7ff be7f 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800df42:	bf00      	nop
 800df44:	200002bc 	.word	0x200002bc
 800df48:	10624dd3 	.word	0x10624dd3
 800df4c:	fffee0c0 	.word	0xfffee0c0
 800df50:	00200045 	.word	0x00200045
 800df54:	002000c5 	.word	0x002000c5

0800df58 <SDMMC_CmdReadSingleBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800df58:	4a1c      	ldr	r2, [pc, #112]	; (800dfcc <SDMMC_CmdReadSingleBlock+0x74>)
 800df5a:	4b1d      	ldr	r3, [pc, #116]	; (800dfd0 <SDMMC_CmdReadSingleBlock+0x78>)
{
 800df5c:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800df5e:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800df60:	f241 1411 	movw	r4, #4369	; 0x1111
  SDMMCx->ARG = Command->Argument;
 800df64:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800df66:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800df6a:	68c1      	ldr	r1, [r0, #12]
 800df6c:	4d19      	ldr	r5, [pc, #100]	; (800dfd4 <SDMMC_CmdReadSingleBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800df6e:	f241 3388 	movw	r3, #5000	; 0x1388
 800df72:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800df74:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800df76:	4918      	ldr	r1, [pc, #96]	; (800dfd8 <SDMMC_CmdReadSingleBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800df78:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800df7c:	432c      	orrs	r4, r5
 800df7e:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800df80:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800df84:	d312      	bcc.n	800dfac <SDMMC_CmdReadSingleBlock+0x54>
    sta_reg = SDMMCx->STA;
 800df86:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800df88:	420a      	tst	r2, r1
 800df8a:	d0f9      	beq.n	800df80 <SDMMC_CmdReadSingleBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800df8c:	0494      	lsls	r4, r2, #18
 800df8e:	d4f7      	bmi.n	800df80 <SDMMC_CmdReadSingleBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800df90:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800df92:	075a      	lsls	r2, r3, #29
 800df94:	d40e      	bmi.n	800dfb4 <SDMMC_CmdReadSingleBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800df96:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800df98:	07db      	lsls	r3, r3, #31
 800df9a:	d40f      	bmi.n	800dfbc <SDMMC_CmdReadSingleBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800df9c:	4b0f      	ldr	r3, [pc, #60]	; (800dfdc <SDMMC_CmdReadSingleBlock+0x84>)
 800df9e:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800dfa0:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800dfa2:	b2db      	uxtb	r3, r3
 800dfa4:	2b11      	cmp	r3, #17
 800dfa6:	d00d      	beq.n	800dfc4 <SDMMC_CmdReadSingleBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800dfa8:	2001      	movs	r0, #1
  return errorstate;
 800dfaa:	e001      	b.n	800dfb0 <SDMMC_CmdReadSingleBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
 800dfac:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800dfb0:	bc30      	pop	{r4, r5}
 800dfb2:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800dfb4:	2304      	movs	r3, #4
 800dfb6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800dfb8:	4618      	mov	r0, r3
 800dfba:	e7f9      	b.n	800dfb0 <SDMMC_CmdReadSingleBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800dfbc:	2301      	movs	r3, #1
 800dfbe:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800dfc0:	4618      	mov	r0, r3
 800dfc2:	e7f5      	b.n	800dfb0 <SDMMC_CmdReadSingleBlock+0x58>
}
 800dfc4:	bc30      	pop	{r4, r5}
 800dfc6:	f7ff be3b 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800dfca:	bf00      	nop
 800dfcc:	200002bc 	.word	0x200002bc
 800dfd0:	10624dd3 	.word	0x10624dd3
 800dfd4:	fffee0c0 	.word	0xfffee0c0
 800dfd8:	00200045 	.word	0x00200045
 800dfdc:	002000c5 	.word	0x002000c5

0800dfe0 <SDMMC_CmdReadMultiBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800dfe0:	4a1c      	ldr	r2, [pc, #112]	; (800e054 <SDMMC_CmdReadMultiBlock+0x74>)
 800dfe2:	4b1d      	ldr	r3, [pc, #116]	; (800e058 <SDMMC_CmdReadMultiBlock+0x78>)
{
 800dfe4:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800dfe6:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800dfe8:	f241 1412 	movw	r4, #4370	; 0x1112
  SDMMCx->ARG = Command->Argument;
 800dfec:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800dfee:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800dff2:	68c1      	ldr	r1, [r0, #12]
 800dff4:	4d19      	ldr	r5, [pc, #100]	; (800e05c <SDMMC_CmdReadMultiBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800dff6:	f241 3388 	movw	r3, #5000	; 0x1388
 800dffa:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800dffc:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800dffe:	4918      	ldr	r1, [pc, #96]	; (800e060 <SDMMC_CmdReadMultiBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e000:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e004:	432c      	orrs	r4, r5
 800e006:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e008:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e00c:	d312      	bcc.n	800e034 <SDMMC_CmdReadMultiBlock+0x54>
    sta_reg = SDMMCx->STA;
 800e00e:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e010:	420a      	tst	r2, r1
 800e012:	d0f9      	beq.n	800e008 <SDMMC_CmdReadMultiBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e014:	0494      	lsls	r4, r2, #18
 800e016:	d4f7      	bmi.n	800e008 <SDMMC_CmdReadMultiBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e018:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e01a:	075a      	lsls	r2, r3, #29
 800e01c:	d40e      	bmi.n	800e03c <SDMMC_CmdReadMultiBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e01e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e020:	07db      	lsls	r3, r3, #31
 800e022:	d40f      	bmi.n	800e044 <SDMMC_CmdReadMultiBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e024:	4b0f      	ldr	r3, [pc, #60]	; (800e064 <SDMMC_CmdReadMultiBlock+0x84>)
 800e026:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e028:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e02a:	b2db      	uxtb	r3, r3
 800e02c:	2b12      	cmp	r3, #18
 800e02e:	d00d      	beq.n	800e04c <SDMMC_CmdReadMultiBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e030:	2001      	movs	r0, #1
  return errorstate;
 800e032:	e001      	b.n	800e038 <SDMMC_CmdReadMultiBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
 800e034:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e038:	bc30      	pop	{r4, r5}
 800e03a:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e03c:	2304      	movs	r3, #4
 800e03e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e040:	4618      	mov	r0, r3
 800e042:	e7f9      	b.n	800e038 <SDMMC_CmdReadMultiBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e044:	2301      	movs	r3, #1
 800e046:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e048:	4618      	mov	r0, r3
 800e04a:	e7f5      	b.n	800e038 <SDMMC_CmdReadMultiBlock+0x58>
}
 800e04c:	bc30      	pop	{r4, r5}
 800e04e:	f7ff bdf7 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800e052:	bf00      	nop
 800e054:	200002bc 	.word	0x200002bc
 800e058:	10624dd3 	.word	0x10624dd3
 800e05c:	fffee0c0 	.word	0xfffee0c0
 800e060:	00200045 	.word	0x00200045
 800e064:	002000c5 	.word	0x002000c5

0800e068 <SDMMC_CmdWriteSingleBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e068:	4a1c      	ldr	r2, [pc, #112]	; (800e0dc <SDMMC_CmdWriteSingleBlock+0x74>)
 800e06a:	4b1d      	ldr	r3, [pc, #116]	; (800e0e0 <SDMMC_CmdWriteSingleBlock+0x78>)
{
 800e06c:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e06e:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e070:	f241 1418 	movw	r4, #4376	; 0x1118
  SDMMCx->ARG = Command->Argument;
 800e074:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e076:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e07a:	68c1      	ldr	r1, [r0, #12]
 800e07c:	4d19      	ldr	r5, [pc, #100]	; (800e0e4 <SDMMC_CmdWriteSingleBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e07e:	f241 3388 	movw	r3, #5000	; 0x1388
 800e082:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e084:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e086:	4918      	ldr	r1, [pc, #96]	; (800e0e8 <SDMMC_CmdWriteSingleBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e088:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e08c:	432c      	orrs	r4, r5
 800e08e:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e090:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e094:	d312      	bcc.n	800e0bc <SDMMC_CmdWriteSingleBlock+0x54>
    sta_reg = SDMMCx->STA;
 800e096:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e098:	420a      	tst	r2, r1
 800e09a:	d0f9      	beq.n	800e090 <SDMMC_CmdWriteSingleBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e09c:	0494      	lsls	r4, r2, #18
 800e09e:	d4f7      	bmi.n	800e090 <SDMMC_CmdWriteSingleBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e0a0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e0a2:	075a      	lsls	r2, r3, #29
 800e0a4:	d40e      	bmi.n	800e0c4 <SDMMC_CmdWriteSingleBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e0a6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e0a8:	07db      	lsls	r3, r3, #31
 800e0aa:	d40f      	bmi.n	800e0cc <SDMMC_CmdWriteSingleBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e0ac:	4b0f      	ldr	r3, [pc, #60]	; (800e0ec <SDMMC_CmdWriteSingleBlock+0x84>)
 800e0ae:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e0b0:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e0b2:	b2db      	uxtb	r3, r3
 800e0b4:	2b18      	cmp	r3, #24
 800e0b6:	d00d      	beq.n	800e0d4 <SDMMC_CmdWriteSingleBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e0b8:	2001      	movs	r0, #1
  return errorstate;
 800e0ba:	e001      	b.n	800e0c0 <SDMMC_CmdWriteSingleBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
 800e0bc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e0c0:	bc30      	pop	{r4, r5}
 800e0c2:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e0c4:	2304      	movs	r3, #4
 800e0c6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e0c8:	4618      	mov	r0, r3
 800e0ca:	e7f9      	b.n	800e0c0 <SDMMC_CmdWriteSingleBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e0cc:	2301      	movs	r3, #1
 800e0ce:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e0d0:	4618      	mov	r0, r3
 800e0d2:	e7f5      	b.n	800e0c0 <SDMMC_CmdWriteSingleBlock+0x58>
}
 800e0d4:	bc30      	pop	{r4, r5}
 800e0d6:	f7ff bdb3 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800e0da:	bf00      	nop
 800e0dc:	200002bc 	.word	0x200002bc
 800e0e0:	10624dd3 	.word	0x10624dd3
 800e0e4:	fffee0c0 	.word	0xfffee0c0
 800e0e8:	00200045 	.word	0x00200045
 800e0ec:	002000c5 	.word	0x002000c5

0800e0f0 <SDMMC_CmdWriteMultiBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e0f0:	4a1c      	ldr	r2, [pc, #112]	; (800e164 <SDMMC_CmdWriteMultiBlock+0x74>)
 800e0f2:	4b1d      	ldr	r3, [pc, #116]	; (800e168 <SDMMC_CmdWriteMultiBlock+0x78>)
{
 800e0f4:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e0f6:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e0f8:	f241 1419 	movw	r4, #4377	; 0x1119
  SDMMCx->ARG = Command->Argument;
 800e0fc:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e0fe:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e102:	68c1      	ldr	r1, [r0, #12]
 800e104:	4d19      	ldr	r5, [pc, #100]	; (800e16c <SDMMC_CmdWriteMultiBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e106:	f241 3388 	movw	r3, #5000	; 0x1388
 800e10a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e10c:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e10e:	4918      	ldr	r1, [pc, #96]	; (800e170 <SDMMC_CmdWriteMultiBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e110:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e114:	432c      	orrs	r4, r5
 800e116:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e118:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e11c:	d312      	bcc.n	800e144 <SDMMC_CmdWriteMultiBlock+0x54>
    sta_reg = SDMMCx->STA;
 800e11e:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e120:	420a      	tst	r2, r1
 800e122:	d0f9      	beq.n	800e118 <SDMMC_CmdWriteMultiBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e124:	0494      	lsls	r4, r2, #18
 800e126:	d4f7      	bmi.n	800e118 <SDMMC_CmdWriteMultiBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e128:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e12a:	075a      	lsls	r2, r3, #29
 800e12c:	d40e      	bmi.n	800e14c <SDMMC_CmdWriteMultiBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e12e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e130:	07db      	lsls	r3, r3, #31
 800e132:	d40f      	bmi.n	800e154 <SDMMC_CmdWriteMultiBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e134:	4b0f      	ldr	r3, [pc, #60]	; (800e174 <SDMMC_CmdWriteMultiBlock+0x84>)
 800e136:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e138:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e13a:	b2db      	uxtb	r3, r3
 800e13c:	2b19      	cmp	r3, #25
 800e13e:	d00d      	beq.n	800e15c <SDMMC_CmdWriteMultiBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e140:	2001      	movs	r0, #1
  return errorstate;
 800e142:	e001      	b.n	800e148 <SDMMC_CmdWriteMultiBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
 800e144:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e148:	bc30      	pop	{r4, r5}
 800e14a:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e14c:	2304      	movs	r3, #4
 800e14e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e150:	4618      	mov	r0, r3
 800e152:	e7f9      	b.n	800e148 <SDMMC_CmdWriteMultiBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e154:	2301      	movs	r3, #1
 800e156:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e158:	4618      	mov	r0, r3
 800e15a:	e7f5      	b.n	800e148 <SDMMC_CmdWriteMultiBlock+0x58>
}
 800e15c:	bc30      	pop	{r4, r5}
 800e15e:	f7ff bd6f 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800e162:	bf00      	nop
 800e164:	200002bc 	.word	0x200002bc
 800e168:	10624dd3 	.word	0x10624dd3
 800e16c:	fffee0c0 	.word	0xfffee0c0
 800e170:	00200045 	.word	0x00200045
 800e174:	002000c5 	.word	0x002000c5

0800e178 <SDMMC_CmdStopTransfer>:
{
 800e178:	b570      	push	{r4, r5, r6, lr}
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800e17a:	68c3      	ldr	r3, [r0, #12]
  SDMMCx->ARG = Command->Argument;
 800e17c:	2600      	movs	r6, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e17e:	4a2a      	ldr	r2, [pc, #168]	; (800e228 <SDMMC_CmdStopTransfer+0xb0>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e180:	f241 140c 	movw	r4, #4364	; 0x110c
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800e184:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e188:	4d28      	ldr	r5, [pc, #160]	; (800e22c <SDMMC_CmdStopTransfer+0xb4>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e18a:	6812      	ldr	r2, [r2, #0]
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800e18c:	60c3      	str	r3, [r0, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800e18e:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e190:	4b27      	ldr	r3, [pc, #156]	; (800e230 <SDMMC_CmdStopTransfer+0xb8>)
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800e192:	f021 0140 	bic.w	r1, r1, #64	; 0x40
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e196:	fba3 3202 	umull	r3, r2, r3, r2
 800e19a:	4b26      	ldr	r3, [pc, #152]	; (800e234 <SDMMC_CmdStopTransfer+0xbc>)
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800e19c:	60c1      	str	r1, [r0, #12]
  SDMMCx->ARG = Command->Argument;
 800e19e:	6086      	str	r6, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e1a0:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e1a2:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e1a4:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e1a8:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e1aa:	4923      	ldr	r1, [pc, #140]	; (800e238 <SDMMC_CmdStopTransfer+0xc0>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e1ac:	432c      	orrs	r4, r5
 800e1ae:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e1b0:	b1c3      	cbz	r3, 800e1e4 <SDMMC_CmdStopTransfer+0x6c>
    sta_reg = SDMMCx->STA;
 800e1b2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800e1b4:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e1b6:	420a      	tst	r2, r1
 800e1b8:	d0fa      	beq.n	800e1b0 <SDMMC_CmdStopTransfer+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e1ba:	0492      	lsls	r2, r2, #18
 800e1bc:	d4f8      	bmi.n	800e1b0 <SDMMC_CmdStopTransfer+0x38>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e1be:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e1c0:	075b      	lsls	r3, r3, #29
 800e1c2:	d417      	bmi.n	800e1f4 <SDMMC_CmdStopTransfer+0x7c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e1c4:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800e1c6:	f014 0401 	ands.w	r4, r4, #1
 800e1ca:	d11a      	bne.n	800e202 <SDMMC_CmdStopTransfer+0x8a>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e1cc:	4b1b      	ldr	r3, [pc, #108]	; (800e23c <SDMMC_CmdStopTransfer+0xc4>)
 800e1ce:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e1d0:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e1d2:	b2db      	uxtb	r3, r3
 800e1d4:	2b0c      	cmp	r3, #12
 800e1d6:	d01b      	beq.n	800e210 <SDMMC_CmdStopTransfer+0x98>
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800e1d8:	68c3      	ldr	r3, [r0, #12]
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e1da:	2401      	movs	r4, #1
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800e1dc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e1e0:	60c3      	str	r3, [r0, #12]
 800e1e2:	e005      	b.n	800e1f0 <SDMMC_CmdStopTransfer+0x78>
 800e1e4:	68c3      	ldr	r3, [r0, #12]
      return SDMMC_ERROR_TIMEOUT;
 800e1e6:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800e1ea:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e1ee:	60c3      	str	r3, [r0, #12]
}
 800e1f0:	4620      	mov	r0, r4
 800e1f2:	bd70      	pop	{r4, r5, r6, pc}
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e1f4:	2404      	movs	r4, #4
 800e1f6:	6384      	str	r4, [r0, #56]	; 0x38
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800e1f8:	68c3      	ldr	r3, [r0, #12]
 800e1fa:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e1fe:	60c3      	str	r3, [r0, #12]
 800e200:	e7f6      	b.n	800e1f0 <SDMMC_CmdStopTransfer+0x78>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e202:	2401      	movs	r4, #1
 800e204:	6384      	str	r4, [r0, #56]	; 0x38
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800e206:	68c3      	ldr	r3, [r0, #12]
 800e208:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e20c:	60c3      	str	r3, [r0, #12]
 800e20e:	e7ef      	b.n	800e1f0 <SDMMC_CmdStopTransfer+0x78>
 800e210:	4605      	mov	r5, r0
 800e212:	f7ff fd15 	bl	800dc40 <SDMMC_GetCmdResp1.part.2>
  if (errorstate == SDMMC_ERROR_ADDR_OUT_OF_RANGE)
 800e216:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
 800e21a:	bf18      	it	ne
 800e21c:	4604      	movne	r4, r0
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800e21e:	68eb      	ldr	r3, [r5, #12]
 800e220:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e224:	60eb      	str	r3, [r5, #12]
 800e226:	e7e3      	b.n	800e1f0 <SDMMC_CmdStopTransfer+0x78>
 800e228:	200002bc 	.word	0x200002bc
 800e22c:	fffee0c0 	.word	0xfffee0c0
 800e230:	10624dd3 	.word	0x10624dd3
 800e234:	05f5e100 	.word	0x05f5e100
 800e238:	00200045 	.word	0x00200045
 800e23c:	002000c5 	.word	0x002000c5

0800e240 <SDMMC_CmdSelDesel>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e240:	4b1c      	ldr	r3, [pc, #112]	; (800e2b4 <SDMMC_CmdSelDesel+0x74>)
 800e242:	491d      	ldr	r1, [pc, #116]	; (800e2b8 <SDMMC_CmdSelDesel+0x78>)
{
 800e244:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e246:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e248:	f241 1407 	movw	r4, #4359	; 0x1107
  SDMMCx->ARG = Command->Argument;
 800e24c:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e24e:	4d1b      	ldr	r5, [pc, #108]	; (800e2bc <SDMMC_CmdSelDesel+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e250:	fba1 3203 	umull	r3, r2, r1, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e254:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e256:	f241 3388 	movw	r3, #5000	; 0x1388
 800e25a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e25c:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e25e:	4918      	ldr	r1, [pc, #96]	; (800e2c0 <SDMMC_CmdSelDesel+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e260:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e264:	432c      	orrs	r4, r5
 800e266:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e268:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e26c:	d312      	bcc.n	800e294 <SDMMC_CmdSelDesel+0x54>
    sta_reg = SDMMCx->STA;
 800e26e:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e270:	420a      	tst	r2, r1
 800e272:	d0f9      	beq.n	800e268 <SDMMC_CmdSelDesel+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e274:	0494      	lsls	r4, r2, #18
 800e276:	d4f7      	bmi.n	800e268 <SDMMC_CmdSelDesel+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e278:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e27a:	075a      	lsls	r2, r3, #29
 800e27c:	d40e      	bmi.n	800e29c <SDMMC_CmdSelDesel+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e27e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e280:	07db      	lsls	r3, r3, #31
 800e282:	d40f      	bmi.n	800e2a4 <SDMMC_CmdSelDesel+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e284:	4b0f      	ldr	r3, [pc, #60]	; (800e2c4 <SDMMC_CmdSelDesel+0x84>)
 800e286:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e288:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e28a:	b2db      	uxtb	r3, r3
 800e28c:	2b07      	cmp	r3, #7
 800e28e:	d00d      	beq.n	800e2ac <SDMMC_CmdSelDesel+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e290:	2001      	movs	r0, #1
  return errorstate;
 800e292:	e001      	b.n	800e298 <SDMMC_CmdSelDesel+0x58>
      return SDMMC_ERROR_TIMEOUT;
 800e294:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e298:	bc30      	pop	{r4, r5}
 800e29a:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e29c:	2304      	movs	r3, #4
 800e29e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e2a0:	4618      	mov	r0, r3
 800e2a2:	e7f9      	b.n	800e298 <SDMMC_CmdSelDesel+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e2a4:	2301      	movs	r3, #1
 800e2a6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e2a8:	4618      	mov	r0, r3
 800e2aa:	e7f5      	b.n	800e298 <SDMMC_CmdSelDesel+0x58>
}
 800e2ac:	bc30      	pop	{r4, r5}
 800e2ae:	f7ff bcc7 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800e2b2:	bf00      	nop
 800e2b4:	200002bc 	.word	0x200002bc
 800e2b8:	10624dd3 	.word	0x10624dd3
 800e2bc:	fffee0c0 	.word	0xfffee0c0
 800e2c0:	00200045 	.word	0x00200045
 800e2c4:	002000c5 	.word	0x002000c5

0800e2c8 <SDMMC_CmdGoIdleState>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e2c8:	4b12      	ldr	r3, [pc, #72]	; (800e314 <SDMMC_CmdGoIdleState+0x4c>)
{
 800e2ca:	4602      	mov	r2, r0
  SDMMCx->ARG = Command->Argument;
 800e2cc:	2100      	movs	r1, #0
{
 800e2ce:	b410      	push	{r4}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e2d0:	4c11      	ldr	r4, [pc, #68]	; (800e318 <SDMMC_CmdGoIdleState+0x50>)
 800e2d2:	6818      	ldr	r0, [r3, #0]
 800e2d4:	f241 3388 	movw	r3, #5000	; 0x1388
  SDMMCx->ARG = Command->Argument;
 800e2d8:	6091      	str	r1, [r2, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e2da:	fba4 4000 	umull	r4, r0, r4, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e2de:	490f      	ldr	r1, [pc, #60]	; (800e31c <SDMMC_CmdGoIdleState+0x54>)
 800e2e0:	68d4      	ldr	r4, [r2, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e2e2:	0a40      	lsrs	r0, r0, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e2e4:	4021      	ands	r1, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e2e6:	fb03 f300 	mul.w	r3, r3, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e2ea:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 800e2ee:	60d1      	str	r1, [r2, #12]
 800e2f0:	e002      	b.n	800e2f8 <SDMMC_CmdGoIdleState+0x30>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 800e2f2:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800e2f4:	0609      	lsls	r1, r1, #24
 800e2f6:	d407      	bmi.n	800e308 <SDMMC_CmdGoIdleState+0x40>
    if (count-- == 0U)
 800e2f8:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e2fc:	d2f9      	bcs.n	800e2f2 <SDMMC_CmdGoIdleState+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 800e2fe:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e302:	f85d 4b04 	ldr.w	r4, [sp], #4
 800e306:	4770      	bx	lr
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e308:	4b05      	ldr	r3, [pc, #20]	; (800e320 <SDMMC_CmdGoIdleState+0x58>)
  return SDMMC_ERROR_NONE;
 800e30a:	2000      	movs	r0, #0
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e30c:	6393      	str	r3, [r2, #56]	; 0x38
}
 800e30e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800e312:	4770      	bx	lr
 800e314:	200002bc 	.word	0x200002bc
 800e318:	10624dd3 	.word	0x10624dd3
 800e31c:	fffee0c0 	.word	0xfffee0c0
 800e320:	002000c5 	.word	0x002000c5

0800e324 <SDMMC_CmdOperCond>:
static uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e324:	4a1c      	ldr	r2, [pc, #112]	; (800e398 <SDMMC_CmdOperCond+0x74>)
{
 800e326:	4601      	mov	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e328:	4b1c      	ldr	r3, [pc, #112]	; (800e39c <SDMMC_CmdOperCond+0x78>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e32a:	f241 1008 	movw	r0, #4360	; 0x1108
{
 800e32e:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
 800e330:	f44f 74d5 	mov.w	r4, #426	; 0x1aa
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e334:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
 800e336:	608c      	str	r4, [r1, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e338:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e33c:	68cd      	ldr	r5, [r1, #12]
 800e33e:	4c18      	ldr	r4, [pc, #96]	; (800e3a0 <SDMMC_CmdOperCond+0x7c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e340:	f241 3388 	movw	r3, #5000	; 0x1388
 800e344:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e346:	402c      	ands	r4, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e348:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e34c:	4320      	orrs	r0, r4
 800e34e:	60c8      	str	r0, [r1, #12]

  do
  {
    if (count-- == 0U)
 800e350:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e354:	d313      	bcc.n	800e37e <SDMMC_CmdOperCond+0x5a>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800e356:	6b4a      	ldr	r2, [r1, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e358:	f012 0f45 	tst.w	r2, #69	; 0x45
 800e35c:	d0f8      	beq.n	800e350 <SDMMC_CmdOperCond+0x2c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800e35e:	0492      	lsls	r2, r2, #18
 800e360:	d4f6      	bmi.n	800e350 <SDMMC_CmdOperCond+0x2c>

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e362:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800e364:	075b      	lsls	r3, r3, #29
 800e366:	d40e      	bmi.n	800e386 <SDMMC_CmdOperCond+0x62>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }

  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e368:	6b48      	ldr	r0, [r1, #52]	; 0x34
 800e36a:	f010 0001 	ands.w	r0, r0, #1
 800e36e:	d10d      	bne.n	800e38c <SDMMC_CmdOperCond+0x68>
  else
  {
    /* Nothing to do */
  }

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
 800e370:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800e372:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 800e376:	d00c      	beq.n	800e392 <SDMMC_CmdOperCond+0x6e>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 800e378:	2340      	movs	r3, #64	; 0x40
 800e37a:	638b      	str	r3, [r1, #56]	; 0x38
 800e37c:	e001      	b.n	800e382 <SDMMC_CmdOperCond+0x5e>
      return SDMMC_ERROR_TIMEOUT;
 800e37e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e382:	bc30      	pop	{r4, r5}
 800e384:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e386:	2004      	movs	r0, #4
 800e388:	6388      	str	r0, [r1, #56]	; 0x38
 800e38a:	e7fa      	b.n	800e382 <SDMMC_CmdOperCond+0x5e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e38c:	2001      	movs	r0, #1
 800e38e:	6388      	str	r0, [r1, #56]	; 0x38
 800e390:	e7f7      	b.n	800e382 <SDMMC_CmdOperCond+0x5e>
  }

  return SDMMC_ERROR_NONE;
 800e392:	4618      	mov	r0, r3
  return errorstate;
 800e394:	e7f5      	b.n	800e382 <SDMMC_CmdOperCond+0x5e>
 800e396:	bf00      	nop
 800e398:	200002bc 	.word	0x200002bc
 800e39c:	10624dd3 	.word	0x10624dd3
 800e3a0:	fffee0c0 	.word	0xfffee0c0

0800e3a4 <SDMMC_CmdAppCommand>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e3a4:	4a1c      	ldr	r2, [pc, #112]	; (800e418 <SDMMC_CmdAppCommand+0x74>)
 800e3a6:	4b1d      	ldr	r3, [pc, #116]	; (800e41c <SDMMC_CmdAppCommand+0x78>)
{
 800e3a8:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e3aa:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e3ac:	f241 1437 	movw	r4, #4407	; 0x1137
  SDMMCx->ARG = Command->Argument;
 800e3b0:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e3b2:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e3b6:	68c1      	ldr	r1, [r0, #12]
 800e3b8:	4d19      	ldr	r5, [pc, #100]	; (800e420 <SDMMC_CmdAppCommand+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e3ba:	f241 3388 	movw	r3, #5000	; 0x1388
 800e3be:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e3c0:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e3c2:	4918      	ldr	r1, [pc, #96]	; (800e424 <SDMMC_CmdAppCommand+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e3c4:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e3c8:	432c      	orrs	r4, r5
 800e3ca:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e3cc:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e3d0:	d312      	bcc.n	800e3f8 <SDMMC_CmdAppCommand+0x54>
    sta_reg = SDMMCx->STA;
 800e3d2:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e3d4:	420a      	tst	r2, r1
 800e3d6:	d0f9      	beq.n	800e3cc <SDMMC_CmdAppCommand+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e3d8:	0494      	lsls	r4, r2, #18
 800e3da:	d4f7      	bmi.n	800e3cc <SDMMC_CmdAppCommand+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e3dc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e3de:	075a      	lsls	r2, r3, #29
 800e3e0:	d40e      	bmi.n	800e400 <SDMMC_CmdAppCommand+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e3e2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e3e4:	07db      	lsls	r3, r3, #31
 800e3e6:	d40f      	bmi.n	800e408 <SDMMC_CmdAppCommand+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e3e8:	4b0f      	ldr	r3, [pc, #60]	; (800e428 <SDMMC_CmdAppCommand+0x84>)
 800e3ea:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e3ec:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e3ee:	b2db      	uxtb	r3, r3
 800e3f0:	2b37      	cmp	r3, #55	; 0x37
 800e3f2:	d00d      	beq.n	800e410 <SDMMC_CmdAppCommand+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e3f4:	2001      	movs	r0, #1
  return errorstate;
 800e3f6:	e001      	b.n	800e3fc <SDMMC_CmdAppCommand+0x58>
      return SDMMC_ERROR_TIMEOUT;
 800e3f8:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e3fc:	bc30      	pop	{r4, r5}
 800e3fe:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e400:	2304      	movs	r3, #4
 800e402:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e404:	4618      	mov	r0, r3
 800e406:	e7f9      	b.n	800e3fc <SDMMC_CmdAppCommand+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e408:	2301      	movs	r3, #1
 800e40a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e40c:	4618      	mov	r0, r3
 800e40e:	e7f5      	b.n	800e3fc <SDMMC_CmdAppCommand+0x58>
}
 800e410:	bc30      	pop	{r4, r5}
 800e412:	f7ff bc15 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800e416:	bf00      	nop
 800e418:	200002bc 	.word	0x200002bc
 800e41c:	10624dd3 	.word	0x10624dd3
 800e420:	fffee0c0 	.word	0xfffee0c0
 800e424:	00200045 	.word	0x00200045
 800e428:	002000c5 	.word	0x002000c5

0800e42c <SDMMC_CmdAppOperCommand>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e42c:	4a15      	ldr	r2, [pc, #84]	; (800e484 <SDMMC_CmdAppOperCommand+0x58>)
 800e42e:	4b16      	ldr	r3, [pc, #88]	; (800e488 <SDMMC_CmdAppOperCommand+0x5c>)
{
 800e430:	b430      	push	{r4, r5}
 800e432:	4604      	mov	r4, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e434:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e436:	f241 1029 	movw	r0, #4393	; 0x1129
  SDMMCx->ARG = Command->Argument;
 800e43a:	60a1      	str	r1, [r4, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e43c:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e440:	68e5      	ldr	r5, [r4, #12]
 800e442:	4912      	ldr	r1, [pc, #72]	; (800e48c <SDMMC_CmdAppOperCommand+0x60>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e444:	f241 3388 	movw	r3, #5000	; 0x1388
 800e448:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e44a:	4029      	ands	r1, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e44c:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e450:	4308      	orrs	r0, r1
 800e452:	60e0      	str	r0, [r4, #12]
    if (count-- == 0U)
 800e454:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e458:	d30d      	bcc.n	800e476 <SDMMC_CmdAppOperCommand+0x4a>
    sta_reg = SDMMCx->STA;
 800e45a:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e45c:	f012 0f45 	tst.w	r2, #69	; 0x45
 800e460:	d0f8      	beq.n	800e454 <SDMMC_CmdAppOperCommand+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800e462:	0492      	lsls	r2, r2, #18
 800e464:	d4f6      	bmi.n	800e454 <SDMMC_CmdAppOperCommand+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e466:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800e468:	f010 0004 	ands.w	r0, r0, #4
 800e46c:	d107      	bne.n	800e47e <SDMMC_CmdAppOperCommand+0x52>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e46e:	4b08      	ldr	r3, [pc, #32]	; (800e490 <SDMMC_CmdAppOperCommand+0x64>)
 800e470:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800e472:	bc30      	pop	{r4, r5}
 800e474:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
 800e476:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e47a:	bc30      	pop	{r4, r5}
 800e47c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e47e:	2004      	movs	r0, #4
 800e480:	63a0      	str	r0, [r4, #56]	; 0x38
 800e482:	e7fa      	b.n	800e47a <SDMMC_CmdAppOperCommand+0x4e>
 800e484:	200002bc 	.word	0x200002bc
 800e488:	10624dd3 	.word	0x10624dd3
 800e48c:	fffee0c0 	.word	0xfffee0c0
 800e490:	002000c5 	.word	0x002000c5

0800e494 <SDMMC_CmdBusWidth>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e494:	4a1c      	ldr	r2, [pc, #112]	; (800e508 <SDMMC_CmdBusWidth+0x74>)
 800e496:	4b1d      	ldr	r3, [pc, #116]	; (800e50c <SDMMC_CmdBusWidth+0x78>)
{
 800e498:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e49a:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e49c:	f241 1406 	movw	r4, #4358	; 0x1106
  SDMMCx->ARG = Command->Argument;
 800e4a0:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e4a2:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e4a6:	68c1      	ldr	r1, [r0, #12]
 800e4a8:	4d19      	ldr	r5, [pc, #100]	; (800e510 <SDMMC_CmdBusWidth+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e4aa:	f241 3388 	movw	r3, #5000	; 0x1388
 800e4ae:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e4b0:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e4b2:	4918      	ldr	r1, [pc, #96]	; (800e514 <SDMMC_CmdBusWidth+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e4b4:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e4b8:	432c      	orrs	r4, r5
 800e4ba:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e4bc:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e4c0:	d312      	bcc.n	800e4e8 <SDMMC_CmdBusWidth+0x54>
    sta_reg = SDMMCx->STA;
 800e4c2:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e4c4:	420a      	tst	r2, r1
 800e4c6:	d0f9      	beq.n	800e4bc <SDMMC_CmdBusWidth+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e4c8:	0494      	lsls	r4, r2, #18
 800e4ca:	d4f7      	bmi.n	800e4bc <SDMMC_CmdBusWidth+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e4cc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e4ce:	075a      	lsls	r2, r3, #29
 800e4d0:	d40e      	bmi.n	800e4f0 <SDMMC_CmdBusWidth+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e4d2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e4d4:	07db      	lsls	r3, r3, #31
 800e4d6:	d40f      	bmi.n	800e4f8 <SDMMC_CmdBusWidth+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e4d8:	4b0f      	ldr	r3, [pc, #60]	; (800e518 <SDMMC_CmdBusWidth+0x84>)
 800e4da:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e4dc:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e4de:	b2db      	uxtb	r3, r3
 800e4e0:	2b06      	cmp	r3, #6
 800e4e2:	d00d      	beq.n	800e500 <SDMMC_CmdBusWidth+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e4e4:	2001      	movs	r0, #1
  return errorstate;
 800e4e6:	e001      	b.n	800e4ec <SDMMC_CmdBusWidth+0x58>
      return SDMMC_ERROR_TIMEOUT;
 800e4e8:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e4ec:	bc30      	pop	{r4, r5}
 800e4ee:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e4f0:	2304      	movs	r3, #4
 800e4f2:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e4f4:	4618      	mov	r0, r3
 800e4f6:	e7f9      	b.n	800e4ec <SDMMC_CmdBusWidth+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e4f8:	2301      	movs	r3, #1
 800e4fa:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e4fc:	4618      	mov	r0, r3
 800e4fe:	e7f5      	b.n	800e4ec <SDMMC_CmdBusWidth+0x58>
}
 800e500:	bc30      	pop	{r4, r5}
 800e502:	f7ff bb9d 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800e506:	bf00      	nop
 800e508:	200002bc 	.word	0x200002bc
 800e50c:	10624dd3 	.word	0x10624dd3
 800e510:	fffee0c0 	.word	0xfffee0c0
 800e514:	00200045 	.word	0x00200045
 800e518:	002000c5 	.word	0x002000c5

0800e51c <SDMMC_CmdSendSCR>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e51c:	4a1c      	ldr	r2, [pc, #112]	; (800e590 <SDMMC_CmdSendSCR+0x74>)
  SDMMCx->ARG = Command->Argument;
 800e51e:	2100      	movs	r1, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e520:	4b1c      	ldr	r3, [pc, #112]	; (800e594 <SDMMC_CmdSendSCR+0x78>)
{
 800e522:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e524:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e526:	f241 1433 	movw	r4, #4403	; 0x1133
  SDMMCx->ARG = Command->Argument;
 800e52a:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e52c:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e530:	68c1      	ldr	r1, [r0, #12]
 800e532:	4d19      	ldr	r5, [pc, #100]	; (800e598 <SDMMC_CmdSendSCR+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e534:	f241 3388 	movw	r3, #5000	; 0x1388
 800e538:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e53a:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e53c:	4917      	ldr	r1, [pc, #92]	; (800e59c <SDMMC_CmdSendSCR+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e53e:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e542:	432c      	orrs	r4, r5
 800e544:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e546:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e54a:	d312      	bcc.n	800e572 <SDMMC_CmdSendSCR+0x56>
    sta_reg = SDMMCx->STA;
 800e54c:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e54e:	420a      	tst	r2, r1
 800e550:	d0f9      	beq.n	800e546 <SDMMC_CmdSendSCR+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e552:	0494      	lsls	r4, r2, #18
 800e554:	d4f7      	bmi.n	800e546 <SDMMC_CmdSendSCR+0x2a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e556:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e558:	075a      	lsls	r2, r3, #29
 800e55a:	d40e      	bmi.n	800e57a <SDMMC_CmdSendSCR+0x5e>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e55c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e55e:	07db      	lsls	r3, r3, #31
 800e560:	d40f      	bmi.n	800e582 <SDMMC_CmdSendSCR+0x66>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e562:	4b0f      	ldr	r3, [pc, #60]	; (800e5a0 <SDMMC_CmdSendSCR+0x84>)
 800e564:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e566:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e568:	b2db      	uxtb	r3, r3
 800e56a:	2b33      	cmp	r3, #51	; 0x33
 800e56c:	d00d      	beq.n	800e58a <SDMMC_CmdSendSCR+0x6e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e56e:	2001      	movs	r0, #1
  return errorstate;
 800e570:	e001      	b.n	800e576 <SDMMC_CmdSendSCR+0x5a>
      return SDMMC_ERROR_TIMEOUT;
 800e572:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e576:	bc30      	pop	{r4, r5}
 800e578:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e57a:	2304      	movs	r3, #4
 800e57c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e57e:	4618      	mov	r0, r3
 800e580:	e7f9      	b.n	800e576 <SDMMC_CmdSendSCR+0x5a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e582:	2301      	movs	r3, #1
 800e584:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e586:	4618      	mov	r0, r3
 800e588:	e7f5      	b.n	800e576 <SDMMC_CmdSendSCR+0x5a>
}
 800e58a:	bc30      	pop	{r4, r5}
 800e58c:	f7ff bb58 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800e590:	200002bc 	.word	0x200002bc
 800e594:	10624dd3 	.word	0x10624dd3
 800e598:	fffee0c0 	.word	0xfffee0c0
 800e59c:	00200045 	.word	0x00200045
 800e5a0:	002000c5 	.word	0x002000c5

0800e5a4 <SDMMC_CmdSendCID>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e5a4:	4a18      	ldr	r2, [pc, #96]	; (800e608 <SDMMC_CmdSendCID+0x64>)
{
 800e5a6:	4601      	mov	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e5a8:	4b18      	ldr	r3, [pc, #96]	; (800e60c <SDMMC_CmdSendCID+0x68>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e5aa:	f241 3002 	movw	r0, #4866	; 0x1302
{
 800e5ae:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
 800e5b0:	2400      	movs	r4, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e5b2:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
 800e5b4:	608c      	str	r4, [r1, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e5b6:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e5ba:	68cd      	ldr	r5, [r1, #12]
 800e5bc:	4c14      	ldr	r4, [pc, #80]	; (800e610 <SDMMC_CmdSendCID+0x6c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e5be:	f241 3388 	movw	r3, #5000	; 0x1388
 800e5c2:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e5c4:	402c      	ands	r4, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e5c6:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e5ca:	4320      	orrs	r0, r4
 800e5cc:	60c8      	str	r0, [r1, #12]
    if (count-- == 0U)
 800e5ce:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e5d2:	d30f      	bcc.n	800e5f4 <SDMMC_CmdSendCID+0x50>
    sta_reg = SDMMCx->STA;
 800e5d4:	6b4a      	ldr	r2, [r1, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e5d6:	f012 0f45 	tst.w	r2, #69	; 0x45
 800e5da:	d0f8      	beq.n	800e5ce <SDMMC_CmdSendCID+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800e5dc:	0492      	lsls	r2, r2, #18
 800e5de:	d4f6      	bmi.n	800e5ce <SDMMC_CmdSendCID+0x2a>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e5e0:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800e5e2:	075b      	lsls	r3, r3, #29
 800e5e4:	d40a      	bmi.n	800e5fc <SDMMC_CmdSendCID+0x58>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e5e6:	6b48      	ldr	r0, [r1, #52]	; 0x34
 800e5e8:	f010 0001 	ands.w	r0, r0, #1
 800e5ec:	d109      	bne.n	800e602 <SDMMC_CmdSendCID+0x5e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e5ee:	4b09      	ldr	r3, [pc, #36]	; (800e614 <SDMMC_CmdSendCID+0x70>)
 800e5f0:	638b      	str	r3, [r1, #56]	; 0x38
 800e5f2:	e001      	b.n	800e5f8 <SDMMC_CmdSendCID+0x54>
      return SDMMC_ERROR_TIMEOUT;
 800e5f4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e5f8:	bc30      	pop	{r4, r5}
 800e5fa:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e5fc:	2004      	movs	r0, #4
 800e5fe:	6388      	str	r0, [r1, #56]	; 0x38
 800e600:	e7fa      	b.n	800e5f8 <SDMMC_CmdSendCID+0x54>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e602:	2001      	movs	r0, #1
 800e604:	6388      	str	r0, [r1, #56]	; 0x38
 800e606:	e7f7      	b.n	800e5f8 <SDMMC_CmdSendCID+0x54>
 800e608:	200002bc 	.word	0x200002bc
 800e60c:	10624dd3 	.word	0x10624dd3
 800e610:	fffee0c0 	.word	0xfffee0c0
 800e614:	002000c5 	.word	0x002000c5

0800e618 <SDMMC_CmdSendCSD>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e618:	4a18      	ldr	r2, [pc, #96]	; (800e67c <SDMMC_CmdSendCSD+0x64>)
 800e61a:	4b19      	ldr	r3, [pc, #100]	; (800e680 <SDMMC_CmdSendCSD+0x68>)
{
 800e61c:	b430      	push	{r4, r5}
 800e61e:	4604      	mov	r4, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e620:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e622:	f241 3009 	movw	r0, #4873	; 0x1309
  SDMMCx->ARG = Command->Argument;
 800e626:	60a1      	str	r1, [r4, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e628:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e62c:	68e5      	ldr	r5, [r4, #12]
 800e62e:	4915      	ldr	r1, [pc, #84]	; (800e684 <SDMMC_CmdSendCSD+0x6c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e630:	f241 3388 	movw	r3, #5000	; 0x1388
 800e634:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e636:	4029      	ands	r1, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e638:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e63c:	4308      	orrs	r0, r1
 800e63e:	60e0      	str	r0, [r4, #12]
    if (count-- == 0U)
 800e640:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e644:	d30f      	bcc.n	800e666 <SDMMC_CmdSendCSD+0x4e>
    sta_reg = SDMMCx->STA;
 800e646:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e648:	f012 0f45 	tst.w	r2, #69	; 0x45
 800e64c:	d0f8      	beq.n	800e640 <SDMMC_CmdSendCSD+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800e64e:	0492      	lsls	r2, r2, #18
 800e650:	d4f6      	bmi.n	800e640 <SDMMC_CmdSendCSD+0x28>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e652:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800e654:	075b      	lsls	r3, r3, #29
 800e656:	d40a      	bmi.n	800e66e <SDMMC_CmdSendCSD+0x56>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e658:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800e65a:	f010 0001 	ands.w	r0, r0, #1
 800e65e:	d109      	bne.n	800e674 <SDMMC_CmdSendCSD+0x5c>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e660:	4b09      	ldr	r3, [pc, #36]	; (800e688 <SDMMC_CmdSendCSD+0x70>)
 800e662:	63a3      	str	r3, [r4, #56]	; 0x38
 800e664:	e001      	b.n	800e66a <SDMMC_CmdSendCSD+0x52>
      return SDMMC_ERROR_TIMEOUT;
 800e666:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e66a:	bc30      	pop	{r4, r5}
 800e66c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e66e:	2004      	movs	r0, #4
 800e670:	63a0      	str	r0, [r4, #56]	; 0x38
 800e672:	e7fa      	b.n	800e66a <SDMMC_CmdSendCSD+0x52>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e674:	2001      	movs	r0, #1
 800e676:	63a0      	str	r0, [r4, #56]	; 0x38
 800e678:	e7f7      	b.n	800e66a <SDMMC_CmdSendCSD+0x52>
 800e67a:	bf00      	nop
 800e67c:	200002bc 	.word	0x200002bc
 800e680:	10624dd3 	.word	0x10624dd3
 800e684:	fffee0c0 	.word	0xfffee0c0
 800e688:	002000c5 	.word	0x002000c5

0800e68c <SDMMC_CmdSetRelAdd>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e68c:	4b25      	ldr	r3, [pc, #148]	; (800e724 <SDMMC_CmdSetRelAdd+0x98>)
 800e68e:	4a26      	ldr	r2, [pc, #152]	; (800e728 <SDMMC_CmdSetRelAdd+0x9c>)
{
 800e690:	b470      	push	{r4, r5, r6}
  SDMMCx->ARG = Command->Argument;
 800e692:	2400      	movs	r4, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e694:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e696:	4d25      	ldr	r5, [pc, #148]	; (800e72c <SDMMC_CmdSetRelAdd+0xa0>)
  SDMMCx->ARG = Command->Argument;
 800e698:	6084      	str	r4, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e69a:	f241 1403 	movw	r4, #4355	; 0x1103
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e69e:	fba2 2303 	umull	r2, r3, r2, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e6a2:	68c6      	ldr	r6, [r0, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e6a4:	0a5a      	lsrs	r2, r3, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e6a6:	4035      	ands	r5, r6
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e6a8:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e6ac:	432c      	orrs	r4, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800e6ae:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e6b2:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e6b4:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e6b8:	d311      	bcc.n	800e6de <SDMMC_CmdSetRelAdd+0x52>
    sta_reg = SDMMCx->STA;
 800e6ba:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e6bc:	f012 0f45 	tst.w	r2, #69	; 0x45
 800e6c0:	d0f8      	beq.n	800e6b4 <SDMMC_CmdSetRelAdd+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800e6c2:	0496      	lsls	r6, r2, #18
 800e6c4:	d4f6      	bmi.n	800e6b4 <SDMMC_CmdSetRelAdd+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e6c6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e6c8:	075d      	lsls	r5, r3, #29
 800e6ca:	d40c      	bmi.n	800e6e6 <SDMMC_CmdSetRelAdd+0x5a>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e6cc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e6ce:	07dc      	lsls	r4, r3, #31
 800e6d0:	d40d      	bmi.n	800e6ee <SDMMC_CmdSetRelAdd+0x62>
  return (uint8_t)(SDMMCx->RESPCMD);
 800e6d2:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e6d4:	b2db      	uxtb	r3, r3
 800e6d6:	2b03      	cmp	r3, #3
 800e6d8:	d00d      	beq.n	800e6f6 <SDMMC_CmdSetRelAdd+0x6a>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e6da:	2001      	movs	r0, #1
 800e6dc:	e001      	b.n	800e6e2 <SDMMC_CmdSetRelAdd+0x56>
      return SDMMC_ERROR_TIMEOUT;
 800e6de:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e6e2:	bc70      	pop	{r4, r5, r6}
 800e6e4:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e6e6:	2304      	movs	r3, #4
 800e6e8:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e6ea:	4618      	mov	r0, r3
 800e6ec:	e7f9      	b.n	800e6e2 <SDMMC_CmdSetRelAdd+0x56>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e6ee:	2301      	movs	r3, #1
 800e6f0:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e6f2:	4618      	mov	r0, r3
 800e6f4:	e7f5      	b.n	800e6e2 <SDMMC_CmdSetRelAdd+0x56>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e6f6:	4b0e      	ldr	r3, [pc, #56]	; (800e730 <SDMMC_CmdSetRelAdd+0xa4>)
 800e6f8:	6383      	str	r3, [r0, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
 800e6fa:	6943      	ldr	r3, [r0, #20]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 800e6fc:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
 800e700:	d009      	beq.n	800e716 <SDMMC_CmdSetRelAdd+0x8a>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 800e702:	045a      	lsls	r2, r3, #17
 800e704:	d40a      	bmi.n	800e71c <SDMMC_CmdSetRelAdd+0x90>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800e706:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800e70a:	bf0c      	ite	eq
 800e70c:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800e710:	f44f 5080 	movne.w	r0, #4096	; 0x1000
 800e714:	e7e5      	b.n	800e6e2 <SDMMC_CmdSetRelAdd+0x56>
    *pRCA = (uint16_t) (response_r1 >> 16);
 800e716:	0c1b      	lsrs	r3, r3, #16
 800e718:	800b      	strh	r3, [r1, #0]
 800e71a:	e7e2      	b.n	800e6e2 <SDMMC_CmdSetRelAdd+0x56>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800e71c:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800e720:	e7df      	b.n	800e6e2 <SDMMC_CmdSetRelAdd+0x56>
 800e722:	bf00      	nop
 800e724:	200002bc 	.word	0x200002bc
 800e728:	10624dd3 	.word	0x10624dd3
 800e72c:	fffee0c0 	.word	0xfffee0c0
 800e730:	002000c5 	.word	0x002000c5

0800e734 <SDMMC_CmdSendStatus>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e734:	4a1c      	ldr	r2, [pc, #112]	; (800e7a8 <SDMMC_CmdSendStatus+0x74>)
 800e736:	4b1d      	ldr	r3, [pc, #116]	; (800e7ac <SDMMC_CmdSendStatus+0x78>)
{
 800e738:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e73a:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e73c:	f241 140d 	movw	r4, #4365	; 0x110d
  SDMMCx->ARG = Command->Argument;
 800e740:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e742:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e746:	68c1      	ldr	r1, [r0, #12]
 800e748:	4d19      	ldr	r5, [pc, #100]	; (800e7b0 <SDMMC_CmdSendStatus+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e74a:	f241 3388 	movw	r3, #5000	; 0x1388
 800e74e:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e750:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e752:	4918      	ldr	r1, [pc, #96]	; (800e7b4 <SDMMC_CmdSendStatus+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e754:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e758:	432c      	orrs	r4, r5
 800e75a:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e75c:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e760:	d312      	bcc.n	800e788 <SDMMC_CmdSendStatus+0x54>
    sta_reg = SDMMCx->STA;
 800e762:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e764:	420a      	tst	r2, r1
 800e766:	d0f9      	beq.n	800e75c <SDMMC_CmdSendStatus+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e768:	0494      	lsls	r4, r2, #18
 800e76a:	d4f7      	bmi.n	800e75c <SDMMC_CmdSendStatus+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e76c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e76e:	075a      	lsls	r2, r3, #29
 800e770:	d40e      	bmi.n	800e790 <SDMMC_CmdSendStatus+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e772:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e774:	07db      	lsls	r3, r3, #31
 800e776:	d40f      	bmi.n	800e798 <SDMMC_CmdSendStatus+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e778:	4b0f      	ldr	r3, [pc, #60]	; (800e7b8 <SDMMC_CmdSendStatus+0x84>)
 800e77a:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e77c:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e77e:	b2db      	uxtb	r3, r3
 800e780:	2b0d      	cmp	r3, #13
 800e782:	d00d      	beq.n	800e7a0 <SDMMC_CmdSendStatus+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e784:	2001      	movs	r0, #1
  return errorstate;
 800e786:	e001      	b.n	800e78c <SDMMC_CmdSendStatus+0x58>
      return SDMMC_ERROR_TIMEOUT;
 800e788:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e78c:	bc30      	pop	{r4, r5}
 800e78e:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e790:	2304      	movs	r3, #4
 800e792:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e794:	4618      	mov	r0, r3
 800e796:	e7f9      	b.n	800e78c <SDMMC_CmdSendStatus+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e798:	2301      	movs	r3, #1
 800e79a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e79c:	4618      	mov	r0, r3
 800e79e:	e7f5      	b.n	800e78c <SDMMC_CmdSendStatus+0x58>
}
 800e7a0:	bc30      	pop	{r4, r5}
 800e7a2:	f7ff ba4d 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800e7a6:	bf00      	nop
 800e7a8:	200002bc 	.word	0x200002bc
 800e7ac:	10624dd3 	.word	0x10624dd3
 800e7b0:	fffee0c0 	.word	0xfffee0c0
 800e7b4:	00200045 	.word	0x00200045
 800e7b8:	002000c5 	.word	0x002000c5

0800e7bc <SDMMC_CmdStatusRegister>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e7bc:	4a1c      	ldr	r2, [pc, #112]	; (800e830 <SDMMC_CmdStatusRegister+0x74>)
  SDMMCx->ARG = Command->Argument;
 800e7be:	2100      	movs	r1, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e7c0:	4b1c      	ldr	r3, [pc, #112]	; (800e834 <SDMMC_CmdStatusRegister+0x78>)
{
 800e7c2:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e7c4:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e7c6:	f241 140d 	movw	r4, #4365	; 0x110d
  SDMMCx->ARG = Command->Argument;
 800e7ca:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e7cc:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e7d0:	68c1      	ldr	r1, [r0, #12]
 800e7d2:	4d19      	ldr	r5, [pc, #100]	; (800e838 <SDMMC_CmdStatusRegister+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e7d4:	f241 3388 	movw	r3, #5000	; 0x1388
 800e7d8:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e7da:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e7dc:	4917      	ldr	r1, [pc, #92]	; (800e83c <SDMMC_CmdStatusRegister+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e7de:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e7e2:	432c      	orrs	r4, r5
 800e7e4:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e7e6:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e7ea:	d312      	bcc.n	800e812 <SDMMC_CmdStatusRegister+0x56>
    sta_reg = SDMMCx->STA;
 800e7ec:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e7ee:	420a      	tst	r2, r1
 800e7f0:	d0f9      	beq.n	800e7e6 <SDMMC_CmdStatusRegister+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e7f2:	0494      	lsls	r4, r2, #18
 800e7f4:	d4f7      	bmi.n	800e7e6 <SDMMC_CmdStatusRegister+0x2a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e7f6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e7f8:	075a      	lsls	r2, r3, #29
 800e7fa:	d40e      	bmi.n	800e81a <SDMMC_CmdStatusRegister+0x5e>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e7fc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e7fe:	07db      	lsls	r3, r3, #31
 800e800:	d40f      	bmi.n	800e822 <SDMMC_CmdStatusRegister+0x66>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e802:	4b0f      	ldr	r3, [pc, #60]	; (800e840 <SDMMC_CmdStatusRegister+0x84>)
 800e804:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e806:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e808:	b2db      	uxtb	r3, r3
 800e80a:	2b0d      	cmp	r3, #13
 800e80c:	d00d      	beq.n	800e82a <SDMMC_CmdStatusRegister+0x6e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e80e:	2001      	movs	r0, #1
  return errorstate;
 800e810:	e001      	b.n	800e816 <SDMMC_CmdStatusRegister+0x5a>
      return SDMMC_ERROR_TIMEOUT;
 800e812:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e816:	bc30      	pop	{r4, r5}
 800e818:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e81a:	2304      	movs	r3, #4
 800e81c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e81e:	4618      	mov	r0, r3
 800e820:	e7f9      	b.n	800e816 <SDMMC_CmdStatusRegister+0x5a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e822:	2301      	movs	r3, #1
 800e824:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e826:	4618      	mov	r0, r3
 800e828:	e7f5      	b.n	800e816 <SDMMC_CmdStatusRegister+0x5a>
}
 800e82a:	bc30      	pop	{r4, r5}
 800e82c:	f7ff ba08 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800e830:	200002bc 	.word	0x200002bc
 800e834:	10624dd3 	.word	0x10624dd3
 800e838:	fffee0c0 	.word	0xfffee0c0
 800e83c:	00200045 	.word	0x00200045
 800e840:	002000c5 	.word	0x002000c5

0800e844 <SDMMC_CmdVoltageSwitch>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e844:	4a1c      	ldr	r2, [pc, #112]	; (800e8b8 <SDMMC_CmdVoltageSwitch+0x74>)
  SDMMCx->ARG = Command->Argument;
 800e846:	2100      	movs	r1, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e848:	4b1c      	ldr	r3, [pc, #112]	; (800e8bc <SDMMC_CmdVoltageSwitch+0x78>)
{
 800e84a:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e84c:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e84e:	f241 140b 	movw	r4, #4363	; 0x110b
  SDMMCx->ARG = Command->Argument;
 800e852:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e854:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e858:	68c1      	ldr	r1, [r0, #12]
 800e85a:	4d19      	ldr	r5, [pc, #100]	; (800e8c0 <SDMMC_CmdVoltageSwitch+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e85c:	f241 3388 	movw	r3, #5000	; 0x1388
 800e860:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e862:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e864:	4917      	ldr	r1, [pc, #92]	; (800e8c4 <SDMMC_CmdVoltageSwitch+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800e866:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800e86a:	432c      	orrs	r4, r5
 800e86c:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
 800e86e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800e872:	d312      	bcc.n	800e89a <SDMMC_CmdVoltageSwitch+0x56>
    sta_reg = SDMMCx->STA;
 800e874:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800e876:	420a      	tst	r2, r1
 800e878:	d0f9      	beq.n	800e86e <SDMMC_CmdVoltageSwitch+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800e87a:	0494      	lsls	r4, r2, #18
 800e87c:	d4f7      	bmi.n	800e86e <SDMMC_CmdVoltageSwitch+0x2a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800e87e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e880:	075a      	lsls	r2, r3, #29
 800e882:	d40e      	bmi.n	800e8a2 <SDMMC_CmdVoltageSwitch+0x5e>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800e884:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800e886:	07db      	lsls	r3, r3, #31
 800e888:	d40f      	bmi.n	800e8aa <SDMMC_CmdVoltageSwitch+0x66>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800e88a:	4b0f      	ldr	r3, [pc, #60]	; (800e8c8 <SDMMC_CmdVoltageSwitch+0x84>)
 800e88c:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800e88e:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800e890:	b2db      	uxtb	r3, r3
 800e892:	2b0b      	cmp	r3, #11
 800e894:	d00d      	beq.n	800e8b2 <SDMMC_CmdVoltageSwitch+0x6e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e896:	2001      	movs	r0, #1
  return errorstate;
 800e898:	e001      	b.n	800e89e <SDMMC_CmdVoltageSwitch+0x5a>
      return SDMMC_ERROR_TIMEOUT;
 800e89a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800e89e:	bc30      	pop	{r4, r5}
 800e8a0:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800e8a2:	2304      	movs	r3, #4
 800e8a4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800e8a6:	4618      	mov	r0, r3
 800e8a8:	e7f9      	b.n	800e89e <SDMMC_CmdVoltageSwitch+0x5a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800e8aa:	2301      	movs	r3, #1
 800e8ac:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800e8ae:	4618      	mov	r0, r3
 800e8b0:	e7f5      	b.n	800e89e <SDMMC_CmdVoltageSwitch+0x5a>
}
 800e8b2:	bc30      	pop	{r4, r5}
 800e8b4:	f7ff b9c4 	b.w	800dc40 <SDMMC_GetCmdResp1.part.2>
 800e8b8:	200002bc 	.word	0x200002bc
 800e8bc:	10624dd3 	.word	0x10624dd3
 800e8c0:	fffee0c0 	.word	0xfffee0c0
 800e8c4:	00200045 	.word	0x00200045
 800e8c8:	002000c5 	.word	0x002000c5

0800e8cc <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800e8cc:	b084      	sub	sp, #16
 800e8ce:	b430      	push	{r4, r5}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800e8d0:	9d08      	ldr	r5, [sp, #32]
{
 800e8d2:	ac03      	add	r4, sp, #12
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800e8d4:	2d01      	cmp	r5, #1
{
 800e8d6:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800e8da:	d131      	bne.n	800e940 <USB_CoreInit+0x74>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800e8dc:	6b82      	ldr	r2, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 800e8de:	4b2e      	ldr	r3, [pc, #184]	; (800e998 <USB_CoreInit+0xcc>)
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800e8e0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
 800e8e4:	990f      	ldr	r1, [sp, #60]	; 0x3c
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800e8e6:	6382      	str	r2, [r0, #56]	; 0x38
    if (cfg.use_external_vbus == 1U)
 800e8e8:	2901      	cmp	r1, #1
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 800e8ea:	68c2      	ldr	r2, [r0, #12]
 800e8ec:	ea03 0302 	and.w	r3, r3, r2
 800e8f0:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 800e8f2:	68c3      	ldr	r3, [r0, #12]
 800e8f4:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 800e8f8:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 800e8fa:	d044      	beq.n	800e986 <USB_CoreInit+0xba>
{
 800e8fc:	4b27      	ldr	r3, [pc, #156]	; (800e99c <USB_CoreInit+0xd0>)
 800e8fe:	e001      	b.n	800e904 <USB_CoreInit+0x38>
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 800e900:	3b01      	subs	r3, #1
 800e902:	d045      	beq.n	800e990 <USB_CoreInit+0xc4>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800e904:	6902      	ldr	r2, [r0, #16]
 800e906:	2a00      	cmp	r2, #0
 800e908:	dafa      	bge.n	800e900 <USB_CoreInit+0x34>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 800e90a:	6903      	ldr	r3, [r0, #16]
 800e90c:	4a23      	ldr	r2, [pc, #140]	; (800e99c <USB_CoreInit+0xd0>)
 800e90e:	f043 0301 	orr.w	r3, r3, #1
 800e912:	6103      	str	r3, [r0, #16]
 800e914:	e001      	b.n	800e91a <USB_CoreInit+0x4e>

  do
  {
    if (++count > 200000U)
 800e916:	3a01      	subs	r2, #1
 800e918:	d03a      	beq.n	800e990 <USB_CoreInit+0xc4>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800e91a:	6903      	ldr	r3, [r0, #16]
 800e91c:	f013 0301 	ands.w	r3, r3, #1
 800e920:	d1f9      	bne.n	800e916 <USB_CoreInit+0x4a>
  if (cfg.dma_enable == 1U)
 800e922:	9a06      	ldr	r2, [sp, #24]
 800e924:	2a01      	cmp	r2, #1
 800e926:	d107      	bne.n	800e938 <USB_CoreInit+0x6c>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 800e928:	6882      	ldr	r2, [r0, #8]
 800e92a:	f042 0206 	orr.w	r2, r2, #6
 800e92e:	6082      	str	r2, [r0, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 800e930:	6882      	ldr	r2, [r0, #8]
 800e932:	f042 0220 	orr.w	r2, r2, #32
 800e936:	6082      	str	r2, [r0, #8]
}
 800e938:	4618      	mov	r0, r3
 800e93a:	bc30      	pop	{r4, r5}
 800e93c:	b004      	add	sp, #16
 800e93e:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 800e940:	68c2      	ldr	r2, [r0, #12]
 800e942:	4b16      	ldr	r3, [pc, #88]	; (800e99c <USB_CoreInit+0xd0>)
 800e944:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800e948:	60c2      	str	r2, [r0, #12]
 800e94a:	e001      	b.n	800e950 <USB_CoreInit+0x84>
    if (++count > 200000U)
 800e94c:	3b01      	subs	r3, #1
 800e94e:	d021      	beq.n	800e994 <USB_CoreInit+0xc8>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800e950:	6902      	ldr	r2, [r0, #16]
 800e952:	2a00      	cmp	r2, #0
 800e954:	dafa      	bge.n	800e94c <USB_CoreInit+0x80>
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 800e956:	6903      	ldr	r3, [r0, #16]
 800e958:	4a10      	ldr	r2, [pc, #64]	; (800e99c <USB_CoreInit+0xd0>)
 800e95a:	f043 0301 	orr.w	r3, r3, #1
 800e95e:	6103      	str	r3, [r0, #16]
 800e960:	e001      	b.n	800e966 <USB_CoreInit+0x9a>
    if (++count > 200000U)
 800e962:	3a01      	subs	r2, #1
 800e964:	d016      	beq.n	800e994 <USB_CoreInit+0xc8>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800e966:	6903      	ldr	r3, [r0, #16]
 800e968:	f013 0301 	ands.w	r3, r3, #1
 800e96c:	d1f9      	bne.n	800e962 <USB_CoreInit+0x96>
    if (cfg.battery_charging_enable == 0U)
 800e96e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800e970:	b922      	cbnz	r2, 800e97c <USB_CoreInit+0xb0>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800e972:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800e974:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800e978:	6382      	str	r2, [r0, #56]	; 0x38
 800e97a:	e7d2      	b.n	800e922 <USB_CoreInit+0x56>
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800e97c:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800e97e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800e982:	6382      	str	r2, [r0, #56]	; 0x38
 800e984:	e7cd      	b.n	800e922 <USB_CoreInit+0x56>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 800e986:	68c3      	ldr	r3, [r0, #12]
 800e988:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800e98c:	60c3      	str	r3, [r0, #12]
 800e98e:	e7b5      	b.n	800e8fc <USB_CoreInit+0x30>
      return HAL_TIMEOUT;
 800e990:	2303      	movs	r3, #3
 800e992:	e7c6      	b.n	800e922 <USB_CoreInit+0x56>
 800e994:	2303      	movs	r3, #3
 800e996:	e7ea      	b.n	800e96e <USB_CoreInit+0xa2>
 800e998:	ffbdffbf 	.word	0xffbdffbf
 800e99c:	00030d40 	.word	0x00030d40

0800e9a0 <USB_EnableGlobalInt>:
{
 800e9a0:	4602      	mov	r2, r0
}
 800e9a2:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 800e9a4:	6893      	ldr	r3, [r2, #8]
 800e9a6:	f043 0301 	orr.w	r3, r3, #1
 800e9aa:	6093      	str	r3, [r2, #8]
}
 800e9ac:	4770      	bx	lr
 800e9ae:	bf00      	nop

0800e9b0 <USB_DisableGlobalInt>:
{
 800e9b0:	4602      	mov	r2, r0
}
 800e9b2:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800e9b4:	6893      	ldr	r3, [r2, #8]
 800e9b6:	f023 0301 	bic.w	r3, r3, #1
 800e9ba:	6093      	str	r3, [r2, #8]
}
 800e9bc:	4770      	bx	lr
 800e9be:	bf00      	nop

0800e9c0 <USB_SetCurrentMode>:
{
 800e9c0:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 800e9c2:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 800e9c4:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 800e9c6:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 800e9ca:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 800e9cc:	d00b      	beq.n	800e9e6 <USB_SetCurrentMode+0x26>
  else if (mode == USB_DEVICE_MODE)
 800e9ce:	b941      	cbnz	r1, 800e9e2 <USB_SetCurrentMode+0x22>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 800e9d0:	68c3      	ldr	r3, [r0, #12]
 800e9d2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800e9d6:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
 800e9d8:	2032      	movs	r0, #50	; 0x32
 800e9da:	f7f2 f82b 	bl	8000a34 <HAL_Delay>
  return HAL_OK;
 800e9de:	2000      	movs	r0, #0
}
 800e9e0:	bd08      	pop	{r3, pc}
    return HAL_ERROR;
 800e9e2:	2001      	movs	r0, #1
}
 800e9e4:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 800e9e6:	68c3      	ldr	r3, [r0, #12]
 800e9e8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800e9ec:	60c3      	str	r3, [r0, #12]
 800e9ee:	e7f3      	b.n	800e9d8 <USB_SetCurrentMode+0x18>

0800e9f0 <USB_ReadPacket>:
  uint32_t count32b = ((uint32_t)len + 3U) / 4U;
 800e9f0:	3203      	adds	r2, #3
  for (i = 0U; i < count32b; i++)
 800e9f2:	0892      	lsrs	r2, r2, #2
 800e9f4:	d00d      	beq.n	800ea12 <USB_ReadPacket+0x22>
 800e9f6:	eb01 0282 	add.w	r2, r1, r2, lsl #2
{
 800e9fa:	b410      	push	{r4}
 800e9fc:	f500 5480 	add.w	r4, r0, #4096	; 0x1000
  uint32_t *pDest = (uint32_t *)dest;
 800ea00:	4608      	mov	r0, r1
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 800ea02:	6823      	ldr	r3, [r4, #0]
 800ea04:	f840 3b04 	str.w	r3, [r0], #4
  for (i = 0U; i < count32b; i++)
 800ea08:	4282      	cmp	r2, r0
 800ea0a:	d1fa      	bne.n	800ea02 <USB_ReadPacket+0x12>
}
 800ea0c:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ea10:	4770      	bx	lr
  uint32_t *pDest = (uint32_t *)dest;
 800ea12:	4608      	mov	r0, r1
}
 800ea14:	4770      	bx	lr
 800ea16:	bf00      	nop

0800ea18 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 800ea18:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 800ea1a:	6980      	ldr	r0, [r0, #24]
}
 800ea1c:	4010      	ands	r0, r2
 800ea1e:	4770      	bx	lr

0800ea20 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 800ea20:	6940      	ldr	r0, [r0, #20]
}
 800ea22:	f000 0001 	and.w	r0, r0, #1
 800ea26:	4770      	bx	lr

0800ea28 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800ea28:	b084      	sub	sp, #16
 800ea2a:	b530      	push	{r4, r5, lr}
 800ea2c:	4604      	mov	r4, r0
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 800ea2e:	2500      	movs	r5, #0
{
 800ea30:	b083      	sub	sp, #12
  USBx_PCGCCTL = 0U;
 800ea32:	f8c4 5e00 	str.w	r5, [r4, #3584]	; 0xe00

  /* Disable VBUS sensing */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
 800ea36:	6ba5      	ldr	r5, [r4, #56]	; 0x38
{
 800ea38:	a807      	add	r0, sp, #28
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
 800ea3a:	f425 1500 	bic.w	r5, r5, #2097152	; 0x200000
 800ea3e:	63a5      	str	r5, [r4, #56]	; 0x38

  /* Disable Battery chargin detector */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
 800ea40:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 800ea42:	f425 3500 	bic.w	r5, r5, #131072	; 0x20000
 800ea46:	63a5      	str	r5, [r4, #56]	; 0x38


  if ((USBx->CID & (0x1U << 8)) != 0U)
 800ea48:	6be5      	ldr	r5, [r4, #60]	; 0x3c
{
 800ea4a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if ((USBx->CID & (0x1U << 8)) != 0U)
 800ea4e:	05eb      	lsls	r3, r5, #23
 800ea50:	9908      	ldr	r1, [sp, #32]
 800ea52:	d565      	bpl.n	800eb20 <USB_HostInit+0xf8>
  {
    if (cfg.speed == USB_OTG_SPEED_FULL)
 800ea54:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ea56:	2b03      	cmp	r3, #3
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 800ea58:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
    if (cfg.speed == USB_OTG_SPEED_FULL)
 800ea5c:	d063      	beq.n	800eb26 <USB_HostInit+0xfe>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 800ea5e:	f023 0304 	bic.w	r3, r3, #4
 800ea62:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800ea66:	f44f 6284 	mov.w	r2, #1056	; 0x420
 800ea6a:	4b31      	ldr	r3, [pc, #196]	; (800eb30 <USB_HostInit+0x108>)
 800ea6c:	6122      	str	r2, [r4, #16]
 800ea6e:	e001      	b.n	800ea74 <USB_HostInit+0x4c>
    if (++count > 200000U)
 800ea70:	3b01      	subs	r3, #1
 800ea72:	d002      	beq.n	800ea7a <USB_HostInit+0x52>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800ea74:	6922      	ldr	r2, [r4, #16]
 800ea76:	0695      	lsls	r5, r2, #26
 800ea78:	d4fa      	bmi.n	800ea70 <USB_HostInit+0x48>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800ea7a:	2210      	movs	r2, #16
 800ea7c:	4b2c      	ldr	r3, [pc, #176]	; (800eb30 <USB_HostInit+0x108>)
 800ea7e:	6122      	str	r2, [r4, #16]
 800ea80:	e001      	b.n	800ea86 <USB_HostInit+0x5e>
    if (++count > 200000U)
 800ea82:	3b01      	subs	r3, #1
 800ea84:	d002      	beq.n	800ea8c <USB_HostInit+0x64>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 800ea86:	6922      	ldr	r2, [r4, #16]
 800ea88:	06d0      	lsls	r0, r2, #27
 800ea8a:	d4fa      	bmi.n	800ea82 <USB_HostInit+0x5a>
  /* Make sure the FIFOs are flushed. */
  (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
  (void)USB_FlushRxFifo(USBx);

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
 800ea8c:	b159      	cbz	r1, 800eaa6 <USB_HostInit+0x7e>
 800ea8e:	2200      	movs	r2, #0
 800ea90:	f504 63a0 	add.w	r3, r4, #1280	; 0x500
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
 800ea94:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    USBx_HC(i)->HCINTMSK = 0U;
 800ea98:	4610      	mov	r0, r2
  for (i = 0U; i < cfg.Host_channels; i++)
 800ea9a:	3201      	adds	r2, #1
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
 800ea9c:	609d      	str	r5, [r3, #8]
    USBx_HC(i)->HCINTMSK = 0U;
 800ea9e:	60d8      	str	r0, [r3, #12]
 800eaa0:	3320      	adds	r3, #32
  for (i = 0U; i < cfg.Host_channels; i++)
 800eaa2:	428a      	cmp	r2, r1
 800eaa4:	d1f9      	bne.n	800ea9a <USB_HostInit+0x72>
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
 800eaa6:	2300      	movs	r3, #0
 800eaa8:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
 800eaaa:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
 800eaae:	9301      	str	r3, [sp, #4]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 800eab0:	9b01      	ldr	r3, [sp, #4]
 800eab2:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 800eab6:	9301      	str	r3, [sp, #4]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 800eab8:	9b01      	ldr	r3, [sp, #4]
 800eaba:	04da      	lsls	r2, r3, #19
 800eabc:	d404      	bmi.n	800eac8 <USB_HostInit+0xa0>
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 800eabe:	9b01      	ldr	r3, [sp, #4]
 800eac0:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800eac4:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(200U);
 800eac8:	20c8      	movs	r0, #200	; 0xc8
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 800eaca:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(200U);
 800eacc:	f7f1 ffb2 	bl	8000a34 <HAL_Delay>
  USBx->GINTSTS = 0xFFFFFFFFU;
 800ead0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  USBx->GINTMSK = 0U;
 800ead4:	2200      	movs	r2, #0
 800ead6:	61a2      	str	r2, [r4, #24]
  USBx->GINTSTS = 0xFFFFFFFFU;
 800ead8:	6163      	str	r3, [r4, #20]
  if ((USBx->CID & (0x1U << 8)) != 0U)
 800eada:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800eadc:	05db      	lsls	r3, r3, #23
 800eade:	d517      	bpl.n	800eb10 <USB_HostInit+0xe8>
    USBx->GRXFSIZ  = 0x200U;
 800eae0:	f44f 7100 	mov.w	r1, #512	; 0x200
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 800eae4:	4a13      	ldr	r2, [pc, #76]	; (800eb34 <USB_HostInit+0x10c>)
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 800eae6:	4b14      	ldr	r3, [pc, #80]	; (800eb38 <USB_HostInit+0x110>)
    USBx->GRXFSIZ  = 0x200U;
 800eae8:	6261      	str	r1, [r4, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 800eaea:	62a2      	str	r2, [r4, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 800eaec:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
  if (cfg.dma_enable == 0U)
 800eaf0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800eaf2:	b91b      	cbnz	r3, 800eafc <USB_HostInit+0xd4>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 800eaf4:	69a3      	ldr	r3, [r4, #24]
 800eaf6:	f043 0310 	orr.w	r3, r3, #16
 800eafa:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
 800eafc:	69a2      	ldr	r2, [r4, #24]
}
 800eafe:	2000      	movs	r0, #0
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
 800eb00:	4b0e      	ldr	r3, [pc, #56]	; (800eb3c <USB_HostInit+0x114>)
 800eb02:	4313      	orrs	r3, r2
 800eb04:	61a3      	str	r3, [r4, #24]
}
 800eb06:	b003      	add	sp, #12
 800eb08:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800eb0c:	b004      	add	sp, #16
 800eb0e:	4770      	bx	lr
    USBx->GRXFSIZ  = 0x80U;
 800eb10:	2180      	movs	r1, #128	; 0x80
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 800eb12:	4a0b      	ldr	r2, [pc, #44]	; (800eb40 <USB_HostInit+0x118>)
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 800eb14:	4b0b      	ldr	r3, [pc, #44]	; (800eb44 <USB_HostInit+0x11c>)
    USBx->GRXFSIZ  = 0x80U;
 800eb16:	6261      	str	r1, [r4, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 800eb18:	62a2      	str	r2, [r4, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 800eb1a:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
 800eb1e:	e7e7      	b.n	800eaf0 <USB_HostInit+0xc8>
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 800eb20:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
 800eb24:	e79b      	b.n	800ea5e <USB_HostInit+0x36>
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 800eb26:	f043 0304 	orr.w	r3, r3, #4
 800eb2a:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
 800eb2e:	e79a      	b.n	800ea66 <USB_HostInit+0x3e>
 800eb30:	00030d40 	.word	0x00030d40
 800eb34:	01000200 	.word	0x01000200
 800eb38:	00e00300 	.word	0x00e00300
 800eb3c:	a3200008 	.word	0xa3200008
 800eb40:	00600080 	.word	0x00600080
 800eb44:	004000e0 	.word	0x004000e0

0800eb48 <USB_InitFSLSPClkSel>:
{
 800eb48:	b410      	push	{r4}
  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 800eb4a:	f8d0 2400 	ldr.w	r2, [r0, #1024]	; 0x400
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 800eb4e:	f001 0303 	and.w	r3, r1, #3
  if (freq == HCFG_48_MHZ)
 800eb52:	2901      	cmp	r1, #1
  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 800eb54:	f500 6480 	add.w	r4, r0, #1024	; 0x400
 800eb58:	f022 0203 	bic.w	r2, r2, #3
 800eb5c:	f8c0 2400 	str.w	r2, [r0, #1024]	; 0x400
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 800eb60:	f8d0 2400 	ldr.w	r2, [r0, #1024]	; 0x400
 800eb64:	ea43 0302 	orr.w	r3, r3, r2
 800eb68:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
  if (freq == HCFG_48_MHZ)
 800eb6c:	d00c      	beq.n	800eb88 <USB_InitFSLSPClkSel+0x40>
  else if (freq == HCFG_6_MHZ)
 800eb6e:	2902      	cmp	r1, #2
 800eb70:	d003      	beq.n	800eb7a <USB_InitFSLSPClkSel+0x32>
}
 800eb72:	2000      	movs	r0, #0
 800eb74:	f85d 4b04 	ldr.w	r4, [sp], #4
 800eb78:	4770      	bx	lr
    USBx_HOST->HFIR = 6000U;
 800eb7a:	f241 7370 	movw	r3, #6000	; 0x1770
}
 800eb7e:	2000      	movs	r0, #0
    USBx_HOST->HFIR = 6000U;
 800eb80:	6063      	str	r3, [r4, #4]
}
 800eb82:	f85d 4b04 	ldr.w	r4, [sp], #4
 800eb86:	4770      	bx	lr
    USBx_HOST->HFIR = 48000U;
 800eb88:	f64b 3380 	movw	r3, #48000	; 0xbb80
}
 800eb8c:	2000      	movs	r0, #0
    USBx_HOST->HFIR = 48000U;
 800eb8e:	6063      	str	r3, [r4, #4]
}
 800eb90:	f85d 4b04 	ldr.w	r4, [sp], #4
 800eb94:	4770      	bx	lr
 800eb96:	bf00      	nop

0800eb98 <USB_ResetPort>:
{
 800eb98:	b530      	push	{r4, r5, lr}
 800eb9a:	4604      	mov	r4, r0
 800eb9c:	b083      	sub	sp, #12
  __IO uint32_t hprt0 = 0U;
 800eb9e:	2500      	movs	r5, #0
  HAL_Delay(100U);                                 /* See Note #1 */
 800eba0:	2064      	movs	r0, #100	; 0x64
  __IO uint32_t hprt0 = 0U;
 800eba2:	9501      	str	r5, [sp, #4]
  hprt0 = USBx_HPRT0;
 800eba4:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
 800eba8:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 800ebaa:	9b01      	ldr	r3, [sp, #4]
 800ebac:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 800ebb0:	9301      	str	r3, [sp, #4]
  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
 800ebb2:	9b01      	ldr	r3, [sp, #4]
 800ebb4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800ebb8:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(100U);                                 /* See Note #1 */
 800ebbc:	f7f1 ff3a 	bl	8000a34 <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 800ebc0:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(10U);
 800ebc2:	200a      	movs	r0, #10
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 800ebc4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800ebc8:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(10U);
 800ebcc:	f7f1 ff32 	bl	8000a34 <HAL_Delay>
}
 800ebd0:	4628      	mov	r0, r5
 800ebd2:	b003      	add	sp, #12
 800ebd4:	bd30      	pop	{r4, r5, pc}
 800ebd6:	bf00      	nop

0800ebd8 <USB_DriveVbus>:
{
 800ebd8:	b082      	sub	sp, #8
  __IO uint32_t hprt0 = 0U;
 800ebda:	2300      	movs	r3, #0
 800ebdc:	9301      	str	r3, [sp, #4]
  hprt0 = USBx_HPRT0;
 800ebde:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
 800ebe2:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 800ebe4:	9b01      	ldr	r3, [sp, #4]
 800ebe6:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 800ebea:	9301      	str	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 800ebec:	9b01      	ldr	r3, [sp, #4]
 800ebee:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 800ebf2:	9b01      	ldr	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 800ebf4:	d101      	bne.n	800ebfa <USB_DriveVbus+0x22>
 800ebf6:	2901      	cmp	r1, #1
 800ebf8:	d00a      	beq.n	800ec10 <USB_DriveVbus+0x38>
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 800ebfa:	04db      	lsls	r3, r3, #19
 800ebfc:	d505      	bpl.n	800ec0a <USB_DriveVbus+0x32>
 800ebfe:	b921      	cbnz	r1, 800ec0a <USB_DriveVbus+0x32>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
 800ec00:	9b01      	ldr	r3, [sp, #4]
 800ec02:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800ec06:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
  }
  return HAL_OK;
}
 800ec0a:	2000      	movs	r0, #0
 800ec0c:	b002      	add	sp, #8
 800ec0e:	4770      	bx	lr
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 800ec10:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800ec14:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
}
 800ec18:	2000      	movs	r0, #0
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 800ec1a:	9b01      	ldr	r3, [sp, #4]
}
 800ec1c:	b002      	add	sp, #8
 800ec1e:	4770      	bx	lr

0800ec20 <USB_GetHostSpeed>:
  *            @arg HCD_SPEED_HIGH: High speed mode
  *            @arg HCD_SPEED_FULL: Full speed mode
  *            @arg HCD_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)
{
 800ec20:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
 800ec22:	2300      	movs	r3, #0
 800ec24:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
 800ec26:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
 800ec2a:	9301      	str	r3, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 800ec2c:	9801      	ldr	r0, [sp, #4]
}
 800ec2e:	f3c0 4041 	ubfx	r0, r0, #17, #2
 800ec32:	b002      	add	sp, #8
 800ec34:	4770      	bx	lr
 800ec36:	bf00      	nop

0800ec38 <USB_GetCurrentFrame>:
*/
uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
 800ec38:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800ec3c:	6880      	ldr	r0, [r0, #8]
}
 800ec3e:	b280      	uxth	r0, r0
 800ec40:	4770      	bx	lr
 800ec42:	bf00      	nop

0800ec44 <USB_HC_Init>:
                              uint8_t epnum,
                              uint8_t dev_address,
                              uint8_t speed,
                              uint8_t ep_type,
                              uint16_t mps)
{
 800ec44:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ec48:	4606      	mov	r6, r0
  HAL_StatusTypeDef ret = HAL_OK;
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t HCcharEpDir, HCcharLowSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
 800ec4a:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 800ec4e:	2001      	movs	r0, #1
{
 800ec50:	f89d 4020 	ldrb.w	r4, [sp, #32]
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
 800ec54:	eb06 1541 	add.w	r5, r6, r1, lsl #5
 800ec58:	f001 010f 	and.w	r1, r1, #15
 800ec5c:	f506 6980 	add.w	r9, r6, #1024	; 0x400
{
 800ec60:	f89d e01c 	ldrb.w	lr, [sp, #28]
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
 800ec64:	f505 68a0 	add.w	r8, r5, #1280	; 0x500
 800ec68:	fa00 f101 	lsl.w	r1, r0, r1
 800ec6c:	f8c8 7008 	str.w	r7, [r8, #8]
 800ec70:	b250      	sxtb	r0, r2
{
 800ec72:	f8bd c024 	ldrh.w	ip, [sp, #36]	; 0x24

  /* Enable channel interrupts required for this transfer. */
  switch (ep_type)
 800ec76:	2c03      	cmp	r4, #3
 800ec78:	d85b      	bhi.n	800ed32 <USB_HC_Init+0xee>
 800ec7a:	e8df f004 	tbb	[pc, r4]
 800ec7e:	3d4a      	.short	0x3d4a
 800ec80:	024a      	.short	0x024a
        }
      }
      break;

    case EP_TYPE_INTR:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800ec82:	f240 679d 	movw	r7, #1693	; 0x69d
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_NAKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
 800ec86:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800ec88:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
 800ec8c:	db63      	blt.n	800ed56 <USB_HC_Init+0x112>
      ret = HAL_ERROR;
      break;
  }

  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800ec8e:	f8d9 7018 	ldr.w	r7, [r9, #24]

  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 800ec92:	2000      	movs	r0, #0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800ec94:	4339      	orrs	r1, r7
  {
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
  }
  else
  {
    HCcharEpDir = 0U;
 800ec96:	4607      	mov	r7, r0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800ec98:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 800ec9c:	69b1      	ldr	r1, [r6, #24]
 800ec9e:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 800eca2:	61b1      	str	r1, [r6, #24]
  else
  {
    HCcharLowSpeed = 0U;
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 800eca4:	0599      	lsls	r1, r3, #22
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
 800eca6:	f3cc 030a 	ubfx	r3, ip, #0, #11
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 800ecaa:	02d2      	lsls	r2, r2, #11
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
 800ecac:	f1be 0f02 	cmp.w	lr, #2
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 800ecb0:	f001 51fe 	and.w	r1, r1, #532676608	; 0x1fc00000
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 800ecb4:	ea4f 4684 	mov.w	r6, r4, lsl #18
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 800ecb8:	f402 42f0 	and.w	r2, r2, #30720	; 0x7800
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
 800ecbc:	bf18      	it	ne
 800ecbe:	f04f 0c00 	movne.w	ip, #0
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 800ecc2:	ea43 0301 	orr.w	r3, r3, r1
 800ecc6:	f406 2140 	and.w	r1, r6, #786432	; 0xc0000
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
 800ecca:	bf08      	it	eq
 800eccc:	f44f 3c00 	moveq.w	ip, #131072	; 0x20000

  if (ep_type == EP_TYPE_INTR)
 800ecd0:	2c03      	cmp	r4, #3
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 800ecd2:	ea43 0302 	orr.w	r3, r3, r2
 800ecd6:	ea43 0301 	orr.w	r3, r3, r1
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
 800ecda:	ea43 0307 	orr.w	r3, r3, r7
 800ecde:	ea43 030c 	orr.w	r3, r3, ip
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 800ece2:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
  if (ep_type == EP_TYPE_INTR)
 800ece6:	d105      	bne.n	800ecf4 <USB_HC_Init+0xb0>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
 800ece8:	f8d5 3500 	ldr.w	r3, [r5, #1280]	; 0x500
 800ecec:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800ecf0:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
  }

  return ret;
}
 800ecf4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800ecf8:	f240 2725 	movw	r7, #549	; 0x225
      if ((epnum & 0x80U) == 0x80U)
 800ecfc:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800ecfe:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
 800ed02:	dac4      	bge.n	800ec8e <USB_HC_Init+0x4a>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
 800ed04:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800ed08:	f440 70c0 	orr.w	r0, r0, #384	; 0x180
 800ed0c:	f8c8 000c 	str.w	r0, [r8, #12]
 800ed10:	e027      	b.n	800ed62 <USB_HC_Init+0x11e>
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800ed12:	f240 479d 	movw	r7, #1181	; 0x49d
      if ((epnum & 0x80U) == 0x80U)
 800ed16:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800ed18:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
 800ed1c:	db1b      	blt.n	800ed56 <USB_HC_Init+0x112>
        if ((USBx->CID & (0x1U << 8)) != 0U)
 800ed1e:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 800ed20:	05c0      	lsls	r0, r0, #23
 800ed22:	d5b4      	bpl.n	800ec8e <USB_HC_Init+0x4a>
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
 800ed24:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800ed28:	f040 0060 	orr.w	r0, r0, #96	; 0x60
 800ed2c:	f8c8 000c 	str.w	r0, [r8, #12]
 800ed30:	e7ad      	b.n	800ec8e <USB_HC_Init+0x4a>
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800ed32:	f8d9 7018 	ldr.w	r7, [r9, #24]
      ret = HAL_ERROR;
 800ed36:	2800      	cmp	r0, #0
 800ed38:	f04f 0001 	mov.w	r0, #1
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800ed3c:	ea41 0107 	orr.w	r1, r1, r7
      ret = HAL_ERROR;
 800ed40:	bfac      	ite	ge
 800ed42:	2700      	movge	r7, #0
 800ed44:	f44f 4700 	movlt.w	r7, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800ed48:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 800ed4c:	69b1      	ldr	r1, [r6, #24]
 800ed4e:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 800ed52:	61b1      	str	r1, [r6, #24]
 800ed54:	e7a6      	b.n	800eca4 <USB_HC_Init+0x60>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 800ed56:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800ed5a:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 800ed5e:	f8c8 000c 	str.w	r0, [r8, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800ed62:	f8d9 7018 	ldr.w	r7, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 800ed66:	2000      	movs	r0, #0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800ed68:	4339      	orrs	r1, r7
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
 800ed6a:	f44f 4700 	mov.w	r7, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 800ed6e:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 800ed72:	69b1      	ldr	r1, [r6, #24]
 800ed74:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 800ed78:	61b1      	str	r1, [r6, #24]
 800ed7a:	e793      	b.n	800eca4 <USB_HC_Init+0x60>

0800ed7c <USB_HC_StartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
{
 800ed7c:	b4f0      	push	{r4, r5, r6, r7}
 800ed7e:	784b      	ldrb	r3, [r1, #1]
  uint8_t  is_oddframe;
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = 256U;

  if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
 800ed80:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 800ed82:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800ed86:	05e4      	lsls	r4, r4, #23
 800ed88:	f503 67a0 	add.w	r7, r3, #1280	; 0x500
 800ed8c:	d50a      	bpl.n	800eda4 <USB_HC_StartXfer+0x28>
 800ed8e:	790c      	ldrb	r4, [r1, #4]
 800ed90:	b944      	cbnz	r4, 800eda4 <USB_HC_StartXfer+0x28>
  {
    if ((dma == 0U) && (hc->do_ping == 1U))
 800ed92:	2a00      	cmp	r2, #0
 800ed94:	d05f      	beq.n	800ee56 <USB_HC_StartXfer+0xda>
    {
      (void)USB_DoPing(USBx, hc->ch_num);
      return HAL_OK;
    }
    else if (dma == 1U)
 800ed96:	2a01      	cmp	r2, #1
 800ed98:	d104      	bne.n	800eda4 <USB_HC_StartXfer+0x28>
    {
      USBx_HC(ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
 800ed9a:	68fd      	ldr	r5, [r7, #12]
 800ed9c:	f025 0560 	bic.w	r5, r5, #96	; 0x60
 800eda0:	60fd      	str	r5, [r7, #12]
      hc->do_ping = 0U;
 800eda2:	714c      	strb	r4, [r1, #5]
      /* ... */
    }
  }

  /* Compute the expected number of packets associated to the transfer */
  if (hc->xfer_len > 0U)
 800eda4:	690d      	ldr	r5, [r1, #16]
 800eda6:	2d00      	cmp	r5, #0
 800eda8:	d149      	bne.n	800ee3e <USB_HC_StartXfer+0xc2>
 800edaa:	f44f 2600 	mov.w	r6, #524288	; 0x80000
 800edae:	f04f 0c01 	mov.w	ip, #1
  }
  else
  {
    num_packets = 1U;
  }
  if (hc->ep_is_in != 0U)
 800edb2:	78cc      	ldrb	r4, [r1, #3]
 800edb4:	b11c      	cbz	r4, 800edbe <USB_HC_StartXfer+0x42>
  {
    hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
 800edb6:	890d      	ldrh	r5, [r1, #8]
 800edb8:	fb0c f505 	mul.w	r5, ip, r5
 800edbc:	610d      	str	r5, [r1, #16]
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 800edbe:	7a8c      	ldrb	r4, [r1, #10]
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
 800edc0:	f3c5 0512 	ubfx	r5, r5, #0, #19
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 800edc4:	0764      	lsls	r4, r4, #29
 800edc6:	f004 44c0 	and.w	r4, r4, #1610612736	; 0x60000000
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800edca:	4334      	orrs	r4, r6
 800edcc:	432c      	orrs	r4, r5
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
 800edce:	613c      	str	r4, [r7, #16]

  if (dma != 0U)
 800edd0:	b10a      	cbz	r2, 800edd6 <USB_HC_StartXfer+0x5a>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
 800edd2:	68cc      	ldr	r4, [r1, #12]
 800edd4:	617c      	str	r4, [r7, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 800edd6:	f500 6680 	add.w	r6, r0, #1024	; 0x400
 800edda:	68b4      	ldr	r4, [r6, #8]
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 800eddc:	f8d3 7500 	ldr.w	r7, [r3, #1280]	; 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 800ede0:	43e4      	mvns	r4, r4

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 800ede2:	4d41      	ldr	r5, [pc, #260]	; (800eee8 <USB_HC_StartXfer+0x16c>)
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 800ede4:	f027 5700 	bic.w	r7, r7, #536870912	; 0x20000000
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 800ede8:	0764      	lsls	r4, r4, #29
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 800edea:	f8c3 7500 	str.w	r7, [r3, #1280]	; 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 800edee:	f004 5400 	and.w	r4, r4, #536870912	; 0x20000000
 800edf2:	f8d3 7500 	ldr.w	r7, [r3, #1280]	; 0x500
 800edf6:	433c      	orrs	r4, r7
 800edf8:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 800edfc:	f8d3 4500 	ldr.w	r4, [r3, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
 800ee00:	78cf      	ldrb	r7, [r1, #3]
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 800ee02:	602c      	str	r4, [r5, #0]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800ee04:	682c      	ldr	r4, [r5, #0]
 800ee06:	f024 4480 	bic.w	r4, r4, #1073741824	; 0x40000000
 800ee0a:	602c      	str	r4, [r5, #0]
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
 800ee0c:	682c      	ldr	r4, [r5, #0]
  if (hc->ep_is_in != 0U)
 800ee0e:	2f00      	cmp	r7, #0
 800ee10:	d031      	beq.n	800ee76 <USB_HC_StartXfer+0xfa>
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
 800ee12:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 800ee16:	602c      	str	r4, [r5, #0]
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 800ee18:	682c      	ldr	r4, [r5, #0]
 800ee1a:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 800ee1e:	602c      	str	r4, [r5, #0]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 800ee20:	682c      	ldr	r4, [r5, #0]
 800ee22:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500

  if (dma == 0U) /* Slave mode */
 800ee26:	bb1a      	cbnz	r2, 800ee70 <USB_HC_StartXfer+0xf4>
  {
    if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
 800ee28:	78cb      	ldrb	r3, [r1, #3]
 800ee2a:	bb0b      	cbnz	r3, 800ee70 <USB_HC_StartXfer+0xf4>
 800ee2c:	690b      	ldr	r3, [r1, #16]
 800ee2e:	b1fb      	cbz	r3, 800ee70 <USB_HC_StartXfer+0xf4>
    {
      switch (hc->ep_type)
 800ee30:	79ca      	ldrb	r2, [r1, #7]
 800ee32:	2a03      	cmp	r2, #3
 800ee34:	d831      	bhi.n	800ee9a <USB_HC_StartXfer+0x11e>
 800ee36:	e8df f002 	tbb	[pc, r2]
 800ee3a:	2944      	.short	0x2944
 800ee3c:	2944      	.short	0x2944
    num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
 800ee3e:	890e      	ldrh	r6, [r1, #8]
 800ee40:	1e6c      	subs	r4, r5, #1
 800ee42:	4434      	add	r4, r6
 800ee44:	fbb4 f4f6 	udiv	r4, r4, r6
    if (num_packets > max_hc_pkt_count)
 800ee48:	fa1f fc84 	uxth.w	ip, r4
 800ee4c:	f5bc 7f80 	cmp.w	ip, #256	; 0x100
 800ee50:	d815      	bhi.n	800ee7e <USB_HC_StartXfer+0x102>
 800ee52:	04e6      	lsls	r6, r4, #19
 800ee54:	e7ad      	b.n	800edb2 <USB_HC_StartXfer+0x36>
    if ((dma == 0U) && (hc->do_ping == 1U))
 800ee56:	794c      	ldrb	r4, [r1, #5]
 800ee58:	2c01      	cmp	r4, #1
 800ee5a:	d1a3      	bne.n	800eda4 <USB_HC_StartXfer+0x28>
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t chnum = (uint32_t)ch_num;
  uint32_t num_packets = 1U;
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800ee5c:	4a23      	ldr	r2, [pc, #140]	; (800eeec <USB_HC_StartXfer+0x170>)
 800ee5e:	613a      	str	r2, [r7, #16]
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
 800ee60:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800ee64:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 800ee68:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  USBx_HC(chnum)->HCCHAR = tmpreg;
 800ee6c:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
 800ee70:	2000      	movs	r0, #0
 800ee72:	bcf0      	pop	{r4, r5, r6, r7}
 800ee74:	4770      	bx	lr
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
 800ee76:	f424 4400 	bic.w	r4, r4, #32768	; 0x8000
 800ee7a:	602c      	str	r4, [r5, #0]
 800ee7c:	e7cc      	b.n	800ee18 <USB_HC_StartXfer+0x9c>
      hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
 800ee7e:	0235      	lsls	r5, r6, #8
 800ee80:	f44f 7c80 	mov.w	ip, #256	; 0x100
 800ee84:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
 800ee88:	610d      	str	r5, [r1, #16]
 800ee8a:	e792      	b.n	800edb2 <USB_HC_StartXfer+0x36>
          if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 800ee8c:	6934      	ldr	r4, [r6, #16]
          len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 800ee8e:	1cda      	adds	r2, r3, #3
          if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 800ee90:	b2a4      	uxth	r4, r4
 800ee92:	f3c2 028f 	ubfx	r2, r2, #2, #16
 800ee96:	4294      	cmp	r4, r2
 800ee98:	d320      	bcc.n	800eedc <USB_HC_StartXfer+0x160>
    count32b = ((uint32_t)len + 3U) / 4U;
 800ee9a:	b29b      	uxth	r3, r3
      (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
 800ee9c:	68ca      	ldr	r2, [r1, #12]
 800ee9e:	7849      	ldrb	r1, [r1, #1]
    count32b = ((uint32_t)len + 3U) / 4U;
 800eea0:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
 800eea2:	089b      	lsrs	r3, r3, #2
 800eea4:	d0e4      	beq.n	800ee70 <USB_HC_StartXfer+0xf4>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 800eea6:	eb00 3001 	add.w	r0, r0, r1, lsl #12
 800eeaa:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800eeae:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 800eeb2:	f852 1b04 	ldr.w	r1, [r2], #4
    for (i = 0U; i < count32b; i++)
 800eeb6:	4293      	cmp	r3, r2
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 800eeb8:	6001      	str	r1, [r0, #0]
    for (i = 0U; i < count32b; i++)
 800eeba:	d1fa      	bne.n	800eeb2 <USB_HC_StartXfer+0x136>
}
 800eebc:	2000      	movs	r0, #0
 800eebe:	bcf0      	pop	{r4, r5, r6, r7}
 800eec0:	4770      	bx	lr
          if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 800eec2:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
          len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 800eec4:	1cda      	adds	r2, r3, #3
          if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 800eec6:	b2a4      	uxth	r4, r4
 800eec8:	f3c2 028f 	ubfx	r2, r2, #2, #16
 800eecc:	4294      	cmp	r4, r2
 800eece:	d2e4      	bcs.n	800ee9a <USB_HC_StartXfer+0x11e>
            USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
 800eed0:	6983      	ldr	r3, [r0, #24]
 800eed2:	f043 0320 	orr.w	r3, r3, #32
 800eed6:	6183      	str	r3, [r0, #24]
 800eed8:	690b      	ldr	r3, [r1, #16]
 800eeda:	e7de      	b.n	800ee9a <USB_HC_StartXfer+0x11e>
            USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
 800eedc:	6983      	ldr	r3, [r0, #24]
 800eede:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800eee2:	6183      	str	r3, [r0, #24]
 800eee4:	690b      	ldr	r3, [r1, #16]
 800eee6:	e7d8      	b.n	800ee9a <USB_HC_StartXfer+0x11e>
 800eee8:	200004c4 	.word	0x200004c4
 800eeec:	80080000 	.word	0x80080000

0800eef0 <USB_HC_ReadInterrupt>:
  return ((USBx_HOST->HAINT) & 0xFFFFU);
 800eef0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800eef4:	6940      	ldr	r0, [r0, #20]
}
 800eef6:	b280      	uxth	r0, r0
 800eef8:	4770      	bx	lr
 800eefa:	bf00      	nop

0800eefc <USB_HC_Halt>:
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 800eefc:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 800ef00:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 800ef04:	f501 62a0 	add.w	r2, r1, #1280	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 800ef08:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 800ef0c:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 800ef10:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800ef14:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 800ef18:	d11f      	bne.n	800ef5a <USB_HC_Halt+0x5e>
    if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 800ef1a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800ef1c:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
 800ef20:	d13c      	bne.n	800ef9c <USB_HC_Halt+0xa0>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800ef22:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 800ef26:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800ef2a:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800ef2e:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800ef32:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
 800ef36:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
 800ef3a:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 800ef3e:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
 800ef42:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 800ef46:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
 800ef4a:	e001      	b.n	800ef50 <USB_HC_Halt+0x54>
        if (++count > 1000U)
 800ef4c:	3b01      	subs	r3, #1
 800ef4e:	d02b      	beq.n	800efa8 <USB_HC_Halt+0xac>
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 800ef50:	6811      	ldr	r1, [r2, #0]
 800ef52:	2900      	cmp	r1, #0
 800ef54:	dbfa      	blt.n	800ef4c <USB_HC_Halt+0x50>
}
 800ef56:	2000      	movs	r0, #0
 800ef58:	4770      	bx	lr
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 800ef5a:	f8d0 3410 	ldr.w	r3, [r0, #1040]	; 0x410
 800ef5e:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
 800ef62:	d11b      	bne.n	800ef9c <USB_HC_Halt+0xa0>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800ef64:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 800ef68:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800ef6c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800ef70:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800ef74:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
 800ef78:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
 800ef7c:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 800ef80:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
 800ef84:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 800ef88:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
 800ef8c:	e001      	b.n	800ef92 <USB_HC_Halt+0x96>
        if (++count > 1000U)
 800ef8e:	3b01      	subs	r3, #1
 800ef90:	d00a      	beq.n	800efa8 <USB_HC_Halt+0xac>
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 800ef92:	6811      	ldr	r1, [r2, #0]
 800ef94:	2900      	cmp	r1, #0
 800ef96:	dbfa      	blt.n	800ef8e <USB_HC_Halt+0x92>
}
 800ef98:	2000      	movs	r0, #0
 800ef9a:	4770      	bx	lr
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800ef9c:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 800efa0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800efa4:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
}
 800efa8:	2000      	movs	r0, #0
 800efaa:	4770      	bx	lr

0800efac <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
 800efac:	b410      	push	{r4}
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800efae:	6882      	ldr	r2, [r0, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800efb0:	f44f 6184 	mov.w	r1, #1056	; 0x420
{
 800efb4:	4604      	mov	r4, r0
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800efb6:	4b5b      	ldr	r3, [pc, #364]	; (800f124 <USB_StopHost+0x178>)
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800efb8:	f022 0201 	bic.w	r2, r2, #1
 800efbc:	6082      	str	r2, [r0, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800efbe:	6101      	str	r1, [r0, #16]
 800efc0:	e001      	b.n	800efc6 <USB_StopHost+0x1a>
    if (++count > 200000U)
 800efc2:	3b01      	subs	r3, #1
 800efc4:	d002      	beq.n	800efcc <USB_StopHost+0x20>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800efc6:	6922      	ldr	r2, [r4, #16]
 800efc8:	0691      	lsls	r1, r2, #26
 800efca:	d4fa      	bmi.n	800efc2 <USB_StopHost+0x16>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800efcc:	2210      	movs	r2, #16
 800efce:	4b55      	ldr	r3, [pc, #340]	; (800f124 <USB_StopHost+0x178>)
 800efd0:	6122      	str	r2, [r4, #16]
 800efd2:	e001      	b.n	800efd8 <USB_StopHost+0x2c>
    if (++count > 200000U)
 800efd4:	3b01      	subs	r3, #1
 800efd6:	d002      	beq.n	800efde <USB_StopHost+0x32>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 800efd8:	6922      	ldr	r2, [r4, #16]
 800efda:	06d2      	lsls	r2, r2, #27
 800efdc:	d4fa      	bmi.n	800efd4 <USB_StopHost+0x28>
  (void)USB_FlushRxFifo(USBx);

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
 800efde:	f8d4 2500 	ldr.w	r2, [r4, #1280]	; 0x500
 800efe2:	f504 61a0 	add.w	r1, r4, #1280	; 0x500
 800efe6:	f504 60e0 	add.w	r0, r4, #1792	; 0x700
  uint32_t count = 0U;
 800efea:	2300      	movs	r3, #0
 800efec:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value |=  USB_OTG_HCCHAR_CHDIS;
    value &= ~USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800eff0:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800eff4:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
    value = USBx_HC(i)->HCCHAR;
 800eff8:	f8d4 2520 	ldr.w	r2, [r4, #1312]	; 0x520
 800effc:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f000:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f004:	f8c4 2520 	str.w	r2, [r4, #1312]	; 0x520
    value = USBx_HC(i)->HCCHAR;
 800f008:	f8d4 2540 	ldr.w	r2, [r4, #1344]	; 0x540
 800f00c:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f010:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f014:	f8c4 2540 	str.w	r2, [r4, #1344]	; 0x540
    value = USBx_HC(i)->HCCHAR;
 800f018:	f8d4 2560 	ldr.w	r2, [r4, #1376]	; 0x560
 800f01c:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f020:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f024:	f8c4 2560 	str.w	r2, [r4, #1376]	; 0x560
    value = USBx_HC(i)->HCCHAR;
 800f028:	f8d4 2580 	ldr.w	r2, [r4, #1408]	; 0x580
 800f02c:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f030:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f034:	f8c4 2580 	str.w	r2, [r4, #1408]	; 0x580
    value = USBx_HC(i)->HCCHAR;
 800f038:	f8d4 25a0 	ldr.w	r2, [r4, #1440]	; 0x5a0
 800f03c:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f040:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f044:	f8c4 25a0 	str.w	r2, [r4, #1440]	; 0x5a0
    value = USBx_HC(i)->HCCHAR;
 800f048:	f8d4 25c0 	ldr.w	r2, [r4, #1472]	; 0x5c0
 800f04c:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f050:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f054:	f8c4 25c0 	str.w	r2, [r4, #1472]	; 0x5c0
    value = USBx_HC(i)->HCCHAR;
 800f058:	f8d4 25e0 	ldr.w	r2, [r4, #1504]	; 0x5e0
 800f05c:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f060:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f064:	f8c4 25e0 	str.w	r2, [r4, #1504]	; 0x5e0
    value = USBx_HC(i)->HCCHAR;
 800f068:	f8d4 2600 	ldr.w	r2, [r4, #1536]	; 0x600
 800f06c:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f070:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f074:	f8c4 2600 	str.w	r2, [r4, #1536]	; 0x600
    value = USBx_HC(i)->HCCHAR;
 800f078:	f8d4 2620 	ldr.w	r2, [r4, #1568]	; 0x620
 800f07c:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f080:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f084:	f8c4 2620 	str.w	r2, [r4, #1568]	; 0x620
    value = USBx_HC(i)->HCCHAR;
 800f088:	f8d4 2640 	ldr.w	r2, [r4, #1600]	; 0x640
 800f08c:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f090:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f094:	f8c4 2640 	str.w	r2, [r4, #1600]	; 0x640
    value = USBx_HC(i)->HCCHAR;
 800f098:	f8d4 2660 	ldr.w	r2, [r4, #1632]	; 0x660
 800f09c:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f0a0:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f0a4:	f8c4 2660 	str.w	r2, [r4, #1632]	; 0x660
    value = USBx_HC(i)->HCCHAR;
 800f0a8:	f8d4 2680 	ldr.w	r2, [r4, #1664]	; 0x680
 800f0ac:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f0b0:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f0b4:	f8c4 2680 	str.w	r2, [r4, #1664]	; 0x680
    value = USBx_HC(i)->HCCHAR;
 800f0b8:	f8d4 26a0 	ldr.w	r2, [r4, #1696]	; 0x6a0
 800f0bc:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f0c0:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f0c4:	f8c4 26a0 	str.w	r2, [r4, #1696]	; 0x6a0
    value = USBx_HC(i)->HCCHAR;
 800f0c8:	f8d4 26c0 	ldr.w	r2, [r4, #1728]	; 0x6c0
 800f0cc:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f0d0:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f0d4:	f8c4 26c0 	str.w	r2, [r4, #1728]	; 0x6c0
    value = USBx_HC(i)->HCCHAR;
 800f0d8:	f8d4 26e0 	ldr.w	r2, [r4, #1760]	; 0x6e0
 800f0dc:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f0e0:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 800f0e4:	f8c4 26e0 	str.w	r2, [r4, #1760]	; 0x6e0
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
 800f0e8:	680a      	ldr	r2, [r1, #0]
 800f0ea:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    value |= USB_OTG_HCCHAR_CHDIS;
    value |= USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
 800f0ee:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    USBx_HC(i)->HCCHAR = value;
 800f0f2:	600a      	str	r2, [r1, #0]
 800f0f4:	e002      	b.n	800f0fc <USB_StopHost+0x150>
      if (++count > 1000U)
      {
        break;
      }
    }
    while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 800f0f6:	680a      	ldr	r2, [r1, #0]
 800f0f8:	2a00      	cmp	r2, #0
 800f0fa:	da03      	bge.n	800f104 <USB_StopHost+0x158>
      if (++count > 1000U)
 800f0fc:	3301      	adds	r3, #1
 800f0fe:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800f102:	d9f8      	bls.n	800f0f6 <USB_StopHost+0x14a>
 800f104:	3120      	adds	r1, #32
  for (i = 0U; i <= 15U; i++)
 800f106:	4281      	cmp	r1, r0
 800f108:	d1ee      	bne.n	800f0e8 <USB_StopHost+0x13c>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = 0xFFFFFFFFU;
 800f10a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  USBx->GINTSTS = 0xFFFFFFFFU;

  (void)USB_EnableGlobalInt(USBx);

  return HAL_OK;
}
 800f10e:	2000      	movs	r0, #0
  USBx_HOST->HAINT = 0xFFFFFFFFU;
 800f110:	f8c4 3414 	str.w	r3, [r4, #1044]	; 0x414
  USBx->GINTSTS = 0xFFFFFFFFU;
 800f114:	6163      	str	r3, [r4, #20]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 800f116:	68a3      	ldr	r3, [r4, #8]
 800f118:	f043 0301 	orr.w	r3, r3, #1
 800f11c:	60a3      	str	r3, [r4, #8]
}
 800f11e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800f122:	4770      	bx	lr
 800f124:	00030d40 	.word	0x00030d40

0800f128 <USBH_Init>:
USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost,
                              void (*pUsrFunc)(USBH_HandleTypeDef *phost,
                              uint8_t id), uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if (phost == NULL)
 800f128:	b3a0      	cbz	r0, 800f194 <USBH_Init+0x6c>
{
 800f12a:	b570      	push	{r4, r5, r6, lr}
 800f12c:	4604      	mov	r4, r0

  /* Set DRiver ID */
  phost->id = id;

  /* Unlink class*/
  phost->pActiveClass = NULL;
 800f12e:	2500      	movs	r5, #0
  phost->id = id;
 800f130:	f880 253c 	strb.w	r2, [r0, #1340]	; 0x53c
 800f134:	460e      	mov	r6, r1
 800f136:	223c      	movs	r2, #60	; 0x3c
 800f138:	4629      	mov	r1, r5
 800f13a:	f200 40f4 	addw	r0, r0, #1268	; 0x4f4
  phost->pActiveClass = NULL;
 800f13e:	f8c4 54ec 	str.w	r5, [r4, #1260]	; 0x4ec
  phost->ClassNumber = 0U;
 800f142:	f8c4 54f0 	str.w	r5, [r4, #1264]	; 0x4f0
 800f146:	f017 ff4a 	bl	8026fde <memset>
 800f14a:	4629      	mov	r1, r5
 800f14c:	f44f 7200 	mov.w	r2, #512	; 0x200
 800f150:	f504 708e 	add.w	r0, r4, #284	; 0x11c
 800f154:	f017 ff43 	bl	8026fde <memset>
    phost->device.Data[i] = 0U;
  }

  phost->gState = HOST_IDLE;
  phost->EnumState = ENUM_IDLE;
  phost->RequestState = CMD_SEND;
 800f158:	2301      	movs	r3, #1
  phost->Timer = 0U;

  phost->Control.state = CTRL_SETUP;
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 800f15a:	2140      	movs	r1, #64	; 0x40
  phost->Control.errorcount = 0U;

  phost->device.address = USBH_ADDRESS_DEFAULT;
 800f15c:	f44f 7280 	mov.w	r2, #256	; 0x100
  phost->gState = HOST_IDLE;
 800f160:	7025      	strb	r5, [r4, #0]
  phost->EnumState = ENUM_IDLE;
 800f162:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
 800f164:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
  phost->Control.errorcount = 0U;
 800f168:	7665      	strb	r5, [r4, #25]
  phost->device.is_connected = 0U;
 800f16a:	f884 5320 	strb.w	r5, [r4, #800]	; 0x320
  phost->device.PortEnabled = 0U;
 800f16e:	f884 5323 	strb.w	r5, [r4, #803]	; 0x323
  phost->device.is_disconnected = 0U;
 800f172:	f884 5321 	strb.w	r5, [r4, #801]	; 0x321
  phost->RequestState = CMD_SEND;
 800f176:	70a3      	strb	r3, [r4, #2]
  phost->device.is_ReEnumerated = 0U;
 800f178:	f884 5322 	strb.w	r5, [r4, #802]	; 0x322
  phost->Control.state = CTRL_SETUP;
 800f17c:	7623      	strb	r3, [r4, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 800f17e:	71a1      	strb	r1, [r4, #6]
  phost->device.address = USBH_ADDRESS_DEFAULT;
 800f180:	f8c4 231c 	str.w	r2, [r4, #796]	; 0x31c
  if (pUsrFunc != NULL)
 800f184:	b10e      	cbz	r6, 800f18a <USBH_Init+0x62>
    phost->pUser = pUsrFunc;
 800f186:	f8c4 6544 	str.w	r6, [r4, #1348]	; 0x544
  USBH_LL_Init(phost);
 800f18a:	4620      	mov	r0, r4
 800f18c:	f00e ffe8 	bl	801e160 <USBH_LL_Init>
  return USBH_OK;
 800f190:	2000      	movs	r0, #0
}
 800f192:	bd70      	pop	{r4, r5, r6, pc}
    return USBH_FAIL;
 800f194:	2002      	movs	r0, #2
}
 800f196:	4770      	bx	lr

0800f198 <USBH_DeInit>:
{
 800f198:	b538      	push	{r3, r4, r5, lr}
 800f19a:	4604      	mov	r4, r0
 800f19c:	223c      	movs	r2, #60	; 0x3c
 800f19e:	2100      	movs	r1, #0
 800f1a0:	f200 40f4 	addw	r0, r0, #1268	; 0x4f4
 800f1a4:	f017 ff1b 	bl	8026fde <memset>
 800f1a8:	f44f 7200 	mov.w	r2, #512	; 0x200
 800f1ac:	2100      	movs	r1, #0
 800f1ae:	f504 708e 	add.w	r0, r4, #284	; 0x11c
 800f1b2:	f017 ff14 	bl	8026fde <memset>
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 800f1b6:	2540      	movs	r5, #64	; 0x40
  phost->gState = HOST_IDLE;
 800f1b8:	2300      	movs	r3, #0
  phost->RequestState = CMD_SEND;
 800f1ba:	2201      	movs	r2, #1
  phost->device.address = USBH_ADDRESS_DEFAULT;
 800f1bc:	f44f 7080 	mov.w	r0, #256	; 0x100
  if (phost->pData != NULL)
 800f1c0:	f8d4 1540 	ldr.w	r1, [r4, #1344]	; 0x540
  phost->gState = HOST_IDLE;
 800f1c4:	7023      	strb	r3, [r4, #0]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 800f1c6:	71a5      	strb	r5, [r4, #6]
  phost->Timer = 0U;
 800f1c8:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
  phost->device.address = USBH_ADDRESS_DEFAULT;
 800f1cc:	f8c4 031c 	str.w	r0, [r4, #796]	; 0x31c
  phost->device.is_connected = 0U;
 800f1d0:	f884 3320 	strb.w	r3, [r4, #800]	; 0x320
  phost->EnumState = ENUM_IDLE;
 800f1d4:	7063      	strb	r3, [r4, #1]
  phost->device.is_disconnected = 0U;
 800f1d6:	f884 3321 	strb.w	r3, [r4, #801]	; 0x321
  phost->Control.errorcount = 0U;
 800f1da:	7663      	strb	r3, [r4, #25]
  phost->device.PortEnabled = 0U;
 800f1dc:	f884 3323 	strb.w	r3, [r4, #803]	; 0x323
  phost->RequestState = CMD_SEND;
 800f1e0:	70a2      	strb	r2, [r4, #2]
  phost->device.is_ReEnumerated = 0U;
 800f1e2:	f884 3322 	strb.w	r3, [r4, #802]	; 0x322
  phost->Control.state = CTRL_SETUP;
 800f1e6:	7622      	strb	r2, [r4, #24]
  if (phost->pData != NULL)
 800f1e8:	b111      	cbz	r1, 800f1f0 <USBH_DeInit+0x58>
    USBH_LL_Stop(phost);
 800f1ea:	4620      	mov	r0, r4
 800f1ec:	f00e fff2 	bl	801e1d4 <USBH_LL_Stop>
}
 800f1f0:	2000      	movs	r0, #0
 800f1f2:	bd38      	pop	{r3, r4, r5, pc}

0800f1f4 <USBH_RegisterClass>:
  */
USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
{
  USBH_StatusTypeDef status = USBH_OK;

  if (pclass != NULL)
 800f1f4:	b149      	cbz	r1, 800f20a <USBH_RegisterClass+0x16>
  {
    if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
 800f1f6:	f8d0 34f0 	ldr.w	r3, [r0, #1264]	; 0x4f0
 800f1fa:	b933      	cbnz	r3, 800f20a <USBH_RegisterClass+0x16>
    {
      /* link the class to the USB Host handle */
      phost->pClass[phost->ClassNumber++] = pclass;
 800f1fc:	2201      	movs	r2, #1
 800f1fe:	f8c0 14e8 	str.w	r1, [r0, #1256]	; 0x4e8
 800f202:	f8c0 24f0 	str.w	r2, [r0, #1264]	; 0x4f0
    USBH_ErrLog("Invalid Class handle");
    status = USBH_FAIL;
  }

  return status;
}
 800f206:	4618      	mov	r0, r3
 800f208:	4770      	bx	lr
    status = USBH_FAIL;
 800f20a:	2302      	movs	r3, #2
}
 800f20c:	4618      	mov	r0, r3
 800f20e:	4770      	bx	lr

0800f210 <USBH_SelectInterface>:
  */
USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
{
  USBH_StatusTypeDef status = USBH_OK;

  if (interface < phost->device.CfgDesc.bNumInterfaces)
 800f210:	f890 333c 	ldrb.w	r3, [r0, #828]	; 0x33c
 800f214:	428b      	cmp	r3, r1
 800f216:	d903      	bls.n	800f220 <USBH_SelectInterface+0x10>
  {
    phost->device.current_interface = interface;
 800f218:	f880 1324 	strb.w	r1, [r0, #804]	; 0x324
  USBH_StatusTypeDef status = USBH_OK;
 800f21c:	2000      	movs	r0, #0
 800f21e:	4770      	bx	lr
    USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
  }
  else
  {
    USBH_ErrLog("Cannot Select This Interface.");
    status = USBH_FAIL;
 800f220:	2002      	movs	r0, #2
  }

  return status;
}
 800f222:	4770      	bx	lr

0800f224 <USBH_FindInterface>:
  * @param  Protocol: Protocol code
  * @retval interface index in the configuration structure
  * @note : (1)interface index 0xFF means interface index not found
  */
uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
{
 800f224:	b430      	push	{r4, r5}
 800f226:	f1a1 04ff 	sub.w	r4, r1, #255	; 0xff
  pcfg = &phost->device.CfgDesc;

  while (if_ix < USBH_MAX_NUM_INTERFACES)
  {
    pif = &pcfg->Itf_Desc[if_ix];
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f22a:	f890 5347 	ldrb.w	r5, [r0, #839]	; 0x347
 800f22e:	fab4 f484 	clz	r4, r4
 800f232:	428d      	cmp	r5, r1
 800f234:	ea4f 1454 	mov.w	r4, r4, lsr #5
 800f238:	d03c      	beq.n	800f2b4 <USBH_FindInterface+0x90>
 800f23a:	2c00      	cmp	r4, #0
 800f23c:	d13a      	bne.n	800f2b4 <USBH_FindInterface+0x90>
 800f23e:	f890 5371 	ldrb.w	r5, [r0, #881]	; 0x371
 800f242:	428d      	cmp	r5, r1
 800f244:	d044      	beq.n	800f2d0 <USBH_FindInterface+0xac>
 800f246:	2c00      	cmp	r4, #0
 800f248:	d142      	bne.n	800f2d0 <USBH_FindInterface+0xac>
 800f24a:	f890 539b 	ldrb.w	r5, [r0, #923]	; 0x39b
 800f24e:	428d      	cmp	r5, r1
 800f250:	d04c      	beq.n	800f2ec <USBH_FindInterface+0xc8>
 800f252:	2c00      	cmp	r4, #0
 800f254:	d14a      	bne.n	800f2ec <USBH_FindInterface+0xc8>
 800f256:	f890 53c5 	ldrb.w	r5, [r0, #965]	; 0x3c5
 800f25a:	428d      	cmp	r5, r1
 800f25c:	d054      	beq.n	800f308 <USBH_FindInterface+0xe4>
 800f25e:	2c00      	cmp	r4, #0
 800f260:	d152      	bne.n	800f308 <USBH_FindInterface+0xe4>
 800f262:	f890 53ef 	ldrb.w	r5, [r0, #1007]	; 0x3ef
 800f266:	428d      	cmp	r5, r1
 800f268:	d05c      	beq.n	800f324 <USBH_FindInterface+0x100>
 800f26a:	2c00      	cmp	r4, #0
 800f26c:	d15a      	bne.n	800f324 <USBH_FindInterface+0x100>
 800f26e:	f890 5419 	ldrb.w	r5, [r0, #1049]	; 0x419
 800f272:	428d      	cmp	r5, r1
 800f274:	d064      	beq.n	800f340 <USBH_FindInterface+0x11c>
 800f276:	2c00      	cmp	r4, #0
 800f278:	d162      	bne.n	800f340 <USBH_FindInterface+0x11c>
 800f27a:	f890 5443 	ldrb.w	r5, [r0, #1091]	; 0x443
 800f27e:	428d      	cmp	r5, r1
 800f280:	d06c      	beq.n	800f35c <USBH_FindInterface+0x138>
 800f282:	2c00      	cmp	r4, #0
 800f284:	d16a      	bne.n	800f35c <USBH_FindInterface+0x138>
 800f286:	f890 546d 	ldrb.w	r5, [r0, #1133]	; 0x46d
 800f28a:	428d      	cmp	r5, r1
 800f28c:	d074      	beq.n	800f378 <USBH_FindInterface+0x154>
 800f28e:	2c00      	cmp	r4, #0
 800f290:	d172      	bne.n	800f378 <USBH_FindInterface+0x154>
 800f292:	f890 5497 	ldrb.w	r5, [r0, #1175]	; 0x497
 800f296:	428d      	cmp	r5, r1
 800f298:	d07c      	beq.n	800f394 <USBH_FindInterface+0x170>
 800f29a:	2c00      	cmp	r4, #0
 800f29c:	d17a      	bne.n	800f394 <USBH_FindInterface+0x170>
 800f29e:	f890 54c1 	ldrb.w	r5, [r0, #1217]	; 0x4c1
 800f2a2:	428d      	cmp	r5, r1
 800f2a4:	f000 8086 	beq.w	800f3b4 <USBH_FindInterface+0x190>
 800f2a8:	2c00      	cmp	r4, #0
 800f2aa:	f040 8083 	bne.w	800f3b4 <USBH_FindInterface+0x190>
    {
      return  if_ix;
    }
    if_ix++;
  }
  return 0xFFU;
 800f2ae:	20ff      	movs	r0, #255	; 0xff
}
 800f2b0:	bc30      	pop	{r4, r5}
 800f2b2:	4770      	bx	lr
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f2b4:	f890 5348 	ldrb.w	r5, [r0, #840]	; 0x348
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800f2b8:	4295      	cmp	r5, r2
 800f2ba:	d001      	beq.n	800f2c0 <USBH_FindInterface+0x9c>
 800f2bc:	2aff      	cmp	r2, #255	; 0xff
 800f2be:	d1be      	bne.n	800f23e <USBH_FindInterface+0x1a>
 800f2c0:	f890 5349 	ldrb.w	r5, [r0, #841]	; 0x349
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800f2c4:	429d      	cmp	r5, r3
 800f2c6:	d001      	beq.n	800f2cc <USBH_FindInterface+0xa8>
 800f2c8:	2bff      	cmp	r3, #255	; 0xff
 800f2ca:	d1b8      	bne.n	800f23e <USBH_FindInterface+0x1a>
  uint8_t if_ix = 0U;
 800f2cc:	2000      	movs	r0, #0
 800f2ce:	e7ef      	b.n	800f2b0 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f2d0:	f890 5372 	ldrb.w	r5, [r0, #882]	; 0x372
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800f2d4:	4295      	cmp	r5, r2
 800f2d6:	d001      	beq.n	800f2dc <USBH_FindInterface+0xb8>
 800f2d8:	2aff      	cmp	r2, #255	; 0xff
 800f2da:	d1b6      	bne.n	800f24a <USBH_FindInterface+0x26>
 800f2dc:	f890 5373 	ldrb.w	r5, [r0, #883]	; 0x373
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800f2e0:	429d      	cmp	r5, r3
 800f2e2:	d001      	beq.n	800f2e8 <USBH_FindInterface+0xc4>
 800f2e4:	2bff      	cmp	r3, #255	; 0xff
 800f2e6:	d1b0      	bne.n	800f24a <USBH_FindInterface+0x26>
    if_ix++;
 800f2e8:	2001      	movs	r0, #1
 800f2ea:	e7e1      	b.n	800f2b0 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f2ec:	f890 539c 	ldrb.w	r5, [r0, #924]	; 0x39c
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800f2f0:	4295      	cmp	r5, r2
 800f2f2:	d001      	beq.n	800f2f8 <USBH_FindInterface+0xd4>
 800f2f4:	2aff      	cmp	r2, #255	; 0xff
 800f2f6:	d1ae      	bne.n	800f256 <USBH_FindInterface+0x32>
 800f2f8:	f890 539d 	ldrb.w	r5, [r0, #925]	; 0x39d
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800f2fc:	429d      	cmp	r5, r3
 800f2fe:	d001      	beq.n	800f304 <USBH_FindInterface+0xe0>
 800f300:	2bff      	cmp	r3, #255	; 0xff
 800f302:	d1a8      	bne.n	800f256 <USBH_FindInterface+0x32>
    if_ix++;
 800f304:	2002      	movs	r0, #2
 800f306:	e7d3      	b.n	800f2b0 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f308:	f890 53c6 	ldrb.w	r5, [r0, #966]	; 0x3c6
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800f30c:	4295      	cmp	r5, r2
 800f30e:	d001      	beq.n	800f314 <USBH_FindInterface+0xf0>
 800f310:	2aff      	cmp	r2, #255	; 0xff
 800f312:	d1a6      	bne.n	800f262 <USBH_FindInterface+0x3e>
 800f314:	f890 53c7 	ldrb.w	r5, [r0, #967]	; 0x3c7
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800f318:	429d      	cmp	r5, r3
 800f31a:	d001      	beq.n	800f320 <USBH_FindInterface+0xfc>
 800f31c:	2bff      	cmp	r3, #255	; 0xff
 800f31e:	d1a0      	bne.n	800f262 <USBH_FindInterface+0x3e>
    if_ix++;
 800f320:	2003      	movs	r0, #3
 800f322:	e7c5      	b.n	800f2b0 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f324:	f890 53f0 	ldrb.w	r5, [r0, #1008]	; 0x3f0
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800f328:	4295      	cmp	r5, r2
 800f32a:	d001      	beq.n	800f330 <USBH_FindInterface+0x10c>
 800f32c:	2aff      	cmp	r2, #255	; 0xff
 800f32e:	d19e      	bne.n	800f26e <USBH_FindInterface+0x4a>
 800f330:	f890 53f1 	ldrb.w	r5, [r0, #1009]	; 0x3f1
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800f334:	429d      	cmp	r5, r3
 800f336:	d001      	beq.n	800f33c <USBH_FindInterface+0x118>
 800f338:	2bff      	cmp	r3, #255	; 0xff
 800f33a:	d198      	bne.n	800f26e <USBH_FindInterface+0x4a>
    if_ix++;
 800f33c:	2004      	movs	r0, #4
 800f33e:	e7b7      	b.n	800f2b0 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f340:	f890 541a 	ldrb.w	r5, [r0, #1050]	; 0x41a
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800f344:	4295      	cmp	r5, r2
 800f346:	d001      	beq.n	800f34c <USBH_FindInterface+0x128>
 800f348:	2aff      	cmp	r2, #255	; 0xff
 800f34a:	d196      	bne.n	800f27a <USBH_FindInterface+0x56>
 800f34c:	f890 541b 	ldrb.w	r5, [r0, #1051]	; 0x41b
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800f350:	429d      	cmp	r5, r3
 800f352:	d001      	beq.n	800f358 <USBH_FindInterface+0x134>
 800f354:	2bff      	cmp	r3, #255	; 0xff
 800f356:	d190      	bne.n	800f27a <USBH_FindInterface+0x56>
    if_ix++;
 800f358:	2005      	movs	r0, #5
 800f35a:	e7a9      	b.n	800f2b0 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f35c:	f890 5444 	ldrb.w	r5, [r0, #1092]	; 0x444
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800f360:	4295      	cmp	r5, r2
 800f362:	d001      	beq.n	800f368 <USBH_FindInterface+0x144>
 800f364:	2aff      	cmp	r2, #255	; 0xff
 800f366:	d18e      	bne.n	800f286 <USBH_FindInterface+0x62>
 800f368:	f890 5445 	ldrb.w	r5, [r0, #1093]	; 0x445
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800f36c:	429d      	cmp	r5, r3
 800f36e:	d001      	beq.n	800f374 <USBH_FindInterface+0x150>
 800f370:	2bff      	cmp	r3, #255	; 0xff
 800f372:	d188      	bne.n	800f286 <USBH_FindInterface+0x62>
    if_ix++;
 800f374:	2006      	movs	r0, #6
 800f376:	e79b      	b.n	800f2b0 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f378:	f890 546e 	ldrb.w	r5, [r0, #1134]	; 0x46e
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800f37c:	4295      	cmp	r5, r2
 800f37e:	d001      	beq.n	800f384 <USBH_FindInterface+0x160>
 800f380:	2aff      	cmp	r2, #255	; 0xff
 800f382:	d186      	bne.n	800f292 <USBH_FindInterface+0x6e>
 800f384:	f890 546f 	ldrb.w	r5, [r0, #1135]	; 0x46f
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800f388:	429d      	cmp	r5, r3
 800f38a:	d001      	beq.n	800f390 <USBH_FindInterface+0x16c>
 800f38c:	2bff      	cmp	r3, #255	; 0xff
 800f38e:	d180      	bne.n	800f292 <USBH_FindInterface+0x6e>
    if_ix++;
 800f390:	2007      	movs	r0, #7
 800f392:	e78d      	b.n	800f2b0 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f394:	f890 5498 	ldrb.w	r5, [r0, #1176]	; 0x498
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800f398:	4295      	cmp	r5, r2
 800f39a:	d002      	beq.n	800f3a2 <USBH_FindInterface+0x17e>
 800f39c:	2aff      	cmp	r2, #255	; 0xff
 800f39e:	f47f af7e 	bne.w	800f29e <USBH_FindInterface+0x7a>
 800f3a2:	f890 5499 	ldrb.w	r5, [r0, #1177]	; 0x499
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800f3a6:	429d      	cmp	r5, r3
 800f3a8:	d002      	beq.n	800f3b0 <USBH_FindInterface+0x18c>
 800f3aa:	2bff      	cmp	r3, #255	; 0xff
 800f3ac:	f47f af77 	bne.w	800f29e <USBH_FindInterface+0x7a>
    if_ix++;
 800f3b0:	2008      	movs	r0, #8
 800f3b2:	e77d      	b.n	800f2b0 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 800f3b4:	f890 14c2 	ldrb.w	r1, [r0, #1218]	; 0x4c2
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800f3b8:	4291      	cmp	r1, r2
 800f3ba:	d002      	beq.n	800f3c2 <USBH_FindInterface+0x19e>
 800f3bc:	2aff      	cmp	r2, #255	; 0xff
 800f3be:	f47f af76 	bne.w	800f2ae <USBH_FindInterface+0x8a>
 800f3c2:	f890 24c3 	ldrb.w	r2, [r0, #1219]	; 0x4c3
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800f3c6:	429a      	cmp	r2, r3
 800f3c8:	d002      	beq.n	800f3d0 <USBH_FindInterface+0x1ac>
 800f3ca:	2bff      	cmp	r3, #255	; 0xff
 800f3cc:	f47f af6f 	bne.w	800f2ae <USBH_FindInterface+0x8a>
    if_ix++;
 800f3d0:	2009      	movs	r0, #9
 800f3d2:	e76d      	b.n	800f2b0 <USBH_FindInterface+0x8c>

0800f3d4 <USBH_Start>:
  *         Start the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Start(USBH_HandleTypeDef *phost)
{
 800f3d4:	b510      	push	{r4, lr}
 800f3d6:	4604      	mov	r4, r0
  /* Start the low level driver  */
  USBH_LL_Start(phost);
 800f3d8:	f00e feee 	bl	801e1b8 <USBH_LL_Start>

  /* Activate VBUS on the port */
  USBH_LL_DriverVBUS(phost, 1);
 800f3dc:	2101      	movs	r1, #1
 800f3de:	4620      	mov	r0, r4
 800f3e0:	f00e ff6e 	bl	801e2c0 <USBH_LL_DriverVBUS>

  return USBH_OK;
}
 800f3e4:	2000      	movs	r0, #0
 800f3e6:	bd10      	pop	{r4, pc}

0800f3e8 <USBH_Stop>:
  *         Stop the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Stop(USBH_HandleTypeDef *phost)
{
 800f3e8:	b510      	push	{r4, lr}
 800f3ea:	4604      	mov	r4, r0
  /* DeActivate VBUS on the port */
  USBH_LL_DriverVBUS(phost, 0);
 800f3ec:	2100      	movs	r1, #0
 800f3ee:	f00e ff67 	bl	801e2c0 <USBH_LL_DriverVBUS>

  /* Stop and cleanup the low level driver  */
  USBH_LL_Stop(phost);
 800f3f2:	4620      	mov	r0, r4
 800f3f4:	f00e feee 	bl	801e1d4 <USBH_LL_Stop>

  /* Free Control Pipes */
  USBH_FreePipe(phost, phost->Control.pipe_in);
 800f3f8:	7921      	ldrb	r1, [r4, #4]
 800f3fa:	4620      	mov	r0, r4
 800f3fc:	f001 fa5e 	bl	80108bc <USBH_FreePipe>
  USBH_FreePipe(phost, phost->Control.pipe_out);
 800f400:	7961      	ldrb	r1, [r4, #5]
 800f402:	4620      	mov	r0, r4
 800f404:	f001 fa5a 	bl	80108bc <USBH_FreePipe>

  return USBH_OK;
}
 800f408:	2000      	movs	r0, #0
 800f40a:	bd10      	pop	{r4, pc}

0800f40c <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
{
 800f40c:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 800f40e:	2302      	movs	r3, #2
{
 800f410:	b087      	sub	sp, #28
 800f412:	4604      	mov	r4, r0
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 800f414:	f88d 3017 	strb.w	r3, [sp, #23]
  uint8_t idx = 0U;

  /* check for Host pending port disconnect event */
  if (phost->device.is_disconnected == 1U)
 800f418:	f890 3321 	ldrb.w	r3, [r0, #801]	; 0x321
 800f41c:	2b01      	cmp	r3, #1
 800f41e:	d101      	bne.n	800f424 <USBH_Process+0x18>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
 800f420:	2303      	movs	r3, #3
 800f422:	7003      	strb	r3, [r0, #0]
  }

  switch (phost->gState)
 800f424:	7823      	ldrb	r3, [r4, #0]
 800f426:	2b0b      	cmp	r3, #11
 800f428:	d84f      	bhi.n	800f4ca <USBH_Process+0xbe>
 800f42a:	e8df f013 	tbh	[pc, r3, lsl #1]
 800f42e:	0059      	.short	0x0059
 800f430:	0082006b 	.word	0x0082006b
 800f434:	004e00b8 	.word	0x004e00b8
 800f438:	00f700ee 	.word	0x00f700ee
 800f43c:	011f010c 	.word	0x011f010c
 800f440:	000c0117 	.word	0x000c0117
 800f444:	0051      	.short	0x0051
#endif
      break;

    case HOST_CHECK_CLASS:

      if (phost->ClassNumber == 0U)
 800f446:	f8d4 34f0 	ldr.w	r3, [r4, #1264]	; 0x4f0
 800f44a:	2b00      	cmp	r3, #0
 800f44c:	d03d      	beq.n	800f4ca <USBH_Process+0xbe>
      {
        USBH_UsrLog("No Class has been registered.");
      }
      else
      {
        phost->pActiveClass = NULL;
 800f44e:	2300      	movs	r3, #0

        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
        {
          for (int j = 0; j < 10; j++)
          {
			  if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[j].bInterfaceClass)
 800f450:	f8d4 14e8 	ldr.w	r1, [r4, #1256]	; 0x4e8
 800f454:	f894 2347 	ldrb.w	r2, [r4, #839]	; 0x347
        phost->pActiveClass = NULL;
 800f458:	f8c4 34ec 	str.w	r3, [r4, #1260]	; 0x4ec
			  if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[j].bInterfaceClass)
 800f45c:	790b      	ldrb	r3, [r1, #4]
 800f45e:	429a      	cmp	r2, r3
 800f460:	d024      	beq.n	800f4ac <USBH_Process+0xa0>
 800f462:	f894 2371 	ldrb.w	r2, [r4, #881]	; 0x371
 800f466:	429a      	cmp	r2, r3
 800f468:	d020      	beq.n	800f4ac <USBH_Process+0xa0>
 800f46a:	f894 239b 	ldrb.w	r2, [r4, #923]	; 0x39b
 800f46e:	429a      	cmp	r2, r3
 800f470:	d01c      	beq.n	800f4ac <USBH_Process+0xa0>
 800f472:	f894 23c5 	ldrb.w	r2, [r4, #965]	; 0x3c5
 800f476:	429a      	cmp	r2, r3
 800f478:	d018      	beq.n	800f4ac <USBH_Process+0xa0>
 800f47a:	f894 23ef 	ldrb.w	r2, [r4, #1007]	; 0x3ef
 800f47e:	429a      	cmp	r2, r3
 800f480:	d014      	beq.n	800f4ac <USBH_Process+0xa0>
 800f482:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
 800f486:	429a      	cmp	r2, r3
 800f488:	d010      	beq.n	800f4ac <USBH_Process+0xa0>
 800f48a:	f894 2443 	ldrb.w	r2, [r4, #1091]	; 0x443
 800f48e:	429a      	cmp	r2, r3
 800f490:	d00c      	beq.n	800f4ac <USBH_Process+0xa0>
 800f492:	f894 246d 	ldrb.w	r2, [r4, #1133]	; 0x46d
 800f496:	429a      	cmp	r2, r3
 800f498:	d008      	beq.n	800f4ac <USBH_Process+0xa0>
 800f49a:	f894 2497 	ldrb.w	r2, [r4, #1175]	; 0x497
 800f49e:	429a      	cmp	r2, r3
 800f4a0:	d004      	beq.n	800f4ac <USBH_Process+0xa0>
 800f4a2:	f894 24c1 	ldrb.w	r2, [r4, #1217]	; 0x4c1
 800f4a6:	429a      	cmp	r2, r3
 800f4a8:	f040 80c8 	bne.w	800f63c <USBH_Process+0x230>
			  {
				phost->pActiveClass = phost->pClass[idx];
 800f4ac:	f8c4 14ec 	str.w	r1, [r4, #1260]	; 0x4ec
          }
        }

        if (phost->pActiveClass != NULL)
        {
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 800f4b0:	4620      	mov	r0, r4
 800f4b2:	688b      	ldr	r3, [r1, #8]
 800f4b4:	4798      	blx	r3
 800f4b6:	2800      	cmp	r0, #0
 800f4b8:	f040 80c0 	bne.w	800f63c <USBH_Process+0x230>
          {
            phost->gState = HOST_CLASS_REQUEST;
 800f4bc:	2206      	movs	r2, #6
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);

            /* Inform user that a class has been activated */
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
 800f4be:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 800f4c2:	4620      	mov	r0, r4
 800f4c4:	2103      	movs	r1, #3
            phost->gState = HOST_CLASS_REQUEST;
 800f4c6:	7022      	strb	r2, [r4, #0]
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
 800f4c8:	4798      	blx	r3
    case HOST_ABORT_STATE:
    default :
      break;
  }
  return USBH_OK;
}
 800f4ca:	2000      	movs	r0, #0
 800f4cc:	b007      	add	sp, #28
 800f4ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (phost->pActiveClass != NULL)
 800f4d0:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
 800f4d4:	2b00      	cmp	r3, #0
 800f4d6:	d0f8      	beq.n	800f4ca <USBH_Process+0xbe>
        phost->pActiveClass->BgndProcess(phost);
 800f4d8:	695b      	ldr	r3, [r3, #20]
 800f4da:	4620      	mov	r0, r4
 800f4dc:	4798      	blx	r3
 800f4de:	e7f4      	b.n	800f4ca <USBH_Process+0xbe>
      if (phost->device.is_connected)
 800f4e0:	f894 3320 	ldrb.w	r3, [r4, #800]	; 0x320
 800f4e4:	2b00      	cmp	r3, #0
 800f4e6:	d0f0      	beq.n	800f4ca <USBH_Process+0xbe>
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 800f4e8:	2301      	movs	r3, #1
        USBH_Delay(200U);
 800f4ea:	20c8      	movs	r0, #200	; 0xc8
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 800f4ec:	7023      	strb	r3, [r4, #0]
        USBH_Delay(200U);
 800f4ee:	f00e ff0b 	bl	801e308 <USBH_Delay>
        USBH_LL_ResetPort(phost);
 800f4f2:	4620      	mov	r0, r4
 800f4f4:	f00e fe8a 	bl	801e20c <USBH_LL_ResetPort>
        phost->device.address = USBH_ADDRESS_DEFAULT;
 800f4f8:	2300      	movs	r3, #0
 800f4fa:	f884 331c 	strb.w	r3, [r4, #796]	; 0x31c
        phost->Timeout = 0U;
 800f4fe:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
 800f502:	e7e2      	b.n	800f4ca <USBH_Process+0xbe>
      if (phost->device.PortEnabled == 1U)
 800f504:	f894 3323 	ldrb.w	r3, [r4, #803]	; 0x323
 800f508:	2b01      	cmp	r3, #1
 800f50a:	f000 8145 	beq.w	800f798 <USBH_Process+0x38c>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
 800f50e:	f8d4 3538 	ldr.w	r3, [r4, #1336]	; 0x538
 800f512:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800f516:	f240 80b7 	bls.w	800f688 <USBH_Process+0x27c>
          phost->device.RstCnt++;
 800f51a:	f894 331f 	ldrb.w	r3, [r4, #799]	; 0x31f
 800f51e:	3301      	adds	r3, #1
 800f520:	b2db      	uxtb	r3, r3
          if (phost->device.RstCnt > 3U)
 800f522:	2b03      	cmp	r3, #3
          phost->device.RstCnt++;
 800f524:	f884 331f 	strb.w	r3, [r4, #799]	; 0x31f
          if (phost->device.RstCnt > 3U)
 800f528:	f200 8088 	bhi.w	800f63c <USBH_Process+0x230>
            phost->gState = HOST_IDLE;
 800f52c:	2300      	movs	r3, #0
 800f52e:	7023      	strb	r3, [r4, #0]
 800f530:	e7cb      	b.n	800f4ca <USBH_Process+0xbe>
      if (phost->pUser != NULL)
 800f532:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 800f536:	b113      	cbz	r3, 800f53e <USBH_Process+0x132>
        phost->pUser(phost, HOST_USER_CONNECTION);
 800f538:	2104      	movs	r1, #4
 800f53a:	4620      	mov	r0, r4
 800f53c:	4798      	blx	r3
      USBH_Delay(100U);
 800f53e:	2064      	movs	r0, #100	; 0x64
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800f540:	2500      	movs	r5, #0
      USBH_Delay(100U);
 800f542:	f00e fee1 	bl	801e308 <USBH_Delay>
      phost->device.speed = USBH_LL_GetSpeed(phost);
 800f546:	4620      	mov	r0, r4
 800f548:	f00e fe52 	bl	801e1f0 <USBH_LL_GetSpeed>
      phost->gState = HOST_ENUMERATION;
 800f54c:	2305      	movs	r3, #5
      phost->device.speed = USBH_LL_GetSpeed(phost);
 800f54e:	f884 031d 	strb.w	r0, [r4, #797]	; 0x31d
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 800f552:	4629      	mov	r1, r5
      phost->gState = HOST_ENUMERATION;
 800f554:	7023      	strb	r3, [r4, #0]
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 800f556:	4620      	mov	r0, r4
 800f558:	f001 f966 	bl	8010828 <USBH_AllocPipe>
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 800f55c:	2180      	movs	r1, #128	; 0x80
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 800f55e:	7160      	strb	r0, [r4, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 800f560:	4620      	mov	r0, r4
 800f562:	f001 f961 	bl	8010828 <USBH_AllocPipe>
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800f566:	79a7      	ldrb	r7, [r4, #6]
 800f568:	f894 631d 	ldrb.w	r6, [r4, #797]	; 0x31d
 800f56c:	4601      	mov	r1, r0
 800f56e:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
 800f572:	2280      	movs	r2, #128	; 0x80
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 800f574:	7120      	strb	r0, [r4, #4]
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 800f576:	4620      	mov	r0, r4
 800f578:	9702      	str	r7, [sp, #8]
 800f57a:	e9cd 6500 	strd	r6, r5, [sp]
 800f57e:	f001 f93d 	bl	80107fc <USBH_OpenPipe>
      USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 800f582:	79a7      	ldrb	r7, [r4, #6]
 800f584:	f894 631d 	ldrb.w	r6, [r4, #797]	; 0x31d
 800f588:	462a      	mov	r2, r5
 800f58a:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
 800f58e:	4620      	mov	r0, r4
 800f590:	7961      	ldrb	r1, [r4, #5]
 800f592:	9501      	str	r5, [sp, #4]
 800f594:	9702      	str	r7, [sp, #8]
 800f596:	9600      	str	r6, [sp, #0]
 800f598:	f001 f930 	bl	80107fc <USBH_OpenPipe>
      break;
 800f59c:	e795      	b.n	800f4ca <USBH_Process+0xbe>
      phost->device.is_disconnected = 0U;
 800f59e:	2500      	movs	r5, #0
 800f5a0:	223c      	movs	r2, #60	; 0x3c
 800f5a2:	f204 40f4 	addw	r0, r4, #1268	; 0x4f4
 800f5a6:	4629      	mov	r1, r5
 800f5a8:	f884 5321 	strb.w	r5, [r4, #801]	; 0x321
 800f5ac:	f017 fd17 	bl	8026fde <memset>
 800f5b0:	4629      	mov	r1, r5
 800f5b2:	f44f 7200 	mov.w	r2, #512	; 0x200
 800f5b6:	f504 708e 	add.w	r0, r4, #284	; 0x11c
 800f5ba:	f017 fd10 	bl	8026fde <memset>
  phost->RequestState = CMD_SEND;
 800f5be:	2301      	movs	r3, #1
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 800f5c0:	2040      	movs	r0, #64	; 0x40
  phost->device.address = USBH_ADDRESS_DEFAULT;
 800f5c2:	f44f 7180 	mov.w	r1, #256	; 0x100
      if (phost->pActiveClass != NULL)
 800f5c6:	f8d4 24ec 	ldr.w	r2, [r4, #1260]	; 0x4ec
  phost->gState = HOST_IDLE;
 800f5ca:	7025      	strb	r5, [r4, #0]
  phost->EnumState = ENUM_IDLE;
 800f5cc:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
 800f5ce:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
  phost->Control.errorcount = 0U;
 800f5d2:	7665      	strb	r5, [r4, #25]
  phost->RequestState = CMD_SEND;
 800f5d4:	70a3      	strb	r3, [r4, #2]
  phost->Control.state = CTRL_SETUP;
 800f5d6:	7623      	strb	r3, [r4, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 800f5d8:	71a0      	strb	r0, [r4, #6]
  phost->device.address = USBH_ADDRESS_DEFAULT;
 800f5da:	f8c4 131c 	str.w	r1, [r4, #796]	; 0x31c
      if (phost->pActiveClass != NULL)
 800f5de:	b122      	cbz	r2, 800f5ea <USBH_Process+0x1de>
        phost->pActiveClass->DeInit(phost);
 800f5e0:	68d3      	ldr	r3, [r2, #12]
 800f5e2:	4620      	mov	r0, r4
 800f5e4:	4798      	blx	r3
        phost->pActiveClass = NULL;
 800f5e6:	f8c4 54ec 	str.w	r5, [r4, #1260]	; 0x4ec
      if (phost->pUser != NULL)
 800f5ea:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 800f5ee:	b113      	cbz	r3, 800f5f6 <USBH_Process+0x1ea>
        phost->pUser(phost, HOST_USER_DISCONNECTION);
 800f5f0:	2105      	movs	r1, #5
 800f5f2:	4620      	mov	r0, r4
 800f5f4:	4798      	blx	r3
      if (phost->device.is_ReEnumerated == 1U)
 800f5f6:	f894 5322 	ldrb.w	r5, [r4, #802]	; 0x322
 800f5fa:	b2ed      	uxtb	r5, r5
 800f5fc:	2d01      	cmp	r5, #1
 800f5fe:	f000 80c0 	beq.w	800f782 <USBH_Process+0x376>
        USBH_LL_Start(phost);
 800f602:	4620      	mov	r0, r4
 800f604:	f00e fdd8 	bl	801e1b8 <USBH_LL_Start>
  return USBH_OK;
 800f608:	e75f      	b.n	800f4ca <USBH_Process+0xbe>
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
  USBH_StatusTypeDef Status = USBH_BUSY;
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;

  switch (phost->EnumState)
 800f60a:	7863      	ldrb	r3, [r4, #1]
 800f60c:	2b07      	cmp	r3, #7
 800f60e:	d84d      	bhi.n	800f6ac <USBH_Process+0x2a0>
 800f610:	e8df f003 	tbb	[pc, r3]
 800f614:	a58b9b41 	.word	0xa58b9b41
 800f618:	5f656d75 	.word	0x5f656d75
      if (phost->pActiveClass != NULL)
 800f61c:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
 800f620:	b163      	cbz	r3, 800f63c <USBH_Process+0x230>
        status = phost->pActiveClass->Requests(phost);
 800f622:	691b      	ldr	r3, [r3, #16]
 800f624:	4620      	mov	r0, r4
 800f626:	4798      	blx	r3
 800f628:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
 800f62c:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800f630:	b33b      	cbz	r3, 800f682 <USBH_Process+0x276>
        else if (status == USBH_FAIL)
 800f632:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800f636:	2b02      	cmp	r3, #2
 800f638:	f47f af47 	bne.w	800f4ca <USBH_Process+0xbe>
        phost->gState = HOST_ABORT_STATE;
 800f63c:	230d      	movs	r3, #13
}
 800f63e:	2000      	movs	r0, #0
        phost->gState = HOST_ABORT_STATE;
 800f640:	7023      	strb	r3, [r4, #0]
}
 800f642:	b007      	add	sp, #28
 800f644:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (phost->pUser != NULL)
 800f646:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 800f64a:	2b00      	cmp	r3, #0
 800f64c:	f43f af3d 	beq.w	800f4ca <USBH_Process+0xbe>
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
 800f650:	2101      	movs	r1, #1
 800f652:	4620      	mov	r0, r4
 800f654:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
 800f656:	2308      	movs	r3, #8
 800f658:	7023      	strb	r3, [r4, #0]
 800f65a:	e736      	b.n	800f4ca <USBH_Process+0xbe>
      if ((phost->device.CfgDesc.bmAttributes) & (1U << 5))
 800f65c:	f894 333f 	ldrb.w	r3, [r4, #831]	; 0x33f
 800f660:	069b      	lsls	r3, r3, #26
 800f662:	f100 8086 	bmi.w	800f772 <USBH_Process+0x366>
        phost->gState = HOST_CHECK_CLASS;
 800f666:	230a      	movs	r3, #10
 800f668:	7023      	strb	r3, [r4, #0]
 800f66a:	e72e      	b.n	800f4ca <USBH_Process+0xbe>
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
 800f66c:	f894 133d 	ldrb.w	r1, [r4, #829]	; 0x33d
 800f670:	4620      	mov	r0, r4
 800f672:	f000 fdc5 	bl	8010200 <USBH_SetCfg>
 800f676:	2800      	cmp	r0, #0
 800f678:	f47f af27 	bne.w	800f4ca <USBH_Process+0xbe>
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 800f67c:	2309      	movs	r3, #9
 800f67e:	7023      	strb	r3, [r4, #0]
 800f680:	e723      	b.n	800f4ca <USBH_Process+0xbe>
          phost->gState = HOST_CLASS;
 800f682:	230b      	movs	r3, #11
 800f684:	7023      	strb	r3, [r4, #0]
 800f686:	e720      	b.n	800f4ca <USBH_Process+0xbe>
          phost->Timeout += 10U;
 800f688:	330a      	adds	r3, #10
          USBH_Delay(10U);
 800f68a:	200a      	movs	r0, #10
          phost->Timeout += 10U;
 800f68c:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
          USBH_Delay(10U);
 800f690:	f00e fe3a 	bl	801e308 <USBH_Delay>
 800f694:	e719      	b.n	800f4ca <USBH_Process+0xbe>
  {
    case ENUM_IDLE:
      /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
 800f696:	2108      	movs	r1, #8
 800f698:	4620      	mov	r0, r4
 800f69a:	f000 f959 	bl	800f950 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
 800f69e:	4605      	mov	r5, r0
 800f6a0:	2800      	cmp	r0, #0
 800f6a2:	f000 80c1 	beq.w	800f828 <USBH_Process+0x41c>
        /* Open Control pipes */
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
                      phost->device.speed, USBH_EP_CONTROL,
                      (uint16_t)phost->Control.pipe_size);
      }
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800f6a6:	2803      	cmp	r0, #3
 800f6a8:	f000 80aa 	beq.w	800f800 <USBH_Process+0x3f4>
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f6ac:	2301      	movs	r3, #1
      status = USBH_HandleEnum(phost);
 800f6ae:	f88d 3017 	strb.w	r3, [sp, #23]
      if (status == USBH_OK)
 800f6b2:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800f6b6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800f6ba:	2b00      	cmp	r3, #0
 800f6bc:	f47f af05 	bne.w	800f4ca <USBH_Process+0xbe>
        if (phost->device.DevDesc.bNumConfigurations == 1U)
 800f6c0:	f894 3337 	ldrb.w	r3, [r4, #823]	; 0x337
        phost->device.current_interface = 0U;
 800f6c4:	f884 2324 	strb.w	r2, [r4, #804]	; 0x324
        if (phost->device.DevDesc.bNumConfigurations == 1U)
 800f6c8:	2b01      	cmp	r3, #1
 800f6ca:	d0c4      	beq.n	800f656 <USBH_Process+0x24a>
          phost->gState = HOST_INPUT;
 800f6cc:	2307      	movs	r3, #7
 800f6ce:	7023      	strb	r3, [r4, #0]
 800f6d0:	e6fb      	b.n	800f4ca <USBH_Process+0xbe>
#endif
      }
      break;

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
 800f6d2:	f894 1336 	ldrb.w	r1, [r4, #822]	; 0x336
 800f6d6:	2900      	cmp	r1, #0
 800f6d8:	d174      	bne.n	800f7c4 <USBH_Process+0x3b8>
        }
      }
      else
      {
        USBH_UsrLog("Serial Number : N/A");
        Status = USBH_OK;
 800f6da:	460b      	mov	r3, r1
 800f6dc:	e7e7      	b.n	800f6ae <USBH_Process+0x2a2>
      if (phost->device.DevDesc.iProduct != 0U)
 800f6de:	f894 1335 	ldrb.w	r1, [r4, #821]	; 0x335
 800f6e2:	2900      	cmp	r1, #0
 800f6e4:	d17f      	bne.n	800f7e6 <USBH_Process+0x3da>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800f6e6:	2207      	movs	r2, #7
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f6e8:	2301      	movs	r3, #1
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800f6ea:	7062      	strb	r2, [r4, #1]
 800f6ec:	e7df      	b.n	800f6ae <USBH_Process+0x2a2>
      if (phost->device.DevDesc.iManufacturer != 0U)
 800f6ee:	f894 1334 	ldrb.w	r1, [r4, #820]	; 0x334
 800f6f2:	2900      	cmp	r1, #0
 800f6f4:	d15a      	bne.n	800f7ac <USBH_Process+0x3a0>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800f6f6:	2206      	movs	r2, #6
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f6f8:	2301      	movs	r3, #1
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800f6fa:	7062      	strb	r2, [r4, #1]
 800f6fc:	e7d7      	b.n	800f6ae <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
 800f6fe:	f8b4 133a 	ldrh.w	r1, [r4, #826]	; 0x33a
 800f702:	4620      	mov	r0, r4
 800f704:	f000 fa32 	bl	800fb6c <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
 800f708:	2800      	cmp	r0, #0
 800f70a:	d04b      	beq.n	800f7a4 <USBH_Process+0x398>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800f70c:	2803      	cmp	r0, #3
 800f70e:	d1cd      	bne.n	800f6ac <USBH_Process+0x2a0>
        phost->device.EnumCnt++;
 800f710:	f894 331e 	ldrb.w	r3, [r4, #798]	; 0x31e
 800f714:	3301      	adds	r3, #1
 800f716:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 800f718:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 800f71a:	f884 331e 	strb.w	r3, [r4, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
 800f71e:	f240 80a6 	bls.w	800f86e <USBH_Process+0x462>
          phost->gState = HOST_ABORT_STATE;
 800f722:	220d      	movs	r2, #13
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f724:	2301      	movs	r3, #1
          phost->gState = HOST_ABORT_STATE;
 800f726:	7022      	strb	r2, [r4, #0]
 800f728:	e7c1      	b.n	800f6ae <USBH_Process+0x2a2>
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
 800f72a:	2101      	movs	r1, #1
 800f72c:	4620      	mov	r0, r4
 800f72e:	f000 fc81 	bl	8010034 <USBH_SetAddress>
      if (ReqStatus == USBH_OK)
 800f732:	4606      	mov	r6, r0
 800f734:	2800      	cmp	r0, #0
 800f736:	f000 80a7 	beq.w	800f888 <USBH_Process+0x47c>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 800f73a:	2803      	cmp	r0, #3
 800f73c:	d1b6      	bne.n	800f6ac <USBH_Process+0x2a0>
        phost->gState = HOST_ABORT_STATE;
 800f73e:	210d      	movs	r1, #13
        phost->EnumState = ENUM_IDLE;
 800f740:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f742:	2301      	movs	r3, #1
        phost->gState = HOST_ABORT_STATE;
 800f744:	7021      	strb	r1, [r4, #0]
        phost->EnumState = ENUM_IDLE;
 800f746:	7062      	strb	r2, [r4, #1]
 800f748:	e7b1      	b.n	800f6ae <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
 800f74a:	2112      	movs	r1, #18
 800f74c:	4620      	mov	r0, r4
 800f74e:	f000 f8ff 	bl	800f950 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
 800f752:	2800      	cmp	r0, #0
 800f754:	d1da      	bne.n	800f70c <USBH_Process+0x300>
        phost->EnumState = ENUM_SET_ADDR;
 800f756:	2202      	movs	r2, #2
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f758:	2301      	movs	r3, #1
        phost->EnumState = ENUM_SET_ADDR;
 800f75a:	7062      	strb	r2, [r4, #1]
 800f75c:	e7a7      	b.n	800f6ae <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
 800f75e:	2109      	movs	r1, #9
 800f760:	4620      	mov	r0, r4
 800f762:	f000 fa03 	bl	800fb6c <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
 800f766:	2800      	cmp	r0, #0
 800f768:	d1d0      	bne.n	800f70c <USBH_Process+0x300>
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 800f76a:	2204      	movs	r2, #4
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f76c:	2301      	movs	r3, #1
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 800f76e:	7062      	strb	r2, [r4, #1]
 800f770:	e79d      	b.n	800f6ae <USBH_Process+0x2a2>
        if (USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP) == USBH_OK)
 800f772:	2101      	movs	r1, #1
 800f774:	4620      	mov	r0, r4
 800f776:	f000 fe29 	bl	80103cc <USBH_SetFeature>
 800f77a:	2800      	cmp	r0, #0
 800f77c:	f47f aea5 	bne.w	800f4ca <USBH_Process+0xbe>
 800f780:	e771      	b.n	800f666 <USBH_Process+0x25a>
        phost->device.is_ReEnumerated = 0U;
 800f782:	2300      	movs	r3, #0
  USBH_LL_Start(phost);
 800f784:	4620      	mov	r0, r4
        phost->device.is_ReEnumerated = 0U;
 800f786:	f884 3322 	strb.w	r3, [r4, #802]	; 0x322
  USBH_LL_Start(phost);
 800f78a:	f00e fd15 	bl	801e1b8 <USBH_LL_Start>
  USBH_LL_DriverVBUS(phost, 1);
 800f78e:	4629      	mov	r1, r5
 800f790:	4620      	mov	r0, r4
 800f792:	f00e fd95 	bl	801e2c0 <USBH_LL_DriverVBUS>
 800f796:	e698      	b.n	800f4ca <USBH_Process+0xbe>
        phost->device.RstCnt = 0U;
 800f798:	2200      	movs	r2, #0
        phost->gState = HOST_DEV_ATTACHED;
 800f79a:	2302      	movs	r3, #2
        phost->device.RstCnt = 0U;
 800f79c:	f884 231f 	strb.w	r2, [r4, #799]	; 0x31f
        phost->gState = HOST_DEV_ATTACHED;
 800f7a0:	7023      	strb	r3, [r4, #0]
 800f7a2:	e692      	b.n	800f4ca <USBH_Process+0xbe>
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 800f7a4:	2205      	movs	r2, #5
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f7a6:	2301      	movs	r3, #1
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 800f7a8:	7062      	strb	r2, [r4, #1]
 800f7aa:	e780      	b.n	800f6ae <USBH_Process+0x2a2>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 800f7ac:	23ff      	movs	r3, #255	; 0xff
 800f7ae:	f504 728e 	add.w	r2, r4, #284	; 0x11c
 800f7b2:	4620      	mov	r0, r4
 800f7b4:	f000 fb30 	bl	800fe18 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 800f7b8:	2800      	cmp	r0, #0
 800f7ba:	d09c      	beq.n	800f6f6 <USBH_Process+0x2ea>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800f7bc:	2803      	cmp	r0, #3
 800f7be:	f47f af75 	bne.w	800f6ac <USBH_Process+0x2a0>
 800f7c2:	e798      	b.n	800f6f6 <USBH_Process+0x2ea>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 800f7c4:	23ff      	movs	r3, #255	; 0xff
 800f7c6:	f504 728e 	add.w	r2, r4, #284	; 0x11c
 800f7ca:	4620      	mov	r0, r4
 800f7cc:	f000 fb24 	bl	800fe18 <USBH_Get_StringDesc>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800f7d0:	f1a0 0303 	sub.w	r3, r0, #3
 800f7d4:	fab3 f383 	clz	r3, r3
 800f7d8:	095b      	lsrs	r3, r3, #5
 800f7da:	2800      	cmp	r0, #0
 800f7dc:	bf08      	it	eq
 800f7de:	2301      	moveq	r3, #1
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f7e0:	f083 0301 	eor.w	r3, r3, #1
 800f7e4:	e763      	b.n	800f6ae <USBH_Process+0x2a2>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 800f7e6:	23ff      	movs	r3, #255	; 0xff
 800f7e8:	f504 728e 	add.w	r2, r4, #284	; 0x11c
 800f7ec:	4620      	mov	r0, r4
 800f7ee:	f000 fb13 	bl	800fe18 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 800f7f2:	2800      	cmp	r0, #0
 800f7f4:	f43f af77 	beq.w	800f6e6 <USBH_Process+0x2da>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 800f7f8:	2803      	cmp	r0, #3
 800f7fa:	f47f af57 	bne.w	800f6ac <USBH_Process+0x2a0>
 800f7fe:	e772      	b.n	800f6e6 <USBH_Process+0x2da>
        phost->device.EnumCnt++;
 800f800:	f894 331e 	ldrb.w	r3, [r4, #798]	; 0x31e
 800f804:	3301      	adds	r3, #1
 800f806:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 800f808:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 800f80a:	f884 331e 	strb.w	r3, [r4, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
 800f80e:	d888      	bhi.n	800f722 <USBH_Process+0x316>
          USBH_FreePipe(phost, phost->Control.pipe_out);
 800f810:	7961      	ldrb	r1, [r4, #5]
 800f812:	4620      	mov	r0, r4
 800f814:	f001 f852 	bl	80108bc <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
 800f818:	7921      	ldrb	r1, [r4, #4]
 800f81a:	4620      	mov	r0, r4
 800f81c:	f001 f84e 	bl	80108bc <USBH_FreePipe>
          phost->gState = HOST_IDLE;
 800f820:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f822:	2301      	movs	r3, #1
          phost->gState = HOST_IDLE;
 800f824:	7022      	strb	r2, [r4, #0]
 800f826:	e742      	b.n	800f6ae <USBH_Process+0x2a2>
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 800f828:	f894 732d 	ldrb.w	r7, [r4, #813]	; 0x32d
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 800f82c:	2601      	movs	r6, #1
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 800f82e:	f894 c31d 	ldrb.w	ip, [r4, #797]	; 0x31d
 800f832:	2280      	movs	r2, #128	; 0x80
 800f834:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
 800f838:	4620      	mov	r0, r4
 800f83a:	7921      	ldrb	r1, [r4, #4]
 800f83c:	9501      	str	r5, [sp, #4]
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 800f83e:	71a7      	strb	r7, [r4, #6]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 800f840:	9702      	str	r7, [sp, #8]
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 800f842:	7066      	strb	r6, [r4, #1]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 800f844:	f8cd c000 	str.w	ip, [sp]
 800f848:	f000 ffd8 	bl	80107fc <USBH_OpenPipe>
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800f84c:	f894 c006 	ldrb.w	ip, [r4, #6]
 800f850:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
 800f854:	462a      	mov	r2, r5
 800f856:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
 800f85a:	4620      	mov	r0, r4
 800f85c:	7961      	ldrb	r1, [r4, #5]
 800f85e:	9501      	str	r5, [sp, #4]
 800f860:	f8cd c008 	str.w	ip, [sp, #8]
 800f864:	9700      	str	r7, [sp, #0]
 800f866:	f000 ffc9 	bl	80107fc <USBH_OpenPipe>
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f86a:	4633      	mov	r3, r6
 800f86c:	e71f      	b.n	800f6ae <USBH_Process+0x2a2>
          USBH_FreePipe(phost, phost->Control.pipe_out);
 800f86e:	7961      	ldrb	r1, [r4, #5]
 800f870:	4620      	mov	r0, r4
 800f872:	f001 f823 	bl	80108bc <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
 800f876:	7921      	ldrb	r1, [r4, #4]
 800f878:	4620      	mov	r0, r4
 800f87a:	f001 f81f 	bl	80108bc <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 800f87e:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f880:	2301      	movs	r3, #1
          phost->EnumState = ENUM_IDLE;
 800f882:	7062      	strb	r2, [r4, #1]
          phost->gState = HOST_IDLE;
 800f884:	7022      	strb	r2, [r4, #0]
 800f886:	e712      	b.n	800f6ae <USBH_Process+0x2a2>
        USBH_Delay(2U);
 800f888:	2002      	movs	r0, #2
        phost->device.address = USBH_DEVICE_ADDRESS;
 800f88a:	2501      	movs	r5, #1
        USBH_Delay(2U);
 800f88c:	f00e fd3c 	bl	801e308 <USBH_Delay>
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800f890:	79a7      	ldrb	r7, [r4, #6]
        phost->EnumState = ENUM_GET_CFG_DESC;
 800f892:	2003      	movs	r0, #3
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800f894:	7921      	ldrb	r1, [r4, #4]
 800f896:	9601      	str	r6, [sp, #4]
 800f898:	462b      	mov	r3, r5
        phost->EnumState = ENUM_GET_CFG_DESC;
 800f89a:	7060      	strb	r0, [r4, #1]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800f89c:	2280      	movs	r2, #128	; 0x80
        phost->device.address = USBH_DEVICE_ADDRESS;
 800f89e:	f884 531c 	strb.w	r5, [r4, #796]	; 0x31c
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800f8a2:	4620      	mov	r0, r4
 800f8a4:	9702      	str	r7, [sp, #8]
 800f8a6:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
 800f8aa:	9700      	str	r7, [sp, #0]
 800f8ac:	f000 ffa6 	bl	80107fc <USBH_OpenPipe>
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 800f8b0:	f894 c006 	ldrb.w	ip, [r4, #6]
 800f8b4:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
 800f8b8:	4632      	mov	r2, r6
 800f8ba:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
 800f8be:	4620      	mov	r0, r4
 800f8c0:	7961      	ldrb	r1, [r4, #5]
 800f8c2:	9601      	str	r6, [sp, #4]
 800f8c4:	f8cd c008 	str.w	ip, [sp, #8]
 800f8c8:	9700      	str	r7, [sp, #0]
 800f8ca:	f000 ff97 	bl	80107fc <USBH_OpenPipe>
  USBH_StatusTypeDef Status = USBH_BUSY;
 800f8ce:	462b      	mov	r3, r5
 800f8d0:	e6ed      	b.n	800f6ae <USBH_Process+0x2a2>
 800f8d2:	bf00      	nop

0800f8d4 <USBH_LL_SetTimer>:
  * @param  phost: Host Handle
  * @retval None
  */
void  USBH_LL_SetTimer(USBH_HandleTypeDef *phost, uint32_t time)
{
  phost->Timer = time;
 800f8d4:	f8c0 1534 	str.w	r1, [r0, #1332]	; 0x534
}
 800f8d8:	4770      	bx	lr
 800f8da:	bf00      	nop

0800f8dc <USBH_LL_IncTimer>:
  * @param  phost: Host Handle
  * @retval None
  */
void  USBH_LL_IncTimer(USBH_HandleTypeDef *phost)
{
  phost->Timer++;
 800f8dc:	f8d0 2534 	ldr.w	r2, [r0, #1332]	; 0x534
 800f8e0:	3201      	adds	r2, #1
 800f8e2:	f8c0 2534 	str.w	r2, [r0, #1332]	; 0x534
  * @param  phost: Host Handle
  * @retval None
  */
static void  USBH_HandleSof(USBH_HandleTypeDef *phost)
{
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 800f8e6:	7802      	ldrb	r2, [r0, #0]
 800f8e8:	2a0b      	cmp	r2, #11
 800f8ea:	d000      	beq.n	800f8ee <USBH_LL_IncTimer+0x12>
}
 800f8ec:	4770      	bx	lr
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 800f8ee:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
 800f8f2:	2b00      	cmp	r3, #0
 800f8f4:	d0fa      	beq.n	800f8ec <USBH_LL_IncTimer+0x10>
  {
    phost->pActiveClass->SOFProcess(phost);
 800f8f6:	699b      	ldr	r3, [r3, #24]
 800f8f8:	4718      	bx	r3
 800f8fa:	bf00      	nop

0800f8fc <USBH_LL_PortEnabled>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortEnabled(USBH_HandleTypeDef *phost)
{
  phost->device.PortEnabled = 1U;
 800f8fc:	2301      	movs	r3, #1
 800f8fe:	f880 3323 	strb.w	r3, [r0, #803]	; 0x323
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif

  return;
}
 800f902:	4770      	bx	lr

0800f904 <USBH_LL_PortDisabled>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortDisabled(USBH_HandleTypeDef *phost)
{
  phost->device.PortEnabled = 0U;
 800f904:	2300      	movs	r3, #0
 800f906:	f880 3323 	strb.w	r3, [r0, #803]	; 0x323

  return;
}
 800f90a:	4770      	bx	lr

0800f90c <USBH_LL_Connect>:
  *         Handle USB Host connexion event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef  USBH_LL_Connect(USBH_HandleTypeDef *phost)
{
 800f90c:	4603      	mov	r3, r0
  phost->device.is_connected = 1U;
  phost->device.is_disconnected = 0U;
 800f90e:	2200      	movs	r2, #0
  phost->device.is_connected = 1U;
 800f910:	2101      	movs	r1, #1
 800f912:	f880 1320 	strb.w	r1, [r0, #800]	; 0x320
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif

  return USBH_OK;
}
 800f916:	4610      	mov	r0, r2
  phost->device.is_disconnected = 0U;
 800f918:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
  phost->device.is_ReEnumerated = 0U;
 800f91c:	f883 2322 	strb.w	r2, [r3, #802]	; 0x322
}
 800f920:	4770      	bx	lr
 800f922:	bf00      	nop

0800f924 <USBH_LL_Disconnect>:
  *         Handle USB Host disconnection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef  USBH_LL_Disconnect(USBH_HandleTypeDef *phost)
{
 800f924:	b538      	push	{r3, r4, r5, lr}
  /* update device connection states */
  phost->device.is_disconnected = 1U;
 800f926:	2301      	movs	r3, #1
  phost->device.is_connected = 0U;
 800f928:	2500      	movs	r5, #0
{
 800f92a:	4604      	mov	r4, r0
  phost->device.is_disconnected = 1U;
 800f92c:	f880 3321 	strb.w	r3, [r0, #801]	; 0x321
  phost->device.PortEnabled = 0U;
 800f930:	f880 5323 	strb.w	r5, [r0, #803]	; 0x323
  phost->device.is_connected = 0U;
 800f934:	f880 5320 	strb.w	r5, [r0, #800]	; 0x320

  /* Stop Host */
  USBH_LL_Stop(phost);
 800f938:	f00e fc4c 	bl	801e1d4 <USBH_LL_Stop>

  /* FRee Control Pipes */
  USBH_FreePipe(phost, phost->Control.pipe_in);
 800f93c:	7921      	ldrb	r1, [r4, #4]
 800f93e:	4620      	mov	r0, r4
 800f940:	f000 ffbc 	bl	80108bc <USBH_FreePipe>
  USBH_FreePipe(phost, phost->Control.pipe_out);
 800f944:	7961      	ldrb	r1, [r4, #5]
 800f946:	4620      	mov	r0, r4
 800f948:	f000 ffb8 	bl	80108bc <USBH_FreePipe>
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif

  return USBH_OK;
}
 800f94c:	4628      	mov	r0, r5
 800f94e:	bd38      	pop	{r3, r4, r5, pc}

0800f950 <USBH_Get_DevDesc>:
  * @param  phost: Host Handle
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_DevDesc(USBH_HandleTypeDef *phost, uint8_t length)
{
 800f950:	b570      	push	{r4, r5, r6, lr}
 800f952:	4604      	mov	r4, r0
                                      uint8_t  req_type,
                                      uint16_t value_idx,
                                      uint8_t *buff,
                                      uint16_t length)
{
  if (phost->RequestState == CMD_SEND)
 800f954:	7880      	ldrb	r0, [r0, #2]
{
 800f956:	b082      	sub	sp, #8
  if (phost->RequestState == CMD_SEND)
 800f958:	2801      	cmp	r0, #1
 800f95a:	d011      	beq.n	800f980 <USBH_Get_DevDesc+0x30>
                               uint16_t length)
{
  USBH_StatusTypeDef status;
  status = USBH_BUSY;

  switch (phost->RequestState)
 800f95c:	2802      	cmp	r0, #2
 800f95e:	d002      	beq.n	800f966 <USBH_Get_DevDesc+0x16>
  status = USBH_BUSY;
 800f960:	2001      	movs	r0, #1
}
 800f962:	b002      	add	sp, #8
 800f964:	bd70      	pop	{r4, r5, r6, pc}
{
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;

  switch (phost->Control.state)
 800f966:	7e23      	ldrb	r3, [r4, #24]
 800f968:	460d      	mov	r5, r1
 800f96a:	3b01      	subs	r3, #1
 800f96c:	2b0a      	cmp	r3, #10
 800f96e:	d8f7      	bhi.n	800f960 <USBH_Get_DevDesc+0x10>
 800f970:	e8df f003 	tbb	[pc, r3]
 800f974:	5548392f 	.word	0x5548392f
 800f978:	8c7f6f60 	.word	0x8c7f6f60
 800f97c:	ac9d      	.short	0xac9d
 800f97e:	14          	.byte	0x14
 800f97f:	00          	.byte	0x00
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800f980:	4e79      	ldr	r6, [pc, #484]	; (800fb68 <USBH_Get_DevDesc+0x218>)
    phost->Control.setup.b.wValue.w = value_idx;
 800f982:	2500      	movs	r5, #0
                                   USB_DESC_DEVICE, phost->device.Data,
 800f984:	f504 728e 	add.w	r2, r4, #284	; 0x11c
      phost->RequestState = CMD_WAIT;
 800f988:	2302      	movs	r3, #2
    phost->Control.setup.b.wLength.w = length;
 800f98a:	82e1      	strh	r1, [r4, #22]
      phost->Control.length = length;
 800f98c:	81a1      	strh	r1, [r4, #12]
      phost->Control.state = CTRL_SETUP;
 800f98e:	7620      	strb	r0, [r4, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800f990:	6126      	str	r6, [r4, #16]
    phost->Control.setup.b.wValue.w = value_idx;
 800f992:	82a5      	strh	r5, [r4, #20]
      phost->Control.buff = buff;
 800f994:	60a2      	str	r2, [r4, #8]
      phost->RequestState = CMD_WAIT;
 800f996:	70a3      	strb	r3, [r4, #2]
}
 800f998:	b002      	add	sp, #8
 800f99a:	bd70      	pop	{r4, r5, r6, pc}
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 800f99c:	7e63      	ldrb	r3, [r4, #25]
 800f99e:	3301      	adds	r3, #1
 800f9a0:	b2db      	uxtb	r3, r3
 800f9a2:	2b02      	cmp	r3, #2
 800f9a4:	7663      	strb	r3, [r4, #25]
 800f9a6:	f240 80d7 	bls.w	800fb58 <USBH_Get_DevDesc+0x208>
        phost->RequestState = CMD_SEND;
      }
      else
      {
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
        phost->Control.errorcount = 0U;
 800f9aa:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800f9ac:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 800f9b0:	2106      	movs	r1, #6
 800f9b2:	4620      	mov	r0, r4
 800f9b4:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");

        /* Free control pipes */
        USBH_FreePipe(phost, phost->Control.pipe_out);
 800f9b6:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 800f9b8:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 800f9ba:	4620      	mov	r0, r4
 800f9bc:	f000 ff7e 	bl	80108bc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 800f9c0:	7921      	ldrb	r1, [r4, #4]
 800f9c2:	4620      	mov	r0, r4
 800f9c4:	f000 ff7a 	bl	80108bc <USBH_FreePipe>

        phost->gState = HOST_IDLE;
 800f9c8:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 800f9ca:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 800f9cc:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 800f9ce:	70a3      	strb	r3, [r4, #2]
 800f9d0:	e7c7      	b.n	800f962 <USBH_Get_DevDesc+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800f9d2:	7962      	ldrb	r2, [r4, #5]
 800f9d4:	f104 0110 	add.w	r1, r4, #16
 800f9d8:	4620      	mov	r0, r4
 800f9da:	f000 fec3 	bl	8010764 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 800f9de:	2302      	movs	r3, #2
 800f9e0:	2001      	movs	r0, #1
 800f9e2:	7623      	strb	r3, [r4, #24]
 800f9e4:	e7bd      	b.n	800f962 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800f9e6:	7961      	ldrb	r1, [r4, #5]
 800f9e8:	4620      	mov	r0, r4
 800f9ea:	f00e fc65 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800f9ee:	2801      	cmp	r0, #1
 800f9f0:	f000 80a7 	beq.w	800fb42 <USBH_Get_DevDesc+0x1f2>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 800f9f4:	2804      	cmp	r0, #4
 800f9f6:	d001      	beq.n	800f9fc <USBH_Get_DevDesc+0xac>
 800f9f8:	2802      	cmp	r0, #2
 800f9fa:	d1b1      	bne.n	800f960 <USBH_Get_DevDesc+0x10>
          phost->Control.state = CTRL_ERROR;
 800f9fc:	230b      	movs	r3, #11
 800f9fe:	2001      	movs	r0, #1
 800fa00:	7623      	strb	r3, [r4, #24]
 800fa02:	e7ae      	b.n	800f962 <USBH_Get_DevDesc+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
 800fa04:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 800fa08:	4620      	mov	r0, r4
 800fa0a:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 800fa0c:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 800fa0e:	68a1      	ldr	r1, [r4, #8]
 800fa10:	89a2      	ldrh	r2, [r4, #12]
 800fa12:	f000 fecf 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 800fa16:	2304      	movs	r3, #4
 800fa18:	2001      	movs	r0, #1
 800fa1a:	7623      	strb	r3, [r4, #24]
 800fa1c:	e7a1      	b.n	800f962 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800fa1e:	7921      	ldrb	r1, [r4, #4]
 800fa20:	4620      	mov	r0, r4
 800fa22:	f00e fc49 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fa26:	2801      	cmp	r0, #1
 800fa28:	d058      	beq.n	800fadc <USBH_Get_DevDesc+0x18c>
      if (URB_Status == USBH_URB_STALL)
 800fa2a:	2805      	cmp	r0, #5
 800fa2c:	d039      	beq.n	800faa2 <USBH_Get_DevDesc+0x152>
        if (URB_Status == USBH_URB_ERROR)
 800fa2e:	2804      	cmp	r0, #4
 800fa30:	d196      	bne.n	800f960 <USBH_Get_DevDesc+0x10>
 800fa32:	e7e3      	b.n	800f9fc <USBH_Get_DevDesc+0xac>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 800fa34:	2501      	movs	r5, #1
 800fa36:	7963      	ldrb	r3, [r4, #5]
 800fa38:	89a2      	ldrh	r2, [r4, #12]
 800fa3a:	4620      	mov	r0, r4
 800fa3c:	68a1      	ldr	r1, [r4, #8]
 800fa3e:	9500      	str	r5, [sp, #0]
 800fa40:	f000 fea0 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800fa44:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800fa48:	2306      	movs	r3, #6
 800fa4a:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 800fa4c:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800fa4e:	7623      	strb	r3, [r4, #24]
 800fa50:	e787      	b.n	800f962 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800fa52:	7961      	ldrb	r1, [r4, #5]
 800fa54:	4620      	mov	r0, r4
 800fa56:	f00e fc2f 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fa5a:	2801      	cmp	r0, #1
 800fa5c:	d06d      	beq.n	800fb3a <USBH_Get_DevDesc+0x1ea>
      else if (URB_Status == USBH_URB_STALL)
 800fa5e:	2805      	cmp	r0, #5
 800fa60:	d01f      	beq.n	800faa2 <USBH_Get_DevDesc+0x152>
      else if (URB_Status == USBH_URB_NOTREADY)
 800fa62:	2802      	cmp	r0, #2
 800fa64:	d074      	beq.n	800fb50 <USBH_Get_DevDesc+0x200>
        if (URB_Status == USBH_URB_ERROR)
 800fa66:	2804      	cmp	r0, #4
 800fa68:	f47f af7a 	bne.w	800f960 <USBH_Get_DevDesc+0x10>
          phost->Control.state = CTRL_ERROR;
 800fa6c:	230b      	movs	r3, #11
 800fa6e:	7623      	strb	r3, [r4, #24]
 800fa70:	e7ab      	b.n	800f9ca <USBH_Get_DevDesc+0x7a>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 800fa72:	2200      	movs	r2, #0
 800fa74:	7923      	ldrb	r3, [r4, #4]
 800fa76:	4620      	mov	r0, r4
 800fa78:	4611      	mov	r1, r2
 800fa7a:	f000 fe9b 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800fa7e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800fa82:	2308      	movs	r3, #8
 800fa84:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 800fa86:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800fa88:	7623      	strb	r3, [r4, #24]
 800fa8a:	e76a      	b.n	800f962 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800fa8c:	7921      	ldrb	r1, [r4, #4]
 800fa8e:	4620      	mov	r0, r4
 800fa90:	f00e fc12 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fa94:	2801      	cmp	r0, #1
 800fa96:	d025      	beq.n	800fae4 <USBH_Get_DevDesc+0x194>
      else if (URB_Status == USBH_URB_ERROR)
 800fa98:	2804      	cmp	r0, #4
 800fa9a:	d0af      	beq.n	800f9fc <USBH_Get_DevDesc+0xac>
        if (URB_Status == USBH_URB_STALL)
 800fa9c:	2805      	cmp	r0, #5
 800fa9e:	f47f af5f 	bne.w	800f960 <USBH_Get_DevDesc+0x10>
        phost->RequestState = CMD_SEND;
 800faa2:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 800faa4:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
 800faa6:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 800faa8:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800faaa:	7623      	strb	r3, [r4, #24]
 800faac:	e759      	b.n	800f962 <USBH_Get_DevDesc+0x12>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 800faae:	2200      	movs	r2, #0
 800fab0:	2501      	movs	r5, #1
 800fab2:	7963      	ldrb	r3, [r4, #5]
 800fab4:	4620      	mov	r0, r4
 800fab6:	4611      	mov	r1, r2
 800fab8:	9500      	str	r5, [sp, #0]
 800faba:	f000 fe63 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800fabe:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800fac2:	230a      	movs	r3, #10
 800fac4:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 800fac6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800fac8:	7623      	strb	r3, [r4, #24]
 800faca:	e74a      	b.n	800f962 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800facc:	7961      	ldrb	r1, [r4, #5]
 800face:	4620      	mov	r0, r4
 800fad0:	f00e fbf2 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fad4:	2801      	cmp	r0, #1
 800fad6:	d005      	beq.n	800fae4 <USBH_Get_DevDesc+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
 800fad8:	2802      	cmp	r0, #2
 800fada:	d1a8      	bne.n	800fa2e <USBH_Get_DevDesc+0xde>
            phost->Control.state = CTRL_STATUS_OUT;
 800fadc:	2309      	movs	r3, #9
 800fade:	2001      	movs	r0, #1
 800fae0:	7623      	strb	r3, [r4, #24]
 800fae2:	e73e      	b.n	800f962 <USBH_Get_DevDesc+0x12>
        phost->RequestState = CMD_SEND;
 800fae4:	2201      	movs	r2, #1
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
 800fae6:	f894 311c 	ldrb.w	r3, [r4, #284]	; 0x11c
        phost->Control.state = CTRL_IDLE;
 800faea:	2000      	movs	r0, #0
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
 800faec:	f894 111d 	ldrb.w	r1, [r4, #285]	; 0x11d
        phost->RequestState = CMD_SEND;
 800faf0:	70a2      	strb	r2, [r4, #2]
  if (length > 8U)
 800faf2:	2d08      	cmp	r5, #8
  dev_desc->bcdUSB             = LE16(buf +  2);
 800faf4:	f8b4 211e 	ldrh.w	r2, [r4, #286]	; 0x11e
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
 800faf8:	f884 3326 	strb.w	r3, [r4, #806]	; 0x326
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
 800fafc:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
        phost->Control.state = CTRL_IDLE;
 800fb00:	7620      	strb	r0, [r4, #24]
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
 800fb02:	f884 1327 	strb.w	r1, [r4, #807]	; 0x327
  dev_desc->bcdUSB             = LE16(buf +  2);
 800fb06:	f8a4 2328 	strh.w	r2, [r4, #808]	; 0x328
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
 800fb0a:	f8c4 332a 	str.w	r3, [r4, #810]	; 0x32a
  if (length > 8U)
 800fb0e:	f67f af28 	bls.w	800f962 <USBH_Get_DevDesc+0x12>
    dev_desc->idVendor           = LE16(buf +  8);
 800fb12:	f8b4 5124 	ldrh.w	r5, [r4, #292]	; 0x124
    dev_desc->idProduct          = LE16(buf + 10);
 800fb16:	f8b4 1126 	ldrh.w	r1, [r4, #294]	; 0x126
    dev_desc->bcdDevice          = LE16(buf + 12);
 800fb1a:	f8b4 2128 	ldrh.w	r2, [r4, #296]	; 0x128
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
 800fb1e:	f8d4 312a 	ldr.w	r3, [r4, #298]	; 0x12a
    dev_desc->idVendor           = LE16(buf +  8);
 800fb22:	f8a4 532e 	strh.w	r5, [r4, #814]	; 0x32e
    dev_desc->idProduct          = LE16(buf + 10);
 800fb26:	f8a4 1330 	strh.w	r1, [r4, #816]	; 0x330
    dev_desc->bcdDevice          = LE16(buf + 12);
 800fb2a:	f8a4 2332 	strh.w	r2, [r4, #818]	; 0x332
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
 800fb2e:	f8c4 3334 	str.w	r3, [r4, #820]	; 0x334
}
 800fb32:	b002      	add	sp, #8
 800fb34:	bd70      	pop	{r4, r5, r6, pc}
          if (direction == USB_D2H)
 800fb36:	2a00      	cmp	r2, #0
 800fb38:	dbd0      	blt.n	800fadc <USBH_Get_DevDesc+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
 800fb3a:	2307      	movs	r3, #7
 800fb3c:	2001      	movs	r0, #1
 800fb3e:	7623      	strb	r3, [r4, #24]
 800fb40:	e70f      	b.n	800f962 <USBH_Get_DevDesc+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
 800fb42:	8ae3      	ldrh	r3, [r4, #22]
 800fb44:	f994 2010 	ldrsb.w	r2, [r4, #16]
 800fb48:	2b00      	cmp	r3, #0
 800fb4a:	d0f4      	beq.n	800fb36 <USBH_Get_DevDesc+0x1e6>
          if (direction == USB_D2H)
 800fb4c:	2a00      	cmp	r2, #0
 800fb4e:	db08      	blt.n	800fb62 <USBH_Get_DevDesc+0x212>
            phost->Control.state = CTRL_DATA_OUT;
 800fb50:	2305      	movs	r3, #5
 800fb52:	2001      	movs	r0, #1
 800fb54:	7623      	strb	r3, [r4, #24]
 800fb56:	e704      	b.n	800f962 <USBH_Get_DevDesc+0x12>
        phost->Control.state = CTRL_SETUP;
 800fb58:	2301      	movs	r3, #1
 800fb5a:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 800fb5c:	4618      	mov	r0, r3
 800fb5e:	70a3      	strb	r3, [r4, #2]
 800fb60:	e6ff      	b.n	800f962 <USBH_Get_DevDesc+0x12>
            phost->Control.state = CTRL_DATA_IN;
 800fb62:	2303      	movs	r3, #3
 800fb64:	7623      	strb	r3, [r4, #24]
 800fb66:	e6fc      	b.n	800f962 <USBH_Get_DevDesc+0x12>
 800fb68:	01000680 	.word	0x01000680

0800fb6c <USBH_Get_CfgDesc>:
{
 800fb6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (phost->RequestState == CMD_SEND)
 800fb70:	7883      	ldrb	r3, [r0, #2]
{
 800fb72:	b083      	sub	sp, #12
 800fb74:	4605      	mov	r5, r0
  uint8_t *pData = phost->device.CfgDesc_Raw;;
 800fb76:	f100 041c 	add.w	r4, r0, #28
  if (phost->RequestState == CMD_SEND)
 800fb7a:	2b01      	cmp	r3, #1
 800fb7c:	d012      	beq.n	800fba4 <USBH_Get_CfgDesc+0x38>
  switch (phost->RequestState)
 800fb7e:	2b02      	cmp	r3, #2
 800fb80:	d003      	beq.n	800fb8a <USBH_Get_CfgDesc+0x1e>
  status = USBH_BUSY;
 800fb82:	2001      	movs	r0, #1
}
 800fb84:	b003      	add	sp, #12
 800fb86:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  switch (phost->Control.state)
 800fb8a:	7e03      	ldrb	r3, [r0, #24]
 800fb8c:	460e      	mov	r6, r1
 800fb8e:	3b01      	subs	r3, #1
 800fb90:	2b0a      	cmp	r3, #10
 800fb92:	d8f6      	bhi.n	800fb82 <USBH_Get_CfgDesc+0x16>
 800fb94:	e8df f003 	tbb	[pc, r3]
 800fb98:	5145372e 	.word	0x5145372e
 800fb9c:	867a695b 	.word	0x867a695b
 800fba0:	a496      	.short	0xa496
 800fba2:	14          	.byte	0x14
 800fba3:	00          	.byte	0x00
    phost->Control.setup.b.wLength.w = length;
 800fba4:	82c1      	strh	r1, [r0, #22]
    phost->Control.setup.b.wValue.w = value_idx;
 800fba6:	2600      	movs	r6, #0
      phost->Control.buff = buff;
 800fba8:	6084      	str	r4, [r0, #8]
      phost->RequestState = CMD_WAIT;
 800fbaa:	2202      	movs	r2, #2
      phost->Control.length = length;
 800fbac:	8181      	strh	r1, [r0, #12]
      status = USBH_BUSY;
 800fbae:	4618      	mov	r0, r3
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800fbb0:	4f98      	ldr	r7, [pc, #608]	; (800fe14 <USBH_Get_CfgDesc+0x2a8>)
      phost->Control.state = CTRL_SETUP;
 800fbb2:	762b      	strb	r3, [r5, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800fbb4:	612f      	str	r7, [r5, #16]
    phost->Control.setup.b.wValue.w = value_idx;
 800fbb6:	82ae      	strh	r6, [r5, #20]
      phost->RequestState = CMD_WAIT;
 800fbb8:	70aa      	strb	r2, [r5, #2]
}
 800fbba:	b003      	add	sp, #12
 800fbbc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 800fbc0:	7e43      	ldrb	r3, [r0, #25]
 800fbc2:	3301      	adds	r3, #1
 800fbc4:	b2db      	uxtb	r3, r3
 800fbc6:	2b02      	cmp	r3, #2
 800fbc8:	7643      	strb	r3, [r0, #25]
 800fbca:	f240 811b 	bls.w	800fe04 <USBH_Get_CfgDesc+0x298>
        phost->Control.errorcount = 0U;
 800fbce:	2400      	movs	r4, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800fbd0:	f8d0 3544 	ldr.w	r3, [r0, #1348]	; 0x544
 800fbd4:	2106      	movs	r1, #6
 800fbd6:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 800fbd8:	7969      	ldrb	r1, [r5, #5]
        phost->Control.errorcount = 0U;
 800fbda:	766c      	strb	r4, [r5, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 800fbdc:	4628      	mov	r0, r5
 800fbde:	f000 fe6d 	bl	80108bc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 800fbe2:	7929      	ldrb	r1, [r5, #4]
 800fbe4:	4628      	mov	r0, r5
 800fbe6:	f000 fe69 	bl	80108bc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 800fbea:	702c      	strb	r4, [r5, #0]
        phost->RequestState = CMD_SEND;
 800fbec:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 800fbee:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 800fbf0:	70ab      	strb	r3, [r5, #2]
 800fbf2:	e7c7      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800fbf4:	7942      	ldrb	r2, [r0, #5]
 800fbf6:	f100 0110 	add.w	r1, r0, #16
 800fbfa:	f000 fdb3 	bl	8010764 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 800fbfe:	2302      	movs	r3, #2
 800fc00:	2001      	movs	r0, #1
 800fc02:	762b      	strb	r3, [r5, #24]
 800fc04:	e7be      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800fc06:	7941      	ldrb	r1, [r0, #5]
 800fc08:	f00e fb56 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fc0c:	2801      	cmp	r0, #1
 800fc0e:	f000 80ee 	beq.w	800fdee <USBH_Get_CfgDesc+0x282>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 800fc12:	2804      	cmp	r0, #4
 800fc14:	d001      	beq.n	800fc1a <USBH_Get_CfgDesc+0xae>
 800fc16:	2802      	cmp	r0, #2
 800fc18:	d1b3      	bne.n	800fb82 <USBH_Get_CfgDesc+0x16>
          phost->Control.state = CTRL_ERROR;
 800fc1a:	230b      	movs	r3, #11
 800fc1c:	2001      	movs	r0, #1
 800fc1e:	762b      	strb	r3, [r5, #24]
 800fc20:	e7b0      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
      phost->Control.timer = (uint16_t)phost->Timer;
 800fc22:	f8d0 2534 	ldr.w	r2, [r0, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 800fc26:	7903      	ldrb	r3, [r0, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 800fc28:	81c2      	strh	r2, [r0, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 800fc2a:	6881      	ldr	r1, [r0, #8]
 800fc2c:	8982      	ldrh	r2, [r0, #12]
 800fc2e:	f000 fdc1 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 800fc32:	2304      	movs	r3, #4
 800fc34:	2001      	movs	r0, #1
 800fc36:	762b      	strb	r3, [r5, #24]
 800fc38:	e7a4      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800fc3a:	7901      	ldrb	r1, [r0, #4]
 800fc3c:	f00e fb3c 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fc40:	2801      	cmp	r0, #1
 800fc42:	d054      	beq.n	800fcee <USBH_Get_CfgDesc+0x182>
      if (URB_Status == USBH_URB_STALL)
 800fc44:	2805      	cmp	r0, #5
 800fc46:	d037      	beq.n	800fcb8 <USBH_Get_CfgDesc+0x14c>
        if (URB_Status == USBH_URB_ERROR)
 800fc48:	2804      	cmp	r0, #4
 800fc4a:	d19a      	bne.n	800fb82 <USBH_Get_CfgDesc+0x16>
 800fc4c:	e7e5      	b.n	800fc1a <USBH_Get_CfgDesc+0xae>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 800fc4e:	2401      	movs	r4, #1
 800fc50:	7943      	ldrb	r3, [r0, #5]
 800fc52:	8982      	ldrh	r2, [r0, #12]
 800fc54:	6881      	ldr	r1, [r0, #8]
 800fc56:	9400      	str	r4, [sp, #0]
 800fc58:	f000 fd94 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800fc5c:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800fc60:	2306      	movs	r3, #6
 800fc62:	4620      	mov	r0, r4
      phost->Control.timer = (uint16_t)phost->Timer;
 800fc64:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800fc66:	762b      	strb	r3, [r5, #24]
 800fc68:	e78c      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800fc6a:	7941      	ldrb	r1, [r0, #5]
 800fc6c:	f00e fb24 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fc70:	2801      	cmp	r0, #1
 800fc72:	f000 80b8 	beq.w	800fde6 <USBH_Get_CfgDesc+0x27a>
      else if (URB_Status == USBH_URB_STALL)
 800fc76:	2805      	cmp	r0, #5
 800fc78:	d01e      	beq.n	800fcb8 <USBH_Get_CfgDesc+0x14c>
      else if (URB_Status == USBH_URB_NOTREADY)
 800fc7a:	2802      	cmp	r0, #2
 800fc7c:	f000 80be 	beq.w	800fdfc <USBH_Get_CfgDesc+0x290>
        if (URB_Status == USBH_URB_ERROR)
 800fc80:	2804      	cmp	r0, #4
 800fc82:	f47f af7e 	bne.w	800fb82 <USBH_Get_CfgDesc+0x16>
          phost->Control.state = CTRL_ERROR;
 800fc86:	230b      	movs	r3, #11
 800fc88:	762b      	strb	r3, [r5, #24]
 800fc8a:	e7af      	b.n	800fbec <USBH_Get_CfgDesc+0x80>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 800fc8c:	2200      	movs	r2, #0
 800fc8e:	7903      	ldrb	r3, [r0, #4]
 800fc90:	4611      	mov	r1, r2
 800fc92:	f000 fd8f 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800fc96:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800fc9a:	2308      	movs	r3, #8
 800fc9c:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 800fc9e:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800fca0:	762b      	strb	r3, [r5, #24]
 800fca2:	e76f      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800fca4:	7901      	ldrb	r1, [r0, #4]
 800fca6:	f00e fb07 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fcaa:	2801      	cmp	r0, #1
 800fcac:	d023      	beq.n	800fcf6 <USBH_Get_CfgDesc+0x18a>
      else if (URB_Status == USBH_URB_ERROR)
 800fcae:	2804      	cmp	r0, #4
 800fcb0:	d0b3      	beq.n	800fc1a <USBH_Get_CfgDesc+0xae>
        if (URB_Status == USBH_URB_STALL)
 800fcb2:	2805      	cmp	r0, #5
 800fcb4:	f47f af65 	bne.w	800fb82 <USBH_Get_CfgDesc+0x16>
        phost->RequestState = CMD_SEND;
 800fcb8:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 800fcba:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
 800fcbc:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 800fcbe:	70aa      	strb	r2, [r5, #2]
        phost->Control.state = CTRL_IDLE;
 800fcc0:	762b      	strb	r3, [r5, #24]
 800fcc2:	e75f      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 800fcc4:	2200      	movs	r2, #0
 800fcc6:	2401      	movs	r4, #1
 800fcc8:	7943      	ldrb	r3, [r0, #5]
 800fcca:	4611      	mov	r1, r2
 800fccc:	9400      	str	r4, [sp, #0]
 800fcce:	f000 fd59 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800fcd2:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800fcd6:	230a      	movs	r3, #10
 800fcd8:	4620      	mov	r0, r4
      phost->Control.timer = (uint16_t)phost->Timer;
 800fcda:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800fcdc:	762b      	strb	r3, [r5, #24]
 800fcde:	e751      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800fce0:	7941      	ldrb	r1, [r0, #5]
 800fce2:	f00e fae9 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fce6:	2801      	cmp	r0, #1
 800fce8:	d005      	beq.n	800fcf6 <USBH_Get_CfgDesc+0x18a>
      else if (URB_Status == USBH_URB_NOTREADY)
 800fcea:	2802      	cmp	r0, #2
 800fcec:	d1ac      	bne.n	800fc48 <USBH_Get_CfgDesc+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
 800fcee:	2309      	movs	r3, #9
 800fcf0:	2001      	movs	r0, #1
 800fcf2:	762b      	strb	r3, [r5, #24]
 800fcf4:	e746      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
 800fcf6:	7f2a      	ldrb	r2, [r5, #28]
        phost->RequestState = CMD_SEND;
 800fcf8:	2101      	movs	r1, #1
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
 800fcfa:	7f6b      	ldrb	r3, [r5, #29]
        phost->Control.state = CTRL_IDLE;
 800fcfc:	2700      	movs	r7, #0
  cfg_desc->wTotalLength        = LE16(buf + 2);
 800fcfe:	8be8      	ldrh	r0, [r5, #30]
  if (length > USB_CONFIGURATION_DESC_SIZE)
 800fd00:	2e09      	cmp	r6, #9
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
 800fd02:	f885 2338 	strb.w	r2, [r5, #824]	; 0x338
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
 800fd06:	f885 3339 	strb.w	r3, [r5, #825]	; 0x339
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
 800fd0a:	6a2a      	ldr	r2, [r5, #32]
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
 800fd0c:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
        phost->RequestState = CMD_SEND;
 800fd10:	70a9      	strb	r1, [r5, #2]
        phost->Control.state = CTRL_IDLE;
 800fd12:	762f      	strb	r7, [r5, #24]
  cfg_desc->wTotalLength        = LE16(buf + 2);
 800fd14:	f8a5 033a 	strh.w	r0, [r5, #826]	; 0x33a
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
 800fd18:	f8c5 233c 	str.w	r2, [r5, #828]	; 0x33c
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
 800fd1c:	f885 3340 	strb.w	r3, [r5, #832]	; 0x340
  if (length > USB_CONFIGURATION_DESC_SIZE)
 800fd20:	d913      	bls.n	800fd4a <USBH_Get_CfgDesc+0x1de>
 800fd22:	46ac      	mov	ip, r5
    ptr = USB_LEN_CFG_DESC;
 800fd24:	2209      	movs	r2, #9
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 800fd26:	f04f 0e2a 	mov.w	lr, #42	; 0x2a
 800fd2a:	b2fe      	uxtb	r6, r7
 800fd2c:	2e09      	cmp	r6, #9
 800fd2e:	bf8c      	ite	hi
 800fd30:	2600      	movhi	r6, #0
 800fd32:	2601      	movls	r6, #1
 800fd34:	e007      	b.n	800fd46 <USBH_Get_CfgDesc+0x1da>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 800fd36:	b146      	cbz	r6, 800fd4a <USBH_Get_CfgDesc+0x1de>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800fd38:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 800fd3a:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800fd3c:	4413      	add	r3, r2
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
 800fd3e:	7861      	ldrb	r1, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800fd40:	b29a      	uxth	r2, r3
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
 800fd42:	2904      	cmp	r1, #4
 800fd44:	d005      	beq.n	800fd52 <USBH_Get_CfgDesc+0x1e6>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 800fd46:	4290      	cmp	r0, r2
 800fd48:	d8f5      	bhi.n	800fd36 <USBH_Get_CfgDesc+0x1ca>
        status = USBH_NOT_SUPPORTED;
 800fd4a:	2000      	movs	r0, #0
}
 800fd4c:	b003      	add	sp, #12
 800fd4e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
 800fd52:	7823      	ldrb	r3, [r4, #0]
        ep_ix = 0U;
 800fd54:	2100      	movs	r1, #0
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 800fd56:	fb0e f907 	mul.w	r9, lr, r7
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
 800fd5a:	f88c 3342 	strb.w	r3, [ip, #834]	; 0x342
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);
 800fd5e:	7863      	ldrb	r3, [r4, #1]
 800fd60:	f88c 3343 	strb.w	r3, [ip, #835]	; 0x343
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);
 800fd64:	78a3      	ldrb	r3, [r4, #2]
 800fd66:	f88c 3344 	strb.w	r3, [ip, #836]	; 0x344
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);
 800fd6a:	78e3      	ldrb	r3, [r4, #3]
 800fd6c:	f88c 3345 	strb.w	r3, [ip, #837]	; 0x345
  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);
 800fd70:	f894 8004 	ldrb.w	r8, [r4, #4]
 800fd74:	f88c 8346 	strb.w	r8, [ip, #838]	; 0x346
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);
 800fd78:	7963      	ldrb	r3, [r4, #5]
 800fd7a:	f88c 3347 	strb.w	r3, [ip, #839]	; 0x347
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);
 800fd7e:	79a3      	ldrb	r3, [r4, #6]
 800fd80:	f88c 3348 	strb.w	r3, [ip, #840]	; 0x348
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);
 800fd84:	79e3      	ldrb	r3, [r4, #7]
 800fd86:	f88c 3349 	strb.w	r3, [ip, #841]	; 0x349
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8);
 800fd8a:	7a23      	ldrb	r3, [r4, #8]
 800fd8c:	f88c 334a 	strb.w	r3, [ip, #842]	; 0x34a
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 800fd90:	4290      	cmp	r0, r2
 800fd92:	d922      	bls.n	800fdda <USBH_Get_CfgDesc+0x26e>
 800fd94:	4541      	cmp	r1, r8
 800fd96:	d220      	bcs.n	800fdda <USBH_Get_CfgDesc+0x26e>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800fd98:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 800fd9a:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800fd9c:	4413      	add	r3, r2
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
 800fd9e:	7866      	ldrb	r6, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 800fda0:	b29a      	uxth	r2, r3
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
 800fda2:	2e05      	cmp	r6, #5
 800fda4:	d1f4      	bne.n	800fd90 <USBH_Get_CfgDesc+0x224>
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 800fda6:	3101      	adds	r1, #1
 800fda8:	7826      	ldrb	r6, [r4, #0]
 800fdaa:	eb09 03c1 	add.w	r3, r9, r1, lsl #3
            ep_ix++;
 800fdae:	b2c9      	uxtb	r1, r1
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 800fdb0:	442b      	add	r3, r5
 800fdb2:	f883 6344 	strb.w	r6, [r3, #836]	; 0x344
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1);
 800fdb6:	7866      	ldrb	r6, [r4, #1]
 800fdb8:	f883 6345 	strb.w	r6, [r3, #837]	; 0x345
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2);
 800fdbc:	78a6      	ldrb	r6, [r4, #2]
 800fdbe:	f883 6346 	strb.w	r6, [r3, #838]	; 0x346
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3);
 800fdc2:	78e6      	ldrb	r6, [r4, #3]
 800fdc4:	f883 6347 	strb.w	r6, [r3, #839]	; 0x347
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4);
 800fdc8:	88a6      	ldrh	r6, [r4, #4]
 800fdca:	f8a3 6348 	strh.w	r6, [r3, #840]	; 0x348
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6);
 800fdce:	79a6      	ldrb	r6, [r4, #6]
 800fdd0:	f883 634a 	strb.w	r6, [r3, #842]	; 0x34a
 800fdd4:	f89c 8346 	ldrb.w	r8, [ip, #838]	; 0x346
 800fdd8:	e7da      	b.n	800fd90 <USBH_Get_CfgDesc+0x224>
 800fdda:	3701      	adds	r7, #1
 800fddc:	f10c 0c2a 	add.w	ip, ip, #42	; 0x2a
 800fde0:	e7a3      	b.n	800fd2a <USBH_Get_CfgDesc+0x1be>
          if (direction == USB_D2H)
 800fde2:	2b00      	cmp	r3, #0
 800fde4:	db83      	blt.n	800fcee <USBH_Get_CfgDesc+0x182>
            phost->Control.state = CTRL_STATUS_IN;
 800fde6:	2307      	movs	r3, #7
 800fde8:	2001      	movs	r0, #1
 800fdea:	762b      	strb	r3, [r5, #24]
 800fdec:	e6ca      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
        if (phost->Control.setup.b.wLength.w != 0U)
 800fdee:	8aea      	ldrh	r2, [r5, #22]
 800fdf0:	f995 3010 	ldrsb.w	r3, [r5, #16]
 800fdf4:	2a00      	cmp	r2, #0
 800fdf6:	d0f4      	beq.n	800fde2 <USBH_Get_CfgDesc+0x276>
          if (direction == USB_D2H)
 800fdf8:	2b00      	cmp	r3, #0
 800fdfa:	db08      	blt.n	800fe0e <USBH_Get_CfgDesc+0x2a2>
            phost->Control.state = CTRL_DATA_OUT;
 800fdfc:	2305      	movs	r3, #5
 800fdfe:	2001      	movs	r0, #1
 800fe00:	762b      	strb	r3, [r5, #24]
 800fe02:	e6bf      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
        phost->Control.state = CTRL_SETUP;
 800fe04:	2301      	movs	r3, #1
 800fe06:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
 800fe08:	4618      	mov	r0, r3
 800fe0a:	70ab      	strb	r3, [r5, #2]
 800fe0c:	e6ba      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
            phost->Control.state = CTRL_DATA_IN;
 800fe0e:	2303      	movs	r3, #3
 800fe10:	762b      	strb	r3, [r5, #24]
 800fe12:	e6b7      	b.n	800fb84 <USBH_Get_CfgDesc+0x18>
 800fe14:	02000680 	.word	0x02000680

0800fe18 <USBH_Get_StringDesc>:
{
 800fe18:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (phost->RequestState == CMD_SEND)
 800fe1a:	7885      	ldrb	r5, [r0, #2]
{
 800fe1c:	b085      	sub	sp, #20
 800fe1e:	4604      	mov	r4, r0
                                   phost->device.Data, length)) == USBH_OK)
 800fe20:	f500 768e 	add.w	r6, r0, #284	; 0x11c
  if (phost->RequestState == CMD_SEND)
 800fe24:	2d01      	cmp	r5, #1
 800fe26:	d010      	beq.n	800fe4a <USBH_Get_StringDesc+0x32>
  switch (phost->RequestState)
 800fe28:	2d02      	cmp	r5, #2
 800fe2a:	d002      	beq.n	800fe32 <USBH_Get_StringDesc+0x1a>
  status = USBH_BUSY;
 800fe2c:	2001      	movs	r0, #1
}
 800fe2e:	b005      	add	sp, #20
 800fe30:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (phost->Control.state)
 800fe32:	7e01      	ldrb	r1, [r0, #24]
 800fe34:	3901      	subs	r1, #1
 800fe36:	290a      	cmp	r1, #10
 800fe38:	d8f8      	bhi.n	800fe2c <USBH_Get_StringDesc+0x14>
 800fe3a:	e8df f001 	tbb	[pc, r1]
 800fe3e:	3e34      	.short	0x3e34
 800fe40:	74655a4d 	.word	0x74655a4d
 800fe44:	b5a69184 	.word	0xb5a69184
 800fe48:	19          	.byte	0x19
 800fe49:	00          	.byte	0x00
  if ((status = USBH_GetDescriptor(phost,
 800fe4a:	f441 7140 	orr.w	r1, r1, #768	; 0x300
    phost->Control.setup.b.wLength.w = length;
 800fe4e:	82c3      	strh	r3, [r0, #22]
      phost->Control.buff = buff;
 800fe50:	6086      	str	r6, [r0, #8]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800fe52:	f44f 6cd0 	mov.w	ip, #1664	; 0x680
    phost->Control.setup.b.wValue.w = value_idx;
 800fe56:	8241      	strh	r1, [r0, #18]
      phost->Control.setup.b.wIndex.w = 0x0409U;
 800fe58:	f240 4709 	movw	r7, #1033	; 0x409
      phost->Control.length = length;
 800fe5c:	8183      	strh	r3, [r0, #12]
      phost->RequestState = CMD_WAIT;
 800fe5e:	2202      	movs	r2, #2
      status = USBH_BUSY;
 800fe60:	4628      	mov	r0, r5
      phost->Control.state = CTRL_SETUP;
 800fe62:	7625      	strb	r5, [r4, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800fe64:	f8a4 c010 	strh.w	ip, [r4, #16]
      phost->Control.setup.b.wIndex.w = 0x0409U;
 800fe68:	82a7      	strh	r7, [r4, #20]
      phost->RequestState = CMD_WAIT;
 800fe6a:	70a2      	strb	r2, [r4, #2]
}
 800fe6c:	b005      	add	sp, #20
 800fe6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 800fe70:	7e63      	ldrb	r3, [r4, #25]
 800fe72:	3301      	adds	r3, #1
 800fe74:	b2db      	uxtb	r3, r3
 800fe76:	2b02      	cmp	r3, #2
 800fe78:	7663      	strb	r3, [r4, #25]
 800fe7a:	f240 80d3 	bls.w	8010024 <USBH_Get_StringDesc+0x20c>
        phost->Control.errorcount = 0U;
 800fe7e:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 800fe80:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 800fe84:	2106      	movs	r1, #6
 800fe86:	4620      	mov	r0, r4
 800fe88:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 800fe8a:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 800fe8c:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 800fe8e:	4620      	mov	r0, r4
 800fe90:	f000 fd14 	bl	80108bc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 800fe94:	7921      	ldrb	r1, [r4, #4]
 800fe96:	4620      	mov	r0, r4
 800fe98:	f000 fd10 	bl	80108bc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 800fe9c:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 800fe9e:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 800fea0:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 800fea2:	70a3      	strb	r3, [r4, #2]
 800fea4:	e7c3      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 800fea6:	7962      	ldrb	r2, [r4, #5]
 800fea8:	f104 0110 	add.w	r1, r4, #16
 800feac:	4620      	mov	r0, r4
 800feae:	f000 fc59 	bl	8010764 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 800feb2:	2302      	movs	r3, #2
 800feb4:	2001      	movs	r0, #1
 800feb6:	7623      	strb	r3, [r4, #24]
 800feb8:	e7b9      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800feba:	7961      	ldrb	r1, [r4, #5]
 800febc:	4620      	mov	r0, r4
 800febe:	f00e f9fb 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fec2:	2801      	cmp	r0, #1
 800fec4:	f000 80a3 	beq.w	801000e <USBH_Get_StringDesc+0x1f6>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 800fec8:	2804      	cmp	r0, #4
 800feca:	d001      	beq.n	800fed0 <USBH_Get_StringDesc+0xb8>
 800fecc:	2802      	cmp	r0, #2
 800fece:	d1ad      	bne.n	800fe2c <USBH_Get_StringDesc+0x14>
          phost->Control.state = CTRL_ERROR;
 800fed0:	230b      	movs	r3, #11
 800fed2:	2001      	movs	r0, #1
 800fed4:	7623      	strb	r3, [r4, #24]
 800fed6:	e7aa      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
      phost->Control.timer = (uint16_t)phost->Timer;
 800fed8:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 800fedc:	4620      	mov	r0, r4
 800fede:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 800fee0:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 800fee2:	68a1      	ldr	r1, [r4, #8]
 800fee4:	89a2      	ldrh	r2, [r4, #12]
 800fee6:	f000 fc65 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 800feea:	2304      	movs	r3, #4
 800feec:	2001      	movs	r0, #1
 800feee:	7623      	strb	r3, [r4, #24]
 800fef0:	e79d      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800fef2:	7921      	ldrb	r1, [r4, #4]
 800fef4:	4620      	mov	r0, r4
 800fef6:	f00e f9df 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800fefa:	2801      	cmp	r0, #1
 800fefc:	d060      	beq.n	800ffc0 <USBH_Get_StringDesc+0x1a8>
      if (URB_Status == USBH_URB_STALL)
 800fefe:	2805      	cmp	r0, #5
 800ff00:	d03d      	beq.n	800ff7e <USBH_Get_StringDesc+0x166>
        if (URB_Status == USBH_URB_ERROR)
 800ff02:	2804      	cmp	r0, #4
 800ff04:	d192      	bne.n	800fe2c <USBH_Get_StringDesc+0x14>
 800ff06:	e7e3      	b.n	800fed0 <USBH_Get_StringDesc+0xb8>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 800ff08:	2501      	movs	r5, #1
 800ff0a:	7963      	ldrb	r3, [r4, #5]
 800ff0c:	89a2      	ldrh	r2, [r4, #12]
 800ff0e:	4620      	mov	r0, r4
 800ff10:	68a1      	ldr	r1, [r4, #8]
 800ff12:	9500      	str	r5, [sp, #0]
 800ff14:	f000 fc36 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800ff18:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800ff1c:	2306      	movs	r3, #6
 800ff1e:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 800ff20:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 800ff22:	7623      	strb	r3, [r4, #24]
 800ff24:	e783      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800ff26:	7961      	ldrb	r1, [r4, #5]
 800ff28:	4620      	mov	r0, r4
 800ff2a:	f00e f9c5 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800ff2e:	2801      	cmp	r0, #1
 800ff30:	d069      	beq.n	8010006 <USBH_Get_StringDesc+0x1ee>
      else if (URB_Status == USBH_URB_STALL)
 800ff32:	2805      	cmp	r0, #5
 800ff34:	d023      	beq.n	800ff7e <USBH_Get_StringDesc+0x166>
      else if (URB_Status == USBH_URB_NOTREADY)
 800ff36:	2802      	cmp	r0, #2
 800ff38:	d070      	beq.n	801001c <USBH_Get_StringDesc+0x204>
        if (URB_Status == USBH_URB_ERROR)
 800ff3a:	2804      	cmp	r0, #4
 800ff3c:	f47f af76 	bne.w	800fe2c <USBH_Get_StringDesc+0x14>
          phost->Control.state = CTRL_ERROR;
 800ff40:	230b      	movs	r3, #11
 800ff42:	7623      	strb	r3, [r4, #24]
 800ff44:	e7ab      	b.n	800fe9e <USBH_Get_StringDesc+0x86>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 800ff46:	2200      	movs	r2, #0
 800ff48:	7923      	ldrb	r3, [r4, #4]
 800ff4a:	4620      	mov	r0, r4
 800ff4c:	4611      	mov	r1, r2
 800ff4e:	f000 fc31 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800ff52:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800ff56:	2308      	movs	r3, #8
 800ff58:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 800ff5a:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 800ff5c:	7623      	strb	r3, [r4, #24]
 800ff5e:	e766      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800ff60:	7921      	ldrb	r1, [r4, #4]
 800ff62:	4620      	mov	r0, r4
 800ff64:	e9cd 2302 	strd	r2, r3, [sp, #8]
 800ff68:	f00e f9a6 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800ff6c:	2801      	cmp	r0, #1
 800ff6e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800ff72:	d029      	beq.n	800ffc8 <USBH_Get_StringDesc+0x1b0>
      else if (URB_Status == USBH_URB_ERROR)
 800ff74:	2804      	cmp	r0, #4
 800ff76:	d0ab      	beq.n	800fed0 <USBH_Get_StringDesc+0xb8>
        if (URB_Status == USBH_URB_STALL)
 800ff78:	2805      	cmp	r0, #5
 800ff7a:	f47f af57 	bne.w	800fe2c <USBH_Get_StringDesc+0x14>
        phost->RequestState = CMD_SEND;
 800ff7e:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 800ff80:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
 800ff82:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 800ff84:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800ff86:	7623      	strb	r3, [r4, #24]
 800ff88:	e751      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 800ff8a:	2200      	movs	r2, #0
 800ff8c:	2501      	movs	r5, #1
 800ff8e:	7963      	ldrb	r3, [r4, #5]
 800ff90:	4620      	mov	r0, r4
 800ff92:	4611      	mov	r1, r2
 800ff94:	9500      	str	r5, [sp, #0]
 800ff96:	f000 fbf5 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 800ff9a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800ff9e:	230a      	movs	r3, #10
 800ffa0:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 800ffa2:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 800ffa4:	7623      	strb	r3, [r4, #24]
 800ffa6:	e742      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800ffa8:	7961      	ldrb	r1, [r4, #5]
 800ffaa:	4620      	mov	r0, r4
 800ffac:	e9cd 2302 	strd	r2, r3, [sp, #8]
 800ffb0:	f00e f982 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 800ffb4:	2801      	cmp	r0, #1
 800ffb6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800ffba:	d005      	beq.n	800ffc8 <USBH_Get_StringDesc+0x1b0>
      else if (URB_Status == USBH_URB_NOTREADY)
 800ffbc:	2802      	cmp	r0, #2
 800ffbe:	d1a0      	bne.n	800ff02 <USBH_Get_StringDesc+0xea>
            phost->Control.state = CTRL_STATUS_OUT;
 800ffc0:	2309      	movs	r3, #9
 800ffc2:	2001      	movs	r0, #1
 800ffc4:	7623      	strb	r3, [r4, #24]
 800ffc6:	e732      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
  if (psrc[1] == USB_DESC_TYPE_STRING)
 800ffc8:	f894 111d 	ldrb.w	r1, [r4, #285]	; 0x11d
        phost->RequestState = CMD_SEND;
 800ffcc:	2501      	movs	r5, #1
        phost->Control.state = CTRL_IDLE;
 800ffce:	2000      	movs	r0, #0
  if (psrc[1] == USB_DESC_TYPE_STRING)
 800ffd0:	2903      	cmp	r1, #3
        phost->RequestState = CMD_SEND;
 800ffd2:	70a5      	strb	r5, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 800ffd4:	7620      	strb	r0, [r4, #24]
  if (psrc[1] == USB_DESC_TYPE_STRING)
 800ffd6:	f47f af2a 	bne.w	800fe2e <USBH_Get_StringDesc+0x16>
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
 800ffda:	f894 111c 	ldrb.w	r1, [r4, #284]	; 0x11c
 800ffde:	3902      	subs	r1, #2
 800ffe0:	428b      	cmp	r3, r1
 800ffe2:	bf28      	it	cs
 800ffe4:	460b      	movcs	r3, r1
 800ffe6:	b299      	uxth	r1, r3
    for (idx = 0U; idx < strlength; idx += 2U)
 800ffe8:	b13b      	cbz	r3, 800fffa <USBH_Get_StringDesc+0x1e2>
      *pdest =  psrc[idx];
 800ffea:	1833      	adds	r3, r6, r0
    for (idx = 0U; idx < strlength; idx += 2U)
 800ffec:	3002      	adds	r0, #2
 800ffee:	b280      	uxth	r0, r0
      *pdest =  psrc[idx];
 800fff0:	789b      	ldrb	r3, [r3, #2]
    for (idx = 0U; idx < strlength; idx += 2U)
 800fff2:	4281      	cmp	r1, r0
      *pdest =  psrc[idx];
 800fff4:	f802 3b01 	strb.w	r3, [r2], #1
    for (idx = 0U; idx < strlength; idx += 2U)
 800fff8:	d8f7      	bhi.n	800ffea <USBH_Get_StringDesc+0x1d2>
    *pdest = 0U; /* mark end of string */
 800fffa:	2000      	movs	r0, #0
 800fffc:	7010      	strb	r0, [r2, #0]
}
 800fffe:	b005      	add	sp, #20
 8010000:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if (direction == USB_D2H)
 8010002:	2a00      	cmp	r2, #0
 8010004:	dbdc      	blt.n	800ffc0 <USBH_Get_StringDesc+0x1a8>
            phost->Control.state = CTRL_STATUS_IN;
 8010006:	2307      	movs	r3, #7
 8010008:	2001      	movs	r0, #1
 801000a:	7623      	strb	r3, [r4, #24]
 801000c:	e70f      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
        if (phost->Control.setup.b.wLength.w != 0U)
 801000e:	8ae3      	ldrh	r3, [r4, #22]
 8010010:	f994 2010 	ldrsb.w	r2, [r4, #16]
 8010014:	2b00      	cmp	r3, #0
 8010016:	d0f4      	beq.n	8010002 <USBH_Get_StringDesc+0x1ea>
          if (direction == USB_D2H)
 8010018:	2a00      	cmp	r2, #0
 801001a:	db08      	blt.n	801002e <USBH_Get_StringDesc+0x216>
            phost->Control.state = CTRL_DATA_OUT;
 801001c:	2305      	movs	r3, #5
 801001e:	2001      	movs	r0, #1
 8010020:	7623      	strb	r3, [r4, #24]
 8010022:	e704      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
        phost->Control.state = CTRL_SETUP;
 8010024:	2301      	movs	r3, #1
 8010026:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 8010028:	4618      	mov	r0, r3
 801002a:	70a3      	strb	r3, [r4, #2]
 801002c:	e6ff      	b.n	800fe2e <USBH_Get_StringDesc+0x16>
            phost->Control.state = CTRL_DATA_IN;
 801002e:	2303      	movs	r3, #3
 8010030:	7623      	strb	r3, [r4, #24]
 8010032:	e6fc      	b.n	800fe2e <USBH_Get_StringDesc+0x16>

08010034 <USBH_SetAddress>:
{
 8010034:	b530      	push	{r4, r5, lr}
 8010036:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
 8010038:	7880      	ldrb	r0, [r0, #2]
{
 801003a:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
 801003c:	2801      	cmp	r0, #1
 801003e:	d011      	beq.n	8010064 <USBH_SetAddress+0x30>
  switch (phost->RequestState)
 8010040:	2802      	cmp	r0, #2
 8010042:	d002      	beq.n	801004a <USBH_SetAddress+0x16>
  status = USBH_BUSY;
 8010044:	2001      	movs	r0, #1
}
 8010046:	b003      	add	sp, #12
 8010048:	bd30      	pop	{r4, r5, pc}
 801004a:	461c      	mov	r4, r3
  switch (phost->Control.state)
 801004c:	7e1b      	ldrb	r3, [r3, #24]
 801004e:	3b01      	subs	r3, #1
 8010050:	2b0a      	cmp	r3, #10
 8010052:	d8f7      	bhi.n	8010044 <USBH_SetAddress+0x10>
 8010054:	e8df f003 	tbb	[pc, r3]
 8010058:	5447382e 	.word	0x5447382e
 801005c:	8b7e6e5f 	.word	0x8b7e6e5f
 8010060:	ac9d      	.short	0xac9d
 8010062:	13          	.byte	0x13
 8010063:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
 8010064:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 8010066:	f44f 65a0 	mov.w	r5, #1280	; 0x500
      phost->RequestState = CMD_WAIT;
 801006a:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 801006c:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
 801006e:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 8010070:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
 8010072:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
 8010074:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 8010076:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
 8010078:	709c      	strb	r4, [r3, #2]
}
 801007a:	b003      	add	sp, #12
 801007c:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 801007e:	7e63      	ldrb	r3, [r4, #25]
 8010080:	3301      	adds	r3, #1
 8010082:	b2db      	uxtb	r3, r3
 8010084:	2b02      	cmp	r3, #2
 8010086:	7663      	strb	r3, [r4, #25]
 8010088:	f240 80b1 	bls.w	80101ee <USBH_SetAddress+0x1ba>
        phost->Control.errorcount = 0U;
 801008c:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 801008e:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 8010092:	2106      	movs	r1, #6
 8010094:	4620      	mov	r0, r4
 8010096:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8010098:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 801009a:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 801009c:	4620      	mov	r0, r4
 801009e:	f000 fc0d 	bl	80108bc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 80100a2:	7921      	ldrb	r1, [r4, #4]
 80100a4:	4620      	mov	r0, r4
 80100a6:	f000 fc09 	bl	80108bc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 80100aa:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 80100ac:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 80100ae:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 80100b0:	70a3      	strb	r3, [r4, #2]
 80100b2:	e7c8      	b.n	8010046 <USBH_SetAddress+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 80100b4:	7962      	ldrb	r2, [r4, #5]
 80100b6:	f104 0110 	add.w	r1, r4, #16
 80100ba:	4620      	mov	r0, r4
 80100bc:	f000 fb52 	bl	8010764 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 80100c0:	2302      	movs	r3, #2
 80100c2:	2001      	movs	r0, #1
 80100c4:	7623      	strb	r3, [r4, #24]
 80100c6:	e7be      	b.n	8010046 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80100c8:	7961      	ldrb	r1, [r4, #5]
 80100ca:	4620      	mov	r0, r4
 80100cc:	f00e f8f4 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80100d0:	2801      	cmp	r0, #1
 80100d2:	f000 8081 	beq.w	80101d8 <USBH_SetAddress+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 80100d6:	2804      	cmp	r0, #4
 80100d8:	d001      	beq.n	80100de <USBH_SetAddress+0xaa>
 80100da:	2802      	cmp	r0, #2
 80100dc:	d1b2      	bne.n	8010044 <USBH_SetAddress+0x10>
          phost->Control.state = CTRL_ERROR;
 80100de:	230b      	movs	r3, #11
 80100e0:	2001      	movs	r0, #1
 80100e2:	7623      	strb	r3, [r4, #24]
 80100e4:	e7af      	b.n	8010046 <USBH_SetAddress+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
 80100e6:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 80100ea:	4620      	mov	r0, r4
 80100ec:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 80100ee:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 80100f0:	68a1      	ldr	r1, [r4, #8]
 80100f2:	89a2      	ldrh	r2, [r4, #12]
 80100f4:	f000 fb5e 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 80100f8:	2304      	movs	r3, #4
 80100fa:	2001      	movs	r0, #1
 80100fc:	7623      	strb	r3, [r4, #24]
 80100fe:	e7a2      	b.n	8010046 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8010100:	7921      	ldrb	r1, [r4, #4]
 8010102:	4620      	mov	r0, r4
 8010104:	f00e f8d8 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8010108:	2801      	cmp	r0, #1
 801010a:	d059      	beq.n	80101c0 <USBH_SetAddress+0x18c>
      if (URB_Status == USBH_URB_STALL)
 801010c:	2805      	cmp	r0, #5
 801010e:	d039      	beq.n	8010184 <USBH_SetAddress+0x150>
        if (URB_Status == USBH_URB_ERROR)
 8010110:	2804      	cmp	r0, #4
 8010112:	d197      	bne.n	8010044 <USBH_SetAddress+0x10>
 8010114:	e7e3      	b.n	80100de <USBH_SetAddress+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 8010116:	2501      	movs	r5, #1
 8010118:	7963      	ldrb	r3, [r4, #5]
 801011a:	89a2      	ldrh	r2, [r4, #12]
 801011c:	4620      	mov	r0, r4
 801011e:	68a1      	ldr	r1, [r4, #8]
 8010120:	9500      	str	r5, [sp, #0]
 8010122:	f000 fb2f 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8010126:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 801012a:	2306      	movs	r3, #6
 801012c:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 801012e:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8010130:	7623      	strb	r3, [r4, #24]
 8010132:	e788      	b.n	8010046 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8010134:	7961      	ldrb	r1, [r4, #5]
 8010136:	4620      	mov	r0, r4
 8010138:	f00e f8be 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 801013c:	2801      	cmp	r0, #1
 801013e:	d047      	beq.n	80101d0 <USBH_SetAddress+0x19c>
      else if (URB_Status == USBH_URB_STALL)
 8010140:	2805      	cmp	r0, #5
 8010142:	d01f      	beq.n	8010184 <USBH_SetAddress+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
 8010144:	2802      	cmp	r0, #2
 8010146:	d04e      	beq.n	80101e6 <USBH_SetAddress+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
 8010148:	2804      	cmp	r0, #4
 801014a:	f47f af7b 	bne.w	8010044 <USBH_SetAddress+0x10>
          phost->Control.state = CTRL_ERROR;
 801014e:	230b      	movs	r3, #11
 8010150:	7623      	strb	r3, [r4, #24]
 8010152:	e7ab      	b.n	80100ac <USBH_SetAddress+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 8010154:	2200      	movs	r2, #0
 8010156:	7923      	ldrb	r3, [r4, #4]
 8010158:	4620      	mov	r0, r4
 801015a:	4611      	mov	r1, r2
 801015c:	f000 fb2a 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8010160:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8010164:	2308      	movs	r3, #8
 8010166:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 8010168:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 801016a:	7623      	strb	r3, [r4, #24]
 801016c:	e76b      	b.n	8010046 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 801016e:	7921      	ldrb	r1, [r4, #4]
 8010170:	4620      	mov	r0, r4
 8010172:	f00e f8a1 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8010176:	2801      	cmp	r0, #1
 8010178:	d026      	beq.n	80101c8 <USBH_SetAddress+0x194>
      else if (URB_Status == USBH_URB_ERROR)
 801017a:	2804      	cmp	r0, #4
 801017c:	d0af      	beq.n	80100de <USBH_SetAddress+0xaa>
        if (URB_Status == USBH_URB_STALL)
 801017e:	2805      	cmp	r0, #5
 8010180:	f47f af60 	bne.w	8010044 <USBH_SetAddress+0x10>
        status = USBH_NOT_SUPPORTED;
 8010184:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 8010186:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8010188:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 801018a:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 801018c:	7623      	strb	r3, [r4, #24]
}
 801018e:	b003      	add	sp, #12
 8010190:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 8010192:	2200      	movs	r2, #0
 8010194:	2501      	movs	r5, #1
 8010196:	7963      	ldrb	r3, [r4, #5]
 8010198:	4620      	mov	r0, r4
 801019a:	4611      	mov	r1, r2
 801019c:	9500      	str	r5, [sp, #0]
 801019e:	f000 faf1 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80101a2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 80101a6:	230a      	movs	r3, #10
 80101a8:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 80101aa:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 80101ac:	7623      	strb	r3, [r4, #24]
 80101ae:	e74a      	b.n	8010046 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80101b0:	7961      	ldrb	r1, [r4, #5]
 80101b2:	4620      	mov	r0, r4
 80101b4:	f00e f880 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80101b8:	2801      	cmp	r0, #1
 80101ba:	d005      	beq.n	80101c8 <USBH_SetAddress+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
 80101bc:	2802      	cmp	r0, #2
 80101be:	d1a7      	bne.n	8010110 <USBH_SetAddress+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
 80101c0:	2309      	movs	r3, #9
 80101c2:	2001      	movs	r0, #1
 80101c4:	7623      	strb	r3, [r4, #24]
 80101c6:	e73e      	b.n	8010046 <USBH_SetAddress+0x12>
        status = USBH_OK;
 80101c8:	2000      	movs	r0, #0
 80101ca:	e7dc      	b.n	8010186 <USBH_SetAddress+0x152>
          if (direction == USB_D2H)
 80101cc:	2a00      	cmp	r2, #0
 80101ce:	dbf7      	blt.n	80101c0 <USBH_SetAddress+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
 80101d0:	2307      	movs	r3, #7
 80101d2:	2001      	movs	r0, #1
 80101d4:	7623      	strb	r3, [r4, #24]
 80101d6:	e736      	b.n	8010046 <USBH_SetAddress+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
 80101d8:	8ae3      	ldrh	r3, [r4, #22]
 80101da:	f994 2010 	ldrsb.w	r2, [r4, #16]
 80101de:	2b00      	cmp	r3, #0
 80101e0:	d0f4      	beq.n	80101cc <USBH_SetAddress+0x198>
          if (direction == USB_D2H)
 80101e2:	2a00      	cmp	r2, #0
 80101e4:	db08      	blt.n	80101f8 <USBH_SetAddress+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
 80101e6:	2305      	movs	r3, #5
 80101e8:	2001      	movs	r0, #1
 80101ea:	7623      	strb	r3, [r4, #24]
 80101ec:	e72b      	b.n	8010046 <USBH_SetAddress+0x12>
        phost->Control.state = CTRL_SETUP;
 80101ee:	2301      	movs	r3, #1
 80101f0:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 80101f2:	4618      	mov	r0, r3
 80101f4:	70a3      	strb	r3, [r4, #2]
 80101f6:	e726      	b.n	8010046 <USBH_SetAddress+0x12>
            phost->Control.state = CTRL_DATA_IN;
 80101f8:	2303      	movs	r3, #3
 80101fa:	7623      	strb	r3, [r4, #24]
 80101fc:	e723      	b.n	8010046 <USBH_SetAddress+0x12>
 80101fe:	bf00      	nop

08010200 <USBH_SetCfg>:
{
 8010200:	b530      	push	{r4, r5, lr}
 8010202:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
 8010204:	7880      	ldrb	r0, [r0, #2]
{
 8010206:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
 8010208:	2801      	cmp	r0, #1
 801020a:	d011      	beq.n	8010230 <USBH_SetCfg+0x30>
  switch (phost->RequestState)
 801020c:	2802      	cmp	r0, #2
 801020e:	d002      	beq.n	8010216 <USBH_SetCfg+0x16>
  status = USBH_BUSY;
 8010210:	2001      	movs	r0, #1
}
 8010212:	b003      	add	sp, #12
 8010214:	bd30      	pop	{r4, r5, pc}
 8010216:	461c      	mov	r4, r3
  switch (phost->Control.state)
 8010218:	7e1b      	ldrb	r3, [r3, #24]
 801021a:	3b01      	subs	r3, #1
 801021c:	2b0a      	cmp	r3, #10
 801021e:	d8f7      	bhi.n	8010210 <USBH_SetCfg+0x10>
 8010220:	e8df f003 	tbb	[pc, r3]
 8010224:	5447382e 	.word	0x5447382e
 8010228:	8b7e6e5f 	.word	0x8b7e6e5f
 801022c:	ac9d      	.short	0xac9d
 801022e:	13          	.byte	0x13
 801022f:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
 8010230:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8010232:	f44f 6510 	mov.w	r5, #2304	; 0x900
      phost->RequestState = CMD_WAIT;
 8010236:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = cfg_idx;
 8010238:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
 801023a:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 801023c:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
 801023e:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
 8010240:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 8010242:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
 8010244:	709c      	strb	r4, [r3, #2]
}
 8010246:	b003      	add	sp, #12
 8010248:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 801024a:	7e63      	ldrb	r3, [r4, #25]
 801024c:	3301      	adds	r3, #1
 801024e:	b2db      	uxtb	r3, r3
 8010250:	2b02      	cmp	r3, #2
 8010252:	7663      	strb	r3, [r4, #25]
 8010254:	f240 80b1 	bls.w	80103ba <USBH_SetCfg+0x1ba>
        phost->Control.errorcount = 0U;
 8010258:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 801025a:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 801025e:	2106      	movs	r1, #6
 8010260:	4620      	mov	r0, r4
 8010262:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8010264:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 8010266:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8010268:	4620      	mov	r0, r4
 801026a:	f000 fb27 	bl	80108bc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 801026e:	7921      	ldrb	r1, [r4, #4]
 8010270:	4620      	mov	r0, r4
 8010272:	f000 fb23 	bl	80108bc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 8010276:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 8010278:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 801027a:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 801027c:	70a3      	strb	r3, [r4, #2]
 801027e:	e7c8      	b.n	8010212 <USBH_SetCfg+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8010280:	7962      	ldrb	r2, [r4, #5]
 8010282:	f104 0110 	add.w	r1, r4, #16
 8010286:	4620      	mov	r0, r4
 8010288:	f000 fa6c 	bl	8010764 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 801028c:	2302      	movs	r3, #2
 801028e:	2001      	movs	r0, #1
 8010290:	7623      	strb	r3, [r4, #24]
 8010292:	e7be      	b.n	8010212 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8010294:	7961      	ldrb	r1, [r4, #5]
 8010296:	4620      	mov	r0, r4
 8010298:	f00e f80e 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 801029c:	2801      	cmp	r0, #1
 801029e:	f000 8081 	beq.w	80103a4 <USBH_SetCfg+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 80102a2:	2804      	cmp	r0, #4
 80102a4:	d001      	beq.n	80102aa <USBH_SetCfg+0xaa>
 80102a6:	2802      	cmp	r0, #2
 80102a8:	d1b2      	bne.n	8010210 <USBH_SetCfg+0x10>
          phost->Control.state = CTRL_ERROR;
 80102aa:	230b      	movs	r3, #11
 80102ac:	2001      	movs	r0, #1
 80102ae:	7623      	strb	r3, [r4, #24]
 80102b0:	e7af      	b.n	8010212 <USBH_SetCfg+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
 80102b2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 80102b6:	4620      	mov	r0, r4
 80102b8:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 80102ba:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 80102bc:	68a1      	ldr	r1, [r4, #8]
 80102be:	89a2      	ldrh	r2, [r4, #12]
 80102c0:	f000 fa78 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 80102c4:	2304      	movs	r3, #4
 80102c6:	2001      	movs	r0, #1
 80102c8:	7623      	strb	r3, [r4, #24]
 80102ca:	e7a2      	b.n	8010212 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 80102cc:	7921      	ldrb	r1, [r4, #4]
 80102ce:	4620      	mov	r0, r4
 80102d0:	f00d fff2 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80102d4:	2801      	cmp	r0, #1
 80102d6:	d059      	beq.n	801038c <USBH_SetCfg+0x18c>
      if (URB_Status == USBH_URB_STALL)
 80102d8:	2805      	cmp	r0, #5
 80102da:	d039      	beq.n	8010350 <USBH_SetCfg+0x150>
        if (URB_Status == USBH_URB_ERROR)
 80102dc:	2804      	cmp	r0, #4
 80102de:	d197      	bne.n	8010210 <USBH_SetCfg+0x10>
 80102e0:	e7e3      	b.n	80102aa <USBH_SetCfg+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 80102e2:	2501      	movs	r5, #1
 80102e4:	7963      	ldrb	r3, [r4, #5]
 80102e6:	89a2      	ldrh	r2, [r4, #12]
 80102e8:	4620      	mov	r0, r4
 80102ea:	68a1      	ldr	r1, [r4, #8]
 80102ec:	9500      	str	r5, [sp, #0]
 80102ee:	f000 fa49 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80102f2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 80102f6:	2306      	movs	r3, #6
 80102f8:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 80102fa:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 80102fc:	7623      	strb	r3, [r4, #24]
 80102fe:	e788      	b.n	8010212 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8010300:	7961      	ldrb	r1, [r4, #5]
 8010302:	4620      	mov	r0, r4
 8010304:	f00d ffd8 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8010308:	2801      	cmp	r0, #1
 801030a:	d047      	beq.n	801039c <USBH_SetCfg+0x19c>
      else if (URB_Status == USBH_URB_STALL)
 801030c:	2805      	cmp	r0, #5
 801030e:	d01f      	beq.n	8010350 <USBH_SetCfg+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
 8010310:	2802      	cmp	r0, #2
 8010312:	d04e      	beq.n	80103b2 <USBH_SetCfg+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
 8010314:	2804      	cmp	r0, #4
 8010316:	f47f af7b 	bne.w	8010210 <USBH_SetCfg+0x10>
          phost->Control.state = CTRL_ERROR;
 801031a:	230b      	movs	r3, #11
 801031c:	7623      	strb	r3, [r4, #24]
 801031e:	e7ab      	b.n	8010278 <USBH_SetCfg+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 8010320:	2200      	movs	r2, #0
 8010322:	7923      	ldrb	r3, [r4, #4]
 8010324:	4620      	mov	r0, r4
 8010326:	4611      	mov	r1, r2
 8010328:	f000 fa44 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 801032c:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8010330:	2308      	movs	r3, #8
 8010332:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 8010334:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8010336:	7623      	strb	r3, [r4, #24]
 8010338:	e76b      	b.n	8010212 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 801033a:	7921      	ldrb	r1, [r4, #4]
 801033c:	4620      	mov	r0, r4
 801033e:	f00d ffbb 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8010342:	2801      	cmp	r0, #1
 8010344:	d026      	beq.n	8010394 <USBH_SetCfg+0x194>
      else if (URB_Status == USBH_URB_ERROR)
 8010346:	2804      	cmp	r0, #4
 8010348:	d0af      	beq.n	80102aa <USBH_SetCfg+0xaa>
        if (URB_Status == USBH_URB_STALL)
 801034a:	2805      	cmp	r0, #5
 801034c:	f47f af60 	bne.w	8010210 <USBH_SetCfg+0x10>
        status = USBH_NOT_SUPPORTED;
 8010350:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 8010352:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8010354:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 8010356:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8010358:	7623      	strb	r3, [r4, #24]
}
 801035a:	b003      	add	sp, #12
 801035c:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 801035e:	2200      	movs	r2, #0
 8010360:	2501      	movs	r5, #1
 8010362:	7963      	ldrb	r3, [r4, #5]
 8010364:	4620      	mov	r0, r4
 8010366:	4611      	mov	r1, r2
 8010368:	9500      	str	r5, [sp, #0]
 801036a:	f000 fa0b 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 801036e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8010372:	230a      	movs	r3, #10
 8010374:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 8010376:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8010378:	7623      	strb	r3, [r4, #24]
 801037a:	e74a      	b.n	8010212 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 801037c:	7961      	ldrb	r1, [r4, #5]
 801037e:	4620      	mov	r0, r4
 8010380:	f00d ff9a 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8010384:	2801      	cmp	r0, #1
 8010386:	d005      	beq.n	8010394 <USBH_SetCfg+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
 8010388:	2802      	cmp	r0, #2
 801038a:	d1a7      	bne.n	80102dc <USBH_SetCfg+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
 801038c:	2309      	movs	r3, #9
 801038e:	2001      	movs	r0, #1
 8010390:	7623      	strb	r3, [r4, #24]
 8010392:	e73e      	b.n	8010212 <USBH_SetCfg+0x12>
        status = USBH_OK;
 8010394:	2000      	movs	r0, #0
 8010396:	e7dc      	b.n	8010352 <USBH_SetCfg+0x152>
          if (direction == USB_D2H)
 8010398:	2a00      	cmp	r2, #0
 801039a:	dbf7      	blt.n	801038c <USBH_SetCfg+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
 801039c:	2307      	movs	r3, #7
 801039e:	2001      	movs	r0, #1
 80103a0:	7623      	strb	r3, [r4, #24]
 80103a2:	e736      	b.n	8010212 <USBH_SetCfg+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
 80103a4:	8ae3      	ldrh	r3, [r4, #22]
 80103a6:	f994 2010 	ldrsb.w	r2, [r4, #16]
 80103aa:	2b00      	cmp	r3, #0
 80103ac:	d0f4      	beq.n	8010398 <USBH_SetCfg+0x198>
          if (direction == USB_D2H)
 80103ae:	2a00      	cmp	r2, #0
 80103b0:	db08      	blt.n	80103c4 <USBH_SetCfg+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
 80103b2:	2305      	movs	r3, #5
 80103b4:	2001      	movs	r0, #1
 80103b6:	7623      	strb	r3, [r4, #24]
 80103b8:	e72b      	b.n	8010212 <USBH_SetCfg+0x12>
        phost->Control.state = CTRL_SETUP;
 80103ba:	2301      	movs	r3, #1
 80103bc:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 80103be:	4618      	mov	r0, r3
 80103c0:	70a3      	strb	r3, [r4, #2]
 80103c2:	e726      	b.n	8010212 <USBH_SetCfg+0x12>
            phost->Control.state = CTRL_DATA_IN;
 80103c4:	2303      	movs	r3, #3
 80103c6:	7623      	strb	r3, [r4, #24]
 80103c8:	e723      	b.n	8010212 <USBH_SetCfg+0x12>
 80103ca:	bf00      	nop

080103cc <USBH_SetFeature>:
{
 80103cc:	b530      	push	{r4, r5, lr}
 80103ce:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
 80103d0:	7880      	ldrb	r0, [r0, #2]
{
 80103d2:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
 80103d4:	2801      	cmp	r0, #1
 80103d6:	d011      	beq.n	80103fc <USBH_SetFeature+0x30>
  switch (phost->RequestState)
 80103d8:	2802      	cmp	r0, #2
 80103da:	d002      	beq.n	80103e2 <USBH_SetFeature+0x16>
  status = USBH_BUSY;
 80103dc:	2001      	movs	r0, #1
}
 80103de:	b003      	add	sp, #12
 80103e0:	bd30      	pop	{r4, r5, pc}
 80103e2:	461c      	mov	r4, r3
  switch (phost->Control.state)
 80103e4:	7e1b      	ldrb	r3, [r3, #24]
 80103e6:	3b01      	subs	r3, #1
 80103e8:	2b0a      	cmp	r3, #10
 80103ea:	d8f7      	bhi.n	80103dc <USBH_SetFeature+0x10>
 80103ec:	e8df f003 	tbb	[pc, r3]
 80103f0:	5447382e 	.word	0x5447382e
 80103f4:	8b7e6e5f 	.word	0x8b7e6e5f
 80103f8:	ac9d      	.short	0xac9d
 80103fa:	13          	.byte	0x13
 80103fb:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
 80103fc:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 80103fe:	f44f 7540 	mov.w	r5, #768	; 0x300
      phost->RequestState = CMD_WAIT;
 8010402:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = wValue;
 8010404:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
 8010406:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8010408:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
 801040a:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
 801040c:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 801040e:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
 8010410:	709c      	strb	r4, [r3, #2]
}
 8010412:	b003      	add	sp, #12
 8010414:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 8010416:	7e63      	ldrb	r3, [r4, #25]
 8010418:	3301      	adds	r3, #1
 801041a:	b2db      	uxtb	r3, r3
 801041c:	2b02      	cmp	r3, #2
 801041e:	7663      	strb	r3, [r4, #25]
 8010420:	f240 80b1 	bls.w	8010586 <USBH_SetFeature+0x1ba>
        phost->Control.errorcount = 0U;
 8010424:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 8010426:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 801042a:	2106      	movs	r1, #6
 801042c:	4620      	mov	r0, r4
 801042e:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8010430:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 8010432:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8010434:	4620      	mov	r0, r4
 8010436:	f000 fa41 	bl	80108bc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 801043a:	7921      	ldrb	r1, [r4, #4]
 801043c:	4620      	mov	r0, r4
 801043e:	f000 fa3d 	bl	80108bc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 8010442:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 8010444:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 8010446:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 8010448:	70a3      	strb	r3, [r4, #2]
 801044a:	e7c8      	b.n	80103de <USBH_SetFeature+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 801044c:	7962      	ldrb	r2, [r4, #5]
 801044e:	f104 0110 	add.w	r1, r4, #16
 8010452:	4620      	mov	r0, r4
 8010454:	f000 f986 	bl	8010764 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 8010458:	2302      	movs	r3, #2
 801045a:	2001      	movs	r0, #1
 801045c:	7623      	strb	r3, [r4, #24]
 801045e:	e7be      	b.n	80103de <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8010460:	7961      	ldrb	r1, [r4, #5]
 8010462:	4620      	mov	r0, r4
 8010464:	f00d ff28 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8010468:	2801      	cmp	r0, #1
 801046a:	f000 8081 	beq.w	8010570 <USBH_SetFeature+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 801046e:	2804      	cmp	r0, #4
 8010470:	d001      	beq.n	8010476 <USBH_SetFeature+0xaa>
 8010472:	2802      	cmp	r0, #2
 8010474:	d1b2      	bne.n	80103dc <USBH_SetFeature+0x10>
          phost->Control.state = CTRL_ERROR;
 8010476:	230b      	movs	r3, #11
 8010478:	2001      	movs	r0, #1
 801047a:	7623      	strb	r3, [r4, #24]
 801047c:	e7af      	b.n	80103de <USBH_SetFeature+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
 801047e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8010482:	4620      	mov	r0, r4
 8010484:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 8010486:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8010488:	68a1      	ldr	r1, [r4, #8]
 801048a:	89a2      	ldrh	r2, [r4, #12]
 801048c:	f000 f992 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 8010490:	2304      	movs	r3, #4
 8010492:	2001      	movs	r0, #1
 8010494:	7623      	strb	r3, [r4, #24]
 8010496:	e7a2      	b.n	80103de <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8010498:	7921      	ldrb	r1, [r4, #4]
 801049a:	4620      	mov	r0, r4
 801049c:	f00d ff0c 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80104a0:	2801      	cmp	r0, #1
 80104a2:	d059      	beq.n	8010558 <USBH_SetFeature+0x18c>
      if (URB_Status == USBH_URB_STALL)
 80104a4:	2805      	cmp	r0, #5
 80104a6:	d039      	beq.n	801051c <USBH_SetFeature+0x150>
        if (URB_Status == USBH_URB_ERROR)
 80104a8:	2804      	cmp	r0, #4
 80104aa:	d197      	bne.n	80103dc <USBH_SetFeature+0x10>
 80104ac:	e7e3      	b.n	8010476 <USBH_SetFeature+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 80104ae:	2501      	movs	r5, #1
 80104b0:	7963      	ldrb	r3, [r4, #5]
 80104b2:	89a2      	ldrh	r2, [r4, #12]
 80104b4:	4620      	mov	r0, r4
 80104b6:	68a1      	ldr	r1, [r4, #8]
 80104b8:	9500      	str	r5, [sp, #0]
 80104ba:	f000 f963 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80104be:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 80104c2:	2306      	movs	r3, #6
 80104c4:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 80104c6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 80104c8:	7623      	strb	r3, [r4, #24]
 80104ca:	e788      	b.n	80103de <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80104cc:	7961      	ldrb	r1, [r4, #5]
 80104ce:	4620      	mov	r0, r4
 80104d0:	f00d fef2 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80104d4:	2801      	cmp	r0, #1
 80104d6:	d047      	beq.n	8010568 <USBH_SetFeature+0x19c>
      else if (URB_Status == USBH_URB_STALL)
 80104d8:	2805      	cmp	r0, #5
 80104da:	d01f      	beq.n	801051c <USBH_SetFeature+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
 80104dc:	2802      	cmp	r0, #2
 80104de:	d04e      	beq.n	801057e <USBH_SetFeature+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
 80104e0:	2804      	cmp	r0, #4
 80104e2:	f47f af7b 	bne.w	80103dc <USBH_SetFeature+0x10>
          phost->Control.state = CTRL_ERROR;
 80104e6:	230b      	movs	r3, #11
 80104e8:	7623      	strb	r3, [r4, #24]
 80104ea:	e7ab      	b.n	8010444 <USBH_SetFeature+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 80104ec:	2200      	movs	r2, #0
 80104ee:	7923      	ldrb	r3, [r4, #4]
 80104f0:	4620      	mov	r0, r4
 80104f2:	4611      	mov	r1, r2
 80104f4:	f000 f95e 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80104f8:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 80104fc:	2308      	movs	r3, #8
 80104fe:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 8010500:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8010502:	7623      	strb	r3, [r4, #24]
 8010504:	e76b      	b.n	80103de <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8010506:	7921      	ldrb	r1, [r4, #4]
 8010508:	4620      	mov	r0, r4
 801050a:	f00d fed5 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 801050e:	2801      	cmp	r0, #1
 8010510:	d026      	beq.n	8010560 <USBH_SetFeature+0x194>
      else if (URB_Status == USBH_URB_ERROR)
 8010512:	2804      	cmp	r0, #4
 8010514:	d0af      	beq.n	8010476 <USBH_SetFeature+0xaa>
        if (URB_Status == USBH_URB_STALL)
 8010516:	2805      	cmp	r0, #5
 8010518:	f47f af60 	bne.w	80103dc <USBH_SetFeature+0x10>
        status = USBH_NOT_SUPPORTED;
 801051c:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 801051e:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8010520:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 8010522:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8010524:	7623      	strb	r3, [r4, #24]
}
 8010526:	b003      	add	sp, #12
 8010528:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 801052a:	2200      	movs	r2, #0
 801052c:	2501      	movs	r5, #1
 801052e:	7963      	ldrb	r3, [r4, #5]
 8010530:	4620      	mov	r0, r4
 8010532:	4611      	mov	r1, r2
 8010534:	9500      	str	r5, [sp, #0]
 8010536:	f000 f925 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 801053a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 801053e:	230a      	movs	r3, #10
 8010540:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 8010542:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8010544:	7623      	strb	r3, [r4, #24]
 8010546:	e74a      	b.n	80103de <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8010548:	7961      	ldrb	r1, [r4, #5]
 801054a:	4620      	mov	r0, r4
 801054c:	f00d feb4 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8010550:	2801      	cmp	r0, #1
 8010552:	d005      	beq.n	8010560 <USBH_SetFeature+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
 8010554:	2802      	cmp	r0, #2
 8010556:	d1a7      	bne.n	80104a8 <USBH_SetFeature+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
 8010558:	2309      	movs	r3, #9
 801055a:	2001      	movs	r0, #1
 801055c:	7623      	strb	r3, [r4, #24]
 801055e:	e73e      	b.n	80103de <USBH_SetFeature+0x12>
        status = USBH_OK;
 8010560:	2000      	movs	r0, #0
 8010562:	e7dc      	b.n	801051e <USBH_SetFeature+0x152>
          if (direction == USB_D2H)
 8010564:	2a00      	cmp	r2, #0
 8010566:	dbf7      	blt.n	8010558 <USBH_SetFeature+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
 8010568:	2307      	movs	r3, #7
 801056a:	2001      	movs	r0, #1
 801056c:	7623      	strb	r3, [r4, #24]
 801056e:	e736      	b.n	80103de <USBH_SetFeature+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
 8010570:	8ae3      	ldrh	r3, [r4, #22]
 8010572:	f994 2010 	ldrsb.w	r2, [r4, #16]
 8010576:	2b00      	cmp	r3, #0
 8010578:	d0f4      	beq.n	8010564 <USBH_SetFeature+0x198>
          if (direction == USB_D2H)
 801057a:	2a00      	cmp	r2, #0
 801057c:	db08      	blt.n	8010590 <USBH_SetFeature+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
 801057e:	2305      	movs	r3, #5
 8010580:	2001      	movs	r0, #1
 8010582:	7623      	strb	r3, [r4, #24]
 8010584:	e72b      	b.n	80103de <USBH_SetFeature+0x12>
        phost->Control.state = CTRL_SETUP;
 8010586:	2301      	movs	r3, #1
 8010588:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 801058a:	4618      	mov	r0, r3
 801058c:	70a3      	strb	r3, [r4, #2]
 801058e:	e726      	b.n	80103de <USBH_SetFeature+0x12>
            phost->Control.state = CTRL_DATA_IN;
 8010590:	2303      	movs	r3, #3
 8010592:	7623      	strb	r3, [r4, #24]
 8010594:	e723      	b.n	80103de <USBH_SetFeature+0x12>
 8010596:	bf00      	nop

08010598 <USBH_ClrFeature>:
{
 8010598:	b530      	push	{r4, r5, lr}
 801059a:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
 801059c:	7880      	ldrb	r0, [r0, #2]
{
 801059e:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
 80105a0:	2801      	cmp	r0, #1
 80105a2:	d011      	beq.n	80105c8 <USBH_ClrFeature+0x30>
  switch (phost->RequestState)
 80105a4:	2802      	cmp	r0, #2
 80105a6:	d002      	beq.n	80105ae <USBH_ClrFeature+0x16>
  status = USBH_BUSY;
 80105a8:	2001      	movs	r0, #1
}
 80105aa:	b003      	add	sp, #12
 80105ac:	bd30      	pop	{r4, r5, pc}
 80105ae:	461c      	mov	r4, r3
  switch (phost->Control.state)
 80105b0:	7e1b      	ldrb	r3, [r3, #24]
 80105b2:	3b01      	subs	r3, #1
 80105b4:	2b0a      	cmp	r3, #10
 80105b6:	d8f7      	bhi.n	80105a8 <USBH_ClrFeature+0x10>
 80105b8:	e8df f003 	tbb	[pc, r3]
 80105bc:	5447382e 	.word	0x5447382e
 80105c0:	8b7e6e5f 	.word	0x8b7e6e5f
 80105c4:	ac9d      	.short	0xac9d
 80105c6:	13          	.byte	0x13
 80105c7:	00          	.byte	0x00
    phost->Control.setup.b.wLength.w = 0U;
 80105c8:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
 80105ca:	f44f 7581 	mov.w	r5, #258	; 0x102
      phost->RequestState = CMD_WAIT;
 80105ce:	2402      	movs	r4, #2
    phost->Control.setup.b.wIndex.w = ep_num;
 80105d0:	8299      	strh	r1, [r3, #20]
      phost->Control.state = CTRL_SETUP;
 80105d2:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
 80105d4:	611d      	str	r5, [r3, #16]
    phost->Control.setup.b.wLength.w = 0U;
 80105d6:	82da      	strh	r2, [r3, #22]
      phost->Control.buff = buff;
 80105d8:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 80105da:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
 80105dc:	709c      	strb	r4, [r3, #2]
}
 80105de:	b003      	add	sp, #12
 80105e0:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 80105e2:	7e63      	ldrb	r3, [r4, #25]
 80105e4:	3301      	adds	r3, #1
 80105e6:	b2db      	uxtb	r3, r3
 80105e8:	2b02      	cmp	r3, #2
 80105ea:	7663      	strb	r3, [r4, #25]
 80105ec:	f240 80b1 	bls.w	8010752 <USBH_ClrFeature+0x1ba>
        phost->Control.errorcount = 0U;
 80105f0:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 80105f2:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 80105f6:	2106      	movs	r1, #6
 80105f8:	4620      	mov	r0, r4
 80105fa:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 80105fc:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 80105fe:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8010600:	4620      	mov	r0, r4
 8010602:	f000 f95b 	bl	80108bc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 8010606:	7921      	ldrb	r1, [r4, #4]
 8010608:	4620      	mov	r0, r4
 801060a:	f000 f957 	bl	80108bc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 801060e:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 8010610:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 8010612:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 8010614:	70a3      	strb	r3, [r4, #2]
 8010616:	e7c8      	b.n	80105aa <USBH_ClrFeature+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8010618:	7962      	ldrb	r2, [r4, #5]
 801061a:	f104 0110 	add.w	r1, r4, #16
 801061e:	4620      	mov	r0, r4
 8010620:	f000 f8a0 	bl	8010764 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 8010624:	2302      	movs	r3, #2
 8010626:	2001      	movs	r0, #1
 8010628:	7623      	strb	r3, [r4, #24]
 801062a:	e7be      	b.n	80105aa <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 801062c:	7961      	ldrb	r1, [r4, #5]
 801062e:	4620      	mov	r0, r4
 8010630:	f00d fe42 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8010634:	2801      	cmp	r0, #1
 8010636:	f000 8081 	beq.w	801073c <USBH_ClrFeature+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 801063a:	2804      	cmp	r0, #4
 801063c:	d001      	beq.n	8010642 <USBH_ClrFeature+0xaa>
 801063e:	2802      	cmp	r0, #2
 8010640:	d1b2      	bne.n	80105a8 <USBH_ClrFeature+0x10>
          phost->Control.state = CTRL_ERROR;
 8010642:	230b      	movs	r3, #11
 8010644:	2001      	movs	r0, #1
 8010646:	7623      	strb	r3, [r4, #24]
 8010648:	e7af      	b.n	80105aa <USBH_ClrFeature+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
 801064a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 801064e:	4620      	mov	r0, r4
 8010650:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 8010652:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8010654:	68a1      	ldr	r1, [r4, #8]
 8010656:	89a2      	ldrh	r2, [r4, #12]
 8010658:	f000 f8ac 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 801065c:	2304      	movs	r3, #4
 801065e:	2001      	movs	r0, #1
 8010660:	7623      	strb	r3, [r4, #24]
 8010662:	e7a2      	b.n	80105aa <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8010664:	7921      	ldrb	r1, [r4, #4]
 8010666:	4620      	mov	r0, r4
 8010668:	f00d fe26 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 801066c:	2801      	cmp	r0, #1
 801066e:	d059      	beq.n	8010724 <USBH_ClrFeature+0x18c>
      if (URB_Status == USBH_URB_STALL)
 8010670:	2805      	cmp	r0, #5
 8010672:	d039      	beq.n	80106e8 <USBH_ClrFeature+0x150>
        if (URB_Status == USBH_URB_ERROR)
 8010674:	2804      	cmp	r0, #4
 8010676:	d197      	bne.n	80105a8 <USBH_ClrFeature+0x10>
 8010678:	e7e3      	b.n	8010642 <USBH_ClrFeature+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 801067a:	2501      	movs	r5, #1
 801067c:	7963      	ldrb	r3, [r4, #5]
 801067e:	89a2      	ldrh	r2, [r4, #12]
 8010680:	4620      	mov	r0, r4
 8010682:	68a1      	ldr	r1, [r4, #8]
 8010684:	9500      	str	r5, [sp, #0]
 8010686:	f000 f87d 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 801068a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 801068e:	2306      	movs	r3, #6
 8010690:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 8010692:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8010694:	7623      	strb	r3, [r4, #24]
 8010696:	e788      	b.n	80105aa <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8010698:	7961      	ldrb	r1, [r4, #5]
 801069a:	4620      	mov	r0, r4
 801069c:	f00d fe0c 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80106a0:	2801      	cmp	r0, #1
 80106a2:	d047      	beq.n	8010734 <USBH_ClrFeature+0x19c>
      else if (URB_Status == USBH_URB_STALL)
 80106a4:	2805      	cmp	r0, #5
 80106a6:	d01f      	beq.n	80106e8 <USBH_ClrFeature+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
 80106a8:	2802      	cmp	r0, #2
 80106aa:	d04e      	beq.n	801074a <USBH_ClrFeature+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
 80106ac:	2804      	cmp	r0, #4
 80106ae:	f47f af7b 	bne.w	80105a8 <USBH_ClrFeature+0x10>
          phost->Control.state = CTRL_ERROR;
 80106b2:	230b      	movs	r3, #11
 80106b4:	7623      	strb	r3, [r4, #24]
 80106b6:	e7ab      	b.n	8010610 <USBH_ClrFeature+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 80106b8:	2200      	movs	r2, #0
 80106ba:	7923      	ldrb	r3, [r4, #4]
 80106bc:	4620      	mov	r0, r4
 80106be:	4611      	mov	r1, r2
 80106c0:	f000 f878 	bl	80107b4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80106c4:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 80106c8:	2308      	movs	r3, #8
 80106ca:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 80106cc:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 80106ce:	7623      	strb	r3, [r4, #24]
 80106d0:	e76b      	b.n	80105aa <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 80106d2:	7921      	ldrb	r1, [r4, #4]
 80106d4:	4620      	mov	r0, r4
 80106d6:	f00d fdef 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80106da:	2801      	cmp	r0, #1
 80106dc:	d026      	beq.n	801072c <USBH_ClrFeature+0x194>
      else if (URB_Status == USBH_URB_ERROR)
 80106de:	2804      	cmp	r0, #4
 80106e0:	d0af      	beq.n	8010642 <USBH_ClrFeature+0xaa>
        if (URB_Status == USBH_URB_STALL)
 80106e2:	2805      	cmp	r0, #5
 80106e4:	f47f af60 	bne.w	80105a8 <USBH_ClrFeature+0x10>
        status = USBH_NOT_SUPPORTED;
 80106e8:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 80106ea:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 80106ec:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 80106ee:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 80106f0:	7623      	strb	r3, [r4, #24]
}
 80106f2:	b003      	add	sp, #12
 80106f4:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 80106f6:	2200      	movs	r2, #0
 80106f8:	2501      	movs	r5, #1
 80106fa:	7963      	ldrb	r3, [r4, #5]
 80106fc:	4620      	mov	r0, r4
 80106fe:	4611      	mov	r1, r2
 8010700:	9500      	str	r5, [sp, #0]
 8010702:	f000 f83f 	bl	8010784 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8010706:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 801070a:	230a      	movs	r3, #10
 801070c:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 801070e:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8010710:	7623      	strb	r3, [r4, #24]
 8010712:	e74a      	b.n	80105aa <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8010714:	7961      	ldrb	r1, [r4, #5]
 8010716:	4620      	mov	r0, r4
 8010718:	f00d fdce 	bl	801e2b8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 801071c:	2801      	cmp	r0, #1
 801071e:	d005      	beq.n	801072c <USBH_ClrFeature+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
 8010720:	2802      	cmp	r0, #2
 8010722:	d1a7      	bne.n	8010674 <USBH_ClrFeature+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
 8010724:	2309      	movs	r3, #9
 8010726:	2001      	movs	r0, #1
 8010728:	7623      	strb	r3, [r4, #24]
 801072a:	e73e      	b.n	80105aa <USBH_ClrFeature+0x12>
        status = USBH_OK;
 801072c:	2000      	movs	r0, #0
 801072e:	e7dc      	b.n	80106ea <USBH_ClrFeature+0x152>
          if (direction == USB_D2H)
 8010730:	2a00      	cmp	r2, #0
 8010732:	dbf7      	blt.n	8010724 <USBH_ClrFeature+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
 8010734:	2307      	movs	r3, #7
 8010736:	2001      	movs	r0, #1
 8010738:	7623      	strb	r3, [r4, #24]
 801073a:	e736      	b.n	80105aa <USBH_ClrFeature+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
 801073c:	8ae3      	ldrh	r3, [r4, #22]
 801073e:	f994 2010 	ldrsb.w	r2, [r4, #16]
 8010742:	2b00      	cmp	r3, #0
 8010744:	d0f4      	beq.n	8010730 <USBH_ClrFeature+0x198>
          if (direction == USB_D2H)
 8010746:	2a00      	cmp	r2, #0
 8010748:	db08      	blt.n	801075c <USBH_ClrFeature+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
 801074a:	2305      	movs	r3, #5
 801074c:	2001      	movs	r0, #1
 801074e:	7623      	strb	r3, [r4, #24]
 8010750:	e72b      	b.n	80105aa <USBH_ClrFeature+0x12>
        phost->Control.state = CTRL_SETUP;
 8010752:	2301      	movs	r3, #1
 8010754:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 8010756:	4618      	mov	r0, r3
 8010758:	70a3      	strb	r3, [r4, #2]
 801075a:	e726      	b.n	80105aa <USBH_ClrFeature+0x12>
            phost->Control.state = CTRL_DATA_IN;
 801075c:	2303      	movs	r3, #3
 801075e:	7623      	strb	r3, [r4, #24]
 8010760:	e723      	b.n	80105aa <USBH_ClrFeature+0x12>
 8010762:	bf00      	nop

08010764 <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
 8010764:	b530      	push	{r4, r5, lr}

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 8010766:	2400      	movs	r4, #0
{
 8010768:	b085      	sub	sp, #20
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 801076a:	2508      	movs	r5, #8
 801076c:	9101      	str	r1, [sp, #4]
 801076e:	4623      	mov	r3, r4
 8010770:	4611      	mov	r1, r2
 8010772:	9403      	str	r4, [sp, #12]
 8010774:	9400      	str	r4, [sp, #0]
 8010776:	4622      	mov	r2, r4
 8010778:	9502      	str	r5, [sp, #8]
 801077a:	f00d fd81 	bl	801e280 <USBH_LL_SubmitURB>
                    USBH_PID_SETUP,       /* Type setup       */
                    buff,                 /* data buffer      */
                    USBH_SETUP_PKT_SIZE,  /* data length      */
                    0U);
  return USBH_OK;
}
 801077e:	4620      	mov	r0, r4
 8010780:	b005      	add	sp, #20
 8010782:	bd30      	pop	{r4, r5, pc}

08010784 <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
 8010784:	b570      	push	{r4, r5, r6, lr}
  if (phost->device.speed != USBH_SPEED_HIGH)
 8010786:	f890 631d 	ldrb.w	r6, [r0, #797]	; 0x31d
{
 801078a:	b084      	sub	sp, #16
 801078c:	461d      	mov	r5, r3
  {
    do_ping = 0U;
  }

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 801078e:	2300      	movs	r3, #0
  if (phost->device.speed != USBH_SPEED_HIGH)
 8010790:	2e00      	cmp	r6, #0
{
 8010792:	f89d 4020 	ldrb.w	r4, [sp, #32]
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 8010796:	f04f 0601 	mov.w	r6, #1
 801079a:	9202      	str	r2, [sp, #8]
    do_ping = 0U;
 801079c:	bf18      	it	ne
 801079e:	461c      	movne	r4, r3
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80107a0:	461a      	mov	r2, r3
 80107a2:	e9cd 6100 	strd	r6, r1, [sp]
 80107a6:	9403      	str	r4, [sp, #12]
 80107a8:	4629      	mov	r1, r5
 80107aa:	f00d fd69 	bl	801e280 <USBH_LL_SubmitURB>
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
}
 80107ae:	2000      	movs	r0, #0
 80107b0:	b004      	add	sp, #16
 80107b2:	bd70      	pop	{r4, r5, r6, pc}

080107b4 <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
 80107b4:	b570      	push	{r4, r5, r6, lr}
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80107b6:	2400      	movs	r4, #0
{
 80107b8:	b084      	sub	sp, #16
 80107ba:	461e      	mov	r6, r3
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80107bc:	2501      	movs	r5, #1
 80107be:	4623      	mov	r3, r4
 80107c0:	9403      	str	r4, [sp, #12]
 80107c2:	9500      	str	r5, [sp, #0]
 80107c4:	e9cd 1201 	strd	r1, r2, [sp, #4]
 80107c8:	4631      	mov	r1, r6
 80107ca:	462a      	mov	r2, r5
 80107cc:	f00d fd58 	bl	801e280 <USBH_LL_SubmitURB>
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;

}
 80107d0:	4620      	mov	r0, r4
 80107d2:	b004      	add	sp, #16
 80107d4:	bd70      	pop	{r4, r5, r6, pc}
 80107d6:	bf00      	nop

080107d8 <USBH_BulkReceiveData>:
  */
USBH_StatusTypeDef USBH_BulkReceiveData(USBH_HandleTypeDef *phost,
                                        uint8_t *buff,
                                        uint16_t length,
                                        uint8_t pipe_num)
{
 80107d8:	b570      	push	{r4, r5, r6, lr}
 80107da:	461e      	mov	r6, r3
 80107dc:	b084      	sub	sp, #16
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80107de:	2400      	movs	r4, #0
 80107e0:	2501      	movs	r5, #1
 80107e2:	2302      	movs	r3, #2
 80107e4:	9403      	str	r4, [sp, #12]
 80107e6:	9500      	str	r5, [sp, #0]
 80107e8:	e9cd 1201 	strd	r1, r2, [sp, #4]
 80107ec:	4631      	mov	r1, r6
 80107ee:	462a      	mov	r2, r5
 80107f0:	f00d fd46 	bl	801e280 <USBH_LL_SubmitURB>
                    USBH_PID_DATA,        /* Type Data        */
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;
}
 80107f4:	4620      	mov	r0, r4
 80107f6:	b004      	add	sp, #16
 80107f8:	bd70      	pop	{r4, r5, r6, pc}
 80107fa:	bf00      	nop

080107fc <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 80107fc:	b530      	push	{r4, r5, lr}
 80107fe:	b085      	sub	sp, #20
 8010800:	f89d 4020 	ldrb.w	r4, [sp, #32]
 8010804:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 8010808:	9400      	str	r4, [sp, #0]
{
 801080a:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 801080e:	e9cd 5401 	strd	r5, r4, [sp, #4]
 8010812:	f00d fd0d 	bl	801e230 <USBH_LL_OpenPipe>

  return USBH_OK;
}
 8010816:	2000      	movs	r0, #0
 8010818:	b005      	add	sp, #20
 801081a:	bd30      	pop	{r4, r5, pc}

0801081c <USBH_ClosePipe>:
  * @param  phost: Host Handle
  * @param  pipe_num: Pipe Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe_num)
{
 801081c:	b508      	push	{r3, lr}
  USBH_LL_ClosePipe(phost, pipe_num);
 801081e:	f00d fd21 	bl	801e264 <USBH_LL_ClosePipe>

  return USBH_OK;
}
 8010822:	2000      	movs	r0, #0
 8010824:	bd08      	pop	{r3, pc}
 8010826:	bf00      	nop

08010828 <USBH_AllocPipe>:
  * @param  phost: Host Handle
  * @param  ep_addr: End point for which the Pipe to be allocated
  * @retval Pipe number
  */
uint8_t USBH_AllocPipe(USBH_HandleTypeDef *phost, uint8_t ep_addr)
{
 8010828:	4603      	mov	r3, r0
{
  uint8_t idx = 0U;

  for (idx = 0U ; idx < 11U ; idx++)
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
 801082a:	f8d0 04f4 	ldr.w	r0, [r0, #1268]	; 0x4f4
 801082e:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
 8010832:	d02a      	beq.n	801088a <USBH_AllocPipe+0x62>
 8010834:	f8d3 24f8 	ldr.w	r2, [r3, #1272]	; 0x4f8
 8010838:	0410      	lsls	r0, r2, #16
 801083a:	d52d      	bpl.n	8010898 <USBH_AllocPipe+0x70>
 801083c:	f8d3 24fc 	ldr.w	r2, [r3, #1276]	; 0x4fc
 8010840:	0412      	lsls	r2, r2, #16
 8010842:	d52b      	bpl.n	801089c <USBH_AllocPipe+0x74>
 8010844:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
 8010848:	0410      	lsls	r0, r2, #16
 801084a:	d529      	bpl.n	80108a0 <USBH_AllocPipe+0x78>
 801084c:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
 8010850:	0412      	lsls	r2, r2, #16
 8010852:	d527      	bpl.n	80108a4 <USBH_AllocPipe+0x7c>
 8010854:	f8d3 2508 	ldr.w	r2, [r3, #1288]	; 0x508
 8010858:	0410      	lsls	r0, r2, #16
 801085a:	d525      	bpl.n	80108a8 <USBH_AllocPipe+0x80>
 801085c:	f8d3 250c 	ldr.w	r2, [r3, #1292]	; 0x50c
 8010860:	0412      	lsls	r2, r2, #16
 8010862:	d525      	bpl.n	80108b0 <USBH_AllocPipe+0x88>
 8010864:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
 8010868:	0410      	lsls	r0, r2, #16
 801086a:	d523      	bpl.n	80108b4 <USBH_AllocPipe+0x8c>
 801086c:	f8d3 2514 	ldr.w	r2, [r3, #1300]	; 0x514
 8010870:	0412      	lsls	r2, r2, #16
 8010872:	d51b      	bpl.n	80108ac <USBH_AllocPipe+0x84>
 8010874:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
 8010878:	0410      	lsls	r0, r2, #16
 801087a:	d505      	bpl.n	8010888 <USBH_AllocPipe+0x60>
 801087c:	f8d3 251c 	ldr.w	r2, [r3, #1308]	; 0x51c
 8010880:	0412      	lsls	r2, r2, #16
 8010882:	d519      	bpl.n	80108b8 <USBH_AllocPipe+0x90>
 8010884:	20ff      	movs	r0, #255	; 0xff
}
 8010886:	4770      	bx	lr
  for (idx = 0U ; idx < 11U ; idx++)
 8010888:	2009      	movs	r0, #9
    phost->Pipes[pipe & 0xFU] = 0x8000U | ep_addr;
 801088a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 801088e:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8010892:	f8c3 14f4 	str.w	r1, [r3, #1268]	; 0x4f4
 8010896:	4770      	bx	lr
  for (idx = 0U ; idx < 11U ; idx++)
 8010898:	2001      	movs	r0, #1
 801089a:	e7f6      	b.n	801088a <USBH_AllocPipe+0x62>
 801089c:	2002      	movs	r0, #2
 801089e:	e7f4      	b.n	801088a <USBH_AllocPipe+0x62>
 80108a0:	2003      	movs	r0, #3
 80108a2:	e7f2      	b.n	801088a <USBH_AllocPipe+0x62>
 80108a4:	2004      	movs	r0, #4
 80108a6:	e7f0      	b.n	801088a <USBH_AllocPipe+0x62>
 80108a8:	2005      	movs	r0, #5
 80108aa:	e7ee      	b.n	801088a <USBH_AllocPipe+0x62>
 80108ac:	2008      	movs	r0, #8
 80108ae:	e7ec      	b.n	801088a <USBH_AllocPipe+0x62>
 80108b0:	2006      	movs	r0, #6
 80108b2:	e7ea      	b.n	801088a <USBH_AllocPipe+0x62>
 80108b4:	2007      	movs	r0, #7
 80108b6:	e7e8      	b.n	801088a <USBH_AllocPipe+0x62>
 80108b8:	200a      	movs	r0, #10
 80108ba:	e7e6      	b.n	801088a <USBH_AllocPipe+0x62>

080108bc <USBH_FreePipe>:
  if (idx < 11U)
 80108bc:	290a      	cmp	r1, #10
 80108be:	d807      	bhi.n	80108d0 <USBH_FreePipe+0x14>
 80108c0:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    phost->Pipes[idx] &= 0x7FFFU;
 80108c4:	f8d0 34f4 	ldr.w	r3, [r0, #1268]	; 0x4f4
 80108c8:	f3c3 030e 	ubfx	r3, r3, #0, #15
 80108cc:	f8c0 34f4 	str.w	r3, [r0, #1268]	; 0x4f4
}
 80108d0:	2000      	movs	r0, #0
 80108d2:	4770      	bx	lr

080108d4 <FATFS_LinkDriver>:
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
 80108d4:	4b11      	ldr	r3, [pc, #68]	; (801091c <FATFS_LinkDriver+0x48>)
 80108d6:	7a5a      	ldrb	r2, [r3, #9]
 80108d8:	b10a      	cbz	r2, 80108de <FATFS_LinkDriver+0xa>
  uint8_t ret = 1;
 80108da:	2001      	movs	r0, #1
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
}
 80108dc:	4770      	bx	lr
{
 80108de:	b5f0      	push	{r4, r5, r6, r7, lr}
 80108e0:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    disk.is_initialized[disk.nbr] = 0;
 80108e4:	f893 e009 	ldrb.w	lr, [r3, #9]
    disk.drv[disk.nbr] = drv;
 80108e8:	7a5e      	ldrb	r6, [r3, #9]
    path[1] = ':';
 80108ea:	f04f 0c3a 	mov.w	ip, #58	; 0x3a
    disk.lun[disk.nbr] = lun;
 80108ee:	7a5d      	ldrb	r5, [r3, #9]
    path[2] = '/';
 80108f0:	272f      	movs	r7, #47	; 0x2f
    DiskNum = disk.nbr++;
 80108f2:	7a5a      	ldrb	r2, [r3, #9]
    disk.drv[disk.nbr] = drv;
 80108f4:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    disk.lun[disk.nbr] = lun;
 80108f8:	441d      	add	r5, r3
    disk.is_initialized[disk.nbr] = 0;
 80108fa:	f803 400e 	strb.w	r4, [r3, lr]
    DiskNum = disk.nbr++;
 80108fe:	b2d2      	uxtb	r2, r2
    disk.drv[disk.nbr] = drv;
 8010900:	6070      	str	r0, [r6, #4]
    disk.lun[disk.nbr] = lun;
 8010902:	722c      	strb	r4, [r5, #8]
    DiskNum = disk.nbr++;
 8010904:	1c50      	adds	r0, r2, #1
    path[0] = DiskNum + '0';
 8010906:	3230      	adds	r2, #48	; 0x30
    DiskNum = disk.nbr++;
 8010908:	b2c0      	uxtb	r0, r0
 801090a:	7258      	strb	r0, [r3, #9]
    path[3] = 0;
 801090c:	4620      	mov	r0, r4
    path[0] = DiskNum + '0';
 801090e:	700a      	strb	r2, [r1, #0]
    path[3] = 0;
 8010910:	70cc      	strb	r4, [r1, #3]
    path[1] = ':';
 8010912:	f881 c001 	strb.w	ip, [r1, #1]
    path[2] = '/';
 8010916:	708f      	strb	r7, [r1, #2]
}
 8010918:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801091a:	bf00      	nop
 801091c:	200004c8 	.word	0x200004c8

08010920 <MIDI_Application>:
 * @brief  Main routine for MIDI application, looped in main.c
 * @param  None
 * @retval none
 */
void MIDI_Application(void)
{
 8010920:	b510      	push	{r4, lr}
	if(Appli_state == APPLICATION_READY)
 8010922:	4c15      	ldr	r4, [pc, #84]	; (8010978 <MIDI_Application+0x58>)
 8010924:	7823      	ldrb	r3, [r4, #0]
 8010926:	2b02      	cmp	r3, #2
 8010928:	d016      	beq.n	8010958 <MIDI_Application+0x38>
	if(Appli_state == APPLICATION_RUNNING)
	{
			//....pffff......grrrrr......
	}

	if(Appli_state == APPLICATION_DISCONNECT)
 801092a:	2b04      	cmp	r3, #4
 801092c:	d000      	beq.n	8010930 <MIDI_Application+0x10>
		HAL_Delay(10);
		MX_USB_HOST_Init();

	}

}
 801092e:	bd10      	pop	{r4, pc}
		Appli_state = APPLICATION_IDLE;
 8010930:	2300      	movs	r3, #0
		setLED_USB(0);
 8010932:	4618      	mov	r0, r3
		Appli_state = APPLICATION_IDLE;
 8010934:	7023      	strb	r3, [r4, #0]
		setLED_USB(0);
 8010936:	f002 ffdb 	bl	80138f0 <setLED_USB>
		USBH_MIDI_Stop(&hUsbHostFS);
 801093a:	4810      	ldr	r0, [pc, #64]	; (801097c <MIDI_Application+0x5c>)
 801093c:	f00d fb8e 	bl	801e05c <USBH_MIDI_Stop>
		HAL_Delay(10);
 8010940:	200a      	movs	r0, #10
 8010942:	f7f0 f877 	bl	8000a34 <HAL_Delay>
		MX_USB_HOST_DeInit();
 8010946:	f00d fa17 	bl	801dd78 <MX_USB_HOST_DeInit>
		HAL_Delay(10);
 801094a:	200a      	movs	r0, #10
 801094c:	f7f0 f872 	bl	8000a34 <HAL_Delay>
}
 8010950:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		MX_USB_HOST_Init();
 8010954:	f00d b9ee 	b.w	801dd34 <MX_USB_HOST_Init>
		USBH_MIDI_Receive(&hUsbHostFS, MIDI_RX_Buffer[MIDI_write_buffer], RX_BUFF_SIZE); // just once at the beginning, start the first reception
 8010958:	4909      	ldr	r1, [pc, #36]	; (8010980 <MIDI_Application+0x60>)
 801095a:	2240      	movs	r2, #64	; 0x40
 801095c:	4b09      	ldr	r3, [pc, #36]	; (8010984 <MIDI_Application+0x64>)
 801095e:	6809      	ldr	r1, [r1, #0]
 8010960:	4806      	ldr	r0, [pc, #24]	; (801097c <MIDI_Application+0x5c>)
 8010962:	eb03 1181 	add.w	r1, r3, r1, lsl #6
 8010966:	f00d fb8f 	bl	801e088 <USBH_MIDI_Receive>
		Appli_state = APPLICATION_RUNNING;
 801096a:	2303      	movs	r3, #3
		setLED_USB(1);
 801096c:	2001      	movs	r0, #1
		Appli_state = APPLICATION_RUNNING;
 801096e:	7023      	strb	r3, [r4, #0]
		setLED_USB(1);
 8010970:	f002 ffbe 	bl	80138f0 <setLED_USB>
 8010974:	7823      	ldrb	r3, [r4, #0]
 8010976:	e7d8      	b.n	801092a <MIDI_Application+0xa>
 8010978:	2000066c 	.word	0x2000066c
 801097c:	300010a0 	.word	0x300010a0
 8010980:	20000008 	.word	0x20000008
 8010984:	30000000 	.word	0x30000000

08010988 <ProcessReceivedMidiDatas>:

}

/*-----------------------------------------------------------------------------*/
void ProcessReceivedMidiDatas(void)
{
 8010988:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int miniBufferPosition = 0;
	int processed = 0;
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
 801098c:	2521      	movs	r5, #33	; 0x21
 801098e:	4c37      	ldr	r4, [pc, #220]	; (8010a6c <ProcessReceivedMidiDatas+0xe4>)
 8010990:	4f37      	ldr	r7, [pc, #220]	; (8010a70 <ProcessReceivedMidiDatas+0xe8>)
 8010992:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 8010a88 <ProcessReceivedMidiDatas+0x100>
			(processed < 32)) // maximum notes to process in a frame * 4
	{

		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
 8010996:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 8010a8c <ProcessReceivedMidiDatas+0x104>
 801099a:	4e36      	ldr	r6, [pc, #216]	; (8010a74 <ProcessReceivedMidiDatas+0xec>)
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
 801099c:	883b      	ldrh	r3, [r7, #0]
 801099e:	8822      	ldrh	r2, [r4, #0]
 80109a0:	429a      	cmp	r2, r3
 80109a2:	d302      	bcc.n	80109aa <ProcessReceivedMidiDatas+0x22>
 80109a4:	f898 3000 	ldrb.w	r3, [r8]
 80109a8:	b1f3      	cbz	r3, 80109e8 <ProcessReceivedMidiDatas+0x60>
 80109aa:	3d01      	subs	r5, #1
 80109ac:	d01c      	beq.n	80109e8 <ProcessReceivedMidiDatas+0x60>
		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
 80109ae:	8822      	ldrh	r2, [r4, #0]
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
 80109b0:	8823      	ldrh	r3, [r4, #0]
 80109b2:	f002 0203 	and.w	r2, r2, #3
 80109b6:	b29b      	uxth	r3, r3
		myUSB_FIFO_readPointer++;
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
 80109b8:	2a03      	cmp	r2, #3
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
 80109ba:	f819 1003 	ldrb.w	r1, [r9, r3]
		myUSB_FIFO_readPointer++;
 80109be:	8823      	ldrh	r3, [r4, #0]
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
 80109c0:	f846 1022 	str.w	r1, [r6, r2, lsl #2]
		myUSB_FIFO_readPointer++;
 80109c4:	f103 0301 	add.w	r3, r3, #1
 80109c8:	b29b      	uxth	r3, r3
 80109ca:	8023      	strh	r3, [r4, #0]
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
 80109cc:	d00e      	beq.n	80109ec <ProcessReceivedMidiDatas+0x64>
		{
			parse_MIDI_Message();
		}
		if (myUSB_FIFO_readPointer >= USB_FIFO_SIZE)
 80109ce:	8823      	ldrh	r3, [r4, #0]
 80109d0:	2bff      	cmp	r3, #255	; 0xff
 80109d2:	d9e3      	bls.n	801099c <ProcessReceivedMidiDatas+0x14>
		{
			myUSB_FIFO_overflowBit = 0;
 80109d4:	2300      	movs	r3, #0
 80109d6:	f888 3000 	strb.w	r3, [r8]
			myUSB_FIFO_readPointer = 0;
 80109da:	8023      	strh	r3, [r4, #0]
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
 80109dc:	883b      	ldrh	r3, [r7, #0]
 80109de:	8822      	ldrh	r2, [r4, #0]
 80109e0:	429a      	cmp	r2, r3
 80109e2:	d2df      	bcs.n	80109a4 <ProcessReceivedMidiDatas+0x1c>
 80109e4:	3d01      	subs	r5, #1
 80109e6:	d1e2      	bne.n	80109ae <ProcessReceivedMidiDatas+0x26>
		}
		processed++;
	}
}
 80109e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	switch(USB_message[1])
 80109ec:	6873      	ldr	r3, [r6, #4]
 80109ee:	2b90      	cmp	r3, #144	; 0x90
 80109f0:	d029      	beq.n	8010a46 <ProcessReceivedMidiDatas+0xbe>
 80109f2:	dd0a      	ble.n	8010a0a <ProcessReceivedMidiDatas+0x82>
 80109f4:	2bb0      	cmp	r3, #176	; 0xb0
 80109f6:	d017      	beq.n	8010a28 <ProcessReceivedMidiDatas+0xa0>
 80109f8:	2be0      	cmp	r3, #224	; 0xe0
 80109fa:	d1e8      	bne.n	80109ce <ProcessReceivedMidiDatas+0x46>
			pitchBend((USB_message[2]) + (USB_message[3] << 7));
 80109fc:	e9d6 3002 	ldrd	r3, r0, [r6, #8]
 8010a00:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
 8010a04:	f00b f814 	bl	801ba30 <pitchBend>
 8010a08:	e7e1      	b.n	80109ce <ProcessReceivedMidiDatas+0x46>
	switch(USB_message[1])
 8010a0a:	2b80      	cmp	r3, #128	; 0x80
 8010a0c:	d1df      	bne.n	80109ce <ProcessReceivedMidiDatas+0x46>
			key = USB_message[2];
 8010a0e:	491a      	ldr	r1, [pc, #104]	; (8010a78 <ProcessReceivedMidiDatas+0xf0>)
			velocity = USB_message[3];
 8010a10:	f8df c07c 	ldr.w	ip, [pc, #124]	; 8010a90 <ProcessReceivedMidiDatas+0x108>
 8010a14:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
			key = USB_message[2];
 8010a18:	600a      	str	r2, [r1, #0]
			noteOff(key, velocity);
 8010a1a:	4610      	mov	r0, r2
 8010a1c:	4619      	mov	r1, r3
			velocity = USB_message[3];
 8010a1e:	f8cc 3000 	str.w	r3, [ip]
			noteOff(key, velocity);
 8010a22:	f00a fe39 	bl	801b698 <noteOff>
 8010a26:	e7d2      	b.n	80109ce <ProcessReceivedMidiDatas+0x46>
			ctrl = USB_message[2];
 8010a28:	68b3      	ldr	r3, [r6, #8]
 8010a2a:	4814      	ldr	r0, [pc, #80]	; (8010a7c <ProcessReceivedMidiDatas+0xf4>)
			data = USB_message[3];
 8010a2c:	68f2      	ldr	r2, [r6, #12]
			switch(ctrl)
 8010a2e:	2b40      	cmp	r3, #64	; 0x40
			data = USB_message[3];
 8010a30:	4913      	ldr	r1, [pc, #76]	; (8010a80 <ProcessReceivedMidiDatas+0xf8>)
			ctrl = USB_message[2];
 8010a32:	6003      	str	r3, [r0, #0]
			data = USB_message[3];
 8010a34:	600a      	str	r2, [r1, #0]
			switch(ctrl)
 8010a36:	d1ca      	bne.n	80109ce <ProcessReceivedMidiDatas+0x46>
 8010a38:	4b12      	ldr	r3, [pc, #72]	; (8010a84 <ProcessReceivedMidiDatas+0xfc>)
 8010a3a:	681b      	ldr	r3, [r3, #0]
					if (data)
 8010a3c:	b182      	cbz	r2, 8010a60 <ProcessReceivedMidiDatas+0xd8>
						if (sustainInverted) 	sustainOff();
 8010a3e:	b18b      	cbz	r3, 8010a64 <ProcessReceivedMidiDatas+0xdc>
 8010a40:	f00b f802 	bl	801ba48 <sustainOff>
 8010a44:	e7c3      	b.n	80109ce <ProcessReceivedMidiDatas+0x46>
			velocity = USB_message[3];
 8010a46:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
			key = USB_message[2];
 8010a4a:	490b      	ldr	r1, [pc, #44]	; (8010a78 <ProcessReceivedMidiDatas+0xf0>)
			velocity = USB_message[3];
 8010a4c:	f8df c040 	ldr.w	ip, [pc, #64]	; 8010a90 <ProcessReceivedMidiDatas+0x108>
			noteOn(key, velocity);
 8010a50:	4610      	mov	r0, r2
			key = USB_message[2];
 8010a52:	600a      	str	r2, [r1, #0]
			noteOn(key, velocity);
 8010a54:	4619      	mov	r1, r3
			velocity = USB_message[3];
 8010a56:	f8cc 3000 	str.w	r3, [ip]
			noteOn(key, velocity);
 8010a5a:	f00a fed7 	bl	801b80c <noteOn>
 8010a5e:	e7b6      	b.n	80109ce <ProcessReceivedMidiDatas+0x46>
						if (sustainInverted) 	sustainOn();
 8010a60:	2b00      	cmp	r3, #0
 8010a62:	d0ed      	beq.n	8010a40 <ProcessReceivedMidiDatas+0xb8>
						else					sustainOn();
 8010a64:	f00a fff2 	bl	801ba4c <sustainOn>
 8010a68:	e7b1      	b.n	80109ce <ProcessReceivedMidiDatas+0x46>
 8010a6a:	bf00      	nop
 8010a6c:	2000066e 	.word	0x2000066e
 8010a70:	20000670 	.word	0x20000670
 8010a74:	200006a4 	.word	0x200006a4
 8010a78:	200006b4 	.word	0x200006b4
 8010a7c:	20000698 	.word	0x20000698
 8010a80:	200006a0 	.word	0x200006a0
 8010a84:	20000694 	.word	0x20000694
 8010a88:	2000066d 	.word	0x2000066d
 8010a8c:	20019124 	.word	0x20019124
 8010a90:	2000069c 	.word	0x2000069c

08010a94 <MX_ADC1_Init>:
  ADC_MultiModeTypeDef multimode = {0};
  ADC_ChannelConfTypeDef sConfig = {0};

  /** Common config 
  */
  hadc1.Instance = ADC1;
 8010a94:	4b49      	ldr	r3, [pc, #292]	; (8010bbc <MX_ADC1_Init+0x128>)
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV4;
 8010a96:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  hadc1.Instance = ADC1;
 8010a9a:	4949      	ldr	r1, [pc, #292]	; (8010bc0 <MX_ADC1_Init+0x12c>)
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 8010a9c:	2208      	movs	r2, #8
{
 8010a9e:	b530      	push	{r4, r5, lr}
  hadc1.Instance = ADC1;
 8010aa0:	6019      	str	r1, [r3, #0]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
  hadc1.Init.OversamplingMode = ENABLE;
  hadc1.Init.Oversampling.Ratio = 64;
 8010aa2:	2140      	movs	r1, #64	; 0x40
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV4;
 8010aa4:	6058      	str	r0, [r3, #4]
  hadc1.Init.Oversampling.RightBitShift = ADC_RIGHTBITSHIFT_6;
 8010aa6:	20c0      	movs	r0, #192	; 0xc0
{
 8010aa8:	b08b      	sub	sp, #44	; 0x2c
  hadc1.Init.NbrOfConversion = 6;
 8010aaa:	2506      	movs	r5, #6
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
 8010aac:	2403      	movs	r4, #3
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 8010aae:	611a      	str	r2, [r3, #16]
  hadc1.Init.Oversampling.Ratio = 64;
 8010ab0:	63d9      	str	r1, [r3, #60]	; 0x3c
  ADC_MultiModeTypeDef multimode = {0};
 8010ab2:	2200      	movs	r2, #0
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 8010ab4:	2101      	movs	r1, #1
  hadc1.Init.Oversampling.RightBitShift = ADC_RIGHTBITSHIFT_6;
 8010ab6:	6418      	str	r0, [r3, #64]	; 0x40
  hadc1.Init.Oversampling.TriggeredMode = ADC_TRIGGEREDMODE_SINGLE_TRIGGER;
  hadc1.Init.Oversampling.OversamplingStopReset = ADC_REGOVERSAMPLING_CONTINUED_MODE;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8010ab8:	4618      	mov	r0, r3
  hadc1.Init.NbrOfConversion = 6;
 8010aba:	619d      	str	r5, [r3, #24]
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
 8010abc:	62dc      	str	r4, [r3, #44]	; 0x2c
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
 8010abe:	609a      	str	r2, [r3, #8]
  ADC_MultiModeTypeDef multimode = {0};
 8010ac0:	9200      	str	r2, [sp, #0]
  ADC_ChannelConfTypeDef sConfig = {0};
 8010ac2:	9203      	str	r2, [sp, #12]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8010ac4:	751a      	strb	r2, [r3, #20]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8010ac6:	771a      	strb	r2, [r3, #28]
  hadc1.Init.Oversampling.TriggeredMode = ADC_TRIGGEREDMODE_SINGLE_TRIGGER;
 8010ac8:	645a      	str	r2, [r3, #68]	; 0x44
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 8010aca:	60d9      	str	r1, [r3, #12]
  hadc1.Init.ContinuousConvMode = ENABLE;
 8010acc:	7559      	strb	r1, [r3, #21]
  hadc1.Init.OversamplingMode = ENABLE;
 8010ace:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
  hadc1.Init.Oversampling.OversamplingStopReset = ADC_REGOVERSAMPLING_CONTINUED_MODE;
 8010ad2:	6499      	str	r1, [r3, #72]	; 0x48
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8010ad4:	e9c3 2209 	strd	r2, r2, [r3, #36]	; 0x24
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
 8010ad8:	e9c3 220c 	strd	r2, r2, [r3, #48]	; 0x30
  ADC_MultiModeTypeDef multimode = {0};
 8010adc:	e9cd 2201 	strd	r2, r2, [sp, #4]
  ADC_ChannelConfTypeDef sConfig = {0};
 8010ae0:	e9cd 2204 	strd	r2, r2, [sp, #16]
 8010ae4:	e9cd 2206 	strd	r2, r2, [sp, #24]
 8010ae8:	e9cd 2208 	strd	r2, r2, [sp, #32]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8010aec:	f7f1 f810 	bl	8001b10 <HAL_ADC_Init>
 8010af0:	2800      	cmp	r0, #0
 8010af2:	d160      	bne.n	8010bb6 <MX_ADC1_Init+0x122>
  {
    Error_Handler();
  }
  /** Configure the ADC multi-mode 
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8010af4:	2300      	movs	r3, #0
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8010af6:	4669      	mov	r1, sp
 8010af8:	4830      	ldr	r0, [pc, #192]	; (8010bbc <MX_ADC1_Init+0x128>)
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8010afa:	9300      	str	r3, [sp, #0]
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8010afc:	f7f1 fb22 	bl	8002144 <HAL_ADCEx_MultiModeConfigChannel>
 8010b00:	2800      	cmp	r0, #0
 8010b02:	d155      	bne.n	8010bb0 <MX_ADC1_Init+0x11c>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_7;
 8010b04:	4b2f      	ldr	r3, [pc, #188]	; (8010bc4 <MX_ADC1_Init+0x130>)
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8010b06:	2106      	movs	r1, #6
  sConfig.SamplingTime = ADC_SAMPLETIME_64CYCLES_5;
 8010b08:	2005      	movs	r0, #5
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8010b0a:	f240 74ff 	movw	r4, #2047	; 0x7ff
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8010b0e:	2204      	movs	r2, #4
  sConfig.Channel = ADC_CHANNEL_7;
 8010b10:	9303      	str	r3, [sp, #12]
  sConfig.Offset = 0;
 8010b12:	2300      	movs	r3, #0
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8010b14:	9104      	str	r1, [sp, #16]
  sConfig.SamplingTime = ADC_SAMPLETIME_64CYCLES_5;
 8010b16:	9005      	str	r0, [sp, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b18:	a903      	add	r1, sp, #12
 8010b1a:	4828      	ldr	r0, [pc, #160]	; (8010bbc <MX_ADC1_Init+0x128>)
  sConfig.Offset = 0;
 8010b1c:	9308      	str	r3, [sp, #32]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8010b1e:	e9cd 4206 	strd	r4, r2, [sp, #24]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b22:	f7f0 fa61 	bl	8000fe8 <HAL_ADC_ConfigChannel>
 8010b26:	2800      	cmp	r0, #0
 8010b28:	d13f      	bne.n	8010baa <MX_ADC1_Init+0x116>
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_19;
  sConfig.Rank = ADC_REGULAR_RANK_2;
 8010b2a:	230c      	movs	r3, #12
  sConfig.Channel = ADC_CHANNEL_19;
 8010b2c:	4a26      	ldr	r2, [pc, #152]	; (8010bc8 <MX_ADC1_Init+0x134>)
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b2e:	4823      	ldr	r0, [pc, #140]	; (8010bbc <MX_ADC1_Init+0x128>)
 8010b30:	eb0d 0103 	add.w	r1, sp, r3
  sConfig.Rank = ADC_REGULAR_RANK_2;
 8010b34:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b38:	f7f0 fa56 	bl	8000fe8 <HAL_ADC_ConfigChannel>
 8010b3c:	bb90      	cbnz	r0, 8010ba4 <MX_ADC1_Init+0x110>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_14;
 8010b3e:	4a23      	ldr	r2, [pc, #140]	; (8010bcc <MX_ADC1_Init+0x138>)
  sConfig.Rank = ADC_REGULAR_RANK_3;
 8010b40:	2312      	movs	r3, #18
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b42:	a903      	add	r1, sp, #12
 8010b44:	481d      	ldr	r0, [pc, #116]	; (8010bbc <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_3;
 8010b46:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b4a:	f7f0 fa4d 	bl	8000fe8 <HAL_ADC_ConfigChannel>
 8010b4e:	bb30      	cbnz	r0, 8010b9e <MX_ADC1_Init+0x10a>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_16;
 8010b50:	4a1f      	ldr	r2, [pc, #124]	; (8010bd0 <MX_ADC1_Init+0x13c>)
  sConfig.Rank = ADC_REGULAR_RANK_4;
 8010b52:	2318      	movs	r3, #24
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b54:	a903      	add	r1, sp, #12
 8010b56:	4819      	ldr	r0, [pc, #100]	; (8010bbc <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_4;
 8010b58:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b5c:	f7f0 fa44 	bl	8000fe8 <HAL_ADC_ConfigChannel>
 8010b60:	b9d0      	cbnz	r0, 8010b98 <MX_ADC1_Init+0x104>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_15;
 8010b62:	4a1c      	ldr	r2, [pc, #112]	; (8010bd4 <MX_ADC1_Init+0x140>)
  sConfig.Rank = ADC_REGULAR_RANK_5;
 8010b64:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b68:	a903      	add	r1, sp, #12
 8010b6a:	4814      	ldr	r0, [pc, #80]	; (8010bbc <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_5;
 8010b6c:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b70:	f7f0 fa3a 	bl	8000fe8 <HAL_ADC_ConfigChannel>
 8010b74:	b968      	cbnz	r0, 8010b92 <MX_ADC1_Init+0xfe>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_8;
 8010b76:	4a18      	ldr	r2, [pc, #96]	; (8010bd8 <MX_ADC1_Init+0x144>)
  sConfig.Rank = ADC_REGULAR_RANK_6;
 8010b78:	f44f 7383 	mov.w	r3, #262	; 0x106
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b7c:	a903      	add	r1, sp, #12
 8010b7e:	480f      	ldr	r0, [pc, #60]	; (8010bbc <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_6;
 8010b80:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8010b84:	f7f0 fa30 	bl	8000fe8 <HAL_ADC_ConfigChannel>
 8010b88:	b108      	cbz	r0, 8010b8e <MX_ADC1_Init+0xfa>
  {
    Error_Handler();
 8010b8a:	f002 fe9f 	bl	80138cc <Error_Handler>
  }

}
 8010b8e:	b00b      	add	sp, #44	; 0x2c
 8010b90:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
 8010b92:	f002 fe9b 	bl	80138cc <Error_Handler>
 8010b96:	e7ee      	b.n	8010b76 <MX_ADC1_Init+0xe2>
    Error_Handler();
 8010b98:	f002 fe98 	bl	80138cc <Error_Handler>
 8010b9c:	e7e1      	b.n	8010b62 <MX_ADC1_Init+0xce>
    Error_Handler();
 8010b9e:	f002 fe95 	bl	80138cc <Error_Handler>
 8010ba2:	e7d5      	b.n	8010b50 <MX_ADC1_Init+0xbc>
    Error_Handler();
 8010ba4:	f002 fe92 	bl	80138cc <Error_Handler>
 8010ba8:	e7c9      	b.n	8010b3e <MX_ADC1_Init+0xaa>
    Error_Handler();
 8010baa:	f002 fe8f 	bl	80138cc <Error_Handler>
 8010bae:	e7bc      	b.n	8010b2a <MX_ADC1_Init+0x96>
    Error_Handler();
 8010bb0:	f002 fe8c 	bl	80138cc <Error_Handler>
 8010bb4:	e7a6      	b.n	8010b04 <MX_ADC1_Init+0x70>
    Error_Handler();
 8010bb6:	f002 fe89 	bl	80138cc <Error_Handler>
 8010bba:	e79b      	b.n	8010af4 <MX_ADC1_Init+0x60>
 8010bbc:	200006b8 	.word	0x200006b8
 8010bc0:	40022000 	.word	0x40022000
 8010bc4:	1d500080 	.word	0x1d500080
 8010bc8:	4fb80000 	.word	0x4fb80000
 8010bcc:	3ac04000 	.word	0x3ac04000
 8010bd0:	43210000 	.word	0x43210000
 8010bd4:	3ef08000 	.word	0x3ef08000
 8010bd8:	21800100 	.word	0x21800100

08010bdc <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 8010bdc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  HAL_DMA_MuxSyncConfigTypeDef pSyncConfig= {0};
  if(adcHandle->Instance==ADC1)
 8010be0:	4b46      	ldr	r3, [pc, #280]	; (8010cfc <HAL_ADC_MspInit+0x120>)
{
 8010be2:	b08f      	sub	sp, #60	; 0x3c
  if(adcHandle->Instance==ADC1)
 8010be4:	6802      	ldr	r2, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8010be6:	2400      	movs	r4, #0
  if(adcHandle->Instance==ADC1)
 8010be8:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8010bea:	940d      	str	r4, [sp, #52]	; 0x34
 8010bec:	e9cd 4409 	strd	r4, r4, [sp, #36]	; 0x24
 8010bf0:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  HAL_DMA_MuxSyncConfigTypeDef pSyncConfig= {0};
 8010bf4:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8010bf8:	e9cd 4406 	strd	r4, r4, [sp, #24]
  if(adcHandle->Instance==ADC1)
 8010bfc:	d002      	beq.n	8010c04 <HAL_ADC_MspInit+0x28>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 8010bfe:	b00f      	add	sp, #60	; 0x3c
 8010c00:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_ADC12_CLK_ENABLE();
 8010c04:	4b3e      	ldr	r3, [pc, #248]	; (8010d00 <HAL_ADC_MspInit+0x124>)
 8010c06:	4606      	mov	r6, r0
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_5;
 8010c08:	2022      	movs	r0, #34	; 0x22
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8010c0a:	2703      	movs	r7, #3
    __HAL_RCC_ADC12_CLK_ENABLE();
 8010c0c:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8010c10:	a909      	add	r1, sp, #36	; 0x24
    hdma_adc1.Instance = DMA2_Stream0;
 8010c12:	4d3c      	ldr	r5, [pc, #240]	; (8010d04 <HAL_ADC_MspInit+0x128>)
    __HAL_RCC_ADC12_CLK_ENABLE();
 8010c14:	f042 0220 	orr.w	r2, r2, #32
 8010c18:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
 8010c1c:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 8010c20:	f002 0220 	and.w	r2, r2, #32
 8010c24:	9201      	str	r2, [sp, #4]
 8010c26:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8010c28:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8010c2c:	f042 0204 	orr.w	r2, r2, #4
 8010c30:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 8010c34:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8010c38:	f002 0204 	and.w	r2, r2, #4
 8010c3c:	9202      	str	r2, [sp, #8]
 8010c3e:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8010c40:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8010c44:	f042 0201 	orr.w	r2, r2, #1
 8010c48:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 8010c4c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_5;
 8010c50:	9009      	str	r0, [sp, #36]	; 0x24
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8010c52:	f003 0301 	and.w	r3, r3, #1
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8010c56:	482c      	ldr	r0, [pc, #176]	; (8010d08 <HAL_ADC_MspInit+0x12c>)
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8010c58:	970a      	str	r7, [sp, #40]	; 0x28
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8010c5a:	9303      	str	r3, [sp, #12]
 8010c5c:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8010c5e:	f7f4 faaf 	bl	80051c0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5 
 8010c62:	23ad      	movs	r3, #173	; 0xad
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8010c64:	a909      	add	r1, sp, #36	; 0x24
 8010c66:	4829      	ldr	r0, [pc, #164]	; (8010d0c <HAL_ADC_MspInit+0x130>)
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5 
 8010c68:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010c6a:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8010c6e:	f7f4 faa7 	bl	80051c0 <HAL_GPIO_Init>
    hdma_adc1.Instance = DMA2_Stream0;
 8010c72:	4b27      	ldr	r3, [pc, #156]	; (8010d10 <HAL_ADC_MspInit+0x134>)
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8010c74:	f44f 6080 	mov.w	r0, #1024	; 0x400
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
 8010c78:	f04f 0e09 	mov.w	lr, #9
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8010c7c:	f44f 6c00 	mov.w	ip, #2048	; 0x800
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8010c80:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 8010c84:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
 8010c88:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    hdma_adc1.Instance = DMA2_Stream0;
 8010c8c:	602b      	str	r3, [r5, #0]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8010c8e:	2304      	movs	r3, #4
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8010c90:	6128      	str	r0, [r5, #16]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 8010c92:	4628      	mov	r0, r5
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8010c94:	60ac      	str	r4, [r5, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 8010c96:	60ec      	str	r4, [r5, #12]
    hdma_adc1.Init.PeriphBurst = DMA_PBURST_SINGLE;
 8010c98:	632c      	str	r4, [r5, #48]	; 0x30
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
 8010c9a:	f8c5 e004 	str.w	lr, [r5, #4]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8010c9e:	626b      	str	r3, [r5, #36]	; 0x24
    hdma_adc1.Init.MemBurst = DMA_MBURST_SINGLE;
 8010ca0:	e9c5 440a 	strd	r4, r4, [r5, #40]	; 0x28
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8010ca4:	e9c5 c705 	strd	ip, r7, [r5, #20]
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
 8010ca8:	e9c5 1207 	strd	r1, r2, [r5, #28]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 8010cac:	f7f1 fcf0 	bl	8002690 <HAL_DMA_Init>
 8010cb0:	b9f0      	cbnz	r0, 8010cf0 <HAL_ADC_MspInit+0x114>
    pSyncConfig.EventEnable = ENABLE;
 8010cb2:	2301      	movs	r3, #1
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
 8010cb4:	f04f 0806 	mov.w	r8, #6
 8010cb8:	f44f 3900 	mov.w	r9, #131072	; 0x20000
    pSyncConfig.SyncEnable = DISABLE;
 8010cbc:	2200      	movs	r2, #0
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
 8010cbe:	a904      	add	r1, sp, #16
 8010cc0:	4810      	ldr	r0, [pc, #64]	; (8010d04 <HAL_ADC_MspInit+0x128>)
    pSyncConfig.SyncEnable = DISABLE;
 8010cc2:	f88d 2018 	strb.w	r2, [sp, #24]
    pSyncConfig.EventEnable = ENABLE;
 8010cc6:	f88d 3019 	strb.w	r3, [sp, #25]
    pSyncConfig.RequestNumber = 1;
 8010cca:	9307      	str	r3, [sp, #28]
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
 8010ccc:	e9cd 8904 	strd	r8, r9, [sp, #16]
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
 8010cd0:	f7f3 fdee 	bl	80048b0 <HAL_DMAEx_ConfigMuxSync>
 8010cd4:	b978      	cbnz	r0, 8010cf6 <HAL_ADC_MspInit+0x11a>
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
 8010cd6:	2200      	movs	r2, #0
 8010cd8:	2105      	movs	r1, #5
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
 8010cda:	64f5      	str	r5, [r6, #76]	; 0x4c
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
 8010cdc:	2012      	movs	r0, #18
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
 8010cde:	63ae      	str	r6, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
 8010ce0:	f7f1 fb0a 	bl	80022f8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
 8010ce4:	2012      	movs	r0, #18
 8010ce6:	f7f1 fb4d 	bl	8002384 <HAL_NVIC_EnableIRQ>
}
 8010cea:	b00f      	add	sp, #60	; 0x3c
 8010cec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      Error_Handler();
 8010cf0:	f002 fdec 	bl	80138cc <Error_Handler>
 8010cf4:	e7dd      	b.n	8010cb2 <HAL_ADC_MspInit+0xd6>
      Error_Handler();
 8010cf6:	f002 fde9 	bl	80138cc <Error_Handler>
 8010cfa:	e7ec      	b.n	8010cd6 <HAL_ADC_MspInit+0xfa>
 8010cfc:	40022000 	.word	0x40022000
 8010d00:	58024400 	.word	0x58024400
 8010d04:	2000071c 	.word	0x2000071c
 8010d08:	58020800 	.word	0x58020800
 8010d0c:	58020000 	.word	0x58020000
 8010d10:	40020410 	.word	0x40020410

08010d14 <audioFrame>:
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

void audioFrame(uint16_t buffer_offset)
{
 8010d14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010d18:	ed2d 8b04 	vpush	{d8-d9}
 8010d1c:	b087      	sub	sp, #28
 8010d1e:	4681      	mov	r9, r0
	//int32_t current_sample;
	uint32_t clipCatcher = 0;

	//tempCount5 = DWT->CYCCNT;

	buttonCheck();
 8010d20:	f00b ff7c 	bl	801cc1c <buttonCheck>

	adcCheck();
 8010d24:	f00c fb14 	bl	801d350 <adcCheck>

	// if the USB write pointer has advanced (indicating unread data is in the buffer),
	// or the overflow bit is set, meaning that the write pointer wrapped around and the read pointer hasn't caught up to it yet
	// then process that new data this frame
	if ((myUSB_FIFO_overflowBit) || (myUSB_FIFO_writePointer > myUSB_FIFO_readPointer))
 8010d28:	4bbb      	ldr	r3, [pc, #748]	; (8011018 <audioFrame+0x304>)
 8010d2a:	781b      	ldrb	r3, [r3, #0]
 8010d2c:	2b00      	cmp	r3, #0
 8010d2e:	f040 8170 	bne.w	8011012 <audioFrame+0x2fe>
 8010d32:	4bba      	ldr	r3, [pc, #744]	; (801101c <audioFrame+0x308>)
 8010d34:	4aba      	ldr	r2, [pc, #744]	; (8011020 <audioFrame+0x30c>)
 8010d36:	881b      	ldrh	r3, [r3, #0]
 8010d38:	8812      	ldrh	r2, [r2, #0]
 8010d3a:	429a      	cmp	r2, r3
 8010d3c:	f0c0 8169 	bcc.w	8011012 <audioFrame+0x2fe>
	{
		ProcessReceivedMidiDatas();
	}


	if (!loadingPreset)
 8010d40:	4bb8      	ldr	r3, [pc, #736]	; (8011024 <audioFrame+0x310>)
 8010d42:	781b      	ldrb	r3, [r3, #0]
 8010d44:	2b00      	cmp	r3, #0
 8010d46:	d154      	bne.n	8010df2 <audioFrame+0xde>
 8010d48:	4cb7      	ldr	r4, [pc, #732]	; (8011028 <audioFrame+0x314>)
 8010d4a:	f8df 8324 	ldr.w	r8, [pc, #804]	; 8011070 <audioFrame+0x35c>
 8010d4e:	4627      	mov	r7, r4
 8010d50:	f104 0518 	add.w	r5, r4, #24
 8010d54:	f8df b31c 	ldr.w	fp, [pc, #796]	; 8011074 <audioFrame+0x360>
 8010d58:	4eb4      	ldr	r6, [pc, #720]	; (801102c <audioFrame+0x318>)
	{

		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
		{
			smoothedADC[i] = tExpSmooth_tick(&adc[i]);
 8010d5a:	4640      	mov	r0, r8
 8010d5c:	f108 0804 	add.w	r8, r8, #4
 8010d60:	f011 fc18 	bl	8022594 <tExpSmooth_tick>
			for (int i = 0; i < KNOB_PAGE_SIZE; i++)
			{
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
 8010d64:	4bb2      	ldr	r3, [pc, #712]	; (8011030 <audioFrame+0x31c>)
			smoothedADC[i] = tExpSmooth_tick(&adc[i]);
 8010d66:	eca7 0a01 	vstmia	r7!, {s0}
		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
 8010d6a:	42bd      	cmp	r5, r7
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
 8010d6c:	f893 a000 	ldrb.w	sl, [r3]
 8010d70:	f89b 3000 	ldrb.w	r3, [fp]
 8010d74:	eb0a 028a 	add.w	r2, sl, sl, lsl #2
 8010d78:	ed94 7a00 	vldr	s14, [r4]
 8010d7c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8010d80:	edd4 7a01 	vldr	s15, [r4, #4]
 8010d84:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8010d88:	f103 0c01 	add.w	ip, r3, #1
 8010d8c:	f103 0002 	add.w	r0, r3, #2
 8010d90:	eb02 0e03 	add.w	lr, r2, r3
 8010d94:	f103 0103 	add.w	r1, r3, #3
 8010d98:	4494      	add	ip, r2
 8010d9a:	f103 0304 	add.w	r3, r3, #4
 8010d9e:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
 8010da2:	4410      	add	r0, r2
 8010da4:	eb06 0c8c 	add.w	ip, r6, ip, lsl #2
 8010da8:	4411      	add	r1, r2
 8010daa:	ed8e 7a00 	vstr	s14, [lr]
 8010dae:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8010db2:	4413      	add	r3, r2
 8010db4:	f8d4 e008 	ldr.w	lr, [r4, #8]
 8010db8:	edcc 7a00 	vstr	s15, [ip]
 8010dbc:	eb06 0181 	add.w	r1, r6, r1, lsl #2
 8010dc0:	f8c0 e000 	str.w	lr, [r0]
 8010dc4:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8010dc8:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 8010dcc:	6920      	ldr	r0, [r4, #16]
 8010dce:	f8c1 c000 	str.w	ip, [r1]
 8010dd2:	6018      	str	r0, [r3, #0]
		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
 8010dd4:	d1c1      	bne.n	8010d5a <audioFrame+0x46>
			}
		}


		if (cvAddParam[currentPreset] >= 0)
 8010dd6:	4b97      	ldr	r3, [pc, #604]	; (8011034 <audioFrame+0x320>)
 8010dd8:	f913 300a 	ldrsb.w	r3, [r3, sl]
 8010ddc:	2b00      	cmp	r3, #0
 8010dde:	db04      	blt.n	8010dea <audioFrame+0xd6>
		{
			presetKnobValues[currentPreset][cvAddParam[currentPreset]] = smoothedADC[5];
 8010de0:	441a      	add	r2, r3
 8010de2:	6963      	ldr	r3, [r4, #20]
 8010de4:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8010de8:	6013      	str	r3, [r2, #0]
		}

		frameFunctions[currentPreset]();
 8010dea:	4b93      	ldr	r3, [pc, #588]	; (8011038 <audioFrame+0x324>)
 8010dec:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
 8010df0:	4798      	blx	r3
	//if the codec isn't ready, keep the buffer as all zeros
	//otherwise, start computing audio!

	bufferCleared = TRUE;

	if (codecReady)
 8010df2:	4a92      	ldr	r2, [pc, #584]	; (801103c <audioFrame+0x328>)
	bufferCleared = TRUE;
 8010df4:	2301      	movs	r3, #1
 8010df6:	4992      	ldr	r1, [pc, #584]	; (8011040 <audioFrame+0x32c>)
	if (codecReady)
 8010df8:	6812      	ldr	r2, [r2, #0]
	bufferCleared = TRUE;
 8010dfa:	700b      	strb	r3, [r1, #0]
	if (codecReady)
 8010dfc:	9201      	str	r2, [sp, #4]
 8010dfe:	2a00      	cmp	r2, #0
 8010e00:	f000 813e 	beq.w	8011080 <audioFrame+0x36c>
 8010e04:	eb09 0403 	add.w	r4, r9, r3
	uint32_t clipCatcher = 0;
 8010e08:	2500      	movs	r5, #0
 8010e0a:	f8df 826c 	ldr.w	r8, [pc, #620]	; 8011078 <audioFrame+0x364>
 8010e0e:	4b85      	ldr	r3, [pc, #532]	; (8011024 <audioFrame+0x310>)
 8010e10:	00a4      	lsls	r4, r4, #2
 8010e12:	9501      	str	r5, [sp, #4]
 8010e14:	f508 6b00 	add.w	fp, r8, #2048	; 0x800
 8010e18:	7819      	ldrb	r1, [r3, #0]
	{

		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
		{
			float theSamples[2];
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8010e1a:	ed9f 8a8a 	vldr	s16, [pc, #552]	; 8011044 <audioFrame+0x330>
	//uint32_t tempCount5 = DWT->CYCCNT;

	//cycleCountVals[1][2] = 0;


	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8010e1e:	eddf 9a8a 	vldr	s19, [pc, #552]	; 8011048 <audioFrame+0x334>
 8010e22:	ed9f 9a8a 	vldr	s18, [pc, #552]	; 801104c <audioFrame+0x338>
	{
		clips |= 2;
	}


	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010e26:	eddf 8a8a 	vldr	s17, [pc, #552]	; 8011050 <audioFrame+0x33c>
 8010e2a:	e00b      	b.n	8010e44 <audioFrame+0x130>
	if (loadingPreset)
 8010e2c:	2300      	movs	r3, #0
 8010e2e:	461a      	mov	r2, r3
		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
 8010e30:	3502      	adds	r5, #2
			audioOutBuffer[buffer_offset + i] = (int32_t)(theSamples[1] * TWO_TO_23);
 8010e32:	f84b 2026 	str.w	r2, [fp, r6, lsl #2]
			audioOutBuffer[buffer_offset + i + 1] = (int32_t)(theSamples[0] * TWO_TO_23);
 8010e36:	f84b 3004 	str.w	r3, [fp, r4]
 8010e3a:	3408      	adds	r4, #8
		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
 8010e3c:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8010e40:	f000 8167 	beq.w	8011112 <audioFrame+0x3fe>
 8010e44:	eb05 0609 	add.w	r6, r5, r9
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8010e48:	f858 2004 	ldr.w	r2, [r8, r4]
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8010e4c:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8010e50:	0212      	lsls	r2, r2, #8
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8010e52:	021b      	lsls	r3, r3, #8
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8010e54:	ee00 2a90 	vmov	s1, r2
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8010e58:	ee07 3a90 	vmov	s15, r3
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8010e5c:	eef8 0ae0 	vcvt.f32.s32	s1, s1
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8010e60:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8010e64:	ee60 0a88 	vmul.f32	s1, s1, s16
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8010e68:	ee67 7a88 	vmul.f32	s15, s15, s16
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8010e6c:	edcd 0a05 	vstr	s1, [sp, #20]
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8010e70:	edcd 7a04 	vstr	s15, [sp, #16]
	if (loadingPreset)
 8010e74:	2900      	cmp	r1, #0
 8010e76:	d1d9      	bne.n	8010e2c <audioFrame+0x118>
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8010e78:	eef4 0ae9 	vcmpe.f32	s1, s19
 8010e7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010e80:	eef4 0ac9 	vcmpe.f32	s1, s18
 8010e84:	bf94      	ite	ls
 8010e86:	2201      	movls	r2, #1
 8010e88:	2200      	movhi	r2, #0
 8010e8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
 8010e8e:	eef4 7ac9 	vcmpe.f32	s15, s18
	uint32_t clips = 0;
 8010e92:	bfa8      	it	ge
 8010e94:	f042 0201 	orrge.w	r2, r2, #1
	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
 8010e98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010e9c:	da04      	bge.n	8010ea8 <audioFrame+0x194>
 8010e9e:	eef4 7a69 	vcmp.f32	s15, s19
 8010ea2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010ea6:	d801      	bhi.n	8010eac <audioFrame+0x198>
		clips |= 2;
 8010ea8:	f042 0202 	orr.w	r2, r2, #2
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010eac:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8010eb0:	9203      	str	r2, [sp, #12]
 8010eb2:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8010eb6:	4f67      	ldr	r7, [pc, #412]	; (8011054 <audioFrame+0x340>)
 8010eb8:	f012 fffc 	bl	8023eb4 <LEAF_clip>
 8010ebc:	4866      	ldr	r0, [pc, #408]	; (8011058 <audioFrame+0x344>)
 8010ebe:	f00d fd37 	bl	801e930 <tEnvelopeFollower_tick>
 8010ec2:	ee20 0a28 	vmul.f32	s0, s0, s17
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
 8010ec6:	4865      	ldr	r0, [pc, #404]	; (801105c <audioFrame+0x348>)
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010ec8:	a904      	add	r1, sp, #16
 8010eca:	eddd 0a04 	vldr	s1, [sp, #16]
 8010ece:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010ed2:	eefc 7ac0 	vcvt.u32.f32	s15, s0
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
 8010ed6:	6800      	ldr	r0, [r0, #0]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010ed8:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8010edc:	9102      	str	r1, [sp, #8]
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
 8010ede:	f8df a19c 	ldr.w	sl, [pc, #412]	; 801107c <audioFrame+0x368>
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010ee2:	ee17 3a90 	vmov	r3, s15
 8010ee6:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8010eea:	edd3 7a00 	vldr	s15, [r3]
 8010eee:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
 8010ef2:	ee17 3a90 	vmov	r3, s15
 8010ef6:	b29b      	uxth	r3, r3
 8010ef8:	6383      	str	r3, [r0, #56]	; 0x38
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010efa:	f012 ffdb 	bl	8023eb4 <LEAF_clip>
 8010efe:	4858      	ldr	r0, [pc, #352]	; (8011060 <audioFrame+0x34c>)
 8010f00:	f00d fd16 	bl	801e930 <tEnvelopeFollower_tick>
 8010f04:	ee20 0a28 	vmul.f32	s0, s0, s17

	tickFunctions[currentPreset](samples);
 8010f08:	9902      	ldr	r1, [sp, #8]
 8010f0a:	4b49      	ldr	r3, [pc, #292]	; (8011030 <audioFrame+0x31c>)
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010f0c:	eefc 7ac0 	vcvt.u32.f32	s15, s0
	tickFunctions[currentPreset](samples);
 8010f10:	4608      	mov	r0, r1
 8010f12:	f893 e000 	ldrb.w	lr, [r3]
 8010f16:	4b53      	ldr	r3, [pc, #332]	; (8011064 <audioFrame+0x350>)
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010f18:	ee17 1a90 	vmov	r1, s15
 8010f1c:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8010f20:	edd1 7a00 	vldr	s15, [r1]
 8010f24:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
 8010f28:	ee17 2a90 	vmov	r2, s15
 8010f2c:	b291      	uxth	r1, r2
 8010f2e:	f8da 2000 	ldr.w	r2, [sl]
 8010f32:	6391      	str	r1, [r2, #56]	; 0x38
	tickFunctions[currentPreset](samples);
 8010f34:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
 8010f38:	4798      	blx	r3

	//now the samples array is output
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8010f3a:	eddd 0a05 	vldr	s1, [sp, #20]
 8010f3e:	9a03      	ldr	r2, [sp, #12]
 8010f40:	eef4 0ac9 	vcmpe.f32	s1, s18
 8010f44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010f48:	da04      	bge.n	8010f54 <audioFrame+0x240>
 8010f4a:	eef4 0a69 	vcmp.f32	s1, s19
 8010f4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010f52:	d801      	bhi.n	8010f58 <audioFrame+0x244>
	{
		clips |= 4;
 8010f54:	f042 0204 	orr.w	r2, r2, #4
	}

	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
 8010f58:	eddd 7a04 	vldr	s15, [sp, #16]
 8010f5c:	eef4 7ae9 	vcmpe.f32	s15, s19
 8010f60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010f64:	d904      	bls.n	8010f70 <audioFrame+0x25c>
 8010f66:	eef4 7a49 	vcmp.f32	s15, s18
 8010f6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010f6e:	db01      	blt.n	8010f74 <audioFrame+0x260>
	{
		clips |= 8;
 8010f70:	f042 0208 	orr.w	r2, r2, #8
 8010f74:	9b01      	ldr	r3, [sp, #4]
	}
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[1], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010f76:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8010f7a:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8010f7e:	4313      	orrs	r3, r2
 8010f80:	9301      	str	r3, [sp, #4]
 8010f82:	f012 ff97 	bl	8023eb4 <LEAF_clip>
 8010f86:	4838      	ldr	r0, [pc, #224]	; (8011068 <audioFrame+0x354>)
 8010f88:	f00d fcd2 	bl	801e930 <tEnvelopeFollower_tick>
 8010f8c:	ee60 7a28 	vmul.f32	s15, s0, s17
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, current_env);
 8010f90:	f8da 3000 	ldr.w	r3, [sl]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010f94:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8010f98:	eddd 0a04 	vldr	s1, [sp, #16]
 8010f9c:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[1], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010fa0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8010fa4:	ee17 2a90 	vmov	r2, s15
 8010fa8:	eb07 0282 	add.w	r2, r7, r2, lsl #2
 8010fac:	edd2 7a00 	vldr	s15, [r2]
 8010fb0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, current_env);
 8010fb4:	ee17 2a90 	vmov	r2, s15
 8010fb8:	b292      	uxth	r2, r2
 8010fba:	63da      	str	r2, [r3, #60]	; 0x3c
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010fbc:	f012 ff7a 	bl	8023eb4 <LEAF_clip>
 8010fc0:	482a      	ldr	r0, [pc, #168]	; (801106c <audioFrame+0x358>)
 8010fc2:	f00d fcb5 	bl	801e930 <tEnvelopeFollower_tick>
 8010fc6:	ee20 0a28 	vmul.f32	s0, s0, s17
 8010fca:	4b16      	ldr	r3, [pc, #88]	; (8011024 <audioFrame+0x310>)
 8010fcc:	ed9d 7a05 	vldr	s14, [sp, #20]
 8010fd0:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 8010fd4:	7819      	ldrb	r1, [r3, #0]
 8010fd6:	eddd 7a04 	vldr	s15, [sp, #16]
 8010fda:	eef0 6a47 	vmov.f32	s13, s14
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, current_env);
 8010fde:	f8da c000 	ldr.w	ip, [sl]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8010fe2:	ee10 3a10 	vmov	r3, s0
 8010fe6:	eeb0 7a67 	vmov.f32	s14, s15
 8010fea:	eefe 6ae4 	vcvt.s32.f32	s13, s13, #23
 8010fee:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 8010ff2:	eebe 7ae4 	vcvt.s32.f32	s14, s14, #23
 8010ff6:	edd7 7a00 	vldr	s15, [r7]
 8010ffa:	ee16 2a90 	vmov	r2, s13
 8010ffe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8011002:	ee17 3a10 	vmov	r3, s14
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, current_env);
 8011006:	ee17 0a90 	vmov	r0, s15
 801100a:	b280      	uxth	r0, r0
 801100c:	f8cc 0034 	str.w	r0, [ip, #52]	; 0x34
 8011010:	e70e      	b.n	8010e30 <audioFrame+0x11c>
		ProcessReceivedMidiDatas();
 8011012:	f7ff fcb9 	bl	8010988 <ProcessReceivedMidiDatas>
 8011016:	e693      	b.n	8010d40 <audioFrame+0x2c>
 8011018:	2000066d 	.word	0x2000066d
 801101c:	20000670 	.word	0x20000670
 8011020:	2000066e 	.word	0x2000066e
 8011024:	2000066b 	.word	0x2000066b
 8011028:	2001886c 	.word	0x2001886c
 801102c:	20002cb8 	.word	0x20002cb8
 8011030:	20000669 	.word	0x20000669
 8011034:	20018980 	.word	0x20018980
 8011038:	20000880 	.word	0x20000880
 801103c:	20000508 	.word	0x20000508
 8011040:	2000000c 	.word	0x2000000c
 8011044:	2ffffff6 	.word	0x2ffffff6
 8011048:	bf7fffef 	.word	0xbf7fffef
 801104c:	3f7fffef 	.word	0x3f7fffef
 8011050:	43ff8000 	.word	0x43ff8000
 8011054:	200008d8 	.word	0x200008d8
 8011058:	200008c8 	.word	0x200008c8
 801105c:	200186c8 	.word	0x200186c8
 8011060:	200008d0 	.word	0x200008d0
 8011064:	2000079c 	.word	0x2000079c
 8011068:	200008cc 	.word	0x200008cc
 801106c:	200008d4 	.word	0x200008d4
 8011070:	20018840 	.word	0x20018840
 8011074:	2000066a 	.word	0x2000066a
 8011078:	30000080 	.word	0x30000080
 801107c:	20018688 	.word	0x20018688
		numBuffersCleared++;
 8011080:	4a4c      	ldr	r2, [pc, #304]	; (80111b4 <audioFrame+0x4a0>)
		if (numBuffersCleared >= numBuffersToClearOnLoad)
 8011082:	494d      	ldr	r1, [pc, #308]	; (80111b8 <audioFrame+0x4a4>)
		numBuffersCleared++;
 8011084:	6813      	ldr	r3, [r2, #0]
		if (numBuffersCleared >= numBuffersToClearOnLoad)
 8011086:	6809      	ldr	r1, [r1, #0]
		numBuffersCleared++;
 8011088:	3301      	adds	r3, #1
		if (numBuffersCleared >= numBuffersToClearOnLoad)
 801108a:	428b      	cmp	r3, r1
		numBuffersCleared++;
 801108c:	6013      	str	r3, [r2, #0]
		if (numBuffersCleared >= numBuffersToClearOnLoad)
 801108e:	da4a      	bge.n	8011126 <audioFrame+0x412>
	if (loadingPreset)
 8011090:	2400      	movs	r4, #0
 8011092:	4d4a      	ldr	r5, [pc, #296]	; (80111bc <audioFrame+0x4a8>)
 8011094:	f8df 814c 	ldr.w	r8, [pc, #332]	; 80111e4 <audioFrame+0x4d0>
			clipCounter[i] = 80;
 8011098:	2750      	movs	r7, #80	; 0x50
			clipHappened[i] = 0;
 801109a:	4e49      	ldr	r6, [pc, #292]	; (80111c0 <audioFrame+0x4ac>)
 801109c:	f8dd 9004 	ldr.w	r9, [sp, #4]
		if ((clipCatcher >> i) & 1)
 80110a0:	fa29 f304 	lsr.w	r3, r9, r4
 80110a4:	07db      	lsls	r3, r3, #31
 80110a6:	d51e      	bpl.n	80110e6 <audioFrame+0x3d2>
			switch (i)
 80110a8:	2c02      	cmp	r4, #2
 80110aa:	d072      	beq.n	8011192 <audioFrame+0x47e>
 80110ac:	2c03      	cmp	r4, #3
 80110ae:	d06c      	beq.n	801118a <audioFrame+0x476>
 80110b0:	2c01      	cmp	r4, #1
 80110b2:	d066      	beq.n	8011182 <audioFrame+0x46e>
					setLED_leftin_clip(1);
 80110b4:	2001      	movs	r0, #1
 80110b6:	f002 fc91 	bl	80139dc <setLED_leftin_clip>
			clipped[i] = 1;
 80110ba:	2201      	movs	r2, #1
			clipHappened[i] = 0;
 80110bc:	2300      	movs	r3, #0
 80110be:	ea4f 0a84 	mov.w	sl, r4, lsl #2
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
 80110c2:	2050      	movs	r0, #80	; 0x50
			clipCounter[i] = 80;
 80110c4:	f845 7024 	str.w	r7, [r5, r4, lsl #2]
			clipped[i] = 1;
 80110c8:	f848 2024 	str.w	r2, [r8, r4, lsl #2]
			clipHappened[i] = 0;
 80110cc:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
			clipCounter[i]--;
 80110d0:	3801      	subs	r0, #1
 80110d2:	f845 000a 	str.w	r0, [r5, sl]
	for (int i = 0; i < 4; i++)
 80110d6:	3401      	adds	r4, #1
 80110d8:	2c04      	cmp	r4, #4
 80110da:	d1e1      	bne.n	80110a0 <audioFrame+0x38c>
}
 80110dc:	b007      	add	sp, #28
 80110de:	ecbd 8b04 	vpop	{d8-d9}
 80110e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
 80110e6:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 80110ea:	ea4f 0a84 	mov.w	sl, r4, lsl #2
 80110ee:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 80110f2:	2800      	cmp	r0, #0
 80110f4:	d15a      	bne.n	80111ac <audioFrame+0x498>
		else if ((clipCounter[i] == 0) && (clipped[i] == 1))
 80110f6:	2b01      	cmp	r3, #1
 80110f8:	d1ed      	bne.n	80110d6 <audioFrame+0x3c2>
			switch (i)
 80110fa:	2c02      	cmp	r4, #2
 80110fc:	d04d      	beq.n	801119a <audioFrame+0x486>
 80110fe:	2c03      	cmp	r4, #3
 8011100:	d051      	beq.n	80111a6 <audioFrame+0x492>
 8011102:	2c01      	cmp	r4, #1
 8011104:	d04c      	beq.n	80111a0 <audioFrame+0x48c>
					setLED_leftin_clip(0);
 8011106:	f002 fc69 	bl	80139dc <setLED_leftin_clip>
			clipped[i] = 0;
 801110a:	2300      	movs	r3, #0
 801110c:	f848 300a 	str.w	r3, [r8, sl]
 8011110:	e7e1      	b.n	80110d6 <audioFrame+0x3c2>
			bufferCleared = 0;
 8011112:	4b2c      	ldr	r3, [pc, #176]	; (80111c4 <audioFrame+0x4b0>)
		if (!loadingPreset)
 8011114:	2900      	cmp	r1, #0
 8011116:	d032      	beq.n	801117e <audioFrame+0x46a>
	if (bufferCleared)
 8011118:	781b      	ldrb	r3, [r3, #0]
 801111a:	2b00      	cmp	r3, #0
 801111c:	d1b0      	bne.n	8011080 <audioFrame+0x36c>
	else numBuffersCleared = 0;
 801111e:	4b25      	ldr	r3, [pc, #148]	; (80111b4 <audioFrame+0x4a0>)
 8011120:	2200      	movs	r2, #0
 8011122:	601a      	str	r2, [r3, #0]
 8011124:	e7b4      	b.n	8011090 <audioFrame+0x37c>
			if (loadingPreset)
 8011126:	4b28      	ldr	r3, [pc, #160]	; (80111c8 <audioFrame+0x4b4>)
			numBuffersCleared = numBuffersToClearOnLoad;
 8011128:	6011      	str	r1, [r2, #0]
			if (loadingPreset)
 801112a:	781b      	ldrb	r3, [r3, #0]
 801112c:	2b00      	cmp	r3, #0
 801112e:	d0af      	beq.n	8011090 <audioFrame+0x37c>
				if (previousPreset != PresetNil)
 8011130:	4b26      	ldr	r3, [pc, #152]	; (80111cc <audioFrame+0x4b8>)
 8011132:	781b      	ldrb	r3, [r3, #0]
 8011134:	2b12      	cmp	r3, #18
 8011136:	d003      	beq.n	8011140 <audioFrame+0x42c>
					freeFunctions[previousPreset]();
 8011138:	4a25      	ldr	r2, [pc, #148]	; (80111d0 <audioFrame+0x4bc>)
 801113a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801113e:	4798      	blx	r3
				setLED_A(0);
 8011140:	2000      	movs	r0, #0
				knobPage = 0;
 8011142:	4604      	mov	r4, r0
				setLED_A(0);
 8011144:	f002 fc02 	bl	801394c <setLED_A>
				setLED_B(0);
 8011148:	4620      	mov	r0, r4
 801114a:	f002 fc0d 	bl	8013968 <setLED_B>
				setLED_C(0);
 801114e:	4620      	mov	r0, r4
 8011150:	f002 fc18 	bl	8013984 <setLED_C>
				setLED_Edit(0);
 8011154:	4620      	mov	r0, r4
 8011156:	f002 fbbd 	bl	80138d4 <setLED_Edit>
				setLED_1(0);
 801115a:	4620      	mov	r0, r4
 801115c:	f002 fbd6 	bl	801390c <setLED_1>
				knobPage = 0;
 8011160:	4b1c      	ldr	r3, [pc, #112]	; (80111d4 <audioFrame+0x4c0>)
 8011162:	701c      	strb	r4, [r3, #0]
				resetKnobValues();
 8011164:	f00c f9f4 	bl	801d550 <resetKnobValues>
				allocFunctions[currentPreset]();
 8011168:	4b1b      	ldr	r3, [pc, #108]	; (80111d8 <audioFrame+0x4c4>)
				leaf.clearOnAllocation = 0;
 801116a:	491c      	ldr	r1, [pc, #112]	; (80111dc <audioFrame+0x4c8>)
				allocFunctions[currentPreset]();
 801116c:	781a      	ldrb	r2, [r3, #0]
 801116e:	4b1c      	ldr	r3, [pc, #112]	; (80111e0 <audioFrame+0x4cc>)
				leaf.clearOnAllocation = 0;
 8011170:	614c      	str	r4, [r1, #20]
				allocFunctions[currentPreset]();
 8011172:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011176:	4798      	blx	r3
				loadingPreset = 0;
 8011178:	4b13      	ldr	r3, [pc, #76]	; (80111c8 <audioFrame+0x4b4>)
 801117a:	701c      	strb	r4, [r3, #0]
 801117c:	e788      	b.n	8011090 <audioFrame+0x37c>
			bufferCleared = 0;
 801117e:	7019      	strb	r1, [r3, #0]
 8011180:	e7cd      	b.n	801111e <audioFrame+0x40a>
					setLED_rightin_clip(1);
 8011182:	4620      	mov	r0, r4
 8011184:	f002 fc38 	bl	80139f8 <setLED_rightin_clip>
					break;
 8011188:	e797      	b.n	80110ba <audioFrame+0x3a6>
					setLED_rightout_clip(1);
 801118a:	2001      	movs	r0, #1
 801118c:	f002 fc18 	bl	80139c0 <setLED_rightout_clip>
					break;
 8011190:	e793      	b.n	80110ba <audioFrame+0x3a6>
					setLED_leftout_clip(1);
 8011192:	2001      	movs	r0, #1
 8011194:	f002 fc06 	bl	80139a4 <setLED_leftout_clip>
					break;
 8011198:	e78f      	b.n	80110ba <audioFrame+0x3a6>
					setLED_leftout_clip(0);
 801119a:	f002 fc03 	bl	80139a4 <setLED_leftout_clip>
					break;
 801119e:	e7b4      	b.n	801110a <audioFrame+0x3f6>
					setLED_rightin_clip(0);
 80111a0:	f002 fc2a 	bl	80139f8 <setLED_rightin_clip>
					break;
 80111a4:	e7b1      	b.n	801110a <audioFrame+0x3f6>
					setLED_rightout_clip(0);
 80111a6:	f002 fc0b 	bl	80139c0 <setLED_rightout_clip>
					break;
 80111aa:	e7ae      	b.n	801110a <audioFrame+0x3f6>
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
 80111ac:	2b01      	cmp	r3, #1
 80111ae:	d192      	bne.n	80110d6 <audioFrame+0x3c2>
 80111b0:	e78e      	b.n	80110d0 <audioFrame+0x3bc>
 80111b2:	bf00      	nop
 80111b4:	2000050c 	.word	0x2000050c
 80111b8:	20000010 	.word	0x20000010
 80111bc:	200004d8 	.word	0x200004d8
 80111c0:	200004e8 	.word	0x200004e8
 80111c4:	2000000c 	.word	0x2000000c
 80111c8:	2000066b 	.word	0x2000066b
 80111cc:	200002d8 	.word	0x200002d8
 80111d0:	200007e8 	.word	0x200007e8
 80111d4:	2000066a 	.word	0x2000066a
 80111d8:	20000669 	.word	0x20000669
 80111dc:	200194e8 	.word	0x200194e8
 80111e0:	20000834 	.word	0x20000834
 80111e4:	200004f8 	.word	0x200004f8

080111e8 <initFunctionPointers>:
}

*/

void initFunctionPointers(void)
{
 80111e8:	b430      	push	{r4, r5}
	allocFunctions[Vocoder] = SFXVocoderAlloc;
 80111ea:	484b      	ldr	r0, [pc, #300]	; (8011318 <initFunctionPointers+0x130>)
 80111ec:	4c4b      	ldr	r4, [pc, #300]	; (801131c <initFunctionPointers+0x134>)
	frameFunctions[Vocoder] = SFXVocoderFrame;
	tickFunctions[Vocoder] = SFXVocoderTick;
	freeFunctions[Vocoder] = SFXVocoderFree;

	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
 80111ee:	4d4c      	ldr	r5, [pc, #304]	; (8011320 <initFunctionPointers+0x138>)
	allocFunctions[Vocoder] = SFXVocoderAlloc;
 80111f0:	6004      	str	r4, [r0, #0]
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
	tickFunctions[VocoderCh] = SFXVocoderChTick;
	freeFunctions[VocoderCh] = SFXVocoderChFree;

	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
 80111f2:	4b4c      	ldr	r3, [pc, #304]	; (8011324 <initFunctionPointers+0x13c>)
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
	freeFunctions[Pitchshift] = SFXPitchShiftFree;

	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
 80111f4:	494c      	ldr	r1, [pc, #304]	; (8011328 <initFunctionPointers+0x140>)
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
	freeFunctions[AutotuneMono] = SFXNeartuneFree;

	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
 80111f6:	4a4d      	ldr	r2, [pc, #308]	; (801132c <initFunctionPointers+0x144>)
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
	freeFunctions[AutotunePoly] = SFXAutotuneFree;

	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
 80111f8:	4c4d      	ldr	r4, [pc, #308]	; (8011330 <initFunctionPointers+0x148>)
	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
 80111fa:	6045      	str	r5, [r0, #4]
	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
 80111fc:	6083      	str	r3, [r0, #8]
	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
 80111fe:	60c1      	str	r1, [r0, #12]
	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
 8011200:	6102      	str	r2, [r0, #16]
	frameFunctions[Vocoder] = SFXVocoderFrame;
 8011202:	494c      	ldr	r1, [pc, #304]	; (8011334 <initFunctionPointers+0x14c>)
	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
 8011204:	6144      	str	r4, [r0, #20]
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;

	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
 8011206:	4d4c      	ldr	r5, [pc, #304]	; (8011338 <initFunctionPointers+0x150>)
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;

	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
 8011208:	4b4c      	ldr	r3, [pc, #304]	; (801133c <initFunctionPointers+0x154>)
	frameFunctions[Vocoder] = SFXVocoderFrame;
 801120a:	4a4d      	ldr	r2, [pc, #308]	; (8011340 <initFunctionPointers+0x158>)
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
 801120c:	4c4d      	ldr	r4, [pc, #308]	; (8011344 <initFunctionPointers+0x15c>)
	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
 801120e:	6185      	str	r5, [r0, #24]
	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
 8011210:	61c3      	str	r3, [r0, #28]
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
 8011212:	4d4d      	ldr	r5, [pc, #308]	; (8011348 <initFunctionPointers+0x160>)
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
 8011214:	4b4d      	ldr	r3, [pc, #308]	; (801134c <initFunctionPointers+0x164>)
	frameFunctions[Vocoder] = SFXVocoderFrame;
 8011216:	600a      	str	r2, [r1, #0]
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
 8011218:	604c      	str	r4, [r1, #4]
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
 801121a:	4a4d      	ldr	r2, [pc, #308]	; (8011350 <initFunctionPointers+0x168>)
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
 801121c:	4c4d      	ldr	r4, [pc, #308]	; (8011354 <initFunctionPointers+0x16c>)
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
 801121e:	608d      	str	r5, [r1, #8]
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
 8011220:	60cb      	str	r3, [r1, #12]
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
 8011222:	4d4d      	ldr	r5, [pc, #308]	; (8011358 <initFunctionPointers+0x170>)
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
 8011224:	4b4d      	ldr	r3, [pc, #308]	; (801135c <initFunctionPointers+0x174>)
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
 8011226:	610a      	str	r2, [r1, #16]
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
 8011228:	614c      	str	r4, [r1, #20]
	tickFunctions[Vocoder] = SFXVocoderTick;
 801122a:	4a4d      	ldr	r2, [pc, #308]	; (8011360 <initFunctionPointers+0x178>)
 801122c:	4c4d      	ldr	r4, [pc, #308]	; (8011364 <initFunctionPointers+0x17c>)
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
 801122e:	618d      	str	r5, [r1, #24]
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
 8011230:	61cb      	str	r3, [r1, #28]
	tickFunctions[VocoderCh] = SFXVocoderChTick;
 8011232:	4d4d      	ldr	r5, [pc, #308]	; (8011368 <initFunctionPointers+0x180>)
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
 8011234:	4b4d      	ldr	r3, [pc, #308]	; (801136c <initFunctionPointers+0x184>)
	tickFunctions[Vocoder] = SFXVocoderTick;
 8011236:	6014      	str	r4, [r2, #0]
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
 8011238:	4c4d      	ldr	r4, [pc, #308]	; (8011370 <initFunctionPointers+0x188>)
	tickFunctions[VocoderCh] = SFXVocoderChTick;
 801123a:	6055      	str	r5, [r2, #4]
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
 801123c:	6093      	str	r3, [r2, #8]
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
 801123e:	4d4d      	ldr	r5, [pc, #308]	; (8011374 <initFunctionPointers+0x18c>)
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
 8011240:	4b4d      	ldr	r3, [pc, #308]	; (8011378 <initFunctionPointers+0x190>)
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
 8011242:	60d4      	str	r4, [r2, #12]
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
 8011244:	4c4d      	ldr	r4, [pc, #308]	; (801137c <initFunctionPointers+0x194>)
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
 8011246:	6115      	str	r5, [r2, #16]
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
 8011248:	6153      	str	r3, [r2, #20]
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
 801124a:	4d4d      	ldr	r5, [pc, #308]	; (8011380 <initFunctionPointers+0x198>)
	freeFunctions[Vocoder] = SFXVocoderFree;
 801124c:	4b4d      	ldr	r3, [pc, #308]	; (8011384 <initFunctionPointers+0x19c>)
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
 801124e:	6194      	str	r4, [r2, #24]
	freeFunctions[Vocoder] = SFXVocoderFree;
 8011250:	4c4d      	ldr	r4, [pc, #308]	; (8011388 <initFunctionPointers+0x1a0>)
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
 8011252:	61d5      	str	r5, [r2, #28]
	freeFunctions[Vocoder] = SFXVocoderFree;
 8011254:	601c      	str	r4, [r3, #0]
	freeFunctions[VocoderCh] = SFXVocoderChFree;
 8011256:	4d4d      	ldr	r5, [pc, #308]	; (801138c <initFunctionPointers+0x1a4>)
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
 8011258:	4c4d      	ldr	r4, [pc, #308]	; (8011390 <initFunctionPointers+0x1a8>)
	freeFunctions[VocoderCh] = SFXVocoderChFree;
 801125a:	605d      	str	r5, [r3, #4]
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
 801125c:	609c      	str	r4, [r3, #8]
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
 801125e:	4d4d      	ldr	r5, [pc, #308]	; (8011394 <initFunctionPointers+0x1ac>)
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
 8011260:	4c4d      	ldr	r4, [pc, #308]	; (8011398 <initFunctionPointers+0x1b0>)
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
 8011262:	60dd      	str	r5, [r3, #12]
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
 8011264:	611c      	str	r4, [r3, #16]
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
 8011266:	4d4d      	ldr	r5, [pc, #308]	; (801139c <initFunctionPointers+0x1b4>)
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
 8011268:	4c4d      	ldr	r4, [pc, #308]	; (80113a0 <initFunctionPointers+0x1b8>)
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
 801126a:	615d      	str	r5, [r3, #20]
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
 801126c:	619c      	str	r4, [r3, #24]
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
 801126e:	4d4d      	ldr	r5, [pc, #308]	; (80113a4 <initFunctionPointers+0x1bc>)

	allocFunctions[Distortion] = SFXDistortionAlloc;
 8011270:	4c4d      	ldr	r4, [pc, #308]	; (80113a8 <initFunctionPointers+0x1c0>)
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
 8011272:	61dd      	str	r5, [r3, #28]
	allocFunctions[Distortion] = SFXDistortionAlloc;
 8011274:	6204      	str	r4, [r0, #32]
	frameFunctions[Distortion] = SFXDistortionFrame;
 8011276:	4d4d      	ldr	r5, [pc, #308]	; (80113ac <initFunctionPointers+0x1c4>)
	tickFunctions[Distortion] = SFXDistortionTick;
 8011278:	4c4d      	ldr	r4, [pc, #308]	; (80113b0 <initFunctionPointers+0x1c8>)
	frameFunctions[Distortion] = SFXDistortionFrame;
 801127a:	620d      	str	r5, [r1, #32]
	tickFunctions[Distortion] = SFXDistortionTick;
 801127c:	6214      	str	r4, [r2, #32]
	freeFunctions[Distortion] = SFXDistortionFree;
 801127e:	4d4d      	ldr	r5, [pc, #308]	; (80113b4 <initFunctionPointers+0x1cc>)

	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
 8011280:	4c4d      	ldr	r4, [pc, #308]	; (80113b8 <initFunctionPointers+0x1d0>)
	freeFunctions[Distortion] = SFXDistortionFree;
 8011282:	621d      	str	r5, [r3, #32]
	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
 8011284:	6244      	str	r4, [r0, #36]	; 0x24
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
 8011286:	4d4d      	ldr	r5, [pc, #308]	; (80113bc <initFunctionPointers+0x1d4>)
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
 8011288:	4c4d      	ldr	r4, [pc, #308]	; (80113c0 <initFunctionPointers+0x1d8>)
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
 801128a:	624d      	str	r5, [r1, #36]	; 0x24
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
 801128c:	6254      	str	r4, [r2, #36]	; 0x24
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
 801128e:	4d4d      	ldr	r5, [pc, #308]	; (80113c4 <initFunctionPointers+0x1dc>)

	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
 8011290:	4c4d      	ldr	r4, [pc, #308]	; (80113c8 <initFunctionPointers+0x1e0>)
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
 8011292:	625d      	str	r5, [r3, #36]	; 0x24
	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
 8011294:	6284      	str	r4, [r0, #40]	; 0x28
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
 8011296:	4d4d      	ldr	r5, [pc, #308]	; (80113cc <initFunctionPointers+0x1e4>)
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
 8011298:	4c4d      	ldr	r4, [pc, #308]	; (80113d0 <initFunctionPointers+0x1e8>)
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
 801129a:	628d      	str	r5, [r1, #40]	; 0x28
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
 801129c:	6294      	str	r4, [r2, #40]	; 0x28
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
 801129e:	4d4d      	ldr	r5, [pc, #308]	; (80113d4 <initFunctionPointers+0x1ec>)

	allocFunctions[Delay] = SFXDelayAlloc;
 80112a0:	4c4d      	ldr	r4, [pc, #308]	; (80113d8 <initFunctionPointers+0x1f0>)
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
 80112a2:	629d      	str	r5, [r3, #40]	; 0x28
	allocFunctions[Delay] = SFXDelayAlloc;
 80112a4:	62c4      	str	r4, [r0, #44]	; 0x2c
	frameFunctions[Delay] = SFXDelayFrame;
 80112a6:	4d4d      	ldr	r5, [pc, #308]	; (80113dc <initFunctionPointers+0x1f4>)
	tickFunctions[Delay] = SFXDelayTick;
 80112a8:	4c4d      	ldr	r4, [pc, #308]	; (80113e0 <initFunctionPointers+0x1f8>)
	frameFunctions[Delay] = SFXDelayFrame;
 80112aa:	62cd      	str	r5, [r1, #44]	; 0x2c
	tickFunctions[Delay] = SFXDelayTick;
 80112ac:	62d4      	str	r4, [r2, #44]	; 0x2c
	freeFunctions[Delay] = SFXDelayFree;
 80112ae:	4d4d      	ldr	r5, [pc, #308]	; (80113e4 <initFunctionPointers+0x1fc>)

	allocFunctions[Reverb] = SFXReverbAlloc;
 80112b0:	4c4d      	ldr	r4, [pc, #308]	; (80113e8 <initFunctionPointers+0x200>)
	freeFunctions[Delay] = SFXDelayFree;
 80112b2:	62dd      	str	r5, [r3, #44]	; 0x2c
	allocFunctions[Reverb] = SFXReverbAlloc;
 80112b4:	6304      	str	r4, [r0, #48]	; 0x30
	frameFunctions[Reverb] = SFXReverbFrame;
 80112b6:	4d4d      	ldr	r5, [pc, #308]	; (80113ec <initFunctionPointers+0x204>)
	tickFunctions[Reverb] = SFXReverbTick;
 80112b8:	4c4d      	ldr	r4, [pc, #308]	; (80113f0 <initFunctionPointers+0x208>)
	frameFunctions[Reverb] = SFXReverbFrame;
 80112ba:	630d      	str	r5, [r1, #48]	; 0x30
	tickFunctions[Reverb] = SFXReverbTick;
 80112bc:	6314      	str	r4, [r2, #48]	; 0x30
	freeFunctions[Reverb] = SFXReverbFree;
 80112be:	4d4d      	ldr	r5, [pc, #308]	; (80113f4 <initFunctionPointers+0x20c>)

	allocFunctions[Reverb2] = SFXReverb2Alloc;
 80112c0:	4c4d      	ldr	r4, [pc, #308]	; (80113f8 <initFunctionPointers+0x210>)
	freeFunctions[Reverb] = SFXReverbFree;
 80112c2:	631d      	str	r5, [r3, #48]	; 0x30
	allocFunctions[Reverb2] = SFXReverb2Alloc;
 80112c4:	6344      	str	r4, [r0, #52]	; 0x34
	frameFunctions[Reverb2] = SFXReverb2Frame;
 80112c6:	4d4d      	ldr	r5, [pc, #308]	; (80113fc <initFunctionPointers+0x214>)
	tickFunctions[Reverb2] = SFXReverb2Tick;
 80112c8:	4c4d      	ldr	r4, [pc, #308]	; (8011400 <initFunctionPointers+0x218>)
	frameFunctions[Reverb2] = SFXReverb2Frame;
 80112ca:	634d      	str	r5, [r1, #52]	; 0x34
	tickFunctions[Reverb2] = SFXReverb2Tick;
 80112cc:	6354      	str	r4, [r2, #52]	; 0x34
	freeFunctions[Reverb2] = SFXReverb2Free;
 80112ce:	4d4d      	ldr	r5, [pc, #308]	; (8011404 <initFunctionPointers+0x21c>)

	allocFunctions[LivingString] = SFXLivingStringAlloc;
 80112d0:	4c4d      	ldr	r4, [pc, #308]	; (8011408 <initFunctionPointers+0x220>)
	freeFunctions[Reverb2] = SFXReverb2Free;
 80112d2:	635d      	str	r5, [r3, #52]	; 0x34
	allocFunctions[LivingString] = SFXLivingStringAlloc;
 80112d4:	6384      	str	r4, [r0, #56]	; 0x38
	frameFunctions[LivingString] = SFXLivingStringFrame;
 80112d6:	4d4d      	ldr	r5, [pc, #308]	; (801140c <initFunctionPointers+0x224>)
	tickFunctions[LivingString] = SFXLivingStringTick;
 80112d8:	4c4d      	ldr	r4, [pc, #308]	; (8011410 <initFunctionPointers+0x228>)
	frameFunctions[LivingString] = SFXLivingStringFrame;
 80112da:	638d      	str	r5, [r1, #56]	; 0x38
	tickFunctions[LivingString] = SFXLivingStringTick;
 80112dc:	6394      	str	r4, [r2, #56]	; 0x38
	freeFunctions[LivingString] = SFXLivingStringFree;
 80112de:	4d4d      	ldr	r5, [pc, #308]	; (8011414 <initFunctionPointers+0x22c>)

	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
 80112e0:	4c4d      	ldr	r4, [pc, #308]	; (8011418 <initFunctionPointers+0x230>)
	freeFunctions[LivingString] = SFXLivingStringFree;
 80112e2:	639d      	str	r5, [r3, #56]	; 0x38
	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
 80112e4:	63c4      	str	r4, [r0, #60]	; 0x3c
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
 80112e6:	4d4d      	ldr	r5, [pc, #308]	; (801141c <initFunctionPointers+0x234>)
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
 80112e8:	4c4d      	ldr	r4, [pc, #308]	; (8011420 <initFunctionPointers+0x238>)
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
 80112ea:	63cd      	str	r5, [r1, #60]	; 0x3c
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
 80112ec:	63d4      	str	r4, [r2, #60]	; 0x3c
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
 80112ee:	4d4d      	ldr	r5, [pc, #308]	; (8011424 <initFunctionPointers+0x23c>)

	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
 80112f0:	4c4d      	ldr	r4, [pc, #308]	; (8011428 <initFunctionPointers+0x240>)
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
 80112f2:	63dd      	str	r5, [r3, #60]	; 0x3c
	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
 80112f4:	6404      	str	r4, [r0, #64]	; 0x40
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
 80112f6:	4d4d      	ldr	r5, [pc, #308]	; (801142c <initFunctionPointers+0x244>)
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
 80112f8:	4c4d      	ldr	r4, [pc, #308]	; (8011430 <initFunctionPointers+0x248>)
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
 80112fa:	640d      	str	r5, [r1, #64]	; 0x40
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
 80112fc:	6414      	str	r4, [r2, #64]	; 0x40
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
 80112fe:	4d4d      	ldr	r5, [pc, #308]	; (8011434 <initFunctionPointers+0x24c>)

	allocFunctions[Rhodes] = SFXRhodesAlloc;
 8011300:	4c4d      	ldr	r4, [pc, #308]	; (8011438 <initFunctionPointers+0x250>)
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
 8011302:	641d      	str	r5, [r3, #64]	; 0x40
	allocFunctions[Rhodes] = SFXRhodesAlloc;
 8011304:	6444      	str	r4, [r0, #68]	; 0x44
	frameFunctions[Rhodes] = SFXRhodesFrame;
 8011306:	4d4d      	ldr	r5, [pc, #308]	; (801143c <initFunctionPointers+0x254>)
	tickFunctions[Rhodes] = SFXRhodesTick;
 8011308:	4c4d      	ldr	r4, [pc, #308]	; (8011440 <initFunctionPointers+0x258>)
	freeFunctions[Rhodes] = SFXRhodesFree;
 801130a:	484e      	ldr	r0, [pc, #312]	; (8011444 <initFunctionPointers+0x25c>)
	frameFunctions[Rhodes] = SFXRhodesFrame;
 801130c:	644d      	str	r5, [r1, #68]	; 0x44
	tickFunctions[Rhodes] = SFXRhodesTick;
 801130e:	6454      	str	r4, [r2, #68]	; 0x44
	freeFunctions[Rhodes] = SFXRhodesFree;
 8011310:	6458      	str	r0, [r3, #68]	; 0x44
}
 8011312:	bc30      	pop	{r4, r5}
 8011314:	4770      	bx	lr
 8011316:	bf00      	nop
 8011318:	20000834 	.word	0x20000834
 801131c:	08014cad 	.word	0x08014cad
 8011320:	08015291 	.word	0x08015291
 8011324:	080160e9 	.word	0x080160e9
 8011328:	080163c5 	.word	0x080163c5
 801132c:	08016579 	.word	0x08016579
 8011330:	0801677d 	.word	0x0801677d
 8011334:	20000880 	.word	0x20000880
 8011338:	08016add 	.word	0x08016add
 801133c:	0801758d 	.word	0x0801758d
 8011340:	08014dd9 	.word	0x08014dd9
 8011344:	08015671 	.word	0x08015671
 8011348:	080161ad 	.word	0x080161ad
 801134c:	0801649d 	.word	0x0801649d
 8011350:	080165ad 	.word	0x080165ad
 8011354:	08016819 	.word	0x08016819
 8011358:	08016c15 	.word	0x08016c15
 801135c:	080176b1 	.word	0x080176b1
 8011360:	2000079c 	.word	0x2000079c
 8011364:	08015045 	.word	0x08015045
 8011368:	08015d45 	.word	0x08015d45
 801136c:	080161b1 	.word	0x080161b1
 8011370:	0801b471 	.word	0x0801b471
 8011374:	080166ad 	.word	0x080166ad
 8011378:	0801681d 	.word	0x0801681d
 801137c:	08016ef1 	.word	0x08016ef1
 8011380:	080176d9 	.word	0x080176d9
 8011384:	200007e8 	.word	0x200007e8
 8011388:	0801521d 	.word	0x0801521d
 801138c:	08016035 	.word	0x08016035
 8011390:	08016379 	.word	0x08016379
 8011394:	08016555 	.word	0x08016555
 8011398:	08016771 	.word	0x08016771
 801139c:	08016aad 	.word	0x08016aad
 80113a0:	0801755d 	.word	0x0801755d
 80113a4:	08017c69 	.word	0x08017c69
 80113a8:	08017ca9 	.word	0x08017ca9
 80113ac:	08017d75 	.word	0x08017d75
 80113b0:	08017e3d 	.word	0x08017e3d
 80113b4:	08017f2d 	.word	0x08017f2d
 80113b8:	08017f5d 	.word	0x08017f5d
 80113bc:	08017fad 	.word	0x08017fad
 80113c0:	08017fd5 	.word	0x08017fd5
 80113c4:	080180e9 	.word	0x080180e9
 80113c8:	08018119 	.word	0x08018119
 80113cc:	08018141 	.word	0x08018141
 80113d0:	08018169 	.word	0x08018169
 80113d4:	080182d1 	.word	0x080182d1
 80113d8:	080182ed 	.word	0x080182ed
 80113dc:	080183e9 	.word	0x080183e9
 80113e0:	0801844d 	.word	0x0801844d
 80113e4:	080186c5 	.word	0x080186c5
 80113e8:	0801871d 	.word	0x0801871d
 80113ec:	08018771 	.word	0x08018771
 80113f0:	08018801 	.word	0x08018801
 80113f4:	08018901 	.word	0x08018901
 80113f8:	0801891d 	.word	0x0801891d
 80113fc:	080189f1 	.word	0x080189f1
 8011400:	080189f5 	.word	0x080189f5
 8011404:	08018bb1 	.word	0x08018bb1
 8011408:	08018bfd 	.word	0x08018bfd
 801140c:	08018cf5 	.word	0x08018cf5
 8011410:	08019145 	.word	0x08019145
 8011414:	0801919d 	.word	0x0801919d
 8011418:	080191c1 	.word	0x080191c1
 801141c:	08019331 	.word	0x08019331
 8011420:	0801967d 	.word	0x0801967d
 8011424:	08019745 	.word	0x08019745
 8011428:	0801979d 	.word	0x0801979d
 801142c:	08019a8d 	.word	0x08019a8d
 8011430:	0801a121 	.word	0x0801a121
 8011434:	0801a255 	.word	0x0801a255
 8011438:	0801a2d5 	.word	0x0801a2d5
 801143c:	0801a429 	.word	0x0801a429
 8011440:	0801ae09 	.word	0x0801ae09
 8011444:	0801b185 	.word	0x0801b185

08011448 <audioInit>:
{
 8011448:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, small_memory, SMALL_MEM_SIZE, &randomNumber);
 801144c:	4b47      	ldr	r3, [pc, #284]	; (801156c <audioInit+0x124>)
{
 801144e:	4606      	mov	r6, r0
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, small_memory, SMALL_MEM_SIZE, &randomNumber);
 8011450:	ed9f 0a47 	vldr	s0, [pc, #284]	; 8011570 <audioInit+0x128>
 8011454:	2080      	movs	r0, #128	; 0x80
{
 8011456:	4688      	mov	r8, r1
 8011458:	4617      	mov	r7, r2
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, small_memory, SMALL_MEM_SIZE, &randomNumber);
 801145a:	4946      	ldr	r1, [pc, #280]	; (8011574 <audioInit+0x12c>)
 801145c:	4a46      	ldr	r2, [pc, #280]	; (8011578 <audioInit+0x130>)
 801145e:	4c47      	ldr	r4, [pc, #284]	; (801157c <audioInit+0x134>)
{
 8011460:	ed2d 8b02 	vpush	{d8}
 8011464:	b086      	sub	sp, #24
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
 8011466:	eddf 8a46 	vldr	s17, [pc, #280]	; 8011580 <audioInit+0x138>
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, small_memory, SMALL_MEM_SIZE, &randomNumber);
 801146a:	f015 fd31 	bl	8026ed0 <LEAF_init>
	tMempool_init (&mediumPool, medium_memory, MED_MEM_SIZE);
 801146e:	4a45      	ldr	r2, [pc, #276]	; (8011584 <audioInit+0x13c>)
 8011470:	4945      	ldr	r1, [pc, #276]	; (8011588 <audioInit+0x140>)
 8011472:	f104 0518 	add.w	r5, r4, #24
 8011476:	4845      	ldr	r0, [pc, #276]	; (801158c <audioInit+0x144>)
 8011478:	f013 f83e 	bl	80244f8 <tMempool_init>
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE);
 801147c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8011480:	4943      	ldr	r1, [pc, #268]	; (8011590 <audioInit+0x148>)
 8011482:	4844      	ldr	r0, [pc, #272]	; (8011594 <audioInit+0x14c>)
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
 8011484:	ed9f 8a44 	vldr	s16, [pc, #272]	; 8011598 <audioInit+0x150>
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE);
 8011488:	f013 f836 	bl	80244f8 <tMempool_init>
	initFunctionPointers();
 801148c:	f7ff feac 	bl	80111e8 <initFunctionPointers>
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
 8011490:	4620      	mov	r0, r4
 8011492:	3404      	adds	r4, #4
 8011494:	eef0 0a68 	vmov.f32	s1, s17
 8011498:	eeb0 0a48 	vmov.f32	s0, s16
 801149c:	f011 f80a 	bl	80224b4 <tExpSmooth_init>
	for (int i = 0; i < 6; i++)
 80114a0:	42ac      	cmp	r4, r5
 80114a2:	d1f5      	bne.n	8011490 <audioInit+0x48>
		tEnvelopeFollower_init(&LED_envelope[i], 0.0001f, .9995f);
 80114a4:	eddf 0a3d 	vldr	s1, [pc, #244]	; 801159c <audioInit+0x154>
	loadingPreset = 1;
 80114a8:	2401      	movs	r4, #1
		tEnvelopeFollower_init(&LED_envelope[i], 0.0001f, .9995f);
 80114aa:	ed9f 0a3d 	vldr	s0, [pc, #244]	; 80115a0 <audioInit+0x158>
 80114ae:	483d      	ldr	r0, [pc, #244]	; (80115a4 <audioInit+0x15c>)
 80114b0:	f00d fa1e 	bl	801e8f0 <tEnvelopeFollower_init>
 80114b4:	eddf 0a39 	vldr	s1, [pc, #228]	; 801159c <audioInit+0x154>
 80114b8:	ed9f 0a39 	vldr	s0, [pc, #228]	; 80115a0 <audioInit+0x158>
 80114bc:	483a      	ldr	r0, [pc, #232]	; (80115a8 <audioInit+0x160>)
 80114be:	f00d fa17 	bl	801e8f0 <tEnvelopeFollower_init>
 80114c2:	eddf 0a36 	vldr	s1, [pc, #216]	; 801159c <audioInit+0x154>
 80114c6:	ed9f 0a36 	vldr	s0, [pc, #216]	; 80115a0 <audioInit+0x158>
 80114ca:	4838      	ldr	r0, [pc, #224]	; (80115ac <audioInit+0x164>)
 80114cc:	f00d fa10 	bl	801e8f0 <tEnvelopeFollower_init>
 80114d0:	eddf 0a32 	vldr	s1, [pc, #200]	; 801159c <audioInit+0x154>
 80114d4:	ed9f 0a32 	vldr	s0, [pc, #200]	; 80115a0 <audioInit+0x158>
 80114d8:	4835      	ldr	r0, [pc, #212]	; (80115b0 <audioInit+0x168>)
 80114da:	f00d fa09 	bl	801e8f0 <tEnvelopeFollower_init>
	LEAF_generate_atodbPositiveClipped(atodbTable, -120.0f, 380.f, ATODB_TABLE_SIZE);
 80114de:	eddf 0a35 	vldr	s1, [pc, #212]	; 80115b4 <audioInit+0x16c>
 80114e2:	ed9f 0a35 	vldr	s0, [pc, #212]	; 80115b8 <audioInit+0x170>
 80114e6:	f44f 7100 	mov.w	r1, #512	; 0x200
 80114ea:	4834      	ldr	r0, [pc, #208]	; (80115bc <audioInit+0x174>)
 80114ec:	f012 fd80 	bl	8023ff0 <LEAF_generate_atodbPositiveClipped>
	initGlobalSFXObjects();
 80114f0:	f003 f928 	bl	8014744 <initGlobalSFXObjects>
	previousPreset = PresetNil;
 80114f4:	4b32      	ldr	r3, [pc, #200]	; (80115c0 <audioInit+0x178>)
	loadingPreset = 1;
 80114f6:	4933      	ldr	r1, [pc, #204]	; (80115c4 <audioInit+0x17c>)
	previousPreset = PresetNil;
 80114f8:	2212      	movs	r2, #18
	HAL_Delay(10);
 80114fa:	200a      	movs	r0, #10
	previousPreset = PresetNil;
 80114fc:	701a      	strb	r2, [r3, #0]
	loadingPreset = 1;
 80114fe:	700c      	strb	r4, [r1, #0]
	HAL_Delay(10);
 8011500:	f7ef fa98 	bl	8000a34 <HAL_Delay>
 8011504:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8011508:	2100      	movs	r1, #0
 801150a:	482f      	ldr	r0, [pc, #188]	; (80115c8 <audioInit+0x180>)
 801150c:	f015 fd67 	bl	8026fde <memset>
	HAL_Delay(1);
 8011510:	4620      	mov	r0, r4
 8011512:	f7ef fa8f 	bl	8000a34 <HAL_Delay>
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
 8011516:	4640      	mov	r0, r8
 8011518:	f44f 7200 	mov.w	r2, #512	; 0x200
 801151c:	492a      	ldr	r1, [pc, #168]	; (80115c8 <audioInit+0x180>)
 801151e:	f7f9 fca5 	bl	800ae6c <HAL_SAI_Transmit_DMA>
 8011522:	4b2a      	ldr	r3, [pc, #168]	; (80115cc <audioInit+0x184>)
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
 8011524:	f44f 7200 	mov.w	r2, #512	; 0x200
 8011528:	4929      	ldr	r1, [pc, #164]	; (80115d0 <audioInit+0x188>)
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
 801152a:	7018      	strb	r0, [r3, #0]
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
 801152c:	4638      	mov	r0, r7
 801152e:	f7f9 fd2d 	bl	800af8c <HAL_SAI_Receive_DMA>
 8011532:	4b28      	ldr	r3, [pc, #160]	; (80115d4 <audioInit+0x18c>)
 8011534:	7018      	strb	r0, [r3, #0]
	AudioCodec_init(hi2c);
 8011536:	4630      	mov	r0, r6
 8011538:	f000 f8e0 	bl	80116fc <AudioCodec_init>
	HAL_Delay(1);
 801153c:	4620      	mov	r0, r4
 801153e:	f7ef fa79 	bl	8000a34 <HAL_Delay>
	HAL_I2C_MspDeInit(hi2c);
 8011542:	4630      	mov	r0, r6
 8011544:	f001 fef0 	bl	8013328 <HAL_I2C_MspDeInit>
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 8011548:	2300      	movs	r3, #0
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 801154a:	f44f 6240 	mov.w	r2, #3072	; 0xc00
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801154e:	a901      	add	r1, sp, #4
 8011550:	4821      	ldr	r0, [pc, #132]	; (80115d8 <audioInit+0x190>)
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 8011552:	9302      	str	r3, [sp, #8]
 8011554:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 8011556:	9201      	str	r2, [sp, #4]
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 8011558:	e9cd 4303 	strd	r4, r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801155c:	f7f3 fe30 	bl	80051c0 <HAL_GPIO_Init>
}
 8011560:	b006      	add	sp, #24
 8011562:	ecbd 8b02 	vpop	{d8}
 8011566:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801156a:	bf00      	nop
 801156c:	080135f9 	.word	0x080135f9
 8011570:	473b8000 	.word	0x473b8000
 8011574:	20003604 	.word	0x20003604
 8011578:	000139c8 	.word	0x000139c8
 801157c:	20018840 	.word	0x20018840
 8011580:	3e4ccccd 	.word	0x3e4ccccd
 8011584:	0007eb58 	.word	0x0007eb58
 8011588:	24000000 	.word	0x24000000
 801158c:	200174cc 	.word	0x200174cc
 8011590:	60000000 	.word	0x60000000
 8011594:	200174b8 	.word	0x200174b8
 8011598:	00000000 	.word	0x00000000
 801159c:	3f7fdf3b 	.word	0x3f7fdf3b
 80115a0:	38d1b717 	.word	0x38d1b717
 80115a4:	200008c8 	.word	0x200008c8
 80115a8:	200008cc 	.word	0x200008cc
 80115ac:	200008d0 	.word	0x200008d0
 80115b0:	200008d4 	.word	0x200008d4
 80115b4:	43be0000 	.word	0x43be0000
 80115b8:	c2f00000 	.word	0xc2f00000
 80115bc:	200008d8 	.word	0x200008d8
 80115c0:	200002d8 	.word	0x200002d8
 80115c4:	2000066b 	.word	0x2000066b
 80115c8:	30000880 	.word	0x30000880
 80115cc:	200007e4 	.word	0x200007e4
 80115d0:	30000080 	.word	0x30000080
 80115d4:	2000087c 	.word	0x2000087c
 80115d8:	58020400 	.word	0x58020400

080115dc <HAL_SAI_ErrorCallback>:



void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
	setLED_Edit(1);
 80115dc:	2001      	movs	r0, #1
 80115de:	f002 b979 	b.w	80138d4 <setLED_Edit>
 80115e2:	bf00      	nop

080115e4 <HAL_SAI_TxCpltCallback>:
 80115e4:	4770      	bx	lr
 80115e6:	bf00      	nop

080115e8 <HAL_SAI_TxHalfCpltCallback>:
}

void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{

}
 80115e8:	4770      	bx	lr
 80115ea:	bf00      	nop

080115ec <HAL_SAI_RxCpltCallback>:


void HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai)
{
	audioFrame(HALF_BUFFER_SIZE);
 80115ec:	f44f 7080 	mov.w	r0, #256	; 0x100
 80115f0:	f7ff bb90 	b.w	8010d14 <audioFrame>

080115f4 <HAL_SAI_RxHalfCpltCallback>:
}

void HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
	audioFrame(0);
 80115f4:	2000      	movs	r0, #0
 80115f6:	f7ff bb8d 	b.w	8010d14 <audioFrame>
 80115fa:	bf00      	nop

080115fc <MX_BDMA_Init>:
  */
void MX_BDMA_Init(void) 
{

  /* DMA controller clock enable */
  __HAL_RCC_BDMA_CLK_ENABLE();
 80115fc:	4b10      	ldr	r3, [pc, #64]	; (8011640 <MX_BDMA_Init+0x44>)

  /* DMA interrupt init */
  /* BDMA_Channel0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
 80115fe:	2200      	movs	r2, #0
 8011600:	2081      	movs	r0, #129	; 0x81
 8011602:	4611      	mov	r1, r2
{
 8011604:	b510      	push	{r4, lr}
  __HAL_RCC_BDMA_CLK_ENABLE();
 8011606:	f8d3 40e0 	ldr.w	r4, [r3, #224]	; 0xe0
{
 801160a:	b082      	sub	sp, #8
  __HAL_RCC_BDMA_CLK_ENABLE();
 801160c:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
 8011610:	f8c3 40e0 	str.w	r4, [r3, #224]	; 0xe0
 8011614:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011618:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 801161c:	9301      	str	r3, [sp, #4]
 801161e:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
 8011620:	f7f0 fe6a 	bl	80022f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BDMA_Channel0_IRQn);
 8011624:	2081      	movs	r0, #129	; 0x81
 8011626:	f7f0 fead 	bl	8002384 <HAL_NVIC_EnableIRQ>
  /* BDMA_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BDMA_Channel1_IRQn, 0, 0);
 801162a:	2200      	movs	r2, #0
 801162c:	2082      	movs	r0, #130	; 0x82
 801162e:	4611      	mov	r1, r2
 8011630:	f7f0 fe62 	bl	80022f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);
 8011634:	2082      	movs	r0, #130	; 0x82

}
 8011636:	b002      	add	sp, #8
 8011638:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);
 801163c:	f7f0 bea2 	b.w	8002384 <HAL_NVIC_EnableIRQ>
 8011640:	58024400 	.word	0x58024400

08011644 <BSP_SD_ReadBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to read
  * @param  Timeout: Timeout for read operation
  * @retval SD status
  */
__weak uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
 8011644:	b500      	push	{lr}
 8011646:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;

  if (HAL_SD_ReadBlocks(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks, Timeout) != HAL_OK)
 8011648:	9300      	str	r3, [sp, #0]
 801164a:	4613      	mov	r3, r2
 801164c:	460a      	mov	r2, r1
 801164e:	4601      	mov	r1, r0
 8011650:	4804      	ldr	r0, [pc, #16]	; (8011664 <BSP_SD_ReadBlocks+0x20>)
 8011652:	f7f9 ff1f 	bl	800b494 <HAL_SD_ReadBlocks>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;  
}
 8011656:	3000      	adds	r0, #0
 8011658:	bf18      	it	ne
 801165a:	2001      	movne	r0, #1
 801165c:	b003      	add	sp, #12
 801165e:	f85d fb04 	ldr.w	pc, [sp], #4
 8011662:	bf00      	nop
 8011664:	20001e70 	.word	0x20001e70

08011668 <BSP_SD_WriteBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to write
  * @param  Timeout: Timeout for write operation
  * @retval SD status
  */
__weak uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
 8011668:	b500      	push	{lr}
 801166a:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;

  if (HAL_SD_WriteBlocks(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks, Timeout) != HAL_OK) 
 801166c:	9300      	str	r3, [sp, #0]
 801166e:	4613      	mov	r3, r2
 8011670:	460a      	mov	r2, r1
 8011672:	4601      	mov	r1, r0
 8011674:	4804      	ldr	r0, [pc, #16]	; (8011688 <BSP_SD_WriteBlocks+0x20>)
 8011676:	f7fa f80f 	bl	800b698 <HAL_SD_WriteBlocks>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;  
}
 801167a:	3000      	adds	r0, #0
 801167c:	bf18      	it	ne
 801167e:	2001      	movne	r0, #1
 8011680:	b003      	add	sp, #12
 8011682:	f85d fb04 	ldr.w	pc, [sp], #4
 8011686:	bf00      	nop
 8011688:	20001e70 	.word	0x20001e70

0801168c <BSP_SD_GetCardState>:
  *          This value can be one of the following values:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
__weak uint8_t BSP_SD_GetCardState(void)
{
 801168c:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
 801168e:	4803      	ldr	r0, [pc, #12]	; (801169c <BSP_SD_GetCardState+0x10>)
 8011690:	f7fa fda0 	bl	800c1d4 <HAL_SD_GetCardState>
}
 8011694:	3804      	subs	r0, #4
 8011696:	bf18      	it	ne
 8011698:	2001      	movne	r0, #1
 801169a:	bd08      	pop	{r3, pc}
 801169c:	20001e70 	.word	0x20001e70

080116a0 <BSP_SD_GetCardInfo>:
  * @retval None 
  */
__weak void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&hsd1, CardInfo);
 80116a0:	4601      	mov	r1, r0
 80116a2:	4801      	ldr	r0, [pc, #4]	; (80116a8 <BSP_SD_GetCardInfo+0x8>)
 80116a4:	f7fa bc0c 	b.w	800bec0 <HAL_SD_GetCardInfo>
 80116a8:	20001e70 	.word	0x20001e70

080116ac <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
__weak uint8_t BSP_SD_IsDetected(void)
{
 80116ac:	b500      	push	{lr}
  __IO uint8_t status = SD_PRESENT;
 80116ae:	2301      	movs	r3, #1
{
 80116b0:	b083      	sub	sp, #12
  __IO uint8_t status = SD_PRESENT;
 80116b2:	f88d 3007 	strb.w	r3, [sp, #7]

  if (BSP_PlatformIsDetected() == 0x0) 
 80116b6:	f000 fc69 	bl	8011f8c <BSP_PlatformIsDetected>
 80116ba:	b908      	cbnz	r0, 80116c0 <BSP_SD_IsDetected+0x14>
  {
    status = SD_NOT_PRESENT;
 80116bc:	f88d 0007 	strb.w	r0, [sp, #7]
  }

  return status;
 80116c0:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 80116c4:	b003      	add	sp, #12
 80116c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80116ca:	bf00      	nop

080116cc <BSP_SD_Init>:
{
 80116cc:	b508      	push	{r3, lr}
  if (BSP_SD_IsDetected() != SD_PRESENT)
 80116ce:	f7ff ffed 	bl	80116ac <BSP_SD_IsDetected>
 80116d2:	2801      	cmp	r0, #1
 80116d4:	d001      	beq.n	80116da <BSP_SD_Init+0xe>
    return MSD_ERROR_SD_NOT_PRESENT;
 80116d6:	2002      	movs	r0, #2
}
 80116d8:	bd08      	pop	{r3, pc}
  sd_state = HAL_SD_Init(&hsd1);
 80116da:	4807      	ldr	r0, [pc, #28]	; (80116f8 <BSP_SD_Init+0x2c>)
 80116dc:	f7fa fcb4 	bl	800c048 <HAL_SD_Init>
  if (sd_state == MSD_OK)
 80116e0:	2800      	cmp	r0, #0
 80116e2:	d1f9      	bne.n	80116d8 <BSP_SD_Init+0xc>
    if (HAL_SD_ConfigWideBusOperation(&hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)
 80116e4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80116e8:	4803      	ldr	r0, [pc, #12]	; (80116f8 <BSP_SD_Init+0x2c>)
 80116ea:	f7fa fbfd 	bl	800bee8 <HAL_SD_ConfigWideBusOperation>
    return MSD_ERROR_SD_NOT_PRESENT;
 80116ee:	3000      	adds	r0, #0
 80116f0:	bf18      	it	ne
 80116f2:	2001      	movne	r0, #1
}
 80116f4:	bd08      	pop	{r3, pc}
 80116f6:	bf00      	nop
 80116f8:	20001e70 	.word	0x20001e70

080116fc <AudioCodec_init>:

volatile int blankCount = 0;
uint16_t addressCounter = 0;


void AudioCodec_init(I2C_HandleTypeDef* hi2c) {
 80116fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	//pull codec reset pin high to start codec working
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
 8011700:	2201      	movs	r2, #1
void AudioCodec_init(I2C_HandleTypeDef* hi2c) {
 8011702:	b082      	sub	sp, #8
 8011704:	4605      	mov	r5, r0

	HAL_Delay(2);
	//enable control port and put part in power-down mode while loading registers
	myI2cData[0] = 0x07;
	myI2cData[1] = 0x03;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011706:	4e40      	ldr	r6, [pc, #256]	; (8011808 <AudioCodec_init+0x10c>)
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
 8011708:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 801170c:	483f      	ldr	r0, [pc, #252]	; (801180c <AudioCodec_init+0x110>)
 801170e:	f7f4 f891 	bl	8005834 <HAL_GPIO_WritePin>
	HAL_Delay(2);
 8011712:	2002      	movs	r0, #2
	myI2cData[0] = 0x07;
 8011714:	4c3e      	ldr	r4, [pc, #248]	; (8011810 <AudioCodec_init+0x114>)
	HAL_Delay(2);
 8011716:	f7ef f98d 	bl	8000a34 <HAL_Delay>
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801171a:	4f3e      	ldr	r7, [pc, #248]	; (8011814 <AudioCodec_init+0x118>)
	myI2cData[0] = 0x07;
 801171c:	f240 3c07 	movw	ip, #775	; 0x307
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011720:	6831      	ldr	r1, [r6, #0]
 8011722:	4622      	mov	r2, r4
 8011724:	883b      	ldrh	r3, [r7, #0]
 8011726:	4628      	mov	r0, r5
 8011728:	9100      	str	r1, [sp, #0]
 801172a:	2120      	movs	r1, #32
 801172c:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 801181c <AudioCodec_init+0x120>
	myI2cData[0] = 0x07;
 8011730:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011734:	f7f4 ff3a 	bl	80065ac <HAL_I2C_Master_Transmit>
	//HAL_Delay(2);

	myI2cData[0] = 0x01;
	myI2cData[1] = 0x41;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011738:	6831      	ldr	r1, [r6, #0]
	myI2cData[0] = 0x01;
 801173a:	f244 1c01 	movw	ip, #16641	; 0x4101
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801173e:	883b      	ldrh	r3, [r7, #0]
 8011740:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011742:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011746:	4628      	mov	r0, r5
 8011748:	9100      	str	r1, [sp, #0]
 801174a:	2120      	movs	r1, #32
	myI2cData[0] = 0x01;
 801174c:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011750:	f7f4 ff2c 	bl	80065ac <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x02;
	myI2cData[1] = 0x00;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011754:	6832      	ldr	r2, [r6, #0]
	myI2cData[0] = 0x02;
 8011756:	f04f 0c02 	mov.w	ip, #2
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801175a:	883b      	ldrh	r3, [r7, #0]
 801175c:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801175e:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011762:	4628      	mov	r0, r5
 8011764:	9200      	str	r2, [sp, #0]
 8011766:	4622      	mov	r2, r4
	myI2cData[0] = 0x02;
 8011768:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801176c:	f7f4 ff1e 	bl	80065ac <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x03;
	myI2cData[1] = 0x79;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011770:	6831      	ldr	r1, [r6, #0]
	myI2cData[0] = 0x03;
 8011772:	f647 1c03 	movw	ip, #30979	; 0x7903
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011776:	883b      	ldrh	r3, [r7, #0]
 8011778:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801177a:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801177e:	4628      	mov	r0, r5
 8011780:	9100      	str	r1, [sp, #0]
 8011782:	2120      	movs	r1, #32
	myI2cData[0] = 0x03;
 8011784:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011788:	f7f4 ff10 	bl	80065ac <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x04;
	myI2cData[1] = 0x01;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801178c:	6832      	ldr	r2, [r6, #0]
	myI2cData[0] = 0x04;
 801178e:	f44f 7c82 	mov.w	ip, #260	; 0x104
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011792:	883b      	ldrh	r3, [r7, #0]
 8011794:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8011796:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801179a:	4628      	mov	r0, r5
 801179c:	9200      	str	r2, [sp, #0]
 801179e:	4622      	mov	r2, r4
	myI2cData[0] = 0x04;
 80117a0:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117a4:	f7f4 ff02 	bl	80065ac <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x05;
	myI2cData[1] = 0x01;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117a8:	6831      	ldr	r1, [r6, #0]
	myI2cData[0] = 0x05;
 80117aa:	f240 1c05 	movw	ip, #261	; 0x105
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117ae:	883b      	ldrh	r3, [r7, #0]
 80117b0:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117b2:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117b6:	4628      	mov	r0, r5
 80117b8:	9100      	str	r1, [sp, #0]
 80117ba:	2120      	movs	r1, #32
	myI2cData[0] = 0x05;
 80117bc:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117c0:	f7f4 fef4 	bl	80065ac <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x06;
	myI2cData[1] = 0x10;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117c4:	6832      	ldr	r2, [r6, #0]
	myI2cData[0] = 0x06;
 80117c6:	f241 0c06 	movw	ip, #4102	; 0x1006
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117ca:	883b      	ldrh	r3, [r7, #0]
 80117cc:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117ce:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117d2:	4628      	mov	r0, r5
 80117d4:	9200      	str	r2, [sp, #0]
 80117d6:	4622      	mov	r2, r4
	myI2cData[0] = 0x06;
 80117d8:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117dc:	f7f4 fee6 	bl	80065ac <HAL_I2C_Master_Transmit>
	//HAL_Delay(1); // might not be necessary

	//turn off power down bit to start things cookin'
	myI2cData[0] = 0x07;
	myI2cData[1] = 0x02;
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117e0:	6831      	ldr	r1, [r6, #0]
 80117e2:	4622      	mov	r2, r4
 80117e4:	883b      	ldrh	r3, [r7, #0]
	myI2cData[0] = 0x07;
 80117e6:	f240 2707 	movw	r7, #519	; 0x207
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117ea:	f888 0000 	strb.w	r0, [r8]
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117ee:	4628      	mov	r0, r5
 80117f0:	9100      	str	r1, [sp, #0]
 80117f2:	2120      	movs	r1, #32
	myI2cData[0] = 0x07;
 80117f4:	8027      	strh	r7, [r4, #0]
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80117f6:	f7f4 fed9 	bl	80065ac <HAL_I2C_Master_Transmit>


	//HAL_Delay(1); // might not be necessary
	codecReady = 1;
 80117fa:	4b07      	ldr	r3, [pc, #28]	; (8011818 <AudioCodec_init+0x11c>)
 80117fc:	2201      	movs	r2, #1
 80117fe:	601a      	str	r2, [r3, #0]

}
 8011800:	b002      	add	sp, #8
 8011802:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8011806:	bf00      	nop
 8011808:	20000014 	.word	0x20000014
 801180c:	58020800 	.word	0x58020800
 8011810:	20000510 	.word	0x20000510
 8011814:	20000018 	.word	0x20000018
 8011818:	20000508 	.word	0x20000508
 801181c:	200010d8 	.word	0x200010d8

08011820 <MX_DMA_Init>:
  */
void MX_DMA_Init(void) 
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8011820:	4b1e      	ldr	r3, [pc, #120]	; (801189c <MX_DMA_Init+0x7c>)
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 3, 0);
 8011822:	2200      	movs	r2, #0
 8011824:	2103      	movs	r1, #3
 8011826:	200c      	movs	r0, #12
{
 8011828:	b510      	push	{r4, lr}
  __HAL_RCC_DMA2_CLK_ENABLE();
 801182a:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
{
 801182e:	b082      	sub	sp, #8
  __HAL_RCC_DMA2_CLK_ENABLE();
 8011830:	f044 0402 	orr.w	r4, r4, #2
 8011834:	f8c3 40d8 	str.w	r4, [r3, #216]	; 0xd8
 8011838:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
 801183c:	f004 0402 	and.w	r4, r4, #2
 8011840:	9400      	str	r4, [sp, #0]
 8011842:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_DMA1_CLK_ENABLE();
 8011844:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
 8011848:	f044 0401 	orr.w	r4, r4, #1
 801184c:	f8c3 40d8 	str.w	r4, [r3, #216]	; 0xd8
 8011850:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8011854:	f003 0301 	and.w	r3, r3, #1
 8011858:	9301      	str	r3, [sp, #4]
 801185a:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 3, 0);
 801185c:	f7f0 fd4c 	bl	80022f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 8011860:	200c      	movs	r0, #12
 8011862:	f7f0 fd8f 	bl	8002384 <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 3, 0);
 8011866:	2200      	movs	r2, #0
 8011868:	2103      	movs	r1, #3
 801186a:	200d      	movs	r0, #13
 801186c:	f7f0 fd44 	bl	80022f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
 8011870:	200d      	movs	r0, #13
 8011872:	f7f0 fd87 	bl	8002384 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 4, 0);
 8011876:	2200      	movs	r2, #0
 8011878:	2104      	movs	r1, #4
 801187a:	2038      	movs	r0, #56	; 0x38
 801187c:	f7f0 fd3c 	bl	80022f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
 8011880:	2038      	movs	r0, #56	; 0x38
 8011882:	f7f0 fd7f 	bl	8002384 <HAL_NVIC_EnableIRQ>
  /* DMAMUX1_OVR_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMAMUX1_OVR_IRQn, 0, 0);
 8011886:	2200      	movs	r2, #0
 8011888:	2066      	movs	r0, #102	; 0x66
 801188a:	4611      	mov	r1, r2
 801188c:	f7f0 fd34 	bl	80022f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMAMUX1_OVR_IRQn);
 8011890:	2066      	movs	r0, #102	; 0x66

}
 8011892:	b002      	add	sp, #8
 8011894:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(DMAMUX1_OVR_IRQn);
 8011898:	f7f0 bd74 	b.w	8002384 <HAL_NVIC_EnableIRQ>
 801189c:	58024400 	.word	0x58024400

080118a0 <EE_VerifyPageFullWriteVariable>:
  *           - PAGE_FULL: if valid page is full
  *           - NO_VALID_PAGE: if no valid page was found
  *           - Flash error code: on write Flash error
  */
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
 80118a0:	b510      	push	{r4, lr}
  HAL_StatusTypeDef FlashStatus = HAL_OK;
  uint16_t ValidPage = PAGE0;
  uint32_t Address = EEPROM_START_ADDRESS, PageEndAddress = EEPROM_START_ADDRESS+PAGE_SIZE;

  uint32_t data32[8] = {Data};
 80118a2:	2300      	movs	r3, #0
{
 80118a4:	b090      	sub	sp, #64	; 0x40
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80118a6:	4c25      	ldr	r4, [pc, #148]	; (801193c <EE_VerifyPageFullWriteVariable+0x9c>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80118a8:	4a25      	ldr	r2, [pc, #148]	; (8011940 <EE_VerifyPageFullWriteVariable+0xa0>)
  uint32_t data32[8] = {Data};
 80118aa:	9100      	str	r1, [sp, #0]
  uint32_t VirtAddress1[8] = {VirtAddress};
 80118ac:	9008      	str	r0, [sp, #32]
  uint32_t data32[8] = {Data};
 80118ae:	9307      	str	r3, [sp, #28]
  uint32_t VirtAddress1[8] = {VirtAddress};
 80118b0:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t data32[8] = {Data};
 80118b2:	e9cd 3301 	strd	r3, r3, [sp, #4]
 80118b6:	e9cd 3303 	strd	r3, r3, [sp, #12]
 80118ba:	e9cd 3305 	strd	r3, r3, [sp, #20]
  uint32_t VirtAddress1[8] = {VirtAddress};
 80118be:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
 80118c2:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
 80118c6:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80118ca:	8823      	ldrh	r3, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80118cc:	8812      	ldrh	r2, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80118ce:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80118d0:	b292      	uxth	r2, r2
      if (PageStatus1 == VALID_PAGE)
 80118d2:	b9ea      	cbnz	r2, 8011910 <EE_VerifyPageFullWriteVariable+0x70>
        if (PageStatus0 == RECEIVE_DATA)
 80118d4:	f64e 62ee 	movw	r2, #61166	; 0xeeee
          return PAGE0;         /* Page0 valid */
 80118d8:	1a9b      	subs	r3, r3, r2
 80118da:	bf18      	it	ne
 80118dc:	2301      	movne	r3, #1
  {
    return  NO_VALID_PAGE;
  }

  /* Get the valid Page start Address */
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 80118de:	f203 440e 	addw	r4, r3, #1038	; 0x40e

  /* Get the valid Page end Address */
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
 80118e2:	4a18      	ldr	r2, [pc, #96]	; (8011944 <EE_VerifyPageFullWriteVariable+0xa4>)
 80118e4:	3301      	adds	r3, #1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 80118e6:	0464      	lsls	r4, r4, #17
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
 80118e8:	eb02 4243 	add.w	r2, r2, r3, lsl #17

  /* Check each active page address starting from begining */
  while (Address < PageEndAddress)
 80118ec:	4294      	cmp	r4, r2
 80118ee:	d303      	bcc.n	80118f8 <EE_VerifyPageFullWriteVariable+0x58>
 80118f0:	e016      	b.n	8011920 <EE_VerifyPageFullWriteVariable+0x80>
     return FlashStatus;
    }
    else
    {
      /* Next address location */
      Address = Address + 64;
 80118f2:	3440      	adds	r4, #64	; 0x40
  while (Address < PageEndAddress)
 80118f4:	42a2      	cmp	r2, r4
 80118f6:	d913      	bls.n	8011920 <EE_VerifyPageFullWriteVariable+0x80>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
 80118f8:	6823      	ldr	r3, [r4, #0]
 80118fa:	3301      	adds	r3, #1
 80118fc:	d1f9      	bne.n	80118f2 <EE_VerifyPageFullWriteVariable+0x52>
      FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, ((uint32_t)data32));
 80118fe:	466a      	mov	r2, sp
 8011900:	4621      	mov	r1, r4
 8011902:	2001      	movs	r0, #1
 8011904:	f7f3 f9d8 	bl	8004cb8 <HAL_FLASH_Program>
      if (FlashStatus != HAL_OK)
 8011908:	b180      	cbz	r0, 801192c <EE_VerifyPageFullWriteVariable+0x8c>
     return FlashStatus;
 801190a:	b280      	uxth	r0, r0
    }
  }

  /* Return PAGE_FULL in case the valid page is full */
  return PAGE_FULL;
}
 801190c:	b010      	add	sp, #64	; 0x40
 801190e:	bd10      	pop	{r4, pc}
      else if (PageStatus0 == VALID_PAGE)
 8011910:	b94b      	cbnz	r3, 8011926 <EE_VerifyPageFullWriteVariable+0x86>
        if (PageStatus1 == RECEIVE_DATA)
 8011912:	f64e 63ee 	movw	r3, #61166	; 0xeeee
          return PAGE0;         /* Page0 valid */
 8011916:	1ad3      	subs	r3, r2, r3
 8011918:	fab3 f383 	clz	r3, r3
 801191c:	095b      	lsrs	r3, r3, #5
 801191e:	e7de      	b.n	80118de <EE_VerifyPageFullWriteVariable+0x3e>
  return PAGE_FULL;
 8011920:	2080      	movs	r0, #128	; 0x80
}
 8011922:	b010      	add	sp, #64	; 0x40
 8011924:	bd10      	pop	{r4, pc}
    return  NO_VALID_PAGE;
 8011926:	20ab      	movs	r0, #171	; 0xab
}
 8011928:	b010      	add	sp, #64	; 0x40
 801192a:	bd10      	pop	{r4, pc}
     FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address + 32, ((uint32_t)VirtAddress1));
 801192c:	f104 0120 	add.w	r1, r4, #32
 8011930:	aa08      	add	r2, sp, #32
 8011932:	2001      	movs	r0, #1
 8011934:	f7f3 f9c0 	bl	8004cb8 <HAL_FLASH_Program>
 8011938:	e7e7      	b.n	801190a <EE_VerifyPageFullWriteVariable+0x6a>
 801193a:	bf00      	nop
 801193c:	081c0000 	.word	0x081c0000
 8011940:	081e0000 	.word	0x081e0000
 8011944:	081bffff 	.word	0x081bffff

08011948 <EE_Init>:
{
 8011948:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t SectorError = 0;
 801194c:	f04f 0800 	mov.w	r8, #0
{
 8011950:	b09f      	sub	sp, #124	; 0x7c
  uint32_t valid[8] = {0x0000};
 8011952:	f04f 0920 	mov.w	r9, #32
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011956:	4cb3      	ldr	r4, [pc, #716]	; (8011c24 <EE_Init+0x2dc>)
  uint32_t valid[8] = {0x0000};
 8011958:	4641      	mov	r1, r8
 801195a:	a80e      	add	r0, sp, #56	; 0x38
 801195c:	464a      	mov	r2, r9
  uint32_t SectorError = 0;
 801195e:	f8cd 8008 	str.w	r8, [sp, #8]
  uint32_t valid[8] = {0x0000};
 8011962:	f015 fb3c 	bl	8026fde <memset>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011966:	8825      	ldrh	r5, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011968:	4eaf      	ldr	r6, [pc, #700]	; (8011c28 <EE_Init+0x2e0>)
  switch (PageStatus0)
 801196a:	f64e 62ee 	movw	r2, #61166	; 0xeeee
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 801196e:	b2ad      	uxth	r5, r5
  pEraseInit.Banks = FLASH_BANK_2 ;
 8011970:	2302      	movs	r3, #2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011972:	8830      	ldrh	r0, [r6, #0]
  pEraseInit.Sector = PAGE0_ID;
 8011974:	f04f 0b06 	mov.w	fp, #6
  pEraseInit.NbSectors = 1;
 8011978:	f04f 0a01 	mov.w	sl, #1
  switch (PageStatus0)
 801197c:	4295      	cmp	r5, r2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 801197e:	b287      	uxth	r7, r0
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 8011980:	f8cd 8010 	str.w	r8, [sp, #16]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8011984:	f8cd 9020 	str.w	r9, [sp, #32]
  pEraseInit.NbSectors = 1;
 8011988:	f8cd a01c 	str.w	sl, [sp, #28]
  pEraseInit.Sector = PAGE0_ID;
 801198c:	e9cd 3b05 	strd	r3, fp, [sp, #20]
  switch (PageStatus0)
 8011990:	f000 80bf 	beq.w	8011b12 <EE_Init+0x1ca>
 8011994:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8011998:	428d      	cmp	r5, r1
 801199a:	f000 808e 	beq.w	8011aba <EE_Init+0x172>
 801199e:	b35d      	cbz	r5, 80119f8 <EE_Init+0xb0>
 80119a0:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
 80119a2:	ab16      	add	r3, sp, #88	; 0x58
 80119a4:	464a      	mov	r2, r9
 80119a6:	4641      	mov	r1, r8
 80119a8:	4618      	mov	r0, r3
 80119aa:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
 80119ac:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
 80119b0:	f015 fb15 	bl	8026fde <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
 80119b4:	9b01      	ldr	r3, [sp, #4]
    if (AddressValue != ERASED)
 80119b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
 80119ba:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
 80119be:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 80119c2:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
 80119c6:	e001      	b.n	80119cc <EE_Init+0x84>
  while (Address <= PAGE0_END_ADDRESS)
 80119c8:	42b4      	cmp	r4, r6
 80119ca:	d009      	beq.n	80119e0 <EE_Init+0x98>
    AddressValue = (*(__IO uint16_t*)Address);
 80119cc:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 80119ce:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 80119d0:	429a      	cmp	r2, r3
 80119d2:	d0f9      	beq.n	80119c8 <EE_Init+0x80>
    FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 80119d4:	a903      	add	r1, sp, #12
 80119d6:	a809      	add	r0, sp, #36	; 0x24
 80119d8:	f7f3 fae8 	bl	8004fac <HAL_FLASHEx_Erase>
    if (FlashStatus != HAL_OK)
 80119dc:	2800      	cmp	r0, #0
 80119de:	d167      	bne.n	8011ab0 <EE_Init+0x168>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS,((uint32_t)valid));
 80119e0:	9a00      	ldr	r2, [sp, #0]
 80119e2:	2001      	movs	r0, #1
 80119e4:	498f      	ldr	r1, [pc, #572]	; (8011c24 <EE_Init+0x2dc>)
 80119e6:	f7f3 f967 	bl	8004cb8 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
 80119ea:	2800      	cmp	r0, #0
 80119ec:	d160      	bne.n	8011ab0 <EE_Init+0x168>
  return HAL_OK;
 80119ee:	2700      	movs	r7, #0
}
 80119f0:	4638      	mov	r0, r7
 80119f2:	b01f      	add	sp, #124	; 0x7c
 80119f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
 80119f8:	2f00      	cmp	r7, #0
 80119fa:	f000 8101 	beq.w	8011c00 <EE_Init+0x2b8>
      else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
 80119fe:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8011a02:	429f      	cmp	r7, r3
 8011a04:	d0f3      	beq.n	80119ee <EE_Init+0xa6>
  int16_t x = -1;
 8011a06:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8011a0a:	4e88      	ldr	r6, [pc, #544]	; (8011c2c <EE_Init+0x2e4>)
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8011a0c:	f8df 822c 	ldr.w	r8, [pc, #556]	; 8011c3c <EE_Init+0x2f4>
      if (PageStatus0 == VALID_PAGE)
 8011a10:	f8df b22c 	ldr.w	fp, [pc, #556]	; 8011c40 <EE_Init+0x2f8>
 8011a14:	f8df 922c 	ldr.w	r9, [pc, #556]	; 8011c44 <EE_Init+0x2fc>
 8011a18:	f8df a22c 	ldr.w	sl, [pc, #556]	; 8011c48 <EE_Init+0x300>
      else if (PageStatus1 == VALID_PAGE)
 8011a1c:	4a84      	ldr	r2, [pc, #528]	; (8011c30 <EE_Init+0x2e8>)
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8011a1e:	f8b8 3000 	ldrh.w	r3, [r8]
 8011a22:	f836 0015 	ldrh.w	r0, [r6, r5, lsl #1]
 8011a26:	4298      	cmp	r0, r3
            x = VarIdx;
 8011a28:	bf08      	it	eq
 8011a2a:	b22c      	sxtheq	r4, r5
          if (VarIdx != x)
 8011a2c:	42a5      	cmp	r5, r4
 8011a2e:	d01d      	beq.n	8011a6c <EE_Init+0x124>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011a30:	4b7c      	ldr	r3, [pc, #496]	; (8011c24 <EE_Init+0x2dc>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011a32:	497d      	ldr	r1, [pc, #500]	; (8011c28 <EE_Init+0x2e0>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011a34:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011a36:	8809      	ldrh	r1, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011a38:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011a3a:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
 8011a3c:	2b00      	cmp	r3, #0
 8011a3e:	f000 8122 	beq.w	8011c86 <EE_Init+0x33e>
      else if (PageStatus1 == VALID_PAGE)
 8011a42:	2900      	cmp	r1, #0
 8011a44:	f040 8151 	bne.w	8011cea <EE_Init+0x3a2>
 8011a48:	497a      	ldr	r1, [pc, #488]	; (8011c34 <EE_Init+0x2ec>)
 8011a4a:	4694      	mov	ip, r2
 8011a4c:	4f7a      	ldr	r7, [pc, #488]	; (8011c38 <EE_Init+0x2f0>)
 8011a4e:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
 8011a50:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
 8011a52:	4288      	cmp	r0, r1
 8011a54:	d106      	bne.n	8011a64 <EE_Init+0x11c>
 8011a56:	e12c      	b.n	8011cb2 <EE_Init+0x36a>
    AddressValue = (*(__IO uint16_t*)Address);
 8011a58:	f833 7c20 	ldrh.w	r7, [r3, #-32]
    if (AddressValue == VirtAddress)
 8011a5c:	42b8      	cmp	r0, r7
 8011a5e:	f000 8126 	beq.w	8011cae <EE_Init+0x366>
 8011a62:	460b      	mov	r3, r1
      Address = Address - 32;
 8011a64:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
 8011a68:	458c      	cmp	ip, r1
 8011a6a:	d3f5      	bcc.n	8011a58 <EE_Init+0x110>
 8011a6c:	3501      	adds	r5, #1
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8011a6e:	2d03      	cmp	r5, #3
 8011a70:	d1d5      	bne.n	8011a1e <EE_Init+0xd6>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE1_BASE_ADDRESS, ((uint32_t)valid));
 8011a72:	aa0e      	add	r2, sp, #56	; 0x38
 8011a74:	496c      	ldr	r1, [pc, #432]	; (8011c28 <EE_Init+0x2e0>)
 8011a76:	2001      	movs	r0, #1
 8011a78:	f7f3 f91e 	bl	8004cb8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
 8011a7c:	b9c0      	cbnz	r0, 8011ab0 <EE_Init+0x168>
        pEraseInit.Sector = PAGE0_ID;
 8011a7e:	2006      	movs	r0, #6
        pEraseInit.Banks = FLASH_BANK_2 ;
 8011a80:	2502      	movs	r5, #2
        pEraseInit.NbSectors = 1;
 8011a82:	2401      	movs	r4, #1
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8011a84:	2220      	movs	r2, #32
        pEraseInit.Sector = PAGE0_ID;
 8011a86:	9006      	str	r0, [sp, #24]
    if (AddressValue != ERASED)
 8011a88:	f64f 71ff 	movw	r1, #65535	; 0xffff
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8011a8c:	4b65      	ldr	r3, [pc, #404]	; (8011c24 <EE_Init+0x2dc>)
  while (Address <= PAGE0_END_ADDRESS)
 8011a8e:	4866      	ldr	r0, [pc, #408]	; (8011c28 <EE_Init+0x2e0>)
        pEraseInit.Banks = FLASH_BANK_2 ;
 8011a90:	9505      	str	r5, [sp, #20]
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8011a92:	e9cd 4207 	strd	r4, r2, [sp, #28]
 8011a96:	e001      	b.n	8011a9c <EE_Init+0x154>
  while (Address <= PAGE0_END_ADDRESS)
 8011a98:	4283      	cmp	r3, r0
 8011a9a:	d0a8      	beq.n	80119ee <EE_Init+0xa6>
    AddressValue = (*(__IO uint16_t*)Address);
 8011a9c:	881a      	ldrh	r2, [r3, #0]
    Address = Address + 4;
 8011a9e:	3304      	adds	r3, #4
    if (AddressValue != ERASED)
 8011aa0:	4291      	cmp	r1, r2
 8011aa2:	d0f9      	beq.n	8011a98 <EE_Init+0x150>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 8011aa4:	a902      	add	r1, sp, #8
 8011aa6:	a804      	add	r0, sp, #16
 8011aa8:	f7f3 fa80 	bl	8004fac <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
 8011aac:	2800      	cmp	r0, #0
 8011aae:	d09e      	beq.n	80119ee <EE_Init+0xa6>
        return FlashStatus;
 8011ab0:	b287      	uxth	r7, r0
}
 8011ab2:	4638      	mov	r0, r7
 8011ab4:	b01f      	add	sp, #124	; 0x7c
 8011ab6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
 8011aba:	b1ff      	cbz	r7, 8011afc <EE_Init+0x1b4>
      else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
 8011abc:	4297      	cmp	r7, r2
 8011abe:	f000 808b 	beq.w	8011bd8 <EE_Init+0x290>
 8011ac2:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
 8011ac4:	ab16      	add	r3, sp, #88	; 0x58
 8011ac6:	464a      	mov	r2, r9
 8011ac8:	4641      	mov	r1, r8
 8011aca:	4618      	mov	r0, r3
 8011acc:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
 8011ace:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
 8011ad2:	f015 fa84 	bl	8026fde <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
 8011ad6:	9b01      	ldr	r3, [sp, #4]
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
 8011ad8:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
 8011adc:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8011ae0:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
 8011ae4:	e002      	b.n	8011aec <EE_Init+0x1a4>
  while (Address <= PAGE0_END_ADDRESS)
 8011ae6:	42b4      	cmp	r4, r6
 8011ae8:	f43f af7a 	beq.w	80119e0 <EE_Init+0x98>
    AddressValue = (*(__IO uint16_t*)Address);
 8011aec:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 8011aee:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 8011af0:	429d      	cmp	r5, r3
 8011af2:	d0f8      	beq.n	8011ae6 <EE_Init+0x19e>
 8011af4:	e76e      	b.n	80119d4 <EE_Init+0x8c>
  while (Address <= PAGE0_END_ADDRESS)
 8011af6:	42b4      	cmp	r4, r6
 8011af8:	f43f af79 	beq.w	80119ee <EE_Init+0xa6>
    AddressValue = (*(__IO uint16_t*)Address);
 8011afc:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 8011afe:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 8011b00:	429d      	cmp	r5, r3
 8011b02:	d0f8      	beq.n	8011af6 <EE_Init+0x1ae>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 8011b04:	a902      	add	r1, sp, #8
 8011b06:	a804      	add	r0, sp, #16
 8011b08:	f7f3 fa50 	bl	8004fac <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
 8011b0c:	2800      	cmp	r0, #0
 8011b0e:	d1cf      	bne.n	8011ab0 <EE_Init+0x168>
 8011b10:	e76d      	b.n	80119ee <EE_Init+0xa6>
      if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
 8011b12:	2f00      	cmp	r7, #0
 8011b14:	d13f      	bne.n	8011b96 <EE_Init+0x24e>
 8011b16:	463c      	mov	r4, r7
  int16_t x = -1;
 8011b18:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8011b1c:	4e43      	ldr	r6, [pc, #268]	; (8011c2c <EE_Init+0x2e4>)
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8011b1e:	f8df 812c 	ldr.w	r8, [pc, #300]	; 8011c4c <EE_Init+0x304>
      if (PageStatus0 == VALID_PAGE)
 8011b22:	f8df b11c 	ldr.w	fp, [pc, #284]	; 8011c40 <EE_Init+0x2f8>
 8011b26:	f8df a120 	ldr.w	sl, [pc, #288]	; 8011c48 <EE_Init+0x300>
 8011b2a:	f8df 9118 	ldr.w	r9, [pc, #280]	; 8011c44 <EE_Init+0x2fc>
      else if (PageStatus1 == VALID_PAGE)
 8011b2e:	4a40      	ldr	r2, [pc, #256]	; (8011c30 <EE_Init+0x2e8>)
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8011b30:	f8b8 3000 	ldrh.w	r3, [r8]
 8011b34:	f836 0014 	ldrh.w	r0, [r6, r4, lsl #1]
 8011b38:	4298      	cmp	r0, r3
            x = VarIdx;
 8011b3a:	bf08      	it	eq
 8011b3c:	b225      	sxtheq	r5, r4
          if (VarIdx != x)
 8011b3e:	42ac      	cmp	r4, r5
 8011b40:	d01d      	beq.n	8011b7e <EE_Init+0x236>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011b42:	4b38      	ldr	r3, [pc, #224]	; (8011c24 <EE_Init+0x2dc>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011b44:	4938      	ldr	r1, [pc, #224]	; (8011c28 <EE_Init+0x2e0>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011b46:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011b48:	8809      	ldrh	r1, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011b4a:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011b4c:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
 8011b4e:	2b00      	cmp	r3, #0
 8011b50:	f000 8094 	beq.w	8011c7c <EE_Init+0x334>
      else if (PageStatus1 == VALID_PAGE)
 8011b54:	2900      	cmp	r1, #0
 8011b56:	f040 80c5 	bne.w	8011ce4 <EE_Init+0x39c>
 8011b5a:	4936      	ldr	r1, [pc, #216]	; (8011c34 <EE_Init+0x2ec>)
 8011b5c:	4694      	mov	ip, r2
 8011b5e:	4f36      	ldr	r7, [pc, #216]	; (8011c38 <EE_Init+0x2f0>)
 8011b60:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
 8011b62:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
 8011b64:	4288      	cmp	r0, r1
 8011b66:	d106      	bne.n	8011b76 <EE_Init+0x22e>
 8011b68:	e094      	b.n	8011c94 <EE_Init+0x34c>
    AddressValue = (*(__IO uint16_t*)Address);
 8011b6a:	f833 7c20 	ldrh.w	r7, [r3, #-32]
    if (AddressValue == VirtAddress)
 8011b6e:	42b8      	cmp	r0, r7
 8011b70:	f000 808e 	beq.w	8011c90 <EE_Init+0x348>
 8011b74:	460b      	mov	r3, r1
      Address = Address - 32;
 8011b76:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
 8011b7a:	4561      	cmp	r1, ip
 8011b7c:	d8f5      	bhi.n	8011b6a <EE_Init+0x222>
 8011b7e:	3401      	adds	r4, #1
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8011b80:	2c03      	cmp	r4, #3
 8011b82:	d1d5      	bne.n	8011b30 <EE_Init+0x1e8>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
 8011b84:	aa0e      	add	r2, sp, #56	; 0x38
 8011b86:	4927      	ldr	r1, [pc, #156]	; (8011c24 <EE_Init+0x2dc>)
 8011b88:	2001      	movs	r0, #1
 8011b8a:	f7f3 f895 	bl	8004cb8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
 8011b8e:	2800      	cmp	r0, #0
 8011b90:	f43f af2d 	beq.w	80119ee <EE_Init+0xa6>
 8011b94:	e78c      	b.n	8011ab0 <EE_Init+0x168>
      else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
 8011b96:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8011b9a:	42af      	cmp	r7, r5
 8011b9c:	f000 8096 	beq.w	8011ccc <EE_Init+0x384>
 8011ba0:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
 8011ba2:	ab16      	add	r3, sp, #88	; 0x58
 8011ba4:	464a      	mov	r2, r9
 8011ba6:	4641      	mov	r1, r8
 8011ba8:	4618      	mov	r0, r3
 8011baa:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
 8011bac:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
 8011bb0:	f015 fa15 	bl	8026fde <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
 8011bb4:	9b01      	ldr	r3, [sp, #4]
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
 8011bb6:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
 8011bba:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8011bbe:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
 8011bc2:	e002      	b.n	8011bca <EE_Init+0x282>
  while (Address <= PAGE0_END_ADDRESS)
 8011bc4:	42b4      	cmp	r4, r6
 8011bc6:	f43f af0b 	beq.w	80119e0 <EE_Init+0x98>
    AddressValue = (*(__IO uint16_t*)Address);
 8011bca:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 8011bcc:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 8011bce:	429d      	cmp	r5, r3
 8011bd0:	d0f8      	beq.n	8011bc4 <EE_Init+0x27c>
 8011bd2:	e6ff      	b.n	80119d4 <EE_Init+0x8c>
  while (Address <= PAGE0_END_ADDRESS)
 8011bd4:	42b4      	cmp	r4, r6
 8011bd6:	d00a      	beq.n	8011bee <EE_Init+0x2a6>
    AddressValue = (*(__IO uint16_t*)Address);
 8011bd8:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 8011bda:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 8011bdc:	429d      	cmp	r5, r3
 8011bde:	d0f9      	beq.n	8011bd4 <EE_Init+0x28c>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 8011be0:	a902      	add	r1, sp, #8
 8011be2:	a804      	add	r0, sp, #16
 8011be4:	f7f3 f9e2 	bl	8004fac <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
 8011be8:	2800      	cmp	r0, #0
 8011bea:	f47f af61 	bne.w	8011ab0 <EE_Init+0x168>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE1_BASE_ADDRESS, ((uint32_t)valid));
 8011bee:	aa0e      	add	r2, sp, #56	; 0x38
 8011bf0:	490d      	ldr	r1, [pc, #52]	; (8011c28 <EE_Init+0x2e0>)
 8011bf2:	2001      	movs	r0, #1
 8011bf4:	f7f3 f860 	bl	8004cb8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
 8011bf8:	2800      	cmp	r0, #0
 8011bfa:	f43f aef8 	beq.w	80119ee <EE_Init+0xa6>
 8011bfe:	e757      	b.n	8011ab0 <EE_Init+0x168>
 8011c00:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
 8011c02:	ab16      	add	r3, sp, #88	; 0x58
 8011c04:	464a      	mov	r2, r9
 8011c06:	4639      	mov	r1, r7
 8011c08:	4618      	mov	r0, r3
 8011c0a:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
 8011c0c:	9703      	str	r7, [sp, #12]
  uint32_t valid[8] = {0x0000};
 8011c0e:	f015 f9e6 	bl	8026fde <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
 8011c12:	9b01      	ldr	r3, [sp, #4]
    if (AddressValue != ERASED)
 8011c14:	f64f 72ff 	movw	r2, #65535	; 0xffff
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
 8011c18:	9709      	str	r7, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
 8011c1a:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8011c1e:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
 8011c22:	e017      	b.n	8011c54 <EE_Init+0x30c>
 8011c24:	081c0000 	.word	0x081c0000
 8011c28:	081e0000 	.word	0x081e0000
 8011c2c:	2000001c 	.word	0x2000001c
 8011c30:	081e0020 	.word	0x081e0020
 8011c34:	081fffe0 	.word	0x081fffe0
 8011c38:	081fffc0 	.word	0x081fffc0
 8011c3c:	081e0006 	.word	0x081e0006
 8011c40:	081dffc0 	.word	0x081dffc0
 8011c44:	081dffe0 	.word	0x081dffe0
 8011c48:	081c0020 	.word	0x081c0020
 8011c4c:	081c0006 	.word	0x081c0006
  while (Address <= PAGE0_END_ADDRESS)
 8011c50:	42b4      	cmp	r4, r6
 8011c52:	d00a      	beq.n	8011c6a <EE_Init+0x322>
    AddressValue = (*(__IO uint16_t*)Address);
 8011c54:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 8011c56:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 8011c58:	429a      	cmp	r2, r3
 8011c5a:	d0f9      	beq.n	8011c50 <EE_Init+0x308>
    FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 8011c5c:	a903      	add	r1, sp, #12
 8011c5e:	a809      	add	r0, sp, #36	; 0x24
 8011c60:	f7f3 f9a4 	bl	8004fac <HAL_FLASHEx_Erase>
    if (FlashStatus != HAL_OK)
 8011c64:	2800      	cmp	r0, #0
 8011c66:	f47f af23 	bne.w	8011ab0 <EE_Init+0x168>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS,((uint32_t)valid));
 8011c6a:	9a00      	ldr	r2, [sp, #0]
 8011c6c:	2001      	movs	r0, #1
 8011c6e:	4920      	ldr	r1, [pc, #128]	; (8011cf0 <EE_Init+0x3a8>)
 8011c70:	f7f3 f822 	bl	8004cb8 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
 8011c74:	2800      	cmp	r0, #0
 8011c76:	f43f aebb 	beq.w	80119f0 <EE_Init+0xa8>
 8011c7a:	e719      	b.n	8011ab0 <EE_Init+0x168>
      if (PageStatus0 == VALID_PAGE)
 8011c7c:	465f      	mov	r7, fp
 8011c7e:	46d4      	mov	ip, sl
 8011c80:	4649      	mov	r1, r9
 8011c82:	464b      	mov	r3, r9
 8011c84:	e76d      	b.n	8011b62 <EE_Init+0x21a>
 8011c86:	465f      	mov	r7, fp
 8011c88:	4649      	mov	r1, r9
 8011c8a:	464b      	mov	r3, r9
 8011c8c:	46d4      	mov	ip, sl
 8011c8e:	e6df      	b.n	8011a50 <EE_Init+0x108>
 8011c90:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
 8011c94:	8839      	ldrh	r1, [r7, #0]
 8011c96:	4b17      	ldr	r3, [pc, #92]	; (8011cf4 <EE_Init+0x3ac>)
 8011c98:	b289      	uxth	r1, r1
 8011c9a:	8019      	strh	r1, [r3, #0]
 8011c9c:	9200      	str	r2, [sp, #0]
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 8011c9e:	f7ff fdff 	bl	80118a0 <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != HAL_OK)
 8011ca2:	9a00      	ldr	r2, [sp, #0]
 8011ca4:	4607      	mov	r7, r0
 8011ca6:	2800      	cmp	r0, #0
 8011ca8:	f43f af69 	beq.w	8011b7e <EE_Init+0x236>
 8011cac:	e6a0      	b.n	80119f0 <EE_Init+0xa8>
 8011cae:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
 8011cb2:	8839      	ldrh	r1, [r7, #0]
 8011cb4:	4b0f      	ldr	r3, [pc, #60]	; (8011cf4 <EE_Init+0x3ac>)
 8011cb6:	b289      	uxth	r1, r1
 8011cb8:	8019      	strh	r1, [r3, #0]
 8011cba:	9200      	str	r2, [sp, #0]
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 8011cbc:	f7ff fdf0 	bl	80118a0 <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != HAL_OK)
 8011cc0:	9a00      	ldr	r2, [sp, #0]
 8011cc2:	4607      	mov	r7, r0
 8011cc4:	2800      	cmp	r0, #0
 8011cc6:	f43f aed1 	beq.w	8011a6c <EE_Init+0x124>
 8011cca:	e691      	b.n	80119f0 <EE_Init+0xa8>
        pEraseInit.Sector = PAGE1_ID;
 8011ccc:	2307      	movs	r3, #7
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
 8011cce:	aa0e      	add	r2, sp, #56	; 0x38
 8011cd0:	4621      	mov	r1, r4
 8011cd2:	4650      	mov	r0, sl
        pEraseInit.Sector = PAGE1_ID;
 8011cd4:	e9cd a305 	strd	sl, r3, [sp, #20]
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
 8011cd8:	f7f2 ffee 	bl	8004cb8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
 8011cdc:	2800      	cmp	r0, #0
 8011cde:	f43f ae86 	beq.w	80119ee <EE_Init+0xa6>
 8011ce2:	e6e5      	b.n	8011ab0 <EE_Init+0x168>
 8011ce4:	4b03      	ldr	r3, [pc, #12]	; (8011cf4 <EE_Init+0x3ac>)
 8011ce6:	8819      	ldrh	r1, [r3, #0]
 8011ce8:	e7d8      	b.n	8011c9c <EE_Init+0x354>
 8011cea:	4b02      	ldr	r3, [pc, #8]	; (8011cf4 <EE_Init+0x3ac>)
 8011cec:	8819      	ldrh	r1, [r3, #0]
 8011cee:	e7e4      	b.n	8011cba <EE_Init+0x372>
 8011cf0:	081c0000 	.word	0x081c0000
 8011cf4:	20000512 	.word	0x20000512

08011cf8 <EE_ReadVariable>:
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011cf8:	4b15      	ldr	r3, [pc, #84]	; (8011d50 <EE_ReadVariable+0x58>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011cfa:	4a16      	ldr	r2, [pc, #88]	; (8011d54 <EE_ReadVariable+0x5c>)
{
 8011cfc:	b430      	push	{r4, r5}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011cfe:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011d00:	8812      	ldrh	r2, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011d02:	b29b      	uxth	r3, r3
      if (PageStatus0 == VALID_PAGE)
 8011d04:	b133      	cbz	r3, 8011d14 <EE_ReadVariable+0x1c>
 8011d06:	b292      	uxth	r2, r2
      else if (PageStatus1 == VALID_PAGE)
 8011d08:	b9fa      	cbnz	r2, 8011d4a <EE_ReadVariable+0x52>
 8011d0a:	4b13      	ldr	r3, [pc, #76]	; (8011d58 <EE_ReadVariable+0x60>)
 8011d0c:	4c13      	ldr	r4, [pc, #76]	; (8011d5c <EE_ReadVariable+0x64>)
 8011d0e:	461a      	mov	r2, r3
 8011d10:	4d13      	ldr	r5, [pc, #76]	; (8011d60 <EE_ReadVariable+0x68>)
 8011d12:	e003      	b.n	8011d1c <EE_ReadVariable+0x24>
      if (PageStatus0 == VALID_PAGE)
 8011d14:	4b13      	ldr	r3, [pc, #76]	; (8011d64 <EE_ReadVariable+0x6c>)
 8011d16:	4c14      	ldr	r4, [pc, #80]	; (8011d68 <EE_ReadVariable+0x70>)
 8011d18:	461a      	mov	r2, r3
 8011d1a:	4d14      	ldr	r5, [pc, #80]	; (8011d6c <EE_ReadVariable+0x74>)
    AddressValue = (*(__IO uint16_t*)Address);
 8011d1c:	8812      	ldrh	r2, [r2, #0]
    if (AddressValue == VirtAddress)
 8011d1e:	4290      	cmp	r0, r2
 8011d20:	d105      	bne.n	8011d2e <EE_ReadVariable+0x36>
 8011d22:	e00d      	b.n	8011d40 <EE_ReadVariable+0x48>
    AddressValue = (*(__IO uint16_t*)Address);
 8011d24:	f833 4c20 	ldrh.w	r4, [r3, #-32]
    if (AddressValue == VirtAddress)
 8011d28:	42a0      	cmp	r0, r4
 8011d2a:	d007      	beq.n	8011d3c <EE_ReadVariable+0x44>
 8011d2c:	4613      	mov	r3, r2
      Address = Address - 32;
 8011d2e:	f1a3 0220 	sub.w	r2, r3, #32
  while (Address > (PageStartAddress + 32))
 8011d32:	42aa      	cmp	r2, r5
 8011d34:	d8f6      	bhi.n	8011d24 <EE_ReadVariable+0x2c>
  uint16_t AddressValue = 0x5555, ReadStatus = 1;
 8011d36:	2001      	movs	r0, #1
}
 8011d38:	bc30      	pop	{r4, r5}
 8011d3a:	4770      	bx	lr
 8011d3c:	f1a3 0440 	sub.w	r4, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
 8011d40:	8823      	ldrh	r3, [r4, #0]
      ReadStatus = 0;
 8011d42:	2000      	movs	r0, #0
      *Data = (*(__IO uint16_t*)(Address - 32));
 8011d44:	800b      	strh	r3, [r1, #0]
}
 8011d46:	bc30      	pop	{r4, r5}
 8011d48:	4770      	bx	lr
    return  NO_VALID_PAGE;
 8011d4a:	20ab      	movs	r0, #171	; 0xab
}
 8011d4c:	bc30      	pop	{r4, r5}
 8011d4e:	4770      	bx	lr
 8011d50:	081c0000 	.word	0x081c0000
 8011d54:	081e0000 	.word	0x081e0000
 8011d58:	081fffe0 	.word	0x081fffe0
 8011d5c:	081fffc0 	.word	0x081fffc0
 8011d60:	081e0020 	.word	0x081e0020
 8011d64:	081dffe0 	.word	0x081dffe0
 8011d68:	081dffc0 	.word	0x081dffc0
 8011d6c:	081c0020 	.word	0x081c0020

08011d70 <EE_WriteVariable>:
{
 8011d70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t data32[8] = {Data};
 8011d74:	2300      	movs	r3, #0
{
 8011d76:	b099      	sub	sp, #100	; 0x64
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011d78:	4c71      	ldr	r4, [pc, #452]	; (8011f40 <EE_WriteVariable+0x1d0>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011d7a:	4a72      	ldr	r2, [pc, #456]	; (8011f44 <EE_WriteVariable+0x1d4>)
  uint32_t VirtAddress1[8] = {VirtAddress};
 8011d7c:	9010      	str	r0, [sp, #64]	; 0x40
  uint32_t data32[8] = {Data};
 8011d7e:	9108      	str	r1, [sp, #32]
 8011d80:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t VirtAddress1[8] = {VirtAddress};
 8011d82:	9317      	str	r3, [sp, #92]	; 0x5c
  uint32_t data32[8] = {Data};
 8011d84:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
 8011d88:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
 8011d8c:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  uint32_t VirtAddress1[8] = {VirtAddress};
 8011d90:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
 8011d94:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
 8011d98:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011d9c:	8823      	ldrh	r3, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011d9e:	8812      	ldrh	r2, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011da0:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011da2:	b292      	uxth	r2, r2
      if (PageStatus1 == VALID_PAGE)
 8011da4:	bb2a      	cbnz	r2, 8011df2 <EE_WriteVariable+0x82>
        if (PageStatus0 == RECEIVE_DATA)
 8011da6:	f64e 62ee 	movw	r2, #61166	; 0xeeee
          return PAGE1;         /* Page1 valid */
 8011daa:	1a9b      	subs	r3, r3, r2
 8011dac:	bf18      	it	ne
 8011dae:	2301      	movne	r3, #1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 8011db0:	f203 470e 	addw	r7, r3, #1038	; 0x40e
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
 8011db4:	4a64      	ldr	r2, [pc, #400]	; (8011f48 <EE_WriteVariable+0x1d8>)
 8011db6:	3301      	adds	r3, #1
 8011db8:	4688      	mov	r8, r1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 8011dba:	047f      	lsls	r7, r7, #17
 8011dbc:	4604      	mov	r4, r0
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
 8011dbe:	eb02 4243 	add.w	r2, r2, r3, lsl #17
  while (Address < PageEndAddress)
 8011dc2:	4297      	cmp	r7, r2
 8011dc4:	d303      	bcc.n	8011dce <EE_WriteVariable+0x5e>
 8011dc6:	e021      	b.n	8011e0c <EE_WriteVariable+0x9c>
      Address = Address + 64;
 8011dc8:	3740      	adds	r7, #64	; 0x40
  while (Address < PageEndAddress)
 8011dca:	42ba      	cmp	r2, r7
 8011dcc:	d91e      	bls.n	8011e0c <EE_WriteVariable+0x9c>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
 8011dce:	683b      	ldr	r3, [r7, #0]
 8011dd0:	3301      	adds	r3, #1
 8011dd2:	d1f9      	bne.n	8011dc8 <EE_WriteVariable+0x58>
      FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, ((uint32_t)data32));
 8011dd4:	ae08      	add	r6, sp, #32
 8011dd6:	4639      	mov	r1, r7
 8011dd8:	2001      	movs	r0, #1
 8011dda:	4632      	mov	r2, r6
 8011ddc:	f7f2 ff6c 	bl	8004cb8 <HAL_FLASH_Program>
      if (FlashStatus != HAL_OK)
 8011de0:	2800      	cmp	r0, #0
 8011de2:	d03f      	beq.n	8011e64 <EE_WriteVariable+0xf4>
     return FlashStatus;
 8011de4:	b285      	uxth	r5, r0
  if (Status == PAGE_FULL)
 8011de6:	2d80      	cmp	r5, #128	; 0x80
 8011de8:	d011      	beq.n	8011e0e <EE_WriteVariable+0x9e>
}
 8011dea:	4628      	mov	r0, r5
 8011dec:	b019      	add	sp, #100	; 0x64
 8011dee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      else if (PageStatus0 == VALID_PAGE)
 8011df2:	b933      	cbnz	r3, 8011e02 <EE_WriteVariable+0x92>
        if (PageStatus1 == RECEIVE_DATA)
 8011df4:	f64e 63ee 	movw	r3, #61166	; 0xeeee
          return PAGE1;         /* Page1 valid */
 8011df8:	1ad3      	subs	r3, r2, r3
 8011dfa:	fab3 f383 	clz	r3, r3
 8011dfe:	095b      	lsrs	r3, r3, #5
 8011e00:	e7d6      	b.n	8011db0 <EE_WriteVariable+0x40>
    /* Old page ID where variable will be taken from */
    OldPageId = PAGE0_ID;
  }
  else
  {
    return NO_VALID_PAGE;       /* No valid Page */
 8011e02:	25ab      	movs	r5, #171	; 0xab
}
 8011e04:	4628      	mov	r0, r5
 8011e06:	b019      	add	sp, #100	; 0x64
 8011e08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011e0c:	ae08      	add	r6, sp, #32
  uint32_t SectorError = 0;
 8011e0e:	2500      	movs	r5, #0
  uint32_t valid[8] = {0x0000};
 8011e10:	2220      	movs	r2, #32
 8011e12:	4630      	mov	r0, r6
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011e14:	4f4b      	ldr	r7, [pc, #300]	; (8011f44 <EE_WriteVariable+0x1d4>)
  uint32_t valid[8] = {0x0000};
 8011e16:	4629      	mov	r1, r5
  uint32_t SectorError = 0;
 8011e18:	9502      	str	r5, [sp, #8]
  uint32_t valid[8] = {0x0000};
 8011e1a:	f015 f8e0 	bl	8026fde <memset>
  uint32_t receive[8] = {0xEEEE};
 8011e1e:	f64e 63ee 	movw	r3, #61166	; 0xeeee
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011e22:	4947      	ldr	r1, [pc, #284]	; (8011f40 <EE_WriteVariable+0x1d0>)
  uint32_t receive[8] = {0xEEEE};
 8011e24:	9517      	str	r5, [sp, #92]	; 0x5c
 8011e26:	9310      	str	r3, [sp, #64]	; 0x40
 8011e28:	e9cd 5511 	strd	r5, r5, [sp, #68]	; 0x44
 8011e2c:	e9cd 5513 	strd	r5, r5, [sp, #76]	; 0x4c
 8011e30:	e9cd 5515 	strd	r5, r5, [sp, #84]	; 0x54
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011e34:	880b      	ldrh	r3, [r1, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011e36:	883a      	ldrh	r2, [r7, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011e38:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011e3a:	b292      	uxth	r2, r2
      if (PageStatus0 == VALID_PAGE)
 8011e3c:	b17b      	cbz	r3, 8011e5e <EE_WriteVariable+0xee>
      else if (PageStatus1 == VALID_PAGE)
 8011e3e:	2a00      	cmp	r2, #0
 8011e40:	d1df      	bne.n	8011e02 <EE_WriteVariable+0x92>
    NewPageAddress = PAGE0_BASE_ADDRESS;
 8011e42:	460f      	mov	r7, r1
      else if (PageStatus1 == VALID_PAGE)
 8011e44:	f04f 0907 	mov.w	r9, #7
  }

  /* Set the new Page status to RECEIVE_DATA status */

  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)receive));
 8011e48:	aa10      	add	r2, sp, #64	; 0x40
 8011e4a:	4639      	mov	r1, r7
 8011e4c:	2001      	movs	r0, #1
 8011e4e:	f7f2 ff33 	bl	8004cb8 <HAL_FLASH_Program>

  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
 8011e52:	b170      	cbz	r0, 8011e72 <EE_WriteVariable+0x102>
  /* Set new Page status to VALID_PAGE status */
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)valid));
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
  {
    return FlashStatus;
 8011e54:	b285      	uxth	r5, r0
}
 8011e56:	4628      	mov	r0, r5
 8011e58:	b019      	add	sp, #100	; 0x64
 8011e5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus0 == VALID_PAGE)
 8011e5e:	f04f 0906 	mov.w	r9, #6
 8011e62:	e7f1      	b.n	8011e48 <EE_WriteVariable+0xd8>
     FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address + 32, ((uint32_t)VirtAddress1));
 8011e64:	f107 0120 	add.w	r1, r7, #32
 8011e68:	aa10      	add	r2, sp, #64	; 0x40
 8011e6a:	2001      	movs	r0, #1
 8011e6c:	f7f2 ff24 	bl	8004cb8 <HAL_FLASH_Program>
 8011e70:	e7b8      	b.n	8011de4 <EE_WriteVariable+0x74>
  EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8011e72:	4641      	mov	r1, r8
 8011e74:	4620      	mov	r0, r4
 8011e76:	f7ff fd13 	bl	80118a0 <EE_VerifyPageFullWriteVariable>
  if (EepromStatus != HAL_OK)
 8011e7a:	4605      	mov	r5, r0
 8011e7c:	2800      	cmp	r0, #0
 8011e7e:	d1b4      	bne.n	8011dea <EE_WriteVariable+0x7a>
 8011e80:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 8011f58 <EE_WriteVariable+0x1e8>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011e84:	4a2e      	ldr	r2, [pc, #184]	; (8011f40 <EE_WriteVariable+0x1d0>)
 8011e86:	f108 0a06 	add.w	sl, r8, #6
      if (PageStatus0 == VALID_PAGE)
 8011e8a:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 8011f5c <EE_WriteVariable+0x1ec>
    if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
 8011e8e:	f838 0b02 	ldrh.w	r0, [r8], #2
 8011e92:	4284      	cmp	r4, r0
 8011e94:	d01b      	beq.n	8011ece <EE_WriteVariable+0x15e>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011e96:	8813      	ldrh	r3, [r2, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011e98:	492a      	ldr	r1, [pc, #168]	; (8011f44 <EE_WriteVariable+0x1d4>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8011e9a:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8011e9c:	8809      	ldrh	r1, [r1, #0]
 8011e9e:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
 8011ea0:	2b00      	cmp	r3, #0
 8011ea2:	d034      	beq.n	8011f0e <EE_WriteVariable+0x19e>
      else if (PageStatus1 == VALID_PAGE)
 8011ea4:	2900      	cmp	r1, #0
 8011ea6:	d148      	bne.n	8011f3a <EE_WriteVariable+0x1ca>
 8011ea8:	4928      	ldr	r1, [pc, #160]	; (8011f4c <EE_WriteVariable+0x1dc>)
 8011eaa:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 8011f60 <EE_WriteVariable+0x1f0>
 8011eae:	f8df c0b4 	ldr.w	ip, [pc, #180]	; 8011f64 <EE_WriteVariable+0x1f4>
 8011eb2:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
 8011eb4:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
 8011eb6:	4288      	cmp	r0, r1
 8011eb8:	d105      	bne.n	8011ec6 <EE_WriteVariable+0x156>
 8011eba:	e031      	b.n	8011f20 <EE_WriteVariable+0x1b0>
    AddressValue = (*(__IO uint16_t*)Address);
 8011ebc:	f833 cc20 	ldrh.w	ip, [r3, #-32]
    if (AddressValue == VirtAddress)
 8011ec0:	4560      	cmp	r0, ip
 8011ec2:	d02b      	beq.n	8011f1c <EE_WriteVariable+0x1ac>
 8011ec4:	460b      	mov	r3, r1
      Address = Address - 32;
 8011ec6:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
 8011eca:	458e      	cmp	lr, r1
 8011ecc:	d3f6      	bcc.n	8011ebc <EE_WriteVariable+0x14c>
  for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8011ece:	45d0      	cmp	r8, sl
 8011ed0:	d1dd      	bne.n	8011e8e <EE_WriteVariable+0x11e>
  HAL_FLASH_Unlock();
 8011ed2:	f7f2 ff67 	bl	8004da4 <HAL_FLASH_Unlock>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 8011ed6:	4b1e      	ldr	r3, [pc, #120]	; (8011f50 <EE_WriteVariable+0x1e0>)
 8011ed8:	f44f 008e 	mov.w	r0, #4653056	; 0x470000
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 8011edc:	2100      	movs	r1, #0
  pEraseInit.Banks = FLASH_BANK_2 ;
 8011ede:	2202      	movs	r2, #2
  pEraseInit.NbSectors = 1;
 8011ee0:	2401      	movs	r4, #1
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 8011ee2:	6158      	str	r0, [r3, #20]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8011ee4:	2320      	movs	r3, #32
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 8011ee6:	9103      	str	r1, [sp, #12]
  FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 8011ee8:	a803      	add	r0, sp, #12
 8011eea:	a902      	add	r1, sp, #8
  pEraseInit.Sector = OldPageId;
 8011eec:	f8cd 9014 	str.w	r9, [sp, #20]
  pEraseInit.Banks = FLASH_BANK_2 ;
 8011ef0:	9204      	str	r2, [sp, #16]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8011ef2:	e9cd 4306 	strd	r4, r3, [sp, #24]
  FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 8011ef6:	f7f3 f859 	bl	8004fac <HAL_FLASHEx_Erase>
  if (FlashStatus != HAL_OK)
 8011efa:	2800      	cmp	r0, #0
 8011efc:	d1aa      	bne.n	8011e54 <EE_WriteVariable+0xe4>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)valid));
 8011efe:	4632      	mov	r2, r6
 8011f00:	4639      	mov	r1, r7
 8011f02:	4620      	mov	r0, r4
 8011f04:	f7f2 fed8 	bl	8004cb8 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
 8011f08:	2800      	cmp	r0, #0
 8011f0a:	d1a3      	bne.n	8011e54 <EE_WriteVariable+0xe4>
 8011f0c:	e76d      	b.n	8011dea <EE_WriteVariable+0x7a>
      if (PageStatus0 == VALID_PAGE)
 8011f0e:	f8df c058 	ldr.w	ip, [pc, #88]	; 8011f68 <EE_WriteVariable+0x1f8>
 8011f12:	4659      	mov	r1, fp
 8011f14:	465b      	mov	r3, fp
 8011f16:	f8df e054 	ldr.w	lr, [pc, #84]	; 8011f6c <EE_WriteVariable+0x1fc>
 8011f1a:	e7cb      	b.n	8011eb4 <EE_WriteVariable+0x144>
 8011f1c:	f1a3 0c40 	sub.w	ip, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
 8011f20:	f8bc 1000 	ldrh.w	r1, [ip]
 8011f24:	4b0b      	ldr	r3, [pc, #44]	; (8011f54 <EE_WriteVariable+0x1e4>)
 8011f26:	b289      	uxth	r1, r1
 8011f28:	8019      	strh	r1, [r3, #0]
 8011f2a:	9201      	str	r2, [sp, #4]
        EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 8011f2c:	f7ff fcb8 	bl	80118a0 <EE_VerifyPageFullWriteVariable>
        if (EepromStatus != HAL_OK)
 8011f30:	9a01      	ldr	r2, [sp, #4]
 8011f32:	2800      	cmp	r0, #0
 8011f34:	d0cb      	beq.n	8011ece <EE_WriteVariable+0x15e>
 8011f36:	4605      	mov	r5, r0
  return Status;
 8011f38:	e757      	b.n	8011dea <EE_WriteVariable+0x7a>
 8011f3a:	4b06      	ldr	r3, [pc, #24]	; (8011f54 <EE_WriteVariable+0x1e4>)
 8011f3c:	8819      	ldrh	r1, [r3, #0]
 8011f3e:	e7f4      	b.n	8011f2a <EE_WriteVariable+0x1ba>
 8011f40:	081c0000 	.word	0x081c0000
 8011f44:	081e0000 	.word	0x081e0000
 8011f48:	081bffff 	.word	0x081bffff
 8011f4c:	081fffe0 	.word	0x081fffe0
 8011f50:	52002000 	.word	0x52002000
 8011f54:	20000512 	.word	0x20000512
 8011f58:	2000001c 	.word	0x2000001c
 8011f5c:	081dffe0 	.word	0x081dffe0
 8011f60:	081e0020 	.word	0x081e0020
 8011f64:	081fffc0 	.word	0x081fffc0
 8011f68:	081dffc0 	.word	0x081dffc0
 8011f6c:	081c0020 	.word	0x081c0020

08011f70 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
 8011f70:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
 8011f72:	4903      	ldr	r1, [pc, #12]	; (8011f80 <MX_FATFS_Init+0x10>)
 8011f74:	4803      	ldr	r0, [pc, #12]	; (8011f84 <MX_FATFS_Init+0x14>)
 8011f76:	f7fe fcad 	bl	80108d4 <FATFS_LinkDriver>
 8011f7a:	4b03      	ldr	r3, [pc, #12]	; (8011f88 <MX_FATFS_Init+0x18>)
 8011f7c:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */     
  /* USER CODE END Init */
}
 8011f7e:	bd08      	pop	{r3, pc}
 8011f80:	200010e0 	.word	0x200010e0
 8011f84:	0802a1a0 	.word	0x0802a1a0
 8011f88:	200010dc 	.word	0x200010dc

08011f8c <BSP_PlatformIsDetected>:
  *
  ******************************************************************************
*/
#include "fatfs_platform.h"

uint8_t	BSP_PlatformIsDetected(void) {
 8011f8c:	b508      	push	{r3, lr}
    uint8_t status = SD_PRESENT;
    /* Check SD card detect pin */
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 8011f8e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8011f92:	4803      	ldr	r0, [pc, #12]	; (8011fa0 <BSP_PlatformIsDetected+0x14>)
 8011f94:	f7f3 fc3c 	bl	8005810 <HAL_GPIO_ReadPin>
    }
    /* USER CODE BEGIN 1 */
    /* user code can be inserted here */
    /* USER CODE END 1 */ 
    return status;
}  
 8011f98:	fab0 f080 	clz	r0, r0
 8011f9c:	0940      	lsrs	r0, r0, #5
 8011f9e:	bd08      	pop	{r3, pc}
 8011fa0:	58020800 	.word	0x58020800

08011fa4 <MX_FMC_Init>:

SDRAM_HandleTypeDef hsdram1;

/* FMC initialization function */
void MX_FMC_Init(void)
{
 8011fa4:	b570      	push	{r4, r5, r6, lr}
  FMC_SDRAM_TimingTypeDef SdramTiming = {0};

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8011fa6:	4b18      	ldr	r3, [pc, #96]	; (8012008 <MX_FMC_Init+0x64>)
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
 8011fa8:	2001      	movs	r0, #1
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8011faa:	4d18      	ldr	r5, [pc, #96]	; (801200c <MX_FMC_Init+0x68>)
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
 8011fac:	2108      	movs	r1, #8
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
 8011fae:	2410      	movs	r4, #16
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8011fb0:	2240      	movs	r2, #64	; 0x40
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8011fb2:	601d      	str	r5, [r3, #0]
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
 8011fb4:	f44f 7580 	mov.w	r5, #256	; 0x100
{
 8011fb8:	b088      	sub	sp, #32
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
  SdramTiming.ExitSelfRefreshDelay = 6;
  SdramTiming.SelfRefreshTime = 4;
 8011fba:	2604      	movs	r6, #4
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
 8011fbc:	6098      	str	r0, [r3, #8]
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_3;
 8011fbe:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
 8011fc2:	60d9      	str	r1, [r3, #12]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 8011fc4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
 8011fc8:	611c      	str	r4, [r3, #16]
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
 8011fca:	2400      	movs	r4, #0
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8011fcc:	615a      	str	r2, [r3, #20]
  SdramTiming.LoadToActiveDelay = 2;
 8011fce:	2202      	movs	r2, #2
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
 8011fd0:	619d      	str	r5, [r3, #24]
  SdramTiming.ExitSelfRefreshDelay = 6;
 8011fd2:	2506      	movs	r5, #6
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_3;
 8011fd4:	6218      	str	r0, [r3, #32]
  SdramTiming.RowCycleDelay = 6;
  SdramTiming.WriteRecoveryTime = 2;
  SdramTiming.RPDelay = 2;
  SdramTiming.RCDDelay = 2;

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 8011fd6:	4618      	mov	r0, r3
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 8011fd8:	6259      	str	r1, [r3, #36]	; 0x24
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 8011fda:	eb0d 0106 	add.w	r1, sp, r6
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
 8011fde:	605c      	str	r4, [r3, #4]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 8011fe0:	61dc      	str	r4, [r3, #28]
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
 8011fe2:	629c      	str	r4, [r3, #40]	; 0x28
  SdramTiming.LoadToActiveDelay = 2;
 8011fe4:	9201      	str	r2, [sp, #4]
  SdramTiming.RCDDelay = 2;
 8011fe6:	9207      	str	r2, [sp, #28]
  SdramTiming.ExitSelfRefreshDelay = 6;
 8011fe8:	9502      	str	r5, [sp, #8]
  SdramTiming.RPDelay = 2;
 8011fea:	e9cd 2205 	strd	r2, r2, [sp, #20]
  SdramTiming.SelfRefreshTime = 4;
 8011fee:	e9cd 6503 	strd	r6, r5, [sp, #12]
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 8011ff2:	f7fa f903 	bl	800c1fc <HAL_SDRAM_Init>
 8011ff6:	b108      	cbz	r0, 8011ffc <MX_FMC_Init+0x58>
  {
    Error_Handler( );
 8011ff8:	f001 fc68 	bl	80138cc <Error_Handler>
  }

  HAL_SetFMCMemorySwappingConfig(FMC_SWAPBMAP_SDRAM_SRAM);
 8011ffc:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 8012000:	f7ee fd30 	bl	8000a64 <HAL_SetFMCMemorySwappingConfig>

}
 8012004:	b008      	add	sp, #32
 8012006:	bd70      	pop	{r4, r5, r6, pc}
 8012008:	20001544 	.word	0x20001544
 801200c:	52004140 	.word	0x52004140

08012010 <HAL_SDRAM_MspInit>:
static void HAL_FMC_MspInit(void){
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if (FMC_Initialized) {
 8012010:	4a2a      	ldr	r2, [pc, #168]	; (80120bc <HAL_SDRAM_MspInit+0xac>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012012:	2300      	movs	r3, #0
  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
 8012014:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012016:	b087      	sub	sp, #28
  if (FMC_Initialized) {
 8012018:	6814      	ldr	r4, [r2, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801201a:	e9cd 3301 	strd	r3, r3, [sp, #4]
 801201e:	e9cd 3303 	strd	r3, r3, [sp, #12]
 8012022:	9305      	str	r3, [sp, #20]
  if (FMC_Initialized) {
 8012024:	b10c      	cbz	r4, 801202a <HAL_SDRAM_MspInit+0x1a>
  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
 8012026:	b007      	add	sp, #28
 8012028:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_RCC_FMC_CLK_ENABLE();
 801202a:	4b25      	ldr	r3, [pc, #148]	; (80120c0 <HAL_SDRAM_MspInit+0xb0>)
  FMC_Initialized = 1;
 801202c:	2101      	movs	r1, #1
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
 801202e:	f64f 003f 	movw	r0, #63551	; 0xf83f
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012032:	2702      	movs	r7, #2
  FMC_Initialized = 1;
 8012034:	6011      	str	r1, [r2, #0]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012036:	2603      	movs	r6, #3
  __HAL_RCC_FMC_CLK_ENABLE();
 8012038:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 801203c:	250c      	movs	r5, #12
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 801203e:	a901      	add	r1, sp, #4
  __HAL_RCC_FMC_CLK_ENABLE();
 8012040:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8012044:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
 8012048:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
 801204c:	9001      	str	r0, [sp, #4]
  __HAL_RCC_FMC_CLK_ENABLE();
 801204e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8012052:	481c      	ldr	r0, [pc, #112]	; (80120c4 <HAL_SDRAM_MspInit+0xb4>)
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012054:	9702      	str	r7, [sp, #8]
  __HAL_RCC_FMC_CLK_ENABLE();
 8012056:	9300      	str	r3, [sp, #0]
 8012058:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 801205a:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 801205e:	f7f3 f8af 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
 8012062:	230d      	movs	r3, #13
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012064:	a901      	add	r1, sp, #4
 8012066:	4818      	ldr	r0, [pc, #96]	; (80120c8 <HAL_SDRAM_MspInit+0xb8>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
 8012068:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801206a:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801206c:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 801206e:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012072:	f7f3 f8a5 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4 
 8012076:	f248 1337 	movw	r3, #33079	; 0x8137
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 801207a:	a901      	add	r1, sp, #4
 801207c:	4813      	ldr	r0, [pc, #76]	; (80120cc <HAL_SDRAM_MspInit+0xbc>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4 
 801207e:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012080:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012082:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8012084:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8012088:	f7f3 f89a 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
 801208c:	f64f 7383 	movw	r3, #65411	; 0xff83
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8012090:	a901      	add	r1, sp, #4
 8012092:	480f      	ldr	r0, [pc, #60]	; (80120d0 <HAL_SDRAM_MspInit+0xc0>)
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
 8012094:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012096:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012098:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 801209a:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 801209e:	f7f3 f88f 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
 80120a2:	f24c 7303 	movw	r3, #50947	; 0xc703
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80120a6:	a901      	add	r1, sp, #4
 80120a8:	480a      	ldr	r0, [pc, #40]	; (80120d4 <HAL_SDRAM_MspInit+0xc4>)
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80120aa:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80120ac:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
 80120ae:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 80120b0:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80120b4:	f7f3 f884 	bl	80051c0 <HAL_GPIO_Init>
}
 80120b8:	b007      	add	sp, #28
 80120ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80120bc:	20000514 	.word	0x20000514
 80120c0:	58024400 	.word	0x58024400
 80120c4:	58021400 	.word	0x58021400
 80120c8:	58020800 	.word	0x58020800
 80120cc:	58021800 	.word	0x58021800
 80120d0:	58021000 	.word	0x58021000
 80120d4:	58020c00 	.word	0x58020c00

080120d8 <GFXdrawPixel.part.0>:
void GFXstartWrite(GFX* myGFX){
    // Overwrite in subclasses if desired!
}

// the most basic function, set a single pixel
void GFXdrawPixel(GFX* myGFX, int16_t x, int16_t y, uint16_t color) {
 80120d8:	b430      	push	{r4, r5}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
    return;

  // check rotation, move pixel around if necessary
  switch (GFXgetRotation(myGFX)) {
 80120da:	7a04      	ldrb	r4, [r0, #8]
 80120dc:	2c02      	cmp	r4, #2
 80120de:	d050      	beq.n	8012182 <GFXdrawPixel.part.0+0xaa>
 80120e0:	2c03      	cmp	r4, #3
 80120e2:	d048      	beq.n	8012176 <GFXdrawPixel.part.0+0x9e>
 80120e4:	2c01      	cmp	r4, #1
 80120e6:	d018      	beq.n	801211a <GFXdrawPixel.part.0+0x42>
    y = myGFX->HEIGHT - y - 1;
    break;
  }

  // x is which column
    switch (color)
 80120e8:	2b01      	cmp	r3, #1
 80120ea:	d01e      	beq.n	801212a <GFXdrawPixel.part.0+0x52>
 80120ec:	d32f      	bcc.n	801214e <GFXdrawPixel.part.0+0x76>
 80120ee:	2b02      	cmp	r3, #2
 80120f0:	d111      	bne.n	8012116 <GFXdrawPixel.part.0+0x3e>
    {
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
      case INVERSE: buffer[x+ (y/8)*myGFX->WIDTH] ^=  (1 << (y&7)); break;
 80120f2:	2a00      	cmp	r2, #0
 80120f4:	4613      	mov	r3, r2
 80120f6:	8804      	ldrh	r4, [r0, #0]
 80120f8:	f04f 0001 	mov.w	r0, #1
 80120fc:	bfb8      	it	lt
 80120fe:	1dd3      	addlt	r3, r2, #7
 8012100:	f002 0207 	and.w	r2, r2, #7
 8012104:	10db      	asrs	r3, r3, #3
 8012106:	fa00 f202 	lsl.w	r2, r0, r2
 801210a:	fb13 1104 	smlabb	r1, r3, r4, r1
 801210e:	4b22      	ldr	r3, [pc, #136]	; (8012198 <GFXdrawPixel.part.0+0xc0>)
 8012110:	5c58      	ldrb	r0, [r3, r1]
 8012112:	4042      	eors	r2, r0
 8012114:	545a      	strb	r2, [r3, r1]
    }

}
 8012116:	bc30      	pop	{r4, r5}
 8012118:	4770      	bx	lr
    x = myGFX->WIDTH - x - 1;
 801211a:	43d4      	mvns	r4, r2
 801211c:	8805      	ldrh	r5, [r0, #0]
    _swap_int16_t(x, y);
 801211e:	460a      	mov	r2, r1
    switch (color)
 8012120:	2b01      	cmp	r3, #1
    x = myGFX->WIDTH - x - 1;
 8012122:	eb04 0105 	add.w	r1, r4, r5
 8012126:	b209      	sxth	r1, r1
    switch (color)
 8012128:	d1e0      	bne.n	80120ec <GFXdrawPixel.part.0+0x14>
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
 801212a:	2a00      	cmp	r2, #0
 801212c:	4613      	mov	r3, r2
 801212e:	8804      	ldrh	r4, [r0, #0]
 8012130:	f002 0007 	and.w	r0, r2, #7
 8012134:	bfb8      	it	lt
 8012136:	1dd3      	addlt	r3, r2, #7
 8012138:	2201      	movs	r2, #1
 801213a:	10db      	asrs	r3, r3, #3
 801213c:	4082      	lsls	r2, r0
 801213e:	fb13 1104 	smlabb	r1, r3, r4, r1
 8012142:	4b15      	ldr	r3, [pc, #84]	; (8012198 <GFXdrawPixel.part.0+0xc0>)
 8012144:	5c58      	ldrb	r0, [r3, r1]
 8012146:	4302      	orrs	r2, r0
 8012148:	545a      	strb	r2, [r3, r1]
}
 801214a:	bc30      	pop	{r4, r5}
 801214c:	4770      	bx	lr
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
 801214e:	2a00      	cmp	r2, #0
 8012150:	4613      	mov	r3, r2
 8012152:	8800      	ldrh	r0, [r0, #0]
 8012154:	f002 0407 	and.w	r4, r2, #7
 8012158:	bfb8      	it	lt
 801215a:	1dd3      	addlt	r3, r2, #7
 801215c:	2201      	movs	r2, #1
 801215e:	10db      	asrs	r3, r3, #3
 8012160:	fb13 1100 	smlabb	r1, r3, r0, r1
 8012164:	480c      	ldr	r0, [pc, #48]	; (8012198 <GFXdrawPixel.part.0+0xc0>)
 8012166:	fa02 f304 	lsl.w	r3, r2, r4
 801216a:	5c42      	ldrb	r2, [r0, r1]
 801216c:	ea22 0203 	bic.w	r2, r2, r3
 8012170:	5442      	strb	r2, [r0, r1]
}
 8012172:	bc30      	pop	{r4, r5}
 8012174:	4770      	bx	lr
    y = myGFX->HEIGHT - y - 1;
 8012176:	43cc      	mvns	r4, r1
 8012178:	8845      	ldrh	r5, [r0, #2]
	_swap_int16_t(x, y);
 801217a:	4611      	mov	r1, r2
    y = myGFX->HEIGHT - y - 1;
 801217c:	1962      	adds	r2, r4, r5
 801217e:	b212      	sxth	r2, r2
 8012180:	e7b2      	b.n	80120e8 <GFXdrawPixel.part.0+0x10>
 8012182:	43c9      	mvns	r1, r1
 8012184:	43d2      	mvns	r2, r2
    x = myGFX->WIDTH - x - 1;
 8012186:	8805      	ldrh	r5, [r0, #0]
    y = myGFX->HEIGHT - y - 1;
 8012188:	8844      	ldrh	r4, [r0, #2]
    x = myGFX->WIDTH - x - 1;
 801218a:	fa05 f181 	sxtah	r1, r5, r1
    y = myGFX->HEIGHT - y - 1;
 801218e:	4422      	add	r2, r4
    x = myGFX->WIDTH - x - 1;
 8012190:	b209      	sxth	r1, r1
    y = myGFX->HEIGHT - y - 1;
 8012192:	b212      	sxth	r2, r2
 8012194:	e7a8      	b.n	80120e8 <GFXdrawPixel.part.0+0x10>
 8012196:	bf00      	nop
 8012198:	2001847c 	.word	0x2001847c

0801219c <GFXinit>:
	myGfx->WIDTH = w;
 801219c:	2300      	movs	r3, #0
	myGfx->_width    = w;
 801219e:	8081      	strh	r1, [r0, #4]
	myGfx->_height   = h;
 80121a0:	80c2      	strh	r2, [r0, #6]
	myGfx->WIDTH = w;
 80121a2:	f361 030f 	bfi	r3, r1, #0, #16
	myGfx->rotation  = 0;
 80121a6:	2101      	movs	r1, #1
	myGfx->WIDTH = w;
 80121a8:	f362 431f 	bfi	r3, r2, #16, #16
	myGfx->fontHeight = 8;
 80121ac:	2208      	movs	r2, #8
	myGfx->rotation  = 0;
 80121ae:	6141      	str	r1, [r0, #20]
	myGfx->WIDTH = w;
 80121b0:	6003      	str	r3, [r0, #0]
	myGfx->rotation  = 0;
 80121b2:	2300      	movs	r3, #0
	myGfx->fontHeight = 8;
 80121b4:	61c2      	str	r2, [r0, #28]
	myGfx->rotation  = 0;
 80121b6:	6083      	str	r3, [r0, #8]
	myGfx->gfxFont   = NULL;
 80121b8:	6183      	str	r3, [r0, #24]
{
 80121ba:	b430      	push	{r4, r5}
	myGfx->rotation  = 0;
 80121bc:	f44f 3580 	mov.w	r5, #65536	; 0x10000
 80121c0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80121c4:	e9c0 5403 	strd	r5, r4, [r0, #12]
}
 80121c8:	bc30      	pop	{r4, r5}
 80121ca:	4770      	bx	lr

080121cc <GFXwriteLine>:
        uint16_t color) {
 80121cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80121d0:	b083      	sub	sp, #12
 80121d2:	460e      	mov	r6, r1
 80121d4:	4614      	mov	r4, r2
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80121d6:	4694      	mov	ip, r2
        uint16_t color) {
 80121d8:	f9bd 7030 	ldrsh.w	r7, [sp, #48]	; 0x30
 80121dc:	4683      	mov	fp, r0
 80121de:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80121e2:	1ab9      	subs	r1, r7, r2
 80121e4:	1b9a      	subs	r2, r3, r6
        uint16_t color) {
 80121e6:	9001      	str	r0, [sp, #4]
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80121e8:	2900      	cmp	r1, #0
 80121ea:	bfb8      	it	lt
 80121ec:	4249      	neglt	r1, r1
 80121ee:	2a00      	cmp	r2, #0
 80121f0:	bfb8      	it	lt
 80121f2:	4252      	neglt	r2, r2
    if (steep) {
 80121f4:	4291      	cmp	r1, r2
 80121f6:	dc6d      	bgt.n	80122d4 <GFXwriteLine+0x108>
 80121f8:	46be      	mov	lr, r7
 80121fa:	463d      	mov	r5, r7
 80121fc:	46a0      	mov	r8, r4
 80121fe:	461f      	mov	r7, r3
 8012200:	4634      	mov	r4, r6
 8012202:	4673      	mov	r3, lr
 8012204:	4666      	mov	r6, ip
 8012206:	4689      	mov	r9, r1
    if (x0 > x1) {
 8012208:	42bc      	cmp	r4, r7
 801220a:	dd0b      	ble.n	8012224 <GFXwriteLine+0x58>
 801220c:	eba8 0005 	sub.w	r0, r8, r5
 8012210:	46b6      	mov	lr, r6
 8012212:	46a4      	mov	ip, r4
        _swap_int16_t(y0, y1);
 8012214:	461e      	mov	r6, r3
 8012216:	ea80 79e0 	eor.w	r9, r0, r0, asr #31
    if (x0 > x1) {
 801221a:	463c      	mov	r4, r7
        _swap_int16_t(y0, y1);
 801221c:	4673      	mov	r3, lr
    if (x0 > x1) {
 801221e:	4667      	mov	r7, ip
 8012220:	eba9 79e0 	sub.w	r9, r9, r0, asr #31
    dx = x1 - x0;
 8012224:	eba7 0804 	sub.w	r8, r7, r4
    dy = abs(y1 - y0);
 8012228:	fa0f f989 	sxth.w	r9, r9
    dx = x1 - x0;
 801222c:	fa0f f888 	sxth.w	r8, r8
    int16_t err = dx / 2;
 8012230:	f1b8 0f00 	cmp.w	r8, #0
 8012234:	4645      	mov	r5, r8
 8012236:	bfb8      	it	lt
 8012238:	f108 0501 	addlt.w	r5, r8, #1
        ystep = -1;
 801223c:	429e      	cmp	r6, r3
 801223e:	bfb4      	ite	lt
 8012240:	f04f 0a01 	movlt.w	sl, #1
 8012244:	f04f 3aff 	movge.w	sl, #4294967295	; 0xffffffff
 8012248:	4291      	cmp	r1, r2
    int16_t err = dx / 2;
 801224a:	ea4f 0565 	mov.w	r5, r5, asr #1
 801224e:	dc38      	bgt.n	80122c2 <GFXwriteLine+0xf6>
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 8012250:	2c00      	cmp	r4, #0
 8012252:	db0f      	blt.n	8012274 <GFXwriteLine+0xa8>
 8012254:	f8bb 3004 	ldrh.w	r3, [fp, #4]
 8012258:	42a3      	cmp	r3, r4
 801225a:	dd0b      	ble.n	8012274 <GFXwriteLine+0xa8>
 801225c:	0432      	lsls	r2, r6, #16
 801225e:	d409      	bmi.n	8012274 <GFXwriteLine+0xa8>
 8012260:	f8bb 0006 	ldrh.w	r0, [fp, #6]
 8012264:	4632      	mov	r2, r6
 8012266:	4621      	mov	r1, r4
 8012268:	9b01      	ldr	r3, [sp, #4]
 801226a:	42b0      	cmp	r0, r6
 801226c:	4658      	mov	r0, fp
 801226e:	dd01      	ble.n	8012274 <GFXwriteLine+0xa8>
 8012270:	f7ff ff32 	bl	80120d8 <GFXdrawPixel.part.0>
        err -= dy;
 8012274:	eba5 0509 	sub.w	r5, r5, r9
    for (; x0<=x1; x0++) {
 8012278:	3401      	adds	r4, #1
        err -= dy;
 801227a:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
 801227c:	b224      	sxth	r4, r4
        if (err < 0) {
 801227e:	2d00      	cmp	r5, #0
 8012280:	da03      	bge.n	801228a <GFXwriteLine+0xbe>
            y0 += ystep;
 8012282:	4456      	add	r6, sl
            err += dx;
 8012284:	4445      	add	r5, r8
            y0 += ystep;
 8012286:	b236      	sxth	r6, r6
            err += dx;
 8012288:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
 801228a:	42bc      	cmp	r4, r7
 801228c:	dde0      	ble.n	8012250 <GFXwriteLine+0x84>
}
 801228e:	b003      	add	sp, #12
 8012290:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 8012294:	f8bb 0006 	ldrh.w	r0, [fp, #6]
 8012298:	4622      	mov	r2, r4
 801229a:	4631      	mov	r1, r6
 801229c:	9b01      	ldr	r3, [sp, #4]
 801229e:	4284      	cmp	r4, r0
 80122a0:	4658      	mov	r0, fp
 80122a2:	da01      	bge.n	80122a8 <GFXwriteLine+0xdc>
 80122a4:	f7ff ff18 	bl	80120d8 <GFXdrawPixel.part.0>
        err -= dy;
 80122a8:	eba5 0509 	sub.w	r5, r5, r9
    for (; x0<=x1; x0++) {
 80122ac:	3401      	adds	r4, #1
        err -= dy;
 80122ae:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
 80122b0:	b224      	sxth	r4, r4
        if (err < 0) {
 80122b2:	2d00      	cmp	r5, #0
 80122b4:	da03      	bge.n	80122be <GFXwriteLine+0xf2>
            y0 += ystep;
 80122b6:	4456      	add	r6, sl
            err += dx;
 80122b8:	4445      	add	r5, r8
            y0 += ystep;
 80122ba:	b236      	sxth	r6, r6
            err += dx;
 80122bc:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
 80122be:	42bc      	cmp	r4, r7
 80122c0:	dce5      	bgt.n	801228e <GFXwriteLine+0xc2>
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80122c2:	2e00      	cmp	r6, #0
 80122c4:	dbf0      	blt.n	80122a8 <GFXwriteLine+0xdc>
 80122c6:	f8bb 3004 	ldrh.w	r3, [fp, #4]
 80122ca:	429e      	cmp	r6, r3
 80122cc:	daec      	bge.n	80122a8 <GFXwriteLine+0xdc>
 80122ce:	0423      	lsls	r3, r4, #16
 80122d0:	d4ea      	bmi.n	80122a8 <GFXwriteLine+0xdc>
 80122d2:	e7df      	b.n	8012294 <GFXwriteLine+0xc8>
 80122d4:	461d      	mov	r5, r3
 80122d6:	46b0      	mov	r8, r6
 80122d8:	4691      	mov	r9, r2
 80122da:	e795      	b.n	8012208 <GFXwriteLine+0x3c>

080122dc <GFXdrawPixel>:
 80122dc:	2900      	cmp	r1, #0
 80122de:	db28      	blt.n	8012332 <GFXdrawPixel+0x56>
void GFXdrawPixel(GFX* myGFX, int16_t x, int16_t y, uint16_t color) {
 80122e0:	b430      	push	{r4, r5}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80122e2:	8884      	ldrh	r4, [r0, #4]
 80122e4:	42a1      	cmp	r1, r4
 80122e6:	da22      	bge.n	801232e <GFXdrawPixel+0x52>
 80122e8:	2a00      	cmp	r2, #0
 80122ea:	db20      	blt.n	801232e <GFXdrawPixel+0x52>
 80122ec:	88c4      	ldrh	r4, [r0, #6]
 80122ee:	42a2      	cmp	r2, r4
 80122f0:	da1d      	bge.n	801232e <GFXdrawPixel+0x52>
  switch (GFXgetRotation(myGFX)) {
 80122f2:	7a04      	ldrb	r4, [r0, #8]
 80122f4:	2c02      	cmp	r4, #2
 80122f6:	d04e      	beq.n	8012396 <GFXdrawPixel+0xba>
 80122f8:	2c03      	cmp	r4, #3
 80122fa:	d046      	beq.n	801238a <GFXdrawPixel+0xae>
 80122fc:	2c01      	cmp	r4, #1
 80122fe:	d019      	beq.n	8012334 <GFXdrawPixel+0x58>
    switch (color)
 8012300:	2b01      	cmp	r3, #1
 8012302:	d02f      	beq.n	8012364 <GFXdrawPixel+0x88>
 8012304:	d31c      	bcc.n	8012340 <GFXdrawPixel+0x64>
 8012306:	2b02      	cmp	r3, #2
 8012308:	d111      	bne.n	801232e <GFXdrawPixel+0x52>
      case INVERSE: buffer[x+ (y/8)*myGFX->WIDTH] ^=  (1 << (y&7)); break;
 801230a:	2a00      	cmp	r2, #0
 801230c:	4613      	mov	r3, r2
 801230e:	8804      	ldrh	r4, [r0, #0]
 8012310:	f04f 0001 	mov.w	r0, #1
 8012314:	bfb8      	it	lt
 8012316:	1dd3      	addlt	r3, r2, #7
 8012318:	f002 0207 	and.w	r2, r2, #7
 801231c:	10db      	asrs	r3, r3, #3
 801231e:	fa00 f202 	lsl.w	r2, r0, r2
 8012322:	fb13 1104 	smlabb	r1, r3, r4, r1
 8012326:	4b20      	ldr	r3, [pc, #128]	; (80123a8 <GFXdrawPixel+0xcc>)
 8012328:	5c58      	ldrb	r0, [r3, r1]
 801232a:	4042      	eors	r2, r0
 801232c:	545a      	strb	r2, [r3, r1]
}
 801232e:	bc30      	pop	{r4, r5}
 8012330:	4770      	bx	lr
 8012332:	4770      	bx	lr
    x = myGFX->WIDTH - x - 1;
 8012334:	43d4      	mvns	r4, r2
 8012336:	8805      	ldrh	r5, [r0, #0]
 8012338:	460a      	mov	r2, r1
 801233a:	1961      	adds	r1, r4, r5
 801233c:	b209      	sxth	r1, r1
 801233e:	e7df      	b.n	8012300 <GFXdrawPixel+0x24>
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
 8012340:	2a00      	cmp	r2, #0
 8012342:	4613      	mov	r3, r2
 8012344:	8800      	ldrh	r0, [r0, #0]
 8012346:	f002 0407 	and.w	r4, r2, #7
 801234a:	bfb8      	it	lt
 801234c:	1dd3      	addlt	r3, r2, #7
 801234e:	2201      	movs	r2, #1
 8012350:	10db      	asrs	r3, r3, #3
 8012352:	40a2      	lsls	r2, r4
 8012354:	fb13 1100 	smlabb	r1, r3, r0, r1
 8012358:	4813      	ldr	r0, [pc, #76]	; (80123a8 <GFXdrawPixel+0xcc>)
 801235a:	5c43      	ldrb	r3, [r0, r1]
 801235c:	ea23 0302 	bic.w	r3, r3, r2
 8012360:	5443      	strb	r3, [r0, r1]
 8012362:	e7e4      	b.n	801232e <GFXdrawPixel+0x52>
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
 8012364:	2a00      	cmp	r2, #0
 8012366:	4613      	mov	r3, r2
 8012368:	8804      	ldrh	r4, [r0, #0]
 801236a:	f04f 0001 	mov.w	r0, #1
 801236e:	bfb8      	it	lt
 8012370:	1dd3      	addlt	r3, r2, #7
 8012372:	f002 0207 	and.w	r2, r2, #7
 8012376:	10db      	asrs	r3, r3, #3
 8012378:	fb13 1104 	smlabb	r1, r3, r4, r1
 801237c:	4c0a      	ldr	r4, [pc, #40]	; (80123a8 <GFXdrawPixel+0xcc>)
 801237e:	fa00 f302 	lsl.w	r3, r0, r2
 8012382:	5c62      	ldrb	r2, [r4, r1]
 8012384:	4313      	orrs	r3, r2
 8012386:	5463      	strb	r3, [r4, r1]
 8012388:	e7d1      	b.n	801232e <GFXdrawPixel+0x52>
    y = myGFX->HEIGHT - y - 1;
 801238a:	8844      	ldrh	r4, [r0, #2]
 801238c:	3c01      	subs	r4, #1
 801238e:	1a64      	subs	r4, r4, r1
 8012390:	4611      	mov	r1, r2
 8012392:	b222      	sxth	r2, r4
 8012394:	e7b4      	b.n	8012300 <GFXdrawPixel+0x24>
    x = myGFX->WIDTH - x - 1;
 8012396:	8804      	ldrh	r4, [r0, #0]
    y = myGFX->HEIGHT - y - 1;
 8012398:	43d2      	mvns	r2, r2
 801239a:	8845      	ldrh	r5, [r0, #2]
    x = myGFX->WIDTH - x - 1;
 801239c:	3c01      	subs	r4, #1
    y = myGFX->HEIGHT - y - 1;
 801239e:	442a      	add	r2, r5
    x = myGFX->WIDTH - x - 1;
 80123a0:	1a61      	subs	r1, r4, r1
    y = myGFX->HEIGHT - y - 1;
 80123a2:	b212      	sxth	r2, r2
    x = myGFX->WIDTH - x - 1;
 80123a4:	b209      	sxth	r1, r1
 80123a6:	e7ab      	b.n	8012300 <GFXdrawPixel+0x24>
 80123a8:	2001847c 	.word	0x2001847c

080123ac <GFXfillRect>:
 80123ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80123b0:	440b      	add	r3, r1
 80123b2:	b089      	sub	sp, #36	; 0x24
 80123b4:	428b      	cmp	r3, r1
 80123b6:	f8bd 504c 	ldrh.w	r5, [sp, #76]	; 0x4c
 80123ba:	f9bd 4048 	ldrsh.w	r4, [sp, #72]	; 0x48
 80123be:	9502      	str	r5, [sp, #8]
 80123c0:	dd25      	ble.n	801240e <GFXfillRect+0x62>
 80123c2:	1e67      	subs	r7, r4, #1
 80123c4:	4417      	add	r7, r2
 80123c6:	b23f      	sxth	r7, r7
 80123c8:	42ba      	cmp	r2, r7
 80123ca:	bfcb      	itete	gt
 80123cc:	4615      	movgt	r5, r2
 80123ce:	463d      	movle	r5, r7
 80123d0:	463c      	movgt	r4, r7
 80123d2:	4614      	movle	r4, r2
 80123d4:	9506      	str	r5, [sp, #24]
 80123d6:	9405      	str	r4, [sp, #20]
 80123d8:	1b2c      	subs	r4, r5, r4
 80123da:	b224      	sxth	r4, r4
 80123dc:	2c00      	cmp	r4, #0
 80123de:	4625      	mov	r5, r4
 80123e0:	9404      	str	r4, [sp, #16]
 80123e2:	bfb8      	it	lt
 80123e4:	1c65      	addlt	r5, r4, #1
 80123e6:	1abc      	subs	r4, r7, r2
 80123e8:	2c00      	cmp	r4, #0
 80123ea:	ea4f 0565 	mov.w	r5, r5, asr #1
 80123ee:	bfb8      	it	lt
 80123f0:	4264      	neglt	r4, r4
 80123f2:	9507      	str	r5, [sp, #28]
 80123f4:	b224      	sxth	r4, r4
 80123f6:	9403      	str	r4, [sp, #12]
 80123f8:	42ba      	cmp	r2, r7
 80123fa:	d00b      	beq.n	8012414 <GFXfillRect+0x68>
 80123fc:	e9dd 4505 	ldrd	r4, r5, [sp, #20]
 8012400:	42ac      	cmp	r4, r5
 8012402:	f340 80f6 	ble.w	80125f2 <GFXfillRect+0x246>
 8012406:	3101      	adds	r1, #1
 8012408:	b209      	sxth	r1, r1
 801240a:	4299      	cmp	r1, r3
 801240c:	dbf4      	blt.n	80123f8 <GFXfillRect+0x4c>
 801240e:	b009      	add	sp, #36	; 0x24
 8012410:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8012414:	f04f 0900 	mov.w	r9, #0
 8012418:	f8dd e00c 	ldr.w	lr, [sp, #12]
 801241c:	468c      	mov	ip, r1
 801241e:	460d      	mov	r5, r1
 8012420:	464c      	mov	r4, r9
 8012422:	4616      	mov	r6, r2
 8012424:	9301      	str	r3, [sp, #4]
 8012426:	e045      	b.n	80124b4 <GFXfillRect+0x108>
 8012428:	2e00      	cmp	r6, #0
 801242a:	db36      	blt.n	801249a <GFXfillRect+0xee>
 801242c:	f8b0 8004 	ldrh.w	r8, [r0, #4]
 8012430:	4546      	cmp	r6, r8
 8012432:	da32      	bge.n	801249a <GFXfillRect+0xee>
 8012434:	042b      	lsls	r3, r5, #16
 8012436:	d430      	bmi.n	801249a <GFXfillRect+0xee>
 8012438:	f8b0 8006 	ldrh.w	r8, [r0, #6]
 801243c:	4545      	cmp	r5, r8
 801243e:	da2c      	bge.n	801249a <GFXfillRect+0xee>
 8012440:	f890 8008 	ldrb.w	r8, [r0, #8]
 8012444:	f1b8 0f02 	cmp.w	r8, #2
 8012448:	f000 80c2 	beq.w	80125d0 <GFXfillRect+0x224>
 801244c:	f1b8 0f03 	cmp.w	r8, #3
 8012450:	f000 80b4 	beq.w	80125bc <GFXfillRect+0x210>
 8012454:	f1b8 0f01 	cmp.w	r8, #1
 8012458:	f000 80a6 	beq.w	80125a8 <GFXfillRect+0x1fc>
 801245c:	46a8      	mov	r8, r5
 801245e:	46b2      	mov	sl, r6
 8012460:	9b02      	ldr	r3, [sp, #8]
 8012462:	2b01      	cmp	r3, #1
 8012464:	d044      	beq.n	80124f0 <GFXfillRect+0x144>
 8012466:	d362      	bcc.n	801252e <GFXfillRect+0x182>
 8012468:	2b02      	cmp	r3, #2
 801246a:	d116      	bne.n	801249a <GFXfillRect+0xee>
 801246c:	f1b8 0f00 	cmp.w	r8, #0
 8012470:	46c3      	mov	fp, r8
 8012472:	8803      	ldrh	r3, [r0, #0]
 8012474:	bfb8      	it	lt
 8012476:	f108 0b07 	addlt.w	fp, r8, #7
 801247a:	f008 0807 	and.w	r8, r8, #7
 801247e:	ea4f 0beb 	mov.w	fp, fp, asr #3
 8012482:	fb1b aa03 	smlabb	sl, fp, r3, sl
 8012486:	2301      	movs	r3, #1
 8012488:	fa03 f808 	lsl.w	r8, r3, r8
 801248c:	4b5e      	ldr	r3, [pc, #376]	; (8012608 <GFXfillRect+0x25c>)
 801248e:	f813 b00a 	ldrb.w	fp, [r3, sl]
 8012492:	ea88 080b 	eor.w	r8, r8, fp
 8012496:	f803 800a 	strb.w	r8, [r3, sl]
 801249a:	eba4 040e 	sub.w	r4, r4, lr
 801249e:	b224      	sxth	r4, r4
 80124a0:	2c00      	cmp	r4, #0
 80124a2:	da03      	bge.n	80124ac <GFXfillRect+0x100>
 80124a4:	3e01      	subs	r6, #1
 80124a6:	444c      	add	r4, r9
 80124a8:	b236      	sxth	r6, r6
 80124aa:	b224      	sxth	r4, r4
 80124ac:	3501      	adds	r5, #1
 80124ae:	b22d      	sxth	r5, r5
 80124b0:	4565      	cmp	r5, ip
 80124b2:	dc35      	bgt.n	8012520 <GFXfillRect+0x174>
 80124b4:	42ba      	cmp	r2, r7
 80124b6:	d1b7      	bne.n	8012428 <GFXfillRect+0x7c>
 80124b8:	2d00      	cmp	r5, #0
 80124ba:	dbee      	blt.n	801249a <GFXfillRect+0xee>
 80124bc:	f8b0 8004 	ldrh.w	r8, [r0, #4]
 80124c0:	4545      	cmp	r5, r8
 80124c2:	daea      	bge.n	801249a <GFXfillRect+0xee>
 80124c4:	0433      	lsls	r3, r6, #16
 80124c6:	d4e8      	bmi.n	801249a <GFXfillRect+0xee>
 80124c8:	f8b0 8006 	ldrh.w	r8, [r0, #6]
 80124cc:	4546      	cmp	r6, r8
 80124ce:	dae4      	bge.n	801249a <GFXfillRect+0xee>
 80124d0:	f890 8008 	ldrb.w	r8, [r0, #8]
 80124d4:	f1b8 0f02 	cmp.w	r8, #2
 80124d8:	d04b      	beq.n	8012572 <GFXfillRect+0x1c6>
 80124da:	f1b8 0f03 	cmp.w	r8, #3
 80124de:	d03e      	beq.n	801255e <GFXfillRect+0x1b2>
 80124e0:	f1b8 0f01 	cmp.w	r8, #1
 80124e4:	d056      	beq.n	8012594 <GFXfillRect+0x1e8>
 80124e6:	9b02      	ldr	r3, [sp, #8]
 80124e8:	46b0      	mov	r8, r6
 80124ea:	46aa      	mov	sl, r5
 80124ec:	2b01      	cmp	r3, #1
 80124ee:	d1ba      	bne.n	8012466 <GFXfillRect+0xba>
 80124f0:	f1b8 0f00 	cmp.w	r8, #0
 80124f4:	46c3      	mov	fp, r8
 80124f6:	8803      	ldrh	r3, [r0, #0]
 80124f8:	bfb8      	it	lt
 80124fa:	f108 0b07 	addlt.w	fp, r8, #7
 80124fe:	f008 0807 	and.w	r8, r8, #7
 8012502:	ea4f 0beb 	mov.w	fp, fp, asr #3
 8012506:	fb1b aa03 	smlabb	sl, fp, r3, sl
 801250a:	2301      	movs	r3, #1
 801250c:	fa03 f808 	lsl.w	r8, r3, r8
 8012510:	4b3d      	ldr	r3, [pc, #244]	; (8012608 <GFXfillRect+0x25c>)
 8012512:	f813 b00a 	ldrb.w	fp, [r3, sl]
 8012516:	ea48 080b 	orr.w	r8, r8, fp
 801251a:	f803 800a 	strb.w	r8, [r3, sl]
 801251e:	e7bc      	b.n	801249a <GFXfillRect+0xee>
 8012520:	3101      	adds	r1, #1
 8012522:	9b01      	ldr	r3, [sp, #4]
 8012524:	b209      	sxth	r1, r1
 8012526:	4299      	cmp	r1, r3
 8012528:	f6ff af66 	blt.w	80123f8 <GFXfillRect+0x4c>
 801252c:	e76f      	b.n	801240e <GFXfillRect+0x62>
 801252e:	f1b8 0f00 	cmp.w	r8, #0
 8012532:	46c3      	mov	fp, r8
 8012534:	8803      	ldrh	r3, [r0, #0]
 8012536:	bfb8      	it	lt
 8012538:	f108 0b07 	addlt.w	fp, r8, #7
 801253c:	f008 0807 	and.w	r8, r8, #7
 8012540:	ea4f 0beb 	mov.w	fp, fp, asr #3
 8012544:	fb1b aa03 	smlabb	sl, fp, r3, sl
 8012548:	2301      	movs	r3, #1
 801254a:	fa03 f808 	lsl.w	r8, r3, r8
 801254e:	4b2e      	ldr	r3, [pc, #184]	; (8012608 <GFXfillRect+0x25c>)
 8012550:	f813 b00a 	ldrb.w	fp, [r3, sl]
 8012554:	ea2b 0808 	bic.w	r8, fp, r8
 8012558:	f803 800a 	strb.w	r8, [r3, sl]
 801255c:	e79d      	b.n	801249a <GFXfillRect+0xee>
 801255e:	f8b0 8002 	ldrh.w	r8, [r0, #2]
 8012562:	46b2      	mov	sl, r6
 8012564:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 8012568:	eba8 0805 	sub.w	r8, r8, r5
 801256c:	fa0f f888 	sxth.w	r8, r8
 8012570:	e776      	b.n	8012460 <GFXfillRect+0xb4>
 8012572:	f8b0 a000 	ldrh.w	sl, [r0]
 8012576:	f8b0 8002 	ldrh.w	r8, [r0, #2]
 801257a:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 801257e:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 8012582:	ebaa 0a05 	sub.w	sl, sl, r5
 8012586:	eba8 0806 	sub.w	r8, r8, r6
 801258a:	fa0f fa8a 	sxth.w	sl, sl
 801258e:	fa0f f888 	sxth.w	r8, r8
 8012592:	e765      	b.n	8012460 <GFXfillRect+0xb4>
 8012594:	f8b0 a000 	ldrh.w	sl, [r0]
 8012598:	46a8      	mov	r8, r5
 801259a:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 801259e:	ebaa 0a06 	sub.w	sl, sl, r6
 80125a2:	fa0f fa8a 	sxth.w	sl, sl
 80125a6:	e75b      	b.n	8012460 <GFXfillRect+0xb4>
 80125a8:	f8b0 a000 	ldrh.w	sl, [r0]
 80125ac:	46b0      	mov	r8, r6
 80125ae:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 80125b2:	ebaa 0a05 	sub.w	sl, sl, r5
 80125b6:	fa0f fa8a 	sxth.w	sl, sl
 80125ba:	e751      	b.n	8012460 <GFXfillRect+0xb4>
 80125bc:	f8b0 8002 	ldrh.w	r8, [r0, #2]
 80125c0:	46aa      	mov	sl, r5
 80125c2:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 80125c6:	eba8 0806 	sub.w	r8, r8, r6
 80125ca:	fa0f f888 	sxth.w	r8, r8
 80125ce:	e747      	b.n	8012460 <GFXfillRect+0xb4>
 80125d0:	f8b0 a000 	ldrh.w	sl, [r0]
 80125d4:	f8b0 8002 	ldrh.w	r8, [r0, #2]
 80125d8:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 80125dc:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 80125e0:	ebaa 0a06 	sub.w	sl, sl, r6
 80125e4:	eba8 0805 	sub.w	r8, r8, r5
 80125e8:	fa0f fa8a 	sxth.w	sl, sl
 80125ec:	fa0f f888 	sxth.w	r8, r8
 80125f0:	e736      	b.n	8012460 <GFXfillRect+0xb4>
 80125f2:	f8dd 9010 	ldr.w	r9, [sp, #16]
 80125f6:	460e      	mov	r6, r1
 80125f8:	9d05      	ldr	r5, [sp, #20]
 80125fa:	f04f 0e00 	mov.w	lr, #0
 80125fe:	9301      	str	r3, [sp, #4]
 8012600:	e9dd c406 	ldrd	ip, r4, [sp, #24]
 8012604:	e756      	b.n	80124b4 <GFXfillRect+0x108>
 8012606:	bf00      	nop
 8012608:	2001847c 	.word	0x2001847c

0801260c <GFXdrawChar>:

// TEXT- AND CHARACTER-HANDLING FUNCTIONS ----------------------------------

// Draw a character
void GFXdrawChar(GFX* myGFX, int16_t x, int16_t y, unsigned char c,
  uint16_t color, uint16_t bg, uint8_t size) {
 801260c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012610:	b09d      	sub	sp, #116	; 0x74
 8012612:	4682      	mov	sl, r0

    if(!myGFX->gfxFont) { // 'Classic' built-in font
 8012614:	6980      	ldr	r0, [r0, #24]
  uint16_t color, uint16_t bg, uint8_t size) {
 8012616:	9212      	str	r2, [sp, #72]	; 0x48
 8012618:	f8bd 2098 	ldrh.w	r2, [sp, #152]	; 0x98
 801261c:	9103      	str	r1, [sp, #12]
 801261e:	9208      	str	r2, [sp, #32]
 8012620:	f8bd 209c 	ldrh.w	r2, [sp, #156]	; 0x9c
 8012624:	9202      	str	r2, [sp, #8]
 8012626:	f89d 20a0 	ldrb.w	r2, [sp, #160]	; 0xa0
 801262a:	920c      	str	r2, [sp, #48]	; 0x30
    if(!myGFX->gfxFont) { // 'Classic' built-in font
 801262c:	2800      	cmp	r0, #0
 801262e:	f000 80f4 	beq.w	801281a <GFXdrawChar+0x20e>

        // Character is assumed previously filtered by write() to eliminate
        // newlines, returns, non-printable characters, etc.  Calling
        // drawChar() directly with 'bad' characters of font may cause mayhem!

        c -= (uint8_t)pgm_read_byte(&myGFX->gfxFont->first);
 8012632:	7a01      	ldrb	r1, [r0, #8]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
 8012634:	6842      	ldr	r2, [r0, #4]
        c -= (uint8_t)pgm_read_byte(&myGFX->gfxFont->first);
 8012636:	1a5b      	subs	r3, r3, r1
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&myGFX->gfxFont->bitmap);
 8012638:	6801      	ldr	r1, [r0, #0]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
 801263a:	b2db      	uxtb	r3, r3
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&myGFX->gfxFont->bitmap);
 801263c:	910f      	str	r1, [sp, #60]	; 0x3c
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
 801263e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3

        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
 8012642:	881a      	ldrh	r2, [r3, #0]
        uint8_t  w  = pgm_read_byte(&glyph->width),
                 h  = pgm_read_byte(&glyph->height);
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
                 yo = pgm_read_byte(&glyph->yOffset);
 8012644:	f993 1006 	ldrsb.w	r1, [r3, #6]
        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
 8012648:	9209      	str	r2, [sp, #36]	; 0x24
        uint8_t  w  = pgm_read_byte(&glyph->width),
 801264a:	789a      	ldrb	r2, [r3, #2]
                 yo = pgm_read_byte(&glyph->yOffset);
 801264c:	911b      	str	r1, [sp, #108]	; 0x6c
        uint8_t  w  = pgm_read_byte(&glyph->width),
 801264e:	9207      	str	r2, [sp, #28]
                 h  = pgm_read_byte(&glyph->height);
 8012650:	78da      	ldrb	r2, [r3, #3]
 8012652:	9213      	str	r2, [sp, #76]	; 0x4c
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
 8012654:	f993 2005 	ldrsb.w	r2, [r3, #5]
        uint8_t  xx, yy, bits = 0, bit = 0;
        int16_t  xo16 = 0, yo16 = 0;

        if(size > 1) {
 8012658:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801265a:	2b01      	cmp	r3, #1
 801265c:	f240 80a7 	bls.w	80127ae <GFXdrawChar+0x1a2>
            xo16 = xo;
            yo16 = yo;
 8012660:	b209      	sxth	r1, r1
            xo16 = xo;
 8012662:	b213      	sxth	r3, r2
            yo16 = yo;
 8012664:	9115      	str	r1, [sp, #84]	; 0x54
        // this (a canvas object type for MCUs that can afford the RAM and
        // displays supporting setAddrWindow() and pushColors()), but haven't
        // implemented this yet.

        //startWrite();
        for(yy=0; yy<h; yy++) {
 8012666:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8012668:	2900      	cmp	r1, #0
 801266a:	f000 80a6 	beq.w	80127ba <GFXdrawChar+0x1ae>
 801266e:	9907      	ldr	r1, [sp, #28]
 8012670:	2900      	cmp	r1, #0
 8012672:	f000 80a2 	beq.w	80127ba <GFXdrawChar+0x1ae>
 8012676:	9c03      	ldr	r4, [sp, #12]
        uint8_t  xx, yy, bits = 0, bit = 0;
 8012678:	2000      	movs	r0, #0
                }
                if(bits & 0x80) {
                    if(size == 1) {
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
                    } else {
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 801267a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801267c:	18a2      	adds	r2, r4, r2
        uint8_t  xx, yy, bits = 0, bit = 0;
 801267e:	9006      	str	r0, [sp, #24]
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 8012680:	b229      	sxth	r1, r5
        uint8_t  xx, yy, bits = 0, bit = 0;
 8012682:	9002      	str	r0, [sp, #8]
 8012684:	921a      	str	r2, [sp, #104]	; 0x68
 8012686:	b2aa      	uxth	r2, r5
 8012688:	fb01 4303 	mla	r3, r1, r3, r4
 801268c:	920a      	str	r2, [sp, #40]	; 0x28
 801268e:	1e4a      	subs	r2, r1, #1
 8012690:	b29b      	uxth	r3, r3
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 8012692:	9116      	str	r1, [sp, #88]	; 0x58
 8012694:	9218      	str	r2, [sp, #96]	; 0x60
 8012696:	4602      	mov	r2, r0
        for(yy=0; yy<h; yy++) {
 8012698:	900e      	str	r0, [sp, #56]	; 0x38
 801269a:	9317      	str	r3, [sp, #92]	; 0x5c
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 801269c:	9b15      	ldr	r3, [sp, #84]	; 0x54
    int16_t err = dx / 2;
 801269e:	2700      	movs	r7, #0
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 80126a0:	9912      	ldr	r1, [sp, #72]	; 0x48
 80126a2:	4413      	add	r3, r2
 80126a4:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80126a6:	fb03 1302 	mla	r3, r3, r2, r1
 80126aa:	b21a      	sxth	r2, r3
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80126ac:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80126ae:	18d3      	adds	r3, r2, r3
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 80126b0:	9210      	str	r2, [sp, #64]	; 0x40
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80126b2:	b219      	sxth	r1, r3
 80126b4:	4613      	mov	r3, r2
 80126b6:	428a      	cmp	r2, r1
 80126b8:	9104      	str	r1, [sp, #16]
 80126ba:	bfa8      	it	ge
 80126bc:	460a      	movge	r2, r1
 80126be:	428b      	cmp	r3, r1
 80126c0:	bfb8      	it	lt
 80126c2:	460b      	movlt	r3, r1
 80126c4:	920b      	str	r2, [sp, #44]	; 0x2c
 80126c6:	9910      	ldr	r1, [sp, #64]	; 0x40
 80126c8:	4698      	mov	r8, r3
    dx = x1 - x0;
 80126ca:	1a9b      	subs	r3, r3, r2
 80126cc:	b21b      	sxth	r3, r3
    int16_t err = dx / 2;
 80126ce:	2b00      	cmp	r3, #0
 80126d0:	461a      	mov	r2, r3
    dx = x1 - x0;
 80126d2:	9314      	str	r3, [sp, #80]	; 0x50
    int16_t err = dx / 2;
 80126d4:	bfb8      	it	lt
 80126d6:	1c5a      	addlt	r2, r3, #1
 80126d8:	9b04      	ldr	r3, [sp, #16]
 80126da:	1a5b      	subs	r3, r3, r1
 80126dc:	1052      	asrs	r2, r2, #1
 80126de:	2b00      	cmp	r3, #0
 80126e0:	9219      	str	r2, [sp, #100]	; 0x64
 80126e2:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80126e4:	bfb8      	it	lt
 80126e6:	425b      	neglt	r3, r3
 80126e8:	9203      	str	r2, [sp, #12]
    dy = abs(y1 - y0);
 80126ea:	fa0f f983 	sxth.w	r9, r3
 80126ee:	e00e      	b.n	801270e <GFXdrawChar+0x102>
                          size, size, color);
                    }
                }
                bits <<= 1;
 80126f0:	9b02      	ldr	r3, [sp, #8]
 80126f2:	3701      	adds	r7, #1
 80126f4:	9a03      	ldr	r2, [sp, #12]
 80126f6:	990a      	ldr	r1, [sp, #40]	; 0x28
 80126f8:	005b      	lsls	r3, r3, #1
 80126fa:	b2bf      	uxth	r7, r7
 80126fc:	440a      	add	r2, r1
 80126fe:	b2db      	uxtb	r3, r3
 8012700:	b292      	uxth	r2, r2
 8012702:	9302      	str	r3, [sp, #8]
            for(xx=0; xx<w; xx++) {
 8012704:	b2fb      	uxtb	r3, r7
 8012706:	9203      	str	r2, [sp, #12]
 8012708:	9a07      	ldr	r2, [sp, #28]
 801270a:	429a      	cmp	r2, r3
 801270c:	d958      	bls.n	80127c0 <GFXdrawChar+0x1b4>
                if(!(bit++ & 7)) {
 801270e:	9b06      	ldr	r3, [sp, #24]
 8012710:	443b      	add	r3, r7
 8012712:	0759      	lsls	r1, r3, #29
 8012714:	d106      	bne.n	8012724 <GFXdrawChar+0x118>
                    bits = pgm_read_byte(&bitmap[bo++]);
 8012716:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8012718:	990f      	ldr	r1, [sp, #60]	; 0x3c
 801271a:	1c53      	adds	r3, r2, #1
 801271c:	5c8a      	ldrb	r2, [r1, r2]
 801271e:	b29b      	uxth	r3, r3
 8012720:	9202      	str	r2, [sp, #8]
 8012722:	9309      	str	r3, [sp, #36]	; 0x24
                if(bits & 0x80) {
 8012724:	9b02      	ldr	r3, [sp, #8]
 8012726:	061a      	lsls	r2, r3, #24
 8012728:	d5e2      	bpl.n	80126f0 <GFXdrawChar+0xe4>
                    if(size == 1) {
 801272a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801272c:	2b01      	cmp	r3, #1
 801272e:	d057      	beq.n	80127e0 <GFXdrawChar+0x1d4>
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 8012730:	f9bd 600c 	ldrsh.w	r6, [sp, #12]
    for (int16_t i=x; i<x+w; i++) {
 8012734:	4433      	add	r3, r6
 8012736:	42b3      	cmp	r3, r6
 8012738:	9305      	str	r3, [sp, #20]
 801273a:	ddd9      	ble.n	80126f0 <GFXdrawChar+0xe4>
 801273c:	9711      	str	r7, [sp, #68]	; 0x44
 801273e:	9f10      	ldr	r7, [sp, #64]	; 0x40
 8012740:	e008      	b.n	8012754 <GFXdrawChar+0x148>
    for (; x0<=x1; x0++) {
 8012742:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8012744:	4543      	cmp	r3, r8
 8012746:	f340 8140 	ble.w	80129ca <GFXdrawChar+0x3be>
    for (int16_t i=x; i<x+w; i++) {
 801274a:	3601      	adds	r6, #1
 801274c:	9b05      	ldr	r3, [sp, #20]
 801274e:	b236      	sxth	r6, r6
 8012750:	429e      	cmp	r6, r3
 8012752:	da2a      	bge.n	80127aa <GFXdrawChar+0x19e>
    if (steep) {
 8012754:	9b04      	ldr	r3, [sp, #16]
 8012756:	429f      	cmp	r7, r3
 8012758:	d1f3      	bne.n	8012742 <GFXdrawChar+0x136>
    dy = abs(y1 - y0);
 801275a:	4634      	mov	r4, r6
 801275c:	46bb      	mov	fp, r7
    int16_t err = dx / 2;
 801275e:	2500      	movs	r5, #0
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 8012760:	2c00      	cmp	r4, #0
 8012762:	db10      	blt.n	8012786 <GFXdrawChar+0x17a>
 8012764:	f8ba 3004 	ldrh.w	r3, [sl, #4]
 8012768:	42a3      	cmp	r3, r4
 801276a:	dd0c      	ble.n	8012786 <GFXdrawChar+0x17a>
 801276c:	f1bb 0f00 	cmp.w	fp, #0
 8012770:	db09      	blt.n	8012786 <GFXdrawChar+0x17a>
 8012772:	f8ba 0006 	ldrh.w	r0, [sl, #6]
 8012776:	465a      	mov	r2, fp
 8012778:	4621      	mov	r1, r4
 801277a:	9b08      	ldr	r3, [sp, #32]
 801277c:	4558      	cmp	r0, fp
 801277e:	4650      	mov	r0, sl
 8012780:	dd01      	ble.n	8012786 <GFXdrawChar+0x17a>
 8012782:	f7ff fca9 	bl	80120d8 <GFXdrawPixel.part.0>
        err -= dy;
 8012786:	eba5 0509 	sub.w	r5, r5, r9
    for (; x0<=x1; x0++) {
 801278a:	3401      	adds	r4, #1
        err -= dy;
 801278c:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
 801278e:	b224      	sxth	r4, r4
        if (err < 0) {
 8012790:	2d00      	cmp	r5, #0
 8012792:	da03      	bge.n	801279c <GFXdrawChar+0x190>
            y0 += ystep;
 8012794:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 8012798:	fa0f fb8b 	sxth.w	fp, fp
    for (; x0<=x1; x0++) {
 801279c:	42a6      	cmp	r6, r4
 801279e:	dadf      	bge.n	8012760 <GFXdrawChar+0x154>
    for (int16_t i=x; i<x+w; i++) {
 80127a0:	3601      	adds	r6, #1
 80127a2:	9b05      	ldr	r3, [sp, #20]
 80127a4:	b236      	sxth	r6, r6
 80127a6:	429e      	cmp	r6, r3
 80127a8:	dbd4      	blt.n	8012754 <GFXdrawChar+0x148>
 80127aa:	9f11      	ldr	r7, [sp, #68]	; 0x44
 80127ac:	e7a0      	b.n	80126f0 <GFXdrawChar+0xe4>
        int16_t  xo16 = 0, yo16 = 0;
 80127ae:	2300      	movs	r3, #0
        for(yy=0; yy<h; yy++) {
 80127b0:	9913      	ldr	r1, [sp, #76]	; 0x4c
        int16_t  xo16 = 0, yo16 = 0;
 80127b2:	9315      	str	r3, [sp, #84]	; 0x54
        for(yy=0; yy<h; yy++) {
 80127b4:	2900      	cmp	r1, #0
 80127b6:	f47f af5a 	bne.w	801266e <GFXdrawChar+0x62>
            }
        }
        //endWrite();

    } // End classic vs custom font
}
 80127ba:	b01d      	add	sp, #116	; 0x74
 80127bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80127c0:	4611      	mov	r1, r2
 80127c2:	9b06      	ldr	r3, [sp, #24]
        for(yy=0; yy<h; yy++) {
 80127c4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80127c6:	440b      	add	r3, r1
 80127c8:	3201      	adds	r2, #1
 80127ca:	b2db      	uxtb	r3, r3
 80127cc:	b2d2      	uxtb	r2, r2
 80127ce:	9306      	str	r3, [sp, #24]
 80127d0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80127d2:	920e      	str	r2, [sp, #56]	; 0x38
 80127d4:	4293      	cmp	r3, r2
 80127d6:	f63f af61 	bhi.w	801269c <GFXdrawChar+0x90>
}
 80127da:	b01d      	add	sp, #116	; 0x74
 80127dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80127e0:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 80127e2:	18f9      	adds	r1, r7, r3
 80127e4:	b209      	sxth	r1, r1
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80127e6:	2900      	cmp	r1, #0
 80127e8:	db82      	blt.n	80126f0 <GFXdrawChar+0xe4>
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
 80127ea:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80127ec:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80127ee:	980e      	ldr	r0, [sp, #56]	; 0x38
 80127f0:	189a      	adds	r2, r3, r2
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80127f2:	f8ba 3004 	ldrh.w	r3, [sl, #4]
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
 80127f6:	4402      	add	r2, r0
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80127f8:	4299      	cmp	r1, r3
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
 80127fa:	b212      	sxth	r2, r2
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80127fc:	f6bf af78 	bge.w	80126f0 <GFXdrawChar+0xe4>
 8012800:	2a00      	cmp	r2, #0
 8012802:	f6ff af75 	blt.w	80126f0 <GFXdrawChar+0xe4>
 8012806:	f8ba 3006 	ldrh.w	r3, [sl, #6]
 801280a:	429a      	cmp	r2, r3
 801280c:	f6bf af70 	bge.w	80126f0 <GFXdrawChar+0xe4>
 8012810:	9b08      	ldr	r3, [sp, #32]
 8012812:	4650      	mov	r0, sl
 8012814:	f7ff fc60 	bl	80120d8 <GFXdrawPixel.part.0>
 8012818:	e76a      	b.n	80126f0 <GFXdrawChar+0xe4>
        if((x >= myGFX->_width)            || // Clip right
 801281a:	f8ba 2004 	ldrh.w	r2, [sl, #4]
 801281e:	4291      	cmp	r1, r2
 8012820:	dacb      	bge.n	80127ba <GFXdrawChar+0x1ae>
           (y >= myGFX->_height)           || // Clip bottom
 8012822:	f8ba 2006 	ldrh.w	r2, [sl, #6]
        if((x >= myGFX->_width)            || // Clip right
 8012826:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8012828:	4294      	cmp	r4, r2
 801282a:	dac6      	bge.n	80127ba <GFXdrawChar+0x1ae>
           ((x + 6 * size - 1) < 0) || // Clip left
 801282c:	3901      	subs	r1, #1
 801282e:	2206      	movs	r2, #6
 8012830:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8012832:	fb12 1205 	smlabb	r2, r2, r5, r1
           (y >= myGFX->_height)           || // Clip bottom
 8012836:	2a00      	cmp	r2, #0
 8012838:	dbbf      	blt.n	80127ba <GFXdrawChar+0x1ae>
           ((y + 8 * size - 1) < 0))   // Clip top
 801283a:	1e62      	subs	r2, r4, #1
 801283c:	9211      	str	r2, [sp, #68]	; 0x44
           ((x + 6 * size - 1) < 0) || // Clip left
 801283e:	eb12 02c5 	adds.w	r2, r2, r5, lsl #3
 8012842:	d4ba      	bmi.n	80127ba <GFXdrawChar+0x1ae>
        if(!myGFX->_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
 8012844:	f8ba 2016 	ldrh.w	r2, [sl, #22]
 8012848:	b91a      	cbnz	r2, 8012852 <GFXdrawChar+0x246>
 801284a:	2baf      	cmp	r3, #175	; 0xaf
 801284c:	d901      	bls.n	8012852 <GFXdrawChar+0x246>
 801284e:	3301      	adds	r3, #1
 8012850:	b2db      	uxtb	r3, r3
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
 8012852:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8012856:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8012858:	2200      	movs	r2, #0
 801285a:	f8bd 100c 	ldrh.w	r1, [sp, #12]
 801285e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8012862:	9206      	str	r2, [sp, #24]
 8012864:	b2a2      	uxth	r2, r4
 8012866:	009b      	lsls	r3, r3, #2
 8012868:	910f      	str	r1, [sp, #60]	; 0x3c
 801286a:	9204      	str	r2, [sp, #16]
 801286c:	3a01      	subs	r2, #1
 801286e:	9309      	str	r3, [sp, #36]	; 0x24
 8012870:	b223      	sxth	r3, r4
 8012872:	9107      	str	r1, [sp, #28]
 8012874:	9310      	str	r3, [sp, #64]	; 0x40
 8012876:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 801287a:	920b      	str	r2, [sp, #44]	; 0x2c
 801287c:	930a      	str	r3, [sp, #40]	; 0x28
 801287e:	460b      	mov	r3, r1
 8012880:	9906      	ldr	r1, [sp, #24]
    GFXdrawPixel(myGFX, x, y, color);
 8012882:	440b      	add	r3, r1
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
 8012884:	9909      	ldr	r1, [sp, #36]	; 0x24
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
 8012886:	f9bd 201c 	ldrsh.w	r2, [sp, #28]
    for (int16_t i=x; i<x+w; i++) {
 801288a:	2700      	movs	r7, #0
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
 801288c:	f810 9001 	ldrb.w	r9, [r0, r1]
    GFXdrawPixel(myGFX, x, y, color);
 8012890:	b21b      	sxth	r3, r3
    for (int16_t i=x; i<x+w; i++) {
 8012892:	990c      	ldr	r1, [sp, #48]	; 0x30
 8012894:	46b8      	mov	r8, r7
 8012896:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8012898:	188e      	adds	r6, r1, r2
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
 801289a:	9205      	str	r2, [sp, #20]
    GFXdrawPixel(myGFX, x, y, color);
 801289c:	930e      	str	r3, [sp, #56]	; 0x38
                if(line & 1) {
 801289e:	f019 0f01 	tst.w	r9, #1
 80128a2:	d035      	beq.n	8012910 <GFXdrawChar+0x304>
                    if(size == 1)
 80128a4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80128a6:	2b01      	cmp	r3, #1
 80128a8:	d055      	beq.n	8012956 <GFXdrawChar+0x34a>
    for (int16_t i=x; i<x+w; i++) {
 80128aa:	9c05      	ldr	r4, [sp, #20]
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, color);
 80128ac:	fa0f fb85 	sxth.w	fp, r5
    for (int16_t i=x; i<x+w; i++) {
 80128b0:	42b4      	cmp	r4, r6
 80128b2:	da11      	bge.n	80128d8 <GFXdrawChar+0x2cc>
 80128b4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80128b6:	950d      	str	r5, [sp, #52]	; 0x34
 80128b8:	18ef      	adds	r7, r5, r3
 80128ba:	9d08      	ldr	r5, [sp, #32]
 80128bc:	b23f      	sxth	r7, r7
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80128be:	4623      	mov	r3, r4
 80128c0:	4621      	mov	r1, r4
    for (int16_t i=x; i<x+w; i++) {
 80128c2:	3401      	adds	r4, #1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80128c4:	9501      	str	r5, [sp, #4]
 80128c6:	9700      	str	r7, [sp, #0]
 80128c8:	465a      	mov	r2, fp
    for (int16_t i=x; i<x+w; i++) {
 80128ca:	b224      	sxth	r4, r4
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80128cc:	4650      	mov	r0, sl
 80128ce:	f7ff fc7d 	bl	80121cc <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
 80128d2:	42b4      	cmp	r4, r6
 80128d4:	dbf3      	blt.n	80128be <GFXdrawChar+0x2b2>
 80128d6:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 80128d8:	9b04      	ldr	r3, [sp, #16]
 80128da:	f108 0801 	add.w	r8, r8, #1
            for(int8_t j=0; j<8; j++, line >>= 1) {
 80128de:	ea4f 0959 	mov.w	r9, r9, lsr #1
 80128e2:	441d      	add	r5, r3
 80128e4:	f1b8 0f08 	cmp.w	r8, #8
 80128e8:	b2ad      	uxth	r5, r5
 80128ea:	d1d8      	bne.n	801289e <GFXdrawChar+0x292>
 80128ec:	461a      	mov	r2, r3
 80128ee:	9b07      	ldr	r3, [sp, #28]
 80128f0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80128f2:	4413      	add	r3, r2
 80128f4:	9a06      	ldr	r2, [sp, #24]
 80128f6:	310c      	adds	r1, #12
 80128f8:	3201      	adds	r2, #1
 80128fa:	b29b      	uxth	r3, r3
 80128fc:	9109      	str	r1, [sp, #36]	; 0x24
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
 80128fe:	2a05      	cmp	r2, #5
 8012900:	9206      	str	r2, [sp, #24]
 8012902:	9307      	str	r3, [sp, #28]
 8012904:	d03b      	beq.n	801297e <GFXdrawChar+0x372>
 8012906:	f8da 0018 	ldr.w	r0, [sl, #24]
 801290a:	4611      	mov	r1, r2
 801290c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801290e:	e7b8      	b.n	8012882 <GFXdrawChar+0x276>
                } else if(bg != color) {
 8012910:	9b08      	ldr	r3, [sp, #32]
 8012912:	9a02      	ldr	r2, [sp, #8]
 8012914:	4293      	cmp	r3, r2
 8012916:	d0df      	beq.n	80128d8 <GFXdrawChar+0x2cc>
                    if(size == 1)
 8012918:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801291a:	2b01      	cmp	r3, #1
 801291c:	d025      	beq.n	801296a <GFXdrawChar+0x35e>
    for (int16_t i=x; i<x+w; i++) {
 801291e:	9c05      	ldr	r4, [sp, #20]
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
 8012920:	fa0f fb85 	sxth.w	fp, r5
    for (int16_t i=x; i<x+w; i++) {
 8012924:	42b4      	cmp	r4, r6
 8012926:	dad7      	bge.n	80128d8 <GFXdrawChar+0x2cc>
 8012928:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801292a:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
 801292e:	46a9      	mov	r9, r5
 8012930:	18ef      	adds	r7, r5, r3
 8012932:	9d02      	ldr	r5, [sp, #8]
 8012934:	b23f      	sxth	r7, r7
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8012936:	4623      	mov	r3, r4
 8012938:	4621      	mov	r1, r4
    for (int16_t i=x; i<x+w; i++) {
 801293a:	3401      	adds	r4, #1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 801293c:	9501      	str	r5, [sp, #4]
 801293e:	9700      	str	r7, [sp, #0]
 8012940:	465a      	mov	r2, fp
    for (int16_t i=x; i<x+w; i++) {
 8012942:	b224      	sxth	r4, r4
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8012944:	4650      	mov	r0, sl
 8012946:	f7ff fc41 	bl	80121cc <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
 801294a:	42b4      	cmp	r4, r6
 801294c:	dbf3      	blt.n	8012936 <GFXdrawChar+0x32a>
 801294e:	464d      	mov	r5, r9
 8012950:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 8012954:	e7c0      	b.n	80128d8 <GFXdrawChar+0x2cc>
    GFXdrawPixel(myGFX, x, y, color);
 8012956:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012958:	4650      	mov	r0, sl
 801295a:	990e      	ldr	r1, [sp, #56]	; 0x38
 801295c:	eb03 0208 	add.w	r2, r3, r8
 8012960:	9b08      	ldr	r3, [sp, #32]
 8012962:	b212      	sxth	r2, r2
 8012964:	f7ff fcba 	bl	80122dc <GFXdrawPixel>
 8012968:	e7b6      	b.n	80128d8 <GFXdrawChar+0x2cc>
 801296a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801296c:	4650      	mov	r0, sl
 801296e:	990e      	ldr	r1, [sp, #56]	; 0x38
 8012970:	eb03 0208 	add.w	r2, r3, r8
 8012974:	9b02      	ldr	r3, [sp, #8]
 8012976:	b212      	sxth	r2, r2
 8012978:	f7ff fcb0 	bl	80122dc <GFXdrawPixel>
 801297c:	e7ac      	b.n	80128d8 <GFXdrawChar+0x2cc>
        if(bg != color) { // If opaque, draw vertical line for last column
 801297e:	9b08      	ldr	r3, [sp, #32]
 8012980:	9a02      	ldr	r2, [sp, #8]
 8012982:	4293      	cmp	r3, r2
 8012984:	f43f af19 	beq.w	80127ba <GFXdrawChar+0x1ae>
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
 8012988:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801298a:	2b01      	cmp	r3, #1
 801298c:	d043      	beq.n	8012a16 <GFXdrawChar+0x40a>
            else          GFXwriteFillRect(myGFX,x+5*size, y, size, 8*size, bg);
 801298e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012990:	eb03 0483 	add.w	r4, r3, r3, lsl #2
 8012994:	00dd      	lsls	r5, r3, #3
 8012996:	9b03      	ldr	r3, [sp, #12]
 8012998:	4423      	add	r3, r4
 801299a:	b21c      	sxth	r4, r3
    for (int16_t i=x; i<x+w; i++) {
 801299c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801299e:	4423      	add	r3, r4
 80129a0:	42a3      	cmp	r3, r4
 80129a2:	461e      	mov	r6, r3
 80129a4:	f77f af09 	ble.w	80127ba <GFXdrawChar+0x1ae>
 80129a8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80129aa:	441d      	add	r5, r3
 80129ac:	b22d      	sxth	r5, r5
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80129ae:	9b02      	ldr	r3, [sp, #8]
 80129b0:	4621      	mov	r1, r4
 80129b2:	9500      	str	r5, [sp, #0]
 80129b4:	4650      	mov	r0, sl
 80129b6:	9301      	str	r3, [sp, #4]
 80129b8:	4623      	mov	r3, r4
    for (int16_t i=x; i<x+w; i++) {
 80129ba:	3401      	adds	r4, #1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80129bc:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80129be:	f7ff fc05 	bl	80121cc <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
 80129c2:	b224      	sxth	r4, r4
 80129c4:	42a6      	cmp	r6, r4
 80129c6:	dcf2      	bgt.n	80129ae <GFXdrawChar+0x3a2>
 80129c8:	e6f7      	b.n	80127ba <GFXdrawChar+0x1ae>
    for (; x0<=x1; x0++) {
 80129ca:	4635      	mov	r5, r6
 80129cc:	960d      	str	r6, [sp, #52]	; 0x34
    int16_t err = dx / 2;
 80129ce:	f8dd b064 	ldr.w	fp, [sp, #100]	; 0x64
    for (; x0<=x1; x0++) {
 80129d2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80129d4:	9e14      	ldr	r6, [sp, #80]	; 0x50
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80129d6:	2d00      	cmp	r5, #0
 80129d8:	db0f      	blt.n	80129fa <GFXdrawChar+0x3ee>
 80129da:	f8ba 3004 	ldrh.w	r3, [sl, #4]
 80129de:	429d      	cmp	r5, r3
 80129e0:	da0b      	bge.n	80129fa <GFXdrawChar+0x3ee>
 80129e2:	0423      	lsls	r3, r4, #16
 80129e4:	d409      	bmi.n	80129fa <GFXdrawChar+0x3ee>
 80129e6:	f8ba 0006 	ldrh.w	r0, [sl, #6]
 80129ea:	4622      	mov	r2, r4
 80129ec:	4629      	mov	r1, r5
 80129ee:	9b08      	ldr	r3, [sp, #32]
 80129f0:	4284      	cmp	r4, r0
 80129f2:	4650      	mov	r0, sl
 80129f4:	da01      	bge.n	80129fa <GFXdrawChar+0x3ee>
 80129f6:	f7ff fb6f 	bl	80120d8 <GFXdrawPixel.part.0>
    for (; x0<=x1; x0++) {
 80129fa:	3401      	adds	r4, #1
        if (err < 0) {
 80129fc:	f1bb 0f00 	cmp.w	fp, #0
    for (; x0<=x1; x0++) {
 8012a00:	b224      	sxth	r4, r4
        if (err < 0) {
 8012a02:	da04      	bge.n	8012a0e <GFXdrawChar+0x402>
            y0 += ystep;
 8012a04:	3d01      	subs	r5, #1
            err += dx;
 8012a06:	44b3      	add	fp, r6
            y0 += ystep;
 8012a08:	b22d      	sxth	r5, r5
            err += dx;
 8012a0a:	fa0f fb8b 	sxth.w	fp, fp
    for (; x0<=x1; x0++) {
 8012a0e:	4544      	cmp	r4, r8
 8012a10:	dde1      	ble.n	80129d6 <GFXdrawChar+0x3ca>
 8012a12:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8012a14:	e699      	b.n	801274a <GFXdrawChar+0x13e>
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
 8012a16:	9b03      	ldr	r3, [sp, #12]
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8012a18:	4650      	mov	r0, sl
 8012a1a:	9a12      	ldr	r2, [sp, #72]	; 0x48
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
 8012a1c:	3305      	adds	r3, #5
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8012a1e:	9902      	ldr	r1, [sp, #8]
 8012a20:	1dd4      	adds	r4, r2, #7
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
 8012a22:	b21b      	sxth	r3, r3
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8012a24:	9127      	str	r1, [sp, #156]	; 0x9c
 8012a26:	b224      	sxth	r4, r4
 8012a28:	4619      	mov	r1, r3
 8012a2a:	9426      	str	r4, [sp, #152]	; 0x98
}
 8012a2c:	b01d      	add	sp, #116	; 0x74
 8012a2e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8012a32:	f7ff bbcb 	b.w	80121cc <GFXwriteLine>
 8012a36:	bf00      	nop

08012a38 <GFXwrite>:
        }
  }
}


void GFXwrite(GFX* myGFX, uint8_t c) {
 8012a38:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(!myGFX->gfxFont) { // 'Classic' built-in font
 8012a3a:	6983      	ldr	r3, [r0, #24]
void GFXwrite(GFX* myGFX, uint8_t c) {
 8012a3c:	b085      	sub	sp, #20
 8012a3e:	4604      	mov	r4, r0
	if(!myGFX->gfxFont) { // 'Classic' built-in font
 8012a40:	b32b      	cbz	r3, 8012a8e <GFXwrite+0x56>
			myGFX->cursor_x += myGFX->textsize * 6;          // Advance x one char
		}

	} else { // Custom font

		if(c == '\n') {
 8012a42:	290a      	cmp	r1, #10
 8012a44:	d018      	beq.n	8012a78 <GFXwrite+0x40>
			myGFX->cursor_x  = 0;
			myGFX->cursor_y += (int16_t)myGFX->textsize *
						(uint8_t)pgm_read_byte(&myGFX->gfxFont->yAdvance);
		} else if(c != '\r') {
 8012a46:	290d      	cmp	r1, #13
 8012a48:	d01f      	beq.n	8012a8a <GFXwrite+0x52>
			uint8_t first = pgm_read_byte(&myGFX->gfxFont->first);
 8012a4a:	7a1a      	ldrb	r2, [r3, #8]
			if((c >= first) && (c <= (uint8_t)pgm_read_byte(&myGFX->gfxFont->last))) {
 8012a4c:	4291      	cmp	r1, r2
 8012a4e:	d31c      	bcc.n	8012a8a <GFXwrite+0x52>
 8012a50:	7a58      	ldrb	r0, [r3, #9]
 8012a52:	4288      	cmp	r0, r1
 8012a54:	d319      	bcc.n	8012a8a <GFXwrite+0x52>
				GFXglyph *glyph = &(((GFXglyph *)pgm_read_pointer(
				  &myGFX->gfxFont->glyph))[c - first]);
 8012a56:	1a8a      	subs	r2, r1, r2
 8012a58:	685d      	ldr	r5, [r3, #4]
 8012a5a:	89e0      	ldrh	r0, [r4, #14]
 8012a5c:	eb05 05c2 	add.w	r5, r5, r2, lsl #3
 8012a60:	b203      	sxth	r3, r0
				uint8_t   w     = pgm_read_byte(&glyph->width),
						  h     = pgm_read_byte(&glyph->height);
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
 8012a62:	78ea      	ldrb	r2, [r5, #3]
				uint8_t   w     = pgm_read_byte(&glyph->width),
 8012a64:	78ae      	ldrb	r6, [r5, #2]
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
 8012a66:	b10a      	cbz	r2, 8012a6c <GFXwrite+0x34>
 8012a68:	2e00      	cmp	r6, #0
 8012a6a:	d157      	bne.n	8012b1c <GFXwrite+0xe4>
					//     cursor_y += (int16_t)textsize *
					//       (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
					// }
					GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
				}
				myGFX->cursor_x += (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)myGFX->textsize;
 8012a6c:	7929      	ldrb	r1, [r5, #4]
 8012a6e:	89a2      	ldrh	r2, [r4, #12]
 8012a70:	fb01 2303 	mla	r3, r1, r3, r2
 8012a74:	81a3      	strh	r3, [r4, #12]
			}
		}

	}
}
 8012a76:	e008      	b.n	8012a8a <GFXwrite+0x52>
			myGFX->cursor_x  = 0;
 8012a78:	2000      	movs	r0, #0
			myGFX->cursor_y += (int16_t)myGFX->textsize *
 8012a7a:	8962      	ldrh	r2, [r4, #10]
 8012a7c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
			myGFX->cursor_x  = 0;
 8012a80:	81a0      	strh	r0, [r4, #12]
			myGFX->cursor_y += (int16_t)myGFX->textsize *
 8012a82:	7a9b      	ldrb	r3, [r3, #10]
 8012a84:	fb01 2303 	mla	r3, r1, r3, r2
 8012a88:	8163      	strh	r3, [r4, #10]
}
 8012a8a:	b005      	add	sp, #20
 8012a8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if(c == '\n') {                        // Newline?
 8012a8e:	290a      	cmp	r1, #10
 8012a90:	d03c      	beq.n	8012b0c <GFXwrite+0xd4>
		} else if(c != '\r') {                 // Ignore carriage returns
 8012a92:	290d      	cmp	r1, #13
 8012a94:	d0f9      	beq.n	8012a8a <GFXwrite+0x52>
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8012a96:	8a85      	ldrh	r5, [r0, #20]
 8012a98:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
			GFXcheckScrollWrap(myGFX, myGFX->textsize * 6 - myGFX->textsize * 2);
 8012a9c:	89c0      	ldrh	r0, [r0, #14]
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8012a9e:	b135      	cbz	r5, 8012aae <GFXwrite+0x76>
 8012aa0:	89a7      	ldrh	r7, [r4, #12]
			GFXcheckScrollWrap(myGFX, myGFX->textsize * 6 - myGFX->textsize * 2);
 8012aa2:	0085      	lsls	r5, r0, #2
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8012aa4:	88a6      	ldrh	r6, [r4, #4]
 8012aa6:	fa07 f585 	sxtah	r5, r7, r5
 8012aaa:	42b5      	cmp	r5, r6
 8012aac:	da6d      	bge.n	8012b8a <GFXwrite+0x152>
    if (myGFX->autoscroll) {
 8012aae:	8c23      	ldrh	r3, [r4, #32]
 8012ab0:	b1b3      	cbz	r3, 8012ae0 <GFXwrite+0xa8>
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
 8012ab2:	8ba5      	ldrh	r5, [r4, #28]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 8012ab4:	8be3      	ldrh	r3, [r4, #30]
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
 8012ab6:	fb15 f500 	smulbb	r5, r5, r0
        if (cursor >= myGFX->_height) {
 8012aba:	88e7      	ldrh	r7, [r4, #6]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 8012abc:	fb13 f300 	smulbb	r3, r3, r0
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
 8012ac0:	3d01      	subs	r5, #1
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 8012ac2:	b21b      	sxth	r3, r3
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
 8012ac4:	b22d      	sxth	r5, r5
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 8012ac6:	18ee      	adds	r6, r5, r3
 8012ac8:	4416      	add	r6, r2
        if (cursor >= myGFX->_height) {
 8012aca:	b2b6      	uxth	r6, r6
 8012acc:	42be      	cmp	r6, r7
 8012ace:	d307      	bcc.n	8012ae0 <GFXwrite+0xa8>
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 8012ad0:	43da      	mvns	r2, r3
            myGFX->cursor_x  = 0;
 8012ad2:	2600      	movs	r6, #0
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 8012ad4:	443a      	add	r2, r7
            myGFX->cursor_x  = 0;
 8012ad6:	81a6      	strh	r6, [r4, #12]
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 8012ad8:	1b52      	subs	r2, r2, r5
 8012ada:	b212      	sxth	r2, r2
 8012adc:	8162      	strh	r2, [r4, #10]
 8012ade:	e001      	b.n	8012ae4 <GFXwrite+0xac>
 8012ae0:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
			GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
 8012ae4:	8a67      	ldrh	r7, [r4, #18]
 8012ae6:	b2c0      	uxtb	r0, r0
 8012ae8:	8a25      	ldrh	r5, [r4, #16]
 8012aea:	460b      	mov	r3, r1
 8012aec:	9002      	str	r0, [sp, #8]
 8012aee:	4631      	mov	r1, r6
 8012af0:	4620      	mov	r0, r4
 8012af2:	e9cd 5700 	strd	r5, r7, [sp]
 8012af6:	f7ff fd89 	bl	801260c <GFXdrawChar>
			myGFX->cursor_x += myGFX->textsize * 6;          // Advance x one char
 8012afa:	89e3      	ldrh	r3, [r4, #14]
 8012afc:	89a2      	ldrh	r2, [r4, #12]
 8012afe:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8012b02:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8012b06:	81a3      	strh	r3, [r4, #12]
}
 8012b08:	b005      	add	sp, #20
 8012b0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize;
 8012b0c:	8b82      	ldrh	r2, [r0, #28]
 8012b0e:	8961      	ldrh	r1, [r4, #10]
 8012b10:	89c0      	ldrh	r0, [r0, #14]
			myGFX->cursor_x  = 0;                     // Reset x to zero,
 8012b12:	81a3      	strh	r3, [r4, #12]
			myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize;
 8012b14:	fb12 1300 	smlabb	r3, r2, r0, r1
 8012b18:	8163      	strh	r3, [r4, #10]
 8012b1a:	e7b6      	b.n	8012a8a <GFXwrite+0x52>
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8012b1c:	8aa7      	ldrh	r7, [r4, #20]
 8012b1e:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
 8012b22:	b197      	cbz	r7, 8012b4a <GFXwrite+0x112>
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
 8012b24:	f995 7005 	ldrsb.w	r7, [r5, #5]
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8012b28:	f8b4 c00c 	ldrh.w	ip, [r4, #12]
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
 8012b2c:	443e      	add	r6, r7
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8012b2e:	88a7      	ldrh	r7, [r4, #4]
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
 8012b30:	fb16 f303 	smulbb	r3, r6, r3
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8012b34:	fa0c f383 	sxtah	r3, ip, r3
 8012b38:	42bb      	cmp	r3, r7
 8012b3a:	db06      	blt.n	8012b4a <GFXwrite+0x112>
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
 8012b3c:	8ba3      	ldrh	r3, [r4, #28]
    	myGFX->cursor_x  = 0;            // Reset x to zero
 8012b3e:	2600      	movs	r6, #0
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
 8012b40:	fb13 2200 	smlabb	r2, r3, r0, r2
    	myGFX->cursor_x  = 0;            // Reset x to zero
 8012b44:	81a6      	strh	r6, [r4, #12]
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
 8012b46:	b212      	sxth	r2, r2
 8012b48:	8162      	strh	r2, [r4, #10]
    if (myGFX->autoscroll) {
 8012b4a:	8c23      	ldrh	r3, [r4, #32]
 8012b4c:	b323      	cbz	r3, 8012b98 <GFXwrite+0x160>
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 8012b4e:	8be3      	ldrh	r3, [r4, #30]
        if (cursor >= myGFX->_height) {
 8012b50:	88e6      	ldrh	r6, [r4, #6]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 8012b52:	fb13 f300 	smulbb	r3, r3, r0
 8012b56:	b21b      	sxth	r3, r3
 8012b58:	189f      	adds	r7, r3, r2
        if (cursor >= myGFX->_height) {
 8012b5a:	b2bf      	uxth	r7, r7
 8012b5c:	42b7      	cmp	r7, r6
 8012b5e:	d31b      	bcc.n	8012b98 <GFXwrite+0x160>
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 8012b60:	1e72      	subs	r2, r6, #1
            myGFX->cursor_x  = 0;
 8012b62:	2600      	movs	r6, #0
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 8012b64:	1ad3      	subs	r3, r2, r3
 8012b66:	46b4      	mov	ip, r6
            myGFX->cursor_x  = 0;
 8012b68:	81a6      	strh	r6, [r4, #12]
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 8012b6a:	b21a      	sxth	r2, r3
 8012b6c:	8162      	strh	r2, [r4, #10]
					GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
 8012b6e:	8a67      	ldrh	r7, [r4, #18]
 8012b70:	b2c0      	uxtb	r0, r0
 8012b72:	8a26      	ldrh	r6, [r4, #16]
 8012b74:	460b      	mov	r3, r1
 8012b76:	9002      	str	r0, [sp, #8]
 8012b78:	4661      	mov	r1, ip
 8012b7a:	4620      	mov	r0, r4
 8012b7c:	e9cd 6700 	strd	r6, r7, [sp]
 8012b80:	f7ff fd44 	bl	801260c <GFXdrawChar>
 8012b84:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8012b88:	e770      	b.n	8012a6c <GFXwrite+0x34>
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
 8012b8a:	8ba5      	ldrh	r5, [r4, #28]
    	myGFX->cursor_x  = 0;            // Reset x to zero
 8012b8c:	81a3      	strh	r3, [r4, #12]
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
 8012b8e:	fb15 2200 	smlabb	r2, r5, r0, r2
 8012b92:	b212      	sxth	r2, r2
 8012b94:	8162      	strh	r2, [r4, #10]
 8012b96:	e78a      	b.n	8012aae <GFXwrite+0x76>
 8012b98:	f9b4 c00c 	ldrsh.w	ip, [r4, #12]
 8012b9c:	e7e7      	b.n	8012b6e <GFXwrite+0x136>
 8012b9e:	bf00      	nop

08012ba0 <GFXsetCursor>:

void GFXsetCursor(GFX* myGFX, int16_t x, int16_t y) {
	myGFX->cursor_x = x;
 8012ba0:	8181      	strh	r1, [r0, #12]
	myGFX->cursor_y = y;
 8012ba2:	8142      	strh	r2, [r0, #10]
}
 8012ba4:	4770      	bx	lr
 8012ba6:	bf00      	nop

08012ba8 <GFXgetCursorX>:

int16_t GFXgetCursorX(GFX* myGFX)
{
    return myGFX->cursor_x;
}
 8012ba8:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
 8012bac:	4770      	bx	lr
 8012bae:	bf00      	nop

08012bb0 <GFXsetTextSize>:
{
    return myGFX->cursor_y;
}

void GFXsetTextSize(GFX* myGFX, uint8_t s) {
	myGFX->textsize = (s > 0) ? s : 1;
 8012bb0:	2900      	cmp	r1, #0
 8012bb2:	bf08      	it	eq
 8012bb4:	2101      	moveq	r1, #1
 8012bb6:	81c1      	strh	r1, [r0, #14]
}
 8012bb8:	4770      	bx	lr
 8012bba:	bf00      	nop

08012bbc <GFXsetTextColor>:

void GFXsetTextColor(GFX* myGFX, uint16_t c, uint16_t b) {
	myGFX->textcolor   = c;
 8012bbc:	8201      	strh	r1, [r0, #16]
	myGFX->textbgcolor = b;
 8012bbe:	8242      	strh	r2, [r0, #18]
}
 8012bc0:	4770      	bx	lr
 8012bc2:	bf00      	nop

08012bc4 <GFXsetFont>:
// to this function to use correct CP437 character values in your code.
void GFXcp437(GFX* myGFX, uint8_t x) {
	myGFX->_cp437 = x;
}

void GFXsetFont(GFX* myGFX, const GFXfont *f) {
 8012bc4:	6983      	ldr	r3, [r0, #24]

	if(f)
 8012bc6:	b139      	cbz	r1, 8012bd8 <GFXsetFont+0x14>
    {            // Font struct pointer passed in?
        if(!myGFX->gfxFont) { // And no current font struct?
 8012bc8:	b10b      	cbz	r3, 8012bce <GFXsetFont+0xa>
		}

		myGFX->fontHeight = 8;
		myGFX->fontDesc = 0;
	}
    myGFX->gfxFont = (GFXfont *)f;
 8012bca:	6181      	str	r1, [r0, #24]
}
 8012bcc:	4770      	bx	lr
        	myGFX->cursor_y += 6;
 8012bce:	8943      	ldrh	r3, [r0, #10]
    myGFX->gfxFont = (GFXfont *)f;
 8012bd0:	6181      	str	r1, [r0, #24]
        	myGFX->cursor_y += 6;
 8012bd2:	3306      	adds	r3, #6
 8012bd4:	8143      	strh	r3, [r0, #10]
}
 8012bd6:	4770      	bx	lr
	else if(myGFX->gfxFont)
 8012bd8:	b113      	cbz	r3, 8012be0 <GFXsetFont+0x1c>
		myGFX->fontDesc = 0;
 8012bda:	83c1      	strh	r1, [r0, #30]
		uint8_t first  = (uint8_t) pgm_read_byte(&f->first);
 8012bdc:	7a0b      	ldrb	r3, [r1, #8]
 8012bde:	deff      	udf	#255	; 0xff
		myGFX->fontHeight = 8;
 8012be0:	2308      	movs	r3, #8
 8012be2:	61c3      	str	r3, [r0, #28]
 8012be4:	e7f1      	b.n	8012bca <GFXsetFont+0x6>
 8012be6:	bf00      	nop

08012be8 <OLEDparseInt>:
	'A', '#',
	'B', ' '
};

int OLEDparseInt(char* buffer, uint32_t myNumber, uint8_t numDigits)
{
 8012be8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (int i = 0; i < numDigits; i++)
 8012bea:	4617      	mov	r7, r2
 8012bec:	b1ca      	cbz	r2, 8012c22 <OLEDparseInt+0x3a>
 8012bee:	460d      	mov	r5, r1
 8012bf0:	4606      	mov	r6, r0
 8012bf2:	1e54      	subs	r4, r2, #1
	{
		int whichPlace = (uint32_t)(powf(10.0f,(numDigits - 1) - i));
 8012bf4:	ee07 4a90 	vmov	s15, r4
 8012bf8:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8012bfc:	3c01      	subs	r4, #1
 8012bfe:	eef8 0ae7 	vcvt.f32.s32	s1, s15
 8012c02:	f014 fcbd 	bl	8027580 <powf>
 8012c06:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8012c0a:	ee17 3a90 	vmov	r3, s15
		int thisDigit = (myNumber / whichPlace);
 8012c0e:	fbb5 f2f3 	udiv	r2, r5, r3
		buffer[i] = thisDigit + 48;
 8012c12:	f102 0130 	add.w	r1, r2, #48	; 0x30
		myNumber -= thisDigit * whichPlace;
 8012c16:	fb02 5513 	mls	r5, r2, r3, r5
	for (int i = 0; i < numDigits; i++)
 8012c1a:	1c63      	adds	r3, r4, #1
		buffer[i] = thisDigit + 48;
 8012c1c:	f806 1b01 	strb.w	r1, [r6], #1
	for (int i = 0; i < numDigits; i++)
 8012c20:	d1e8      	bne.n	8012bf4 <OLEDparseInt+0xc>
	}

	return numDigits;
}
 8012c22:	4638      	mov	r0, r7
 8012c24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012c26:	bf00      	nop

08012c28 <OLEDparsePitch>:

int OLEDparsePitch(char* buffer, float midi, uint8_t showCents)
{
	int pclass, octave, note, neg = 0; float offset;

	note = (int)midi;
 8012c28:	eebd 7ac0 	vcvt.s32.f32	s14, s0
	offset = midi - note;

	if ((midi + 0.5f) > (note+1))
 8012c2c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	note = (int)midi;
 8012c30:	ee17 3a10 	vmov	r3, s14
	offset = midi - note;
 8012c34:	eef8 6ac7 	vcvt.f32.s32	s13, s14
	if ((midi + 0.5f) > (note+1))
 8012c38:	ee70 7a27 	vadd.f32	s15, s0, s15
 8012c3c:	1c5a      	adds	r2, r3, #1
	offset = midi - note;
 8012c3e:	ee30 0a66 	vsub.f32	s0, s0, s13
	if ((midi + 0.5f) > (note+1))
 8012c42:	ee07 2a10 	vmov	s14, r2
 8012c46:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
{
 8012c4a:	b470      	push	{r4, r5, r6}
	if ((midi + 0.5f) > (note+1))
 8012c4c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8012c50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012c54:	dd3a      	ble.n	8012ccc <OLEDparsePitch+0xa4>
	{
		note += 1;
		offset = (1.0f - offset) + 0.01f;
 8012c56:	eddf 7a20 	vldr	s15, [pc, #128]	; 8012cd8 <OLEDparsePitch+0xb0>
		note += 1;
 8012c5a:	4613      	mov	r3, r2
		neg = 1;
 8012c5c:	2601      	movs	r6, #1
		offset = (1.0f - offset) + 0.01f;
 8012c5e:	ee37 0ac0 	vsub.f32	s0, s15, s0
	}

	pclass = (note % 12);
 8012c62:	4d1e      	ldr	r5, [pc, #120]	; (8012cdc <OLEDparsePitch+0xb4>)
 8012c64:	17da      	asrs	r2, r3, #31
	octave = (int)(note / 12) - 1;

	int idx = 0;

	buffer[idx++] = pitches[pclass*2];
 8012c66:	4c1e      	ldr	r4, [pc, #120]	; (8012ce0 <OLEDparsePitch+0xb8>)
	pclass = (note % 12);
 8012c68:	fb85 c503 	smull	ip, r5, r5, r3
 8012c6c:	ebc2 0265 	rsb	r2, r2, r5, asr #1
 8012c70:	eb02 0542 	add.w	r5, r2, r2, lsl #1
		buffer[i] = thisDigit + 48;
 8012c74:	322f      	adds	r2, #47	; 0x2f
	pclass = (note % 12);
 8012c76:	eba3 0385 	sub.w	r3, r3, r5, lsl #2
	buffer[idx++] = pitches[pclass*2];
 8012c7a:	f814 5013 	ldrb.w	r5, [r4, r3, lsl #1]
	buffer[idx++] = pitches[pclass*2+1];
 8012c7e:	eb04 0343 	add.w	r3, r4, r3, lsl #1
	buffer[idx++] = pitches[pclass*2];
 8012c82:	7005      	strb	r5, [r0, #0]
	buffer[idx++] = pitches[pclass*2+1];
 8012c84:	785b      	ldrb	r3, [r3, #1]
		buffer[i] = thisDigit + 48;
 8012c86:	7082      	strb	r2, [r0, #2]
	buffer[idx++] = pitches[pclass*2+1];
 8012c88:	7043      	strb	r3, [r0, #1]

	OLEDparseInt(&buffer[idx++], octave, 1);

	if (showCents)
 8012c8a:	b309      	cbz	r1, 8012cd0 <OLEDparsePitch+0xa8>
		if (neg == 1)
			buffer[idx++] = '-';
		else
			buffer[idx++] = '+';

		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
 8012c8c:	eddf 7a15 	vldr	s15, [pc, #84]	; 8012ce4 <OLEDparsePitch+0xbc>
		if (neg == 1)
 8012c90:	2e01      	cmp	r6, #1
		int thisDigit = (myNumber / whichPlace);
 8012c92:	4a15      	ldr	r2, [pc, #84]	; (8012ce8 <OLEDparsePitch+0xc0>)
		buffer[idx++] = ' ';
 8012c94:	f04f 0120 	mov.w	r1, #32
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
 8012c98:	ee20 0a27 	vmul.f32	s0, s0, s15
			buffer[idx++] = '+';
 8012c9c:	bf0c      	ite	eq
 8012c9e:	232d      	moveq	r3, #45	; 0x2d
 8012ca0:	232b      	movne	r3, #43	; 0x2b
		buffer[idx++] = ' ';
 8012ca2:	70c1      	strb	r1, [r0, #3]
		idx += 2;
 8012ca4:	2107      	movs	r1, #7
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
 8012ca6:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8012caa:	7103      	strb	r3, [r0, #4]
 8012cac:	ee17 3a90 	vmov	r3, s15
		int thisDigit = (myNumber / whichPlace);
 8012cb0:	fba2 4203 	umull	r4, r2, r2, r3
 8012cb4:	08d2      	lsrs	r2, r2, #3
		myNumber -= thisDigit * whichPlace;
 8012cb6:	eb02 0482 	add.w	r4, r2, r2, lsl #2
		buffer[i] = thisDigit + 48;
 8012cba:	3230      	adds	r2, #48	; 0x30
		myNumber -= thisDigit * whichPlace;
 8012cbc:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
		buffer[i] = thisDigit + 48;
 8012cc0:	7142      	strb	r2, [r0, #5]
 8012cc2:	3330      	adds	r3, #48	; 0x30
 8012cc4:	7183      	strb	r3, [r0, #6]
	}

	return idx;
}
 8012cc6:	4608      	mov	r0, r1
 8012cc8:	bc70      	pop	{r4, r5, r6}
 8012cca:	4770      	bx	lr
	int pclass, octave, note, neg = 0; float offset;
 8012ccc:	2600      	movs	r6, #0
 8012cce:	e7c8      	b.n	8012c62 <OLEDparsePitch+0x3a>
	OLEDparseInt(&buffer[idx++], octave, 1);
 8012cd0:	2103      	movs	r1, #3
}
 8012cd2:	bc70      	pop	{r4, r5, r6}
 8012cd4:	4608      	mov	r0, r1
 8012cd6:	4770      	bx	lr
 8012cd8:	3f8147ae 	.word	0x3f8147ae
 8012cdc:	2aaaaaab 	.word	0x2aaaaaab
 8012ce0:	20000024 	.word	0x20000024
 8012ce4:	42c80000 	.word	0x42c80000
 8012ce8:	cccccccd 	.word	0xcccccccd

08012cec <OLEDparsePitchClass>:
int OLEDparsePitchClass(char* buffer, float midi)
{
	int pclass, note;
	float offset;

	note = (int)midi;
 8012cec:	eebd 7ac0 	vcvt.s32.f32	s14, s0
	{
		note += 1;
		offset = (1.0f - offset) + 0.01f;
	}

	pclass = (note % 12);
 8012cf0:	4a13      	ldr	r2, [pc, #76]	; (8012d40 <OLEDparsePitchClass+0x54>)
	if ((midi + 0.5f) > (note+1))
 8012cf2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5

	int idx = 0;

	buffer[idx++] = pitches[pclass*2];
 8012cf6:	4913      	ldr	r1, [pc, #76]	; (8012d44 <OLEDparsePitchClass+0x58>)
	note = (int)midi;
 8012cf8:	ee17 3a10 	vmov	r3, s14
	if ((midi + 0.5f) > (note+1))
 8012cfc:	ee30 0a27 	vadd.f32	s0, s0, s15
{
 8012d00:	b430      	push	{r4, r5}
	if ((midi + 0.5f) > (note+1))
 8012d02:	1c5c      	adds	r4, r3, #1
{
 8012d04:	4605      	mov	r5, r0
	buffer[idx++] = pitches[pclass*2+1];

	return idx;
}
 8012d06:	2002      	movs	r0, #2
	if ((midi + 0.5f) > (note+1))
 8012d08:	ee07 4a90 	vmov	s15, r4
 8012d0c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		note += 1;
 8012d10:	eeb4 0a67 	vcmp.f32	s0, s15
 8012d14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012d18:	bfc8      	it	gt
 8012d1a:	4623      	movgt	r3, r4
	pclass = (note % 12);
 8012d1c:	fb82 2403 	smull	r2, r4, r2, r3
 8012d20:	17da      	asrs	r2, r3, #31
 8012d22:	ebc2 0264 	rsb	r2, r2, r4, asr #1
 8012d26:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8012d2a:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
	buffer[idx++] = pitches[pclass*2];
 8012d2e:	f811 2013 	ldrb.w	r2, [r1, r3, lsl #1]
	buffer[idx++] = pitches[pclass*2+1];
 8012d32:	eb01 0343 	add.w	r3, r1, r3, lsl #1
	buffer[idx++] = pitches[pclass*2];
 8012d36:	702a      	strb	r2, [r5, #0]
	buffer[idx++] = pitches[pclass*2+1];
 8012d38:	785b      	ldrb	r3, [r3, #1]
 8012d3a:	706b      	strb	r3, [r5, #1]
}
 8012d3c:	bc30      	pop	{r4, r5}
 8012d3e:	4770      	bx	lr
 8012d40:	2aaaaaab 	.word	0x2aaaaaab
 8012d44:	20000024 	.word	0x20000024

08012d48 <OLEDparseFixedFloat>:

int OLEDparseFixedFloat(char* buffer, float input, uint8_t numDigits, uint8_t numDecimal)
{
	float power = powf(10.0f, numDecimal);
 8012d48:	ee07 2a90 	vmov	s15, r2
{
 8012d4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012d50:	ed2d 8b02 	vpush	{d8}
 8012d54:	b085      	sub	sp, #20
 8012d56:	eeb0 8a40 	vmov.f32	s16, s0
	float power = powf(10.0f, numDecimal);
 8012d5a:	eef8 0a67 	vcvt.f32.u32	s1, s15
{
 8012d5e:	4680      	mov	r8, r0
	float power = powf(10.0f, numDecimal);
 8012d60:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
{
 8012d64:	9201      	str	r2, [sp, #4]
 8012d66:	9102      	str	r1, [sp, #8]
	float power = powf(10.0f, numDecimal);
 8012d68:	f014 fc0a 	bl	8027580 <powf>
	float f = ((float)(int)(input * power + 0.5f)) / power;
 8012d6c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8012d70:	eee0 7a08 	vfma.f32	s15, s0, s16
 8012d74:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8012d78:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012d7c:	ee87 7a80 	vdiv.f32	s14, s15, s0

	int nonzeroHasHappened = 0, decimalHasHappened = 0;

	int myNumber = (int)(f * power);
 8012d80:	ee27 0a00 	vmul.f32	s0, s14, s0
 8012d84:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8012d88:	ee17 5a90 	vmov	r5, s15

	int idx = 0, i = 0;

	if (myNumber < 0)
 8012d8c:	2d00      	cmp	r5, #0
 8012d8e:	f2c0 8082 	blt.w	8012e96 <OLEDparseFixedFloat+0x14e>
	int idx = 0, i = 0;
 8012d92:	2600      	movs	r6, #0
		myNumber *= -1;
		buffer[idx++] = '-';
		i++;
	}

	while (i < numDigits)
 8012d94:	9b02      	ldr	r3, [sp, #8]
 8012d96:	429e      	cmp	r6, r3
 8012d98:	da3e      	bge.n	8012e18 <OLEDparseFixedFloat+0xd0>
 8012d9a:	2400      	movs	r4, #0
 8012d9c:	1b9f      	subs	r7, r3, r6
 8012d9e:	9603      	str	r6, [sp, #12]
		if ((decimalHasHappened == 0) && ((numDigits-i) == numDecimal))
		{
			if (nonzeroHasHappened == 0)
			{
				idx++; //get past the negative if there is one - this is hacky should figure out how to do it right
				buffer[idx-1] = '0';
 8012da0:	46a9      	mov	r9, r5
			decimalHasHappened = 1;
		}
		else
		{

			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8012da2:	f107 3aff 	add.w	sl, r7, #4294967295	; 0xffffffff
	while (i < numDigits)
 8012da6:	9400      	str	r4, [sp, #0]
				buffer[idx-1] = '0';
 8012da8:	46a3      	mov	fp, r4
 8012daa:	e00d      	b.n	8012dc8 <OLEDparseFixedFloat+0x80>
			int thisDigit = (myNumber / whichPlace);

			if (nonzeroHasHappened == 0)
			{
				if (thisDigit > 0)
 8012dac:	2b00      	cmp	r3, #0
 8012dae:	dd63      	ble.n	8012e78 <OLEDparseFixedFloat+0x130>
				{
					buffer[idx++] = thisDigit + 48;
 8012db0:	f103 0e30 	add.w	lr, r3, #48	; 0x30
 8012db4:	462e      	mov	r6, r5
					nonzeroHasHappened = 1;
 8012db6:	f04f 0b01 	mov.w	fp, #1
					buffer[idx++] = thisDigit + 48;
 8012dba:	f88c e000 	strb.w	lr, [ip]
 8012dbe:	3401      	adds	r4, #1
 8012dc0:	fb02 9913 	mls	r9, r2, r3, r9
	while (i < numDigits)
 8012dc4:	42bc      	cmp	r4, r7
 8012dc6:	d027      	beq.n	8012e18 <OLEDparseFixedFloat+0xd0>
		if ((decimalHasHappened == 0) && ((numDigits-i) == numDecimal))
 8012dc8:	9b00      	ldr	r3, [sp, #0]
 8012dca:	1c75      	adds	r5, r6, #1
 8012dcc:	b91b      	cbnz	r3, 8012dd6 <OLEDparseFixedFloat+0x8e>
 8012dce:	1b3b      	subs	r3, r7, r4
 8012dd0:	9a01      	ldr	r2, [sp, #4]
 8012dd2:	429a      	cmp	r2, r3
 8012dd4:	d026      	beq.n	8012e24 <OLEDparseFixedFloat+0xdc>
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8012dd6:	ebaa 0304 	sub.w	r3, sl, r4
 8012dda:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8012dde:	ee07 3a90 	vmov	s15, r3
 8012de2:	eef8 0ae7 	vcvt.f32.s32	s1, s15
 8012de6:	f014 fbcb 	bl	8027580 <powf>
 8012dea:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8012dee:	eb08 0c06 	add.w	ip, r8, r6
 8012df2:	ee17 2a90 	vmov	r2, s15
			int thisDigit = (myNumber / whichPlace);
 8012df6:	fb99 f3f2 	sdiv	r3, r9, r2
			if (nonzeroHasHappened == 0)
 8012dfa:	f1bb 0f00 	cmp.w	fp, #0
 8012dfe:	d0d5      	beq.n	8012dac <OLEDparseFixedFloat+0x64>
					buffer[idx++] = ' ';
				}
			}
			else
			{
				buffer[idx++] = thisDigit + 48;
 8012e00:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8012e04:	462e      	mov	r6, r5
 8012e06:	f04f 0b01 	mov.w	fp, #1
 8012e0a:	f88c 1000 	strb.w	r1, [ip]
 8012e0e:	3401      	adds	r4, #1
 8012e10:	fb02 9913 	mls	r9, r2, r3, r9
	while (i < numDigits)
 8012e14:	42bc      	cmp	r4, r7
 8012e16:	d1d7      	bne.n	8012dc8 <OLEDparseFixedFloat+0x80>
			i++;
		}
	}

	return idx;
}
 8012e18:	4630      	mov	r0, r6
 8012e1a:	b005      	add	sp, #20
 8012e1c:	ecbd 8b02 	vpop	{d8}
 8012e20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (nonzeroHasHappened == 0)
 8012e24:	f1bb 0f00 	cmp.w	fp, #0
 8012e28:	d02c      	beq.n	8012e84 <OLEDparseFixedFloat+0x13c>
 8012e2a:	4632      	mov	r2, r6
	while (i < numDigits)
 8012e2c:	9b03      	ldr	r3, [sp, #12]
			buffer[idx++] = '.';
 8012e2e:	f04f 012e 	mov.w	r1, #46	; 0x2e
	while (i < numDigits)
 8012e32:	4423      	add	r3, r4
			buffer[idx++] = '.';
 8012e34:	f808 1002 	strb.w	r1, [r8, r2]
	while (i < numDigits)
 8012e38:	9a02      	ldr	r2, [sp, #8]
 8012e3a:	4293      	cmp	r3, r2
 8012e3c:	da31      	bge.n	8012ea2 <OLEDparseFixedFloat+0x15a>
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8012e3e:	ebaa 0304 	sub.w	r3, sl, r4
			decimalHasHappened = 1;
 8012e42:	2201      	movs	r2, #1
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8012e44:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
				buffer[idx++] = thisDigit + 48;
 8012e48:	f04f 0b01 	mov.w	fp, #1
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8012e4c:	ee07 3a90 	vmov	s15, r3
			decimalHasHappened = 1;
 8012e50:	9200      	str	r2, [sp, #0]
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8012e52:	eef8 0ae7 	vcvt.f32.s32	s1, s15
 8012e56:	f014 fb93 	bl	8027580 <powf>
 8012e5a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8012e5e:	eb08 0c05 	add.w	ip, r8, r5
 8012e62:	3501      	adds	r5, #1
 8012e64:	ee17 2a90 	vmov	r2, s15
				buffer[idx++] = thisDigit + 48;
 8012e68:	462e      	mov	r6, r5
			int thisDigit = (myNumber / whichPlace);
 8012e6a:	fb99 f3f2 	sdiv	r3, r9, r2
				buffer[idx++] = thisDigit + 48;
 8012e6e:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8012e72:	f88c 1000 	strb.w	r1, [ip]
 8012e76:	e7ca      	b.n	8012e0e <OLEDparseFixedFloat+0xc6>
					buffer[idx++] = ' ';
 8012e78:	f04f 0120 	mov.w	r1, #32
 8012e7c:	462e      	mov	r6, r5
 8012e7e:	f88c 1000 	strb.w	r1, [ip]
 8012e82:	e79c      	b.n	8012dbe <OLEDparseFixedFloat+0x76>
				buffer[idx-1] = '0';
 8012e84:	eb08 0305 	add.w	r3, r8, r5
 8012e88:	f04f 0130 	mov.w	r1, #48	; 0x30
 8012e8c:	462a      	mov	r2, r5
 8012e8e:	1cb5      	adds	r5, r6, #2
 8012e90:	f803 1c01 	strb.w	r1, [r3, #-1]
 8012e94:	e7ca      	b.n	8012e2c <OLEDparseFixedFloat+0xe4>
		buffer[idx++] = '-';
 8012e96:	232d      	movs	r3, #45	; 0x2d
		myNumber *= -1;
 8012e98:	426d      	negs	r5, r5
		buffer[idx++] = '-';
 8012e9a:	2601      	movs	r6, #1
 8012e9c:	f888 3000 	strb.w	r3, [r8]
 8012ea0:	e778      	b.n	8012d94 <OLEDparseFixedFloat+0x4c>
			buffer[idx++] = '.';
 8012ea2:	462e      	mov	r6, r5
}
 8012ea4:	4630      	mov	r0, r6
 8012ea6:	b005      	add	sp, #20
 8012ea8:	ecbd 8b02 	vpop	{d8}
 8012eac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08012eb0 <MX_GPIO_Init>:
     PA13 (JTMS/SWDIO)   ------> DEBUG_JTMS-SWDIO
     PA14 (JTCK/SWCLK)   ------> DEBUG_JTCK-SWCLK
     PB3 (JTDO/TRACESWO)   ------> DEBUG_JTDO-SWO
*/
void MX_GPIO_Init(void)
{
 8012eb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8012eb4:	4b8d      	ldr	r3, [pc, #564]	; (80130ec <MX_GPIO_Init+0x23c>)
{
 8012eb6:	b08f      	sub	sp, #60	; 0x3c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012eb8:	2400      	movs	r4, #0
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : PC14 PC4 PC6 PC7 */
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8012eba:	2501      	movs	r5, #1
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8012ebc:	f8df 8238 	ldr.w	r8, [pc, #568]	; 80130f8 <MX_GPIO_Init+0x248>
 8012ec0:	f244 01d0 	movw	r1, #16592	; 0x40d0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012ec4:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8012ec6:	4622      	mov	r2, r4
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012ec8:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8012eca:	4640      	mov	r0, r8
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012ecc:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
 8012ece:	f8df a22c 	ldr.w	sl, [pc, #556]	; 80130fc <MX_GPIO_Init+0x24c>
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
 8012ed2:	f8df 922c 	ldr.w	r9, [pc, #556]	; 8013100 <MX_GPIO_Init+0x250>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
 8012ed6:	f8df b22c 	ldr.w	fp, [pc, #556]	; 8013104 <MX_GPIO_Init+0x254>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012eda:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8012ede:	f8d3 60e0 	ldr.w	r6, [r3, #224]	; 0xe0
 8012ee2:	f046 0610 	orr.w	r6, r6, #16
 8012ee6:	f8c3 60e0 	str.w	r6, [r3, #224]	; 0xe0
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

  /*Configure GPIO pins : PF7 PF8 PF9 PF10 */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012eea:	2603      	movs	r6, #3
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8012eec:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012ef0:	f007 0710 	and.w	r7, r7, #16
 8012ef4:	9701      	str	r7, [sp, #4]
 8012ef6:	9f01      	ldr	r7, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8012ef8:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012efc:	f047 0704 	orr.w	r7, r7, #4
 8012f00:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
 8012f04:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f08:	f007 0704 	and.w	r7, r7, #4
 8012f0c:	9702      	str	r7, [sp, #8]
 8012f0e:	9f02      	ldr	r7, [sp, #8]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8012f10:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f14:	f047 0720 	orr.w	r7, r7, #32
 8012f18:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
 8012f1c:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f20:	f007 0720 	and.w	r7, r7, #32
 8012f24:	9703      	str	r7, [sp, #12]
 8012f26:	9f03      	ldr	r7, [sp, #12]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8012f28:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f2c:	f047 0780 	orr.w	r7, r7, #128	; 0x80
 8012f30:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
 8012f34:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f38:	f007 0780 	and.w	r7, r7, #128	; 0x80
 8012f3c:	9704      	str	r7, [sp, #16]
 8012f3e:	9f04      	ldr	r7, [sp, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8012f40:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f44:	432f      	orrs	r7, r5
 8012f46:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
 8012f4a:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f4e:	402f      	ands	r7, r5
 8012f50:	9705      	str	r7, [sp, #20]
 8012f52:	9f05      	ldr	r7, [sp, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8012f54:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f58:	f047 0702 	orr.w	r7, r7, #2
 8012f5c:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
 8012f60:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f64:	f007 0702 	and.w	r7, r7, #2
 8012f68:	9706      	str	r7, [sp, #24]
 8012f6a:	9f06      	ldr	r7, [sp, #24]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8012f6c:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f70:	f047 0740 	orr.w	r7, r7, #64	; 0x40
 8012f74:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
 8012f78:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f7c:	f007 0740 	and.w	r7, r7, #64	; 0x40
 8012f80:	9707      	str	r7, [sp, #28]
 8012f82:	9f07      	ldr	r7, [sp, #28]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8012f84:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
 8012f88:	f047 0708 	orr.w	r7, r7, #8
 8012f8c:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
 8012f90:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
 8012f94:	4f56      	ldr	r7, [pc, #344]	; (80130f0 <MX_GPIO_Init+0x240>)
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8012f96:	f003 0308 	and.w	r3, r3, #8
 8012f9a:	9308      	str	r3, [sp, #32]
 8012f9c:	9b08      	ldr	r3, [sp, #32]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8012f9e:	f7f2 fc49 	bl	8005834 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
 8012fa2:	4622      	mov	r2, r4
 8012fa4:	4650      	mov	r0, sl
 8012fa6:	2140      	movs	r1, #64	; 0x40
 8012fa8:	f7f2 fc44 	bl	8005834 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
 8012fac:	4622      	mov	r2, r4
 8012fae:	4648      	mov	r0, r9
 8012fb0:	f44f 61ea 	mov.w	r1, #1872	; 0x750
 8012fb4:	f7f2 fc3e 	bl	8005834 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
 8012fb8:	4622      	mov	r2, r4
 8012fba:	4658      	mov	r0, fp
 8012fbc:	2111      	movs	r1, #17
 8012fbe:	f7f2 fc39 	bl	8005834 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
 8012fc2:	4622      	mov	r2, r4
 8012fc4:	4638      	mov	r0, r7
 8012fc6:	f44f 6198 	mov.w	r1, #1216	; 0x4c0
 8012fca:	f7f2 fc33 	bl	8005834 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 8012fce:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012fd2:	a909      	add	r1, sp, #36	; 0x24
 8012fd4:	4640      	mov	r0, r8
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 8012fd6:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012fd8:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012fdc:	f7f2 f8f0 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
 8012fe0:	f244 03d0 	movw	r3, #16592	; 0x40d0
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012fe4:	a909      	add	r1, sp, #36	; 0x24
 8012fe6:	4640      	mov	r0, r8
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8012fe8:	e9cd 3509 	strd	r3, r5, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8012fec:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012ff0:	f7f2 f8e6 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_15;
 8012ff4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8012ff8:	4b3e      	ldr	r3, [pc, #248]	; (80130f4 <MX_GPIO_Init+0x244>)
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012ffa:	4640      	mov	r0, r8
 8012ffc:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012ffe:	940b      	str	r4, [sp, #44]	; 0x2c

  /*Configure GPIO pins : PD11 PD7 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8013000:	f508 6880 	add.w	r8, r8, #1024	; 0x400
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8013004:	e9cd 2309 	strd	r2, r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8013008:	f7f2 f8da 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_6;
 801300c:	2340      	movs	r3, #64	; 0x40
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 801300e:	a909      	add	r1, sp, #36	; 0x24
 8013010:	4650      	mov	r0, sl
  GPIO_InitStruct.Pin = GPIO_PIN_6;
 8013012:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8013014:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013016:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 801301a:	f7f2 f8d1 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
 801301e:	f44f 63f0 	mov.w	r3, #1920	; 0x780
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8013022:	4650      	mov	r0, sl
 8013024:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013026:	940b      	str	r4, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8013028:	e9cd 3609 	strd	r3, r6, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 801302c:	f7f2 f8c8 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15;
 8013030:	f248 0302 	movw	r3, #32770	; 0x8002
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8013034:	a909      	add	r1, sp, #36	; 0x24
 8013036:	4648      	mov	r0, r9
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15;
 8013038:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801303a:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801303e:	f7f2 f8bf 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
 8013042:	f44f 63ea 	mov.w	r3, #1872	; 0x750
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8013046:	4648      	mov	r0, r9
 8013048:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
 801304a:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 801304c:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801304e:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8013052:	f7f2 f8b5 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 8013056:	2311      	movs	r3, #17
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8013058:	a909      	add	r1, sp, #36	; 0x24
 801305a:	4658      	mov	r0, fp
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 801305c:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 801305e:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013060:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8013064:	f7f2 f8ac 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
 8013068:	f24f 0302 	movw	r3, #61442	; 0xf002
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801306c:	a909      	add	r1, sp, #36	; 0x24
 801306e:	4658      	mov	r0, fp
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
 8013070:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8013072:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8013076:	f7f2 f8a3 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_9;
 801307a:	f44f 7301 	mov.w	r3, #516	; 0x204
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801307e:	4658      	mov	r0, fp
 8013080:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_9;
 8013082:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013084:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8013088:	f7f2 f89a 	bl	80051c0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
 801308c:	f44f 6308 	mov.w	r3, #2176	; 0x880
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8013090:	a909      	add	r1, sp, #36	; 0x24
 8013092:	4640      	mov	r0, r8
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
 8013094:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8013096:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 801309a:	f7f2 f891 	bl	80051c0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG3 PG9 PG13 PG14 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_13|GPIO_PIN_14;
 801309e:	f246 2308 	movw	r3, #25096	; 0x6208
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80130a2:	a909      	add	r1, sp, #36	; 0x24
 80130a4:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_13|GPIO_PIN_14;
 80130a6:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80130a8:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80130ac:	f7f2 f888 	bl	80051c0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG6 PG7 PG10 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
 80130b0:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80130b4:	a909      	add	r1, sp, #36	; 0x24
 80130b6:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
 80130b8:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80130ba:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80130bc:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80130c0:	f7f2 f87e 	bl	80051c0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PD3 PD4 PD5 PD6 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
 80130c4:	2378      	movs	r3, #120	; 0x78
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80130c6:	4640      	mov	r0, r8
 80130c8:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
 80130ca:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80130cc:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80130d0:	f7f2 f876 	bl	80051c0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG11 PG12 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 80130d4:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80130d8:	a909      	add	r1, sp, #36	; 0x24
 80130da:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 80130dc:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80130de:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80130e2:	f7f2 f86d 	bl	80051c0 <HAL_GPIO_Init>

}
 80130e6:	b00f      	add	sp, #60	; 0x3c
 80130e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80130ec:	58024400 	.word	0x58024400
 80130f0:	58021800 	.word	0x58021800
 80130f4:	11110000 	.word	0x11110000
 80130f8:	58020800 	.word	0x58020800
 80130fc:	58021400 	.word	0x58021400
 8013100:	58020000 	.word	0x58020000
 8013104:	58020400 	.word	0x58020400

08013108 <MX_I2C2_Init>:
DMA_HandleTypeDef hdma_i2c4_rx;
DMA_HandleTypeDef hdma_i2c4_tx;

/* I2C2 init function */
void MX_I2C2_Init(void)
{
 8013108:	b538      	push	{r3, r4, r5, lr}

  hi2c2.Instance = I2C2;
 801310a:	4b13      	ldr	r3, [pc, #76]	; (8013158 <MX_I2C2_Init+0x50>)
  hi2c2.Init.Timing = 0x505097F4;
  hi2c2.Init.OwnAddress1 = 0;
 801310c:	2200      	movs	r2, #0
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 801310e:	2101      	movs	r1, #1
  hi2c2.Instance = I2C2;
 8013110:	4d12      	ldr	r5, [pc, #72]	; (801315c <MX_I2C2_Init+0x54>)
  hi2c2.Init.Timing = 0x505097F4;
 8013112:	4c13      	ldr	r4, [pc, #76]	; (8013160 <MX_I2C2_Init+0x58>)
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 8013114:	4618      	mov	r0, r3
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8013116:	621a      	str	r2, [r3, #32]
  hi2c2.Init.Timing = 0x505097F4;
 8013118:	e9c3 5400 	strd	r5, r4, [r3]
  hi2c2.Init.OwnAddress1 = 0;
 801311c:	e9c3 2102 	strd	r2, r1, [r3, #8]
  hi2c2.Init.OwnAddress2 = 0;
 8013120:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8013124:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 8013128:	f7f3 f952 	bl	80063d0 <HAL_I2C_Init>
 801312c:	b988      	cbnz	r0, 8013152 <MX_I2C2_Init+0x4a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 801312e:	2100      	movs	r1, #0
 8013130:	4809      	ldr	r0, [pc, #36]	; (8013158 <MX_I2C2_Init+0x50>)
 8013132:	f7f4 fe59 	bl	8007de8 <HAL_I2CEx_ConfigAnalogFilter>
 8013136:	b948      	cbnz	r0, 801314c <MX_I2C2_Init+0x44>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
 8013138:	2100      	movs	r1, #0
 801313a:	4807      	ldr	r0, [pc, #28]	; (8013158 <MX_I2C2_Init+0x50>)
 801313c:	f7f4 feac 	bl	8007e98 <HAL_I2CEx_ConfigDigitalFilter>
 8013140:	b900      	cbnz	r0, 8013144 <MX_I2C2_Init+0x3c>
  {
    Error_Handler();
  }

}
 8013142:	bd38      	pop	{r3, r4, r5, pc}
 8013144:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
 8013148:	f000 bbc0 	b.w	80138cc <Error_Handler>
    Error_Handler();
 801314c:	f000 fbbe 	bl	80138cc <Error_Handler>
 8013150:	e7f2      	b.n	8013138 <MX_I2C2_Init+0x30>
    Error_Handler();
 8013152:	f000 fbbb 	bl	80138cc <Error_Handler>
 8013156:	e7ea      	b.n	801312e <MX_I2C2_Init+0x26>
 8013158:	2000163c 	.word	0x2000163c
 801315c:	40005800 	.word	0x40005800
 8013160:	505097f4 	.word	0x505097f4

08013164 <MX_I2C4_Init>:
/* I2C4 init function */
void MX_I2C4_Init(void)
{
 8013164:	b538      	push	{r3, r4, r5, lr}

  hi2c4.Instance = I2C4;
 8013166:	4b13      	ldr	r3, [pc, #76]	; (80131b4 <MX_I2C4_Init+0x50>)
  hi2c4.Init.Timing = 0x307075B1;
  hi2c4.Init.OwnAddress1 = 0;
 8013168:	2200      	movs	r2, #0
  hi2c4.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 801316a:	2101      	movs	r1, #1
  hi2c4.Instance = I2C4;
 801316c:	4d12      	ldr	r5, [pc, #72]	; (80131b8 <MX_I2C4_Init+0x54>)
  hi2c4.Init.Timing = 0x307075B1;
 801316e:	4c13      	ldr	r4, [pc, #76]	; (80131bc <MX_I2C4_Init+0x58>)
  hi2c4.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c4.Init.OwnAddress2 = 0;
  hi2c4.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
 8013170:	4618      	mov	r0, r3
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8013172:	621a      	str	r2, [r3, #32]
  hi2c4.Init.Timing = 0x307075B1;
 8013174:	e9c3 5400 	strd	r5, r4, [r3]
  hi2c4.Init.OwnAddress1 = 0;
 8013178:	e9c3 2102 	strd	r2, r1, [r3, #8]
  hi2c4.Init.OwnAddress2 = 0;
 801317c:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8013180:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
 8013184:	f7f3 f924 	bl	80063d0 <HAL_I2C_Init>
 8013188:	b988      	cbnz	r0, 80131ae <MX_I2C4_Init+0x4a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c4, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 801318a:	2100      	movs	r1, #0
 801318c:	4809      	ldr	r0, [pc, #36]	; (80131b4 <MX_I2C4_Init+0x50>)
 801318e:	f7f4 fe2b 	bl	8007de8 <HAL_I2CEx_ConfigAnalogFilter>
 8013192:	b948      	cbnz	r0, 80131a8 <MX_I2C4_Init+0x44>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c4, 0) != HAL_OK)
 8013194:	2100      	movs	r1, #0
 8013196:	4807      	ldr	r0, [pc, #28]	; (80131b4 <MX_I2C4_Init+0x50>)
 8013198:	f7f4 fe7e 	bl	8007e98 <HAL_I2CEx_ConfigDigitalFilter>
 801319c:	b900      	cbnz	r0, 80131a0 <MX_I2C4_Init+0x3c>
  {
    Error_Handler();
  }

}
 801319e:	bd38      	pop	{r3, r4, r5, pc}
 80131a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
 80131a4:	f000 bb92 	b.w	80138cc <Error_Handler>
    Error_Handler();
 80131a8:	f000 fb90 	bl	80138cc <Error_Handler>
 80131ac:	e7f2      	b.n	8013194 <MX_I2C4_Init+0x30>
    Error_Handler();
 80131ae:	f000 fb8d 	bl	80138cc <Error_Handler>
 80131b2:	e7ea      	b.n	801318a <MX_I2C4_Init+0x26>
 80131b4:	200015f0 	.word	0x200015f0
 80131b8:	58001c00 	.word	0x58001c00
 80131bc:	307075b1 	.word	0x307075b1

080131c0 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 80131c0:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(i2cHandle->Instance==I2C2)
 80131c2:	4a50      	ldr	r2, [pc, #320]	; (8013304 <HAL_I2C_MspInit+0x144>)
{
 80131c4:	b08b      	sub	sp, #44	; 0x2c
  if(i2cHandle->Instance==I2C2)
 80131c6:	6803      	ldr	r3, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80131c8:	2400      	movs	r4, #0
  if(i2cHandle->Instance==I2C2)
 80131ca:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80131cc:	9409      	str	r4, [sp, #36]	; 0x24
 80131ce:	e9cd 4405 	strd	r4, r4, [sp, #20]
 80131d2:	e9cd 4407 	strd	r4, r4, [sp, #28]
  if(i2cHandle->Instance==I2C2)
 80131d6:	d069      	beq.n	80132ac <HAL_I2C_MspInit+0xec>
    __HAL_RCC_I2C2_CLK_ENABLE();
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
 80131d8:	4a4b      	ldr	r2, [pc, #300]	; (8013308 <HAL_I2C_MspInit+0x148>)
 80131da:	4293      	cmp	r3, r2
 80131dc:	d001      	beq.n	80131e2 <HAL_I2C_MspInit+0x22>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
  /* USER CODE BEGIN I2C4_MspInit 1 */

  /* USER CODE END I2C4_MspInit 1 */
  }
}
 80131de:	b00b      	add	sp, #44	; 0x2c
 80131e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80131e2:	4f4a      	ldr	r7, [pc, #296]	; (801330c <HAL_I2C_MspInit+0x14c>)
 80131e4:	4605      	mov	r5, r0
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
 80131e6:	f44f 5040 	mov.w	r0, #12288	; 0x3000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80131ea:	2212      	movs	r2, #18
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80131ec:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80131f0:	a905      	add	r1, sp, #20
    hdma_i2c4_rx.Instance = BDMA_Channel0;
 80131f2:	4e47      	ldr	r6, [pc, #284]	; (8013310 <HAL_I2C_MspInit+0x150>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80131f4:	f043 0308 	orr.w	r3, r3, #8
 80131f8:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 80131fc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
 8013200:	9005      	str	r0, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8013202:	2001      	movs	r0, #1
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8013204:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8013208:	9206      	str	r2, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
 801320a:	2204      	movs	r2, #4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 801320c:	9008      	str	r0, [sp, #32]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 801320e:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8013210:	4840      	ldr	r0, [pc, #256]	; (8013314 <HAL_I2C_MspInit+0x154>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8013212:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
 8013214:	9209      	str	r2, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8013216:	f7f1 ffd3 	bl	80051c0 <HAL_GPIO_Init>
    __HAL_RCC_I2C4_CLK_ENABLE();
 801321a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
    hdma_i2c4_rx.Init.Request = BDMA_REQUEST_I2C4_RX;
 801321e:	210d      	movs	r1, #13
    hdma_i2c4_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8013220:	60b4      	str	r4, [r6, #8]
    hdma_i2c4_rx.Init.MemInc = DMA_MINC_ENABLE;
 8013222:	f44f 6280 	mov.w	r2, #1024	; 0x400
    __HAL_RCC_I2C4_CLK_ENABLE();
 8013226:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    if (HAL_DMA_Init(&hdma_i2c4_rx) != HAL_OK)
 801322a:	4630      	mov	r0, r6
    __HAL_RCC_I2C4_CLK_ENABLE();
 801322c:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 8013230:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
    hdma_i2c4_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8013234:	60f4      	str	r4, [r6, #12]
    __HAL_RCC_I2C4_CLK_ENABLE();
 8013236:	f003 0380 	and.w	r3, r3, #128	; 0x80
    hdma_i2c4_rx.Init.MemInc = DMA_MINC_ENABLE;
 801323a:	6132      	str	r2, [r6, #16]
    __HAL_RCC_I2C4_CLK_ENABLE();
 801323c:	9304      	str	r3, [sp, #16]
 801323e:	9b04      	ldr	r3, [sp, #16]
    hdma_i2c4_rx.Instance = BDMA_Channel0;
 8013240:	4b35      	ldr	r3, [pc, #212]	; (8013318 <HAL_I2C_MspInit+0x158>)
    hdma_i2c4_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8013242:	e9c6 4405 	strd	r4, r4, [r6, #20]
    hdma_i2c4_rx.Init.Priority = DMA_PRIORITY_LOW;
 8013246:	e9c6 4407 	strd	r4, r4, [r6, #28]
    hdma_i2c4_rx.Instance = BDMA_Channel0;
 801324a:	e9c6 3100 	strd	r3, r1, [r6]
    if (HAL_DMA_Init(&hdma_i2c4_rx) != HAL_OK)
 801324e:	f7ef fa1f 	bl	8002690 <HAL_DMA_Init>
 8013252:	2800      	cmp	r0, #0
 8013254:	d153      	bne.n	80132fe <HAL_I2C_MspInit+0x13e>
    hdma_i2c4_tx.Instance = BDMA_Channel1;
 8013256:	4c31      	ldr	r4, [pc, #196]	; (801331c <HAL_I2C_MspInit+0x15c>)
    hdma_i2c4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8013258:	2300      	movs	r3, #0
    hdma_i2c4_tx.Instance = BDMA_Channel1;
 801325a:	4831      	ldr	r0, [pc, #196]	; (8013320 <HAL_I2C_MspInit+0x160>)
    hdma_i2c4_tx.Init.Request = BDMA_REQUEST_I2C4_TX;
 801325c:	270e      	movs	r7, #14
    hdma_i2c4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 801325e:	2140      	movs	r1, #64	; 0x40
    hdma_i2c4_tx.Init.MemInc = DMA_MINC_ENABLE;
 8013260:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_i2c4_tx.Instance = BDMA_Channel1;
 8013264:	6020      	str	r0, [r4, #0]
    if (HAL_DMA_Init(&hdma_i2c4_tx) != HAL_OK)
 8013266:	4620      	mov	r0, r4
    __HAL_LINKDMA(i2cHandle,hdmarx,hdma_i2c4_rx);
 8013268:	63ee      	str	r6, [r5, #60]	; 0x3c
 801326a:	63b5      	str	r5, [r6, #56]	; 0x38
    hdma_i2c4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 801326c:	e9c4 7101 	strd	r7, r1, [r4, #4]
    hdma_i2c4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8013270:	e9c4 3203 	strd	r3, r2, [r4, #12]
    hdma_i2c4_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8013274:	e9c4 3305 	strd	r3, r3, [r4, #20]
    hdma_i2c4_tx.Init.Priority = DMA_PRIORITY_LOW;
 8013278:	e9c4 3307 	strd	r3, r3, [r4, #28]
    if (HAL_DMA_Init(&hdma_i2c4_tx) != HAL_OK)
 801327c:	f7ef fa08 	bl	8002690 <HAL_DMA_Init>
 8013280:	2800      	cmp	r0, #0
 8013282:	d139      	bne.n	80132f8 <HAL_I2C_MspInit+0x138>
    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c4_tx);
 8013284:	63ac      	str	r4, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 7, 0);
 8013286:	2200      	movs	r2, #0
 8013288:	2107      	movs	r1, #7
 801328a:	205f      	movs	r0, #95	; 0x5f
    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c4_tx);
 801328c:	63a5      	str	r5, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 7, 0);
 801328e:	f7ef f833 	bl	80022f8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_EV_IRQn);
 8013292:	205f      	movs	r0, #95	; 0x5f
 8013294:	f7ef f876 	bl	8002384 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C4_ER_IRQn, 7, 0);
 8013298:	2200      	movs	r2, #0
 801329a:	2107      	movs	r1, #7
 801329c:	2060      	movs	r0, #96	; 0x60
 801329e:	f7ef f82b 	bl	80022f8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
 80132a2:	2060      	movs	r0, #96	; 0x60
 80132a4:	f7ef f86e 	bl	8002384 <HAL_NVIC_EnableIRQ>
}
 80132a8:	b00b      	add	sp, #44	; 0x2c
 80132aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80132ac:	4c17      	ldr	r4, [pc, #92]	; (801330c <HAL_I2C_MspInit+0x14c>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 80132ae:	2204      	movs	r2, #4
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 80132b0:	f44f 6640 	mov.w	r6, #3072	; 0xc00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80132b4:	2512      	movs	r5, #18
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80132b6:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80132ba:	a905      	add	r1, sp, #20
 80132bc:	4819      	ldr	r0, [pc, #100]	; (8013324 <HAL_I2C_MspInit+0x164>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80132be:	f043 0302 	orr.w	r3, r3, #2
 80132c2:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 80132c6:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 80132ca:	9605      	str	r6, [sp, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80132cc:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80132d0:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 80132d2:	9209      	str	r2, [sp, #36]	; 0x24
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80132d4:	9301      	str	r3, [sp, #4]
 80132d6:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80132d8:	f7f1 ff72 	bl	80051c0 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
 80132dc:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80132e0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80132e4:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 80132e8:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80132ec:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80132f0:	9302      	str	r3, [sp, #8]
 80132f2:	9b02      	ldr	r3, [sp, #8]
}
 80132f4:	b00b      	add	sp, #44	; 0x2c
 80132f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      Error_Handler();
 80132f8:	f000 fae8 	bl	80138cc <Error_Handler>
 80132fc:	e7c2      	b.n	8013284 <HAL_I2C_MspInit+0xc4>
      Error_Handler();
 80132fe:	f000 fae5 	bl	80138cc <Error_Handler>
 8013302:	e7a8      	b.n	8013256 <HAL_I2C_MspInit+0x96>
 8013304:	40005800 	.word	0x40005800
 8013308:	58001c00 	.word	0x58001c00
 801330c:	58024400 	.word	0x58024400
 8013310:	20001688 	.word	0x20001688
 8013314:	58020c00 	.word	0x58020c00
 8013318:	58025408 	.word	0x58025408
 801331c:	20001578 	.word	0x20001578
 8013320:	5802541c 	.word	0x5802541c
 8013324:	58020400 	.word	0x58020400

08013328 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{

  if(i2cHandle->Instance==I2C2)
 8013328:	4a18      	ldr	r2, [pc, #96]	; (801338c <HAL_I2C_MspDeInit+0x64>)
 801332a:	6803      	ldr	r3, [r0, #0]
 801332c:	4293      	cmp	r3, r2
 801332e:	d020      	beq.n	8013372 <HAL_I2C_MspDeInit+0x4a>

  /* USER CODE BEGIN I2C2_MspDeInit 1 */

  /* USER CODE END I2C2_MspDeInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
 8013330:	4a17      	ldr	r2, [pc, #92]	; (8013390 <HAL_I2C_MspDeInit+0x68>)
 8013332:	4293      	cmp	r3, r2
 8013334:	d000      	beq.n	8013338 <HAL_I2C_MspDeInit+0x10>
 8013336:	4770      	bx	lr
  {
  /* USER CODE BEGIN I2C4_MspDeInit 0 */

  /* USER CODE END I2C4_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C4_CLK_DISABLE();
 8013338:	f502 320a 	add.w	r2, r2, #141312	; 0x22800
  
    /**I2C4 GPIO Configuration    
    PD12     ------> I2C4_SCL
    PD13     ------> I2C4_SDA 
    */
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
 801333c:	f44f 5140 	mov.w	r1, #12288	; 0x3000
{
 8013340:	b510      	push	{r4, lr}
    __HAL_RCC_I2C4_CLK_DISABLE();
 8013342:	f8d2 30f4 	ldr.w	r3, [r2, #244]	; 0xf4
 8013346:	4604      	mov	r4, r0
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
 8013348:	4812      	ldr	r0, [pc, #72]	; (8013394 <HAL_I2C_MspDeInit+0x6c>)
    __HAL_RCC_I2C4_CLK_DISABLE();
 801334a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 801334e:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
 8013352:	f7f2 f93f 	bl	80055d4 <HAL_GPIO_DeInit>

    /* I2C4 DMA DeInit */
    HAL_DMA_DeInit(i2cHandle->hdmarx);
 8013356:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8013358:	f7ef fdca 	bl	8002ef0 <HAL_DMA_DeInit>
    HAL_DMA_DeInit(i2cHandle->hdmatx);
 801335c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801335e:	f7ef fdc7 	bl	8002ef0 <HAL_DMA_DeInit>

    /* I2C4 interrupt Deinit */
    HAL_NVIC_DisableIRQ(I2C4_EV_IRQn);
 8013362:	205f      	movs	r0, #95	; 0x5f
 8013364:	f7ef f822 	bl	80023ac <HAL_NVIC_DisableIRQ>
    HAL_NVIC_DisableIRQ(I2C4_ER_IRQn);
 8013368:	2060      	movs	r0, #96	; 0x60
  /* USER CODE BEGIN I2C4_MspDeInit 1 */

  /* USER CODE END I2C4_MspDeInit 1 */
  }
} 
 801336a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(I2C4_ER_IRQn);
 801336e:	f7ef b81d 	b.w	80023ac <HAL_NVIC_DisableIRQ>
    __HAL_RCC_I2C2_CLK_DISABLE();
 8013372:	4a09      	ldr	r2, [pc, #36]	; (8013398 <HAL_I2C_MspDeInit+0x70>)
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
 8013374:	f44f 6140 	mov.w	r1, #3072	; 0xc00
 8013378:	4808      	ldr	r0, [pc, #32]	; (801339c <HAL_I2C_MspDeInit+0x74>)
    __HAL_RCC_I2C2_CLK_DISABLE();
 801337a:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 801337e:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8013382:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
 8013386:	f7f2 b925 	b.w	80055d4 <HAL_GPIO_DeInit>
 801338a:	bf00      	nop
 801338c:	40005800 	.word	0x40005800
 8013390:	58001c00 	.word	0x58001c00
 8013394:	58020c00 	.word	0x58020c00
 8013398:	58024400 	.word	0x58024400
 801339c:	58020400 	.word	0x58020400

080133a0 <SCB_EnableDCache>:
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 80133a0:	4816      	ldr	r0, [pc, #88]	; (80133fc <SCB_EnableDCache+0x5c>)
 80133a2:	2300      	movs	r3, #0
{
 80133a4:	b4f0      	push	{r4, r5, r6, r7}
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 80133a6:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
 80133aa:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 80133ae:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80133b2:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80133b6:	f3c5 06c9 	ubfx	r6, r5, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 80133ba:	f3c5 354e 	ubfx	r5, r5, #13, #15
 80133be:	07b7      	lsls	r7, r6, #30
 80133c0:	016d      	lsls	r5, r5, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80133c2:	ea05 040c 	and.w	r4, r5, ip
 80133c6:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80133c8:	4632      	mov	r2, r6
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80133ca:	ea44 0301 	orr.w	r3, r4, r1
      } while (ways-- != 0U);
 80133ce:	3a01      	subs	r2, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80133d0:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
 80133d4:	f8c0 3260 	str.w	r3, [r0, #608]	; 0x260
      } while (ways-- != 0U);
 80133d8:	1c53      	adds	r3, r2, #1
 80133da:	d1f6      	bne.n	80133ca <SCB_EnableDCache+0x2a>
 80133dc:	3d20      	subs	r5, #32
    } while(sets-- != 0U);
 80133de:	f115 0f20 	cmn.w	r5, #32
 80133e2:	d1ee      	bne.n	80133c2 <SCB_EnableDCache+0x22>
 80133e4:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 80133e8:	6943      	ldr	r3, [r0, #20]
 80133ea:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80133ee:	6143      	str	r3, [r0, #20]
 80133f0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80133f4:	f3bf 8f6f 	isb	sy
}
 80133f8:	bcf0      	pop	{r4, r5, r6, r7}
 80133fa:	4770      	bx	lr
 80133fc:	e000ed00 	.word	0xe000ed00

08013400 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8013400:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013404:	b0cc      	sub	sp, #304	; 0x130
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8013406:	224c      	movs	r2, #76	; 0x4c
 8013408:	2100      	movs	r1, #0
 801340a:	a80a      	add	r0, sp, #40	; 0x28
 801340c:	f013 fde7 	bl	8026fde <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8013410:	2220      	movs	r2, #32
 8013412:	2100      	movs	r1, #0
 8013414:	a802      	add	r0, sp, #8
 8013416:	f013 fde2 	bl	8026fde <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 801341a:	22bc      	movs	r2, #188	; 0xbc
 801341c:	2100      	movs	r1, #0
 801341e:	a81d      	add	r0, sp, #116	; 0x74
 8013420:	f013 fddd 	bl	8026fde <memset>

  /** Supply configuration update enable 
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
 8013424:	2002      	movs	r0, #2
 8013426:	f7f4 fd8d 	bl	8007f44 <HAL_PWREx_ConfigSupply>
  /** Configure the main internal regulator output voltage 
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
 801342a:	4b3f      	ldr	r3, [pc, #252]	; (8013528 <SystemClock_Config+0x128>)
 801342c:	2100      	movs	r1, #0
 801342e:	4a3f      	ldr	r2, [pc, #252]	; (801352c <SystemClock_Config+0x12c>)

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 8013430:	4618      	mov	r0, r3
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
 8013432:	9101      	str	r1, [sp, #4]
 8013434:	6999      	ldr	r1, [r3, #24]
 8013436:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
 801343a:	6199      	str	r1, [r3, #24]
 801343c:	699b      	ldr	r3, [r3, #24]
 801343e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8013442:	9301      	str	r3, [sp, #4]
 8013444:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8013446:	f043 0301 	orr.w	r3, r3, #1
 801344a:	62d3      	str	r3, [r2, #44]	; 0x2c
 801344c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 801344e:	f003 0301 	and.w	r3, r3, #1
 8013452:	9301      	str	r3, [sp, #4]
 8013454:	9b01      	ldr	r3, [sp, #4]
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 8013456:	6983      	ldr	r3, [r0, #24]
 8013458:	049b      	lsls	r3, r3, #18
 801345a:	d5fc      	bpl.n	8013456 <SystemClock_Config+0x56>
  /** Macro to configure the PLL clock source 
  */
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 801345c:	4a34      	ldr	r2, [pc, #208]	; (8013530 <SystemClock_Config+0x130>)
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 801345e:	2402      	movs	r4, #2
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8013460:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
 8013464:	f04f 0c21 	mov.w	ip, #33	; 0x21
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 8013468:	6a93      	ldr	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 801346a:	2501      	movs	r5, #1
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 10;
 801346c:	210a      	movs	r1, #10
  RCC_OscInitStruct.PLL.PLLN = 384;
 801346e:	f44f 76c0 	mov.w	r6, #384	; 0x180
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 8013472:	f023 0303 	bic.w	r3, r3, #3
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 3;
 8013476:	2703      	movs	r7, #3
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_1;
 8013478:	f04f 0804 	mov.w	r8, #4
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 801347c:	4323      	orrs	r3, r4
 801347e:	6293      	str	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 8013480:	2300      	movs	r3, #0
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8013482:	900b      	str	r0, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8013484:	a80a      	add	r0, sp, #40	; 0x28
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
 8013486:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 801348a:	9510      	str	r5, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = 2;
 801348c:	9417      	str	r4, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLR = 2;
 801348e:	9419      	str	r4, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLQ = 3;
 8013490:	9718      	str	r7, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 8013492:	931c      	str	r3, [sp, #112]	; 0x70
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8013494:	e9cd 4413 	strd	r4, r4, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLN = 384;
 8013498:	e9cd 1615 	strd	r1, r6, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 801349c:	e9cd 831a 	strd	r8, r3, [sp, #104]	; 0x68
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80134a0:	f7f4 fd90 	bl	8007fc4 <HAL_RCC_OscConfig>
 80134a4:	b100      	cbz	r0, 80134a8 <SystemClock_Config+0xa8>
 80134a6:	e7fe      	b.n	80134a6 <SystemClock_Config+0xa6>
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80134a8:	223f      	movs	r2, #63	; 0x3f
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80134aa:	9703      	str	r7, [sp, #12]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
 80134ac:	2708      	movs	r7, #8
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
 80134ae:	2340      	movs	r3, #64	; 0x40
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80134b0:	9202      	str	r2, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
 80134b2:	f44f 6280 	mov.w	r2, #1024	; 0x400
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
 80134b6:	9004      	str	r0, [sp, #16]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80134b8:	4641      	mov	r1, r8
 80134ba:	eb0d 0007 	add.w	r0, sp, r7
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
 80134be:	9705      	str	r7, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
 80134c0:	e9cd 3306 	strd	r3, r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
 80134c4:	e9cd 2308 	strd	r2, r3, [sp, #32]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80134c8:	f7f5 f9a2 	bl	8008810 <HAL_RCC_ClockConfig>
 80134cc:	4603      	mov	r3, r0
 80134ce:	b100      	cbz	r0, 80134d2 <SystemClock_Config+0xd2>
 80134d0:	e7fe      	b.n	80134d0 <SystemClock_Config+0xd0>
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_SAI1
                              |RCC_PERIPHCLK_SDMMC|RCC_PERIPHCLK_I2C2
                              |RCC_PERIPHCLK_ADC|RCC_PERIPHCLK_I2C4
                              |RCC_PERIPHCLK_USB|RCC_PERIPHCLK_FMC;
  PeriphClkInitStruct.PLL2.PLL2M = 25;
 80134d2:	2219      	movs	r2, #25
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_SAI1
 80134d4:	f8df e05c 	ldr.w	lr, [pc, #92]	; 8013534 <SystemClock_Config+0x134>
  PeriphClkInitStruct.PLL2.PLL2N = 344;
 80134d8:	f44f 7cac 	mov.w	ip, #344	; 0x158
  PeriphClkInitStruct.PLL2.PLL2R = 1;
  PeriphClkInitStruct.PLL2.PLL2RGE = RCC_PLL2VCIRANGE_0;
  PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOWIDE;
  PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
  PeriphClkInitStruct.PLL3.PLL3M = 25;
  PeriphClkInitStruct.PLL3.PLL3N = 384;
 80134dc:	9627      	str	r6, [sp, #156]	; 0x9c
  PeriphClkInitStruct.FmcClockSelection = RCC_FMCCLKSOURCE_D1HCLK;
  PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
  PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLL2;
  PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_HSI48;
  PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
 80134de:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  PeriphClkInitStruct.PLL2.PLL2P = 7;
 80134e2:	2607      	movs	r6, #7
  PeriphClkInitStruct.I2c4ClockSelection = RCC_I2C4CLKSOURCE_D3PCLK1;
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80134e4:	a81d      	add	r0, sp, #116	; 0x74
  PeriphClkInitStruct.PLL2.PLL2Q = 2;
 80134e6:	9421      	str	r4, [sp, #132]	; 0x84
  PeriphClkInitStruct.PLL2.PLL2R = 1;
 80134e8:	9522      	str	r5, [sp, #136]	; 0x88
  PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
 80134ea:	9325      	str	r3, [sp, #148]	; 0x94
  PeriphClkInitStruct.FmcClockSelection = RCC_FMCCLKSOURCE_D1HCLK;
 80134ec:	932e      	str	r3, [sp, #184]	; 0xb8
  PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
 80134ee:	9330      	str	r3, [sp, #192]	; 0xc0
  PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLL2;
 80134f0:	9532      	str	r5, [sp, #200]	; 0xc8
  PeriphClkInitStruct.I2c4ClockSelection = RCC_I2C4CLKSOURCE_D3PCLK1;
 80134f2:	9342      	str	r3, [sp, #264]	; 0x108
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
 80134f4:	9345      	str	r3, [sp, #276]	; 0x114
  PeriphClkInitStruct.PLL3.PLL3M = 25;
 80134f6:	9226      	str	r2, [sp, #152]	; 0x98
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
 80134f8:	913e      	str	r1, [sp, #248]	; 0xf8
  PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOWIDE;
 80134fa:	e9cd 3323 	strd	r3, r3, [sp, #140]	; 0x8c
  PeriphClkInitStruct.PLL3.PLL3Q = 8;
 80134fe:	e9cd 4728 	strd	r4, r7, [sp, #160]	; 0xa0
  PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_0;
 8013502:	e9cd 432a 	strd	r4, r3, [sp, #168]	; 0xa8
  PeriphClkInitStruct.PLL3.PLL3FRACN = 0;
 8013506:	e9cd 332c 	strd	r3, r3, [sp, #176]	; 0xb0
  PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
 801350a:	e9cd 333c 	strd	r3, r3, [sp, #240]	; 0xf0
  PeriphClkInitStruct.PLL2.PLL2M = 25;
 801350e:	e9cd e21d 	strd	lr, r2, [sp, #116]	; 0x74
  PeriphClkInitStruct.PLL2.PLL2P = 7;
 8013512:	e9cd c61f 	strd	ip, r6, [sp, #124]	; 0x7c
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8013516:	f7f5 fe13 	bl	8009140 <HAL_RCCEx_PeriphCLKConfig>
 801351a:	b100      	cbz	r0, 801351e <SystemClock_Config+0x11e>
 801351c:	e7fe      	b.n	801351c <SystemClock_Config+0x11c>
  {
    Error_Handler();
  }
  /** Enable USB Voltage detector 
  */
  HAL_PWREx_EnableUSBVoltageDetector();
 801351e:	f7f4 fd41 	bl	8007fa4 <HAL_PWREx_EnableUSBVoltageDetector>
}
 8013522:	b04c      	add	sp, #304	; 0x130
 8013524:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8013528:	58024800 	.word	0x58024800
 801352c:	58000400 	.word	0x58000400
 8013530:	58024400 	.word	0x58024400
 8013534:	010f0118 	.word	0x010f0118

08013538 <HAL_ADC_ConvCpltCallback>:

/* USER CODE BEGIN 4 */
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
	//HAL_MDMA_Start_IT(&hmdma_mdma_channel40_dma1_stream0_tc_0, (uint32_t)&ADC_valuesDMA, (uint32_t)&ADC_values, 10, 1);
}
 8013538:	4770      	bx	lr
 801353a:	bf00      	nop

0801353c <HAL_ADC_ConvHalfCpltCallback>:
 801353c:	4770      	bx	lr
 801353e:	bf00      	nop

08013540 <SDRAM_Initialization_sequence>:
#define SDRAM_MODEREG_WRITEBURST_MODE_SINGLE     ((uint16_t)0x0200)

//#define SDRAM_REFRESH_COUNT                   	 ((uint32_t)956)// 7.9us in cycles of 8.333333ns + 20 cycles as recommended by datasheet page 866/3289 for STM32H743
#define SDRAM_REFRESH_COUNT                   	 ((uint32_t)0x0569)// 7.9us in cycles of 8.333333ns + 20 cycles as recommended by datasheet page 866/3289 for STM32H743
void SDRAM_Initialization_sequence(void)
{
 8013540:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
    Command.AutoRefreshNumber = 1;
    Command.ModeRegisterDefinition = 0;

    /* Send the command */
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8013544:	4c2b      	ldr	r4, [pc, #172]	; (80135f4 <SDRAM_Initialization_sequence+0xb4>)
{
 8013546:	b087      	sub	sp, #28
    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 8013548:	2501      	movs	r5, #1
    __IO uint32_t tmpmrd = 0;
 801354a:	2600      	movs	r6, #0
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 801354c:	2710      	movs	r7, #16
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 801354e:	a902      	add	r1, sp, #8
 8013550:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013554:	4620      	mov	r0, r4
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);

    /* Step 4: Configure the 1st Auto Refresh command */
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
    Command.AutoRefreshNumber = 8;
 8013556:	f04f 0808 	mov.w	r8, #8
    __IO uint32_t tmpmrd = 0;
 801355a:	9601      	str	r6, [sp, #4]
    Command.ModeRegisterDefinition = 0;
 801355c:	9605      	str	r6, [sp, #20]
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 801355e:	f04f 0903 	mov.w	r9, #3
    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 8013562:	9502      	str	r5, [sp, #8]
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 8013564:	e9cd 7503 	strd	r7, r5, [sp, #12]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8013568:	f7f8 fe70 	bl	800c24c <HAL_SDRAM_SendCommand>
    HAL_Delay(1);
 801356c:	4628      	mov	r0, r5
 801356e:	f7ed fa61 	bl	8000a34 <HAL_Delay>
    Command.CommandMode = FMC_SDRAM_CMD_PALL;
 8013572:	2302      	movs	r3, #2
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8013574:	eb0d 0108 	add.w	r1, sp, r8
 8013578:	4620      	mov	r0, r4
 801357a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    Command.CommandMode = FMC_SDRAM_CMD_PALL;
 801357e:	9302      	str	r3, [sp, #8]
    Command.ModeRegisterDefinition = 0;
 8013580:	9605      	str	r6, [sp, #20]
    Command.AutoRefreshNumber = 1;
 8013582:	e9cd 7503 	strd	r7, r5, [sp, #12]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8013586:	f7f8 fe61 	bl	800c24c <HAL_SDRAM_SendCommand>
    tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_4 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL
 801358a:	f240 2222 	movw	r2, #546	; 0x222
    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
 801358e:	2304      	movs	r3, #4
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8013590:	eb0d 0108 	add.w	r1, sp, r8
    tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_4 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL
 8013594:	9201      	str	r2, [sp, #4]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8013596:	4620      	mov	r0, r4
    Command.ModeRegisterDefinition = tmpmrd;
 8013598:	f8dd c004 	ldr.w	ip, [sp, #4]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 801359c:	f64f 72ff 	movw	r2, #65535	; 0xffff
    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
 80135a0:	9302      	str	r3, [sp, #8]
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 80135a2:	9703      	str	r7, [sp, #12]
    Command.ModeRegisterDefinition = tmpmrd;
 80135a4:	e9cd 5c04 	strd	r5, ip, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80135a8:	f7f8 fe50 	bl	800c24c <HAL_SDRAM_SendCommand>
    Command.ModeRegisterDefinition = 0;

    /* Send the command */
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80135ac:	eb0d 0108 	add.w	r1, sp, r8
 80135b0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80135b4:	4620      	mov	r0, r4
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 80135b6:	9703      	str	r7, [sp, #12]
    Command.ModeRegisterDefinition = 0;
 80135b8:	9605      	str	r6, [sp, #20]
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 80135ba:	f8cd 9008 	str.w	r9, [sp, #8]
    Command.AutoRefreshNumber = 8;
 80135be:	f8cd 8010 	str.w	r8, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80135c2:	f7f8 fe43 	bl	800c24c <HAL_SDRAM_SendCommand>

    /* Step 2: Insert 100 us minimum delay */
    /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
    HAL_Delay(1);
 80135c6:	4628      	mov	r0, r5
 80135c8:	f7ed fa34 	bl	8000a34 <HAL_Delay>
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
    Command.AutoRefreshNumber = 8;
    Command.ModeRegisterDefinition = 0;

    /* Send the command */
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80135cc:	eb0d 0108 	add.w	r1, sp, r8
 80135d0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80135d4:	4620      	mov	r0, r4
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 80135d6:	e9cd 9702 	strd	r9, r7, [sp, #8]
    Command.ModeRegisterDefinition = 0;
 80135da:	e9cd 8604 	strd	r8, r6, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80135de:	f7f8 fe35 	bl	800c24c <HAL_SDRAM_SendCommand>

    /* Step 6: Set the refresh rate counter */
    /* Set the device refresh rate */
    HAL_SDRAM_ProgramRefreshRate(&hsdram1, SDRAM_REFRESH_COUNT);
 80135e2:	f240 5169 	movw	r1, #1385	; 0x569
 80135e6:	4620      	mov	r0, r4
 80135e8:	f7f8 fe52 	bl	800c290 <HAL_SDRAM_ProgramRefreshRate>
}
 80135ec:	b007      	add	sp, #28
 80135ee:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80135f2:	bf00      	nop
 80135f4:	20001544 	.word	0x20001544

080135f8 <randomNumber>:

float randomNumber(void) {
 80135f8:	b500      	push	{lr}
 80135fa:	b083      	sub	sp, #12

	uint32_t rand;
	HAL_RNG_GenerateRandomNumber(&hrng, &rand);
 80135fc:	4807      	ldr	r0, [pc, #28]	; (801361c <randomNumber+0x24>)
 80135fe:	a901      	add	r1, sp, #4
 8013600:	f7f6 ff34 	bl	800a46c <HAL_RNG_GenerateRandomNumber>
	float num = (float)rand * INV_TWO_TO_32;
 8013604:	eddd 7a01 	vldr	s15, [sp, #4]
 8013608:	ed9f 0a05 	vldr	s0, [pc, #20]	; 8013620 <randomNumber+0x28>
 801360c:	eef8 7a67 	vcvt.f32.u32	s15, s15
	return num;
}
 8013610:	ee27 0a80 	vmul.f32	s0, s15, s0
 8013614:	b003      	add	sp, #12
 8013616:	f85d fb04 	ldr.w	pc, [sp], #4
 801361a:	bf00      	nop
 801361c:	20001c3c 	.word	0x20001c3c
 8013620:	2f80000d 	.word	0x2f80000d

08013624 <MPU_Conf>:


void MPU_Conf(void)
{
 8013624:	b510      	push	{r4, lr}
 8013626:	b084      	sub	sp, #16
  // So a buffer size for read/write of 4096 would take up 64k = 4096*8 * 2 (read and write).
  // I increased that to 256k so that there would be room for the ADC knob inputs and other peripherals that might require DMA access.
  // we have a total of 256k in SRAM1 (128k, 0x30000000-0x30020000) and SRAM2 (128k, 0x30020000-0x3004000) of D2 domain.
  // There is an SRAM3 in D2 domain as well (32k, 0x30040000-0x3004800) that is currently not mapped by the MPU (memory protection unit) controller.

  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 8013628:	2400      	movs	r4, #0
	HAL_MPU_Disable();
 801362a:	f7ee fef1 	bl	8002410 <HAL_MPU_Disable>
  MPU_InitStruct.BaseAddress = 0x30000000;
 801362e:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8013632:	f240 1201 	movw	r2, #257	; 0x101
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 8013636:	4b0d      	ldr	r3, [pc, #52]	; (801366c <MPU_Conf+0x48>)


  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;


  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8013638:	4668      	mov	r0, sp
  MPU_InitStruct.BaseAddress = 0x30000000;
 801363a:	9101      	str	r1, [sp, #4]
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 801363c:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 8013640:	e9cd 3402 	strd	r3, r4, [sp, #8]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8013644:	f7ee ff06 	bl	8002454 <HAL_MPU_ConfigRegion>
  //now set up D3 domain RAM

  MPU_InitStruct.Enable = MPU_REGION_ENABLE;

  //D3 Domain�SRAM1
  MPU_InitStruct.BaseAddress = 0x38000000;
 8013648:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 801364c:	f240 2201 	movw	r2, #513	; 0x201


  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
 8013650:	4b07      	ldr	r3, [pc, #28]	; (8013670 <MPU_Conf+0x4c>)


  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;


  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8013652:	4668      	mov	r0, sp
  MPU_InitStruct.BaseAddress = 0x38000000;
 8013654:	9101      	str	r1, [sp, #4]
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8013656:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
 801365a:	9302      	str	r3, [sp, #8]
 801365c:	9403      	str	r4, [sp, #12]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 801365e:	f7ee fef9 	bl	8002454 <HAL_MPU_ConfigRegion>
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  */



  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 8013662:	2004      	movs	r0, #4
 8013664:	f7ee fee4 	bl	8002430 <HAL_MPU_Enable>
}
 8013668:	b004      	add	sp, #16
 801366a:	bd10      	pop	{r4, pc}
 801366c:	03010011 	.word	0x03010011
 8013670:	0301000f 	.word	0x0301000f

08013674 <main>:
{
 8013674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  MPU_Conf();
 8013676:	f7ff ffd5 	bl	8013624 <MPU_Conf>
  __ASM volatile ("dsb 0xF":::"memory");
 801367a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 801367e:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 8013682:	4c7e      	ldr	r4, [pc, #504]	; (801387c <main+0x208>)
 8013684:	2500      	movs	r5, #0
 8013686:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 801368a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 801368e:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8013692:	6963      	ldr	r3, [r4, #20]
 8013694:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8013698:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 801369a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 801369e:	f3bf 8f6f 	isb	sy
  SCB_EnableDCache();
 80136a2:	f7ff fe7d 	bl	80133a0 <SCB_EnableDCache>
  HAL_Init();
 80136a6:	f7ed f981 	bl	80009ac <HAL_Init>
  __ASM volatile ("dsb 0xF":::"memory");
 80136aa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80136ae:	f3bf 8f6f 	isb	sy
    SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
 80136b2:	6963      	ldr	r3, [r4, #20]
 80136b4:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80136b8:	6163      	str	r3, [r4, #20]
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80136ba:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 80136be:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80136c2:	f3bf 8f6f 	isb	sy
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 80136c6:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 80136ca:	f3bf 8f4f 	dsb	sy
    SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
 80136ce:	6963      	ldr	r3, [r4, #20]
 80136d0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80136d4:	6163      	str	r3, [r4, #20]
 80136d6:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 80136da:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 80136de:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80136e2:	f3c3 06c9 	ubfx	r6, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 80136e6:	f3c3 334e 	ubfx	r3, r3, #13, #15
 80136ea:	07b7      	lsls	r7, r6, #30
 80136ec:	0158      	lsls	r0, r3, #5
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 80136ee:	ea00 050c 	and.w	r5, r0, ip
 80136f2:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80136f4:	4632      	mov	r2, r6
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 80136f6:	ea41 0305 	orr.w	r3, r1, r5
      } while (ways-- != 0U);
 80136fa:	3a01      	subs	r2, #1
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 80136fc:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
 8013700:	f8c4 3274 	str.w	r3, [r4, #628]	; 0x274
      } while (ways-- != 0U);
 8013704:	1c53      	adds	r3, r2, #1
 8013706:	d1f6      	bne.n	80136f6 <main+0x82>
 8013708:	3820      	subs	r0, #32
    } while(sets-- != 0U);
 801370a:	f110 0f20 	cmn.w	r0, #32
 801370e:	d1ee      	bne.n	80136ee <main+0x7a>
 8013710:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8013714:	f3bf 8f6f 	isb	sy
  SystemClock_Config();
 8013718:	f7ff fe72 	bl	8013400 <SystemClock_Config>
  MX_GPIO_Init();
 801371c:	f7ff fbc8 	bl	8012eb0 <MX_GPIO_Init>
  MX_BDMA_Init();
 8013720:	f7fd ff6c 	bl	80115fc <MX_BDMA_Init>
  MX_DMA_Init();
 8013724:	f7fe f87c 	bl	8011820 <MX_DMA_Init>
  MX_FMC_Init();
 8013728:	f7fe fc3c 	bl	8011fa4 <MX_FMC_Init>
  MX_ADC1_Init();
 801372c:	f7fd f9b2 	bl	8010a94 <MX_ADC1_Init>
  MX_I2C2_Init();
 8013730:	f7ff fcea 	bl	8013108 <MX_I2C2_Init>
  MX_SDMMC1_SD_Init();
 8013734:	f000 ff88 	bl	8014648 <MX_SDMMC1_SD_Init>
  MX_FATFS_Init();
 8013738:	f7fe fc1a 	bl	8011f70 <MX_FATFS_Init>
  MX_SAI1_Init();
 801373c:	f000 fdfc 	bl	8014338 <MX_SAI1_Init>
  MX_RNG_Init();
 8013740:	f000 fdcc 	bl	80142dc <MX_RNG_Init>
  MX_I2C4_Init();
 8013744:	f7ff fd0e 	bl	8013164 <MX_I2C4_Init>
  MX_USB_HOST_Init();
 8013748:	f00a faf4 	bl	801dd34 <MX_USB_HOST_Init>
  MX_TIM3_Init();
 801374c:	f008 fcdc 	bl	801c108 <MX_TIM3_Init>
  MX_TIM4_Init();
 8013750:	f008 fd58 	bl	801c204 <MX_TIM4_Init>
  __ASM volatile ("dsb 0xF":::"memory");
 8013754:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8013758:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 801375c:	2500      	movs	r5, #0
 801375e:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8013762:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8013766:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 801376a:	6963      	ldr	r3, [r4, #20]
 801376c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8013770:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8013772:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8013776:	f3bf 8f6f 	isb	sy
  SCB_EnableDCache();
 801377a:	f7ff fe11 	bl	80133a0 <SCB_EnableDCache>
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
 801377e:	2104      	movs	r1, #4
 8013780:	483f      	ldr	r0, [pc, #252]	; (8013880 <main+0x20c>)
 8013782:	f7f9 f8c5 	bl	800c910 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);
 8013786:	4629      	mov	r1, r5
 8013788:	483e      	ldr	r0, [pc, #248]	; (8013884 <main+0x210>)
 801378a:	f7f9 f8c1 	bl	800c910 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);
 801378e:	2104      	movs	r1, #4
 8013790:	483c      	ldr	r0, [pc, #240]	; (8013884 <main+0x210>)
 8013792:	f7f9 f8bd 	bl	800c910 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_3);
 8013796:	2108      	movs	r1, #8
 8013798:	483a      	ldr	r0, [pc, #232]	; (8013884 <main+0x210>)
 801379a:	f7f9 f8b9 	bl	800c910 <HAL_TIM_PWM_Start>
  HAL_FLASH_Unlock();
 801379e:	f7f1 fb01 	bl	8004da4 <HAL_FLASH_Unlock>
  if( EE_Init() != EE_OK)
 80137a2:	f7fe f8d1 	bl	8011948 <EE_Init>
 80137a6:	4605      	mov	r5, r0
 80137a8:	b100      	cbz	r0, 80137ac <main+0x138>
 80137aa:	e7fe      	b.n	80137aa <main+0x136>
  if((EE_ReadVariable(VirtAddVarTab[0],  &VarDataTab)) != HAL_OK) // read what the preset was before last power-off
 80137ac:	4c36      	ldr	r4, [pc, #216]	; (8013888 <main+0x214>)
 80137ae:	4937      	ldr	r1, [pc, #220]	; (801388c <main+0x218>)
 80137b0:	8820      	ldrh	r0, [r4, #0]
 80137b2:	f7fe faa1 	bl	8011cf8 <EE_ReadVariable>
 80137b6:	2800      	cmp	r0, #0
 80137b8:	d13e      	bne.n	8013838 <main+0x1c4>
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
 80137ba:	4b34      	ldr	r3, [pc, #208]	; (801388c <main+0x218>)

// helper function to initialize measuring unit (cycle counter) */
static void CycleCounterInit( void )
{
  /* Enable TRC */
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80137bc:	4a34      	ldr	r2, [pc, #208]	; (8013890 <main+0x21c>)
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
 80137be:	881b      	ldrh	r3, [r3, #0]
 80137c0:	4834      	ldr	r0, [pc, #208]	; (8013894 <main+0x220>)
 80137c2:	2b12      	cmp	r3, #18

  /* Unlock DWT registers */
  if ((*(uint32_t*)0xE0001FB4) & 1)
 80137c4:	4934      	ldr	r1, [pc, #208]	; (8013898 <main+0x224>)
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
 80137c6:	bf28      	it	cs
 80137c8:	2300      	movcs	r3, #0
 80137ca:	7003      	strb	r3, [r0, #0]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80137cc:	68d3      	ldr	r3, [r2, #12]
  if ((*(uint32_t*)0xE0001FB4) & 1)
 80137ce:	6809      	ldr	r1, [r1, #0]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80137d0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80137d4:	60d3      	str	r3, [r2, #12]
  if ((*(uint32_t*)0xE0001FB4) & 1)
 80137d6:	07cb      	lsls	r3, r1, #31
 80137d8:	d502      	bpl.n	80137e0 <main+0x16c>
    *(uint32_t*)0xE0001FB0 = 0xC5ACCE55;
 80137da:	4b30      	ldr	r3, [pc, #192]	; (801389c <main+0x228>)
 80137dc:	4a30      	ldr	r2, [pc, #192]	; (80138a0 <main+0x22c>)
 80137de:	601a      	str	r2, [r3, #0]

  /* clear the cycle counter */
  DWT->CYCCNT = 0;
 80137e0:	4830      	ldr	r0, [pc, #192]	; (80138a4 <main+0x230>)
 80137e2:	2500      	movs	r5, #0

  /* start the cycle counter */
  DWT->CTRL = 0x40000001;
 80137e4:	4c30      	ldr	r4, [pc, #192]	; (80138a8 <main+0x234>)
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
 80137e6:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  DWT->CYCCNT = 0;
 80137ea:	6045      	str	r5, [r0, #4]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
 80137ec:	462a      	mov	r2, r5
  DWT->CTRL = 0x40000001;
 80137ee:	6004      	str	r4, [r0, #0]

  for (int i = 0; i < 4; i++)
  {
	  cycleCountAverages[i][0] = 0.0f;
 80137f0:	2400      	movs	r4, #0
 80137f2:	4b2e      	ldr	r3, [pc, #184]	; (80138ac <main+0x238>)
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
 80137f4:	482e      	ldr	r0, [pc, #184]	; (80138b0 <main+0x23c>)
	  cycleCountAverages[i][0] = 0.0f;
 80137f6:	601c      	str	r4, [r3, #0]
	  cycleCountAverages[i][1] = 0.0f;
 80137f8:	605c      	str	r4, [r3, #4]
	  cycleCountAverages[i][2] = 0.0f;
 80137fa:	609c      	str	r4, [r3, #8]
	  cycleCountAverages[i][0] = 0.0f;
 80137fc:	60dc      	str	r4, [r3, #12]
	  cycleCountAverages[i][1] = 0.0f;
 80137fe:	611c      	str	r4, [r3, #16]
	  cycleCountAverages[i][2] = 0.0f;
 8013800:	615c      	str	r4, [r3, #20]
	  cycleCountAverages[i][0] = 0.0f;
 8013802:	619c      	str	r4, [r3, #24]
	  cycleCountAverages[i][1] = 0.0f;
 8013804:	61dc      	str	r4, [r3, #28]
	  cycleCountAverages[i][2] = 0.0f;
 8013806:	621c      	str	r4, [r3, #32]
	  cycleCountAverages[i][0] = 0.0f;
 8013808:	625c      	str	r4, [r3, #36]	; 0x24
	  cycleCountAverages[i][1] = 0.0f;
 801380a:	629c      	str	r4, [r3, #40]	; 0x28
	  cycleCountAverages[i][2] = 0.0f;
 801380c:	62dc      	str	r4, [r3, #44]	; 0x2c
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
 801380e:	f7f2 f811 	bl	8005834 <HAL_GPIO_WritePin>
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8013812:	eef1 3a10 	vmrs	r3, fpscr
  tempFPURegisterVal |= (1<<24); // set the FTZ (flush-to-zero) bit in the FPU control register  // this makes checking for denormals not necessary as they are automatically set to zero by the hardware
 8013816:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 801381a:	eee1 3a10 	vmsr	fpscr, r3
  HAL_ADCEx_Calibration_Start(&hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED);
 801381e:	f240 72ff 	movw	r2, #2047	; 0x7ff
 8013822:	4629      	mov	r1, r5
 8013824:	4823      	ldr	r0, [pc, #140]	; (80138b4 <main+0x240>)
 8013826:	f7ee fc05 	bl	8002034 <HAL_ADCEx_Calibration_Start>
  if (HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&ADC_values, NUM_ADC_CHANNELS) != HAL_OK)
 801382a:	2206      	movs	r2, #6
 801382c:	4922      	ldr	r1, [pc, #136]	; (80138b8 <main+0x244>)
 801382e:	4821      	ldr	r0, [pc, #132]	; (80138b4 <main+0x240>)
 8013830:	f7ed f932 	bl	8000a98 <HAL_ADC_Start_DMA>
 8013834:	b138      	cbz	r0, 8013846 <main+0x1d2>
 8013836:	e7fe      	b.n	8013836 <main+0x1c2>
	  if((EE_WriteVariable(VirtAddVarTab[0],  0)) != HAL_OK)
 8013838:	4629      	mov	r1, r5
 801383a:	8820      	ldrh	r0, [r4, #0]
 801383c:	f7fe fa98 	bl	8011d70 <EE_WriteVariable>
 8013840:	2800      	cmp	r0, #0
 8013842:	d0ba      	beq.n	80137ba <main+0x146>
 8013844:	e7fe      	b.n	8013844 <main+0x1d0>
 8013846:	4c1d      	ldr	r4, [pc, #116]	; (80138bc <main+0x248>)
  HAL_Delay(10);
 8013848:	200a      	movs	r0, #10
 801384a:	f7ed f8f3 	bl	8000a34 <HAL_Delay>
  OLED_init(&hi2c4);
 801384e:	4620      	mov	r0, r4
 8013850:	f000 f95c 	bl	8013b0c <OLED_init>
  SDRAM_Initialization_sequence();
 8013854:	f7ff fe74 	bl	8013540 <SDRAM_Initialization_sequence>
  audioInit(&hi2c2, &hsai_BlockA1, &hsai_BlockB1);
 8013858:	4a19      	ldr	r2, [pc, #100]	; (80138c0 <main+0x24c>)
 801385a:	491a      	ldr	r1, [pc, #104]	; (80138c4 <main+0x250>)
 801385c:	481a      	ldr	r0, [pc, #104]	; (80138c8 <main+0x254>)
 801385e:	f7fd fdf3 	bl	8011448 <audioInit>
  OLED_writePreset();
 8013862:	f000 f8d7 	bl	8013a14 <OLED_writePreset>
    MX_USB_HOST_Process();
 8013866:	f00a fa9b 	bl	801dda0 <MX_USB_HOST_Process>
    OLED_process(); // process what to write to the screen but don't actually draw
 801386a:	f000 fcc3 	bl	80141f4 <OLED_process>
 	if (hi2c4.State == HAL_I2C_STATE_READY)
 801386e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8013872:	2b20      	cmp	r3, #32
 8013874:	d1f7      	bne.n	8013866 <main+0x1f2>
	  OLED_draw();
 8013876:	f000 fa95 	bl	8013da4 <OLED_draw>
 801387a:	e7f4      	b.n	8013866 <main+0x1f2>
 801387c:	e000ed00 	.word	0xe000ed00
 8013880:	200186c8 	.word	0x200186c8
 8013884:	20018688 	.word	0x20018688
 8013888:	2000001c 	.word	0x2000001c
 801388c:	20000518 	.word	0x20000518
 8013890:	e000edf0 	.word	0xe000edf0
 8013894:	20000669 	.word	0x20000669
 8013898:	e0001fb4 	.word	0xe0001fb4
 801389c:	e0001fb0 	.word	0xe0001fb0
 80138a0:	c5acce55 	.word	0xc5acce55
 80138a4:	e0001000 	.word	0xe0001000
 80138a8:	40000001 	.word	0x40000001
 80138ac:	20001b08 	.word	0x20001b08
 80138b0:	58020800 	.word	0x58020800
 80138b4:	200006b8 	.word	0x200006b8
 80138b8:	30001080 	.word	0x30001080
 80138bc:	200015f0 	.word	0x200015f0
 80138c0:	20001c50 	.word	0x20001c50
 80138c4:	20001dd8 	.word	0x20001dd8
 80138c8:	2000163c 	.word	0x2000163c

080138cc <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80138cc:	e7fe      	b.n	80138cc <Error_Handler>
 80138ce:	bf00      	nop

080138d0 <assert_failed>:
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
 80138d0:	4770      	bx	lr
 80138d2:	bf00      	nop

080138d4 <setLED_Edit>:
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
}

void setLED_Edit(int onOff)
{
	if (onOff)
 80138d4:	b920      	cbnz	r0, 80138e0 <setLED_Edit+0xc>
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_RESET);
 80138d6:	4602      	mov	r2, r0
 80138d8:	2180      	movs	r1, #128	; 0x80
 80138da:	4804      	ldr	r0, [pc, #16]	; (80138ec <setLED_Edit+0x18>)
 80138dc:	f7f1 bfaa 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
 80138e0:	2201      	movs	r2, #1
 80138e2:	2180      	movs	r1, #128	; 0x80
 80138e4:	4801      	ldr	r0, [pc, #4]	; (80138ec <setLED_Edit+0x18>)
 80138e6:	f7f1 bfa5 	b.w	8005834 <HAL_GPIO_WritePin>
 80138ea:	bf00      	nop
 80138ec:	58020800 	.word	0x58020800

080138f0 <setLED_USB>:
}


void setLED_USB(int onOff)
{
	if (onOff)
 80138f0:	b920      	cbnz	r0, 80138fc <setLED_USB+0xc>
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);
 80138f2:	4602      	mov	r2, r0
 80138f4:	2140      	movs	r1, #64	; 0x40
 80138f6:	4804      	ldr	r0, [pc, #16]	; (8013908 <setLED_USB+0x18>)
 80138f8:	f7f1 bf9c 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
 80138fc:	2201      	movs	r2, #1
 80138fe:	2140      	movs	r1, #64	; 0x40
 8013900:	4801      	ldr	r0, [pc, #4]	; (8013908 <setLED_USB+0x18>)
 8013902:	f7f1 bf97 	b.w	8005834 <HAL_GPIO_WritePin>
 8013906:	bf00      	nop
 8013908:	58021800 	.word	0x58021800

0801390c <setLED_1>:
}


void setLED_1(int onOff)
{
	if (onOff)
 801390c:	b928      	cbnz	r0, 801391a <setLED_1+0xe>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET);
 801390e:	4602      	mov	r2, r0
 8013910:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8013914:	4804      	ldr	r0, [pc, #16]	; (8013928 <setLED_1+0x1c>)
 8013916:	f7f1 bf8d 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
 801391a:	2201      	movs	r2, #1
 801391c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8013920:	4801      	ldr	r0, [pc, #4]	; (8013928 <setLED_1+0x1c>)
 8013922:	f7f1 bf87 	b.w	8005834 <HAL_GPIO_WritePin>
 8013926:	bf00      	nop
 8013928:	58020000 	.word	0x58020000

0801392c <setLED_2>:
	}
}

void setLED_2(int onOff)
{
	if (onOff)
 801392c:	b928      	cbnz	r0, 801393a <setLED_2+0xe>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
 801392e:	4602      	mov	r2, r0
 8013930:	f44f 7180 	mov.w	r1, #256	; 0x100
 8013934:	4804      	ldr	r0, [pc, #16]	; (8013948 <setLED_2+0x1c>)
 8013936:	f7f1 bf7d 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
 801393a:	2201      	movs	r2, #1
 801393c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8013940:	4801      	ldr	r0, [pc, #4]	; (8013948 <setLED_2+0x1c>)
 8013942:	f7f1 bf77 	b.w	8005834 <HAL_GPIO_WritePin>
 8013946:	bf00      	nop
 8013948:	58020000 	.word	0x58020000

0801394c <setLED_A>:
}


void setLED_A(int onOff)
{
	if (onOff)
 801394c:	b920      	cbnz	r0, 8013958 <setLED_A+0xc>
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_RESET);
 801394e:	4602      	mov	r2, r0
 8013950:	2140      	movs	r1, #64	; 0x40
 8013952:	4804      	ldr	r0, [pc, #16]	; (8013964 <setLED_A+0x18>)
 8013954:	f7f1 bf6e 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
 8013958:	2201      	movs	r2, #1
 801395a:	2140      	movs	r1, #64	; 0x40
 801395c:	4801      	ldr	r0, [pc, #4]	; (8013964 <setLED_A+0x18>)
 801395e:	f7f1 bf69 	b.w	8005834 <HAL_GPIO_WritePin>
 8013962:	bf00      	nop
 8013964:	58020800 	.word	0x58020800

08013968 <setLED_B>:
	}
}

void setLED_B(int onOff)
{
	if (onOff)
 8013968:	b920      	cbnz	r0, 8013974 <setLED_B+0xc>
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_RESET);
 801396a:	4602      	mov	r2, r0
 801396c:	2180      	movs	r1, #128	; 0x80
 801396e:	4804      	ldr	r0, [pc, #16]	; (8013980 <setLED_B+0x18>)
 8013970:	f7f1 bf60 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
 8013974:	2201      	movs	r2, #1
 8013976:	2180      	movs	r1, #128	; 0x80
 8013978:	4801      	ldr	r0, [pc, #4]	; (8013980 <setLED_B+0x18>)
 801397a:	f7f1 bf5b 	b.w	8005834 <HAL_GPIO_WritePin>
 801397e:	bf00      	nop
 8013980:	58021800 	.word	0x58021800

08013984 <setLED_C>:
	}
}

void setLED_C(int onOff)
{
	if (onOff)
 8013984:	b928      	cbnz	r0, 8013992 <setLED_C+0xe>
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_RESET);
 8013986:	4602      	mov	r2, r0
 8013988:	f44f 6180 	mov.w	r1, #1024	; 0x400
 801398c:	4804      	ldr	r0, [pc, #16]	; (80139a0 <setLED_C+0x1c>)
 801398e:	f7f1 bf51 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
 8013992:	2201      	movs	r2, #1
 8013994:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8013998:	4801      	ldr	r0, [pc, #4]	; (80139a0 <setLED_C+0x1c>)
 801399a:	f7f1 bf4b 	b.w	8005834 <HAL_GPIO_WritePin>
 801399e:	bf00      	nop
 80139a0:	58021800 	.word	0x58021800

080139a4 <setLED_leftout_clip>:
	}
}

void setLED_leftout_clip(int onOff)
{
	if (onOff)
 80139a4:	b920      	cbnz	r0, 80139b0 <setLED_leftout_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 80139a6:	4602      	mov	r2, r0
 80139a8:	2110      	movs	r1, #16
 80139aa:	4804      	ldr	r0, [pc, #16]	; (80139bc <setLED_leftout_clip+0x18>)
 80139ac:	f7f1 bf42 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
 80139b0:	2201      	movs	r2, #1
 80139b2:	2110      	movs	r1, #16
 80139b4:	4801      	ldr	r0, [pc, #4]	; (80139bc <setLED_leftout_clip+0x18>)
 80139b6:	f7f1 bf3d 	b.w	8005834 <HAL_GPIO_WritePin>
 80139ba:	bf00      	nop
 80139bc:	58020000 	.word	0x58020000

080139c0 <setLED_rightout_clip>:
	}
}

void setLED_rightout_clip(int onOff)
{
	if (onOff)
 80139c0:	b920      	cbnz	r0, 80139cc <setLED_rightout_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_RESET);
 80139c2:	4602      	mov	r2, r0
 80139c4:	2140      	movs	r1, #64	; 0x40
 80139c6:	4804      	ldr	r0, [pc, #16]	; (80139d8 <setLED_rightout_clip+0x18>)
 80139c8:	f7f1 bf34 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
 80139cc:	2201      	movs	r2, #1
 80139ce:	2140      	movs	r1, #64	; 0x40
 80139d0:	4801      	ldr	r0, [pc, #4]	; (80139d8 <setLED_rightout_clip+0x18>)
 80139d2:	f7f1 bf2f 	b.w	8005834 <HAL_GPIO_WritePin>
 80139d6:	bf00      	nop
 80139d8:	58020000 	.word	0x58020000

080139dc <setLED_leftin_clip>:
	}
}

void setLED_leftin_clip(int onOff)
{
	if (onOff)
 80139dc:	b920      	cbnz	r0, 80139e8 <setLED_leftin_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_RESET);
 80139de:	4602      	mov	r2, r0
 80139e0:	2110      	movs	r1, #16
 80139e2:	4804      	ldr	r0, [pc, #16]	; (80139f4 <setLED_leftin_clip+0x18>)
 80139e4:	f7f1 bf26 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
 80139e8:	2201      	movs	r2, #1
 80139ea:	2110      	movs	r1, #16
 80139ec:	4801      	ldr	r0, [pc, #4]	; (80139f4 <setLED_leftin_clip+0x18>)
 80139ee:	f7f1 bf21 	b.w	8005834 <HAL_GPIO_WritePin>
 80139f2:	bf00      	nop
 80139f4:	58020800 	.word	0x58020800

080139f8 <setLED_rightin_clip>:
	}
}

void setLED_rightin_clip(int onOff)
{
	if (onOff)
 80139f8:	b920      	cbnz	r0, 8013a04 <setLED_rightin_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
 80139fa:	4602      	mov	r2, r0
 80139fc:	2101      	movs	r1, #1
 80139fe:	4804      	ldr	r0, [pc, #16]	; (8013a10 <setLED_rightin_clip+0x18>)
 8013a00:	f7f1 bf18 	b.w	8005834 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
 8013a04:	2201      	movs	r2, #1
 8013a06:	4802      	ldr	r0, [pc, #8]	; (8013a10 <setLED_rightin_clip+0x18>)
 8013a08:	4611      	mov	r1, r2
 8013a0a:	f7f1 bf13 	b.w	8005834 <HAL_GPIO_WritePin>
 8013a0e:	bf00      	nop
 8013a10:	58020400 	.word	0x58020400

08013a14 <OLED_writePreset>:
	}
//	OLED_draw();
}

void OLED_writePreset()
{
 8013a14:	b5f0      	push	{r4, r5, r6, r7, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
 8013a16:	4936      	ldr	r1, [pc, #216]	; (8013af0 <OLED_writePreset+0xdc>)
{
 8013a18:	b089      	sub	sp, #36	; 0x24
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
 8013a1a:	4836      	ldr	r0, [pc, #216]	; (8013af4 <OLED_writePreset+0xe0>)
}


void OLEDclear()
{
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8013a1c:	2600      	movs	r6, #0
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
 8013a1e:	f7ff f8d1 	bl	8012bc4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8013a22:	2320      	movs	r3, #32
	itoa((currentPreset+1), tempString, 10);
 8013a24:	4f34      	ldr	r7, [pc, #208]	; (8013af8 <OLED_writePreset+0xe4>)
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8013a26:	4632      	mov	r2, r6
 8013a28:	4631      	mov	r1, r6
 8013a2a:	9300      	str	r3, [sp, #0]
 8013a2c:	4831      	ldr	r0, [pc, #196]	; (8013af4 <OLED_writePreset+0xe0>)
 8013a2e:	2380      	movs	r3, #128	; 0x80
 8013a30:	9601      	str	r6, [sp, #4]
	itoa((currentPreset+1), tempString, 10);
 8013a32:	ac02      	add	r4, sp, #8
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8013a34:	f7fe fcba 	bl	80123ac <GFXfillRect>
	itoa((currentPreset+1), tempString, 10);
 8013a38:	7838      	ldrb	r0, [r7, #0]
 8013a3a:	4621      	mov	r1, r4
 8013a3c:	220a      	movs	r2, #10
 8013a3e:	3001      	adds	r0, #1
 8013a40:	f013 fac0 	bl	8026fc4 <itoa>
	strcat(tempString, ":");
 8013a44:	4620      	mov	r0, r4
 8013a46:	f7ec fc47 	bl	80002d8 <strlen>
 8013a4a:	4a2c      	ldr	r2, [pc, #176]	; (8013afc <OLED_writePreset+0xe8>)
 8013a4c:	4603      	mov	r3, r0
	strcat(tempString, modeNames[currentPreset]);
 8013a4e:	783d      	ldrb	r5, [r7, #0]
	strcat(tempString, ":");
 8013a50:	8812      	ldrh	r2, [r2, #0]
 8013a52:	3001      	adds	r0, #1
	strcat(tempString, modeNames[currentPreset]);
 8013a54:	492a      	ldr	r1, [pc, #168]	; (8013b00 <OLED_writePreset+0xec>)
	strcat(tempString, ":");
 8013a56:	52e2      	strh	r2, [r4, r3]
	strcat(tempString, modeNames[currentPreset]);
 8013a58:	4420      	add	r0, r4
 8013a5a:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
 8013a5e:	f013 fac6 	bl	8026fee <stpcpy>
	int myLength = strlen(tempString);
 8013a62:	1b05      	subs	r5, r0, r4

void OLEDwriteString(const char* myCharArray, int arrayLength, int startCursor, OLEDLine line)
{
	int cursorX = startCursor;
	int cursorY = 12 + (16 * (line%2));
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013a64:	4631      	mov	r1, r6
 8013a66:	220c      	movs	r2, #12
 8013a68:	4822      	ldr	r0, [pc, #136]	; (8013af4 <OLED_writePreset+0xe0>)
 8013a6a:	f7ff f899 	bl	8012ba0 <GFXsetCursor>

	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013a6e:	2010      	movs	r0, #16
 8013a70:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8013a74:	9601      	str	r6, [sp, #4]
 8013a76:	9000      	str	r0, [sp, #0]
 8013a78:	4632      	mov	r2, r6
 8013a7a:	009b      	lsls	r3, r3, #2
 8013a7c:	4631      	mov	r1, r6
 8013a7e:	481d      	ldr	r0, [pc, #116]	; (8013af4 <OLED_writePreset+0xe0>)
 8013a80:	b21b      	sxth	r3, r3
 8013a82:	f7fe fc93 	bl	80123ac <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8013a86:	b145      	cbz	r5, 8013a9a <OLED_writePreset+0x86>
	{
		GFXwrite(&theGFX, myCharArray[i]);
 8013a88:	4e1a      	ldr	r6, [pc, #104]	; (8013af4 <OLED_writePreset+0xe0>)
 8013a8a:	4425      	add	r5, r4
 8013a8c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8013a90:	4630      	mov	r0, r6
 8013a92:	f7fe ffd1 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013a96:	42a5      	cmp	r5, r4
 8013a98:	d1f8      	bne.n	8013a8c <OLED_writePreset+0x78>
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8013a9a:	491a      	ldr	r1, [pc, #104]	; (8013b04 <OLED_writePreset+0xf0>)
 8013a9c:	4815      	ldr	r0, [pc, #84]	; (8013af4 <OLED_writePreset+0xe0>)
 8013a9e:	f7ff f891 	bl	8012bc4 <GFXsetFont>
	OLEDwriteString(modeNamesDetails[currentPreset], strlen(modeNamesDetails[currentPreset]), 0, SecondLine);
 8013aa2:	783a      	ldrb	r2, [r7, #0]
 8013aa4:	4b18      	ldr	r3, [pc, #96]	; (8013b08 <OLED_writePreset+0xf4>)
 8013aa6:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
 8013aaa:	4620      	mov	r0, r4
 8013aac:	f7ec fc14 	bl	80002d8 <strlen>
 8013ab0:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013ab2:	221c      	movs	r2, #28
 8013ab4:	2100      	movs	r1, #0
 8013ab6:	480f      	ldr	r0, [pc, #60]	; (8013af4 <OLED_writePreset+0xe0>)
 8013ab8:	f7ff f872 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013abc:	2220      	movs	r2, #32
 8013abe:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8013ac2:	2100      	movs	r1, #0
 8013ac4:	9200      	str	r2, [sp, #0]
 8013ac6:	2210      	movs	r2, #16
 8013ac8:	009b      	lsls	r3, r3, #2
 8013aca:	9101      	str	r1, [sp, #4]
 8013acc:	4809      	ldr	r0, [pc, #36]	; (8013af4 <OLED_writePreset+0xe0>)
 8013ace:	b21b      	sxth	r3, r3
 8013ad0:	f7fe fc6c 	bl	80123ac <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8013ad4:	b14d      	cbz	r5, 8013aea <OLED_writePreset+0xd6>
 8013ad6:	3c01      	subs	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
 8013ad8:	4e06      	ldr	r6, [pc, #24]	; (8013af4 <OLED_writePreset+0xe0>)
 8013ada:	4425      	add	r5, r4
 8013adc:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8013ae0:	4630      	mov	r0, r6
 8013ae2:	f7fe ffa9 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013ae6:	42a5      	cmp	r5, r4
 8013ae8:	d1f8      	bne.n	8013adc <OLED_writePreset+0xc8>
}
 8013aea:	b009      	add	sp, #36	; 0x24
 8013aec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013aee:	bf00      	nop
 8013af0:	08029b04 	.word	0x08029b04
 8013af4:	20001c18 	.word	0x20001c18
 8013af8:	20000669 	.word	0x20000669
 8013afc:	0802a19c 	.word	0x0802a19c
 8013b00:	20018758 	.word	0x20018758
 8013b04:	08029550 	.word	0x08029550
 8013b08:	20018938 	.word	0x20018938

08013b0c <OLED_init>:
{
 8013b0c:	b530      	push	{r4, r5, lr}
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
 8013b0e:	2278      	movs	r2, #120	; 0x78
{
 8013b10:	b083      	sub	sp, #12
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
 8013b12:	2102      	movs	r1, #2
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
 8013b14:	4d28      	ldr	r5, [pc, #160]	; (8013bb8 <OLED_init+0xac>)
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
 8013b16:	f007 ff9b 	bl	801ba50 <ssd1306_begin>
 8013b1a:	f44f 7200 	mov.w	r2, #512	; 0x200
 8013b1e:	2100      	movs	r1, #0
 8013b20:	4826      	ldr	r0, [pc, #152]	; (8013bbc <OLED_init+0xb0>)
 8013b22:	f013 fa5c 	bl	8026fde <memset>
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
 8013b26:	4b26      	ldr	r3, [pc, #152]	; (8013bc0 <OLED_init+0xb4>)
 8013b28:	4926      	ldr	r1, [pc, #152]	; (8013bc4 <OLED_init+0xb8>)
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
 8013b2a:	4a27      	ldr	r2, [pc, #156]	; (8013bc8 <OLED_init+0xbc>)
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
 8013b2c:	6019      	str	r1, [r3, #0]
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
 8013b2e:	605a      	str	r2, [r3, #4]
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
 8013b30:	4826      	ldr	r0, [pc, #152]	; (8013bcc <OLED_init+0xc0>)
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
 8013b32:	4927      	ldr	r1, [pc, #156]	; (8013bd0 <OLED_init+0xc4>)
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
 8013b34:	4a27      	ldr	r2, [pc, #156]	; (8013bd4 <OLED_init+0xc8>)
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
 8013b36:	609d      	str	r5, [r3, #8]
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
 8013b38:	60d8      	str	r0, [r3, #12]
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
 8013b3a:	6119      	str	r1, [r3, #16]
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
 8013b3c:	615a      	str	r2, [r3, #20]
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
 8013b3e:	4d26      	ldr	r5, [pc, #152]	; (8013bd8 <OLED_init+0xcc>)
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
 8013b40:	4826      	ldr	r0, [pc, #152]	; (8013bdc <OLED_init+0xd0>)
	buttonActionFunctions[Distortion] = UIDistortionButtons;
 8013b42:	4927      	ldr	r1, [pc, #156]	; (8013be0 <OLED_init+0xd4>)
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
 8013b44:	4a27      	ldr	r2, [pc, #156]	; (8013be4 <OLED_init+0xd8>)
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
 8013b46:	619d      	str	r5, [r3, #24]
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
 8013b48:	61d8      	str	r0, [r3, #28]
	buttonActionFunctions[Distortion] = UIDistortionButtons;
 8013b4a:	6219      	str	r1, [r3, #32]
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
 8013b4c:	625a      	str	r2, [r3, #36]	; 0x24
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
 8013b4e:	4d26      	ldr	r5, [pc, #152]	; (8013be8 <OLED_init+0xdc>)
	buttonActionFunctions[Delay] = UIDelayButtons;
 8013b50:	4826      	ldr	r0, [pc, #152]	; (8013bec <OLED_init+0xe0>)
	buttonActionFunctions[Reverb] = UIReverbButtons;
 8013b52:	4927      	ldr	r1, [pc, #156]	; (8013bf0 <OLED_init+0xe4>)
	buttonActionFunctions[Reverb2] = UIReverb2Buttons;
 8013b54:	4a27      	ldr	r2, [pc, #156]	; (8013bf4 <OLED_init+0xe8>)
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
 8013b56:	629d      	str	r5, [r3, #40]	; 0x28
	buttonActionFunctions[Delay] = UIDelayButtons;
 8013b58:	62d8      	str	r0, [r3, #44]	; 0x2c
	buttonActionFunctions[Reverb] = UIReverbButtons;
 8013b5a:	6319      	str	r1, [r3, #48]	; 0x30
	buttonActionFunctions[Reverb2] = UIReverb2Buttons;
 8013b5c:	635a      	str	r2, [r3, #52]	; 0x34
	  GFXinit(&theGFX, 128, 32);
 8013b5e:	4c26      	ldr	r4, [pc, #152]	; (8013bf8 <OLED_init+0xec>)
	buttonActionFunctions[LivingStringSynth] = UILivingStringSynthButtons;
 8013b60:	4826      	ldr	r0, [pc, #152]	; (8013bfc <OLED_init+0xf0>)
	buttonActionFunctions[ClassicSynth] = UIClassicSynthButtons;
 8013b62:	4927      	ldr	r1, [pc, #156]	; (8013c00 <OLED_init+0xf4>)
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
 8013b64:	4a27      	ldr	r2, [pc, #156]	; (8013c04 <OLED_init+0xf8>)
	buttonActionFunctions[LivingString] = UILivingStringButtons;
 8013b66:	4d28      	ldr	r5, [pc, #160]	; (8013c08 <OLED_init+0xfc>)
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
 8013b68:	e9c3 1210 	strd	r1, r2, [r3, #64]	; 0x40
	buttonActionFunctions[LivingStringSynth] = UILivingStringSynthButtons;
 8013b6c:	e9c3 500e 	strd	r5, r0, [r3, #56]	; 0x38
	  initModeNames();
 8013b70:	f008 fc24 	bl	801c3bc <initModeNames>
	  GFXinit(&theGFX, 128, 32);
 8013b74:	4620      	mov	r0, r4
 8013b76:	2220      	movs	r2, #32
 8013b78:	2180      	movs	r1, #128	; 0x80
 8013b7a:	f7fe fb0f 	bl	801219c <GFXinit>
	  GFXsetFont(&theGFX, &EuphemiaCAS8pt7b); //this one is elegant but definitely not monospaced can fit 9 Ms
 8013b7e:	4620      	mov	r0, r4
 8013b80:	4922      	ldr	r1, [pc, #136]	; (8013c0c <OLED_init+0x100>)
 8013b82:	f7ff f81f 	bl	8012bc4 <GFXsetFont>
	  GFXsetTextColor(&theGFX, 1, 0);
 8013b86:	4620      	mov	r0, r4
 8013b88:	2200      	movs	r2, #0
 8013b8a:	2101      	movs	r1, #1
 8013b8c:	f7ff f816 	bl	8012bbc <GFXsetTextColor>
	  GFXsetTextSize(&theGFX, 1);
 8013b90:	4620      	mov	r0, r4
 8013b92:	2101      	movs	r1, #1
 8013b94:	f7ff f80c 	bl	8012bb0 <GFXsetTextSize>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8013b98:	2200      	movs	r2, #0
 8013b9a:	2320      	movs	r3, #32
 8013b9c:	4620      	mov	r0, r4
 8013b9e:	4611      	mov	r1, r2
 8013ba0:	9201      	str	r2, [sp, #4]
 8013ba2:	9300      	str	r3, [sp, #0]
 8013ba4:	2380      	movs	r3, #128	; 0x80
 8013ba6:	f7fe fc01 	bl	80123ac <GFXfillRect>
	  OLED_writePreset();
 8013baa:	f7ff ff33 	bl	8013a14 <OLED_writePreset>
}
 8013bae:	b003      	add	sp, #12
 8013bb0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	ssd1306_display_full_buffer();
 8013bb4:	f008 b8aa 	b.w	801bd0c <ssd1306_display_full_buffer>
 8013bb8:	0801d709 	.word	0x0801d709
 8013bbc:	2001847c 	.word	0x2001847c
 8013bc0:	200190c0 	.word	0x200190c0
 8013bc4:	0801d601 	.word	0x0801d601
 8013bc8:	0801d685 	.word	0x0801d685
 8013bcc:	0801d711 	.word	0x0801d711
 8013bd0:	0801d76d 	.word	0x0801d76d
 8013bd4:	0801d775 	.word	0x0801d775
 8013bd8:	0801d865 	.word	0x0801d865
 8013bdc:	0801d8f9 	.word	0x0801d8f9
 8013be0:	0801d97d 	.word	0x0801d97d
 8013be4:	0801d9b5 	.word	0x0801d9b5
 8013be8:	0801d9ed 	.word	0x0801d9ed
 8013bec:	0801da25 	.word	0x0801da25
 8013bf0:	0801da81 	.word	0x0801da81
 8013bf4:	0801dadd 	.word	0x0801dadd
 8013bf8:	20001c18 	.word	0x20001c18
 8013bfc:	0801db99 	.word	0x0801db99
 8013c00:	0801dc1d 	.word	0x0801dc1d
 8013c04:	0801dc69 	.word	0x0801dc69
 8013c08:	0801db15 	.word	0x0801db15
 8013c0c:	08029b04 	.word	0x08029b04

08013c10 <OLED_writeEditScreen>:
{
 8013c10:	b570      	push	{r4, r5, r6, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8013c12:	4921      	ldr	r1, [pc, #132]	; (8013c98 <OLED_writeEditScreen+0x88>)
{
 8013c14:	b082      	sub	sp, #8
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8013c16:	4821      	ldr	r0, [pc, #132]	; (8013c9c <OLED_writeEditScreen+0x8c>)
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8013c18:	2500      	movs	r5, #0
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8013c1a:	f7fe ffd3 	bl	8012bc4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8013c1e:	2320      	movs	r3, #32
 8013c20:	462a      	mov	r2, r5
 8013c22:	4629      	mov	r1, r5
 8013c24:	9501      	str	r5, [sp, #4]
 8013c26:	9300      	str	r3, [sp, #0]
 8013c28:	2380      	movs	r3, #128	; 0x80
 8013c2a:	481c      	ldr	r0, [pc, #112]	; (8013c9c <OLED_writeEditScreen+0x8c>)
 8013c2c:	f7fe fbbe 	bl	80123ac <GFXfillRect>
 8013c30:	4c1b      	ldr	r4, [pc, #108]	; (8013ca0 <OLED_writeEditScreen+0x90>)
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013c32:	4629      	mov	r1, r5
 8013c34:	220c      	movs	r2, #12
 8013c36:	4819      	ldr	r0, [pc, #100]	; (8013c9c <OLED_writeEditScreen+0x8c>)
 8013c38:	f104 060f 	add.w	r6, r4, #15
 8013c3c:	f7fe ffb0 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013c40:	2310      	movs	r3, #16
 8013c42:	9501      	str	r5, [sp, #4]
 8013c44:	462a      	mov	r2, r5
 8013c46:	4629      	mov	r1, r5
		GFXwrite(&theGFX, myCharArray[i]);
 8013c48:	4d14      	ldr	r5, [pc, #80]	; (8013c9c <OLED_writeEditScreen+0x8c>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013c4a:	9300      	str	r3, [sp, #0]
 8013c4c:	23b4      	movs	r3, #180	; 0xb4
 8013c4e:	4813      	ldr	r0, [pc, #76]	; (8013c9c <OLED_writeEditScreen+0x8c>)
 8013c50:	f7fe fbac 	bl	80123ac <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
 8013c54:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8013c58:	4628      	mov	r0, r5
 8013c5a:	f7fe feed 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013c5e:	42a6      	cmp	r6, r4
 8013c60:	d1f8      	bne.n	8013c54 <OLED_writeEditScreen+0x44>
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013c62:	221c      	movs	r2, #28
 8013c64:	2100      	movs	r1, #0
 8013c66:	480d      	ldr	r0, [pc, #52]	; (8013c9c <OLED_writeEditScreen+0x8c>)
 8013c68:	4c0e      	ldr	r4, [pc, #56]	; (8013ca4 <OLED_writeEditScreen+0x94>)
 8013c6a:	f7fe ff99 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013c6e:	2100      	movs	r1, #0
 8013c70:	2220      	movs	r2, #32
 8013c72:	f104 0610 	add.w	r6, r4, #16
		GFXwrite(&theGFX, myCharArray[i]);
 8013c76:	4d09      	ldr	r5, [pc, #36]	; (8013c9c <OLED_writeEditScreen+0x8c>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013c78:	23c0      	movs	r3, #192	; 0xc0
 8013c7a:	4808      	ldr	r0, [pc, #32]	; (8013c9c <OLED_writeEditScreen+0x8c>)
 8013c7c:	e9cd 2100 	strd	r2, r1, [sp]
 8013c80:	2210      	movs	r2, #16
 8013c82:	f7fe fb93 	bl	80123ac <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
 8013c86:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8013c8a:	4628      	mov	r0, r5
 8013c8c:	f7fe fed4 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013c90:	42b4      	cmp	r4, r6
 8013c92:	d1f8      	bne.n	8013c86 <OLED_writeEditScreen+0x76>
}
 8013c94:	b002      	add	sp, #8
 8013c96:	bd70      	pop	{r4, r5, r6, pc}
 8013c98:	08029550 	.word	0x08029550
 8013c9c:	20001c18 	.word	0x20001c18
 8013ca0:	0802a177 	.word	0x0802a177
 8013ca4:	0802a187 	.word	0x0802a187

08013ca8 <OLED_writeTuning>:
{
 8013ca8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8013cac:	2600      	movs	r6, #0
{
 8013cae:	b083      	sub	sp, #12
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8013cb0:	2710      	movs	r7, #16
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8013cb2:	4937      	ldr	r1, [pc, #220]	; (8013d90 <OLED_writeTuning+0xe8>)
 8013cb4:	4837      	ldr	r0, [pc, #220]	; (8013d94 <OLED_writeTuning+0xec>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013cb6:	f04f 0920 	mov.w	r9, #32
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8013cba:	f7fe ff83 	bl	8012bc4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8013cbe:	2380      	movs	r3, #128	; 0x80
 8013cc0:	4631      	mov	r1, r6
 8013cc2:	463a      	mov	r2, r7
 8013cc4:	4833      	ldr	r0, [pc, #204]	; (8013d94 <OLED_writeTuning+0xec>)
 8013cc6:	9601      	str	r6, [sp, #4]
 8013cc8:	9700      	str	r7, [sp, #0]
 8013cca:	f7fe fb6f 	bl	80123ac <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013cce:	4631      	mov	r1, r6
 8013cd0:	221c      	movs	r2, #28
 8013cd2:	4830      	ldr	r0, [pc, #192]	; (8013d94 <OLED_writeTuning+0xec>)
 8013cd4:	f7fe ff64 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013cd8:	2318      	movs	r3, #24
 8013cda:	463a      	mov	r2, r7
 8013cdc:	4631      	mov	r1, r6
 8013cde:	482d      	ldr	r0, [pc, #180]	; (8013d94 <OLED_writeTuning+0xec>)
 8013ce0:	9601      	str	r6, [sp, #4]
 8013ce2:	f8cd 9000 	str.w	r9, [sp]
 8013ce6:	f7fe fb61 	bl	80123ac <GFXfillRect>
	OLEDwriteInt(currentTuning, 2, 12, SecondLine);
 8013cea:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 8013da0 <OLED_writeTuning+0xf8>
		GFXwrite(&theGFX, myCharArray[i]);
 8013cee:	2154      	movs	r1, #84	; 0x54
 8013cf0:	4828      	ldr	r0, [pc, #160]	; (8013d94 <OLED_writeTuning+0xec>)
	}
}

void OLEDwriteInt(uint32_t myNumber, int numDigits, int startCursor, OLEDLine line)
{
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8013cf2:	4c29      	ldr	r4, [pc, #164]	; (8013d98 <OLED_writeTuning+0xf0>)
		GFXwrite(&theGFX, myCharArray[i]);
 8013cf4:	f7fe fea0 	bl	8012a38 <GFXwrite>
 8013cf8:	4631      	mov	r1, r6
 8013cfa:	4826      	ldr	r0, [pc, #152]	; (8013d94 <OLED_writeTuning+0xec>)
 8013cfc:	f7fe fe9c 	bl	8012a38 <GFXwrite>
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8013d00:	f8d8 1000 	ldr.w	r1, [r8]
 8013d04:	2202      	movs	r2, #2
 8013d06:	4620      	mov	r0, r4
 8013d08:	f7fe ff6e 	bl	8012be8 <OLEDparseInt>
 8013d0c:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013d0e:	221c      	movs	r2, #28
 8013d10:	210c      	movs	r1, #12
 8013d12:	4820      	ldr	r0, [pc, #128]	; (8013d94 <OLED_writeTuning+0xec>)
 8013d14:	f7fe ff44 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013d18:	f8cd 9000 	str.w	r9, [sp]
 8013d1c:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8013d20:	9601      	str	r6, [sp, #4]
 8013d22:	463a      	mov	r2, r7
 8013d24:	210c      	movs	r1, #12
 8013d26:	009b      	lsls	r3, r3, #2
 8013d28:	481a      	ldr	r0, [pc, #104]	; (8013d94 <OLED_writeTuning+0xec>)
 8013d2a:	b21b      	sxth	r3, r3
 8013d2c:	f7fe fb3e 	bl	80123ac <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8013d30:	42b5      	cmp	r5, r6
 8013d32:	dd08      	ble.n	8013d46 <OLED_writeTuning+0x9e>
		GFXwrite(&theGFX, myCharArray[i]);
 8013d34:	4e17      	ldr	r6, [pc, #92]	; (8013d94 <OLED_writeTuning+0xec>)
 8013d36:	4425      	add	r5, r4
 8013d38:	f814 1b01 	ldrb.w	r1, [r4], #1
 8013d3c:	4630      	mov	r0, r6
 8013d3e:	f7fe fe7b 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013d42:	42ac      	cmp	r4, r5
 8013d44:	d1f8      	bne.n	8013d38 <OLED_writeTuning+0x90>
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
 8013d46:	f8d8 3000 	ldr.w	r3, [r8]
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013d4a:	221c      	movs	r2, #28
 8013d4c:	4811      	ldr	r0, [pc, #68]	; (8013d94 <OLED_writeTuning+0xec>)
 8013d4e:	2124      	movs	r1, #36	; 0x24
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
 8013d50:	eb03 0543 	add.w	r5, r3, r3, lsl #1
 8013d54:	4c11      	ldr	r4, [pc, #68]	; (8013d9c <OLED_writeTuning+0xf4>)
		GFXwrite(&theGFX, myCharArray[i]);
 8013d56:	4606      	mov	r6, r0
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
 8013d58:	eb03 0585 	add.w	r5, r3, r5, lsl #2
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013d5c:	f7fe ff20 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013d60:	2300      	movs	r3, #0
 8013d62:	2220      	movs	r2, #32
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
 8013d64:	4425      	add	r5, r4
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013d66:	9301      	str	r3, [sp, #4]
 8013d68:	2124      	movs	r1, #36	; 0x24
 8013d6a:	9200      	str	r2, [sp, #0]
 8013d6c:	2390      	movs	r3, #144	; 0x90
 8013d6e:	2210      	movs	r2, #16
 8013d70:	4630      	mov	r0, r6
 8013d72:	1e6c      	subs	r4, r5, #1
 8013d74:	350b      	adds	r5, #11
 8013d76:	f7fe fb19 	bl	80123ac <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
 8013d7a:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8013d7e:	4630      	mov	r0, r6
 8013d80:	f7fe fe5a 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013d84:	42a5      	cmp	r5, r4
 8013d86:	d1f8      	bne.n	8013d7a <OLED_writeTuning+0xd2>
}
 8013d88:	b003      	add	sp, #12
 8013d8a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8013d8e:	bf00      	nop
 8013d90:	08029550 	.word	0x08029550
 8013d94:	20001c18 	.word	0x20001c18
 8013d98:	20001bf8 	.word	0x20001bf8
 8013d9c:	0802a208 	.word	0x0802a208
 8013da0:	20000664 	.word	0x20000664

08013da4 <OLED_draw>:
	ssd1306_display_full_buffer();
 8013da4:	f007 bfb2 	b.w	801bd0c <ssd1306_display_full_buffer>

08013da8 <OLEDclearLine>:
{
 8013da8:	4602      	mov	r2, r0
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8013daa:	2100      	movs	r1, #0
 8013dac:	2380      	movs	r3, #128	; 0x80
 8013dae:	4807      	ldr	r0, [pc, #28]	; (8013dcc <OLEDclearLine+0x24>)
{
 8013db0:	b510      	push	{r4, lr}
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8013db2:	0854      	lsrs	r4, r2, #1
 8013db4:	f002 0201 	and.w	r2, r2, #1
{
 8013db8:	b082      	sub	sp, #8
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8013dba:	3401      	adds	r4, #1
 8013dbc:	0112      	lsls	r2, r2, #4
 8013dbe:	9101      	str	r1, [sp, #4]
 8013dc0:	0124      	lsls	r4, r4, #4
 8013dc2:	9400      	str	r4, [sp, #0]
 8013dc4:	f7fe faf2 	bl	80123ac <GFXfillRect>
}
 8013dc8:	b002      	add	sp, #8
 8013dca:	bd10      	pop	{r4, pc}
 8013dcc:	20001c18 	.word	0x20001c18

08013dd0 <OLEDwriteString>:
{
 8013dd0:	b5f0      	push	{r4, r5, r6, r7, lr}
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013dd2:	b217      	sxth	r7, r2
	int cursorY = 12 + (16 * (line%2));
 8013dd4:	f003 0201 	and.w	r2, r3, #1
{
 8013dd8:	461e      	mov	r6, r3
 8013dda:	460d      	mov	r5, r1
	int cursorY = 12 + (16 * (line%2));
 8013ddc:	0112      	lsls	r2, r2, #4
{
 8013dde:	b083      	sub	sp, #12
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013de0:	4639      	mov	r1, r7
{
 8013de2:	4604      	mov	r4, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013de4:	320c      	adds	r2, #12
 8013de6:	480f      	ldr	r0, [pc, #60]	; (8013e24 <OLEDwriteString+0x54>)
 8013de8:	f7fe feda 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013dec:	1c73      	adds	r3, r6, #1
 8013dee:	eb05 0045 	add.w	r0, r5, r5, lsl #1
 8013df2:	2200      	movs	r2, #0
 8013df4:	011b      	lsls	r3, r3, #4
 8013df6:	4639      	mov	r1, r7
 8013df8:	0080      	lsls	r0, r0, #2
 8013dfa:	e9cd 3200 	strd	r3, r2, [sp]
 8013dfe:	b203      	sxth	r3, r0
 8013e00:	4808      	ldr	r0, [pc, #32]	; (8013e24 <OLEDwriteString+0x54>)
 8013e02:	0132      	lsls	r2, r6, #4
 8013e04:	f7fe fad2 	bl	80123ac <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8013e08:	2d00      	cmp	r5, #0
 8013e0a:	dd09      	ble.n	8013e20 <OLEDwriteString+0x50>
 8013e0c:	3c01      	subs	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
 8013e0e:	4e05      	ldr	r6, [pc, #20]	; (8013e24 <OLEDwriteString+0x54>)
 8013e10:	4425      	add	r5, r4
 8013e12:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8013e16:	4630      	mov	r0, r6
 8013e18:	f7fe fe0e 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013e1c:	42ac      	cmp	r4, r5
 8013e1e:	d1f8      	bne.n	8013e12 <OLEDwriteString+0x42>
}
 8013e20:	b003      	add	sp, #12
 8013e22:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013e24:	20001c18 	.word	0x20001c18

08013e28 <OLEDwriteInt>:
{
 8013e28:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8013e2a:	4c17      	ldr	r4, [pc, #92]	; (8013e88 <OLEDwriteInt+0x60>)
{
 8013e2c:	461f      	mov	r7, r3
 8013e2e:	b083      	sub	sp, #12
 8013e30:	4616      	mov	r6, r2
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8013e32:	b2ca      	uxtb	r2, r1
 8013e34:	4601      	mov	r1, r0
 8013e36:	4620      	mov	r0, r4
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013e38:	b236      	sxth	r6, r6
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8013e3a:	f7fe fed5 	bl	8012be8 <OLEDparseInt>
	int cursorY = 12 + (16 * (line%2));
 8013e3e:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8013e42:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013e44:	4631      	mov	r1, r6
	int cursorY = 12 + (16 * (line%2));
 8013e46:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013e48:	4810      	ldr	r0, [pc, #64]	; (8013e8c <OLEDwriteInt+0x64>)
 8013e4a:	320c      	adds	r2, #12
 8013e4c:	f7fe fea8 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013e50:	1c7b      	adds	r3, r7, #1
 8013e52:	eb05 0045 	add.w	r0, r5, r5, lsl #1
 8013e56:	2200      	movs	r2, #0
 8013e58:	011b      	lsls	r3, r3, #4
 8013e5a:	4631      	mov	r1, r6
 8013e5c:	0080      	lsls	r0, r0, #2
 8013e5e:	e9cd 3200 	strd	r3, r2, [sp]
 8013e62:	b203      	sxth	r3, r0
 8013e64:	4809      	ldr	r0, [pc, #36]	; (8013e8c <OLEDwriteInt+0x64>)
 8013e66:	013a      	lsls	r2, r7, #4
 8013e68:	f7fe faa0 	bl	80123ac <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8013e6c:	2d00      	cmp	r5, #0
 8013e6e:	dd08      	ble.n	8013e82 <OLEDwriteInt+0x5a>
		GFXwrite(&theGFX, myCharArray[i]);
 8013e70:	4e06      	ldr	r6, [pc, #24]	; (8013e8c <OLEDwriteInt+0x64>)
 8013e72:	4425      	add	r5, r4
 8013e74:	f814 1b01 	ldrb.w	r1, [r4], #1
 8013e78:	4630      	mov	r0, r6
 8013e7a:	f7fe fddd 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013e7e:	42a5      	cmp	r5, r4
 8013e80:	d1f8      	bne.n	8013e74 <OLEDwriteInt+0x4c>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
 8013e82:	b003      	add	sp, #12
 8013e84:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013e86:	bf00      	nop
 8013e88:	20001bf8 	.word	0x20001bf8
 8013e8c:	20001c18 	.word	0x20001c18

08013e90 <OLEDwritePitch>:

	OLEDwriteLine(oled_buffer, len, line);
}

void OLEDwritePitch(float midi, int startCursor, OLEDLine line, int showCents)
{
 8013e90:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
 8013e92:	4c16      	ldr	r4, [pc, #88]	; (8013eec <OLEDwritePitch+0x5c>)
{
 8013e94:	460f      	mov	r7, r1
 8013e96:	b083      	sub	sp, #12
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
 8013e98:	b2d1      	uxtb	r1, r2
{
 8013e9a:	4606      	mov	r6, r0
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
 8013e9c:	4620      	mov	r0, r4
 8013e9e:	f7fe fec3 	bl	8012c28 <OLEDparsePitch>
	int cursorY = 12 + (16 * (line%2));
 8013ea2:	f007 0201 	and.w	r2, r7, #1
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013ea6:	b236      	sxth	r6, r6
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
 8013ea8:	4605      	mov	r5, r0
	int cursorY = 12 + (16 * (line%2));
 8013eaa:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013eac:	4810      	ldr	r0, [pc, #64]	; (8013ef0 <OLEDwritePitch+0x60>)
 8013eae:	4631      	mov	r1, r6
 8013eb0:	320c      	adds	r2, #12
 8013eb2:	f7fe fe75 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013eb6:	1c7a      	adds	r2, r7, #1
 8013eb8:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8013ebc:	2000      	movs	r0, #0
 8013ebe:	0112      	lsls	r2, r2, #4
 8013ec0:	4631      	mov	r1, r6
 8013ec2:	009b      	lsls	r3, r3, #2
 8013ec4:	e9cd 2000 	strd	r2, r0, [sp]
 8013ec8:	b21b      	sxth	r3, r3
 8013eca:	4809      	ldr	r0, [pc, #36]	; (8013ef0 <OLEDwritePitch+0x60>)
 8013ecc:	013a      	lsls	r2, r7, #4
 8013ece:	f7fe fa6d 	bl	80123ac <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8013ed2:	2d00      	cmp	r5, #0
 8013ed4:	dd08      	ble.n	8013ee8 <OLEDwritePitch+0x58>
		GFXwrite(&theGFX, myCharArray[i]);
 8013ed6:	4e06      	ldr	r6, [pc, #24]	; (8013ef0 <OLEDwritePitch+0x60>)
 8013ed8:	4425      	add	r5, r4
 8013eda:	f814 1b01 	ldrb.w	r1, [r4], #1
 8013ede:	4630      	mov	r0, r6
 8013ee0:	f7fe fdaa 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013ee4:	42a5      	cmp	r5, r4
 8013ee6:	d1f8      	bne.n	8013eda <OLEDwritePitch+0x4a>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
 8013ee8:	b003      	add	sp, #12
 8013eea:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013eec:	20001bf8 	.word	0x20001bf8
 8013ef0:	20001c18 	.word	0x20001c18

08013ef4 <OLEDwritePitchClass>:

void OLEDwritePitchClass(float midi, int startCursor, OLEDLine line)
{
 8013ef4:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparsePitchClass(oled_buffer, midi);
 8013ef6:	4c16      	ldr	r4, [pc, #88]	; (8013f50 <OLEDwritePitchClass+0x5c>)
{
 8013ef8:	460f      	mov	r7, r1
 8013efa:	b083      	sub	sp, #12
 8013efc:	4606      	mov	r6, r0
	int len = OLEDparsePitchClass(oled_buffer, midi);
 8013efe:	4620      	mov	r0, r4
 8013f00:	f7fe fef4 	bl	8012cec <OLEDparsePitchClass>
	int cursorY = 12 + (16 * (line%2));
 8013f04:	f007 0201 	and.w	r2, r7, #1
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013f08:	b236      	sxth	r6, r6
	int len = OLEDparsePitchClass(oled_buffer, midi);
 8013f0a:	4605      	mov	r5, r0
	int cursorY = 12 + (16 * (line%2));
 8013f0c:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013f0e:	4811      	ldr	r0, [pc, #68]	; (8013f54 <OLEDwritePitchClass+0x60>)
 8013f10:	4631      	mov	r1, r6
 8013f12:	320c      	adds	r2, #12
 8013f14:	f7fe fe44 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013f18:	1c7a      	adds	r2, r7, #1
 8013f1a:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8013f1e:	2000      	movs	r0, #0
 8013f20:	0112      	lsls	r2, r2, #4
 8013f22:	4631      	mov	r1, r6
 8013f24:	009b      	lsls	r3, r3, #2
 8013f26:	e9cd 2000 	strd	r2, r0, [sp]
 8013f2a:	b21b      	sxth	r3, r3
 8013f2c:	4809      	ldr	r0, [pc, #36]	; (8013f54 <OLEDwritePitchClass+0x60>)
 8013f2e:	013a      	lsls	r2, r7, #4
 8013f30:	f7fe fa3c 	bl	80123ac <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8013f34:	2d00      	cmp	r5, #0
 8013f36:	dd08      	ble.n	8013f4a <OLEDwritePitchClass+0x56>
		GFXwrite(&theGFX, myCharArray[i]);
 8013f38:	4e06      	ldr	r6, [pc, #24]	; (8013f54 <OLEDwritePitchClass+0x60>)
 8013f3a:	4425      	add	r5, r4
 8013f3c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8013f40:	4630      	mov	r0, r6
 8013f42:	f7fe fd79 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013f46:	42a5      	cmp	r5, r4
 8013f48:	d1f8      	bne.n	8013f3c <OLEDwritePitchClass+0x48>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
 8013f4a:	b003      	add	sp, #12
 8013f4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013f4e:	bf00      	nop
 8013f50:	20001bf8 	.word	0x20001bf8
 8013f54:	20001c18 	.word	0x20001c18

08013f58 <OLEDwriteFloat>:
	OLEDwriteLine(oled_buffer, len, line);
}


void OLEDwriteFloat(float input, int startCursor, OLEDLine line)
{
 8013f58:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013f5a:	ed2d 8b02 	vpush	{d8}
 8013f5e:	b083      	sub	sp, #12
 8013f60:	4606      	mov	r6, r0
 8013f62:	460f      	mov	r7, r1
 8013f64:	eeb0 8a40 	vmov.f32	s16, s0
	int numDigits = 5;
	int numDecimal = 1;

	if (fastabsf(input)<1.0f)
 8013f68:	f00f feca 	bl	8023d00 <fastabsf>
 8013f6c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8013f70:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8013f74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013f78:	d439      	bmi.n	8013fee <OLEDwriteFloat+0x96>
	{
		numDigits = 3;
		numDecimal = 2;
	}

	else if (fastabsf(input)<10.0f)
 8013f7a:	eeb0 0a48 	vmov.f32	s0, s16
 8013f7e:	f00f febf 	bl	8023d00 <fastabsf>
 8013f82:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8013f86:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8013f8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013f8e:	d531      	bpl.n	8013ff4 <OLEDwriteFloat+0x9c>
 8013f90:	2202      	movs	r2, #2
 8013f92:	2104      	movs	r1, #4
	{
		numDigits = 8;
		numDecimal = 0;
	}

	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
 8013f94:	4c41      	ldr	r4, [pc, #260]	; (801409c <OLEDwriteFloat+0x144>)
 8013f96:	eeb0 0a48 	vmov.f32	s0, s16
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013f9a:	b236      	sxth	r6, r6
	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
 8013f9c:	4620      	mov	r0, r4
 8013f9e:	f7fe fed3 	bl	8012d48 <OLEDparseFixedFloat>
	int cursorY = 12 + (16 * (line%2));
 8013fa2:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
 8013fa6:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013fa8:	4631      	mov	r1, r6
	int cursorY = 12 + (16 * (line%2));
 8013faa:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8013fac:	483c      	ldr	r0, [pc, #240]	; (80140a0 <OLEDwriteFloat+0x148>)
 8013fae:	320c      	adds	r2, #12
 8013fb0:	f7fe fdf6 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8013fb4:	1c7a      	adds	r2, r7, #1
 8013fb6:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8013fba:	2000      	movs	r0, #0
 8013fbc:	0112      	lsls	r2, r2, #4
 8013fbe:	4631      	mov	r1, r6
 8013fc0:	009b      	lsls	r3, r3, #2
 8013fc2:	e9cd 2000 	strd	r2, r0, [sp]
 8013fc6:	b21b      	sxth	r3, r3
 8013fc8:	4835      	ldr	r0, [pc, #212]	; (80140a0 <OLEDwriteFloat+0x148>)
 8013fca:	013a      	lsls	r2, r7, #4
 8013fcc:	f7fe f9ee 	bl	80123ac <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8013fd0:	2d00      	cmp	r5, #0
 8013fd2:	dd08      	ble.n	8013fe6 <OLEDwriteFloat+0x8e>
		GFXwrite(&theGFX, myCharArray[i]);
 8013fd4:	4e32      	ldr	r6, [pc, #200]	; (80140a0 <OLEDwriteFloat+0x148>)
 8013fd6:	4425      	add	r5, r4
 8013fd8:	f814 1b01 	ldrb.w	r1, [r4], #1
 8013fdc:	4630      	mov	r0, r6
 8013fde:	f7fe fd2b 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8013fe2:	42ac      	cmp	r4, r5
 8013fe4:	d1f8      	bne.n	8013fd8 <OLEDwriteFloat+0x80>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
 8013fe6:	b003      	add	sp, #12
 8013fe8:	ecbd 8b02 	vpop	{d8}
 8013fec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013fee:	2202      	movs	r2, #2
 8013ff0:	2103      	movs	r1, #3
 8013ff2:	e7cf      	b.n	8013f94 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<100.0f)
 8013ff4:	eeb0 0a48 	vmov.f32	s0, s16
 8013ff8:	f00f fe82 	bl	8023d00 <fastabsf>
 8013ffc:	eddf 7a29 	vldr	s15, [pc, #164]	; 80140a4 <OLEDwriteFloat+0x14c>
 8014000:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8014004:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014008:	d502      	bpl.n	8014010 <OLEDwriteFloat+0xb8>
 801400a:	2202      	movs	r2, #2
 801400c:	2105      	movs	r1, #5
 801400e:	e7c1      	b.n	8013f94 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<1000.0f)
 8014010:	eeb0 0a48 	vmov.f32	s0, s16
 8014014:	f00f fe74 	bl	8023d00 <fastabsf>
 8014018:	eddf 7a23 	vldr	s15, [pc, #140]	; 80140a8 <OLEDwriteFloat+0x150>
 801401c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8014020:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014024:	d502      	bpl.n	801402c <OLEDwriteFloat+0xd4>
 8014026:	2201      	movs	r2, #1
 8014028:	2105      	movs	r1, #5
 801402a:	e7b3      	b.n	8013f94 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<10000.0f)
 801402c:	eeb0 0a48 	vmov.f32	s0, s16
 8014030:	f00f fe66 	bl	8023d00 <fastabsf>
 8014034:	eddf 7a1d 	vldr	s15, [pc, #116]	; 80140ac <OLEDwriteFloat+0x154>
 8014038:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801403c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014040:	d502      	bpl.n	8014048 <OLEDwriteFloat+0xf0>
 8014042:	2200      	movs	r2, #0
 8014044:	2105      	movs	r1, #5
 8014046:	e7a5      	b.n	8013f94 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<100000.0f)
 8014048:	eeb0 0a48 	vmov.f32	s0, s16
 801404c:	f00f fe58 	bl	8023d00 <fastabsf>
 8014050:	eddf 7a17 	vldr	s15, [pc, #92]	; 80140b0 <OLEDwriteFloat+0x158>
 8014054:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8014058:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801405c:	d502      	bpl.n	8014064 <OLEDwriteFloat+0x10c>
 801405e:	2200      	movs	r2, #0
 8014060:	2106      	movs	r1, #6
 8014062:	e797      	b.n	8013f94 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<1000000.0f)
 8014064:	eeb0 0a48 	vmov.f32	s0, s16
 8014068:	f00f fe4a 	bl	8023d00 <fastabsf>
 801406c:	eddf 7a11 	vldr	s15, [pc, #68]	; 80140b4 <OLEDwriteFloat+0x15c>
 8014070:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8014074:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014078:	d502      	bpl.n	8014080 <OLEDwriteFloat+0x128>
 801407a:	2200      	movs	r2, #0
 801407c:	2107      	movs	r1, #7
 801407e:	e789      	b.n	8013f94 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<10000000.0f)
 8014080:	eeb0 0a48 	vmov.f32	s0, s16
 8014084:	f00f fe3c 	bl	8023d00 <fastabsf>
 8014088:	eddf 7a0b 	vldr	s15, [pc, #44]	; 80140b8 <OLEDwriteFloat+0x160>
 801408c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8014090:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014094:	d5c7      	bpl.n	8014026 <OLEDwriteFloat+0xce>
 8014096:	2200      	movs	r2, #0
 8014098:	2108      	movs	r1, #8
 801409a:	e77b      	b.n	8013f94 <OLEDwriteFloat+0x3c>
 801409c:	20001bf8 	.word	0x20001bf8
 80140a0:	20001c18 	.word	0x20001c18
 80140a4:	42c80000 	.word	0x42c80000
 80140a8:	447a0000 	.word	0x447a0000
 80140ac:	461c4000 	.word	0x461c4000
 80140b0:	47c35000 	.word	0x47c35000
 80140b4:	49742400 	.word	0x49742400
 80140b8:	4b189680 	.word	0x4b189680

080140bc <OLED_writeKnobParameter.part.0>:
void OLED_writeKnobParameter(int whichKnob)
 80140bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80140c0:	f8df 9124 	ldr.w	r9, [pc, #292]	; 80141e8 <OLED_writeKnobParameter.part.0+0x12c>
void OLED_writeKnobParameter(int whichKnob)
 80140c4:	4680      	mov	r8, r0
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
 80140c6:	f8df a124 	ldr.w	sl, [pc, #292]	; 80141ec <OLED_writeKnobParameter.part.0+0x130>
 80140ca:	2605      	movs	r6, #5
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80140cc:	0080      	lsls	r0, r0, #2
 80140ce:	4941      	ldr	r1, [pc, #260]	; (80141d4 <OLED_writeKnobParameter.part.0+0x118>)
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
 80140d0:	f89a 2000 	ldrb.w	r2, [sl]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80140d4:	4401      	add	r1, r0
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80140d6:	f8df b118 	ldr.w	fp, [pc, #280]	; 80141f0 <OLED_writeKnobParameter.part.0+0x134>
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
 80140da:	fb16 8602 	smlabb	r6, r6, r2, r8
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80140de:	4a3e      	ldr	r2, [pc, #248]	; (80141d8 <OLED_writeKnobParameter.part.0+0x11c>)
void OLED_writeKnobParameter(int whichKnob)
 80140e0:	ed2d 8b02 	vpush	{d8}
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80140e4:	f899 3000 	ldrb.w	r3, [r9]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80140e8:	4402      	add	r2, r0
 80140ea:	6809      	ldr	r1, [r1, #0]
void OLED_writeKnobParameter(int whichKnob)
 80140ec:	b083      	sub	sp, #12
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80140ee:	eb03 0383 	add.w	r3, r3, r3, lsl #2
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80140f2:	6011      	str	r1, [r2, #0]
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80140f4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80140f8:	4433      	add	r3, r6
 80140fa:	f85b 0023 	ldr.w	r0, [fp, r3, lsl #2]
 80140fe:	f7ec f8eb 	bl	80002d8 <strlen>
		if (len > 0)
 8014102:	2800      	cmp	r0, #0
 8014104:	d061      	beq.n	80141ca <OLED_writeKnobParameter.part.0+0x10e>
 8014106:	4605      	mov	r5, r0
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8014108:	4934      	ldr	r1, [pc, #208]	; (80141dc <OLED_writeKnobParameter.part.0+0x120>)
 801410a:	4835      	ldr	r0, [pc, #212]	; (80141e0 <OLED_writeKnobParameter.part.0+0x124>)
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 801410c:	2700      	movs	r7, #0
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 801410e:	f7fe fd59 	bl	8012bc4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8014112:	2310      	movs	r3, #16
 8014114:	4639      	mov	r1, r7
 8014116:	4832      	ldr	r0, [pc, #200]	; (80141e0 <OLED_writeKnobParameter.part.0+0x124>)
 8014118:	461a      	mov	r2, r3
 801411a:	9300      	str	r3, [sp, #0]
 801411c:	9701      	str	r7, [sp, #4]
 801411e:	2380      	movs	r3, #128	; 0x80
 8014120:	f7fe f944 	bl	80123ac <GFXfillRect>
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
 8014124:	f899 3000 	ldrb.w	r3, [r9]
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8014128:	482d      	ldr	r0, [pc, #180]	; (80141e0 <OLED_writeKnobParameter.part.0+0x124>)
 801412a:	4639      	mov	r1, r7
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
 801412c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8014130:	221c      	movs	r2, #28
		GFXwrite(&theGFX, myCharArray[i]);
 8014132:	4681      	mov	r9, r0
	for (int i = 0; i < arrayLength; ++i)
 8014134:	463c      	mov	r4, r7
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
 8014136:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801413a:	441e      	add	r6, r3
 801413c:	f85b 6026 	ldr.w	r6, [fp, r6, lsl #2]
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8014140:	f7fe fd2e 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8014144:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8014148:	2020      	movs	r0, #32
 801414a:	9701      	str	r7, [sp, #4]
 801414c:	2210      	movs	r2, #16
 801414e:	009b      	lsls	r3, r3, #2
 8014150:	9000      	str	r0, [sp, #0]
 8014152:	4639      	mov	r1, r7
 8014154:	4648      	mov	r0, r9
 8014156:	b21b      	sxth	r3, r3
 8014158:	3e01      	subs	r6, #1
 801415a:	f7fe f927 	bl	80123ac <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 801415e:	3401      	adds	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
 8014160:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8014164:	4648      	mov	r0, r9
 8014166:	f7fe fc67 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 801416a:	42a5      	cmp	r5, r4
 801416c:	dcf7      	bgt.n	801415e <OLED_writeKnobParameter.part.0+0xa2>
	return GFXgetCursorX(&theGFX);
 801416e:	481c      	ldr	r0, [pc, #112]	; (80141e0 <OLED_writeKnobParameter.part.0+0x124>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8014170:	2420      	movs	r4, #32
	return GFXgetCursorX(&theGFX);
 8014172:	f7fe fd19 	bl	8012ba8 <GFXgetCursorX>
 8014176:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8014178:	221c      	movs	r2, #28
 801417a:	4819      	ldr	r0, [pc, #100]	; (80141e0 <OLED_writeKnobParameter.part.0+0x124>)
 801417c:	4629      	mov	r1, r5
 801417e:	f7fe fd0f 	bl	8012ba0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8014182:	2300      	movs	r3, #0
 8014184:	4629      	mov	r1, r5
 8014186:	2210      	movs	r2, #16
 8014188:	4815      	ldr	r0, [pc, #84]	; (80141e0 <OLED_writeKnobParameter.part.0+0x124>)
 801418a:	e9cd 4300 	strd	r4, r3, [sp]
 801418e:	230c      	movs	r3, #12
 8014190:	f7fe f90c 	bl	80123ac <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
 8014194:	4621      	mov	r1, r4
 8014196:	4812      	ldr	r0, [pc, #72]	; (80141e0 <OLED_writeKnobParameter.part.0+0x124>)
 8014198:	f7fe fc4e 	bl	8012a38 <GFXwrite>
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
 801419c:	f89a 1000 	ldrb.w	r1, [sl]
 80141a0:	2205      	movs	r2, #5
 80141a2:	4b10      	ldr	r3, [pc, #64]	; (80141e4 <OLED_writeKnobParameter.part.0+0x128>)
	return GFXgetCursorX(&theGFX);
 80141a4:	480e      	ldr	r0, [pc, #56]	; (80141e0 <OLED_writeKnobParameter.part.0+0x124>)
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
 80141a6:	fb12 8801 	smlabb	r8, r2, r1, r8
 80141aa:	eb03 0888 	add.w	r8, r3, r8, lsl #2
 80141ae:	ed98 8a00 	vldr	s16, [r8]
	return GFXgetCursorX(&theGFX);
 80141b2:	f7fe fcf9 	bl	8012ba8 <GFXgetCursorX>
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
 80141b6:	2101      	movs	r1, #1
 80141b8:	eeb0 0a48 	vmov.f32	s0, s16
}
 80141bc:	b003      	add	sp, #12
 80141be:	ecbd 8b02 	vpop	{d8}
 80141c2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
 80141c6:	f7ff bec7 	b.w	8013f58 <OLEDwriteFloat>
}
 80141ca:	b003      	add	sp, #12
 80141cc:	ecbd 8b02 	vpop	{d8}
 80141d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80141d4:	2001886c 	.word	0x2001886c
 80141d8:	20018884 	.word	0x20018884
 80141dc:	08029550 	.word	0x08029550
 80141e0:	20001c18 	.word	0x20001c18
 80141e4:	200187dc 	.word	0x200187dc
 80141e8:	20000669 	.word	0x20000669
 80141ec:	2000066a 	.word	0x2000066a
 80141f0:	200189ac 	.word	0x200189ac

080141f4 <OLED_process>:
{
 80141f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (writeKnobFlag >= 0)
 80141f8:	4c2d      	ldr	r4, [pc, #180]	; (80142b0 <OLED_process+0xbc>)
{
 80141fa:	b083      	sub	sp, #12
	if (writeKnobFlag >= 0)
 80141fc:	f994 0000 	ldrsb.w	r0, [r4]
 8014200:	2800      	cmp	r0, #0
 8014202:	db03      	blt.n	801420c <OLED_process+0x18>
	if (whichKnob < KNOB_PAGE_SIZE)
 8014204:	2804      	cmp	r0, #4
 8014206:	dd50      	ble.n	80142aa <OLED_process+0xb6>
		writeKnobFlag = -1;
 8014208:	23ff      	movs	r3, #255	; 0xff
 801420a:	7023      	strb	r3, [r4, #0]
	if (writeButtonFlag >= 0 && writeActionFlag >= 0) //These should always be set together
 801420c:	4e29      	ldr	r6, [pc, #164]	; (80142b4 <OLED_process+0xc0>)
 801420e:	f996 0000 	ldrsb.w	r0, [r6]
 8014212:	2800      	cmp	r0, #0
 8014214:	db46      	blt.n	80142a4 <OLED_process+0xb0>
 8014216:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 80142c8 <OLED_process+0xd4>
 801421a:	f998 1000 	ldrsb.w	r1, [r8]
 801421e:	2900      	cmp	r1, #0
 8014220:	db40      	blt.n	80142a4 <OLED_process+0xb0>
	char* str = buttonActionFunctions[currentPreset](whichButton, whichAction);
 8014222:	4a25      	ldr	r2, [pc, #148]	; (80142b8 <OLED_process+0xc4>)
 8014224:	b2c9      	uxtb	r1, r1
 8014226:	4b25      	ldr	r3, [pc, #148]	; (80142bc <OLED_process+0xc8>)
 8014228:	b2c0      	uxtb	r0, r0
 801422a:	7812      	ldrb	r2, [r2, #0]
 801422c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8014230:	4798      	blx	r3
 8014232:	4605      	mov	r5, r0
	int len = strlen(str);
 8014234:	f7ec f850 	bl	80002d8 <strlen>
	if (len > 0)
 8014238:	4607      	mov	r7, r0
 801423a:	b378      	cbz	r0, 801429c <OLED_process+0xa8>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 801423c:	f04f 0900 	mov.w	r9, #0
 8014240:	f04f 0b10 	mov.w	fp, #16
		GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8014244:	491e      	ldr	r1, [pc, #120]	; (80142c0 <OLED_process+0xcc>)
 8014246:	3d01      	subs	r5, #1
 8014248:	481e      	ldr	r0, [pc, #120]	; (80142c4 <OLED_process+0xd0>)
	for (int i = 0; i < arrayLength; ++i)
 801424a:	464c      	mov	r4, r9
		GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 801424c:	f7fe fcba 	bl	8012bc4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8014250:	2380      	movs	r3, #128	; 0x80
 8014252:	4649      	mov	r1, r9
 8014254:	465a      	mov	r2, fp
 8014256:	481b      	ldr	r0, [pc, #108]	; (80142c4 <OLED_process+0xd0>)
 8014258:	f8cd 9004 	str.w	r9, [sp, #4]
 801425c:	f8cd b000 	str.w	fp, [sp]
 8014260:	f7fe f8a4 	bl	80123ac <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8014264:	4649      	mov	r1, r9
 8014266:	221c      	movs	r2, #28
 8014268:	4816      	ldr	r0, [pc, #88]	; (80142c4 <OLED_process+0xd0>)
 801426a:	f7fe fc99 	bl	8012ba0 <GFXsetCursor>
		GFXwrite(&theGFX, myCharArray[i]);
 801426e:	f8df a054 	ldr.w	sl, [pc, #84]	; 80142c4 <OLED_process+0xd0>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8014272:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 8014276:	2020      	movs	r0, #32
 8014278:	f8cd 9004 	str.w	r9, [sp, #4]
 801427c:	465a      	mov	r2, fp
 801427e:	009b      	lsls	r3, r3, #2
 8014280:	9000      	str	r0, [sp, #0]
 8014282:	4649      	mov	r1, r9
 8014284:	4650      	mov	r0, sl
 8014286:	b21b      	sxth	r3, r3
 8014288:	f7fe f890 	bl	80123ac <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 801428c:	3401      	adds	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
 801428e:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8014292:	4650      	mov	r0, sl
 8014294:	f7fe fbd0 	bl	8012a38 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8014298:	42a7      	cmp	r7, r4
 801429a:	dcf7      	bgt.n	801428c <OLED_process+0x98>
		writeButtonFlag = -1;
 801429c:	23ff      	movs	r3, #255	; 0xff
 801429e:	7033      	strb	r3, [r6, #0]
		writeActionFlag = -1;
 80142a0:	f888 3000 	strb.w	r3, [r8]
}
 80142a4:	b003      	add	sp, #12
 80142a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80142aa:	f7ff ff07 	bl	80140bc <OLED_writeKnobParameter.part.0>
 80142ae:	e7ab      	b.n	8014208 <OLED_process+0x14>
 80142b0:	200002db 	.word	0x200002db
 80142b4:	200002da 	.word	0x200002da
 80142b8:	20000669 	.word	0x20000669
 80142bc:	200190c0 	.word	0x200190c0
 80142c0:	08029550 	.word	0x08029550
 80142c4:	20001c18 	.word	0x20001c18
 80142c8:	200002d9 	.word	0x200002d9

080142cc <OLEDgetCursor>:
 80142cc:	b508      	push	{r3, lr}
 80142ce:	4802      	ldr	r0, [pc, #8]	; (80142d8 <OLEDgetCursor+0xc>)
 80142d0:	f7fe fc6a 	bl	8012ba8 <GFXgetCursorX>
 80142d4:	bd08      	pop	{r3, pc}
 80142d6:	bf00      	nop
 80142d8:	20001c18 	.word	0x20001c18

080142dc <MX_RNG_Init>:

RNG_HandleTypeDef hrng;

/* RNG init function */
void MX_RNG_Init(void)
{
 80142dc:	b508      	push	{r3, lr}

  hrng.Instance = RNG;
 80142de:	4b07      	ldr	r3, [pc, #28]	; (80142fc <MX_RNG_Init+0x20>)
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
 80142e0:	2100      	movs	r1, #0
  hrng.Instance = RNG;
 80142e2:	4a07      	ldr	r2, [pc, #28]	; (8014300 <MX_RNG_Init+0x24>)
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 80142e4:	4618      	mov	r0, r3
  hrng.Instance = RNG;
 80142e6:	e9c3 2100 	strd	r2, r1, [r3]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 80142ea:	f7f6 f867 	bl	800a3bc <HAL_RNG_Init>
 80142ee:	b900      	cbnz	r0, 80142f2 <MX_RNG_Init+0x16>
  {
    Error_Handler();
  }

}
 80142f0:	bd08      	pop	{r3, pc}
 80142f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 80142f6:	f7ff bae9 	b.w	80138cc <Error_Handler>
 80142fa:	bf00      	nop
 80142fc:	20001c3c 	.word	0x20001c3c
 8014300:	48021800 	.word	0x48021800

08014304 <HAL_RNG_MspInit>:

void HAL_RNG_MspInit(RNG_HandleTypeDef* rngHandle)
{

  if(rngHandle->Instance==RNG)
 8014304:	6802      	ldr	r2, [r0, #0]
 8014306:	4b0a      	ldr	r3, [pc, #40]	; (8014330 <HAL_RNG_MspInit+0x2c>)
 8014308:	429a      	cmp	r2, r3
 801430a:	d000      	beq.n	801430e <HAL_RNG_MspInit+0xa>
 801430c:	4770      	bx	lr
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */
    /* RNG clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
 801430e:	4b09      	ldr	r3, [pc, #36]	; (8014334 <HAL_RNG_MspInit+0x30>)
{
 8014310:	b082      	sub	sp, #8
    __HAL_RCC_RNG_CLK_ENABLE();
 8014312:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 8014316:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801431a:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
 801431e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 8014322:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014326:	9301      	str	r3, [sp, #4]
 8014328:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }
}
 801432a:	b002      	add	sp, #8
 801432c:	4770      	bx	lr
 801432e:	bf00      	nop
 8014330:	48021800 	.word	0x48021800
 8014334:	58024400 	.word	0x58024400

08014338 <MX_SAI1_Init>:
DMA_HandleTypeDef hdma_sai1_a;
DMA_HandleTypeDef hdma_sai1_b;

/* SAI1 init function */
void MX_SAI1_Init(void)
{
 8014338:	b570      	push	{r4, r5, r6, lr}

  hsai_BlockA1.Instance = SAI1_Block_A;
 801433a:	481a      	ldr	r0, [pc, #104]	; (80143a4 <MX_SAI1_Init+0x6c>)
  hsai_BlockA1.Init.AudioMode = SAI_MODEMASTER_TX;
 801433c:	2500      	movs	r5, #0
  hsai_BlockA1.Instance = SAI1_Block_A;
 801433e:	4c1a      	ldr	r4, [pc, #104]	; (80143a8 <MX_SAI1_Init+0x70>)
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
  hsai_BlockA1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 8014340:	2101      	movs	r1, #1
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
 8014342:	f64b 3280 	movw	r2, #48000	; 0xbb80
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
  hsai_BlockA1.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 8014346:	2302      	movs	r3, #2
  hsai_BlockA1.Instance = SAI1_Block_A;
 8014348:	6020      	str	r0, [r4, #0]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 801434a:	4620      	mov	r0, r4
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 801434c:	61e1      	str	r1, [r4, #28]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 801434e:	4629      	mov	r1, r5
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
 8014350:	6222      	str	r2, [r4, #32]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 8014352:	461a      	mov	r2, r3
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 8014354:	60e5      	str	r5, [r4, #12]
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 8014356:	6365      	str	r5, [r4, #52]	; 0x34
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
 8014358:	e9c4 5501 	strd	r5, r5, [r4, #4]
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
 801435c:	e9c4 5505 	strd	r5, r5, [r4, #20]
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
 8014360:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 8014364:	f7f6 f8b2 	bl	800a4cc <HAL_SAI_InitProtocol>
 8014368:	b9c8      	cbnz	r0, 801439e <MX_SAI1_Init+0x66>
  {
    Error_Handler();
  }

  hsai_BlockB1.Instance = SAI1_Block_B;
 801436a:	4c10      	ldr	r4, [pc, #64]	; (80143ac <MX_SAI1_Init+0x74>)
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
 801436c:	2500      	movs	r5, #0
  hsai_BlockB1.Instance = SAI1_Block_B;
 801436e:	4910      	ldr	r1, [pc, #64]	; (80143b0 <MX_SAI1_Init+0x78>)
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
 8014370:	2203      	movs	r2, #3
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
  hsai_BlockB1.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 8014372:	2302      	movs	r3, #2
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
 8014374:	2601      	movs	r6, #1
  hsai_BlockB1.Instance = SAI1_Block_B;
 8014376:	6021      	str	r1, [r4, #0]
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 8014378:	4620      	mov	r0, r4
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
 801437a:	6062      	str	r2, [r4, #4]
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 801437c:	4629      	mov	r1, r5
 801437e:	461a      	mov	r2, r3
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
 8014380:	60a6      	str	r6, [r4, #8]
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 8014382:	61e6      	str	r6, [r4, #28]
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
 8014384:	6165      	str	r5, [r4, #20]
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 8014386:	60e5      	str	r5, [r4, #12]
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 8014388:	6365      	str	r5, [r4, #52]	; 0x34
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
 801438a:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 801438e:	f7f6 f89d 	bl	800a4cc <HAL_SAI_InitProtocol>
 8014392:	b900      	cbnz	r0, 8014396 <MX_SAI1_Init+0x5e>
  {
    Error_Handler();
  }

}
 8014394:	bd70      	pop	{r4, r5, r6, pc}
 8014396:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Error_Handler();
 801439a:	f7ff ba97 	b.w	80138cc <Error_Handler>
    Error_Handler();
 801439e:	f7ff fa95 	bl	80138cc <Error_Handler>
 80143a2:	e7e2      	b.n	801436a <MX_SAI1_Init+0x32>
 80143a4:	40015804 	.word	0x40015804
 80143a8:	20001dd8 	.word	0x20001dd8
 80143ac:	20001c50 	.word	0x20001c50
 80143b0:	40015824 	.word	0x40015824

080143b4 <HAL_SAI_MspInit>:
static uint32_t SAI1_client =0;

void HAL_SAI_MspInit(SAI_HandleTypeDef* hsai)
{
 80143b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
/* SAI1 */
    if(hsai->Instance==SAI1_Block_A)
 80143b8:	4a5e      	ldr	r2, [pc, #376]	; (8014534 <HAL_SAI_MspInit+0x180>)
{
 80143ba:	b088      	sub	sp, #32
    if(hsai->Instance==SAI1_Block_A)
 80143bc:	6803      	ldr	r3, [r0, #0]
{
 80143be:	4605      	mov	r5, r0
    if(hsai->Instance==SAI1_Block_A)
 80143c0:	4293      	cmp	r3, r2
 80143c2:	d040      	beq.n	8014446 <HAL_SAI_MspInit+0x92>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
    }
    if(hsai->Instance==SAI1_Block_B)
 80143c4:	4a5c      	ldr	r2, [pc, #368]	; (8014538 <HAL_SAI_MspInit+0x184>)
 80143c6:	4293      	cmp	r3, r2
 80143c8:	d002      	beq.n	80143d0 <HAL_SAI_MspInit+0x1c>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
    }
}
 80143ca:	b008      	add	sp, #32
 80143cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (SAI1_client == 0)
 80143d0:	4c5a      	ldr	r4, [pc, #360]	; (801453c <HAL_SAI_MspInit+0x188>)
 80143d2:	6822      	ldr	r2, [r4, #0]
 80143d4:	2a00      	cmp	r2, #0
 80143d6:	d07b      	beq.n	80144d0 <HAL_SAI_MspInit+0x11c>
    SAI1_client ++;
 80143d8:	3201      	adds	r2, #1
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 80143da:	2008      	movs	r0, #8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80143dc:	2600      	movs	r6, #0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80143de:	2302      	movs	r3, #2
    SAI1_client ++;
 80143e0:	6022      	str	r2, [r4, #0]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 80143e2:	2206      	movs	r2, #6
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80143e4:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 80143e6:	9003      	str	r0, [sp, #12]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80143e8:	4855      	ldr	r0, [pc, #340]	; (8014540 <HAL_SAI_MspInit+0x18c>)
    hdma_sai1_b.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 80143ea:	f44f 4780 	mov.w	r7, #16384	; 0x4000
    hdma_sai1_b.Instance = DMA1_Stream2;
 80143ee:	4c55      	ldr	r4, [pc, #340]	; (8014544 <HAL_SAI_MspInit+0x190>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80143f0:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80143f2:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 80143f4:	9207      	str	r2, [sp, #28]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80143f6:	9605      	str	r6, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80143f8:	f7f0 fee2 	bl	80051c0 <HAL_GPIO_Init>
    hdma_sai1_b.Instance = DMA1_Stream2;
 80143fc:	4a52      	ldr	r2, [pc, #328]	; (8014548 <HAL_SAI_MspInit+0x194>)
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
 80143fe:	2358      	movs	r3, #88	; 0x58
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8014400:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    hdma_sai1_b.Init.MemInc = DMA_MINC_ENABLE;
 8014404:	f44f 6c80 	mov.w	ip, #1024	; 0x400
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
 8014408:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_sai1_b.Instance = DMA1_Stream2;
 801440c:	6022      	str	r2, [r4, #0]
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
 801440e:	6063      	str	r3, [r4, #4]
    hdma_sai1_b.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 8014410:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8014414:	2304      	movs	r3, #4
    hdma_sai1_b.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8014416:	60a6      	str	r6, [r4, #8]
    hdma_sai1_b.Init.PeriphInc = DMA_PINC_DISABLE;
 8014418:	60e6      	str	r6, [r4, #12]
    hdma_sai1_b.Init.PeriphBurst = DMA_PBURST_SINGLE;
 801441a:	6326      	str	r6, [r4, #48]	; 0x30
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 801441c:	e9c4 c004 	strd	ip, r0, [r4, #16]
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
 8014420:	4620      	mov	r0, r4
    hdma_sai1_b.Init.MemBurst = DMA_MBURST_SINGLE;
 8014422:	e9c4 660a 	strd	r6, r6, [r4, #40]	; 0x28
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
 8014426:	e9c4 7106 	strd	r7, r1, [r4, #24]
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 801442a:	e9c4 2308 	strd	r2, r3, [r4, #32]
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
 801442e:	f7ee f92f 	bl	8002690 <HAL_DMA_Init>
 8014432:	2800      	cmp	r0, #0
 8014434:	d162      	bne.n	80144fc <HAL_SAI_MspInit+0x148>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
 8014436:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
 801443a:	63a5      	str	r5, [r4, #56]	; 0x38
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
 801443c:	f8c5 4080 	str.w	r4, [r5, #128]	; 0x80
}
 8014440:	b008      	add	sp, #32
 8014442:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (SAI1_client == 0)
 8014446:	4c3d      	ldr	r4, [pc, #244]	; (801453c <HAL_SAI_MspInit+0x188>)
 8014448:	6822      	ldr	r2, [r4, #0]
 801444a:	2a00      	cmp	r2, #0
 801444c:	d05c      	beq.n	8014508 <HAL_SAI_MspInit+0x154>
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5;
 801444e:	2024      	movs	r0, #36	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014450:	2600      	movs	r6, #0
    SAI1_client ++;
 8014452:	3201      	adds	r2, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8014454:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8014456:	2303      	movs	r3, #3
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 8014458:	f04f 0806 	mov.w	r8, #6
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 801445c:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5;
 801445e:	9003      	str	r0, [sp, #12]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8014460:	4837      	ldr	r0, [pc, #220]	; (8014540 <HAL_SAI_MspInit+0x18c>)
    SAI1_client ++;
 8014462:	6022      	str	r2, [r4, #0]
    hdma_sai1_a.Instance = DMA1_Stream1;
 8014464:	4c39      	ldr	r4, [pc, #228]	; (801454c <HAL_SAI_MspInit+0x198>)
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 8014466:	e9cd 3806 	strd	r3, r8, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801446a:	e9cd 7604 	strd	r7, r6, [sp, #16]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 801446e:	f7f0 fea7 	bl	80051c0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6;
 8014472:	2350      	movs	r3, #80	; 0x50
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8014474:	a903      	add	r1, sp, #12
 8014476:	4832      	ldr	r0, [pc, #200]	; (8014540 <HAL_SAI_MspInit+0x18c>)
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6;
 8014478:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 801447a:	e9cd 7806 	strd	r7, r8, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801447e:	e9cd 7604 	strd	r7, r6, [sp, #16]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8014482:	f7f0 fe9d 	bl	80051c0 <HAL_GPIO_Init>
    hdma_sai1_a.Instance = DMA1_Stream1;
 8014486:	4b32      	ldr	r3, [pc, #200]	; (8014550 <HAL_SAI_MspInit+0x19c>)
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8014488:	2040      	movs	r0, #64	; 0x40
    hdma_sai1_a.Init.Request = DMA_REQUEST_SAI1_A;
 801448a:	f04f 0857 	mov.w	r8, #87	; 0x57
    hdma_sai1_a.Init.MemInc = DMA_MINC_ENABLE;
 801448e:	f44f 6e80 	mov.w	lr, #1024	; 0x400
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8014492:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    hdma_sai1_a.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8014496:	f44f 4780 	mov.w	r7, #16384	; 0x4000
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
 801449a:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_sai1_a.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 801449e:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_sai1_a.Instance = DMA1_Stream1;
 80144a2:	6023      	str	r3, [r4, #0]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80144a4:	2304      	movs	r3, #4
    hdma_sai1_a.Init.PeriphInc = DMA_PINC_DISABLE;
 80144a6:	60e6      	str	r6, [r4, #12]
    hdma_sai1_a.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
 80144a8:	62a6      	str	r6, [r4, #40]	; 0x28
    hdma_sai1_a.Init.MemBurst = DMA_MBURST_SINGLE;
 80144aa:	62e6      	str	r6, [r4, #44]	; 0x2c
    hdma_sai1_a.Init.PeriphBurst = DMA_PBURST_SINGLE;
 80144ac:	6326      	str	r6, [r4, #48]	; 0x30
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80144ae:	e9c4 8001 	strd	r8, r0, [r4, #4]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
 80144b2:	4620      	mov	r0, r4
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 80144b4:	e9c4 ec04 	strd	lr, ip, [r4, #16]
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
 80144b8:	e9c4 7106 	strd	r7, r1, [r4, #24]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80144bc:	e9c4 2308 	strd	r2, r3, [r4, #32]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
 80144c0:	f7ee f8e6 	bl	8002690 <HAL_DMA_Init>
 80144c4:	b9e8      	cbnz	r0, 8014502 <HAL_SAI_MspInit+0x14e>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
 80144c6:	63a5      	str	r5, [r4, #56]	; 0x38
 80144c8:	682b      	ldr	r3, [r5, #0]
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
 80144ca:	e9c5 4420 	strd	r4, r4, [r5, #128]	; 0x80
 80144ce:	e779      	b.n	80143c4 <HAL_SAI_MspInit+0x10>
       __HAL_RCC_SAI1_CLK_ENABLE();
 80144d0:	4b20      	ldr	r3, [pc, #128]	; (8014554 <HAL_SAI_MspInit+0x1a0>)
      HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
 80144d2:	2102      	movs	r1, #2
 80144d4:	2057      	movs	r0, #87	; 0x57
       __HAL_RCC_SAI1_CLK_ENABLE();
 80144d6:	f8d3 60f0 	ldr.w	r6, [r3, #240]	; 0xf0
 80144da:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
 80144de:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
 80144e2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80144e6:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80144ea:	9302      	str	r3, [sp, #8]
 80144ec:	9b02      	ldr	r3, [sp, #8]
      HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
 80144ee:	f7ed ff03 	bl	80022f8 <HAL_NVIC_SetPriority>
      HAL_NVIC_EnableIRQ(SAI1_IRQn);
 80144f2:	2057      	movs	r0, #87	; 0x57
 80144f4:	f7ed ff46 	bl	8002384 <HAL_NVIC_EnableIRQ>
 80144f8:	6822      	ldr	r2, [r4, #0]
 80144fa:	e76d      	b.n	80143d8 <HAL_SAI_MspInit+0x24>
      Error_Handler();
 80144fc:	f7ff f9e6 	bl	80138cc <Error_Handler>
 8014500:	e799      	b.n	8014436 <HAL_SAI_MspInit+0x82>
      Error_Handler();
 8014502:	f7ff f9e3 	bl	80138cc <Error_Handler>
 8014506:	e7de      	b.n	80144c6 <HAL_SAI_MspInit+0x112>
       __HAL_RCC_SAI1_CLK_ENABLE();
 8014508:	4b12      	ldr	r3, [pc, #72]	; (8014554 <HAL_SAI_MspInit+0x1a0>)
    HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
 801450a:	2102      	movs	r1, #2
 801450c:	2057      	movs	r0, #87	; 0x57
       __HAL_RCC_SAI1_CLK_ENABLE();
 801450e:	f8d3 60f0 	ldr.w	r6, [r3, #240]	; 0xf0
 8014512:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
 8014516:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
 801451a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 801451e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8014522:	9301      	str	r3, [sp, #4]
 8014524:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
 8014526:	f7ed fee7 	bl	80022f8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SAI1_IRQn);
 801452a:	2057      	movs	r0, #87	; 0x57
 801452c:	f7ed ff2a 	bl	8002384 <HAL_NVIC_EnableIRQ>
 8014530:	6822      	ldr	r2, [r4, #0]
 8014532:	e78c      	b.n	801444e <HAL_SAI_MspInit+0x9a>
 8014534:	40015804 	.word	0x40015804
 8014538:	40015824 	.word	0x40015824
 801453c:	2000051c 	.word	0x2000051c
 8014540:	58021000 	.word	0x58021000
 8014544:	20001d60 	.word	0x20001d60
 8014548:	40020040 	.word	0x40020040
 801454c:	20001ce8 	.word	0x20001ce8
 8014550:	40020028 	.word	0x40020028
 8014554:	58024400 	.word	0x58024400

08014558 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 8014558:	b538      	push	{r3, r4, r5, lr}
Stat = STA_NOINIT;  
 801455a:	4c0a      	ldr	r4, [pc, #40]	; (8014584 <SD_initialize+0x2c>)
 801455c:	2501      	movs	r5, #1
 801455e:	7025      	strb	r5, [r4, #0]

#if !defined(DISABLE_SD_INIT)

  if(BSP_SD_Init() == MSD_OK)
 8014560:	f7fd f8b4 	bl	80116cc <BSP_SD_Init>
 8014564:	b108      	cbz	r0, 801456a <SD_initialize+0x12>

#else
  Stat = SD_CheckStatus(lun);
#endif

  return Stat;
 8014566:	7820      	ldrb	r0, [r4, #0]
}
 8014568:	bd38      	pop	{r3, r4, r5, pc}
  Stat = STA_NOINIT;
 801456a:	7025      	strb	r5, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
 801456c:	f7fd f88e 	bl	801168c <BSP_SD_GetCardState>
 8014570:	b918      	cbnz	r0, 801457a <SD_initialize+0x22>
    Stat &= ~STA_NOINIT;
 8014572:	7823      	ldrb	r3, [r4, #0]
 8014574:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8014578:	7023      	strb	r3, [r4, #0]
  return Stat;
 801457a:	7823      	ldrb	r3, [r4, #0]
 801457c:	b2db      	uxtb	r3, r3
    Stat = SD_CheckStatus(lun);
 801457e:	7023      	strb	r3, [r4, #0]
  return Stat;
 8014580:	7820      	ldrb	r0, [r4, #0]
}
 8014582:	bd38      	pop	{r3, r4, r5, pc}
 8014584:	2000003c 	.word	0x2000003c

08014588 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 8014588:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 801458a:	2301      	movs	r3, #1
 801458c:	4c05      	ldr	r4, [pc, #20]	; (80145a4 <SD_status+0x1c>)
 801458e:	7023      	strb	r3, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
 8014590:	f7fd f87c 	bl	801168c <BSP_SD_GetCardState>
 8014594:	b918      	cbnz	r0, 801459e <SD_status+0x16>
    Stat &= ~STA_NOINIT;
 8014596:	7823      	ldrb	r3, [r4, #0]
 8014598:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 801459c:	7023      	strb	r3, [r4, #0]
  return Stat;
 801459e:	7820      	ldrb	r0, [r4, #0]
  return SD_CheckStatus(lun);
}
 80145a0:	bd10      	pop	{r4, pc}
 80145a2:	bf00      	nop
 80145a4:	2000003c 	.word	0x2000003c

080145a8 <SD_read>:
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
              
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 80145a8:	b508      	push	{r3, lr}
 80145aa:	4608      	mov	r0, r1
 80145ac:	4611      	mov	r1, r2
 80145ae:	461a      	mov	r2, r3
  DRESULT res = RES_ERROR;

  if(BSP_SD_ReadBlocks((uint32_t*)buff,
 80145b0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80145b4:	f7fd f846 	bl	8011644 <BSP_SD_ReadBlocks>
 80145b8:	b920      	cbnz	r0, 80145c4 <SD_read+0x1c>
                       (uint32_t) (sector),
                       count, SD_TIMEOUT) == MSD_OK)
  {
    /* wait until the read operation is finished */
    while(BSP_SD_GetCardState()!= MSD_OK)
 80145ba:	f7fd f867 	bl	801168c <BSP_SD_GetCardState>
 80145be:	2800      	cmp	r0, #0
 80145c0:	d1fb      	bne.n	80145ba <SD_read+0x12>
    }
    res = RES_OK;
  }

  return res;
}
 80145c2:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
 80145c4:	2001      	movs	r0, #1
}
 80145c6:	bd08      	pop	{r3, pc}

080145c8 <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
 80145c8:	4b16      	ldr	r3, [pc, #88]	; (8014624 <SD_ioctl+0x5c>)
 80145ca:	781b      	ldrb	r3, [r3, #0]
 80145cc:	07db      	lsls	r3, r3, #31
 80145ce:	d408      	bmi.n	80145e2 <SD_ioctl+0x1a>
{
 80145d0:	b510      	push	{r4, lr}
 80145d2:	4614      	mov	r4, r2
 80145d4:	b08a      	sub	sp, #40	; 0x28

  switch (cmd)
 80145d6:	2903      	cmp	r1, #3
 80145d8:	d821      	bhi.n	801461e <SD_ioctl+0x56>
 80145da:	e8df f001 	tbb	[pc, r1]
 80145de:	0704      	.short	0x0704
 80145e0:	170f      	.short	0x170f
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 80145e2:	2003      	movs	r0, #3
  default:
    res = RES_PARERR;
  }

  return res;
}
 80145e4:	4770      	bx	lr
    res = RES_OK;
 80145e6:	2000      	movs	r0, #0
}
 80145e8:	b00a      	add	sp, #40	; 0x28
 80145ea:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 80145ec:	a801      	add	r0, sp, #4
 80145ee:	f7fd f857 	bl	80116a0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 80145f2:	9b07      	ldr	r3, [sp, #28]
    res = RES_OK;
 80145f4:	2000      	movs	r0, #0
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 80145f6:	6023      	str	r3, [r4, #0]
}
 80145f8:	b00a      	add	sp, #40	; 0x28
 80145fa:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 80145fc:	a801      	add	r0, sp, #4
 80145fe:	f7fd f84f 	bl	80116a0 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
 8014602:	9b08      	ldr	r3, [sp, #32]
    res = RES_OK;
 8014604:	2000      	movs	r0, #0
    *(WORD*)buff = CardInfo.LogBlockSize;
 8014606:	8023      	strh	r3, [r4, #0]
}
 8014608:	b00a      	add	sp, #40	; 0x28
 801460a:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 801460c:	a801      	add	r0, sp, #4
 801460e:	f7fd f847 	bl	80116a0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 8014612:	9b08      	ldr	r3, [sp, #32]
 8014614:	2000      	movs	r0, #0
 8014616:	0a5b      	lsrs	r3, r3, #9
 8014618:	6023      	str	r3, [r4, #0]
}
 801461a:	b00a      	add	sp, #40	; 0x28
 801461c:	bd10      	pop	{r4, pc}
    res = RES_PARERR;
 801461e:	2004      	movs	r0, #4
}
 8014620:	b00a      	add	sp, #40	; 0x28
 8014622:	bd10      	pop	{r4, pc}
 8014624:	2000003c 	.word	0x2000003c

08014628 <SD_write>:
{
 8014628:	b508      	push	{r3, lr}
 801462a:	4608      	mov	r0, r1
 801462c:	4611      	mov	r1, r2
 801462e:	461a      	mov	r2, r3
  if(BSP_SD_WriteBlocks((uint32_t*)buff,
 8014630:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8014634:	f7fd f818 	bl	8011668 <BSP_SD_WriteBlocks>
 8014638:	b920      	cbnz	r0, 8014644 <SD_write+0x1c>
    while(BSP_SD_GetCardState()!= MSD_OK)
 801463a:	f7fd f827 	bl	801168c <BSP_SD_GetCardState>
 801463e:	2800      	cmp	r0, #0
 8014640:	d1fb      	bne.n	801463a <SD_write+0x12>
}
 8014642:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
 8014644:	2001      	movs	r0, #1
}
 8014646:	bd08      	pop	{r3, pc}

08014648 <MX_SDMMC1_SD_Init>:
SD_HandleTypeDef hsd1;

/* SDMMC1 init function */

void MX_SDMMC1_SD_Init(void)
{
 8014648:	b410      	push	{r4}

  hsd1.Instance = SDMMC1;
 801464a:	4b08      	ldr	r3, [pc, #32]	; (801466c <MX_SDMMC1_SD_Init+0x24>)
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
 801464c:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  hsd1.Instance = SDMMC1;
 8014650:	4807      	ldr	r0, [pc, #28]	; (8014670 <MX_SDMMC1_SD_Init+0x28>)
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
  hsd1.Init.ClockDiv = 0;
  hsd1.Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
 8014652:	2101      	movs	r1, #1
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
 8014654:	2200      	movs	r2, #0
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
 8014656:	60dc      	str	r4, [r3, #12]
  hsd1.Instance = SDMMC1;
 8014658:	6018      	str	r0, [r3, #0]
  hsd1.Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
 801465a:	6199      	str	r1, [r3, #24]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 801465c:	e9c3 2201 	strd	r2, r2, [r3, #4]
  hsd1.Init.ClockDiv = 0;
 8014660:	e9c3 2204 	strd	r2, r2, [r3, #16]

}
 8014664:	f85d 4b04 	ldr.w	r4, [sp], #4
 8014668:	4770      	bx	lr
 801466a:	bf00      	nop
 801466c:	20001e70 	.word	0x20001e70
 8014670:	52007000 	.word	0x52007000

08014674 <HAL_SD_MspInit>:

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
 8014674:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(sdHandle->Instance==SDMMC1)
 8014678:	4b2e      	ldr	r3, [pc, #184]	; (8014734 <HAL_SD_MspInit+0xc0>)
{
 801467a:	b088      	sub	sp, #32
  if(sdHandle->Instance==SDMMC1)
 801467c:	6802      	ldr	r2, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801467e:	2400      	movs	r4, #0
  if(sdHandle->Instance==SDMMC1)
 8014680:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8014682:	9407      	str	r4, [sp, #28]
 8014684:	e9cd 4403 	strd	r4, r4, [sp, #12]
 8014688:	e9cd 4405 	strd	r4, r4, [sp, #20]
  if(sdHandle->Instance==SDMMC1)
 801468c:	d002      	beq.n	8014694 <HAL_SD_MspInit+0x20>

  /* USER CODE BEGIN SDMMC1_MspInit 1 */

  /* USER CODE END SDMMC1_MspInit 1 */
  }
}
 801468e:	b008      	add	sp, #32
 8014690:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8014694:	4b28      	ldr	r3, [pc, #160]	; (8014738 <HAL_SD_MspInit+0xc4>)
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
 8014696:	250c      	movs	r5, #12
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
 8014698:	f44f 6070 	mov.w	r0, #3840	; 0xf00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801469c:	2702      	movs	r7, #2
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 801469e:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80146a2:	2603      	movs	r6, #3
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80146a4:	f04f 0801 	mov.w	r8, #1
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80146a8:	eb0d 0105 	add.w	r1, sp, r5
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 80146ac:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80146b0:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
 80146b4:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 80146b8:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
 80146bc:	9200      	str	r2, [sp, #0]
 80146be:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80146c0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80146c4:	f042 0204 	orr.w	r2, r2, #4
 80146c8:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 80146cc:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80146d0:	f002 0204 	and.w	r2, r2, #4
 80146d4:	9201      	str	r2, [sp, #4]
 80146d6:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80146d8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80146dc:	f042 0208 	orr.w	r2, r2, #8
 80146e0:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 80146e4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
 80146e8:	9003      	str	r0, [sp, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80146ea:	f003 0308 	and.w	r3, r3, #8
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80146ee:	4813      	ldr	r0, [pc, #76]	; (801473c <HAL_SD_MspInit+0xc8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80146f0:	9704      	str	r7, [sp, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80146f2:	9302      	str	r3, [sp, #8]
 80146f4:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
 80146f6:	9507      	str	r5, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80146f8:	e9cd 8605 	strd	r8, r6, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80146fc:	f7f0 fd60 	bl	80051c0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 8014700:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8014704:	eb0d 0105 	add.w	r1, sp, r5
 8014708:	480c      	ldr	r0, [pc, #48]	; (801473c <HAL_SD_MspInit+0xc8>)
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 801470a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801470c:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801470e:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
 8014710:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8014714:	f7f0 fd54 	bl	80051c0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8014718:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 801471a:	eb0d 0105 	add.w	r1, sp, r5
 801471e:	4808      	ldr	r0, [pc, #32]	; (8014740 <HAL_SD_MspInit+0xcc>)
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8014720:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8014722:	e9cd 7804 	strd	r7, r8, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
 8014726:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 801472a:	f7f0 fd49 	bl	80051c0 <HAL_GPIO_Init>
}
 801472e:	b008      	add	sp, #32
 8014730:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8014734:	52007000 	.word	0x52007000
 8014738:	58024400 	.word	0x58024400
 801473c:	58020800 	.word	0x58020800
 8014740:	58020c00 	.word	0x58020c00

08014744 <initGlobalSFXObjects>:
        float oversamplerArray[MAX_OVERSAMPLER_RATIO];



        void initGlobalSFXObjects()
        {
 8014744:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        void calculateNoteArray()
        {
            for (int i = 0; i < 128; i++)
            {
                float tempNote = i;
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8014748:	4beb      	ldr	r3, [pc, #940]	; (8014af8 <initGlobalSFXObjects+0x3b4>)
            for (int i = 0; i < 128; i++)
 801474a:	2000      	movs	r0, #0
 801474c:	4ceb      	ldr	r4, [pc, #940]	; (8014afc <initGlobalSFXObjects+0x3b8>)
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801474e:	781f      	ldrb	r7, [r3, #0]
 8014750:	4eeb      	ldr	r6, [pc, #940]	; (8014b00 <initGlobalSFXObjects+0x3bc>)
 8014752:	4dec      	ldr	r5, [pc, #944]	; (8014b04 <initGlobalSFXObjects+0x3c0>)
                float tempNote = i;
 8014754:	ee07 0a90 	vmov	s15, r0
            for (int i = 0; i < 128; i++)
 8014758:	3001      	adds	r0, #1
                float tempNote = i;
 801475a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            for (int i = 0; i < 128; i++)
 801475e:	2880      	cmp	r0, #128	; 0x80
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8014760:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8014764:	ee17 3a90 	vmov	r3, s15
 8014768:	eba3 0307 	sub.w	r3, r3, r7
 801476c:	fb85 2103 	smull	r2, r1, r5, r3
 8014770:	ea4f 72e3 	mov.w	r2, r3, asr #31
 8014774:	ebc2 0261 	rsb	r2, r2, r1, asr #1
 8014778:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 801477c:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 8014780:	ee07 3a90 	vmov	s15, r3
 8014784:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8014788:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801478c:	ee17 3a90 	vmov	r3, s15
 8014790:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8014794:	edd3 7a00 	vldr	s15, [r3]
 8014798:	ee37 7a87 	vadd.f32	s14, s15, s14
                notes[i] = tunedNote;
 801479c:	eca4 7a01 	vstmia	r4!, {s14}
            for (int i = 0; i < 128; i++)
 80147a0:	d1d8      	bne.n	8014754 <initGlobalSFXObjects+0x10>
 80147a2:	4cd9      	ldr	r4, [pc, #868]	; (8014b08 <initGlobalSFXObjects+0x3c4>)
            tSimplePoly_init(&poly, NUM_VOC_VOICES);
 80147a4:	2108      	movs	r1, #8
 80147a6:	48d9      	ldr	r0, [pc, #868]	; (8014b0c <initGlobalSFXObjects+0x3c8>)
                tExpSmooth_init(&polyRamp[i], 0.0f, 0.02f);
 80147a8:	2600      	movs	r6, #0
 80147aa:	f8df a3ac 	ldr.w	sl, [pc, #940]	; 8014b58 <initGlobalSFXObjects+0x414>
 80147ae:	f104 0520 	add.w	r5, r4, #32
            tSimplePoly_init(&poly, NUM_VOC_VOICES);
 80147b2:	f00f ff77 	bl	80246a4 <tSimplePoly_init>
                tExpSmooth_init(&polyRamp[i], 0.0f, 0.02f);
 80147b6:	4620      	mov	r0, r4
 80147b8:	3404      	adds	r4, #4
 80147ba:	eddf 0ad5 	vldr	s1, [pc, #852]	; 8014b10 <initGlobalSFXObjects+0x3cc>
 80147be:	ed9f 0ad5 	vldr	s0, [pc, #852]	; 8014b14 <initGlobalSFXObjects+0x3d0>
 80147c2:	f00d fe77 	bl	80224b4 <tExpSmooth_init>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 80147c6:	42a5      	cmp	r5, r4
 80147c8:	d1f5      	bne.n	80147b6 <initGlobalSFXObjects+0x72>
            tExpSmooth_init(&comp, 1.0f, 0.01f);
 80147ca:	eddf 0ad3 	vldr	s1, [pc, #844]	; 8014b18 <initGlobalSFXObjects+0x3d4>
 80147ce:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80147d2:	48d2      	ldr	r0, [pc, #840]	; (8014b1c <initGlobalSFXObjects+0x3d8>)
            defaultPresetKnobValues[VocoderCh][2] = 1.0f; // quality
 80147d4:	f04f 547e 	mov.w	r4, #1065353216	; 0x3f800000
            tExpSmooth_init(&comp, 1.0f, 0.01f);
 80147d8:	f00d fe6c 	bl	80224b4 <tExpSmooth_init>
            LEAF_generate_exp(expBuffer, 1000.0f, -1.0f, 0.0f, -0.0008f, EXP_BUFFER_SIZE); //exponential buffer rising from 0 to 1
 80147dc:	2180      	movs	r1, #128	; 0x80
 80147de:	eddf 1ad0 	vldr	s3, [pc, #832]	; 8014b20 <initGlobalSFXObjects+0x3dc>
 80147e2:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 80147e6:	ed9f 1acb 	vldr	s2, [pc, #812]	; 8014b14 <initGlobalSFXObjects+0x3d0>
 80147ea:	ed9f 0ace 	vldr	s0, [pc, #824]	; 8014b24 <initGlobalSFXObjects+0x3e0>
 80147ee:	48ce      	ldr	r0, [pc, #824]	; (8014b28 <initGlobalSFXObjects+0x3e4>)
 80147f0:	f00f fbd6 	bl	8023fa0 <LEAF_generate_exp>
            LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE); // exponential decay buffer falling from 1 to 0
 80147f4:	f44f 7100 	mov.w	r1, #512	; 0x200
 80147f8:	48cc      	ldr	r0, [pc, #816]	; (8014b2c <initGlobalSFXObjects+0x3e8>)
 80147fa:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 80147fe:	eddf 1ac8 	vldr	s3, [pc, #800]	; 8014b20 <initGlobalSFXObjects+0x3dc>
 8014802:	eddf 0ac4 	vldr	s1, [pc, #784]	; 8014b14 <initGlobalSFXObjects+0x3d0>
 8014806:	ed9f 0aca 	vldr	s0, [pc, #808]	; 8014b30 <initGlobalSFXObjects+0x3ec>
 801480a:	f00f fbc9 	bl	8023fa0 <LEAF_generate_exp>
            defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
 801480e:	4bc9      	ldr	r3, [pc, #804]	; (8014b34 <initGlobalSFXObjects+0x3f0>)
            defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
 8014810:	48c9      	ldr	r0, [pc, #804]	; (8014b38 <initGlobalSFXObjects+0x3f4>)
            defaultPresetKnobValues[Vocoder][1] = 0.5f; // warp factor
 8014812:	f04f 527c 	mov.w	r2, #1056964608	; 0x3f000000
            defaultPresetKnobValues[Pitchshift][5] = 0.25f; //offset
 8014816:	f04f 517a 	mov.w	r1, #1048576000	; 0x3e800000
            defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
 801481a:	4fc8      	ldr	r7, [pc, #800]	; (8014b3c <initGlobalSFXObjects+0x3f8>)
            defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
 801481c:	f8df c33c 	ldr.w	ip, [pc, #828]	; 8014b5c <initGlobalSFXObjects+0x418>
            defaultPresetKnobValues[SamplerButtonPress][2] = 0.75f; // speed
 8014820:	f04f 5e7d 	mov.w	lr, #1061158912	; 0x3f400000
            defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
 8014824:	f8df 8338 	ldr.w	r8, [pc, #824]	; 8014b60 <initGlobalSFXObjects+0x41c>
            defaultPresetKnobValues[Delay][0] = 0.25f; // delayL
 8014828:	f203 494c 	addw	r9, r3, #1100	; 0x44c
            defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
 801482c:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
            defaultPresetKnobValues[Delay][1] = 0.25f; // delayR
 8014830:	f503 6b8a 	add.w	fp, r3, #1104	; 0x450
            defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
 8014834:	48c2      	ldr	r0, [pc, #776]	; (8014b40 <initGlobalSFXObjects+0x3fc>)
            defaultPresetKnobValues[Vocoder][5] = 0.02f; // breathiness
 8014836:	f8c3 a014 	str.w	sl, [r3, #20]
            defaultPresetKnobValues[Delay][3] = 1.0f; // lowpass
 801483a:	f503 6a8b 	add.w	sl, r3, #1112	; 0x458
            defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
 801483e:	601f      	str	r7, [r3, #0]
            defaultPresetKnobValues[VocoderCh][0] = 0.4f; // volume
 8014840:	665f      	str	r7, [r3, #100]	; 0x64
            defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
 8014842:	f8c3 8008 	str.w	r8, [r3, #8]
            defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
 8014846:	f8c3 c010 	str.w	ip, [r3, #16]
            defaultPresetKnobValues[VocoderCh][4] = 0.2f; //noise thresh
 801484a:	f8c3 c074 	str.w	ip, [r3, #116]	; 0x74
            defaultPresetKnobValues[VocoderCh][2] = 1.0f; // quality
 801484e:	66dc      	str	r4, [r3, #108]	; 0x6c
            defaultPresetKnobValues[Pitchshift][5] = 0.25f; //offset
 8014850:	f8c3 10dc 	str.w	r1, [r3, #220]	; 0xdc
            defaultPresetKnobValues[Pitchshift][6] = 0.25f;
 8014854:	f8c3 10e0 	str.w	r1, [r3, #224]	; 0xe0
            defaultPresetKnobValues[Vocoder][3] = 0.0f; // sawToPulse
 8014858:	60de      	str	r6, [r3, #12]
            defaultPresetKnobValues[Vocoder][9] = 0.0f;
 801485a:	625e      	str	r6, [r3, #36]	; 0x24
            defaultPresetKnobValues[VocoderCh][5] = 0.0f;// saw->pulse fade
 801485c:	679e      	str	r6, [r3, #120]	; 0x78
            defaultPresetKnobValues[VocoderCh][8] = 0.0f; // breathiness
 801485e:	f8c3 6084 	str.w	r6, [r3, #132]	; 0x84
            defaultPresetKnobValues[VocoderCh][13] = 0.0f; // stereo
 8014862:	f8c3 6098 	str.w	r6, [r3, #152]	; 0x98
            defaultPresetKnobValues[VocoderCh][14] = 0.0f; // barkpull
 8014866:	f8c3 609c 	str.w	r6, [r3, #156]	; 0x9c
            defaultPresetKnobValues[Pitchshift][2] = 0.0f; // f amount
 801486a:	f8c3 60d0 	str.w	r6, [r3, #208]	; 0xd0
            defaultPresetKnobValues[Vocoder][1] = 0.5f; // warp factor
 801486e:	605a      	str	r2, [r3, #4]
            defaultPresetKnobValues[Vocoder][6] = 0.5f; // tilt
 8014870:	619a      	str	r2, [r3, #24]
            defaultPresetKnobValues[Vocoder][7] = 0.5f; // pulse width
 8014872:	61da      	str	r2, [r3, #28]
            defaultPresetKnobValues[Vocoder][8] = 0.5f; // pulse shape
 8014874:	621a      	str	r2, [r3, #32]
            defaultPresetKnobValues[VocoderCh][1] = 0.5f; // warp factor
 8014876:	669a      	str	r2, [r3, #104]	; 0x68
            defaultPresetKnobValues[VocoderCh][3] = 0.5f; //band width
 8014878:	671a      	str	r2, [r3, #112]	; 0x70
            defaultPresetKnobValues[VocoderCh][6] = 0.5f; // pulse length
 801487a:	67da      	str	r2, [r3, #124]	; 0x7c
            defaultPresetKnobValues[VocoderCh][7] = 0.5f; // pulse width
 801487c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
            defaultPresetKnobValues[VocoderCh][10] = 0.5f;// squish
 8014880:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            defaultPresetKnobValues[VocoderCh][11] = 0.5f; // offset
 8014884:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
            defaultPresetKnobValues[VocoderCh][12] = 0.5f; // tilt
 8014888:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
            defaultPresetKnobValues[Pitchshift][0] = 0.5f; // pitch
 801488c:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
            defaultPresetKnobValues[Pitchshift][1] = 0.5f; // fine pitch
 8014890:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
            defaultPresetKnobValues[Pitchshift][3] = 0.5f; // formant
 8014894:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
            defaultPresetKnobValues[Pitchshift][4] = 0.5f; //range
 8014898:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
            defaultPresetKnobValues[Pitchshift][7] = 0.25f;
 801489c:	f8c3 10e4 	str.w	r1, [r3, #228]	; 0xe4
            defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
 80148a0:	f8c3 02bc 	str.w	r0, [r3, #700]	; 0x2bc
            defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
 80148a4:	48a7      	ldr	r0, [pc, #668]	; (8014b44 <initGlobalSFXObjects+0x400>)
            defaultPresetKnobValues[Pitchshift][8] = 0.25f;
 80148a6:	f8c3 10e8 	str.w	r1, [r3, #232]	; 0xe8
            defaultPresetKnobValues[Pitchshift][9] = 0.25f;
 80148aa:	f8c3 10ec 	str.w	r1, [r3, #236]	; 0xec
            defaultPresetKnobValues[AutotuneMono][1] = 1.0f; // amount
 80148ae:	f8c3 4130 	str.w	r4, [r3, #304]	; 0x130
            defaultPresetKnobValues[AutotuneMono][3] = 1.0f; // leap allow
 80148b2:	f8c3 4138 	str.w	r4, [r3, #312]	; 0x138
            defaultPresetKnobValues[AutotuneMono][4] = 0.25f; // hysteresis
 80148b6:	f8c3 113c 	str.w	r1, [r3, #316]	; 0x13c
            defaultPresetKnobValues[AutotunePoly][0] = 1.0f; // fidelity thresh
 80148ba:	f8c3 4190 	str.w	r4, [r3, #400]	; 0x190
            defaultPresetKnobValues[SamplerButtonPress][1] = 1.0f; // end
 80148be:	f8c3 41f8 	str.w	r4, [r3, #504]	; 0x1f8
            defaultPresetKnobValues[SamplerButtonPress][4] = 0.4f;//crossfade
 80148c2:	f8c3 7204 	str.w	r7, [r3, #516]	; 0x204
            defaultPresetKnobValues[SamplerKeyboard][1] = 1.0f; // end
 80148c6:	f8c3 425c 	str.w	r4, [r3, #604]	; 0x25c
            defaultPresetKnobValues[SamplerKeyboard][5] = 0.4f;//crossfade
 80148ca:	f8c3 726c 	str.w	r7, [r3, #620]	; 0x26c
            defaultPresetKnobValues[SamplerAutoGrab][3] = 0.25f; // crossfade
 80148ce:	f8c3 12c8 	str.w	r1, [r3, #712]	; 0x2c8
            defaultPresetKnobValues[SamplerButtonPress][2] = 0.75f; // speed
 80148d2:	f8c3 e1fc 	str.w	lr, [r3, #508]	; 0x1fc
            defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
 80148d6:	f8c3 0198 	str.w	r0, [r3, #408]	; 0x198
            defaultPresetKnobValues[SamplerKeyboard][2] = 0.75f; // speed
 80148da:	f8c3 e260 	str.w	lr, [r3, #608]	; 0x260
            defaultPresetKnobValues[SamplerAutoGrab][2] = 0.75f; // speed
 80148de:	f8c3 e2c4 	str.w	lr, [r3, #708]	; 0x2c4
            defaultPresetKnobValues[AutotuneMono][0] = 0.0f; // pickiness
 80148e2:	f8c3 612c 	str.w	r6, [r3, #300]	; 0x12c
            defaultPresetKnobValues[AutotuneMono][2] = 0.5f; // speed
 80148e6:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
            defaultPresetKnobValues[AutotunePoly][1] = 0.5f;
 80148ea:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
            defaultPresetKnobValues[AutotunePoly][3] = 0.0f;
 80148ee:	f8c3 619c 	str.w	r6, [r3, #412]	; 0x19c
            defaultPresetKnobValues[AutotunePoly][4] = 0.0f;
 80148f2:	f8c3 61a0 	str.w	r6, [r3, #416]	; 0x1a0
            defaultPresetKnobValues[SamplerButtonPress][0] = 0.0f; // start
 80148f6:	f8c3 61f4 	str.w	r6, [r3, #500]	; 0x1f4
            defaultPresetKnobValues[SamplerButtonPress][3] = 0.5f; // speed mult
 80148fa:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            defaultPresetKnobValues[SamplerKeyboard][0] = 0.0f; // start
 80148fe:	f8c3 6258 	str.w	r6, [r3, #600]	; 0x258
            defaultPresetKnobValues[SamplerKeyboard][3] = 0.5f; // speed mult
 8014902:	f8c3 2264 	str.w	r2, [r3, #612]	; 0x264
            defaultPresetKnobValues[SamplerKeyboard][4] = 0.0f; //looping on
 8014906:	f8c3 6268 	str.w	r6, [r3, #616]	; 0x268
            defaultPresetKnobValues[SamplerKeyboard][6] = 0.0f;//velocity sensitivity
 801490a:	f8c3 6270 	str.w	r6, [r3, #624]	; 0x270
            defaultPresetKnobValues[SamplerAutoGrab][1] = 0.5f; // window
 801490e:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0
            defaultPresetKnobValues[SamplerAutoGrab][4] = 0.0f;
 8014912:	f8c3 62cc 	str.w	r6, [r3, #716]	; 0x2cc
            defaultPresetKnobValues[SamplerAutoGrab][5] = 0.0f; // len rand
 8014916:	f8c3 62d0 	str.w	r6, [r3, #720]	; 0x2d0
            defaultPresetKnobValues[SamplerAutoGrab][6] = 0.0f; // speed rand
 801491a:	f8c3 62d4 	str.w	r6, [r3, #724]	; 0x2d4
            defaultPresetKnobValues[SamplerAutoGrab][7] = 0.0f;
 801491e:	f8c3 62d8 	str.w	r6, [r3, #728]	; 0x2d8
            defaultPresetKnobValues[SamplerAutoGrab][8] = 0.0f;
 8014922:	f8c3 62dc 	str.w	r6, [r3, #732]	; 0x2dc
            defaultPresetKnobValues[Delay][0] = 0.25f; // delayL
 8014926:	f8c9 1000 	str.w	r1, [r9]
            defaultPresetKnobValues[Delay][4] = 0.5f; // feedback
 801492a:	f203 495c 	addw	r9, r3, #1116	; 0x45c
            defaultPresetKnobValues[Delay][3] = 1.0f; // lowpass
 801492e:	f8ca 4000 	str.w	r4, [sl]
            defaultPresetKnobValues[Reverb][1] = 0.5f; // in lowpass
 8014932:	f203 4ab4 	addw	sl, r3, #1204	; 0x4b4
            defaultPresetKnobValues[Wavefolder][3] = 0.75f; // post gain
 8014936:	f8c3 e390 	str.w	lr, [r3, #912]	; 0x390
            defaultPresetKnobValues[Delay][5] = 1.0f; // post gain
 801493a:	f503 6e8c 	add.w	lr, r3, #1120	; 0x460
            defaultPresetKnobValues[Delay][1] = 0.25f; // delayR
 801493e:	f8cb 1000 	str.w	r1, [fp]
            defaultPresetKnobValues[Reverb][0] = 0.5f; // size
 8014942:	f503 6b96 	add.w	fp, r3, #1200	; 0x4b0
            defaultPresetKnobValues[Delay][5] = 1.0f; // post gain
 8014946:	f8ce 4000 	str.w	r4, [lr]
            defaultPresetKnobValues[Reverb][3] = 0.5f; // fb lowpass
 801494a:	f203 4ebc 	addw	lr, r3, #1212	; 0x4bc
            defaultPresetKnobValues[Delay][4] = 0.5f; // feedback
 801494e:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[Reverb][2] = 0.5f; // in highpass
 8014952:	f503 6997 	add.w	r9, r3, #1208	; 0x4b8
            defaultPresetKnobValues[Reverb][1] = 0.5f; // in lowpass
 8014956:	f8ca 2000 	str.w	r2, [sl]
            defaultPresetKnobValues[Reverb2][0] = 0.2f; // size
 801495a:	f203 5a14 	addw	sl, r3, #1300	; 0x514
            defaultPresetKnobValues[Reverb][0] = 0.5f; // size
 801495e:	f8cb 2000 	str.w	r2, [fp]
            defaultPresetKnobValues[Reverb][4] = 0.5f; // fb gain
 8014962:	f503 6b98 	add.w	fp, r3, #1216	; 0x4c0
            defaultPresetKnobValues[Reverb2][0] = 0.2f; // size
 8014966:	f8ca c000 	str.w	ip, [sl]
            defaultPresetKnobValues[Delay][2] = 0.0f; // highpass
 801496a:	f203 4a54 	addw	sl, r3, #1108	; 0x454
            defaultPresetKnobValues[Reverb][2] = 0.5f; // in highpass
 801496e:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[Reverb2][1] = 0.5f; // lowpass
 8014972:	f503 69a3 	add.w	r9, r3, #1304	; 0x518
            defaultPresetKnobValues[Reverb][3] = 0.5f; // fb lowpass
 8014976:	f8ce 2000 	str.w	r2, [lr]
            defaultPresetKnobValues[Reverb2][2] = 0.5f; // highpass
 801497a:	f203 5e1c 	addw	lr, r3, #1308	; 0x51c
            defaultPresetKnobValues[Reverb][4] = 0.5f; // fb gain
 801497e:	f8cb 2000 	str.w	r2, [fp]
            defaultPresetKnobValues[Reverb2][3] = 0.5f; // peak freq
 8014982:	f503 6ba4 	add.w	fp, r3, #1312	; 0x520
            defaultPresetKnobValues[Reverb2][1] = 0.5f; // lowpass
 8014986:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[Reverb2][4] = 0.5f; // peak gain
 801498a:	f203 5924 	addw	r9, r3, #1316	; 0x524
            defaultPresetKnobValues[Reverb2][2] = 0.5f; // highpass
 801498e:	f8ce 2000 	str.w	r2, [lr]
            defaultPresetKnobValues[LivingString][1] = 0.1f; // detune
 8014992:	f203 5e7c 	addw	lr, r3, #1404	; 0x57c
            defaultPresetKnobValues[Delay][2] = 0.0f; // highpass
 8014996:	f8ca 6000 	str.w	r6, [sl]
            defaultPresetKnobValues[LivingString][5] = 0.25f; // prep pos
 801499a:	f203 5a8c 	addw	sl, r3, #1420	; 0x58c
            defaultPresetKnobValues[Distortion][0] = .25f; // pre gain
 801499e:	f8c3 1320 	str.w	r1, [r3, #800]	; 0x320
            defaultPresetKnobValues[Distortion][4] = 0.25f; //post gain
 80149a2:	f8c3 1330 	str.w	r1, [r3, #816]	; 0x330
            defaultPresetKnobValues[Wavefolder][0] = 0.4f; // gain
 80149a6:	f8c3 7384 	str.w	r7, [r3, #900]	; 0x384
            defaultPresetKnobValues[BitCrusher][0] = 0.1f; // quality
 80149aa:	f8c3 03e8 	str.w	r0, [r3, #1000]	; 0x3e8
            defaultPresetKnobValues[SamplerAutoGrab][9] = 0.0f;
 80149ae:	f8c3 62e0 	str.w	r6, [r3, #736]	; 0x2e0
            defaultPresetKnobValues[Distortion][1] = 0.5f; // tilt (low and high shelves, opposing gains)
 80149b2:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
            defaultPresetKnobValues[Distortion][2] = 0.5f; // mid gain
 80149b6:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
            defaultPresetKnobValues[Distortion][3] = 0.5f; // mid freq
 80149ba:	f8c3 232c 	str.w	r2, [r3, #812]	; 0x32c
            defaultPresetKnobValues[Wavefolder][1] = 0.5f; // offset1
 80149be:	f8c3 2388 	str.w	r2, [r3, #904]	; 0x388
            defaultPresetKnobValues[Wavefolder][2] = 0.5f; // offset2
 80149c2:	f8c3 238c 	str.w	r2, [r3, #908]	; 0x38c
            defaultPresetKnobValues[Wavefolder][4] = 0.0f;
 80149c6:	f8c3 6394 	str.w	r6, [r3, #916]	; 0x394
            defaultPresetKnobValues[BitCrusher][1] = 0.5f; // samp ratio
 80149ca:	f8c3 23ec 	str.w	r2, [r3, #1004]	; 0x3ec
            defaultPresetKnobValues[BitCrusher][2] = 0.0f; // rounding
 80149ce:	f8c3 63f0 	str.w	r6, [r3, #1008]	; 0x3f0
            defaultPresetKnobValues[BitCrusher][3] = 0.0f; // operation
 80149d2:	f8c3 63f4 	str.w	r6, [r3, #1012]	; 0x3f4
            defaultPresetKnobValues[BitCrusher][4] = 0.5f; // post gain
 80149d6:	f8c3 23f8 	str.w	r2, [r3, #1016]	; 0x3f8
            defaultPresetKnobValues[BitCrusher][5] = 0.0f; // pre gain
 80149da:	f8c3 63fc 	str.w	r6, [r3, #1020]	; 0x3fc
            defaultPresetKnobValues[Reverb2][3] = 0.5f; // peak freq
 80149de:	f8cb 2000 	str.w	r2, [fp]
            defaultPresetKnobValues[LivingString][4] = 0.5f; // pick pos
 80149e2:	f503 6bb1 	add.w	fp, r3, #1416	; 0x588
            defaultPresetKnobValues[Reverb2][4] = 0.5f; // peak gain
 80149e6:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[LivingString][9] = 0.5f;
 80149ea:	f203 599c 	addw	r9, r3, #1436	; 0x59c
            defaultPresetKnobValues[LivingString][1] = 0.1f; // detune
 80149ee:	f8ce 0000 	str.w	r0, [lr]
            defaultPresetKnobValues[LivingStringSynth][0] = 0.5f;
 80149f2:	f203 5edc 	addw	lr, r3, #1500	; 0x5dc
            defaultPresetKnobValues[LivingString][5] = 0.25f; // prep pos
 80149f6:	f8ca 1000 	str.w	r1, [sl]
            defaultPresetKnobValues[LivingStringSynth][2] = .85f; // decay
 80149fa:	f203 5ae4 	addw	sl, r3, #1508	; 0x5e4
            defaultPresetKnobValues[LivingStringSynth][0] = 0.5f;
 80149fe:	f8ce 2000 	str.w	r2, [lr]
            defaultPresetKnobValues[LivingStringSynth][3] = 1.0f; // damping
 8014a02:	f503 6ebd 	add.w	lr, r3, #1512	; 0x5e8
            defaultPresetKnobValues[LivingStringSynth][2] = .85f; // decay
 8014a06:	f8ca 8000 	str.w	r8, [sl]
            defaultPresetKnobValues[LivingStringSynth][5] = 0.25f; // prep pos
 8014a0a:	f503 6abe 	add.w	sl, r3, #1520	; 0x5f0
            defaultPresetKnobValues[LivingString][9] = 0.5f;
 8014a0e:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[LivingStringSynth][4] = 0.4f; // pick pos
 8014a12:	f203 59ec 	addw	r9, r3, #1516	; 0x5ec
            defaultPresetKnobValues[LivingStringSynth][3] = 1.0f; // damping
 8014a16:	f8ce 4000 	str.w	r4, [lr]
            defaultPresetKnobValues[LivingStringSynth][9] = 0.4f; // release time
 8014a1a:	f503 64c0 	add.w	r4, r3, #1536	; 0x600
            defaultPresetKnobValues[LivingStringSynth][5] = 0.25f; // prep pos
 8014a1e:	f8ca 1000 	str.w	r1, [sl]
            defaultPresetKnobValues[ClassicSynth][0] = 0.5f; // volume
 8014a22:	f503 6ec8 	add.w	lr, r3, #1600	; 0x640
            defaultPresetKnobValues[ClassicSynth][2] = 0.2f; // detune
 8014a26:	f503 6ac9 	add.w	sl, r3, #1608	; 0x648
            defaultPresetKnobValues[LivingStringSynth][4] = 0.4f; // pick pos
 8014a2a:	f8c9 7000 	str.w	r7, [r9]
            defaultPresetKnobValues[ClassicSynth][0] = 0.5f; // volume
 8014a2e:	f8ce 2000 	str.w	r2, [lr]
            defaultPresetKnobValues[ClassicSynth][1] = 0.5f; // lowpass
 8014a32:	f203 6844 	addw	r8, r3, #1604	; 0x644
            defaultPresetKnobValues[ClassicSynth][2] = 0.2f; // detune
 8014a36:	f8ca c000 	str.w	ip, [sl]
            defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
 8014a3a:	f503 69af 	add.w	r9, r3, #1400	; 0x578
            defaultPresetKnobValues[LivingStringSynth][9] = 0.4f; // release time
 8014a3e:	6027      	str	r7, [r4, #0]
            defaultPresetKnobValues[LivingString][2] = 0.3f; // decay
 8014a40:	f503 6eb0 	add.w	lr, r3, #1408	; 0x580
            defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
 8014a44:	4c40      	ldr	r4, [pc, #256]	; (8014b48 <initGlobalSFXObjects+0x404>)
            defaultPresetKnobValues[LivingString][11] = 0.3f;// freq 3
 8014a46:	f203 5ca4 	addw	ip, r3, #1444	; 0x5a4
            defaultPresetKnobValues[LivingString][12] = 0.3f;// freq 4
 8014a4a:	f503 67b5 	add.w	r7, r3, #1448	; 0x5a8
            defaultPresetKnobValues[ClassicSynth][1] = 0.5f; // lowpass
 8014a4e:	f8c8 2000 	str.w	r2, [r8]
            defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
 8014a52:	f8c9 4000 	str.w	r4, [r9]
            defaultPresetKnobValues[LivingString][10] = 0.3f;// freq 2
 8014a56:	f503 68b4 	add.w	r8, r3, #1440	; 0x5a0
            defaultPresetKnobValues[LivingString][2] = 0.3f; // decay
 8014a5a:	f8ce 4000 	str.w	r4, [lr]
            defaultPresetKnobValues[LivingString][13] = 0.3f;// freq 5
 8014a5e:	f203 59ac 	addw	r9, r3, #1452	; 0x5ac
            defaultPresetKnobValues[LivingString][11] = 0.3f;// freq 3
 8014a62:	f8cc 4000 	str.w	r4, [ip]
            defaultPresetKnobValues[LivingString][14] = 0.3f;// freq 6
 8014a66:	f503 6eb6 	add.w	lr, r3, #1456	; 0x5b0
            defaultPresetKnobValues[LivingStringSynth][8] = 0.3f; // feedback volume
 8014a6a:	f203 5afc 	addw	sl, r3, #1532	; 0x5fc
            defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
 8014a6e:	f203 5c84 	addw	ip, r3, #1412	; 0x584
            defaultPresetKnobValues[LivingString][12] = 0.3f;// freq 4
 8014a72:	603c      	str	r4, [r7, #0]
            defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
 8014a74:	4f35      	ldr	r7, [pc, #212]	; (8014b4c <initGlobalSFXObjects+0x408>)
            defaultPresetKnobValues[LivingString][10] = 0.3f;// freq 2
 8014a76:	f8c8 4000 	str.w	r4, [r8]
            defaultPresetKnobValues[LivingString][6] = 0.0f; // prep index
 8014a7a:	f503 68b2 	add.w	r8, r3, #1424	; 0x590
            defaultPresetKnobValues[LivingString][13] = 0.3f;// freq 5
 8014a7e:	f8c9 4000 	str.w	r4, [r9]
            defaultPresetKnobValues[LivingString][7] = 0.0f; // let ring
 8014a82:	f203 5994 	addw	r9, r3, #1428	; 0x594
            defaultPresetKnobValues[LivingString][4] = 0.5f; // pick pos
 8014a86:	f8cb 2000 	str.w	r2, [fp]
            defaultPresetKnobValues[LivingStringSynth][1] = 0.5f;
 8014a8a:	f503 6bbc 	add.w	fp, r3, #1504	; 0x5e0
            defaultPresetKnobValues[LivingString][14] = 0.3f;// freq 6
 8014a8e:	f8ce 4000 	str.w	r4, [lr]
            defaultPresetKnobValues[LivingString][8] = 0.8f;
 8014a92:	f503 6eb3 	add.w	lr, r3, #1432	; 0x598
            defaultPresetKnobValues[LivingStringSynth][8] = 0.3f; // feedback volume
 8014a96:	f8ca 4000 	str.w	r4, [sl]
            defaultPresetKnobValues[ClassicSynth][5] = 0.0f;
 8014a9a:	f203 6454 	addw	r4, r3, #1620	; 0x654
            defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
 8014a9e:	f8cc 7000 	str.w	r7, [ip]
            defaultPresetKnobValues[LivingStringSynth][7] = 0.0f; // let ring
 8014aa2:	f503 6cbf 	add.w	ip, r3, #1528	; 0x5f8
            defaultPresetKnobValues[LivingString][8] = 0.8f;
 8014aa6:	eddf 7a2a 	vldr	s15, [pc, #168]	; 8014b50 <initGlobalSFXObjects+0x40c>
            defaultPresetKnobValues[LivingStringSynth][6] = 0.0f; // prep index
 8014aaa:	f203 5af4 	addw	sl, r3, #1524	; 0x5f4
            defaultPresetKnobValues[LivingStringSynth][1] = 0.5f;
 8014aae:	f8cb 2000 	str.w	r2, [fp]
            defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
 8014ab2:	f503 6bcb 	add.w	fp, r3, #1624	; 0x658
            defaultPresetKnobValues[LivingString][6] = 0.0f; // prep index
 8014ab6:	f8c8 6000 	str.w	r6, [r8]
            defaultPresetKnobValues[ClassicSynth][3] = 0.0f;
 8014aba:	f203 684c 	addw	r8, r3, #1612	; 0x64c
            defaultPresetKnobValues[LivingString][7] = 0.0f; // let ring
 8014abe:	f8c9 6000 	str.w	r6, [r9]
            defaultPresetKnobValues[ClassicSynth][4] = 0.0f;
 8014ac2:	f503 69ca 	add.w	r9, r3, #1616	; 0x650
            defaultPresetKnobValues[LivingString][8] = 0.8f;
 8014ac6:	edce 7a00 	vstr	s15, [lr]
            defaultPresetKnobValues[ClassicSynth][7] = 0.9f;
 8014aca:	f203 6e5c 	addw	lr, r3, #1628	; 0x65c
            defaultPresetKnobValues[LivingStringSynth][7] = 0.0f; // let ring
 8014ace:	f8cc 6000 	str.w	r6, [ip]
            defaultPresetKnobValues[ClassicSynth][8] = 0.1f;
 8014ad2:	f503 6ccc 	add.w	ip, r3, #1632	; 0x660
            defaultPresetKnobValues[ClassicSynth][5] = 0.0f;
 8014ad6:	6026      	str	r6, [r4, #0]
            defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
 8014ad8:	4c1e      	ldr	r4, [pc, #120]	; (8014b54 <initGlobalSFXObjects+0x410>)
            defaultPresetKnobValues[LivingStringSynth][6] = 0.0f; // prep index
 8014ada:	f8ca 6000 	str.w	r6, [sl]
            defaultPresetKnobValues[ClassicSynth][11] = 0.06f;
 8014ade:	f203 6a6c 	addw	sl, r3, #1644	; 0x66c
            defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
 8014ae2:	f8cb 4000 	str.w	r4, [fp]
            defaultPresetKnobValues[ClassicSynth][3] = 0.0f;
 8014ae6:	f8c8 6000 	str.w	r6, [r8]
            defaultPresetKnobValues[ClassicSynth][9] = 0.1f;
 8014aea:	f203 6864 	addw	r8, r3, #1636	; 0x664
            defaultPresetKnobValues[ClassicSynth][4] = 0.0f;
 8014aee:	f8c9 6000 	str.w	r6, [r9]
            defaultPresetKnobValues[ClassicSynth][12] = 0.9f;
 8014af2:	f503 69ce 	add.w	r9, r3, #1648	; 0x670
 8014af6:	e035      	b.n	8014b64 <initGlobalSFXObjects+0x420>
 8014af8:	20000668 	.word	0x20000668
 8014afc:	200029f0 	.word	0x200029f0
 8014b00:	20000634 	.word	0x20000634
 8014b04:	2aaaaaab 	.word	0x2aaaaaab
 8014b08:	20017968 	.word	0x20017968
 8014b0c:	200174c8 	.word	0x200174c8
 8014b10:	3ca3d70a 	.word	0x3ca3d70a
 8014b14:	00000000 	.word	0x00000000
 8014b18:	3c23d70a 	.word	0x3c23d70a
 8014b1c:	20017204 	.word	0x20017204
 8014b20:	ba51b717 	.word	0xba51b717
 8014b24:	447a0000 	.word	0x447a0000
 8014b28:	20016fec 	.word	0x20016fec
 8014b2c:	20017988 	.word	0x20017988
 8014b30:	3a83126f 	.word	0x3a83126f
 8014b34:	20001f10 	.word	0x20001f10
 8014b38:	3f28f5c3 	.word	0x3f28f5c3
 8014b3c:	3ecccccd 	.word	0x3ecccccd
 8014b40:	3f733333 	.word	0x3f733333
 8014b44:	3dcccccd 	.word	0x3dcccccd
 8014b48:	3e99999a 	.word	0x3e99999a
 8014b4c:	3f666666 	.word	0x3f666666
 8014b50:	3f4ccccd 	.word	0x3f4ccccd
 8014b54:	3d75c28f 	.word	0x3d75c28f
 8014b58:	3ca3d70a 	.word	0x3ca3d70a
 8014b5c:	3e4ccccd 	.word	0x3e4ccccd
 8014b60:	3f59999a 	.word	0x3f59999a
            defaultPresetKnobValues[ClassicSynth][7] = 0.9f;
 8014b64:	f8ce 7000 	str.w	r7, [lr]
            defaultPresetKnobValues[ClassicSynth][13] = 0.1f;
 8014b68:	f203 6e74 	addw	lr, r3, #1652	; 0x674
            defaultPresetKnobValues[ClassicSynth][8] = 0.1f;
 8014b6c:	f8cc 0000 	str.w	r0, [ip]
            defaultPresetKnobValues[ClassicSynth][14] = 0.1f;
 8014b70:	f503 6ccf 	add.w	ip, r3, #1656	; 0x678
            defaultPresetKnobValues[ClassicSynth][9] = 0.1f;
 8014b74:	f8c8 0000 	str.w	r0, [r8]
            defaultPresetKnobValues[ClassicSynth][16] = 0.06f;
 8014b78:	f503 68d0 	add.w	r8, r3, #1664	; 0x680
            defaultPresetKnobValues[ClassicSynth][13] = 0.1f;
 8014b7c:	f8ce 0000 	str.w	r0, [lr]
            defaultPresetKnobValues[ClassicSynth][18] = 0.1f;
 8014b80:	f503 6ed1 	add.w	lr, r3, #1672	; 0x688
            defaultPresetKnobValues[ClassicSynth][14] = 0.1f;
 8014b84:	f8cc 0000 	str.w	r0, [ip]
            defaultPresetKnobValues[ClassicSynth][19] = 0.1f;
 8014b88:	f203 6c8c 	addw	ip, r3, #1676	; 0x68c
            defaultPresetKnobValues[ClassicSynth][16] = 0.06f;
 8014b8c:	f8c8 4000 	str.w	r4, [r8]
            defaultPresetKnobValues[Rhodes][0] = 0.25f;
 8014b90:	f203 68a4 	addw	r8, r3, #1700	; 0x6a4
            defaultPresetKnobValues[ClassicSynth][18] = 0.1f;
 8014b94:	f8ce 0000 	str.w	r0, [lr]
            defaultPresetKnobValues[Rhodes][2] = 0.25f;
 8014b98:	f203 6eac 	addw	lr, r3, #1708	; 0x6ac
            defaultPresetKnobValues[ClassicSynth][19] = 0.1f;
 8014b9c:	f8cc 0000 	str.w	r0, [ip]
            defaultPresetKnobValues[Rhodes][3] = 0.5f;
 8014ba0:	f503 6cd6 	add.w	ip, r3, #1712	; 0x6b0
            defaultPresetKnobValues[ClassicSynth][11] = 0.06f;
 8014ba4:	f8ca 4000 	str.w	r4, [sl]
            defaultPresetKnobValues[Rhodes][7] = 0.9f;
 8014ba8:	f503 60d8 	add.w	r0, r3, #1728	; 0x6c0
            defaultPresetKnobValues[Rhodes][1] = 0.25f;
 8014bac:	f503 64d5 	add.w	r4, r3, #1704	; 0x6a8
            defaultPresetKnobValues[ClassicSynth][12] = 0.9f;
 8014bb0:	f8c9 7000 	str.w	r7, [r9]
            defaultPresetKnobValues[Rhodes][0] = 0.25f;
 8014bb4:	f8c8 1000 	str.w	r1, [r8]
            defaultPresetKnobValues[ClassicSynth][17] = 0.9f;
 8014bb8:	f203 6984 	addw	r9, r3, #1668	; 0x684
            defaultPresetKnobValues[Rhodes][1] = 0.25f;
 8014bbc:	6021      	str	r1, [r4, #0]
            defaultPresetKnobValues[Rhodes][9] = 0.5f;
 8014bbe:	f503 68d9 	add.w	r8, r3, #1736	; 0x6c8
            defaultPresetKnobValues[Rhodes][2] = 0.25f;
 8014bc2:	f8ce 1000 	str.w	r1, [lr]
            defaultPresetKnobValues[Rhodes][12] = 0.9f;
 8014bc6:	f203 64d4 	addw	r4, r3, #1748	; 0x6d4
            defaultPresetKnobValues[Rhodes][7] = 0.9f;
 8014bca:	6007      	str	r7, [r0, #0]
            defaultPresetKnobValues[Rhodes][14] = 0.5f;
 8014bcc:	f203 6edc 	addw	lr, r3, #1756	; 0x6dc
            defaultPresetKnobValues[Rhodes][3] = 0.5f;
 8014bd0:	f8cc 2000 	str.w	r2, [ip]
            defaultPresetKnobValues[Rhodes][15] = 0.8f;
 8014bd4:	f503 61dc 	add.w	r1, r3, #1760	; 0x6e0
            defaultPresetKnobValues[Rhodes][18] = 0.5f;
 8014bd8:	f203 6cec 	addw	ip, r3, #1772	; 0x6ec
            defaultPresetKnobValues[Rhodes][19] = 0.5f;
 8014bdc:	f503 60de 	add.w	r0, r3, #1776	; 0x6f0
            defaultPresetKnobValues[ClassicSynth][17] = 0.9f;
 8014be0:	f8c9 7000 	str.w	r7, [r9]
            defaultPresetKnobValues[Rhodes][8] = 0.1007f;
 8014be4:	f203 6ac4 	addw	sl, r3, #1732	; 0x6c4
            defaultPresetKnobValues[Rhodes][12] = 0.9f;
 8014be8:	6027      	str	r7, [r4, #0]
            defaultPresetKnobValues[ClassicSynth][15] = 0.0f;
 8014bea:	f203 647c 	addw	r4, r3, #1660	; 0x67c
            defaultPresetKnobValues[Rhodes][9] = 0.5f;
 8014bee:	f8c8 2000 	str.w	r2, [r8]
            defaultPresetKnobValues[Rhodes][4] = 0.0f; //stereo spread
 8014bf2:	f203 67b4 	addw	r7, r3, #1716	; 0x6b4
            defaultPresetKnobValues[Rhodes][14] = 0.5f;
 8014bf6:	f8ce 2000 	str.w	r2, [lr]
            defaultPresetKnobValues[Rhodes][5] = 0.05f;
 8014bfa:	f503 68d7 	add.w	r8, r3, #1720	; 0x6b8
            defaultPresetKnobValues[Rhodes][6] = 0.05f;
 8014bfe:	f203 6ebc 	addw	lr, r3, #1724	; 0x6bc
            defaultPresetKnobValues[Rhodes][18] = 0.5f;
 8014c02:	f8cc 2000 	str.w	r2, [ip]
            defaultPresetKnobValues[Rhodes][19] = 0.5f;
 8014c06:	6002      	str	r2, [r0, #0]
            defaultPresetKnobValues[Rhodes][10] = 0.05f;
 8014c08:	f203 6ccc 	addw	ip, r3, #1740	; 0x6cc
            defaultPresetKnobValues[Rhodes][11] = 0.05f;
 8014c0c:	f503 60da 	add.w	r0, r3, #1744	; 0x6d0
            defaultPresetKnobValues[Rhodes][15] = 0.8f;
 8014c10:	edc1 7a00 	vstr	s15, [r1]
            defaultPresetKnobValues[Rhodes][5] = 0.05f;
 8014c14:	4920      	ldr	r1, [pc, #128]	; (8014c98 <initGlobalSFXObjects+0x554>)
            defaultPresetKnobValues[ClassicSynth][10] = 0.0f;
 8014c16:	f503 69cd 	add.w	r9, r3, #1640	; 0x668
            defaultPresetKnobValues[ClassicSynth][15] = 0.0f;
 8014c1a:	6026      	str	r6, [r4, #0]
            defaultPresetKnobValues[Rhodes][13] = 0.1007f;
 8014c1c:	f503 64db 	add.w	r4, r3, #1752	; 0x6d8
            defaultPresetKnobValues[Rhodes][4] = 0.0f; //stereo spread
 8014c20:	603e      	str	r6, [r7, #0]
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
 8014c22:	f203 67e4 	addw	r7, r3, #1764	; 0x6e4
            defaultPresetKnobValues[Rhodes][5] = 0.05f;
 8014c26:	f8c8 1000 	str.w	r1, [r8]
            defaultPresetKnobValues[Rhodes][20] = 0.5f;
 8014c2a:	f203 68f4 	addw	r8, r3, #1780	; 0x6f4
            defaultPresetKnobValues[Rhodes][6] = 0.05f;
 8014c2e:	f8ce 1000 	str.w	r1, [lr]
            defaultPresetKnobValues[Rhodes][21] = 0.0f;
 8014c32:	f503 6edf 	add.w	lr, r3, #1784	; 0x6f8
            defaultPresetKnobValues[Rhodes][10] = 0.05f;
 8014c36:	f8cc 1000 	str.w	r1, [ip]
            defaultPresetKnobValues[Rhodes][22] = 0.00f;
 8014c3a:	f203 6cfc 	addw	ip, r3, #1788	; 0x6fc
            defaultPresetKnobValues[Rhodes][11] = 0.05f;
 8014c3e:	6001      	str	r1, [r0, #0]
            defaultPresetKnobValues[Rhodes][23] = 0.00f;
 8014c40:	f503 60e0 	add.w	r0, r3, #1792	; 0x700
            defaultPresetKnobValues[Rhodes][8] = 0.1007f;
 8014c44:	4915      	ldr	r1, [pc, #84]	; (8014c9c <initGlobalSFXObjects+0x558>)
 8014c46:	4d16      	ldr	r5, [pc, #88]	; (8014ca0 <initGlobalSFXObjects+0x55c>)
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
 8014c48:	f8df b05c 	ldr.w	fp, [pc, #92]	; 8014ca8 <initGlobalSFXObjects+0x564>
            defaultPresetKnobValues[ClassicSynth][10] = 0.0f;
 8014c4c:	f8c9 6000 	str.w	r6, [r9]
            defaultPresetKnobValues[Rhodes][17] = 0.7f;
 8014c50:	f503 69dd 	add.w	r9, r3, #1768	; 0x6e8
            defaultPresetKnobValues[Rhodes][13] = 0.1007f;
 8014c54:	6021      	str	r1, [r4, #0]
 8014c56:	461c      	mov	r4, r3
            defaultPresetKnobValues[Rhodes][8] = 0.1007f;
 8014c58:	f8ca 1000 	str.w	r1, [sl]
            defaultPresetKnobValues[Rhodes][24] = 0.00f;
 8014c5c:	f203 7104 	addw	r1, r3, #1796	; 0x704
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
 8014c60:	f8c7 b000 	str.w	fp, [r7]
 8014c64:	f505 67e1 	add.w	r7, r5, #1800	; 0x708
            defaultPresetKnobValues[Rhodes][17] = 0.7f;
 8014c68:	4b0e      	ldr	r3, [pc, #56]	; (8014ca4 <initGlobalSFXObjects+0x560>)
 8014c6a:	f8c9 3000 	str.w	r3, [r9]
            defaultPresetKnobValues[Rhodes][20] = 0.5f;
 8014c6e:	f8c8 2000 	str.w	r2, [r8]
            defaultPresetKnobValues[Rhodes][21] = 0.0f;
 8014c72:	f8ce 6000 	str.w	r6, [lr]
            defaultPresetKnobValues[Rhodes][22] = 0.00f;
 8014c76:	f8cc 6000 	str.w	r6, [ip]
            defaultPresetKnobValues[Rhodes][23] = 0.00f;
 8014c7a:	6006      	str	r6, [r0, #0]
            defaultPresetKnobValues[Rhodes][24] = 0.00f;
 8014c7c:	600e      	str	r6, [r1, #0]
 8014c7e:	4628      	mov	r0, r5
 8014c80:	3564      	adds	r5, #100	; 0x64
 8014c82:	4621      	mov	r1, r4
 8014c84:	2264      	movs	r2, #100	; 0x64
 8014c86:	f012 f99f 	bl	8026fc8 <memcpy>
            for (int p = 0; p < PresetNil; p++)
 8014c8a:	42af      	cmp	r7, r5
 8014c8c:	f104 0464 	add.w	r4, r4, #100	; 0x64
 8014c90:	d1f5      	bne.n	8014c7e <initGlobalSFXObjects+0x53a>
        }
 8014c92:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014c96:	bf00      	nop
 8014c98:	3d4ccccd 	.word	0x3d4ccccd
 8014c9c:	3dce3bcd 	.word	0x3dce3bcd
 8014ca0:	20002cb8 	.word	0x20002cb8
 8014ca4:	3f333333 	.word	0x3f333333
 8014ca8:	3f19999a 	.word	0x3f19999a

08014cac <SFXVocoderAlloc>:
        {
 8014cac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            tTalkboxFloat_init(&vocoder, 1024);
 8014cb0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8014cb4:	4833      	ldr	r0, [pc, #204]	; (8014d84 <SFXVocoderAlloc+0xd8>)
            tHighpass_init(&noiseHP, 4500.0f);
 8014cb6:	2400      	movs	r4, #0
            tSimplePoly_setNumVoices(&poly, numVoices);
 8014cb8:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8014dd4 <SFXVocoderAlloc+0x128>
 8014cbc:	4f32      	ldr	r7, [pc, #200]	; (8014d88 <SFXVocoderAlloc+0xdc>)
 8014cbe:	4e33      	ldr	r6, [pc, #204]	; (8014d8c <SFXVocoderAlloc+0xe0>)
        {
 8014cc0:	ed2d 8b02 	vpush	{d8}
            tTalkboxFloat_init(&vocoder, 1024);
 8014cc4:	f00b fc62 	bl	802058c <tTalkboxFloat_init>
            tTalkboxFloat_setWarpOn(&vocoder, 1);
 8014cc8:	2101      	movs	r1, #1
 8014cca:	482e      	ldr	r0, [pc, #184]	; (8014d84 <SFXVocoderAlloc+0xd8>)
 8014ccc:	f00b fe9a 	bl	8020a04 <tTalkboxFloat_setWarpOn>
            tNoise_init(&vocoderNoise, WhiteNoise);
 8014cd0:	4621      	mov	r1, r4
 8014cd2:	482f      	ldr	r0, [pc, #188]	; (8014d90 <SFXVocoderAlloc+0xe4>)
 8014cd4:	f010 f8f4 	bl	8024ec0 <tNoise_init>
            tZeroCrossing_init(&zerox, 16);
 8014cd8:	2110      	movs	r1, #16
 8014cda:	482e      	ldr	r0, [pc, #184]	; (8014d94 <SFXVocoderAlloc+0xe8>)
 8014cdc:	f009 fe5a 	bl	801e994 <tZeroCrossing_init>
            tSimplePoly_setNumVoices(&poly, numVoices);
 8014ce0:	f898 1000 	ldrb.w	r1, [r8]
 8014ce4:	482c      	ldr	r0, [pc, #176]	; (8014d98 <SFXVocoderAlloc+0xec>)
 8014ce6:	f00f ff67 	bl	8024bb8 <tSimplePoly_setNumVoices>
            tExpSmooth_init(&noiseRamp, 0.0f, 0.005f);
 8014cea:	eddf 0a2c 	vldr	s1, [pc, #176]	; 8014d9c <SFXVocoderAlloc+0xf0>
 8014cee:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 8014da0 <SFXVocoderAlloc+0xf4>
 8014cf2:	482c      	ldr	r0, [pc, #176]	; (8014da4 <SFXVocoderAlloc+0xf8>)
 8014cf4:	f00d fbde 	bl	80224b4 <tExpSmooth_init>
            tVZFilter_init(&shelf1, Lowshelf, 80.0f, 6.0f);
 8014cf8:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
 8014cfc:	ed9f 0a2a 	vldr	s0, [pc, #168]	; 8014da8 <SFXVocoderAlloc+0xfc>
 8014d00:	2106      	movs	r1, #6
 8014d02:	482a      	ldr	r0, [pc, #168]	; (8014dac <SFXVocoderAlloc+0x100>)
 8014d04:	f00d ff92 	bl	8022c2c <tVZFilter_init>
            tVZFilter_init(&shelf2, Highshelf, 12000.0f, 6.0f);
 8014d08:	ed9f 0a29 	vldr	s0, [pc, #164]	; 8014db0 <SFXVocoderAlloc+0x104>
 8014d0c:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
 8014d10:	2107      	movs	r1, #7
 8014d12:	4828      	ldr	r0, [pc, #160]	; (8014db4 <SFXVocoderAlloc+0x108>)
 8014d14:	f00d ff8a 	bl	8022c2c <tVZFilter_init>
            tNoise_init(&breathNoise, WhiteNoise);
 8014d18:	4827      	ldr	r0, [pc, #156]	; (8014db8 <SFXVocoderAlloc+0x10c>)
 8014d1a:	4621      	mov	r1, r4
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
 8014d1c:	eddf 8a27 	vldr	s17, [pc, #156]	; 8014dbc <SFXVocoderAlloc+0x110>
            tNoise_init(&breathNoise, WhiteNoise);
 8014d20:	f010 f8ce 	bl	8024ec0 <tNoise_init>
            tHighpass_init(&noiseHP, 4500.0f);
 8014d24:	ed9f 0a26 	vldr	s0, [pc, #152]	; 8014dc0 <SFXVocoderAlloc+0x114>
 8014d28:	4826      	ldr	r0, [pc, #152]	; (8014dc4 <SFXVocoderAlloc+0x118>)
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
 8014d2a:	ed9f 8a27 	vldr	s16, [pc, #156]	; 8014dc8 <SFXVocoderAlloc+0x11c>
            tHighpass_init(&noiseHP, 4500.0f);
 8014d2e:	f00d ff19 	bl	8022b64 <tHighpass_init>
 8014d32:	1935      	adds	r5, r6, r4
                tSawtooth_init(&osc[i]);
 8014d34:	1938      	adds	r0, r7, r4
 8014d36:	f010 f80d 	bl	8024d54 <tSawtooth_init>
 8014d3a:	3404      	adds	r4, #4
                tRosenbergGlottalPulse_init(&glottal[i]);
 8014d3c:	4628      	mov	r0, r5
 8014d3e:	f00b fe69 	bl	8020a14 <tRosenbergGlottalPulse_init>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
 8014d42:	eef0 0a68 	vmov.f32	s1, s17
 8014d46:	eeb0 0a48 	vmov.f32	s0, s16
 8014d4a:	4628      	mov	r0, r5
 8014d4c:	f00b ff80 	bl	8020c50 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 8014d50:	2c20      	cmp	r4, #32
 8014d52:	d1ee      	bne.n	8014d32 <SFXVocoderAlloc+0x86>
            setLED_A(numVoices == 1);
 8014d54:	f8d8 0000 	ldr.w	r0, [r8]
 8014d58:	f1a0 0001 	sub.w	r0, r0, #1
 8014d5c:	fab0 f080 	clz	r0, r0
 8014d60:	0940      	lsrs	r0, r0, #5
 8014d62:	f7fe fdf3 	bl	801394c <setLED_A>
            setLED_B(internalExternal);
 8014d66:	4b19      	ldr	r3, [pc, #100]	; (8014dcc <SFXVocoderAlloc+0x120>)
 8014d68:	6818      	ldr	r0, [r3, #0]
 8014d6a:	f7fe fdfd 	bl	8013968 <setLED_B>
            vocFreezeLPC = 0;
 8014d6e:	2300      	movs	r3, #0
 8014d70:	4a17      	ldr	r2, [pc, #92]	; (8014dd0 <SFXVocoderAlloc+0x124>)
            setLED_C(vocFreezeLPC);
 8014d72:	4618      	mov	r0, r3
            vocFreezeLPC = 0;
 8014d74:	6013      	str	r3, [r2, #0]
        }
 8014d76:	ecbd 8b02 	vpop	{d8}
 8014d7a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            setLED_C(vocFreezeLPC);
 8014d7e:	f7fe be01 	b.w	8013984 <setLED_C>
 8014d82:	bf00      	nop
 8014d84:	2001818c 	.word	0x2001818c
 8014d88:	20017284 	.word	0x20017284
 8014d8c:	200027f0 	.word	0x200027f0
 8014d90:	2000340c 	.word	0x2000340c
 8014d94:	2001763c 	.word	0x2001763c
 8014d98:	200174c8 	.word	0x200174c8
 8014d9c:	3ba3d70a 	.word	0x3ba3d70a
 8014da0:	00000000 	.word	0x00000000
 8014da4:	20018274 	.word	0x20018274
 8014da8:	42a00000 	.word	0x42a00000
 8014dac:	200174a4 	.word	0x200174a4
 8014db0:	463b8000 	.word	0x463b8000
 8014db4:	200173cc 	.word	0x200173cc
 8014db8:	200027c0 	.word	0x200027c0
 8014dbc:	3ecccccd 	.word	0x3ecccccd
 8014dc0:	458ca000 	.word	0x458ca000
 8014dc4:	20003404 	.word	0x20003404
 8014dc8:	3e99999a 	.word	0x3e99999a
 8014dcc:	200005ac 	.word	0x200005ac
 8014dd0:	20000628 	.word	0x20000628
 8014dd4:	20000254 	.word	0x20000254

08014dd8 <SFXVocoderFrame>:
        {
 8014dd8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8014ddc:	4c82      	ldr	r4, [pc, #520]	; (8014fe8 <SFXVocoderFrame+0x210>)
        {
 8014dde:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8014de2:	7d21      	ldrb	r1, [r4, #20]
 8014de4:	2901      	cmp	r1, #1
 8014de6:	d112      	bne.n	8014e0e <SFXVocoderFrame+0x36>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8014de8:	4d80      	ldr	r5, [pc, #512]	; (8014fec <SFXVocoderFrame+0x214>)
                tSimplePoly_setNumVoices(&poly, numVoices);
 8014dea:	4881      	ldr	r0, [pc, #516]	; (8014ff0 <SFXVocoderFrame+0x218>)
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8014dec:	682b      	ldr	r3, [r5, #0]
 8014dee:	2b01      	cmp	r3, #1
 8014df0:	bfd8      	it	le
 8014df2:	2108      	movle	r1, #8
 8014df4:	6029      	str	r1, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
 8014df6:	f00f fedf 	bl	8024bb8 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
 8014dfa:	6828      	ldr	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8014dfc:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
 8014dfe:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8014e02:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
 8014e04:	fab0 f080 	clz	r0, r0
 8014e08:	0940      	lsrs	r0, r0, #5
 8014e0a:	f7fe fd9f 	bl	801394c <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 8014e0e:	7e23      	ldrb	r3, [r4, #24]
 8014e10:	2b01      	cmp	r3, #1
 8014e12:	f000 80dd 	beq.w	8014fd0 <SFXVocoderFrame+0x1f8>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 8014e16:	7f23      	ldrb	r3, [r4, #28]
 8014e18:	2b01      	cmp	r3, #1
 8014e1a:	f000 80c9 	beq.w	8014fb0 <SFXVocoderFrame+0x1d8>
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
 8014e1e:	4b75      	ldr	r3, [pc, #468]	; (8014ff4 <SFXVocoderFrame+0x21c>)
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
 8014e20:	eeb3 6a0e 	vmov.f32	s12, #62	; 0x41f00000  30.0
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 8014e24:	eddf 6a74 	vldr	s13, [pc, #464]	; 8014ff8 <SFXVocoderFrame+0x220>
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
 8014e28:	eeba 7a0e 	vmov.f32	s14, #174	; 0xc1700000 -15.0
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 8014e2c:	ed93 5a01 	vldr	s10, [r3, #4]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8014e30:	2400      	movs	r4, #0
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 8014e32:	eddf 7a72 	vldr	s15, [pc, #456]	; 8014ffc <SFXVocoderFrame+0x224>
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
 8014e36:	edd3 5a06 	vldr	s11, [r3, #24]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8014e3a:	46a1      	mov	r9, r4
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 8014e3c:	eee5 7a26 	vfma.f32	s15, s10, s13
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
 8014e40:	edd3 6a02 	vldr	s13, [r3, #8]
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
 8014e44:	eea5 7a86 	vfma.f32	s14, s11, s12
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
 8014e48:	ed9f 6a6d 	vldr	s12, [pc, #436]	; 8015000 <SFXVocoderFrame+0x228>
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
 8014e4c:	4d6d      	ldr	r5, [pc, #436]	; (8015004 <SFXVocoderFrame+0x22c>)
 8014e4e:	6819      	ldr	r1, [r3, #0]
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
 8014e50:	ee66 6a86 	vmul.f32	s13, s13, s12
            displayValues[3] = presetKnobValues[Vocoder][3]; //crossfade between sawtooth and glottal pulse
 8014e54:	68da      	ldr	r2, [r3, #12]
            displayValues[4] = presetKnobValues[Vocoder][4]; //noise thresh
 8014e56:	6918      	ldr	r0, [r3, #16]
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
 8014e58:	6029      	str	r1, [r5, #0]
            tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
 8014e5a:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[5] = presetKnobValues[Vocoder][5]; //breathy
 8014e5e:	6959      	ldr	r1, [r3, #20]
            displayValues[3] = presetKnobValues[Vocoder][3]; //crossfade between sawtooth and glottal pulse
 8014e60:	60ea      	str	r2, [r5, #12]
            displayValues[7] = presetKnobValues[Vocoder][7]; //pulse length
 8014e62:	69da      	ldr	r2, [r3, #28]
            displayValues[8] = presetKnobValues[Vocoder][8]; //open length
 8014e64:	6a1b      	ldr	r3, [r3, #32]
            displayValues[4] = presetKnobValues[Vocoder][4]; //noise thresh
 8014e66:	6128      	str	r0, [r5, #16]
            tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
 8014e68:	4867      	ldr	r0, [pc, #412]	; (8015008 <SFXVocoderFrame+0x230>)
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 8014e6a:	edc5 7a01 	vstr	s15, [r5, #4]
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
 8014e6e:	edc5 6a02 	vstr	s13, [r5, #8]
            displayValues[5] = presetKnobValues[Vocoder][5]; //breathy
 8014e72:	6169      	str	r1, [r5, #20]
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
 8014e74:	ed85 7a06 	vstr	s14, [r5, #24]
            displayValues[7] = presetKnobValues[Vocoder][7]; //pulse length
 8014e78:	61ea      	str	r2, [r5, #28]
            displayValues[8] = presetKnobValues[Vocoder][8]; //open length
 8014e7a:	622b      	str	r3, [r5, #32]
            tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
 8014e7c:	f00b fdbe 	bl	80209fc <tTalkboxFloat_setWarpFactor>
            tTalkboxFloat_setQuality(&vocoder, displayValues[2]);
 8014e80:	ed95 0a02 	vldr	s0, [r5, #8]
 8014e84:	4860      	ldr	r0, [pc, #384]	; (8015008 <SFXVocoderFrame+0x230>)
 8014e86:	f00b fd9b 	bl	80209c0 <tTalkboxFloat_setQuality>
 8014e8a:	4f60      	ldr	r7, [pc, #384]	; (801500c <SFXVocoderFrame+0x234>)
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8014e8c:	4e58      	ldr	r6, [pc, #352]	; (8014ff0 <SFXVocoderFrame+0x218>)
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8014e8e:	ed9f 8a60 	vldr	s16, [pc, #384]	; 8015010 <SFXVocoderFrame+0x238>
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8014e92:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 8015040 <SFXVocoderFrame+0x268>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8014e96:	e04f      	b.n	8014f38 <SFXVocoderFrame+0x160>
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8014e98:	f00f febe 	bl	8024c18 <tSimplePoly_getVelocity>
 8014e9c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8014ea0:	2800      	cmp	r0, #0
 8014ea2:	4658      	mov	r0, fp
 8014ea4:	fe30 0a08 	vselgt.f32	s0, s0, s16
 8014ea8:	f00d fb6a 	bl	8022580 <tExpSmooth_setDest>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8014eac:	4651      	mov	r1, sl
 8014eae:	4630      	mov	r0, r6
 8014eb0:	f00f fea6 	bl	8024c00 <tSimplePoly_getPitch>
 8014eb4:	ee07 0a90 	vmov	s15, r0
 8014eb8:	4a56      	ldr	r2, [pc, #344]	; (8015014 <SFXVocoderFrame+0x23c>)
 8014eba:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8014ebe:	4b56      	ldr	r3, [pc, #344]	; (8015018 <SFXVocoderFrame+0x240>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8014ec0:	ed92 0a00 	vldr	s0, [r2]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8014ec4:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8014ec6:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8014eca:	4954      	ldr	r1, [pc, #336]	; (801501c <SFXVocoderFrame+0x244>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8014ecc:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8014ed0:	ee17 3a90 	vmov	r3, s15
 8014ed4:	1a9b      	subs	r3, r3, r2
 8014ed6:	fb88 2003 	smull	r2, r0, r8, r3
 8014eda:	17da      	asrs	r2, r3, #31
 8014edc:	ebc2 0260 	rsb	r2, r2, r0, asr #1
 8014ee0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8014ee4:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 8014ee8:	ee07 3a90 	vmov	s15, r3
 8014eec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8014ef0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014ef4:	ee17 3a90 	vmov	r3, s15
 8014ef8:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8014efc:	ed93 0a00 	vldr	s0, [r3]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8014f00:	ee37 0a00 	vadd.f32	s0, s14, s0
 8014f04:	f00f f8c2 	bl	802408c <LEAF_midiToFrequency>
                tSawtooth_setFreq(&osc[i], freq[i]);
 8014f08:	4845      	ldr	r0, [pc, #276]	; (8015020 <SFXVocoderFrame+0x248>)
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8014f0a:	ed87 0a00 	vstr	s0, [r7]
                tSawtooth_setFreq(&osc[i], freq[i]);
 8014f0e:	4420      	add	r0, r4
 8014f10:	f00f ff48 	bl	8024da4 <tSawtooth_setFreq>
 8014f14:	4b43      	ldr	r3, [pc, #268]	; (8015024 <SFXVocoderFrame+0x24c>)
                tRosenbergGlottalPulse_setFreq(&glottal[i], freq[i]);
 8014f16:	ecb7 0a01 	vldmia	r7!, {s0}
 8014f1a:	eb04 0a03 	add.w	sl, r4, r3
 8014f1e:	3404      	adds	r4, #4
 8014f20:	4650      	mov	r0, sl
 8014f22:	f00b fe6b 	bl	8020bfc <tRosenbergGlottalPulse_setFreq>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], displayValues[8] * displayValues[7], displayValues[7]);
 8014f26:	edd5 0a07 	vldr	s1, [r5, #28]
 8014f2a:	ed95 0a08 	vldr	s0, [r5, #32]
 8014f2e:	4650      	mov	r0, sl
 8014f30:	ee20 0a80 	vmul.f32	s0, s1, s0
 8014f34:	f00b fe8c 	bl	8020c50 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8014f38:	4630      	mov	r0, r6
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8014f3a:	fa5f fa89 	uxtb.w	sl, r9
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8014f3e:	f00f fe43 	bl	8024bc8 <tSimplePoly_getNumVoices>
 8014f42:	4b39      	ldr	r3, [pc, #228]	; (8015028 <SFXVocoderFrame+0x250>)
 8014f44:	4548      	cmp	r0, r9
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8014f46:	4651      	mov	r1, sl
 8014f48:	4630      	mov	r0, r6
 8014f4a:	eb04 0b03 	add.w	fp, r4, r3
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8014f4e:	f109 0901 	add.w	r9, r9, #1
 8014f52:	dca1      	bgt.n	8014e98 <SFXVocoderFrame+0xc0>
            if (tSimplePoly_getNumActiveVoices(&poly) != 0)
 8014f54:	4826      	ldr	r0, [pc, #152]	; (8014ff0 <SFXVocoderFrame+0x218>)
 8014f56:	f00f fe3b 	bl	8024bd0 <tSimplePoly_getNumActiveVoices>
 8014f5a:	b9c0      	cbnz	r0, 8014f8e <SFXVocoderFrame+0x1b6>
                tExpSmooth_setDest(&comp, 0.0f);
 8014f5c:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 8015010 <SFXVocoderFrame+0x238>
 8014f60:	4832      	ldr	r0, [pc, #200]	; (801502c <SFXVocoderFrame+0x254>)
 8014f62:	f00d fb0d 	bl	8022580 <tExpSmooth_setDest>
            tVZFilter_setGain(&shelf1, fasterdbtoa(-1.0f * displayValues[6]));
 8014f66:	ed95 0a06 	vldr	s0, [r5, #24]
 8014f6a:	eeb1 0a40 	vneg.f32	s0, s0
 8014f6e:	f00f f969 	bl	8024244 <fasterdbtoa>
 8014f72:	482f      	ldr	r0, [pc, #188]	; (8015030 <SFXVocoderFrame+0x258>)
 8014f74:	f00e fc96 	bl	80238a4 <tVZFilter_setGain>
            tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
 8014f78:	ed95 0a06 	vldr	s0, [r5, #24]
 8014f7c:	f00f f95a 	bl	8024234 <fastdbtoa>
 8014f80:	482c      	ldr	r0, [pc, #176]	; (8015034 <SFXVocoderFrame+0x25c>)
        }
 8014f82:	ecbd 8b02 	vpop	{d8}
 8014f86:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
 8014f8a:	f00e bc8b 	b.w	80238a4 <tVZFilter_setGain>
                tExpSmooth_setDest(&comp, sqrtf(1.0f / (float)tSimplePoly_getNumActiveVoices(&poly)));
 8014f8e:	4818      	ldr	r0, [pc, #96]	; (8014ff0 <SFXVocoderFrame+0x218>)
 8014f90:	f00f fe1e 	bl	8024bd0 <tSimplePoly_getNumActiveVoices>
 8014f94:	ee07 0a90 	vmov	s15, r0
 8014f98:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8014f9c:	4823      	ldr	r0, [pc, #140]	; (801502c <SFXVocoderFrame+0x254>)
 8014f9e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014fa2:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8014fa6:	eeb1 0ac0 	vsqrt.f32	s0, s0
 8014faa:	f00d fae9 	bl	8022580 <tExpSmooth_setDest>
 8014fae:	e7da      	b.n	8014f66 <SFXVocoderFrame+0x18e>
                vocFreezeLPC = !vocFreezeLPC;
 8014fb0:	4d21      	ldr	r5, [pc, #132]	; (8015038 <SFXVocoderFrame+0x260>)
                tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
 8014fb2:	4815      	ldr	r0, [pc, #84]	; (8015008 <SFXVocoderFrame+0x230>)
                vocFreezeLPC = !vocFreezeLPC;
 8014fb4:	682b      	ldr	r3, [r5, #0]
 8014fb6:	fab3 f383 	clz	r3, r3
 8014fba:	095b      	lsrs	r3, r3, #5
                tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
 8014fbc:	4619      	mov	r1, r3
                vocFreezeLPC = !vocFreezeLPC;
 8014fbe:	602b      	str	r3, [r5, #0]
                tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
 8014fc0:	f00b fd24 	bl	8020a0c <tTalkboxFloat_setFreeze>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8014fc4:	2300      	movs	r3, #0
                setLED_C(vocFreezeLPC);
 8014fc6:	6828      	ldr	r0, [r5, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8014fc8:	7723      	strb	r3, [r4, #28]
                setLED_C(vocFreezeLPC);
 8014fca:	f7fe fcdb 	bl	8013984 <setLED_C>
 8014fce:	e726      	b.n	8014e1e <SFXVocoderFrame+0x46>
                internalExternal = !internalExternal;
 8014fd0:	4a1a      	ldr	r2, [pc, #104]	; (801503c <SFXVocoderFrame+0x264>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8014fd2:	2100      	movs	r1, #0
                internalExternal = !internalExternal;
 8014fd4:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8014fd6:	7621      	strb	r1, [r4, #24]
                internalExternal = !internalExternal;
 8014fd8:	fab3 f383 	clz	r3, r3
 8014fdc:	095b      	lsrs	r3, r3, #5
                setLED_B(internalExternal);
 8014fde:	4618      	mov	r0, r3
                internalExternal = !internalExternal;
 8014fe0:	6013      	str	r3, [r2, #0]
                setLED_B(internalExternal);
 8014fe2:	f7fe fcc1 	bl	8013968 <setLED_B>
 8014fe6:	e716      	b.n	8014e16 <SFXVocoderFrame+0x3e>
 8014fe8:	2001872c 	.word	0x2001872c
 8014fec:	20000254 	.word	0x20000254
 8014ff0:	200174c8 	.word	0x200174c8
 8014ff4:	20002cb8 	.word	0x20002cb8
 8014ff8:	3ecccccd 	.word	0x3ecccccd
 8014ffc:	be4ccccd 	.word	0xbe4ccccd
 8015000:	3f8ccccd 	.word	0x3f8ccccd
 8015004:	200187dc 	.word	0x200187dc
 8015008:	2001818c 	.word	0x2001818c
 801500c:	200033e4 	.word	0x200033e4
 8015010:	00000000 	.word	0x00000000
 8015014:	200005e8 	.word	0x200005e8
 8015018:	20000668 	.word	0x20000668
 801501c:	20000634 	.word	0x20000634
 8015020:	20017284 	.word	0x20017284
 8015024:	200027f0 	.word	0x200027f0
 8015028:	20017968 	.word	0x20017968
 801502c:	20017204 	.word	0x20017204
 8015030:	200174a4 	.word	0x200174a4
 8015034:	200173cc 	.word	0x200173cc
 8015038:	20000628 	.word	0x20000628
 801503c:	200005ac 	.word	0x200005ac
 8015040:	2aaaaaab 	.word	0x2aaaaaab

08015044 <SFXVocoderTick>:
            if (internalExternal == 1)
 8015044:	4b60      	ldr	r3, [pc, #384]	; (80151c8 <SFXVocoderTick+0x184>)
        {
 8015046:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801504a:	ed2d 8b08 	vpush	{d8-d11}
            if (internalExternal == 1)
 801504e:	681b      	ldr	r3, [r3, #0]
        {
 8015050:	4680      	mov	r8, r0
 8015052:	ed90 8a01 	vldr	s16, [r0, #4]
            if (internalExternal == 1)
 8015056:	2b01      	cmp	r3, #1
 8015058:	f000 80b1 	beq.w	80151be <SFXVocoderTick+0x17a>
                zerocross = tZeroCrossing_tick(&zerox, input[1]);
 801505c:	eeb0 0a48 	vmov.f32	s0, s16
 8015060:	485a      	ldr	r0, [pc, #360]	; (80151cc <SFXVocoderTick+0x188>)
 8015062:	f009 fcd1 	bl	801ea08 <tZeroCrossing_tick>
                if (!vocChFreeze)
 8015066:	4b5a      	ldr	r3, [pc, #360]	; (80151d0 <SFXVocoderTick+0x18c>)
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
 8015068:	4f5a      	ldr	r7, [pc, #360]	; (80151d4 <SFXVocoderTick+0x190>)
                if (!vocChFreeze)
 801506a:	681b      	ldr	r3, [r3, #0]
 801506c:	2b00      	cmp	r3, #0
 801506e:	f000 808f 	beq.w	8015190 <SFXVocoderTick+0x14c>
                noiseRampVal = tExpSmooth_tick(&noiseRamp);
 8015072:	4859      	ldr	r0, [pc, #356]	; (80151d8 <SFXVocoderTick+0x194>)
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015074:	2400      	movs	r4, #0
                noiseRampVal = tExpSmooth_tick(&noiseRamp);
 8015076:	f00d fa8d 	bl	8022594 <tExpSmooth_tick>
 801507a:	eeb0 ba40 	vmov.f32	s22, s0
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
 801507e:	4857      	ldr	r0, [pc, #348]	; (80151dc <SFXVocoderTick+0x198>)
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015080:	4626      	mov	r6, r4
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
 8015082:	f00f ff33 	bl	8024eec <tNoise_tick>
 8015086:	eddf 7a56 	vldr	s15, [pc, #344]	; 80151e0 <SFXVocoderTick+0x19c>
 801508a:	ee20 0a0b 	vmul.f32	s0, s0, s22
            float sample = 0.0f;
 801508e:	ed9f 9a55 	vldr	s18, [pc, #340]	; 80151e4 <SFXVocoderTick+0x1a0>
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015092:	f8df a180 	ldr.w	sl, [pc, #384]	; 8015214 <SFXVocoderTick+0x1d0>
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 8015096:	f8df 9180 	ldr.w	r9, [pc, #384]	; 8015218 <SFXVocoderTick+0x1d4>
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
 801509a:	ee20 aa27 	vmul.f32	s20, s0, s15
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
 801509e:	eddf aa52 	vldr	s21, [pc, #328]	; 80151e8 <SFXVocoderTick+0x1a4>
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80150a2:	e026      	b.n	80150f2 <SFXVocoderTick+0xae>
 80150a4:	4d51      	ldr	r5, [pc, #324]	; (80151ec <SFXVocoderTick+0x1a8>)
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 80150a6:	f00f feaf 	bl	8024e08 <tSawtooth_tick>
 80150aa:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 80150ae:	4425      	add	r5, r4
 80150b0:	eef0 8a40 	vmov.f32	s17, s0
 80150b4:	4628      	mov	r0, r5
 80150b6:	f00d fa6d 	bl	8022594 <tExpSmooth_tick>
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
 80150ba:	484d      	ldr	r0, [pc, #308]	; (80151f0 <SFXVocoderTick+0x1ac>)
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 80150bc:	edd7 7a03 	vldr	s15, [r7, #12]
 80150c0:	ee68 8a80 	vmul.f32	s17, s17, s0
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
 80150c4:	4420      	add	r0, r4
 80150c6:	3404      	adds	r4, #4
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 80150c8:	ee38 8a67 	vsub.f32	s16, s16, s15
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
 80150cc:	f00b fd26 	bl	8020b1c <tRosenbergGlottalPulse_tickHQ>
 80150d0:	4628      	mov	r0, r5
 80150d2:	eef0 9a40 	vmov.f32	s19, s0
 80150d6:	f00d fa5d 	bl	8022594 <tExpSmooth_tick>
 80150da:	edd7 7a03 	vldr	s15, [r7, #12]
 80150de:	ee67 7aaa 	vmul.f32	s15, s15, s21
 80150e2:	ee67 7aa9 	vmul.f32	s15, s15, s19
 80150e6:	ee27 0a80 	vmul.f32	s0, s15, s0
 80150ea:	eea8 0a88 	vfma.f32	s0, s17, s16
 80150ee:	ee39 9a00 	vadd.f32	s18, s18, s0
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80150f2:	4650      	mov	r0, sl
 80150f4:	f00f fd68 	bl	8024bc8 <tSimplePoly_getNumVoices>
 80150f8:	42b0      	cmp	r0, r6
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 80150fa:	eb09 0004 	add.w	r0, r9, r4
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80150fe:	f106 0601 	add.w	r6, r6, #1
 8015102:	dccf      	bgt.n	80150a4 <SFXVocoderTick+0x60>
                sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
 8015104:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015108:	ed97 7a05 	vldr	s14, [r7, #20]
 801510c:	eddf 7a39 	vldr	s15, [pc, #228]	; 80151f4 <SFXVocoderTick+0x1b0>
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
 8015110:	4839      	ldr	r0, [pc, #228]	; (80151f8 <SFXVocoderTick+0x1b4>)
                sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
 8015112:	eeb0 8a40 	vmov.f32	s16, s0
 8015116:	ee30 0a4b 	vsub.f32	s0, s0, s22
 801511a:	eea7 8a67 	vfms.f32	s16, s14, s15
 801511e:	ee28 8a00 	vmul.f32	s16, s16, s0
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
 8015122:	f00f fee3 	bl	8024eec <tNoise_tick>
 8015126:	4835      	ldr	r0, [pc, #212]	; (80151fc <SFXVocoderTick+0x1b8>)
 8015128:	f00d fd70 	bl	8022c0c <tHighpass_tick>
 801512c:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
 8015130:	edd7 7a05 	vldr	s15, [r7, #20]
                sample *= tExpSmooth_tick(&comp);
 8015134:	4832      	ldr	r0, [pc, #200]	; (8015200 <SFXVocoderTick+0x1bc>)
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
 8015136:	ee67 7a87 	vmul.f32	s15, s15, s14
 801513a:	ee27 0a80 	vmul.f32	s0, s15, s0
 801513e:	eea9 0a08 	vfma.f32	s0, s18, s16
 8015142:	ee3a aa00 	vadd.f32	s20, s20, s0
                sample *= tExpSmooth_tick(&comp);
 8015146:	f00d fa25 	bl	8022594 <tExpSmooth_tick>
 801514a:	ed98 8a01 	vldr	s16, [r8, #4]
 801514e:	ee2a 0a00 	vmul.f32	s0, s20, s0
            sample = tanhf(sample);
 8015152:	f012 fb7b 	bl	802784c <tanhf>
            sample = tTalkboxFloat_tick(&vocoder, sample, input[1]);
 8015156:	eef0 0a48 	vmov.f32	s1, s16
 801515a:	482a      	ldr	r0, [pc, #168]	; (8015204 <SFXVocoderTick+0x1c0>)
 801515c:	f00b fb60 	bl	8020820 <tTalkboxFloat_tick>
            sample = tVZFilter_tick(&shelf1, sample); //put it through the low shelf
 8015160:	4829      	ldr	r0, [pc, #164]	; (8015208 <SFXVocoderTick+0x1c4>)
 8015162:	f00d ff65 	bl	8023030 <tVZFilter_tick>
            sample = tVZFilter_tick(&shelf2, sample); // now put that result through the high shelf
 8015166:	4829      	ldr	r0, [pc, #164]	; (801520c <SFXVocoderTick+0x1c8>)
 8015168:	f00d ff62 	bl	8023030 <tVZFilter_tick>
            sample *= displayValues[0] * 0.6f;
 801516c:	edd7 7a00 	vldr	s15, [r7]
 8015170:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 80151e0 <SFXVocoderTick+0x19c>
 8015174:	ee67 7a87 	vmul.f32	s15, s15, s14
            sample = tanhf(sample);
 8015178:	ee27 0a80 	vmul.f32	s0, s15, s0
 801517c:	f012 fb66 	bl	802784c <tanhf>
            input[0] = sample;
 8015180:	ed88 0a00 	vstr	s0, [r8]
            input[1] = sample;
 8015184:	ed88 0a01 	vstr	s0, [r8, #4]
        }
 8015188:	ecbd 8b08 	vpop	{d8-d11}
 801518c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
 8015190:	ed9f 6a1f 	vldr	s12, [pc, #124]	; 8015210 <SFXVocoderTick+0x1cc>
 8015194:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8015198:	edd7 7a04 	vldr	s15, [r7, #16]
 801519c:	ed9f 7a11 	vldr	s14, [pc, #68]	; 80151e4 <SFXVocoderTick+0x1a0>
 80151a0:	ee77 7ac6 	vsub.f32	s15, s15, s12
 80151a4:	480c      	ldr	r0, [pc, #48]	; (80151d8 <SFXVocoderTick+0x194>)
 80151a6:	eef4 7ac0 	vcmpe.f32	s15, s0
 80151aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80151ae:	bf54      	ite	pl
 80151b0:	eeb0 0a47 	vmovpl.f32	s0, s14
 80151b4:	eeb0 0a66 	vmovmi.f32	s0, s13
 80151b8:	f00d f9e2 	bl	8022580 <tExpSmooth_setDest>
 80151bc:	e759      	b.n	8015072 <SFXVocoderTick+0x2e>
                sample = input[0];
 80151be:	ed90 0a00 	vldr	s0, [r0]
 80151c2:	4f04      	ldr	r7, [pc, #16]	; (80151d4 <SFXVocoderTick+0x190>)
 80151c4:	e7c5      	b.n	8015152 <SFXVocoderTick+0x10e>
 80151c6:	bf00      	nop
 80151c8:	200005ac 	.word	0x200005ac
 80151cc:	2001763c 	.word	0x2001763c
 80151d0:	20000624 	.word	0x20000624
 80151d4:	200187dc 	.word	0x200187dc
 80151d8:	20018274 	.word	0x20018274
 80151dc:	2000340c 	.word	0x2000340c
 80151e0:	3f19999a 	.word	0x3f19999a
 80151e4:	00000000 	.word	0x00000000
 80151e8:	3ff33333 	.word	0x3ff33333
 80151ec:	20017968 	.word	0x20017968
 80151f0:	200027f0 	.word	0x200027f0
 80151f4:	3e99999a 	.word	0x3e99999a
 80151f8:	200027c0 	.word	0x200027c0
 80151fc:	20003404 	.word	0x20003404
 8015200:	20017204 	.word	0x20017204
 8015204:	2001818c 	.word	0x2001818c
 8015208:	200174a4 	.word	0x200174a4
 801520c:	200173cc 	.word	0x200173cc
 8015210:	3dcccccd 	.word	0x3dcccccd
 8015214:	200174c8 	.word	0x200174c8
 8015218:	20017284 	.word	0x20017284

0801521c <SFXVocoderFree>:
        {
 801521c:	b570      	push	{r4, r5, r6, lr}
            tTalkboxFloat_free(&vocoder);
 801521e:	4812      	ldr	r0, [pc, #72]	; (8015268 <SFXVocoderFree+0x4c>)
            tVZFilter_free(&shelf2);
 8015220:	2400      	movs	r4, #0
            tTalkboxFloat_free(&vocoder);
 8015222:	f00b f893 	bl	802034c <tTalkboxFloat_free>
            tNoise_free(&vocoderNoise);
 8015226:	4811      	ldr	r0, [pc, #68]	; (801526c <SFXVocoderFree+0x50>)
 8015228:	f00f fe5c 	bl	8024ee4 <tNoise_free>
            tZeroCrossing_free(&zerox);
 801522c:	4810      	ldr	r0, [pc, #64]	; (8015270 <SFXVocoderFree+0x54>)
 801522e:	f009 fbdb 	bl	801e9e8 <tZeroCrossing_free>
            tExpSmooth_free(&noiseRamp);
 8015232:	4810      	ldr	r0, [pc, #64]	; (8015274 <SFXVocoderFree+0x58>)
 8015234:	f00d f98e 	bl	8022554 <tExpSmooth_free>
            tNoise_free(&breathNoise);
 8015238:	480f      	ldr	r0, [pc, #60]	; (8015278 <SFXVocoderFree+0x5c>)
 801523a:	f00f fe53 	bl	8024ee4 <tNoise_free>
            tHighpass_free(&noiseHP);
 801523e:	480f      	ldr	r0, [pc, #60]	; (801527c <SFXVocoderFree+0x60>)
 8015240:	f00d fcd0 	bl	8022be4 <tHighpass_free>
            tVZFilter_free(&shelf1);
 8015244:	480e      	ldr	r0, [pc, #56]	; (8015280 <SFXVocoderFree+0x64>)
 8015246:	f00d fee5 	bl	8023014 <tVZFilter_free>
            tVZFilter_free(&shelf2);
 801524a:	480e      	ldr	r0, [pc, #56]	; (8015284 <SFXVocoderFree+0x68>)
 801524c:	4e0e      	ldr	r6, [pc, #56]	; (8015288 <SFXVocoderFree+0x6c>)
 801524e:	4d0f      	ldr	r5, [pc, #60]	; (801528c <SFXVocoderFree+0x70>)
 8015250:	f00d fee0 	bl	8023014 <tVZFilter_free>
                tSawtooth_free(&osc[i]);
 8015254:	1930      	adds	r0, r6, r4
 8015256:	f00f fda1 	bl	8024d9c <tSawtooth_free>
                tRosenbergGlottalPulse_free(&glottal[i]);
 801525a:	1928      	adds	r0, r5, r4
 801525c:	3404      	adds	r4, #4
 801525e:	f00b fbed 	bl	8020a3c <tRosenbergGlottalPulse_free>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 8015262:	2c20      	cmp	r4, #32
 8015264:	d1f6      	bne.n	8015254 <SFXVocoderFree+0x38>
        }
 8015266:	bd70      	pop	{r4, r5, r6, pc}
 8015268:	2001818c 	.word	0x2001818c
 801526c:	2000340c 	.word	0x2000340c
 8015270:	2001763c 	.word	0x2001763c
 8015274:	20018274 	.word	0x20018274
 8015278:	200027c0 	.word	0x200027c0
 801527c:	20003404 	.word	0x20003404
 8015280:	200174a4 	.word	0x200174a4
 8015284:	200173cc 	.word	0x200173cc
 8015288:	20017284 	.word	0x20017284
 801528c:	200027f0 	.word	0x200027f0

08015290 <SFXVocoderChAlloc>:
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8015290:	4bc9      	ldr	r3, [pc, #804]	; (80155b8 <SFXVocoderChAlloc+0x328>)
 8015292:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015296:	ed9f 6ac9 	vldr	s12, [pc, #804]	; 80155bc <SFXVocoderChAlloc+0x32c>
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 801529a:	eeb0 3a00 	vmov.f32	s6, #0	; 0x40000000  2.0
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 801529e:	4ac8      	ldr	r2, [pc, #800]	; (80155c0 <SFXVocoderChAlloc+0x330>)
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
 80152a0:	eebf 5a00 	vmov.f32	s10, #240	; 0xbf800000 -1.0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80152a4:	eddf 6ac7 	vldr	s13, [pc, #796]	; 80155c4 <SFXVocoderChAlloc+0x334>
 80152a8:	eef2 2a00 	vmov.f32	s5, #32	; 0x41000000  8.0
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 80152ac:	ed9f 2ac6 	vldr	s4, [pc, #792]	; 80155c8 <SFXVocoderChAlloc+0x338>
            tVZFilter_init(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f);
 80152b0:	eef0 0a08 	vmov.f32	s1, #8	; 0x40400000  3.0
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 80152b4:	ed9f 4ac5 	vldr	s8, [pc, #788]	; 80155cc <SFXVocoderChAlloc+0x33c>
            tVZFilter_init(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f);
 80152b8:	2107      	movs	r1, #7
 80152ba:	ed9f 0ac5 	vldr	s0, [pc, #788]	; 80155d0 <SFXVocoderChAlloc+0x340>
        {
 80152be:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80152c2:	ed2d 8b04 	vpush	{d8-d9}
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 80152c6:	ed93 7a00 	vldr	s14, [r3]
        {
 80152ca:	b083      	sub	sp, #12
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80152cc:	edd2 4a1b 	vldr	s9, [r2, #108]	; 0x6c
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
 80152d0:	2400      	movs	r4, #0
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 80152d2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 80152d6:	edd2 5a1c 	vldr	s11, [r2, #112]	; 0x70
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80152da:	ee64 4aa6 	vmul.f32	s9, s9, s13
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 80152de:	eddf 6abd 	vldr	s13, [pc, #756]	; 80155d4 <SFXVocoderChAlloc+0x344>
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 80152e2:	4bbd      	ldr	r3, [pc, #756]	; (80155d8 <SFXVocoderChAlloc+0x348>)
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
 80152e4:	f04f 0801 	mov.w	r8, #1
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 80152e8:	ee37 7a46 	vsub.f32	s14, s14, s12
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 80152ec:	ed9f 6abb 	vldr	s12, [pc, #748]	; 80155dc <SFXVocoderChAlloc+0x34c>
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80152f0:	eefc 4ae4 	vcvt.u32.f32	s9, s9
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 80152f4:	edd2 1a1a 	vldr	s3, [r2, #104]	; 0x68
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 80152f8:	eea5 6a83 	vfma.f32	s12, s11, s6
            displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
 80152fc:	edd2 5a23 	vldr	s11, [r2, #140]	; 0x8c
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8015300:	eec7 3a87 	vdiv.f32	s7, s15, s14
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
 8015304:	edd2 7a25 	vldr	s15, [r2, #148]	; 0x94
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8015308:	edcd 4a01 	vstr	s9, [sp, #4]
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
 801530c:	4625      	mov	r5, r4
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 801530e:	f89d 0004 	ldrb.w	r0, [sp, #4]
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8015312:	ed9f 7ab3 	vldr	s14, [pc, #716]	; 80155e0 <SFXVocoderChAlloc+0x350>
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8015316:	edd2 4a24 	vldr	s9, [r2, #144]	; 0x90
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
 801531a:	eea7 5a83 	vfma.f32	s10, s15, s6
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 801531e:	ee07 0a90 	vmov	s15, r0
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8015322:	eea1 4a82 	vfma.f32	s8, s3, s4
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8015326:	6e50      	ldr	r0, [r2, #100]	; 0x64
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8015328:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 801532c:	ed9f 2aad 	vldr	s4, [pc, #692]	; 80155e4 <SFXVocoderChAlloc+0x354>
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
 8015330:	f8d2 c074 	ldr.w	ip, [r2, #116]	; 0x74
            displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
 8015334:	ee75 5aa5 	vadd.f32	s11, s11, s11
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
 8015338:	6f97      	ldr	r7, [r2, #120]	; 0x78
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 801533a:	ee64 4a82 	vmul.f32	s9, s9, s4
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 801533e:	ee77 7aa2 	vadd.f32	s15, s15, s5
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
 8015342:	f8d2 6080 	ldr.w	r6, [r2, #128]	; 0x80
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8015346:	6018      	str	r0, [r3, #0]
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
 8015348:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 801534c:	edc3 7a02 	vstr	s15, [r3, #8]
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
 8015350:	f8d2 e098 	ldr.w	lr, [r2, #152]	; 0x98
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
 8015354:	f8d2 a07c 	ldr.w	sl, [r2, #124]	; 0x7c
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 8015358:	ee63 6aa6 	vmul.f32	s13, s7, s13
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
 801535c:	f8d2 9084 	ldr.w	r9, [r2, #132]	; 0x84
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
 8015360:	f8c3 c010 	str.w	ip, [r3, #16]
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
 8015364:	615f      	str	r7, [r3, #20]
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8015366:	ee66 7a87 	vmul.f32	s15, s13, s14
            displayValues[14] = presetKnobValues[VocoderCh][14]; //odd/even
 801536a:	f8d2 c09c 	ldr.w	ip, [r2, #156]	; 0x9c
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
 801536e:	61de      	str	r6, [r3, #28]
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8015370:	4a9d      	ldr	r2, [pc, #628]	; (80155e8 <SFXVocoderChAlloc+0x358>)
            thisBandwidth = bandWidthInOctaves * myQ;
 8015372:	ee26 7a27 	vmul.f32	s14, s12, s15
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8015376:	4f9d      	ldr	r7, [pc, #628]	; (80155ec <SFXVocoderChAlloc+0x35c>)
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 8015378:	f8df b2e4 	ldr.w	fp, [pc, #740]	; 8015660 <SFXVocoderChAlloc+0x3d0>
            thisBandwidth = bandWidthInOctaves * myQ;
 801537c:	4e9c      	ldr	r6, [pc, #624]	; (80155f0 <SFXVocoderChAlloc+0x360>)
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
 801537e:	6258      	str	r0, [r3, #36]	; 0x24
            tVZFilter_init(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f);
 8015380:	489c      	ldr	r0, [pc, #624]	; (80155f4 <SFXVocoderChAlloc+0x364>)
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
 8015382:	f8c3 a018 	str.w	sl, [r3, #24]
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
 8015386:	f8c3 9020 	str.w	r9, [r3, #32]
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 801538a:	ed83 4a01 	vstr	s8, [r3, #4]
            displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
 801538e:	edc3 5a0a 	vstr	s11, [r3, #40]	; 0x28
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8015392:	edc3 4a0b 	vstr	s9, [r3, #44]	; 0x2c
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
 8015396:	ed83 5a0c 	vstr	s10, [r3, #48]	; 0x30
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 801539a:	ed83 6a03 	vstr	s12, [r3, #12]
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 801539e:	edc7 3a00 	vstr	s7, [r7]
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
 80153a2:	f8c3 e034 	str.w	lr, [r3, #52]	; 0x34
            displayValues[14] = presetKnobValues[VocoderCh][14]; //odd/even
 80153a6:	f8c3 c038 	str.w	ip, [r3, #56]	; 0x38
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 80153aa:	edcb 6a00 	vstr	s13, [fp]
            thisBandwidth = bandWidthInOctaves * myQ;
 80153ae:	ed86 7a00 	vstr	s14, [r6]
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 80153b2:	edc2 7a00 	vstr	s15, [r2]
            tVZFilter_init(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f);
 80153b6:	f00d fc39 	bl	8022c2c <tVZFilter_init>
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
 80153ba:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 80153be:	488d      	ldr	r0, [pc, #564]	; (80155f4 <SFXVocoderChAlloc+0x364>)
 80153c0:	f8df a2a0 	ldr.w	sl, [pc, #672]	; 8015664 <SFXVocoderChAlloc+0x3d4>
 80153c4:	f00e fa6e 	bl	80238a4 <tVZFilter_setGain>
 80153c8:	f8df 929c 	ldr.w	r9, [pc, #668]	; 8015668 <SFXVocoderChAlloc+0x3d8>
 80153cc:	4f8a      	ldr	r7, [pc, #552]	; (80155f8 <SFXVocoderChAlloc+0x368>)
                tExpSmooth_init(&envFollowers[i], 0.0f, 0.001f); // factor of .001 is 10 ms?
 80153ce:	ed9f 9a8b 	vldr	s18, [pc, #556]	; 80155fc <SFXVocoderChAlloc+0x36c>
 80153d2:	eddf 8a8b 	vldr	s17, [pc, #556]	; 8015600 <SFXVocoderChAlloc+0x370>
 80153d6:	e004      	b.n	80153e2 <SFXVocoderChAlloc+0x152>
 80153d8:	3501      	adds	r5, #1
 80153da:	f108 0801 	add.w	r8, r8, #1
 80153de:	3704      	adds	r7, #4
 80153e0:	3408      	adds	r4, #8
                float bandFreq = faster_mtof(((float)i * bandWidthInSemitones) + 30.0f); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
 80153e2:	ee07 5a90 	vmov	s15, r5
 80153e6:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 80153ea:	ed9b 7a00 	vldr	s14, [fp]
 80153ee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80153f2:	eea7 0a87 	vfma.f32	s0, s15, s14
 80153f6:	f00e fecd 	bl	8024194 <faster_mtof>
                bandGains[i] = 1.0f;
 80153fa:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
                float bandFreq = faster_mtof(((float)i * bandWidthInSemitones) + 30.0f); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
 80153fe:	eeb0 8a40 	vmov.f32	s16, s0
                    tVZFilter_init(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth);
 8015402:	eb0a 0004 	add.w	r0, sl, r4
 8015406:	2103      	movs	r1, #3
                bandGains[i] = 1.0f;
 8015408:	f849 3b04 	str.w	r3, [r9], #4
                if (i == 0)
 801540c:	2d00      	cmp	r5, #0
 801540e:	f000 80ad 	beq.w	801556c <SFXVocoderChAlloc+0x2dc>
 8015412:	edd6 7a00 	vldr	s15, [r6]
                else if (i == (MAX_NUM_VOCODER_BANDS-1))
 8015416:	2d17      	cmp	r5, #23
                    tVZFilter_init(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth);
 8015418:	eef0 0a67 	vmov.f32	s1, s15
                else if (i == (MAX_NUM_VOCODER_BANDS-1))
 801541c:	f000 8082 	beq.w	8015524 <SFXVocoderChAlloc+0x294>
                    tVZFilter_init(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth);
 8015420:	f00d fc04 	bl	8022c2c <tVZFilter_init>
                    tVZFilter_init(&analysisBands[i][1], BandpassPeak, bandFreq, thisBandwidth);
 8015424:	4b77      	ldr	r3, [pc, #476]	; (8015604 <SFXVocoderChAlloc+0x374>)
 8015426:	edd6 0a00 	vldr	s1, [r6]
 801542a:	eeb0 0a48 	vmov.f32	s0, s16
 801542e:	1918      	adds	r0, r3, r4
 8015430:	2103      	movs	r1, #3
 8015432:	f00d fbfb 	bl	8022c2c <tVZFilter_init>
                    tVZFilter_init(&synthesisBands[i][0], BandpassPeak, bandFreq, thisBandwidth);
 8015436:	4b74      	ldr	r3, [pc, #464]	; (8015608 <SFXVocoderChAlloc+0x378>)
 8015438:	edd6 0a00 	vldr	s1, [r6]
 801543c:	eeb0 0a48 	vmov.f32	s0, s16
 8015440:	1918      	adds	r0, r3, r4
 8015442:	2103      	movs	r1, #3
 8015444:	f00d fbf2 	bl	8022c2c <tVZFilter_init>
                    tVZFilter_init(&synthesisBands[i][1], BandpassPeak, bandFreq, thisBandwidth);
 8015448:	4b70      	ldr	r3, [pc, #448]	; (801560c <SFXVocoderChAlloc+0x37c>)
 801544a:	eeb0 0a48 	vmov.f32	s0, s16
 801544e:	edd6 0a00 	vldr	s1, [r6]
 8015452:	1918      	adds	r0, r3, r4
 8015454:	2103      	movs	r1, #3
 8015456:	f00d fbe9 	bl	8022c2c <tVZFilter_init>
                tExpSmooth_init(&envFollowers[i], 0.0f, 0.001f); // factor of .001 is 10 ms?
 801545a:	eef0 0a49 	vmov.f32	s1, s18
 801545e:	eeb0 0a68 	vmov.f32	s0, s17
 8015462:	4638      	mov	r0, r7
 8015464:	f00d f826 	bl	80224b4 <tExpSmooth_init>
            for (int i = 0; i < MAX_NUM_VOCODER_BANDS; i++)
 8015468:	f1b8 0f18 	cmp.w	r8, #24
 801546c:	d1b4      	bne.n	80153d8 <SFXVocoderChAlloc+0x148>
            tNoise_init(&breathNoise, WhiteNoise);
 801546e:	2100      	movs	r1, #0
 8015470:	4867      	ldr	r0, [pc, #412]	; (8015610 <SFXVocoderChAlloc+0x380>)
 8015472:	f00f fd25 	bl	8024ec0 <tNoise_init>
            tSimplePoly_setNumVoices(&poly, numVoices);
 8015476:	f8df 81f4 	ldr.w	r8, [pc, #500]	; 801566c <SFXVocoderChAlloc+0x3dc>
            tNoise_init(&vocoderNoise, WhiteNoise);
 801547a:	2100      	movs	r1, #0
 801547c:	4865      	ldr	r0, [pc, #404]	; (8015614 <SFXVocoderChAlloc+0x384>)
 801547e:	f00f fd1f 	bl	8024ec0 <tNoise_init>
            tZeroCrossing_init(&zerox, 256);
 8015482:	f44f 7180 	mov.w	r1, #256	; 0x100
 8015486:	4864      	ldr	r0, [pc, #400]	; (8015618 <SFXVocoderChAlloc+0x388>)
            tHighpass_init(&chVocFinalHP2, 20.0f);
 8015488:	2400      	movs	r4, #0
            tZeroCrossing_init(&zerox, 256);
 801548a:	f009 fa83 	bl	801e994 <tZeroCrossing_init>
            tSimplePoly_setNumVoices(&poly, numVoices);
 801548e:	f898 1000 	ldrb.w	r1, [r8]
 8015492:	4862      	ldr	r0, [pc, #392]	; (801561c <SFXVocoderChAlloc+0x38c>)
 8015494:	f00f fb90 	bl	8024bb8 <tSimplePoly_setNumVoices>
            tExpSmooth_init(&noiseRamp, 0.0f, 0.05f);
 8015498:	eddf 0a61 	vldr	s1, [pc, #388]	; 8015620 <SFXVocoderChAlloc+0x390>
 801549c:	ed9f 0a58 	vldr	s0, [pc, #352]	; 8015600 <SFXVocoderChAlloc+0x370>
 80154a0:	4860      	ldr	r0, [pc, #384]	; (8015624 <SFXVocoderChAlloc+0x394>)
 80154a2:	f00d f807 	bl	80224b4 <tExpSmooth_init>
            tHighpass_init(&noiseHP, 5000.0f);
 80154a6:	ed9f 0a60 	vldr	s0, [pc, #384]	; 8015628 <SFXVocoderChAlloc+0x398>
 80154aa:	4860      	ldr	r0, [pc, #384]	; (801562c <SFXVocoderChAlloc+0x39c>)
 80154ac:	f00d fb5a 	bl	8022b64 <tHighpass_init>
            tHighpass_init(&chVocFinalHP1, 20.0f);
 80154b0:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 80154b4:	485e      	ldr	r0, [pc, #376]	; (8015630 <SFXVocoderChAlloc+0x3a0>)
 80154b6:	f00d fb55 	bl	8022b64 <tHighpass_init>
            tHighpass_init(&chVocFinalHP2, 20.0f);
 80154ba:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 80154be:	485d      	ldr	r0, [pc, #372]	; (8015634 <SFXVocoderChAlloc+0x3a4>)
 80154c0:	4f5d      	ldr	r7, [pc, #372]	; (8015638 <SFXVocoderChAlloc+0x3a8>)
 80154c2:	4e5e      	ldr	r6, [pc, #376]	; (801563c <SFXVocoderChAlloc+0x3ac>)
                tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
 80154c4:	eddf 8a5e 	vldr	s17, [pc, #376]	; 8015640 <SFXVocoderChAlloc+0x3b0>
                tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
 80154c8:	ed9f 8a5e 	vldr	s16, [pc, #376]	; 8015644 <SFXVocoderChAlloc+0x3b4>
            tHighpass_init(&chVocFinalHP2, 20.0f);
 80154cc:	f00d fb4a 	bl	8022b64 <tHighpass_init>
 80154d0:	1935      	adds	r5, r6, r4
                tSawtooth_init(&osc[i]);
 80154d2:	1938      	adds	r0, r7, r4
 80154d4:	f00f fc3e 	bl	8024d54 <tSawtooth_init>
 80154d8:	3404      	adds	r4, #4
                tRosenbergGlottalPulse_init(&glottal[i]);
 80154da:	4628      	mov	r0, r5
 80154dc:	f00b fa9a 	bl	8020a14 <tRosenbergGlottalPulse_init>
                tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
 80154e0:	eeb0 0a68 	vmov.f32	s0, s17
 80154e4:	4628      	mov	r0, r5
 80154e6:	f00b fb97 	bl	8020c18 <tRosenbergGlottalPulse_setOpenLength>
                tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
 80154ea:	eeb0 0a48 	vmov.f32	s0, s16
 80154ee:	4628      	mov	r0, r5
 80154f0:	f00b fba0 	bl	8020c34 <tRosenbergGlottalPulse_setPulseLength>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 80154f4:	2c20      	cmp	r4, #32
 80154f6:	d1eb      	bne.n	80154d0 <SFXVocoderChAlloc+0x240>
            setLED_A(numVoices == 1);
 80154f8:	f8d8 0000 	ldr.w	r0, [r8]
 80154fc:	f1a0 0001 	sub.w	r0, r0, #1
 8015500:	fab0 f080 	clz	r0, r0
 8015504:	0940      	lsrs	r0, r0, #5
 8015506:	f7fe fa21 	bl	801394c <setLED_A>
            setLED_B(internalExternal);
 801550a:	4b4f      	ldr	r3, [pc, #316]	; (8015648 <SFXVocoderChAlloc+0x3b8>)
 801550c:	6818      	ldr	r0, [r3, #0]
 801550e:	f7fe fa2b 	bl	8013968 <setLED_B>
            setLED_C(vocChFreeze);
 8015512:	4b4e      	ldr	r3, [pc, #312]	; (801564c <SFXVocoderChAlloc+0x3bc>)
 8015514:	6818      	ldr	r0, [r3, #0]
        }
 8015516:	b003      	add	sp, #12
 8015518:	ecbd 8b04 	vpop	{d8-d9}
 801551c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            setLED_C(vocChFreeze);
 8015520:	f7fe ba30 	b.w	8013984 <setLED_C>
                    tVZFilter_init(&analysisBands[i][0], Highpass, bandFreq, thisBandwidth);
 8015524:	2100      	movs	r1, #0
 8015526:	484a      	ldr	r0, [pc, #296]	; (8015650 <SFXVocoderChAlloc+0x3c0>)
 8015528:	f00d fb80 	bl	8022c2c <tVZFilter_init>
                    tVZFilter_init(&analysisBands[i][1], Highpass, bandFreq, thisBandwidth);
 801552c:	edd6 0a00 	vldr	s1, [r6]
 8015530:	eeb0 0a48 	vmov.f32	s0, s16
 8015534:	2100      	movs	r1, #0
 8015536:	4847      	ldr	r0, [pc, #284]	; (8015654 <SFXVocoderChAlloc+0x3c4>)
 8015538:	f00d fb78 	bl	8022c2c <tVZFilter_init>
                    tVZFilter_init(&synthesisBands[i][0], Highpass, bandFreq, thisBandwidth);
 801553c:	edd6 0a00 	vldr	s1, [r6]
 8015540:	eeb0 0a48 	vmov.f32	s0, s16
 8015544:	2100      	movs	r1, #0
 8015546:	4844      	ldr	r0, [pc, #272]	; (8015658 <SFXVocoderChAlloc+0x3c8>)
 8015548:	f00d fb70 	bl	8022c2c <tVZFilter_init>
                    tVZFilter_init(&synthesisBands[i][1], Highpass, bandFreq, thisBandwidth);
 801554c:	eeb0 0a48 	vmov.f32	s0, s16
 8015550:	edd6 0a00 	vldr	s1, [r6]
 8015554:	2100      	movs	r1, #0
 8015556:	4841      	ldr	r0, [pc, #260]	; (801565c <SFXVocoderChAlloc+0x3cc>)
 8015558:	f00d fb68 	bl	8022c2c <tVZFilter_init>
                tExpSmooth_init(&envFollowers[i], 0.0f, 0.001f); // factor of .001 is 10 ms?
 801555c:	4638      	mov	r0, r7
 801555e:	eddf 0a27 	vldr	s1, [pc, #156]	; 80155fc <SFXVocoderChAlloc+0x36c>
 8015562:	ed9f 0a27 	vldr	s0, [pc, #156]	; 8015600 <SFXVocoderChAlloc+0x370>
 8015566:	f00c ffa5 	bl	80224b4 <tExpSmooth_init>
 801556a:	e780      	b.n	801546e <SFXVocoderChAlloc+0x1de>
                    tVZFilter_init(&analysisBands[i][0], Lowpass, bandFreq, thisBandwidth);
 801556c:	edd6 0a00 	vldr	s1, [r6]
 8015570:	4650      	mov	r0, sl
 8015572:	2101      	movs	r1, #1
 8015574:	f00d fb5a 	bl	8022c2c <tVZFilter_init>
                    tVZFilter_init(&analysisBands[i][1], Lowpass, bandFreq, thisBandwidth);
 8015578:	edd6 0a00 	vldr	s1, [r6]
 801557c:	eeb0 0a48 	vmov.f32	s0, s16
 8015580:	2101      	movs	r1, #1
 8015582:	4820      	ldr	r0, [pc, #128]	; (8015604 <SFXVocoderChAlloc+0x374>)
 8015584:	f00d fb52 	bl	8022c2c <tVZFilter_init>
                    tVZFilter_init(&synthesisBands[i][0], Lowpass, bandFreq,thisBandwidth);
 8015588:	edd6 0a00 	vldr	s1, [r6]
 801558c:	eeb0 0a48 	vmov.f32	s0, s16
 8015590:	2101      	movs	r1, #1
 8015592:	481d      	ldr	r0, [pc, #116]	; (8015608 <SFXVocoderChAlloc+0x378>)
 8015594:	f00d fb4a 	bl	8022c2c <tVZFilter_init>
                    tVZFilter_init(&synthesisBands[i][1], Lowpass, bandFreq,thisBandwidth);
 8015598:	eeb0 0a48 	vmov.f32	s0, s16
 801559c:	edd6 0a00 	vldr	s1, [r6]
 80155a0:	2101      	movs	r1, #1
 80155a2:	481a      	ldr	r0, [pc, #104]	; (801560c <SFXVocoderChAlloc+0x37c>)
 80155a4:	f00d fb42 	bl	8022c2c <tVZFilter_init>
                tExpSmooth_init(&envFollowers[i], 0.0f, 0.001f); // factor of .001 is 10 ms?
 80155a8:	eef0 0a49 	vmov.f32	s1, s18
 80155ac:	eeb0 0a68 	vmov.f32	s0, s17
 80155b0:	4638      	mov	r0, r7
 80155b2:	f00c ff7f 	bl	80224b4 <tExpSmooth_init>
 80155b6:	e70f      	b.n	80153d8 <SFXVocoderChAlloc+0x148>
 80155b8:	20000258 	.word	0x20000258
 80155bc:	3f7d70a4 	.word	0x3f7d70a4
 80155c0:	20002cb8 	.word	0x20002cb8
 80155c4:	41873333 	.word	0x41873333
 80155c8:	3f4ccccd 	.word	0x3f4ccccd
 80155cc:	becccccd 	.word	0xbecccccd
 80155d0:	45bb8000 	.word	0x45bb8000
 80155d4:	42c60000 	.word	0x42c60000
 80155d8:	200187dc 	.word	0x200187dc
 80155dc:	3dcccccd 	.word	0x3dcccccd
 80155e0:	3daaaaab 	.word	0x3daaaaab
 80155e4:	42700000 	.word	0x42700000
 80155e8:	20003410 	.word	0x20003410
 80155ec:	20000248 	.word	0x20000248
 80155f0:	200027e8 	.word	0x200027e8
 80155f4:	2001759c 	.word	0x2001759c
 80155f8:	200175d8 	.word	0x200175d8
 80155fc:	3a83126f 	.word	0x3a83126f
 8015600:	00000000 	.word	0x00000000
 8015604:	20018288 	.word	0x20018288
 8015608:	200173d0 	.word	0x200173d0
 801560c:	200173d4 	.word	0x200173d4
 8015610:	200027c0 	.word	0x200027c0
 8015614:	2000340c 	.word	0x2000340c
 8015618:	2001763c 	.word	0x2001763c
 801561c:	200174c8 	.word	0x200174c8
 8015620:	3d4ccccd 	.word	0x3d4ccccd
 8015624:	20018274 	.word	0x20018274
 8015628:	459c4000 	.word	0x459c4000
 801562c:	20003404 	.word	0x20003404
 8015630:	200027e4 	.word	0x200027e4
 8015634:	20018278 	.word	0x20018278
 8015638:	20017284 	.word	0x20017284
 801563c:	200027f0 	.word	0x200027f0
 8015640:	3e99999a 	.word	0x3e99999a
 8015644:	3ecccccd 	.word	0x3ecccccd
 8015648:	200005ac 	.word	0x200005ac
 801564c:	20000624 	.word	0x20000624
 8015650:	2001833c 	.word	0x2001833c
 8015654:	20018340 	.word	0x20018340
 8015658:	20017488 	.word	0x20017488
 801565c:	2001748c 	.word	0x2001748c
 8015660:	200174bc 	.word	0x200174bc
 8015664:	20018284 	.word	0x20018284
 8015668:	20017220 	.word	0x20017220
 801566c:	20000254 	.word	0x20000254

08015670 <SFXVocoderChFrame>:
        {
 8015670:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8015674:	4c4c      	ldr	r4, [pc, #304]	; (80157a8 <SFXVocoderChFrame+0x138>)
        {
 8015676:	ed2d 8b08 	vpush	{d8-d11}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801567a:	7d21      	ldrb	r1, [r4, #20]
        {
 801567c:	b087      	sub	sp, #28
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801567e:	2901      	cmp	r1, #1
 8015680:	d112      	bne.n	80156a8 <SFXVocoderChFrame+0x38>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8015682:	4d4a      	ldr	r5, [pc, #296]	; (80157ac <SFXVocoderChFrame+0x13c>)
                tSimplePoly_setNumVoices(&poly, numVoices);
 8015684:	484a      	ldr	r0, [pc, #296]	; (80157b0 <SFXVocoderChFrame+0x140>)
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8015686:	682b      	ldr	r3, [r5, #0]
 8015688:	2b01      	cmp	r3, #1
 801568a:	bfd8      	it	le
 801568c:	2108      	movle	r1, #8
 801568e:	6029      	str	r1, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
 8015690:	f00f fa92 	bl	8024bb8 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
 8015694:	6828      	ldr	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8015696:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
 8015698:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801569c:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
 801569e:	fab0 f080 	clz	r0, r0
 80156a2:	0940      	lsrs	r0, r0, #5
 80156a4:	f7fe f952 	bl	801394c <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 80156a8:	7e23      	ldrb	r3, [r4, #24]
 80156aa:	2b01      	cmp	r3, #1
 80156ac:	f000 8296 	beq.w	8015bdc <SFXVocoderChFrame+0x56c>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 80156b0:	7f23      	ldrb	r3, [r4, #28]
 80156b2:	2b01      	cmp	r3, #1
 80156b4:	f000 82a1 	beq.w	8015bfa <SFXVocoderChFrame+0x58a>
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 80156b8:	4b3e      	ldr	r3, [pc, #248]	; (80157b4 <SFXVocoderChFrame+0x144>)
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 80156ba:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80156be:	eddf 6a3e 	vldr	s13, [pc, #248]	; 80157b8 <SFXVocoderChFrame+0x148>
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
 80156c2:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80156c6:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
 80156ca:	eeb8 6a00 	vmov.f32	s12, #128	; 0xc0000000 -2.0
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 80156ce:	ed93 5a1c 	vldr	s10, [r3, #112]	; 0x70
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
 80156d2:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80156d6:	ee27 7a26 	vmul.f32	s14, s14, s13
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 80156da:	eddf 4a38 	vldr	s9, [pc, #224]	; 80157bc <SFXVocoderChFrame+0x14c>
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 80156de:	ed93 2a1a 	vldr	s4, [r3, #104]	; 0x68
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80156e2:	eef2 2a00 	vmov.f32	s5, #32	; 0x41000000  8.0
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 80156e6:	eee5 4a27 	vfma.f32	s9, s10, s15
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 80156ea:	ed9f 3a35 	vldr	s6, [pc, #212]	; 80157c0 <SFXVocoderChFrame+0x150>
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80156ee:	eebc 7ac7 	vcvt.u32.f32	s14, s14
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 80156f2:	ed9f 4a34 	vldr	s8, [pc, #208]	; 80157c4 <SFXVocoderChFrame+0x154>
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
 80156f6:	ed93 5a23 	vldr	s10, [r3, #140]	; 0x8c
            chVocOutputGain = 9.0f * displayValues[0];
 80156fa:	eef2 6a02 	vmov.f32	s13, #34	; 0x41100000  9.0
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 80156fe:	eea2 4a03 	vfma.f32	s8, s4, s6
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8015702:	ed93 3a19 	vldr	s6, [r3, #100]	; 0x64
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8015706:	ed8d 7a00 	vstr	s14, [sp]
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
 801570a:	ee35 5a23 	vadd.f32	s10, s10, s7
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 801570e:	f89d 2000 	ldrb.w	r2, [sp]
            chVocOutputGain = 9.0f * displayValues[0];
 8015712:	ee63 6a26 	vmul.f32	s13, s6, s13
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
 8015716:	ed93 7a25 	vldr	s14, [r3, #148]	; 0x94
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801571a:	2500      	movs	r5, #0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 801571c:	ee07 2a90 	vmov	s15, r2
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
 8015720:	edd3 3a26 	vldr	s7, [r3, #152]	; 0x98
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
 8015724:	eea7 6a25 	vfma.f32	s12, s14, s11
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8015728:	ed9f 2a27 	vldr	s4, [pc, #156]	; 80157c8 <SFXVocoderChFrame+0x158>
            oneMinusStereo = 1.0f - displayValues[13];
 801572c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8015730:	edd3 5a24 	vldr	s11, [r3, #144]	; 0x90
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8015734:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8015738:	4c24      	ldr	r4, [pc, #144]	; (80157cc <SFXVocoderChFrame+0x15c>)
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
 801573a:	6f5e      	ldr	r6, [r3, #116]	; 0x74
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 801573c:	ee65 5a82 	vmul.f32	s11, s11, s4
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
 8015740:	6f98      	ldr	r0, [r3, #120]	; 0x78
            oneMinusStereo = 1.0f - displayValues[13];
 8015742:	ee37 7a63 	vsub.f32	s14, s14, s7
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
 8015746:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8015748:	ee77 7aa2 	vadd.f32	s15, s15, s5
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
 801574c:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015750:	46a9      	mov	r9, r5
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
 8015752:	6126      	str	r6, [r4, #16]
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
 8015754:	6160      	str	r0, [r4, #20]
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
 8015756:	f8d3 6084 	ldr.w	r6, [r3, #132]	; 0x84
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
 801575a:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
 801575e:	61a1      	str	r1, [r4, #24]
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
 8015760:	61e2      	str	r2, [r4, #28]
            displayValues[14] = presetKnobValues[VocoderCh][14]; //snap to bark scale
 8015762:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
            chVocOutputGain = 9.0f * displayValues[0];
 8015766:	4a1a      	ldr	r2, [pc, #104]	; (80157d0 <SFXVocoderChFrame+0x160>)
            oneMinusStereo = 1.0f - displayValues[13];
 8015768:	4b1a      	ldr	r3, [pc, #104]	; (80157d4 <SFXVocoderChFrame+0x164>)
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
 801576a:	6226      	str	r6, [r4, #32]
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 801576c:	edc4 7a02 	vstr	s15, [r4, #8]
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8015770:	ed84 4a01 	vstr	s8, [r4, #4]
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8015774:	edc4 4a03 	vstr	s9, [r4, #12]
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
 8015778:	6260      	str	r0, [r4, #36]	; 0x24
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
 801577a:	ed84 5a0a 	vstr	s10, [r4, #40]	; 0x28
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 801577e:	edc4 5a0b 	vstr	s11, [r4, #44]	; 0x2c
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
 8015782:	ed84 6a0c 	vstr	s12, [r4, #48]	; 0x30
            displayValues[14] = presetKnobValues[VocoderCh][14]; //snap to bark scale
 8015786:	63a1      	str	r1, [r4, #56]	; 0x38
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8015788:	ed84 3a00 	vstr	s6, [r4]
            chVocOutputGain = 9.0f * displayValues[0];
 801578c:	edc2 6a00 	vstr	s13, [r2]
 8015790:	4f11      	ldr	r7, [pc, #68]	; (80157d8 <SFXVocoderChFrame+0x168>)
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
 8015792:	edc4 3a0d 	vstr	s7, [r4, #52]	; 0x34
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015796:	4e06      	ldr	r6, [pc, #24]	; (80157b0 <SFXVocoderChFrame+0x140>)
            oneMinusStereo = 1.0f - displayValues[13];
 8015798:	ed83 7a00 	vstr	s14, [r3]
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 801579c:	ed9f 8a0f 	vldr	s16, [pc, #60]	; 80157dc <SFXVocoderChFrame+0x16c>
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80157a0:	f8df 803c 	ldr.w	r8, [pc, #60]	; 80157e0 <SFXVocoderChFrame+0x170>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80157a4:	e06e      	b.n	8015884 <SFXVocoderChFrame+0x214>
 80157a6:	bf00      	nop
 80157a8:	2001872c 	.word	0x2001872c
 80157ac:	20000254 	.word	0x20000254
 80157b0:	200174c8 	.word	0x200174c8
 80157b4:	20002cb8 	.word	0x20002cb8
 80157b8:	41873333 	.word	0x41873333
 80157bc:	3dcccccd 	.word	0x3dcccccd
 80157c0:	3f4ccccd 	.word	0x3f4ccccd
 80157c4:	becccccd 	.word	0xbecccccd
 80157c8:	42700000 	.word	0x42700000
 80157cc:	200187dc 	.word	0x200187dc
 80157d0:	200001f0 	.word	0x200001f0
 80157d4:	2000025c 	.word	0x2000025c
 80157d8:	200033e4 	.word	0x200033e4
 80157dc:	00000000 	.word	0x00000000
 80157e0:	2aaaaaab 	.word	0x2aaaaaab
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 80157e4:	f00f fa18 	bl	8024c18 <tSimplePoly_getVelocity>
 80157e8:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80157ec:	2800      	cmp	r0, #0
 80157ee:	4658      	mov	r0, fp
 80157f0:	fe30 0a08 	vselgt.f32	s0, s0, s16
 80157f4:	f00c fec4 	bl	8022580 <tExpSmooth_setDest>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 80157f8:	4651      	mov	r1, sl
 80157fa:	4630      	mov	r0, r6
 80157fc:	f00f fa00 	bl	8024c00 <tSimplePoly_getPitch>
 8015800:	ee07 0a90 	vmov	s15, r0
 8015804:	4ad0      	ldr	r2, [pc, #832]	; (8015b48 <SFXVocoderChFrame+0x4d8>)
 8015806:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801580a:	4bd0      	ldr	r3, [pc, #832]	; (8015b4c <SFXVocoderChFrame+0x4dc>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801580c:	ed92 0a00 	vldr	s0, [r2]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8015810:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8015812:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8015816:	49ce      	ldr	r1, [pc, #824]	; (8015b50 <SFXVocoderChFrame+0x4e0>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8015818:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801581c:	ee17 3a90 	vmov	r3, s15
 8015820:	1a9b      	subs	r3, r3, r2
 8015822:	fb88 2003 	smull	r2, r0, r8, r3
 8015826:	17da      	asrs	r2, r3, #31
 8015828:	ebc2 0260 	rsb	r2, r2, r0, asr #1
 801582c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8015830:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 8015834:	ee07 3a90 	vmov	s15, r3
 8015838:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801583c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8015840:	ee17 3a90 	vmov	r3, s15
 8015844:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8015848:	ed93 0a00 	vldr	s0, [r3]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801584c:	ee37 0a00 	vadd.f32	s0, s14, s0
 8015850:	f00e fc1c 	bl	802408c <LEAF_midiToFrequency>
                tSawtooth_setFreq(&osc[i], freq[i]);
 8015854:	48bf      	ldr	r0, [pc, #764]	; (8015b54 <SFXVocoderChFrame+0x4e4>)
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8015856:	ed87 0a00 	vstr	s0, [r7]
                tSawtooth_setFreq(&osc[i], freq[i]);
 801585a:	4428      	add	r0, r5
 801585c:	f00f faa2 	bl	8024da4 <tSawtooth_setFreq>
 8015860:	4bbd      	ldr	r3, [pc, #756]	; (8015b58 <SFXVocoderChFrame+0x4e8>)
                tRosenbergGlottalPulse_setFreq(&glottal[i], freq[i]);
 8015862:	ecb7 0a01 	vldmia	r7!, {s0}
 8015866:	eb05 0a03 	add.w	sl, r5, r3
 801586a:	3504      	adds	r5, #4
 801586c:	4650      	mov	r0, sl
 801586e:	f00b f9c5 	bl	8020bfc <tRosenbergGlottalPulse_setFreq>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], displayValues[6] * displayValues[7], displayValues[6]);
 8015872:	edd4 0a06 	vldr	s1, [r4, #24]
 8015876:	ed94 0a07 	vldr	s0, [r4, #28]
 801587a:	4650      	mov	r0, sl
 801587c:	ee20 0a80 	vmul.f32	s0, s1, s0
 8015880:	f00b f9e6 	bl	8020c50 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015884:	4630      	mov	r0, r6
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8015886:	fa5f fa89 	uxtb.w	sl, r9
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801588a:	f00f f99d 	bl	8024bc8 <tSimplePoly_getNumVoices>
 801588e:	4bb3      	ldr	r3, [pc, #716]	; (8015b5c <SFXVocoderChFrame+0x4ec>)
 8015890:	4548      	cmp	r0, r9
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8015892:	4651      	mov	r1, sl
 8015894:	4630      	mov	r0, r6
 8015896:	eb05 0b03 	add.w	fp, r5, r3
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801589a:	f109 0901 	add.w	r9, r9, #1
 801589e:	dca1      	bgt.n	80157e4 <SFXVocoderChFrame+0x174>
            numberOfVocoderBands = displayValues[2];
 80158a0:	ed94 7a02 	vldr	s14, [r4, #8]
            float warpFactor = 1.0f + displayValues[1];
 80158a4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 80158a8:	4ead      	ldr	r6, [pc, #692]	; (8015b60 <SFXVocoderChFrame+0x4f0>)
            numberOfVocoderBands = displayValues[2];
 80158aa:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 80158ae:	4dad      	ldr	r5, [pc, #692]	; (8015b64 <SFXVocoderChFrame+0x4f4>)
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 80158b0:	6833      	ldr	r3, [r6, #0]
            float warpFactor = 1.0f + displayValues[1];
 80158b2:	edd4 8a01 	vldr	s17, [r4, #4]
            numberOfVocoderBands = displayValues[2];
 80158b6:	ee17 1a10 	vmov	r1, s14
 80158ba:	ed85 7a00 	vstr	s14, [r5]
            float warpFactor = 1.0f + displayValues[1];
 80158be:	ee78 8aa7 	vadd.f32	s17, s17, s15
            float myQ = displayValues[3];
 80158c2:	ed94 8a03 	vldr	s16, [r4, #12]
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 80158c6:	4299      	cmp	r1, r3
            float bandSquish = displayValues[10];
 80158c8:	ed94 9a0a 	vldr	s18, [r4, #40]	; 0x28
            float bandOffset = displayValues[11];
 80158cc:	ed94 aa0b 	vldr	s20, [r4, #44]	; 0x2c
            float myTilt = displayValues[12];
 80158d0:	edd4 aa0c 	vldr	s21, [r4, #48]	; 0x30
            float barkPull = displayValues[14];
 80158d4:	edd4 9a0e 	vldr	s19, [r4, #56]	; 0x38
 80158d8:	f8df 82ec 	ldr.w	r8, [pc, #748]	; 8015bc8 <SFXVocoderChFrame+0x558>
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 80158dc:	f000 8108 	beq.w	8015af0 <SFXVocoderChFrame+0x480>
 80158e0:	f8df a2e8 	ldr.w	sl, [pc, #744]	; 8015bcc <SFXVocoderChFrame+0x55c>
 80158e4:	f8df b2e8 	ldr.w	fp, [pc, #744]	; 8015bd0 <SFXVocoderChFrame+0x560>
 80158e8:	4b9f      	ldr	r3, [pc, #636]	; (8015b68 <SFXVocoderChFrame+0x4f8>)
 80158ea:	9300      	str	r3, [sp, #0]
 80158ec:	4b9f      	ldr	r3, [pc, #636]	; (8015b6c <SFXVocoderChFrame+0x4fc>)
 80158ee:	9301      	str	r3, [sp, #4]
 80158f0:	4b9f      	ldr	r3, [pc, #636]	; (8015b70 <SFXVocoderChFrame+0x500>)
 80158f2:	9302      	str	r3, [sp, #8]
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 80158f4:	ee07 1a90 	vmov	s15, r1
 80158f8:	ed9f 6a9e 	vldr	s12, [pc, #632]	; 8015b74 <SFXVocoderChFrame+0x504>
 80158fc:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8015900:	ed9f 7a9d 	vldr	s14, [pc, #628]	; 8015b78 <SFXVocoderChFrame+0x508>
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8015904:	eef8 6ae7 	vcvt.f32.s32	s13, s15
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8015908:	eddf 7a9c 	vldr	s15, [pc, #624]	; 8015b7c <SFXVocoderChFrame+0x50c>
                alteringBands = 1;
 801590c:	499c      	ldr	r1, [pc, #624]	; (8015b80 <SFXVocoderChFrame+0x510>)
 801590e:	f04f 0c01 	mov.w	ip, #1
                invMyQ = 1.0f / myQ;
 8015912:	ee85 5a88 	vdiv.f32	s10, s11, s16
 8015916:	4b9b      	ldr	r3, [pc, #620]	; (8015b84 <SFXVocoderChFrame+0x514>)
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8015918:	489b      	ldr	r0, [pc, #620]	; (8015b88 <SFXVocoderChFrame+0x518>)
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 801591a:	4a9c      	ldr	r2, [pc, #624]	; (8015b8c <SFXVocoderChFrame+0x51c>)
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 801591c:	f8df e2b4 	ldr.w	lr, [pc, #692]	; 8015bd4 <SFXVocoderChFrame+0x564>
                thisBandwidth = bandWidthInOctaves * myQ;
 8015920:	4f9b      	ldr	r7, [pc, #620]	; (8015b90 <SFXVocoderChFrame+0x520>)
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8015922:	ee76 6ac6 	vsub.f32	s13, s13, s12
                alteringBands = 1;
 8015926:	9103      	str	r1, [sp, #12]
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8015928:	ee69 7a27 	vmul.f32	s15, s18, s15
                alteringBands = 1;
 801592c:	f8c1 c000 	str.w	ip, [r1]
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8015930:	ee85 6aa6 	vdiv.f32	s12, s11, s13
                invMyQ = 1.0f / myQ;
 8015934:	ed83 5a00 	vstr	s10, [r3]
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8015938:	ee67 7a86 	vmul.f32	s15, s15, s12
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 801593c:	ed82 6a00 	vstr	s12, [r2]
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8015940:	ee27 7a87 	vmul.f32	s14, s15, s14
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8015944:	edc0 7a00 	vstr	s15, [r0]
                thisBandwidth = bandWidthInOctaves * myQ;
 8015948:	ee67 6a08 	vmul.f32	s13, s14, s16
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 801594c:	ed8e 7a00 	vstr	s14, [lr]
                thisBandwidth = bandWidthInOctaves * myQ;
 8015950:	edc7 6a00 	vstr	s13, [r7]
                float bandFreq = faster_mtof(((float)currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
 8015954:	f8df 9280 	ldr.w	r9, [pc, #640]	; 8015bd8 <SFXVocoderChFrame+0x568>
 8015958:	eeb0 0a4a 	vmov.f32	s0, s20
            float oneMinusBarkPull = 1.0f - barkPull;
 801595c:	eeb7 ba00 	vmov.f32	s22, #112	; 0x3f800000  1.0
                float bandFreq = faster_mtof(((float)currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
 8015960:	ed99 7a00 	vldr	s14, [r9]
 8015964:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
            float oneMinusBarkPull = 1.0f - barkPull;
 8015968:	ee7b ba69 	vsub.f32	s23, s22, s19
                float bandFreq = faster_mtof(((float)currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
 801596c:	eea7 0a27 	vfma.f32	s0, s14, s15
 8015970:	e9cd 3204 	strd	r3, r2, [sp, #16]
 8015974:	f00e fc0e 	bl	8024194 <faster_mtof>
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8015978:	f8d9 c000 	ldr.w	ip, [r9]
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 801597c:	9a05      	ldr	r2, [sp, #20]
 801597e:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8015982:	ea4f 018c 	mov.w	r1, ip, lsl #2
 8015986:	4883      	ldr	r0, [pc, #524]	; (8015b94 <SFXVocoderChFrame+0x524>)
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 8015988:	edd2 6a00 	vldr	s13, [r2]
                float myHeight = (float)currentBandToAlter * invNumberOfVocoderBands; //x value
 801598c:	ee06 ca10 	vmov	s12, ip
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8015990:	4408      	add	r0, r1
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 8015992:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
                float myHeight = (float)currentBandToAlter * invNumberOfVocoderBands; //x value
 8015996:	eeb8 4ac6 	vcvt.f32.s32	s8, s12
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 801599a:	4a7f      	ldr	r2, [pc, #508]	; (8015b98 <SFXVocoderChFrame+0x528>)
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 801599c:	ee66 6aa7 	vmul.f32	s13, s13, s15
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 80159a0:	edd0 7a00 	vldr	s15, [r0]
                float tiltOffset = (1.0f - ((myTilt * 0.5f) + 0.5f)) + 0.5f;
 80159a4:	ee7a 4a8b 	vadd.f32	s9, s21, s22
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 80159a8:	9b04      	ldr	r3, [sp, #16]
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 80159aa:	ee69 7aa7 	vmul.f32	s15, s19, s15
                if (bandFreq > 5000.0f) // a way to keep the upper bands fixed so consonants are not stretched even though vowels are
 80159ae:	eddf 5a7b 	vldr	s11, [pc, #492]	; 8015b9c <SFXVocoderChFrame+0x52c>
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 80159b2:	eea4 7a26 	vfma.f32	s14, s8, s13
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 80159b6:	440a      	add	r2, r1
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 80159b8:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 80159bc:	ed93 6a00 	vldr	s12, [r3]
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 80159c0:	eeeb 7a80 	vfma.f32	s15, s23, s0
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 80159c4:	4b76      	ldr	r3, [pc, #472]	; (8015ba0 <SFXVocoderChFrame+0x530>)
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 80159c6:	ee68 6a29 	vmul.f32	s13, s16, s19
 80159ca:	edd2 0a00 	vldr	s1, [r2]
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 80159ce:	4419      	add	r1, r3
                if (analysisOrSynthesis == 0)
 80159d0:	4b74      	ldr	r3, [pc, #464]	; (8015ba4 <SFXVocoderChFrame+0x534>)
 80159d2:	ea4f 00cc 	mov.w	r0, ip, lsl #3
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 80159d6:	eea4 7ac5 	vfms.f32	s14, s9, s10
                if (analysisOrSynthesis == 0)
 80159da:	681b      	ldr	r3, [r3, #0]
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 80159dc:	ee66 0aa0 	vmul.f32	s1, s13, s1
 80159e0:	edd7 6a00 	vldr	s13, [r7]
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 80159e4:	eeb0 0a67 	vmov.f32	s0, s15
 80159e8:	eddf 7a6f 	vldr	s15, [pc, #444]	; 8015ba8 <SFXVocoderChFrame+0x538>
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 80159ec:	eee6 0aab 	vfma.f32	s1, s13, s23
                float tempWarpFactor = warpFactor;
 80159f0:	eeb4 0ae5 	vcmpe.f32	s0, s11
 80159f4:	fe80 0a67 	vminnm.f32	s0, s0, s15
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 80159f8:	ee27 7a06 	vmul.f32	s14, s14, s12
                float tempWarpFactor = warpFactor;
 80159fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 8015a00:	ed81 7a00 	vstr	s14, [r1]
                float tempWarpFactor = warpFactor;
 8015a04:	bf98      	it	ls
 8015a06:	eeb0 ba68 	vmovls.f32	s22, s17
                if (analysisOrSynthesis == 0)
 8015a0a:	2b00      	cmp	r3, #0
 8015a0c:	f040 8101 	bne.w	8015c12 <SFXVocoderChFrame+0x5a2>
                    tVZFilter_setFreqAndBandwidth(&analysisBands[currentBandToAlter][0], bandFreq, bandBandwidth);
 8015a10:	4f66      	ldr	r7, [pc, #408]	; (8015bac <SFXVocoderChFrame+0x53c>)
 8015a12:	4438      	add	r0, r7
 8015a14:	f00d fd5a 	bl	80234cc <tVZFilter_setFreqAndBandwidth>
                    analysisBands[currentBandToAlter][1]->B = analysisBands[currentBandToAlter][0]->B;
 8015a18:	f8d9 3000 	ldr.w	r3, [r9]
 8015a1c:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015a20:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
 8015a24:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8015a26:	6851      	ldr	r1, [r2, #4]
 8015a28:	6348      	str	r0, [r1, #52]	; 0x34
                    analysisBands[currentBandToAlter][1]->fc = analysisBands[currentBandToAlter][0]->fc;
 8015a2a:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015a2e:	6851      	ldr	r1, [r2, #4]
 8015a30:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8015a32:	6288      	str	r0, [r1, #40]	; 0x28
                    analysisBands[currentBandToAlter][1]->R2 = analysisBands[currentBandToAlter][0]->R2;
 8015a34:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015a38:	6851      	ldr	r1, [r2, #4]
 8015a3a:	6940      	ldr	r0, [r0, #20]
 8015a3c:	6148      	str	r0, [r1, #20]
                    analysisBands[currentBandToAlter][1]->cL = analysisBands[currentBandToAlter][0]->cL;
 8015a3e:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015a42:	6851      	ldr	r1, [r2, #4]
 8015a44:	69c0      	ldr	r0, [r0, #28]
 8015a46:	61c8      	str	r0, [r1, #28]
                    analysisBands[currentBandToAlter][1]->cB = analysisBands[currentBandToAlter][0]->cB;
 8015a48:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015a4c:	6851      	ldr	r1, [r2, #4]
 8015a4e:	6a00      	ldr	r0, [r0, #32]
 8015a50:	6208      	str	r0, [r1, #32]
                    analysisBands[currentBandToAlter][1]->cH = analysisBands[currentBandToAlter][0]->cH;
 8015a52:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015a56:	6851      	ldr	r1, [r2, #4]
 8015a58:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8015a5a:	6248      	str	r0, [r1, #36]	; 0x24
                    analysisBands[currentBandToAlter][1]->h = analysisBands[currentBandToAlter][0]->h;
 8015a5c:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015a60:	6851      	ldr	r1, [r2, #4]
 8015a62:	6980      	ldr	r0, [r0, #24]
 8015a64:	6188      	str	r0, [r1, #24]
                    analysisBands[currentBandToAlter][1]->g = analysisBands[currentBandToAlter][0]->g;
 8015a66:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
 8015a6a:	6852      	ldr	r2, [r2, #4]
 8015a6c:	6909      	ldr	r1, [r1, #16]
                    analysisOrSynthesis++;
 8015a6e:	484d      	ldr	r0, [pc, #308]	; (8015ba4 <SFXVocoderChFrame+0x534>)
                    analysisBands[currentBandToAlter][1]->g = analysisBands[currentBandToAlter][0]->g;
 8015a70:	6111      	str	r1, [r2, #16]
                    analysisOrSynthesis++;
 8015a72:	6802      	ldr	r2, [r0, #0]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 8015a74:	6829      	ldr	r1, [r5, #0]
                    analysisOrSynthesis++;
 8015a76:	3201      	adds	r2, #1
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 8015a78:	428b      	cmp	r3, r1
                    analysisOrSynthesis++;
 8015a7a:	6002      	str	r2, [r0, #0]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 8015a7c:	db02      	blt.n	8015a84 <SFXVocoderChFrame+0x414>
 8015a7e:	2a00      	cmp	r2, #0
 8015a80:	f000 8106 	beq.w	8015c90 <SFXVocoderChFrame+0x620>
            prevBandOffset = bandOffset;
 8015a84:	9b00      	ldr	r3, [sp, #0]
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015a86:	2900      	cmp	r1, #0
            prevNumberOfVocoderBands = numberOfVocoderBands;
 8015a88:	6031      	str	r1, [r6, #0]
            prevBandOffset = bandOffset;
 8015a8a:	ed83 aa00 	vstr	s20, [r3]
            prevMyTilt = myTilt;
 8015a8e:	9b01      	ldr	r3, [sp, #4]
            prevMyQ = myQ;
 8015a90:	ed88 8a00 	vstr	s16, [r8]
            prevMyTilt = myTilt;
 8015a94:	edc3 aa00 	vstr	s21, [r3]
            prevBarkPull = barkPull;
 8015a98:	9b02      	ldr	r3, [sp, #8]
            prevWarpFactor = warpFactor;
 8015a9a:	edca 8a00 	vstr	s17, [sl]
            prevBandSquish = bandSquish;
 8015a9e:	ed8b 9a00 	vstr	s18, [fp]
            prevBarkPull = barkPull;
 8015aa2:	edc3 9a00 	vstr	s19, [r3]
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015aa6:	dd13      	ble.n	8015ad0 <SFXVocoderChFrame+0x460>
 8015aa8:	4f41      	ldr	r7, [pc, #260]	; (8015bb0 <SFXVocoderChFrame+0x540>)
 8015aaa:	2600      	movs	r6, #0
                tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
 8015aac:	eddf 8a41 	vldr	s17, [pc, #260]	; 8015bb4 <SFXVocoderChFrame+0x544>
 8015ab0:	ed9f 8a41 	vldr	s16, [pc, #260]	; 8015bb8 <SFXVocoderChFrame+0x548>
 8015ab4:	eeb0 0a48 	vmov.f32	s0, s16
 8015ab8:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8015abc:	4638      	mov	r0, r7
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015abe:	3601      	adds	r6, #1
 8015ac0:	3704      	adds	r7, #4
                tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
 8015ac2:	eea7 0aa8 	vfma.f32	s0, s15, s17
 8015ac6:	f00c fd49 	bl	802255c <tExpSmooth_setFactor>
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015aca:	682b      	ldr	r3, [r5, #0]
 8015acc:	42b3      	cmp	r3, r6
 8015ace:	dcf1      	bgt.n	8015ab4 <SFXVocoderChFrame+0x444>
            if (tSimplePoly_getNumActiveVoices(&poly) != 0)
 8015ad0:	483a      	ldr	r0, [pc, #232]	; (8015bbc <SFXVocoderChFrame+0x54c>)
 8015ad2:	f00f f87d 	bl	8024bd0 <tSimplePoly_getNumActiveVoices>
 8015ad6:	2800      	cmp	r0, #0
 8015ad8:	f040 80e0 	bne.w	8015c9c <SFXVocoderChFrame+0x62c>
                tExpSmooth_setDest(&comp, 0.0f);
 8015adc:	ed9f 0a38 	vldr	s0, [pc, #224]	; 8015bc0 <SFXVocoderChFrame+0x550>
 8015ae0:	4838      	ldr	r0, [pc, #224]	; (8015bc4 <SFXVocoderChFrame+0x554>)
        }
 8015ae2:	b007      	add	sp, #28
 8015ae4:	ecbd 8b08 	vpop	{d8-d11}
 8015ae8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                tExpSmooth_setDest(&comp, 0.0f);
 8015aec:	f00c bd48 	b.w	8022580 <tExpSmooth_setDest>
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 8015af0:	edd8 7a00 	vldr	s15, [r8]
 8015af4:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 8015bcc <SFXVocoderChFrame+0x55c>
 8015af8:	eef4 7a48 	vcmp.f32	s15, s16
 8015afc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b00:	f47f aef0 	bne.w	80158e4 <SFXVocoderChFrame+0x274>
 8015b04:	edda 7a00 	vldr	s15, [sl]
 8015b08:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 8015bd0 <SFXVocoderChFrame+0x560>
 8015b0c:	eef4 7a68 	vcmp.f32	s15, s17
 8015b10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b14:	f47f aee8 	bne.w	80158e8 <SFXVocoderChFrame+0x278>
 8015b18:	eddb 7a00 	vldr	s15, [fp]
 8015b1c:	4b12      	ldr	r3, [pc, #72]	; (8015b68 <SFXVocoderChFrame+0x4f8>)
 8015b1e:	eef4 7a49 	vcmp.f32	s15, s18
 8015b22:	9300      	str	r3, [sp, #0]
 8015b24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b28:	f040 80cd 	bne.w	8015cc6 <SFXVocoderChFrame+0x656>
 8015b2c:	edd3 7a00 	vldr	s15, [r3]
 8015b30:	4b0e      	ldr	r3, [pc, #56]	; (8015b6c <SFXVocoderChFrame+0x4fc>)
 8015b32:	eef4 7a4a 	vcmp.f32	s15, s20
 8015b36:	9301      	str	r3, [sp, #4]
 8015b38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b3c:	f000 80c8 	beq.w	8015cd0 <SFXVocoderChFrame+0x660>
 8015b40:	4b0b      	ldr	r3, [pc, #44]	; (8015b70 <SFXVocoderChFrame+0x500>)
 8015b42:	9302      	str	r3, [sp, #8]
 8015b44:	e6d6      	b.n	80158f4 <SFXVocoderChFrame+0x284>
 8015b46:	bf00      	nop
 8015b48:	200005e8 	.word	0x200005e8
 8015b4c:	20000668 	.word	0x20000668
 8015b50:	20000634 	.word	0x20000634
 8015b54:	20017284 	.word	0x20017284
 8015b58:	200027f0 	.word	0x200027f0
 8015b5c:	20017968 	.word	0x20017968
 8015b60:	20000270 	.word	0x20000270
 8015b64:	20000258 	.word	0x20000258
 8015b68:	20000264 	.word	0x20000264
 8015b6c:	200005f4 	.word	0x200005f4
 8015b70:	200005f0 	.word	0x200005f0
 8015b74:	3f7d70a4 	.word	0x3f7d70a4
 8015b78:	3daaaaab 	.word	0x3daaaaab
 8015b7c:	42bc0000 	.word	0x42bc0000
 8015b80:	20000524 	.word	0x20000524
 8015b84:	20000244 	.word	0x20000244
 8015b88:	200174bc 	.word	0x200174bc
 8015b8c:	20000248 	.word	0x20000248
 8015b90:	200027e8 	.word	0x200027e8
 8015b94:	20000130 	.word	0x20000130
 8015b98:	20000190 	.word	0x20000190
 8015b9c:	459c4000 	.word	0x459c4000
 8015ba0:	20017220 	.word	0x20017220
 8015ba4:	20000528 	.word	0x20000528
 8015ba8:	467a0000 	.word	0x467a0000
 8015bac:	20018284 	.word	0x20018284
 8015bb0:	200175d8 	.word	0x200175d8
 8015bb4:	3ac49ba6 	.word	0x3ac49ba6
 8015bb8:	38d1b717 	.word	0x38d1b717
 8015bbc:	200174c8 	.word	0x200174c8
 8015bc0:	00000000 	.word	0x00000000
 8015bc4:	20017204 	.word	0x20017204
 8015bc8:	2000026c 	.word	0x2000026c
 8015bcc:	20000278 	.word	0x20000278
 8015bd0:	20000268 	.word	0x20000268
 8015bd4:	20003410 	.word	0x20003410
 8015bd8:	2000057c 	.word	0x2000057c
                internalExternal = !internalExternal;
 8015bdc:	4a4c      	ldr	r2, [pc, #304]	; (8015d10 <SFXVocoderChFrame+0x6a0>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8015bde:	2100      	movs	r1, #0
                internalExternal = !internalExternal;
 8015be0:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8015be2:	7621      	strb	r1, [r4, #24]
                internalExternal = !internalExternal;
 8015be4:	fab3 f383 	clz	r3, r3
 8015be8:	095b      	lsrs	r3, r3, #5
                setLED_B(internalExternal);
 8015bea:	4618      	mov	r0, r3
                internalExternal = !internalExternal;
 8015bec:	6013      	str	r3, [r2, #0]
                setLED_B(internalExternal);
 8015bee:	f7fd febb 	bl	8013968 <setLED_B>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 8015bf2:	7f23      	ldrb	r3, [r4, #28]
 8015bf4:	2b01      	cmp	r3, #1
 8015bf6:	f47f ad5f 	bne.w	80156b8 <SFXVocoderChFrame+0x48>
                vocChFreeze = !vocChFreeze;
 8015bfa:	4a46      	ldr	r2, [pc, #280]	; (8015d14 <SFXVocoderChFrame+0x6a4>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8015bfc:	2100      	movs	r1, #0
                vocChFreeze = !vocChFreeze;
 8015bfe:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8015c00:	7721      	strb	r1, [r4, #28]
                vocChFreeze = !vocChFreeze;
 8015c02:	fab3 f383 	clz	r3, r3
 8015c06:	095b      	lsrs	r3, r3, #5
                setLED_C(vocChFreeze);
 8015c08:	4618      	mov	r0, r3
                vocChFreeze = !vocChFreeze;
 8015c0a:	6013      	str	r3, [r2, #0]
                setLED_C(vocChFreeze);
 8015c0c:	f7fd feba 	bl	8013984 <setLED_C>
 8015c10:	e552      	b.n	80156b8 <SFXVocoderChFrame+0x48>
                    tVZFilter_setFreqAndBandwidth(&synthesisBands[currentBandToAlter][0], bandFreq * tempWarpFactor, bandBandwidth);
 8015c12:	4f41      	ldr	r7, [pc, #260]	; (8015d18 <SFXVocoderChFrame+0x6a8>)
 8015c14:	ee2b 0a00 	vmul.f32	s0, s22, s0
 8015c18:	4438      	add	r0, r7
 8015c1a:	f00d fc57 	bl	80234cc <tVZFilter_setFreqAndBandwidth>
                    synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
 8015c1e:	f8d9 3000 	ldr.w	r3, [r9]
                    analysisOrSynthesis = 0;
 8015c22:	f04f 0e00 	mov.w	lr, #0
                    synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
 8015c26:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015c2a:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
                    currentBandToAlter++;
 8015c2e:	f103 0c01 	add.w	ip, r3, #1
                    synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
 8015c32:	6851      	ldr	r1, [r2, #4]
 8015c34:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8015c36:	6348      	str	r0, [r1, #52]	; 0x34
                    synthesisBands[currentBandToAlter][1]->fc = synthesisBands[currentBandToAlter][0]->fc;
 8015c38:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015c3c:	6851      	ldr	r1, [r2, #4]
 8015c3e:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8015c40:	6288      	str	r0, [r1, #40]	; 0x28
                    synthesisBands[currentBandToAlter][1]->R2 = synthesisBands[currentBandToAlter][0]->R2;
 8015c42:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015c46:	6851      	ldr	r1, [r2, #4]
 8015c48:	6940      	ldr	r0, [r0, #20]
 8015c4a:	6148      	str	r0, [r1, #20]
                    synthesisBands[currentBandToAlter][1]->cL = synthesisBands[currentBandToAlter][0]->cL;
 8015c4c:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015c50:	6851      	ldr	r1, [r2, #4]
 8015c52:	69c0      	ldr	r0, [r0, #28]
 8015c54:	61c8      	str	r0, [r1, #28]
                    synthesisBands[currentBandToAlter][1]->cB = synthesisBands[currentBandToAlter][0]->cB;
 8015c56:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015c5a:	6851      	ldr	r1, [r2, #4]
 8015c5c:	6a00      	ldr	r0, [r0, #32]
 8015c5e:	6208      	str	r0, [r1, #32]
                    synthesisBands[currentBandToAlter][1]->cH = synthesisBands[currentBandToAlter][0]->cH;
 8015c60:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015c64:	6851      	ldr	r1, [r2, #4]
 8015c66:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8015c68:	6248      	str	r0, [r1, #36]	; 0x24
                    synthesisBands[currentBandToAlter][1]->h = synthesisBands[currentBandToAlter][0]->h;
 8015c6a:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8015c6e:	6851      	ldr	r1, [r2, #4]
 8015c70:	6980      	ldr	r0, [r0, #24]
 8015c72:	6188      	str	r0, [r1, #24]
                    synthesisBands[currentBandToAlter][1]->g = synthesisBands[currentBandToAlter][0]->g;
 8015c74:	f857 3033 	ldr.w	r3, [r7, r3, lsl #3]
 8015c78:	6852      	ldr	r2, [r2, #4]
 8015c7a:	691b      	ldr	r3, [r3, #16]
 8015c7c:	6113      	str	r3, [r2, #16]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 8015c7e:	6829      	ldr	r1, [r5, #0]
                    analysisOrSynthesis = 0;
 8015c80:	4b26      	ldr	r3, [pc, #152]	; (8015d1c <SFXVocoderChFrame+0x6ac>)
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 8015c82:	458c      	cmp	ip, r1
                    currentBandToAlter++;
 8015c84:	f8c9 c000 	str.w	ip, [r9]
                    analysisOrSynthesis = 0;
 8015c88:	f8c3 e000 	str.w	lr, [r3]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 8015c8c:	f6ff aefa 	blt.w	8015a84 <SFXVocoderChFrame+0x414>
                    alteringBands = 0;
 8015c90:	2300      	movs	r3, #0
 8015c92:	9a03      	ldr	r2, [sp, #12]
                    currentBandToAlter = 0;
 8015c94:	f8c9 3000 	str.w	r3, [r9]
                    alteringBands = 0;
 8015c98:	6013      	str	r3, [r2, #0]
 8015c9a:	e6f3      	b.n	8015a84 <SFXVocoderChFrame+0x414>
                tExpSmooth_setDest(&comp, sqrtf(1.0f / (float)tSimplePoly_getNumActiveVoices(&poly)));
 8015c9c:	4820      	ldr	r0, [pc, #128]	; (8015d20 <SFXVocoderChFrame+0x6b0>)
 8015c9e:	f00e ff97 	bl	8024bd0 <tSimplePoly_getNumActiveVoices>
 8015ca2:	ee07 0a90 	vmov	s15, r0
 8015ca6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8015caa:	481e      	ldr	r0, [pc, #120]	; (8015d24 <SFXVocoderChFrame+0x6b4>)
 8015cac:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8015cb0:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8015cb4:	eeb1 0ac0 	vsqrt.f32	s0, s0
        }
 8015cb8:	b007      	add	sp, #28
 8015cba:	ecbd 8b08 	vpop	{d8-d11}
 8015cbe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                tExpSmooth_setDest(&comp, 0.0f);
 8015cc2:	f00c bc5d 	b.w	8022580 <tExpSmooth_setDest>
 8015cc6:	4b18      	ldr	r3, [pc, #96]	; (8015d28 <SFXVocoderChFrame+0x6b8>)
 8015cc8:	9301      	str	r3, [sp, #4]
 8015cca:	4b18      	ldr	r3, [pc, #96]	; (8015d2c <SFXVocoderChFrame+0x6bc>)
 8015ccc:	9302      	str	r3, [sp, #8]
 8015cce:	e611      	b.n	80158f4 <SFXVocoderChFrame+0x284>
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 8015cd0:	edd3 7a00 	vldr	s15, [r3]
 8015cd4:	4b15      	ldr	r3, [pc, #84]	; (8015d2c <SFXVocoderChFrame+0x6bc>)
 8015cd6:	eef4 7a6a 	vcmp.f32	s15, s21
 8015cda:	9302      	str	r3, [sp, #8]
 8015cdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015ce0:	f47f ae08 	bne.w	80158f4 <SFXVocoderChFrame+0x284>
 8015ce4:	edd3 7a00 	vldr	s15, [r3]
 8015ce8:	eef4 7a69 	vcmp.f32	s15, s19
 8015cec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015cf0:	f47f ae00 	bne.w	80158f4 <SFXVocoderChFrame+0x284>
            if (alteringBands)
 8015cf4:	4b0e      	ldr	r3, [pc, #56]	; (8015d30 <SFXVocoderChFrame+0x6c0>)
 8015cf6:	9303      	str	r3, [sp, #12]
 8015cf8:	681b      	ldr	r3, [r3, #0]
 8015cfa:	2b00      	cmp	r3, #0
 8015cfc:	f43f aec2 	beq.w	8015a84 <SFXVocoderChFrame+0x414>
 8015d00:	4b0c      	ldr	r3, [pc, #48]	; (8015d34 <SFXVocoderChFrame+0x6c4>)
 8015d02:	4a0d      	ldr	r2, [pc, #52]	; (8015d38 <SFXVocoderChFrame+0x6c8>)
 8015d04:	edd3 7a00 	vldr	s15, [r3]
 8015d08:	4f0c      	ldr	r7, [pc, #48]	; (8015d3c <SFXVocoderChFrame+0x6cc>)
 8015d0a:	4b0d      	ldr	r3, [pc, #52]	; (8015d40 <SFXVocoderChFrame+0x6d0>)
 8015d0c:	e622      	b.n	8015954 <SFXVocoderChFrame+0x2e4>
 8015d0e:	bf00      	nop
 8015d10:	200005ac 	.word	0x200005ac
 8015d14:	20000624 	.word	0x20000624
 8015d18:	200173d0 	.word	0x200173d0
 8015d1c:	20000528 	.word	0x20000528
 8015d20:	200174c8 	.word	0x200174c8
 8015d24:	20017204 	.word	0x20017204
 8015d28:	200005f4 	.word	0x200005f4
 8015d2c:	200005f0 	.word	0x200005f0
 8015d30:	20000524 	.word	0x20000524
 8015d34:	200174bc 	.word	0x200174bc
 8015d38:	20000248 	.word	0x20000248
 8015d3c:	200027e8 	.word	0x200027e8
 8015d40:	20000244 	.word	0x20000244

08015d44 <SFXVocoderChTick>:
        {
 8015d44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015d48:	4605      	mov	r5, r0
            input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
 8015d4a:	489c      	ldr	r0, [pc, #624]	; (8015fbc <SFXVocoderChTick+0x278>)
        {
 8015d4c:	ed2d 8b06 	vpush	{d8-d10}
 8015d50:	b083      	sub	sp, #12
            input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
 8015d52:	ed95 0a01 	vldr	s0, [r5, #4]
 8015d56:	f00d f96b 	bl	8023030 <tVZFilter_tick>
            if (internalExternal == 1)
 8015d5a:	4b99      	ldr	r3, [pc, #612]	; (8015fc0 <SFXVocoderChTick+0x27c>)
            input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
 8015d5c:	ed85 0a01 	vstr	s0, [r5, #4]
            if (internalExternal == 1)
 8015d60:	681b      	ldr	r3, [r3, #0]
 8015d62:	2b01      	cmp	r3, #1
 8015d64:	f040 80a8 	bne.w	8015eb8 <SFXVocoderChTick+0x174>
                sample = input[0];
 8015d68:	ed95 0a00 	vldr	s0, [r5]
 8015d6c:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 8016028 <SFXVocoderChTick+0x2e4>
            sample = LEAF_tanh(sample);
 8015d70:	f00e f8f2 	bl	8023f58 <LEAF_tanh>
            input[1] = input[1] * (displayValues[0] * 30.0f);
 8015d74:	eeb3 7a0e 	vmov.f32	s14, #62	; 0x41f00000  30.0
            sample = LEAF_tanh(sample);
 8015d78:	eeb0 9a40 	vmov.f32	s18, s0
            input[1] = input[1] * (displayValues[0] * 30.0f);
 8015d7c:	ed98 0a00 	vldr	s0, [r8]
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015d80:	4f90      	ldr	r7, [pc, #576]	; (8015fc4 <SFXVocoderChTick+0x280>)
            input[1] = input[1] * (displayValues[0] * 30.0f);
 8015d82:	ee20 0a07 	vmul.f32	s0, s0, s14
 8015d86:	edd5 7a01 	vldr	s15, [r5, #4]
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015d8a:	683b      	ldr	r3, [r7, #0]
            float output[2] = {0.0f, 0.0f};
 8015d8c:	ed9f 8a8e 	vldr	s16, [pc, #568]	; 8015fc8 <SFXVocoderChTick+0x284>
            input[1] = input[1] * (displayValues[0] * 30.0f);
 8015d90:	ee20 0a27 	vmul.f32	s0, s0, s15
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015d94:	2b00      	cmp	r3, #0
            float output[2] = {0.0f, 0.0f};
 8015d96:	ed8d 8a00 	vstr	s16, [sp]
 8015d9a:	ed8d 8a01 	vstr	s16, [sp, #4]
            input[1] = input[1] * (displayValues[0] * 30.0f);
 8015d9e:	ed85 0a01 	vstr	s0, [r5, #4]
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015da2:	f340 8108 	ble.w	8015fb6 <SFXVocoderChTick+0x272>
 8015da6:	f04f 0b00 	mov.w	fp, #0
                tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
 8015daa:	eef0 9a48 	vmov.f32	s19, s16
 8015dae:	4e87      	ldr	r6, [pc, #540]	; (8015fcc <SFXVocoderChTick+0x288>)
 8015db0:	46da      	mov	sl, fp
 8015db2:	f8df 8278 	ldr.w	r8, [pc, #632]	; 801602c <SFXVocoderChTick+0x2e8>
 8015db6:	e02f      	b.n	8015e18 <SFXVocoderChTick+0xd4>
                tempSamp = tExpSmooth_tick(&envFollowers[i]);
 8015db8:	4648      	mov	r0, r9
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015dba:	f10b 0b01 	add.w	fp, fp, #1
                tempSamp = tExpSmooth_tick(&envFollowers[i]);
 8015dbe:	f00c fbe9 	bl	8022594 <tExpSmooth_tick>
                tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
 8015dc2:	eeb0 1a00 	vmov.f32	s2, #0	; 0x40000000  2.0
 8015dc6:	eef0 0a40 	vmov.f32	s1, s0
 8015dca:	eeb0 0a69 	vmov.f32	s0, s19
 8015dce:	f00e f871 	bl	8023eb4 <LEAF_clip>
                tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][0], tempSynth);
 8015dd2:	4b7f      	ldr	r3, [pc, #508]	; (8015fd0 <SFXVocoderChTick+0x28c>)
                tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
 8015dd4:	eef0 8a40 	vmov.f32	s17, s0
                tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][0], tempSynth);
 8015dd8:	1918      	adds	r0, r3, r4
 8015dda:	eeb0 0a49 	vmov.f32	s0, s18
 8015dde:	f00d f965 	bl	80230ac <tVZFilter_tickEfficient>
                tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][1], tempSynth);
 8015de2:	4b7c      	ldr	r3, [pc, #496]	; (8015fd4 <SFXVocoderChTick+0x290>)
 8015de4:	1918      	adds	r0, r3, r4
 8015de6:	f00d f961 	bl	80230ac <tVZFilter_tickEfficient>
                output[oddEven] += tempSynth * tempSamp * bandGains[i];
 8015dea:	ee28 0a80 	vmul.f32	s0, s17, s0
 8015dee:	ecf6 7a01 	vldmia	r6!, {s15}
 8015df2:	ab02      	add	r3, sp, #8
 8015df4:	a902      	add	r1, sp, #8
 8015df6:	eea0 8a27 	vfma.f32	s16, s0, s15
 8015dfa:	eb03 028a 	add.w	r2, r3, sl, lsl #2
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015dfe:	683b      	ldr	r3, [r7, #0]
 8015e00:	f00b 0a01 	and.w	sl, fp, #1
 8015e04:	455b      	cmp	r3, fp
 8015e06:	eb01 018a 	add.w	r1, r1, sl, lsl #2
                output[oddEven] += tempSynth * tempSamp * bandGains[i];
 8015e0a:	ed02 8a02 	vstr	s16, [r2, #-8]
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015e0e:	dd1a      	ble.n	8015e46 <SFXVocoderChTick+0x102>
 8015e10:	ed11 8a02 	vldr	s16, [r1, #-8]
 8015e14:	ed95 0a01 	vldr	s0, [r5, #4]
 8015e18:	4a6f      	ldr	r2, [pc, #444]	; (8015fd8 <SFXVocoderChTick+0x294>)
 8015e1a:	ea4f 04cb 	mov.w	r4, fp, lsl #3
                if (!vocChFreeze)
 8015e1e:	f8d8 3000 	ldr.w	r3, [r8]
 8015e22:	eb02 098b 	add.w	r9, r2, fp, lsl #2
 8015e26:	2b00      	cmp	r3, #0
 8015e28:	d1c6      	bne.n	8015db8 <SFXVocoderChTick+0x74>
                    tempSamp = tVZFilter_tickEfficient(&analysisBands[i][0], tempSamp);
 8015e2a:	4b6c      	ldr	r3, [pc, #432]	; (8015fdc <SFXVocoderChTick+0x298>)
 8015e2c:	1918      	adds	r0, r3, r4
 8015e2e:	f00d f93d 	bl	80230ac <tVZFilter_tickEfficient>
                    tempSamp = tVZFilter_tickEfficient(&analysisBands[i][1], tempSamp);
 8015e32:	4b6b      	ldr	r3, [pc, #428]	; (8015fe0 <SFXVocoderChTick+0x29c>)
 8015e34:	1918      	adds	r0, r3, r4
 8015e36:	f00d f939 	bl	80230ac <tVZFilter_tickEfficient>
                    tExpSmooth_setDest(&envFollowers[i], fabsf(tempSamp));
 8015e3a:	4648      	mov	r0, r9
 8015e3c:	eeb0 0ac0 	vabs.f32	s0, s0
 8015e40:	f00c fb9e 	bl	8022580 <tExpSmooth_setDest>
 8015e44:	e7b8      	b.n	8015db8 <SFXVocoderChTick+0x74>
 8015e46:	ed9d 9a00 	vldr	s18, [sp]
 8015e4a:	ed9d 8a01 	vldr	s16, [sp, #4]
            float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
 8015e4e:	4e65      	ldr	r6, [pc, #404]	; (8015fe4 <SFXVocoderChTick+0x2a0>)
 8015e50:	eeb0 0a49 	vmov.f32	s0, s18
 8015e54:	4c64      	ldr	r4, [pc, #400]	; (8015fe8 <SFXVocoderChTick+0x2a4>)
 8015e56:	ed96 7a00 	vldr	s14, [r6]
 8015e5a:	edd4 7a00 	vldr	s15, [r4]
 8015e5e:	eea7 0a08 	vfma.f32	s0, s14, s16
 8015e62:	4862      	ldr	r0, [pc, #392]	; (8015fec <SFXVocoderChTick+0x2a8>)
            input[0] = 0.98f * LEAF_tanh(finalSample1);
 8015e64:	eddf 8a62 	vldr	s17, [pc, #392]	; 8015ff0 <SFXVocoderChTick+0x2ac>
            float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
 8015e68:	ee20 0a27 	vmul.f32	s0, s0, s15
 8015e6c:	f00c fece 	bl	8022c0c <tHighpass_tick>
            float finalSample2 = tHighpass_tick(&chVocFinalHP2, (output[1] + (output[0] * oneMinusStereo)) * chVocOutputGain);
 8015e70:	edd6 7a00 	vldr	s15, [r6]
            float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
 8015e74:	eef0 9a40 	vmov.f32	s19, s0
            float finalSample2 = tHighpass_tick(&chVocFinalHP2, (output[1] + (output[0] * oneMinusStereo)) * chVocOutputGain);
 8015e78:	ed94 0a00 	vldr	s0, [r4]
 8015e7c:	eea7 8a89 	vfma.f32	s16, s15, s18
 8015e80:	485c      	ldr	r0, [pc, #368]	; (8015ff4 <SFXVocoderChTick+0x2b0>)
 8015e82:	ee28 0a00 	vmul.f32	s0, s16, s0
 8015e86:	f00c fec1 	bl	8022c0c <tHighpass_tick>
 8015e8a:	eeb0 8a40 	vmov.f32	s16, s0
            input[0] = 0.98f * LEAF_tanh(finalSample1);
 8015e8e:	eeb0 0a69 	vmov.f32	s0, s19
 8015e92:	f00e f861 	bl	8023f58 <LEAF_tanh>
 8015e96:	ee60 7a28 	vmul.f32	s15, s0, s17
            input[1] = 0.98f * LEAF_tanh(finalSample2);
 8015e9a:	eeb0 0a48 	vmov.f32	s0, s16
            input[0] = 0.98f * LEAF_tanh(finalSample1);
 8015e9e:	edc5 7a00 	vstr	s15, [r5]
            input[1] = 0.98f * LEAF_tanh(finalSample2);
 8015ea2:	f00e f859 	bl	8023f58 <LEAF_tanh>
 8015ea6:	ee20 0a28 	vmul.f32	s0, s0, s17
 8015eaa:	ed85 0a01 	vstr	s0, [r5, #4]
        }
 8015eae:	b003      	add	sp, #12
 8015eb0:	ecbd 8b06 	vpop	{d8-d10}
 8015eb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (!vocChFreeze)
 8015eb8:	f8df 8170 	ldr.w	r8, [pc, #368]	; 801602c <SFXVocoderChTick+0x2e8>
                float zerocross = tZeroCrossing_tick(&zerox, input[1]);
 8015ebc:	484e      	ldr	r0, [pc, #312]	; (8015ff8 <SFXVocoderChTick+0x2b4>)
 8015ebe:	f008 fda3 	bl	801ea08 <tZeroCrossing_tick>
                if (!vocChFreeze)
 8015ec2:	f8d8 3000 	ldr.w	r3, [r8]
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
 8015ec6:	f8df 8160 	ldr.w	r8, [pc, #352]	; 8016028 <SFXVocoderChTick+0x2e4>
                if (!vocChFreeze)
 8015eca:	b9ab      	cbnz	r3, 8015ef8 <SFXVocoderChTick+0x1b4>
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
 8015ecc:	ed9f 6a4b 	vldr	s12, [pc, #300]	; 8015ffc <SFXVocoderChTick+0x2b8>
 8015ed0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8015ed4:	edd8 7a04 	vldr	s15, [r8, #16]
 8015ed8:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 8015fc8 <SFXVocoderChTick+0x284>
 8015edc:	ee77 7ac6 	vsub.f32	s15, s15, s12
 8015ee0:	4847      	ldr	r0, [pc, #284]	; (8016000 <SFXVocoderChTick+0x2bc>)
 8015ee2:	eef4 7ac0 	vcmpe.f32	s15, s0
 8015ee6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015eea:	bf54      	ite	pl
 8015eec:	eeb0 0a47 	vmovpl.f32	s0, s14
 8015ef0:	eeb0 0a66 	vmovmi.f32	s0, s13
 8015ef4:	f00c fb44 	bl	8022580 <tExpSmooth_setDest>
                float noiseRampVal = tExpSmooth_tick(&noiseRamp);
 8015ef8:	4841      	ldr	r0, [pc, #260]	; (8016000 <SFXVocoderChTick+0x2bc>)
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015efa:	2400      	movs	r4, #0
                float noiseRampVal = tExpSmooth_tick(&noiseRamp);
 8015efc:	f00c fb4a 	bl	8022594 <tExpSmooth_tick>
 8015f00:	eeb0 aa40 	vmov.f32	s20, s0
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
 8015f04:	483f      	ldr	r0, [pc, #252]	; (8016004 <SFXVocoderChTick+0x2c0>)
 8015f06:	f00e fff1 	bl	8024eec <tNoise_tick>
            float sample = 0.0f;
 8015f0a:	ed9f 9a2f 	vldr	s18, [pc, #188]	; 8015fc8 <SFXVocoderChTick+0x284>
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
 8015f0e:	ee60 8a0a 	vmul.f32	s17, s0, s20
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015f12:	f8df 911c 	ldr.w	r9, [pc, #284]	; 8016030 <SFXVocoderChTick+0x2ec>
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
 8015f16:	4f3c      	ldr	r7, [pc, #240]	; (8016008 <SFXVocoderChTick+0x2c4>)
                    if (tempRamp > 0.0001f)
 8015f18:	eddf 9a3c 	vldr	s19, [pc, #240]	; 801600c <SFXVocoderChTick+0x2c8>
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015f1c:	e005      	b.n	8015f2a <SFXVocoderChTick+0x1e6>
                            sample += tSawtooth_tick(&osc[i]) * tempRamp;
 8015f1e:	1998      	adds	r0, r3, r6
 8015f20:	f00e ff72 	bl	8024e08 <tSawtooth_tick>
 8015f24:	eea0 9a08 	vfma.f32	s18, s0, s16
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015f28:	3401      	adds	r4, #1
 8015f2a:	4648      	mov	r0, r9
 8015f2c:	00a6      	lsls	r6, r4, #2
 8015f2e:	f00e fe4b 	bl	8024bc8 <tSimplePoly_getNumVoices>
 8015f32:	42a0      	cmp	r0, r4
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
 8015f34:	eb07 0006 	add.w	r0, r7, r6
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8015f38:	dd19      	ble.n	8015f6e <SFXVocoderChTick+0x22a>
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
 8015f3a:	f00c fb2b 	bl	8022594 <tExpSmooth_tick>
                    if (tempRamp > 0.0001f)
 8015f3e:	eeb4 0ae9 	vcmpe.f32	s0, s19
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
 8015f42:	eeb0 8a40 	vmov.f32	s16, s0
                        if (displayValues[5] < 0.5f)
 8015f46:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
                    if (tempRamp > 0.0001f)
 8015f4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f4e:	ddeb      	ble.n	8015f28 <SFXVocoderChTick+0x1e4>
                        if (displayValues[5] < 0.5f)
 8015f50:	ed98 7a05 	vldr	s14, [r8, #20]
                            sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
 8015f54:	482e      	ldr	r0, [pc, #184]	; (8016010 <SFXVocoderChTick+0x2cc>)
                        if (displayValues[5] < 0.5f)
 8015f56:	eeb4 7ae7 	vcmpe.f32	s14, s15
                            sample += tSawtooth_tick(&osc[i]) * tempRamp;
 8015f5a:	4b2e      	ldr	r3, [pc, #184]	; (8016014 <SFXVocoderChTick+0x2d0>)
                            sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
 8015f5c:	4430      	add	r0, r6
                        if (displayValues[5] < 0.5f)
 8015f5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f62:	d4dc      	bmi.n	8015f1e <SFXVocoderChTick+0x1da>
                            sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
 8015f64:	f00a fd6e 	bl	8020a44 <tRosenbergGlottalPulse_tick>
 8015f68:	eea0 9a08 	vfma.f32	s18, s0, s16
 8015f6c:	e7dc      	b.n	8015f28 <SFXVocoderChTick+0x1e4>
                sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
 8015f6e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015f72:	edd8 6a08 	vldr	s13, [r8, #32]
 8015f76:	ed9f 7a28 	vldr	s14, [pc, #160]	; 8016018 <SFXVocoderChTick+0x2d4>
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
 8015f7a:	4828      	ldr	r0, [pc, #160]	; (801601c <SFXVocoderChTick+0x2d8>)
                sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
 8015f7c:	eeb0 8a67 	vmov.f32	s16, s15
 8015f80:	ee77 7aca 	vsub.f32	s15, s15, s20
 8015f84:	eea6 8ac7 	vfms.f32	s16, s13, s14
 8015f88:	ee28 8a27 	vmul.f32	s16, s16, s15
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
 8015f8c:	f00e ffae 	bl	8024eec <tNoise_tick>
 8015f90:	4823      	ldr	r0, [pc, #140]	; (8016020 <SFXVocoderChTick+0x2dc>)
 8015f92:	f00c fe3b 	bl	8022c0c <tHighpass_tick>
 8015f96:	edd8 7a08 	vldr	s15, [r8, #32]
                sample *= tExpSmooth_tick(&comp);
 8015f9a:	4822      	ldr	r0, [pc, #136]	; (8016024 <SFXVocoderChTick+0x2e0>)
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
 8015f9c:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8015fa0:	ee67 7a80 	vmul.f32	s15, s15, s0
 8015fa4:	eee9 7a08 	vfma.f32	s15, s18, s16
 8015fa8:	ee78 8aa7 	vadd.f32	s17, s17, s15
                sample *= tExpSmooth_tick(&comp);
 8015fac:	f00c faf2 	bl	8022594 <tExpSmooth_tick>
 8015fb0:	ee28 0a80 	vmul.f32	s0, s17, s0
 8015fb4:	e6dc      	b.n	8015d70 <SFXVocoderChTick+0x2c>
            for (int i = 0; i < numberOfVocoderBands; i++)
 8015fb6:	eeb0 9a48 	vmov.f32	s18, s16
 8015fba:	e748      	b.n	8015e4e <SFXVocoderChTick+0x10a>
 8015fbc:	2001759c 	.word	0x2001759c
 8015fc0:	200005ac 	.word	0x200005ac
 8015fc4:	20000258 	.word	0x20000258
 8015fc8:	00000000 	.word	0x00000000
 8015fcc:	20017220 	.word	0x20017220
 8015fd0:	200173d0 	.word	0x200173d0
 8015fd4:	200173d4 	.word	0x200173d4
 8015fd8:	200175d8 	.word	0x200175d8
 8015fdc:	20018284 	.word	0x20018284
 8015fe0:	20018288 	.word	0x20018288
 8015fe4:	2000025c 	.word	0x2000025c
 8015fe8:	200001f0 	.word	0x200001f0
 8015fec:	200027e4 	.word	0x200027e4
 8015ff0:	3f7ae148 	.word	0x3f7ae148
 8015ff4:	20018278 	.word	0x20018278
 8015ff8:	2001763c 	.word	0x2001763c
 8015ffc:	3dcccccd 	.word	0x3dcccccd
 8016000:	20018274 	.word	0x20018274
 8016004:	2000340c 	.word	0x2000340c
 8016008:	20017968 	.word	0x20017968
 801600c:	38d1b717 	.word	0x38d1b717
 8016010:	200027f0 	.word	0x200027f0
 8016014:	20017284 	.word	0x20017284
 8016018:	3e99999a 	.word	0x3e99999a
 801601c:	200027c0 	.word	0x200027c0
 8016020:	20003404 	.word	0x20003404
 8016024:	20017204 	.word	0x20017204
 8016028:	200187dc 	.word	0x200187dc
 801602c:	20000624 	.word	0x20000624
 8016030:	200174c8 	.word	0x200174c8

08016034 <SFXVocoderChFree>:
        {
 8016034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8016036:	4c1f      	ldr	r4, [pc, #124]	; (80160b4 <SFXVocoderChFree+0x80>)
 8016038:	4d1f      	ldr	r5, [pc, #124]	; (80160b8 <SFXVocoderChFree+0x84>)
 801603a:	f104 07c0 	add.w	r7, r4, #192	; 0xc0
 801603e:	4e1f      	ldr	r6, [pc, #124]	; (80160bc <SFXVocoderChFree+0x88>)
                tVZFilter_free(&analysisBands[i][0]);
 8016040:	4620      	mov	r0, r4
 8016042:	f00c ffe7 	bl	8023014 <tVZFilter_free>
                tVZFilter_free(&analysisBands[i][1]);
 8016046:	1d20      	adds	r0, r4, #4
 8016048:	f00c ffe4 	bl	8023014 <tVZFilter_free>
                tVZFilter_free(&synthesisBands[i][0]);
 801604c:	1f28      	subs	r0, r5, #4
 801604e:	f00c ffe1 	bl	8023014 <tVZFilter_free>
 8016052:	3408      	adds	r4, #8
                tVZFilter_free(&synthesisBands[i][1]);
 8016054:	4628      	mov	r0, r5
 8016056:	3508      	adds	r5, #8
 8016058:	f00c ffdc 	bl	8023014 <tVZFilter_free>
                tExpSmooth_free(&envFollowers[i]);
 801605c:	4630      	mov	r0, r6
 801605e:	f00c fa79 	bl	8022554 <tExpSmooth_free>
            for (int i = 0; i < MAX_NUM_VOCODER_BANDS; i++)
 8016062:	42a7      	cmp	r7, r4
 8016064:	f106 0604 	add.w	r6, r6, #4
 8016068:	d1ea      	bne.n	8016040 <SFXVocoderChFree+0xc>
            tNoise_free(&breathNoise);
 801606a:	4815      	ldr	r0, [pc, #84]	; (80160c0 <SFXVocoderChFree+0x8c>)
            tHighpass_free(&chVocFinalHP2);
 801606c:	2400      	movs	r4, #0
            tNoise_free(&breathNoise);
 801606e:	f00e ff39 	bl	8024ee4 <tNoise_free>
            tNoise_free(&vocoderNoise);
 8016072:	4814      	ldr	r0, [pc, #80]	; (80160c4 <SFXVocoderChFree+0x90>)
 8016074:	f00e ff36 	bl	8024ee4 <tNoise_free>
            tZeroCrossing_free(&zerox);
 8016078:	4813      	ldr	r0, [pc, #76]	; (80160c8 <SFXVocoderChFree+0x94>)
 801607a:	f008 fcb5 	bl	801e9e8 <tZeroCrossing_free>
            tExpSmooth_free(&noiseRamp);
 801607e:	4813      	ldr	r0, [pc, #76]	; (80160cc <SFXVocoderChFree+0x98>)
 8016080:	f00c fa68 	bl	8022554 <tExpSmooth_free>
            tHighpass_free(&noiseHP);
 8016084:	4812      	ldr	r0, [pc, #72]	; (80160d0 <SFXVocoderChFree+0x9c>)
 8016086:	f00c fdad 	bl	8022be4 <tHighpass_free>
            tVZFilter_free(&vocodec_highshelf);
 801608a:	4812      	ldr	r0, [pc, #72]	; (80160d4 <SFXVocoderChFree+0xa0>)
 801608c:	f00c ffc2 	bl	8023014 <tVZFilter_free>
            tHighpass_free(&chVocFinalHP1);
 8016090:	4811      	ldr	r0, [pc, #68]	; (80160d8 <SFXVocoderChFree+0xa4>)
 8016092:	f00c fda7 	bl	8022be4 <tHighpass_free>
            tHighpass_free(&chVocFinalHP2);
 8016096:	4811      	ldr	r0, [pc, #68]	; (80160dc <SFXVocoderChFree+0xa8>)
 8016098:	4e11      	ldr	r6, [pc, #68]	; (80160e0 <SFXVocoderChFree+0xac>)
 801609a:	4d12      	ldr	r5, [pc, #72]	; (80160e4 <SFXVocoderChFree+0xb0>)
 801609c:	f00c fda2 	bl	8022be4 <tHighpass_free>
                tSawtooth_free(&osc[i]);
 80160a0:	1930      	adds	r0, r6, r4
 80160a2:	f00e fe7b 	bl	8024d9c <tSawtooth_free>
                tRosenbergGlottalPulse_free(&glottal[i]);
 80160a6:	1928      	adds	r0, r5, r4
 80160a8:	3404      	adds	r4, #4
 80160aa:	f00a fcc7 	bl	8020a3c <tRosenbergGlottalPulse_free>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 80160ae:	2c20      	cmp	r4, #32
 80160b0:	d1f6      	bne.n	80160a0 <SFXVocoderChFree+0x6c>
        }
 80160b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80160b4:	20018284 	.word	0x20018284
 80160b8:	200173d4 	.word	0x200173d4
 80160bc:	200175d8 	.word	0x200175d8
 80160c0:	200027c0 	.word	0x200027c0
 80160c4:	2000340c 	.word	0x2000340c
 80160c8:	2001763c 	.word	0x2001763c
 80160cc:	20018274 	.word	0x20018274
 80160d0:	20003404 	.word	0x20003404
 80160d4:	2001759c 	.word	0x2001759c
 80160d8:	200027e4 	.word	0x200027e4
 80160dc:	20018278 	.word	0x20018278
 80160e0:	20017284 	.word	0x20017284
 80160e4:	200027f0 	.word	0x200027f0

080160e8 <SFXPitchShiftAlloc>:
        {
 80160e8:	b530      	push	{r4, r5, lr}
            tRetune_initToPool(&retune, NUM_RETUNE, 1024, 512, &mediumPool);
 80160ea:	4d24      	ldr	r5, [pc, #144]	; (801617c <SFXPitchShiftAlloc+0x94>)
            tFormantShifter_init(&fs, 7);
 80160ec:	2107      	movs	r1, #7
 80160ee:	4824      	ldr	r0, [pc, #144]	; (8016180 <SFXPitchShiftAlloc+0x98>)
            tRamp_init(&pitchshiftRamp, 100.0f, 1);
 80160f0:	4c24      	ldr	r4, [pc, #144]	; (8016184 <SFXPitchShiftAlloc+0x9c>)
        {
 80160f2:	ed2d 8b02 	vpush	{d8}
 80160f6:	b083      	sub	sp, #12
            tExpSmooth_init(&smoother1, 0.0f, 0.01f);
 80160f8:	eddf 8a23 	vldr	s17, [pc, #140]	; 8016188 <SFXPitchShiftAlloc+0xa0>
            tFormantShifter_init(&fs, 7);
 80160fc:	f00b fc30 	bl	8021960 <tFormantShifter_init>
            tRetune_initToPool(&retune, NUM_RETUNE, 1024, 512, &mediumPool);
 8016100:	f44f 7300 	mov.w	r3, #512	; 0x200
 8016104:	9500      	str	r5, [sp, #0]
 8016106:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801610a:	2101      	movs	r1, #1
 801610c:	481f      	ldr	r0, [pc, #124]	; (801618c <SFXPitchShiftAlloc+0xa4>)
 801610e:	f00a ff29 	bl	8020f64 <tRetune_initToPool>
            tRetune_initToPool(&retune2, NUM_RETUNE, 1024, 512, &mediumPool);
 8016112:	f44f 7300 	mov.w	r3, #512	; 0x200
 8016116:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801611a:	9500      	str	r5, [sp, #0]
 801611c:	2101      	movs	r1, #1
 801611e:	481c      	ldr	r0, [pc, #112]	; (8016190 <SFXPitchShiftAlloc+0xa8>)
 8016120:	f00a ff20 	bl	8020f64 <tRetune_initToPool>
            tRamp_init(&pitchshiftRamp, 100.0f, 1);
 8016124:	4620      	mov	r0, r4
 8016126:	2101      	movs	r1, #1
 8016128:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 8016194 <SFXPitchShiftAlloc+0xac>
 801612c:	f00c f90e 	bl	802234c <tRamp_init>
            tExpSmooth_init(&smoother1, 0.0f, 0.01f);
 8016130:	ed9f 8a19 	vldr	s16, [pc, #100]	; 8016198 <SFXPitchShiftAlloc+0xb0>
            tRamp_setVal(&pitchshiftRamp, 1.0f);
 8016134:	4620      	mov	r0, r4
 8016136:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801613a:	f00c f981 	bl	8022440 <tRamp_setVal>
            tSimplePoly_setNumVoices(&poly, 1);
 801613e:	2101      	movs	r1, #1
 8016140:	4816      	ldr	r0, [pc, #88]	; (801619c <SFXPitchShiftAlloc+0xb4>)
 8016142:	f00e fd39 	bl	8024bb8 <tSimplePoly_setNumVoices>
            tExpSmooth_init(&smoother1, 0.0f, 0.01f);
 8016146:	eef0 0a68 	vmov.f32	s1, s17
 801614a:	eeb0 0a48 	vmov.f32	s0, s16
 801614e:	4814      	ldr	r0, [pc, #80]	; (80161a0 <SFXPitchShiftAlloc+0xb8>)
 8016150:	f00c f9b0 	bl	80224b4 <tExpSmooth_init>
            tExpSmooth_init(&smoother2, 0.0f, 0.01f);
 8016154:	eef0 0a68 	vmov.f32	s1, s17
 8016158:	eeb0 0a48 	vmov.f32	s0, s16
 801615c:	4811      	ldr	r0, [pc, #68]	; (80161a4 <SFXPitchShiftAlloc+0xbc>)
 801615e:	f00c f9a9 	bl	80224b4 <tExpSmooth_init>
            tExpSmooth_init(&smoother3, 0.0f, 0.01f);
 8016162:	eef0 0a68 	vmov.f32	s1, s17
 8016166:	eeb0 0a48 	vmov.f32	s0, s16
 801616a:	480f      	ldr	r0, [pc, #60]	; (80161a8 <SFXPitchShiftAlloc+0xc0>)
        }
 801616c:	b003      	add	sp, #12
 801616e:	ecbd 8b02 	vpop	{d8}
 8016172:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            tExpSmooth_init(&smoother3, 0.0f, 0.01f);
 8016176:	f00c b99d 	b.w	80224b4 <tExpSmooth_init>
 801617a:	bf00      	nop
 801617c:	200174cc 	.word	0x200174cc
 8016180:	2000290c 	.word	0x2000290c
 8016184:	20017640 	.word	0x20017640
 8016188:	3c23d70a 	.word	0x3c23d70a
 801618c:	20002630 	.word	0x20002630
 8016190:	20017888 	.word	0x20017888
 8016194:	42c80000 	.word	0x42c80000
 8016198:	00000000 	.word	0x00000000
 801619c:	200174c8 	.word	0x200174c8
 80161a0:	200027ec 	.word	0x200027ec
 80161a4:	20016fe8 	.word	0x20016fe8
 80161a8:	200177bc 	.word	0x200177bc

080161ac <SFXPitchShiftFrame>:
        }
 80161ac:	4770      	bx	lr
 80161ae:	bf00      	nop

080161b0 <SFXPitchShiftTick>:
        {
 80161b0:	b570      	push	{r4, r5, r6, lr}
 80161b2:	ed2d 8b04 	vpush	{d8-d9}
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
 80161b6:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
 80161ba:	4e60      	ldr	r6, [pc, #384]	; (801633c <SFXPitchShiftTick+0x18c>)
 80161bc:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
            float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
 80161c0:	ed9f 7a5f 	vldr	s14, [pc, #380]	; 8016340 <SFXPitchShiftTick+0x190>
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
 80161c4:	edd6 6a33 	vldr	s13, [r6, #204]	; 0xcc
        {
 80161c8:	b082      	sub	sp, #8
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
 80161ca:	eef0 5a48 	vmov.f32	s11, s16
            float myPitchFactorCoarse = (presetKnobValues[Pitchshift][0]*2.0f) - 1.0f;
 80161ce:	ed96 6a32 	vldr	s12, [r6, #200]	; 0xc8
            displayValues[0] = myPitchFactorCombined;
 80161d2:	4c5c      	ldr	r4, [pc, #368]	; (8016344 <SFXPitchShiftTick+0x194>)
        {
 80161d4:	4605      	mov	r5, r0
            float myPitchFactorCoarse = (presetKnobValues[Pitchshift][0]*2.0f) - 1.0f;
 80161d6:	eea6 8a27 	vfma.f32	s16, s12, s15
            float keyPitch = (float)tSimplePoly_getPitchAndCheckActive(&poly, 0);
 80161da:	2100      	movs	r1, #0
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
 80161dc:	eee6 5aa7 	vfma.f32	s11, s13, s15
            float keyPitch = (float)tSimplePoly_getPitchAndCheckActive(&poly, 0);
 80161e0:	4859      	ldr	r0, [pc, #356]	; (8016348 <SFXPitchShiftTick+0x198>)
            float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
 80161e2:	eea5 8a87 	vfma.f32	s16, s11, s14
            displayValues[0] = myPitchFactorCombined;
 80161e6:	ed84 8a00 	vstr	s16, [r4]
            displayValues[1] = myPitchFactorCombined;
 80161ea:	ed84 8a01 	vstr	s16, [r4, #4]
            float keyPitch = (float)tSimplePoly_getPitchAndCheckActive(&poly, 0);
 80161ee:	f00e fd0d 	bl	8024c0c <tSimplePoly_getPitchAndCheckActive>
 80161f2:	ee07 0a90 	vmov	s15, r0
 80161f6:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
            if (keyPitch >= 0)
 80161fa:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80161fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016202:	f280 8094 	bge.w	801632e <SFXPitchShiftTick+0x17e>
                keyPitch = 1.0f;
 8016206:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
            float myPitchFactor = fastexp2f(myPitchFactorCombined);
 801620a:	eeb0 0a48 	vmov.f32	s0, s16
 801620e:	f00d fd7f 	bl	8023d10 <fastexp2f>
            myPitchFactor *= keyPitch;
 8016212:	ee68 8a80 	vmul.f32	s17, s17, s0
            tRetune_setPitchFactor(&retune, myPitchFactor, 0);
 8016216:	2100      	movs	r1, #0
 8016218:	484c      	ldr	r0, [pc, #304]	; (801634c <SFXPitchShiftTick+0x19c>)
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
 801621a:	eebf 9a00 	vmov.f32	s18, #240	; 0xbf800000 -1.0
            tRetune_setPitchFactor(&retune, myPitchFactor, 0);
 801621e:	eeb0 0a68 	vmov.f32	s0, s17
 8016222:	f00b f899 	bl	8021358 <tRetune_setPitchFactor>
            tRetune_setPitchFactor(&retune2, myPitchFactor, 0);
 8016226:	2100      	movs	r1, #0
 8016228:	4849      	ldr	r0, [pc, #292]	; (8016350 <SFXPitchShiftTick+0x1a0>)
 801622a:	eeb0 0a68 	vmov.f32	s0, s17
 801622e:	f00b f893 	bl	8021358 <tRetune_setPitchFactor>
            displayValues[2] = LEAF_clip( 0.0f,((presetKnobValues[Pitchshift][2]) * 3.0f) - 0.2f,3.0f);
 8016232:	eeb0 1a08 	vmov.f32	s2, #8	; 0x40400000  3.0
 8016236:	edd6 7a34 	vldr	s15, [r6, #208]	; 0xd0
 801623a:	eddf 0a46 	vldr	s1, [pc, #280]	; 8016354 <SFXPitchShiftTick+0x1a4>
 801623e:	ed9f 0a46 	vldr	s0, [pc, #280]	; 8016358 <SFXPitchShiftTick+0x1a8>
 8016242:	eee7 0a81 	vfma.f32	s1, s15, s2
 8016246:	f00d fe35 	bl	8023eb4 <LEAF_clip>
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
 801624a:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
            displayValues[2] = LEAF_clip( 0.0f,((presetKnobValues[Pitchshift][2]) * 3.0f) - 0.2f,3.0f);
 801624e:	ed84 0a02 	vstr	s0, [r4, #8]
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
 8016252:	eeb0 0a49 	vmov.f32	s0, s18
 8016256:	ed96 7a35 	vldr	s14, [r6, #212]	; 0xd4
 801625a:	eea7 0a27 	vfma.f32	s0, s14, s15
 801625e:	f00d fd57 	bl	8023d10 <fastexp2f>
            tExpSmooth_setDest(&smoother3, displayValues[2]);
 8016262:	483e      	ldr	r0, [pc, #248]	; (801635c <SFXPitchShiftTick+0x1ac>)
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
 8016264:	ed84 0a03 	vstr	s0, [r4, #12]
            tExpSmooth_setDest(&smoother3, displayValues[2]);
 8016268:	ed94 0a02 	vldr	s0, [r4, #8]
 801626c:	f00c f988 	bl	8022580 <tExpSmooth_setDest>
            tFormantShifter_setIntensity(&fs, tExpSmooth_tick(&smoother3)+.1f);
 8016270:	483a      	ldr	r0, [pc, #232]	; (801635c <SFXPitchShiftTick+0x1ac>)
 8016272:	f00c f98f 	bl	8022594 <tExpSmooth_tick>
 8016276:	eddf 7a32 	vldr	s15, [pc, #200]	; 8016340 <SFXPitchShiftTick+0x190>
 801627a:	4839      	ldr	r0, [pc, #228]	; (8016360 <SFXPitchShiftTick+0x1b0>)
 801627c:	ee30 0a27 	vadd.f32	s0, s0, s15
 8016280:	f00b fd68 	bl	8021d54 <tFormantShifter_setIntensity>
            tFormantShifter_setShiftFactor(&fs, displayValues[3]);
 8016284:	ed94 0a03 	vldr	s0, [r4, #12]
 8016288:	4835      	ldr	r0, [pc, #212]	; (8016360 <SFXPitchShiftTick+0x1b0>)
 801628a:	f00b fd5f 	bl	8021d4c <tFormantShifter_setShiftFactor>
            if (displayValues[2] > 0.01f)
 801628e:	eddf 7a35 	vldr	s15, [pc, #212]	; 8016364 <SFXPitchShiftTick+0x1b4>
 8016292:	ed94 7a02 	vldr	s14, [r4, #8]
                tRamp_setDest(&pitchshiftRamp, 1.0f);
 8016296:	4834      	ldr	r0, [pc, #208]	; (8016368 <SFXPitchShiftTick+0x1b8>)
            if (displayValues[2] > 0.01f)
 8016298:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801629c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                tRamp_setDest(&pitchshiftRamp, -1.0f);
 80162a0:	bfcc      	ite	gt
 80162a2:	eeb0 0a49 	vmovgt.f32	s0, s18
                tRamp_setDest(&pitchshiftRamp, 1.0f);
 80162a6:	eeb7 0a00 	vmovle.f32	s0, #112	; 0x3f800000  1.0
 80162aa:	f00c f8bb 	bl	8022424 <tRamp_setDest>
            float crossfadeVal = tRamp_tick(&pitchshiftRamp);
 80162ae:	482e      	ldr	r0, [pc, #184]	; (8016368 <SFXPitchShiftTick+0x1b8>)
 80162b0:	f00c f8d4 	bl	802245c <tRamp_tick>
            LEAF_crossfade(crossfadeVal, myGains);
 80162b4:	4668      	mov	r0, sp
 80162b6:	f00d fd79 	bl	8023dac <LEAF_crossfade>
            tExpSmooth_setDest(&smoother1, myGains[0]);
 80162ba:	ed9d 0a00 	vldr	s0, [sp]
 80162be:	482b      	ldr	r0, [pc, #172]	; (801636c <SFXPitchShiftTick+0x1bc>)
 80162c0:	f00c f95e 	bl	8022580 <tExpSmooth_setDest>
            tExpSmooth_setDest(&smoother2, myGains[1]);
 80162c4:	ed9d 0a01 	vldr	s0, [sp, #4]
 80162c8:	4829      	ldr	r0, [pc, #164]	; (8016370 <SFXPitchShiftTick+0x1c0>)
 80162ca:	f00c f959 	bl	8022580 <tExpSmooth_setDest>
            float formantsample = tanhf(tFormantShifter_remove(&fs, input[1]));
 80162ce:	4824      	ldr	r0, [pc, #144]	; (8016360 <SFXPitchShiftTick+0x1b0>)
 80162d0:	ed95 0a01 	vldr	s0, [r5, #4]
 80162d4:	f00b fb86 	bl	80219e4 <tFormantShifter_remove>
 80162d8:	f011 fab8 	bl	802784c <tanhf>
            float* samples = tRetune_tick(&retune2, formantsample);
 80162dc:	481c      	ldr	r0, [pc, #112]	; (8016350 <SFXPitchShiftTick+0x1a0>)
 80162de:	f00a ff67 	bl	80211b0 <tRetune_tick>
            formantsample = samples[0];
 80162e2:	ed90 8a00 	vldr	s16, [r0]
            samples = tRetune_tick(&retune, sample);
 80162e6:	ed95 0a01 	vldr	s0, [r5, #4]
 80162ea:	4818      	ldr	r0, [pc, #96]	; (801634c <SFXPitchShiftTick+0x19c>)
 80162ec:	f00a ff60 	bl	80211b0 <tRetune_tick>
            formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
 80162f0:	eeb0 0a48 	vmov.f32	s0, s16
            sample = samples[0];
 80162f4:	ed90 8a00 	vldr	s16, [r0]
            formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
 80162f8:	4819      	ldr	r0, [pc, #100]	; (8016360 <SFXPitchShiftTick+0x1b0>)
 80162fa:	f00b fbf1 	bl	8021ae0 <tFormantShifter_add>
 80162fe:	f011 faa5 	bl	802784c <tanhf>
 8016302:	481b      	ldr	r0, [pc, #108]	; (8016370 <SFXPitchShiftTick+0x1c0>)
 8016304:	eeb0 9a40 	vmov.f32	s18, s0
 8016308:	f00c f944 	bl	8022594 <tExpSmooth_tick>
            sample = (sample * (tExpSmooth_tick(&smoother1))) +  formantsample;
 801630c:	4817      	ldr	r0, [pc, #92]	; (801636c <SFXPitchShiftTick+0x1bc>)
            formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
 801630e:	eef0 8a40 	vmov.f32	s17, s0
            sample = (sample * (tExpSmooth_tick(&smoother1))) +  formantsample;
 8016312:	f00c f93f 	bl	8022594 <tExpSmooth_tick>
 8016316:	ee20 0a08 	vmul.f32	s0, s0, s16
 801631a:	eea9 0a28 	vfma.f32	s0, s18, s17
            input[0] = sample;
 801631e:	ed85 0a00 	vstr	s0, [r5]
            input[1] = sample;
 8016322:	ed85 0a01 	vstr	s0, [r5, #4]
        }
 8016326:	b002      	add	sp, #8
 8016328:	ecbd 8b04 	vpop	{d8-d9}
 801632c:	bd70      	pop	{r4, r5, r6, pc}
                keyPitch = LEAF_midiToFrequency(keyPitch) * 0.003822629969419f ;
 801632e:	eddf 8a11 	vldr	s17, [pc, #68]	; 8016374 <SFXPitchShiftTick+0x1c4>
 8016332:	f00d feab 	bl	802408c <LEAF_midiToFrequency>
 8016336:	ee60 8a28 	vmul.f32	s17, s0, s17
 801633a:	e766      	b.n	801620a <SFXPitchShiftTick+0x5a>
 801633c:	20002cb8 	.word	0x20002cb8
 8016340:	3dcccccd 	.word	0x3dcccccd
 8016344:	200187dc 	.word	0x200187dc
 8016348:	200174c8 	.word	0x200174c8
 801634c:	20002630 	.word	0x20002630
 8016350:	20017888 	.word	0x20017888
 8016354:	be4ccccd 	.word	0xbe4ccccd
 8016358:	00000000 	.word	0x00000000
 801635c:	200177bc 	.word	0x200177bc
 8016360:	2000290c 	.word	0x2000290c
 8016364:	3c23d70a 	.word	0x3c23d70a
 8016368:	20017640 	.word	0x20017640
 801636c:	200027ec 	.word	0x200027ec
 8016370:	20016fe8 	.word	0x20016fe8
 8016374:	3b7a8517 	.word	0x3b7a8517

08016378 <SFXPitchShiftFree>:
        {
 8016378:	b508      	push	{r3, lr}
            tFormantShifter_free(&fs);
 801637a:	480b      	ldr	r0, [pc, #44]	; (80163a8 <SFXPitchShiftFree+0x30>)
 801637c:	f00b faf6 	bl	802196c <tFormantShifter_free>
            tRetune_free(&retune);
 8016380:	480a      	ldr	r0, [pc, #40]	; (80163ac <SFXPitchShiftFree+0x34>)
 8016382:	f00a fed3 	bl	802112c <tRetune_free>
            tRetune_free(&retune2);
 8016386:	480a      	ldr	r0, [pc, #40]	; (80163b0 <SFXPitchShiftFree+0x38>)
 8016388:	f00a fed0 	bl	802112c <tRetune_free>
            tRamp_free(&pitchshiftRamp);
 801638c:	4809      	ldr	r0, [pc, #36]	; (80163b4 <SFXPitchShiftFree+0x3c>)
 801638e:	f00c f845 	bl	802241c <tRamp_free>
            tExpSmooth_free(&smoother1);
 8016392:	4809      	ldr	r0, [pc, #36]	; (80163b8 <SFXPitchShiftFree+0x40>)
 8016394:	f00c f8de 	bl	8022554 <tExpSmooth_free>
            tExpSmooth_free(&smoother2);
 8016398:	4808      	ldr	r0, [pc, #32]	; (80163bc <SFXPitchShiftFree+0x44>)
 801639a:	f00c f8db 	bl	8022554 <tExpSmooth_free>
            tExpSmooth_free(&smoother3);
 801639e:	4808      	ldr	r0, [pc, #32]	; (80163c0 <SFXPitchShiftFree+0x48>)
        }
 80163a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tExpSmooth_free(&smoother3);
 80163a4:	f00c b8d6 	b.w	8022554 <tExpSmooth_free>
 80163a8:	2000290c 	.word	0x2000290c
 80163ac:	20002630 	.word	0x20002630
 80163b0:	20017888 	.word	0x20017888
 80163b4:	20017640 	.word	0x20017640
 80163b8:	200027ec 	.word	0x200027ec
 80163bc:	20016fe8 	.word	0x20016fe8
 80163c0:	200177bc 	.word	0x200177bc

080163c4 <SFXNeartuneAlloc>:
        {
 80163c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            leaf.clearOnAllocation = 1;
 80163c6:	2401      	movs	r4, #1
 80163c8:	4d28      	ldr	r5, [pc, #160]	; (801646c <SFXNeartuneAlloc+0xa8>)
            tRetune_init(&autotuneMono, 1, 512, 256);
 80163ca:	f44f 7380 	mov.w	r3, #256	; 0x100
 80163ce:	4828      	ldr	r0, [pc, #160]	; (8016470 <SFXNeartuneAlloc+0xac>)
 80163d0:	4621      	mov	r1, r4
 80163d2:	f44f 7200 	mov.w	r2, #512	; 0x200
            leaf.clearOnAllocation = 1;
 80163d6:	616c      	str	r4, [r5, #20]
            tRetune_init(&autotuneMono, 1, 512, 256);
 80163d8:	f00a fe9e 	bl	8021118 <tRetune_init>
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80163dc:	4b25      	ldr	r3, [pc, #148]	; (8016474 <SFXNeartuneAlloc+0xb0>)
            for (int i = 0; i < 128; i++)
 80163de:	2100      	movs	r1, #0
 80163e0:	4825      	ldr	r0, [pc, #148]	; (8016478 <SFXNeartuneAlloc+0xb4>)
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80163e2:	781f      	ldrb	r7, [r3, #0]
 80163e4:	4e25      	ldr	r6, [pc, #148]	; (801647c <SFXNeartuneAlloc+0xb8>)
 80163e6:	4d26      	ldr	r5, [pc, #152]	; (8016480 <SFXNeartuneAlloc+0xbc>)
                float tempNote = i;
 80163e8:	ee07 1a90 	vmov	s15, r1
            for (int i = 0; i < 128; i++)
 80163ec:	3101      	adds	r1, #1
                float tempNote = i;
 80163ee:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            for (int i = 0; i < 128; i++)
 80163f2:	2980      	cmp	r1, #128	; 0x80
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80163f4:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 80163f8:	ee17 3a90 	vmov	r3, s15
 80163fc:	eba3 0307 	sub.w	r3, r3, r7
 8016400:	fb85 2403 	smull	r2, r4, r5, r3
 8016404:	ea4f 72e3 	mov.w	r2, r3, asr #31
 8016408:	ebc2 0264 	rsb	r2, r2, r4, asr #1
 801640c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8016410:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 8016414:	ee07 3a90 	vmov	s15, r3
 8016418:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801641c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8016420:	ee17 3a90 	vmov	r3, s15
 8016424:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8016428:	edd3 7a00 	vldr	s15, [r3]
 801642c:	ee77 7a87 	vadd.f32	s15, s15, s14
                notes[i] = tunedNote;
 8016430:	ece0 7a01 	vstmia	r0!, {s15}
            for (int i = 0; i < 128; i++)
 8016434:	d1d8      	bne.n	80163e8 <SFXNeartuneAlloc+0x24>
            tExpSmooth_init(&neartune_smoother, 1.0f, .007f);
 8016436:	eddf 0a13 	vldr	s1, [pc, #76]	; 8016484 <SFXNeartuneAlloc+0xc0>
 801643a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801643e:	4812      	ldr	r0, [pc, #72]	; (8016488 <SFXNeartuneAlloc+0xc4>)
 8016440:	f00c f838 	bl	80224b4 <tExpSmooth_init>
            tRamp_init(&nearWetRamp, 20.0f, 1);
 8016444:	2101      	movs	r1, #1
 8016446:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 801644a:	4810      	ldr	r0, [pc, #64]	; (801648c <SFXNeartuneAlloc+0xc8>)
 801644c:	f00b ff7e 	bl	802234c <tRamp_init>
            setLED_A(autotuneChromatic);
 8016450:	4b0f      	ldr	r3, [pc, #60]	; (8016490 <SFXNeartuneAlloc+0xcc>)
 8016452:	6818      	ldr	r0, [r3, #0]
 8016454:	f7fd fa7a 	bl	801394c <setLED_A>
            setLED_C(autotuneLock);
 8016458:	4b0e      	ldr	r3, [pc, #56]	; (8016494 <SFXNeartuneAlloc+0xd0>)
 801645a:	6818      	ldr	r0, [r3, #0]
 801645c:	f7fd fa92 	bl	8013984 <setLED_C>
            lastSnap = 1.0f;
 8016460:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8016464:	4b0c      	ldr	r3, [pc, #48]	; (8016498 <SFXNeartuneAlloc+0xd4>)
 8016466:	601a      	str	r2, [r3, #0]
        }
 8016468:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801646a:	bf00      	nop
 801646c:	200194e8 	.word	0x200194e8
 8016470:	200174c0 	.word	0x200174c0
 8016474:	20000668 	.word	0x20000668
 8016478:	200029f0 	.word	0x200029f0
 801647c:	20000634 	.word	0x20000634
 8016480:	2aaaaaab 	.word	0x2aaaaaab
 8016484:	3be56042 	.word	0x3be56042
 8016488:	20017594 	.word	0x20017594
 801648c:	200183ac 	.word	0x200183ac
 8016490:	2000052c 	.word	0x2000052c
 8016494:	20000530 	.word	0x20000530
 8016498:	20000250 	.word	0x20000250

0801649c <SFXNeartuneFrame>:
        {
 801649c:	b538      	push	{r3, r4, r5, lr}
            if ((tSimplePoly_getNumActiveVoices(&poly) != 0) || (autotuneChromatic == 1) || (autotuneLock == 1))
 801649e:	4826      	ldr	r0, [pc, #152]	; (8016538 <SFXNeartuneFrame+0x9c>)
 80164a0:	f00e fb96 	bl	8024bd0 <tSimplePoly_getNumActiveVoices>
 80164a4:	b9e8      	cbnz	r0, 80164e2 <SFXNeartuneFrame+0x46>
 80164a6:	4b25      	ldr	r3, [pc, #148]	; (801653c <SFXNeartuneFrame+0xa0>)
 80164a8:	681b      	ldr	r3, [r3, #0]
 80164aa:	2b01      	cmp	r3, #1
 80164ac:	d019      	beq.n	80164e2 <SFXNeartuneFrame+0x46>
 80164ae:	4b24      	ldr	r3, [pc, #144]	; (8016540 <SFXNeartuneFrame+0xa4>)
 80164b0:	681b      	ldr	r3, [r3, #0]
 80164b2:	2b01      	cmp	r3, #1
 80164b4:	d015      	beq.n	80164e2 <SFXNeartuneFrame+0x46>
            if (buttonActionsSFX[ButtonA][ActionPress])
 80164b6:	4c23      	ldr	r4, [pc, #140]	; (8016544 <SFXNeartuneFrame+0xa8>)
                tRamp_setDest(&nearWetRamp, -1.0f);
 80164b8:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 80164bc:	4822      	ldr	r0, [pc, #136]	; (8016548 <SFXNeartuneFrame+0xac>)
 80164be:	f00b ffb1 	bl	8022424 <tRamp_setDest>
            if (buttonActionsSFX[ButtonA][ActionPress])
 80164c2:	7d23      	ldrb	r3, [r4, #20]
 80164c4:	b1b3      	cbz	r3, 80164f4 <SFXNeartuneFrame+0x58>
                autotuneChromatic = !autotuneChromatic;
 80164c6:	4a1d      	ldr	r2, [pc, #116]	; (801653c <SFXNeartuneFrame+0xa0>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 80164c8:	2100      	movs	r1, #0
                autotuneChromatic = !autotuneChromatic;
 80164ca:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 80164cc:	7521      	strb	r1, [r4, #20]
                autotuneChromatic = !autotuneChromatic;
 80164ce:	fab3 f383 	clz	r3, r3
 80164d2:	095b      	lsrs	r3, r3, #5
                setLED_A(autotuneChromatic);
 80164d4:	4618      	mov	r0, r3
                autotuneChromatic = !autotuneChromatic;
 80164d6:	6013      	str	r3, [r2, #0]
                setLED_A(autotuneChromatic);
 80164d8:	f7fd fa38 	bl	801394c <setLED_A>
            if (buttonActionsSFX[ButtonC][ActionPress])
 80164dc:	7f23      	ldrb	r3, [r4, #28]
 80164de:	b963      	cbnz	r3, 80164fa <SFXNeartuneFrame+0x5e>
        }
 80164e0:	bd38      	pop	{r3, r4, r5, pc}
            if (buttonActionsSFX[ButtonA][ActionPress])
 80164e2:	4c18      	ldr	r4, [pc, #96]	; (8016544 <SFXNeartuneFrame+0xa8>)
                tRamp_setDest(&nearWetRamp, 1.0f);
 80164e4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80164e8:	4817      	ldr	r0, [pc, #92]	; (8016548 <SFXNeartuneFrame+0xac>)
 80164ea:	f00b ff9b 	bl	8022424 <tRamp_setDest>
            if (buttonActionsSFX[ButtonA][ActionPress])
 80164ee:	7d23      	ldrb	r3, [r4, #20]
 80164f0:	2b00      	cmp	r3, #0
 80164f2:	d1e8      	bne.n	80164c6 <SFXNeartuneFrame+0x2a>
            if (buttonActionsSFX[ButtonC][ActionPress])
 80164f4:	7f23      	ldrb	r3, [r4, #28]
 80164f6:	2b00      	cmp	r3, #0
 80164f8:	d0f2      	beq.n	80164e0 <SFXNeartuneFrame+0x44>
                autotuneLock = !autotuneLock;
 80164fa:	4d11      	ldr	r5, [pc, #68]	; (8016540 <SFXNeartuneFrame+0xa4>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 80164fc:	2200      	movs	r2, #0
                autotuneLock = !autotuneLock;
 80164fe:	682b      	ldr	r3, [r5, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8016500:	7722      	strb	r2, [r4, #28]
                autotuneLock = !autotuneLock;
 8016502:	fab3 f383 	clz	r3, r3
 8016506:	095b      	lsrs	r3, r3, #5
                setLED_C(autotuneLock);
 8016508:	4618      	mov	r0, r3
                autotuneLock = !autotuneLock;
 801650a:	602b      	str	r3, [r5, #0]
                setLED_C(autotuneLock);
 801650c:	f7fd fa3a 	bl	8013984 <setLED_C>
                if (autotuneLock)
 8016510:	6829      	ldr	r1, [r5, #0]
 8016512:	b151      	cbz	r1, 801652a <SFXNeartuneFrame+0x8e>
 8016514:	4d0d      	ldr	r5, [pc, #52]	; (801654c <SFXNeartuneFrame+0xb0>)
 8016516:	4c0e      	ldr	r4, [pc, #56]	; (8016550 <SFXNeartuneFrame+0xb4>)
 8016518:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801651a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801651c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801651e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8016520:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8016524:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        }
 8016528:	bd38      	pop	{r3, r4, r5, pc}
 801652a:	2230      	movs	r2, #48	; 0x30
 801652c:	4808      	ldr	r0, [pc, #32]	; (8016550 <SFXNeartuneFrame+0xb4>)
 801652e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8016532:	f010 bd54 	b.w	8026fde <memset>
 8016536:	bf00      	nop
 8016538:	200174c8 	.word	0x200174c8
 801653c:	2000052c 	.word	0x2000052c
 8016540:	20000530 	.word	0x20000530
 8016544:	2001872c 	.word	0x2001872c
 8016548:	200183ac 	.word	0x200183ac
 801654c:	20000540 	.word	0x20000540
 8016550:	200005b8 	.word	0x200005b8

08016554 <SFXNeartuneFree>:
        {
 8016554:	b508      	push	{r3, lr}
            tRetune_free(&autotuneMono);
 8016556:	4805      	ldr	r0, [pc, #20]	; (801656c <SFXNeartuneFree+0x18>)
 8016558:	f00a fde8 	bl	802112c <tRetune_free>
            tExpSmooth_free(&neartune_smoother);
 801655c:	4804      	ldr	r0, [pc, #16]	; (8016570 <SFXNeartuneFree+0x1c>)
 801655e:	f00b fff9 	bl	8022554 <tExpSmooth_free>
            tRamp_free(&nearWetRamp);
 8016562:	4804      	ldr	r0, [pc, #16]	; (8016574 <SFXNeartuneFree+0x20>)
        }
 8016564:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tRamp_free(&nearWetRamp);
 8016568:	f00b bf58 	b.w	802241c <tRamp_free>
 801656c:	200174c0 	.word	0x200174c0
 8016570:	20017594 	.word	0x20017594
 8016574:	200183ac 	.word	0x200183ac

08016578 <SFXAutotuneAlloc>:
        {
 8016578:	b500      	push	{lr}
            tAutotune_initToPool(&autotunePoly, NUM_AUTOTUNE, 1024, 512, &mediumPool);
 801657a:	4809      	ldr	r0, [pc, #36]	; (80165a0 <SFXAutotuneAlloc+0x28>)
        {
 801657c:	b083      	sub	sp, #12
            tAutotune_initToPool(&autotunePoly, NUM_AUTOTUNE, 1024, 512, &mediumPool);
 801657e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8016582:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8016586:	9000      	str	r0, [sp, #0]
 8016588:	2104      	movs	r1, #4
 801658a:	4806      	ldr	r0, [pc, #24]	; (80165a4 <SFXAutotuneAlloc+0x2c>)
 801658c:	f00a ff06 	bl	802139c <tAutotune_initToPool>
            tSimplePoly_setNumVoices(&poly, NUM_AUTOTUNE);
 8016590:	2104      	movs	r1, #4
 8016592:	4805      	ldr	r0, [pc, #20]	; (80165a8 <SFXAutotuneAlloc+0x30>)
        }
 8016594:	b003      	add	sp, #12
 8016596:	f85d eb04 	ldr.w	lr, [sp], #4
            tSimplePoly_setNumVoices(&poly, NUM_AUTOTUNE);
 801659a:	f00e bb0d 	b.w	8024bb8 <tSimplePoly_setNumVoices>
 801659e:	bf00      	nop
 80165a0:	200174cc 	.word	0x200174cc
 80165a4:	200033e0 	.word	0x200033e0
 80165a8:	200174c8 	.word	0x200174c8

080165ac <SFXAutotuneFrame>:
        {
 80165ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80165b0:	4f35      	ldr	r7, [pc, #212]	; (8016688 <SFXAutotuneFrame+0xdc>)
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 80165b2:	2400      	movs	r4, #0
 80165b4:	4d35      	ldr	r5, [pc, #212]	; (801668c <SFXAutotuneFrame+0xe0>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80165b6:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 80166a8 <SFXAutotuneFrame+0xfc>
        {
 80165ba:	ed2d 8b02 	vpush	{d8}
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 80165be:	ed9f 8a34 	vldr	s16, [pc, #208]	; 8016690 <SFXAutotuneFrame+0xe4>
        {
 80165c2:	b082      	sub	sp, #8
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 80165c4:	e03e      	b.n	8016644 <SFXAutotuneFrame+0x98>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 80165c6:	f00e fb1b 	bl	8024c00 <tSimplePoly_getPitch>
 80165ca:	ee07 0a90 	vmov	s15, r0
 80165ce:	4a31      	ldr	r2, [pc, #196]	; (8016694 <SFXAutotuneFrame+0xe8>)
 80165d0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80165d4:	4b30      	ldr	r3, [pc, #192]	; (8016698 <SFXAutotuneFrame+0xec>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 80165d6:	ed92 0a00 	vldr	s0, [r2]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80165da:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 80165dc:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 80165e0:	492e      	ldr	r1, [pc, #184]	; (801669c <SFXAutotuneFrame+0xf0>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80165e2:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 80165e6:	ee17 3a90 	vmov	r3, s15
 80165ea:	1a9b      	subs	r3, r3, r2
 80165ec:	fb88 2003 	smull	r2, r0, r8, r3
 80165f0:	17da      	asrs	r2, r3, #31
 80165f2:	ebc2 0260 	rsb	r2, r2, r0, asr #1
 80165f6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80165fa:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 80165fe:	ee07 3a90 	vmov	s15, r3
 8016602:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8016606:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801660a:	ee17 3a90 	vmov	r3, s15
 801660e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8016612:	ed93 0a00 	vldr	s0, [r3]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8016616:	ee37 0a00 	vadd.f32	s0, s14, s0
 801661a:	f00d fd37 	bl	802408c <LEAF_midiToFrequency>
 801661e:	4b20      	ldr	r3, [pc, #128]	; (80166a0 <SFXAutotuneFrame+0xf4>)
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8016620:	4631      	mov	r1, r6
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8016622:	eca7 0a01 	vstmia	r7!, {s0}
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8016626:	4628      	mov	r0, r5
 8016628:	eb03 0684 	add.w	r6, r3, r4, lsl #2
 801662c:	f00e faf4 	bl	8024c18 <tSimplePoly_getVelocity>
 8016630:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8016634:	2800      	cmp	r0, #0
 8016636:	4630      	mov	r0, r6
 8016638:	f104 0401 	add.w	r4, r4, #1
 801663c:	fe30 0a08 	vselgt.f32	s0, s0, s16
 8016640:	f00b ff9e 	bl	8022580 <tExpSmooth_setDest>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8016644:	4628      	mov	r0, r5
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8016646:	b2e6      	uxtb	r6, r4
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8016648:	f00e fabe 	bl	8024bc8 <tSimplePoly_getNumVoices>
 801664c:	42a0      	cmp	r0, r4
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801664e:	4631      	mov	r1, r6
 8016650:	4628      	mov	r0, r5
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8016652:	dcb8      	bgt.n	80165c6 <SFXAutotuneFrame+0x1a>
            int tempNumVoices = tSimplePoly_getNumActiveVoices(&poly);
 8016654:	480d      	ldr	r0, [pc, #52]	; (801668c <SFXAutotuneFrame+0xe0>)
 8016656:	f00e fabb 	bl	8024bd0 <tSimplePoly_getNumActiveVoices>
            if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
 801665a:	9001      	str	r0, [sp, #4]
 801665c:	b920      	cbnz	r0, 8016668 <SFXAutotuneFrame+0xbc>
        }
 801665e:	b002      	add	sp, #8
 8016660:	ecbd 8b02 	vpop	{d8}
 8016664:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
 8016668:	ee07 0a90 	vmov	s15, r0
 801666c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8016670:	480c      	ldr	r0, [pc, #48]	; (80166a4 <SFXAutotuneFrame+0xf8>)
 8016672:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8016676:	ee80 0a27 	vdiv.f32	s0, s0, s15
        }
 801667a:	b002      	add	sp, #8
 801667c:	ecbd 8b02 	vpop	{d8}
 8016680:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
 8016684:	f00b bf7c 	b.w	8022580 <tExpSmooth_setDest>
 8016688:	200033e4 	.word	0x200033e4
 801668c:	200174c8 	.word	0x200174c8
 8016690:	00000000 	.word	0x00000000
 8016694:	200005e8 	.word	0x200005e8
 8016698:	20000668 	.word	0x20000668
 801669c:	20000634 	.word	0x20000634
 80166a0:	20017968 	.word	0x20017968
 80166a4:	20017204 	.word	0x20017204
 80166a8:	2aaaaaab 	.word	0x2aaaaaab

080166ac <SFXAutotuneTick>:
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
 80166ac:	4b27      	ldr	r3, [pc, #156]	; (801674c <SFXAutotuneTick+0xa0>)
 80166ae:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 80166b2:	ed9f 7a27 	vldr	s14, [pc, #156]	; 8016750 <SFXAutotuneTick+0xa4>
        {
 80166b6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80166ba:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
 80166be:	edd3 6a64 	vldr	s13, [r3, #400]	; 0x190
        {
 80166c2:	4680      	mov	r8, r0
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
 80166c4:	4b23      	ldr	r3, [pc, #140]	; (8016754 <SFXAutotuneTick+0xa8>)
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 80166c6:	2400      	movs	r4, #0
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
 80166c8:	eee6 7a87 	vfma.f32	s15, s13, s14
            tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
 80166cc:	4822      	ldr	r0, [pc, #136]	; (8016758 <SFXAutotuneTick+0xac>)
 80166ce:	4d23      	ldr	r5, [pc, #140]	; (801675c <SFXAutotuneTick+0xb0>)
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 80166d0:	4f23      	ldr	r7, [pc, #140]	; (8016760 <SFXAutotuneTick+0xb4>)
                tAutotune_setFreq(&autotunePoly, freq[i], i);
 80166d2:	4606      	mov	r6, r0
            tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
 80166d4:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
 80166d8:	edc3 7a00 	vstr	s15, [r3]
            tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
 80166dc:	f00b f880 	bl	80217e0 <tAutotune_setFidelityThreshold>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 80166e0:	e003      	b.n	80166ea <SFXAutotuneTick+0x3e>
                tAutotune_setFreq(&autotunePoly, freq[i], i);
 80166e2:	ecb5 0a01 	vldmia	r5!, {s0}
 80166e6:	f00b f873 	bl	80217d0 <tAutotune_setFreq>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 80166ea:	4638      	mov	r0, r7
 80166ec:	f00e fa6c 	bl	8024bc8 <tSimplePoly_getNumVoices>
 80166f0:	42a0      	cmp	r0, r4
                tAutotune_setFreq(&autotunePoly, freq[i], i);
 80166f2:	4621      	mov	r1, r4
 80166f4:	4630      	mov	r0, r6
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 80166f6:	f104 0401 	add.w	r4, r4, #1
 80166fa:	dcf2      	bgt.n	80166e2 <SFXAutotuneTick+0x36>
            float* samples = tAutotune_tick(&autotunePoly, input[1]);
 80166fc:	ed98 0a01 	vldr	s0, [r8, #4]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8016700:	2400      	movs	r4, #0
            float* samples = tAutotune_tick(&autotunePoly, input[1]);
 8016702:	4815      	ldr	r0, [pc, #84]	; (8016758 <SFXAutotuneTick+0xac>)
 8016704:	f00a ff68 	bl	80215d8 <tAutotune_tick>
            float sample = 0.0f;
 8016708:	ed9f 8a16 	vldr	s16, [pc, #88]	; 8016764 <SFXAutotuneTick+0xb8>
            float* samples = tAutotune_tick(&autotunePoly, input[1]);
 801670c:	4605      	mov	r5, r0
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 801670e:	4f14      	ldr	r7, [pc, #80]	; (8016760 <SFXAutotuneTick+0xb4>)
                sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
 8016710:	4e15      	ldr	r6, [pc, #84]	; (8016768 <SFXAutotuneTick+0xbc>)
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8016712:	e005      	b.n	8016720 <SFXAutotuneTick+0x74>
                sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
 8016714:	ecf5 8a01 	vldmia	r5!, {s17}
 8016718:	f00b ff3c 	bl	8022594 <tExpSmooth_tick>
 801671c:	eea8 8a80 	vfma.f32	s16, s17, s0
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8016720:	4638      	mov	r0, r7
 8016722:	f00e fa51 	bl	8024bc8 <tSimplePoly_getNumVoices>
 8016726:	42a0      	cmp	r0, r4
                sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
 8016728:	eb06 0084 	add.w	r0, r6, r4, lsl #2
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 801672c:	f104 0401 	add.w	r4, r4, #1
 8016730:	dcf0      	bgt.n	8016714 <SFXAutotuneTick+0x68>
            sample *= tExpSmooth_tick(&comp);
 8016732:	480e      	ldr	r0, [pc, #56]	; (801676c <SFXAutotuneTick+0xc0>)
 8016734:	f00b ff2e 	bl	8022594 <tExpSmooth_tick>
 8016738:	ee28 0a00 	vmul.f32	s0, s16, s0
            input[0] = sample;
 801673c:	ed88 0a00 	vstr	s0, [r8]
            input[1] = sample;
 8016740:	ed88 0a01 	vstr	s0, [r8, #4]
        }
 8016744:	ecbd 8b02 	vpop	{d8}
 8016748:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801674c:	20002cb8 	.word	0x20002cb8
 8016750:	3ef0a3d7 	.word	0x3ef0a3d7
 8016754:	200187dc 	.word	0x200187dc
 8016758:	200033e0 	.word	0x200033e0
 801675c:	200033e4 	.word	0x200033e4
 8016760:	200174c8 	.word	0x200174c8
 8016764:	00000000 	.word	0x00000000
 8016768:	20017968 	.word	0x20017968
 801676c:	20017204 	.word	0x20017204

08016770 <SFXAutotuneFree>:
            tAutotune_free(&autotunePoly);
 8016770:	4801      	ldr	r0, [pc, #4]	; (8016778 <SFXAutotuneFree+0x8>)
 8016772:	f00a beef 	b.w	8021554 <tAutotune_free>
 8016776:	bf00      	nop
 8016778:	200033e0 	.word	0x200033e0

0801677c <SFXSamplerBPAlloc>:
        {
 801677c:	b538      	push	{r3, r4, r5, lr}
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
 801677e:	4b1c      	ldr	r3, [pc, #112]	; (80167f0 <SFXSamplerBPAlloc+0x74>)
 8016780:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 80167f4 <SFXSamplerBPAlloc+0x78>
 8016784:	4c1c      	ldr	r4, [pc, #112]	; (80167f8 <SFXSamplerBPAlloc+0x7c>)
 8016786:	4a1d      	ldr	r2, [pc, #116]	; (80167fc <SFXSamplerBPAlloc+0x80>)
 8016788:	4620      	mov	r0, r4
            tSampler_init(&sampler, &buff);
 801678a:	4d1d      	ldr	r5, [pc, #116]	; (8016800 <SFXSamplerBPAlloc+0x84>)
        {
 801678c:	ed2d 8b02 	vpush	{d8}
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
 8016790:	edd3 7a00 	vldr	s15, [r3]
            tExpSmooth_init(&startSmooth, 0.0f, 0.01f);
 8016794:	eddf 8a1b 	vldr	s17, [pc, #108]	; 8016804 <SFXSamplerBPAlloc+0x88>
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
 8016798:	ee67 7a87 	vmul.f32	s15, s15, s14
            tExpSmooth_init(&startSmooth, 0.0f, 0.01f);
 801679c:	ed9f 8a1a 	vldr	s16, [pc, #104]	; 8016808 <SFXSamplerBPAlloc+0x8c>
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
 80167a0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80167a4:	ee17 1a90 	vmov	r1, s15
 80167a8:	f00f fd74 	bl	8026294 <tBuffer_initToPool>
            tBuffer_setRecordMode(&buff, RecordOneShot);
 80167ac:	4620      	mov	r0, r4
 80167ae:	2100      	movs	r1, #0
 80167b0:	f00f fdd6 	bl	8026360 <tBuffer_setRecordMode>
            tSampler_init(&sampler, &buff);
 80167b4:	4621      	mov	r1, r4
 80167b6:	4628      	mov	r0, r5
 80167b8:	f00f fde2 	bl	8026380 <tSampler_init>
            tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
 80167bc:	4b13      	ldr	r3, [pc, #76]	; (801680c <SFXSamplerBPAlloc+0x90>)
 80167be:	4628      	mov	r0, r5
 80167c0:	6819      	ldr	r1, [r3, #0]
 80167c2:	3101      	adds	r1, #1
 80167c4:	b2c9      	uxtb	r1, r1
 80167c6:	f00f fe37 	bl	8026438 <tSampler_setMode>
            tExpSmooth_init(&startSmooth, 0.0f, 0.01f);
 80167ca:	eef0 0a68 	vmov.f32	s1, s17
 80167ce:	eeb0 0a48 	vmov.f32	s0, s16
 80167d2:	480f      	ldr	r0, [pc, #60]	; (8016810 <SFXSamplerBPAlloc+0x94>)
 80167d4:	f00b fe6e 	bl	80224b4 <tExpSmooth_init>
            tExpSmooth_init(&lengthSmooth, 0.0f, 0.01f);
 80167d8:	eef0 0a68 	vmov.f32	s1, s17
 80167dc:	eeb0 0a48 	vmov.f32	s0, s16
 80167e0:	480c      	ldr	r0, [pc, #48]	; (8016814 <SFXSamplerBPAlloc+0x98>)
        }
 80167e2:	ecbd 8b02 	vpop	{d8}
 80167e6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            tExpSmooth_init(&lengthSmooth, 0.0f, 0.01f);
 80167ea:	f00b be63 	b.w	80224b4 <tExpSmooth_init>
 80167ee:	bf00      	nop
 80167f0:	200194e8 	.word	0x200194e8
 80167f4:	432c0000 	.word	0x432c0000
 80167f8:	20003598 	.word	0x20003598
 80167fc:	200174b8 	.word	0x200174b8
 8016800:	200171fc 	.word	0x200171fc
 8016804:	3c23d70a 	.word	0x3c23d70a
 8016808:	00000000 	.word	0x00000000
 801680c:	20000534 	.word	0x20000534
 8016810:	200177c0 	.word	0x200177c0
 8016814:	20016fcc 	.word	0x20016fcc

08016818 <SFXSamplerBPFrame>:
 8016818:	4770      	bx	lr
 801681a:	bf00      	nop

0801681c <SFXSamplerBPTick>:
        {
 801681c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            if (buttonActionsSFX[ButtonC][ActionPress])
 8016820:	4e91      	ldr	r6, [pc, #580]	; (8016a68 <SFXSamplerBPTick+0x24c>)
        {
 8016822:	4607      	mov	r7, r0
            int recordPosition = tBuffer_getRecordPosition(&buff);
 8016824:	4891      	ldr	r0, [pc, #580]	; (8016a6c <SFXSamplerBPTick+0x250>)
        {
 8016826:	ed2d 8b02 	vpush	{d8}
            int recordPosition = tBuffer_getRecordPosition(&buff);
 801682a:	f00f fd91 	bl	8026350 <tBuffer_getRecordPosition>
            if (buttonActionsSFX[ButtonC][ActionPress])
 801682e:	7f33      	ldrb	r3, [r6, #28]
            int recordPosition = tBuffer_getRecordPosition(&buff);
 8016830:	ee08 0a10 	vmov	s16, r0
            if (buttonActionsSFX[ButtonC][ActionPress])
 8016834:	2b00      	cmp	r3, #0
 8016836:	f040 80a8 	bne.w	801698a <SFXSamplerBPTick+0x16e>
            if (buttonActionsSFX[ButtonB][ActionPress])
 801683a:	7e33      	ldrb	r3, [r6, #24]
 801683c:	f8df 825c 	ldr.w	r8, [pc, #604]	; 8016a9c <SFXSamplerBPTick+0x280>
 8016840:	4c8b      	ldr	r4, [pc, #556]	; (8016a70 <SFXSamplerBPTick+0x254>)
 8016842:	4d8c      	ldr	r5, [pc, #560]	; (8016a74 <SFXSamplerBPTick+0x258>)
 8016844:	2b00      	cmp	r3, #0
 8016846:	f040 80b3 	bne.w	80169b0 <SFXSamplerBPTick+0x194>
            if (buttonActionsSFX[ButtonA][ActionPress])
 801684a:	7d33      	ldrb	r3, [r6, #20]
 801684c:	2b00      	cmp	r3, #0
 801684e:	f040 80c6 	bne.w	80169de <SFXSamplerBPTick+0x1c2>
            if (buttonActionsSFX[ButtonA][ActionRelease])
 8016852:	7d73      	ldrb	r3, [r6, #21]
 8016854:	2b00      	cmp	r3, #0
 8016856:	f040 80d1 	bne.w	80169fc <SFXSamplerBPTick+0x1e0>
            sampleLength = (float)recordPosition * leaf.invSampleRate;
 801685a:	4b87      	ldr	r3, [pc, #540]	; (8016a78 <SFXSamplerBPTick+0x25c>)
 801685c:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8016860:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
            displayValues[0] = knobs[0] * sampleLength;
 8016864:	ed94 7a7d 	vldr	s14, [r4, #500]	; 0x1f4
            sampleLength = (float)recordPosition * leaf.invSampleRate;
 8016868:	edd3 7a01 	vldr	s15, [r3, #4]
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 801686c:	edd4 0a7e 	vldr	s1, [r4, #504]	; 0x1f8
            sampleLength = (float)recordPosition * leaf.invSampleRate;
 8016870:	ee68 7a27 	vmul.f32	s15, s16, s15
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8016874:	ed9f 0a81 	vldr	s0, [pc, #516]	; 8016a7c <SFXSamplerBPTick+0x260>
 8016878:	ee38 1ac7 	vsub.f32	s2, s17, s14
            displayValues[0] = knobs[0] * sampleLength;
 801687c:	ee27 7a87 	vmul.f32	s14, s15, s14
            sampleLength = (float)recordPosition * leaf.invSampleRate;
 8016880:	edc8 7a00 	vstr	s15, [r8]
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8016884:	ee21 1a27 	vmul.f32	s2, s2, s15
 8016888:	ee67 0aa0 	vmul.f32	s1, s15, s1
            displayValues[0] = knobs[0] * sampleLength;
 801688c:	ed85 7a00 	vstr	s14, [r5]
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8016890:	f00d fb10 	bl	8023eb4 <LEAF_clip>
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8016894:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8016898:	edd4 6a7f 	vldr	s13, [r4, #508]	; 0x1fc
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 801689c:	ed94 7a80 	vldr	s14, [r4, #512]	; 0x200
 80168a0:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 80168a4:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 80168a8:	ed85 0a01 	vstr	s0, [r5, #4]
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 80168ac:	ee76 6ae7 	vsub.f32	s13, s13, s15
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 80168b0:	ee77 7a67 	vsub.f32	s15, s14, s15
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 80168b4:	ee66 6aa5 	vmul.f32	s13, s13, s11
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 80168b8:	ee67 7a86 	vmul.f32	s15, s15, s12
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 80168bc:	edc5 6a02 	vstr	s13, [r5, #8]
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 80168c0:	fef8 7a67 	vrinta.f32	s15, s15
            if (rate < 0.0f)
 80168c4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80168c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80168cc:	f100 80c0 	bmi.w	8016a50 <SFXSamplerBPTick+0x234>
                rate += 1.0f;
 80168d0:	ee77 7aa8 	vadd.f32	s15, s15, s17
            displayValues[4] = knobs[4] * 4000.0f;
 80168d4:	ed9f 6a6a 	vldr	s12, [pc, #424]	; 8016a80 <SFXSamplerBPTick+0x264>
            samplerRate = displayValues[3] * displayValues[2];
 80168d8:	ee66 6aa7 	vmul.f32	s13, s13, s15
            displayValues[4] = knobs[4] * 4000.0f;
 80168dc:	ed94 7a81 	vldr	s14, [r4, #516]	; 0x204
            tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
 80168e0:	ed94 0a7d 	vldr	s0, [r4, #500]	; 0x1f4
            displayValues[4] = knobs[4] * 4000.0f;
 80168e4:	ee27 7a06 	vmul.f32	s14, s14, s12
            samplerRate = displayValues[3] * displayValues[2];
 80168e8:	4e66      	ldr	r6, [pc, #408]	; (8016a84 <SFXSamplerBPTick+0x268>)
            tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
 80168ea:	ee28 0a00 	vmul.f32	s0, s16, s0
 80168ee:	4866      	ldr	r0, [pc, #408]	; (8016a88 <SFXSamplerBPTick+0x26c>)
            samplerRate = displayValues[3] * displayValues[2];
 80168f0:	edc6 6a00 	vstr	s13, [r6]
            displayValues[4] = knobs[4] * 4000.0f;
 80168f4:	ed85 7a04 	vstr	s14, [r5, #16]
            displayValues[3] = rate;
 80168f8:	edc5 7a03 	vstr	s15, [r5, #12]
            tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
 80168fc:	f00b fe40 	bl	8022580 <tExpSmooth_setDest>
            tExpSmooth_setDest(&lengthSmooth, knobs[1] * recordPosition);
 8016900:	ed94 0a7e 	vldr	s0, [r4, #504]	; 0x1f8
 8016904:	4861      	ldr	r0, [pc, #388]	; (8016a8c <SFXSamplerBPTick+0x270>)
 8016906:	ee28 0a00 	vmul.f32	s0, s16, s0
            samplePlayStart = tExpSmooth_tick(&startSmooth);
 801690a:	f8df 9194 	ldr.w	r9, [pc, #404]	; 8016aa0 <SFXSamplerBPTick+0x284>
            tExpSmooth_setDest(&lengthSmooth, knobs[1] * recordPosition);
 801690e:	f00b fe37 	bl	8022580 <tExpSmooth_setDest>
            samplePlayStart = tExpSmooth_tick(&startSmooth);
 8016912:	485d      	ldr	r0, [pc, #372]	; (8016a88 <SFXSamplerBPTick+0x26c>)
 8016914:	f00b fe3e 	bl	8022594 <tExpSmooth_tick>
 8016918:	eebd 0ac0 	vcvt.s32.f32	s0, s0
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 801691c:	485b      	ldr	r0, [pc, #364]	; (8016a8c <SFXSamplerBPTick+0x270>)
 801691e:	f8df 8184 	ldr.w	r8, [pc, #388]	; 8016aa4 <SFXSamplerBPTick+0x288>
            samplePlayStart = tExpSmooth_tick(&startSmooth);
 8016922:	ed89 0a00 	vstr	s0, [r9]
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 8016926:	f00b fe35 	bl	8022594 <tExpSmooth_tick>
            crossfadeLength = displayValues[4];
 801692a:	edd5 7a04 	vldr	s15, [r5, #16]
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 801692e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
            crossfadeLength = displayValues[4];
 8016932:	4c57      	ldr	r4, [pc, #348]	; (8016a90 <SFXSamplerBPTick+0x274>)
 8016934:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            tSampler_setStart(&sampler, samplePlayStart);
 8016938:	f8d9 1000 	ldr.w	r1, [r9]
 801693c:	4855      	ldr	r0, [pc, #340]	; (8016a94 <SFXSamplerBPTick+0x278>)
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 801693e:	ed88 0a00 	vstr	s0, [r8]
            crossfadeLength = displayValues[4];
 8016942:	edc4 7a00 	vstr	s15, [r4]
            tSampler_setStart(&sampler, samplePlayStart);
 8016946:	f00f fded 	bl	8026524 <tSampler_setStart>
            tSampler_setLength(&sampler, samplePlayLength);
 801694a:	f8d8 1000 	ldr.w	r1, [r8]
 801694e:	4851      	ldr	r0, [pc, #324]	; (8016a94 <SFXSamplerBPTick+0x278>)
 8016950:	f010 fa0c 	bl	8026d6c <tSampler_setLength>
            tSampler_setRate(&sampler, samplerRate);
 8016954:	ed96 0a00 	vldr	s0, [r6]
 8016958:	484e      	ldr	r0, [pc, #312]	; (8016a94 <SFXSamplerBPTick+0x278>)
 801695a:	f010 faa1 	bl	8026ea0 <tSampler_setRate>
            tSampler_setCrossfadeLength(&sampler, crossfadeLength);
 801695e:	6821      	ldr	r1, [r4, #0]
 8016960:	484c      	ldr	r0, [pc, #304]	; (8016a94 <SFXSamplerBPTick+0x278>)
 8016962:	f00f fd6d 	bl	8026440 <tSampler_setCrossfadeLength>
            tBuffer_tick(&buff, input[1]);
 8016966:	ed97 0a01 	vldr	s0, [r7, #4]
 801696a:	4840      	ldr	r0, [pc, #256]	; (8016a6c <SFXSamplerBPTick+0x250>)
 801696c:	f00f fcb6 	bl	80262dc <tBuffer_tick>
            sample = tanhf(tSampler_tick(&sampler));
 8016970:	4848      	ldr	r0, [pc, #288]	; (8016a94 <SFXSamplerBPTick+0x278>)
 8016972:	f00f ff03 	bl	802677c <tSampler_tick>
 8016976:	f010 ff69 	bl	802784c <tanhf>
            input[0] = sample;
 801697a:	ed87 0a00 	vstr	s0, [r7]
            input[1] = sample;
 801697e:	ed87 0a01 	vstr	s0, [r7, #4]
        }
 8016982:	ecbd 8b02 	vpop	{d8}
 8016986:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (samplePlaying)
 801698a:	4b43      	ldr	r3, [pc, #268]	; (8016a98 <SFXSamplerBPTick+0x27c>)
 801698c:	681a      	ldr	r2, [r3, #0]
 801698e:	2a00      	cmp	r2, #0
 8016990:	d140      	bne.n	8016a14 <SFXSamplerBPTick+0x1f8>
                    samplePlaying = 1;
 8016992:	2201      	movs	r2, #1
                    tSampler_play(&sampler);
 8016994:	483f      	ldr	r0, [pc, #252]	; (8016a94 <SFXSamplerBPTick+0x278>)
 8016996:	f8df 8104 	ldr.w	r8, [pc, #260]	; 8016a9c <SFXSamplerBPTick+0x280>
 801699a:	4c35      	ldr	r4, [pc, #212]	; (8016a70 <SFXSamplerBPTick+0x254>)
                    samplePlaying = 1;
 801699c:	601a      	str	r2, [r3, #0]
 801699e:	4d35      	ldr	r5, [pc, #212]	; (8016a74 <SFXSamplerBPTick+0x258>)
                    tSampler_play(&sampler);
 80169a0:	f00f fd64 	bl	802646c <tSampler_play>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 80169a4:	2300      	movs	r3, #0
 80169a6:	7733      	strb	r3, [r6, #28]
            if (buttonActionsSFX[ButtonB][ActionPress])
 80169a8:	7e33      	ldrb	r3, [r6, #24]
 80169aa:	2b00      	cmp	r3, #0
 80169ac:	f43f af4d 	beq.w	801684a <SFXSamplerBPTick+0x2e>
                bpMode = !bpMode;
 80169b0:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 8016aa8 <SFXSamplerBPTick+0x28c>
                tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
 80169b4:	4837      	ldr	r0, [pc, #220]	; (8016a94 <SFXSamplerBPTick+0x278>)
                bpMode = !bpMode;
 80169b6:	f8d9 3000 	ldr.w	r3, [r9]
 80169ba:	fab3 f383 	clz	r3, r3
 80169be:	095b      	lsrs	r3, r3, #5
                tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
 80169c0:	1c59      	adds	r1, r3, #1
                bpMode = !bpMode;
 80169c2:	f8c9 3000 	str.w	r3, [r9]
                tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
 80169c6:	f00f fd37 	bl	8026438 <tSampler_setMode>
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 80169ca:	2300      	movs	r3, #0
                setLED_B(bpMode);
 80169cc:	f8d9 0000 	ldr.w	r0, [r9]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 80169d0:	7633      	strb	r3, [r6, #24]
                setLED_B(bpMode);
 80169d2:	f7fc ffc9 	bl	8013968 <setLED_B>
            if (buttonActionsSFX[ButtonA][ActionPress])
 80169d6:	7d33      	ldrb	r3, [r6, #20]
 80169d8:	2b00      	cmp	r3, #0
 80169da:	f43f af3a 	beq.w	8016852 <SFXSamplerBPTick+0x36>
                tSampler_stop(&sampler);
 80169de:	482d      	ldr	r0, [pc, #180]	; (8016a94 <SFXSamplerBPTick+0x278>)
 80169e0:	f00f fd94 	bl	802650c <tSampler_stop>
                tBuffer_record(&buff);
 80169e4:	4821      	ldr	r0, [pc, #132]	; (8016a6c <SFXSamplerBPTick+0x250>)
 80169e6:	f00f fca9 	bl	802633c <tBuffer_record>
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 80169ea:	2300      	movs	r3, #0
                setLED_A(1);
 80169ec:	2001      	movs	r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 80169ee:	7533      	strb	r3, [r6, #20]
                setLED_A(1);
 80169f0:	f7fc ffac 	bl	801394c <setLED_A>
            if (buttonActionsSFX[ButtonA][ActionRelease])
 80169f4:	7d73      	ldrb	r3, [r6, #21]
 80169f6:	2b00      	cmp	r3, #0
 80169f8:	f43f af2f 	beq.w	801685a <SFXSamplerBPTick+0x3e>
                tBuffer_stop(&buff);
 80169fc:	481b      	ldr	r0, [pc, #108]	; (8016a6c <SFXSamplerBPTick+0x250>)
 80169fe:	f00f fca3 	bl	8026348 <tBuffer_stop>
                if (samplePlaying) tSampler_play(&sampler);
 8016a02:	4b25      	ldr	r3, [pc, #148]	; (8016a98 <SFXSamplerBPTick+0x27c>)
 8016a04:	681b      	ldr	r3, [r3, #0]
 8016a06:	bb53      	cbnz	r3, 8016a5e <SFXSamplerBPTick+0x242>
                buttonActionsSFX[ButtonA][ActionRelease] = 0;
 8016a08:	2300      	movs	r3, #0
                setLED_A(0);
 8016a0a:	4618      	mov	r0, r3
                buttonActionsSFX[ButtonA][ActionRelease] = 0;
 8016a0c:	7573      	strb	r3, [r6, #21]
                setLED_A(0);
 8016a0e:	f7fc ff9d 	bl	801394c <setLED_A>
 8016a12:	e722      	b.n	801685a <SFXSamplerBPTick+0x3e>
                    samplePlaying = 0;
 8016a14:	2200      	movs	r2, #0
                    tSampler_stop(&sampler);
 8016a16:	481f      	ldr	r0, [pc, #124]	; (8016a94 <SFXSamplerBPTick+0x278>)
                    displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8016a18:	4c15      	ldr	r4, [pc, #84]	; (8016a70 <SFXSamplerBPTick+0x254>)
                    samplePlaying = 0;
 8016a1a:	601a      	str	r2, [r3, #0]
                    tSampler_stop(&sampler);
 8016a1c:	f00f fd76 	bl	802650c <tSampler_stop>
                    displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8016a20:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8016a24:	ed94 1a7d 	vldr	s2, [r4, #500]	; 0x1f4
 8016a28:	f8df 8070 	ldr.w	r8, [pc, #112]	; 8016a9c <SFXSamplerBPTick+0x280>
 8016a2c:	edd4 0a7e 	vldr	s1, [r4, #504]	; 0x1f8
 8016a30:	ee77 7ac1 	vsub.f32	s15, s15, s2
 8016a34:	ed98 1a00 	vldr	s2, [r8]
 8016a38:	4d0e      	ldr	r5, [pc, #56]	; (8016a74 <SFXSamplerBPTick+0x258>)
 8016a3a:	ee61 0a20 	vmul.f32	s1, s2, s1
 8016a3e:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 8016a7c <SFXSamplerBPTick+0x260>
 8016a42:	ee27 1a81 	vmul.f32	s2, s15, s2
 8016a46:	f00d fa35 	bl	8023eb4 <LEAF_clip>
 8016a4a:	ed85 0a01 	vstr	s0, [r5, #4]
 8016a4e:	e7a9      	b.n	80169a4 <SFXSamplerBPTick+0x188>
                (rate = 1.0f / fabsf(rate-1.0f));
 8016a50:	ee77 7ae8 	vsub.f32	s15, s15, s17
 8016a54:	eeb0 7ae7 	vabs.f32	s14, s15
 8016a58:	eec8 7a87 	vdiv.f32	s15, s17, s14
 8016a5c:	e73a      	b.n	80168d4 <SFXSamplerBPTick+0xb8>
                if (samplePlaying) tSampler_play(&sampler);
 8016a5e:	480d      	ldr	r0, [pc, #52]	; (8016a94 <SFXSamplerBPTick+0x278>)
 8016a60:	f00f fd04 	bl	802646c <tSampler_play>
 8016a64:	e7d0      	b.n	8016a08 <SFXSamplerBPTick+0x1ec>
 8016a66:	bf00      	nop
 8016a68:	2001872c 	.word	0x2001872c
 8016a6c:	20003598 	.word	0x20003598
 8016a70:	20002cb8 	.word	0x20002cb8
 8016a74:	200187dc 	.word	0x200187dc
 8016a78:	200194e8 	.word	0x200194e8
 8016a7c:	00000000 	.word	0x00000000
 8016a80:	457a0000 	.word	0x457a0000
 8016a84:	200002b4 	.word	0x200002b4
 8016a88:	200177c0 	.word	0x200177c0
 8016a8c:	20016fcc 	.word	0x20016fcc
 8016a90:	20000574 	.word	0x20000574
 8016a94:	200171fc 	.word	0x200171fc
 8016a98:	200002ac 	.word	0x200002ac
 8016a9c:	2000060c 	.word	0x2000060c
 8016aa0:	20000614 	.word	0x20000614
 8016aa4:	20000610 	.word	0x20000610
 8016aa8:	20000534 	.word	0x20000534

08016aac <SFXSamplerBPFree>:
        {
 8016aac:	b508      	push	{r3, lr}
            tBuffer_free(&buff);
 8016aae:	4807      	ldr	r0, [pc, #28]	; (8016acc <SFXSamplerBPFree+0x20>)
 8016ab0:	f00f fc08 	bl	80262c4 <tBuffer_free>
            tSampler_free(&sampler);
 8016ab4:	4806      	ldr	r0, [pc, #24]	; (8016ad0 <SFXSamplerBPFree+0x24>)
 8016ab6:	f00f fcb3 	bl	8026420 <tSampler_free>
            tExpSmooth_free(&startSmooth);
 8016aba:	4806      	ldr	r0, [pc, #24]	; (8016ad4 <SFXSamplerBPFree+0x28>)
 8016abc:	f00b fd4a 	bl	8022554 <tExpSmooth_free>
            tExpSmooth_free(&lengthSmooth);
 8016ac0:	4805      	ldr	r0, [pc, #20]	; (8016ad8 <SFXSamplerBPFree+0x2c>)
        }
 8016ac2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tExpSmooth_free(&lengthSmooth);
 8016ac6:	f00b bd45 	b.w	8022554 <tExpSmooth_free>
 8016aca:	bf00      	nop
 8016acc:	20003598 	.word	0x20003598
 8016ad0:	200171fc 	.word	0x200171fc
 8016ad4:	200177c0 	.word	0x200177c0
 8016ad8:	20016fcc 	.word	0x20016fcc

08016adc <SFXSamplerKAlloc>:
            leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
 8016adc:	2200      	movs	r2, #0
            currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
 8016ade:	4937      	ldr	r1, [pc, #220]	; (8016bbc <SFXSamplerKAlloc+0xe0>)
 8016ae0:	2018      	movs	r0, #24
        {
 8016ae2:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
 8016ae6:	f8df b11c 	ldr.w	fp, [pc, #284]	; 8016c04 <SFXSamplerKAlloc+0x128>
            currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
 8016aea:	4614      	mov	r4, r2
 8016aec:	f8df a118 	ldr.w	sl, [pc, #280]	; 8016c08 <SFXSamplerKAlloc+0x12c>
 8016af0:	f8df 9118 	ldr.w	r9, [pc, #280]	; 8016c0c <SFXSamplerKAlloc+0x130>
 8016af4:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8016c10 <SFXSamplerKAlloc+0x134>
 8016af8:	4f31      	ldr	r7, [pc, #196]	; (8016bc0 <SFXSamplerKAlloc+0xe4>)
            leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
 8016afa:	f8cb 2014 	str.w	r2, [fp, #20]
        {
 8016afe:	ed2d 8b04 	vpush	{d8-d9}
                tExpSmooth_init(&kSamplerGains[i], 0.0f, 0.04f);
 8016b02:	ed9f 9a30 	vldr	s18, [pc, #192]	; 8016bc4 <SFXSamplerKAlloc+0xe8>
                samplePlayStarts[i] = 0;
 8016b06:	ed9f 8a30 	vldr	s16, [pc, #192]	; 8016bc8 <SFXSamplerKAlloc+0xec>
                crossfadeLengths[i] = 1000;
 8016b0a:	eddf 8a30 	vldr	s17, [pc, #192]	; 8016bcc <SFXSamplerKAlloc+0xf0>
            currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
 8016b0e:	6008      	str	r0, [r1, #0]
                tBuffer_initToPool(&keyBuff[i], leaf.sampleRate * 3.5f, &largePool);
 8016b10:	eef0 7a0c 	vmov.f32	s15, #12	; 0x40600000  3.5
 8016b14:	ed9b 7a00 	vldr	s14, [fp]
 8016b18:	4b2d      	ldr	r3, [pc, #180]	; (8016bd0 <SFXSamplerKAlloc+0xf4>)
 8016b1a:	4a2e      	ldr	r2, [pc, #184]	; (8016bd4 <SFXSamplerKAlloc+0xf8>)
 8016b1c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8016b20:	191d      	adds	r5, r3, r4
 8016b22:	4b2d      	ldr	r3, [pc, #180]	; (8016bd8 <SFXSamplerKAlloc+0xfc>)
 8016b24:	4628      	mov	r0, r5
 8016b26:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8016b2a:	191e      	adds	r6, r3, r4
 8016b2c:	ee17 1a90 	vmov	r1, s15
 8016b30:	f00f fbb0 	bl	8026294 <tBuffer_initToPool>
                tBuffer_setRecordMode(&keyBuff[i], RecordOneShot);
 8016b34:	4628      	mov	r0, r5
 8016b36:	2100      	movs	r1, #0
 8016b38:	f00f fc12 	bl	8026360 <tBuffer_setRecordMode>
                tSampler_init(&keySampler[i], &keyBuff[i]);
 8016b3c:	4629      	mov	r1, r5
 8016b3e:	4630      	mov	r0, r6
 8016b40:	f00f fc1e 	bl	8026380 <tSampler_init>
                tSampler_setMode(&keySampler[i], PlayLoop);
 8016b44:	2101      	movs	r1, #1
 8016b46:	4630      	mov	r0, r6
 8016b48:	f00f fc76 	bl	8026438 <tSampler_setMode>
                tExpSmooth_init(&kSamplerGains[i], 0.0f, 0.04f);
 8016b4c:	4a23      	ldr	r2, [pc, #140]	; (8016bdc <SFXSamplerKAlloc+0x100>)
                detectedAttackPos[i] = 0;
 8016b4e:	2300      	movs	r3, #0
                tExpSmooth_init(&kSamplerGains[i], 0.0f, 0.04f);
 8016b50:	eef0 0a49 	vmov.f32	s1, s18
 8016b54:	1910      	adds	r0, r2, r4
                detectedAttackPos[i] = 0;
 8016b56:	4a22      	ldr	r2, [pc, #136]	; (8016be0 <SFXSamplerKAlloc+0x104>)
                tExpSmooth_init(&kSamplerGains[i], 0.0f, 0.04f);
 8016b58:	ed9f 0a1b 	vldr	s0, [pc, #108]	; 8016bc8 <SFXSamplerKAlloc+0xec>
                detectedAttackPos[i] = 0;
 8016b5c:	5113      	str	r3, [r2, r4]
                samplerKeyHeld[i] = 0;
 8016b5e:	4a21      	ldr	r2, [pc, #132]	; (8016be4 <SFXSamplerKAlloc+0x108>)
                samplePlayStarts[i] = 0;
 8016b60:	ecaa 8a01 	vstmia	sl!, {s16}
                samplerKeyHeld[i] = 0;
 8016b64:	5113      	str	r3, [r2, r4]
                samplePlayLengths[i] = 0;
 8016b66:	eca9 8a01 	vstmia	r9!, {s16}
                crossfadeLengths[i] = 1000;
 8016b6a:	ece8 8a01 	vstmia	r8!, {s17}
                tExpSmooth_init(&kSamplerGains[i], 0.0f, 0.04f);
 8016b6e:	f00b fca1 	bl	80224b4 <tExpSmooth_init>
                loopOns[i] = 1;
 8016b72:	2101      	movs	r1, #1
                sampleRatesMult[i] = 1.0f;
 8016b74:	4a1c      	ldr	r2, [pc, #112]	; (8016be8 <SFXSamplerKAlloc+0x10c>)
                loopOns[i] = 1;
 8016b76:	481d      	ldr	r0, [pc, #116]	; (8016bec <SFXSamplerKAlloc+0x110>)
                sampleRates[i] = 1.0f;
 8016b78:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
                sampleRatesMult[i] = 1.0f;
 8016b7c:	4422      	add	r2, r4
                loopOns[i] = 1;
 8016b7e:	5101      	str	r1, [r0, r4]
 8016b80:	3404      	adds	r4, #4
                sampleRates[i] = 1.0f;
 8016b82:	f847 3b04 	str.w	r3, [r7], #4
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 8016b86:	2cc4      	cmp	r4, #196	; 0xc4
                sampleRatesMult[i] = 1.0f;
 8016b88:	6013      	str	r3, [r2, #0]
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 8016b8a:	d1c1      	bne.n	8016b10 <SFXSamplerKAlloc+0x34>
            tSimplePoly_setNumVoices(&poly, NUM_SAMPLER_VOICES);
 8016b8c:	2106      	movs	r1, #6
 8016b8e:	4818      	ldr	r0, [pc, #96]	; (8016bf0 <SFXSamplerKAlloc+0x114>)
 8016b90:	f00e f812 	bl	8024bb8 <tSimplePoly_setNumVoices>
            setLED_B(controlAllKeys);
 8016b94:	4917      	ldr	r1, [pc, #92]	; (8016bf4 <SFXSamplerKAlloc+0x118>)
                waitingForDeactivation[i] = -1;
 8016b96:	4b18      	ldr	r3, [pc, #96]	; (8016bf8 <SFXSamplerKAlloc+0x11c>)
 8016b98:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
            setLED_B(controlAllKeys);
 8016b9c:	6808      	ldr	r0, [r1, #0]
                waitingForDeactivation[i] = -1;
 8016b9e:	e9c3 2200 	strd	r2, r2, [r3]
 8016ba2:	e9c3 2202 	strd	r2, r2, [r3, #8]
 8016ba6:	e9c3 2204 	strd	r2, r2, [r3, #16]
            setLED_B(controlAllKeys);
 8016baa:	f7fc fedd 	bl	8013968 <setLED_B>
            samp_thresh = 0.0002f;
 8016bae:	4b13      	ldr	r3, [pc, #76]	; (8016bfc <SFXSamplerKAlloc+0x120>)
 8016bb0:	4a13      	ldr	r2, [pc, #76]	; (8016c00 <SFXSamplerKAlloc+0x124>)
 8016bb2:	601a      	str	r2, [r3, #0]
        }
 8016bb4:	ecbd 8b04 	vpop	{d8-d9}
 8016bb8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016bbc:	20000224 	.word	0x20000224
 8016bc0:	20002910 	.word	0x20002910
 8016bc4:	3d23d70a 	.word	0x3d23d70a
 8016bc8:	00000000 	.word	0x00000000
 8016bcc:	447a0000 	.word	0x447a0000
 8016bd0:	200181b0 	.word	0x200181b0
 8016bd4:	200174b8 	.word	0x200174b8
 8016bd8:	200034d4 	.word	0x200034d4
 8016bdc:	20002634 	.word	0x20002634
 8016be0:	200183b8 	.word	0x200183b8
 8016be4:	200176e4 	.word	0x200176e4
 8016be8:	2001788c 	.word	0x2001788c
 8016bec:	20002bf4 	.word	0x20002bf4
 8016bf0:	200174c8 	.word	0x200174c8
 8016bf4:	20000570 	.word	0x20000570
 8016bf8:	200175c0 	.word	0x200175c0
 8016bfc:	20000604 	.word	0x20000604
 8016c00:	3951b717 	.word	0x3951b717
 8016c04:	200194e8 	.word	0x200194e8
 8016c08:	200172ec 	.word	0x200172ec
 8016c0c:	20002828 	.word	0x20002828
 8016c10:	200177c4 	.word	0x200177c4

08016c14 <SFXSamplerKFrame>:
            int currentSamplerKey = currentSamplerKeyGlobal;
 8016c14:	4aa4      	ldr	r2, [pc, #656]	; (8016ea8 <SFXSamplerKFrame+0x294>)
            if (samplerKeyHeld[currentSamplerKey])
 8016c16:	4ba5      	ldr	r3, [pc, #660]	; (8016eac <SFXSamplerKFrame+0x298>)
        {
 8016c18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016c1c:	ed2d 8b04 	vpush	{d8-d9}
            int currentSamplerKey = currentSamplerKeyGlobal;
 8016c20:	6814      	ldr	r4, [r2, #0]
        {
 8016c22:	b083      	sub	sp, #12
            if (samplerKeyHeld[currentSamplerKey])
 8016c24:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8016c28:	2b00      	cmp	r3, #0
 8016c2a:	f040 80fe 	bne.w	8016e2a <SFXSamplerKFrame+0x216>
            if (buttonActionsSFX[ButtonA][ActionPress])
 8016c2e:	4da0      	ldr	r5, [pc, #640]	; (8016eb0 <SFXSamplerKFrame+0x29c>)
 8016c30:	7d2b      	ldrb	r3, [r5, #20]
 8016c32:	b163      	cbz	r3, 8016c4e <SFXSamplerKFrame+0x3a>
                tBuffer_setRecordPosition(&keyBuff[currentSamplerKey],0);
 8016c34:	489f      	ldr	r0, [pc, #636]	; (8016eb4 <SFXSamplerKFrame+0x2a0>)
 8016c36:	2100      	movs	r1, #0
 8016c38:	eb00 0684 	add.w	r6, r0, r4, lsl #2
 8016c3c:	4630      	mov	r0, r6
 8016c3e:	f00f fb8b 	bl	8026358 <tBuffer_setRecordPosition>
                tBuffer_setRecordedLength(&keyBuff[currentSamplerKey],0);
 8016c42:	4630      	mov	r0, r6
 8016c44:	2100      	movs	r1, #0
 8016c46:	f00f fb93 	bl	8026370 <tBuffer_setRecordedLength>
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8016c4a:	2300      	movs	r3, #0
 8016c4c:	752b      	strb	r3, [r5, #20]
            if (buttonActionsSFX[ButtonB][ActionPress])
 8016c4e:	7e2b      	ldrb	r3, [r5, #24]
 8016c50:	b153      	cbz	r3, 8016c68 <SFXSamplerKFrame+0x54>
                controlAllKeys = !controlAllKeys;
 8016c52:	4a99      	ldr	r2, [pc, #612]	; (8016eb8 <SFXSamplerKFrame+0x2a4>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8016c54:	2100      	movs	r1, #0
                controlAllKeys = !controlAllKeys;
 8016c56:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8016c58:	7629      	strb	r1, [r5, #24]
                controlAllKeys = !controlAllKeys;
 8016c5a:	fab3 f383 	clz	r3, r3
 8016c5e:	095b      	lsrs	r3, r3, #5
                setLED_B(controlAllKeys);
 8016c60:	4618      	mov	r0, r3
                controlAllKeys = !controlAllKeys;
 8016c62:	6013      	str	r3, [r2, #0]
                setLED_B(controlAllKeys);
 8016c64:	f7fc fe80 	bl	8013968 <setLED_B>
            if (buttonActionsSFX[ButtonC][ActionPress])
 8016c68:	7f2b      	ldrb	r3, [r5, #28]
 8016c6a:	2b00      	cmp	r3, #0
 8016c6c:	f000 80bf 	beq.w	8016dee <SFXSamplerKFrame+0x1da>
                if (!controlAllKeys)
 8016c70:	4a91      	ldr	r2, [pc, #580]	; (8016eb8 <SFXSamplerKFrame+0x2a4>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8016c72:	2300      	movs	r3, #0
                if (!controlAllKeys)
 8016c74:	f8d2 9000 	ldr.w	r9, [r2]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8016c78:	772b      	strb	r3, [r5, #28]
                if (!controlAllKeys)
 8016c7a:	f1b9 0f00 	cmp.w	r9, #0
 8016c7e:	d051      	beq.n	8016d24 <SFXSamplerKFrame+0x110>
 8016c80:	2306      	movs	r3, #6
 8016c82:	f8df 9264 	ldr.w	r9, [pc, #612]	; 8016ee8 <SFXSamplerKFrame+0x2d4>
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 8016c86:	eddf 8a8d 	vldr	s17, [pc, #564]	; 8016ebc <SFXSamplerKFrame+0x2a8>
                                float previousPower = 0.0f;
 8016c8a:	ed9f 9a8d 	vldr	s18, [pc, #564]	; 8016ec0 <SFXSamplerKFrame+0x2ac>
 8016c8e:	9301      	str	r3, [sp, #4]
 8016c90:	4f88      	ldr	r7, [pc, #544]	; (8016eb4 <SFXSamplerKFrame+0x2a0>)
 8016c92:	4e8c      	ldr	r6, [pc, #560]	; (8016ec4 <SFXSamplerKFrame+0x2b0>)
 8016c94:	f8df 8230 	ldr.w	r8, [pc, #560]	; 8016ec8 <SFXSamplerKFrame+0x2b4>
 8016c98:	e01c      	b.n	8016cd4 <SFXSamplerKFrame+0xc0>
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 8016c9a:	eeb4 8ac0 	vcmpe.f32	s16, s0
 8016c9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ca2:	d53a      	bpl.n	8016d1a <SFXSamplerKFrame+0x106>
                                        int thePos = (i + detectedAttackPos[key] - 480) % buffLength;
 8016ca4:	6833      	ldr	r3, [r6, #0]
 8016ca6:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
 8016caa:	449b      	add	fp, r3
 8016cac:	fb9b f3f4 	sdiv	r3, fp, r4
 8016cb0:	fb04 b413 	mls	r4, r4, r3, fp
 8016cb4:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
                                        samplePlayStarts[key] = thePos;
 8016cb8:	ee07 4a90 	vmov	s15, r4
                                        detectedAttackPos[key] = thePos;
 8016cbc:	6034      	str	r4, [r6, #0]
                                        samplePlayStarts[key] = thePos;
 8016cbe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8016cc2:	edc8 7a00 	vstr	s15, [r8]
 8016cc6:	3604      	adds	r6, #4
 8016cc8:	3704      	adds	r7, #4
 8016cca:	f108 0804 	add.w	r8, r8, #4
                        for (int key = 0; key < NUM_SAMPLER_KEYS; key++)
 8016cce:	45b1      	cmp	r9, r6
 8016cd0:	f000 80a1 	beq.w	8016e16 <SFXSamplerKFrame+0x202>
                            int buffLength = tBuffer_getRecordedLength(&keyBuff[key]);
 8016cd4:	4638      	mov	r0, r7
 8016cd6:	f00f fb47 	bl	8026368 <tBuffer_getRecordedLength>
                            if (buffLength > 0)
 8016cda:	1e04      	subs	r4, r0, #0
 8016cdc:	ddf3      	ble.n	8016cc6 <SFXSamplerKFrame+0xb2>
                                if (detectedAttackPos[key] > 0)
 8016cde:	6833      	ldr	r3, [r6, #0]
 8016ce0:	2b00      	cmp	r3, #0
 8016ce2:	f300 8089 	bgt.w	8016df8 <SFXSamplerKFrame+0x1e4>
                                float previousPower = 0.0f;
 8016ce6:	eeb0 0a49 	vmov.f32	s0, s18
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 8016cea:	ee30 8a28 	vadd.f32	s16, s0, s17
        {
 8016cee:	2501      	movs	r5, #1
 8016cf0:	f8df a1f8 	ldr.w	sl, [pc, #504]	; 8016eec <SFXSamplerKFrame+0x2d8>
 8016cf4:	f105 3bff 	add.w	fp, r5, #4294967295	; 0xffffffff
                                    float testSample = tBuffer_get(&keyBuff[key], (i + detectedAttackPos[key]) % buffLength);
 8016cf8:	4638      	mov	r0, r7
 8016cfa:	445b      	add	r3, fp
 8016cfc:	fb93 f1f4 	sdiv	r1, r3, r4
 8016d00:	fb04 3111 	mls	r1, r4, r1, r3
 8016d04:	f00f fb08 	bl	8026318 <tBuffer_get>
                                    currentPower = testSample*testSample;
 8016d08:	ee20 0a00 	vmul.f32	s0, s0, s0
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 8016d0c:	edda 7a00 	vldr	s15, [sl]
 8016d10:	eef4 7ac0 	vcmpe.f32	s15, s0
 8016d14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016d18:	d4bf      	bmi.n	8016c9a <SFXSamplerKFrame+0x86>
                                    if (i >= buffLength)
 8016d1a:	42ac      	cmp	r4, r5
 8016d1c:	ddd3      	ble.n	8016cc6 <SFXSamplerKFrame+0xb2>
 8016d1e:	3501      	adds	r5, #1
 8016d20:	6833      	ldr	r3, [r6, #0]
 8016d22:	e7e7      	b.n	8016cf4 <SFXSamplerKFrame+0xe0>
                    int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 8016d24:	ea4f 0884 	mov.w	r8, r4, lsl #2
 8016d28:	4f62      	ldr	r7, [pc, #392]	; (8016eb4 <SFXSamplerKFrame+0x2a0>)
                    if (detectedAttackPos[currentSamplerKey] > 0)
 8016d2a:	4e66      	ldr	r6, [pc, #408]	; (8016ec4 <SFXSamplerKFrame+0x2b0>)
                    int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 8016d2c:	4447      	add	r7, r8
 8016d2e:	4638      	mov	r0, r7
 8016d30:	f00f fb1a 	bl	8026368 <tBuffer_getRecordedLength>
                    if (detectedAttackPos[currentSamplerKey] > 0)
 8016d34:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
                    int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 8016d38:	4605      	mov	r5, r0
                    if (detectedAttackPos[currentSamplerKey] > 0)
 8016d3a:	2b00      	cmp	r3, #0
 8016d3c:	f300 80a3 	bgt.w	8016e86 <SFXSamplerKFrame+0x272>
                    float previousPower = 0.0f;
 8016d40:	ed9f 0a5f 	vldr	s0, [pc, #380]	; 8016ec0 <SFXSamplerKFrame+0x2ac>
                        if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 8016d44:	ed9f 8a5d 	vldr	s16, [pc, #372]	; 8016ebc <SFXSamplerKFrame+0x2a8>
 8016d48:	f8df a1a0 	ldr.w	sl, [pc, #416]	; 8016eec <SFXSamplerKFrame+0x2d8>
 8016d4c:	ee30 8a08 	vadd.f32	s16, s0, s16
                        float testSample = tBuffer_get(&keyBuff[currentSamplerKey], (i + detectedAttackPos[currentSamplerKey]) % buffLength);
 8016d50:	444b      	add	r3, r9
 8016d52:	4638      	mov	r0, r7
 8016d54:	f109 0b01 	add.w	fp, r9, #1
 8016d58:	fb93 f1f5 	sdiv	r1, r3, r5
 8016d5c:	fb05 3111 	mls	r1, r5, r1, r3
 8016d60:	f00f fada 	bl	8026318 <tBuffer_get>
                        currentPower = testSample*testSample;
 8016d64:	ee20 0a00 	vmul.f32	s0, s0, s0
                        if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 8016d68:	edda 7a00 	vldr	s15, [sl]
 8016d6c:	eef4 7ac0 	vcmpe.f32	s15, s0
 8016d70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016d74:	f140 8081 	bpl.w	8016e7a <SFXSamplerKFrame+0x266>
 8016d78:	eeb4 8ac0 	vcmpe.f32	s16, s0
 8016d7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016d80:	d57b      	bpl.n	8016e7a <SFXSamplerKFrame+0x266>
                            int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
 8016d82:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
                            OLEDclearLine(SecondLine);
 8016d86:	2001      	movs	r0, #1
                            samplePlayStarts[currentSamplerKey] = thePos;
 8016d88:	4a4f      	ldr	r2, [pc, #316]	; (8016ec8 <SFXSamplerKFrame+0x2b4>)
                            int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
 8016d8a:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
                            samplePlayStarts[currentSamplerKey] = thePos;
 8016d8e:	4490      	add	r8, r2
                            int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
 8016d90:	4499      	add	r9, r3
 8016d92:	fb99 f3f5 	sdiv	r3, r9, r5
 8016d96:	fb05 9313 	mls	r3, r5, r3, r9
 8016d9a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
                            samplePlayStarts[currentSamplerKey] = thePos;
 8016d9e:	ee07 3a90 	vmov	s15, r3
                            detectedAttackPos[currentSamplerKey] = thePos;
 8016da2:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
                            samplePlayStarts[currentSamplerKey] = thePos;
 8016da6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8016daa:	edc8 7a00 	vstr	s15, [r8]
                            OLEDclearLine(SecondLine);
 8016dae:	f7fc fffb 	bl	8013da8 <OLEDclearLine>
                            OLEDwriteString("ATKDETECT ", 10, 0, SecondLine);
 8016db2:	2200      	movs	r2, #0
 8016db4:	210a      	movs	r1, #10
 8016db6:	2301      	movs	r3, #1
 8016db8:	4844      	ldr	r0, [pc, #272]	; (8016ecc <SFXSamplerKFrame+0x2b8>)
 8016dba:	f7fd f809 	bl	8013dd0 <OLEDwriteString>
                            OLEDwriteFloat((samplePlayStarts[currentSamplerKey] / (float)buffLength) * (buffLength * leaf.invSampleRate), OLEDgetCursor(), SecondLine);
 8016dbe:	ee07 5a90 	vmov	s15, r5
 8016dc2:	ed98 7a00 	vldr	s14, [r8]
 8016dc6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8016dca:	4b41      	ldr	r3, [pc, #260]	; (8016ed0 <SFXSamplerKFrame+0x2bc>)
 8016dcc:	ee87 8a27 	vdiv.f32	s16, s14, s15
 8016dd0:	ed93 7a01 	vldr	s14, [r3, #4]
 8016dd4:	ee67 7a87 	vmul.f32	s15, s15, s14
 8016dd8:	ee28 8a27 	vmul.f32	s16, s16, s15
 8016ddc:	f7fd fa76 	bl	80142cc <OLEDgetCursor>
 8016de0:	2101      	movs	r1, #1
 8016de2:	eeb0 0a48 	vmov.f32	s0, s16
 8016de6:	f7fd f8b7 	bl	8013f58 <OLEDwriteFloat>
                        if (i >= buffLength)
 8016dea:	455d      	cmp	r5, fp
 8016dec:	dd34      	ble.n	8016e58 <SFXSamplerKFrame+0x244>
        }
 8016dee:	b003      	add	sp, #12
 8016df0:	ecbd 8b04 	vpop	{d8-d9}
 8016df4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                    previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
 8016df8:	f241 22bf 	movw	r2, #4799	; 0x12bf
                                    detectedAttackPos[key] += 4800;
 8016dfc:	f503 5196 	add.w	r1, r3, #4800	; 0x12c0
                                    previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
 8016e00:	4638      	mov	r0, r7
 8016e02:	441a      	add	r2, r3
                                    detectedAttackPos[key] += 4800;
 8016e04:	6031      	str	r1, [r6, #0]
                                    previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
 8016e06:	fb92 f1f4 	sdiv	r1, r2, r4
 8016e0a:	fb04 2111 	mls	r1, r4, r1, r2
 8016e0e:	f00f fa83 	bl	8026318 <tBuffer_get>
 8016e12:	6833      	ldr	r3, [r6, #0]
 8016e14:	e769      	b.n	8016cea <SFXSamplerKFrame+0xd6>
                    for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
 8016e16:	9b01      	ldr	r3, [sp, #4]
 8016e18:	3b01      	subs	r3, #1
 8016e1a:	9301      	str	r3, [sp, #4]
 8016e1c:	f47f af38 	bne.w	8016c90 <SFXSamplerKFrame+0x7c>
        }
 8016e20:	b003      	add	sp, #12
 8016e22:	ecbd 8b04 	vpop	{d8-d9}
 8016e26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if ((tBuffer_isActive(&keyBuff[currentSamplerKey])) || (currentSamplerKey != prevSamplerKey)) //only write if recording
 8016e2a:	4822      	ldr	r0, [pc, #136]	; (8016eb4 <SFXSamplerKFrame+0x2a0>)
 8016e2c:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 8016e30:	f00f faa2 	bl	8026378 <tBuffer_isActive>
 8016e34:	4b27      	ldr	r3, [pc, #156]	; (8016ed4 <SFXSamplerKFrame+0x2c0>)
 8016e36:	b158      	cbz	r0, 8016e50 <SFXSamplerKFrame+0x23c>
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
 8016e38:	4a27      	ldr	r2, [pc, #156]	; (8016ed8 <SFXSamplerKFrame+0x2c4>)
 8016e3a:	2101      	movs	r1, #1
                    writeButtonFlag = ExtraMessage;
 8016e3c:	4827      	ldr	r0, [pc, #156]	; (8016edc <SFXSamplerKFrame+0x2c8>)
 8016e3e:	250a      	movs	r5, #10
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
 8016e40:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
                    writeActionFlag = ActionHoldContinuous;
 8016e44:	2103      	movs	r1, #3
 8016e46:	4a26      	ldr	r2, [pc, #152]	; (8016ee0 <SFXSamplerKFrame+0x2cc>)
                    writeButtonFlag = ExtraMessage;
 8016e48:	7005      	strb	r5, [r0, #0]
                    writeActionFlag = ActionHoldContinuous;
 8016e4a:	7011      	strb	r1, [r2, #0]
                prevSamplerKey = currentSamplerKey;
 8016e4c:	601c      	str	r4, [r3, #0]
 8016e4e:	e6ee      	b.n	8016c2e <SFXSamplerKFrame+0x1a>
                if ((tBuffer_isActive(&keyBuff[currentSamplerKey])) || (currentSamplerKey != prevSamplerKey)) //only write if recording
 8016e50:	681a      	ldr	r2, [r3, #0]
 8016e52:	42a2      	cmp	r2, r4
 8016e54:	d1f0      	bne.n	8016e38 <SFXSamplerKFrame+0x224>
 8016e56:	e7f9      	b.n	8016e4c <SFXSamplerKFrame+0x238>
                            detectedAttackPos[currentSamplerKey] = 0;
 8016e58:	2500      	movs	r5, #0
                            OLEDclearLine(SecondLine);
 8016e5a:	2001      	movs	r0, #1
                            detectedAttackPos[currentSamplerKey] = 0;
 8016e5c:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
                            OLEDclearLine(SecondLine);
 8016e60:	f7fc ffa2 	bl	8013da8 <OLEDclearLine>
                            OLEDwriteString("NO ATK FOUND ", 10, 0, SecondLine);
 8016e64:	462a      	mov	r2, r5
 8016e66:	2301      	movs	r3, #1
 8016e68:	210a      	movs	r1, #10
 8016e6a:	481e      	ldr	r0, [pc, #120]	; (8016ee4 <SFXSamplerKFrame+0x2d0>)
        }
 8016e6c:	b003      	add	sp, #12
 8016e6e:	ecbd 8b04 	vpop	{d8-d9}
 8016e72:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                            OLEDwriteString("NO ATK FOUND ", 10, 0, SecondLine);
 8016e76:	f7fc bfab 	b.w	8013dd0 <OLEDwriteString>
                        if (i >= buffLength)
 8016e7a:	455d      	cmp	r5, fp
 8016e7c:	ddec      	ble.n	8016e58 <SFXSamplerKFrame+0x244>
        {
 8016e7e:	46d9      	mov	r9, fp
 8016e80:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 8016e84:	e764      	b.n	8016d50 <SFXSamplerKFrame+0x13c>
                        previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
 8016e86:	f241 22bf 	movw	r2, #4799	; 0x12bf
                        detectedAttackPos[currentSamplerKey] += 4800;
 8016e8a:	f503 5196 	add.w	r1, r3, #4800	; 0x12c0
                        previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
 8016e8e:	4638      	mov	r0, r7
 8016e90:	441a      	add	r2, r3
                        detectedAttackPos[currentSamplerKey] += 4800;
 8016e92:	f846 1024 	str.w	r1, [r6, r4, lsl #2]
                        previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
 8016e96:	fb92 f1f5 	sdiv	r1, r2, r5
 8016e9a:	fb05 2111 	mls	r1, r5, r1, r2
 8016e9e:	f00f fa3b 	bl	8026318 <tBuffer_get>
 8016ea2:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 8016ea6:	e74d      	b.n	8016d44 <SFXSamplerKFrame+0x130>
 8016ea8:	20000224 	.word	0x20000224
 8016eac:	200176e4 	.word	0x200176e4
 8016eb0:	2001872c 	.word	0x2001872c
 8016eb4:	200181b0 	.word	0x200181b0
 8016eb8:	20000570 	.word	0x20000570
 8016ebc:	3a03126f 	.word	0x3a03126f
 8016ec0:	00000000 	.word	0x00000000
 8016ec4:	200183b8 	.word	0x200183b8
 8016ec8:	200172ec 	.word	0x200172ec
 8016ecc:	0802a1ec 	.word	0x0802a1ec
 8016ed0:	200194e8 	.word	0x200194e8
 8016ed4:	20000274 	.word	0x20000274
 8016ed8:	2001889c 	.word	0x2001889c
 8016edc:	200002da 	.word	0x200002da
 8016ee0:	200002d9 	.word	0x200002d9
 8016ee4:	0802a1dc 	.word	0x0802a1dc
 8016ee8:	2001847c 	.word	0x2001847c
 8016eec:	20000604 	.word	0x20000604

08016ef0 <SFXSamplerKTick>:
            if (!controlAllKeys)
 8016ef0:	4bd0      	ldr	r3, [pc, #832]	; (8017234 <SFXSamplerKTick+0x344>)
        {
 8016ef2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016ef6:	ed2d 8b04 	vpush	{d8-d9}
 8016efa:	b087      	sub	sp, #28
            if (!controlAllKeys)
 8016efc:	681e      	ldr	r6, [r3, #0]
        {
 8016efe:	9000      	str	r0, [sp, #0]
            if (!controlAllKeys)
 8016f00:	2e00      	cmp	r6, #0
 8016f02:	f000 81c5 	beq.w	8017290 <SFXSamplerKTick+0x3a0>
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
 8016f06:	f04f 0900 	mov.w	r9, #0
 8016f0a:	4ccb      	ldr	r4, [pc, #812]	; (8017238 <SFXSamplerKTick+0x348>)
 8016f0c:	4dcb      	ldr	r5, [pc, #812]	; (801723c <SFXSamplerKTick+0x34c>)
 8016f0e:	f8df a378 	ldr.w	sl, [pc, #888]	; 8017288 <SFXSamplerKTick+0x398>
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 8016f12:	eddf 8acb 	vldr	s17, [pc, #812]	; 8017240 <SFXSamplerKTick+0x350>
                    displayValues[5] = knobs[5] * 4000.0f;
 8016f16:	ed9f 8acb 	vldr	s16, [pc, #812]	; 8017244 <SFXSamplerKTick+0x354>
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8016f1a:	f8df b368 	ldr.w	fp, [pc, #872]	; 8017284 <SFXSamplerKTick+0x394>
 8016f1e:	e005      	b.n	8016f2c <SFXSamplerKTick+0x3c>
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
 8016f20:	f109 0901 	add.w	r9, r9, #1
 8016f24:	f1b9 0f06 	cmp.w	r9, #6
 8016f28:	f000 80f5 	beq.w	8017116 <SFXSamplerKTick+0x226>
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 8016f2c:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
                    displayValues[0] = knobs[0];
 8016f30:	ed94 1a96 	vldr	s2, [r4, #600]	; 0x258
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 8016f34:	edd4 0a97 	vldr	s1, [r4, #604]	; 0x25c
 8016f38:	eeb0 0a68 	vmov.f32	s0, s17
                    displayValues[0] = knobs[0];
 8016f3c:	ed85 1a00 	vstr	s2, [r5]
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 8016f40:	ee39 1a41 	vsub.f32	s2, s18, s2
 8016f44:	f00c ffb6 	bl	8023eb4 <LEAF_clip>
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8016f48:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8016f4c:	edd4 5a98 	vldr	s11, [r4, #608]	; 0x260
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8016f50:	eeb2 7a0c 	vmov.f32	s14, #44	; 0x41600000  14.0
 8016f54:	edd4 6a99 	vldr	s13, [r4, #612]	; 0x264
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8016f58:	eeb1 6a00 	vmov.f32	s12, #16	; 0x40800000  4.0
 8016f5c:	ee75 5ae7 	vsub.f32	s11, s11, s15
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 8016f60:	ed85 0a01 	vstr	s0, [r5, #4]
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8016f64:	ee76 7ae7 	vsub.f32	s15, s13, s15
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8016f68:	ee25 6a86 	vmul.f32	s12, s11, s12
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8016f6c:	ee67 7a87 	vmul.f32	s15, s15, s14
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8016f70:	ed85 6a02 	vstr	s12, [r5, #8]
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8016f74:	fef8 7a67 	vrinta.f32	s15, s15
                    if (rate < 0.0f)
 8016f78:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016f7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016f80:	f100 811a 	bmi.w	80171b8 <SFXSamplerKTick+0x2c8>
                        rate += 1.0f;
 8016f84:	ee77 7a89 	vadd.f32	s15, s15, s18
                    displayValues[5] = knobs[5] * 4000.0f;
 8016f88:	edd4 6a9b 	vldr	s13, [r4, #620]	; 0x26c
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8016f8c:	fa5f f689 	uxtb.w	r6, r9
                    displayValues[4] = roundf(knobs[4]);
 8016f90:	ed94 7a9a 	vldr	s14, [r4, #616]	; 0x268
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8016f94:	4658      	mov	r0, fp
                    displayValues[5] = knobs[5] * 4000.0f;
 8016f96:	ee66 6a88 	vmul.f32	s13, s13, s16
                    displayValues[6] = knobs[6];
 8016f9a:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8016f9e:	4631      	mov	r1, r6
                    displayValues[3] = rate;
 8016fa0:	edc5 7a03 	vstr	s15, [r5, #12]
                    displayValues[6] = knobs[6];
 8016fa4:	61ab      	str	r3, [r5, #24]
                    displayValues[4] = roundf(knobs[4]);
 8016fa6:	fef8 7a47 	vrinta.f32	s15, s14
                    displayValues[5] = knobs[5] * 4000.0f;
 8016faa:	edc5 6a05 	vstr	s13, [r5, #20]
                    displayValues[4] = roundf(knobs[4]);
 8016fae:	edc5 7a04 	vstr	s15, [r5, #16]
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8016fb2:	f00d fe37 	bl	8024c24 <tSimplePoly_isOn>
 8016fb6:	2800      	cmp	r0, #0
 8016fb8:	ddb2      	ble.n	8016f20 <SFXSamplerKTick+0x30>
                        int key = tSimplePoly_getPitch(&poly, i) - LOWEST_SAMPLER_KEY;
 8016fba:	4631      	mov	r1, r6
 8016fbc:	4658      	mov	r0, fp
 8016fbe:	f00d fe1f 	bl	8024c00 <tSimplePoly_getPitch>
 8016fc2:	f1a0 0624 	sub.w	r6, r0, #36	; 0x24
                        if ((0 <= key) && (key < NUM_SAMPLER_KEYS))
 8016fc6:	2e30      	cmp	r6, #48	; 0x30
 8016fc8:	d8aa      	bhi.n	8016f20 <SFXSamplerKTick+0x30>
                            tBuffer_tick(&keyBuff[key], input[1]);
 8016fca:	4b9f      	ldr	r3, [pc, #636]	; (8017248 <SFXSamplerKTick+0x358>)
 8016fcc:	00b7      	lsls	r7, r6, #2
 8016fce:	9a00      	ldr	r2, [sp, #0]
 8016fd0:	eb03 0807 	add.w	r8, r3, r7
 8016fd4:	ed92 0a01 	vldr	s0, [r2, #4]
 8016fd8:	4640      	mov	r0, r8
 8016fda:	f00f f97f 	bl	80262dc <tBuffer_tick>
                            int recordedLength = tBuffer_getRecordedLength(&keyBuff[key]);
 8016fde:	4640      	mov	r0, r8
 8016fe0:	f00f f9c2 	bl	8026368 <tBuffer_getRecordedLength>
                            if (knobs[0] != prevKnobs[0])
 8016fe4:	ed94 7a96 	vldr	s14, [r4, #600]	; 0x258
                            sampleLength = recordedLength * leaf.invSampleRate;
 8016fe8:	ee07 0a90 	vmov	s15, r0
                            if (knobs[0] != prevKnobs[0])
 8016fec:	ed9a 6a00 	vldr	s12, [sl]
                            sampleLength = recordedLength * leaf.invSampleRate;
 8016ff0:	4a96      	ldr	r2, [pc, #600]	; (801724c <SFXSamplerKTick+0x35c>)
 8016ff2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8016ff6:	4b96      	ldr	r3, [pc, #600]	; (8017250 <SFXSamplerKTick+0x360>)
                            if (knobs[0] != prevKnobs[0])
 8016ff8:	eeb4 7a46 	vcmp.f32	s14, s12
                            sampleLength = recordedLength * leaf.invSampleRate;
 8016ffc:	edd2 6a01 	vldr	s13, [r2, #4]
 8017000:	ee66 6aa7 	vmul.f32	s13, s13, s15
                            if (knobs[0] != prevKnobs[0])
 8017004:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                            sampleLength = recordedLength * leaf.invSampleRate;
 8017008:	edc3 6a00 	vstr	s13, [r3]
                                samplePlayStarts[key]= (knobs[0] * recordedLength);
 801700c:	4b91      	ldr	r3, [pc, #580]	; (8017254 <SFXSamplerKTick+0x364>)
                            if (knobs[0] != prevKnobs[0])
 801700e:	f040 810a 	bne.w	8017226 <SFXSamplerKTick+0x336>
 8017012:	443b      	add	r3, r7
 8017014:	edd3 6a00 	vldr	s13, [r3]
                            if (knobs[1] != prevKnobs[1])
 8017018:	ed94 7a97 	vldr	s14, [r4, #604]	; 0x25c
 801701c:	ed9a 6a01 	vldr	s12, [sl, #4]
                                samplePlayLengths[key] = (knobs[1] * recordedLength);
 8017020:	4a8d      	ldr	r2, [pc, #564]	; (8017258 <SFXSamplerKTick+0x368>)
                            if (knobs[1] != prevKnobs[1])
 8017022:	eeb4 7a46 	vcmp.f32	s14, s12
 8017026:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801702a:	d004      	beq.n	8017036 <SFXSamplerKTick+0x146>
                                samplePlayLengths[key] = (knobs[1] * recordedLength);
 801702c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8017030:	19d3      	adds	r3, r2, r7
 8017032:	edc3 7a00 	vstr	s15, [r3]
                            if (knobs[2] != prevKnobs[2])
 8017036:	ed94 7a98 	vldr	s14, [r4, #608]	; 0x260
 801703a:	edda 7a02 	vldr	s15, [sl, #8]
                                sampleRates[key] = displayValues[2];
 801703e:	4b87      	ldr	r3, [pc, #540]	; (801725c <SFXSamplerKTick+0x36c>)
                            if (knobs[2] != prevKnobs[2])
 8017040:	eeb4 7a67 	vcmp.f32	s14, s15
                                sampleRates[key] = displayValues[2];
 8017044:	9305      	str	r3, [sp, #20]
                            if (knobs[2] != prevKnobs[2])
 8017046:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801704a:	d002      	beq.n	8017052 <SFXSamplerKTick+0x162>
                                sampleRates[key] = displayValues[2];
 801704c:	68a9      	ldr	r1, [r5, #8]
 801704e:	443b      	add	r3, r7
 8017050:	6019      	str	r1, [r3, #0]
                            if (knobs[3] != prevKnobs[3])
 8017052:	ed94 7a99 	vldr	s14, [r4, #612]	; 0x264
 8017056:	edda 7a03 	vldr	s15, [sl, #12]
                                sampleRatesMult[key] = displayValues[3];
 801705a:	4b81      	ldr	r3, [pc, #516]	; (8017260 <SFXSamplerKTick+0x370>)
                            if (knobs[3] != prevKnobs[3])
 801705c:	eeb4 7a67 	vcmp.f32	s14, s15
                                sampleRatesMult[key] = displayValues[3];
 8017060:	9304      	str	r3, [sp, #16]
                            if (knobs[3] != prevKnobs[3])
 8017062:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017066:	d002      	beq.n	801706e <SFXSamplerKTick+0x17e>
                                sampleRatesMult[key] = displayValues[3];
 8017068:	68e9      	ldr	r1, [r5, #12]
 801706a:	443b      	add	r3, r7
 801706c:	6019      	str	r1, [r3, #0]
                            if (knobs[4] != prevKnobs[4])
 801706e:	edd4 7a9a 	vldr	s15, [r4, #616]	; 0x268
 8017072:	ed9a 7a04 	vldr	s14, [sl, #16]
 8017076:	eef4 7a47 	vcmp.f32	s15, s14
 801707a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801707e:	f040 822e 	bne.w	80174de <SFXSamplerKTick+0x5ee>
 8017082:	4b78      	ldr	r3, [pc, #480]	; (8017264 <SFXSamplerKTick+0x374>)
 8017084:	9303      	str	r3, [sp, #12]
                            if (knobs[5] != prevKnobs[5])
 8017086:	ed94 7a9b 	vldr	s14, [r4, #620]	; 0x26c
 801708a:	edda 7a05 	vldr	s15, [sl, #20]
                                crossfadeLengths[key] = displayValues[5];
 801708e:	4b76      	ldr	r3, [pc, #472]	; (8017268 <SFXSamplerKTick+0x378>)
                            if (knobs[5] != prevKnobs[5])
 8017090:	eeb4 7a67 	vcmp.f32	s14, s15
 8017094:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017098:	d002      	beq.n	80170a0 <SFXSamplerKTick+0x1b0>
                                crossfadeLengths[key] = displayValues[5];
 801709a:	6968      	ldr	r0, [r5, #20]
 801709c:	19d9      	adds	r1, r3, r7
 801709e:	6008      	str	r0, [r1, #0]
                            tSampler_setStart(&keySampler[key], samplePlayStarts[key]);
 80170a0:	4872      	ldr	r0, [pc, #456]	; (801726c <SFXSamplerKTick+0x37c>)
 80170a2:	eefd 7ae6 	vcvt.s32.f32	s15, s13
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
 80170a6:	f109 0901 	add.w	r9, r9, #1
                            tSampler_setStart(&keySampler[key], samplePlayStarts[key]);
 80170aa:	eb00 0807 	add.w	r8, r0, r7
 80170ae:	ee17 1a90 	vmov	r1, s15
 80170b2:	4640      	mov	r0, r8
 80170b4:	e9cd 3201 	strd	r3, r2, [sp, #4]
 80170b8:	f00f fa34 	bl	8026524 <tSampler_setStart>
                            tSampler_setLength(&keySampler[key], samplePlayLengths[key]);
 80170bc:	9a02      	ldr	r2, [sp, #8]
 80170be:	4640      	mov	r0, r8
 80170c0:	443a      	add	r2, r7
 80170c2:	edd2 7a00 	vldr	s15, [r2]
 80170c6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80170ca:	ee17 1a90 	vmov	r1, s15
 80170ce:	f00f fe4d 	bl	8026d6c <tSampler_setLength>
                            tSampler_setCrossfadeLength(&keySampler[key], crossfadeLengths[key]);
 80170d2:	9b01      	ldr	r3, [sp, #4]
 80170d4:	4640      	mov	r0, r8
 80170d6:	443b      	add	r3, r7
 80170d8:	edd3 7a00 	vldr	s15, [r3]
 80170dc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80170e0:	ee17 1a90 	vmov	r1, s15
 80170e4:	f00f f9ac 	bl	8026440 <tSampler_setCrossfadeLength>
                            tSampler_setRate(&keySampler[key], sampleRates[key] * sampleRatesMult[key]);
 80170e8:	9b05      	ldr	r3, [sp, #20]
 80170ea:	9a04      	ldr	r2, [sp, #16]
 80170ec:	4640      	mov	r0, r8
 80170ee:	443b      	add	r3, r7
 80170f0:	443a      	add	r2, r7
 80170f2:	ed93 0a00 	vldr	s0, [r3]
 80170f6:	edd2 7a00 	vldr	s15, [r2]
 80170fa:	ee20 0a27 	vmul.f32	s0, s0, s15
 80170fe:	f00f fecf 	bl	8026ea0 <tSampler_setRate>
                            tSampler_setMode(&keySampler[key], (PlayMode)loopOns[key]);
 8017102:	9b03      	ldr	r3, [sp, #12]
 8017104:	4640      	mov	r0, r8
 8017106:	f813 1026 	ldrb.w	r1, [r3, r6, lsl #2]
 801710a:	f00f f995 	bl	8026438 <tSampler_setMode>
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
 801710e:	f1b9 0f06 	cmp.w	r9, #6
 8017112:	f47f af0b 	bne.w	8016f2c <SFXSamplerKTick+0x3c>
 8017116:	f8df e174 	ldr.w	lr, [pc, #372]	; 801728c <SFXSamplerKTick+0x39c>
 801711a:	2424      	movs	r4, #36	; 0x24
 801711c:	f8df c168 	ldr.w	ip, [pc, #360]	; 8017288 <SFXSamplerKTick+0x398>
            float sample = 0.0f;
 8017120:	ed9f 9a47 	vldr	s18, [pc, #284]	; 8017240 <SFXSamplerKTick+0x350>
                if ( tempGain > 0.001f)
 8017124:	eddf 8a52 	vldr	s17, [pc, #328]	; 8017270 <SFXSamplerKTick+0x380>
 8017128:	4e52      	ldr	r6, [pc, #328]	; (8017274 <SFXSamplerKTick+0x384>)
                    sample += tSampler_tick(&keySampler[i]) * tempGain;
 801712a:	4f53      	ldr	r7, [pc, #332]	; (8017278 <SFXSamplerKTick+0x388>)
                        if (waitingForDeactivation[j] == (i + LOWEST_SAMPLER_KEY))
 801712c:	4d53      	ldr	r5, [pc, #332]	; (801727c <SFXSamplerKTick+0x38c>)
 801712e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8017132:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8017136:	e89e 0003 	ldmia.w	lr, {r0, r1}
 801713a:	e88c 0003 	stmia.w	ip, {r0, r1}
 801713e:	e015      	b.n	801716c <SFXSamplerKTick+0x27c>
 8017140:	682b      	ldr	r3, [r5, #0]
 8017142:	42a3      	cmp	r3, r4
 8017144:	d067      	beq.n	8017216 <SFXSamplerKTick+0x326>
 8017146:	686b      	ldr	r3, [r5, #4]
 8017148:	429c      	cmp	r4, r3
 801714a:	d05c      	beq.n	8017206 <SFXSamplerKTick+0x316>
 801714c:	68ab      	ldr	r3, [r5, #8]
 801714e:	429c      	cmp	r4, r3
 8017150:	d051      	beq.n	80171f6 <SFXSamplerKTick+0x306>
 8017152:	68eb      	ldr	r3, [r5, #12]
 8017154:	429c      	cmp	r4, r3
 8017156:	d046      	beq.n	80171e6 <SFXSamplerKTick+0x2f6>
 8017158:	692b      	ldr	r3, [r5, #16]
 801715a:	429c      	cmp	r4, r3
 801715c:	d03b      	beq.n	80171d6 <SFXSamplerKTick+0x2e6>
 801715e:	696b      	ldr	r3, [r5, #20]
 8017160:	429c      	cmp	r4, r3
 8017162:	d030      	beq.n	80171c6 <SFXSamplerKTick+0x2d6>
 8017164:	3401      	adds	r4, #1
 8017166:	3604      	adds	r6, #4
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 8017168:	2c55      	cmp	r4, #85	; 0x55
 801716a:	d013      	beq.n	8017194 <SFXSamplerKTick+0x2a4>
                float tempGain = tExpSmooth_tick(&kSamplerGains[i]);
 801716c:	4630      	mov	r0, r6
 801716e:	f00b fa11 	bl	8022594 <tExpSmooth_tick>
                if ( tempGain > 0.001f)
 8017172:	eeb4 0ae8 	vcmpe.f32	s0, s17
                float tempGain = tExpSmooth_tick(&kSamplerGains[i]);
 8017176:	eeb0 8a40 	vmov.f32	s16, s0
                if ( tempGain > 0.001f)
 801717a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801717e:	dddf      	ble.n	8017140 <SFXSamplerKTick+0x250>
                    sample += tSampler_tick(&keySampler[i]) * tempGain;
 8017180:	eb07 0084 	add.w	r0, r7, r4, lsl #2
 8017184:	3401      	adds	r4, #1
 8017186:	f00f faf9 	bl	802677c <tSampler_tick>
 801718a:	3604      	adds	r6, #4
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 801718c:	2c55      	cmp	r4, #85	; 0x55
                    sample += tSampler_tick(&keySampler[i]) * tempGain;
 801718e:	eea0 9a08 	vfma.f32	s18, s0, s16
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 8017192:	d1eb      	bne.n	801716c <SFXSamplerKTick+0x27c>
            sample = tanhf(sample) * 0.98f;
 8017194:	eeb0 0a49 	vmov.f32	s0, s18
 8017198:	f010 fb58 	bl	802784c <tanhf>
 801719c:	eddf 7a38 	vldr	s15, [pc, #224]	; 8017280 <SFXSamplerKTick+0x390>
            input[0] = sample;
 80171a0:	9b00      	ldr	r3, [sp, #0]
            sample = tanhf(sample) * 0.98f;
 80171a2:	ee20 0a27 	vmul.f32	s0, s0, s15
            input[0] = sample;
 80171a6:	ed83 0a00 	vstr	s0, [r3]
            input[1] = sample;
 80171aa:	ed83 0a01 	vstr	s0, [r3, #4]
        }
 80171ae:	b007      	add	sp, #28
 80171b0:	ecbd 8b04 	vpop	{d8-d9}
 80171b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        (rate = 1.0f / fabsf(rate-1.0f));
 80171b8:	ee77 7ac9 	vsub.f32	s15, s15, s18
 80171bc:	eeb0 7ae7 	vabs.f32	s14, s15
 80171c0:	eec9 7a07 	vdiv.f32	s15, s18, s14
 80171c4:	e6e0      	b.n	8016f88 <SFXSamplerKTick+0x98>
                            tSimplePoly_deactivateVoice(&poly, j);
 80171c6:	2105      	movs	r1, #5
 80171c8:	482e      	ldr	r0, [pc, #184]	; (8017284 <SFXSamplerKTick+0x394>)
 80171ca:	f00d fc3f 	bl	8024a4c <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 80171ce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80171d2:	616b      	str	r3, [r5, #20]
 80171d4:	e7c6      	b.n	8017164 <SFXSamplerKTick+0x274>
                            tSimplePoly_deactivateVoice(&poly, j);
 80171d6:	2104      	movs	r1, #4
 80171d8:	482a      	ldr	r0, [pc, #168]	; (8017284 <SFXSamplerKTick+0x394>)
 80171da:	f00d fc37 	bl	8024a4c <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 80171de:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80171e2:	612b      	str	r3, [r5, #16]
 80171e4:	e7bb      	b.n	801715e <SFXSamplerKTick+0x26e>
                            tSimplePoly_deactivateVoice(&poly, j);
 80171e6:	2103      	movs	r1, #3
 80171e8:	4826      	ldr	r0, [pc, #152]	; (8017284 <SFXSamplerKTick+0x394>)
 80171ea:	f00d fc2f 	bl	8024a4c <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 80171ee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80171f2:	60eb      	str	r3, [r5, #12]
 80171f4:	e7b0      	b.n	8017158 <SFXSamplerKTick+0x268>
                            tSimplePoly_deactivateVoice(&poly, j);
 80171f6:	2102      	movs	r1, #2
 80171f8:	4822      	ldr	r0, [pc, #136]	; (8017284 <SFXSamplerKTick+0x394>)
 80171fa:	f00d fc27 	bl	8024a4c <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 80171fe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8017202:	60ab      	str	r3, [r5, #8]
 8017204:	e7a5      	b.n	8017152 <SFXSamplerKTick+0x262>
                            tSimplePoly_deactivateVoice(&poly, j);
 8017206:	2101      	movs	r1, #1
 8017208:	481e      	ldr	r0, [pc, #120]	; (8017284 <SFXSamplerKTick+0x394>)
 801720a:	f00d fc1f 	bl	8024a4c <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 801720e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8017212:	606b      	str	r3, [r5, #4]
 8017214:	e79a      	b.n	801714c <SFXSamplerKTick+0x25c>
                            tSimplePoly_deactivateVoice(&poly, j);
 8017216:	2100      	movs	r1, #0
 8017218:	481a      	ldr	r0, [pc, #104]	; (8017284 <SFXSamplerKTick+0x394>)
 801721a:	f00d fc17 	bl	8024a4c <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 801721e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8017222:	602b      	str	r3, [r5, #0]
 8017224:	e78f      	b.n	8017146 <SFXSamplerKTick+0x256>
                                samplePlayStarts[key]= (knobs[0] * recordedLength);
 8017226:	ee67 6a87 	vmul.f32	s13, s15, s14
 801722a:	443b      	add	r3, r7
 801722c:	edc3 6a00 	vstr	s13, [r3]
 8017230:	e6f2      	b.n	8017018 <SFXSamplerKTick+0x128>
 8017232:	bf00      	nop
 8017234:	20000570 	.word	0x20000570
 8017238:	20002cb8 	.word	0x20002cb8
 801723c:	200187dc 	.word	0x200187dc
 8017240:	00000000 	.word	0x00000000
 8017244:	457a0000 	.word	0x457a0000
 8017248:	200181b0 	.word	0x200181b0
 801724c:	200194e8 	.word	0x200194e8
 8017250:	2000060c 	.word	0x2000060c
 8017254:	200172ec 	.word	0x200172ec
 8017258:	20002828 	.word	0x20002828
 801725c:	20002910 	.word	0x20002910
 8017260:	2001788c 	.word	0x2001788c
 8017264:	20002bf4 	.word	0x20002bf4
 8017268:	200177c4 	.word	0x200177c4
 801726c:	200034d4 	.word	0x200034d4
 8017270:	3a83126f 	.word	0x3a83126f
 8017274:	20002634 	.word	0x20002634
 8017278:	20003444 	.word	0x20003444
 801727c:	200175c0 	.word	0x200175c0
 8017280:	3f7ae148 	.word	0x3f7ae148
 8017284:	200174c8 	.word	0x200174c8
 8017288:	20018198 	.word	0x20018198
 801728c:	20002f10 	.word	0x20002f10
            int currentSamplerKey = currentSamplerKeyGlobal;
 8017290:	4ba0      	ldr	r3, [pc, #640]	; (8017514 <SFXSamplerKTick+0x624>)
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8017292:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
                displayValues[0] = knobs[0] * sampleLength;
 8017296:	4ca0      	ldr	r4, [pc, #640]	; (8017518 <SFXSamplerKTick+0x628>)
            int currentSamplerKey = currentSamplerKeyGlobal;
 8017298:	f8d3 8000 	ldr.w	r8, [r3]
                int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 801729c:	4b9f      	ldr	r3, [pc, #636]	; (801751c <SFXSamplerKTick+0x62c>)
 801729e:	ea4f 0788 	mov.w	r7, r8, lsl #2
                displayValues[0] = knobs[0] * sampleLength;
 80172a2:	4d9f      	ldr	r5, [pc, #636]	; (8017520 <SFXSamplerKTick+0x630>)
                int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 80172a4:	19d8      	adds	r0, r3, r7
 80172a6:	f00f f85f 	bl	8026368 <tBuffer_getRecordedLength>
                sampleLength = recordedLength * leaf.invSampleRate;
 80172aa:	ee07 0a90 	vmov	s15, r0
 80172ae:	4b9d      	ldr	r3, [pc, #628]	; (8017524 <SFXSamplerKTick+0x634>)
 80172b0:	eef8 8ae7 	vcvt.f32.s32	s17, s15
                displayValues[0] = knobs[0] * sampleLength;
 80172b4:	ed94 7a96 	vldr	s14, [r4, #600]	; 0x258
                sampleLength = recordedLength * leaf.invSampleRate;
 80172b8:	edd3 7a01 	vldr	s15, [r3, #4]
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 80172bc:	ee38 1a47 	vsub.f32	s2, s16, s14
 80172c0:	edd4 0a97 	vldr	s1, [r4, #604]	; 0x25c
                sampleLength = recordedLength * leaf.invSampleRate;
 80172c4:	ee68 7aa7 	vmul.f32	s15, s17, s15
 80172c8:	4b97      	ldr	r3, [pc, #604]	; (8017528 <SFXSamplerKTick+0x638>)
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 80172ca:	ed9f 0a98 	vldr	s0, [pc, #608]	; 801752c <SFXSamplerKTick+0x63c>
                displayValues[0] = knobs[0] * sampleLength;
 80172ce:	ee27 7a87 	vmul.f32	s14, s15, s14
                sampleLength = recordedLength * leaf.invSampleRate;
 80172d2:	edc3 7a00 	vstr	s15, [r3]
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 80172d6:	ee21 1a27 	vmul.f32	s2, s2, s15
 80172da:	ee67 0aa0 	vmul.f32	s1, s15, s1
                displayValues[0] = knobs[0] * sampleLength;
 80172de:	ed85 7a00 	vstr	s14, [r5]
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 80172e2:	f00c fde7 	bl	8023eb4 <LEAF_clip>
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 80172e6:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 80172ea:	edd4 5a98 	vldr	s11, [r4, #608]	; 0x260
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 80172ee:	ed94 6a99 	vldr	s12, [r4, #612]	; 0x264
 80172f2:	eeb2 7a0c 	vmov.f32	s14, #44	; 0x41600000  14.0
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 80172f6:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 80172fa:	ed85 0a01 	vstr	s0, [r5, #4]
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 80172fe:	ee75 3ae7 	vsub.f32	s7, s11, s15
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8017302:	ee76 7a67 	vsub.f32	s15, s12, s15
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8017306:	ee63 3aa6 	vmul.f32	s7, s7, s13
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 801730a:	ee67 7a87 	vmul.f32	s15, s15, s14
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 801730e:	edc5 3a02 	vstr	s7, [r5, #8]
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8017312:	fef8 7a67 	vrinta.f32	s15, s15
                if (rate < 0.0f)
 8017316:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801731a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801731e:	f100 80f1 	bmi.w	8017504 <SFXSamplerKTick+0x614>
                    rate += 1.0f;
 8017322:	ee37 3a88 	vadd.f32	s6, s15, s16
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 8017326:	f8df a224 	ldr.w	sl, [pc, #548]	; 801754c <SFXSamplerKTick+0x65c>
 801732a:	edd4 7a96 	vldr	s15, [r4, #600]	; 0x258
 801732e:	edda 4a00 	vldr	s9, [sl]
 8017332:	ed9f 5a7f 	vldr	s10, [pc, #508]	; 8017530 <SFXSamplerKTick+0x640>
 8017336:	ee77 4ae4 	vsub.f32	s9, s15, s9
                displayValues[5] = knobs[5] * 4000.0f;
 801733a:	ed94 7a9b 	vldr	s14, [r4, #620]	; 0x26c
 801733e:	eddf 2a7d 	vldr	s5, [pc, #500]	; 8017534 <SFXSamplerKTick+0x644>
                displayValues[6] = knobs[6];
 8017342:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 8017346:	eef0 4ae4 	vabs.f32	s9, s9
                displayValues[4] = roundf(knobs[4]);
 801734a:	edd4 6a9a 	vldr	s13, [r4, #616]	; 0x268
                displayValues[5] = knobs[5] * 4000.0f;
 801734e:	ee67 2a22 	vmul.f32	s5, s14, s5
                displayValues[6] = knobs[6];
 8017352:	61ab      	str	r3, [r5, #24]
                displayValues[4] = roundf(knobs[4]);
 8017354:	feb8 4a66 	vrinta.f32	s8, s13
                displayValues[3] = rate;
 8017358:	ed85 3a03 	vstr	s6, [r5, #12]
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 801735c:	eef4 4ac5 	vcmpe.f32	s9, s10
                displayValues[4] = roundf(knobs[4]);
 8017360:	ed85 4a04 	vstr	s8, [r5, #16]
                displayValues[5] = knobs[5] * 4000.0f;
 8017364:	edc5 2a05 	vstr	s5, [r5, #20]
                    samplePlayStarts[currentSamplerKey]= (knobs[0] * recordedLength);// + detectedAttackPos[currentSamplerKey];
 8017368:	4b73      	ldr	r3, [pc, #460]	; (8017538 <SFXSamplerKTick+0x648>)
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 801736a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801736e:	f300 80c1 	bgt.w	80174f4 <SFXSamplerKTick+0x604>
 8017372:	443b      	add	r3, r7
 8017374:	edd3 7a00 	vldr	s15, [r3]
                if (fabsf(knobs[1]-prevKnobs[1])  > 0.0001f)
 8017378:	ed94 5a97 	vldr	s10, [r4, #604]	; 0x25c
 801737c:	edda 4a01 	vldr	s9, [sl, #4]
 8017380:	ed9f 2a6b 	vldr	s4, [pc, #428]	; 8017530 <SFXSamplerKTick+0x640>
 8017384:	ee75 4a64 	vsub.f32	s9, s10, s9
                    samplePlayLengths[currentSamplerKey] = (knobs[1] * recordedLength);// - detectedAttackPos[currentSamplerKey];
 8017388:	f8df b1c4 	ldr.w	fp, [pc, #452]	; 8017550 <SFXSamplerKTick+0x660>
                if (fabsf(knobs[1]-prevKnobs[1])  > 0.0001f)
 801738c:	eef0 4ae4 	vabs.f32	s9, s9
 8017390:	eef4 4ac2 	vcmpe.f32	s9, s4
 8017394:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017398:	dd05      	ble.n	80173a6 <SFXSamplerKTick+0x4b6>
                    samplePlayLengths[currentSamplerKey] = (knobs[1] * recordedLength);// - detectedAttackPos[currentSamplerKey];
 801739a:	ee28 5a85 	vmul.f32	s10, s17, s10
 801739e:	eb0b 0307 	add.w	r3, fp, r7
 80173a2:	ed83 5a00 	vstr	s10, [r3]
                if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
 80173a6:	edda 4a02 	vldr	s9, [sl, #8]
 80173aa:	ed9f 5a61 	vldr	s10, [pc, #388]	; 8017530 <SFXSamplerKTick+0x640>
 80173ae:	ee75 5ae4 	vsub.f32	s11, s11, s9
                    sampleRates[currentSamplerKey] = displayValues[2];
 80173b2:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 8017554 <SFXSamplerKTick+0x664>
                if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
 80173b6:	eef0 5ae5 	vabs.f32	s11, s11
 80173ba:	eef4 5ac5 	vcmpe.f32	s11, s10
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
 80173be:	ed9a 5a03 	vldr	s10, [sl, #12]
 80173c2:	eddf 5a5b 	vldr	s11, [pc, #364]	; 8017530 <SFXSamplerKTick+0x640>
 80173c6:	ee36 6a45 	vsub.f32	s12, s12, s10
                if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
 80173ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
 80173ce:	eeb0 6ac6 	vabs.f32	s12, s12
                    sampleRates[currentSamplerKey] = displayValues[2];
 80173d2:	bfc8      	it	gt
 80173d4:	eb09 0307 	addgt.w	r3, r9, r7
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
 80173d8:	eeb4 6ae5 	vcmpe.f32	s12, s11
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
 80173dc:	edda 5a04 	vldr	s11, [sl, #16]
                    sampleRates[currentSamplerKey] = displayValues[2];
 80173e0:	bfc8      	it	gt
 80173e2:	edc3 3a00 	vstrgt	s7, [r3]
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
 80173e6:	ee76 6ae5 	vsub.f32	s13, s13, s11
 80173ea:	ed9f 6a51 	vldr	s12, [pc, #324]	; 8017530 <SFXSamplerKTick+0x640>
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
 80173ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
 80173f2:	4b52      	ldr	r3, [pc, #328]	; (801753c <SFXSamplerKTick+0x64c>)
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
 80173f4:	eef0 6ae6 	vabs.f32	s13, s13
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
 80173f8:	9301      	str	r3, [sp, #4]
 80173fa:	bfc8      	it	gt
 80173fc:	19db      	addgt	r3, r3, r7
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
 80173fe:	eef4 6ac6 	vcmpe.f32	s13, s12
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
 8017402:	bfc8      	it	gt
 8017404:	ed83 3a00 	vstrgt	s6, [r3]
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
 8017408:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801740c:	dd78      	ble.n	8017500 <SFXSamplerKTick+0x610>
                    loopOns[currentSamplerKey] = roundf(knobs[4]);
 801740e:	eebd 4ac4 	vcvt.s32.f32	s8, s8
 8017412:	4b4b      	ldr	r3, [pc, #300]	; (8017540 <SFXSamplerKTick+0x650>)
 8017414:	ee14 2a10 	vmov	r2, s8
 8017418:	f843 2028 	str.w	r2, [r3, r8, lsl #2]
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 801741c:	ed9a 6a05 	vldr	s12, [sl, #20]
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 8017420:	eefd 7ae7 	vcvt.s32.f32	s15, s15
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 8017424:	eddf 6a42 	vldr	s13, [pc, #264]	; 8017530 <SFXSamplerKTick+0x640>
                tSampler_setLength(&keySampler[currentSamplerKey], samplePlayLengths[currentSamplerKey]);
 8017428:	44bb      	add	fp, r7
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 801742a:	ee37 7a46 	vsub.f32	s14, s14, s12
                    crossfadeLengths[currentSamplerKey] = displayValues[5];
 801742e:	f8df a128 	ldr.w	sl, [pc, #296]	; 8017558 <SFXSamplerKTick+0x668>
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 8017432:	4d44      	ldr	r5, [pc, #272]	; (8017544 <SFXSamplerKTick+0x654>)
                tSampler_setRate(&keySampler[currentSamplerKey], sampleRates[currentSamplerKey] * sampleRatesMult[currentSamplerKey]);
 8017434:	44b9      	add	r9, r7
 8017436:	9302      	str	r3, [sp, #8]
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 8017438:	eeb0 7ac7 	vabs.f32	s14, s14
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 801743c:	443d      	add	r5, r7
                    if (tSimplePoly_isOn(&poly, i) > 0)
 801743e:	4c42      	ldr	r4, [pc, #264]	; (8017548 <SFXSamplerKTick+0x658>)
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 8017440:	4628      	mov	r0, r5
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 8017442:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8017446:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    crossfadeLengths[currentSamplerKey] = displayValues[5];
 801744a:	bfc4      	itt	gt
 801744c:	eb0a 0107 	addgt.w	r1, sl, r7
 8017450:	edc1 2a00 	vstrgt	s5, [r1]
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 8017454:	ee17 1a90 	vmov	r1, s15
 8017458:	f00f f864 	bl	8026524 <tSampler_setStart>
                tSampler_setLength(&keySampler[currentSamplerKey], samplePlayLengths[currentSamplerKey]);
 801745c:	eddb 7a00 	vldr	s15, [fp]
 8017460:	4628      	mov	r0, r5
 8017462:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8017466:	ee17 1a90 	vmov	r1, s15
 801746a:	f00f fc7f 	bl	8026d6c <tSampler_setLength>
                tSampler_setCrossfadeLength(&keySampler[currentSamplerKey], crossfadeLengths[currentSamplerKey]);
 801746e:	eb0a 0207 	add.w	r2, sl, r7
 8017472:	4628      	mov	r0, r5
 8017474:	edd2 7a00 	vldr	s15, [r2]
 8017478:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801747c:	ee17 1a90 	vmov	r1, s15
 8017480:	f00e ffde 	bl	8026440 <tSampler_setCrossfadeLength>
                tSampler_setRate(&keySampler[currentSamplerKey], sampleRates[currentSamplerKey] * sampleRatesMult[currentSamplerKey]);
 8017484:	9b01      	ldr	r3, [sp, #4]
 8017486:	ed99 0a00 	vldr	s0, [r9]
 801748a:	4628      	mov	r0, r5
 801748c:	443b      	add	r3, r7
 801748e:	edd3 7a00 	vldr	s15, [r3]
 8017492:	ee20 0a27 	vmul.f32	s0, s0, s15
 8017496:	f00f fd03 	bl	8026ea0 <tSampler_setRate>
                tSampler_setMode(&keySampler[currentSamplerKey], (PlayMode)loopOns[currentSamplerKey]);
 801749a:	9b02      	ldr	r3, [sp, #8]
 801749c:	4628      	mov	r0, r5
 801749e:	f813 1028 	ldrb.w	r1, [r3, r8, lsl #2]
 80174a2:	f00e ffc9 	bl	8026438 <tSampler_setMode>
 80174a6:	e002      	b.n	80174ae <SFXSamplerKTick+0x5be>
                for (int i = 0; i < NUM_SAMPLER_VOICES; ++i)
 80174a8:	2e06      	cmp	r6, #6
 80174aa:	f43f ae34 	beq.w	8017116 <SFXSamplerKTick+0x226>
                    if (tSimplePoly_isOn(&poly, i) > 0)
 80174ae:	b2f5      	uxtb	r5, r6
 80174b0:	4620      	mov	r0, r4
 80174b2:	3601      	adds	r6, #1
 80174b4:	4629      	mov	r1, r5
 80174b6:	f00d fbb5 	bl	8024c24 <tSimplePoly_isOn>
 80174ba:	2800      	cmp	r0, #0
                        int key = tSimplePoly_getPitch(&poly, i) - LOWEST_SAMPLER_KEY;
 80174bc:	4629      	mov	r1, r5
 80174be:	4620      	mov	r0, r4
                    if (tSimplePoly_isOn(&poly, i) > 0)
 80174c0:	ddf2      	ble.n	80174a8 <SFXSamplerKTick+0x5b8>
                        int key = tSimplePoly_getPitch(&poly, i) - LOWEST_SAMPLER_KEY;
 80174c2:	f00d fb9d 	bl	8024c00 <tSimplePoly_getPitch>
 80174c6:	3824      	subs	r0, #36	; 0x24
                        if ((0 <= key) && (key < NUM_SAMPLER_KEYS))
 80174c8:	2830      	cmp	r0, #48	; 0x30
 80174ca:	d8ed      	bhi.n	80174a8 <SFXSamplerKTick+0x5b8>
                            tBuffer_tick(&keyBuff[key], input[1]);
 80174cc:	4b13      	ldr	r3, [pc, #76]	; (801751c <SFXSamplerKTick+0x62c>)
 80174ce:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80174d2:	9b00      	ldr	r3, [sp, #0]
 80174d4:	ed93 0a01 	vldr	s0, [r3, #4]
 80174d8:	f00e ff00 	bl	80262dc <tBuffer_tick>
 80174dc:	e7e4      	b.n	80174a8 <SFXSamplerKTick+0x5b8>
                                loopOns[key] = roundf(knobs[4]);
 80174de:	fef8 7a67 	vrinta.f32	s15, s15
 80174e2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80174e6:	4b16      	ldr	r3, [pc, #88]	; (8017540 <SFXSamplerKTick+0x650>)
 80174e8:	ee17 1a90 	vmov	r1, s15
 80174ec:	9303      	str	r3, [sp, #12]
 80174ee:	f843 1026 	str.w	r1, [r3, r6, lsl #2]
 80174f2:	e5c8      	b.n	8017086 <SFXSamplerKTick+0x196>
                    samplePlayStarts[currentSamplerKey]= (knobs[0] * recordedLength);// + detectedAttackPos[currentSamplerKey];
 80174f4:	ee68 7aa7 	vmul.f32	s15, s17, s15
 80174f8:	443b      	add	r3, r7
 80174fa:	edc3 7a00 	vstr	s15, [r3]
 80174fe:	e73b      	b.n	8017378 <SFXSamplerKTick+0x488>
 8017500:	4b0f      	ldr	r3, [pc, #60]	; (8017540 <SFXSamplerKTick+0x650>)
 8017502:	e78b      	b.n	801741c <SFXSamplerKTick+0x52c>
                    (rate = 1.0f / fabsf(rate-1.0f));
 8017504:	ee77 7ac8 	vsub.f32	s15, s15, s16
 8017508:	eef0 7ae7 	vabs.f32	s15, s15
 801750c:	ee88 3a27 	vdiv.f32	s6, s16, s15
 8017510:	e709      	b.n	8017326 <SFXSamplerKTick+0x436>
 8017512:	bf00      	nop
 8017514:	20000224 	.word	0x20000224
 8017518:	20002cb8 	.word	0x20002cb8
 801751c:	200181b0 	.word	0x200181b0
 8017520:	200187dc 	.word	0x200187dc
 8017524:	200194e8 	.word	0x200194e8
 8017528:	2000060c 	.word	0x2000060c
 801752c:	00000000 	.word	0x00000000
 8017530:	38d1b717 	.word	0x38d1b717
 8017534:	457a0000 	.word	0x457a0000
 8017538:	200172ec 	.word	0x200172ec
 801753c:	2001788c 	.word	0x2001788c
 8017540:	20002bf4 	.word	0x20002bf4
 8017544:	200034d4 	.word	0x200034d4
 8017548:	200174c8 	.word	0x200174c8
 801754c:	20018198 	.word	0x20018198
 8017550:	20002828 	.word	0x20002828
 8017554:	20002910 	.word	0x20002910
 8017558:	200177c4 	.word	0x200177c4

0801755c <SFXSamplerKFree>:
        {
 801755c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801755e:	2400      	movs	r4, #0
 8017560:	4f07      	ldr	r7, [pc, #28]	; (8017580 <SFXSamplerKFree+0x24>)
 8017562:	4e08      	ldr	r6, [pc, #32]	; (8017584 <SFXSamplerKFree+0x28>)
 8017564:	4d08      	ldr	r5, [pc, #32]	; (8017588 <SFXSamplerKFree+0x2c>)
                tBuffer_free(&keyBuff[i]);
 8017566:	1938      	adds	r0, r7, r4
 8017568:	f00e feac 	bl	80262c4 <tBuffer_free>
                tSampler_free(&keySampler[i]);
 801756c:	1930      	adds	r0, r6, r4
 801756e:	f00e ff57 	bl	8026420 <tSampler_free>
                tExpSmooth_free(&kSamplerGains[i]);
 8017572:	1928      	adds	r0, r5, r4
 8017574:	3404      	adds	r4, #4
 8017576:	f00a ffed 	bl	8022554 <tExpSmooth_free>
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 801757a:	2cc4      	cmp	r4, #196	; 0xc4
 801757c:	d1f3      	bne.n	8017566 <SFXSamplerKFree+0xa>
        }
 801757e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8017580:	200181b0 	.word	0x200181b0
 8017584:	200034d4 	.word	0x200034d4
 8017588:	20002634 	.word	0x20002634

0801758c <SFXSamplerAutoAlloc>:
        {
 801758c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
 8017590:	4c34      	ldr	r4, [pc, #208]	; (8017664 <SFXSamplerAutoAlloc+0xd8>)
 8017592:	f8df 8118 	ldr.w	r8, [pc, #280]	; 80176ac <SFXSamplerAutoAlloc+0x120>
 8017596:	4f34      	ldr	r7, [pc, #208]	; (8017668 <SFXSamplerAutoAlloc+0xdc>)
            tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
 8017598:	1d25      	adds	r5, r4, #4
            tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
 801759a:	4642      	mov	r2, r8
 801759c:	4620      	mov	r0, r4
 801759e:	4639      	mov	r1, r7
            tSampler_init(&asSampler[0], &asBuff[0]);
 80175a0:	4e32      	ldr	r6, [pc, #200]	; (801766c <SFXSamplerAutoAlloc+0xe0>)
            tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
 80175a2:	f00e fe77 	bl	8026294 <tBuffer_initToPool>
            tBuffer_setRecordMode(&asBuff[0], RecordOneShot);
 80175a6:	4620      	mov	r0, r4
 80175a8:	2100      	movs	r1, #0
 80175aa:	f00e fed9 	bl	8026360 <tBuffer_setRecordMode>
            tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
 80175ae:	4642      	mov	r2, r8
 80175b0:	4639      	mov	r1, r7
 80175b2:	4628      	mov	r0, r5
 80175b4:	f00e fe6e 	bl	8026294 <tBuffer_initToPool>
            tBuffer_setRecordMode(&asBuff[1], RecordOneShot);
 80175b8:	4628      	mov	r0, r5
 80175ba:	2100      	movs	r1, #0
            tSampler_init(&asSampler[1], &asBuff[1]);
 80175bc:	1d37      	adds	r7, r6, #4
            tBuffer_setRecordMode(&asBuff[1], RecordOneShot);
 80175be:	f00e fecf 	bl	8026360 <tBuffer_setRecordMode>
            tSampler_init(&asSampler[0], &asBuff[0]);
 80175c2:	4621      	mov	r1, r4
 80175c4:	4630      	mov	r0, r6
            randLengthVal = leaf.random() * 10000.0f;
 80175c6:	4c2a      	ldr	r4, [pc, #168]	; (8017670 <SFXSamplerAutoAlloc+0xe4>)
            tSampler_init(&asSampler[0], &asBuff[0]);
 80175c8:	f00e feda 	bl	8026380 <tSampler_init>
            tSampler_setMode(&asSampler[0], PlayLoop);
 80175cc:	4630      	mov	r0, r6
 80175ce:	2101      	movs	r1, #1
 80175d0:	f00e ff32 	bl	8026438 <tSampler_setMode>
            tSampler_init(&asSampler[1], &asBuff[1]);
 80175d4:	4629      	mov	r1, r5
 80175d6:	4638      	mov	r0, r7
            currentSampler = 1;
 80175d8:	2501      	movs	r5, #1
            tSampler_init(&asSampler[1], &asBuff[1]);
 80175da:	f00e fed1 	bl	8026380 <tSampler_init>
            tSampler_setMode(&asSampler[1], PlayLoop);
 80175de:	2101      	movs	r1, #1
 80175e0:	4638      	mov	r0, r7
 80175e2:	f00e ff29 	bl	8026438 <tSampler_setMode>
            tEnvelopeFollower_init(&envfollow, 0.00001f, 0.9999f);
 80175e6:	eddf 0a23 	vldr	s1, [pc, #140]	; 8017674 <SFXSamplerAutoAlloc+0xe8>
 80175ea:	ed9f 0a23 	vldr	s0, [pc, #140]	; 8017678 <SFXSamplerAutoAlloc+0xec>
 80175ee:	4823      	ldr	r0, [pc, #140]	; (801767c <SFXSamplerAutoAlloc+0xf0>)
 80175f0:	f007 f97e 	bl	801e8f0 <tEnvelopeFollower_init>
            tExpSmooth_init(&cfxSmooth, 0.0f, 0.01f);
 80175f4:	eddf 0a22 	vldr	s1, [pc, #136]	; 8017680 <SFXSamplerAutoAlloc+0xf4>
 80175f8:	ed9f 0a22 	vldr	s0, [pc, #136]	; 8017684 <SFXSamplerAutoAlloc+0xf8>
 80175fc:	4822      	ldr	r0, [pc, #136]	; (8017688 <SFXSamplerAutoAlloc+0xfc>)
 80175fe:	f00a ff59 	bl	80224b4 <tExpSmooth_init>
            setLED_A(samplerMode == PlayBackAndForth);
 8017602:	4b22      	ldr	r3, [pc, #136]	; (801768c <SFXSamplerAutoAlloc+0x100>)
 8017604:	7818      	ldrb	r0, [r3, #0]
 8017606:	f1a0 0002 	sub.w	r0, r0, #2
 801760a:	fab0 f080 	clz	r0, r0
 801760e:	0940      	lsrs	r0, r0, #5
 8017610:	f7fc f99c 	bl	801394c <setLED_A>
            setLED_B(triggerChannel);
 8017614:	4b1e      	ldr	r3, [pc, #120]	; (8017690 <SFXSamplerAutoAlloc+0x104>)
 8017616:	6818      	ldr	r0, [r3, #0]
 8017618:	f7fc f9a6 	bl	8013968 <setLED_B>
            currentSampler = 1;
 801761c:	481d      	ldr	r0, [pc, #116]	; (8017694 <SFXSamplerAutoAlloc+0x108>)
            sample_countdown = 0;
 801761e:	4a1e      	ldr	r2, [pc, #120]	; (8017698 <SFXSamplerAutoAlloc+0x10c>)
 8017620:	2100      	movs	r1, #0
            currentSampler = 1;
 8017622:	6005      	str	r5, [r0, #0]
            randLengthVal = leaf.random() * 10000.0f;
 8017624:	6923      	ldr	r3, [r4, #16]
            sample_countdown = 0;
 8017626:	6011      	str	r1, [r2, #0]
            randLengthVal = leaf.random() * 10000.0f;
 8017628:	4798      	blx	r3
 801762a:	eddf 7a1c 	vldr	s15, [pc, #112]	; 801769c <SFXSamplerAutoAlloc+0x110>
 801762e:	4a1c      	ldr	r2, [pc, #112]	; (80176a0 <SFXSamplerAutoAlloc+0x114>)
 8017630:	ee20 0a27 	vmul.f32	s0, s0, s15
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
 8017634:	6923      	ldr	r3, [r4, #16]
            randLengthVal = leaf.random() * 10000.0f;
 8017636:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 801763a:	ed82 0a00 	vstr	s0, [r2]
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
 801763e:	4798      	blx	r3
 8017640:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8017644:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
            setLED_C(pitchQuantization);
 8017648:	4a16      	ldr	r2, [pc, #88]	; (80176a4 <SFXSamplerAutoAlloc+0x118>)
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
 801764a:	4b17      	ldr	r3, [pc, #92]	; (80176a8 <SFXSamplerAutoAlloc+0x11c>)
 801764c:	ee30 0a67 	vsub.f32	s0, s0, s15
            setLED_C(pitchQuantization);
 8017650:	6810      	ldr	r0, [r2, #0]
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
 8017652:	ee20 0a07 	vmul.f32	s0, s0, s14
 8017656:	ed83 0a00 	vstr	s0, [r3]
        }
 801765a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            setLED_C(pitchQuantization);
 801765e:	f7fc b991 	b.w	8013984 <setLED_C>
 8017662:	bf00      	nop
 8017664:	200174a8 	.word	0x200174a8
 8017668:	0002ee00 	.word	0x0002ee00
 801766c:	200177b0 	.word	0x200177b0
 8017670:	200194e8 	.word	0x200194e8
 8017674:	3f7ff972 	.word	0x3f7ff972
 8017678:	3727c5ac 	.word	0x3727c5ac
 801767c:	200183b0 	.word	0x200183b0
 8017680:	3c23d70a 	.word	0x3c23d70a
 8017684:	00000000 	.word	0x00000000
 8017688:	20017200 	.word	0x20017200
 801768c:	200002b0 	.word	0x200002b0
 8017690:	20000620 	.word	0x20000620
 8017694:	20000584 	.word	0x20000584
 8017698:	20000618 	.word	0x20000618
 801769c:	461c4000 	.word	0x461c4000
 80176a0:	200005fc 	.word	0x200005fc
 80176a4:	200005ec 	.word	0x200005ec
 80176a8:	20000600 	.word	0x20000600
 80176ac:	200174b8 	.word	0x200174b8

080176b0 <SFXSamplerAutoFrame>:
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 80176b0:	4b07      	ldr	r3, [pc, #28]	; (80176d0 <SFXSamplerAutoFrame+0x20>)
 80176b2:	7f1a      	ldrb	r2, [r3, #28]
 80176b4:	2a01      	cmp	r2, #1
 80176b6:	d000      	beq.n	80176ba <SFXSamplerAutoFrame+0xa>
        }
 80176b8:	4770      	bx	lr
                pitchQuantization = !pitchQuantization;
 80176ba:	4906      	ldr	r1, [pc, #24]	; (80176d4 <SFXSamplerAutoFrame+0x24>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 80176bc:	2000      	movs	r0, #0
                pitchQuantization = !pitchQuantization;
 80176be:	680a      	ldr	r2, [r1, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 80176c0:	7718      	strb	r0, [r3, #28]
                pitchQuantization = !pitchQuantization;
 80176c2:	fab2 f282 	clz	r2, r2
 80176c6:	0952      	lsrs	r2, r2, #5
                setLED_C(pitchQuantization);
 80176c8:	4610      	mov	r0, r2
                pitchQuantization = !pitchQuantization;
 80176ca:	600a      	str	r2, [r1, #0]
                setLED_C(pitchQuantization);
 80176cc:	f7fc b95a 	b.w	8013984 <setLED_C>
 80176d0:	2001872c 	.word	0x2001872c
 80176d4:	200005ec 	.word	0x200005ec

080176d8 <SFXSamplerAutoTick>:
        {
 80176d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (triggerChannel > 0)
 80176dc:	f8df 93c8 	ldr.w	r9, [pc, #968]	; 8017aa8 <SFXSamplerAutoTick+0x3d0>
        {
 80176e0:	4604      	mov	r4, r0
            samp_thresh = 1.0f - knobs[0];
 80176e2:	f8df 83c8 	ldr.w	r8, [pc, #968]	; 8017aac <SFXSamplerAutoTick+0x3d4>
            if (triggerChannel > 0)
 80176e6:	f8d9 3000 	ldr.w	r3, [r9]
            if (pitchQuantization)
 80176ea:	4ed5      	ldr	r6, [pc, #852]	; (8017a40 <SFXSamplerAutoTick+0x368>)
            if (triggerChannel > 0)
 80176ec:	2b00      	cmp	r3, #0
                currentPower = tEnvelopeFollower_tick(&envfollow, input[1]);
 80176ee:	4dd5      	ldr	r5, [pc, #852]	; (8017a44 <SFXSamplerAutoTick+0x36c>)
        {
 80176f0:	ed2d 8b06 	vpush	{d8-d10}
                currentPower = tEnvelopeFollower_tick(&envfollow, input[0]);
 80176f4:	bfc8      	it	gt
 80176f6:	ed90 0a00 	vldrgt	s0, [r0]
        {
 80176fa:	b089      	sub	sp, #36	; 0x24
                currentPower = tEnvelopeFollower_tick(&envfollow, input[1]);
 80176fc:	bfd8      	it	le
 80176fe:	ed90 0a01 	vldrle	s0, [r0, #4]
 8017702:	48d1      	ldr	r0, [pc, #836]	; (8017a48 <SFXSamplerAutoTick+0x370>)
 8017704:	f007 f914 	bl	801e930 <tEnvelopeFollower_tick>
            samp_thresh = 1.0f - knobs[0];
 8017708:	4ad0      	ldr	r2, [pc, #832]	; (8017a4c <SFXSamplerAutoTick+0x374>)
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 801770a:	4bd1      	ldr	r3, [pc, #836]	; (8017a50 <SFXSamplerAutoTick+0x378>)
            samp_thresh = 1.0f - knobs[0];
 801770c:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 8017710:	edd2 6ab0 	vldr	s13, [r2, #704]	; 0x2c0
 8017714:	eef6 4a00 	vmov.f32	s9, #96	; 0x3f000000  0.5
 8017718:	edd3 7a00 	vldr	s15, [r3]
 801771c:	49cd      	ldr	r1, [pc, #820]	; (8017a54 <SFXSamplerAutoTick+0x37c>)
 801771e:	ee66 6aa7 	vmul.f32	s13, s13, s15
 8017722:	ed9f 5acd 	vldr	s10, [pc, #820]	; 8017a58 <SFXSamplerAutoTick+0x380>
 8017726:	ed9f 7acd 	vldr	s14, [pc, #820]	; 8017a5c <SFXSamplerAutoTick+0x384>
 801772a:	edd2 7ab2 	vldr	s15, [r2, #712]	; 0x2c8
 801772e:	eefd 6ae6 	vcvt.s32.f32	s13, s13
            samp_thresh = 1.0f - knobs[0];
 8017732:	ed92 6aaf 	vldr	s12, [r2, #700]	; 0x2bc
 8017736:	ee67 7a87 	vmul.f32	s15, s15, s14
            displayValues[0] = samp_thresh;
 801773a:	4bc9      	ldr	r3, [pc, #804]	; (8017a60 <SFXSamplerAutoTick+0x388>)
            samp_thresh = 1.0f - knobs[0];
 801773c:	ee35 6ac6 	vsub.f32	s12, s11, s12
 8017740:	ed92 7ab1 	vldr	s14, [r2, #708]	; 0x2c4
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 8017744:	ee16 0a90 	vmov	r0, s13
 8017748:	ed92 9ab4 	vldr	s18, [r2, #720]	; 0x2d0
 801774c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
                currentPower = tEnvelopeFollower_tick(&envfollow, input[1]);
 8017750:	ed85 0a00 	vstr	s0, [r5]
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 8017754:	eb01 0180 	add.w	r1, r1, r0, lsl #2
            displayValues[0] = samp_thresh;
 8017758:	ed83 6a00 	vstr	s12, [r3]
            samp_thresh = 1.0f - knobs[0];
 801775c:	ed88 6a00 	vstr	s12, [r8]
 8017760:	ee37 7a64 	vsub.f32	s14, s14, s9
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 8017764:	edd1 0a00 	vldr	s1, [r1]
 8017768:	eef8 6ae7 	vcvt.f32.s32	s13, s15
            if (pitchQuantization)
 801776c:	6831      	ldr	r1, [r6, #0]
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 801776e:	ee60 0a85 	vmul.f32	s1, s1, s10
 8017772:	ed9f 5abc 	vldr	s10, [pc, #752]	; 8017a64 <SFXSamplerAutoTick+0x38c>
 8017776:	ee29 9a05 	vmul.f32	s18, s18, s10
 801777a:	eefd 8ae0 	vcvt.s32.f32	s17, s1
            displayValues[1] = window_size;
 801777e:	eeb8 6ae8 	vcvt.f32.s32	s12, s17
 8017782:	ed83 6a01 	vstr	s12, [r3, #4]
            if (pitchQuantization)
 8017786:	b349      	cbz	r1, 80177dc <SFXSamplerAutoTick+0x104>
                rate = roundf((knobs[2] - 0.5f) * 14.0f);
 8017788:	eeb2 5a0c 	vmov.f32	s10, #44	; 0x41600000  14.0
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801778c:	ed9f 6ab6 	vldr	s12, [pc, #728]	; 8017a68 <SFXSamplerAutoTick+0x390>
                rate = roundf((knobs[2] - 0.5f) * 14.0f);
 8017790:	ee27 7a05 	vmul.f32	s14, s14, s10
 8017794:	feb8 7a47 	vrinta.f32	s14, s14
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 8017798:	eeb4 7ac6 	vcmpe.f32	s14, s12
 801779c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80177a0:	f100 819c 	bmi.w	8017adc <SFXSamplerAutoTick+0x404>
                else rate += 1.0f;
 80177a4:	ee77 9a25 	vadd.f32	s19, s14, s11
            crossfadeLength = knobs[3] * 1000.0f;
 80177a8:	4fb0      	ldr	r7, [pc, #704]	; (8017a6c <SFXSamplerAutoTick+0x394>)
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 80177aa:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
            displayValues[3] = crossfadeLength;
 80177ae:	edc3 6a03 	vstr	s13, [r3, #12]
            crossfadeLength = knobs[3] * 1000.0f;
 80177b2:	edc7 7a00 	vstr	s15, [r7]
            displayValues[2] = rate;
 80177b6:	edc3 9a02 	vstr	s19, [r3, #8]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 80177ba:	eeb4 9ac7 	vcmpe.f32	s18, s14
 80177be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80177c2:	f100 81a2 	bmi.w	8017b0a <SFXSamplerAutoTick+0x432>
            displayValues[5] = randLengthAmount;
 80177c6:	ed83 9a05 	vstr	s18, [r3, #20]
                randRateAmount = roundf(knobs[6] * 8.0f);
 80177ca:	eeb2 0a00 	vmov.f32	s0, #32	; 0x41000000  8.0
 80177ce:	ed92 8ab5 	vldr	s16, [r2, #724]	; 0x2d4
 80177d2:	ee28 8a00 	vmul.f32	s16, s16, s0
 80177d6:	feb8 8a48 	vrinta.f32	s16, s16
 80177da:	e025      	b.n	8017828 <SFXSamplerAutoTick+0x150>
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 80177dc:	eeb3 6a04 	vmov.f32	s12, #52	; 0x41a00000  20.0
            crossfadeLength = knobs[3] * 1000.0f;
 80177e0:	4fa2      	ldr	r7, [pc, #648]	; (8017a6c <SFXSamplerAutoTick+0x394>)
                rate = (knobs[2] - 0.5f) * 4.0f;
 80177e2:	eef1 9a00 	vmov.f32	s19, #16	; 0x40800000  4.0
            displayValues[3] = crossfadeLength;
 80177e6:	edc3 6a03 	vstr	s13, [r3, #12]
            crossfadeLength = knobs[3] * 1000.0f;
 80177ea:	edc7 7a00 	vstr	s15, [r7]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 80177ee:	eeb4 9ac6 	vcmpe.f32	s18, s12
                rate = (knobs[2] - 0.5f) * 4.0f;
 80177f2:	ee67 9a29 	vmul.f32	s19, s14, s19
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 80177f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            displayValues[2] = rate;
 80177fa:	edc3 9a02 	vstr	s19, [r3, #8]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 80177fe:	f100 80d9 	bmi.w	80179b4 <SFXSamplerAutoTick+0x2dc>
            displayValues[5] = randLengthAmount;
 8017802:	ed83 9a05 	vstr	s18, [r3, #20]
                randRateAmount = knobs[6] * 2.0f;
 8017806:	ed92 8ab5 	vldr	s16, [r2, #724]	; 0x2d4
                if (randRateAmount < 0.01) randRateAmount = 0.0f;
 801780a:	ed9f 7a97 	vldr	s14, [pc, #604]	; 8017a68 <SFXSamplerAutoTick+0x390>
                randRateAmount = knobs[6] * 2.0f;
 801780e:	ee38 8a08 	vadd.f32	s16, s16, s16
                if (randRateAmount < 0.01) randRateAmount = 0.0f;
 8017812:	ed9f 6b89 	vldr	d6, [pc, #548]	; 8017a38 <SFXSamplerAutoTick+0x360>
 8017816:	eeb7 5ac8 	vcvt.f64.f32	d5, s16
 801781a:	eeb4 5b46 	vcmp.f64	d5, d6
 801781e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017822:	bf48      	it	mi
 8017824:	eeb0 8a47 	vmovmi.f32	s16, s14
            tSampler_setCrossfadeLength(&asSampler[0], crossfadeLength);
 8017828:	ee17 1a90 	vmov	r1, s15
 801782c:	4890      	ldr	r0, [pc, #576]	; (8017a70 <SFXSamplerAutoTick+0x398>)
            displayValues[6] = randRateAmount;
 801782e:	ed83 8a06 	vstr	s16, [r3, #24]
            tSampler_setCrossfadeLength(&asSampler[0], crossfadeLength);
 8017832:	f00e fe05 	bl	8026440 <tSampler_setCrossfadeLength>
            tSampler_setCrossfadeLength(&asSampler[1], crossfadeLength);
 8017836:	6839      	ldr	r1, [r7, #0]
 8017838:	488e      	ldr	r0, [pc, #568]	; (8017a74 <SFXSamplerAutoTick+0x39c>)
 801783a:	f00e fe01 	bl	8026440 <tSampler_setCrossfadeLength>
            if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
 801783e:	ed95 7a00 	vldr	s14, [r5]
 8017842:	edd8 7a00 	vldr	s15, [r8]
 8017846:	f8df a268 	ldr.w	sl, [pc, #616]	; 8017ab0 <SFXSamplerAutoTick+0x3d8>
 801784a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801784e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017852:	f340 80b4 	ble.w	80179be <SFXSamplerAutoTick+0x2e6>
 8017856:	edda 7a00 	vldr	s15, [sl]
 801785a:	eddf 6a87 	vldr	s13, [pc, #540]	; 8017a78 <SFXSamplerAutoTick+0x3a0>
 801785e:	ed95 7a00 	vldr	s14, [r5]
 8017862:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8017866:	eef4 7ac7 	vcmpe.f32	s15, s14
 801786a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801786e:	f140 80a6 	bpl.w	80179be <SFXSamplerAutoTick+0x2e6>
 8017872:	4f82      	ldr	r7, [pc, #520]	; (8017a7c <SFXSamplerAutoTick+0x3a4>)
 8017874:	f8df b23c 	ldr.w	fp, [pc, #572]	; 8017ab4 <SFXSamplerAutoTick+0x3dc>
 8017878:	683b      	ldr	r3, [r7, #0]
 801787a:	2b00      	cmp	r3, #0
 801787c:	f000 814a 	beq.w	8017b14 <SFXSamplerAutoTick+0x43c>
 8017880:	4b7f      	ldr	r3, [pc, #508]	; (8017a80 <SFXSamplerAutoTick+0x3a8>)
 8017882:	f8df 8234 	ldr.w	r8, [pc, #564]	; 8017ab8 <SFXSamplerAutoTick+0x3e0>
 8017886:	9301      	str	r3, [sp, #4]
 8017888:	4f7e      	ldr	r7, [pc, #504]	; (8017a84 <SFXSamplerAutoTick+0x3ac>)
 801788a:	4b79      	ldr	r3, [pc, #484]	; (8017a70 <SFXSamplerAutoTick+0x398>)
 801788c:	9302      	str	r3, [sp, #8]
            tBuffer_tick(&asBuff[0], input[1]);
 801788e:	ed94 0a01 	vldr	s0, [r4, #4]
 8017892:	487d      	ldr	r0, [pc, #500]	; (8017a88 <SFXSamplerAutoTick+0x3b0>)
 8017894:	f00e fd22 	bl	80262dc <tBuffer_tick>
            tBuffer_tick(&asBuff[1], input[1]);
 8017898:	ed94 0a01 	vldr	s0, [r4, #4]
 801789c:	487b      	ldr	r0, [pc, #492]	; (8017a8c <SFXSamplerAutoTick+0x3b4>)
 801789e:	f00e fd1d 	bl	80262dc <tBuffer_tick>
            if (sample_countdown > 0)
 80178a2:	f8db 2000 	ldr.w	r2, [fp]
 80178a6:	2a00      	cmp	r2, #0
 80178a8:	f000 808c 	beq.w	80179c4 <SFXSamplerAutoTick+0x2ec>
                sample_countdown--;
 80178ac:	3a01      	subs	r2, #1
 80178ae:	f8cb 2000 	str.w	r2, [fp]
            if (pitchQuantization)
 80178b2:	6833      	ldr	r3, [r6, #0]
 80178b4:	ed98 0a00 	vldr	s0, [r8]
 80178b8:	2b00      	cmp	r3, #0
 80178ba:	f000 80b0 	beq.w	8017a1e <SFXSamplerAutoTick+0x346>
                tSampler_setRate(&asSampler[0], rate * randRateVal);
 80178be:	ee29 0a80 	vmul.f32	s0, s19, s0
 80178c2:	486b      	ldr	r0, [pc, #428]	; (8017a70 <SFXSamplerAutoTick+0x398>)
 80178c4:	f00f faec 	bl	8026ea0 <tSampler_setRate>
                tSampler_setRate(&asSampler[1], rate * randRateVal);
 80178c8:	ed98 0a00 	vldr	s0, [r8]
 80178cc:	4869      	ldr	r0, [pc, #420]	; (8017a74 <SFXSamplerAutoTick+0x39c>)
 80178ce:	ee29 0a80 	vmul.f32	s0, s19, s0
 80178d2:	f00f fae5 	bl	8026ea0 <tSampler_setRate>
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 80178d6:	9b01      	ldr	r3, [sp, #4]
 80178d8:	ee18 2a90 	vmov	r2, s17
 80178dc:	ed9f 1a5e 	vldr	s2, [pc, #376]	; 8017a58 <SFXSamplerAutoTick+0x380>
 80178e0:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 80178e4:	681b      	ldr	r3, [r3, #0]
            if (buttonActionsSFX[ButtonA][ActionPress])
 80178e6:	4e6a      	ldr	r6, [pc, #424]	; (8017a90 <SFXSamplerAutoTick+0x3b8>)
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 80178e8:	441a      	add	r2, r3
 80178ea:	ee00 2a90 	vmov	s1, r2
 80178ee:	eef8 0ae0 	vcvt.f32.s32	s1, s1
 80178f2:	f00c fadf 	bl	8023eb4 <LEAF_clip>
 80178f6:	eefd 7ac0 	vcvt.s32.f32	s15, s0
            tSampler_setEnd(&asSampler[0], finalWindowSize);
 80178fa:	485d      	ldr	r0, [pc, #372]	; (8017a70 <SFXSamplerAutoTick+0x398>)
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 80178fc:	ee17 1a90 	vmov	r1, s15
 8017900:	edc7 7a00 	vstr	s15, [r7]
            tSampler_setEnd(&asSampler[0], finalWindowSize);
 8017904:	f00e fea4 	bl	8026650 <tSampler_setEnd>
            tSampler_setEnd(&asSampler[1], finalWindowSize);
 8017908:	6839      	ldr	r1, [r7, #0]
 801790a:	485a      	ldr	r0, [pc, #360]	; (8017a74 <SFXSamplerAutoTick+0x39c>)
 801790c:	f00e fea0 	bl	8026650 <tSampler_setEnd>
            if (buttonActionsSFX[ButtonA][ActionPress])
 8017910:	7d33      	ldrb	r3, [r6, #20]
 8017912:	b14b      	cbz	r3, 8017928 <SFXSamplerAutoTick+0x250>
                if (samplerMode == PlayLoop)
 8017914:	f8df 81a4 	ldr.w	r8, [pc, #420]	; 8017abc <SFXSamplerAutoTick+0x3e4>
 8017918:	f898 7000 	ldrb.w	r7, [r8]
 801791c:	2f01      	cmp	r7, #1
 801791e:	f000 815d 	beq.w	8017bdc <SFXSamplerAutoTick+0x504>
                else if (samplerMode == PlayBackAndForth)
 8017922:	2f02      	cmp	r7, #2
 8017924:	f000 816b 	beq.w	8017bfe <SFXSamplerAutoTick+0x526>
            if (buttonActionsSFX[ButtonB][ActionPress])
 8017928:	7e33      	ldrb	r3, [r6, #24]
 801792a:	2b00      	cmp	r3, #0
 801792c:	f040 80c8 	bne.w	8017ac0 <SFXSamplerAutoTick+0x3e8>
            float fade = tExpSmooth_tick(&cfxSmooth);
 8017930:	4e58      	ldr	r6, [pc, #352]	; (8017a94 <SFXSamplerAutoTick+0x3bc>)
 8017932:	4630      	mov	r0, r6
 8017934:	f00a fe2e 	bl	8022594 <tExpSmooth_tick>
            if (fabsf(cfxSmooth->curr - cfxSmooth->dest) < 0.00001f)
 8017938:	6833      	ldr	r3, [r6, #0]
 801793a:	ed9f 7a57 	vldr	s14, [pc, #348]	; 8017a98 <SFXSamplerAutoTick+0x3c0>
 801793e:	edd3 7a03 	vldr	s15, [r3, #12]
 8017942:	edd3 6a04 	vldr	s13, [r3, #16]
 8017946:	ee77 7ae6 	vsub.f32	s15, s15, s13
 801794a:	eef0 7ae7 	vabs.f32	s15, s15
 801794e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8017952:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017956:	d502      	bpl.n	801795e <SFXSamplerAutoTick+0x286>
                fadeDone = 1;
 8017958:	4b50      	ldr	r3, [pc, #320]	; (8017a9c <SFXSamplerAutoTick+0x3c4>)
 801795a:	2201      	movs	r2, #1
 801795c:	601a      	str	r2, [r3, #0]
            LEAF_crossfade((fade * 2.0f) - 1.0f, volumes);
 801795e:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 8017962:	a806      	add	r0, sp, #24
 8017964:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8017968:	eee0 7a07 	vfma.f32	s15, s0, s14
 801796c:	eeb0 0a67 	vmov.f32	s0, s15
 8017970:	f00c fa1c 	bl	8023dac <LEAF_crossfade>
            sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
 8017974:	483e      	ldr	r0, [pc, #248]	; (8017a70 <SFXSamplerAutoTick+0x398>)
 8017976:	f00e ff01 	bl	802677c <tSampler_tick>
 801797a:	483e      	ldr	r0, [pc, #248]	; (8017a74 <SFXSamplerAutoTick+0x39c>)
 801797c:	eef0 8a40 	vmov.f32	s17, s0
 8017980:	ed9d 8a07 	vldr	s16, [sp, #28]
 8017984:	f00e fefa 	bl	802677c <tSampler_tick>
 8017988:	eddd 7a06 	vldr	s15, [sp, #24]
            input[0] = sample * 0.99f;
 801798c:	ed9f 7a44 	vldr	s14, [pc, #272]	; 8017aa0 <SFXSamplerAutoTick+0x3c8>
            sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
 8017990:	ee20 0a27 	vmul.f32	s0, s0, s15
            previousPower = currentPower;
 8017994:	682b      	ldr	r3, [r5, #0]
 8017996:	f8ca 3000 	str.w	r3, [sl]
            sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
 801799a:	eea8 0a88 	vfma.f32	s0, s17, s16
            input[0] = sample * 0.99f;
 801799e:	ee20 0a07 	vmul.f32	s0, s0, s14
 80179a2:	ed84 0a00 	vstr	s0, [r4]
            input[1] = sample * 0.99f;
 80179a6:	ed84 0a01 	vstr	s0, [r4, #4]
        }
 80179aa:	b009      	add	sp, #36	; 0x24
 80179ac:	ecbd 8b06 	vpop	{d8-d10}
 80179b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            displayValues[5] = randLengthAmount;
 80179b4:	ed9f 9a2c 	vldr	s18, [pc, #176]	; 8017a68 <SFXSamplerAutoTick+0x390>
 80179b8:	ed83 9a05 	vstr	s18, [r3, #20]
 80179bc:	e723      	b.n	8017806 <SFXSamplerAutoTick+0x12e>
 80179be:	f8df b0f4 	ldr.w	fp, [pc, #244]	; 8017ab4 <SFXSamplerAutoTick+0x3dc>
 80179c2:	e75d      	b.n	8017880 <SFXSamplerAutoTick+0x1a8>
            else if (samp_triggered == 1)
 80179c4:	4b2d      	ldr	r3, [pc, #180]	; (8017a7c <SFXSamplerAutoTick+0x3a4>)
 80179c6:	6819      	ldr	r1, [r3, #0]
 80179c8:	2901      	cmp	r1, #1
 80179ca:	f47f af72 	bne.w	80178b2 <SFXSamplerAutoTick+0x1da>
                currentSampler = !currentSampler;
 80179ce:	4935      	ldr	r1, [pc, #212]	; (8017aa4 <SFXSamplerAutoTick+0x3cc>)
                setLED_1(0);
 80179d0:	4610      	mov	r0, r2
 80179d2:	9203      	str	r2, [sp, #12]
 80179d4:	9305      	str	r3, [sp, #20]
                currentSampler = !currentSampler;
 80179d6:	9104      	str	r1, [sp, #16]
                setLED_1(0);
 80179d8:	f7fb ff98 	bl	801390c <setLED_1>
                currentSampler = !currentSampler;
 80179dc:	9904      	ldr	r1, [sp, #16]
                tSampler_play(&asSampler[currentSampler]);
 80179de:	9b02      	ldr	r3, [sp, #8]
                currentSampler = !currentSampler;
 80179e0:	6808      	ldr	r0, [r1, #0]
 80179e2:	9102      	str	r1, [sp, #8]
 80179e4:	fab0 fc80 	clz	ip, r0
 80179e8:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
                tSampler_play(&asSampler[currentSampler]);
 80179ec:	eb03 008c 	add.w	r0, r3, ip, lsl #2
                currentSampler = !currentSampler;
 80179f0:	f8c1 c000 	str.w	ip, [r1]
                tSampler_play(&asSampler[currentSampler]);
 80179f4:	f00e fd3a 	bl	802646c <tSampler_play>
                tExpSmooth_setDest(&cfxSmooth,(float)currentSampler);
 80179f8:	9902      	ldr	r1, [sp, #8]
 80179fa:	4826      	ldr	r0, [pc, #152]	; (8017a94 <SFXSamplerAutoTick+0x3bc>)
 80179fc:	ed91 0a00 	vldr	s0, [r1]
 8017a00:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8017a04:	f00a fdbc 	bl	8022580 <tExpSmooth_setDest>
                samp_triggered = 0;
 8017a08:	9a03      	ldr	r2, [sp, #12]
 8017a0a:	9b05      	ldr	r3, [sp, #20]
                fadeDone = 0;
 8017a0c:	4923      	ldr	r1, [pc, #140]	; (8017a9c <SFXSamplerAutoTick+0x3c4>)
                samp_triggered = 0;
 8017a0e:	601a      	str	r2, [r3, #0]
            if (pitchQuantization)
 8017a10:	6833      	ldr	r3, [r6, #0]
                fadeDone = 0;
 8017a12:	600a      	str	r2, [r1, #0]
 8017a14:	ed98 0a00 	vldr	s0, [r8]
            if (pitchQuantization)
 8017a18:	2b00      	cmp	r3, #0
 8017a1a:	f47f af50 	bne.w	80178be <SFXSamplerAutoTick+0x1e6>
                tSampler_setRate(&asSampler[0], rate + randRateVal);
 8017a1e:	ee39 0a80 	vadd.f32	s0, s19, s0
 8017a22:	4813      	ldr	r0, [pc, #76]	; (8017a70 <SFXSamplerAutoTick+0x398>)
 8017a24:	f00f fa3c 	bl	8026ea0 <tSampler_setRate>
                tSampler_setRate(&asSampler[1], rate + randRateVal);
 8017a28:	ed98 0a00 	vldr	s0, [r8]
 8017a2c:	4811      	ldr	r0, [pc, #68]	; (8017a74 <SFXSamplerAutoTick+0x39c>)
 8017a2e:	ee39 0a80 	vadd.f32	s0, s19, s0
 8017a32:	f00f fa35 	bl	8026ea0 <tSampler_setRate>
 8017a36:	e74e      	b.n	80178d6 <SFXSamplerAutoTick+0x1fe>
 8017a38:	47ae147b 	.word	0x47ae147b
 8017a3c:	3f847ae1 	.word	0x3f847ae1
 8017a40:	200005ec 	.word	0x200005ec
 8017a44:	20000580 	.word	0x20000580
 8017a48:	200183b0 	.word	0x200183b0
 8017a4c:	20002cb8 	.word	0x20002cb8
 8017a50:	2000023c 	.word	0x2000023c
 8017a54:	20016fec 	.word	0x20016fec
 8017a58:	483b8000 	.word	0x483b8000
 8017a5c:	447a0000 	.word	0x447a0000
 8017a60:	200187dc 	.word	0x200187dc
 8017a64:	459c4000 	.word	0x459c4000
 8017a68:	00000000 	.word	0x00000000
 8017a6c:	20000574 	.word	0x20000574
 8017a70:	200177b0 	.word	0x200177b0
 8017a74:	200177b4 	.word	0x200177b4
 8017a78:	3a83126f 	.word	0x3a83126f
 8017a7c:	20000608 	.word	0x20000608
 8017a80:	200005fc 	.word	0x200005fc
 8017a84:	20000240 	.word	0x20000240
 8017a88:	200174a8 	.word	0x200174a8
 8017a8c:	200174ac 	.word	0x200174ac
 8017a90:	2001872c 	.word	0x2001872c
 8017a94:	20017200 	.word	0x20017200
 8017a98:	3727c5ac 	.word	0x3727c5ac
 8017a9c:	20000594 	.word	0x20000594
 8017aa0:	3f7d70a4 	.word	0x3f7d70a4
 8017aa4:	20000584 	.word	0x20000584
 8017aa8:	20000620 	.word	0x20000620
 8017aac:	20000604 	.word	0x20000604
 8017ab0:	200005f8 	.word	0x200005f8
 8017ab4:	20000618 	.word	0x20000618
 8017ab8:	20000600 	.word	0x20000600
 8017abc:	200002b0 	.word	0x200002b0
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
 8017ac0:	f8d9 3000 	ldr.w	r3, [r9]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8017ac4:	2200      	movs	r2, #0
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
 8017ac6:	4293      	cmp	r3, r2
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8017ac8:	7632      	strb	r2, [r6, #24]
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
 8017aca:	bfcc      	ite	gt
 8017acc:	2300      	movgt	r3, #0
 8017ace:	2301      	movle	r3, #1
                setLED_B(triggerChannel);
 8017ad0:	4618      	mov	r0, r3
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
 8017ad2:	f8c9 3000 	str.w	r3, [r9]
                setLED_B(triggerChannel);
 8017ad6:	f7fb ff47 	bl	8013968 <setLED_B>
 8017ada:	e729      	b.n	8017930 <SFXSamplerAutoTick+0x258>
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 8017adc:	ee37 7a65 	vsub.f32	s14, s14, s11
            crossfadeLength = knobs[3] * 1000.0f;
 8017ae0:	4f56      	ldr	r7, [pc, #344]	; (8017c3c <SFXSamplerAutoTick+0x564>)
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 8017ae2:	eeb3 5a04 	vmov.f32	s10, #52	; 0x41a00000  20.0
            displayValues[3] = crossfadeLength;
 8017ae6:	edc3 6a03 	vstr	s13, [r3, #12]
            crossfadeLength = knobs[3] * 1000.0f;
 8017aea:	edc7 7a00 	vstr	s15, [r7]
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 8017aee:	eeb0 7ac7 	vabs.f32	s14, s14
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 8017af2:	eeb4 9a45 	vcmp.f32	s18, s10
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 8017af6:	eec5 9a87 	vdiv.f32	s19, s11, s14
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 8017afa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017afe:	bf48      	it	mi
 8017b00:	eeb0 9a46 	vmovmi.f32	s18, s12
            displayValues[2] = rate;
 8017b04:	edc3 9a02 	vstr	s19, [r3, #8]
 8017b08:	e65d      	b.n	80177c6 <SFXSamplerAutoTick+0xee>
            displayValues[5] = randLengthAmount;
 8017b0a:	ed83 6a05 	vstr	s12, [r3, #20]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 8017b0e:	eeb0 9a46 	vmov.f32	s18, s12
 8017b12:	e65a      	b.n	80177ca <SFXSamplerAutoTick+0xf2>
            if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
 8017b14:	f8db 2000 	ldr.w	r2, [fp]
 8017b18:	2a00      	cmp	r2, #0
 8017b1a:	f47f aeb1 	bne.w	8017880 <SFXSamplerAutoTick+0x1a8>
 8017b1e:	4a48      	ldr	r2, [pc, #288]	; (8017c40 <SFXSamplerAutoTick+0x568>)
 8017b20:	6812      	ldr	r2, [r2, #0]
 8017b22:	2a01      	cmp	r2, #1
 8017b24:	f47f aeac 	bne.w	8017880 <SFXSamplerAutoTick+0x1a8>
                randLengthVal = (leaf.random() - 0.5f) * randLengthAmount * 2.0f;
 8017b28:	f8df 8134 	ldr.w	r8, [pc, #308]	; 8017c60 <SFXSamplerAutoTick+0x588>
 8017b2c:	eeb6 aa00 	vmov.f32	s20, #96	; 0x3f000000  0.5
 8017b30:	4b44      	ldr	r3, [pc, #272]	; (8017c44 <SFXSamplerAutoTick+0x56c>)
 8017b32:	ee39 9a09 	vadd.f32	s18, s18, s18
 8017b36:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8017b3a:	9301      	str	r3, [sp, #4]
 8017b3c:	4790      	blx	r2
 8017b3e:	ee30 0a4a 	vsub.f32	s0, s0, s20
 8017b42:	9b01      	ldr	r3, [sp, #4]
                if (pitchQuantization) randRateVal = roundf(leaf.random() * randRateAmount) + 1.0f;
 8017b44:	6832      	ldr	r2, [r6, #0]
                randLengthVal = (leaf.random() - 0.5f) * randLengthAmount * 2.0f;
 8017b46:	ee20 0a09 	vmul.f32	s0, s0, s18
 8017b4a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8017b4e:	ed83 0a00 	vstr	s0, [r3]
                if (pitchQuantization) randRateVal = roundf(leaf.random() * randRateAmount) + 1.0f;
 8017b52:	2a00      	cmp	r2, #0
 8017b54:	d064      	beq.n	8017c20 <SFXSamplerAutoTick+0x548>
 8017b56:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8017b5a:	4790      	blx	r2
 8017b5c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8017b60:	ee60 7a08 	vmul.f32	s15, s0, s16
 8017b64:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8017c64 <SFXSamplerAutoTick+0x58c>
 8017b68:	fef8 7a67 	vrinta.f32	s15, s15
 8017b6c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8017b70:	edc8 7a00 	vstr	s15, [r8]
                samp_triggered = 1;
 8017b74:	2101      	movs	r1, #1
                tSampler_stop(&asSampler[!currentSampler]);
 8017b76:	4b34      	ldr	r3, [pc, #208]	; (8017c48 <SFXSamplerAutoTick+0x570>)
 8017b78:	4a34      	ldr	r2, [pc, #208]	; (8017c4c <SFXSamplerAutoTick+0x574>)
                setLED_1(1);
 8017b7a:	4608      	mov	r0, r1
                tSampler_stop(&asSampler[!currentSampler]);
 8017b7c:	9302      	str	r3, [sp, #8]
 8017b7e:	9203      	str	r2, [sp, #12]
                samp_triggered = 1;
 8017b80:	6039      	str	r1, [r7, #0]
                setLED_1(1);
 8017b82:	f7fb fec3 	bl	801390c <setLED_1>
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 8017b86:	9a01      	ldr	r2, [sp, #4]
 8017b88:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 8017b8c:	ed9f 1a30 	vldr	s2, [pc, #192]	; 8017c50 <SFXSamplerAutoTick+0x578>
 8017b90:	6811      	ldr	r1, [r2, #0]
 8017b92:	ee18 2a90 	vmov	r2, s17
 8017b96:	4f2f      	ldr	r7, [pc, #188]	; (8017c54 <SFXSamplerAutoTick+0x57c>)
 8017b98:	440a      	add	r2, r1
 8017b9a:	ee00 2a90 	vmov	s1, r2
 8017b9e:	eef8 0ae0 	vcvt.f32.s32	s1, s1
 8017ba2:	f00c f987 	bl	8023eb4 <LEAF_clip>
                tSampler_stop(&asSampler[!currentSampler]);
 8017ba6:	9a03      	ldr	r2, [sp, #12]
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 8017ba8:	eefd 7ac0 	vcvt.s32.f32	s15, s0
                tSampler_stop(&asSampler[!currentSampler]);
 8017bac:	9b02      	ldr	r3, [sp, #8]
 8017bae:	6810      	ldr	r0, [r2, #0]
 8017bb0:	fab0 f080 	clz	r0, r0
                sample_countdown = finalWindowSize;
 8017bb4:	edcb 7a00 	vstr	s15, [fp]
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 8017bb8:	edc7 7a00 	vstr	s15, [r7]
                tSampler_stop(&asSampler[!currentSampler]);
 8017bbc:	0940      	lsrs	r0, r0, #5
 8017bbe:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8017bc2:	f00e fca3 	bl	802650c <tSampler_stop>
                tBuffer_record(&asBuff[!currentSampler]);
 8017bc6:	9a03      	ldr	r2, [sp, #12]
 8017bc8:	4823      	ldr	r0, [pc, #140]	; (8017c58 <SFXSamplerAutoTick+0x580>)
 8017bca:	6812      	ldr	r2, [r2, #0]
 8017bcc:	fab2 f282 	clz	r2, r2
 8017bd0:	0952      	lsrs	r2, r2, #5
 8017bd2:	eb00 0082 	add.w	r0, r0, r2, lsl #2
 8017bd6:	f00e fbb1 	bl	802633c <tBuffer_record>
 8017bda:	e658      	b.n	801788e <SFXSamplerAutoTick+0x1b6>
                    tSampler_setMode(&asSampler[0], PlayBackAndForth);
 8017bdc:	2102      	movs	r1, #2
 8017bde:	481a      	ldr	r0, [pc, #104]	; (8017c48 <SFXSamplerAutoTick+0x570>)
 8017be0:	f00e fc2a 	bl	8026438 <tSampler_setMode>
                    tSampler_setMode(&asSampler[1], PlayBackAndForth);
 8017be4:	2102      	movs	r1, #2
 8017be6:	481d      	ldr	r0, [pc, #116]	; (8017c5c <SFXSamplerAutoTick+0x584>)
 8017be8:	f00e fc26 	bl	8026438 <tSampler_setMode>
                    samplerMode = PlayBackAndForth;
 8017bec:	2302      	movs	r3, #2
                    setLED_A(1);
 8017bee:	4638      	mov	r0, r7
                    samplerMode = PlayBackAndForth;
 8017bf0:	f888 3000 	strb.w	r3, [r8]
                    setLED_A(1);
 8017bf4:	f7fb feaa 	bl	801394c <setLED_A>
                    buttonActionsSFX[ButtonA][ActionPress] = 0;
 8017bf8:	2300      	movs	r3, #0
 8017bfa:	7533      	strb	r3, [r6, #20]
 8017bfc:	e694      	b.n	8017928 <SFXSamplerAutoTick+0x250>
                    tSampler_setMode(&asSampler[0], PlayLoop);
 8017bfe:	2101      	movs	r1, #1
 8017c00:	4811      	ldr	r0, [pc, #68]	; (8017c48 <SFXSamplerAutoTick+0x570>)
 8017c02:	f00e fc19 	bl	8026438 <tSampler_setMode>
                    tSampler_setMode(&asSampler[1], PlayLoop);
 8017c06:	2101      	movs	r1, #1
 8017c08:	4814      	ldr	r0, [pc, #80]	; (8017c5c <SFXSamplerAutoTick+0x584>)
 8017c0a:	f00e fc15 	bl	8026438 <tSampler_setMode>
                    samplerMode = PlayLoop;
 8017c0e:	2301      	movs	r3, #1
                    setLED_A(0);
 8017c10:	2000      	movs	r0, #0
                    samplerMode = PlayLoop;
 8017c12:	f888 3000 	strb.w	r3, [r8]
                    setLED_A(0);
 8017c16:	f7fb fe99 	bl	801394c <setLED_A>
                    buttonActionsSFX[ButtonA][ActionPress] = 0;
 8017c1a:	2300      	movs	r3, #0
 8017c1c:	7533      	strb	r3, [r6, #20]
 8017c1e:	e683      	b.n	8017928 <SFXSamplerAutoTick+0x250>
                else randRateVal = (leaf.random() - 0.5f) * randRateAmount * 2.0f;
 8017c20:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8017c24:	ee38 8a08 	vadd.f32	s16, s16, s16
 8017c28:	4790      	blx	r2
 8017c2a:	ee30 0a4a 	vsub.f32	s0, s0, s20
 8017c2e:	f8df 8034 	ldr.w	r8, [pc, #52]	; 8017c64 <SFXSamplerAutoTick+0x58c>
 8017c32:	ee20 8a08 	vmul.f32	s16, s0, s16
 8017c36:	ed88 8a00 	vstr	s16, [r8]
 8017c3a:	e79b      	b.n	8017b74 <SFXSamplerAutoTick+0x49c>
 8017c3c:	20000574 	.word	0x20000574
 8017c40:	20000594 	.word	0x20000594
 8017c44:	200005fc 	.word	0x200005fc
 8017c48:	200177b0 	.word	0x200177b0
 8017c4c:	20000584 	.word	0x20000584
 8017c50:	483b8000 	.word	0x483b8000
 8017c54:	20000240 	.word	0x20000240
 8017c58:	200174a8 	.word	0x200174a8
 8017c5c:	200177b4 	.word	0x200177b4
 8017c60:	200194e8 	.word	0x200194e8
 8017c64:	20000600 	.word	0x20000600

08017c68 <SFXSamplerAutoFree>:
        {
 8017c68:	b538      	push	{r3, r4, r5, lr}
            tBuffer_free(&asBuff[0]);
 8017c6a:	4d0b      	ldr	r5, [pc, #44]	; (8017c98 <SFXSamplerAutoFree+0x30>)
            tSampler_free(&asSampler[0]);
 8017c6c:	4c0b      	ldr	r4, [pc, #44]	; (8017c9c <SFXSamplerAutoFree+0x34>)
            tBuffer_free(&asBuff[0]);
 8017c6e:	4628      	mov	r0, r5
 8017c70:	f00e fb28 	bl	80262c4 <tBuffer_free>
            tBuffer_free(&asBuff[1]);
 8017c74:	1d28      	adds	r0, r5, #4
 8017c76:	f00e fb25 	bl	80262c4 <tBuffer_free>
            tSampler_free(&asSampler[0]);
 8017c7a:	4620      	mov	r0, r4
 8017c7c:	f00e fbd0 	bl	8026420 <tSampler_free>
            tSampler_free(&asSampler[1]);
 8017c80:	1d20      	adds	r0, r4, #4
 8017c82:	f00e fbcd 	bl	8026420 <tSampler_free>
            tEnvelopeFollower_free(&envfollow);
 8017c86:	4806      	ldr	r0, [pc, #24]	; (8017ca0 <SFXSamplerAutoFree+0x38>)
 8017c88:	f006 fe4e 	bl	801e928 <tEnvelopeFollower_free>
            tExpSmooth_free(&cfxSmooth);
 8017c8c:	4805      	ldr	r0, [pc, #20]	; (8017ca4 <SFXSamplerAutoFree+0x3c>)
        }
 8017c8e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            tExpSmooth_free(&cfxSmooth);
 8017c92:	f00a bc5f 	b.w	8022554 <tExpSmooth_free>
 8017c96:	bf00      	nop
 8017c98:	200174a8 	.word	0x200174a8
 8017c9c:	200177b0 	.word	0x200177b0
 8017ca0:	200183b0 	.word	0x200183b0
 8017ca4:	20017200 	.word	0x20017200

08017ca8 <SFXDistortionAlloc>:
        {
 8017ca8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            tOversampler_init(&oversampler, distOS_ratio, FALSE);
 8017cac:	4d26      	ldr	r5, [pc, #152]	; (8017d48 <SFXDistortionAlloc+0xa0>)
            leaf.clearOnAllocation = 1;
 8017cae:	2301      	movs	r3, #1
 8017cb0:	4c26      	ldr	r4, [pc, #152]	; (8017d4c <SFXDistortionAlloc+0xa4>)
            tOversampler_init(&oversampler, distOS_ratio, FALSE);
 8017cb2:	2200      	movs	r2, #0
            tVZFilter_init(&shelf1, Lowshelf, 80.0f, 6.0f);
 8017cb4:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 8017d70 <SFXDistortionAlloc+0xc8>
            tOversampler_init(&oversampler, distOS_ratio, FALSE);
 8017cb8:	6829      	ldr	r1, [r5, #0]
 8017cba:	4825      	ldr	r0, [pc, #148]	; (8017d50 <SFXDistortionAlloc+0xa8>)
            tVZFilter_init(&shelf2, Highshelf, 12000.0f, 6.0f);
 8017cbc:	4f25      	ldr	r7, [pc, #148]	; (8017d54 <SFXDistortionAlloc+0xac>)
            leaf.clearOnAllocation = 1;
 8017cbe:	6163      	str	r3, [r4, #20]
            tOversampler_init(&oversampler, distOS_ratio, FALSE);
 8017cc0:	f007 fe44 	bl	801f94c <tOversampler_init>
            tVZFilter_init(&bell1, Bell, 1000.0f, 1.9f);
 8017cc4:	4e24      	ldr	r6, [pc, #144]	; (8017d58 <SFXDistortionAlloc+0xb0>)
            tVZFilter_init(&shelf1, Lowshelf, 80.0f, 6.0f);
 8017cc6:	4640      	mov	r0, r8
 8017cc8:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
 8017ccc:	ed9f 0a23 	vldr	s0, [pc, #140]	; 8017d5c <SFXDistortionAlloc+0xb4>
 8017cd0:	2106      	movs	r1, #6
 8017cd2:	f00a ffab 	bl	8022c2c <tVZFilter_init>
            tVZFilter_init(&shelf2, Highshelf, 12000.0f, 6.0f);
 8017cd6:	4638      	mov	r0, r7
 8017cd8:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
 8017cdc:	ed9f 0a20 	vldr	s0, [pc, #128]	; 8017d60 <SFXDistortionAlloc+0xb8>
 8017ce0:	2107      	movs	r1, #7
 8017ce2:	f00a ffa3 	bl	8022c2c <tVZFilter_init>
            tVZFilter_init(&bell1, Bell, 1000.0f, 1.9f);
 8017ce6:	eddf 0a1f 	vldr	s1, [pc, #124]	; 8017d64 <SFXDistortionAlloc+0xbc>
 8017cea:	2105      	movs	r1, #5
 8017cec:	4630      	mov	r0, r6
 8017cee:	ed9f 0a1e 	vldr	s0, [pc, #120]	; 8017d68 <SFXDistortionAlloc+0xc0>
 8017cf2:	f00a ff9b 	bl	8022c2c <tVZFilter_init>
            tVZFilter_setSampleRate(&shelf1, leaf.sampleRate * distOS_ratio);
 8017cf6:	edd5 7a00 	vldr	s15, [r5]
 8017cfa:	ed94 0a00 	vldr	s0, [r4]
 8017cfe:	4640      	mov	r0, r8
 8017d00:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8017d04:	ee27 0a80 	vmul.f32	s0, s15, s0
 8017d08:	f00b f988 	bl	802301c <tVZFilter_setSampleRate>
            tVZFilter_setSampleRate(&shelf2, leaf.sampleRate * distOS_ratio);
 8017d0c:	edd5 7a00 	vldr	s15, [r5]
 8017d10:	ed94 0a00 	vldr	s0, [r4]
 8017d14:	4638      	mov	r0, r7
 8017d16:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8017d1a:	ee27 0a80 	vmul.f32	s0, s15, s0
 8017d1e:	f00b f97d 	bl	802301c <tVZFilter_setSampleRate>
            tVZFilter_setSampleRate(&bell1, leaf.sampleRate * distOS_ratio);
 8017d22:	ed95 0a00 	vldr	s0, [r5]
 8017d26:	edd4 7a00 	vldr	s15, [r4]
 8017d2a:	4630      	mov	r0, r6
 8017d2c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8017d30:	ee20 0a27 	vmul.f32	s0, s0, s15
 8017d34:	f00b f972 	bl	802301c <tVZFilter_setSampleRate>
            setLED_A(distortionMode);
 8017d38:	4b0c      	ldr	r3, [pc, #48]	; (8017d6c <SFXDistortionAlloc+0xc4>)
 8017d3a:	6818      	ldr	r0, [r3, #0]
 8017d3c:	f7fb fe06 	bl	801394c <setLED_A>
            leaf.clearOnAllocation = 0;
 8017d40:	2300      	movs	r3, #0
 8017d42:	6163      	str	r3, [r4, #20]
        }
 8017d44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8017d48:	20000238 	.word	0x20000238
 8017d4c:	200194e8 	.word	0x200194e8
 8017d50:	20018194 	.word	0x20018194
 8017d54:	200173cc 	.word	0x200173cc
 8017d58:	200172e4 	.word	0x200172e4
 8017d5c:	42a00000 	.word	0x42a00000
 8017d60:	463b8000 	.word	0x463b8000
 8017d64:	3ff33333 	.word	0x3ff33333
 8017d68:	447a0000 	.word	0x447a0000
 8017d6c:	2000058c 	.word	0x2000058c
 8017d70:	200174a4 	.word	0x200174a4

08017d74 <SFXDistortionFrame>:
            if (buttonActionsSFX[ButtonA][ActionPress])
 8017d74:	4a27      	ldr	r2, [pc, #156]	; (8017e14 <SFXDistortionFrame+0xa0>)
        {
 8017d76:	b510      	push	{r4, lr}
            if (buttonActionsSFX[ButtonA][ActionPress])
 8017d78:	7d13      	ldrb	r3, [r2, #20]
 8017d7a:	b153      	cbz	r3, 8017d92 <SFXDistortionFrame+0x1e>
                distortionMode = !distortionMode;
 8017d7c:	4926      	ldr	r1, [pc, #152]	; (8017e18 <SFXDistortionFrame+0xa4>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8017d7e:	2000      	movs	r0, #0
                distortionMode = !distortionMode;
 8017d80:	680b      	ldr	r3, [r1, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8017d82:	7510      	strb	r0, [r2, #20]
                distortionMode = !distortionMode;
 8017d84:	fab3 f383 	clz	r3, r3
 8017d88:	095b      	lsrs	r3, r3, #5
                setLED_A(distortionMode);
 8017d8a:	4618      	mov	r0, r3
                distortionMode = !distortionMode;
 8017d8c:	600b      	str	r3, [r1, #0]
                setLED_A(distortionMode);
 8017d8e:	f7fb fddd 	bl	801394c <setLED_A>
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 8017d92:	4b22      	ldr	r3, [pc, #136]	; (8017e1c <SFXDistortionFrame+0xa8>)
 8017d94:	eeb3 6a0e 	vmov.f32	s12, #62	; 0x41f00000  30.0
 8017d98:	eeba 7a0e 	vmov.f32	s14, #174	; 0xc1700000 -15.0
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
 8017d9c:	eddf 6a20 	vldr	s13, [pc, #128]	; 8017e20 <SFXDistortionFrame+0xac>
 8017da0:	eefb 7a01 	vmov.f32	s15, #177	; 0xc1880000 -17.0
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 8017da4:	ed93 5ac9 	vldr	s10, [r3, #804]	; 0x324
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
 8017da8:	edd3 5aca 	vldr	s11, [r3, #808]	; 0x328
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 8017dac:	eea5 7a06 	vfma.f32	s14, s10, s12
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 8017db0:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 8017e24 <SFXDistortionFrame+0xb0>
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
 8017db4:	eee5 7aa6 	vfma.f32	s15, s11, s13
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 8017db8:	ed93 6acb 	vldr	s12, [r3, #812]	; 0x32c
 8017dbc:	eddf 6a1a 	vldr	s13, [pc, #104]	; 8017e28 <SFXDistortionFrame+0xb4>
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 8017dc0:	4c1a      	ldr	r4, [pc, #104]	; (8017e2c <SFXDistortionFrame+0xb8>)
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 8017dc2:	eea6 0a26 	vfma.f32	s0, s12, s13
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 8017dc6:	ed84 7a01 	vstr	s14, [r4, #4]
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
 8017dca:	edc4 7a02 	vstr	s15, [r4, #8]
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 8017dce:	f00c f9e1 	bl	8024194 <faster_mtof>
            tVZFilter_setGain(&shelf1, fastdbtoa(-1.0f * displayValues[1]));
 8017dd2:	edd4 7a01 	vldr	s15, [r4, #4]
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 8017dd6:	ed84 0a03 	vstr	s0, [r4, #12]
            tVZFilter_setGain(&shelf1, fastdbtoa(-1.0f * displayValues[1]));
 8017dda:	eeb1 0a67 	vneg.f32	s0, s15
 8017dde:	f00c fa29 	bl	8024234 <fastdbtoa>
 8017de2:	4813      	ldr	r0, [pc, #76]	; (8017e30 <SFXDistortionFrame+0xbc>)
 8017de4:	f00b fd5e 	bl	80238a4 <tVZFilter_setGain>
            tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[1]));
 8017de8:	ed94 0a01 	vldr	s0, [r4, #4]
 8017dec:	f00c fa22 	bl	8024234 <fastdbtoa>
 8017df0:	4810      	ldr	r0, [pc, #64]	; (8017e34 <SFXDistortionFrame+0xc0>)
 8017df2:	f00b fd57 	bl	80238a4 <tVZFilter_setGain>
            tVZFilter_setFreq(&bell1, displayValues[3]);
 8017df6:	ed94 0a03 	vldr	s0, [r4, #12]
 8017dfa:	480f      	ldr	r0, [pc, #60]	; (8017e38 <SFXDistortionFrame+0xc4>)
 8017dfc:	f00b f988 	bl	8023110 <tVZFilter_setFreq>
            tVZFilter_setGain(&bell1, fastdbtoa(displayValues[2]));
 8017e00:	ed94 0a02 	vldr	s0, [r4, #8]
 8017e04:	f00c fa16 	bl	8024234 <fastdbtoa>
 8017e08:	480b      	ldr	r0, [pc, #44]	; (8017e38 <SFXDistortionFrame+0xc4>)
        }
 8017e0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            tVZFilter_setGain(&bell1, fastdbtoa(displayValues[2]));
 8017e0e:	f00b bd49 	b.w	80238a4 <tVZFilter_setGain>
 8017e12:	bf00      	nop
 8017e14:	2001872c 	.word	0x2001872c
 8017e18:	2000058c 	.word	0x2000058c
 8017e1c:	20002cb8 	.word	0x20002cb8
 8017e20:	42080000 	.word	0x42080000
 8017e24:	42280000 	.word	0x42280000
 8017e28:	429a0000 	.word	0x429a0000
 8017e2c:	200187dc 	.word	0x200187dc
 8017e30:	200174a4 	.word	0x200174a4
 8017e34:	200173cc 	.word	0x200173cc
 8017e38:	200172e4 	.word	0x200172e4

08017e3c <SFXDistortionTick>:
        {
 8017e3c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
 8017e40:	4e30      	ldr	r6, [pc, #192]	; (8017f04 <SFXDistortionTick+0xc8>)
 8017e42:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
 8017e46:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8017e4a:	4b2f      	ldr	r3, [pc, #188]	; (8017f08 <SFXDistortionTick+0xcc>)
 8017e4c:	edd6 6ac8 	vldr	s13, [r6, #800]	; 0x320
        {
 8017e50:	4683      	mov	fp, r0
            displayValues[4] = presetKnobValues[Distortion][4]; // 15.0f
 8017e52:	f8d6 2330 	ldr.w	r2, [r6, #816]	; 0x330
            displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
 8017e56:	eee6 7a87 	vfma.f32	s15, s13, s14
            for (int i = 0; i < distOS_ratio; i++)
 8017e5a:	4f2c      	ldr	r7, [pc, #176]	; (8017f0c <SFXDistortionTick+0xd0>)
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
 8017e5c:	492c      	ldr	r1, [pc, #176]	; (8017f10 <SFXDistortionTick+0xd4>)
        {
 8017e5e:	ed2d 8b02 	vpush	{d8}
            float sample = input[1];
 8017e62:	ed90 0a01 	vldr	s0, [r0, #4]
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
 8017e66:	482b      	ldr	r0, [pc, #172]	; (8017f14 <SFXDistortionTick+0xd8>)
 8017e68:	ee27 0a80 	vmul.f32	s0, s15, s0
            displayValues[4] = presetKnobValues[Distortion][4]; // 15.0f
 8017e6c:	611a      	str	r2, [r3, #16]
            displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
 8017e6e:	edc3 7a00 	vstr	s15, [r3]
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
 8017e72:	f007 fe57 	bl	801fb24 <tOversampler_upsample>
            for (int i = 0; i < distOS_ratio; i++)
 8017e76:	683b      	ldr	r3, [r7, #0]
 8017e78:	2b00      	cmp	r3, #0
 8017e7a:	dd32      	ble.n	8017ee2 <SFXDistortionTick+0xa6>
 8017e7c:	4c24      	ldr	r4, [pc, #144]	; (8017f10 <SFXDistortionTick+0xd4>)
 8017e7e:	2500      	movs	r5, #0
 8017e80:	f8df a09c 	ldr.w	sl, [pc, #156]	; 8017f20 <SFXDistortionTick+0xe4>
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
 8017e84:	f8df 909c 	ldr.w	r9, [pc, #156]	; 8017f24 <SFXDistortionTick+0xe8>
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
 8017e88:	f8df 809c 	ldr.w	r8, [pc, #156]	; 8017f28 <SFXDistortionTick+0xec>
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
 8017e8c:	ed9f 8a22 	vldr	s16, [pc, #136]	; 8017f18 <SFXDistortionTick+0xdc>
                if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
 8017e90:	f8da 3000 	ldr.w	r3, [sl]
 8017e94:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8017e98:	ecf4 7a01 	vldmia	r4!, {s15}
 8017e9c:	2b00      	cmp	r3, #0
                else oversamplerArray[i] = tanhf(oversamplerArray[i]);
 8017e9e:	eeb0 0a67 	vmov.f32	s0, s15
                if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
 8017ea2:	dc2a      	bgt.n	8017efa <SFXDistortionTick+0xbe>
                else oversamplerArray[i] = tanhf(oversamplerArray[i]);
 8017ea4:	f00f fcd2 	bl	802784c <tanhf>
 8017ea8:	ed04 0a01 	vstr	s0, [r4, #-4]
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
 8017eac:	4648      	mov	r0, r9
            for (int i = 0; i < distOS_ratio; i++)
 8017eae:	3501      	adds	r5, #1
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
 8017eb0:	f00b f8be 	bl	8023030 <tVZFilter_tick>
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
 8017eb4:	4640      	mov	r0, r8
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
 8017eb6:	ed04 0a01 	vstr	s0, [r4, #-4]
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
 8017eba:	f00b f8b9 	bl	8023030 <tVZFilter_tick>
                oversamplerArray[i] = tVZFilter_tick(&bell1, oversamplerArray[i]); // now add a bell (or peaking eq) filter
 8017ebe:	4817      	ldr	r0, [pc, #92]	; (8017f1c <SFXDistortionTick+0xe0>)
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
 8017ec0:	ed04 0a01 	vstr	s0, [r4, #-4]
                oversamplerArray[i] = tVZFilter_tick(&bell1, oversamplerArray[i]); // now add a bell (or peaking eq) filter
 8017ec4:	f00b f8b4 	bl	8023030 <tVZFilter_tick>
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
 8017ec8:	edd6 7acc 	vldr	s15, [r6, #816]	; 0x330
 8017ecc:	ee20 0a27 	vmul.f32	s0, s0, s15
 8017ed0:	f00f fcbc 	bl	802784c <tanhf>
            for (int i = 0; i < distOS_ratio; i++)
 8017ed4:	683b      	ldr	r3, [r7, #0]
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
 8017ed6:	ee20 0a08 	vmul.f32	s0, s0, s16
            for (int i = 0; i < distOS_ratio; i++)
 8017eda:	42ab      	cmp	r3, r5
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
 8017edc:	ed04 0a01 	vstr	s0, [r4, #-4]
            for (int i = 0; i < distOS_ratio; i++)
 8017ee0:	dcd6      	bgt.n	8017e90 <SFXDistortionTick+0x54>
            sample = tOversampler_downsample(&oversampler, oversamplerArray);
 8017ee2:	490b      	ldr	r1, [pc, #44]	; (8017f10 <SFXDistortionTick+0xd4>)
 8017ee4:	480b      	ldr	r0, [pc, #44]	; (8017f14 <SFXDistortionTick+0xd8>)
 8017ee6:	f007 fe67 	bl	801fbb8 <tOversampler_downsample>
            input[0] = sample;
 8017eea:	ed8b 0a00 	vstr	s0, [fp]
            input[1] = sample;
 8017eee:	ed8b 0a01 	vstr	s0, [fp, #4]
        }
 8017ef2:	ecbd 8b02 	vpop	{d8}
 8017ef6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
 8017efa:	f00b ff81 	bl	8023e00 <LEAF_shaper>
 8017efe:	ed04 0a01 	vstr	s0, [r4, #-4]
 8017f02:	e7d3      	b.n	8017eac <SFXDistortionTick+0x70>
 8017f04:	20002cb8 	.word	0x20002cb8
 8017f08:	200187dc 	.word	0x200187dc
 8017f0c:	20000238 	.word	0x20000238
 8017f10:	20017210 	.word	0x20017210
 8017f14:	20018194 	.word	0x20018194
 8017f18:	3f733333 	.word	0x3f733333
 8017f1c:	200172e4 	.word	0x200172e4
 8017f20:	2000058c 	.word	0x2000058c
 8017f24:	200174a4 	.word	0x200174a4
 8017f28:	200173cc 	.word	0x200173cc

08017f2c <SFXDistortionFree>:
        {
 8017f2c:	b508      	push	{r3, lr}
            tOversampler_free(&oversampler);
 8017f2e:	4807      	ldr	r0, [pc, #28]	; (8017f4c <SFXDistortionFree+0x20>)
 8017f30:	f007 fd5e 	bl	801f9f0 <tOversampler_free>
            tVZFilter_free(&shelf1);
 8017f34:	4806      	ldr	r0, [pc, #24]	; (8017f50 <SFXDistortionFree+0x24>)
 8017f36:	f00b f86d 	bl	8023014 <tVZFilter_free>
            tVZFilter_free(&shelf2);
 8017f3a:	4806      	ldr	r0, [pc, #24]	; (8017f54 <SFXDistortionFree+0x28>)
 8017f3c:	f00b f86a 	bl	8023014 <tVZFilter_free>
            tVZFilter_free(&bell1);
 8017f40:	4805      	ldr	r0, [pc, #20]	; (8017f58 <SFXDistortionFree+0x2c>)
        }
 8017f42:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tVZFilter_free(&bell1);
 8017f46:	f00b b865 	b.w	8023014 <tVZFilter_free>
 8017f4a:	bf00      	nop
 8017f4c:	20018194 	.word	0x20018194
 8017f50:	200174a4 	.word	0x200174a4
 8017f54:	200173cc 	.word	0x200173cc
 8017f58:	200172e4 	.word	0x200172e4

08017f5c <SFXWaveFolderAlloc>:
        {
 8017f5c:	b510      	push	{r4, lr}
            leaf.clearOnAllocation = 1;
 8017f5e:	2301      	movs	r3, #1
 8017f60:	4c0c      	ldr	r4, [pc, #48]	; (8017f94 <SFXWaveFolderAlloc+0x38>)
            tLockhartWavefolder_init(&wavefolder1);
 8017f62:	480d      	ldr	r0, [pc, #52]	; (8017f98 <SFXWaveFolderAlloc+0x3c>)
            leaf.clearOnAllocation = 1;
 8017f64:	6163      	str	r3, [r4, #20]
            tLockhartWavefolder_init(&wavefolder1);
 8017f66:	f007 fe57 	bl	801fc18 <tLockhartWavefolder_init>
            tLockhartWavefolder_init(&wavefolder2);
 8017f6a:	480c      	ldr	r0, [pc, #48]	; (8017f9c <SFXWaveFolderAlloc+0x40>)
 8017f6c:	f007 fe54 	bl	801fc18 <tLockhartWavefolder_init>
            tHighpass_init(&wfHP, 10.0f);
 8017f70:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8017f74:	480a      	ldr	r0, [pc, #40]	; (8017fa0 <SFXWaveFolderAlloc+0x44>)
 8017f76:	f00a fdf5 	bl	8022b64 <tHighpass_init>
            tOversampler_init(&oversampler, 2, FALSE);
 8017f7a:	2200      	movs	r2, #0
 8017f7c:	2102      	movs	r1, #2
 8017f7e:	4809      	ldr	r0, [pc, #36]	; (8017fa4 <SFXWaveFolderAlloc+0x48>)
 8017f80:	f007 fce4 	bl	801f94c <tOversampler_init>
            setLED_A(foldMode);
 8017f84:	4b08      	ldr	r3, [pc, #32]	; (8017fa8 <SFXWaveFolderAlloc+0x4c>)
 8017f86:	6818      	ldr	r0, [r3, #0]
 8017f88:	f7fb fce0 	bl	801394c <setLED_A>
            leaf.clearOnAllocation = 0;
 8017f8c:	2300      	movs	r3, #0
 8017f8e:	6163      	str	r3, [r4, #20]
        }
 8017f90:	bd10      	pop	{r4, pc}
 8017f92:	bf00      	nop
 8017f94:	200194e8 	.word	0x200194e8
 8017f98:	200026f8 	.word	0x200026f8
 8017f9c:	200173c8 	.word	0x200173c8
 8017fa0:	2001720c 	.word	0x2001720c
 8017fa4:	20018194 	.word	0x20018194
 8017fa8:	2000059c 	.word	0x2000059c

08017fac <SFXWaveFolderFrame>:
            if (buttonActionsSFX[ButtonA][ActionPress])
 8017fac:	4a07      	ldr	r2, [pc, #28]	; (8017fcc <SFXWaveFolderFrame+0x20>)
 8017fae:	7d13      	ldrb	r3, [r2, #20]
 8017fb0:	b903      	cbnz	r3, 8017fb4 <SFXWaveFolderFrame+0x8>
        }
 8017fb2:	4770      	bx	lr
                foldMode = !foldMode;
 8017fb4:	4906      	ldr	r1, [pc, #24]	; (8017fd0 <SFXWaveFolderFrame+0x24>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8017fb6:	2000      	movs	r0, #0
                foldMode = !foldMode;
 8017fb8:	680b      	ldr	r3, [r1, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8017fba:	7510      	strb	r0, [r2, #20]
                foldMode = !foldMode;
 8017fbc:	fab3 f383 	clz	r3, r3
 8017fc0:	095b      	lsrs	r3, r3, #5
                setLED_A(foldMode);
 8017fc2:	4618      	mov	r0, r3
                foldMode = !foldMode;
 8017fc4:	600b      	str	r3, [r1, #0]
                setLED_A(foldMode);
 8017fc6:	f7fb bcc1 	b.w	801394c <setLED_A>
 8017fca:	bf00      	nop
 8017fcc:	2001872c 	.word	0x2001872c
 8017fd0:	2000059c 	.word	0x2000059c

08017fd4 <SFXWaveFolderTick>:
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 8017fd4:	4b3a      	ldr	r3, [pc, #232]	; (80180c0 <SFXWaveFolderTick+0xec>)
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
 8017fd6:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 8017fda:	eeb1 6a00 	vmov.f32	s12, #16	; 0x40800000  4.0
            if (foldMode == 0)
 8017fde:	4939      	ldr	r1, [pc, #228]	; (80180c4 <SFXWaveFolderTick+0xf0>)
        {
 8017fe0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8017fe4:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 8017fe8:	ed93 0ae1 	vldr	s0, [r3, #900]	; 0x384
        {
 8017fec:	4606      	mov	r6, r0
            displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
 8017fee:	ed93 7ae3 	vldr	s14, [r3, #908]	; 0x38c
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
 8017ff2:	edd3 7ae2 	vldr	s15, [r3, #904]	; 0x388
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 8017ff6:	ee20 0a06 	vmul.f32	s0, s0, s12
            displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
 8017ffa:	ee37 7a66 	vsub.f32	s14, s14, s13
            float sample = input[1];
 8017ffe:	ed90 8a01 	vldr	s16, [r0, #4]
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
 8018002:	ee77 7ae6 	vsub.f32	s15, s15, s13
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 8018006:	4c30      	ldr	r4, [pc, #192]	; (80180c8 <SFXWaveFolderTick+0xf4>)
            displayValues[3] = presetKnobValues[Wavefolder][3];
 8018008:	f8d3 2390 	ldr.w	r2, [r3, #912]	; 0x390
            sample = sample * gain;
 801800c:	ee20 8a08 	vmul.f32	s16, s0, s16
            if (foldMode == 0)
 8018010:	680b      	ldr	r3, [r1, #0]
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 8018012:	ed84 0a00 	vstr	s0, [r4]
            displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
 8018016:	ed84 7a02 	vstr	s14, [r4, #8]
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
 801801a:	edc4 7a01 	vstr	s15, [r4, #4]
            displayValues[3] = presetKnobValues[Wavefolder][3];
 801801e:	60e2      	str	r2, [r4, #12]
            if (foldMode == 0)
 8018020:	bb93      	cbnz	r3, 8018088 <SFXWaveFolderTick+0xb4>
 8018022:	4d2a      	ldr	r5, [pc, #168]	; (80180cc <SFXWaveFolderTick+0xf8>)
                tOversampler_upsample(&oversampler, sample, oversamplerArray);
 8018024:	eeb0 0a48 	vmov.f32	s0, s16
 8018028:	4829      	ldr	r0, [pc, #164]	; (80180d0 <SFXWaveFolderTick+0xfc>)
 801802a:	4629      	mov	r1, r5
                    oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
 801802c:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80180d8 <SFXWaveFolderTick+0x104>
 8018030:	f105 0708 	add.w	r7, r5, #8
                tOversampler_upsample(&oversampler, sample, oversamplerArray);
 8018034:	f007 fd76 	bl	801fb24 <tOversampler_upsample>
                    oversamplerArray[i] = sample + displayValues[1];
 8018038:	edd4 7a01 	vldr	s15, [r4, #4]
                    oversamplerArray[i] *= displayValues[0];
 801803c:	ed94 0a00 	vldr	s0, [r4]
                    oversamplerArray[i] = sample + displayValues[1];
 8018040:	ee78 7a27 	vadd.f32	s15, s16, s15
                    oversamplerArray[i] = tanhf(oversamplerArray[i]);
 8018044:	ee27 0a80 	vmul.f32	s0, s15, s0
 8018048:	f00f fc00 	bl	802784c <tanhf>
                    oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
 801804c:	4640      	mov	r0, r8
                    oversamplerArray[i] = tanhf(oversamplerArray[i]);
 801804e:	ed85 0a00 	vstr	s0, [r5]
                    oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
 8018052:	f007 fe6f 	bl	801fd34 <tLockhartWavefolder_tick>
                    oversamplerArray[i] = tanhf(oversamplerArray[i]);
 8018056:	f00f fbf9 	bl	802784c <tanhf>
 801805a:	eca5 0a01 	vstmia	r5!, {s0}
                for (int i = 0; i < 2; i++)
 801805e:	42bd      	cmp	r5, r7
 8018060:	d1ea      	bne.n	8018038 <SFXWaveFolderTick+0x64>
                sample = tHighpass_tick(&wfHP, tOversampler_downsample(&oversampler, oversamplerArray)) * displayValues[3];
 8018062:	491a      	ldr	r1, [pc, #104]	; (80180cc <SFXWaveFolderTick+0xf8>)
 8018064:	481a      	ldr	r0, [pc, #104]	; (80180d0 <SFXWaveFolderTick+0xfc>)
 8018066:	f007 fda7 	bl	801fbb8 <tOversampler_downsample>
                sample = tHighpass_tick(&wfHP, sample) * displayValues[3];
 801806a:	481a      	ldr	r0, [pc, #104]	; (80180d4 <SFXWaveFolderTick+0x100>)
 801806c:	f00a fdce 	bl	8022c0c <tHighpass_tick>
 8018070:	edd4 7a03 	vldr	s15, [r4, #12]
 8018074:	ee20 0a27 	vmul.f32	s0, s0, s15
                input[0] = sample;
 8018078:	ed86 0a00 	vstr	s0, [r6]
                input[1] = sample;
 801807c:	ed86 0a01 	vstr	s0, [r6, #4]
        }
 8018080:	ecbd 8b02 	vpop	{d8}
 8018084:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                sample = sample + displayValues[1];
 8018088:	ee77 7a88 	vadd.f32	s15, s15, s16
                sample = LEAF_tanh(sample);
 801808c:	ee20 0a27 	vmul.f32	s0, s0, s15
 8018090:	f00b ff62 	bl	8023f58 <LEAF_tanh>
                sample = tLockhartWavefolder_tick(&wavefolder1, sample);
 8018094:	4810      	ldr	r0, [pc, #64]	; (80180d8 <SFXWaveFolderTick+0x104>)
 8018096:	f007 fe4d 	bl	801fd34 <tLockhartWavefolder_tick>
                sample = sample + displayValues[2];
 801809a:	edd4 7a02 	vldr	s15, [r4, #8]
                sample *= displayValues[0];
 801809e:	ed94 7a00 	vldr	s14, [r4]
                sample = sample + displayValues[2];
 80180a2:	ee30 0a27 	vadd.f32	s0, s0, s15
                sample = LEAF_tanh(sample);
 80180a6:	ee20 0a07 	vmul.f32	s0, s0, s14
 80180aa:	f00b ff55 	bl	8023f58 <LEAF_tanh>
                sample = tLockhartWavefolder_tick(&wavefolder2, sample);
 80180ae:	480b      	ldr	r0, [pc, #44]	; (80180dc <SFXWaveFolderTick+0x108>)
 80180b0:	f007 fe40 	bl	801fd34 <tLockhartWavefolder_tick>
                sample = tOversampler_tick(&oversampler, sample, oversampleBuf, &LEAF_tanh);
 80180b4:	4a0a      	ldr	r2, [pc, #40]	; (80180e0 <SFXWaveFolderTick+0x10c>)
 80180b6:	490b      	ldr	r1, [pc, #44]	; (80180e4 <SFXWaveFolderTick+0x110>)
 80180b8:	4805      	ldr	r0, [pc, #20]	; (80180d0 <SFXWaveFolderTick+0xfc>)
 80180ba:	f007 fca9 	bl	801fa10 <tOversampler_tick>
 80180be:	e7d4      	b.n	801806a <SFXWaveFolderTick+0x96>
 80180c0:	20002cb8 	.word	0x20002cb8
 80180c4:	2000059c 	.word	0x2000059c
 80180c8:	200187dc 	.word	0x200187dc
 80180cc:	20017210 	.word	0x20017210
 80180d0:	20018194 	.word	0x20018194
 80180d4:	2001720c 	.word	0x2001720c
 80180d8:	200026f8 	.word	0x200026f8
 80180dc:	200173c8 	.word	0x200173c8
 80180e0:	08023f59 	.word	0x08023f59
 80180e4:	20018344 	.word	0x20018344

080180e8 <SFXWaveFolderFree>:
        {
 80180e8:	b508      	push	{r3, lr}
            tLockhartWavefolder_free(&wavefolder1);
 80180ea:	4807      	ldr	r0, [pc, #28]	; (8018108 <SFXWaveFolderFree+0x20>)
 80180ec:	f007 fe1e 	bl	801fd2c <tLockhartWavefolder_free>
            tLockhartWavefolder_free(&wavefolder2);
 80180f0:	4806      	ldr	r0, [pc, #24]	; (801810c <SFXWaveFolderFree+0x24>)
 80180f2:	f007 fe1b 	bl	801fd2c <tLockhartWavefolder_free>
            tHighpass_free(&wfHP);
 80180f6:	4806      	ldr	r0, [pc, #24]	; (8018110 <SFXWaveFolderFree+0x28>)
 80180f8:	f00a fd74 	bl	8022be4 <tHighpass_free>
            tOversampler_free(&oversampler);
 80180fc:	4805      	ldr	r0, [pc, #20]	; (8018114 <SFXWaveFolderFree+0x2c>)
        }
 80180fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tOversampler_free(&oversampler);
 8018102:	f007 bc75 	b.w	801f9f0 <tOversampler_free>
 8018106:	bf00      	nop
 8018108:	200026f8 	.word	0x200026f8
 801810c:	200173c8 	.word	0x200173c8
 8018110:	2001720c 	.word	0x2001720c
 8018114:	20018194 	.word	0x20018194

08018118 <SFXBitcrusherAlloc>:
        {
 8018118:	b508      	push	{r3, lr}
            tCrusher_init(&crush);
 801811a:	4806      	ldr	r0, [pc, #24]	; (8018134 <SFXBitcrusherAlloc+0x1c>)
 801811c:	f007 ff22 	bl	801ff64 <tCrusher_init>
            tCrusher_init(&crush2);
 8018120:	4805      	ldr	r0, [pc, #20]	; (8018138 <SFXBitcrusherAlloc+0x20>)
 8018122:	f007 ff1f 	bl	801ff64 <tCrusher_init>
            setLED_A(crusherStereo);
 8018126:	4b05      	ldr	r3, [pc, #20]	; (801813c <SFXBitcrusherAlloc+0x24>)
 8018128:	6818      	ldr	r0, [r3, #0]
        }
 801812a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            setLED_A(crusherStereo);
 801812e:	f7fb bc0d 	b.w	801394c <setLED_A>
 8018132:	bf00      	nop
 8018134:	20003408 	.word	0x20003408
 8018138:	200029d4 	.word	0x200029d4
 801813c:	20000578 	.word	0x20000578

08018140 <SFXBitcrusherFrame>:
            if (buttonActionsSFX[ButtonA][ActionPress])
 8018140:	4a07      	ldr	r2, [pc, #28]	; (8018160 <SFXBitcrusherFrame+0x20>)
 8018142:	7d13      	ldrb	r3, [r2, #20]
 8018144:	b903      	cbnz	r3, 8018148 <SFXBitcrusherFrame+0x8>
        }
 8018146:	4770      	bx	lr
                crusherStereo = !crusherStereo;
 8018148:	4906      	ldr	r1, [pc, #24]	; (8018164 <SFXBitcrusherFrame+0x24>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801814a:	2000      	movs	r0, #0
                crusherStereo = !crusherStereo;
 801814c:	680b      	ldr	r3, [r1, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801814e:	7510      	strb	r0, [r2, #20]
                crusherStereo = !crusherStereo;
 8018150:	fab3 f383 	clz	r3, r3
 8018154:	095b      	lsrs	r3, r3, #5
                setLED_A(crusherStereo);
 8018156:	4618      	mov	r0, r3
                crusherStereo = !crusherStereo;
 8018158:	600b      	str	r3, [r1, #0]
                setLED_A(crusherStereo);
 801815a:	f7fb bbf7 	b.w	801394c <setLED_A>
 801815e:	bf00      	nop
 8018160:	2001872c 	.word	0x2001872c
 8018164:	20000578 	.word	0x20000578

08018168 <SFXBitcrusherTick>:
        {
 8018168:	b570      	push	{r4, r5, r6, lr}
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
 801816a:	4d51      	ldr	r5, [pc, #324]	; (80182b0 <SFXBitcrusherTick+0x148>)
        {
 801816c:	4606      	mov	r6, r0
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
 801816e:	eddf 6a51 	vldr	s13, [pc, #324]	; 80182b4 <SFXBitcrusherTick+0x14c>
 8018172:	ed95 7afa 	vldr	s14, [r5, #1000]	; 0x3e8
 8018176:	eddf 7a50 	vldr	s15, [pc, #320]	; 80182b8 <SFXBitcrusherTick+0x150>
 801817a:	4c50      	ldr	r4, [pc, #320]	; (80182bc <SFXBitcrusherTick+0x154>)
            tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
 801817c:	eeb0 0a47 	vmov.f32	s0, s14
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
 8018180:	eee7 7a26 	vfma.f32	s15, s14, s13
            tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
 8018184:	484e      	ldr	r0, [pc, #312]	; (80182c0 <SFXBitcrusherTick+0x158>)
        {
 8018186:	ed2d 8b02 	vpush	{d8}
            tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
 801818a:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
 801818e:	ed9f 8a4d 	vldr	s16, [pc, #308]	; 80182c4 <SFXBitcrusherTick+0x15c>
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
 8018192:	edc4 7a00 	vstr	s15, [r4]
            tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
 8018196:	f007 ff6f 	bl	8020078 <tCrusher_setQuality>
            tCrusher_setQuality (&crush2, presetKnobValues[BitCrusher][0]);
 801819a:	ed95 0afa 	vldr	s0, [r5, #1000]	; 0x3e8
 801819e:	484a      	ldr	r0, [pc, #296]	; (80182c8 <SFXBitcrusherTick+0x160>)
 80181a0:	f007 ff6a 	bl	8020078 <tCrusher_setQuality>
            displayValues[1] = presetKnobValues[BitCrusher][1];
 80181a4:	edd5 7afb 	vldr	s15, [r5, #1004]	; 0x3ec
            tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
 80181a8:	4845      	ldr	r0, [pc, #276]	; (80182c0 <SFXBitcrusherTick+0x158>)
 80181aa:	ee27 0aa8 	vmul.f32	s0, s15, s17
            displayValues[1] = presetKnobValues[BitCrusher][1];
 80181ae:	edc4 7a01 	vstr	s15, [r4, #4]
            tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
 80181b2:	f007 ff8d 	bl	80200d0 <tCrusher_setSamplingRatio>
            tCrusher_setSamplingRatio (&crush2, presetKnobValues[BitCrusher][1] * 0.5f);
 80181b6:	ed95 0afb 	vldr	s0, [r5, #1004]	; 0x3ec
 80181ba:	4843      	ldr	r0, [pc, #268]	; (80182c8 <SFXBitcrusherTick+0x160>)
 80181bc:	ee20 0a28 	vmul.f32	s0, s0, s17
 80181c0:	f007 ff86 	bl	80200d0 <tCrusher_setSamplingRatio>
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
 80181c4:	edd5 7afc 	vldr	s15, [r5, #1008]	; 0x3f0
            tCrusher_setRound (&crush, displayValues[2]);
 80181c8:	483d      	ldr	r0, [pc, #244]	; (80182c0 <SFXBitcrusherTick+0x158>)
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
 80181ca:	ee67 7a88 	vmul.f32	s15, s15, s16
            tCrusher_setRound (&crush, displayValues[2]);
 80181ce:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
 80181d2:	edc4 7a02 	vstr	s15, [r4, #8]
            tCrusher_setRound (&crush, displayValues[2]);
 80181d6:	f007 ff75 	bl	80200c4 <tCrusher_setRound>
            tCrusher_setRound (&crush2, displayValues[2]);
 80181da:	ed94 0a02 	vldr	s0, [r4, #8]
 80181de:	483a      	ldr	r0, [pc, #232]	; (80182c8 <SFXBitcrusherTick+0x160>)
 80181e0:	f007 ff70 	bl	80200c4 <tCrusher_setRound>
            displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
 80181e4:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 80181e8:	ed95 0afd 	vldr	s0, [r5, #1012]	; 0x3f4
            tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
 80181ec:	4834      	ldr	r0, [pc, #208]	; (80182c0 <SFXBitcrusherTick+0x158>)
            displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
 80181ee:	ee60 7a27 	vmul.f32	s15, s0, s15
 80181f2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80181f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80181fa:	edc4 7a03 	vstr	s15, [r4, #12]
            tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
 80181fe:	f007 ff31 	bl	8020064 <tCrusher_setOperation>
            tCrusher_setOperation (&crush2, presetKnobValues[BitCrusher][3]);
 8018202:	ed95 0afd 	vldr	s0, [r5, #1012]	; 0x3f4
 8018206:	4830      	ldr	r0, [pc, #192]	; (80182c8 <SFXBitcrusherTick+0x160>)
 8018208:	f007 ff2c 	bl	8020064 <tCrusher_setOperation>
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
 801820c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8018210:	eeb1 7a04 	vmov.f32	s14, #20	; 0x40a00000  5.0
 8018214:	ed95 6aff 	vldr	s12, [r5, #1020]	; 0x3fc
            if (displayValues[0] < 0.1f)
 8018218:	edd4 6a00 	vldr	s13, [r4]
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
 801821c:	eef0 5a67 	vmov.f32	s11, s15
            displayValues[4] = presetKnobValues[BitCrusher][4];
 8018220:	f8d5 33f8 	ldr.w	r3, [r5, #1016]	; 0x3f8
            if (displayValues[0] < 0.1f)
 8018224:	eef4 6ac8 	vcmpe.f32	s13, s16
            displayValues[4] = presetKnobValues[BitCrusher][4];
 8018228:	6123      	str	r3, [r4, #16]
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
 801822a:	eee6 5a07 	vfma.f32	s11, s12, s14
            if (displayValues[0] < 0.1f)
 801822e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
 8018232:	eeb0 7a65 	vmov.f32	s14, s11
 8018236:	edc4 5a05 	vstr	s11, [r4, #20]
            if (displayValues[0] < 0.1f)
 801823a:	d41e      	bmi.n	801827a <SFXBitcrusherTick+0x112>
                volumeComp = (1.0f / (displayValues[3] + 1.0f));
 801823c:	edd4 6a03 	vldr	s13, [r4, #12]
 8018240:	ee76 6aa7 	vadd.f32	s13, s13, s15
 8018244:	eec7 8aa6 	vdiv.f32	s17, s15, s13
            sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
 8018248:	ed96 0a01 	vldr	s0, [r6, #4]
 801824c:	481c      	ldr	r0, [pc, #112]	; (80182c0 <SFXBitcrusherTick+0x158>)
 801824e:	ee27 0a00 	vmul.f32	s0, s14, s0
 8018252:	f007 fec7 	bl	801ffe4 <tCrusher_tick>
 8018256:	f00f faf9 	bl	802784c <tanhf>
            if (crusherStereo)
 801825a:	4b1c      	ldr	r3, [pc, #112]	; (80182cc <SFXBitcrusherTick+0x164>)
            sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
 801825c:	ee20 0a28 	vmul.f32	s0, s0, s17
 8018260:	ed94 8a04 	vldr	s16, [r4, #16]
            if (crusherStereo)
 8018264:	681b      	ldr	r3, [r3, #0]
            sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
 8018266:	ee20 8a08 	vmul.f32	s16, s0, s16
            if (crusherStereo)
 801826a:	b94b      	cbnz	r3, 8018280 <SFXBitcrusherTick+0x118>
                input[1] = sample;
 801826c:	ed86 8a01 	vstr	s16, [r6, #4]
            input[0] = sample;
 8018270:	ed86 8a00 	vstr	s16, [r6]
        }
 8018274:	ecbd 8b02 	vpop	{d8}
 8018278:	bd70      	pop	{r4, r5, r6, pc}
                volumeComp = 1.0f;
 801827a:	eef0 8a67 	vmov.f32	s17, s15
 801827e:	e7e3      	b.n	8018248 <SFXBitcrusherTick+0xe0>
                input[1] = tanhf(tCrusher_tick(&crush2, input[0] * displayValues[5])) * displayValues[4] * volumeComp;
 8018280:	edd4 7a05 	vldr	s15, [r4, #20]
 8018284:	ed96 0a00 	vldr	s0, [r6]
 8018288:	480f      	ldr	r0, [pc, #60]	; (80182c8 <SFXBitcrusherTick+0x160>)
 801828a:	ee20 0a27 	vmul.f32	s0, s0, s15
 801828e:	f007 fea9 	bl	801ffe4 <tCrusher_tick>
 8018292:	f00f fadb 	bl	802784c <tanhf>
 8018296:	edd4 7a04 	vldr	s15, [r4, #16]
            input[0] = sample;
 801829a:	ed86 8a00 	vstr	s16, [r6]
                input[1] = tanhf(tCrusher_tick(&crush2, input[0] * displayValues[5])) * displayValues[4] * volumeComp;
 801829e:	ee68 8aa7 	vmul.f32	s17, s17, s15
 80182a2:	ee68 8a80 	vmul.f32	s17, s17, s0
 80182a6:	edc6 8a01 	vstr	s17, [r6, #4]
        }
 80182aa:	ecbd 8b02 	vpop	{d8}
 80182ae:	bd70      	pop	{r4, r5, r6, pc}
 80182b0:	20002cb8 	.word	0x20002cb8
 80182b4:	3f7d70a4 	.word	0x3f7d70a4
 80182b8:	3c23d70a 	.word	0x3c23d70a
 80182bc:	200187dc 	.word	0x200187dc
 80182c0:	20003408 	.word	0x20003408
 80182c4:	3dcccccd 	.word	0x3dcccccd
 80182c8:	200029d4 	.word	0x200029d4
 80182cc:	20000578 	.word	0x20000578

080182d0 <SFXBitcrusherFree>:
        {
 80182d0:	b508      	push	{r3, lr}
            tCrusher_free(&crush);
 80182d2:	4804      	ldr	r0, [pc, #16]	; (80182e4 <SFXBitcrusherFree+0x14>)
 80182d4:	f007 fe7a 	bl	801ffcc <tCrusher_free>
            tCrusher_free(&crush2);
 80182d8:	4803      	ldr	r0, [pc, #12]	; (80182e8 <SFXBitcrusherFree+0x18>)
        }
 80182da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tCrusher_free(&crush2);
 80182de:	f007 be75 	b.w	801ffcc <tCrusher_free>
 80182e2:	bf00      	nop
 80182e4:	20003408 	.word	0x20003408
 80182e8:	200029d4 	.word	0x200029d4

080182ec <SFXDelayAlloc>:
        {
 80182ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            tTapeDelay_initToPool(&delay, 2000, 30000, &mediumPool);
 80182ee:	4f2c      	ldr	r7, [pc, #176]	; (80183a0 <SFXDelayAlloc+0xb4>)
            leaf.clearOnAllocation = 1;
 80182f0:	2501      	movs	r5, #1
 80182f2:	4e2c      	ldr	r6, [pc, #176]	; (80183a4 <SFXDelayAlloc+0xb8>)
            tTapeDelay_initToPool(&delay, 2000, 30000, &mediumPool);
 80182f4:	f247 5130 	movw	r1, #30000	; 0x7530
 80182f8:	463a      	mov	r2, r7
 80182fa:	482b      	ldr	r0, [pc, #172]	; (80183a8 <SFXDelayAlloc+0xbc>)
            delayShaper = 0;
 80182fc:	2400      	movs	r4, #0
            leaf.clearOnAllocation = 1;
 80182fe:	6175      	str	r5, [r6, #20]
        {
 8018300:	ed2d 8b04 	vpush	{d8-d9}
            tTapeDelay_initToPool(&delay, 2000, 30000, &mediumPool);
 8018304:	ed9f 9a29 	vldr	s18, [pc, #164]	; 80183ac <SFXDelayAlloc+0xc0>
            tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
 8018308:	ed9f 8a29 	vldr	s16, [pc, #164]	; 80183b0 <SFXDelayAlloc+0xc4>
            tTapeDelay_initToPool(&delay, 2000, 30000, &mediumPool);
 801830c:	eeb0 0a49 	vmov.f32	s0, s18
            tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
 8018310:	eddf 8a28 	vldr	s17, [pc, #160]	; 80183b4 <SFXDelayAlloc+0xc8>
            tTapeDelay_initToPool(&delay, 2000, 30000, &mediumPool);
 8018314:	f007 fa0c 	bl	801f730 <tTapeDelay_initToPool>
            tTapeDelay_initToPool(&delay2, 2000, 30000, &mediumPool);
 8018318:	463a      	mov	r2, r7
 801831a:	eeb0 0a49 	vmov.f32	s0, s18
 801831e:	f247 5130 	movw	r1, #30000	; 0x7530
 8018322:	4825      	ldr	r0, [pc, #148]	; (80183b8 <SFXDelayAlloc+0xcc>)
 8018324:	f007 fa04 	bl	801f730 <tTapeDelay_initToPool>
            tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
 8018328:	eef0 0a48 	vmov.f32	s1, s16
 801832c:	eeb0 0a68 	vmov.f32	s0, s17
 8018330:	4629      	mov	r1, r5
 8018332:	4822      	ldr	r0, [pc, #136]	; (80183bc <SFXDelayAlloc+0xd0>)
 8018334:	f00a fa64 	bl	8022800 <tSVF_init>
            tSVF_init(&delayHP, SVFTypeHighpass, 20.f, .7f);
 8018338:	eef0 0a48 	vmov.f32	s1, s16
 801833c:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8018340:	4621      	mov	r1, r4
 8018342:	481f      	ldr	r0, [pc, #124]	; (80183c0 <SFXDelayAlloc+0xd4>)
 8018344:	f00a fa5c 	bl	8022800 <tSVF_init>
            tSVF_init(&delayLP2, SVFTypeLowpass, 16000.f, .7f);
 8018348:	eef0 0a48 	vmov.f32	s1, s16
 801834c:	eeb0 0a68 	vmov.f32	s0, s17
 8018350:	4629      	mov	r1, r5
 8018352:	481c      	ldr	r0, [pc, #112]	; (80183c4 <SFXDelayAlloc+0xd8>)
 8018354:	f00a fa54 	bl	8022800 <tSVF_init>
            tSVF_init(&delayHP2, SVFTypeHighpass, 20.f, .7f);
 8018358:	eef0 0a48 	vmov.f32	s1, s16
 801835c:	4621      	mov	r1, r4
 801835e:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8018362:	4819      	ldr	r0, [pc, #100]	; (80183c8 <SFXDelayAlloc+0xdc>)
 8018364:	f00a fa4c 	bl	8022800 <tSVF_init>
            tHighpass_init(&delayShaperHp, 20.0f);
 8018368:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 801836c:	4817      	ldr	r0, [pc, #92]	; (80183cc <SFXDelayAlloc+0xe0>)
 801836e:	f00a fbf9 	bl	8022b64 <tHighpass_init>
            tFeedbackLeveler_init(&feedbackControl, .99f, 0.01f, 0.125f, 0);
 8018372:	4621      	mov	r1, r4
 8018374:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
 8018378:	eddf 0a15 	vldr	s1, [pc, #84]	; 80183d0 <SFXDelayAlloc+0xe4>
 801837c:	ed9f 0a15 	vldr	s0, [pc, #84]	; 80183d4 <SFXDelayAlloc+0xe8>
 8018380:	4815      	ldr	r0, [pc, #84]	; (80183d8 <SFXDelayAlloc+0xec>)
 8018382:	f007 febb 	bl	80200fc <tFeedbackLeveler_init>
            capFeedback = 1;
 8018386:	4915      	ldr	r1, [pc, #84]	; (80183dc <SFXDelayAlloc+0xf0>)
            delayShaper = 0;
 8018388:	4a15      	ldr	r2, [pc, #84]	; (80183e0 <SFXDelayAlloc+0xf4>)
            setLED_A(delayShaper);
 801838a:	4620      	mov	r0, r4
            freeze = 0;
 801838c:	4b15      	ldr	r3, [pc, #84]	; (80183e4 <SFXDelayAlloc+0xf8>)
            capFeedback = 1;
 801838e:	600d      	str	r5, [r1, #0]
            delayShaper = 0;
 8018390:	6014      	str	r4, [r2, #0]
            freeze = 0;
 8018392:	601c      	str	r4, [r3, #0]
            setLED_A(delayShaper);
 8018394:	f7fb fada 	bl	801394c <setLED_A>
            leaf.clearOnAllocation = 0;
 8018398:	6174      	str	r4, [r6, #20]
        }
 801839a:	ecbd 8b04 	vpop	{d8-d9}
 801839e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80183a0:	200174cc 	.word	0x200174cc
 80183a4:	200194e8 	.word	0x200194e8
 80183a8:	200177b8 	.word	0x200177b8
 80183ac:	44fa0000 	.word	0x44fa0000
 80183b0:	3f333333 	.word	0x3f333333
 80183b4:	467a0000 	.word	0x467a0000
 80183b8:	20003600 	.word	0x20003600
 80183bc:	20017644 	.word	0x20017644
 80183c0:	20017280 	.word	0x20017280
 80183c4:	200175bc 	.word	0x200175bc
 80183c8:	200174d0 	.word	0x200174d0
 80183cc:	200174b0 	.word	0x200174b0
 80183d0:	3c23d70a 	.word	0x3c23d70a
 80183d4:	3f7d70a4 	.word	0x3f7d70a4
 80183d8:	200172e8 	.word	0x200172e8
 80183dc:	20000538 	.word	0x20000538
 80183e0:	20000588 	.word	0x20000588
 80183e4:	200005a0 	.word	0x200005a0

080183e8 <SFXDelayFrame>:
        {
 80183e8:	b510      	push	{r4, lr}
            if (buttonActionsSFX[ButtonA][ActionPress])
 80183ea:	4c14      	ldr	r4, [pc, #80]	; (801843c <SFXDelayFrame+0x54>)
 80183ec:	7d23      	ldrb	r3, [r4, #20]
 80183ee:	b9cb      	cbnz	r3, 8018424 <SFXDelayFrame+0x3c>
            if (buttonActionsSFX[ButtonB][ActionPress])
 80183f0:	7e23      	ldrb	r3, [r4, #24]
 80183f2:	b13b      	cbz	r3, 8018404 <SFXDelayFrame+0x1c>
                capFeedback = !capFeedback;
 80183f4:	4a12      	ldr	r2, [pc, #72]	; (8018440 <SFXDelayFrame+0x58>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 80183f6:	2100      	movs	r1, #0
                capFeedback = !capFeedback;
 80183f8:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 80183fa:	7621      	strb	r1, [r4, #24]
                capFeedback = !capFeedback;
 80183fc:	fab3 f383 	clz	r3, r3
 8018400:	095b      	lsrs	r3, r3, #5
 8018402:	6013      	str	r3, [r2, #0]
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018404:	7f23      	ldrb	r3, [r4, #28]
 8018406:	b903      	cbnz	r3, 801840a <SFXDelayFrame+0x22>
        }
 8018408:	bd10      	pop	{r4, pc}
                freeze = !freeze;
 801840a:	4a0e      	ldr	r2, [pc, #56]	; (8018444 <SFXDelayFrame+0x5c>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801840c:	2100      	movs	r1, #0
                freeze = !freeze;
 801840e:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8018410:	7721      	strb	r1, [r4, #28]
                freeze = !freeze;
 8018412:	fab3 f383 	clz	r3, r3
 8018416:	095b      	lsrs	r3, r3, #5
 8018418:	6013      	str	r3, [r2, #0]
                setLED_C(freeze);
 801841a:	4618      	mov	r0, r3
        }
 801841c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                setLED_C(freeze);
 8018420:	f7fb bab0 	b.w	8013984 <setLED_C>
                delayShaper = !delayShaper;
 8018424:	4a08      	ldr	r2, [pc, #32]	; (8018448 <SFXDelayFrame+0x60>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8018426:	2100      	movs	r1, #0
                delayShaper = !delayShaper;
 8018428:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801842a:	7521      	strb	r1, [r4, #20]
                delayShaper = !delayShaper;
 801842c:	fab3 f383 	clz	r3, r3
 8018430:	095b      	lsrs	r3, r3, #5
                setLED_A(delayShaper);
 8018432:	4618      	mov	r0, r3
                delayShaper = !delayShaper;
 8018434:	6013      	str	r3, [r2, #0]
                setLED_A(delayShaper);
 8018436:	f7fb fa89 	bl	801394c <setLED_A>
 801843a:	e7d9      	b.n	80183f0 <SFXDelayFrame+0x8>
 801843c:	2001872c 	.word	0x2001872c
 8018440:	20000538 	.word	0x20000538
 8018444:	200005a0 	.word	0x200005a0
 8018448:	20000588 	.word	0x20000588

0801844c <SFXDelayTick>:
        {
 801844c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 801844e:	4d88      	ldr	r5, [pc, #544]	; (8018670 <SFXDelayTick+0x224>)
        {
 8018450:	4607      	mov	r7, r0
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 8018452:	eddf 6a88 	vldr	s13, [pc, #544]	; 8018674 <SFXDelayTick+0x228>
 8018456:	462b      	mov	r3, r5
 8018458:	4c87      	ldr	r4, [pc, #540]	; (8018678 <SFXDelayTick+0x22c>)
        {
 801845a:	ed2d 8b02 	vpush	{d8}
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
 801845e:	eeb2 8a04 	vmov.f32	s16, #36	; 0x41200000  10.0
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 8018462:	ecb3 7a01 	vldmia	r3!, {s14}
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
 8018466:	edd5 7a02 	vldr	s15, [r5, #8]
 801846a:	eddf 8a84 	vldr	s17, [pc, #528]	; 801867c <SFXDelayTick+0x230>
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 801846e:	ee27 7a26 	vmul.f32	s14, s14, s13
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
 8018472:	eeb0 0a48 	vmov.f32	s0, s16
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 8018476:	ed84 7a00 	vstr	s14, [r4]
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
 801847a:	eea7 0aa8 	vfma.f32	s0, s15, s17
            displayValues[1] = presetKnobValues[Delay][1] * 30000.0f;
 801847e:	edd3 7a00 	vldr	s15, [r3]
 8018482:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8018486:	edc4 7a01 	vstr	s15, [r4, #4]
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
 801848a:	f00b fe83 	bl	8024194 <faster_mtof>
 801848e:	ed84 0a02 	vstr	s0, [r4, #8]
            displayValues[3] = faster_mtof((presetKnobValues[Delay][3] * 128) + 10.0f);
 8018492:	eeb0 0a48 	vmov.f32	s0, s16
 8018496:	edd5 7a03 	vldr	s15, [r5, #12]
 801849a:	eea7 0aa8 	vfma.f32	s0, s15, s17
 801849e:	f00b fe79 	bl	8024194 <faster_mtof>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
 80184a2:	4b77      	ldr	r3, [pc, #476]	; (8018680 <SFXDelayTick+0x234>)
            displayValues[3] = faster_mtof((presetKnobValues[Delay][3] * 128) + 10.0f);
 80184a4:	ed84 0a03 	vstr	s0, [r4, #12]
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
 80184a8:	681b      	ldr	r3, [r3, #0]
 80184aa:	2b00      	cmp	r3, #0
 80184ac:	f040 80d1 	bne.w	8018652 <SFXDelayTick+0x206>
 80184b0:	edd5 7a04 	vldr	s15, [r5, #16]
 80184b4:	ed9f 7a73 	vldr	s14, [pc, #460]	; 8018684 <SFXDelayTick+0x238>
 80184b8:	ee67 7a87 	vmul.f32	s15, s15, s14
            displayValues[5] = presetKnobValues[Delay][5];
 80184bc:	4b72      	ldr	r3, [pc, #456]	; (8018688 <SFXDelayTick+0x23c>)
            tSVF_setFreq(&delayHP, displayValues[2]);
 80184be:	ed94 0a02 	vldr	s0, [r4, #8]
            displayValues[5] = presetKnobValues[Delay][5];
 80184c2:	681b      	ldr	r3, [r3, #0]
            tSVF_setFreq(&delayHP, displayValues[2]);
 80184c4:	4871      	ldr	r0, [pc, #452]	; (801868c <SFXDelayTick+0x240>)
            displayValues[5] = presetKnobValues[Delay][5];
 80184c6:	6163      	str	r3, [r4, #20]
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
 80184c8:	edc4 7a04 	vstr	s15, [r4, #16]
            tSVF_setFreq(&delayHP, displayValues[2]);
 80184cc:	f00a fa4c 	bl	8022968 <tSVF_setFreq>
            tSVF_setFreq(&delayHP2, displayValues[2]);
 80184d0:	ed94 0a02 	vldr	s0, [r4, #8]
 80184d4:	486e      	ldr	r0, [pc, #440]	; (8018690 <SFXDelayTick+0x244>)
 80184d6:	f00a fa47 	bl	8022968 <tSVF_setFreq>
            tSVF_setFreq(&delayLP, displayValues[3]);
 80184da:	ed94 0a03 	vldr	s0, [r4, #12]
 80184de:	486d      	ldr	r0, [pc, #436]	; (8018694 <SFXDelayTick+0x248>)
 80184e0:	f00a fa42 	bl	8022968 <tSVF_setFreq>
            tSVF_setFreq(&delayLP2, displayValues[3]);
 80184e4:	ed94 0a03 	vldr	s0, [r4, #12]
 80184e8:	486b      	ldr	r0, [pc, #428]	; (8018698 <SFXDelayTick+0x24c>)
 80184ea:	f00a fa3d 	bl	8022968 <tSVF_setFreq>
            if (delayShaper == 0)
 80184ee:	4b6b      	ldr	r3, [pc, #428]	; (801869c <SFXDelayTick+0x250>)
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
 80184f0:	4e6b      	ldr	r6, [pc, #428]	; (80186a0 <SFXDelayTick+0x254>)
            if (delayShaper == 0)
 80184f2:	681b      	ldr	r3, [r3, #0]
 80184f4:	2b00      	cmp	r3, #0
 80184f6:	d16d      	bne.n	80185d4 <SFXDelayTick+0x188>
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
 80184f8:	ed94 7a04 	vldr	s14, [r4, #16]
 80184fc:	edd6 7a00 	vldr	s15, [r6]
 8018500:	ed97 0a01 	vldr	s0, [r7, #4]
                input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
 8018504:	4d67      	ldr	r5, [pc, #412]	; (80186a4 <SFXDelayTick+0x258>)
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
 8018506:	eea7 0a27 	vfma.f32	s0, s14, s15
 801850a:	f00f f99f 	bl	802784c <tanhf>
 801850e:	4866      	ldr	r0, [pc, #408]	; (80186a8 <SFXDelayTick+0x25c>)
 8018510:	f007 fe56 	bl	80201c0 <tFeedbackLeveler_tick>
                input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
 8018514:	edd5 7a00 	vldr	s15, [r5]
 8018518:	ed94 7a04 	vldr	s14, [r4, #16]
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
 801851c:	eef0 8a40 	vmov.f32	s17, s0
                input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
 8018520:	ed97 0a01 	vldr	s0, [r7, #4]
 8018524:	eea7 0a27 	vfma.f32	s0, s14, s15
 8018528:	f00f f990 	bl	802784c <tanhf>
 801852c:	485e      	ldr	r0, [pc, #376]	; (80186a8 <SFXDelayTick+0x25c>)
 801852e:	f007 fe47 	bl	80201c0 <tFeedbackLeveler_tick>
 8018532:	eeb0 8a40 	vmov.f32	s16, s0
            tTapeDelay_setDelay(&delay, displayValues[0]);
 8018536:	ed94 0a00 	vldr	s0, [r4]
 801853a:	485c      	ldr	r0, [pc, #368]	; (80186ac <SFXDelayTick+0x260>)
 801853c:	f007 f9ac 	bl	801f898 <tTapeDelay_setDelay>
            tTapeDelay_setDelay(&delay2, displayValues[1]);
 8018540:	ed94 0a01 	vldr	s0, [r4, #4]
 8018544:	485a      	ldr	r0, [pc, #360]	; (80186b0 <SFXDelayTick+0x264>)
 8018546:	f007 f9a7 	bl	801f898 <tTapeDelay_setDelay>
            if (!freeze)
 801854a:	4b5a      	ldr	r3, [pc, #360]	; (80186b4 <SFXDelayTick+0x268>)
 801854c:	681b      	ldr	r3, [r3, #0]
 801854e:	2b00      	cmp	r3, #0
 8018550:	d070      	beq.n	8018634 <SFXDelayTick+0x1e8>
                delayFB1 = tTapeDelay_tick(&delay, delayFB1);
 8018552:	4856      	ldr	r0, [pc, #344]	; (80186ac <SFXDelayTick+0x260>)
 8018554:	ed96 0a00 	vldr	s0, [r6]
 8018558:	f007 f928 	bl	801f7ac <tTapeDelay_tick>
                delayFB2 = tTapeDelay_tick(&delay2, delayFB2);
 801855c:	4854      	ldr	r0, [pc, #336]	; (80186b0 <SFXDelayTick+0x264>)
                delayFB1 = tTapeDelay_tick(&delay, delayFB1);
 801855e:	ed86 0a00 	vstr	s0, [r6]
                delayFB2 = tTapeDelay_tick(&delay2, delayFB2);
 8018562:	ed95 0a00 	vldr	s0, [r5]
 8018566:	f007 f921 	bl	801f7ac <tTapeDelay_tick>
 801856a:	ed85 0a00 	vstr	s0, [r5]
            delayFB1 = tSVF_tick(&delayLP, delayFB1);
 801856e:	4849      	ldr	r0, [pc, #292]	; (8018694 <SFXDelayTick+0x248>)
 8018570:	ed96 0a00 	vldr	s0, [r6]
 8018574:	f00a f9c2 	bl	80228fc <tSVF_tick>
            delayFB2 = tSVF_tick(&delayLP2, delayFB2);
 8018578:	4847      	ldr	r0, [pc, #284]	; (8018698 <SFXDelayTick+0x24c>)
            delayFB1 = tSVF_tick(&delayLP, delayFB1);
 801857a:	ed86 0a00 	vstr	s0, [r6]
            delayFB2 = tSVF_tick(&delayLP2, delayFB2);
 801857e:	ed95 0a00 	vldr	s0, [r5]
 8018582:	f00a f9bb 	bl	80228fc <tSVF_tick>
            delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
 8018586:	4841      	ldr	r0, [pc, #260]	; (801868c <SFXDelayTick+0x240>)
            delayFB2 = tSVF_tick(&delayLP2, delayFB2);
 8018588:	ed85 0a00 	vstr	s0, [r5]
            delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
 801858c:	ed96 0a00 	vldr	s0, [r6]
 8018590:	f00a f9b4 	bl	80228fc <tSVF_tick>
 8018594:	f00f f95a 	bl	802784c <tanhf>
            delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
 8018598:	483d      	ldr	r0, [pc, #244]	; (8018690 <SFXDelayTick+0x244>)
            delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
 801859a:	ed86 0a00 	vstr	s0, [r6]
            delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
 801859e:	ed95 0a00 	vldr	s0, [r5]
 80185a2:	f00a f9ab 	bl	80228fc <tSVF_tick>
 80185a6:	f00f f951 	bl	802784c <tanhf>
            input[0] = delayFB1 * displayValues[5];
 80185aa:	edd4 7a05 	vldr	s15, [r4, #20]
 80185ae:	ed96 7a00 	vldr	s14, [r6]
            delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
 80185b2:	ed85 0a00 	vstr	s0, [r5]
            input[0] = delayFB1 * displayValues[5];
 80185b6:	ee67 7a87 	vmul.f32	s15, s15, s14
 80185ba:	edc7 7a00 	vstr	s15, [r7]
            input[1] = delayFB2 * displayValues[5];
 80185be:	edd4 7a05 	vldr	s15, [r4, #20]
 80185c2:	ed95 7a00 	vldr	s14, [r5]
 80185c6:	ee67 7a87 	vmul.f32	s15, s15, s14
 80185ca:	edc7 7a01 	vstr	s15, [r7, #4]
        }
 80185ce:	ecbd 8b02 	vpop	{d8}
 80185d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
 80185d4:	ed96 7a00 	vldr	s14, [r6]
 80185d8:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 80185dc:	edd4 7a04 	vldr	s15, [r4, #16]
 80185e0:	ed97 0a01 	vldr	s0, [r7, #4]
 80185e4:	ee67 7a87 	vmul.f32	s15, s15, s14
                input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
 80185e8:	4d2e      	ldr	r5, [pc, #184]	; (80186a4 <SFXDelayTick+0x258>)
                input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
 80185ea:	eef0 0a48 	vmov.f32	s1, s16
 80185ee:	eea7 0a88 	vfma.f32	s0, s15, s16
 80185f2:	f00b fc05 	bl	8023e00 <LEAF_shaper>
 80185f6:	4830      	ldr	r0, [pc, #192]	; (80186b8 <SFXDelayTick+0x26c>)
 80185f8:	f00a fb08 	bl	8022c0c <tHighpass_tick>
 80185fc:	482a      	ldr	r0, [pc, #168]	; (80186a8 <SFXDelayTick+0x25c>)
 80185fe:	f007 fddf 	bl	80201c0 <tFeedbackLeveler_tick>
                input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
 8018602:	ed95 7a00 	vldr	s14, [r5]
 8018606:	edd4 7a04 	vldr	s15, [r4, #16]
                input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
 801860a:	eef0 8a40 	vmov.f32	s17, s0
                input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
 801860e:	ed97 0a01 	vldr	s0, [r7, #4]
 8018612:	eef0 0a48 	vmov.f32	s1, s16
 8018616:	ee67 7a87 	vmul.f32	s15, s15, s14
 801861a:	eea7 0a88 	vfma.f32	s0, s15, s16
 801861e:	f00b fbef 	bl	8023e00 <LEAF_shaper>
 8018622:	4825      	ldr	r0, [pc, #148]	; (80186b8 <SFXDelayTick+0x26c>)
 8018624:	f00a faf2 	bl	8022c0c <tHighpass_tick>
 8018628:	481f      	ldr	r0, [pc, #124]	; (80186a8 <SFXDelayTick+0x25c>)
 801862a:	f007 fdc9 	bl	80201c0 <tFeedbackLeveler_tick>
 801862e:	eeb0 8a40 	vmov.f32	s16, s0
 8018632:	e780      	b.n	8018536 <SFXDelayTick+0xea>
                delayFB1 = tTapeDelay_tick(&delay, input1);
 8018634:	481d      	ldr	r0, [pc, #116]	; (80186ac <SFXDelayTick+0x260>)
 8018636:	eeb0 0a68 	vmov.f32	s0, s17
 801863a:	f007 f8b7 	bl	801f7ac <tTapeDelay_tick>
                delayFB2 = tTapeDelay_tick(&delay2, input2);
 801863e:	481c      	ldr	r0, [pc, #112]	; (80186b0 <SFXDelayTick+0x264>)
                delayFB1 = tTapeDelay_tick(&delay, input1);
 8018640:	ed86 0a00 	vstr	s0, [r6]
                delayFB2 = tTapeDelay_tick(&delay2, input2);
 8018644:	eeb0 0a48 	vmov.f32	s0, s16
 8018648:	f007 f8b0 	bl	801f7ac <tTapeDelay_tick>
 801864c:	ed85 0a00 	vstr	s0, [r5]
 8018650:	e78d      	b.n	801856e <SFXDelayTick+0x122>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
 8018652:	eddf 7a0c 	vldr	s15, [pc, #48]	; 8018684 <SFXDelayTick+0x238>
 8018656:	edd5 0a04 	vldr	s1, [r5, #16]
 801865a:	ed9f 1a18 	vldr	s2, [pc, #96]	; 80186bc <SFXDelayTick+0x270>
 801865e:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8018662:	ed9f 0a17 	vldr	s0, [pc, #92]	; 80186c0 <SFXDelayTick+0x274>
 8018666:	f00b fc25 	bl	8023eb4 <LEAF_clip>
 801866a:	eef0 7a40 	vmov.f32	s15, s0
 801866e:	e725      	b.n	80184bc <SFXDelayTick+0x70>
 8018670:	20003104 	.word	0x20003104
 8018674:	46ea6000 	.word	0x46ea6000
 8018678:	200187dc 	.word	0x200187dc
 801867c:	43000000 	.word	0x43000000
 8018680:	20000538 	.word	0x20000538
 8018684:	3f8ccccd 	.word	0x3f8ccccd
 8018688:	20003118 	.word	0x20003118
 801868c:	20017280 	.word	0x20017280
 8018690:	200174d0 	.word	0x200174d0
 8018694:	20017644 	.word	0x20017644
 8018698:	200175bc 	.word	0x200175bc
 801869c:	20000588 	.word	0x20000588
 80186a0:	200174c4 	.word	0x200174c4
 80186a4:	2001827c 	.word	0x2001827c
 80186a8:	200172e8 	.word	0x200172e8
 80186ac:	200177b8 	.word	0x200177b8
 80186b0:	20003600 	.word	0x20003600
 80186b4:	200005a0 	.word	0x200005a0
 80186b8:	200174b0 	.word	0x200174b0
 80186bc:	3f666666 	.word	0x3f666666
 80186c0:	00000000 	.word	0x00000000

080186c4 <SFXDelayFree>:
        {
 80186c4:	b508      	push	{r3, lr}
            tTapeDelay_free(&delay);
 80186c6:	480d      	ldr	r0, [pc, #52]	; (80186fc <SFXDelayFree+0x38>)
 80186c8:	f007 f864 	bl	801f794 <tTapeDelay_free>
            tTapeDelay_free(&delay2);
 80186cc:	480c      	ldr	r0, [pc, #48]	; (8018700 <SFXDelayFree+0x3c>)
 80186ce:	f007 f861 	bl	801f794 <tTapeDelay_free>
            tSVF_free(&delayLP);
 80186d2:	480c      	ldr	r0, [pc, #48]	; (8018704 <SFXDelayFree+0x40>)
 80186d4:	f00a f90e 	bl	80228f4 <tSVF_free>
            tSVF_free(&delayHP);
 80186d8:	480b      	ldr	r0, [pc, #44]	; (8018708 <SFXDelayFree+0x44>)
 80186da:	f00a f90b 	bl	80228f4 <tSVF_free>
            tSVF_free(&delayLP2);
 80186de:	480b      	ldr	r0, [pc, #44]	; (801870c <SFXDelayFree+0x48>)
 80186e0:	f00a f908 	bl	80228f4 <tSVF_free>
            tSVF_free(&delayHP2);
 80186e4:	480a      	ldr	r0, [pc, #40]	; (8018710 <SFXDelayFree+0x4c>)
 80186e6:	f00a f905 	bl	80228f4 <tSVF_free>
            tHighpass_free(&delayShaperHp);
 80186ea:	480a      	ldr	r0, [pc, #40]	; (8018714 <SFXDelayFree+0x50>)
 80186ec:	f00a fa7a 	bl	8022be4 <tHighpass_free>
            tFeedbackLeveler_free(&feedbackControl);
 80186f0:	4809      	ldr	r0, [pc, #36]	; (8018718 <SFXDelayFree+0x54>)
        }
 80186f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tFeedbackLeveler_free(&feedbackControl);
 80186f6:	f007 bd53 	b.w	80201a0 <tFeedbackLeveler_free>
 80186fa:	bf00      	nop
 80186fc:	200177b8 	.word	0x200177b8
 8018700:	20003600 	.word	0x20003600
 8018704:	20017644 	.word	0x20017644
 8018708:	20017280 	.word	0x20017280
 801870c:	200175bc 	.word	0x200175bc
 8018710:	200174d0 	.word	0x200174d0
 8018714:	200174b0 	.word	0x200174b0
 8018718:	200172e8 	.word	0x200172e8

0801871c <SFXReverbAlloc>:
        {
 801871c:	b570      	push	{r4, r5, r6, lr}
            tDattorroReverb_initToPool(&reverb, &mediumPool);
 801871e:	4e0d      	ldr	r6, [pc, #52]	; (8018754 <SFXReverbAlloc+0x38>)
            leaf.clearOnAllocation = 1;
 8018720:	2501      	movs	r5, #1
 8018722:	4c0d      	ldr	r4, [pc, #52]	; (8018758 <SFXReverbAlloc+0x3c>)
            tDattorroReverb_initToPool(&reverb, &mediumPool);
 8018724:	490d      	ldr	r1, [pc, #52]	; (801875c <SFXReverbAlloc+0x40>)
 8018726:	4630      	mov	r0, r6
            leaf.clearOnAllocation = 1;
 8018728:	6165      	str	r5, [r4, #20]
            tDattorroReverb_initToPool(&reverb, &mediumPool);
 801872a:	f00d f8e9 	bl	8025900 <tDattorroReverb_initToPool>
            tExpSmooth_init(&sizeSmoother, 0.5f, 0.001f);
 801872e:	eddf 0a0c 	vldr	s1, [pc, #48]	; 8018760 <SFXReverbAlloc+0x44>
 8018732:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
 8018736:	480b      	ldr	r0, [pc, #44]	; (8018764 <SFXReverbAlloc+0x48>)
 8018738:	f009 febc 	bl	80224b4 <tExpSmooth_init>
            tDattorroReverb_setMix(&reverb, 1.0f);
 801873c:	4630      	mov	r0, r6
 801873e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8018742:	f00d fc9f 	bl	8026084 <tDattorroReverb_setMix>
            freeze = 0;
 8018746:	2300      	movs	r3, #0
            capFeedback = 1;
 8018748:	4907      	ldr	r1, [pc, #28]	; (8018768 <SFXReverbAlloc+0x4c>)
            freeze = 0;
 801874a:	4a08      	ldr	r2, [pc, #32]	; (801876c <SFXReverbAlloc+0x50>)
            capFeedback = 1;
 801874c:	600d      	str	r5, [r1, #0]
            leaf.clearOnAllocation = 0;
 801874e:	6163      	str	r3, [r4, #20]
            freeze = 0;
 8018750:	6013      	str	r3, [r2, #0]
        }
 8018752:	bd70      	pop	{r4, r5, r6, pc}
 8018754:	20002bf0 	.word	0x20002bf0
 8018758:	200194e8 	.word	0x200194e8
 801875c:	200174cc 	.word	0x200174cc
 8018760:	3a83126f 	.word	0x3a83126f
 8018764:	20018188 	.word	0x20018188
 8018768:	20000538 	.word	0x20000538
 801876c:	200005a0 	.word	0x200005a0

08018770 <SFXReverbFrame>:
            if (buttonActionsSFX[ButtonB][ActionPress])
 8018770:	4a1c      	ldr	r2, [pc, #112]	; (80187e4 <SFXReverbFrame+0x74>)
        {
 8018772:	b570      	push	{r4, r5, r6, lr}
 8018774:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonB][ActionPress])
 8018778:	7e13      	ldrb	r3, [r2, #24]
 801877a:	b13b      	cbz	r3, 801878c <SFXReverbFrame+0x1c>
                capFeedback = !capFeedback;
 801877c:	491a      	ldr	r1, [pc, #104]	; (80187e8 <SFXReverbFrame+0x78>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801877e:	2000      	movs	r0, #0
                capFeedback = !capFeedback;
 8018780:	680b      	ldr	r3, [r1, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8018782:	7610      	strb	r0, [r2, #24]
                capFeedback = !capFeedback;
 8018784:	fab3 f383 	clz	r3, r3
 8018788:	095b      	lsrs	r3, r3, #5
 801878a:	600b      	str	r3, [r1, #0]
            displayValues[1] = faster_mtof(presetKnobValues[Reverb][1]*129.0f);
 801878c:	4e17      	ldr	r6, [pc, #92]	; (80187ec <SFXReverbFrame+0x7c>)
 801878e:	ed9f 8a18 	vldr	s16, [pc, #96]	; 80187f0 <SFXReverbFrame+0x80>
 8018792:	4635      	mov	r5, r6
 8018794:	4c17      	ldr	r4, [pc, #92]	; (80187f4 <SFXReverbFrame+0x84>)
 8018796:	ecb5 0a01 	vldmia	r5!, {s0}
 801879a:	ee20 0a08 	vmul.f32	s0, s0, s16
 801879e:	f00b fcf9 	bl	8024194 <faster_mtof>
            tDattorroReverb_setFeedbackFilter(&reverb, displayValues[1]);
 80187a2:	4815      	ldr	r0, [pc, #84]	; (80187f8 <SFXReverbFrame+0x88>)
            displayValues[1] = faster_mtof(presetKnobValues[Reverb][1]*129.0f);
 80187a4:	ed84 0a01 	vstr	s0, [r4, #4]
            tDattorroReverb_setFeedbackFilter(&reverb, displayValues[1]);
 80187a8:	f00d fd54 	bl	8026254 <tDattorroReverb_setFeedbackFilter>
            displayValues[2] =  faster_mtof(presetKnobValues[Reverb][2]*123.0f);
 80187ac:	eddf 7a13 	vldr	s15, [pc, #76]	; 80187fc <SFXReverbFrame+0x8c>
 80187b0:	ed95 0a00 	vldr	s0, [r5]
 80187b4:	ee20 0a27 	vmul.f32	s0, s0, s15
 80187b8:	f00b fcec 	bl	8024194 <faster_mtof>
            tDattorroReverb_setHP(&reverb, displayValues[2]);
 80187bc:	480e      	ldr	r0, [pc, #56]	; (80187f8 <SFXReverbFrame+0x88>)
            displayValues[2] =  faster_mtof(presetKnobValues[Reverb][2]*123.0f);
 80187be:	ed84 0a02 	vstr	s0, [r4, #8]
            tDattorroReverb_setHP(&reverb, displayValues[2]);
 80187c2:	f00d fcad 	bl	8026120 <tDattorroReverb_setHP>
            displayValues[3] = faster_mtof(presetKnobValues[Reverb][3]*129.0f);
 80187c6:	ed96 0a02 	vldr	s0, [r6, #8]
 80187ca:	ee20 0a08 	vmul.f32	s0, s0, s16
 80187ce:	f00b fce1 	bl	8024194 <faster_mtof>
            tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
 80187d2:	4809      	ldr	r0, [pc, #36]	; (80187f8 <SFXReverbFrame+0x88>)
            displayValues[3] = faster_mtof(presetKnobValues[Reverb][3]*129.0f);
 80187d4:	ed84 0a03 	vstr	s0, [r4, #12]
        }
 80187d8:	ecbd 8b02 	vpop	{d8}
 80187dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
 80187e0:	f00d bd22 	b.w	8026228 <tDattorroReverb_setInputFilter>
 80187e4:	2001872c 	.word	0x2001872c
 80187e8:	20000538 	.word	0x20000538
 80187ec:	2000316c 	.word	0x2000316c
 80187f0:	43010000 	.word	0x43010000
 80187f4:	200187dc 	.word	0x200187dc
 80187f8:	20002bf0 	.word	0x20002bf0
 80187fc:	42f60000 	.word	0x42f60000

08018800 <SFXReverbTick>:
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018800:	4b34      	ldr	r3, [pc, #208]	; (80188d4 <SFXReverbTick+0xd4>)
        {
 8018802:	b570      	push	{r4, r5, r6, lr}
 8018804:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018808:	7f1a      	ldrb	r2, [r3, #28]
        {
 801880a:	b082      	sub	sp, #8
 801880c:	4604      	mov	r4, r0
            if (buttonActionsSFX[ButtonC][ActionPress])
 801880e:	2a00      	cmp	r2, #0
 8018810:	d144      	bne.n	801889c <SFXReverbTick+0x9c>
            input[1] *= 4.0f;
 8018812:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 8018816:	edd4 7a01 	vldr	s15, [r4, #4]
            displayValues[0] = presetKnobValues[Reverb][0];
 801881a:	4e2f      	ldr	r6, [pc, #188]	; (80188d8 <SFXReverbTick+0xd8>)
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
 801881c:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 80188dc <SFXReverbTick+0xdc>
            input[1] *= 4.0f;
 8018820:	ee67 7aa6 	vmul.f32	s15, s15, s13
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
 8018824:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 80188e0 <SFXReverbTick+0xe0>
            displayValues[0] = presetKnobValues[Reverb][0];
 8018828:	4d2e      	ldr	r5, [pc, #184]	; (80188e4 <SFXReverbTick+0xe4>)
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
 801882a:	482f      	ldr	r0, [pc, #188]	; (80188e8 <SFXReverbTick+0xe8>)
            input[1] *= 4.0f;
 801882c:	edc4 7a01 	vstr	s15, [r4, #4]
            displayValues[0] = presetKnobValues[Reverb][0];
 8018830:	edd6 7a00 	vldr	s15, [r6]
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
 8018834:	eea7 0a87 	vfma.f32	s0, s15, s14
            displayValues[0] = presetKnobValues[Reverb][0];
 8018838:	edc5 7a00 	vstr	s15, [r5]
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
 801883c:	f009 fea0 	bl	8022580 <tExpSmooth_setDest>
            float tempSize = tExpSmooth_tick(&sizeSmoother);
 8018840:	4829      	ldr	r0, [pc, #164]	; (80188e8 <SFXReverbTick+0xe8>)
 8018842:	f009 fea7 	bl	8022594 <tExpSmooth_tick>
            tDattorroReverb_setSize(&reverb, tempSize);
 8018846:	4829      	ldr	r0, [pc, #164]	; (80188ec <SFXReverbTick+0xec>)
 8018848:	f00d fc88 	bl	802615c <tDattorroReverb_setSize>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
 801884c:	4b28      	ldr	r3, [pc, #160]	; (80188f0 <SFXReverbTick+0xf0>)
 801884e:	681b      	ldr	r3, [r3, #0]
 8018850:	bba3      	cbnz	r3, 80188bc <SFXReverbTick+0xbc>
 8018852:	edd6 7a04 	vldr	s15, [r6, #16]
            tDattorroReverb_setFeedbackGain(&reverb, displayValues[4]);
 8018856:	eeb0 0a67 	vmov.f32	s0, s15
 801885a:	4824      	ldr	r0, [pc, #144]	; (80188ec <SFXReverbTick+0xec>)
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
 801885c:	edc5 7a04 	vstr	s15, [r5, #16]
            tDattorroReverb_setFeedbackGain(&reverb, displayValues[4]);
 8018860:	f00d fd14 	bl	802628c <tDattorroReverb_setFeedbackGain>
            sample = tanhf(stereo[0]) * 0.99f;
 8018864:	ed9f 8a23 	vldr	s16, [pc, #140]	; 80188f4 <SFXReverbTick+0xf4>
            tDattorroReverb_tickStereo(&reverb, input[1], stereo);
 8018868:	4669      	mov	r1, sp
 801886a:	4820      	ldr	r0, [pc, #128]	; (80188ec <SFXReverbTick+0xec>)
 801886c:	ed94 0a01 	vldr	s0, [r4, #4]
 8018870:	f00d fa60 	bl	8025d34 <tDattorroReverb_tickStereo>
            sample = tanhf(stereo[0]) * 0.99f;
 8018874:	ed9d 0a00 	vldr	s0, [sp]
 8018878:	f00e ffe8 	bl	802784c <tanhf>
 801887c:	ee60 7a08 	vmul.f32	s15, s0, s16
            input[1] = tanhf(stereo[1]) * 0.99f;
 8018880:	ed9d 0a01 	vldr	s0, [sp, #4]
            input[0] = sample;
 8018884:	edc4 7a00 	vstr	s15, [r4]
            input[1] = tanhf(stereo[1]) * 0.99f;
 8018888:	f00e ffe0 	bl	802784c <tanhf>
 801888c:	ee20 0a08 	vmul.f32	s0, s0, s16
 8018890:	ed84 0a01 	vstr	s0, [r4, #4]
        }
 8018894:	b002      	add	sp, #8
 8018896:	ecbd 8b02 	vpop	{d8}
 801889a:	bd70      	pop	{r4, r5, r6, pc}
                freeze = !freeze;
 801889c:	4d16      	ldr	r5, [pc, #88]	; (80188f8 <SFXReverbTick+0xf8>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801889e:	2100      	movs	r1, #0
                tDattorroReverb_setFreeze(&reverb, freeze);
 80188a0:	4812      	ldr	r0, [pc, #72]	; (80188ec <SFXReverbTick+0xec>)
                freeze = !freeze;
 80188a2:	682a      	ldr	r2, [r5, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 80188a4:	7719      	strb	r1, [r3, #28]
                freeze = !freeze;
 80188a6:	fab2 f282 	clz	r2, r2
 80188aa:	0952      	lsrs	r2, r2, #5
                tDattorroReverb_setFreeze(&reverb, freeze);
 80188ac:	4611      	mov	r1, r2
                freeze = !freeze;
 80188ae:	602a      	str	r2, [r5, #0]
                tDattorroReverb_setFreeze(&reverb, freeze);
 80188b0:	f00d fbf8 	bl	80260a4 <tDattorroReverb_setFreeze>
                setLED_C(freeze);
 80188b4:	6828      	ldr	r0, [r5, #0]
 80188b6:	f7fb f865 	bl	8013984 <setLED_C>
 80188ba:	e7aa      	b.n	8018812 <SFXReverbTick+0x12>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
 80188bc:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
 80188c0:	edd6 0a04 	vldr	s1, [r6, #16]
 80188c4:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 80188fc <SFXReverbTick+0xfc>
 80188c8:	f00b faf4 	bl	8023eb4 <LEAF_clip>
 80188cc:	eef0 7a40 	vmov.f32	s15, s0
 80188d0:	e7c1      	b.n	8018856 <SFXReverbTick+0x56>
 80188d2:	bf00      	nop
 80188d4:	2001872c 	.word	0x2001872c
 80188d8:	20003168 	.word	0x20003168
 80188dc:	3f666666 	.word	0x3f666666
 80188e0:	3dcccccd 	.word	0x3dcccccd
 80188e4:	200187dc 	.word	0x200187dc
 80188e8:	20018188 	.word	0x20018188
 80188ec:	20002bf0 	.word	0x20002bf0
 80188f0:	20000538 	.word	0x20000538
 80188f4:	3f7d70a4 	.word	0x3f7d70a4
 80188f8:	200005a0 	.word	0x200005a0
 80188fc:	00000000 	.word	0x00000000

08018900 <SFXReverbFree>:
        {
 8018900:	b508      	push	{r3, lr}
            tDattorroReverb_free(&reverb);
 8018902:	4804      	ldr	r0, [pc, #16]	; (8018914 <SFXReverbFree+0x14>)
 8018904:	f00d f9be 	bl	8025c84 <tDattorroReverb_free>
            tExpSmooth_free(&sizeSmoother);
 8018908:	4803      	ldr	r0, [pc, #12]	; (8018918 <SFXReverbFree+0x18>)
        }
 801890a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tExpSmooth_free(&sizeSmoother);
 801890e:	f009 be21 	b.w	8022554 <tExpSmooth_free>
 8018912:	bf00      	nop
 8018914:	20002bf0 	.word	0x20002bf0
 8018918:	20018188 	.word	0x20018188

0801891c <SFXReverb2Alloc>:
        {
 801891c:	b570      	push	{r4, r5, r6, lr}
            tNReverb_initToPool(&reverb2, 1.0f, &mediumPool);
 801891e:	4e27      	ldr	r6, [pc, #156]	; (80189bc <SFXReverb2Alloc+0xa0>)
            leaf.clearOnAllocation = 1;
 8018920:	2401      	movs	r4, #1
 8018922:	4d27      	ldr	r5, [pc, #156]	; (80189c0 <SFXReverb2Alloc+0xa4>)
            tNReverb_initToPool(&reverb2, 1.0f, &mediumPool);
 8018924:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8018928:	4926      	ldr	r1, [pc, #152]	; (80189c4 <SFXReverb2Alloc+0xa8>)
 801892a:	4630      	mov	r0, r6
            leaf.clearOnAllocation = 1;
 801892c:	616c      	str	r4, [r5, #20]
        {
 801892e:	ed2d 8b04 	vpush	{d8-d9}
            tSVF_init(&lowpass, SVFTypeLowpass, 18000.0f, 0.75f);
 8018932:	ed9f 9a25 	vldr	s18, [pc, #148]	; 80189c8 <SFXReverb2Alloc+0xac>
            tNReverb_initToPool(&reverb2, 1.0f, &mediumPool);
 8018936:	f00c fe09 	bl	802554c <tNReverb_initToPool>
            tSVF_init(&highpass, SVFTypeHighpass, 40.0f, 0.75f);
 801893a:	eddf 8a24 	vldr	s17, [pc, #144]	; 80189cc <SFXReverb2Alloc+0xb0>
            tNReverb_setMix(&reverb2, 1.0f);
 801893e:	4630      	mov	r0, r6
 8018940:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
            tSVF_init(&bandpass, SVFTypeBandpass, 2000.0f, 1.0f);
 8018944:	ed9f 8a22 	vldr	s16, [pc, #136]	; 80189d0 <SFXReverb2Alloc+0xb4>
            tNReverb_setMix(&reverb2, 1.0f);
 8018948:	f00c ff2e 	bl	80257a8 <tNReverb_setMix>
            tSVF_init(&lowpass, SVFTypeLowpass, 18000.0f, 0.75f);
 801894c:	eeb0 0a49 	vmov.f32	s0, s18
 8018950:	4621      	mov	r1, r4
 8018952:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
 8018956:	481f      	ldr	r0, [pc, #124]	; (80189d4 <SFXReverb2Alloc+0xb8>)
 8018958:	f009 ff52 	bl	8022800 <tSVF_init>
            tSVF_init(&highpass, SVFTypeHighpass, 40.0f, 0.75f);
 801895c:	eeb0 0a68 	vmov.f32	s0, s17
 8018960:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
 8018964:	2100      	movs	r1, #0
 8018966:	481c      	ldr	r0, [pc, #112]	; (80189d8 <SFXReverb2Alloc+0xbc>)
 8018968:	f009 ff4a 	bl	8022800 <tSVF_init>
            tSVF_init(&bandpass, SVFTypeBandpass, 2000.0f, 1.0f);
 801896c:	eeb0 0a48 	vmov.f32	s0, s16
 8018970:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8018974:	2102      	movs	r1, #2
 8018976:	4819      	ldr	r0, [pc, #100]	; (80189dc <SFXReverb2Alloc+0xc0>)
 8018978:	f009 ff42 	bl	8022800 <tSVF_init>
            tSVF_init(&lowpass2, SVFTypeLowpass, 18000.0f, 0.75f);
 801897c:	eeb0 0a49 	vmov.f32	s0, s18
 8018980:	4621      	mov	r1, r4
 8018982:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
 8018986:	4816      	ldr	r0, [pc, #88]	; (80189e0 <SFXReverb2Alloc+0xc4>)
 8018988:	f009 ff3a 	bl	8022800 <tSVF_init>
            tSVF_init(&highpass2, SVFTypeHighpass, 40.0f, 0.75f);
 801898c:	eeb0 0a68 	vmov.f32	s0, s17
 8018990:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
 8018994:	2100      	movs	r1, #0
 8018996:	4813      	ldr	r0, [pc, #76]	; (80189e4 <SFXReverb2Alloc+0xc8>)
 8018998:	f009 ff32 	bl	8022800 <tSVF_init>
            tSVF_init(&bandpass2, SVFTypeBandpass, 2000.0f, 1.0f);
 801899c:	eeb0 0a48 	vmov.f32	s0, s16
 80189a0:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 80189a4:	2102      	movs	r1, #2
 80189a6:	4810      	ldr	r0, [pc, #64]	; (80189e8 <SFXReverb2Alloc+0xcc>)
 80189a8:	f009 ff2a 	bl	8022800 <tSVF_init>
            freeze = 0;
 80189ac:	2300      	movs	r3, #0
 80189ae:	4a0f      	ldr	r2, [pc, #60]	; (80189ec <SFXReverb2Alloc+0xd0>)
            leaf.clearOnAllocation = 0;
 80189b0:	616b      	str	r3, [r5, #20]
            freeze = 0;
 80189b2:	6013      	str	r3, [r2, #0]
        }
 80189b4:	ecbd 8b04 	vpop	{d8-d9}
 80189b8:	bd70      	pop	{r4, r5, r6, pc}
 80189ba:	bf00      	nop
 80189bc:	20018280 	.word	0x20018280
 80189c0:	200194e8 	.word	0x200194e8
 80189c4:	200174cc 	.word	0x200174cc
 80189c8:	468ca000 	.word	0x468ca000
 80189cc:	42200000 	.word	0x42200000
 80189d0:	44fa0000 	.word	0x44fa0000
 80189d4:	200028f0 	.word	0x200028f0
 80189d8:	20018190 	.word	0x20018190
 80189dc:	200175b8 	.word	0x200175b8
 80189e0:	20017208 	.word	0x20017208
 80189e4:	200174b4 	.word	0x200174b4
 80189e8:	20017598 	.word	0x20017598
 80189ec:	200005a0 	.word	0x200005a0

080189f0 <SFXReverb2Frame>:
 80189f0:	4770      	bx	lr
 80189f2:	bf00      	nop

080189f4 <SFXReverb2Tick>:
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
 80189f4:	4b5f      	ldr	r3, [pc, #380]	; (8018b74 <SFXReverb2Tick+0x180>)
 80189f6:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
        {
 80189fa:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80189fe:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
 8018a02:	ed93 0a00 	vldr	s0, [r3]
        {
 8018a06:	b083      	sub	sp, #12
            if (!freeze)
 8018a08:	f8df 919c 	ldr.w	r9, [pc, #412]	; 8018ba8 <SFXReverb2Tick+0x1b4>
        {
 8018a0c:	4605      	mov	r5, r0
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
 8018a0e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8018a12:	4c59      	ldr	r4, [pc, #356]	; (8018b78 <SFXReverb2Tick+0x184>)
            if (!freeze)
 8018a14:	f8d9 3000 	ldr.w	r3, [r9]
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
 8018a18:	ed84 0a00 	vstr	s0, [r4]
            if (!freeze)
 8018a1c:	2b00      	cmp	r3, #0
 8018a1e:	f040 8092 	bne.w	8018b46 <SFXReverb2Tick+0x152>
                tNReverb_setT60(&reverb2, displayValues[0]);
 8018a22:	4856      	ldr	r0, [pc, #344]	; (8018b7c <SFXReverb2Tick+0x188>)
 8018a24:	f00c fe88 	bl	8025738 <tNReverb_setT60>
            displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
 8018a28:	4e55      	ldr	r6, [pc, #340]	; (8018b80 <SFXReverb2Tick+0x18c>)
 8018a2a:	eddf 7a56 	vldr	s15, [pc, #344]	; 8018b84 <SFXReverb2Tick+0x190>
 8018a2e:	4637      	mov	r7, r6
            displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
 8018a30:	ed9f 8a55 	vldr	s16, [pc, #340]	; 8018b88 <SFXReverb2Tick+0x194>
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018a34:	f8df 8174 	ldr.w	r8, [pc, #372]	; 8018bac <SFXReverb2Tick+0x1b8>
            displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
 8018a38:	ecb7 0a01 	vldmia	r7!, {s0}
 8018a3c:	ee20 0a27 	vmul.f32	s0, s0, s15
 8018a40:	f00b fba8 	bl	8024194 <faster_mtof>
            tSVF_setFreq(&lowpass, displayValues[1]);
 8018a44:	4851      	ldr	r0, [pc, #324]	; (8018b8c <SFXReverb2Tick+0x198>)
            displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
 8018a46:	ed84 0a01 	vstr	s0, [r4, #4]
            tSVF_setFreq(&lowpass, displayValues[1]);
 8018a4a:	f009 ff8d 	bl	8022968 <tSVF_setFreq>
            tSVF_setFreq(&lowpass2, displayValues[1]);
 8018a4e:	4850      	ldr	r0, [pc, #320]	; (8018b90 <SFXReverb2Tick+0x19c>)
 8018a50:	ed94 0a01 	vldr	s0, [r4, #4]
 8018a54:	f009 ff88 	bl	8022968 <tSVF_setFreq>
            displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
 8018a58:	ed97 0a00 	vldr	s0, [r7]
 8018a5c:	ee20 0a08 	vmul.f32	s0, s0, s16
 8018a60:	f00b fb98 	bl	8024194 <faster_mtof>
            tSVF_setFreq(&highpass, displayValues[2]);
 8018a64:	484b      	ldr	r0, [pc, #300]	; (8018b94 <SFXReverb2Tick+0x1a0>)
            displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
 8018a66:	ed84 0a02 	vstr	s0, [r4, #8]
            tSVF_setFreq(&highpass, displayValues[2]);
 8018a6a:	f009 ff7d 	bl	8022968 <tSVF_setFreq>
            tSVF_setFreq(&highpass2, displayValues[2]);
 8018a6e:	484a      	ldr	r0, [pc, #296]	; (8018b98 <SFXReverb2Tick+0x1a4>)
 8018a70:	ed94 0a02 	vldr	s0, [r4, #8]
 8018a74:	f009 ff78 	bl	8022968 <tSVF_setFreq>
            displayValues[3] = faster_mtof(presetKnobValues[Reverb2][3]*128.0f);
 8018a78:	ed96 0a02 	vldr	s0, [r6, #8]
 8018a7c:	ee20 0a08 	vmul.f32	s0, s0, s16
 8018a80:	f00b fb88 	bl	8024194 <faster_mtof>
            tSVF_setFreq(&bandpass, displayValues[3]);
 8018a84:	4845      	ldr	r0, [pc, #276]	; (8018b9c <SFXReverb2Tick+0x1a8>)
            displayValues[3] = faster_mtof(presetKnobValues[Reverb2][3]*128.0f);
 8018a86:	ed84 0a03 	vstr	s0, [r4, #12]
            tSVF_setFreq(&bandpass, displayValues[3]);
 8018a8a:	f009 ff6d 	bl	8022968 <tSVF_setFreq>
            tSVF_setFreq(&bandpass2, displayValues[3]);
 8018a8e:	ed94 0a03 	vldr	s0, [r4, #12]
 8018a92:	4843      	ldr	r0, [pc, #268]	; (8018ba0 <SFXReverb2Tick+0x1ac>)
 8018a94:	f009 ff68 	bl	8022968 <tSVF_setFreq>
            displayValues[4] = (presetKnobValues[Reverb2][4] * 4.0f) - 2.0f;
 8018a98:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8018a9c:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
 8018aa0:	edd6 6a03 	vldr	s13, [r6, #12]
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018aa4:	f898 301c 	ldrb.w	r3, [r8, #28]
            displayValues[4] = (presetKnobValues[Reverb2][4] * 4.0f) - 2.0f;
 8018aa8:	eee6 7a87 	vfma.f32	s15, s13, s14
 8018aac:	edc4 7a04 	vstr	s15, [r4, #16]
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018ab0:	2b00      	cmp	r3, #0
 8018ab2:	d150      	bne.n	8018b56 <SFXReverb2Tick+0x162>
            if (buttonActionsSFX[ButtonA][ActionPress])
 8018ab4:	f898 3014 	ldrb.w	r3, [r8, #20]
 8018ab8:	b163      	cbz	r3, 8018ad4 <SFXReverb2Tick+0xe0>
                freeze = !freeze;
 8018aba:	f8d9 3000 	ldr.w	r3, [r9]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8018abe:	2200      	movs	r2, #0
                freeze = !freeze;
 8018ac0:	fab3 f383 	clz	r3, r3
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8018ac4:	f888 2014 	strb.w	r2, [r8, #20]
                freeze = !freeze;
 8018ac8:	095b      	lsrs	r3, r3, #5
                setLED_C(freeze);
 8018aca:	4618      	mov	r0, r3
                freeze = !freeze;
 8018acc:	f8c9 3000 	str.w	r3, [r9]
                setLED_C(freeze);
 8018ad0:	f7fa ff58 	bl	8013984 <setLED_C>
            tNReverb_tickStereo(&reverb2, input[1], stereoOuts);
 8018ad4:	4669      	mov	r1, sp
 8018ad6:	ed95 0a01 	vldr	s0, [r5, #4]
 8018ada:	4828      	ldr	r0, [pc, #160]	; (8018b7c <SFXReverb2Tick+0x188>)
 8018adc:	f00c fe68 	bl	80257b0 <tNReverb_tickStereo>
            float leftOut = tSVF_tick(&lowpass, stereoOuts[0]);
 8018ae0:	ed9d 0a00 	vldr	s0, [sp]
 8018ae4:	4829      	ldr	r0, [pc, #164]	; (8018b8c <SFXReverb2Tick+0x198>)
 8018ae6:	f009 ff09 	bl	80228fc <tSVF_tick>
            leftOut = tSVF_tick(&highpass, leftOut);
 8018aea:	482a      	ldr	r0, [pc, #168]	; (8018b94 <SFXReverb2Tick+0x1a0>)
 8018aec:	f009 ff06 	bl	80228fc <tSVF_tick>
            leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
 8018af0:	482a      	ldr	r0, [pc, #168]	; (8018b9c <SFXReverb2Tick+0x1a8>)
            leftOut = tSVF_tick(&highpass, leftOut);
 8018af2:	eef0 8a40 	vmov.f32	s17, s0
            leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
 8018af6:	f009 ff01 	bl	80228fc <tSVF_tick>
 8018afa:	edd4 7a04 	vldr	s15, [r4, #16]
            float rightOutTemp = tSVF_tick(&lowpass2, stereoOuts[1]);
 8018afe:	4824      	ldr	r0, [pc, #144]	; (8018b90 <SFXReverb2Tick+0x19c>)
            leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
 8018b00:	eee0 8a27 	vfma.f32	s17, s0, s15
            float rightOutTemp = tSVF_tick(&lowpass2, stereoOuts[1]);
 8018b04:	ed9d 0a01 	vldr	s0, [sp, #4]
 8018b08:	f009 fef8 	bl	80228fc <tSVF_tick>
            rightOutTemp = tSVF_tick(&highpass2, rightOutTemp);
 8018b0c:	4822      	ldr	r0, [pc, #136]	; (8018b98 <SFXReverb2Tick+0x1a4>)
 8018b0e:	f009 fef5 	bl	80228fc <tSVF_tick>
            rightOutTemp += tSVF_tick(&bandpass, rightOutTemp) * displayValues[4];
 8018b12:	4822      	ldr	r0, [pc, #136]	; (8018b9c <SFXReverb2Tick+0x1a8>)
            rightOutTemp = tSVF_tick(&highpass2, rightOutTemp);
 8018b14:	eeb0 8a40 	vmov.f32	s16, s0
            rightOutTemp += tSVF_tick(&bandpass, rightOutTemp) * displayValues[4];
 8018b18:	f009 fef0 	bl	80228fc <tSVF_tick>
 8018b1c:	edd4 7a04 	vldr	s15, [r4, #16]
 8018b20:	eea0 8a27 	vfma.f32	s16, s0, s15
            sample = tanhf(leftOut);
 8018b24:	eeb0 0a68 	vmov.f32	s0, s17
 8018b28:	f00e fe90 	bl	802784c <tanhf>
            input[0] = sample;
 8018b2c:	ed85 0a00 	vstr	s0, [r5]
            input[1] = tanhf(rightOutTemp);
 8018b30:	eeb0 0a48 	vmov.f32	s0, s16
 8018b34:	f00e fe8a 	bl	802784c <tanhf>
 8018b38:	ed85 0a01 	vstr	s0, [r5, #4]
        }
 8018b3c:	b003      	add	sp, #12
 8018b3e:	ecbd 8b02 	vpop	{d8}
 8018b42:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                tNReverb_setT60(&reverb2, 1000.0f);
 8018b46:	ed9f 0a17 	vldr	s0, [pc, #92]	; 8018ba4 <SFXReverb2Tick+0x1b0>
 8018b4a:	480c      	ldr	r0, [pc, #48]	; (8018b7c <SFXReverb2Tick+0x188>)
 8018b4c:	f00c fdf4 	bl	8025738 <tNReverb_setT60>
                input[1] = 0.0f;
 8018b50:	2300      	movs	r3, #0
 8018b52:	606b      	str	r3, [r5, #4]
 8018b54:	e768      	b.n	8018a28 <SFXReverb2Tick+0x34>
                freeze = !freeze;
 8018b56:	f8d9 3000 	ldr.w	r3, [r9]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8018b5a:	2200      	movs	r2, #0
                freeze = !freeze;
 8018b5c:	fab3 f383 	clz	r3, r3
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8018b60:	f888 201c 	strb.w	r2, [r8, #28]
                freeze = !freeze;
 8018b64:	095b      	lsrs	r3, r3, #5
                setLED_C(freeze);
 8018b66:	4618      	mov	r0, r3
                freeze = !freeze;
 8018b68:	f8c9 3000 	str.w	r3, [r9]
                setLED_C(freeze);
 8018b6c:	f7fa ff0a 	bl	8013984 <setLED_C>
 8018b70:	e7a0      	b.n	8018ab4 <SFXReverb2Tick+0xc0>
 8018b72:	bf00      	nop
 8018b74:	200031cc 	.word	0x200031cc
 8018b78:	200187dc 	.word	0x200187dc
 8018b7c:	20018280 	.word	0x20018280
 8018b80:	200031d0 	.word	0x200031d0
 8018b84:	43070000 	.word	0x43070000
 8018b88:	43000000 	.word	0x43000000
 8018b8c:	200028f0 	.word	0x200028f0
 8018b90:	20017208 	.word	0x20017208
 8018b94:	20018190 	.word	0x20018190
 8018b98:	200174b4 	.word	0x200174b4
 8018b9c:	200175b8 	.word	0x200175b8
 8018ba0:	20017598 	.word	0x20017598
 8018ba4:	447a0000 	.word	0x447a0000
 8018ba8:	200005a0 	.word	0x200005a0
 8018bac:	2001872c 	.word	0x2001872c

08018bb0 <SFXReverb2Free>:
        {
 8018bb0:	b508      	push	{r3, lr}
            tNReverb_free(&reverb2);
 8018bb2:	480b      	ldr	r0, [pc, #44]	; (8018be0 <SFXReverb2Free+0x30>)
 8018bb4:	f00c fda4 	bl	8025700 <tNReverb_free>
            tSVF_free(&lowpass);
 8018bb8:	480a      	ldr	r0, [pc, #40]	; (8018be4 <SFXReverb2Free+0x34>)
 8018bba:	f009 fe9b 	bl	80228f4 <tSVF_free>
            tSVF_free(&highpass);
 8018bbe:	480a      	ldr	r0, [pc, #40]	; (8018be8 <SFXReverb2Free+0x38>)
 8018bc0:	f009 fe98 	bl	80228f4 <tSVF_free>
            tSVF_free(&bandpass);
 8018bc4:	4809      	ldr	r0, [pc, #36]	; (8018bec <SFXReverb2Free+0x3c>)
 8018bc6:	f009 fe95 	bl	80228f4 <tSVF_free>
            tSVF_free(&lowpass2);
 8018bca:	4809      	ldr	r0, [pc, #36]	; (8018bf0 <SFXReverb2Free+0x40>)
 8018bcc:	f009 fe92 	bl	80228f4 <tSVF_free>
            tSVF_free(&highpass2);
 8018bd0:	4808      	ldr	r0, [pc, #32]	; (8018bf4 <SFXReverb2Free+0x44>)
 8018bd2:	f009 fe8f 	bl	80228f4 <tSVF_free>
            tSVF_free(&bandpass2);
 8018bd6:	4808      	ldr	r0, [pc, #32]	; (8018bf8 <SFXReverb2Free+0x48>)
        }
 8018bd8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tSVF_free(&bandpass2);
 8018bdc:	f009 be8a 	b.w	80228f4 <tSVF_free>
 8018be0:	20018280 	.word	0x20018280
 8018be4:	200028f0 	.word	0x200028f0
 8018be8:	20018190 	.word	0x20018190
 8018bec:	200175b8 	.word	0x200175b8
 8018bf0:	20017208 	.word	0x20017208
 8018bf4:	200174b4 	.word	0x200174b4
 8018bf8:	20017598 	.word	0x20017598

08018bfc <SFXLivingStringAlloc>:
        {
 8018bfc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            levMode = 0;
 8018c00:	2300      	movs	r3, #0
 8018c02:	4e2b      	ldr	r6, [pc, #172]	; (8018cb0 <SFXLivingStringAlloc+0xb4>)
 8018c04:	4d2b      	ldr	r5, [pc, #172]	; (8018cb4 <SFXLivingStringAlloc+0xb8>)
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 8018c06:	2106      	movs	r1, #6
 8018c08:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 8018cec <SFXLivingStringAlloc+0xf0>
 8018c0c:	461c      	mov	r4, r3
 8018c0e:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 8018cf0 <SFXLivingStringAlloc+0xf4>
 8018c12:	4f29      	ldr	r7, [pc, #164]	; (8018cb8 <SFXLivingStringAlloc+0xbc>)
 8018c14:	4829      	ldr	r0, [pc, #164]	; (8018cbc <SFXLivingStringAlloc+0xc0>)
            levMode = 0;
 8018c16:	6033      	str	r3, [r6, #0]
        {
 8018c18:	ed2d 8b06 	vpush	{d8-d10}
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 8018c1c:	eddf aa28 	vldr	s21, [pc, #160]	; 8018cc0 <SFXLivingStringAlloc+0xc4>
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 8018c20:	f00b ffca 	bl	8024bb8 <tSimplePoly_setNumVoices>
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 8018c24:	ed9f aa27 	vldr	s20, [pc, #156]	; 8018cc4 <SFXLivingStringAlloc+0xc8>
                tComplexLivingString_initToPool(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode, &mediumPool);
 8018c28:	eddf 9a27 	vldr	s19, [pc, #156]	; 8018cc8 <SFXLivingStringAlloc+0xcc>
 8018c2c:	ed9f 9a27 	vldr	s18, [pc, #156]	; 8018ccc <SFXLivingStringAlloc+0xd0>
 8018c30:	ed9f 8a27 	vldr	s16, [pc, #156]	; 8018cd0 <SFXLivingStringAlloc+0xd4>
 8018c34:	eddf 8a27 	vldr	s17, [pc, #156]	; 8018cd4 <SFXLivingStringAlloc+0xd8>
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 8018c38:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8018c3c:	4798      	blx	r3
 8018c3e:	eef0 7a4a 	vmov.f32	s15, s20
                tComplexLivingString_initToPool(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode, &mediumPool);
 8018c42:	ed9f 3a1f 	vldr	s6, [pc, #124]	; 8018cc0 <SFXLivingStringAlloc+0xc4>
 8018c46:	eb08 0004 	add.w	r0, r8, r4
 8018c4a:	eeb4 4a00 	vmov.f32	s8, #64	; 0x3e000000  0.125
 8018c4e:	4a22      	ldr	r2, [pc, #136]	; (8018cd8 <SFXLivingStringAlloc+0xdc>)
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 8018c50:	eee0 7a2a 	vfma.f32	s15, s0, s21
                tComplexLivingString_initToPool(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode, &mediumPool);
 8018c54:	6831      	ldr	r1, [r6, #0]
 8018c56:	eef0 3a69 	vmov.f32	s7, s19
 8018c5a:	ed9f 0a20 	vldr	s0, [pc, #128]	; 8018cdc <SFXLivingStringAlloc+0xe0>
 8018c5e:	eeb0 1a43 	vmov.f32	s2, s6
 8018c62:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
 8018c66:	eeb0 2a49 	vmov.f32	s4, s18
 8018c6a:	eef0 1a48 	vmov.f32	s3, s16
 8018c6e:	eef0 0a68 	vmov.f32	s1, s17
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 8018c72:	ece5 7a01 	vstmia	r5!, {s15}
                tComplexLivingString_initToPool(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode, &mediumPool);
 8018c76:	f00c f98b 	bl	8024f90 <tComplexLivingString_initToPool>
                tExpSmooth_init(&stringGains[i], 0.0f, 0.002f);
 8018c7a:	1938      	adds	r0, r7, r4
 8018c7c:	3404      	adds	r4, #4
 8018c7e:	eddf 0a18 	vldr	s1, [pc, #96]	; 8018ce0 <SFXLivingStringAlloc+0xe4>
 8018c82:	eeb0 0a48 	vmov.f32	s0, s16
 8018c86:	f009 fc15 	bl	80224b4 <tExpSmooth_init>
            for (int i = 0; i < NUM_STRINGS; i++)
 8018c8a:	2c18      	cmp	r4, #24
 8018c8c:	d1d4      	bne.n	8018c38 <SFXLivingStringAlloc+0x3c>
            ignoreFreqKnobs = 0;
 8018c8e:	2300      	movs	r3, #0
 8018c90:	4a14      	ldr	r2, [pc, #80]	; (8018ce4 <SFXLivingStringAlloc+0xe8>)
            setLED_A(ignoreFreqKnobs);
 8018c92:	4618      	mov	r0, r3
            ignoreFreqKnobs = 0;
 8018c94:	6013      	str	r3, [r2, #0]
            setLED_A(ignoreFreqKnobs);
 8018c96:	f7fa fe59 	bl	801394c <setLED_A>
            setLED_B(independentStrings);
 8018c9a:	4b13      	ldr	r3, [pc, #76]	; (8018ce8 <SFXLivingStringAlloc+0xec>)
 8018c9c:	6818      	ldr	r0, [r3, #0]
 8018c9e:	f7fa fe63 	bl	8013968 <setLED_B>
            setLED_C(levMode);
 8018ca2:	6830      	ldr	r0, [r6, #0]
        }
 8018ca4:	ecbd 8b06 	vpop	{d8-d10}
 8018ca8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            setLED_C(levMode);
 8018cac:	f7fa be6a 	b.w	8013984 <setLED_C>
 8018cb0:	200005b0 	.word	0x200005b0
 8018cb4:	20002810 	.word	0x20002810
 8018cb8:	20016fd0 	.word	0x20016fd0
 8018cbc:	200174c8 	.word	0x200174c8
 8018cc0:	3e99999a 	.word	0x3e99999a
 8018cc4:	be19999a 	.word	0xbe19999a
 8018cc8:	3c23d70a 	.word	0x3c23d70a
 8018ccc:	460ca000 	.word	0x460ca000
 8018cd0:	00000000 	.word	0x00000000
 8018cd4:	3f4ccccd 	.word	0x3f4ccccd
 8018cd8:	200174cc 	.word	0x200174cc
 8018cdc:	43dc0000 	.word	0x43dc0000
 8018ce0:	3b03126f 	.word	0x3b03126f
 8018ce4:	200005a4 	.word	0x200005a4
 8018ce8:	200005a8 	.word	0x200005a8
 8018cec:	200194e8 	.word	0x200194e8
 8018cf0:	20002618 	.word	0x20002618

08018cf4 <SFXLivingStringFrame>:
        {
 8018cf4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8018cf8:	4db5      	ldr	r5, [pc, #724]	; (8018fd0 <SFXLivingStringFrame+0x2dc>)
        {
 8018cfa:	ed2d 8b04 	vpush	{d8-d9}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8018cfe:	7d2b      	ldrb	r3, [r5, #20]
        {
 8018d00:	b083      	sub	sp, #12
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8018d02:	2b01      	cmp	r3, #1
 8018d04:	f000 8204 	beq.w	8019110 <SFXLivingStringFrame+0x41c>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 8018d08:	7f2b      	ldrb	r3, [r5, #28]
 8018d0a:	2b01      	cmp	r3, #1
 8018d0c:	f000 8136 	beq.w	8018f7c <SFXLivingStringFrame+0x288>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 8018d10:	7e2b      	ldrb	r3, [r5, #24]
 8018d12:	4fb0      	ldr	r7, [pc, #704]	; (8018fd4 <SFXLivingStringFrame+0x2e0>)
 8018d14:	2b01      	cmp	r3, #1
                independentStrings = !independentStrings;
 8018d16:	f8df 82fc 	ldr.w	r8, [pc, #764]	; 8019014 <SFXLivingStringFrame+0x320>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 8018d1a:	f000 814c 	beq.w	8018fb6 <SFXLivingStringFrame+0x2c2>
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
 8018d1e:	4dae      	ldr	r5, [pc, #696]	; (8018fd8 <SFXLivingStringFrame+0x2e4>)
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48f) + 0.5f;//pickPos
 8018d20:	eeb6 9a00 	vmov.f32	s18, #96	; 0x3f000000  0.5
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
 8018d24:	eddf 8aad 	vldr	s17, [pc, #692]	; 8018fdc <SFXLivingStringFrame+0x2e8>
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 8018d28:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
 8018d2c:	462e      	mov	r6, r5
 8018d2e:	4cac      	ldr	r4, [pc, #688]	; (8018fe0 <SFXLivingStringFrame+0x2ec>)
 8018d30:	ecb6 0a01 	vldmia	r6!, {s0}
 8018d34:	ee20 0a28 	vmul.f32	s0, s0, s17
 8018d38:	f00b f9a8 	bl	802408c <LEAF_midiToFrequency>
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
 8018d3c:	eef2 7a08 	vmov.f32	s15, #40	; 0x41400000  12.0
 8018d40:	edd5 6a03 	vldr	s13, [r5, #12]
 8018d44:	ed9f 7aa7 	vldr	s14, [pc, #668]	; 8018fe4 <SFXLivingStringFrame+0x2f0>
            displayValues[1] = presetKnobValues[LivingString][1]; //detune
 8018d48:	6832      	ldr	r2, [r6, #0]
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
 8018d4a:	eee6 7a87 	vfma.f32	s15, s13, s14
            displayValues[2] = presetKnobValues[LivingString][2]; //decay
 8018d4e:	68ab      	ldr	r3, [r5, #8]
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
 8018d50:	ed84 0a00 	vstr	s0, [r4]
            displayValues[2] = presetKnobValues[LivingString][2]; //decay
 8018d54:	60a3      	str	r3, [r4, #8]
            displayValues[1] = presetKnobValues[LivingString][1]; //detune
 8018d56:	6062      	str	r2, [r4, #4]
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
 8018d58:	eeb0 0a67 	vmov.f32	s0, s15
 8018d5c:	f00b f9f6 	bl	802414c <mtof>
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48f) + 0.5f;//pickPos
 8018d60:	eeb0 5a49 	vmov.f32	s10, s18
 8018d64:	ed9f 7aa0 	vldr	s14, [pc, #640]	; 8018fe8 <SFXLivingStringFrame+0x2f4>
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 8018d68:	eef2 5a00 	vmov.f32	s11, #32	; 0x41000000  8.0
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48f) + 0.5f;//pickPos
 8018d6c:	edd5 6a04 	vldr	s13, [r5, #16]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 8018d70:	eeb9 6a00 	vmov.f32	s12, #144	; 0xc0800000 -4.0
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48f) + 0.02f;//prepPos
 8018d74:	edd5 4a05 	vldr	s9, [r5, #20]
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48f) + 0.5f;//pickPos
 8018d78:	eea6 5a87 	vfma.f32	s10, s13, s14
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48f) + 0.02f;//prepPos
 8018d7c:	eddf 7a9b 	vldr	s15, [pc, #620]	; 8018fec <SFXLivingStringFrame+0x2f8>
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
 8018d80:	ed84 0a03 	vstr	s0, [r4, #12]
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48f) + 0.02f;//prepPos
 8018d84:	eee4 7a87 	vfma.f32	s15, s9, s14
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48f) + 0.5f;//pickPos
 8018d88:	eef0 6a45 	vmov.f32	s13, s10
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 8018d8c:	ed95 5a06 	vldr	s10, [r5, #24]
 8018d90:	eea5 6a25 	vfma.f32	s12, s10, s11
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48f) + 0.02f;//prepPos
 8018d94:	edc4 7a05 	vstr	s15, [r4, #20]
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48f) + 0.5f;//pickPos
 8018d98:	edc4 6a04 	vstr	s13, [r4, #16]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 8018d9c:	eeb0 0a46 	vmov.f32	s0, s12
 8018da0:	f00e fd54 	bl	802784c <tanhf>
 8018da4:	ee30 0a08 	vadd.f32	s0, s0, s16
            displayValues[7] = presetKnobValues[LivingString][7];// let ring
 8018da8:	69eb      	ldr	r3, [r5, #28]
            if (!independentStrings)
 8018daa:	f8d8 6000 	ldr.w	r6, [r8]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 8018dae:	ee20 0a09 	vmul.f32	s0, s0, s18
            displayValues[7] = presetKnobValues[LivingString][7];// let ring
 8018db2:	61e3      	str	r3, [r4, #28]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 8018db4:	ed84 0a06 	vstr	s0, [r4, #24]
            if (!independentStrings)
 8018db8:	2e00      	cmp	r6, #0
 8018dba:	f040 8133 	bne.w	8019024 <SFXLivingStringFrame+0x330>
                if (!ignoreFreqKnobs)
 8018dbe:	4b8c      	ldr	r3, [pc, #560]	; (8018ff0 <SFXLivingStringFrame+0x2fc>)
 8018dc0:	f8d3 9000 	ldr.w	r9, [r3]
 8018dc4:	f1b9 0f00 	cmp.w	r9, #0
 8018dc8:	f000 808b 	beq.w	8018ee2 <SFXLivingStringFrame+0x1ee>
 8018dcc:	f8df 8248 	ldr.w	r8, [pc, #584]	; 8019018 <SFXLivingStringFrame+0x324>
 8018dd0:	46b1      	mov	r9, r6
 8018dd2:	4b88      	ldr	r3, [pc, #544]	; (8018ff4 <SFXLivingStringFrame+0x300>)
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 8018dd4:	9700      	str	r7, [sp, #0]
 8018dd6:	f8cd 8004 	str.w	r8, [sp, #4]
 8018dda:	461f      	mov	r7, r3
 8018ddc:	f8df a23c 	ldr.w	sl, [pc, #572]	; 801901c <SFXLivingStringFrame+0x328>
 8018de0:	46b0      	mov	r8, r6
 8018de2:	f8df b23c 	ldr.w	fp, [pc, #572]	; 8019020 <SFXLivingStringFrame+0x32c>
 8018de6:	ed9f 9a84 	vldr	s18, [pc, #528]	; 8018ff8 <SFXLivingStringFrame+0x304>
 8018dea:	eddf 8a84 	vldr	s17, [pc, #528]	; 8018ffc <SFXLivingStringFrame+0x308>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8018dee:	fa5f f688 	uxtb.w	r6, r8
 8018df2:	9b00      	ldr	r3, [sp, #0]
 8018df4:	4882      	ldr	r0, [pc, #520]	; (8019000 <SFXLivingStringFrame+0x30c>)
 8018df6:	4631      	mov	r1, r6
 8018df8:	eb03 0509 	add.w	r5, r3, r9
 8018dfc:	f00b ff00 	bl	8024c00 <tSimplePoly_getPitch>
 8018e00:	ee07 0a90 	vmov	s15, r0
 8018e04:	ed9b 0a00 	vldr	s0, [fp]
 8018e08:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018e0c:	4b7d      	ldr	r3, [pc, #500]	; (8019004 <SFXLivingStringFrame+0x310>)
 8018e0e:	7818      	ldrb	r0, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8018e10:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018e14:	4b7c      	ldr	r3, [pc, #496]	; (8019008 <SFXLivingStringFrame+0x314>)
 8018e16:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8018e1a:	ee17 1a90 	vmov	r1, s15
 8018e1e:	1a09      	subs	r1, r1, r0
 8018e20:	fb83 3c01 	smull	r3, ip, r3, r1
 8018e24:	17c8      	asrs	r0, r1, #31
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8018e26:	4b79      	ldr	r3, [pc, #484]	; (801900c <SFXLivingStringFrame+0x318>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018e28:	ebc0 006c 	rsb	r0, r0, ip, asr #1
 8018e2c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8018e30:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
 8018e34:	ee07 0a90 	vmov	s15, r0
 8018e38:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8018e3c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8018e40:	ee17 1a90 	vmov	r1, s15
 8018e44:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8018e48:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8018e4c:	ee37 0a00 	vadd.f32	s0, s14, s0
 8018e50:	f00b f91c 	bl	802408c <LEAF_midiToFrequency>
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 8018e54:	eef0 6a48 	vmov.f32	s13, s16
 8018e58:	ecb7 7a01 	vldmia	r7!, {s14}
 8018e5c:	4628      	mov	r0, r5
 8018e5e:	edd4 7a01 	vldr	s15, [r4, #4]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8018e62:	ecaa 0a01 	vstmia	sl!, {s0}
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 8018e66:	eee7 6a27 	vfma.f32	s13, s14, s15
 8018e6a:	ee26 0a80 	vmul.f32	s0, s13, s0
 8018e6e:	f00c f9fd 	bl	802526c <tComplexLivingString_setFreq>
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 8018e72:	eeb0 0a68 	vmov.f32	s0, s17
 8018e76:	edd4 7a02 	vldr	s15, [r4, #8]
 8018e7a:	4628      	mov	r0, r5
 8018e7c:	eea7 0a89 	vfma.f32	s0, s15, s18
 8018e80:	f00c fa5c 	bl	802533c <tComplexLivingString_setDecay>
                        tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
 8018e84:	4628      	mov	r0, r5
 8018e86:	ed94 0a03 	vldr	s0, [r4, #12]
 8018e8a:	f00c fa37 	bl	80252fc <tComplexLivingString_setDampFreq>
                        tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
 8018e8e:	4628      	mov	r0, r5
 8018e90:	ed94 0a04 	vldr	s0, [r4, #16]
 8018e94:	f00c fa02 	bl	802529c <tComplexLivingString_setPickPos>
                        tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
 8018e98:	4628      	mov	r0, r5
 8018e9a:	ed94 0a05 	vldr	s0, [r4, #20]
 8018e9e:	f00c fa0d 	bl	80252bc <tComplexLivingString_setPrepPos>
                        tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
 8018ea2:	ed94 0a06 	vldr	s0, [r4, #24]
 8018ea6:	4628      	mov	r0, r5
 8018ea8:	f00c fa1a 	bl	80252e0 <tComplexLivingString_setPrepIndex>
                        if (tSimplePoly_isOn(&poly, i))
 8018eac:	4631      	mov	r1, r6
 8018eae:	4854      	ldr	r0, [pc, #336]	; (8019000 <SFXLivingStringFrame+0x30c>)
 8018eb0:	f00b feb8 	bl	8024c24 <tSimplePoly_isOn>
 8018eb4:	9b01      	ldr	r3, [sp, #4]
                            tExpSmooth_setDest(&stringGains[i], 1.0f);
 8018eb6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8018eba:	eb03 0109 	add.w	r1, r3, r9
                        if (tSimplePoly_isOn(&poly, i))
 8018ebe:	b908      	cbnz	r0, 8018ec4 <SFXLivingStringFrame+0x1d0>
                            tExpSmooth_setDest(&stringGains[i], displayValues[7]);
 8018ec0:	ed94 0a07 	vldr	s0, [r4, #28]
                    for (int i = 0; i < NUM_STRINGS; i++)
 8018ec4:	f108 0801 	add.w	r8, r8, #1
                            tExpSmooth_setDest(&stringGains[i], displayValues[7]);
 8018ec8:	4608      	mov	r0, r1
 8018eca:	f009 fb59 	bl	8022580 <tExpSmooth_setDest>
 8018ece:	f109 0904 	add.w	r9, r9, #4
                    for (int i = 0; i < NUM_STRINGS; i++)
 8018ed2:	f1b8 0f06 	cmp.w	r8, #6
 8018ed6:	d18a      	bne.n	8018dee <SFXLivingStringFrame+0xfa>
        }
 8018ed8:	b003      	add	sp, #12
 8018eda:	ecbd 8b04 	vpop	{d8-d9}
 8018ede:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018ee2:	f8df a110 	ldr.w	sl, [pc, #272]	; 8018ff4 <SFXLivingStringFrame+0x300>
                if (!ignoreFreqKnobs)
 8018ee6:	464e      	mov	r6, r9
 8018ee8:	f8df 812c 	ldr.w	r8, [pc, #300]	; 8019018 <SFXLivingStringFrame+0x324>
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 8018eec:	ed9f 9a42 	vldr	s18, [pc, #264]	; 8018ff8 <SFXLivingStringFrame+0x304>
 8018ef0:	eddf 8a42 	vldr	s17, [pc, #264]	; 8018ffc <SFXLivingStringFrame+0x308>
                        float freqVal = displayValues[0] * (i+1);
 8018ef4:	f109 0901 	add.w	r9, r9, #1
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 8018ef8:	eeb0 0a48 	vmov.f32	s0, s16
 8018efc:	ecba 6a01 	vldmia	sl!, {s12}
 8018f00:	19bd      	adds	r5, r7, r6
 8018f02:	edd4 6a01 	vldr	s13, [r4, #4]
                        float freqVal = displayValues[0] * (i+1);
 8018f06:	ee07 9a90 	vmov	s15, r9
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 8018f0a:	4628      	mov	r0, r5
                        float freqVal = displayValues[0] * (i+1);
 8018f0c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8018f10:	edd4 7a00 	vldr	s15, [r4]
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 8018f14:	eea6 0a26 	vfma.f32	s0, s12, s13
                        float freqVal = displayValues[0] * (i+1);
 8018f18:	ee67 7a27 	vmul.f32	s15, s14, s15
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 8018f1c:	ee27 0a80 	vmul.f32	s0, s15, s0
 8018f20:	f00c f9a4 	bl	802526c <tComplexLivingString_setFreq>
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 8018f24:	eeb0 0a68 	vmov.f32	s0, s17
 8018f28:	edd4 7a02 	vldr	s15, [r4, #8]
 8018f2c:	4628      	mov	r0, r5
 8018f2e:	eea7 0a89 	vfma.f32	s0, s15, s18
 8018f32:	f00c fa03 	bl	802533c <tComplexLivingString_setDecay>
                        tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
 8018f36:	4628      	mov	r0, r5
 8018f38:	ed94 0a03 	vldr	s0, [r4, #12]
 8018f3c:	f00c f9de 	bl	80252fc <tComplexLivingString_setDampFreq>
                        tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
 8018f40:	4628      	mov	r0, r5
 8018f42:	ed94 0a04 	vldr	s0, [r4, #16]
 8018f46:	f00c f9a9 	bl	802529c <tComplexLivingString_setPickPos>
                        tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
 8018f4a:	4628      	mov	r0, r5
 8018f4c:	ed94 0a05 	vldr	s0, [r4, #20]
 8018f50:	f00c f9b4 	bl	80252bc <tComplexLivingString_setPrepPos>
                        tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
 8018f54:	4628      	mov	r0, r5
 8018f56:	ed94 0a06 	vldr	s0, [r4, #24]
 8018f5a:	f00c f9c1 	bl	80252e0 <tComplexLivingString_setPrepIndex>
                        tExpSmooth_setDest(&stringGains[i], 1.0f);
 8018f5e:	eb08 0006 	add.w	r0, r8, r6
 8018f62:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8018f66:	3604      	adds	r6, #4
 8018f68:	f009 fb0a 	bl	8022580 <tExpSmooth_setDest>
                    for (int i = 0; i < NUM_STRINGS; i++)
 8018f6c:	f1b9 0f06 	cmp.w	r9, #6
 8018f70:	d1c0      	bne.n	8018ef4 <SFXLivingStringFrame+0x200>
        }
 8018f72:	b003      	add	sp, #12
 8018f74:	ecbd 8b04 	vpop	{d8-d9}
 8018f78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                levMode = !levMode;
 8018f7c:	4e24      	ldr	r6, [pc, #144]	; (8019010 <SFXLivingStringFrame+0x31c>)
 8018f7e:	4f15      	ldr	r7, [pc, #84]	; (8018fd4 <SFXLivingStringFrame+0x2e0>)
 8018f80:	6831      	ldr	r1, [r6, #0]
 8018f82:	463c      	mov	r4, r7
 8018f84:	f107 0818 	add.w	r8, r7, #24
 8018f88:	fab1 f181 	clz	r1, r1
 8018f8c:	0949      	lsrs	r1, r1, #5
 8018f8e:	6031      	str	r1, [r6, #0]
 8018f90:	e000      	b.n	8018f94 <SFXLivingStringFrame+0x2a0>
 8018f92:	6831      	ldr	r1, [r6, #0]
                    tComplexLivingString_setLevMode(&theString[i], levMode);
 8018f94:	4620      	mov	r0, r4
 8018f96:	3404      	adds	r4, #4
 8018f98:	f00c f9e8 	bl	802536c <tComplexLivingString_setLevMode>
                for (int i = 0; i < NUM_STRINGS; i++)
 8018f9c:	4544      	cmp	r4, r8
 8018f9e:	d1f8      	bne.n	8018f92 <SFXLivingStringFrame+0x29e>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8018fa0:	2300      	movs	r3, #0
                setLED_C(levMode);
 8018fa2:	6830      	ldr	r0, [r6, #0]
                independentStrings = !independentStrings;
 8018fa4:	f8df 806c 	ldr.w	r8, [pc, #108]	; 8019014 <SFXLivingStringFrame+0x320>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8018fa8:	772b      	strb	r3, [r5, #28]
                setLED_C(levMode);
 8018faa:	f7fa fceb 	bl	8013984 <setLED_C>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 8018fae:	7e2b      	ldrb	r3, [r5, #24]
 8018fb0:	2b01      	cmp	r3, #1
 8018fb2:	f47f aeb4 	bne.w	8018d1e <SFXLivingStringFrame+0x2a>
                independentStrings = !independentStrings;
 8018fb6:	f8d8 3000 	ldr.w	r3, [r8]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8018fba:	2200      	movs	r2, #0
                independentStrings = !independentStrings;
 8018fbc:	fab3 f383 	clz	r3, r3
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8018fc0:	762a      	strb	r2, [r5, #24]
                independentStrings = !independentStrings;
 8018fc2:	095b      	lsrs	r3, r3, #5
                setLED_B(independentStrings);
 8018fc4:	4618      	mov	r0, r3
                independentStrings = !independentStrings;
 8018fc6:	f8c8 3000 	str.w	r3, [r8]
                setLED_B(independentStrings);
 8018fca:	f7fa fccd 	bl	8013968 <setLED_B>
 8018fce:	e6a6      	b.n	8018d1e <SFXLivingStringFrame+0x2a>
 8018fd0:	2001872c 	.word	0x2001872c
 8018fd4:	20002618 	.word	0x20002618
 8018fd8:	20003230 	.word	0x20003230
 8018fdc:	42b40000 	.word	0x42b40000
 8018fe0:	200187dc 	.word	0x200187dc
 8018fe4:	43020000 	.word	0x43020000
 8018fe8:	3ef5c28f 	.word	0x3ef5c28f
 8018fec:	3ca3d70a 	.word	0x3ca3d70a
 8018ff0:	200005a4 	.word	0x200005a4
 8018ff4:	20002810 	.word	0x20002810
 8018ff8:	3c75c28f 	.word	0x3c75c28f
 8018ffc:	3f7eb852 	.word	0x3f7eb852
 8019000:	200174c8 	.word	0x200174c8
 8019004:	20000668 	.word	0x20000668
 8019008:	2aaaaaab 	.word	0x2aaaaaab
 801900c:	20000634 	.word	0x20000634
 8019010:	200005b0 	.word	0x200005b0
 8019014:	200005a8 	.word	0x200005a8
 8019018:	20016fd0 	.word	0x20016fd0
 801901c:	200033e4 	.word	0x200033e4
 8019020:	200005e8 	.word	0x200005e8
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
 8019024:	ed95 0a0a 	vldr	s0, [r5, #40]	; 0x28
                displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
 8019028:	2600      	movs	r6, #0
 801902a:	f8df a110 	ldr.w	sl, [pc, #272]	; 801913c <SFXLivingStringFrame+0x448>
 801902e:	f104 0b24 	add.w	fp, r4, #36	; 0x24
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
 8019032:	ee20 0a28 	vmul.f32	s0, s0, s17
                for (int i = 0; i < NUM_STRINGS; i++)
 8019036:	46b1      	mov	r9, r6
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
 8019038:	f00b f828 	bl	802408c <LEAF_midiToFrequency>
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
 801903c:	edd5 7a0b 	vldr	s15, [r5, #44]	; 0x2c
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
 8019040:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
 8019044:	ee27 0aa8 	vmul.f32	s0, s15, s17
                    tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 8019048:	eddf 9a39 	vldr	s19, [pc, #228]	; 8019130 <SFXLivingStringFrame+0x43c>
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
 801904c:	f00b f81e 	bl	802408c <LEAF_midiToFrequency>
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
 8019050:	edd5 7a0c 	vldr	s15, [r5, #48]	; 0x30
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
 8019054:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
 8019058:	ee27 0aa8 	vmul.f32	s0, s15, s17
                    tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801905c:	ed9f 9a35 	vldr	s18, [pc, #212]	; 8019134 <SFXLivingStringFrame+0x440>
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
 8019060:	f00b f814 	bl	802408c <LEAF_midiToFrequency>
                displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
 8019064:	edd5 7a0d 	vldr	s15, [r5, #52]	; 0x34
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
 8019068:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
                displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
 801906c:	ee27 0aa8 	vmul.f32	s0, s15, s17
 8019070:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 8019140 <SFXLivingStringFrame+0x44c>
 8019074:	f00b f80a 	bl	802408c <LEAF_midiToFrequency>
                displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
 8019078:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
                displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
 801907c:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
                displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
 8019080:	ee27 0aa8 	vmul.f32	s0, s15, s17
 8019084:	f00b f802 	bl	802408c <LEAF_midiToFrequency>
 8019088:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
                    float freqVal = i == 0 ? displayValues[0] : displayValues[9+i];
 801908c:	2e00      	cmp	r6, #0
 801908e:	d04b      	beq.n	8019128 <SFXLivingStringFrame+0x434>
 8019090:	eddb 7a00 	vldr	s15, [fp]
                    tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 8019094:	eeb0 0a48 	vmov.f32	s0, s16
 8019098:	ecfa 6a01 	vldmia	sl!, {s13}
 801909c:	ed94 7a01 	vldr	s14, [r4, #4]
 80190a0:	eb07 0509 	add.w	r5, r7, r9
                for (int i = 0; i < NUM_STRINGS; i++)
 80190a4:	3601      	adds	r6, #1
 80190a6:	f10b 0b04 	add.w	fp, fp, #4
                    tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 80190aa:	eea6 0a87 	vfma.f32	s0, s13, s14
 80190ae:	4628      	mov	r0, r5
 80190b0:	ee20 0a27 	vmul.f32	s0, s0, s15
 80190b4:	f00c f8da 	bl	802526c <tComplexLivingString_setFreq>
                    tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 80190b8:	eeb0 0a49 	vmov.f32	s0, s18
 80190bc:	edd4 7a02 	vldr	s15, [r4, #8]
 80190c0:	4628      	mov	r0, r5
 80190c2:	eea7 0aa9 	vfma.f32	s0, s15, s19
 80190c6:	f00c f939 	bl	802533c <tComplexLivingString_setDecay>
                    tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
 80190ca:	4628      	mov	r0, r5
 80190cc:	ed94 0a03 	vldr	s0, [r4, #12]
 80190d0:	f00c f914 	bl	80252fc <tComplexLivingString_setDampFreq>
                    tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
 80190d4:	4628      	mov	r0, r5
 80190d6:	ed94 0a04 	vldr	s0, [r4, #16]
 80190da:	f00c f8df 	bl	802529c <tComplexLivingString_setPickPos>
                    tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
 80190de:	4628      	mov	r0, r5
 80190e0:	ed94 0a05 	vldr	s0, [r4, #20]
 80190e4:	f00c f8ea 	bl	80252bc <tComplexLivingString_setPrepPos>
                    tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
 80190e8:	4628      	mov	r0, r5
 80190ea:	ed94 0a06 	vldr	s0, [r4, #24]
 80190ee:	f00c f8f7 	bl	80252e0 <tComplexLivingString_setPrepIndex>
                    tExpSmooth_setDest(&stringGains[i], 1.0f);
 80190f2:	eb08 0009 	add.w	r0, r8, r9
 80190f6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80190fa:	f109 0904 	add.w	r9, r9, #4
 80190fe:	f009 fa3f 	bl	8022580 <tExpSmooth_setDest>
                for (int i = 0; i < NUM_STRINGS; i++)
 8019102:	2e06      	cmp	r6, #6
 8019104:	d1c2      	bne.n	801908c <SFXLivingStringFrame+0x398>
        }
 8019106:	b003      	add	sp, #12
 8019108:	ecbd 8b04 	vpop	{d8-d9}
 801910c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                ignoreFreqKnobs = !ignoreFreqKnobs;
 8019110:	4a09      	ldr	r2, [pc, #36]	; (8019138 <SFXLivingStringFrame+0x444>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8019112:	2100      	movs	r1, #0
                ignoreFreqKnobs = !ignoreFreqKnobs;
 8019114:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8019116:	7529      	strb	r1, [r5, #20]
                ignoreFreqKnobs = !ignoreFreqKnobs;
 8019118:	fab3 f383 	clz	r3, r3
 801911c:	095b      	lsrs	r3, r3, #5
                setLED_A(ignoreFreqKnobs);
 801911e:	4618      	mov	r0, r3
                ignoreFreqKnobs = !ignoreFreqKnobs;
 8019120:	6013      	str	r3, [r2, #0]
                setLED_A(ignoreFreqKnobs);
 8019122:	f7fa fc13 	bl	801394c <setLED_A>
 8019126:	e5ef      	b.n	8018d08 <SFXLivingStringFrame+0x14>
                    float freqVal = i == 0 ? displayValues[0] : displayValues[9+i];
 8019128:	edd4 7a00 	vldr	s15, [r4]
 801912c:	e7b2      	b.n	8019094 <SFXLivingStringFrame+0x3a0>
 801912e:	bf00      	nop
 8019130:	3c75c28f 	.word	0x3c75c28f
 8019134:	3f7eb852 	.word	0x3f7eb852
 8019138:	200005a4 	.word	0x200005a4
 801913c:	20002810 	.word	0x20002810
 8019140:	20016fd0 	.word	0x20016fd0

08019144 <SFXLivingStringTick>:
        {
 8019144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8019146:	4605      	mov	r5, r0
 8019148:	2400      	movs	r4, #0
 801914a:	4f10      	ldr	r7, [pc, #64]	; (801918c <SFXLivingStringTick+0x48>)
 801914c:	4e10      	ldr	r6, [pc, #64]	; (8019190 <SFXLivingStringTick+0x4c>)
 801914e:	ed2d 8b02 	vpush	{d8}
            float sample = 0.0f;
 8019152:	ed9f 8a10 	vldr	s16, [pc, #64]	; 8019194 <SFXLivingStringTick+0x50>
                float tick = tComplexLivingString_tick(&theString[i], input[1]);
 8019156:	1938      	adds	r0, r7, r4
 8019158:	ed95 0a01 	vldr	s0, [r5, #4]
 801915c:	f00c f914 	bl	8025388 <tComplexLivingString_tick>
                sample += tick * tExpSmooth_tick(&stringGains[i]);
 8019160:	1930      	adds	r0, r6, r4
 8019162:	3404      	adds	r4, #4
                float tick = tComplexLivingString_tick(&theString[i], input[1]);
 8019164:	eef0 8a40 	vmov.f32	s17, s0
                sample += tick * tExpSmooth_tick(&stringGains[i]);
 8019168:	f009 fa14 	bl	8022594 <tExpSmooth_tick>
            for (int i = 0; i < NUM_STRINGS; i++)
 801916c:	2c18      	cmp	r4, #24
                sample += tick * tExpSmooth_tick(&stringGains[i]);
 801916e:	eea0 8a28 	vfma.f32	s16, s0, s17
            for (int i = 0; i < NUM_STRINGS; i++)
 8019172:	d1f0      	bne.n	8019156 <SFXLivingStringTick+0x12>
            sample *= 0.1625f;
 8019174:	eddf 7a08 	vldr	s15, [pc, #32]	; 8019198 <SFXLivingStringTick+0x54>
 8019178:	ee28 8a27 	vmul.f32	s16, s16, s15
            input[0] = sample;
 801917c:	ed85 8a00 	vstr	s16, [r5]
            input[1] = sample;
 8019180:	ed85 8a01 	vstr	s16, [r5, #4]
        }
 8019184:	ecbd 8b02 	vpop	{d8}
 8019188:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801918a:	bf00      	nop
 801918c:	20002618 	.word	0x20002618
 8019190:	20016fd0 	.word	0x20016fd0
 8019194:	00000000 	.word	0x00000000
 8019198:	3e266666 	.word	0x3e266666

0801919c <SFXLivingStringFree>:
        {
 801919c:	b570      	push	{r4, r5, r6, lr}
 801919e:	2400      	movs	r4, #0
 80191a0:	4e05      	ldr	r6, [pc, #20]	; (80191b8 <SFXLivingStringFree+0x1c>)
 80191a2:	4d06      	ldr	r5, [pc, #24]	; (80191bc <SFXLivingStringFree+0x20>)
                tComplexLivingString_free(&theString[i]);
 80191a4:	1930      	adds	r0, r6, r4
 80191a6:	f00c f815 	bl	80251d4 <tComplexLivingString_free>
                tExpSmooth_free(&stringGains[i]);
 80191aa:	1928      	adds	r0, r5, r4
 80191ac:	3404      	adds	r4, #4
 80191ae:	f009 f9d1 	bl	8022554 <tExpSmooth_free>
            for (int i = 0; i < NUM_STRINGS; i++)
 80191b2:	2c18      	cmp	r4, #24
 80191b4:	d1f6      	bne.n	80191a4 <SFXLivingStringFree+0x8>
        }
 80191b6:	bd70      	pop	{r4, r5, r6, pc}
 80191b8:	20002618 	.word	0x20002618
 80191bc:	20016fd0 	.word	0x20016fd0

080191c0 <SFXLivingStringSynthAlloc>:
            levMode = 1;
 80191c0:	4a42      	ldr	r2, [pc, #264]	; (80192cc <SFXLivingStringSynthAlloc+0x10c>)
 80191c2:	2001      	movs	r0, #1
            leaf.clearOnAllocation = 0;
 80191c4:	2300      	movs	r3, #0
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 80191c6:	2106      	movs	r1, #6
        {
 80191c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
            leaf.clearOnAllocation = 0;
 80191cc:	f8df a154 	ldr.w	sl, [pc, #340]	; 8019324 <SFXLivingStringSynthAlloc+0x164>
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 80191d0:	461c      	mov	r4, r3
 80191d2:	4d3f      	ldr	r5, [pc, #252]	; (80192d0 <SFXLivingStringSynthAlloc+0x110>)
 80191d4:	f8df 9150 	ldr.w	r9, [pc, #336]	; 8019328 <SFXLivingStringSynthAlloc+0x168>
 80191d8:	f8df 8150 	ldr.w	r8, [pc, #336]	; 801932c <SFXLivingStringSynthAlloc+0x16c>
 80191dc:	4f3d      	ldr	r7, [pc, #244]	; (80192d4 <SFXLivingStringSynthAlloc+0x114>)
 80191de:	4e3e      	ldr	r6, [pc, #248]	; (80192d8 <SFXLivingStringSynthAlloc+0x118>)
            leaf.clearOnAllocation = 0;
 80191e0:	f8ca 3014 	str.w	r3, [sl, #20]
        {
 80191e4:	ed2d 8b06 	vpush	{d8-d10}
                tComplexLivingString_initToPool(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr, &mediumPool);
 80191e8:	eddf aa3c 	vldr	s21, [pc, #240]	; 80192dc <SFXLivingStringSynthAlloc+0x11c>
 80191ec:	eddf 8a3c 	vldr	s17, [pc, #240]	; 80192e0 <SFXLivingStringSynthAlloc+0x120>
 80191f0:	ed9f aa3c 	vldr	s20, [pc, #240]	; 80192e4 <SFXLivingStringSynthAlloc+0x124>
 80191f4:	eddf 9a3c 	vldr	s19, [pc, #240]	; 80192e8 <SFXLivingStringSynthAlloc+0x128>
 80191f8:	ed9f 9a3c 	vldr	s18, [pc, #240]	; 80192ec <SFXLivingStringSynthAlloc+0x12c>
                tSlide_init(&stringOutEnvs[i], 10.0f, 1000.0f);
 80191fc:	ed9f 8a3c 	vldr	s16, [pc, #240]	; 80192f0 <SFXLivingStringSynthAlloc+0x130>
            levMode = 1;
 8019200:	6010      	str	r0, [r2, #0]
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 8019202:	483c      	ldr	r0, [pc, #240]	; (80192f4 <SFXLivingStringSynthAlloc+0x134>)
 8019204:	f00b fcd8 	bl	8024bb8 <tSimplePoly_setNumVoices>
                tComplexLivingString_initToPool(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr, &mediumPool);
 8019208:	4a3b      	ldr	r2, [pc, #236]	; (80192f8 <SFXLivingStringSynthAlloc+0x138>)
 801920a:	eeb4 4a00 	vmov.f32	s8, #64	; 0x3e000000  0.125
 801920e:	6829      	ldr	r1, [r5, #0]
 8019210:	eef0 3a6a 	vmov.f32	s7, s21
 8019214:	eeb0 3a68 	vmov.f32	s6, s17
 8019218:	eddf 1a31 	vldr	s3, [pc, #196]	; 80192e0 <SFXLivingStringSynthAlloc+0x120>
 801921c:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
 8019220:	eb09 0004 	add.w	r0, r9, r4
 8019224:	eeb0 2a4a 	vmov.f32	s4, s20
 8019228:	ed9f 0a34 	vldr	s0, [pc, #208]	; 80192fc <SFXLivingStringSynthAlloc+0x13c>
 801922c:	eeb0 1a69 	vmov.f32	s2, s19
 8019230:	eef0 0a49 	vmov.f32	s1, s18
 8019234:	f00b feac 	bl	8024f90 <tComplexLivingString_initToPool>
                tSlide_init(&stringOutEnvs[i], 10.0f, 1000.0f);
 8019238:	eb08 0004 	add.w	r0, r8, r4
 801923c:	eef0 0a48 	vmov.f32	s1, s16
 8019240:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8019244:	f009 f9b6 	bl	80225b4 <tSlide_init>
                tSlide_init(&stringInEnvs[i], 12.0f, 1000.0f);
 8019248:	1938      	adds	r0, r7, r4
 801924a:	eef0 0a48 	vmov.f32	s1, s16
 801924e:	eeb2 0a08 	vmov.f32	s0, #40	; 0x41400000  12.0
 8019252:	f009 f9af 	bl	80225b4 <tSlide_init>
                tADSR4_init(&pluckEnvs[i], 4.0f, 70.0f, 0.0f, 5.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE);
 8019256:	1930      	adds	r0, r6, r4
 8019258:	3404      	adds	r4, #4
 801925a:	f44f 7200 	mov.w	r2, #512	; 0x200
 801925e:	4928      	ldr	r1, [pc, #160]	; (8019300 <SFXLivingStringSynthAlloc+0x140>)
 8019260:	eef1 1a04 	vmov.f32	s3, #20	; 0x40a00000  5.0
 8019264:	eeb0 1a68 	vmov.f32	s2, s17
 8019268:	eddf 0a26 	vldr	s1, [pc, #152]	; 8019304 <SFXLivingStringSynthAlloc+0x144>
 801926c:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 8019270:	f008 fd90 	bl	8021d94 <tADSR4_init>
            for (int i = 0; i < NUM_STRINGS; i++)
 8019274:	2c18      	cmp	r4, #24
 8019276:	d1c7      	bne.n	8019208 <SFXLivingStringSynthAlloc+0x48>
            tVZFilter_init(&pluckFilt, BandpassPeak, 2000.0f, 4.0f);
 8019278:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801927c:	ed9f 0a22 	vldr	s0, [pc, #136]	; 8019308 <SFXLivingStringSynthAlloc+0x148>
 8019280:	2103      	movs	r1, #3
 8019282:	4822      	ldr	r0, [pc, #136]	; (801930c <SFXLivingStringSynthAlloc+0x14c>)
 8019284:	f009 fcd2 	bl	8022c2c <tVZFilter_init>
            tNoise_init(&stringPluckNoise, WhiteNoise);
 8019288:	2100      	movs	r1, #0
 801928a:	4821      	ldr	r0, [pc, #132]	; (8019310 <SFXLivingStringSynthAlloc+0x150>)
 801928c:	f00b fe18 	bl	8024ec0 <tNoise_init>
            setLED_A(numVoices == 1);
 8019290:	4b20      	ldr	r3, [pc, #128]	; (8019314 <SFXLivingStringSynthAlloc+0x154>)
 8019292:	6818      	ldr	r0, [r3, #0]
 8019294:	f1a0 0001 	sub.w	r0, r0, #1
 8019298:	fab0 f080 	clz	r0, r0
 801929c:	0940      	lsrs	r0, r0, #5
 801929e:	f7fa fb55 	bl	801394c <setLED_A>
            setLED_B(voicePluck);
 80192a2:	4b1d      	ldr	r3, [pc, #116]	; (8019318 <SFXLivingStringSynthAlloc+0x158>)
 80192a4:	6818      	ldr	r0, [r3, #0]
 80192a6:	f7fa fb5f 	bl	8013968 <setLED_B>
            setLED_C(levModeStr);
 80192aa:	6828      	ldr	r0, [r5, #0]
 80192ac:	f7fa fb6a 	bl	8013984 <setLED_C>
            samplesPerMs = leaf.sampleRate / 1000.0f;
 80192b0:	edda 7a00 	vldr	s15, [sl]
 80192b4:	ed9f 7a19 	vldr	s14, [pc, #100]	; 801931c <SFXLivingStringSynthAlloc+0x15c>
 80192b8:	4b19      	ldr	r3, [pc, #100]	; (8019320 <SFXLivingStringSynthAlloc+0x160>)
 80192ba:	ee67 7a87 	vmul.f32	s15, s15, s14
 80192be:	edc3 7a00 	vstr	s15, [r3]
        }
 80192c2:	ecbd 8b06 	vpop	{d8-d10}
 80192c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80192ca:	bf00      	nop
 80192cc:	200005b0 	.word	0x200005b0
 80192d0:	200005b4 	.word	0x200005b4
 80192d4:	20017668 	.word	0x20017668
 80192d8:	200173b0 	.word	0x200173b0
 80192dc:	3c23d70a 	.word	0x3c23d70a
 80192e0:	00000000 	.word	0x00000000
 80192e4:	460ca000 	.word	0x460ca000
 80192e8:	3e99999a 	.word	0x3e99999a
 80192ec:	3e4ccccd 	.word	0x3e4ccccd
 80192f0:	447a0000 	.word	0x447a0000
 80192f4:	200174c8 	.word	0x200174c8
 80192f8:	200174cc 	.word	0x200174cc
 80192fc:	43dc0000 	.word	0x43dc0000
 8019300:	20017988 	.word	0x20017988
 8019304:	428c0000 	.word	0x428c0000
 8019308:	44fa0000 	.word	0x44fa0000
 801930c:	200183b4 	.word	0x200183b4
 8019310:	200028ec 	.word	0x200028ec
 8019314:	20000254 	.word	0x20000254
 8019318:	2000062c 	.word	0x2000062c
 801931c:	3a83126f 	.word	0x3a83126f
 8019320:	200002b8 	.word	0x200002b8
 8019324:	200194e8 	.word	0x200194e8
 8019328:	20002618 	.word	0x20002618
 801932c:	200175a0 	.word	0x200175a0

08019330 <SFXLivingStringSynthFrame>:
        {
 8019330:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8019334:	4db5      	ldr	r5, [pc, #724]	; (801960c <SFXLivingStringSynthFrame+0x2dc>)
        {
 8019336:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801933a:	7d29      	ldrb	r1, [r5, #20]
        {
 801933c:	b083      	sub	sp, #12
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801933e:	2901      	cmp	r1, #1
 8019340:	d112      	bne.n	8019368 <SFXLivingStringSynthFrame+0x38>
                numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
 8019342:	4cb3      	ldr	r4, [pc, #716]	; (8019610 <SFXLivingStringSynthFrame+0x2e0>)
                tSimplePoly_setNumVoices(&poly, numVoices);
 8019344:	48b3      	ldr	r0, [pc, #716]	; (8019614 <SFXLivingStringSynthFrame+0x2e4>)
                numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
 8019346:	6823      	ldr	r3, [r4, #0]
 8019348:	2b01      	cmp	r3, #1
 801934a:	bfd8      	it	le
 801934c:	2106      	movle	r1, #6
 801934e:	6021      	str	r1, [r4, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
 8019350:	f00b fc32 	bl	8024bb8 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
 8019354:	6820      	ldr	r0, [r4, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8019356:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
 8019358:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801935c:	752b      	strb	r3, [r5, #20]
                setLED_A(numVoices == 1);
 801935e:	fab0 f080 	clz	r0, r0
 8019362:	0940      	lsrs	r0, r0, #5
 8019364:	f7fa faf2 	bl	801394c <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 8019368:	7e2b      	ldrb	r3, [r5, #24]
 801936a:	2b01      	cmp	r3, #1
 801936c:	f000 8142 	beq.w	80195f4 <SFXLivingStringSynthFrame+0x2c4>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 8019370:	7f2b      	ldrb	r3, [r5, #28]
 8019372:	2b01      	cmp	r3, #1
 8019374:	f000 8125 	beq.w	80195c2 <SFXLivingStringSynthFrame+0x292>
 8019378:	f8df a2f8 	ldr.w	sl, [pc, #760]	; 8019674 <SFXLivingStringSynthFrame+0x344>
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 801937c:	4da6      	ldr	r5, [pc, #664]	; (8019618 <SFXLivingStringSynthFrame+0x2e8>)
 801937e:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 8019382:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8019386:	eddf 6aa5 	vldr	s13, [pc, #660]	; 801961c <SFXLivingStringSynthFrame+0x2ec>
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 801938a:	462b      	mov	r3, r5
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 801938c:	ed95 6a03 	vldr	s12, [r5, #12]
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 8019390:	4ca3      	ldr	r4, [pc, #652]	; (8019620 <SFXLivingStringSynthFrame+0x2f0>)
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 8019392:	2600      	movs	r6, #0
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 8019394:	ecf3 7a01 	vldmia	r3!, {s15}
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 8019398:	eea6 0a26 	vfma.f32	s0, s12, s13
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
 801939c:	eddf 8aa1 	vldr	s17, [pc, #644]	; 8019624 <SFXLivingStringSynthFrame+0x2f4>
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 80193a0:	ee67 7a87 	vmul.f32	s15, s15, s14
            displayValues[1] = presetKnobValues[LivingStringSynth][1]; //lowpass
 80193a4:	681a      	ldr	r2, [r3, #0]
            displayValues[2] = presetKnobValues[LivingStringSynth][2]; //decay
 80193a6:	68ab      	ldr	r3, [r5, #8]
            displayValues[1] = presetKnobValues[LivingStringSynth][1]; //lowpass
 80193a8:	6062      	str	r2, [r4, #4]
            displayValues[2] = presetKnobValues[LivingStringSynth][2]; //decay
 80193aa:	60a3      	str	r3, [r4, #8]
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 80193ac:	edc4 7a00 	vstr	s15, [r4]
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 80193b0:	f00a fef0 	bl	8024194 <faster_mtof>
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44f) + 0.52f;//pick Pos
 80193b4:	eddf 6a9c 	vldr	s13, [pc, #624]	; 8019628 <SFXLivingStringSynthFrame+0x2f8>
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 80193b8:	eef2 5a01 	vmov.f32	s11, #33	; 0x41080000  8.5
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44f) + 0.52f;//pick Pos
 80193bc:	ed95 5a04 	vldr	s10, [r5, #16]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 80193c0:	eeb9 6a01 	vmov.f32	s12, #145	; 0xc0880000 -4.250
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44f) + 0.52f;//pick Pos
 80193c4:	ed9f 7a99 	vldr	s14, [pc, #612]	; 801962c <SFXLivingStringSynthFrame+0x2fc>
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44f) + 0.04f;//prep Pos
 80193c8:	edd5 4a05 	vldr	s9, [r5, #20]
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44f) + 0.52f;//pick Pos
 80193cc:	eea5 7a26 	vfma.f32	s14, s10, s13
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 80193d0:	ed95 5a06 	vldr	s10, [r5, #24]
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44f) + 0.04f;//prep Pos
 80193d4:	eddf 7a96 	vldr	s15, [pc, #600]	; 8019630 <SFXLivingStringSynthFrame+0x300>
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 80193d8:	eea5 6a25 	vfma.f32	s12, s10, s11
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 80193dc:	ed84 0a03 	vstr	s0, [r4, #12]
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44f) + 0.04f;//prep Pos
 80193e0:	eee4 7aa6 	vfma.f32	s15, s9, s13
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
 80193e4:	ed9f 8a93 	vldr	s16, [pc, #588]	; 8019634 <SFXLivingStringSynthFrame+0x304>
 80193e8:	f8df b28c 	ldr.w	fp, [pc, #652]	; 8019678 <SFXLivingStringSynthFrame+0x348>
 80193ec:	4f92      	ldr	r7, [pc, #584]	; (8019638 <SFXLivingStringSynthFrame+0x308>)
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44f) + 0.52f;//pick Pos
 80193ee:	ed84 7a04 	vstr	s14, [r4, #16]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 80193f2:	eeb0 0a46 	vmov.f32	s0, s12
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44f) + 0.04f;//prep Pos
 80193f6:	edc4 7a05 	vstr	s15, [r4, #20]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 80193fa:	f00a fdad 	bl	8023f58 <LEAF_tanh>
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 80193fe:	4b8f      	ldr	r3, [pc, #572]	; (801963c <SFXLivingStringSynthFrame+0x30c>)
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 8019400:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 8019404:	edd5 7a09 	vldr	s15, [r5, #36]	; 0x24
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 8019408:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801940c:	edd3 5a00 	vldr	s11, [r3]
            displayValues[8] = presetKnobValues[LivingStringSynth][8];//feedback level
 8019410:	6a2a      	ldr	r2, [r5, #32]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 8019412:	ee30 0a07 	vadd.f32	s0, s0, s14
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 8019416:	ee67 7aa5 	vmul.f32	s15, s15, s11
 801941a:	4b89      	ldr	r3, [pc, #548]	; (8019640 <SFXLivingStringSynthFrame+0x310>)
            displayValues[8] = presetKnobValues[LivingStringSynth][8];//feedback level
 801941c:	6222      	str	r2, [r4, #32]
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801941e:	eddf 6a89 	vldr	s13, [pc, #548]	; 8019644 <SFXLivingStringSynthFrame+0x314>
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 8019422:	ee20 0a06 	vmul.f32	s0, s0, s12
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 8019426:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            displayValues[7] = presetKnobValues[LivingStringSynth][7];//let Ring
 801942a:	69e9      	ldr	r1, [r5, #28]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 801942c:	ed84 0a06 	vstr	s0, [r4, #24]
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 8019430:	ee17 2a90 	vmov	r2, s15
            displayValues[7] = presetKnobValues[LivingStringSynth][7];//let Ring
 8019434:	61e1      	str	r1, [r4, #28]
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 8019436:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801943a:	edd3 7a00 	vldr	s15, [r3]
 801943e:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8019442:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
 8019446:	eeb0 0a48 	vmov.f32	s0, s16
 801944a:	edd4 7a02 	vldr	s15, [r4, #8]
 801944e:	eb0a 0506 	add.w	r5, sl, r6
 8019452:	eea7 0aa8 	vfma.f32	s0, s15, s17
 8019456:	4628      	mov	r0, r5
 8019458:	f00b ff70 	bl	802533c <tComplexLivingString_setDecay>
                tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
 801945c:	4628      	mov	r0, r5
 801945e:	ed94 0a03 	vldr	s0, [r4, #12]
 8019462:	f00b ff4b 	bl	80252fc <tComplexLivingString_setDampFreq>
                tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
 8019466:	4628      	mov	r0, r5
 8019468:	ed94 0a04 	vldr	s0, [r4, #16]
 801946c:	f00b ff16 	bl	802529c <tComplexLivingString_setPickPos>
                tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
 8019470:	4628      	mov	r0, r5
 8019472:	ed94 0a05 	vldr	s0, [r4, #20]
 8019476:	f00b ff21 	bl	80252bc <tComplexLivingString_setPrepPos>
                tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
 801947a:	4628      	mov	r0, r5
 801947c:	ed94 0a06 	vldr	s0, [r4, #24]
 8019480:	f00b ff2e 	bl	80252e0 <tComplexLivingString_setPrepIndex>
                tSlide_setDownSlide(&stringOutEnvs[i], displayValues[9] * samplesPerMs);
 8019484:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8019488:	edd7 7a00 	vldr	s15, [r7]
 801948c:	eb0b 0006 	add.w	r0, fp, r6
 8019490:	3604      	adds	r6, #4
 8019492:	ee20 0a27 	vmul.f32	s0, s0, s15
 8019496:	f009 f8b9 	bl	802260c <tSlide_setDownSlide>
            for (int i = 0; i < NUM_STRINGS; i++)
 801949a:	2e18      	cmp	r6, #24
 801949c:	d1d3      	bne.n	8019446 <SFXLivingStringSynthFrame+0x116>
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
 801949e:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 80194a2:	ed94 7a01 	vldr	s14, [r4, #4]
 80194a6:	eddf 7a68 	vldr	s15, [pc, #416]	; 8019648 <SFXLivingStringSynthFrame+0x318>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80194aa:	2500      	movs	r5, #0
 80194ac:	4b67      	ldr	r3, [pc, #412]	; (801964c <SFXLivingStringSynthFrame+0x31c>)
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
 80194ae:	eea7 0a27 	vfma.f32	s0, s14, s15
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80194b2:	462e      	mov	r6, r5
 80194b4:	9301      	str	r3, [sp, #4]
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
 80194b6:	f00a fe6d 	bl	8024194 <faster_mtof>
 80194ba:	4865      	ldr	r0, [pc, #404]	; (8019650 <SFXLivingStringSynthFrame+0x320>)
 80194bc:	f009 fe28 	bl	8023110 <tVZFilter_setFreq>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80194c0:	f8df 8150 	ldr.w	r8, [pc, #336]	; 8019614 <SFXLivingStringSynthFrame+0x2e4>
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
 80194c4:	eddf 8a63 	vldr	s17, [pc, #396]	; 8019654 <SFXLivingStringSynthFrame+0x324>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80194c8:	e01a      	b.n	8019500 <SFXLivingStringSynthFrame+0x1d0>
                    tComplexLivingString_setTargetLev(&theString[i],voiceOn * displayValues[8]);
 80194ca:	ed94 0a08 	vldr	s0, [r4, #32]
 80194ce:	ee28 0a00 	vmul.f32	s0, s16, s0
 80194d2:	f00b ff37 	bl	8025344 <tComplexLivingString_setTargetLev>
                if (voiceOn)
 80194d6:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80194da:	4f5f      	ldr	r7, [pc, #380]	; (8019658 <SFXLivingStringSynthFrame+0x328>)
 80194dc:	eb0b 0305 	add.w	r3, fp, r5
                    tSlide_setDest(&stringOutEnvs[i], 1.0f);
 80194e0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80194e4:	442f      	add	r7, r5
                if (voiceOn)
 80194e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    tSlide_setDest(&stringOutEnvs[i], 1.0f);
 80194ea:	4618      	mov	r0, r3
                if (voiceOn)
 80194ec:	d05a      	beq.n	80195a4 <SFXLivingStringSynthFrame+0x274>
                    tSlide_setDest(&stringOutEnvs[i], 1.0f);
 80194ee:	f009 f895 	bl	802261c <tSlide_setDest>
                    tSlide_setDest(&stringInEnvs[i], 1.0f);
 80194f2:	4638      	mov	r0, r7
 80194f4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80194f8:	f009 f890 	bl	802261c <tSlide_setDest>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80194fc:	3601      	adds	r6, #1
 80194fe:	3504      	adds	r5, #4
 8019500:	4640      	mov	r0, r8
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8019502:	fa5f f986 	uxtb.w	r9, r6
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8019506:	f00b fb5f 	bl	8024bc8 <tSimplePoly_getNumVoices>
 801950a:	42b0      	cmp	r0, r6
 801950c:	eb0a 0705 	add.w	r7, sl, r5
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8019510:	4649      	mov	r1, r9
 8019512:	4640      	mov	r0, r8
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8019514:	dd50      	ble.n	80195b8 <SFXLivingStringSynthFrame+0x288>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8019516:	f00b fb73 	bl	8024c00 <tSimplePoly_getPitch>
 801951a:	ee07 0a90 	vmov	s15, r0
 801951e:	4a4f      	ldr	r2, [pc, #316]	; (801965c <SFXLivingStringSynthFrame+0x32c>)
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
 8019520:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8019524:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8019528:	4b4d      	ldr	r3, [pc, #308]	; (8019660 <SFXLivingStringSynthFrame+0x330>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801952a:	ed92 0a00 	vldr	s0, [r2]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801952e:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8019530:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8019534:	494b      	ldr	r1, [pc, #300]	; (8019664 <SFXLivingStringSynthFrame+0x334>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8019536:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801953a:	ee17 3a90 	vmov	r3, s15
 801953e:	1a9b      	subs	r3, r3, r2
 8019540:	4a49      	ldr	r2, [pc, #292]	; (8019668 <SFXLivingStringSynthFrame+0x338>)
 8019542:	fb82 2003 	smull	r2, r0, r2, r3
 8019546:	17da      	asrs	r2, r3, #31
 8019548:	ebc2 0260 	rsb	r2, r2, r0, asr #1
 801954c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8019550:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 8019554:	ee07 3a90 	vmov	s15, r3
 8019558:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801955c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019560:	ee17 3a90 	vmov	r3, s15
 8019564:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8019568:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801956c:	ee37 0a00 	vadd.f32	s0, s14, s0
 8019570:	f00a fd8c 	bl	802408c <LEAF_midiToFrequency>
 8019574:	9b01      	ldr	r3, [sp, #4]
                tComplexLivingString_setFreq(&theString[i], freq[i]);
 8019576:	4638      	mov	r0, r7
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8019578:	eca3 0a01 	vstmia	r3!, {s0}
 801957c:	9301      	str	r3, [sp, #4]
                tComplexLivingString_setFreq(&theString[i], freq[i]);
 801957e:	f00b fe75 	bl	802526c <tComplexLivingString_setFreq>
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
 8019582:	4649      	mov	r1, r9
 8019584:	4640      	mov	r0, r8
 8019586:	f00b fb47 	bl	8024c18 <tSimplePoly_getVelocity>
                if (levModeStr)
 801958a:	4b38      	ldr	r3, [pc, #224]	; (801966c <SFXLivingStringSynthFrame+0x33c>)
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
 801958c:	2800      	cmp	r0, #0
                    tComplexLivingString_setTargetLev(&theString[i],1.0f);
 801958e:	eeb0 0a48 	vmov.f32	s0, s16
                if (levModeStr)
 8019592:	681b      	ldr	r3, [r3, #0]
                    tComplexLivingString_setTargetLev(&theString[i],1.0f);
 8019594:	4638      	mov	r0, r7
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
 8019596:	fe38 8a28 	vselgt.f32	s16, s16, s17
                if (levModeStr)
 801959a:	2b00      	cmp	r3, #0
 801959c:	d195      	bne.n	80194ca <SFXLivingStringSynthFrame+0x19a>
                    tComplexLivingString_setTargetLev(&theString[i],1.0f);
 801959e:	f00b fed1 	bl	8025344 <tComplexLivingString_setTargetLev>
 80195a2:	e798      	b.n	80194d6 <SFXLivingStringSynthFrame+0x1a6>
                    tSlide_setDest(&stringOutEnvs[i], displayValues[7]);
 80195a4:	ed94 0a07 	vldr	s0, [r4, #28]
 80195a8:	f009 f838 	bl	802261c <tSlide_setDest>
                    tSlide_setDest(&stringInEnvs[i], 0.0f);
 80195ac:	eeb0 0a68 	vmov.f32	s0, s17
 80195b0:	4638      	mov	r0, r7
 80195b2:	f009 f833 	bl	802261c <tSlide_setDest>
 80195b6:	e7a1      	b.n	80194fc <SFXLivingStringSynthFrame+0x1cc>
        }
 80195b8:	b003      	add	sp, #12
 80195ba:	ecbd 8b02 	vpop	{d8}
 80195be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                levModeStr = !levModeStr;
 80195c2:	4e2a      	ldr	r6, [pc, #168]	; (801966c <SFXLivingStringSynthFrame+0x33c>)
 80195c4:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 8019674 <SFXLivingStringSynthFrame+0x344>
 80195c8:	6831      	ldr	r1, [r6, #0]
 80195ca:	4654      	mov	r4, sl
 80195cc:	f10a 0718 	add.w	r7, sl, #24
 80195d0:	fab1 f181 	clz	r1, r1
 80195d4:	0949      	lsrs	r1, r1, #5
 80195d6:	6031      	str	r1, [r6, #0]
 80195d8:	e000      	b.n	80195dc <SFXLivingStringSynthFrame+0x2ac>
 80195da:	6831      	ldr	r1, [r6, #0]
                    tComplexLivingString_setLevMode(&theString[i], levModeStr);
 80195dc:	4620      	mov	r0, r4
 80195de:	3404      	adds	r4, #4
 80195e0:	f00b fec4 	bl	802536c <tComplexLivingString_setLevMode>
                for (int i = 0; i < NUM_STRINGS; i++)
 80195e4:	42a7      	cmp	r7, r4
 80195e6:	d1f8      	bne.n	80195da <SFXLivingStringSynthFrame+0x2aa>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 80195e8:	2300      	movs	r3, #0
                setLED_C(levModeStr);
 80195ea:	6830      	ldr	r0, [r6, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 80195ec:	772b      	strb	r3, [r5, #28]
                setLED_C(levModeStr);
 80195ee:	f7fa f9c9 	bl	8013984 <setLED_C>
 80195f2:	e6c3      	b.n	801937c <SFXLivingStringSynthFrame+0x4c>
                voicePluck = !voicePluck;
 80195f4:	4a1e      	ldr	r2, [pc, #120]	; (8019670 <SFXLivingStringSynthFrame+0x340>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 80195f6:	2100      	movs	r1, #0
                voicePluck = !voicePluck;
 80195f8:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 80195fa:	7629      	strb	r1, [r5, #24]
                voicePluck = !voicePluck;
 80195fc:	fab3 f383 	clz	r3, r3
 8019600:	095b      	lsrs	r3, r3, #5
                setLED_B(voicePluck);
 8019602:	4618      	mov	r0, r3
                voicePluck = !voicePluck;
 8019604:	6013      	str	r3, [r2, #0]
                setLED_B(voicePluck);
 8019606:	f7fa f9af 	bl	8013968 <setLED_B>
 801960a:	e6b1      	b.n	8019370 <SFXLivingStringSynthFrame+0x40>
 801960c:	2001872c 	.word	0x2001872c
 8019610:	20000254 	.word	0x20000254
 8019614:	200174c8 	.word	0x200174c8
 8019618:	20003294 	.word	0x20003294
 801961c:	42ee0000 	.word	0x42ee0000
 8019620:	200187dc 	.word	0x200187dc
 8019624:	3ca3d70a 	.word	0x3ca3d70a
 8019628:	3ee147ae 	.word	0x3ee147ae
 801962c:	3f051eb8 	.word	0x3f051eb8
 8019630:	3d23d70a 	.word	0x3d23d70a
 8019634:	3f7ae148 	.word	0x3f7ae148
 8019638:	200002b8 	.word	0x200002b8
 801963c:	2000023c 	.word	0x2000023c
 8019640:	20016fec 	.word	0x20016fec
 8019644:	46000000 	.word	0x46000000
 8019648:	42c80000 	.word	0x42c80000
 801964c:	200033e4 	.word	0x200033e4
 8019650:	200183b4 	.word	0x200183b4
 8019654:	00000000 	.word	0x00000000
 8019658:	20017668 	.word	0x20017668
 801965c:	200005e8 	.word	0x200005e8
 8019660:	20000668 	.word	0x20000668
 8019664:	20000634 	.word	0x20000634
 8019668:	2aaaaaab 	.word	0x2aaaaaab
 801966c:	200005b4 	.word	0x200005b4
 8019670:	2000062c 	.word	0x2000062c
 8019674:	20002618 	.word	0x20002618
 8019678:	200175a0 	.word	0x200175a0

0801967c <SFXLivingStringSynthTick>:
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
 801967c:	4b27      	ldr	r3, [pc, #156]	; (801971c <SFXLivingStringSynthTick+0xa0>)
        {
 801967e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8019682:	ed2d 8b06 	vpush	{d8-d10}
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
 8019686:	ed93 8a00 	vldr	s16, [r3]
        {
 801968a:	4606      	mov	r6, r0
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
 801968c:	4824      	ldr	r0, [pc, #144]	; (8019720 <SFXLivingStringSynthTick+0xa4>)
            pluck = tVZFilter_tick(&pluckFilt, pluck);
 801968e:	2400      	movs	r4, #0
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
 8019690:	f00b fc2c 	bl	8024eec <tNoise_tick>
            pluck = tVZFilter_tick(&pluckFilt, pluck);
 8019694:	4823      	ldr	r0, [pc, #140]	; (8019724 <SFXLivingStringSynthTick+0xa8>)
 8019696:	ee28 0a00 	vmul.f32	s0, s16, s0
            float sample = 0.0f;
 801969a:	ed9f 9a23 	vldr	s18, [pc, #140]	; 8019728 <SFXLivingStringSynthTick+0xac>
            pluck = tVZFilter_tick(&pluckFilt, pluck);
 801969e:	f009 fcc7 	bl	8023030 <tVZFilter_tick>
 80196a2:	eeb0 aa40 	vmov.f32	s20, s0
 80196a6:	f8df a090 	ldr.w	sl, [pc, #144]	; 8019738 <SFXLivingStringSynthTick+0xbc>
 80196aa:	f8df 9090 	ldr.w	r9, [pc, #144]	; 801973c <SFXLivingStringSynthTick+0xc0>
 80196ae:	f8df 8090 	ldr.w	r8, [pc, #144]	; 8019740 <SFXLivingStringSynthTick+0xc4>
 80196b2:	4f1e      	ldr	r7, [pc, #120]	; (801972c <SFXLivingStringSynthTick+0xb0>)
                inputSample = (input[1] * voicePluck) + (pluck * tADSR4_tick(&pluckEnvs[i]));
 80196b4:	edda 7a00 	vldr	s15, [sl]
 80196b8:	eb09 0004 	add.w	r0, r9, r4
 80196bc:	edd6 9a01 	vldr	s19, [r6, #4]
 80196c0:	eb08 0504 	add.w	r5, r8, r4
 80196c4:	eef8 8ae7 	vcvt.f32.s32	s17, s15
 80196c8:	f008 fc22 	bl	8021f10 <tADSR4_tick>
 80196cc:	ee20 8a0a 	vmul.f32	s16, s0, s20
                sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
 80196d0:	4628      	mov	r0, r5
 80196d2:	f008 ffa7 	bl	8022624 <tSlide_tickNoInput>
 80196d6:	1938      	adds	r0, r7, r4
 80196d8:	3404      	adds	r4, #4
                inputSample = (input[1] * voicePluck) + (pluck * tADSR4_tick(&pluckEnvs[i]));
 80196da:	eea9 8aa8 	vfma.f32	s16, s19, s17
                sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
 80196de:	ee20 0a08 	vmul.f32	s0, s0, s16
 80196e2:	f00b fe51 	bl	8025388 <tComplexLivingString_tick>
 80196e6:	4628      	mov	r0, r5
 80196e8:	eeb0 8a40 	vmov.f32	s16, s0
 80196ec:	f008 ff9a 	bl	8022624 <tSlide_tickNoInput>
            for (int i = 0; i < NUM_STRINGS; i++)
 80196f0:	2c18      	cmp	r4, #24
                sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
 80196f2:	eea8 9a00 	vfma.f32	s18, s16, s0
            for (int i = 0; i < NUM_STRINGS; i++)
 80196f6:	d1dd      	bne.n	80196b4 <SFXLivingStringSynthTick+0x38>
            sample *= 0.1625f;
 80196f8:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 8019730 <SFXLivingStringSynthTick+0xb4>
            sample = LEAF_tanh(sample) * 0.98f;
 80196fc:	ee29 0a00 	vmul.f32	s0, s18, s0
 8019700:	f00a fc2a 	bl	8023f58 <LEAF_tanh>
 8019704:	eddf 7a0b 	vldr	s15, [pc, #44]	; 8019734 <SFXLivingStringSynthTick+0xb8>
 8019708:	ee20 0a27 	vmul.f32	s0, s0, s15
            input[0] = sample;
 801970c:	ed86 0a00 	vstr	s0, [r6]
            input[1] = sample;
 8019710:	ed86 0a01 	vstr	s0, [r6, #4]
        }
 8019714:	ecbd 8b06 	vpop	{d8-d10}
 8019718:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801971c:	200187dc 	.word	0x200187dc
 8019720:	200028ec 	.word	0x200028ec
 8019724:	200183b4 	.word	0x200183b4
 8019728:	00000000 	.word	0x00000000
 801972c:	20002618 	.word	0x20002618
 8019730:	3e266666 	.word	0x3e266666
 8019734:	3f7ae148 	.word	0x3f7ae148
 8019738:	2000062c 	.word	0x2000062c
 801973c:	200173b0 	.word	0x200173b0
 8019740:	200175a0 	.word	0x200175a0

08019744 <SFXLivingStringSynthFree>:
        {
 8019744:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8019748:	2400      	movs	r4, #0
 801974a:	f8df 804c 	ldr.w	r8, [pc, #76]	; 8019798 <SFXLivingStringSynthFree+0x54>
 801974e:	4f0d      	ldr	r7, [pc, #52]	; (8019784 <SFXLivingStringSynthFree+0x40>)
 8019750:	4e0d      	ldr	r6, [pc, #52]	; (8019788 <SFXLivingStringSynthFree+0x44>)
 8019752:	4d0e      	ldr	r5, [pc, #56]	; (801978c <SFXLivingStringSynthFree+0x48>)
                tComplexLivingString_free(&theString[i]);
 8019754:	eb08 0004 	add.w	r0, r8, r4
 8019758:	f00b fd3c 	bl	80251d4 <tComplexLivingString_free>
                tSlide_free(&stringInEnvs[i]);
 801975c:	1938      	adds	r0, r7, r4
 801975e:	f008 ff51 	bl	8022604 <tSlide_free>
                tSlide_free(&stringOutEnvs[i]);
 8019762:	1930      	adds	r0, r6, r4
 8019764:	f008 ff4e 	bl	8022604 <tSlide_free>
                tADSR4_free(&pluckEnvs[i]);
 8019768:	1928      	adds	r0, r5, r4
 801976a:	3404      	adds	r4, #4
 801976c:	f008 fb6e 	bl	8021e4c <tADSR4_free>
            for (int i = 0; i < NUM_STRINGS; i++)
 8019770:	2c18      	cmp	r4, #24
 8019772:	d1ef      	bne.n	8019754 <SFXLivingStringSynthFree+0x10>
            tVZFilter_free(&pluckFilt);
 8019774:	4806      	ldr	r0, [pc, #24]	; (8019790 <SFXLivingStringSynthFree+0x4c>)
 8019776:	f009 fc4d 	bl	8023014 <tVZFilter_free>
            tNoise_free(&stringPluckNoise);
 801977a:	4806      	ldr	r0, [pc, #24]	; (8019794 <SFXLivingStringSynthFree+0x50>)
        }
 801977c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            tNoise_free(&stringPluckNoise);
 8019780:	f00b bbb0 	b.w	8024ee4 <tNoise_free>
 8019784:	20017668 	.word	0x20017668
 8019788:	200175a0 	.word	0x200175a0
 801978c:	200173b0 	.word	0x200173b0
 8019790:	200183b4 	.word	0x200183b4
 8019794:	200028ec 	.word	0x200028ec
 8019798:	20002618 	.word	0x20002618

0801979c <SFXClassicSynthAlloc>:
        {
 801979c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            tSimplePoly_setNumVoices(&poly, numVoices);
 80197a0:	4b9f      	ldr	r3, [pc, #636]	; (8019a20 <SFXClassicSynthAlloc+0x284>)
            leaf.clearOnAllocation = 1;
 80197a2:	2201      	movs	r2, #1
 80197a4:	f8df 92dc 	ldr.w	r9, [pc, #732]	; 8019a84 <SFXClassicSynthAlloc+0x2e8>
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
 80197a8:	2700      	movs	r7, #0
            tSimplePoly_setNumVoices(&poly, numVoices);
 80197aa:	489e      	ldr	r0, [pc, #632]	; (8019a24 <SFXClassicSynthAlloc+0x288>)
            leaf.clearOnAllocation = 1;
 80197ac:	f8c9 2014 	str.w	r2, [r9, #20]
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
 80197b0:	46ba      	mov	sl, r7
 80197b2:	f8df b2d4 	ldr.w	fp, [pc, #724]	; 8019a88 <SFXClassicSynthAlloc+0x2ec>
        {
 80197b6:	ed2d 8b08 	vpush	{d8-d11}
            tSimplePoly_setNumVoices(&poly, numVoices);
 80197ba:	7819      	ldrb	r1, [r3, #0]
 80197bc:	f00b f9fc 	bl	8024bb8 <tSimplePoly_setNumVoices>
            displayValues[0] = knobs[0]; //synth volume
 80197c0:	4a99      	ldr	r2, [pc, #612]	; (8019a28 <SFXClassicSynthAlloc+0x28c>)
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 80197c2:	499a      	ldr	r1, [pc, #616]	; (8019a2c <SFXClassicSynthAlloc+0x290>)
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 80197c4:	eef0 4a00 	vmov.f32	s9, #0	; 0x40000000  2.0
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 80197c8:	ed92 5a05 	vldr	s10, [r2, #20]
            displayValues[0] = knobs[0]; //synth volume
 80197cc:	4694      	mov	ip, r2
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 80197ce:	edd1 7a00 	vldr	s15, [r1]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 80197d2:	edd2 5a06 	vldr	s11, [r2, #24]
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 80197d6:	ed92 6a08 	vldr	s12, [r2, #32]
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 80197da:	ee27 5a85 	vmul.f32	s10, s15, s10
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 80197de:	edd2 6a0a 	vldr	s13, [r2, #40]	; 0x28
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 80197e2:	ee67 5aa5 	vmul.f32	s11, s15, s11
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 80197e6:	ed92 7a0b 	vldr	s14, [r2, #44]	; 0x2c
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 80197ea:	ee27 6a86 	vmul.f32	s12, s15, s12
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 80197ee:	ee67 6aa6 	vmul.f32	s13, s15, s13
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 80197f2:	eddf 8a8f 	vldr	s17, [pc, #572]	; 8019a30 <SFXClassicSynthAlloc+0x294>
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 80197f6:	ee27 7a87 	vmul.f32	s14, s15, s14
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 80197fa:	498e      	ldr	r1, [pc, #568]	; (8019a34 <SFXClassicSynthAlloc+0x298>)
 80197fc:	eebd 5ac5 	vcvt.s32.f32	s10, s10
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 8019800:	ed92 4a04 	vldr	s8, [r2, #16]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019804:	eefd 5ae5 	vcvt.s32.f32	s11, s11
            displayValues[0] = knobs[0]; //synth volume
 8019808:	f85c 8b04 	ldr.w	r8, [ip], #4
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801980c:	eebd 6ac6 	vcvt.s32.f32	s12, s12
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 8019810:	ed9f aa89 	vldr	s20, [pc, #548]	; 8019a38 <SFXClassicSynthAlloc+0x29c>
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019814:	eefd 6ae6 	vcvt.s32.f32	s13, s13
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019818:	ee15 ea10 	vmov	lr, s10
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801981c:	eebd 7ac7 	vcvt.s32.f32	s14, s14
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019820:	ee15 6a90 	vmov	r6, s11
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 8019824:	eef0 3a68 	vmov.f32	s7, s17
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 8019828:	ee16 5a10 	vmov	r5, s12
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801982c:	ee16 4a90 	vmov	r4, s13
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019830:	eb01 0e8e 	add.w	lr, r1, lr, lsl #2
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019834:	ee17 0a10 	vmov	r0, s14
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019838:	eb01 0686 	add.w	r6, r1, r6, lsl #2
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801983c:	eb01 0585 	add.w	r5, r1, r5, lsl #2
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 8019840:	eee4 3a24 	vfma.f32	s7, s8, s9
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019844:	eb01 0484 	add.w	r4, r1, r4, lsl #2
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 8019848:	eddc 4a00 	vldr	s9, [ip]
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801984c:	eb01 0080 	add.w	r0, r1, r0, lsl #2
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 8019850:	ed9f 7a7a 	vldr	s14, [pc, #488]	; 8019a3c <SFXClassicSynthAlloc+0x2a0>
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019854:	ed9f 6a7a 	vldr	s12, [pc, #488]	; 8019a40 <SFXClassicSynthAlloc+0x2a4>
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019858:	edd4 6a00 	vldr	s13, [r4]
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 801985c:	ee64 4a87 	vmul.f32	s9, s9, s14
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019860:	ed9e 4a00 	vldr	s8, [lr]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019864:	ed96 5a00 	vldr	s10, [r6]
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019868:	ee66 6a86 	vmul.f32	s13, s13, s12
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801986c:	edd5 5a00 	vldr	s11, [r5]
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019870:	ee24 4a06 	vmul.f32	s8, s8, s12
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019874:	ed90 7a00 	vldr	s14, [r0]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019878:	ee25 5a06 	vmul.f32	s10, s10, s12
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801987c:	ee65 5a86 	vmul.f32	s11, s11, s12
            displayValues[0] = knobs[0]; //synth volume
 8019880:	4c70      	ldr	r4, [pc, #448]	; (8019a44 <SFXClassicSynthAlloc+0x2a8>)
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019882:	ee27 7a06 	vmul.f32	s14, s14, s12
            displayValues[12] = knobs[12]; //sus
 8019886:	6b10      	ldr	r0, [r2, #48]	; 0x30
            displayValues[2] = knobs[2]; //keyfollow filter cutoff
 8019888:	f8d2 e008 	ldr.w	lr, [r2, #8]
            displayValues[3] = knobs[3]; //detune
 801988c:	f8d2 c00c 	ldr.w	ip, [r2, #12]
            displayValues[7] = knobs[7]; //sus
 8019890:	69d6      	ldr	r6, [r2, #28]
            displayValues[9] = knobs[9]; //leak
 8019892:	6a55      	ldr	r5, [r2, #36]	; 0x24
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019894:	edc4 6a0a 	vstr	s13, [r4, #40]	; 0x28
            displayValues[12] = knobs[12]; //sus
 8019898:	6320      	str	r0, [r4, #48]	; 0x30
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801989a:	ed84 4a05 	vstr	s8, [r4, #20]
            displayValues[0] = knobs[0]; //synth volume
 801989e:	f8c4 8000 	str.w	r8, [r4]
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 80198a2:	edc4 4a01 	vstr	s9, [r4, #4]
            displayValues[2] = knobs[2]; //keyfollow filter cutoff
 80198a6:	f8c4 e008 	str.w	lr, [r4, #8]
            displayValues[3] = knobs[3]; //detune
 80198aa:	f8c4 c00c 	str.w	ip, [r4, #12]
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 80198ae:	edc4 3a04 	vstr	s7, [r4, #16]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 80198b2:	ed84 5a06 	vstr	s10, [r4, #24]
            displayValues[7] = knobs[7]; //sus
 80198b6:	61e6      	str	r6, [r4, #28]
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 80198b8:	edc4 5a08 	vstr	s11, [r4, #32]
            displayValues[9] = knobs[9]; //leak
 80198bc:	6265      	str	r5, [r4, #36]	; 0x24
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 80198be:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 80198c2:	ed92 7a0d 	vldr	s14, [r2, #52]	; 0x34
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 80198c6:	eddf 6a60 	vldr	s13, [pc, #384]	; 8019a48 <SFXClassicSynthAlloc+0x2ac>
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 80198ca:	ee67 7a87 	vmul.f32	s15, s15, s14
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 80198ce:	ed92 7a0f 	vldr	s14, [r2, #60]	; 0x3c
            displayValues[14] = knobs[14]; //leak
 80198d2:	6b90      	ldr	r0, [r2, #56]	; 0x38
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 80198d4:	ee27 7a26 	vmul.f32	s14, s14, s13
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
 80198d8:	6c12      	ldr	r2, [r2, #64]	; 0x40
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 80198da:	eefd 7ae7 	vcvt.s32.f32	s15, s15
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 80198de:	eddf 9a5b 	vldr	s19, [pc, #364]	; 8019a4c <SFXClassicSynthAlloc+0x2b0>
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
 80198e2:	ed9f 9a5b 	vldr	s18, [pc, #364]	; 8019a50 <SFXClassicSynthAlloc+0x2b4>
                tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 80198e6:	ed9f ba5b 	vldr	s22, [pc, #364]	; 8019a54 <SFXClassicSynthAlloc+0x2b8>
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 80198ea:	ee17 3a90 	vmov	r3, s15
            displayValues[14] = knobs[14]; //leak
 80198ee:	63a0      	str	r0, [r4, #56]	; 0x38
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
 80198f0:	6422      	str	r2, [r4, #64]	; 0x40
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 80198f2:	eb01 0183 	add.w	r1, r1, r3, lsl #2
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 80198f6:	ed84 7a0f 	vstr	s14, [r4, #60]	; 0x3c
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 80198fa:	edd1 7a00 	vldr	s15, [r1]
 80198fe:	ee27 6a86 	vmul.f32	s12, s15, s12
 8019902:	ed84 6a0d 	vstr	s12, [r4, #52]	; 0x34
 8019906:	4b54      	ldr	r3, [pc, #336]	; (8019a58 <SFXClassicSynthAlloc+0x2bc>)
 8019908:	f10a 080c 	add.w	r8, sl, #12
 801990c:	eb03 060a 	add.w	r6, r3, sl
 8019910:	4b52      	ldr	r3, [pc, #328]	; (8019a5c <SFXClassicSynthAlloc+0x2c0>)
                    tSawtooth_init(&osc[(i * NUM_OSC_PER_VOICE) + j]);
 8019912:	eb0b 000a 	add.w	r0, fp, sl
 8019916:	eb03 050a 	add.w	r5, r3, sl
 801991a:	f00b fa1b 	bl	8024d54 <tSawtooth_init>
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801991e:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8019922:	f10a 0a04 	add.w	sl, sl, #4
 8019926:	4798      	blx	r3
 8019928:	eef0 7a69 	vmov.f32	s15, s19
                    tRosenbergGlottalPulse_init(&glottal[(i * NUM_OSC_PER_VOICE) + j]);
 801992c:	4628      	mov	r0, r5
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801992e:	eee0 7a0a 	vfma.f32	s15, s0, s20
 8019932:	ece6 7a01 	vstmia	r6!, {s15}
                    tRosenbergGlottalPulse_init(&glottal[(i * NUM_OSC_PER_VOICE) + j]);
 8019936:	f007 f86d 	bl	8020a14 <tRosenbergGlottalPulse_init>
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
 801993a:	eeb0 0a49 	vmov.f32	s0, s18
 801993e:	4628      	mov	r0, r5
 8019940:	f007 f96a 	bl	8020c18 <tRosenbergGlottalPulse_setOpenLength>
                    tRosenbergGlottalPulse_setPulseLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.4f);
 8019944:	eeb0 0a68 	vmov.f32	s0, s17
 8019948:	4628      	mov	r0, r5
 801994a:	f007 f973 	bl	8020c34 <tRosenbergGlottalPulse_setPulseLength>
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
 801994e:	45c2      	cmp	sl, r8
 8019950:	d1de      	bne.n	8019910 <SFXClassicSynthAlloc+0x174>
 8019952:	4b43      	ldr	r3, [pc, #268]	; (8019a60 <SFXClassicSynthAlloc+0x2c4>)
                tEfficientSVF_init(&synthLP[i], SVFTypeLowpass, 2000, displayValues[4]);
 8019954:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8019958:	ed94 0a04 	vldr	s0, [r4, #16]
 801995c:	2101      	movs	r1, #1
 801995e:	19de      	adds	r6, r3, r7
 8019960:	4b40      	ldr	r3, [pc, #256]	; (8019a64 <SFXClassicSynthAlloc+0x2c8>)
                tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 8019962:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 8019966:	eddf aa40 	vldr	s21, [pc, #256]	; 8019a68 <SFXClassicSynthAlloc+0x2cc>
                tEfficientSVF_init(&synthLP[i], SVFTypeLowpass, 2000, displayValues[4]);
 801996a:	19d8      	adds	r0, r3, r7
 801996c:	f009 f82a 	bl	80229c4 <tEfficientSVF_init>
 8019970:	4b3e      	ldr	r3, [pc, #248]	; (8019a6c <SFXClassicSynthAlloc+0x2d0>)
                tADSR4_init(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE);
 8019972:	f44f 7200 	mov.w	r2, #512	; 0x200
 8019976:	493e      	ldr	r1, [pc, #248]	; (8019a70 <SFXClassicSynthAlloc+0x2d4>)
 8019978:	edd4 1a08 	vldr	s3, [r4, #32]
 801997c:	4630      	mov	r0, r6
 801997e:	ed94 1a07 	vldr	s2, [r4, #28]
 8019982:	19dd      	adds	r5, r3, r7
 8019984:	edd4 0a06 	vldr	s1, [r4, #24]
 8019988:	3704      	adds	r7, #4
 801998a:	ed94 0a05 	vldr	s0, [r4, #20]
 801998e:	f008 fa01 	bl	8021d94 <tADSR4_init>
                tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 8019992:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8019996:	eeb0 0a6a 	vmov.f32	s0, s21
 801999a:	4630      	mov	r0, r6
 801999c:	ee78 7a67 	vsub.f32	s15, s16, s15
 80199a0:	eea7 0a8b 	vfma.f32	s0, s15, s22
 80199a4:	f008 fa96 	bl	8021ed4 <tADSR4_setLeakFactor>
                tADSR4_init(&polyFiltEnvs[i], displayValues[10], displayValues[11], displayValues[12], displayValues[13], decayExpBuffer, DECAY_EXP_BUFFER_SIZE);
 80199a8:	4628      	mov	r0, r5
 80199aa:	f44f 7200 	mov.w	r2, #512	; 0x200
 80199ae:	4930      	ldr	r1, [pc, #192]	; (8019a70 <SFXClassicSynthAlloc+0x2d4>)
 80199b0:	edd4 1a0d 	vldr	s3, [r4, #52]	; 0x34
 80199b4:	ed94 1a0c 	vldr	s2, [r4, #48]	; 0x30
 80199b8:	edd4 0a0b 	vldr	s1, [r4, #44]	; 0x2c
 80199bc:	ed94 0a0a 	vldr	s0, [r4, #40]	; 0x28
 80199c0:	f008 f9e8 	bl	8021d94 <tADSR4_init>
                tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
 80199c4:	edd4 7a0e 	vldr	s15, [r4, #56]	; 0x38
 80199c8:	eeb0 0a6a 	vmov.f32	s0, s21
 80199cc:	4628      	mov	r0, r5
 80199ce:	ee38 8a67 	vsub.f32	s16, s16, s15
 80199d2:	eea8 0a0b 	vfma.f32	s0, s16, s22
 80199d6:	f008 fa7d 	bl	8021ed4 <tADSR4_setLeakFactor>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 80199da:	2f20      	cmp	r7, #32
 80199dc:	d193      	bne.n	8019906 <SFXClassicSynthAlloc+0x16a>
            tCycle_init(&pwmLFO1);
 80199de:	4825      	ldr	r0, [pc, #148]	; (8019a74 <SFXClassicSynthAlloc+0x2d8>)
 80199e0:	f00b f92a 	bl	8024c38 <tCycle_init>
            tCycle_init(&pwmLFO2);
 80199e4:	4824      	ldr	r0, [pc, #144]	; (8019a78 <SFXClassicSynthAlloc+0x2dc>)
 80199e6:	f00b f927 	bl	8024c38 <tCycle_init>
            tCycle_setFreq(&pwmLFO1, 63.0f);
 80199ea:	ed9f 0a24 	vldr	s0, [pc, #144]	; 8019a7c <SFXClassicSynthAlloc+0x2e0>
 80199ee:	4821      	ldr	r0, [pc, #132]	; (8019a74 <SFXClassicSynthAlloc+0x2d8>)
 80199f0:	f00b f944 	bl	8024c7c <tCycle_setFreq>
            tCycle_setFreq(&pwmLFO2, 72.11f);
 80199f4:	ed9f 0a22 	vldr	s0, [pc, #136]	; 8019a80 <SFXClassicSynthAlloc+0x2e4>
 80199f8:	481f      	ldr	r0, [pc, #124]	; (8019a78 <SFXClassicSynthAlloc+0x2dc>)
 80199fa:	f00b f93f 	bl	8024c7c <tCycle_setFreq>
            setLED_A(numVoices == 1);
 80199fe:	4b08      	ldr	r3, [pc, #32]	; (8019a20 <SFXClassicSynthAlloc+0x284>)
 8019a00:	6818      	ldr	r0, [r3, #0]
 8019a02:	f1a0 0001 	sub.w	r0, r0, #1
 8019a06:	fab0 f080 	clz	r0, r0
 8019a0a:	0940      	lsrs	r0, r0, #5
 8019a0c:	f7f9 ff9e 	bl	801394c <setLED_A>
            leaf.clearOnAllocation = 0;
 8019a10:	2300      	movs	r3, #0
        }
 8019a12:	ecbd 8b08 	vpop	{d8-d11}
            leaf.clearOnAllocation = 0;
 8019a16:	f8c9 3014 	str.w	r3, [r9, #20]
        }
 8019a1a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8019a1e:	bf00      	nop
 8019a20:	20000254 	.word	0x20000254
 8019a24:	200174c8 	.word	0x200174c8
 8019a28:	200032f8 	.word	0x200032f8
 8019a2c:	2000023c 	.word	0x2000023c
 8019a30:	3ecccccd 	.word	0x3ecccccd
 8019a34:	20016fec 	.word	0x20016fec
 8019a38:	3cd844d0 	.word	0x3cd844d0
 8019a3c:	45800000 	.word	0x45800000
 8019a40:	46000000 	.word	0x46000000
 8019a44:	200187dc 	.word	0x200187dc
 8019a48:	457ff000 	.word	0x457ff000
 8019a4c:	bc5844d0 	.word	0xbc5844d0
 8019a50:	3e99999a 	.word	0x3e99999a
 8019a54:	3851b717 	.word	0x3851b717
 8019a58:	2001834c 	.word	0x2001834c
 8019a5c:	200027f0 	.word	0x200027f0
 8019a60:	20017648 	.word	0x20017648
 8019a64:	200033c0 	.word	0x200033c0
 8019a68:	3f7ffcb9 	.word	0x3f7ffcb9
 8019a6c:	20001ef0 	.word	0x20001ef0
 8019a70:	20017988 	.word	0x20017988
 8019a74:	20017638 	.word	0x20017638
 8019a78:	200177ac 	.word	0x200177ac
 8019a7c:	427c0000 	.word	0x427c0000
 8019a80:	42903852 	.word	0x42903852
 8019a84:	200194e8 	.word	0x200194e8
 8019a88:	20017284 	.word	0x20017284

08019a8c <SFXClassicSynthFrame>:
        {
 8019a8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8019a90:	4cc2      	ldr	r4, [pc, #776]	; (8019d9c <SFXClassicSynthFrame+0x310>)
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8019a92:	4bc3      	ldr	r3, [pc, #780]	; (8019da0 <SFXClassicSynthFrame+0x314>)
        {
 8019a94:	ed2d 8b08 	vpush	{d8-d11}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8019a98:	7d21      	ldrb	r1, [r4, #20]
        {
 8019a9a:	b085      	sub	sp, #20
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8019a9c:	2901      	cmp	r1, #1
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8019a9e:	9302      	str	r3, [sp, #8]
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8019aa0:	d113      	bne.n	8019aca <SFXClassicSynthFrame+0x3e>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8019aa2:	681b      	ldr	r3, [r3, #0]
 8019aa4:	9d02      	ldr	r5, [sp, #8]
 8019aa6:	2b01      	cmp	r3, #1
                tSimplePoly_setNumVoices(&poly, numVoices);
 8019aa8:	48be      	ldr	r0, [pc, #760]	; (8019da4 <SFXClassicSynthFrame+0x318>)
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8019aaa:	462a      	mov	r2, r5
 8019aac:	bfd8      	it	le
 8019aae:	2108      	movle	r1, #8
 8019ab0:	6011      	str	r1, [r2, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
 8019ab2:	f00b f881 	bl	8024bb8 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
 8019ab6:	6828      	ldr	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8019ab8:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
 8019aba:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8019abe:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
 8019ac0:	fab0 f080 	clz	r0, r0
 8019ac4:	0940      	lsrs	r0, r0, #5
 8019ac6:	f7f9 ff41 	bl	801394c <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 8019aca:	7e23      	ldrb	r3, [r4, #24]
 8019acc:	2b01      	cmp	r3, #1
 8019ace:	f000 80f0 	beq.w	8019cb2 <SFXClassicSynthFrame+0x226>
            if (writeKnobFlag != -1)
 8019ad2:	4bb5      	ldr	r3, [pc, #724]	; (8019da8 <SFXClassicSynthFrame+0x31c>)
 8019ad4:	f993 2000 	ldrsb.w	r2, [r3]
 8019ad8:	1c53      	adds	r3, r2, #1
 8019ada:	d01d      	beq.n	8019b18 <SFXClassicSynthFrame+0x8c>
                switch(writeKnobFlag + (knobPage * KNOB_PAGE_SIZE))
 8019adc:	49b3      	ldr	r1, [pc, #716]	; (8019dac <SFXClassicSynthFrame+0x320>)
 8019ade:	2305      	movs	r3, #5
 8019ae0:	7809      	ldrb	r1, [r1, #0]
 8019ae2:	fb13 2301 	smlabb	r3, r3, r1, r2
 8019ae6:	2b10      	cmp	r3, #16
 8019ae8:	d816      	bhi.n	8019b18 <SFXClassicSynthFrame+0x8c>
 8019aea:	e8df f013 	tbh	[pc, r3, lsl #1]
 8019aee:	0011      	.short	0x0011
 8019af0:	02dd02e2 	.word	0x02dd02e2
 8019af4:	02b902d8 	.word	0x02b902d8
 8019af8:	0263028e 	.word	0x0263028e
 8019afc:	021f024a 	.word	0x021f024a
 8019b00:	01cf01fa 	.word	0x01cf01fa
 8019b04:	014801a4 	.word	0x014801a4
 8019b08:	00f8011d 	.word	0x00f8011d
 8019b0c:	00e800ed 	.word	0x00e800ed
                        displayValues[0] = knobs[0]; //synth volume
 8019b10:	4ba7      	ldr	r3, [pc, #668]	; (8019db0 <SFXClassicSynthFrame+0x324>)
 8019b12:	4ea8      	ldr	r6, [pc, #672]	; (8019db4 <SFXClassicSynthFrame+0x328>)
 8019b14:	681b      	ldr	r3, [r3, #0]
 8019b16:	6033      	str	r3, [r6, #0]
            float tempLFO1 = (tCycle_tick(&pwmLFO1) * 0.25f) + 0.5f; // pulse length
 8019b18:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
 8019b1c:	48a6      	ldr	r0, [pc, #664]	; (8019db8 <SFXClassicSynthFrame+0x32c>)
 8019b1e:	eeb5 8a00 	vmov.f32	s16, #80	; 0x3e800000  0.250
 8019b22:	f00b f8b9 	bl	8024c98 <tCycle_tick>
            float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
 8019b26:	48a5      	ldr	r0, [pc, #660]	; (8019dbc <SFXClassicSynthFrame+0x330>)
            float tempLFO1 = (tCycle_tick(&pwmLFO1) * 0.25f) + 0.5f; // pulse length
 8019b28:	eef0 9a68 	vmov.f32	s19, s17
 8019b2c:	eee0 9a08 	vfma.f32	s19, s0, s16
            float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
 8019b30:	f00b f8b2 	bl	8024c98 <tCycle_tick>
            for (int i = 0; i < numVoices; i++)
 8019b34:	9b02      	ldr	r3, [sp, #8]
            float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
 8019b36:	eee0 8a08 	vfma.f32	s17, s0, s16
            for (int i = 0; i < numVoices; i++)
 8019b3a:	681b      	ldr	r3, [r3, #0]
 8019b3c:	2b00      	cmp	r3, #0
            float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
 8019b3e:	ee68 8aa9 	vmul.f32	s17, s17, s19
            for (int i = 0; i < numVoices; i++)
 8019b42:	f340 80a4 	ble.w	8019c8e <SFXClassicSynthFrame+0x202>
 8019b46:	f04f 0a00 	mov.w	sl, #0
 8019b4a:	4b9d      	ldr	r3, [pc, #628]	; (8019dc0 <SFXClassicSynthFrame+0x334>)
 8019b4c:	4f9d      	ldr	r7, [pc, #628]	; (8019dc4 <SFXClassicSynthFrame+0x338>)
 8019b4e:	46d1      	mov	r9, sl
 8019b50:	4e98      	ldr	r6, [pc, #608]	; (8019db4 <SFXClassicSynthFrame+0x328>)
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
 8019b52:	f8df b250 	ldr.w	fp, [pc, #592]	; 8019da4 <SFXClassicSynthFrame+0x318>
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
 8019b56:	eddf ba9c 	vldr	s23, [pc, #624]	; 8019dc8 <SFXClassicSynthFrame+0x33c>
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
 8019b5a:	ed9f ba9c 	vldr	s22, [pc, #624]	; 8019dcc <SFXClassicSynthFrame+0x340>
 8019b5e:	eddf aa9c 	vldr	s21, [pc, #624]	; 8019dd0 <SFXClassicSynthFrame+0x344>
 8019b62:	9301      	str	r3, [sp, #4]
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
 8019b64:	fa5f f389 	uxtb.w	r3, r9
 8019b68:	4a9a      	ldr	r2, [pc, #616]	; (8019dd4 <SFXClassicSynthFrame+0x348>)
 8019b6a:	4658      	mov	r0, fp
                    float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
 8019b6c:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
 8019b70:	461c      	mov	r4, r3
 8019b72:	4619      	mov	r1, r3
 8019b74:	9303      	str	r3, [sp, #12]
 8019b76:	eb02 050a 	add.w	r5, r2, sl
 8019b7a:	f00b f841 	bl	8024c00 <tSimplePoly_getPitch>
 8019b7e:	ee07 0a90 	vmov	s15, r0
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8019b82:	4621      	mov	r1, r4
 8019b84:	4658      	mov	r0, fp
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
 8019b86:	eeb8 aae7 	vcvt.f32.s32	s20, s15
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8019b8a:	f00b f839 	bl	8024c00 <tSimplePoly_getPitch>
 8019b8e:	ee07 0a90 	vmov	s15, r0
 8019b92:	4b91      	ldr	r3, [pc, #580]	; (8019dd8 <SFXClassicSynthFrame+0x34c>)
 8019b94:	f10a 080c 	add.w	r8, sl, #12
 8019b98:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8019b9c:	ed93 0a00 	vldr	s0, [r3]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8019ba0:	4b8e      	ldr	r3, [pc, #568]	; (8019ddc <SFXClassicSynthFrame+0x350>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8019ba2:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8019ba6:	7818      	ldrb	r0, [r3, #0]
 8019ba8:	4b8d      	ldr	r3, [pc, #564]	; (8019de0 <SFXClassicSynthFrame+0x354>)
 8019baa:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8019bae:	ee17 1a90 	vmov	r1, s15
 8019bb2:	1a09      	subs	r1, r1, r0
 8019bb4:	fb83 3401 	smull	r3, r4, r3, r1
 8019bb8:	17c8      	asrs	r0, r1, #31
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8019bba:	4b8a      	ldr	r3, [pc, #552]	; (8019de4 <SFXClassicSynthFrame+0x358>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8019bbc:	ebc0 0064 	rsb	r0, r0, r4, asr #1
 8019bc0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8019bc4:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
 8019bc8:	ee07 0a90 	vmov	s15, r0
 8019bcc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8019bd0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019bd4:	ee17 1a90 	vmov	r1, s15
 8019bd8:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8019bdc:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8019be0:	ee37 0a00 	vadd.f32	s0, s14, s0
 8019be4:	f00a fa52 	bl	802408c <LEAF_midiToFrequency>
 8019be8:	eca7 0a01 	vstmia	r7!, {s0}
                    float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
 8019bec:	eeb0 8a49 	vmov.f32	s16, s18
 8019bf0:	ecb5 7a01 	vldmia	r5!, {s14}
 8019bf4:	edd6 7a03 	vldr	s15, [r6, #12]
 8019bf8:	4b7b      	ldr	r3, [pc, #492]	; (8019de8 <SFXClassicSynthFrame+0x35c>)
 8019bfa:	eea7 8a27 	vfma.f32	s16, s14, s15
 8019bfe:	eb03 040a 	add.w	r4, r3, sl
                    tSawtooth_setFreq(&osc[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
 8019c02:	4b7a      	ldr	r3, [pc, #488]	; (8019dec <SFXClassicSynthFrame+0x360>)
 8019c04:	eb03 000a 	add.w	r0, r3, sl
 8019c08:	f10a 0a04 	add.w	sl, sl, #4
                    float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
 8019c0c:	ee28 8a00 	vmul.f32	s16, s16, s0
                    tSawtooth_setFreq(&osc[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
 8019c10:	eeb0 0a48 	vmov.f32	s0, s16
 8019c14:	f00b f8c6 	bl	8024da4 <tSawtooth_setFreq>
                    tRosenbergGlottalPulse_setFreq(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
 8019c18:	eeb0 0a48 	vmov.f32	s0, s16
 8019c1c:	4620      	mov	r0, r4
 8019c1e:	f006 ffed 	bl	8020bfc <tRosenbergGlottalPulse_setFreq>
                    tRosenbergGlottalPulse_setPulseLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempLFO1);
 8019c22:	eeb0 0a69 	vmov.f32	s0, s19
 8019c26:	4620      	mov	r0, r4
 8019c28:	f007 f804 	bl	8020c34 <tRosenbergGlottalPulse_setPulseLength>
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempLFO2);
 8019c2c:	eeb0 0a68 	vmov.f32	s0, s17
 8019c30:	4620      	mov	r0, r4
 8019c32:	f006 fff1 	bl	8020c18 <tRosenbergGlottalPulse_setOpenLength>
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
 8019c36:	45d0      	cmp	r8, sl
 8019c38:	d002      	beq.n	8019c40 <SFXClassicSynthFrame+0x1b4>
 8019c3a:	ed17 0a01 	vldr	s0, [r7, #-4]
 8019c3e:	e7d5      	b.n	8019bec <SFXClassicSynthFrame+0x160>
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
 8019c40:	edd6 7a02 	vldr	s15, [r6, #8]
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
 8019c44:	eeb0 1a4b 	vmov.f32	s2, s22
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
 8019c48:	edd6 0a01 	vldr	s1, [r6, #4]
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
 8019c4c:	eeb0 0a6a 	vmov.f32	s0, s21
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
 8019c50:	ee67 7aab 	vmul.f32	s15, s15, s23
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
 8019c54:	eeea 0a27 	vfma.f32	s1, s20, s15
 8019c58:	f00a f92c 	bl	8023eb4 <LEAF_clip>
                if (numVoices > 1)
 8019c5c:	9b02      	ldr	r3, [sp, #8]
                filtFreqs[i] = (uint16_t) tempFreq2;
 8019c5e:	eebc 0ac0 	vcvt.u32.f32	s0, s0
                if (numVoices > 1)
 8019c62:	6819      	ldr	r1, [r3, #0]
                filtFreqs[i] = (uint16_t) tempFreq2;
 8019c64:	9b01      	ldr	r3, [sp, #4]
 8019c66:	ee10 2a10 	vmov	r2, s0
                if (numVoices > 1)
 8019c6a:	2901      	cmp	r1, #1
                filtFreqs[i] = (uint16_t) tempFreq2;
 8019c6c:	f823 2f02 	strh.w	r2, [r3, #2]!
 8019c70:	9301      	str	r3, [sp, #4]
                if (numVoices > 1)
 8019c72:	dd0c      	ble.n	8019c8e <SFXClassicSynthFrame+0x202>
                    if (poly->voices[i][0] == -2)
 8019c74:	f8db 0000 	ldr.w	r0, [fp]
 8019c78:	6900      	ldr	r0, [r0, #16]
 8019c7a:	f850 0029 	ldr.w	r0, [r0, r9, lsl #2]
 8019c7e:	6800      	ldr	r0, [r0, #0]
 8019c80:	3002      	adds	r0, #2
 8019c82:	d009      	beq.n	8019c98 <SFXClassicSynthFrame+0x20c>
            for (int i = 0; i < numVoices; i++)
 8019c84:	f109 0901 	add.w	r9, r9, #1
 8019c88:	4589      	cmp	r9, r1
 8019c8a:	f6ff af6b 	blt.w	8019b64 <SFXClassicSynthFrame+0xd8>
        }
 8019c8e:	b005      	add	sp, #20
 8019c90:	ecbd 8b08 	vpop	{d8-d11}
 8019c94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        if (polyEnvs[i]->whichStage == env_idle)
 8019c98:	4b55      	ldr	r3, [pc, #340]	; (8019df0 <SFXClassicSynthFrame+0x364>)
 8019c9a:	f853 0029 	ldr.w	r0, [r3, r9, lsl #2]
 8019c9e:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8019ca0:	2800      	cmp	r0, #0
 8019ca2:	d1ef      	bne.n	8019c84 <SFXClassicSynthFrame+0x1f8>
                            tSimplePoly_deactivateVoice(&poly, i);
 8019ca4:	9903      	ldr	r1, [sp, #12]
 8019ca6:	4658      	mov	r0, fp
 8019ca8:	f00a fed0 	bl	8024a4c <tSimplePoly_deactivateVoice>
 8019cac:	9b02      	ldr	r3, [sp, #8]
 8019cae:	6819      	ldr	r1, [r3, #0]
 8019cb0:	e7e8      	b.n	8019c84 <SFXClassicSynthFrame+0x1f8>
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8019cb2:	2300      	movs	r3, #0
                setLED_Edit(0);
 8019cb4:	4618      	mov	r0, r3
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8019cb6:	7623      	strb	r3, [r4, #24]
                setLED_Edit(0);
 8019cb8:	f7f9 fe0c 	bl	80138d4 <setLED_Edit>
 8019cbc:	e709      	b.n	8019ad2 <SFXClassicSynthFrame+0x46>
                        displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
 8019cbe:	4b4d      	ldr	r3, [pc, #308]	; (8019df4 <SFXClassicSynthFrame+0x368>)
 8019cc0:	4e3c      	ldr	r6, [pc, #240]	; (8019db4 <SFXClassicSynthFrame+0x328>)
 8019cc2:	681b      	ldr	r3, [r3, #0]
 8019cc4:	6433      	str	r3, [r6, #64]	; 0x40
                        break;
 8019cc6:	e727      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 8019cc8:	4b4b      	ldr	r3, [pc, #300]	; (8019df8 <SFXClassicSynthFrame+0x36c>)
 8019cca:	ed9f 7a40 	vldr	s14, [pc, #256]	; 8019dcc <SFXClassicSynthFrame+0x340>
 8019cce:	edd3 7a00 	vldr	s15, [r3]
 8019cd2:	4e38      	ldr	r6, [pc, #224]	; (8019db4 <SFXClassicSynthFrame+0x328>)
 8019cd4:	ee67 7a87 	vmul.f32	s15, s15, s14
 8019cd8:	edc6 7a0f 	vstr	s15, [r6, #60]	; 0x3c
                        break;
 8019cdc:	e71c      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[14] = knobs[14]; //leak
 8019cde:	4b47      	ldr	r3, [pc, #284]	; (8019dfc <SFXClassicSynthFrame+0x370>)
                        for (int i = 0; i < numVoices; i++)
 8019ce0:	9f02      	ldr	r7, [sp, #8]
                        displayValues[14] = knobs[14]; //leak
 8019ce2:	edd3 7a00 	vldr	s15, [r3]
                        for (int i = 0; i < numVoices; i++)
 8019ce6:	683b      	ldr	r3, [r7, #0]
                        displayValues[14] = knobs[14]; //leak
 8019ce8:	4e32      	ldr	r6, [pc, #200]	; (8019db4 <SFXClassicSynthFrame+0x328>)
                        for (int i = 0; i < numVoices; i++)
 8019cea:	2b00      	cmp	r3, #0
                        displayValues[14] = knobs[14]; //leak
 8019cec:	edc6 7a0e 	vstr	s15, [r6, #56]	; 0x38
                        for (int i = 0; i < numVoices; i++)
 8019cf0:	f77f af12 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
                            tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
 8019cf4:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 8019cf8:	4d41      	ldr	r5, [pc, #260]	; (8019e00 <SFXClassicSynthFrame+0x374>)
                        for (int i = 0; i < numVoices; i++)
 8019cfa:	2400      	movs	r4, #0
                            tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
 8019cfc:	eddf 8a41 	vldr	s17, [pc, #260]	; 8019e04 <SFXClassicSynthFrame+0x378>
 8019d00:	ed9f 8a41 	vldr	s16, [pc, #260]	; 8019e08 <SFXClassicSynthFrame+0x37c>
 8019d04:	e001      	b.n	8019d0a <SFXClassicSynthFrame+0x27e>
 8019d06:	edd6 7a0e 	vldr	s15, [r6, #56]	; 0x38
 8019d0a:	ee79 7a67 	vsub.f32	s15, s18, s15
 8019d0e:	4628      	mov	r0, r5
 8019d10:	eeb0 0a48 	vmov.f32	s0, s16
                        for (int i = 0; i < numVoices; i++)
 8019d14:	3401      	adds	r4, #1
 8019d16:	3504      	adds	r5, #4
                            tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
 8019d18:	eea7 0aa8 	vfma.f32	s0, s15, s17
 8019d1c:	f008 f8da 	bl	8021ed4 <tADSR4_setLeakFactor>
                        for (int i = 0; i < numVoices; i++)
 8019d20:	683b      	ldr	r3, [r7, #0]
 8019d22:	42a3      	cmp	r3, r4
 8019d24:	dcef      	bgt.n	8019d06 <SFXClassicSynthFrame+0x27a>
 8019d26:	e6f7      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 8019d28:	4a38      	ldr	r2, [pc, #224]	; (8019e0c <SFXClassicSynthFrame+0x380>)
 8019d2a:	4b39      	ldr	r3, [pc, #228]	; (8019e10 <SFXClassicSynthFrame+0x384>)
 8019d2c:	edd2 7a00 	vldr	s15, [r2]
 8019d30:	ed93 7a00 	vldr	s14, [r3]
 8019d34:	4b37      	ldr	r3, [pc, #220]	; (8019e14 <SFXClassicSynthFrame+0x388>)
 8019d36:	ee67 7a87 	vmul.f32	s15, s15, s14
                        for (int i = 0; i < numVoices; i++)
 8019d3a:	9f02      	ldr	r7, [sp, #8]
                        displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 8019d3c:	ed9f 7a36 	vldr	s14, [pc, #216]	; 8019e18 <SFXClassicSynthFrame+0x38c>
                        for (int i = 0; i < numVoices; i++)
 8019d40:	683a      	ldr	r2, [r7, #0]
                        displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 8019d42:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019d46:	4e1b      	ldr	r6, [pc, #108]	; (8019db4 <SFXClassicSynthFrame+0x328>)
                        for (int i = 0; i < numVoices; i++)
 8019d48:	2a00      	cmp	r2, #0
                        displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 8019d4a:	ee17 1a90 	vmov	r1, s15
 8019d4e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8019d52:	ed93 0a00 	vldr	s0, [r3]
 8019d56:	ee20 0a07 	vmul.f32	s0, s0, s14
 8019d5a:	ed86 0a0d 	vstr	s0, [r6, #52]	; 0x34
                        for (int i = 0; i < numVoices; i++)
 8019d5e:	f77f aedb 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
 8019d62:	4d27      	ldr	r5, [pc, #156]	; (8019e00 <SFXClassicSynthFrame+0x374>)
 8019d64:	2400      	movs	r4, #0
 8019d66:	e001      	b.n	8019d6c <SFXClassicSynthFrame+0x2e0>
 8019d68:	ed96 0a0d 	vldr	s0, [r6, #52]	; 0x34
                            tADSR4_setRelease(&polyFiltEnvs[i], displayValues[13]);
 8019d6c:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
 8019d6e:	3401      	adds	r4, #1
                            tADSR4_setRelease(&polyFiltEnvs[i], displayValues[13]);
 8019d70:	f008 f8a2 	bl	8021eb8 <tADSR4_setRelease>
                        for (int i = 0; i < numVoices; i++)
 8019d74:	683b      	ldr	r3, [r7, #0]
 8019d76:	3504      	adds	r5, #4
 8019d78:	42a3      	cmp	r3, r4
 8019d7a:	dcf5      	bgt.n	8019d68 <SFXClassicSynthFrame+0x2dc>
 8019d7c:	e6cc      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[12] = knobs[12]; //sus
 8019d7e:	4b27      	ldr	r3, [pc, #156]	; (8019e1c <SFXClassicSynthFrame+0x390>)
                        for (int i = 0; i < numVoices; i++)
 8019d80:	9f02      	ldr	r7, [sp, #8]
                        displayValues[12] = knobs[12]; //sus
 8019d82:	ed93 0a00 	vldr	s0, [r3]
                        for (int i = 0; i < numVoices; i++)
 8019d86:	683b      	ldr	r3, [r7, #0]
                        displayValues[12] = knobs[12]; //sus
 8019d88:	4e0a      	ldr	r6, [pc, #40]	; (8019db4 <SFXClassicSynthFrame+0x328>)
                        for (int i = 0; i < numVoices; i++)
 8019d8a:	2b00      	cmp	r3, #0
                        displayValues[12] = knobs[12]; //sus
 8019d8c:	ed86 0a0c 	vstr	s0, [r6, #48]	; 0x30
                        for (int i = 0; i < numVoices; i++)
 8019d90:	f77f aec2 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
 8019d94:	4d1a      	ldr	r5, [pc, #104]	; (8019e00 <SFXClassicSynthFrame+0x374>)
 8019d96:	2400      	movs	r4, #0
 8019d98:	e044      	b.n	8019e24 <SFXClassicSynthFrame+0x398>
 8019d9a:	bf00      	nop
 8019d9c:	2001872c 	.word	0x2001872c
 8019da0:	20000254 	.word	0x20000254
 8019da4:	200174c8 	.word	0x200174c8
 8019da8:	200002db 	.word	0x200002db
 8019dac:	2000066a 	.word	0x2000066a
 8019db0:	200032f8 	.word	0x200032f8
 8019db4:	200187dc 	.word	0x200187dc
 8019db8:	20017638 	.word	0x20017638
 8019dbc:	200177ac 	.word	0x200177ac
 8019dc0:	200171ea 	.word	0x200171ea
 8019dc4:	200033e4 	.word	0x200033e4
 8019dc8:	42800000 	.word	0x42800000
 8019dcc:	457ff000 	.word	0x457ff000
 8019dd0:	00000000 	.word	0x00000000
 8019dd4:	2001834c 	.word	0x2001834c
 8019dd8:	200005e8 	.word	0x200005e8
 8019ddc:	20000668 	.word	0x20000668
 8019de0:	2aaaaaab 	.word	0x2aaaaaab
 8019de4:	20000634 	.word	0x20000634
 8019de8:	200027f0 	.word	0x200027f0
 8019dec:	20017284 	.word	0x20017284
 8019df0:	20017648 	.word	0x20017648
 8019df4:	20003338 	.word	0x20003338
 8019df8:	20003334 	.word	0x20003334
 8019dfc:	20003330 	.word	0x20003330
 8019e00:	20001ef0 	.word	0x20001ef0
 8019e04:	3851b717 	.word	0x3851b717
 8019e08:	3f7ffcb9 	.word	0x3f7ffcb9
 8019e0c:	2000332c 	.word	0x2000332c
 8019e10:	2000023c 	.word	0x2000023c
 8019e14:	20016fec 	.word	0x20016fec
 8019e18:	46000000 	.word	0x46000000
 8019e1c:	20003328 	.word	0x20003328
 8019e20:	ed96 0a0c 	vldr	s0, [r6, #48]	; 0x30
                            tADSR4_setSustain(&polyFiltEnvs[i], displayValues[12]);
 8019e24:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
 8019e26:	3401      	adds	r4, #1
                            tADSR4_setSustain(&polyFiltEnvs[i], displayValues[12]);
 8019e28:	f008 f830 	bl	8021e8c <tADSR4_setSustain>
                        for (int i = 0; i < numVoices; i++)
 8019e2c:	683b      	ldr	r3, [r7, #0]
 8019e2e:	3504      	adds	r5, #4
 8019e30:	42a3      	cmp	r3, r4
 8019e32:	dcf5      	bgt.n	8019e20 <SFXClassicSynthFrame+0x394>
 8019e34:	e670      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019e36:	4aa4      	ldr	r2, [pc, #656]	; (801a0c8 <SFXClassicSynthFrame+0x63c>)
 8019e38:	4ba4      	ldr	r3, [pc, #656]	; (801a0cc <SFXClassicSynthFrame+0x640>)
 8019e3a:	edd2 7a00 	vldr	s15, [r2]
 8019e3e:	ed93 7a00 	vldr	s14, [r3]
 8019e42:	4ba3      	ldr	r3, [pc, #652]	; (801a0d0 <SFXClassicSynthFrame+0x644>)
 8019e44:	ee67 7a87 	vmul.f32	s15, s15, s14
                        for (int i = 0; i < numVoices; i++)
 8019e48:	9f02      	ldr	r7, [sp, #8]
                        displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019e4a:	ed9f 7aa2 	vldr	s14, [pc, #648]	; 801a0d4 <SFXClassicSynthFrame+0x648>
                        for (int i = 0; i < numVoices; i++)
 8019e4e:	683a      	ldr	r2, [r7, #0]
                        displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019e50:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019e54:	4ea0      	ldr	r6, [pc, #640]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
                        for (int i = 0; i < numVoices; i++)
 8019e56:	2a00      	cmp	r2, #0
                        displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019e58:	ee17 1a90 	vmov	r1, s15
 8019e5c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8019e60:	ed93 0a00 	vldr	s0, [r3]
 8019e64:	ee20 0a07 	vmul.f32	s0, s0, s14
 8019e68:	ed86 0a0b 	vstr	s0, [r6, #44]	; 0x2c
                        for (int i = 0; i < numVoices; i++)
 8019e6c:	f77f ae54 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
 8019e70:	4d9a      	ldr	r5, [pc, #616]	; (801a0dc <SFXClassicSynthFrame+0x650>)
 8019e72:	2400      	movs	r4, #0
 8019e74:	e001      	b.n	8019e7a <SFXClassicSynthFrame+0x3ee>
 8019e76:	ed96 0a0b 	vldr	s0, [r6, #44]	; 0x2c
                            tADSR4_setDecay(&polyFiltEnvs[i], displayValues[11]);
 8019e7a:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
 8019e7c:	3401      	adds	r4, #1
                            tADSR4_setDecay(&polyFiltEnvs[i], displayValues[11]);
 8019e7e:	f007 fff7 	bl	8021e70 <tADSR4_setDecay>
                        for (int i = 0; i < numVoices; i++)
 8019e82:	683b      	ldr	r3, [r7, #0]
 8019e84:	3504      	adds	r5, #4
 8019e86:	42a3      	cmp	r3, r4
 8019e88:	dcf5      	bgt.n	8019e76 <SFXClassicSynthFrame+0x3ea>
 8019e8a:	e645      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019e8c:	4a94      	ldr	r2, [pc, #592]	; (801a0e0 <SFXClassicSynthFrame+0x654>)
 8019e8e:	4b8f      	ldr	r3, [pc, #572]	; (801a0cc <SFXClassicSynthFrame+0x640>)
 8019e90:	edd2 7a00 	vldr	s15, [r2]
 8019e94:	ed93 7a00 	vldr	s14, [r3]
 8019e98:	4b8d      	ldr	r3, [pc, #564]	; (801a0d0 <SFXClassicSynthFrame+0x644>)
 8019e9a:	ee67 7a87 	vmul.f32	s15, s15, s14
                        for (int i = 0; i < numVoices; i++)
 8019e9e:	9f02      	ldr	r7, [sp, #8]
                        displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019ea0:	ed9f 7a8c 	vldr	s14, [pc, #560]	; 801a0d4 <SFXClassicSynthFrame+0x648>
                        for (int i = 0; i < numVoices; i++)
 8019ea4:	683a      	ldr	r2, [r7, #0]
                        displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019ea6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019eaa:	4e8b      	ldr	r6, [pc, #556]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
                        for (int i = 0; i < numVoices; i++)
 8019eac:	2a00      	cmp	r2, #0
                        displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 8019eae:	ee17 1a90 	vmov	r1, s15
 8019eb2:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8019eb6:	ed93 0a00 	vldr	s0, [r3]
 8019eba:	ee20 0a07 	vmul.f32	s0, s0, s14
 8019ebe:	ed86 0a0a 	vstr	s0, [r6, #40]	; 0x28
                        for (int i = 0; i < numVoices; i++)
 8019ec2:	f77f ae29 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
 8019ec6:	4d85      	ldr	r5, [pc, #532]	; (801a0dc <SFXClassicSynthFrame+0x650>)
 8019ec8:	2400      	movs	r4, #0
 8019eca:	e001      	b.n	8019ed0 <SFXClassicSynthFrame+0x444>
 8019ecc:	ed96 0a0a 	vldr	s0, [r6, #40]	; 0x28
                            tADSR4_setAttack(&polyFiltEnvs[i], displayValues[10]);
 8019ed0:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
 8019ed2:	3401      	adds	r4, #1
                            tADSR4_setAttack(&polyFiltEnvs[i], displayValues[10]);
 8019ed4:	f007 ffbe 	bl	8021e54 <tADSR4_setAttack>
                        for (int i = 0; i < numVoices; i++)
 8019ed8:	683b      	ldr	r3, [r7, #0]
 8019eda:	3504      	adds	r5, #4
 8019edc:	42a3      	cmp	r3, r4
 8019ede:	dcf5      	bgt.n	8019ecc <SFXClassicSynthFrame+0x440>
 8019ee0:	e61a      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[9] = knobs[9]; //leak
 8019ee2:	4b80      	ldr	r3, [pc, #512]	; (801a0e4 <SFXClassicSynthFrame+0x658>)
                        for (int i = 0; i < numVoices; i++)
 8019ee4:	9f02      	ldr	r7, [sp, #8]
                        displayValues[9] = knobs[9]; //leak
 8019ee6:	edd3 7a00 	vldr	s15, [r3]
                        for (int i = 0; i < numVoices; i++)
 8019eea:	683b      	ldr	r3, [r7, #0]
                        displayValues[9] = knobs[9]; //leak
 8019eec:	4e7a      	ldr	r6, [pc, #488]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
                        for (int i = 0; i < numVoices; i++)
 8019eee:	2b00      	cmp	r3, #0
                        displayValues[9] = knobs[9]; //leak
 8019ef0:	edc6 7a09 	vstr	s15, [r6, #36]	; 0x24
                        for (int i = 0; i < numVoices; i++)
 8019ef4:	f77f ae10 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
                            tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 8019ef8:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 8019efc:	4d7a      	ldr	r5, [pc, #488]	; (801a0e8 <SFXClassicSynthFrame+0x65c>)
                        for (int i = 0; i < numVoices; i++)
 8019efe:	2400      	movs	r4, #0
                            tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 8019f00:	eddf 8a7a 	vldr	s17, [pc, #488]	; 801a0ec <SFXClassicSynthFrame+0x660>
 8019f04:	ed9f 8a7a 	vldr	s16, [pc, #488]	; 801a0f0 <SFXClassicSynthFrame+0x664>
 8019f08:	e001      	b.n	8019f0e <SFXClassicSynthFrame+0x482>
 8019f0a:	edd6 7a09 	vldr	s15, [r6, #36]	; 0x24
 8019f0e:	ee79 7a67 	vsub.f32	s15, s18, s15
 8019f12:	4628      	mov	r0, r5
 8019f14:	eeb0 0a48 	vmov.f32	s0, s16
                        for (int i = 0; i < numVoices; i++)
 8019f18:	3401      	adds	r4, #1
 8019f1a:	3504      	adds	r5, #4
                            tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 8019f1c:	eea7 0aa8 	vfma.f32	s0, s15, s17
 8019f20:	f007 ffd8 	bl	8021ed4 <tADSR4_setLeakFactor>
                        for (int i = 0; i < numVoices; i++)
 8019f24:	683b      	ldr	r3, [r7, #0]
 8019f26:	42a3      	cmp	r3, r4
 8019f28:	dcef      	bgt.n	8019f0a <SFXClassicSynthFrame+0x47e>
 8019f2a:	e5f5      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 8019f2c:	4a71      	ldr	r2, [pc, #452]	; (801a0f4 <SFXClassicSynthFrame+0x668>)
 8019f2e:	4b67      	ldr	r3, [pc, #412]	; (801a0cc <SFXClassicSynthFrame+0x640>)
 8019f30:	edd2 7a00 	vldr	s15, [r2]
 8019f34:	ed93 7a00 	vldr	s14, [r3]
 8019f38:	4b65      	ldr	r3, [pc, #404]	; (801a0d0 <SFXClassicSynthFrame+0x644>)
 8019f3a:	ee67 7a87 	vmul.f32	s15, s15, s14
                        for (int i = 0; i < numVoices; i++)
 8019f3e:	9f02      	ldr	r7, [sp, #8]
                        displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 8019f40:	ed9f 7a64 	vldr	s14, [pc, #400]	; 801a0d4 <SFXClassicSynthFrame+0x648>
                        for (int i = 0; i < numVoices; i++)
 8019f44:	683a      	ldr	r2, [r7, #0]
                        displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 8019f46:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019f4a:	4e63      	ldr	r6, [pc, #396]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
                        for (int i = 0; i < numVoices; i++)
 8019f4c:	2a00      	cmp	r2, #0
                        displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 8019f4e:	ee17 1a90 	vmov	r1, s15
 8019f52:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8019f56:	ed93 0a00 	vldr	s0, [r3]
 8019f5a:	ee20 0a07 	vmul.f32	s0, s0, s14
 8019f5e:	ed86 0a08 	vstr	s0, [r6, #32]
                        for (int i = 0; i < numVoices; i++)
 8019f62:	f77f add9 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
 8019f66:	4d60      	ldr	r5, [pc, #384]	; (801a0e8 <SFXClassicSynthFrame+0x65c>)
 8019f68:	2400      	movs	r4, #0
 8019f6a:	e001      	b.n	8019f70 <SFXClassicSynthFrame+0x4e4>
 8019f6c:	ed96 0a08 	vldr	s0, [r6, #32]
                            tADSR4_setRelease(&polyEnvs[i], displayValues[8]);
 8019f70:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
 8019f72:	3401      	adds	r4, #1
                            tADSR4_setRelease(&polyEnvs[i], displayValues[8]);
 8019f74:	f007 ffa0 	bl	8021eb8 <tADSR4_setRelease>
                        for (int i = 0; i < numVoices; i++)
 8019f78:	683b      	ldr	r3, [r7, #0]
 8019f7a:	3504      	adds	r5, #4
 8019f7c:	42a3      	cmp	r3, r4
 8019f7e:	dcf5      	bgt.n	8019f6c <SFXClassicSynthFrame+0x4e0>
 8019f80:	e5ca      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[7] = knobs[7]; //sus
 8019f82:	4b5d      	ldr	r3, [pc, #372]	; (801a0f8 <SFXClassicSynthFrame+0x66c>)
                        for (int i = 0; i < numVoices; i++)
 8019f84:	9f02      	ldr	r7, [sp, #8]
                        displayValues[7] = knobs[7]; //sus
 8019f86:	ed93 0a00 	vldr	s0, [r3]
                        for (int i = 0; i < numVoices; i++)
 8019f8a:	683b      	ldr	r3, [r7, #0]
                        displayValues[7] = knobs[7]; //sus
 8019f8c:	4e52      	ldr	r6, [pc, #328]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
                        for (int i = 0; i < numVoices; i++)
 8019f8e:	2b00      	cmp	r3, #0
                        displayValues[7] = knobs[7]; //sus
 8019f90:	ed86 0a07 	vstr	s0, [r6, #28]
                        for (int i = 0; i < numVoices; i++)
 8019f94:	f77f adc0 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
 8019f98:	4d53      	ldr	r5, [pc, #332]	; (801a0e8 <SFXClassicSynthFrame+0x65c>)
 8019f9a:	2400      	movs	r4, #0
 8019f9c:	e001      	b.n	8019fa2 <SFXClassicSynthFrame+0x516>
 8019f9e:	ed96 0a07 	vldr	s0, [r6, #28]
                            tADSR4_setSustain(&polyEnvs[i], displayValues[7]);
 8019fa2:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
 8019fa4:	3401      	adds	r4, #1
                            tADSR4_setSustain(&polyEnvs[i], displayValues[7]);
 8019fa6:	f007 ff71 	bl	8021e8c <tADSR4_setSustain>
                        for (int i = 0; i < numVoices; i++)
 8019faa:	683b      	ldr	r3, [r7, #0]
 8019fac:	3504      	adds	r5, #4
 8019fae:	42a3      	cmp	r3, r4
 8019fb0:	dcf5      	bgt.n	8019f9e <SFXClassicSynthFrame+0x512>
 8019fb2:	e5b1      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019fb4:	4a51      	ldr	r2, [pc, #324]	; (801a0fc <SFXClassicSynthFrame+0x670>)
 8019fb6:	4b45      	ldr	r3, [pc, #276]	; (801a0cc <SFXClassicSynthFrame+0x640>)
 8019fb8:	edd2 7a00 	vldr	s15, [r2]
 8019fbc:	ed93 7a00 	vldr	s14, [r3]
 8019fc0:	4b43      	ldr	r3, [pc, #268]	; (801a0d0 <SFXClassicSynthFrame+0x644>)
 8019fc2:	ee67 7a87 	vmul.f32	s15, s15, s14
                        for (int i = 0; i < numVoices; i++)
 8019fc6:	9f02      	ldr	r7, [sp, #8]
                        displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019fc8:	ed9f 7a42 	vldr	s14, [pc, #264]	; 801a0d4 <SFXClassicSynthFrame+0x648>
                        for (int i = 0; i < numVoices; i++)
 8019fcc:	683a      	ldr	r2, [r7, #0]
                        displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019fce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019fd2:	4e41      	ldr	r6, [pc, #260]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
                        for (int i = 0; i < numVoices; i++)
 8019fd4:	2a00      	cmp	r2, #0
                        displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 8019fd6:	ee17 1a90 	vmov	r1, s15
 8019fda:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8019fde:	ed93 0a00 	vldr	s0, [r3]
 8019fe2:	ee20 0a07 	vmul.f32	s0, s0, s14
 8019fe6:	ed86 0a06 	vstr	s0, [r6, #24]
                        for (int i = 0; i < numVoices; i++)
 8019fea:	f77f ad95 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
 8019fee:	4d3e      	ldr	r5, [pc, #248]	; (801a0e8 <SFXClassicSynthFrame+0x65c>)
 8019ff0:	2400      	movs	r4, #0
 8019ff2:	e001      	b.n	8019ff8 <SFXClassicSynthFrame+0x56c>
 8019ff4:	ed96 0a06 	vldr	s0, [r6, #24]
                            tADSR4_setDecay(&polyEnvs[i], displayValues[6]);
 8019ff8:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
 8019ffa:	3401      	adds	r4, #1
                            tADSR4_setDecay(&polyEnvs[i], displayValues[6]);
 8019ffc:	f007 ff38 	bl	8021e70 <tADSR4_setDecay>
                        for (int i = 0; i < numVoices; i++)
 801a000:	683b      	ldr	r3, [r7, #0]
 801a002:	3504      	adds	r5, #4
 801a004:	42a3      	cmp	r3, r4
 801a006:	dcf5      	bgt.n	8019ff4 <SFXClassicSynthFrame+0x568>
 801a008:	e586      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801a00a:	4a3d      	ldr	r2, [pc, #244]	; (801a100 <SFXClassicSynthFrame+0x674>)
 801a00c:	4b2f      	ldr	r3, [pc, #188]	; (801a0cc <SFXClassicSynthFrame+0x640>)
 801a00e:	edd2 7a00 	vldr	s15, [r2]
 801a012:	ed93 7a00 	vldr	s14, [r3]
 801a016:	4b2e      	ldr	r3, [pc, #184]	; (801a0d0 <SFXClassicSynthFrame+0x644>)
 801a018:	ee67 7a87 	vmul.f32	s15, s15, s14
                        for (int i = 0; i < numVoices; i++)
 801a01c:	9f02      	ldr	r7, [sp, #8]
                        displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801a01e:	ed9f 7a2d 	vldr	s14, [pc, #180]	; 801a0d4 <SFXClassicSynthFrame+0x648>
                        for (int i = 0; i < numVoices; i++)
 801a022:	683a      	ldr	r2, [r7, #0]
                        displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801a024:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801a028:	4e2b      	ldr	r6, [pc, #172]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
                        for (int i = 0; i < numVoices; i++)
 801a02a:	2a00      	cmp	r2, #0
                        displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801a02c:	ee17 1a90 	vmov	r1, s15
 801a030:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 801a034:	ed93 0a00 	vldr	s0, [r3]
 801a038:	ee20 0a07 	vmul.f32	s0, s0, s14
 801a03c:	ed86 0a05 	vstr	s0, [r6, #20]
                        for (int i = 0; i < numVoices; i++)
 801a040:	f77f ad6a 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
 801a044:	4d28      	ldr	r5, [pc, #160]	; (801a0e8 <SFXClassicSynthFrame+0x65c>)
 801a046:	2400      	movs	r4, #0
 801a048:	e001      	b.n	801a04e <SFXClassicSynthFrame+0x5c2>
 801a04a:	ed96 0a05 	vldr	s0, [r6, #20]
                            tADSR4_setAttack(&polyEnvs[i], displayValues[5]);
 801a04e:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
 801a050:	3401      	adds	r4, #1
                            tADSR4_setAttack(&polyEnvs[i], displayValues[5]);
 801a052:	f007 feff 	bl	8021e54 <tADSR4_setAttack>
                        for (int i = 0; i < numVoices; i++)
 801a056:	683b      	ldr	r3, [r7, #0]
 801a058:	3504      	adds	r5, #4
 801a05a:	42a3      	cmp	r3, r4
 801a05c:	dcf5      	bgt.n	801a04a <SFXClassicSynthFrame+0x5be>
 801a05e:	e55b      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801a060:	4b28      	ldr	r3, [pc, #160]	; (801a104 <SFXClassicSynthFrame+0x678>)
 801a062:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 801a066:	ed9f 0a28 	vldr	s0, [pc, #160]	; 801a108 <SFXClassicSynthFrame+0x67c>
 801a06a:	ed93 7a00 	vldr	s14, [r3]
                        for (int i = 0; i < numVoices; i++)
 801a06e:	9f02      	ldr	r7, [sp, #8]
                        displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801a070:	eea7 0a27 	vfma.f32	s0, s14, s15
 801a074:	4e18      	ldr	r6, [pc, #96]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
                        for (int i = 0; i < numVoices; i++)
 801a076:	683b      	ldr	r3, [r7, #0]
 801a078:	2b00      	cmp	r3, #0
                        displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801a07a:	ed86 0a04 	vstr	s0, [r6, #16]
                        for (int i = 0; i < numVoices; i++)
 801a07e:	f77f ad4b 	ble.w	8019b18 <SFXClassicSynthFrame+0x8c>
 801a082:	4d22      	ldr	r5, [pc, #136]	; (801a10c <SFXClassicSynthFrame+0x680>)
 801a084:	2400      	movs	r4, #0
 801a086:	e001      	b.n	801a08c <SFXClassicSynthFrame+0x600>
 801a088:	ed96 0a04 	vldr	s0, [r6, #16]
                            tEfficientSVF_setQ(&synthLP[i],displayValues[4]);
 801a08c:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
 801a08e:	3401      	adds	r4, #1
                            tEfficientSVF_setQ(&synthLP[i],displayValues[4]);
 801a090:	f008 fd4c 	bl	8022b2c <tEfficientSVF_setQ>
                        for (int i = 0; i < numVoices; i++)
 801a094:	683b      	ldr	r3, [r7, #0]
 801a096:	3504      	adds	r5, #4
 801a098:	42a3      	cmp	r3, r4
 801a09a:	dcf5      	bgt.n	801a088 <SFXClassicSynthFrame+0x5fc>
 801a09c:	e53c      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[3] = knobs[3]; //detune
 801a09e:	4b1c      	ldr	r3, [pc, #112]	; (801a110 <SFXClassicSynthFrame+0x684>)
 801a0a0:	4e0d      	ldr	r6, [pc, #52]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
 801a0a2:	681b      	ldr	r3, [r3, #0]
 801a0a4:	60f3      	str	r3, [r6, #12]
                        break;
 801a0a6:	e537      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[2] = knobs[2]; //keyfollow filter cutoff
 801a0a8:	4b1a      	ldr	r3, [pc, #104]	; (801a114 <SFXClassicSynthFrame+0x688>)
 801a0aa:	4e0b      	ldr	r6, [pc, #44]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
 801a0ac:	681b      	ldr	r3, [r3, #0]
 801a0ae:	60b3      	str	r3, [r6, #8]
                        break;
 801a0b0:	e532      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
                        displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 801a0b2:	4b19      	ldr	r3, [pc, #100]	; (801a118 <SFXClassicSynthFrame+0x68c>)
 801a0b4:	ed9f 7a19 	vldr	s14, [pc, #100]	; 801a11c <SFXClassicSynthFrame+0x690>
 801a0b8:	edd3 7a00 	vldr	s15, [r3]
 801a0bc:	4e06      	ldr	r6, [pc, #24]	; (801a0d8 <SFXClassicSynthFrame+0x64c>)
 801a0be:	ee67 7a87 	vmul.f32	s15, s15, s14
 801a0c2:	edc6 7a01 	vstr	s15, [r6, #4]
                        break;
 801a0c6:	e527      	b.n	8019b18 <SFXClassicSynthFrame+0x8c>
 801a0c8:	20003324 	.word	0x20003324
 801a0cc:	2000023c 	.word	0x2000023c
 801a0d0:	20016fec 	.word	0x20016fec
 801a0d4:	46000000 	.word	0x46000000
 801a0d8:	200187dc 	.word	0x200187dc
 801a0dc:	20001ef0 	.word	0x20001ef0
 801a0e0:	20003320 	.word	0x20003320
 801a0e4:	2000331c 	.word	0x2000331c
 801a0e8:	20017648 	.word	0x20017648
 801a0ec:	3851b717 	.word	0x3851b717
 801a0f0:	3f7ffcb9 	.word	0x3f7ffcb9
 801a0f4:	20003318 	.word	0x20003318
 801a0f8:	20003314 	.word	0x20003314
 801a0fc:	20003310 	.word	0x20003310
 801a100:	2000330c 	.word	0x2000330c
 801a104:	20003308 	.word	0x20003308
 801a108:	3ecccccd 	.word	0x3ecccccd
 801a10c:	200033c0 	.word	0x200033c0
 801a110:	20003304 	.word	0x20003304
 801a114:	20003300 	.word	0x20003300
 801a118:	200032fc 	.word	0x200032fc
 801a11c:	45800000 	.word	0x45800000

0801a120 <SFXClassicSynthTick>:
        {
 801a120:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801a124:	2500      	movs	r5, #0
 801a126:	f8df a124 	ldr.w	sl, [pc, #292]	; 801a24c <SFXClassicSynthTick+0x12c>
 801a12a:	260c      	movs	r6, #12
 801a12c:	4c3e      	ldr	r4, [pc, #248]	; (801a228 <SFXClassicSynthTick+0x108>)
 801a12e:	46a9      	mov	r9, r5
        {
 801a130:	ed2d 8b08 	vpush	{d8-d11}
 801a134:	b083      	sub	sp, #12
            float sample = 0.0f;
 801a136:	eddf aa3d 	vldr	s21, [pc, #244]	; 801a22c <SFXClassicSynthTick+0x10c>
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
 801a13a:	ed9f ba3d 	vldr	s22, [pc, #244]	; 801a230 <SFXClassicSynthTick+0x110>
        {
 801a13e:	9001      	str	r0, [sp, #4]
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
 801a140:	eef0 ba6a 	vmov.f32	s23, s21
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801a144:	483b      	ldr	r0, [pc, #236]	; (801a234 <SFXClassicSynthTick+0x114>)
 801a146:	f00a fd3f 	bl	8024bc8 <tSimplePoly_getNumVoices>
 801a14a:	4548      	cmp	r0, r9
 801a14c:	dd58      	ble.n	801a200 <SFXClassicSynthTick+0xe0>
                float env = tADSR4_tick(&polyEnvs[i]);
 801a14e:	483a      	ldr	r0, [pc, #232]	; (801a238 <SFXClassicSynthTick+0x118>)
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
 801a150:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
 801a154:	eb05 0b45 	add.w	fp, r5, r5, lsl #1
                float tempSample = 0.0f;
 801a158:	eddf 8a34 	vldr	s17, [pc, #208]	; 801a22c <SFXClassicSynthTick+0x10c>
                float env = tADSR4_tick(&polyEnvs[i]);
 801a15c:	4428      	add	r0, r5
 801a15e:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 801a250 <SFXClassicSynthTick+0x130>
 801a162:	f007 fed5 	bl	8021f10 <tADSR4_tick>
 801a166:	eef0 9a40 	vmov.f32	s19, s0
 801a16a:	4f34      	ldr	r7, [pc, #208]	; (801a23c <SFXClassicSynthTick+0x11c>)
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
 801a16c:	eb08 000b 	add.w	r0, r8, fp
 801a170:	f00a fe4a 	bl	8024e08 <tSawtooth_tick>
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
 801a174:	eb07 000b 	add.w	r0, r7, fp
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
 801a178:	eeb0 9a40 	vmov.f32	s18, s0
 801a17c:	ed94 8a10 	vldr	s16, [r4, #64]	; 0x40
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
 801a180:	f006 fc60 	bl	8020a44 <tRosenbergGlottalPulse_tick>
 801a184:	edd4 7a10 	vldr	s15, [r4, #64]	; 0x40
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
 801a188:	ee3a 8a48 	vsub.f32	s16, s20, s16
 801a18c:	f10b 0b04 	add.w	fp, fp, #4
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
 801a190:	ee20 0a27 	vmul.f32	s0, s0, s15
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
 801a194:	45b3      	cmp	fp, r6
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
 801a196:	eea9 0a08 	vfma.f32	s0, s18, s16
 801a19a:	eee9 8a80 	vfma.f32	s17, s19, s0
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
 801a19e:	d1e5      	bne.n	801a16c <SFXClassicSynthTick+0x4c>
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
 801a1a0:	f83a 3f02 	ldrh.w	r3, [sl, #2]!
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801a1a4:	f109 0901 	add.w	r9, r9, #1
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
 801a1a8:	4825      	ldr	r0, [pc, #148]	; (801a240 <SFXClassicSynthTick+0x120>)
 801a1aa:	360c      	adds	r6, #12
 801a1ac:	ee08 3a10 	vmov	s16, r3
 801a1b0:	ed94 9a0f 	vldr	s18, [r4, #60]	; 0x3c
 801a1b4:	4428      	add	r0, r5
 801a1b6:	4f23      	ldr	r7, [pc, #140]	; (801a244 <SFXClassicSynthTick+0x124>)
 801a1b8:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 801a1bc:	f007 fea8 	bl	8021f10 <tADSR4_tick>
 801a1c0:	eeb0 1a4b 	vmov.f32	s2, s22
 801a1c4:	442f      	add	r7, r5
 801a1c6:	3504      	adds	r5, #4
 801a1c8:	eef0 0a48 	vmov.f32	s1, s16
 801a1cc:	eee9 0a00 	vfma.f32	s1, s18, s0
 801a1d0:	eeb0 0a6b 	vmov.f32	s0, s23
 801a1d4:	f009 fe6e 	bl	8023eb4 <LEAF_clip>
 801a1d8:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 801a1dc:	4638      	mov	r0, r7
 801a1de:	ee10 3a10 	vmov	r3, s0
 801a1e2:	b299      	uxth	r1, r3
 801a1e4:	f008 fc7e 	bl	8022ae4 <tEfficientSVF_setFreq>
                sample += tEfficientSVF_tick(&synthLP[i], tempSample);
 801a1e8:	4638      	mov	r0, r7
 801a1ea:	eeb0 0a68 	vmov.f32	s0, s17
 801a1ee:	f008 fc29 	bl	8022a44 <tEfficientSVF_tick>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801a1f2:	4810      	ldr	r0, [pc, #64]	; (801a234 <SFXClassicSynthTick+0x114>)
                sample += tEfficientSVF_tick(&synthLP[i], tempSample);
 801a1f4:	ee7a aa80 	vadd.f32	s21, s21, s0
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801a1f8:	f00a fce6 	bl	8024bc8 <tSimplePoly_getNumVoices>
 801a1fc:	4548      	cmp	r0, r9
 801a1fe:	dca6      	bgt.n	801a14e <SFXClassicSynthTick+0x2e>
            sample *= INV_NUM_OSC_PER_VOICE * displayValues[0];
 801a200:	ed94 0a00 	vldr	s0, [r4]
 801a204:	eddf 7a10 	vldr	s15, [pc, #64]	; 801a248 <SFXClassicSynthTick+0x128>
 801a208:	ee20 0a27 	vmul.f32	s0, s0, s15
            sample = tanhf(sample);
 801a20c:	ee20 0a2a 	vmul.f32	s0, s0, s21
 801a210:	f00d fb1c 	bl	802784c <tanhf>
            input[0] = sample;
 801a214:	9b01      	ldr	r3, [sp, #4]
 801a216:	ed83 0a00 	vstr	s0, [r3]
            input[1] = sample;
 801a21a:	ed83 0a01 	vstr	s0, [r3, #4]
        }
 801a21e:	b003      	add	sp, #12
 801a220:	ecbd 8b08 	vpop	{d8-d11}
 801a224:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801a228:	200187dc 	.word	0x200187dc
 801a22c:	00000000 	.word	0x00000000
 801a230:	457ff000 	.word	0x457ff000
 801a234:	200174c8 	.word	0x200174c8
 801a238:	20017648 	.word	0x20017648
 801a23c:	200027f0 	.word	0x200027f0
 801a240:	20001ef0 	.word	0x20001ef0
 801a244:	200033c0 	.word	0x200033c0
 801a248:	3ea8f5c3 	.word	0x3ea8f5c3
 801a24c:	200171ea 	.word	0x200171ea
 801a250:	20017284 	.word	0x20017284

0801a254 <SFXClassicSynthFree>:
        {
 801a254:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a258:	2500      	movs	r5, #0
 801a25a:	260c      	movs	r6, #12
 801a25c:	f8df 8064 	ldr.w	r8, [pc, #100]	; 801a2c4 <SFXClassicSynthFree+0x70>
 801a260:	4f15      	ldr	r7, [pc, #84]	; (801a2b8 <SFXClassicSynthFree+0x64>)
 801a262:	f8df b064 	ldr.w	fp, [pc, #100]	; 801a2c8 <SFXClassicSynthFree+0x74>
 801a266:	f8df a064 	ldr.w	sl, [pc, #100]	; 801a2cc <SFXClassicSynthFree+0x78>
 801a26a:	f8df 9064 	ldr.w	r9, [pc, #100]	; 801a2d0 <SFXClassicSynthFree+0x7c>
 801a26e:	eb05 0445 	add.w	r4, r5, r5, lsl #1
                    tSawtooth_free(&osc[(i * NUM_OSC_PER_VOICE) + j]);
 801a272:	eb08 0004 	add.w	r0, r8, r4
 801a276:	f00a fd91 	bl	8024d9c <tSawtooth_free>
                    tRosenbergGlottalPulse_free(&glottal[(i * NUM_OSC_PER_VOICE) + j]);
 801a27a:	1938      	adds	r0, r7, r4
 801a27c:	3404      	adds	r4, #4
 801a27e:	f006 fbdd 	bl	8020a3c <tRosenbergGlottalPulse_free>
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
 801a282:	42b4      	cmp	r4, r6
 801a284:	d1f5      	bne.n	801a272 <SFXClassicSynthFree+0x1e>
                tEfficientSVF_free(&synthLP[i]);
 801a286:	eb0b 0005 	add.w	r0, fp, r5
 801a28a:	f104 060c 	add.w	r6, r4, #12
 801a28e:	f008 fbd5 	bl	8022a3c <tEfficientSVF_free>
                tADSR4_free(&polyEnvs[i]);
 801a292:	eb0a 0005 	add.w	r0, sl, r5
 801a296:	f007 fdd9 	bl	8021e4c <tADSR4_free>
                tADSR4_free(&polyFiltEnvs[i]);
 801a29a:	eb09 0005 	add.w	r0, r9, r5
 801a29e:	3504      	adds	r5, #4
 801a2a0:	f007 fdd4 	bl	8021e4c <tADSR4_free>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801a2a4:	2d20      	cmp	r5, #32
 801a2a6:	d1e2      	bne.n	801a26e <SFXClassicSynthFree+0x1a>
            tCycle_free(&pwmLFO1);
 801a2a8:	4804      	ldr	r0, [pc, #16]	; (801a2bc <SFXClassicSynthFree+0x68>)
 801a2aa:	f00a fce3 	bl	8024c74 <tCycle_free>
            tCycle_free(&pwmLFO2);
 801a2ae:	4804      	ldr	r0, [pc, #16]	; (801a2c0 <SFXClassicSynthFree+0x6c>)
        }
 801a2b0:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            tCycle_free(&pwmLFO2);
 801a2b4:	f00a bcde 	b.w	8024c74 <tCycle_free>
 801a2b8:	200027f0 	.word	0x200027f0
 801a2bc:	20017638 	.word	0x20017638
 801a2c0:	200177ac 	.word	0x200177ac
 801a2c4:	20017284 	.word	0x20017284
 801a2c8:	200033c0 	.word	0x200033c0
 801a2cc:	20017648 	.word	0x20017648
 801a2d0:	20001ef0 	.word	0x20001ef0

0801a2d4 <SFXRhodesAlloc>:
        {
 801a2d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
            leaf.clearOnAllocation = 1;
 801a2d8:	2101      	movs	r1, #1
            soundNames[0] = "DARK  ";
 801a2da:	f8df 9140 	ldr.w	r9, [pc, #320]	; 801a41c <SFXRhodesAlloc+0x148>
 801a2de:	4a3e      	ldr	r2, [pc, #248]	; (801a3d8 <SFXRhodesAlloc+0x104>)
            soundNames[4] = "CUSTOM";
 801a2e0:	2400      	movs	r4, #0
            soundNames[1] = "LIGHT ";
 801a2e2:	4b3e      	ldr	r3, [pc, #248]	; (801a3dc <SFXRhodesAlloc+0x108>)
            leaf.clearOnAllocation = 1;
 801a2e4:	f8df a138 	ldr.w	sl, [pc, #312]	; 801a420 <SFXRhodesAlloc+0x14c>
            soundNames[0] = "DARK  ";
 801a2e8:	f8c9 2000 	str.w	r2, [r9]
            leaf.clearOnAllocation = 1;
 801a2ec:	f8ca 1014 	str.w	r1, [sl, #20]
            soundNames[3] = "PAD   ";
 801a2f0:	4a3b      	ldr	r2, [pc, #236]	; (801a3e0 <SFXRhodesAlloc+0x10c>)
            soundNames[2] = "BASS  ";
 801a2f2:	493c      	ldr	r1, [pc, #240]	; (801a3e4 <SFXRhodesAlloc+0x110>)
            soundNames[1] = "LIGHT ";
 801a2f4:	f8c9 3004 	str.w	r3, [r9, #4]
 801a2f8:	f8df 8128 	ldr.w	r8, [pc, #296]	; 801a424 <SFXRhodesAlloc+0x150>
            soundNames[4] = "CUSTOM";
 801a2fc:	4b3a      	ldr	r3, [pc, #232]	; (801a3e8 <SFXRhodesAlloc+0x114>)
 801a2fe:	4f3b      	ldr	r7, [pc, #236]	; (801a3ec <SFXRhodesAlloc+0x118>)
 801a300:	f8c9 3010 	str.w	r3, [r9, #16]
        {
 801a304:	ed2d 8b04 	vpush	{d8-d9}
                    tADSR4_init(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE);
 801a308:	ed9f 9a39 	vldr	s18, [pc, #228]	; 801a3f0 <SFXRhodesAlloc+0x11c>
 801a30c:	eddf 8a39 	vldr	s17, [pc, #228]	; 801a3f4 <SFXRhodesAlloc+0x120>
                    tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
 801a310:	ed9f 8a39 	vldr	s16, [pc, #228]	; 801a3f8 <SFXRhodesAlloc+0x124>
            soundNames[3] = "PAD   ";
 801a314:	e9c9 1202 	strd	r1, r2, [r9, #8]
 801a318:	f104 0618 	add.w	r6, r4, #24
 801a31c:	193d      	adds	r5, r7, r4
                    tCycle_init(&FM_sines[i][j]);
 801a31e:	eb08 0004 	add.w	r0, r8, r4
 801a322:	f00a fc89 	bl	8024c38 <tCycle_init>
 801a326:	3404      	adds	r4, #4
                    tADSR4_init(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE);
 801a328:	4628      	mov	r0, r5
 801a32a:	f44f 7200 	mov.w	r2, #512	; 0x200
 801a32e:	4933      	ldr	r1, [pc, #204]	; (801a3fc <SFXRhodesAlloc+0x128>)
 801a330:	eef0 1a49 	vmov.f32	s3, s18
 801a334:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
 801a338:	eef0 0a68 	vmov.f32	s1, s17
 801a33c:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 801a340:	f007 fd28 	bl	8021d94 <tADSR4_init>
                    tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
 801a344:	eeb0 0a48 	vmov.f32	s0, s16
 801a348:	4628      	mov	r0, r5
 801a34a:	f007 fdc3 	bl	8021ed4 <tADSR4_setLeakFactor>
                for (int j = 0; j < 6; j++)
 801a34e:	42b4      	cmp	r4, r6
 801a350:	d1e4      	bne.n	801a31c <SFXRhodesAlloc+0x48>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801a352:	2cc0      	cmp	r4, #192	; 0xc0
 801a354:	d1e0      	bne.n	801a318 <SFXRhodesAlloc+0x44>
 801a356:	4c2a      	ldr	r4, [pc, #168]	; (801a400 <SFXRhodesAlloc+0x12c>)
                tExpSmooth_init(&susSmoothers[i], 1.0f, 0.01f);
 801a358:	ed9f 8a2a 	vldr	s16, [pc, #168]	; 801a404 <SFXRhodesAlloc+0x130>
 801a35c:	f104 0518 	add.w	r5, r4, #24
 801a360:	4620      	mov	r0, r4
 801a362:	3404      	adds	r4, #4
 801a364:	eef0 0a48 	vmov.f32	s1, s16
 801a368:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801a36c:	f008 f8a2 	bl	80224b4 <tExpSmooth_init>
            for (int i = 0; i < 6; i++)
 801a370:	42a5      	cmp	r5, r4
 801a372:	d1f5      	bne.n	801a360 <SFXRhodesAlloc+0x8c>
            tCycle_init(&tremolo);
 801a374:	4824      	ldr	r0, [pc, #144]	; (801a408 <SFXRhodesAlloc+0x134>)
 801a376:	f00a fc5f 	bl	8024c38 <tCycle_init>
            tCycle_setFreq(&tremolo, 3.0f);
 801a37a:	eeb0 0a08 	vmov.f32	s0, #8	; 0x40400000  3.0
 801a37e:	4822      	ldr	r0, [pc, #136]	; (801a408 <SFXRhodesAlloc+0x134>)
 801a380:	f00a fc7c 	bl	8024c7c <tCycle_setFreq>
            tSimplePoly_setNumVoices(&poly, NUM_VOC_VOICES);
 801a384:	2108      	movs	r1, #8
 801a386:	4821      	ldr	r0, [pc, #132]	; (801a40c <SFXRhodesAlloc+0x138>)
 801a388:	f00a fc16 	bl	8024bb8 <tSimplePoly_setNumVoices>
            setLED_A(numVoices == 1);
 801a38c:	4b20      	ldr	r3, [pc, #128]	; (801a410 <SFXRhodesAlloc+0x13c>)
 801a38e:	6818      	ldr	r0, [r3, #0]
 801a390:	f1a0 0001 	sub.w	r0, r0, #1
 801a394:	fab0 f080 	clz	r0, r0
 801a398:	0940      	lsrs	r0, r0, #5
 801a39a:	f7f9 fad7 	bl	801394c <setLED_A>
            setLED_C(tremoloStereo == 1);
 801a39e:	4b1d      	ldr	r3, [pc, #116]	; (801a414 <SFXRhodesAlloc+0x140>)
 801a3a0:	6818      	ldr	r0, [r3, #0]
 801a3a2:	f1a0 0001 	sub.w	r0, r0, #1
 801a3a6:	fab0 f080 	clz	r0, r0
 801a3aa:	0940      	lsrs	r0, r0, #5
 801a3ac:	f7f9 faea 	bl	8013984 <setLED_C>
            OLEDclearLine(SecondLine);
 801a3b0:	2001      	movs	r0, #1
 801a3b2:	f7f9 fcf9 	bl	8013da8 <OLEDclearLine>
            OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
 801a3b6:	4918      	ldr	r1, [pc, #96]	; (801a418 <SFXRhodesAlloc+0x144>)
 801a3b8:	2301      	movs	r3, #1
 801a3ba:	2200      	movs	r2, #0
 801a3bc:	6808      	ldr	r0, [r1, #0]
 801a3be:	2106      	movs	r1, #6
 801a3c0:	f859 0020 	ldr.w	r0, [r9, r0, lsl #2]
 801a3c4:	f7f9 fd04 	bl	8013dd0 <OLEDwriteString>
            leaf.clearOnAllocation = 0;
 801a3c8:	2300      	movs	r3, #0
        }
 801a3ca:	ecbd 8b04 	vpop	{d8-d9}
            leaf.clearOnAllocation = 0;
 801a3ce:	f8ca 3014 	str.w	r3, [sl, #20]
        }
 801a3d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801a3d6:	bf00      	nop
 801a3d8:	0802a1b4 	.word	0x0802a1b4
 801a3dc:	0802a1bc 	.word	0x0802a1bc
 801a3e0:	0802a1cc 	.word	0x0802a1cc
 801a3e4:	0802a1c4 	.word	0x0802a1c4
 801a3e8:	0802a1d4 	.word	0x0802a1d4
 801a3ec:	200174d4 	.word	0x200174d4
 801a3f0:	42c80000 	.word	0x42c80000
 801a3f4:	447a0000 	.word	0x447a0000
 801a3f8:	3f7ffeb0 	.word	0x3f7ffeb0
 801a3fc:	20017988 	.word	0x20017988
 801a400:	200029d8 	.word	0x200029d8
 801a404:	3c23d70a 	.word	0x3c23d70a
 801a408:	200177a8 	.word	0x200177a8
 801a40c:	200174c8 	.word	0x200174c8
 801a410:	20000254 	.word	0x20000254
 801a414:	2000061c 	.word	0x2000061c
 801a418:	20000520 	.word	0x20000520
 801a41c:	20017490 	.word	0x20017490
 801a420:	200194e8 	.word	0x200194e8
 801a424:	20003414 	.word	0x20003414

0801a428 <SFXRhodesFrame>:
        {
 801a428:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801a42c:	4ce3      	ldr	r4, [pc, #908]	; (801a7bc <SFXRhodesFrame+0x394>)
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801a42e:	4be4      	ldr	r3, [pc, #912]	; (801a7c0 <SFXRhodesFrame+0x398>)
        {
 801a430:	ed2d 8b04 	vpush	{d8-d9}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801a434:	7d21      	ldrb	r1, [r4, #20]
        {
 801a436:	b083      	sub	sp, #12
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801a438:	2901      	cmp	r1, #1
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801a43a:	9301      	str	r3, [sp, #4]
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801a43c:	d113      	bne.n	801a466 <SFXRhodesFrame+0x3e>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801a43e:	681b      	ldr	r3, [r3, #0]
 801a440:	9d01      	ldr	r5, [sp, #4]
 801a442:	2b01      	cmp	r3, #1
                tSimplePoly_setNumVoices(&poly, numVoices);
 801a444:	48df      	ldr	r0, [pc, #892]	; (801a7c4 <SFXRhodesFrame+0x39c>)
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801a446:	462a      	mov	r2, r5
 801a448:	bfd8      	it	le
 801a44a:	2108      	movle	r1, #8
 801a44c:	6011      	str	r1, [r2, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
 801a44e:	f00a fbb3 	bl	8024bb8 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
 801a452:	6828      	ldr	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801a454:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
 801a456:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801a45a:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
 801a45c:	fab0 f080 	clz	r0, r0
 801a460:	0940      	lsrs	r0, r0, #5
 801a462:	f7f9 fa73 	bl	801394c <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 801a466:	7e23      	ldrb	r3, [r4, #24]
 801a468:	2b01      	cmp	r3, #1
 801a46a:	d10e      	bne.n	801a48a <SFXRhodesFrame+0x62>
                Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
 801a46c:	48d6      	ldr	r0, [pc, #856]	; (801a7c8 <SFXRhodesFrame+0x3a0>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801a46e:	2100      	movs	r1, #0
                Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
 801a470:	4ad6      	ldr	r2, [pc, #856]	; (801a7cc <SFXRhodesFrame+0x3a4>)
 801a472:	6803      	ldr	r3, [r0, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801a474:	7621      	strb	r1, [r4, #24]
                Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
 801a476:	3301      	adds	r3, #1
 801a478:	fb82 2103 	smull	r2, r1, r2, r3
 801a47c:	17da      	asrs	r2, r3, #31
 801a47e:	ebc2 0261 	rsb	r2, r2, r1, asr #1
 801a482:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 801a486:	1a9b      	subs	r3, r3, r2
 801a488:	6003      	str	r3, [r0, #0]
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 801a48a:	7f23      	ldrb	r3, [r4, #28]
 801a48c:	2b01      	cmp	r3, #1
 801a48e:	f000 8431 	beq.w	801acf4 <SFXRhodesFrame+0x8cc>
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801a492:	4dcf      	ldr	r5, [pc, #828]	; (801a7d0 <SFXRhodesFrame+0x3a8>)
 801a494:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a498:	4bce      	ldr	r3, [pc, #824]	; (801a7d4 <SFXRhodesFrame+0x3ac>)
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
 801a49a:	eeb2 2a04 	vmov.f32	s4, #36	; 0x41200000  10.0
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801a49e:	ed95 6a08 	vldr	s12, [r5, #32]
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801a4a2:	4628      	mov	r0, r5
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a4a4:	edd3 6a00 	vldr	s13, [r3]
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801a4a8:	eefa 0a04 	vmov.f32	s1, #164	; 0xc1200000 -10.0
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a4ac:	ed95 7a05 	vldr	s14, [r5, #20]
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801a4b0:	edd5 7a06 	vldr	s15, [r5, #24]
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a4b4:	ee26 7a87 	vmul.f32	s14, s13, s14
 801a4b8:	49c7      	ldr	r1, [pc, #796]	; (801a7d8 <SFXRhodesFrame+0x3b0>)
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801a4ba:	ee66 7aa7 	vmul.f32	s15, s13, s15
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801a4be:	ecf0 3a01 	vldmia	r0!, {s7}
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801a4c2:	ee66 6a86 	vmul.f32	s13, s13, s12
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
 801a4c6:	edd5 4a03 	vldr	s9, [r5, #12]
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a4ca:	eebd 7ac7 	vcvt.s32.f32	s14, s14
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801a4ce:	ed9f 1ac3 	vldr	s2, [pc, #780]	; 801a7dc <SFXRhodesFrame+0x3b4>
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801a4d2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a4d6:	eddf 2ac2 	vldr	s5, [pc, #776]	; 801a7e0 <SFXRhodesFrame+0x3b8>
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801a4da:	eefd 6ae6 	vcvt.s32.f32	s13, s13
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801a4de:	ed95 6a0a 	vldr	s12, [r5, #40]	; 0x28
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a4e2:	ee17 2a10 	vmov	r2, s14
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801a4e6:	ee63 3aa5 	vmul.f32	s7, s7, s11
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801a4ea:	ee17 3a90 	vmov	r3, s15
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
 801a4ee:	eddf 7abd 	vldr	s15, [pc, #756]	; 801a7e4 <SFXRhodesFrame+0x3bc>
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801a4f2:	ee16 4a90 	vmov	r4, s13
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a4f6:	eb01 0282 	add.w	r2, r1, r2, lsl #2
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801a4fa:	eb01 0383 	add.w	r3, r1, r3, lsl #2
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
 801a4fe:	ee64 4aa7 	vmul.f32	s9, s9, s15
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801a502:	eb01 0184 	add.w	r1, r1, r4, lsl #2
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a506:	ed92 3a00 	vldr	s6, [r2]
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801a50a:	ed93 5a00 	vldr	s10, [r3]
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801a50e:	ee66 6a01 	vmul.f32	s13, s12, s2
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801a512:	edd1 5a00 	vldr	s11, [r1]
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a516:	ee23 3a22 	vmul.f32	s6, s6, s5
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
 801a51a:	ed95 4a02 	vldr	s8, [r5, #8]
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801a51e:	ee25 5a22 	vmul.f32	s10, s10, s5
            FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
 801a522:	ed95 7a0b 	vldr	s14, [r5, #44]	; 0x2c
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801a526:	ee65 5aa2 	vmul.f32	s11, s11, s5
            FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
 801a52a:	edd5 7a0c 	vldr	s15, [r5, #48]	; 0x30
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
 801a52e:	ee24 4a02 	vmul.f32	s8, s8, s4
            FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
 801a532:	ee27 7a01 	vmul.f32	s14, s14, s2
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801a536:	4cac      	ldr	r4, [pc, #688]	; (801a7e8 <SFXRhodesFrame+0x3c0>)
            FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
 801a538:	ee67 7a81 	vmul.f32	s15, s15, s2
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801a53c:	4eab      	ldr	r6, [pc, #684]	; (801a7ec <SFXRhodesFrame+0x3c4>)
            displayValues[9] = presetKnobValues[Rhodes][9];
 801a53e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
            displayValues[1] = presetKnobValues[Rhodes][1]; // tremelo amount
 801a540:	6800      	ldr	r0, [r0, #0]
            displayValues[4] = presetKnobValues[Rhodes][4]; //pan spread
 801a542:	6929      	ldr	r1, [r5, #16]
            displayValues[7] = presetKnobValues[Rhodes][7];
 801a544:	69ea      	ldr	r2, [r5, #28]
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
 801a546:	ed84 4a02 	vstr	s8, [r4, #8]
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801a54a:	edc4 5a08 	vstr	s11, [r4, #32]
            displayValues[9] = presetKnobValues[Rhodes][9];
 801a54e:	6263      	str	r3, [r4, #36]	; 0x24
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801a550:	ed84 3a05 	vstr	s6, [r4, #20]
            displayValues[1] = presetKnobValues[Rhodes][1]; // tremelo amount
 801a554:	6060      	str	r0, [r4, #4]
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801a556:	edc4 3a00 	vstr	s7, [r4]
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
 801a55a:	edc4 4a03 	vstr	s9, [r4, #12]
            displayValues[4] = presetKnobValues[Rhodes][4]; //pan spread
 801a55e:	6121      	str	r1, [r4, #16]
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801a560:	ed84 5a06 	vstr	s10, [r4, #24]
            displayValues[7] = presetKnobValues[Rhodes][7];
 801a564:	61e2      	str	r2, [r4, #28]
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801a566:	edc4 6a0a 	vstr	s13, [r4, #40]	; 0x28
 801a56a:	edc6 6a18 	vstr	s13, [r6, #96]	; 0x60
            FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
 801a56e:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c
 801a572:	ed86 7a19 	vstr	s14, [r6, #100]	; 0x64
            FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
 801a576:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
 801a57a:	edc6 7a1a 	vstr	s15, [r6, #104]	; 0x68
            FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
 801a57e:	ed95 7a0d 	vldr	s14, [r5, #52]	; 0x34
            FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
 801a582:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
            FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
 801a586:	ee27 7a01 	vmul.f32	s14, s14, s2
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801a58a:	edd5 6a15 	vldr	s13, [r5, #84]	; 0x54
            FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
 801a58e:	ee67 7a81 	vmul.f32	s15, s15, s2
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a592:	f8df 827c 	ldr.w	r8, [pc, #636]	; 801a810 <SFXRhodesFrame+0x3e8>
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801a596:	eee6 0a81 	vfma.f32	s1, s13, s2
 801a59a:	ed9f 0a95 	vldr	s0, [pc, #596]	; 801a7f0 <SFXRhodesFrame+0x3c8>
            FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
 801a59e:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
 801a5a2:	ed86 7a1b 	vstr	s14, [r6, #108]	; 0x6c
            FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
 801a5a6:	edc4 7a0e 	vstr	s15, [r4, #56]	; 0x38
 801a5aa:	edc6 7a1c 	vstr	s15, [r6, #112]	; 0x70
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801a5ae:	f009 fc81 	bl	8023eb4 <LEAF_clip>
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a5b2:	ed95 4a0f 	vldr	s8, [r5, #60]	; 0x3c
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a5b6:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a5ba:	edd8 6a0f 	vldr	s13, [r8, #60]	; 0x3c
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a5be:	4b8d      	ldr	r3, [pc, #564]	; (801a7f4 <SFXRhodesFrame+0x3cc>)
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a5c0:	eef4 6a44 	vcmp.f32	s13, s8
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801a5c4:	ed84 0a15 	vstr	s0, [r4, #84]	; 0x54
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a5c8:	ed93 7a00 	vldr	s14, [r3]
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801a5cc:	ed86 0a1d 	vstr	s0, [r6, #116]	; 0x74
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a5d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a5d4:	ee75 7ac7 	vsub.f32	s15, s11, s14
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a5d8:	d01a      	beq.n	801a610 <SFXRhodesFrame+0x1e8>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a5da:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801a5de:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
 801a5e2:	ee74 6a66 	vsub.f32	s13, s8, s13
 801a5e6:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a5ea:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
 801a5ee:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a5f2:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a5f6:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
 801a5fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a5fe:	f100 83a6 	bmi.w	801ad4e <SFXRhodesFrame+0x926>
                    else rate += 1.0f;
 801a602:	ee36 6a25 	vadd.f32	s12, s12, s11
                    FM_freqRatios[4][k-15] = rate;
 801a606:	4a7c      	ldr	r2, [pc, #496]	; (801a7f8 <SFXRhodesFrame+0x3d0>)
                    displayValues[k] = rate;
 801a608:	ed84 6a0f 	vstr	s12, [r4, #60]	; 0x3c
                    FM_freqRatios[4][k-15] = rate;
 801a60c:	ed82 6a18 	vstr	s12, [r2, #96]	; 0x60
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a610:	4a7a      	ldr	r2, [pc, #488]	; (801a7fc <SFXRhodesFrame+0x3d4>)
 801a612:	edd8 6a10 	vldr	s13, [r8, #64]	; 0x40
 801a616:	edd2 4a00 	vldr	s9, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801a61a:	ed88 4a0f 	vstr	s8, [r8, #60]	; 0x3c
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a61e:	eef4 6a64 	vcmp.f32	s13, s9
 801a622:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a626:	d01e      	beq.n	801a666 <SFXRhodesFrame+0x23e>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a628:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801a62c:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
 801a630:	ee74 6ae6 	vsub.f32	s13, s9, s13
 801a634:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a638:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
 801a63c:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a640:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a644:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a648:	eef0 6a46 	vmov.f32	s13, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a64c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a650:	f100 8384 	bmi.w	801ad5c <SFXRhodesFrame+0x934>
                    else rate += 1.0f;
 801a654:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 801a658:	ee36 6a86 	vadd.f32	s12, s13, s12
                    FM_freqRatios[4][k-15] = rate;
 801a65c:	4a66      	ldr	r2, [pc, #408]	; (801a7f8 <SFXRhodesFrame+0x3d0>)
                    displayValues[k] = rate;
 801a65e:	ed84 6a10 	vstr	s12, [r4, #64]	; 0x40
                    FM_freqRatios[4][k-15] = rate;
 801a662:	ed82 6a19 	vstr	s12, [r2, #100]	; 0x64
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a666:	4a66      	ldr	r2, [pc, #408]	; (801a800 <SFXRhodesFrame+0x3d8>)
 801a668:	edd8 6a11 	vldr	s13, [r8, #68]	; 0x44
 801a66c:	ed92 5a00 	vldr	s10, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801a670:	edc8 4a10 	vstr	s9, [r8, #64]	; 0x40
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a674:	eef4 6a45 	vcmp.f32	s13, s10
 801a678:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a67c:	d01e      	beq.n	801a6bc <SFXRhodesFrame+0x294>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a67e:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801a682:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
 801a686:	ee75 6a66 	vsub.f32	s13, s10, s13
 801a68a:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a68e:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
 801a692:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a696:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a69a:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a69e:	eef0 6a46 	vmov.f32	s13, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a6a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a6a6:	f100 8362 	bmi.w	801ad6e <SFXRhodesFrame+0x946>
                    else rate += 1.0f;
 801a6aa:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 801a6ae:	ee36 6a86 	vadd.f32	s12, s13, s12
                    FM_freqRatios[4][k-15] = rate;
 801a6b2:	4a51      	ldr	r2, [pc, #324]	; (801a7f8 <SFXRhodesFrame+0x3d0>)
                    displayValues[k] = rate;
 801a6b4:	ed84 6a11 	vstr	s12, [r4, #68]	; 0x44
                    FM_freqRatios[4][k-15] = rate;
 801a6b8:	ed82 6a1a 	vstr	s12, [r2, #104]	; 0x68
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a6bc:	4a51      	ldr	r2, [pc, #324]	; (801a804 <SFXRhodesFrame+0x3dc>)
 801a6be:	edd8 6a12 	vldr	s13, [r8, #72]	; 0x48
 801a6c2:	edd2 5a00 	vldr	s11, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801a6c6:	ed88 5a11 	vstr	s10, [r8, #68]	; 0x44
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a6ca:	eef4 6a65 	vcmp.f32	s13, s11
 801a6ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a6d2:	d01e      	beq.n	801a712 <SFXRhodesFrame+0x2ea>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a6d4:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801a6d8:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
 801a6dc:	ee75 6ae6 	vsub.f32	s13, s11, s13
 801a6e0:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a6e4:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
 801a6e8:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a6ec:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a6f0:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a6f4:	eef0 6a46 	vmov.f32	s13, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a6f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a6fc:	f100 8307 	bmi.w	801ad0e <SFXRhodesFrame+0x8e6>
                    else rate += 1.0f;
 801a700:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 801a704:	ee36 6a86 	vadd.f32	s12, s13, s12
                    FM_freqRatios[4][k-15] = rate;
 801a708:	4a3b      	ldr	r2, [pc, #236]	; (801a7f8 <SFXRhodesFrame+0x3d0>)
                    displayValues[k] = rate;
 801a70a:	ed84 6a12 	vstr	s12, [r4, #72]	; 0x48
                    FM_freqRatios[4][k-15] = rate;
 801a70e:	ed82 6a1b 	vstr	s12, [r2, #108]	; 0x6c
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a712:	4a3d      	ldr	r2, [pc, #244]	; (801a808 <SFXRhodesFrame+0x3e0>)
 801a714:	edd8 6a13 	vldr	s13, [r8, #76]	; 0x4c
 801a718:	ed92 6a00 	vldr	s12, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801a71c:	edc8 5a12 	vstr	s11, [r8, #72]	; 0x48
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a720:	eef4 6a46 	vcmp.f32	s13, s12
 801a724:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a728:	d01e      	beq.n	801a768 <SFXRhodesFrame+0x340>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a72a:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801a72e:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
 801a732:	ee76 6a66 	vsub.f32	s13, s12, s13
 801a736:	ee66 6aa3 	vmul.f32	s13, s13, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a73a:	ee67 3aa6 	vmul.f32	s7, s15, s13
                    float snapRate = roundf(rawRate);
 801a73e:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a742:	eee7 3a26 	vfma.f32	s7, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a746:	eef5 3ac0 	vcmpe.f32	s7, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a74a:	eef0 6a63 	vmov.f32	s13, s7
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a74e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a752:	f100 82e5 	bmi.w	801ad20 <SFXRhodesFrame+0x8f8>
                    else rate += 1.0f;
 801a756:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
 801a75a:	ee76 3aa3 	vadd.f32	s7, s13, s7
                    FM_freqRatios[4][k-15] = rate;
 801a75e:	4a26      	ldr	r2, [pc, #152]	; (801a7f8 <SFXRhodesFrame+0x3d0>)
                    displayValues[k] = rate;
 801a760:	edc4 3a13 	vstr	s7, [r4, #76]	; 0x4c
                    FM_freqRatios[4][k-15] = rate;
 801a764:	edc2 3a1c 	vstr	s7, [r2, #112]	; 0x70
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a768:	4a28      	ldr	r2, [pc, #160]	; (801a80c <SFXRhodesFrame+0x3e4>)
 801a76a:	edd8 3a14 	vldr	s7, [r8, #80]	; 0x50
 801a76e:	edd2 6a00 	vldr	s13, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801a772:	ed88 6a13 	vstr	s12, [r8, #76]	; 0x4c
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801a776:	eef4 6a63 	vcmp.f32	s13, s7
 801a77a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a77e:	d049      	beq.n	801a814 <SFXRhodesFrame+0x3ec>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a780:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
 801a784:	eeb2 3a0c 	vmov.f32	s6, #44	; 0x41600000  14.0
 801a788:	ee76 3ae3 	vsub.f32	s7, s13, s7
 801a78c:	ee63 3a83 	vmul.f32	s7, s7, s6
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a790:	ee67 7aa3 	vmul.f32	s15, s15, s7
                    float snapRate = roundf(rawRate);
 801a794:	fef8 3a63 	vrinta.f32	s7, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a798:	eee7 7a23 	vfma.f32	s15, s14, s7
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a79c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801a7a0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801a7a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a7a8:	f100 82c3 	bmi.w	801ad32 <SFXRhodesFrame+0x90a>
                    else rate += 1.0f;
 801a7ac:	ee77 7a87 	vadd.f32	s15, s15, s14
                    FM_freqRatios[4][k-15] = rate;
 801a7b0:	4a11      	ldr	r2, [pc, #68]	; (801a7f8 <SFXRhodesFrame+0x3d0>)
                    displayValues[k] = rate;
 801a7b2:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
                    FM_freqRatios[4][k-15] = rate;
 801a7b6:	edc2 7a1d 	vstr	s15, [r2, #116]	; 0x74
 801a7ba:	e02b      	b.n	801a814 <SFXRhodesFrame+0x3ec>
 801a7bc:	2001872c 	.word	0x2001872c
 801a7c0:	20000254 	.word	0x20000254
 801a7c4:	200174c8 	.word	0x200174c8
 801a7c8:	20000520 	.word	0x20000520
 801a7cc:	66666667 	.word	0x66666667
 801a7d0:	2000335c 	.word	0x2000335c
 801a7d4:	2000023c 	.word	0x2000023c
 801a7d8:	20016fec 	.word	0x20016fec
 801a7dc:	447a0000 	.word	0x447a0000
 801a7e0:	46000000 	.word	0x46000000
 801a7e4:	3fa66666 	.word	0x3fa66666
 801a7e8:	200187dc 	.word	0x200187dc
 801a7ec:	200000b8 	.word	0x200000b8
 801a7f0:	00000000 	.word	0x00000000
 801a7f4:	20000260 	.word	0x20000260
 801a7f8:	20000040 	.word	0x20000040
 801a7fc:	2000339c 	.word	0x2000339c
 801a800:	200033a0 	.word	0x200033a0
 801a804:	200033a4 	.word	0x200033a4
 801a808:	200033a8 	.word	0x200033a8
 801a80c:	200033ac 	.word	0x200033ac
 801a810:	20017680 	.word	0x20017680
            if (presetKnobValues[Rhodes][22] != prevKnobValues[22])
 801a814:	4abd      	ldr	r2, [pc, #756]	; (801ab0c <SFXRhodesFrame+0x6e4>)
 801a816:	edd8 7a16 	vldr	s15, [r8, #88]	; 0x58
 801a81a:	ed92 7a00 	vldr	s14, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801a81e:	edc8 6a14 	vstr	s13, [r8, #80]	; 0x50
            if (presetKnobValues[Rhodes][22] != prevKnobValues[22])
 801a822:	eeb4 7a67 	vcmp.f32	s14, s15
 801a826:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a82a:	f000 80b7 	beq.w	801a99c <SFXRhodesFrame+0x574>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a82e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
                overtoneSnap = displayValues[22] = presetKnobValues[Rhodes][22];
 801a832:	ed84 7a16 	vstr	s14, [r4, #88]	; 0x58
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a836:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
                overtoneSnap = displayValues[22] = presetKnobValues[Rhodes][22];
 801a83a:	ed83 7a00 	vstr	s14, [r3]
 801a83e:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a842:	ee34 4a67 	vsub.f32	s8, s8, s15
 801a846:	ee73 7a47 	vsub.f32	s15, s6, s14
 801a84a:	ee24 4a23 	vmul.f32	s8, s8, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a84e:	ee64 3a27 	vmul.f32	s7, s8, s15
                    float snapRate = roundf(rawRate);
 801a852:	feb8 4a44 	vrinta.f32	s8, s8
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a856:	eee7 3a04 	vfma.f32	s7, s14, s8
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a85a:	eef5 3ac0 	vcmpe.f32	s7, #0.0
 801a85e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a862:	f100 826d 	bmi.w	801ad40 <SFXRhodesFrame+0x918>
                    else rate += 1.0f;
 801a866:	ee33 4a83 	vadd.f32	s8, s7, s6
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a86a:	eeb6 3a00 	vmov.f32	s6, #96	; 0x3f000000  0.5
                    FM_freqRatios[4][k-15] = rate;
 801a86e:	4ba8      	ldr	r3, [pc, #672]	; (801ab10 <SFXRhodesFrame+0x6e8>)
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a870:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
                    displayValues[k] = rate;
 801a874:	ed84 4a0f 	vstr	s8, [r4, #60]	; 0x3c
                    FM_freqRatios[4][k-15] = rate;
 801a878:	ed83 4a18 	vstr	s8, [r3, #96]	; 0x60
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a87c:	ee74 4ac3 	vsub.f32	s9, s9, s6
 801a880:	ee64 4aa3 	vmul.f32	s9, s9, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a884:	ee24 4aa7 	vmul.f32	s8, s9, s15
                    float snapRate = roundf(rawRate);
 801a888:	fef8 4a64 	vrinta.f32	s9, s9
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a88c:	eea7 4a24 	vfma.f32	s8, s14, s9
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a890:	eeb5 4ac0 	vcmpe.f32	s8, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a894:	eef0 4a44 	vmov.f32	s9, s8
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a898:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
 801a89c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a8a0:	f100 828a 	bmi.w	801adb8 <SFXRhodesFrame+0x990>
                    else rate += 1.0f;
 801a8a4:	ee74 4a84 	vadd.f32	s9, s9, s8
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a8a8:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
 801a8ac:	edc4 4a10 	vstr	s9, [r4, #64]	; 0x40
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a8b0:	eeb2 4a0c 	vmov.f32	s8, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
 801a8b4:	edc3 4a19 	vstr	s9, [r3, #100]	; 0x64
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a8b8:	ee35 5a63 	vsub.f32	s10, s10, s7
 801a8bc:	ee25 5a04 	vmul.f32	s10, s10, s8
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a8c0:	ee65 4a27 	vmul.f32	s9, s10, s15
                    float snapRate = roundf(rawRate);
 801a8c4:	feb8 5a45 	vrinta.f32	s10, s10
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a8c8:	eee7 4a05 	vfma.f32	s9, s14, s10
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a8cc:	eef5 4ac0 	vcmpe.f32	s9, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a8d0:	eeb0 5a64 	vmov.f32	s10, s9
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a8d4:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
 801a8d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a8dc:	f100 8265 	bmi.w	801adaa <SFXRhodesFrame+0x982>
                    else rate += 1.0f;
 801a8e0:	ee35 5a24 	vadd.f32	s10, s10, s9
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a8e4:	eeb6 4a00 	vmov.f32	s8, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
 801a8e8:	ed84 5a11 	vstr	s10, [r4, #68]	; 0x44
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a8ec:	eef2 4a0c 	vmov.f32	s9, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
 801a8f0:	ed83 5a1a 	vstr	s10, [r3, #104]	; 0x68
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a8f4:	ee75 5ac4 	vsub.f32	s11, s11, s8
 801a8f8:	ee65 5aa4 	vmul.f32	s11, s11, s9
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a8fc:	ee25 5aa7 	vmul.f32	s10, s11, s15
                    float snapRate = roundf(rawRate);
 801a900:	fef8 5a65 	vrinta.f32	s11, s11
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a904:	eea7 5a25 	vfma.f32	s10, s14, s11
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a908:	eeb5 5ac0 	vcmpe.f32	s10, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a90c:	eef0 5a45 	vmov.f32	s11, s10
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a910:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 801a914:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a918:	f100 8240 	bmi.w	801ad9c <SFXRhodesFrame+0x974>
                    else rate += 1.0f;
 801a91c:	ee75 5a85 	vadd.f32	s11, s11, s10
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a920:	eef6 4a00 	vmov.f32	s9, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
 801a924:	edc4 5a12 	vstr	s11, [r4, #72]	; 0x48
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a928:	eeb2 5a0c 	vmov.f32	s10, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
 801a92c:	edc3 5a1b 	vstr	s11, [r3, #108]	; 0x6c
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a930:	ee36 6a64 	vsub.f32	s12, s12, s9
 801a934:	ee26 6a05 	vmul.f32	s12, s12, s10
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a938:	ee66 5a27 	vmul.f32	s11, s12, s15
                    float snapRate = roundf(rawRate);
 801a93c:	feb8 6a46 	vrinta.f32	s12, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a940:	eee7 5a06 	vfma.f32	s11, s14, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a944:	eef5 5ac0 	vcmpe.f32	s11, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a948:	eeb0 6a65 	vmov.f32	s12, s11
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a94c:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 801a950:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a954:	f100 821b 	bmi.w	801ad8e <SFXRhodesFrame+0x966>
                    else rate += 1.0f;
 801a958:	ee36 6a25 	vadd.f32	s12, s12, s11
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a95c:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
 801a960:	ed84 6a13 	vstr	s12, [r4, #76]	; 0x4c
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a964:	eef2 5a0c 	vmov.f32	s11, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
 801a968:	ed83 6a1c 	vstr	s12, [r3, #112]	; 0x70
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801a96c:	ee76 6ac5 	vsub.f32	s13, s13, s10
 801a970:	ee66 6aa5 	vmul.f32	s13, s13, s11
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a974:	ee66 7aa7 	vmul.f32	s15, s13, s15
                    float snapRate = roundf(rawRate);
 801a978:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801a97c:	eee7 7a26 	vfma.f32	s15, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a980:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801a984:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801a988:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a98c:	f100 81f8 	bmi.w	801ad80 <SFXRhodesFrame+0x958>
                    else rate += 1.0f;
 801a990:	ee77 7aa6 	vadd.f32	s15, s15, s13
                    displayValues[k] = rate;
 801a994:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
                    FM_freqRatios[4][k-15] = rate;
 801a998:	edc3 7a1d 	vstr	s15, [r3, #116]	; 0x74
            displayValues[23] = presetKnobValues[Rhodes][23];
 801a99c:	4b5d      	ldr	r3, [pc, #372]	; (801ab14 <SFXRhodesFrame+0x6ec>)
            prevKnobValues[22] = presetKnobValues[Rhodes][22];
 801a99e:	ed88 7a16 	vstr	s14, [r8, #88]	; 0x58
            displayValues[23] = presetKnobValues[Rhodes][23];
 801a9a2:	edd3 7a00 	vldr	s15, [r3]
            if (prevDisplayValues[23] != displayValues[23])
 801a9a6:	4b5c      	ldr	r3, [pc, #368]	; (801ab18 <SFXRhodesFrame+0x6f0>)
            displayValues[23] = presetKnobValues[Rhodes][23];
 801a9a8:	edc4 7a17 	vstr	s15, [r4, #92]	; 0x5c
            if (prevDisplayValues[23] != displayValues[23])
 801a9ac:	edd3 6a17 	vldr	s13, [r3, #92]	; 0x5c
 801a9b0:	eef4 7a66 	vcmp.f32	s15, s13
 801a9b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a9b8:	d03b      	beq.n	801aa32 <SFXRhodesFrame+0x60a>
 801a9ba:	f8df 9180 	ldr.w	r9, [pc, #384]	; 801ab3c <SFXRhodesFrame+0x714>
                    randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
 801a9be:	eeb0 9a00 	vmov.f32	s18, #0	; 0x40000000  2.0
 801a9c2:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 801a9c6:	4f55      	ldr	r7, [pc, #340]	; (801ab1c <SFXRhodesFrame+0x6f4>)
 801a9c8:	f109 0518 	add.w	r5, r9, #24
            if (prevDisplayValues[23] != displayValues[23])
 801a9cc:	464e      	mov	r6, r9
                    randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
 801a9ce:	ed9f 8a54 	vldr	s16, [pc, #336]	; 801ab20 <SFXRhodesFrame+0x6f8>
                    float randomNumberDraw = (leaf.random() * 2.0f) + 0.08f;
 801a9d2:	693b      	ldr	r3, [r7, #16]
 801a9d4:	4798      	blx	r3
                    randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
 801a9d6:	eeb0 7a48 	vmov.f32	s14, s16
 801a9da:	eef0 6a68 	vmov.f32	s13, s17
 801a9de:	edd4 7a17 	vldr	s15, [r4, #92]	; 0x5c
 801a9e2:	eea0 7a09 	vfma.f32	s14, s0, s18
 801a9e6:	eee7 6a27 	vfma.f32	s13, s14, s15
 801a9ea:	ece6 6a01 	vstmia	r6!, {s13}
                for (int i = 0; i < 6; i++)
 801a9ee:	42ae      	cmp	r6, r5
 801a9f0:	d1ef      	bne.n	801a9d2 <SFXRhodesFrame+0x5aa>
 801a9f2:	4f4c      	ldr	r7, [pc, #304]	; (801ab24 <SFXRhodesFrame+0x6fc>)
                        tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(10.0f, displayValues[6] * randomDecays[j], 20000.0f))); //FM_decays[Rsound][j] * displayValues[6]);
 801a9f4:	ed9f 8a4c 	vldr	s16, [pc, #304]	; 801ab28 <SFXRhodesFrame+0x700>
 801a9f8:	f107 0ac0 	add.w	sl, r7, #192	; 0xc0
            if (prevDisplayValues[23] != displayValues[23])
 801a9fc:	46bb      	mov	fp, r7
 801a9fe:	464d      	mov	r5, r9
                        tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(10.0f, displayValues[6] * randomDecays[j], 20000.0f))); //FM_decays[Rsound][j] * displayValues[6]);
 801aa00:	ecf5 0a01 	vldmia	r5!, {s1}
 801aa04:	eeb0 1a48 	vmov.f32	s2, s16
 801aa08:	edd4 7a06 	vldr	s15, [r4, #24]
 801aa0c:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 801aa10:	ee60 0aa7 	vmul.f32	s1, s1, s15
 801aa14:	f009 fa4e 	bl	8023eb4 <LEAF_clip>
 801aa18:	4658      	mov	r0, fp
 801aa1a:	f007 fa29 	bl	8021e70 <tADSR4_setDecay>
                    for (int j = 0; j < 6; j++)
 801aa1e:	42b5      	cmp	r5, r6
 801aa20:	f10b 0b04 	add.w	fp, fp, #4
 801aa24:	d1ec      	bne.n	801aa00 <SFXRhodesFrame+0x5d8>
 801aa26:	3718      	adds	r7, #24
                for (int i = 0; i < NUM_VOC_VOICES; i++)
 801aa28:	4557      	cmp	r7, sl
 801aa2a:	d1e7      	bne.n	801a9fc <SFXRhodesFrame+0x5d4>
 801aa2c:	4b39      	ldr	r3, [pc, #228]	; (801ab14 <SFXRhodesFrame+0x6ec>)
 801aa2e:	edd3 6a00 	vldr	s13, [r3]
            displayValues[24] = presetKnobValues[Rhodes][24];
 801aa32:	4b3e      	ldr	r3, [pc, #248]	; (801ab2c <SFXRhodesFrame+0x704>)
            if (prevDisplayValues[24] != displayValues[24])
 801aa34:	4a38      	ldr	r2, [pc, #224]	; (801ab18 <SFXRhodesFrame+0x6f0>)
            displayValues[24] = presetKnobValues[Rhodes][24];
 801aa36:	ed93 7a00 	vldr	s14, [r3]
            if (prevDisplayValues[24] != displayValues[24])
 801aa3a:	edd2 7a18 	vldr	s15, [r2, #96]	; 0x60
            prevKnobValues[23] = presetKnobValues[Rhodes][23];
 801aa3e:	edc8 6a17 	vstr	s13, [r8, #92]	; 0x5c
            if (prevDisplayValues[24] != displayValues[24])
 801aa42:	eeb4 7a67 	vcmp.f32	s14, s15
            displayValues[24] = presetKnobValues[Rhodes][24];
 801aa46:	ed84 7a18 	vstr	s14, [r4, #96]	; 0x60
            if (prevDisplayValues[24] != displayValues[24])
 801aa4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aa4e:	d024      	beq.n	801aa9a <SFXRhodesFrame+0x672>
 801aa50:	4d37      	ldr	r5, [pc, #220]	; (801ab30 <SFXRhodesFrame+0x708>)
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
 801aa52:	eeb0 9a00 	vmov.f32	s18, #0	; 0x40000000  2.0
 801aa56:	eeff 8a00 	vmov.f32	s17, #240	; 0xbf800000 -1.0
 801aa5a:	4e36      	ldr	r6, [pc, #216]	; (801ab34 <SFXRhodesFrame+0x70c>)
 801aa5c:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 801aa60:	f105 0818 	add.w	r8, r5, #24
 801aa64:	4f2d      	ldr	r7, [pc, #180]	; (801ab1c <SFXRhodesFrame+0x6f4>)
                    float randomNumberDraw = leaf.random() * 2.0f;
 801aa66:	693b      	ldr	r3, [r7, #16]
 801aa68:	4798      	blx	r3
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
 801aa6a:	eeb0 7a68 	vmov.f32	s14, s17
 801aa6e:	eef0 6a48 	vmov.f32	s13, s16
 801aa72:	edd4 7a18 	vldr	s15, [r4, #96]	; 0x60
                    tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
 801aa76:	4630      	mov	r0, r6
 801aa78:	3604      	adds	r6, #4
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
 801aa7a:	eea0 7a09 	vfma.f32	s14, s0, s18
                    tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
 801aa7e:	ed94 0a07 	vldr	s0, [r4, #28]
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
 801aa82:	eee7 6a27 	vfma.f32	s13, s14, s15
 801aa86:	ece5 6a01 	vstmia	r5!, {s13}
                    tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
 801aa8a:	ee26 0a80 	vmul.f32	s0, s13, s0
 801aa8e:	f007 fd77 	bl	8022580 <tExpSmooth_setDest>
                for (int i = 0; i < 6; i++)
 801aa92:	4545      	cmp	r5, r8
 801aa94:	d1e7      	bne.n	801aa66 <SFXRhodesFrame+0x63e>
 801aa96:	edd4 7a18 	vldr	s15, [r4, #96]	; 0x60
            prevDisplayValues[24] = displayValues[24];
 801aa9a:	4b1f      	ldr	r3, [pc, #124]	; (801ab18 <SFXRhodesFrame+0x6f0>)
 801aa9c:	f04f 0806 	mov.w	r8, #6
 801aaa0:	f8df a09c 	ldr.w	sl, [pc, #156]	; 801ab40 <SFXRhodesFrame+0x718>
 801aaa4:	f103 0714 	add.w	r7, r3, #20
 801aaa8:	4e23      	ldr	r6, [pc, #140]	; (801ab38 <SFXRhodesFrame+0x710>)
                                    tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
 801aaaa:	ed9f 8a1f 	vldr	s16, [pc, #124]	; 801ab28 <SFXRhodesFrame+0x700>
            prevDisplayValues[24] = displayValues[24];
 801aaae:	edc3 7a18 	vstr	s15, [r3, #96]	; 0x60
                if (prevDisplayValues[k] != displayValues[k])
 801aab2:	ecb7 7a01 	vldmia	r7!, {s14}
 801aab6:	ecfa 7a01 	vldmia	sl!, {s15}
 801aaba:	eeb4 7a67 	vcmp.f32	s14, s15
 801aabe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aac2:	d01a      	beq.n	801aafa <SFXRhodesFrame+0x6d2>
                    switch(k)
 801aac4:	f1a8 0307 	sub.w	r3, r8, #7
 801aac8:	2b03      	cmp	r3, #3
 801aaca:	d805      	bhi.n	801aad8 <SFXRhodesFrame+0x6b0>
 801aacc:	e8df f013 	tbh	[pc, r3, lsl #1]
 801aad0:	00d900f0 	.word	0x00d900f0
 801aad4:	003a00c5 	.word	0x003a00c5
 801aad8:	4d12      	ldr	r5, [pc, #72]	; (801ab24 <SFXRhodesFrame+0x6fc>)
 801aada:	f105 0bc0 	add.w	fp, r5, #192	; 0xc0
 801aade:	f105 0918 	add.w	r9, r5, #24
                                    tADSR4_setAttack(&FM_envs[i][j], displayValues[5] );
 801aae2:	4628      	mov	r0, r5
 801aae4:	3504      	adds	r5, #4
 801aae6:	ed94 0a05 	vldr	s0, [r4, #20]
 801aaea:	f007 f9b3 	bl	8021e54 <tADSR4_setAttack>
                                for (int j = 0; j < 6; j++)
 801aaee:	45a9      	cmp	r9, r5
 801aaf0:	d1f7      	bne.n	801aae2 <SFXRhodesFrame+0x6ba>
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801aaf2:	45d9      	cmp	r9, fp
 801aaf4:	d1f3      	bne.n	801aade <SFXRhodesFrame+0x6b6>
 801aaf6:	ed5a 7a01 	vldr	s15, [sl, #-4]
            for (int k = 5; k < 10; k++)
 801aafa:	f1b8 0f0a 	cmp.w	r8, #10
                prevDisplayValues[k] = displayValues[k];
 801aafe:	ed47 7a01 	vstr	s15, [r7, #-4]
            for (int k = 5; k < 10; k++)
 801ab02:	d03d      	beq.n	801ab80 <SFXRhodesFrame+0x758>
 801ab04:	f108 0801 	add.w	r8, r8, #1
 801ab08:	e7d3      	b.n	801aab2 <SFXRhodesFrame+0x68a>
 801ab0a:	bf00      	nop
 801ab0c:	200033b4 	.word	0x200033b4
 801ab10:	20000040 	.word	0x20000040
 801ab14:	200033b8 	.word	0x200033b8
 801ab18:	2000359c 	.word	0x2000359c
 801ab1c:	200194e8 	.word	0x200194e8
 801ab20:	bf6b851f 	.word	0xbf6b851f
 801ab24:	200174d4 	.word	0x200174d4
 801ab28:	469c4000 	.word	0x469c4000
 801ab2c:	200033bc 	.word	0x200033bc
 801ab30:	20000294 	.word	0x20000294
 801ab34:	200029d8 	.word	0x200029d8
 801ab38:	20000294 	.word	0x20000294
 801ab3c:	2000027c 	.word	0x2000027c
 801ab40:	200187f0 	.word	0x200187f0
 801ab44:	4da0      	ldr	r5, [pc, #640]	; (801adc8 <SFXRhodesFrame+0x9a0>)
                                    tADSR4_setLeakFactor(&FM_envs[i][j], ((1.0f - displayValues[9])  * 0.00004f) + 0.99996f);
 801ab46:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 801ab4a:	eddf 8aa0 	vldr	s17, [pc, #640]	; 801adcc <SFXRhodesFrame+0x9a4>
 801ab4e:	f105 07c0 	add.w	r7, r5, #192	; 0xc0
 801ab52:	ed9f 8a9f 	vldr	s16, [pc, #636]	; 801add0 <SFXRhodesFrame+0x9a8>
 801ab56:	f105 0618 	add.w	r6, r5, #24
 801ab5a:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 801ab5e:	eeb0 0a48 	vmov.f32	s0, s16
 801ab62:	4628      	mov	r0, r5
 801ab64:	3504      	adds	r5, #4
 801ab66:	ee79 7a67 	vsub.f32	s15, s18, s15
 801ab6a:	eea7 0aa8 	vfma.f32	s0, s15, s17
 801ab6e:	f007 f9b1 	bl	8021ed4 <tADSR4_setLeakFactor>
                                for (int j = 0; j < 6; j++)
 801ab72:	42b5      	cmp	r5, r6
 801ab74:	d1f1      	bne.n	801ab5a <SFXRhodesFrame+0x732>
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801ab76:	42bd      	cmp	r5, r7
 801ab78:	d1ed      	bne.n	801ab56 <SFXRhodesFrame+0x72e>
                prevDisplayValues[k] = displayValues[k];
 801ab7a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801ab7c:	4a95      	ldr	r2, [pc, #596]	; (801add4 <SFXRhodesFrame+0x9ac>)
 801ab7e:	6253      	str	r3, [r2, #36]	; 0x24
            for (int i = 0; i < numVoices; i++)
 801ab80:	9b01      	ldr	r3, [sp, #4]
 801ab82:	681b      	ldr	r3, [r3, #0]
 801ab84:	2b00      	cmp	r3, #0
 801ab86:	dd49      	ble.n	801ac1c <SFXRhodesFrame+0x7f4>
 801ab88:	f8df a268 	ldr.w	sl, [pc, #616]	; 801adf4 <SFXRhodesFrame+0x9cc>
 801ab8c:	2500      	movs	r5, #0
 801ab8e:	f8df b268 	ldr.w	fp, [pc, #616]	; 801adf8 <SFXRhodesFrame+0x9d0>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801ab92:	4656      	mov	r6, sl
 801ab94:	f8df 9264 	ldr.w	r9, [pc, #612]	; 801adfc <SFXRhodesFrame+0x9d4>
 801ab98:	4f8f      	ldr	r7, [pc, #572]	; (801add8 <SFXRhodesFrame+0x9b0>)
                        if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
 801ab9a:	46d8      	mov	r8, fp
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801ab9c:	fa5f fb85 	uxtb.w	fp, r5
 801aba0:	4630      	mov	r0, r6
 801aba2:	4659      	mov	r1, fp
 801aba4:	f00a f82c 	bl	8024c00 <tSimplePoly_getPitch>
 801aba8:	ee07 0a90 	vmov	s15, r0
 801abac:	ed99 0a00 	vldr	s0, [r9]
 801abb0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801abb4:	7839      	ldrb	r1, [r7, #0]
 801abb6:	4a89      	ldr	r2, [pc, #548]	; (801addc <SFXRhodesFrame+0x9b4>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801abb8:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801abbc:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801abc0:	ee17 3a90 	vmov	r3, s15
 801abc4:	1a5b      	subs	r3, r3, r1
 801abc6:	fb82 2003 	smull	r2, r0, r2, r3
 801abca:	17d9      	asrs	r1, r3, #31
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801abcc:	4a84      	ldr	r2, [pc, #528]	; (801ade0 <SFXRhodesFrame+0x9b8>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801abce:	ebc1 0160 	rsb	r1, r1, r0, asr #1
 801abd2:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 801abd6:	eba3 0381 	sub.w	r3, r3, r1, lsl #2
 801abda:	ee07 3a90 	vmov	s15, r3
 801abde:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801abe2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801abe6:	ee17 3a90 	vmov	r3, s15
 801abea:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801abee:	ed93 0a00 	vldr	s0, [r3]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801abf2:	ee37 0a00 	vadd.f32	s0, s14, s0
 801abf6:	f009 fa49 	bl	802408c <LEAF_midiToFrequency>
                if (numVoices > 1)
 801abfa:	9b01      	ldr	r3, [sp, #4]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801abfc:	eca8 0a01 	vstmia	r8!, {s0}
                if (numVoices > 1)
 801ac00:	681b      	ldr	r3, [r3, #0]
 801ac02:	2b01      	cmp	r3, #1
 801ac04:	dd0a      	ble.n	801ac1c <SFXRhodesFrame+0x7f4>
                    if (poly->voices[i][0] == -2)
 801ac06:	f8da 1000 	ldr.w	r1, [sl]
 801ac0a:	6909      	ldr	r1, [r1, #16]
 801ac0c:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
 801ac10:	6809      	ldr	r1, [r1, #0]
 801ac12:	3102      	adds	r1, #2
 801ac14:	d00c      	beq.n	801ac30 <SFXRhodesFrame+0x808>
            for (int i = 0; i < numVoices; i++)
 801ac16:	3501      	adds	r5, #1
 801ac18:	429d      	cmp	r5, r3
 801ac1a:	dbbf      	blt.n	801ab9c <SFXRhodesFrame+0x774>
            tCycle_setFreq(&tremolo, displayValues[2]);
 801ac1c:	ed94 0a02 	vldr	s0, [r4, #8]
 801ac20:	4870      	ldr	r0, [pc, #448]	; (801ade4 <SFXRhodesFrame+0x9bc>)
        }
 801ac22:	b003      	add	sp, #12
 801ac24:	ecbd 8b04 	vpop	{d8-d9}
 801ac28:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            tCycle_setFreq(&tremolo, displayValues[2]);
 801ac2c:	f00a b826 	b.w	8024c7c <tCycle_setFreq>
 801ac30:	eb05 0145 	add.w	r1, r5, r5, lsl #1
                        if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
 801ac34:	4a64      	ldr	r2, [pc, #400]	; (801adc8 <SFXRhodesFrame+0x9a0>)
 801ac36:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
 801ac3a:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
 801ac3e:	6a80      	ldr	r0, [r0, #40]	; 0x28
 801ac40:	2800      	cmp	r0, #0
 801ac42:	d1e8      	bne.n	801ac16 <SFXRhodesFrame+0x7ee>
 801ac44:	6889      	ldr	r1, [r1, #8]
 801ac46:	6a89      	ldr	r1, [r1, #40]	; 0x28
 801ac48:	2900      	cmp	r1, #0
 801ac4a:	d1e4      	bne.n	801ac16 <SFXRhodesFrame+0x7ee>
                            tSimplePoly_deactivateVoice(&poly, i);
 801ac4c:	4659      	mov	r1, fp
 801ac4e:	4630      	mov	r0, r6
 801ac50:	f009 fefc 	bl	8024a4c <tSimplePoly_deactivateVoice>
 801ac54:	9b01      	ldr	r3, [sp, #4]
 801ac56:	681b      	ldr	r3, [r3, #0]
 801ac58:	e7dd      	b.n	801ac16 <SFXRhodesFrame+0x7ee>
 801ac5a:	4d5b      	ldr	r5, [pc, #364]	; (801adc8 <SFXRhodesFrame+0x9a0>)
 801ac5c:	f105 0bc0 	add.w	fp, r5, #192	; 0xc0
 801ac60:	f105 0918 	add.w	r9, r5, #24
                                    tADSR4_setRelease(&FM_envs[i][j], displayValues[8]);
 801ac64:	4628      	mov	r0, r5
 801ac66:	3504      	adds	r5, #4
 801ac68:	ed94 0a08 	vldr	s0, [r4, #32]
 801ac6c:	f007 f924 	bl	8021eb8 <tADSR4_setRelease>
                                for (int j = 0; j < 6; j++)
 801ac70:	454d      	cmp	r5, r9
 801ac72:	d1f7      	bne.n	801ac64 <SFXRhodesFrame+0x83c>
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801ac74:	455d      	cmp	r5, fp
 801ac76:	d1f3      	bne.n	801ac60 <SFXRhodesFrame+0x838>
                prevDisplayValues[k] = displayValues[k];
 801ac78:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 801ac7c:	f847 3c04 	str.w	r3, [r7, #-4]
 801ac80:	e740      	b.n	801ab04 <SFXRhodesFrame+0x6dc>
 801ac82:	4d59      	ldr	r5, [pc, #356]	; (801ade8 <SFXRhodesFrame+0x9c0>)
 801ac84:	f8df 9178 	ldr.w	r9, [pc, #376]	; 801ae00 <SFXRhodesFrame+0x9d8>
 801ac88:	f105 0b18 	add.w	fp, r5, #24
                                tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
 801ac8c:	ecb5 0a01 	vldmia	r5!, {s0}
 801ac90:	4648      	mov	r0, r9
 801ac92:	edd4 7a07 	vldr	s15, [r4, #28]
 801ac96:	f109 0904 	add.w	r9, r9, #4
 801ac9a:	ee20 0a27 	vmul.f32	s0, s0, s15
 801ac9e:	f007 fc6f 	bl	8022580 <tExpSmooth_setDest>
                            for (int i = 0; i < 6; i++)
 801aca2:	45ab      	cmp	fp, r5
 801aca4:	d1f2      	bne.n	801ac8c <SFXRhodesFrame+0x864>
                prevDisplayValues[k] = displayValues[k];
 801aca6:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 801acaa:	f847 3c04 	str.w	r3, [r7, #-4]
 801acae:	e729      	b.n	801ab04 <SFXRhodesFrame+0x6dc>
 801acb0:	f8df 9114 	ldr.w	r9, [pc, #276]	; 801adc8 <SFXRhodesFrame+0x9a0>
 801acb4:	f8df b14c 	ldr.w	fp, [pc, #332]	; 801ae04 <SFXRhodesFrame+0x9dc>
            prevDisplayValues[24] = displayValues[24];
 801acb8:	464d      	mov	r5, r9
                                    tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
 801acba:	ecfb 0a01 	vldmia	fp!, {s1}
 801acbe:	eeb0 1a48 	vmov.f32	s2, s16
 801acc2:	edd4 7a06 	vldr	s15, [r4, #24]
 801acc6:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
 801acca:	ee60 0aa7 	vmul.f32	s1, s1, s15
 801acce:	f009 f8f1 	bl	8023eb4 <LEAF_clip>
 801acd2:	4628      	mov	r0, r5
 801acd4:	f007 f8cc 	bl	8021e70 <tADSR4_setDecay>
                                for (int j = 0; j < 6; j++)
 801acd8:	455e      	cmp	r6, fp
 801acda:	f105 0504 	add.w	r5, r5, #4
 801acde:	d1ec      	bne.n	801acba <SFXRhodesFrame+0x892>
 801ace0:	f109 0918 	add.w	r9, r9, #24
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801ace4:	4b41      	ldr	r3, [pc, #260]	; (801adec <SFXRhodesFrame+0x9c4>)
 801ace6:	454b      	cmp	r3, r9
 801ace8:	d1e4      	bne.n	801acb4 <SFXRhodesFrame+0x88c>
                prevDisplayValues[k] = displayValues[k];
 801acea:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 801acee:	f847 3c04 	str.w	r3, [r7, #-4]
 801acf2:	e707      	b.n	801ab04 <SFXRhodesFrame+0x6dc>
                tremoloStereo = !tremoloStereo;
 801acf4:	4a3e      	ldr	r2, [pc, #248]	; (801adf0 <SFXRhodesFrame+0x9c8>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801acf6:	2100      	movs	r1, #0
                tremoloStereo = !tremoloStereo;
 801acf8:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801acfa:	7721      	strb	r1, [r4, #28]
                tremoloStereo = !tremoloStereo;
 801acfc:	fab3 f383 	clz	r3, r3
 801ad00:	095b      	lsrs	r3, r3, #5
                setLED_C(tremoloStereo == 1);
 801ad02:	4618      	mov	r0, r3
                tremoloStereo = !tremoloStereo;
 801ad04:	6013      	str	r3, [r2, #0]
                setLED_C(tremoloStereo == 1);
 801ad06:	f7f8 fe3d 	bl	8013984 <setLED_C>
 801ad0a:	f7ff bbc2 	b.w	801a492 <SFXRhodesFrame+0x6a>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801ad0e:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
 801ad12:	ee76 6a63 	vsub.f32	s13, s12, s7
 801ad16:	eef0 6ae6 	vabs.f32	s13, s13
 801ad1a:	ee83 6aa6 	vdiv.f32	s12, s7, s13
 801ad1e:	e4f3      	b.n	801a708 <SFXRhodesFrame+0x2e0>
 801ad20:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
 801ad24:	ee73 6ac3 	vsub.f32	s13, s7, s6
 801ad28:	eef0 6ae6 	vabs.f32	s13, s13
 801ad2c:	eec3 3a26 	vdiv.f32	s7, s6, s13
 801ad30:	e515      	b.n	801a75e <SFXRhodesFrame+0x336>
 801ad32:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801ad36:	eef0 3ae7 	vabs.f32	s7, s15
 801ad3a:	eec7 7a23 	vdiv.f32	s15, s14, s7
 801ad3e:	e537      	b.n	801a7b0 <SFXRhodesFrame+0x388>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801ad40:	ee33 4ac3 	vsub.f32	s8, s7, s6
 801ad44:	eef0 3ac4 	vabs.f32	s7, s8
 801ad48:	ee83 4a23 	vdiv.f32	s8, s6, s7
 801ad4c:	e58d      	b.n	801a86a <SFXRhodesFrame+0x442>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801ad4e:	ee76 6a65 	vsub.f32	s13, s12, s11
 801ad52:	eef0 6ae6 	vabs.f32	s13, s13
 801ad56:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 801ad5a:	e454      	b.n	801a606 <SFXRhodesFrame+0x1de>
 801ad5c:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 801ad60:	ee76 6a65 	vsub.f32	s13, s12, s11
 801ad64:	eef0 6ae6 	vabs.f32	s13, s13
 801ad68:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 801ad6c:	e476      	b.n	801a65c <SFXRhodesFrame+0x234>
 801ad6e:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 801ad72:	ee76 6a65 	vsub.f32	s13, s12, s11
 801ad76:	eef0 6ae6 	vabs.f32	s13, s13
 801ad7a:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 801ad7e:	e498      	b.n	801a6b2 <SFXRhodesFrame+0x28a>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801ad80:	ee77 7ae6 	vsub.f32	s15, s15, s13
 801ad84:	eeb0 6ae7 	vabs.f32	s12, s15
 801ad88:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801ad8c:	e602      	b.n	801a994 <SFXRhodesFrame+0x56c>
 801ad8e:	ee36 6a65 	vsub.f32	s12, s12, s11
 801ad92:	eeb0 5ac6 	vabs.f32	s10, s12
 801ad96:	ee85 6a85 	vdiv.f32	s12, s11, s10
 801ad9a:	e5df      	b.n	801a95c <SFXRhodesFrame+0x534>
 801ad9c:	ee75 5ac5 	vsub.f32	s11, s11, s10
 801ada0:	eef0 4ae5 	vabs.f32	s9, s11
 801ada4:	eec5 5a24 	vdiv.f32	s11, s10, s9
 801ada8:	e5ba      	b.n	801a920 <SFXRhodesFrame+0x4f8>
 801adaa:	ee35 5a64 	vsub.f32	s10, s10, s9
 801adae:	eeb0 4ac5 	vabs.f32	s8, s10
 801adb2:	ee84 5a84 	vdiv.f32	s10, s9, s8
 801adb6:	e595      	b.n	801a8e4 <SFXRhodesFrame+0x4bc>
 801adb8:	ee74 4ac4 	vsub.f32	s9, s9, s8
 801adbc:	eef0 3ae4 	vabs.f32	s7, s9
 801adc0:	eec4 4a23 	vdiv.f32	s9, s8, s7
 801adc4:	e570      	b.n	801a8a8 <SFXRhodesFrame+0x480>
 801adc6:	bf00      	nop
 801adc8:	200174d4 	.word	0x200174d4
 801adcc:	3827c5ac 	.word	0x3827c5ac
 801add0:	3f7ffd61 	.word	0x3f7ffd61
 801add4:	2000359c 	.word	0x2000359c
 801add8:	20000668 	.word	0x20000668
 801addc:	2aaaaaab 	.word	0x2aaaaaab
 801ade0:	20000634 	.word	0x20000634
 801ade4:	200177a8 	.word	0x200177a8
 801ade8:	20000294 	.word	0x20000294
 801adec:	20017594 	.word	0x20017594
 801adf0:	2000061c 	.word	0x2000061c
 801adf4:	200174c8 	.word	0x200174c8
 801adf8:	200033e4 	.word	0x200033e4
 801adfc:	200005e8 	.word	0x200005e8
 801ae00:	200029d8 	.word	0x200029d8
 801ae04:	2000027c 	.word	0x2000027c

0801ae08 <SFXRhodesTick>:
        {
 801ae08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ae0c:	f8df 8364 	ldr.w	r8, [pc, #868]	; 801b174 <SFXRhodesTick+0x36c>
 801ae10:	4cc8      	ldr	r4, [pc, #800]	; (801b134 <SFXRhodesTick+0x32c>)
 801ae12:	f108 0518 	add.w	r5, r8, #24
 801ae16:	4646      	mov	r6, r8
 801ae18:	ed2d 8b08 	vpush	{d8-d11}
 801ae1c:	b08f      	sub	sp, #60	; 0x3c
 801ae1e:	900d      	str	r0, [sp, #52]	; 0x34
                sustainsFinal[i] = tExpSmooth_tick(&susSmoothers[i]);
 801ae20:	4620      	mov	r0, r4
 801ae22:	3404      	adds	r4, #4
 801ae24:	f007 fbb6 	bl	8022594 <tExpSmooth_tick>
 801ae28:	eca6 0a01 	vstmia	r6!, {s0}
            for (int i = 0; i < 6; i++)
 801ae2c:	42ae      	cmp	r6, r5
 801ae2e:	d1f7      	bne.n	801ae20 <SFXRhodesTick+0x18>
 801ae30:	4bc1      	ldr	r3, [pc, #772]	; (801b138 <SFXRhodesTick+0x330>)
 801ae32:	f103 09c0 	add.w	r9, r3, #192	; 0xc0
 801ae36:	461f      	mov	r7, r3
        {
 801ae38:	463d      	mov	r5, r7
 801ae3a:	4644      	mov	r4, r8
                    tADSR4_setSustain(&FM_envs[i][j], sustainsFinal[j]); //FM_sustains[Rsound][j] * displayValues[7]);
 801ae3c:	ecb4 0a01 	vldmia	r4!, {s0}
 801ae40:	4628      	mov	r0, r5
 801ae42:	f007 f823 	bl	8021e8c <tADSR4_setSustain>
 801ae46:	3504      	adds	r5, #4
                for (int j = 0; j < 6; j++)
 801ae48:	42a6      	cmp	r6, r4
 801ae4a:	d1f7      	bne.n	801ae3c <SFXRhodesTick+0x34>
 801ae4c:	3718      	adds	r7, #24
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801ae4e:	454f      	cmp	r7, r9
 801ae50:	d1f2      	bne.n	801ae38 <SFXRhodesTick+0x30>
            for (int i = 0; i < numVoices; i++)
 801ae52:	4bba      	ldr	r3, [pc, #744]	; (801b13c <SFXRhodesTick+0x334>)
 801ae54:	681a      	ldr	r2, [r3, #0]
 801ae56:	2a00      	cmp	r2, #0
 801ae58:	f340 8165 	ble.w	801b126 <SFXRhodesTick+0x31e>
 801ae5c:	49b8      	ldr	r1, [pc, #736]	; (801b140 <SFXRhodesTick+0x338>)
 801ae5e:	f04f 0a00 	mov.w	sl, #0
 801ae62:	f8df 8314 	ldr.w	r8, [pc, #788]	; 801b178 <SFXRhodesTick+0x370>
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801ae66:	eef7 aa00 	vmov.f32	s21, #112	; 0x3f800000  1.0
 801ae6a:	9105      	str	r1, [sp, #20]
 801ae6c:	eeb6 aa00 	vmov.f32	s20, #96	; 0x3f000000  0.5
 801ae70:	49b1      	ldr	r1, [pc, #708]	; (801b138 <SFXRhodesTick+0x330>)
            for (int i = 0; i < numVoices; i++)
 801ae72:	4652      	mov	r2, sl
            float rightSample = 0.0f;
 801ae74:	ed9f 9ab3 	vldr	s18, [pc, #716]	; 801b144 <SFXRhodesTick+0x33c>
 801ae78:	f101 0014 	add.w	r0, r1, #20
 801ae7c:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 801b17c <SFXRhodesTick+0x374>
            float leftSample = 0.0f;
 801ae80:	eef0 9a49 	vmov.f32	s19, s18
 801ae84:	4cb0      	ldr	r4, [pc, #704]	; (801b148 <SFXRhodesTick+0x340>)
 801ae86:	900c      	str	r0, [sp, #48]	; 0x30
 801ae88:	48b0      	ldr	r0, [pc, #704]	; (801b14c <SFXRhodesTick+0x344>)
 801ae8a:	f8df b2f4 	ldr.w	fp, [pc, #756]	; 801b180 <SFXRhodesTick+0x378>
 801ae8e:	9004      	str	r0, [sp, #16]
 801ae90:	f101 0010 	add.w	r0, r1, #16
 801ae94:	4dae      	ldr	r5, [pc, #696]	; (801b150 <SFXRhodesTick+0x348>)
 801ae96:	900b      	str	r0, [sp, #44]	; 0x2c
 801ae98:	f101 000c 	add.w	r0, r1, #12
 801ae9c:	900a      	str	r0, [sp, #40]	; 0x28
 801ae9e:	1d08      	adds	r0, r1, #4
 801aea0:	3108      	adds	r1, #8
 801aea2:	9008      	str	r0, [sp, #32]
 801aea4:	9109      	str	r1, [sp, #36]	; 0x24
 801aea6:	4641      	mov	r1, r8
 801aea8:	46d0      	mov	r8, sl
 801aeaa:	468a      	mov	sl, r1
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801aeac:	f8d9 7000 	ldr.w	r7, [r9]
            for (int i = 0; i < numVoices; i++)
 801aeb0:	3201      	adds	r2, #1
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801aeb2:	ed9a 0a00 	vldr	s0, [sl]
 801aeb6:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 801aeba:	eddb 7a00 	vldr	s15, [fp]
                float myFrequency = freq[i];
 801aebe:	9905      	ldr	r1, [sp, #20]
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801aec0:	00ff      	lsls	r7, r7, #3
 801aec2:	ee67 7a80 	vmul.f32	s15, s15, s0
                float myFrequency = freq[i];
 801aec6:	ecf1 8a01 	vldmia	r1!, {s17}
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801aeca:	eb05 0c07 	add.w	ip, r5, r7
 801aece:	9307      	str	r3, [sp, #28]
 801aed0:	4ba0      	ldr	r3, [pc, #640]	; (801b154 <SFXRhodesTick+0x34c>)
 801aed2:	4427      	add	r7, r4
 801aed4:	ed9c 0a05 	vldr	s0, [ip, #20]
 801aed8:	eb03 0608 	add.w	r6, r3, r8
                float myFrequency = freq[i];
 801aedc:	9105      	str	r1, [sp, #20]
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801aede:	ee27 0a80 	vmul.f32	s0, s15, s0
            for (int i = 0; i < numVoices; i++)
 801aee2:	9206      	str	r2, [sp, #24]
 801aee4:	3b04      	subs	r3, #4
 801aee6:	4a9c      	ldr	r2, [pc, #624]	; (801b158 <SFXRhodesTick+0x350>)
 801aee8:	499c      	ldr	r1, [pc, #624]	; (801b15c <SFXRhodesTick+0x354>)
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801aeea:	4630      	mov	r0, r6
 801aeec:	ed97 7a05 	vldr	s14, [r7, #20]
 801aef0:	4442      	add	r2, r8
 801aef2:	4443      	add	r3, r8
 801aef4:	4441      	add	r1, r8
 801aef6:	eea7 0a28 	vfma.f32	s0, s14, s17
 801aefa:	9202      	str	r2, [sp, #8]
 801aefc:	9303      	str	r3, [sp, #12]
 801aefe:	9101      	str	r1, [sp, #4]
 801af00:	f009 febc 	bl	8024c7c <tCycle_setFreq>
                feedback_output = tCycle_tick(&FM_sines[i][5]);
 801af04:	4630      	mov	r0, r6
 801af06:	4f96      	ldr	r7, [pc, #600]	; (801b160 <SFXRhodesTick+0x358>)
 801af08:	f009 fec6 	bl	8024c98 <tCycle_tick>
                tCycle_setFreq(&FM_sines[i][4], (myFrequency  * FM_freqRatios[Rsound][4]) + (FM_indices[Rsound][4] * feedback_output * displayValues[0] * tADSR4_tick(&FM_envs[i][5])));
 801af0c:	f8d9 0000 	ldr.w	r0, [r9]
 801af10:	edda 7a00 	vldr	s15, [sl]
 801af14:	4447      	add	r7, r8
 801af16:	eb00 0040 	add.w	r0, r0, r0, lsl #1
                feedback_output = tCycle_tick(&FM_sines[i][5]);
 801af1a:	ed8b 0a00 	vstr	s0, [fp]
                tCycle_setFreq(&FM_sines[i][4], (myFrequency  * FM_freqRatios[Rsound][4]) + (FM_indices[Rsound][4] * feedback_output * displayValues[0] * tADSR4_tick(&FM_envs[i][5])));
 801af1e:	00c0      	lsls	r0, r0, #3
 801af20:	eb05 0c00 	add.w	ip, r5, r0
 801af24:	1826      	adds	r6, r4, r0
 801af26:	980c      	ldr	r0, [sp, #48]	; 0x30
 801af28:	ed9c 8a04 	vldr	s16, [ip, #16]
 801af2c:	4440      	add	r0, r8
 801af2e:	ed96 ba04 	vldr	s22, [r6, #16]
 801af32:	ee28 8a27 	vmul.f32	s16, s16, s15
 801af36:	4e8b      	ldr	r6, [pc, #556]	; (801b164 <SFXRhodesTick+0x35c>)
 801af38:	4446      	add	r6, r8
 801af3a:	ee28 8a00 	vmul.f32	s16, s16, s0
 801af3e:	f006 ffe7 	bl	8021f10 <tADSR4_tick>
 801af42:	9803      	ldr	r0, [sp, #12]
 801af44:	ee28 0a00 	vmul.f32	s0, s16, s0
 801af48:	eeab 0a28 	vfma.f32	s0, s22, s17
 801af4c:	f009 fe96 	bl	8024c7c <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][3], (myFrequency  * FM_freqRatios[Rsound][3]) + (FM_indices[Rsound][3] * displayValues[0] * tCycle_tick(&FM_sines[i][4]) * tADSR4_tickNoInterp(&FM_envs[i][4])));
 801af50:	f8d9 1000 	ldr.w	r1, [r9]
 801af54:	edda 7a00 	vldr	s15, [sl]
 801af58:	eb01 0c41 	add.w	ip, r1, r1, lsl #1
 801af5c:	9803      	ldr	r0, [sp, #12]
 801af5e:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 801af62:	eb05 0e0c 	add.w	lr, r5, ip
 801af66:	44a4      	add	ip, r4
 801af68:	ed9e 8a03 	vldr	s16, [lr, #12]
 801af6c:	ed9c ba03 	vldr	s22, [ip, #12]
 801af70:	ee28 8a27 	vmul.f32	s16, s16, s15
 801af74:	f009 fe90 	bl	8024c98 <tCycle_tick>
 801af78:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801af7a:	ee28 8a00 	vmul.f32	s16, s16, s0
 801af7e:	eb03 0008 	add.w	r0, r3, r8
 801af82:	f007 f923 	bl	80221cc <tADSR4_tickNoInterp>
 801af86:	9802      	ldr	r0, [sp, #8]
 801af88:	ee28 0a00 	vmul.f32	s0, s16, s0
 801af8c:	eeab 0a28 	vfma.f32	s0, s22, s17
 801af90:	f009 fe74 	bl	8024c7c <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][2], (myFrequency  * FM_freqRatios[Rsound][2]) + (FM_indices[Rsound][2] * displayValues[0] * tCycle_tick(&FM_sines[i][3]) * tADSR4_tickNoInterp(&FM_envs[i][3])));
 801af94:	f8d9 1000 	ldr.w	r1, [r9]
 801af98:	edda 7a00 	vldr	s15, [sl]
 801af9c:	eb01 0c41 	add.w	ip, r1, r1, lsl #1
 801afa0:	9802      	ldr	r0, [sp, #8]
 801afa2:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 801afa6:	eb05 0e0c 	add.w	lr, r5, ip
 801afaa:	44a4      	add	ip, r4
 801afac:	ed9e 8a02 	vldr	s16, [lr, #8]
 801afb0:	ed9c ba02 	vldr	s22, [ip, #8]
 801afb4:	ee28 8a27 	vmul.f32	s16, s16, s15
 801afb8:	f009 fe6e 	bl	8024c98 <tCycle_tick>
 801afbc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801afbe:	ee28 8a00 	vmul.f32	s16, s16, s0
 801afc2:	eb03 0008 	add.w	r0, r3, r8
 801afc6:	f007 f901 	bl	80221cc <tADSR4_tickNoInterp>
 801afca:	9801      	ldr	r0, [sp, #4]
 801afcc:	ee28 0a00 	vmul.f32	s0, s16, s0
 801afd0:	eeab 0a28 	vfma.f32	s0, s22, s17
 801afd4:	f009 fe52 	bl	8024c7c <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][1], myFrequency  * FM_freqRatios[Rsound][1]);
 801afd8:	f8d9 1000 	ldr.w	r1, [r9]
 801afdc:	4638      	mov	r0, r7
 801afde:	eb01 0c41 	add.w	ip, r1, r1, lsl #1
 801afe2:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
 801afe6:	ed9c 0a01 	vldr	s0, [ip, #4]
 801afea:	ee28 0a80 	vmul.f32	s0, s17, s0
 801afee:	f009 fe45 	bl	8024c7c <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][0],( myFrequency  * FM_freqRatios[Rsound][0]) + (FM_indices[Rsound][0] * displayValues[0] * tCycle_tick(&FM_sines[i][1]) * tADSR4_tickNoInterp(&FM_envs[i][1])));
 801aff2:	f8d9 1000 	ldr.w	r1, [r9]
 801aff6:	4638      	mov	r0, r7
 801aff8:	edda 7a00 	vldr	s15, [sl]
 801affc:	eb01 0c41 	add.w	ip, r1, r1, lsl #1
 801b000:	ea4f 07cc 	mov.w	r7, ip, lsl #3
 801b004:	eb05 0c07 	add.w	ip, r5, r7
 801b008:	4427      	add	r7, r4
 801b00a:	ed9c 8a00 	vldr	s16, [ip]
 801b00e:	ed97 ba00 	vldr	s22, [r7]
 801b012:	ee28 8a27 	vmul.f32	s16, s16, s15
 801b016:	f009 fe3f 	bl	8024c98 <tCycle_tick>
 801b01a:	9b08      	ldr	r3, [sp, #32]
 801b01c:	ee28 8a00 	vmul.f32	s16, s16, s0
 801b020:	eb03 0008 	add.w	r0, r3, r8
 801b024:	f007 f8d2 	bl	80221cc <tADSR4_tickNoInterp>
 801b028:	4630      	mov	r0, r6
 801b02a:	ee28 0a00 	vmul.f32	s0, s16, s0
 801b02e:	eeab 0a28 	vfma.f32	s0, s22, s17
 801b032:	f009 fe23 	bl	8024c7c <tCycle_setFreq>
                sample += (tCycle_tick(&FM_sines[i][2]) * tADSR4_tickNoInterp(&FM_envs[i][2]));
 801b036:	9801      	ldr	r0, [sp, #4]
 801b038:	f009 fe2e 	bl	8024c98 <tCycle_tick>
 801b03c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b03e:	eeb0 ba40 	vmov.f32	s22, s0
 801b042:	eb03 0008 	add.w	r0, r3, r8
 801b046:	f007 f8c1 	bl	80221cc <tADSR4_tickNoInterp>
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
 801b04a:	4630      	mov	r0, r6
                sample += (tCycle_tick(&FM_sines[i][2]) * tADSR4_tickNoInterp(&FM_envs[i][2]));
 801b04c:	eef0 8a40 	vmov.f32	s17, s0
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
 801b050:	f009 fe22 	bl	8024c98 <tCycle_tick>
 801b054:	4b38      	ldr	r3, [pc, #224]	; (801b138 <SFXRhodesTick+0x330>)
 801b056:	eeb0 8a40 	vmov.f32	s16, s0
 801b05a:	eb03 0008 	add.w	r0, r3, r8
 801b05e:	f108 0818 	add.w	r8, r8, #24
 801b062:	f007 f8b3 	bl	80221cc <tADSR4_tickNoInterp>
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801b066:	9b04      	ldr	r3, [sp, #16]
 801b068:	edda 7a04 	vldr	s15, [sl, #16]
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
 801b06c:	ee28 0a00 	vmul.f32	s0, s16, s0
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801b070:	ecf3 6a01 	vldmia	r3!, {s13}
 801b074:	ee3a 6ae7 	vsub.f32	s12, s21, s15
            for (int i = 0; i < numVoices; i++)
 801b078:	9a06      	ldr	r2, [sp, #24]
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801b07a:	ee3a 7ae6 	vsub.f32	s14, s21, s13
 801b07e:	9304      	str	r3, [sp, #16]
                rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
 801b080:	ee67 6aa6 	vmul.f32	s13, s15, s13
            for (int i = 0; i < numVoices; i++)
 801b084:	9b07      	ldr	r3, [sp, #28]
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
 801b086:	eeab 0a28 	vfma.f32	s0, s22, s17
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801b08a:	ee67 7a27 	vmul.f32	s15, s14, s15
            for (int i = 0; i < numVoices; i++)
 801b08e:	6818      	ldr	r0, [r3, #0]
                rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
 801b090:	eee6 6a0a 	vfma.f32	s13, s12, s20
            for (int i = 0; i < numVoices; i++)
 801b094:	4290      	cmp	r0, r2
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801b096:	eee6 7a0a 	vfma.f32	s15, s12, s20
                rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
 801b09a:	eea6 9a80 	vfma.f32	s18, s13, s0
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801b09e:	eee7 9a80 	vfma.f32	s19, s15, s0
            for (int i = 0; i < numVoices; i++)
 801b0a2:	f73f af03 	bgt.w	801aeac <SFXRhodesTick+0xa4>
 801b0a6:	eddf 7a30 	vldr	s15, [pc, #192]	; 801b168 <SFXRhodesTick+0x360>
 801b0aa:	46d0      	mov	r8, sl
 801b0ac:	ee69 9aa7 	vmul.f32	s19, s19, s15
 801b0b0:	ee29 9a27 	vmul.f32	s18, s18, s15
            float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
 801b0b4:	482d      	ldr	r0, [pc, #180]	; (801b16c <SFXRhodesTick+0x364>)
 801b0b6:	f009 fdef 	bl	8024c98 <tCycle_tick>
 801b0ba:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801b0be:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 801b0c2:	edd8 6a01 	vldr	s13, [r8, #4]
            if (tremoloStereo)
 801b0c6:	4b2a      	ldr	r3, [pc, #168]	; (801b170 <SFXRhodesTick+0x368>)
            float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
 801b0c8:	ee30 0a27 	vadd.f32	s0, s0, s15
 801b0cc:	ee26 7a87 	vmul.f32	s14, s13, s14
            if (tremoloStereo)
 801b0d0:	681b      	ldr	r3, [r3, #0]
 801b0d2:	ee77 7ae6 	vsub.f32	s15, s15, s13
            float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
 801b0d6:	ee20 7a07 	vmul.f32	s14, s0, s14
 801b0da:	ee37 0a87 	vadd.f32	s0, s15, s14
            if (tremoloStereo)
 801b0de:	b9cb      	cbnz	r3, 801b114 <SFXRhodesTick+0x30c>
                rightSample *= ((tremoloSignal) + (1.0f - displayValues[1]));
 801b0e0:	ee29 9a00 	vmul.f32	s18, s18, s0
            leftSample *= displayValues[3]; //drive
 801b0e4:	ed98 8a03 	vldr	s16, [r8, #12]
 801b0e8:	ee68 9a29 	vmul.f32	s19, s16, s19
            leftSample = tanhf(leftSample);
 801b0ec:	ee29 0a80 	vmul.f32	s0, s19, s0
 801b0f0:	f00c fbac 	bl	802784c <tanhf>
 801b0f4:	eef0 8a40 	vmov.f32	s17, s0
            rightSample = tanhf(rightSample);
 801b0f8:	ee28 0a09 	vmul.f32	s0, s16, s18
 801b0fc:	f00c fba6 	bl	802784c <tanhf>
            input[0] = leftSample;
 801b100:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801b102:	edc3 8a00 	vstr	s17, [r3]
            input[1] = rightSample;
 801b106:	ed83 0a01 	vstr	s0, [r3, #4]
        }
 801b10a:	b00f      	add	sp, #60	; 0x3c
 801b10c:	ecbd 8b08 	vpop	{d8-d11}
 801b110:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                rightSample *= ((1.0f-tremoloSignal) + (1.0f - displayValues[1]));
 801b114:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 801b118:	ee77 6ae6 	vsub.f32	s13, s15, s13
 801b11c:	ee36 7ac7 	vsub.f32	s14, s13, s14
 801b120:	ee27 9a09 	vmul.f32	s18, s14, s18
 801b124:	e7de      	b.n	801b0e4 <SFXRhodesTick+0x2dc>
            for (int i = 0; i < numVoices; i++)
 801b126:	ed9f 9a07 	vldr	s18, [pc, #28]	; 801b144 <SFXRhodesTick+0x33c>
 801b12a:	f8df 804c 	ldr.w	r8, [pc, #76]	; 801b178 <SFXRhodesTick+0x370>
 801b12e:	eef0 9a49 	vmov.f32	s19, s18
 801b132:	e7bf      	b.n	801b0b4 <SFXRhodesTick+0x2ac>
 801b134:	200029d8 	.word	0x200029d8
 801b138:	200174d4 	.word	0x200174d4
 801b13c:	20000254 	.word	0x20000254
 801b140:	200033e4 	.word	0x200033e4
 801b144:	00000000 	.word	0x00000000
 801b148:	20000040 	.word	0x20000040
 801b14c:	200027c4 	.word	0x200027c4
 801b150:	200000b8 	.word	0x200000b8
 801b154:	20003428 	.word	0x20003428
 801b158:	20003420 	.word	0x20003420
 801b15c:	2000341c 	.word	0x2000341c
 801b160:	20003418 	.word	0x20003418
 801b164:	20003414 	.word	0x20003414
 801b168:	3ecccccd 	.word	0x3ecccccd
 801b16c:	200177a8 	.word	0x200177a8
 801b170:	2000061c 	.word	0x2000061c
 801b174:	200028f4 	.word	0x200028f4
 801b178:	200187dc 	.word	0x200187dc
 801b17c:	20000520 	.word	0x20000520
 801b180:	20000598 	.word	0x20000598

0801b184 <SFXRhodesFree>:
        {
 801b184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801b186:	2400      	movs	r4, #0
 801b188:	4f12      	ldr	r7, [pc, #72]	; (801b1d4 <SFXRhodesFree+0x50>)
 801b18a:	4e13      	ldr	r6, [pc, #76]	; (801b1d8 <SFXRhodesFree+0x54>)
 801b18c:	f104 0518 	add.w	r5, r4, #24
                    tCycle_free(&FM_sines[i][j]);
 801b190:	1938      	adds	r0, r7, r4
 801b192:	f009 fd6f 	bl	8024c74 <tCycle_free>
                    tADSR4_free(&FM_envs[i][j]);
 801b196:	1930      	adds	r0, r6, r4
 801b198:	3404      	adds	r4, #4
 801b19a:	f006 fe57 	bl	8021e4c <tADSR4_free>
                for (int j = 0; j < 6; j++)
 801b19e:	42ac      	cmp	r4, r5
 801b1a0:	d1f6      	bne.n	801b190 <SFXRhodesFree+0xc>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801b1a2:	2cc0      	cmp	r4, #192	; 0xc0
 801b1a4:	d1f2      	bne.n	801b18c <SFXRhodesFree+0x8>
                tExpSmooth_free(&susSmoothers[i]);
 801b1a6:	480d      	ldr	r0, [pc, #52]	; (801b1dc <SFXRhodesFree+0x58>)
 801b1a8:	f007 f9d4 	bl	8022554 <tExpSmooth_free>
 801b1ac:	480c      	ldr	r0, [pc, #48]	; (801b1e0 <SFXRhodesFree+0x5c>)
 801b1ae:	f007 f9d1 	bl	8022554 <tExpSmooth_free>
 801b1b2:	480c      	ldr	r0, [pc, #48]	; (801b1e4 <SFXRhodesFree+0x60>)
 801b1b4:	f007 f9ce 	bl	8022554 <tExpSmooth_free>
 801b1b8:	480b      	ldr	r0, [pc, #44]	; (801b1e8 <SFXRhodesFree+0x64>)
 801b1ba:	f007 f9cb 	bl	8022554 <tExpSmooth_free>
 801b1be:	480b      	ldr	r0, [pc, #44]	; (801b1ec <SFXRhodesFree+0x68>)
 801b1c0:	f007 f9c8 	bl	8022554 <tExpSmooth_free>
 801b1c4:	480a      	ldr	r0, [pc, #40]	; (801b1f0 <SFXRhodesFree+0x6c>)
 801b1c6:	f007 f9c5 	bl	8022554 <tExpSmooth_free>
            tCycle_free(&tremolo);
 801b1ca:	480a      	ldr	r0, [pc, #40]	; (801b1f4 <SFXRhodesFree+0x70>)
        }
 801b1cc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            tCycle_free(&tremolo);
 801b1d0:	f009 bd50 	b.w	8024c74 <tCycle_free>
 801b1d4:	20003414 	.word	0x20003414
 801b1d8:	200174d4 	.word	0x200174d4
 801b1dc:	200029d8 	.word	0x200029d8
 801b1e0:	200029dc 	.word	0x200029dc
 801b1e4:	200029e0 	.word	0x200029e0
 801b1e8:	200029e4 	.word	0x200029e4
 801b1ec:	200029e8 	.word	0x200029e8
 801b1f0:	200029ec 	.word	0x200029ec
 801b1f4:	200177a8 	.word	0x200177a8

0801b1f8 <calculateNoteArray>:
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801b1f8:	4b17      	ldr	r3, [pc, #92]	; (801b258 <calculateNoteArray+0x60>)
            for (int i = 0; i < 128; i++)
 801b1fa:	2100      	movs	r1, #0
 801b1fc:	4817      	ldr	r0, [pc, #92]	; (801b25c <calculateNoteArray+0x64>)
        {
 801b1fe:	b4f0      	push	{r4, r5, r6, r7}
 801b200:	4e17      	ldr	r6, [pc, #92]	; (801b260 <calculateNoteArray+0x68>)
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801b202:	781f      	ldrb	r7, [r3, #0]
 801b204:	4d17      	ldr	r5, [pc, #92]	; (801b264 <calculateNoteArray+0x6c>)
                float tempNote = i;
 801b206:	ee07 1a90 	vmov	s15, r1
            for (int i = 0; i < 128; i++)
 801b20a:	3101      	adds	r1, #1
                float tempNote = i;
 801b20c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            for (int i = 0; i < 128; i++)
 801b210:	2980      	cmp	r1, #128	; 0x80
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801b212:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801b216:	ee17 3a90 	vmov	r3, s15
 801b21a:	eba3 0307 	sub.w	r3, r3, r7
 801b21e:	fb85 2403 	smull	r2, r4, r5, r3
 801b222:	ea4f 72e3 	mov.w	r2, r3, asr #31
 801b226:	ebc2 0264 	rsb	r2, r2, r4, asr #1
 801b22a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 801b22e:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 801b232:	ee07 3a90 	vmov	s15, r3
 801b236:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801b23a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801b23e:	ee17 3a90 	vmov	r3, s15
 801b242:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 801b246:	edd3 7a00 	vldr	s15, [r3]
 801b24a:	ee77 7a87 	vadd.f32	s15, s15, s14
                notes[i] = tunedNote;
 801b24e:	ece0 7a01 	vstmia	r0!, {s15}
            for (int i = 0; i < 128; i++)
 801b252:	d1d8      	bne.n	801b206 <calculateNoteArray+0xe>
            }
        }
 801b254:	bcf0      	pop	{r4, r5, r6, r7}
 801b256:	4770      	bx	lr
 801b258:	20000668 	.word	0x20000668
 801b25c:	200029f0 	.word	0x200029f0
 801b260:	20000634 	.word	0x20000634
 801b264:	2aaaaaab 	.word	0x2aaaaaab

0801b268 <nearestNoteWithHysteresis>:

        int lastNearNote = -1;


        float nearestNoteWithHysteresis(float note, float hysteresis)
        {
 801b268:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            float leastDifference = fastabsf(note - notes[0]);
 801b26c:	4f75      	ldr	r7, [pc, #468]	; (801b444 <nearestNoteWithHysteresis+0x1dc>)
        {
 801b26e:	ed2d 8b04 	vpush	{d8-d9}
 801b272:	eef0 8a40 	vmov.f32	s17, s0
            float leastDifference = fastabsf(note - notes[0]);
 801b276:	ed97 0a00 	vldr	s0, [r7]
        {
 801b27a:	eeb0 9a60 	vmov.f32	s18, s1
            float leastDifference = fastabsf(note - notes[0]);
 801b27e:	ee38 0ac0 	vsub.f32	s0, s17, s0
 801b282:	f008 fd3d 	bl	8023d00 <fastabsf>
            float difference;
            int nearIndex = 0;
            int* chord;
            float output = 0.0f;

            if (autotuneChromatic > 0)
 801b286:	4b70      	ldr	r3, [pc, #448]	; (801b448 <nearestNoteWithHysteresis+0x1e0>)
            {
                chord = chromaticArray;
 801b288:	4970      	ldr	r1, [pc, #448]	; (801b44c <nearestNoteWithHysteresis+0x1e4>)
            float leastDifference = fastabsf(note - notes[0]);
 801b28a:	eeb0 8a40 	vmov.f32	s16, s0
            if (autotuneChromatic > 0)
 801b28e:	6818      	ldr	r0, [r3, #0]
            }
            else
            {
                chord = chordArray;
            }
            if (autotuneLock > 0)
 801b290:	4a6f      	ldr	r2, [pc, #444]	; (801b450 <nearestNoteWithHysteresis+0x1e8>)
                chord = chromaticArray;
 801b292:	4b70      	ldr	r3, [pc, #448]	; (801b454 <nearestNoteWithHysteresis+0x1ec>)
            if (autotuneLock > 0)
 801b294:	6812      	ldr	r2, [r2, #0]
                chord = chromaticArray;
 801b296:	2800      	cmp	r0, #0
 801b298:	bfd4      	ite	le
 801b29a:	4688      	movle	r8, r1
 801b29c:	4698      	movgt	r8, r3
            {
                chord = lockArray;
 801b29e:	4b6e      	ldr	r3, [pc, #440]	; (801b458 <nearestNoteWithHysteresis+0x1f0>)
 801b2a0:	2a00      	cmp	r2, #0
 801b2a2:	bfc8      	it	gt
 801b2a4:	4698      	movgt	r8, r3
            }
            int hasNotes = 0;
            for (int i = 0; i < 12; i++)
            {
                if (chord[i] > 0)
 801b2a6:	e9d8 3200 	ldrd	r3, r2, [r8]
 801b2aa:	f8d8 0008 	ldr.w	r0, [r8, #8]
 801b2ae:	2b00      	cmp	r3, #0
 801b2b0:	bfcc      	ite	gt
 801b2b2:	2301      	movgt	r3, #1
 801b2b4:	2300      	movle	r3, #0
                {
                    hasNotes = 1;
 801b2b6:	2a00      	cmp	r2, #0
                if (chord[i] > 0)
 801b2b8:	e9d8 1203 	ldrd	r1, r2, [r8, #12]
                    hasNotes = 1;
 801b2bc:	bfc8      	it	gt
 801b2be:	2301      	movgt	r3, #1
 801b2c0:	2800      	cmp	r0, #0
                if (chord[i] > 0)
 801b2c2:	f8d8 0014 	ldr.w	r0, [r8, #20]
                    hasNotes = 1;
 801b2c6:	bfc8      	it	gt
 801b2c8:	2301      	movgt	r3, #1
 801b2ca:	2900      	cmp	r1, #0
                if (chord[i] > 0)
 801b2cc:	f8d8 1018 	ldr.w	r1, [r8, #24]
                    hasNotes = 1;
 801b2d0:	bfc8      	it	gt
 801b2d2:	2301      	movgt	r3, #1
 801b2d4:	2a00      	cmp	r2, #0
                if (chord[i] > 0)
 801b2d6:	f8d8 201c 	ldr.w	r2, [r8, #28]
                    hasNotes = 1;
 801b2da:	bfc8      	it	gt
 801b2dc:	2301      	movgt	r3, #1
 801b2de:	2800      	cmp	r0, #0
                if (chord[i] > 0)
 801b2e0:	f8d8 0020 	ldr.w	r0, [r8, #32]
                    hasNotes = 1;
 801b2e4:	bfc8      	it	gt
 801b2e6:	2301      	movgt	r3, #1
 801b2e8:	2900      	cmp	r1, #0
                if (chord[i] > 0)
 801b2ea:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
                    hasNotes = 1;
 801b2ee:	bfc8      	it	gt
 801b2f0:	2301      	movgt	r3, #1
 801b2f2:	2a00      	cmp	r2, #0
                if (chord[i] > 0)
 801b2f4:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
                    hasNotes = 1;
 801b2f8:	bfc8      	it	gt
 801b2fa:	2301      	movgt	r3, #1
 801b2fc:	2800      	cmp	r0, #0
 801b2fe:	bfc8      	it	gt
 801b300:	2301      	movgt	r3, #1
 801b302:	2900      	cmp	r1, #0
 801b304:	bfc8      	it	gt
 801b306:	2301      	movgt	r3, #1
                if (chord[i] > 0)
 801b308:	2a00      	cmp	r2, #0
 801b30a:	f340 808d 	ble.w	801b428 <nearestNoteWithHysteresis+0x1c0>
 801b30e:	4d53      	ldr	r5, [pc, #332]	; (801b45c <nearestNoteWithHysteresis+0x1f4>)

            }
            if (hasNotes)
            {

                for(int i = 1; i < 128; i++)
 801b310:	2401      	movs	r4, #1
            int nearIndex = 0;
 801b312:	2600      	movs	r6, #0
                {
                    if (chord[i%12] > 0)
 801b314:	f8df 914c 	ldr.w	r9, [pc, #332]	; 801b464 <nearestNoteWithHysteresis+0x1fc>
 801b318:	e003      	b.n	801b322 <nearestNoteWithHysteresis+0xba>
                for(int i = 1; i < 128; i++)
 801b31a:	3401      	adds	r4, #1
 801b31c:	3504      	adds	r5, #4
 801b31e:	2c80      	cmp	r4, #128	; 0x80
 801b320:	d01c      	beq.n	801b35c <nearestNoteWithHysteresis+0xf4>
                    if (chord[i%12] > 0)
 801b322:	fba9 2304 	umull	r2, r3, r9, r4
 801b326:	08db      	lsrs	r3, r3, #3
 801b328:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801b32c:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
 801b330:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 801b334:	2b00      	cmp	r3, #0
 801b336:	ddf0      	ble.n	801b31a <nearestNoteWithHysteresis+0xb2>
                    {
                        difference = fastabsf(note - notes[i]);
 801b338:	ed95 0a00 	vldr	s0, [r5]
 801b33c:	ee38 0ac0 	vsub.f32	s0, s17, s0
 801b340:	f008 fcde 	bl	8023d00 <fastabsf>
                        if(difference < leastDifference)
 801b344:	eeb4 0ac8 	vcmpe.f32	s0, s16
 801b348:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b34c:	d5e5      	bpl.n	801b31a <nearestNoteWithHysteresis+0xb2>
 801b34e:	4626      	mov	r6, r4
                for(int i = 1; i < 128; i++)
 801b350:	3401      	adds	r4, #1
                        {
                            leastDifference = difference;
 801b352:	eeb0 8a40 	vmov.f32	s16, s0
 801b356:	3504      	adds	r5, #4
                for(int i = 1; i < 128; i++)
 801b358:	2c80      	cmp	r4, #128	; 0x80
 801b35a:	d1e2      	bne.n	801b322 <nearestNoteWithHysteresis+0xba>
                            nearIndex = i;
                        }
                    }
                }

                if (lastNearNote == -1)
 801b35c:	4840      	ldr	r0, [pc, #256]	; (801b460 <nearestNoteWithHysteresis+0x1f8>)
 801b35e:	6801      	ldr	r1, [r0, #0]
 801b360:	1c4b      	adds	r3, r1, #1
 801b362:	d058      	beq.n	801b416 <nearestNoteWithHysteresis+0x1ae>
 801b364:	eb07 0381 	add.w	r3, r7, r1, lsl #2
                {
                    output = notes[nearIndex];
                    lastNearNote = nearIndex;
                    return output;
                }
                if (nearIndex != lastNearNote)
 801b368:	42b1      	cmp	r1, r6
 801b36a:	ed93 0a00 	vldr	s0, [r3]
 801b36e:	d057      	beq.n	801b420 <nearestNoteWithHysteresis+0x1b8>
 801b370:	460b      	mov	r3, r1
                {
                    //check if it's beyond the hysteresis

                    //find closest note in chord upward from lastNearNote
                    int upNote = 0;
 801b372:	2400      	movs	r4, #0
                    int downNote = 128;
                    int i = lastNearNote;
                    while ((i < 128) && (upNote == 0))
                    {
                        i++;
                        if (chord[i%12] > 0)
 801b374:	f8df c0f0 	ldr.w	ip, [pc, #240]	; 801b468 <nearestNoteWithHysteresis+0x200>
 801b378:	e00f      	b.n	801b39a <nearestNoteWithHysteresis+0x132>
 801b37a:	ebc2 0265 	rsb	r2, r2, r5, asr #1
                    while ((i < 128) && (upNote == 0))
 801b37e:	b9a4      	cbnz	r4, 801b3aa <nearestNoteWithHysteresis+0x142>
                        if (chord[i%12] > 0)
 801b380:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 801b384:	eba3 0282 	sub.w	r2, r3, r2, lsl #2
 801b388:	f858 2022 	ldr.w	r2, [r8, r2, lsl #2]
 801b38c:	2a00      	cmp	r2, #0
 801b38e:	bfcc      	ite	gt
 801b390:	461c      	movgt	r4, r3
 801b392:	2400      	movle	r4, #0
                        {
                            upNote = i;
                        }
                        if (i == 128)
                        {
                            upNote = 128;
 801b394:	2b80      	cmp	r3, #128	; 0x80
 801b396:	bf08      	it	eq
 801b398:	461c      	moveq	r4, r3
                    while ((i < 128) && (upNote == 0))
 801b39a:	2b7f      	cmp	r3, #127	; 0x7f
                        i++;
 801b39c:	f103 0301 	add.w	r3, r3, #1
                        if (chord[i%12] > 0)
 801b3a0:	fb8c 2503 	smull	r2, r5, ip, r3
 801b3a4:	ea4f 72e3 	mov.w	r2, r3, asr #31
                    while ((i < 128) && (upNote == 0))
 801b3a8:	dde7      	ble.n	801b37a <nearestNoteWithHysteresis+0x112>
                    int downNote = 128;
 801b3aa:	2280      	movs	r2, #128	; 0x80
                    }
                    i = lastNearNote;
                    while ((i > 0) && (downNote == 128))
                    {
                        i--;
                        if (chord[i%12] > 0)
 801b3ac:	4d2d      	ldr	r5, [pc, #180]	; (801b464 <nearestNoteWithHysteresis+0x1fc>)
 801b3ae:	e010      	b.n	801b3d2 <nearestNoteWithHysteresis+0x16a>
                    while ((i > 0) && (downNote == 128))
 801b3b0:	2a80      	cmp	r2, #128	; 0x80
                        if (chord[i%12] > 0)
 801b3b2:	ea4f 03d3 	mov.w	r3, r3, lsr #3
                    while ((i > 0) && (downNote == 128))
 801b3b6:	d112      	bne.n	801b3de <nearestNoteWithHysteresis+0x176>
                        if (chord[i%12] > 0)
 801b3b8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801b3bc:	eba1 0383 	sub.w	r3, r1, r3, lsl #2
 801b3c0:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 801b3c4:	2b00      	cmp	r3, #0
 801b3c6:	bfcc      	ite	gt
 801b3c8:	460a      	movgt	r2, r1
 801b3ca:	2280      	movle	r2, #128	; 0x80
                        {
                            downNote = i;
                        }
                        if (i == 0)
                        {
                            downNote = 0;
 801b3cc:	2900      	cmp	r1, #0
 801b3ce:	bf08      	it	eq
 801b3d0:	460a      	moveq	r2, r1
                    while ((i > 0) && (downNote == 128))
 801b3d2:	2900      	cmp	r1, #0
                        i--;
 801b3d4:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
                        if (chord[i%12] > 0)
 801b3d8:	fba5 c301 	umull	ip, r3, r5, r1
                    while ((i > 0) && (downNote == 128))
 801b3dc:	dce8      	bgt.n	801b3b0 <nearestNoteWithHysteresis+0x148>
                        }
                    }
                    //now should have adjacent notes in array available
                    //calculate the differences that should be necessary to move away
                    float upperNearHyst = (notes[upNote] - notes[lastNearNote]) * hysteresis;
                    float lowerNearHyst = (notes[lastNearNote] - notes[downNote]) * -hysteresis;
 801b3de:	eb07 0282 	add.w	r2, r7, r2, lsl #2

                    float theDifference = note - notes[lastNearNote];
 801b3e2:	ee78 8ac0 	vsub.f32	s17, s17, s0
                    float lowerNearHyst = (notes[lastNearNote] - notes[downNote]) * -hysteresis;
 801b3e6:	edd2 7a00 	vldr	s15, [r2]
 801b3ea:	ee70 7a67 	vsub.f32	s15, s0, s15
                    if ((theDifference > upperNearHyst) || (theDifference < lowerNearHyst))
 801b3ee:	ee69 7a67 	vnmul.f32	s15, s18, s15
 801b3f2:	eef4 7ae8 	vcmpe.f32	s15, s17
 801b3f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b3fa:	dc0c      	bgt.n	801b416 <nearestNoteWithHysteresis+0x1ae>
                    float upperNearHyst = (notes[upNote] - notes[lastNearNote]) * hysteresis;
 801b3fc:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 801b400:	edd4 7a00 	vldr	s15, [r4]
 801b404:	ee77 7ac0 	vsub.f32	s15, s15, s0
 801b408:	ee27 9a89 	vmul.f32	s18, s15, s18
                    if ((theDifference > upperNearHyst) || (theDifference < lowerNearHyst))
 801b40c:	eeb4 9a68 	vcmp.f32	s18, s17
 801b410:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b414:	d504      	bpl.n	801b420 <nearestNoteWithHysteresis+0x1b8>
                    {
                        output = notes[nearIndex];
 801b416:	eb07 0786 	add.w	r7, r7, r6, lsl #2
                        lastNearNote = nearIndex;
 801b41a:	6006      	str	r6, [r0, #0]
                        output = notes[nearIndex];
 801b41c:	ed97 0a00 	vldr	s0, [r7]
            else
            {
                output = -1.0f; //signal that there are no notes to snap to
            }
            return output;
        }
 801b420:	ecbd 8b04 	vpop	{d8-d9}
 801b424:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (chord[i] > 0)
 801b428:	f8d8 202c 	ldr.w	r2, [r8, #44]	; 0x2c
 801b42c:	2a00      	cmp	r2, #0
 801b42e:	f73f af6e 	bgt.w	801b30e <nearestNoteWithHysteresis+0xa6>
            if (hasNotes)
 801b432:	2b00      	cmp	r3, #0
 801b434:	f47f af6b 	bne.w	801b30e <nearestNoteWithHysteresis+0xa6>
                output = -1.0f; //signal that there are no notes to snap to
 801b438:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
        }
 801b43c:	ecbd 8b04 	vpop	{d8-d9}
 801b440:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801b444:	200029f0 	.word	0x200029f0
 801b448:	2000052c 	.word	0x2000052c
 801b44c:	20000540 	.word	0x20000540
 801b450:	20000530 	.word	0x20000530
 801b454:	200001f4 	.word	0x200001f4
 801b458:	200005b8 	.word	0x200005b8
 801b45c:	200029f4 	.word	0x200029f4
 801b460:	2000024c 	.word	0x2000024c
 801b464:	aaaaaaab 	.word	0xaaaaaaab
 801b468:	2aaaaaab 	.word	0x2aaaaaab
 801b46c:	00000000 	.word	0x00000000

0801b470 <SFXNeartuneTick>:
        {
 801b470:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b472:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801b476:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 801b47a:	4d75      	ldr	r5, [pc, #468]	; (801b650 <SFXNeartuneTick+0x1e0>)
 801b47c:	eddf 7a75 	vldr	s15, [pc, #468]	; 801b654 <SFXNeartuneTick+0x1e4>
        {
 801b480:	b083      	sub	sp, #12
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801b482:	ed95 7a4b 	vldr	s14, [r5, #300]	; 0x12c
        {
 801b486:	4606      	mov	r6, r0
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801b488:	eef0 6a48 	vmov.f32	s13, s16
 801b48c:	4c72      	ldr	r4, [pc, #456]	; (801b658 <SFXNeartuneTick+0x1e8>)
            tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
 801b48e:	4873      	ldr	r0, [pc, #460]	; (801b65c <SFXNeartuneTick+0x1ec>)
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801b490:	eee7 6a27 	vfma.f32	s13, s14, s15
            tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
 801b494:	eeb0 0a66 	vmov.f32	s0, s13
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801b498:	edc4 6a00 	vstr	s13, [r4]
            tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
 801b49c:	f005 ff6e 	bl	802137c <tRetune_setFidelityThreshold>
            displayValues[1] = LEAF_clip(0.0f, presetKnobValues[AutotuneMono][1] * 1.1f, 1.0f); // amount of forcing to new pitch
 801b4a0:	eddf 7a6f 	vldr	s15, [pc, #444]	; 801b660 <SFXNeartuneTick+0x1f0>
 801b4a4:	edd5 0a4c 	vldr	s1, [r5, #304]	; 0x130
 801b4a8:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 801b4ac:	ed9f 0a6d 	vldr	s0, [pc, #436]	; 801b664 <SFXNeartuneTick+0x1f4>
 801b4b0:	ee60 0aa7 	vmul.f32	s1, s1, s15
 801b4b4:	f008 fcfe 	bl	8023eb4 <LEAF_clip>
            displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
 801b4b8:	eef2 5a08 	vmov.f32	s11, #40	; 0x41400000  12.0
 801b4bc:	edd5 7a4e 	vldr	s15, [r5, #312]	; 0x138
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
 801b4c0:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
            displayValues[2] = presetKnobValues[AutotuneMono][2]; //speed to get to desired pitch shift
 801b4c4:	edd5 6a4d 	vldr	s13, [r5, #308]	; 0x134
            displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
 801b4c8:	ee67 7aa5 	vmul.f32	s15, s15, s11
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
 801b4cc:	ed95 7a4f 	vldr	s14, [r5, #316]	; 0x13c
            if (displayValues[2] > .90f)
 801b4d0:	eddf 5a65 	vldr	s11, [pc, #404]	; 801b668 <SFXNeartuneTick+0x1f8>
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
 801b4d4:	ee37 7a06 	vadd.f32	s14, s14, s12
            displayValues[1] = LEAF_clip(0.0f, presetKnobValues[AutotuneMono][1] * 1.1f, 1.0f); // amount of forcing to new pitch
 801b4d8:	ed84 0a01 	vstr	s0, [r4, #4]
            if (displayValues[2] > .90f)
 801b4dc:	eef4 6ae5 	vcmpe.f32	s13, s11
            displayValues[2] = presetKnobValues[AutotuneMono][2]; //speed to get to desired pitch shift
 801b4e0:	edc4 6a02 	vstr	s13, [r4, #8]
            displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
 801b4e4:	edc4 7a03 	vstr	s15, [r4, #12]
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
 801b4e8:	ee27 7a08 	vmul.f32	s14, s14, s16
            if (displayValues[2] > .90f)
 801b4ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
 801b4f0:	ed84 7a04 	vstr	s14, [r4, #16]
            if (displayValues[2] > .90f)
 801b4f4:	f300 8084 	bgt.w	801b600 <SFXNeartuneTick+0x190>
 801b4f8:	ee66 7aa6 	vmul.f32	s15, s13, s13
 801b4fc:	ee67 7aa6 	vmul.f32	s15, s15, s13
            tExpSmooth_setFactor(&neartune_smoother, expBuffer[(int)(displayValues[2] * displayValues[2] * displayValues[2] * expBufferSizeMinusOne)]);
 801b500:	4a5a      	ldr	r2, [pc, #360]	; (801b66c <SFXNeartuneTick+0x1fc>)
 801b502:	4b5b      	ldr	r3, [pc, #364]	; (801b670 <SFXNeartuneTick+0x200>)
 801b504:	ed92 7a00 	vldr	s14, [r2]
 801b508:	485a      	ldr	r0, [pc, #360]	; (801b674 <SFXNeartuneTick+0x204>)
 801b50a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801b50e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801b512:	ee17 2a90 	vmov	r2, s15
 801b516:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801b51a:	ed93 0a00 	vldr	s0, [r3]
 801b51e:	f007 f81d 	bl	802255c <tExpSmooth_setFactor>
            float destFactor = tExpSmooth_tick(&neartune_smoother);
 801b522:	4854      	ldr	r0, [pc, #336]	; (801b674 <SFXNeartuneTick+0x204>)
 801b524:	f007 f836 	bl	8022594 <tExpSmooth_tick>
            float detectedPeriod = tRetune_getInputPeriod(&autotuneMono);
 801b528:	484c      	ldr	r0, [pc, #304]	; (801b65c <SFXNeartuneTick+0x1ec>)
            float destFactor = tExpSmooth_tick(&neartune_smoother);
 801b52a:	eef0 8a40 	vmov.f32	s17, s0
            float detectedPeriod = tRetune_getInputPeriod(&autotuneMono);
 801b52e:	f005 ff29 	bl	8021384 <tRetune_getInputPeriod>
            if (detectedPeriod > 0.0f)
 801b532:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801b536:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b53a:	dd3b      	ble.n	801b5b4 <SFXNeartuneTick+0x144>
                detectedNote = LEAF_frequencyToMidi(1.0f / detectedPeriod);
 801b53c:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 801b540:	4d4d      	ldr	r5, [pc, #308]	; (801b678 <SFXNeartuneTick+0x208>)
 801b542:	ee88 0a00 	vdiv.f32	s0, s16, s0
 801b546:	f008 fc47 	bl	8023dd8 <LEAF_frequencyToMidi>
                desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
 801b54a:	edd4 0a04 	vldr	s1, [r4, #16]
                detectedNote = LEAF_frequencyToMidi(1.0f / detectedPeriod);
 801b54e:	ed85 0a00 	vstr	s0, [r5]
                desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
 801b552:	f7ff fe89 	bl	801b268 <nearestNoteWithHysteresis>
 801b556:	4b49      	ldr	r3, [pc, #292]	; (801b67c <SFXNeartuneTick+0x20c>)
                if (desiredSnap > 0.0f)
 801b558:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
                desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
 801b55c:	ed83 0a00 	vstr	s0, [r3]
                if (desiredSnap > 0.0f)
 801b560:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b564:	dd68      	ble.n	801b638 <SFXNeartuneTick+0x1c8>
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801b566:	edd4 6a01 	vldr	s13, [r4, #4]
 801b56a:	edd5 7a00 	vldr	s15, [r5]
 801b56e:	ee38 8a66 	vsub.f32	s16, s16, s13
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801b572:	4c43      	ldr	r4, [pc, #268]	; (801b680 <SFXNeartuneTick+0x210>)
                    changeAmount = (fabsf(destinationNote-detectedNote));
 801b574:	4a43      	ldr	r2, [pc, #268]	; (801b684 <SFXNeartuneTick+0x214>)
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801b576:	ed94 7a00 	vldr	s14, [r4]
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801b57a:	ee28 8a27 	vmul.f32	s16, s16, s15
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801b57e:	4b42      	ldr	r3, [pc, #264]	; (801b688 <SFXNeartuneTick+0x218>)
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801b580:	4f42      	ldr	r7, [pc, #264]	; (801b68c <SFXNeartuneTick+0x21c>)
 801b582:	eea0 8a26 	vfma.f32	s16, s0, s13
                    if ((changeAmount < 11.9))
 801b586:	ed9f 6b30 	vldr	d6, [pc, #192]	; 801b648 <SFXNeartuneTick+0x1d8>
                    changeAmount = (fabsf(destinationNote-detectedNote));
 801b58a:	ee78 7a67 	vsub.f32	s15, s16, s15
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801b58e:	ed87 8a00 	vstr	s16, [r7]
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801b592:	ee38 7a47 	vsub.f32	s14, s16, s14
                    changeAmount = (fabsf(destinationNote-detectedNote));
 801b596:	eef0 7ae7 	vabs.f32	s15, s15
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801b59a:	eeb0 7ac7 	vabs.f32	s14, s14
                    if ((changeAmount < 11.9))
 801b59e:	eeb7 5ae7 	vcvt.f64.f32	d5, s15
                    changeAmount = (fabsf(destinationNote-detectedNote));
 801b5a2:	edc2 7a00 	vstr	s15, [r2]
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801b5a6:	ed83 7a00 	vstr	s14, [r3]
                    if ((changeAmount < 11.9))
 801b5aa:	eeb4 5bc6 	vcmpe.f64	d5, d6
 801b5ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b5b2:	d42a      	bmi.n	801b60a <SFXNeartuneTick+0x19a>
            tRetune_setPitchFactor(&autotuneMono, destFactor, 0);
 801b5b4:	2100      	movs	r1, #0
 801b5b6:	eeb0 0a68 	vmov.f32	s0, s17
 801b5ba:	4828      	ldr	r0, [pc, #160]	; (801b65c <SFXNeartuneTick+0x1ec>)
 801b5bc:	f005 fecc 	bl	8021358 <tRetune_setPitchFactor>
            float* samples = tRetune_tick(&autotuneMono, input[1]);
 801b5c0:	ed96 0a01 	vldr	s0, [r6, #4]
 801b5c4:	4825      	ldr	r0, [pc, #148]	; (801b65c <SFXNeartuneTick+0x1ec>)
 801b5c6:	f005 fdf3 	bl	80211b0 <tRetune_tick>
 801b5ca:	4604      	mov	r4, r0
            LEAF_crossfade(tRamp_tick(&nearWetRamp), fades);
 801b5cc:	4830      	ldr	r0, [pc, #192]	; (801b690 <SFXNeartuneTick+0x220>)
 801b5ce:	f006 ff45 	bl	802245c <tRamp_tick>
 801b5d2:	4668      	mov	r0, sp
 801b5d4:	f008 fbea 	bl	8023dac <LEAF_crossfade>
            sample += input[1] * fades[1]; // crossfade to dry signal if no notes held down.
 801b5d8:	edd6 7a01 	vldr	s15, [r6, #4]
 801b5dc:	ed9d 7a01 	vldr	s14, [sp, #4]
 801b5e0:	edd4 6a00 	vldr	s13, [r4]
 801b5e4:	ee67 7a87 	vmul.f32	s15, s15, s14
 801b5e8:	ed9d 7a00 	vldr	s14, [sp]
 801b5ec:	eee6 7a87 	vfma.f32	s15, s13, s14
            input[0] = sample;
 801b5f0:	edc6 7a00 	vstr	s15, [r6]
            input[1] = sample;
 801b5f4:	edc6 7a01 	vstr	s15, [r6, #4]
        }
 801b5f8:	b003      	add	sp, #12
 801b5fa:	ecbd 8b02 	vpop	{d8}
 801b5fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
                displayValues[2] = 1.0f;
 801b600:	eef0 7a46 	vmov.f32	s15, s12
 801b604:	ed84 6a02 	vstr	s12, [r4, #8]
 801b608:	e77a      	b.n	801b500 <SFXNeartuneTick+0x90>
                        destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
 801b60a:	eeb0 0a48 	vmov.f32	s0, s16
 801b60e:	f008 fd3d 	bl	802408c <LEAF_midiToFrequency>
 801b612:	eeb0 8a40 	vmov.f32	s16, s0
 801b616:	ed95 0a00 	vldr	s0, [r5]
 801b61a:	f008 fd37 	bl	802408c <LEAF_midiToFrequency>
 801b61e:	4b1d      	ldr	r3, [pc, #116]	; (801b694 <SFXNeartuneTick+0x224>)
 801b620:	eec8 7a00 	vdiv.f32	s15, s16, s0
                        tExpSmooth_setDest(&neartune_smoother, destinationFactor);
 801b624:	4813      	ldr	r0, [pc, #76]	; (801b674 <SFXNeartuneTick+0x204>)
 801b626:	eeb0 0a67 	vmov.f32	s0, s15
                        destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
 801b62a:	edc3 7a00 	vstr	s15, [r3]
                        tExpSmooth_setDest(&neartune_smoother, destinationFactor);
 801b62e:	f006 ffa7 	bl	8022580 <tExpSmooth_setDest>
                        lastSnap = destinationNote;
 801b632:	683b      	ldr	r3, [r7, #0]
 801b634:	6023      	str	r3, [r4, #0]
 801b636:	e7bd      	b.n	801b5b4 <SFXNeartuneTick+0x144>
                    tExpSmooth_setDest(&neartune_smoother, 1.0f);
 801b638:	eeb0 0a48 	vmov.f32	s0, s16
 801b63c:	480d      	ldr	r0, [pc, #52]	; (801b674 <SFXNeartuneTick+0x204>)
 801b63e:	f006 ff9f 	bl	8022580 <tExpSmooth_setDest>
 801b642:	e7b7      	b.n	801b5b4 <SFXNeartuneTick+0x144>
 801b644:	f3af 8000 	nop.w
 801b648:	cccccccd 	.word	0xcccccccd
 801b64c:	4027cccc 	.word	0x4027cccc
 801b650:	20002cb8 	.word	0x20002cb8
 801b654:	3efae148 	.word	0x3efae148
 801b658:	200187dc 	.word	0x200187dc
 801b65c:	200174c0 	.word	0x200174c0
 801b660:	3f8ccccd 	.word	0x3f8ccccd
 801b664:	00000000 	.word	0x00000000
 801b668:	3f666666 	.word	0x3f666666
 801b66c:	2000023c 	.word	0x2000023c
 801b670:	20016fec 	.word	0x20016fec
 801b674:	20017594 	.word	0x20017594
 801b678:	20000234 	.word	0x20000234
 801b67c:	20000228 	.word	0x20000228
 801b680:	20000250 	.word	0x20000250
 801b684:	2000053c 	.word	0x2000053c
 801b688:	20000590 	.word	0x20000590
 801b68c:	20000230 	.word	0x20000230
 801b690:	200183ac 	.word	0x200183ac
 801b694:	2000022c 	.word	0x2000022c

0801b698 <noteOff>:
            }
        }

        void noteOff(int key, int velocity)
        {
            if (chordArray[key%12] > 0) chordArray[key%12]--;
 801b698:	4a4e      	ldr	r2, [pc, #312]	; (801b7d4 <noteOff+0x13c>)
 801b69a:	494f      	ldr	r1, [pc, #316]	; (801b7d8 <noteOff+0x140>)
 801b69c:	fb82 3200 	smull	r3, r2, r2, r0
 801b6a0:	17c3      	asrs	r3, r0, #31
 801b6a2:	ebc3 0362 	rsb	r3, r3, r2, asr #1
 801b6a6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801b6aa:	eba0 0383 	sub.w	r3, r0, r3, lsl #2
        {
 801b6ae:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            if (chordArray[key%12] > 0) chordArray[key%12]--;
 801b6b2:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
        {
 801b6b6:	4604      	mov	r4, r0
            if (chordArray[key%12] > 0) chordArray[key%12]--;
 801b6b8:	2a00      	cmp	r2, #0
 801b6ba:	dd02      	ble.n	801b6c2 <noteOff+0x2a>
 801b6bc:	3a01      	subs	r2, #1
 801b6be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]



            if (currentPreset == Rhodes)
 801b6c2:	4b46      	ldr	r3, [pc, #280]	; (801b7dc <noteOff+0x144>)
 801b6c4:	781b      	ldrb	r3, [r3, #0]
 801b6c6:	2b11      	cmp	r3, #17
 801b6c8:	d03c      	beq.n	801b744 <noteOff+0xac>
                        tADSR4_off(&FM_envs[voice][j]);
                    }
                }

            }
            else if (currentPreset == ClassicSynth)
 801b6ca:	2b10      	cmp	r3, #16
 801b6cc:	d057      	beq.n	801b77e <noteOff+0xe6>
                    tADSR4_off(&polyEnvs[voice]);
                    tADSR4_off(&polyFiltEnvs[voice]);
                }
            }

            else if (currentPreset == SamplerKeyboard)
 801b6ce:	2b06      	cmp	r3, #6
 801b6d0:	d00c      	beq.n	801b6ec <noteOff+0x54>
                    UISamplerKButtons(ButtonC, ActionHoldContinuous);
                    tSampler_stop(&keySampler[key-LOWEST_SAMPLER_KEY]);
                    waitingForDeactivation[voice] = key;
                }
            }
            else if (currentPreset == LivingStringSynth)
 801b6d2:	2b0f      	cmp	r3, #15
 801b6d4:	b2e1      	uxtb	r1, r4
            {
                int voice;

                voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
 801b6d6:	4842      	ldr	r0, [pc, #264]	; (801b7e0 <noteOff+0x148>)
            else if (currentPreset == LivingStringSynth)
 801b6d8:	d066      	beq.n	801b7a8 <noteOff+0x110>
                    tADSR4_off(&pluckEnvs[voice]);
                }
            }
            else
            {
                tSimplePoly_noteOff(&poly, key);
 801b6da:	f009 f915 	bl	8024908 <tSimplePoly_noteOff>
            }

            if (tSimplePoly_getNumActiveVoices(&poly) < 1)
 801b6de:	4840      	ldr	r0, [pc, #256]	; (801b7e0 <noteOff+0x148>)
 801b6e0:	f009 fa76 	bl	8024bd0 <tSimplePoly_getNumActiveVoices>
 801b6e4:	2800      	cmp	r0, #0
 801b6e6:	dd28      	ble.n	801b73a <noteOff+0xa2>
            {
                setLED_2(0);
            }

        }
 801b6e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                if (key >= LOWEST_SAMPLER_KEY && key < LOWEST_SAMPLER_KEY + NUM_SAMPLER_KEYS)
 801b6ec:	f1a4 0524 	sub.w	r5, r4, #36	; 0x24
 801b6f0:	2d30      	cmp	r5, #48	; 0x30
 801b6f2:	d8f4      	bhi.n	801b6de <noteOff+0x46>
 801b6f4:	00af      	lsls	r7, r5, #2
                    if (tBuffer_isActive(&keyBuff[key-LOWEST_SAMPLER_KEY]) == 1)
 801b6f6:	4e3b      	ldr	r6, [pc, #236]	; (801b7e4 <noteOff+0x14c>)
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801b6f8:	b2e1      	uxtb	r1, r4
 801b6fa:	4839      	ldr	r0, [pc, #228]	; (801b7e0 <noteOff+0x148>)
                    if (tBuffer_isActive(&keyBuff[key-LOWEST_SAMPLER_KEY]) == 1)
 801b6fc:	443e      	add	r6, r7
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801b6fe:	f009 f9ef 	bl	8024ae0 <tSimplePoly_markPendingNoteOff>
 801b702:	4680      	mov	r8, r0
                    if (tBuffer_isActive(&keyBuff[key-LOWEST_SAMPLER_KEY]) == 1)
 801b704:	4630      	mov	r0, r6
 801b706:	f00a fe37 	bl	8026378 <tBuffer_isActive>
 801b70a:	2801      	cmp	r0, #1
 801b70c:	d059      	beq.n	801b7c2 <noteOff+0x12a>
                        tExpSmooth_setDest(&kSamplerGains[key-LOWEST_SAMPLER_KEY], 0.0f);
 801b70e:	4836      	ldr	r0, [pc, #216]	; (801b7e8 <noteOff+0x150>)
 801b710:	ed9f 0a36 	vldr	s0, [pc, #216]	; 801b7ec <noteOff+0x154>
 801b714:	4438      	add	r0, r7
 801b716:	f006 ff33 	bl	8022580 <tExpSmooth_setDest>
                    samplerKeyHeld[key-LOWEST_SAMPLER_KEY] = 0;
 801b71a:	4b35      	ldr	r3, [pc, #212]	; (801b7f0 <noteOff+0x158>)
 801b71c:	2200      	movs	r2, #0
                    UISamplerKButtons(ButtonC, ActionHoldContinuous);
 801b71e:	2103      	movs	r1, #3
 801b720:	2007      	movs	r0, #7
                    samplerKeyHeld[key-LOWEST_SAMPLER_KEY] = 0;
 801b722:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
                    UISamplerKButtons(ButtonC, ActionHoldContinuous);
 801b726:	f002 f89d 	bl	801d864 <UISamplerKButtons>
                    tSampler_stop(&keySampler[key-LOWEST_SAMPLER_KEY]);
 801b72a:	4832      	ldr	r0, [pc, #200]	; (801b7f4 <noteOff+0x15c>)
 801b72c:	4438      	add	r0, r7
 801b72e:	f00a feed 	bl	802650c <tSampler_stop>
                    waitingForDeactivation[voice] = key;
 801b732:	4b31      	ldr	r3, [pc, #196]	; (801b7f8 <noteOff+0x160>)
 801b734:	f843 4028 	str.w	r4, [r3, r8, lsl #2]
 801b738:	e7d1      	b.n	801b6de <noteOff+0x46>
                setLED_2(0);
 801b73a:	2000      	movs	r0, #0
        }
 801b73c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
                setLED_2(0);
 801b740:	f7f8 b8f4 	b.w	801392c <setLED_2>
                if (tSimplePoly_getNumVoices(&poly) > 1)
 801b744:	4826      	ldr	r0, [pc, #152]	; (801b7e0 <noteOff+0x148>)
 801b746:	f009 fa3f 	bl	8024bc8 <tSimplePoly_getNumVoices>
 801b74a:	2801      	cmp	r0, #1
 801b74c:	b2e1      	uxtb	r1, r4
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801b74e:	4824      	ldr	r0, [pc, #144]	; (801b7e0 <noteOff+0x148>)
                if (tSimplePoly_getNumVoices(&poly) > 1)
 801b750:	dd12      	ble.n	801b778 <noteOff+0xe0>
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801b752:	f009 f9c5 	bl	8024ae0 <tSimplePoly_markPendingNoteOff>
                if (voice >= 0)
 801b756:	2800      	cmp	r0, #0
 801b758:	dbc1      	blt.n	801b6de <noteOff+0x46>
 801b75a:	4c28      	ldr	r4, [pc, #160]	; (801b7fc <noteOff+0x164>)
 801b75c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 801b760:	f104 0518 	add.w	r5, r4, #24
 801b764:	00c0      	lsls	r0, r0, #3
 801b766:	4404      	add	r4, r0
 801b768:	4405      	add	r5, r0
                        tADSR4_off(&FM_envs[voice][j]);
 801b76a:	4620      	mov	r0, r4
 801b76c:	3404      	adds	r4, #4
 801b76e:	f006 fbc7 	bl	8021f00 <tADSR4_off>
                    for (int j = 0; j < 6; j++)
 801b772:	42a5      	cmp	r5, r4
 801b774:	d1f9      	bne.n	801b76a <noteOff+0xd2>
 801b776:	e7b2      	b.n	801b6de <noteOff+0x46>
                    voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
 801b778:	f009 f8c6 	bl	8024908 <tSimplePoly_noteOff>
 801b77c:	e7eb      	b.n	801b756 <noteOff+0xbe>
                if (tSimplePoly_getNumVoices(&poly) > 1)
 801b77e:	4818      	ldr	r0, [pc, #96]	; (801b7e0 <noteOff+0x148>)
 801b780:	f009 fa22 	bl	8024bc8 <tSimplePoly_getNumVoices>
 801b784:	2801      	cmp	r0, #1
 801b786:	b2e1      	uxtb	r1, r4
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801b788:	4815      	ldr	r0, [pc, #84]	; (801b7e0 <noteOff+0x148>)
                if (tSimplePoly_getNumVoices(&poly) > 1)
 801b78a:	dd17      	ble.n	801b7bc <noteOff+0x124>
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801b78c:	f009 f9a8 	bl	8024ae0 <tSimplePoly_markPendingNoteOff>
                if (voice >= 0)
 801b790:	2800      	cmp	r0, #0
 801b792:	dba4      	blt.n	801b6de <noteOff+0x46>
 801b794:	0084      	lsls	r4, r0, #2
                    tADSR4_off(&polyEnvs[voice]);
 801b796:	481a      	ldr	r0, [pc, #104]	; (801b800 <noteOff+0x168>)
 801b798:	4420      	add	r0, r4
 801b79a:	f006 fbb1 	bl	8021f00 <tADSR4_off>
                    tADSR4_off(&polyFiltEnvs[voice]);
 801b79e:	4819      	ldr	r0, [pc, #100]	; (801b804 <noteOff+0x16c>)
 801b7a0:	4420      	add	r0, r4
 801b7a2:	f006 fbad 	bl	8021f00 <tADSR4_off>
 801b7a6:	e79a      	b.n	801b6de <noteOff+0x46>
                voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
 801b7a8:	f009 f8ae 	bl	8024908 <tSimplePoly_noteOff>
                if (voice >= 0)
 801b7ac:	2800      	cmp	r0, #0
 801b7ae:	db96      	blt.n	801b6de <noteOff+0x46>
                    tADSR4_off(&pluckEnvs[voice]);
 801b7b0:	4b15      	ldr	r3, [pc, #84]	; (801b808 <noteOff+0x170>)
 801b7b2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801b7b6:	f006 fba3 	bl	8021f00 <tADSR4_off>
 801b7ba:	e790      	b.n	801b6de <noteOff+0x46>
                    voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
 801b7bc:	f009 f8a4 	bl	8024908 <tSimplePoly_noteOff>
 801b7c0:	e7e6      	b.n	801b790 <noteOff+0xf8>
                        tBuffer_stop(&keyBuff[key-LOWEST_SAMPLER_KEY]);
 801b7c2:	4630      	mov	r0, r6
 801b7c4:	f00a fdc0 	bl	8026348 <tBuffer_stop>
                        UISamplerKButtons(ButtonUp, ActionPress);
 801b7c8:	2100      	movs	r1, #0
 801b7ca:	2004      	movs	r0, #4
 801b7cc:	f002 f84a 	bl	801d864 <UISamplerKButtons>
 801b7d0:	e7a3      	b.n	801b71a <noteOff+0x82>
 801b7d2:	bf00      	nop
 801b7d4:	2aaaaaab 	.word	0x2aaaaaab
 801b7d8:	20000540 	.word	0x20000540
 801b7dc:	20000669 	.word	0x20000669
 801b7e0:	200174c8 	.word	0x200174c8
 801b7e4:	200181b0 	.word	0x200181b0
 801b7e8:	20002634 	.word	0x20002634
 801b7ec:	00000000 	.word	0x00000000
 801b7f0:	200176e4 	.word	0x200176e4
 801b7f4:	200034d4 	.word	0x200034d4
 801b7f8:	200175c0 	.word	0x200175c0
 801b7fc:	200174d4 	.word	0x200174d4
 801b800:	20017648 	.word	0x20017648
 801b804:	20001ef0 	.word	0x20001ef0
 801b808:	200173b0 	.word	0x200173b0

0801b80c <noteOn>:
            if (!velocity)
 801b80c:	2900      	cmp	r1, #0
 801b80e:	d038      	beq.n	801b882 <noteOn+0x76>
                chordArray[key%12]++;
 801b810:	4a73      	ldr	r2, [pc, #460]	; (801b9e0 <noteOn+0x1d4>)
        {
 801b812:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801b814:	4604      	mov	r4, r0
 801b816:	460d      	mov	r5, r1
                chordArray[key%12]++;
 801b818:	17c3      	asrs	r3, r0, #31
 801b81a:	4872      	ldr	r0, [pc, #456]	; (801b9e4 <noteOn+0x1d8>)
 801b81c:	fb82 1204 	smull	r1, r2, r2, r4
                if (currentPreset == AutotuneMono)
 801b820:	4971      	ldr	r1, [pc, #452]	; (801b9e8 <noteOn+0x1dc>)
                chordArray[key%12]++;
 801b822:	ebc3 0362 	rsb	r3, r3, r2, asr #1
 801b826:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801b82a:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
        {
 801b82e:	ed2d 8b02 	vpush	{d8}
                chordArray[key%12]++;
 801b832:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
                if (currentPreset == AutotuneMono)
 801b836:	7809      	ldrb	r1, [r1, #0]
                chordArray[key%12]++;
 801b838:	3201      	adds	r2, #1
                if (currentPreset == AutotuneMono)
 801b83a:	2903      	cmp	r1, #3
                chordArray[key%12]++;
 801b83c:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
                if (currentPreset == AutotuneMono)
 801b840:	d010      	beq.n	801b864 <noteOn+0x58>
                if (currentPreset == Rhodes)
 801b842:	2911      	cmp	r1, #17
 801b844:	d03a      	beq.n	801b8bc <noteOn+0xb0>
                else if (currentPreset == ClassicSynth)
 801b846:	2910      	cmp	r1, #16
 801b848:	d05d      	beq.n	801b906 <noteOn+0xfa>
                else if (currentPreset == SamplerKeyboard)
 801b84a:	2906      	cmp	r1, #6
 801b84c:	d123      	bne.n	801b896 <noteOn+0x8a>
                    if ((key >= LOWEST_SAMPLER_KEY) && key < (LOWEST_SAMPLER_KEY + NUM_SAMPLER_KEYS))
 801b84e:	f1a4 0624 	sub.w	r6, r4, #36	; 0x24
 801b852:	2e30      	cmp	r6, #48	; 0x30
 801b854:	d970      	bls.n	801b938 <noteOn+0x12c>
                setLED_2(1);
 801b856:	2001      	movs	r0, #1
        }
 801b858:	ecbd 8b02 	vpop	{d8}
 801b85c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                setLED_2(1);
 801b860:	f7f8 b864 	b.w	801392c <setLED_2>
                    if (autotuneLock)
 801b864:	4a61      	ldr	r2, [pc, #388]	; (801b9ec <noteOn+0x1e0>)
 801b866:	6812      	ldr	r2, [r2, #0]
 801b868:	b96a      	cbnz	r2, 801b886 <noteOn+0x7a>
 801b86a:	b2ea      	uxtb	r2, r5
                    tSimplePoly_noteOn(&poly, key, velocity);
 801b86c:	4621      	mov	r1, r4
 801b86e:	4860      	ldr	r0, [pc, #384]	; (801b9f0 <noteOn+0x1e4>)
 801b870:	f008 ff1e 	bl	80246b0 <tSimplePoly_noteOn>
                setLED_2(1);
 801b874:	2001      	movs	r0, #1
        }
 801b876:	ecbd 8b02 	vpop	{d8}
 801b87a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                setLED_2(1);
 801b87e:	f7f8 b855 	b.w	801392c <setLED_2>
                noteOff(key, velocity);
 801b882:	f7ff bf09 	b.w	801b698 <noteOff>
                        lockArray[key%12]++;
 801b886:	485b      	ldr	r0, [pc, #364]	; (801b9f4 <noteOn+0x1e8>)
 801b888:	b2ea      	uxtb	r2, r5
 801b88a:	f850 1023 	ldr.w	r1, [r0, r3, lsl #2]
 801b88e:	3101      	adds	r1, #1
 801b890:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
 801b894:	e7ea      	b.n	801b86c <noteOn+0x60>
                else if (currentPreset == LivingStringSynth)
 801b896:	290f      	cmp	r1, #15
 801b898:	b2ea      	uxtb	r2, r5
 801b89a:	d1e7      	bne.n	801b86c <noteOn+0x60>
                    int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
 801b89c:	4621      	mov	r1, r4
 801b89e:	4854      	ldr	r0, [pc, #336]	; (801b9f0 <noteOn+0x1e4>)
 801b8a0:	f008 ff06 	bl	80246b0 <tSimplePoly_noteOn>
                    if (whichVoice >= 0)
 801b8a4:	2800      	cmp	r0, #0
 801b8a6:	dbd6      	blt.n	801b856 <noteOn+0x4a>
                        tADSR4_on(&pluckEnvs[whichVoice], velocity * 0.0078125f);
 801b8a8:	4b53      	ldr	r3, [pc, #332]	; (801b9f8 <noteOn+0x1ec>)
 801b8aa:	ee00 5a10 	vmov	s0, r5
 801b8ae:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801b8b2:	eeba 0aec 	vcvt.f32.s32	s0, s0, #7
 801b8b6:	f006 fb11 	bl	8021edc <tADSR4_on>
 801b8ba:	e7cc      	b.n	801b856 <noteOn+0x4a>
                    int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
 801b8bc:	b2ea      	uxtb	r2, r5
 801b8be:	4621      	mov	r1, r4
 801b8c0:	484b      	ldr	r0, [pc, #300]	; (801b9f0 <noteOn+0x1e4>)
 801b8c2:	f008 fef5 	bl	80246b0 <tSimplePoly_noteOn>
                    if (whichVoice >= 0)
 801b8c6:	1e07      	subs	r7, r0, #0
 801b8c8:	dbc5      	blt.n	801b856 <noteOn+0x4a>
 801b8ca:	eb07 0647 	add.w	r6, r7, r7, lsl #1
 801b8ce:	4b4b      	ldr	r3, [pc, #300]	; (801b9fc <noteOn+0x1f0>)
                            tADSR4_on(&FM_envs[whichVoice][j], velocity * 0.0078125f);
 801b8d0:	ee08 5a10 	vmov	s16, r5
 801b8d4:	00f2      	lsls	r2, r6, #3
 801b8d6:	f103 0618 	add.w	r6, r3, #24
 801b8da:	eeba 8aec 	vcvt.f32.s32	s16, s16, #7
 801b8de:	18d5      	adds	r5, r2, r3
 801b8e0:	4416      	add	r6, r2
 801b8e2:	4628      	mov	r0, r5
 801b8e4:	3504      	adds	r5, #4
 801b8e6:	eeb0 0a48 	vmov.f32	s0, s16
 801b8ea:	f006 faf7 	bl	8021edc <tADSR4_on>
                        for (int j = 0; j < 6; j++)
 801b8ee:	42ae      	cmp	r6, r5
 801b8f0:	d1f7      	bne.n	801b8e2 <noteOn+0xd6>
                        panValues[whichVoice] = key * 0.0078125f; // divide by 128.0f
 801b8f2:	ee07 4a90 	vmov	s15, r4
 801b8f6:	4b42      	ldr	r3, [pc, #264]	; (801ba00 <noteOn+0x1f4>)
 801b8f8:	eefa 7aec 	vcvt.f32.s32	s15, s15, #7
 801b8fc:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 801b900:	edc7 7a00 	vstr	s15, [r7]
 801b904:	e7a7      	b.n	801b856 <noteOn+0x4a>
                    int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
 801b906:	4621      	mov	r1, r4
 801b908:	b2ea      	uxtb	r2, r5
 801b90a:	4839      	ldr	r0, [pc, #228]	; (801b9f0 <noteOn+0x1e4>)
 801b90c:	f008 fed0 	bl	80246b0 <tSimplePoly_noteOn>
                    if (whichVoice >= 0)
 801b910:	2800      	cmp	r0, #0
 801b912:	dba0      	blt.n	801b856 <noteOn+0x4a>
                        tADSR4_on(&polyEnvs[whichVoice], velocity * 0.0078125f);
 801b914:	ee08 5a10 	vmov	s16, r5
 801b918:	0084      	lsls	r4, r0, #2
 801b91a:	483a      	ldr	r0, [pc, #232]	; (801ba04 <noteOn+0x1f8>)
 801b91c:	eeba 8aec 	vcvt.f32.s32	s16, s16, #7
 801b920:	4420      	add	r0, r4
 801b922:	eeb0 0a48 	vmov.f32	s0, s16
 801b926:	f006 fad9 	bl	8021edc <tADSR4_on>
                        tADSR4_on(&polyFiltEnvs[whichVoice], velocity * 0.0078125f);
 801b92a:	4837      	ldr	r0, [pc, #220]	; (801ba08 <noteOn+0x1fc>)
 801b92c:	eeb0 0a48 	vmov.f32	s0, s16
 801b930:	4420      	add	r0, r4
 801b932:	f006 fad3 	bl	8021edc <tADSR4_on>
 801b936:	e78e      	b.n	801b856 <noteOn+0x4a>
                        int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
 801b938:	4621      	mov	r1, r4
 801b93a:	b2ea      	uxtb	r2, r5
 801b93c:	482c      	ldr	r0, [pc, #176]	; (801b9f0 <noteOn+0x1e4>)
 801b93e:	f008 feb7 	bl	80246b0 <tSimplePoly_noteOn>
                        if (whichVoice >= 0)
 801b942:	2800      	cmp	r0, #0
 801b944:	db87      	blt.n	801b856 <noteOn+0x4a>
                            if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
 801b946:	4f31      	ldr	r7, [pc, #196]	; (801ba0c <noteOn+0x200>)
                            currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
 801b948:	4c31      	ldr	r4, [pc, #196]	; (801ba10 <noteOn+0x204>)
                            if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
 801b94a:	eb07 0086 	add.w	r0, r7, r6, lsl #2
                            currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
 801b94e:	6026      	str	r6, [r4, #0]
                            if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
 801b950:	f00a fd0a 	bl	8026368 <tBuffer_getRecordedLength>
 801b954:	b970      	cbnz	r0, 801b974 <noteOn+0x168>
                                tBuffer_record(&keyBuff[currentSamplerKeyGlobal]);
 801b956:	6820      	ldr	r0, [r4, #0]
 801b958:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 801b95c:	f00a fcee 	bl	802633c <tBuffer_record>
                                newBuffer[currentSamplerKeyGlobal] = 1;
 801b960:	6823      	ldr	r3, [r4, #0]
 801b962:	4a2c      	ldr	r2, [pc, #176]	; (801ba14 <noteOn+0x208>)
 801b964:	2101      	movs	r1, #1
 801b966:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                            samplerKeyHeld[currentSamplerKeyGlobal] = 1;
 801b96a:	4a2b      	ldr	r2, [pc, #172]	; (801ba18 <noteOn+0x20c>)
 801b96c:	2101      	movs	r1, #1
 801b96e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 801b972:	e770      	b.n	801b856 <noteOn+0x4a>
                                tSampler_play(&keySampler[currentSamplerKeyGlobal]);
 801b974:	4b29      	ldr	r3, [pc, #164]	; (801ba1c <noteOn+0x210>)
 801b976:	6820      	ldr	r0, [r4, #0]
                                if (newBuffer[currentSamplerKeyGlobal])
 801b978:	4e26      	ldr	r6, [pc, #152]	; (801ba14 <noteOn+0x208>)
                                tSampler_play(&keySampler[currentSamplerKeyGlobal]);
 801b97a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801b97e:	f00a fd75 	bl	802646c <tSampler_play>
                                if (newBuffer[currentSamplerKeyGlobal])
 801b982:	6823      	ldr	r3, [r4, #0]
 801b984:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 801b988:	b9ba      	cbnz	r2, 801b9ba <noteOn+0x1ae>
 801b98a:	009a      	lsls	r2, r3, #2
                                float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
 801b98c:	4b24      	ldr	r3, [pc, #144]	; (801ba20 <noteOn+0x214>)
 801b98e:	ee07 5a90 	vmov	s15, r5
 801b992:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801b996:	eddf 6a23 	vldr	s13, [pc, #140]	; 801ba24 <noteOn+0x218>
 801b99a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801b99e:	edd3 7a06 	vldr	s15, [r3, #24]
                                tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
 801b9a2:	4821      	ldr	r0, [pc, #132]	; (801ba28 <noteOn+0x21c>)
                                float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
 801b9a4:	ee30 0a67 	vsub.f32	s0, s0, s15
 801b9a8:	ee67 7aa6 	vmul.f32	s15, s15, s13
                                tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
 801b9ac:	4410      	add	r0, r2
 801b9ae:	eea7 0a27 	vfma.f32	s0, s14, s15
 801b9b2:	f006 fde5 	bl	8022580 <tExpSmooth_setDest>
 801b9b6:	6823      	ldr	r3, [r4, #0]
 801b9b8:	e7d7      	b.n	801b96a <noteOn+0x15e>
                                    int recordLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]);
 801b9ba:	eb07 0083 	add.w	r0, r7, r3, lsl #2
 801b9be:	f00a fcd3 	bl	8026368 <tBuffer_getRecordedLength>
                                    samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
 801b9c2:	6823      	ldr	r3, [r4, #0]
 801b9c4:	ee07 0a90 	vmov	s15, r0
 801b9c8:	4918      	ldr	r1, [pc, #96]	; (801ba2c <noteOn+0x220>)
 801b9ca:	009a      	lsls	r2, r3, #2
                                    newBuffer[currentSamplerKeyGlobal] = 0;
 801b9cc:	2000      	movs	r0, #0
                                    samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
 801b9ce:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801b9d2:	4411      	add	r1, r2
                                    newBuffer[currentSamplerKeyGlobal] = 0;
 801b9d4:	f846 0023 	str.w	r0, [r6, r3, lsl #2]
                                    samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
 801b9d8:	edc1 7a00 	vstr	s15, [r1]
 801b9dc:	e7d6      	b.n	801b98c <noteOn+0x180>
 801b9de:	bf00      	nop
 801b9e0:	2aaaaaab 	.word	0x2aaaaaab
 801b9e4:	20000540 	.word	0x20000540
 801b9e8:	20000669 	.word	0x20000669
 801b9ec:	20000530 	.word	0x20000530
 801b9f0:	200174c8 	.word	0x200174c8
 801b9f4:	200005b8 	.word	0x200005b8
 801b9f8:	200173b0 	.word	0x200173b0
 801b9fc:	200174d4 	.word	0x200174d4
 801ba00:	200027c4 	.word	0x200027c4
 801ba04:	20017648 	.word	0x20017648
 801ba08:	20001ef0 	.word	0x20001ef0
 801ba0c:	200181b0 	.word	0x200181b0
 801ba10:	20000224 	.word	0x20000224
 801ba14:	200026fc 	.word	0x200026fc
 801ba18:	200176e4 	.word	0x200176e4
 801ba1c:	200034d4 	.word	0x200034d4
 801ba20:	200187dc 	.word	0x200187dc
 801ba24:	3c000000 	.word	0x3c000000
 801ba28:	20002634 	.word	0x20002634
 801ba2c:	20002828 	.word	0x20002828

0801ba30 <pitchBend>:


        void pitchBend(int data)
        {
            pitchBendValue = (data - 8192) * 0.000244140625f;
 801ba30:	f5a0 5300 	sub.w	r3, r0, #8192	; 0x2000
 801ba34:	ee07 3a90 	vmov	s15, r3
 801ba38:	4b02      	ldr	r3, [pc, #8]	; (801ba44 <pitchBend+0x14>)
 801ba3a:	eefa 7aca 	vcvt.f32.s32	s15, s15, #12
 801ba3e:	edc3 7a00 	vstr	s15, [r3]
        }
 801ba42:	4770      	bx	lr
 801ba44:	200005e8 	.word	0x200005e8

0801ba48 <sustainOff>:
 801ba48:	4770      	bx	lr
 801ba4a:	bf00      	nop

0801ba4c <sustainOn>:
        }

        void sustainOn()
        {

        }
 801ba4c:	4770      	bx	lr
 801ba4e:	bf00      	nop

0801ba50 <ssd1306_begin>:
uint8_t OLED_i2c_address;
uint8_t OLED_externalVCC;
I2C_HandleTypeDef* OLED_i2c_handle;

void ssd1306_begin(I2C_HandleTypeDef* hi2c, uint8_t vccstate, uint8_t i2caddr)
{
 801ba50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	OLED_i2c_address = i2caddr;
 801ba54:	4ea9      	ldr	r6, [pc, #676]	; (801bcfc <ssd1306_begin+0x2ac>)
{
 801ba56:	4688      	mov	r8, r1
	OLED_externalVCC = vccstate;
	OLED_i2c_handle = hi2c;
 801ba58:	4da9      	ldr	r5, [pc, #676]	; (801bd00 <ssd1306_begin+0x2b0>)
{
 801ba5a:	b084      	sub	sp, #16
	OLED_externalVCC = vccstate;
 801ba5c:	4ba9      	ldr	r3, [pc, #676]	; (801bd04 <ssd1306_begin+0x2b4>)

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
 801ba5e:	f44f 7100 	mov.w	r1, #512	; 0x200
	OLED_i2c_address = i2caddr;
 801ba62:	7032      	strb	r2, [r6, #0]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
 801ba64:	2201      	movs	r2, #1
	OLED_i2c_handle = hi2c;
 801ba66:	6028      	str	r0, [r5, #0]

void ssd1306_command(uint8_t c) {
	// I2C
	//	uint8_t control = 0x00;   // Co = 0, D/C = 0

	uint8_t i2c_message[2] = {0,0};
 801ba68:	ac04      	add	r4, sp, #16
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
 801ba6a:	48a7      	ldr	r0, [pc, #668]	; (801bd08 <ssd1306_begin+0x2b8>)
	i2c_message[1] = c;
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ba6c:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	OLED_externalVCC = vccstate;
 801ba70:	f883 8000 	strb.w	r8, [r3]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
 801ba74:	f7e9 fede 	bl	8005834 <HAL_GPIO_WritePin>
	HAL_Delay(1);
 801ba78:	2001      	movs	r0, #1
 801ba7a:	f7e4 ffdb 	bl	8000a34 <HAL_Delay>
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET); //PULL RESET LINE HIGH
 801ba7e:	2200      	movs	r2, #0
 801ba80:	f44f 7100 	mov.w	r1, #512	; 0x200
 801ba84:	48a0      	ldr	r0, [pc, #640]	; (801bd08 <ssd1306_begin+0x2b8>)
 801ba86:	f7e9 fed5 	bl	8005834 <HAL_GPIO_WritePin>
	HAL_Delay(10);
 801ba8a:	200a      	movs	r0, #10
 801ba8c:	f7e4 ffd2 	bl	8000a34 <HAL_Delay>
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
 801ba90:	2201      	movs	r2, #1
 801ba92:	f44f 7100 	mov.w	r1, #512	; 0x200
 801ba96:	489c      	ldr	r0, [pc, #624]	; (801bd08 <ssd1306_begin+0x2b8>)
 801ba98:	f7e9 fecc 	bl	8005834 <HAL_GPIO_WritePin>
	uint8_t i2c_message[2] = {0,0};
 801ba9c:	f44f 432e 	mov.w	r3, #44544	; 0xae00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801baa0:	7831      	ldrb	r1, [r6, #0]
 801baa2:	6828      	ldr	r0, [r5, #0]
 801baa4:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801baa6:	f824 3d04 	strh.w	r3, [r4, #-4]!
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801baaa:	2302      	movs	r3, #2
 801baac:	4622      	mov	r2, r4
 801baae:	f7ea fd7d 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bab2:	f44f 4c55 	mov.w	ip, #54528	; 0xd500
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bab6:	7831      	ldrb	r1, [r6, #0]
 801bab8:	4622      	mov	r2, r4
 801baba:	6828      	ldr	r0, [r5, #0]
 801babc:	2302      	movs	r3, #2
 801babe:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801bac0:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bac4:	f7ea fd72 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bac8:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bacc:	7831      	ldrb	r1, [r6, #0]
 801bace:	6828      	ldr	r0, [r5, #0]
 801bad0:	4622      	mov	r2, r4
 801bad2:	9700      	str	r7, [sp, #0]
 801bad4:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bad6:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bada:	f7ea fd67 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bade:	f44f 4c28 	mov.w	ip, #43008	; 0xa800
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bae2:	7831      	ldrb	r1, [r6, #0]
 801bae4:	6828      	ldr	r0, [r5, #0]
 801bae6:	4622      	mov	r2, r4
 801bae8:	9700      	str	r7, [sp, #0]
 801baea:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801baec:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801baf0:	f7ea fd5c 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801baf4:	f44f 5cf8 	mov.w	ip, #7936	; 0x1f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801baf8:	7831      	ldrb	r1, [r6, #0]
 801bafa:	6828      	ldr	r0, [r5, #0]
 801bafc:	4622      	mov	r2, r4
 801bafe:	9700      	str	r7, [sp, #0]
 801bb00:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bb02:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb06:	f7ea fd51 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bb0a:	f44f 4c53 	mov.w	ip, #54016	; 0xd300
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb0e:	7831      	ldrb	r1, [r6, #0]
 801bb10:	6828      	ldr	r0, [r5, #0]
 801bb12:	4622      	mov	r2, r4
 801bb14:	9700      	str	r7, [sp, #0]
 801bb16:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bb18:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb1c:	f7ea fd46 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bb20:	f04f 0c00 	mov.w	ip, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb24:	7831      	ldrb	r1, [r6, #0]
 801bb26:	6828      	ldr	r0, [r5, #0]
 801bb28:	4622      	mov	r2, r4
 801bb2a:	9700      	str	r7, [sp, #0]
 801bb2c:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bb2e:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb32:	f7ea fd3b 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bb36:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb3a:	7831      	ldrb	r1, [r6, #0]
 801bb3c:	6828      	ldr	r0, [r5, #0]
 801bb3e:	4622      	mov	r2, r4
 801bb40:	9700      	str	r7, [sp, #0]
 801bb42:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bb44:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb48:	f7ea fd30 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bb4c:	f44f 4c0d 	mov.w	ip, #36096	; 0x8d00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb50:	7831      	ldrb	r1, [r6, #0]
 801bb52:	6828      	ldr	r0, [r5, #0]
 801bb54:	4622      	mov	r2, r4
 801bb56:	9700      	str	r7, [sp, #0]
 801bb58:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bb5a:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb5e:	f7ea fd25 	bl	80065ac <HAL_I2C_Master_Transmit>
	if (vccstate == SSD1306_EXTERNALVCC)
 801bb62:	f1b8 0f01 	cmp.w	r8, #1
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb66:	6828      	ldr	r0, [r5, #0]
 801bb68:	7831      	ldrb	r1, [r6, #0]
 801bb6a:	4622      	mov	r2, r4
	uint8_t i2c_message[2] = {0,0};
 801bb6c:	bf0c      	ite	eq
 801bb6e:	f44f 5c80 	moveq.w	ip, #4096	; 0x1000
 801bb72:	f44f 5ca0 	movne.w	ip, #5120	; 0x1400
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb76:	9700      	str	r7, [sp, #0]
 801bb78:	2302      	movs	r3, #2
 801bb7a:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
 801bb7e:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb82:	f7ea fd13 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bb86:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb8a:	7831      	ldrb	r1, [r6, #0]
 801bb8c:	4622      	mov	r2, r4
 801bb8e:	6828      	ldr	r0, [r5, #0]
 801bb90:	2302      	movs	r3, #2
 801bb92:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801bb94:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bb98:	f7ea fd08 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bb9c:	f04f 0c00 	mov.w	ip, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bba0:	7831      	ldrb	r1, [r6, #0]
 801bba2:	6828      	ldr	r0, [r5, #0]
 801bba4:	4622      	mov	r2, r4
 801bba6:	9700      	str	r7, [sp, #0]
 801bba8:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bbaa:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bbae:	f7ea fcfd 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bbb2:	f44f 4c21 	mov.w	ip, #41216	; 0xa100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bbb6:	7831      	ldrb	r1, [r6, #0]
 801bbb8:	6828      	ldr	r0, [r5, #0]
 801bbba:	4622      	mov	r2, r4
 801bbbc:	9700      	str	r7, [sp, #0]
 801bbbe:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bbc0:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bbc4:	f7ea fcf2 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bbc8:	f44f 4c48 	mov.w	ip, #51200	; 0xc800
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bbcc:	7831      	ldrb	r1, [r6, #0]
 801bbce:	6828      	ldr	r0, [r5, #0]
 801bbd0:	4622      	mov	r2, r4
 801bbd2:	9700      	str	r7, [sp, #0]
 801bbd4:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bbd6:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bbda:	f7ea fce7 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bbde:	f44f 4c5a 	mov.w	ip, #55808	; 0xda00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bbe2:	7831      	ldrb	r1, [r6, #0]
 801bbe4:	6828      	ldr	r0, [r5, #0]
 801bbe6:	4622      	mov	r2, r4
 801bbe8:	9700      	str	r7, [sp, #0]
 801bbea:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bbec:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bbf0:	f7ea fcdc 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bbf4:	f44f 7c00 	mov.w	ip, #512	; 0x200
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bbf8:	7831      	ldrb	r1, [r6, #0]
 801bbfa:	6828      	ldr	r0, [r5, #0]
 801bbfc:	4622      	mov	r2, r4
 801bbfe:	9700      	str	r7, [sp, #0]
 801bc00:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bc02:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc06:	f7ea fcd1 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bc0a:	f44f 4c01 	mov.w	ip, #33024	; 0x8100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc0e:	7831      	ldrb	r1, [r6, #0]
 801bc10:	6828      	ldr	r0, [r5, #0]
 801bc12:	4622      	mov	r2, r4
 801bc14:	9700      	str	r7, [sp, #0]
 801bc16:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bc18:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc1c:	f7ea fcc6 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bc20:	f44f 4c0f 	mov.w	ip, #36608	; 0x8f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc24:	7831      	ldrb	r1, [r6, #0]
 801bc26:	6828      	ldr	r0, [r5, #0]
 801bc28:	4622      	mov	r2, r4
 801bc2a:	9700      	str	r7, [sp, #0]
 801bc2c:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bc2e:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc32:	f7ea fcbb 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bc36:	f44f 4c59 	mov.w	ip, #55552	; 0xd900
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc3a:	7831      	ldrb	r1, [r6, #0]
 801bc3c:	6828      	ldr	r0, [r5, #0]
 801bc3e:	4622      	mov	r2, r4
 801bc40:	9700      	str	r7, [sp, #0]
 801bc42:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bc44:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc48:	f7ea fcb0 	bl	80065ac <HAL_I2C_Master_Transmit>
	if (vccstate == SSD1306_EXTERNALVCC)
 801bc4c:	f1b8 0f01 	cmp.w	r8, #1
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc50:	6828      	ldr	r0, [r5, #0]
 801bc52:	7831      	ldrb	r1, [r6, #0]
 801bc54:	4622      	mov	r2, r4
	uint8_t i2c_message[2] = {0,0};
 801bc56:	bf0c      	ite	eq
 801bc58:	f44f 5c08 	moveq.w	ip, #8704	; 0x2200
 801bc5c:	f44f 4c71 	movne.w	ip, #61696	; 0xf100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc60:	9700      	str	r7, [sp, #0]
 801bc62:	2302      	movs	r3, #2
 801bc64:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
 801bc68:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc6c:	f7ea fc9e 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bc70:	f44f 4c5b 	mov.w	ip, #56064	; 0xdb00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc74:	7831      	ldrb	r1, [r6, #0]
 801bc76:	4622      	mov	r2, r4
 801bc78:	6828      	ldr	r0, [r5, #0]
 801bc7a:	2302      	movs	r3, #2
 801bc7c:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801bc7e:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc82:	f7ea fc93 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bc86:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc8a:	7831      	ldrb	r1, [r6, #0]
 801bc8c:	6828      	ldr	r0, [r5, #0]
 801bc8e:	4622      	mov	r2, r4
 801bc90:	9700      	str	r7, [sp, #0]
 801bc92:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bc94:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bc98:	f7ea fc88 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bc9c:	f44f 4c24 	mov.w	ip, #41984	; 0xa400
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bca0:	7831      	ldrb	r1, [r6, #0]
 801bca2:	6828      	ldr	r0, [r5, #0]
 801bca4:	4622      	mov	r2, r4
 801bca6:	9700      	str	r7, [sp, #0]
 801bca8:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bcaa:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bcae:	f7ea fc7d 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bcb2:	f44f 4c26 	mov.w	ip, #42496	; 0xa600
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bcb6:	7831      	ldrb	r1, [r6, #0]
 801bcb8:	6828      	ldr	r0, [r5, #0]
 801bcba:	4622      	mov	r2, r4
 801bcbc:	9700      	str	r7, [sp, #0]
 801bcbe:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bcc0:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bcc4:	f7ea fc72 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bcc8:	f44f 5c38 	mov.w	ip, #11776	; 0x2e00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bccc:	7831      	ldrb	r1, [r6, #0]
 801bcce:	6828      	ldr	r0, [r5, #0]
 801bcd0:	4622      	mov	r2, r4
 801bcd2:	9700      	str	r7, [sp, #0]
 801bcd4:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bcd6:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bcda:	f7ea fc67 	bl	80065ac <HAL_I2C_Master_Transmit>
 801bcde:	6828      	ldr	r0, [r5, #0]
 801bce0:	4622      	mov	r2, r4
 801bce2:	7831      	ldrb	r1, [r6, #0]
	uint8_t i2c_message[2] = {0,0};
 801bce4:	f44f 452f 	mov.w	r5, #44800	; 0xaf00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bce8:	2302      	movs	r3, #2
 801bcea:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801bcec:	f8ad 500c 	strh.w	r5, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bcf0:	f7ea fc5c 	bl	80065ac <HAL_I2C_Master_Transmit>
}
 801bcf4:	b004      	add	sp, #16
 801bcf6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801bcfa:	bf00      	nop
 801bcfc:	20018684 	.word	0x20018684
 801bd00:	20018680 	.word	0x20018680
 801bd04:	2001867c 	.word	0x2001867c
 801bd08:	58020000 	.word	0x58020000

0801bd0c <ssd1306_display_full_buffer>:
  ssd1306_command(contrast);
}



void ssd1306_display_full_buffer(void) {
 801bd0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801bd10:	b084      	sub	sp, #16
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd12:	4e2d      	ldr	r6, [pc, #180]	; (801bdc8 <ssd1306_display_full_buffer+0xbc>)
 801bd14:	4d2d      	ldr	r5, [pc, #180]	; (801bdcc <ssd1306_display_full_buffer+0xc0>)
 801bd16:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
 801bd1a:	ac04      	add	r4, sp, #16
 801bd1c:	f44f 5204 	mov.w	r2, #8448	; 0x2100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd20:	7831      	ldrb	r1, [r6, #0]
	uint8_t i2c_message[2] = {0,0};
 801bd22:	f04f 0800 	mov.w	r8, #0
 801bd26:	f824 2d04 	strh.w	r2, [r4, #-4]!
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd2a:	2302      	movs	r3, #2
 801bd2c:	4622      	mov	r2, r4
 801bd2e:	6828      	ldr	r0, [r5, #0]
 801bd30:	9700      	str	r7, [sp, #0]
 801bd32:	f7ea fc3b 	bl	80065ac <HAL_I2C_Master_Transmit>
 801bd36:	7831      	ldrb	r1, [r6, #0]
 801bd38:	4622      	mov	r2, r4
 801bd3a:	6828      	ldr	r0, [r5, #0]
 801bd3c:	9700      	str	r7, [sp, #0]
 801bd3e:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bd40:	f8ad 800c 	strh.w	r8, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd44:	f7ea fc32 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bd48:	f44f 4cfe 	mov.w	ip, #32512	; 0x7f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd4c:	7831      	ldrb	r1, [r6, #0]
 801bd4e:	4622      	mov	r2, r4
 801bd50:	6828      	ldr	r0, [r5, #0]
 801bd52:	9700      	str	r7, [sp, #0]
 801bd54:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bd56:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd5a:	f7ea fc27 	bl	80065ac <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801bd5e:	f44f 5c08 	mov.w	ip, #8704	; 0x2200
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd62:	7831      	ldrb	r1, [r6, #0]
 801bd64:	4622      	mov	r2, r4
 801bd66:	6828      	ldr	r0, [r5, #0]
 801bd68:	9700      	str	r7, [sp, #0]
 801bd6a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801bd6c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd70:	f7ea fc1c 	bl	80065ac <HAL_I2C_Master_Transmit>
 801bd74:	7831      	ldrb	r1, [r6, #0]
 801bd76:	4622      	mov	r2, r4
 801bd78:	6828      	ldr	r0, [r5, #0]
 801bd7a:	2302      	movs	r3, #2
 801bd7c:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801bd7e:	f8ad 800c 	strh.w	r8, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd82:	f7ea fc13 	bl	80065ac <HAL_I2C_Master_Transmit>
//		HAL_I2C_Master_Transmit_DMA(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 17);
////		HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 17, 2000);
////		HAL_Delay(1);
//		i--;
//	}
	displayBufferChunk[0] = 0x40;
 801bd86:	f8df 804c 	ldr.w	r8, [pc, #76]	; 801bdd4 <ssd1306_display_full_buffer+0xc8>
	uint8_t i2c_message[2] = {0,0};
 801bd8a:	f44f 7c40 	mov.w	ip, #768	; 0x300
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd8e:	7831      	ldrb	r1, [r6, #0]
 801bd90:	4622      	mov	r2, r4
 801bd92:	6828      	ldr	r0, [r5, #0]
 801bd94:	2302      	movs	r3, #2
 801bd96:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801bd98:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801bd9c:	f7ea fc06 	bl	80065ac <HAL_I2C_Master_Transmit>
	displayBufferChunk[0] = 0x40;
 801bda0:	4640      	mov	r0, r8
 801bda2:	2340      	movs	r3, #64	; 0x40
 801bda4:	f44f 7200 	mov.w	r2, #512	; 0x200
 801bda8:	4909      	ldr	r1, [pc, #36]	; (801bdd0 <ssd1306_display_full_buffer+0xc4>)
 801bdaa:	f800 3b01 	strb.w	r3, [r0], #1
 801bdae:	f00b f90b 	bl	8026fc8 <memcpy>
	for (int i = 0; i < 512; i++)
	{
		displayBufferChunk[i+1] = buffer[i];
	}
	HAL_I2C_Master_Transmit_DMA(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 513);
 801bdb2:	4642      	mov	r2, r8
 801bdb4:	7831      	ldrb	r1, [r6, #0]
 801bdb6:	f240 2301 	movw	r3, #513	; 0x201
 801bdba:	6828      	ldr	r0, [r5, #0]
 801bdbc:	f7ea fd20 	bl	8006800 <HAL_I2C_Master_Transmit_DMA>
}
 801bdc0:	b004      	add	sp, #16
 801bdc2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801bdc6:	bf00      	nop
 801bdc8:	20018684 	.word	0x20018684
 801bdcc:	20018680 	.word	0x20018680
 801bdd0:	2001847c 	.word	0x2001847c
 801bdd4:	38000000 	.word	0x38000000

0801bdd8 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 801bdd8:	4b07      	ldr	r3, [pc, #28]	; (801bdf8 <HAL_MspInit+0x20>)
{
 801bdda:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 801bddc:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
 801bde0:	f042 0202 	orr.w	r2, r2, #2
 801bde4:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
 801bde8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801bdec:	f003 0302 	and.w	r3, r3, #2
 801bdf0:	9301      	str	r3, [sp, #4]
 801bdf2:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 801bdf4:	b002      	add	sp, #8
 801bdf6:	4770      	bx	lr
 801bdf8:	58024400 	.word	0x58024400

0801bdfc <NMI_Handler>:
void NMI_Handler(void)
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bdfc:	4b05      	ldr	r3, [pc, #20]	; (801be14 <NMI_Handler+0x18>)
 801bdfe:	2001      	movs	r0, #1
 801be00:	2100      	movs	r1, #0
 801be02:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801be06:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801be0a:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801be0e:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
	}
  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 801be12:	4770      	bx	lr
 801be14:	20001b38 	.word	0x20001b38

0801be18 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801be18:	4b05      	ldr	r3, [pc, #20]	; (801be30 <MemManage_Handler+0x18>)
 801be1a:	2001      	movs	r0, #1
 801be1c:	2100      	movs	r1, #0
 801be1e:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801be22:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801be26:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801be2a:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
 801be2e:	e7fe      	b.n	801be2e <MemManage_Handler+0x16>
 801be30:	20001b38 	.word	0x20001b38

0801be34 <BusFault_Handler>:
 801be34:	b508      	push	{r3, lr}
 801be36:	f7ff ffef 	bl	801be18 <MemManage_Handler>
 801be3a:	bf00      	nop

0801be3c <UsageFault_Handler>:
 801be3c:	b508      	push	{r3, lr}
 801be3e:	f7ff ffeb 	bl	801be18 <MemManage_Handler>
 801be42:	bf00      	nop

0801be44 <SVC_Handler>:
 801be44:	4b05      	ldr	r3, [pc, #20]	; (801be5c <SVC_Handler+0x18>)
 801be46:	2001      	movs	r0, #1
 801be48:	2100      	movs	r1, #0
 801be4a:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801be4e:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801be52:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801be56:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
 801be5a:	4770      	bx	lr
 801be5c:	20001b38 	.word	0x20001b38

0801be60 <DebugMon_Handler>:
 801be60:	4b05      	ldr	r3, [pc, #20]	; (801be78 <DebugMon_Handler+0x18>)
 801be62:	2001      	movs	r0, #1
 801be64:	2100      	movs	r1, #0
 801be66:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801be6a:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801be6e:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801be72:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
 801be76:	4770      	bx	lr
 801be78:	20001b38 	.word	0x20001b38

0801be7c <PendSV_Handler>:
 801be7c:	4b05      	ldr	r3, [pc, #20]	; (801be94 <PendSV_Handler+0x18>)
 801be7e:	2001      	movs	r0, #1
 801be80:	2100      	movs	r1, #0
 801be82:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801be86:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801be8a:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801be8e:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
 801be92:	4770      	bx	lr
 801be94:	20001b38 	.word	0x20001b38

0801be98 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801be98:	4b06      	ldr	r3, [pc, #24]	; (801beb4 <SysTick_Handler+0x1c>)
 801be9a:	2001      	movs	r0, #1
 801be9c:	2100      	movs	r1, #0
 801be9e:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801bea2:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801bea6:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801beaa:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
	}
  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 801beae:	f7e4 bdaf 	b.w	8000a10 <HAL_IncTick>
 801beb2:	bf00      	nop
 801beb4:	20001b38 	.word	0x20001b38

0801beb8 <DMA1_Stream1_IRQHandler>:

/**
  * @brief This function handles DMA1 stream1 global interrupt.
  */
void DMA1_Stream1_IRQHandler(void)
{
 801beb8:	b430      	push	{r4, r5}
  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801beba:	4b07      	ldr	r3, [pc, #28]	; (801bed8 <DMA1_Stream1_IRQHandler+0x20>)
 801bebc:	2401      	movs	r4, #1
 801bebe:	2500      	movs	r5, #0
	}
  /* USER CODE END DMA1_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sai1_a);
 801bec0:	4806      	ldr	r0, [pc, #24]	; (801bedc <DMA1_Stream1_IRQHandler+0x24>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bec2:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801bec6:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801beca:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801bece:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN DMA1_Stream1_IRQn 1 */

  /* USER CODE END DMA1_Stream1_IRQn 1 */
}
 801bed2:	bc30      	pop	{r4, r5}
  HAL_DMA_IRQHandler(&hdma_sai1_a);
 801bed4:	f7e8 b8c8 	b.w	8004068 <HAL_DMA_IRQHandler>
 801bed8:	20001b38 	.word	0x20001b38
 801bedc:	20001ce8 	.word	0x20001ce8

0801bee0 <DMA1_Stream2_IRQHandler>:

/**
  * @brief This function handles DMA1 stream2 global interrupt.
  */
void DMA1_Stream2_IRQHandler(void)
{
 801bee0:	b430      	push	{r4, r5}
  /* USER CODE BEGIN DMA1_Stream2_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bee2:	4b07      	ldr	r3, [pc, #28]	; (801bf00 <DMA1_Stream2_IRQHandler+0x20>)
 801bee4:	2401      	movs	r4, #1
 801bee6:	2500      	movs	r5, #0
	}
  /* USER CODE END DMA1_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sai1_b);
 801bee8:	4806      	ldr	r0, [pc, #24]	; (801bf04 <DMA1_Stream2_IRQHandler+0x24>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801beea:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801beee:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801bef2:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801bef6:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN DMA1_Stream2_IRQn 1 */

  /* USER CODE END DMA1_Stream2_IRQn 1 */
}
 801befa:	bc30      	pop	{r4, r5}
  HAL_DMA_IRQHandler(&hdma_sai1_b);
 801befc:	f7e8 b8b4 	b.w	8004068 <HAL_DMA_IRQHandler>
 801bf00:	20001b38 	.word	0x20001b38
 801bf04:	20001d60 	.word	0x20001d60

0801bf08 <ADC_IRQHandler>:

/**
  * @brief This function handles ADC1 and ADC2 global interrupts.
  */
void ADC_IRQHandler(void)
{
 801bf08:	b430      	push	{r4, r5}
  /* USER CODE BEGIN ADC_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bf0a:	4b07      	ldr	r3, [pc, #28]	; (801bf28 <ADC_IRQHandler+0x20>)
 801bf0c:	2401      	movs	r4, #1
 801bf0e:	2500      	movs	r5, #0
	}
  /* USER CODE END ADC_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc1);
 801bf10:	4806      	ldr	r0, [pc, #24]	; (801bf2c <ADC_IRQHandler+0x24>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bf12:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801bf16:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801bf1a:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801bf1e:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN ADC_IRQn 1 */

  /* USER CODE END ADC_IRQn 1 */
}
 801bf22:	bc30      	pop	{r4, r5}
  HAL_ADC_IRQHandler(&hadc1);
 801bf24:	f7e4 beb2 	b.w	8000c8c <HAL_ADC_IRQHandler>
 801bf28:	20001b38 	.word	0x20001b38
 801bf2c:	200006b8 	.word	0x200006b8

0801bf30 <DMA2_Stream0_IRQHandler>:

/**
  * @brief This function handles DMA2 stream0 global interrupt.
  */
void DMA2_Stream0_IRQHandler(void)
{
 801bf30:	b430      	push	{r4, r5}
  /* USER CODE BEGIN DMA2_Stream0_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bf32:	4b07      	ldr	r3, [pc, #28]	; (801bf50 <DMA2_Stream0_IRQHandler+0x20>)
 801bf34:	2401      	movs	r4, #1
 801bf36:	2500      	movs	r5, #0
	}
  /* USER CODE END DMA2_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 801bf38:	4806      	ldr	r0, [pc, #24]	; (801bf54 <DMA2_Stream0_IRQHandler+0x24>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bf3a:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801bf3e:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801bf42:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801bf46:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN DMA2_Stream0_IRQn 1 */

  /* USER CODE END DMA2_Stream0_IRQn 1 */
}
 801bf4a:	bc30      	pop	{r4, r5}
  HAL_DMA_IRQHandler(&hdma_adc1);
 801bf4c:	f7e8 b88c 	b.w	8004068 <HAL_DMA_IRQHandler>
 801bf50:	20001b38 	.word	0x20001b38
 801bf54:	2000071c 	.word	0x2000071c

0801bf58 <SAI1_IRQHandler>:
/**
  * @brief This function handles SAI1 global interrupt.
  */
uint8_t isItCalled = 0;
void SAI1_IRQHandler(void)
{
 801bf58:	b538      	push	{r3, r4, r5, lr}
  /* USER CODE BEGIN SAI1_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
	}
	isItCalled = 1;
 801bf5a:	4a0b      	ldr	r2, [pc, #44]	; (801bf88 <SAI1_IRQHandler+0x30>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bf5c:	2401      	movs	r4, #1
 801bf5e:	4b0b      	ldr	r3, [pc, #44]	; (801bf8c <SAI1_IRQHandler+0x34>)
 801bf60:	2500      	movs	r5, #0
	isItCalled = 1;
 801bf62:	2101      	movs	r1, #1
  /* USER CODE END SAI1_IRQn 0 */
  HAL_SAI_IRQHandler(&hsai_BlockA1);
 801bf64:	480a      	ldr	r0, [pc, #40]	; (801bf90 <SAI1_IRQHandler+0x38>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bf66:	e9c3 4504 	strd	r4, r5, [r3, #16]
	isItCalled = 1;
 801bf6a:	7011      	strb	r1, [r2, #0]
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bf6c:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801bf70:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801bf74:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  HAL_SAI_IRQHandler(&hsai_BlockA1);
 801bf78:	f7ef f926 	bl	800b1c8 <HAL_SAI_IRQHandler>
  HAL_SAI_IRQHandler(&hsai_BlockB1);
 801bf7c:	4805      	ldr	r0, [pc, #20]	; (801bf94 <SAI1_IRQHandler+0x3c>)
  /* USER CODE BEGIN SAI1_IRQn 1 */

  /* USER CODE END SAI1_IRQn 1 */
}
 801bf7e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_SAI_IRQHandler(&hsai_BlockB1);
 801bf82:	f7ef b921 	b.w	800b1c8 <HAL_SAI_IRQHandler>
 801bf86:	bf00      	nop
 801bf88:	20000630 	.word	0x20000630
 801bf8c:	20001b38 	.word	0x20001b38
 801bf90:	20001dd8 	.word	0x20001dd8
 801bf94:	20001c50 	.word	0x20001c50

0801bf98 <I2C4_EV_IRQHandler>:

/**
  * @brief This function handles I2C4 event interrupt.
  */
void I2C4_EV_IRQHandler(void)
{
 801bf98:	b430      	push	{r4, r5}
  /* USER CODE BEGIN I2C4_EV_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bf9a:	4b07      	ldr	r3, [pc, #28]	; (801bfb8 <I2C4_EV_IRQHandler+0x20>)
 801bf9c:	2401      	movs	r4, #1
 801bf9e:	2500      	movs	r5, #0
	}
  /* USER CODE END I2C4_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c4);
 801bfa0:	4806      	ldr	r0, [pc, #24]	; (801bfbc <I2C4_EV_IRQHandler+0x24>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bfa2:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801bfa6:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801bfaa:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801bfae:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN I2C4_EV_IRQn 1 */

  /* USER CODE END I2C4_EV_IRQn 1 */
}
 801bfb2:	bc30      	pop	{r4, r5}
  HAL_I2C_EV_IRQHandler(&hi2c4);
 801bfb4:	f7ea bd26 	b.w	8006a04 <HAL_I2C_EV_IRQHandler>
 801bfb8:	20001b38 	.word	0x20001b38
 801bfbc:	200015f0 	.word	0x200015f0

0801bfc0 <I2C4_ER_IRQHandler>:

/**
  * @brief This function handles I2C4 error interrupt.
  */
void I2C4_ER_IRQHandler(void)
{
 801bfc0:	b430      	push	{r4, r5}
  /* USER CODE BEGIN I2C4_ER_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bfc2:	4b07      	ldr	r3, [pc, #28]	; (801bfe0 <I2C4_ER_IRQHandler+0x20>)
 801bfc4:	2401      	movs	r4, #1
 801bfc6:	2500      	movs	r5, #0
	}
  /* USER CODE END I2C4_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c4);
 801bfc8:	4806      	ldr	r0, [pc, #24]	; (801bfe4 <I2C4_ER_IRQHandler+0x24>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bfca:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801bfce:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801bfd2:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801bfd6:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN I2C4_ER_IRQn 1 */

  /* USER CODE END I2C4_ER_IRQn 1 */
}
 801bfda:	bc30      	pop	{r4, r5}
  HAL_I2C_ER_IRQHandler(&hi2c4);
 801bfdc:	f7eb bd5a 	b.w	8007a94 <HAL_I2C_ER_IRQHandler>
 801bfe0:	20001b38 	.word	0x20001b38
 801bfe4:	200015f0 	.word	0x200015f0

0801bfe8 <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 801bfe8:	b430      	push	{r4, r5}
  /* USER CODE BEGIN OTG_FS_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bfea:	4b07      	ldr	r3, [pc, #28]	; (801c008 <OTG_FS_IRQHandler+0x20>)
 801bfec:	2401      	movs	r4, #1
 801bfee:	2500      	movs	r5, #0
	}
  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_HCD_IRQHandler(&hhcd_USB_OTG_FS);
 801bff0:	4806      	ldr	r0, [pc, #24]	; (801c00c <OTG_FS_IRQHandler+0x24>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801bff2:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801bff6:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801bffa:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801bffe:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 801c002:	bc30      	pop	{r4, r5}
  HAL_HCD_IRQHandler(&hhcd_USB_OTG_FS);
 801c004:	f7e9 bd4e 	b.w	8005aa4 <HAL_HCD_IRQHandler>
 801c008:	20001b38 	.word	0x20001b38
 801c00c:	20019224 	.word	0x20019224

0801c010 <DMAMUX1_OVR_IRQHandler>:

/**
  * @brief This function handles DMAMUX1 overrun interrupt.
  */
void DMAMUX1_OVR_IRQHandler(void)
{
 801c010:	b430      	push	{r4, r5}
  /* USER CODE BEGIN DMAMUX1_OVR_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801c012:	4b07      	ldr	r3, [pc, #28]	; (801c030 <DMAMUX1_OVR_IRQHandler+0x20>)
 801c014:	2401      	movs	r4, #1
 801c016:	2500      	movs	r5, #0
	}
  /* USER CODE END DMAMUX1_OVR_IRQn 0 */
  // Handle DMA2_Stream0
  HAL_DMAEx_MUX_IRQHandler(&hdma_adc1);
 801c018:	4806      	ldr	r0, [pc, #24]	; (801c034 <DMAMUX1_OVR_IRQHandler+0x24>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801c01a:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801c01e:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801c022:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801c026:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN DMAMUX1_OVR_IRQn 1 */

  /* USER CODE END DMAMUX1_OVR_IRQn 1 */
}
 801c02a:	bc30      	pop	{r4, r5}
  HAL_DMAEx_MUX_IRQHandler(&hdma_adc1);
 801c02c:	f7e8 bda8 	b.w	8004b80 <HAL_DMAEx_MUX_IRQHandler>
 801c030:	20001b38 	.word	0x20001b38
 801c034:	2000071c 	.word	0x2000071c

0801c038 <BDMA_Channel0_IRQHandler>:

/**
  * @brief This function handles BDMA channel0 global interrupt.
  */
void BDMA_Channel0_IRQHandler(void)
{
 801c038:	b430      	push	{r4, r5}
  /* USER CODE BEGIN BDMA_Channel0_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801c03a:	4b07      	ldr	r3, [pc, #28]	; (801c058 <BDMA_Channel0_IRQHandler+0x20>)
 801c03c:	2401      	movs	r4, #1
 801c03e:	2500      	movs	r5, #0
	}
  /* USER CODE END BDMA_Channel0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_i2c4_rx);
 801c040:	4806      	ldr	r0, [pc, #24]	; (801c05c <BDMA_Channel0_IRQHandler+0x24>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801c042:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801c046:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801c04a:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801c04e:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN BDMA_Channel0_IRQn 1 */

  /* USER CODE END BDMA_Channel0_IRQn 1 */
}
 801c052:	bc30      	pop	{r4, r5}
  HAL_DMA_IRQHandler(&hdma_i2c4_rx);
 801c054:	f7e8 b808 	b.w	8004068 <HAL_DMA_IRQHandler>
 801c058:	20001b38 	.word	0x20001b38
 801c05c:	20001688 	.word	0x20001688

0801c060 <BDMA_Channel1_IRQHandler>:

/**
  * @brief This function handles BDMA channel1 global interrupt.
  */
void BDMA_Channel1_IRQHandler(void)
{
 801c060:	b430      	push	{r4, r5}
  /* USER CODE BEGIN BDMA_Channel1_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801c062:	4b07      	ldr	r3, [pc, #28]	; (801c080 <BDMA_Channel1_IRQHandler+0x20>)
 801c064:	2401      	movs	r4, #1
 801c066:	2500      	movs	r5, #0
	}
  /* USER CODE END BDMA_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_i2c4_tx);
 801c068:	4806      	ldr	r0, [pc, #24]	; (801c084 <BDMA_Channel1_IRQHandler+0x24>)
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801c06a:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801c06e:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801c072:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801c076:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN BDMA_Channel1_IRQn 1 */

  /* USER CODE END BDMA_Channel1_IRQn 1 */
}
 801c07a:	bc30      	pop	{r4, r5}
  HAL_DMA_IRQHandler(&hdma_i2c4_tx);
 801c07c:	f7e7 bff4 	b.w	8004068 <HAL_DMA_IRQHandler>
 801c080:	20001b38 	.word	0x20001b38
 801c084:	20001578 	.word	0x20001578

0801c088 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 801c088:	b430      	push	{r4, r5}
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 801c08a:	4c19      	ldr	r4, [pc, #100]	; (801c0f0 <SystemInit+0x68>)
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 801c08c:	2200      	movs	r2, #0
  RCC->CR |= RCC_CR_HSION;
 801c08e:	4b19      	ldr	r3, [pc, #100]	; (801c0f4 <SystemInit+0x6c>)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 801c090:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88

  /* Reset HSEON, CSSON , CSION,RC48ON, CSIKERON PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 801c094:	4818      	ldr	r0, [pc, #96]	; (801c0f8 <SystemInit+0x70>)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 801c096:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  SCB->VTOR = FLASH_BANK2_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
#endif /* VECT_TAB_SRAM */

#else
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 801c09a:	4d18      	ldr	r5, [pc, #96]	; (801c0fc <SystemInit+0x74>)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 801c09c:	f8c4 1088 	str.w	r1, [r4, #136]	; 0x88
  RCC->CR |= RCC_CR_HSION;
 801c0a0:	681c      	ldr	r4, [r3, #0]
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 801c0a2:	4917      	ldr	r1, [pc, #92]	; (801c100 <SystemInit+0x78>)
  RCC->CR |= RCC_CR_HSION;
 801c0a4:	f044 0401 	orr.w	r4, r4, #1
 801c0a8:	601c      	str	r4, [r3, #0]
  RCC->CFGR = 0x00000000;
 801c0aa:	611a      	str	r2, [r3, #16]
  RCC->CR &= 0xEAF6ED7FU;
 801c0ac:	681c      	ldr	r4, [r3, #0]
 801c0ae:	4020      	ands	r0, r4
 801c0b0:	6018      	str	r0, [r3, #0]
  RCC->D1CFGR = 0x00000000;
 801c0b2:	619a      	str	r2, [r3, #24]
  RCC->D2CFGR = 0x00000000;
 801c0b4:	61da      	str	r2, [r3, #28]
  RCC->D3CFGR = 0x00000000;
 801c0b6:	621a      	str	r2, [r3, #32]
  RCC->PLLCKSELR = 0x00000000;
 801c0b8:	629a      	str	r2, [r3, #40]	; 0x28
  RCC->PLLCFGR = 0x00000000;
 801c0ba:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->PLL1DIVR = 0x00000000;
 801c0bc:	631a      	str	r2, [r3, #48]	; 0x30
  RCC->PLL1FRACR = 0x00000000;
 801c0be:	635a      	str	r2, [r3, #52]	; 0x34
  RCC->PLL2DIVR = 0x00000000;
 801c0c0:	639a      	str	r2, [r3, #56]	; 0x38
  RCC->PLL2FRACR = 0x00000000;
 801c0c2:	63da      	str	r2, [r3, #60]	; 0x3c
  RCC->PLL3DIVR = 0x00000000;
 801c0c4:	641a      	str	r2, [r3, #64]	; 0x40
  RCC->PLL3FRACR = 0x00000000;
 801c0c6:	645a      	str	r2, [r3, #68]	; 0x44
  RCC->CR &= 0xFFFBFFFFU;
 801c0c8:	6818      	ldr	r0, [r3, #0]
 801c0ca:	f420 2080 	bic.w	r0, r0, #262144	; 0x40000
 801c0ce:	6018      	str	r0, [r3, #0]
  RCC->CIER = 0x00000000;
 801c0d0:	661a      	str	r2, [r3, #96]	; 0x60
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 801c0d2:	682b      	ldr	r3, [r5, #0]
 801c0d4:	4019      	ands	r1, r3
 801c0d6:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 801c0da:	d202      	bcs.n	801c0e2 <SystemInit+0x5a>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
 801c0dc:	4b09      	ldr	r3, [pc, #36]	; (801c104 <SystemInit+0x7c>)
 801c0de:	2201      	movs	r2, #1
 801c0e0:	601a      	str	r2, [r3, #0]

  /* Configure the Vector Table location add offset address for cortex-M7 ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM */
#else
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 801c0e2:	4b03      	ldr	r3, [pc, #12]	; (801c0f0 <SystemInit+0x68>)
 801c0e4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 801c0e8:	609a      	str	r2, [r3, #8]
#endif

#endif /*DUAL_CORE && CORE_CM4*/

}
 801c0ea:	bc30      	pop	{r4, r5}
 801c0ec:	4770      	bx	lr
 801c0ee:	bf00      	nop
 801c0f0:	e000ed00 	.word	0xe000ed00
 801c0f4:	58024400 	.word	0x58024400
 801c0f8:	eaf6ed7f 	.word	0xeaf6ed7f
 801c0fc:	5c001000 	.word	0x5c001000
 801c100:	ffff0000 	.word	0xffff0000
 801c104:	51008108 	.word	0x51008108

0801c108 <MX_TIM3_Init>:
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;

/* TIM3 init function */
void MX_TIM3_Init(void)
{
 801c108:	b530      	push	{r4, r5, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  htim3.Instance = TIM3;
 801c10a:	4c39      	ldr	r4, [pc, #228]	; (801c1f0 <MX_TIM3_Init+0xe8>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801c10c:	2300      	movs	r3, #0
{
 801c10e:	b093      	sub	sp, #76	; 0x4c
  htim3.Init.Prescaler = 0;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 1024;
 801c110:	f44f 6280 	mov.w	r2, #1024	; 0x400
  htim3.Instance = TIM3;
 801c114:	4937      	ldr	r1, [pc, #220]	; (801c1f4 <MX_TIM3_Init+0xec>)
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 801c116:	4620      	mov	r0, r4
  htim3.Init.Period = 1024;
 801c118:	60e2      	str	r2, [r4, #12]
  htim3.Instance = TIM3;
 801c11a:	6021      	str	r1, [r4, #0]
  htim3.Init.Prescaler = 0;
 801c11c:	6063      	str	r3, [r4, #4]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801c11e:	9303      	str	r3, [sp, #12]
  TIM_OC_InitTypeDef sConfigOC = {0};
 801c120:	930b      	str	r3, [sp, #44]	; 0x2c
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 801c122:	60a3      	str	r3, [r4, #8]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801c124:	6123      	str	r3, [r4, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801c126:	61a3      	str	r3, [r4, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801c128:	e9cd 3304 	strd	r3, r3, [sp, #16]
  TIM_OC_InitTypeDef sConfigOC = {0};
 801c12c:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
 801c130:	e9cd 330e 	strd	r3, r3, [sp, #56]	; 0x38
 801c134:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 801c138:	f7f0 fad4 	bl	800c6e4 <HAL_TIM_PWM_Init>
 801c13c:	bb38      	cbnz	r0, 801c18e <MX_TIM3_Init+0x86>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801c13e:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 801c140:	a903      	add	r1, sp, #12
 801c142:	482b      	ldr	r0, [pc, #172]	; (801c1f0 <MX_TIM3_Init+0xe8>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801c144:	9303      	str	r3, [sp, #12]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801c146:	9305      	str	r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 801c148:	f7f1 fad2 	bl	800d6f0 <HAL_TIMEx_MasterConfigSynchronization>
 801c14c:	b9e0      	cbnz	r0, 801c188 <MX_TIM3_Init+0x80>
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
 801c14e:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 801c150:	2560      	movs	r5, #96	; 0x60
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 801c152:	a90b      	add	r1, sp, #44	; 0x2c
 801c154:	2204      	movs	r2, #4
 801c156:	4826      	ldr	r0, [pc, #152]	; (801c1f0 <MX_TIM3_Init+0xe8>)
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 801c158:	930d      	str	r3, [sp, #52]	; 0x34
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 801c15a:	930f      	str	r3, [sp, #60]	; 0x3c
  sConfigOC.Pulse = 0;
 801c15c:	e9cd 530b 	strd	r5, r3, [sp, #44]	; 0x2c
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 801c160:	f7f1 f838 	bl	800d1d4 <HAL_TIM_PWM_ConfigChannel>
 801c164:	b108      	cbz	r0, 801c16a <MX_TIM3_Init+0x62>
  {
    Error_Handler();
 801c166:	f7f7 fbb1 	bl	80138cc <Error_Handler>
}
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(timHandle->Instance==TIM3)
 801c16a:	6822      	ldr	r2, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801c16c:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM3)
 801c16e:	4921      	ldr	r1, [pc, #132]	; (801c1f4 <MX_TIM3_Init+0xec>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801c170:	930a      	str	r3, [sp, #40]	; 0x28
  if(timHandle->Instance==TIM3)
 801c172:	428a      	cmp	r2, r1
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801c174:	e9cd 3306 	strd	r3, r3, [sp, #24]
 801c178:	e9cd 3308 	strd	r3, r3, [sp, #32]
  if(timHandle->Instance==TIM3)
 801c17c:	d021      	beq.n	801c1c2 <MX_TIM3_Init+0xba>

  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM4)
 801c17e:	4b1e      	ldr	r3, [pc, #120]	; (801c1f8 <MX_TIM3_Init+0xf0>)
 801c180:	429a      	cmp	r2, r3
 801c182:	d007      	beq.n	801c194 <MX_TIM3_Init+0x8c>
}
 801c184:	b013      	add	sp, #76	; 0x4c
 801c186:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
 801c188:	f7f7 fba0 	bl	80138cc <Error_Handler>
 801c18c:	e7df      	b.n	801c14e <MX_TIM3_Init+0x46>
    Error_Handler();
 801c18e:	f7f7 fb9d 	bl	80138cc <Error_Handler>
 801c192:	e7d4      	b.n	801c13e <MX_TIM3_Init+0x36>
  {
  /* USER CODE BEGIN TIM4_MspPostInit 0 */

  /* USER CODE END TIM4_MspPostInit 0 */
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c194:	4b19      	ldr	r3, [pc, #100]	; (801c1fc <MX_TIM3_Init+0xf4>)
    PB6     ------> TIM4_CH1
    PB7     ------> TIM4_CH2
    PB8     ------> TIM4_CH3 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801c196:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
 801c198:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c19c:	a906      	add	r1, sp, #24
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c19e:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c1a2:	4817      	ldr	r0, [pc, #92]	; (801c200 <MX_TIM3_Init+0xf8>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c1a4:	4322      	orrs	r2, r4
 801c1a6:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 801c1aa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
 801c1ae:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c1b0:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801c1b2:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 801c1b4:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c1b6:	9302      	str	r3, [sp, #8]
 801c1b8:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c1ba:	f7e9 f801 	bl	80051c0 <HAL_GPIO_Init>
}
 801c1be:	b013      	add	sp, #76	; 0x4c
 801c1c0:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c1c2:	4b0e      	ldr	r3, [pc, #56]	; (801c1fc <MX_TIM3_Init+0xf4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801c1c4:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801c1c6:	2520      	movs	r5, #32
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c1c8:	a906      	add	r1, sp, #24
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c1ca:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c1ce:	480c      	ldr	r0, [pc, #48]	; (801c200 <MX_TIM3_Init+0xf8>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c1d0:	4322      	orrs	r2, r4
 801c1d2:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 801c1d6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801c1da:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c1dc:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801c1de:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 801c1e0:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c1e2:	9301      	str	r3, [sp, #4]
 801c1e4:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c1e6:	f7e8 ffeb 	bl	80051c0 <HAL_GPIO_Init>
}
 801c1ea:	b013      	add	sp, #76	; 0x4c
 801c1ec:	bd30      	pop	{r4, r5, pc}
 801c1ee:	bf00      	nop
 801c1f0:	200186c8 	.word	0x200186c8
 801c1f4:	40000400 	.word	0x40000400
 801c1f8:	40000800 	.word	0x40000800
 801c1fc:	58024400 	.word	0x58024400
 801c200:	58020400 	.word	0x58020400

0801c204 <MX_TIM4_Init>:
{
 801c204:	b530      	push	{r4, r5, lr}
  htim4.Instance = TIM4;
 801c206:	4c4e      	ldr	r4, [pc, #312]	; (801c340 <MX_TIM4_Init+0x13c>)
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801c208:	2300      	movs	r3, #0
{
 801c20a:	b097      	sub	sp, #92	; 0x5c
  htim4.Init.Period = 1024;
 801c20c:	f44f 6280 	mov.w	r2, #1024	; 0x400
  htim4.Instance = TIM4;
 801c210:	494c      	ldr	r1, [pc, #304]	; (801c344 <MX_TIM4_Init+0x140>)
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
 801c212:	4620      	mov	r0, r4
  htim4.Init.Period = 1024;
 801c214:	60e2      	str	r2, [r4, #12]
  htim4.Instance = TIM4;
 801c216:	6021      	str	r1, [r4, #0]
  htim4.Init.Prescaler = 0;
 801c218:	6063      	str	r3, [r4, #4]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801c21a:	9306      	str	r3, [sp, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801c21c:	9303      	str	r3, [sp, #12]
  TIM_OC_InitTypeDef sConfigOC = {0};
 801c21e:	930f      	str	r3, [sp, #60]	; 0x3c
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 801c220:	60a3      	str	r3, [r4, #8]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801c222:	6123      	str	r3, [r4, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801c224:	61a3      	str	r3, [r4, #24]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801c226:	9309      	str	r3, [sp, #36]	; 0x24
 801c228:	e9cd 3307 	strd	r3, r3, [sp, #28]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801c22c:	e9cd 3304 	strd	r3, r3, [sp, #16]
  TIM_OC_InitTypeDef sConfigOC = {0};
 801c230:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
 801c234:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
 801c238:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
 801c23c:	f7f0 f93c 	bl	800c4b8 <HAL_TIM_Base_Init>
 801c240:	2800      	cmp	r0, #0
 801c242:	d14d      	bne.n	801c2e0 <MX_TIM4_Init+0xdc>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801c244:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 801c248:	a906      	add	r1, sp, #24
 801c24a:	483d      	ldr	r0, [pc, #244]	; (801c340 <MX_TIM4_Init+0x13c>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801c24c:	9306      	str	r3, [sp, #24]
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 801c24e:	f7f0 fc49 	bl	800cae4 <HAL_TIM_ConfigClockSource>
 801c252:	2800      	cmp	r0, #0
 801c254:	d141      	bne.n	801c2da <MX_TIM4_Init+0xd6>
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
 801c256:	483a      	ldr	r0, [pc, #232]	; (801c340 <MX_TIM4_Init+0x13c>)
 801c258:	f7f0 fa44 	bl	800c6e4 <HAL_TIM_PWM_Init>
 801c25c:	2800      	cmp	r0, #0
 801c25e:	d139      	bne.n	801c2d4 <MX_TIM4_Init+0xd0>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801c260:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 801c262:	a903      	add	r1, sp, #12
 801c264:	4836      	ldr	r0, [pc, #216]	; (801c340 <MX_TIM4_Init+0x13c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801c266:	9303      	str	r3, [sp, #12]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801c268:	9305      	str	r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 801c26a:	f7f1 fa41 	bl	800d6f0 <HAL_TIMEx_MasterConfigSynchronization>
 801c26e:	bb70      	cbnz	r0, 801c2ce <MX_TIM4_Init+0xca>
  sConfigOC.Pulse = 0;
 801c270:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 801c272:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 801c274:	a90f      	add	r1, sp, #60	; 0x3c
 801c276:	4832      	ldr	r0, [pc, #200]	; (801c340 <MX_TIM4_Init+0x13c>)
 801c278:	461a      	mov	r2, r3
  sConfigOC.Pulse = 0;
 801c27a:	9310      	str	r3, [sp, #64]	; 0x40
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 801c27c:	9311      	str	r3, [sp, #68]	; 0x44
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 801c27e:	9313      	str	r3, [sp, #76]	; 0x4c
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 801c280:	950f      	str	r5, [sp, #60]	; 0x3c
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 801c282:	f7f0 ffa7 	bl	800d1d4 <HAL_TIM_PWM_ConfigChannel>
 801c286:	b9f8      	cbnz	r0, 801c2c8 <MX_TIM4_Init+0xc4>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 801c288:	2204      	movs	r2, #4
 801c28a:	a90f      	add	r1, sp, #60	; 0x3c
 801c28c:	482c      	ldr	r0, [pc, #176]	; (801c340 <MX_TIM4_Init+0x13c>)
 801c28e:	f7f0 ffa1 	bl	800d1d4 <HAL_TIM_PWM_ConfigChannel>
 801c292:	b9b0      	cbnz	r0, 801c2c2 <MX_TIM4_Init+0xbe>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 801c294:	a90f      	add	r1, sp, #60	; 0x3c
 801c296:	2208      	movs	r2, #8
 801c298:	4829      	ldr	r0, [pc, #164]	; (801c340 <MX_TIM4_Init+0x13c>)
 801c29a:	f7f0 ff9b 	bl	800d1d4 <HAL_TIM_PWM_ConfigChannel>
 801c29e:	b108      	cbz	r0, 801c2a4 <MX_TIM4_Init+0xa0>
    Error_Handler();
 801c2a0:	f7f7 fb14 	bl	80138cc <Error_Handler>
  if(timHandle->Instance==TIM3)
 801c2a4:	6822      	ldr	r2, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801c2a6:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM3)
 801c2a8:	4927      	ldr	r1, [pc, #156]	; (801c348 <MX_TIM4_Init+0x144>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801c2aa:	930e      	str	r3, [sp, #56]	; 0x38
  if(timHandle->Instance==TIM3)
 801c2ac:	428a      	cmp	r2, r1
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801c2ae:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
 801c2b2:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  if(timHandle->Instance==TIM3)
 801c2b6:	d02d      	beq.n	801c314 <MX_TIM4_Init+0x110>
  else if(timHandle->Instance==TIM4)
 801c2b8:	4b22      	ldr	r3, [pc, #136]	; (801c344 <MX_TIM4_Init+0x140>)
 801c2ba:	429a      	cmp	r2, r3
 801c2bc:	d013      	beq.n	801c2e6 <MX_TIM4_Init+0xe2>
}
 801c2be:	b017      	add	sp, #92	; 0x5c
 801c2c0:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
 801c2c2:	f7f7 fb03 	bl	80138cc <Error_Handler>
 801c2c6:	e7e5      	b.n	801c294 <MX_TIM4_Init+0x90>
    Error_Handler();
 801c2c8:	f7f7 fb00 	bl	80138cc <Error_Handler>
 801c2cc:	e7dc      	b.n	801c288 <MX_TIM4_Init+0x84>
    Error_Handler();
 801c2ce:	f7f7 fafd 	bl	80138cc <Error_Handler>
 801c2d2:	e7cd      	b.n	801c270 <MX_TIM4_Init+0x6c>
    Error_Handler();
 801c2d4:	f7f7 fafa 	bl	80138cc <Error_Handler>
 801c2d8:	e7c2      	b.n	801c260 <MX_TIM4_Init+0x5c>
    Error_Handler();
 801c2da:	f7f7 faf7 	bl	80138cc <Error_Handler>
 801c2de:	e7ba      	b.n	801c256 <MX_TIM4_Init+0x52>
    Error_Handler();
 801c2e0:	f7f7 faf4 	bl	80138cc <Error_Handler>
 801c2e4:	e7ae      	b.n	801c244 <MX_TIM4_Init+0x40>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c2e6:	4b19      	ldr	r3, [pc, #100]	; (801c34c <MX_TIM4_Init+0x148>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801c2e8:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
 801c2ea:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c2ee:	a90a      	add	r1, sp, #40	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c2f0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c2f4:	4816      	ldr	r0, [pc, #88]	; (801c350 <MX_TIM4_Init+0x14c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c2f6:	4322      	orrs	r2, r4
 801c2f8:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 801c2fc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
 801c300:	950a      	str	r5, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c302:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801c304:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 801c306:	940e      	str	r4, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c308:	9302      	str	r3, [sp, #8]
 801c30a:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c30c:	f7e8 ff58 	bl	80051c0 <HAL_GPIO_Init>
}
 801c310:	b017      	add	sp, #92	; 0x5c
 801c312:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c314:	4b0d      	ldr	r3, [pc, #52]	; (801c34c <MX_TIM4_Init+0x148>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801c316:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801c318:	2520      	movs	r5, #32
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c31a:	a90a      	add	r1, sp, #40	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c31c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c320:	480b      	ldr	r0, [pc, #44]	; (801c350 <MX_TIM4_Init+0x14c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c322:	4322      	orrs	r2, r4
 801c324:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 801c328:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801c32c:	950a      	str	r5, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c32e:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801c330:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 801c332:	940e      	str	r4, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801c334:	9301      	str	r3, [sp, #4]
 801c336:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801c338:	f7e8 ff42 	bl	80051c0 <HAL_GPIO_Init>
}
 801c33c:	b017      	add	sp, #92	; 0x5c
 801c33e:	bd30      	pop	{r4, r5, pc}
 801c340:	20018688 	.word	0x20018688
 801c344:	40000800 	.word	0x40000800
 801c348:	40000400 	.word	0x40000400
 801c34c:	58024400 	.word	0x58024400
 801c350:	58020400 	.word	0x58020400

0801c354 <HAL_TIM_PWM_MspInit>:
  if(tim_pwmHandle->Instance==TIM3)
 801c354:	6802      	ldr	r2, [r0, #0]
 801c356:	4b0a      	ldr	r3, [pc, #40]	; (801c380 <HAL_TIM_PWM_MspInit+0x2c>)
 801c358:	429a      	cmp	r2, r3
 801c35a:	d000      	beq.n	801c35e <HAL_TIM_PWM_MspInit+0xa>
 801c35c:	4770      	bx	lr
    __HAL_RCC_TIM3_CLK_ENABLE();
 801c35e:	4b09      	ldr	r3, [pc, #36]	; (801c384 <HAL_TIM_PWM_MspInit+0x30>)
{
 801c360:	b082      	sub	sp, #8
    __HAL_RCC_TIM3_CLK_ENABLE();
 801c362:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 801c366:	f042 0202 	orr.w	r2, r2, #2
 801c36a:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
 801c36e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 801c372:	f003 0302 	and.w	r3, r3, #2
 801c376:	9301      	str	r3, [sp, #4]
 801c378:	9b01      	ldr	r3, [sp, #4]
}
 801c37a:	b002      	add	sp, #8
 801c37c:	4770      	bx	lr
 801c37e:	bf00      	nop
 801c380:	40000400 	.word	0x40000400
 801c384:	58024400 	.word	0x58024400

0801c388 <HAL_TIM_Base_MspInit>:
  if(tim_baseHandle->Instance==TIM4)
 801c388:	6802      	ldr	r2, [r0, #0]
 801c38a:	4b0a      	ldr	r3, [pc, #40]	; (801c3b4 <HAL_TIM_Base_MspInit+0x2c>)
 801c38c:	429a      	cmp	r2, r3
 801c38e:	d000      	beq.n	801c392 <HAL_TIM_Base_MspInit+0xa>
 801c390:	4770      	bx	lr
    __HAL_RCC_TIM4_CLK_ENABLE();
 801c392:	4b09      	ldr	r3, [pc, #36]	; (801c3b8 <HAL_TIM_Base_MspInit+0x30>)
{
 801c394:	b082      	sub	sp, #8
    __HAL_RCC_TIM4_CLK_ENABLE();
 801c396:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 801c39a:	f042 0204 	orr.w	r2, r2, #4
 801c39e:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
 801c3a2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 801c3a6:	f003 0304 	and.w	r3, r3, #4
 801c3aa:	9301      	str	r3, [sp, #4]
 801c3ac:	9b01      	ldr	r3, [sp, #4]
}
 801c3ae:	b002      	add	sp, #8
 801c3b0:	4770      	bx	lr
 801c3b2:	bf00      	nop
 801c3b4:	40000800 	.word	0x40000800
 801c3b8:	58024400 	.word	0x58024400

0801c3bc <initModeNames>:
        VocodecPresetType currentPreset = (VocodecPresetType)0;
        VocodecPresetType previousPreset = PresetNil;
        uint8_t loadingPreset = 0;

        void initModeNames(void)
        {
 801c3bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c3c0:	4ad2      	ldr	r2, [pc, #840]	; (801c70c <initModeNames+0x350>)
 801c3c2:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
            for (int i = 0; i < NUM_ADC_CHANNELS; i++)
            {
                floatADCUI[i] = -1.0f;
                orderedParams[i] = i;
 801c3c6:	4cd2      	ldr	r4, [pc, #840]	; (801c710 <initModeNames+0x354>)
            }
            orderedParams[6] = ButtonA;
            orderedParams[7] = ButtonB;
 801c3c8:	f04f 0906 	mov.w	r9, #6
                floatADCUI[i] = -1.0f;
 801c3cc:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
                cvAddParam[i] = -1;
            }

            modeNames[Vocoder] = "VOCODER1";
            shortModeNames[Vocoder] = "VL";
            modeNamesDetails[Vocoder] = "LPC";
 801c3d0:	f8df b45c 	ldr.w	fp, [pc, #1116]	; 801c830 <initModeNames+0x474>
                floatADCUI[i] = -1.0f;
 801c3d4:	4bcf      	ldr	r3, [pc, #828]	; (801c714 <initModeNames+0x358>)
            orderedParams[7] = ButtonB;
 801c3d6:	f884 9007 	strb.w	r9, [r4, #7]
                orderedParams[i] = i;
 801c3da:	f04f 0904 	mov.w	r9, #4
 801c3de:	6017      	str	r7, [r2, #0]
 801c3e0:	6057      	str	r7, [r2, #4]
 801c3e2:	6097      	str	r7, [r2, #8]
 801c3e4:	60d7      	str	r7, [r2, #12]
 801c3e6:	8217      	strh	r7, [r2, #16]
 801c3e8:	f8df e448 	ldr.w	lr, [pc, #1096]	; 801c834 <initModeNames+0x478>
            modeNamesDetails[Vocoder] = "LPC";
 801c3ec:	4aca      	ldr	r2, [pc, #808]	; (801c718 <initModeNames+0x35c>)
                floatADCUI[i] = -1.0f;
 801c3ee:	edc3 7a00 	vstr	s15, [r3]
 801c3f2:	edc3 7a01 	vstr	s15, [r3, #4]
 801c3f6:	edc3 7a02 	vstr	s15, [r3, #8]
 801c3fa:	edc3 7a03 	vstr	s15, [r3, #12]
 801c3fe:	edc3 7a04 	vstr	s15, [r3, #16]
 801c402:	edc3 7a05 	vstr	s15, [r3, #20]
                orderedParams[i] = i;
 801c406:	f8c4 e000 	str.w	lr, [r4]
            numPages[Vocoder] = 2;
            knobParamNames[Vocoder][0] = "VOLUME";
 801c40a:	4bc4      	ldr	r3, [pc, #784]	; (801c71c <initModeNames+0x360>)
            knobParamNames[Vocoder][1] = "WARP";
 801c40c:	f8df e428 	ldr.w	lr, [pc, #1064]	; 801c838 <initModeNames+0x47c>
                orderedParams[i] = i;
 801c410:	f884 9004 	strb.w	r9, [r4, #4]
 801c414:	f04f 0905 	mov.w	r9, #5
            modeNamesDetails[Vocoder] = "LPC";
 801c418:	f8cb 2000 	str.w	r2, [fp]
            knobParamNames[Vocoder][0] = "VOLUME";
 801c41c:	4ac0      	ldr	r2, [pc, #768]	; (801c720 <initModeNames+0x364>)
                orderedParams[i] = i;
 801c41e:	f884 9005 	strb.w	r9, [r4, #5]
            orderedParams[6] = ButtonA;
 801c422:	f884 9006 	strb.w	r9, [r4, #6]
            knobParamNames[Vocoder][2] = "QUALITY";
            knobParamNames[Vocoder][3] = "SAWtoPULSE";
 801c426:	4cbf      	ldr	r4, [pc, #764]	; (801c724 <initModeNames+0x368>)
            modeNames[Vocoder] = "VOCODER1";
 801c428:	f8df 8410 	ldr.w	r8, [pc, #1040]	; 801c83c <initModeNames+0x480>
 801c42c:	f8df a410 	ldr.w	sl, [pc, #1040]	; 801c840 <initModeNames+0x484>
            knobParamNames[Vocoder][7] = "PULSEWIDTH";
            knobParamNames[Vocoder][8] = "PULSESHAPE";
            knobParamNames[Vocoder][9] = "";


            modeNames[VocoderCh] = "VOCODER2";
 801c430:	4dbd      	ldr	r5, [pc, #756]	; (801c728 <initModeNames+0x36c>)
            shortModeNames[Vocoder] = "VL";
 801c432:	f8df c410 	ldr.w	ip, [pc, #1040]	; 801c844 <initModeNames+0x488>
 801c436:	48bd      	ldr	r0, [pc, #756]	; (801c72c <initModeNames+0x370>)
            shortModeNames[VocoderCh] = "VC";
 801c438:	49bd      	ldr	r1, [pc, #756]	; (801c730 <initModeNames+0x374>)
            knobParamNames[Vocoder][4] = "NOISTHRESH";
 801c43a:	4fbe      	ldr	r7, [pc, #760]	; (801c734 <initModeNames+0x378>)
            shortModeNames[Vocoder] = "VL";
 801c43c:	f8cc 0000 	str.w	r0, [ip]
            shortModeNames[VocoderCh] = "VC";
 801c440:	f8cc 1004 	str.w	r1, [ip, #4]
            knobParamNames[Vocoder][8] = "PULSESHAPE";
 801c444:	48bc      	ldr	r0, [pc, #752]	; (801c738 <initModeNames+0x37c>)
            knobParamNames[Vocoder][9] = "";
 801c446:	49bd      	ldr	r1, [pc, #756]	; (801c73c <initModeNames+0x380>)
            modeNamesDetails[VocoderCh] = "CHANNEL";
 801c448:	4ebd      	ldr	r6, [pc, #756]	; (801c740 <initModeNames+0x384>)
            knobParamNames[Vocoder][4] = "NOISTHRESH";
 801c44a:	611f      	str	r7, [r3, #16]
            modeNamesDetails[VocoderCh] = "CHANNEL";
 801c44c:	f8cb 6004 	str.w	r6, [fp, #4]
            knobParamNames[VocoderCh][11] = "BANDOFF";
            knobParamNames[VocoderCh][12] = "TILT";
            knobParamNames[VocoderCh][13] = "STEREO";
            knobParamNames[VocoderCh][14] = "BARKPULL";

            modeNames[Pitchshift] = "PITCHSHIFT";
 801c450:	f8df 93f4 	ldr.w	r9, [pc, #1012]	; 801c848 <initModeNames+0x48c>
            knobParamNames[VocoderCh][10] = "BANDSQUISH";
 801c454:	4ebb      	ldr	r6, [pc, #748]	; (801c744 <initModeNames+0x388>)
            knobParamNames[Vocoder][1] = "WARP";
 801c456:	e9c3 2e00 	strd	r2, lr, [r3]
            knobParamNames[Vocoder][2] = "QUALITY";
 801c45a:	4abb      	ldr	r2, [pc, #748]	; (801c748 <initModeNames+0x38c>)
            knobParamNames[Vocoder][3] = "SAWtoPULSE";
 801c45c:	e9c3 2402 	strd	r2, r4, [r3, #8]
            knobParamNames[Vocoder][5] = "BREATH";
 801c460:	4aba      	ldr	r2, [pc, #744]	; (801c74c <initModeNames+0x390>)
            modeNames[VocoderCh] = "VOCODER2";
 801c462:	e9c8 a500 	strd	sl, r5, [r8]
            knobParamNames[Vocoder][5] = "BREATH";
 801c466:	615a      	str	r2, [r3, #20]
            knobParamNames[Vocoder][7] = "PULSEWIDTH";
 801c468:	4db9      	ldr	r5, [pc, #740]	; (801c750 <initModeNames+0x394>)
            knobParamNames[Vocoder][6] = "TILT";
 801c46a:	4aba      	ldr	r2, [pc, #744]	; (801c754 <initModeNames+0x398>)
            knobParamNames[VocoderCh][3] = "BANDWIDTH";
 801c46c:	f8df a3dc 	ldr.w	sl, [pc, #988]	; 801c84c <initModeNames+0x490>
            knobParamNames[Vocoder][7] = "PULSEWIDTH";
 801c470:	e9c3 2506 	strd	r2, r5, [r3, #24]
            knobParamNames[VocoderCh][0] = "VOLUME";
 801c474:	4aaa      	ldr	r2, [pc, #680]	; (801c720 <initModeNames+0x364>)
            knobParamNames[Vocoder][9] = "";
 801c476:	e9c3 0108 	strd	r0, r1, [r3, #32]
            knobParamNames[VocoderCh][1] = "WARP";
 801c47a:	e9c3 2e19 	strd	r2, lr, [r3, #100]	; 0x64
            knobParamNames[VocoderCh][2] = "QUALITY";
 801c47e:	4ab2      	ldr	r2, [pc, #712]	; (801c748 <initModeNames+0x38c>)
            knobParamNames[VocoderCh][5] = "SAWtoPULSE";
 801c480:	679c      	str	r4, [r3, #120]	; 0x78
            knobParamNames[VocoderCh][2] = "QUALITY";
 801c482:	66da      	str	r2, [r3, #108]	; 0x6c
            knobParamNames[VocoderCh][14] = "BARKPULL";
 801c484:	4cb4      	ldr	r4, [pc, #720]	; (801c758 <initModeNames+0x39c>)
            knobParamNames[VocoderCh][7] = "PULSESHAPE";
 801c486:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
            knobParamNames[VocoderCh][8] = "BREATH";
 801c48a:	4ab0      	ldr	r2, [pc, #704]	; (801c74c <initModeNames+0x390>)
            knobParamNames[VocoderCh][12] = "TILT";
 801c48c:	48b1      	ldr	r0, [pc, #708]	; (801c754 <initModeNames+0x398>)
            modeNames[Pitchshift] = "PITCHSHIFT";
 801c48e:	f8c8 9008 	str.w	r9, [r8, #8]
            knobParamNames[VocoderCh][4] = "NOISTHRESH";
 801c492:	675f      	str	r7, [r3, #116]	; 0x74
            knobParamNames[VocoderCh][11] = "BANDOFF";
 801c494:	f8df e3b8 	ldr.w	lr, [pc, #952]	; 801c850 <initModeNames+0x494>
            knobParamNames[VocoderCh][6] = "PULSEWIDTH";
 801c498:	67dd      	str	r5, [r3, #124]	; 0x7c
            shortModeNames[Pitchshift] = "PS";
 801c49a:	4fb0      	ldr	r7, [pc, #704]	; (801c75c <initModeNames+0x3a0>)
            modeNamesDetails[Pitchshift] = "";
            numPages[Pitchshift] = 2;
            knobParamNames[Pitchshift][0] = "SHIFT";
 801c49c:	4db0      	ldr	r5, [pc, #704]	; (801c760 <initModeNames+0x3a4>)
            knobParamNames[VocoderCh][8] = "BREATH";
 801c49e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            knobParamNames[VocoderCh][12] = "TILT";
 801c4a2:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
            knobParamNames[Pitchshift][1] = "FINE";
 801c4a6:	4aaf      	ldr	r2, [pc, #700]	; (801c764 <initModeNames+0x3a8>)
            knobParamNames[Pitchshift][2] = "F AMT";
 801c4a8:	f8df 93a8 	ldr.w	r9, [pc, #936]	; 801c854 <initModeNames+0x498>
            knobParamNames[Pitchshift][3] = "FORMANT";
 801c4ac:	48ae      	ldr	r0, [pc, #696]	; (801c768 <initModeNames+0x3ac>)
            knobParamNames[VocoderCh][10] = "BANDSQUISH";
 801c4ae:	f8c3 608c 	str.w	r6, [r3, #140]	; 0x8c
            knobParamNames[VocoderCh][14] = "BARKPULL";
 801c4b2:	f8c3 409c 	str.w	r4, [r3, #156]	; 0x9c
            knobParamNames[Pitchshift][4] = "RANGE";
 801c4b6:	4ead      	ldr	r6, [pc, #692]	; (801c76c <initModeNames+0x3b0>)
            knobParamNames[Pitchshift][6] = "";
            knobParamNames[Pitchshift][7] = "";
            knobParamNames[Pitchshift][8] = "";
            knobParamNames[Pitchshift][9] = "";

            modeNames[AutotuneMono] = "AUTOTUNE";
 801c4b8:	4cad      	ldr	r4, [pc, #692]	; (801c770 <initModeNames+0x3b4>)
            shortModeNames[Pitchshift] = "PS";
 801c4ba:	f8cc 7008 	str.w	r7, [ip, #8]
            modeNames[AutotuneMono] = "AUTOTUNE";
 801c4be:	f8c8 400c 	str.w	r4, [r8, #12]
            knobParamNames[VocoderCh][11] = "BANDOFF";
 801c4c2:	f8c3 e090 	str.w	lr, [r3, #144]	; 0x90
            shortModeNames[AutotuneMono] = "NT";
 801c4c6:	4fab      	ldr	r7, [pc, #684]	; (801c774 <initModeNames+0x3b8>)
            knobParamNames[Pitchshift][5] = "OFFSET";
 801c4c8:	f8df e38c 	ldr.w	lr, [pc, #908]	; 801c858 <initModeNames+0x49c>
            knobParamNames[Pitchshift][0] = "SHIFT";
 801c4cc:	f8c3 50c8 	str.w	r5, [r3, #200]	; 0xc8
            knobParamNames[Pitchshift][1] = "FINE";
 801c4d0:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
            modeNamesDetails[AutotuneMono] = "";
            numPages[AutotuneMono] = 1;
            knobParamNames[AutotuneMono][0] = "PICKINESS";
            knobParamNames[AutotuneMono][1] = "AMOUNT";
 801c4d4:	4da8      	ldr	r5, [pc, #672]	; (801c778 <initModeNames+0x3bc>)
            knobParamNames[VocoderCh][9] = "SPEED";
 801c4d6:	4aa9      	ldr	r2, [pc, #676]	; (801c77c <initModeNames+0x3c0>)
            knobParamNames[Pitchshift][4] = "RANGE";
 801c4d8:	f8c3 60d8 	str.w	r6, [r3, #216]	; 0xd8
            knobParamNames[VocoderCh][13] = "STEREO";
 801c4dc:	4ca8      	ldr	r4, [pc, #672]	; (801c780 <initModeNames+0x3c4>)
            knobParamNames[AutotuneMono][2] = "SPEED";
            knobParamNames[AutotuneMono][3] = "LEAPALLOW";
 801c4de:	4ea9      	ldr	r6, [pc, #676]	; (801c784 <initModeNames+0x3c8>)
            modeNamesDetails[Pitchshift] = "";
 801c4e0:	f8cb 1008 	str.w	r1, [fp, #8]
            modeNamesDetails[AutotuneMono] = "";
 801c4e4:	f8cb 100c 	str.w	r1, [fp, #12]
            shortModeNames[AutotuneMono] = "NT";
 801c4e8:	f8cc 700c 	str.w	r7, [ip, #12]
            knobParamNames[VocoderCh][3] = "BANDWIDTH";
 801c4ec:	f8c3 a070 	str.w	sl, [r3, #112]	; 0x70
            knobParamNames[Pitchshift][5] = "OFFSET";
 801c4f0:	f8c3 e0dc 	str.w	lr, [r3, #220]	; 0xdc
            knobParamNames[AutotuneMono][4] = "HYSTERESIS";


            modeNames[AutotunePoly] = "HARMONIZE";
            shortModeNames[AutotunePoly] = "AT";
 801c4f4:	4fa4      	ldr	r7, [pc, #656]	; (801c788 <initModeNames+0x3cc>)
            knobParamNames[AutotuneMono][1] = "AMOUNT";
 801c4f6:	f8c3 5130 	str.w	r5, [r3, #304]	; 0x130
            knobParamNames[VocoderCh][9] = "SPEED";
 801c4fa:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            knobParamNames[AutotunePoly][2] = "";
            knobParamNames[AutotunePoly][3] = "";
            knobParamNames[AutotunePoly][4] = "";


            modeNames[SamplerButtonPress] = "SAMPLER BP";
 801c4fe:	4da3      	ldr	r5, [pc, #652]	; (801c78c <initModeNames+0x3d0>)
            knobParamNames[VocoderCh][13] = "STEREO";
 801c500:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
            shortModeNames[SamplerButtonPress] = "SB";
 801c504:	f8df e354 	ldr.w	lr, [pc, #852]	; 801c85c <initModeNames+0x4a0>
            knobParamNames[SamplerButtonPress][4] = "CROSSFADE";



            modeNames[SamplerKeyboard] = "KEYSAMPLER";
            shortModeNames[SamplerKeyboard] = "KS";
 801c508:	4ca1      	ldr	r4, [pc, #644]	; (801c790 <initModeNames+0x3d4>)
            modeNames[AutotunePoly] = "HARMONIZE";
 801c50a:	f8df a354 	ldr.w	sl, [pc, #852]	; 801c860 <initModeNames+0x4a4>
            knobParamNames[Pitchshift][3] = "FORMANT";
 801c50e:	e9c3 9034 	strd	r9, r0, [r3, #208]	; 0xd0
            knobParamNames[AutotuneMono][0] = "PICKINESS";
 801c512:	48a0      	ldr	r0, [pc, #640]	; (801c794 <initModeNames+0x3d8>)
            knobParamNames[AutotuneMono][4] = "HYSTERESIS";
 801c514:	f8df 934c 	ldr.w	r9, [pc, #844]	; 801c864 <initModeNames+0x4a8>
            knobParamNames[Pitchshift][7] = "";
 801c518:	e9c3 1138 	strd	r1, r1, [r3, #224]	; 0xe0
            knobParamNames[Pitchshift][9] = "";
 801c51c:	e9c3 113a 	strd	r1, r1, [r3, #232]	; 0xe8
            knobParamNames[AutotuneMono][0] = "PICKINESS";
 801c520:	f8c3 012c 	str.w	r0, [r3, #300]	; 0x12c
            knobParamNames[AutotuneMono][3] = "LEAPALLOW";
 801c524:	f8c3 6138 	str.w	r6, [r3, #312]	; 0x138
            modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
 801c528:	4e9b      	ldr	r6, [pc, #620]	; (801c798 <initModeNames+0x3dc>)
            shortModeNames[AutotunePoly] = "AT";
 801c52a:	f8cc 7010 	str.w	r7, [ip, #16]
            modeNames[SamplerButtonPress] = "SAMPLER BP";
 801c52e:	f8c8 5014 	str.w	r5, [r8, #20]
            modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
 801c532:	f8cb 6014 	str.w	r6, [fp, #20]
            knobParamNames[AutotunePoly][0] = "PICKINESS";
 801c536:	f8c3 0190 	str.w	r0, [r3, #400]	; 0x190
            modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
 801c53a:	4f98      	ldr	r7, [pc, #608]	; (801c79c <initModeNames+0x3e0>)
            modeNames[SamplerKeyboard] = "KEYSAMPLER";
 801c53c:	4898      	ldr	r0, [pc, #608]	; (801c7a0 <initModeNames+0x3e4>)
            numPages[SamplerKeyboard] = 2;
            knobParamNames[SamplerKeyboard][0] = "START";
            knobParamNames[SamplerKeyboard][1] = "LENGTH";
            knobParamNames[SamplerKeyboard][2] = "SPEED";
            knobParamNames[SamplerKeyboard][3] = "SPEEDMULT";
            knobParamNames[SamplerKeyboard][4] = "LOOP ON";
 801c53e:	4d99      	ldr	r5, [pc, #612]	; (801c7a4 <initModeNames+0x3e8>)
            knobParamNames[SamplerKeyboard][7] = "";
            knobParamNames[SamplerKeyboard][8] = "";
            knobParamNames[SamplerKeyboard][9] = "";


            modeNames[SamplerAutoGrab] = "AUTOSAMP";
 801c540:	4e99      	ldr	r6, [pc, #612]	; (801c7a8 <initModeNames+0x3ec>)
            shortModeNames[SamplerButtonPress] = "SB";
 801c542:	f8cc e014 	str.w	lr, [ip, #20]
            modeNames[SamplerKeyboard] = "KEYSAMPLER";
 801c546:	f8c8 0018 	str.w	r0, [r8, #24]
            shortModeNames[SamplerKeyboard] = "KS";
 801c54a:	f8cc 4018 	str.w	r4, [ip, #24]
            knobParamNames[SamplerButtonPress][0] = "START";
 801c54e:	4897      	ldr	r0, [pc, #604]	; (801c7ac <initModeNames+0x3f0>)
            knobParamNames[SamplerButtonPress][1] = "LENGTH";
 801c550:	4c97      	ldr	r4, [pc, #604]	; (801c7b0 <initModeNames+0x3f4>)
            modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
 801c552:	f8cb 7018 	str.w	r7, [fp, #24]
            modeNames[SamplerAutoGrab] = "AUTOSAMP";
 801c556:	f8c8 601c 	str.w	r6, [r8, #28]
            knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
 801c55a:	4f96      	ldr	r7, [pc, #600]	; (801c7b4 <initModeNames+0x3f8>)
            knobParamNames[SamplerKeyboard][6] = "VELO SENS";
 801c55c:	f8df e308 	ldr.w	lr, [pc, #776]	; 801c868 <initModeNames+0x4ac>
            knobParamNames[SamplerKeyboard][4] = "LOOP ON";
 801c560:	f8c3 5268 	str.w	r5, [r3, #616]	; 0x268
            shortModeNames[SamplerAutoGrab] = "AS";
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
            numPages[SamplerAutoGrab] = 2;
            knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
 801c564:	4e94      	ldr	r6, [pc, #592]	; (801c7b8 <initModeNames+0x3fc>)
            knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
 801c566:	4d95      	ldr	r5, [pc, #596]	; (801c7bc <initModeNames+0x400>)
            modeNamesDetails[AutotunePoly] = "";
 801c568:	f8cb 1010 	str.w	r1, [fp, #16]
            modeNames[AutotunePoly] = "HARMONIZE";
 801c56c:	f8c8 a010 	str.w	sl, [r8, #16]
            knobParamNames[AutotuneMono][2] = "SPEED";
 801c570:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
            knobParamNames[AutotunePoly][1] = "";
 801c574:	f8c3 1194 	str.w	r1, [r3, #404]	; 0x194
            knobParamNames[AutotunePoly][2] = "";
 801c578:	f8c3 1198 	str.w	r1, [r3, #408]	; 0x198
            knobParamNames[AutotunePoly][3] = "";
 801c57c:	f8c3 119c 	str.w	r1, [r3, #412]	; 0x19c
            knobParamNames[AutotunePoly][4] = "";
 801c580:	f8c3 11a0 	str.w	r1, [r3, #416]	; 0x1a0
            knobParamNames[SamplerButtonPress][2] = "SPEED";
 801c584:	f8c3 21fc 	str.w	r2, [r3, #508]	; 0x1fc
            knobParamNames[SamplerKeyboard][2] = "SPEED";
 801c588:	f8c3 2260 	str.w	r2, [r3, #608]	; 0x260
            knobParamNames[SamplerKeyboard][7] = "";
 801c58c:	f8c3 1274 	str.w	r1, [r3, #628]	; 0x274
            knobParamNames[SamplerKeyboard][8] = "";
 801c590:	f8c3 1278 	str.w	r1, [r3, #632]	; 0x278
            knobParamNames[SamplerKeyboard][9] = "";
 801c594:	f8c3 127c 	str.w	r1, [r3, #636]	; 0x27c
            knobParamNames[AutotuneMono][4] = "HYSTERESIS";
 801c598:	f8c3 913c 	str.w	r9, [r3, #316]	; 0x13c
            knobParamNames[SamplerKeyboard][6] = "VELO SENS";
 801c59c:	f8c3 e270 	str.w	lr, [r3, #624]	; 0x270
            shortModeNames[SamplerAutoGrab] = "AS";
 801c5a0:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 801c86c <initModeNames+0x4b0>
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
 801c5a4:	f8df a2c8 	ldr.w	sl, [pc, #712]	; 801c870 <initModeNames+0x4b4>
            knobParamNames[SamplerButtonPress][0] = "START";
 801c5a8:	f8c3 01f4 	str.w	r0, [r3, #500]	; 0x1f4
            knobParamNames[SamplerKeyboard][0] = "START";
 801c5ac:	f8c3 0258 	str.w	r0, [r3, #600]	; 0x258
            knobParamNames[SamplerButtonPress][1] = "LENGTH";
 801c5b0:	f8c3 41f8 	str.w	r4, [r3, #504]	; 0x1f8
            knobParamNames[SamplerAutoGrab][1] = "WINDOW";
 801c5b4:	4882      	ldr	r0, [pc, #520]	; (801c7c0 <initModeNames+0x404>)
            knobParamNames[SamplerKeyboard][1] = "LENGTH";
 801c5b6:	f8c3 425c 	str.w	r4, [r3, #604]	; 0x25c
            knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
 801c5ba:	f8c3 7200 	str.w	r7, [r3, #512]	; 0x200
            knobParamNames[SamplerAutoGrab][2] = "SPEED";
            knobParamNames[SamplerAutoGrab][3] = "CROSSFADE";
            knobParamNames[SamplerAutoGrab][4] = "";
            knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
 801c5be:	4c81      	ldr	r4, [pc, #516]	; (801c7c4 <initModeNames+0x408>)
            knobParamNames[SamplerKeyboard][3] = "SPEEDMULT";
 801c5c0:	f8c3 7264 	str.w	r7, [r3, #612]	; 0x264
            knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
 801c5c4:	f8c3 5204 	str.w	r5, [r3, #516]	; 0x204
            knobParamNames[SamplerKeyboard][5] = "CROSSFADE";
 801c5c8:	f8c3 526c 	str.w	r5, [r3, #620]	; 0x26c
            knobParamNames[SamplerAutoGrab][2] = "SPEED";
 801c5cc:	f8c3 22c4 	str.w	r2, [r3, #708]	; 0x2c4
            knobParamNames[SamplerAutoGrab][3] = "CROSSFADE";
 801c5d0:	f8c3 52c8 	str.w	r5, [r3, #712]	; 0x2c8

            modeNames[BitCrusher] = "BITCRUSH";
            shortModeNames[BitCrusher] = "BC";
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
            numPages[BitCrusher] = 2;
            knobParamNames[BitCrusher][0] = "QUALITY";
 801c5d4:	4a5c      	ldr	r2, [pc, #368]	; (801c748 <initModeNames+0x38c>)
            knobParamNames[Distortion][1] = "TILT";
 801c5d6:	4d5f      	ldr	r5, [pc, #380]	; (801c754 <initModeNames+0x398>)
            knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
 801c5d8:	f8c3 62bc 	str.w	r6, [r3, #700]	; 0x2bc
            modeNames[Wavefolder] = "WAVEFOLD";
 801c5dc:	4e7a      	ldr	r6, [pc, #488]	; (801c7c8 <initModeNames+0x40c>)
            shortModeNames[SamplerAutoGrab] = "AS";
 801c5de:	f8cc 901c 	str.w	r9, [ip, #28]
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
 801c5e2:	f8cb a01c 	str.w	sl, [fp, #28]
            modeNames[Wavefolder] = "WAVEFOLD";
 801c5e6:	f8c8 6024 	str.w	r6, [r8, #36]	; 0x24
            knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
 801c5ea:	f8df e288 	ldr.w	lr, [pc, #648]	; 801c874 <initModeNames+0x4b8>
            modeNames[Distortion] = "DISTORT";
 801c5ee:	f8df 9288 	ldr.w	r9, [pc, #648]	; 801c878 <initModeNames+0x4bc>
            shortModeNames[Distortion] = "DT";
 801c5f2:	4f76      	ldr	r7, [pc, #472]	; (801c7cc <initModeNames+0x410>)
            knobParamNames[Distortion][1] = "TILT";
 801c5f4:	f8c3 5324 	str.w	r5, [r3, #804]	; 0x324
            knobParamNames[BitCrusher][0] = "QUALITY";
 801c5f8:	f8c3 23e8 	str.w	r2, [r3, #1000]	; 0x3e8
            modeNamesDetails[Distortion] = "WITH EQ";
 801c5fc:	4d74      	ldr	r5, [pc, #464]	; (801c7d0 <initModeNames+0x414>)
            knobParamNames[Distortion][2] = "MID GAIN";
 801c5fe:	4a75      	ldr	r2, [pc, #468]	; (801c7d4 <initModeNames+0x418>)
            knobParamNames[Distortion][3] = "MID FREQ";
 801c600:	f8df a278 	ldr.w	sl, [pc, #632]	; 801c87c <initModeNames+0x4c0>
            knobParamNames[SamplerAutoGrab][1] = "WINDOW";
 801c604:	f8c3 02c0 	str.w	r0, [r3, #704]	; 0x2c0
            knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
 801c608:	f8c3 42d0 	str.w	r4, [r3, #720]	; 0x2d0
            shortModeNames[Wavefolder] = "WF";
 801c60c:	4872      	ldr	r0, [pc, #456]	; (801c7d8 <initModeNames+0x41c>)
            modeNamesDetails[Wavefolder] = "SERGE STYLE";
 801c60e:	4c73      	ldr	r4, [pc, #460]	; (801c7dc <initModeNames+0x420>)
            knobParamNames[BitCrusher][1] = "SAMP RATIO";
 801c610:	4e73      	ldr	r6, [pc, #460]	; (801c7e0 <initModeNames+0x424>)
            modeNames[Distortion] = "DISTORT";
 801c612:	f8c8 9020 	str.w	r9, [r8, #32]
            shortModeNames[Distortion] = "DT";
 801c616:	f8cc 7020 	str.w	r7, [ip, #32]
            modeNamesDetails[Distortion] = "WITH EQ";
 801c61a:	f8cb 5020 	str.w	r5, [fp, #32]
            shortModeNames[Wavefolder] = "WF";
 801c61e:	f8cc 0024 	str.w	r0, [ip, #36]	; 0x24
            modeNamesDetails[Wavefolder] = "SERGE STYLE";
 801c622:	f8cb 4024 	str.w	r4, [fp, #36]	; 0x24
            knobParamNames[Distortion][0] = "PRE GAIN";
 801c626:	486f      	ldr	r0, [pc, #444]	; (801c7e4 <initModeNames+0x428>)
            knobParamNames[Distortion][4] = "POST GAIN";
 801c628:	4c6f      	ldr	r4, [pc, #444]	; (801c7e8 <initModeNames+0x42c>)
            knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
 801c62a:	f8c3 e2d4 	str.w	lr, [r3, #724]	; 0x2d4
            knobParamNames[Wavefolder][1] = "OFFSET1";
 801c62e:	f8df 9250 	ldr.w	r9, [pc, #592]	; 801c880 <initModeNames+0x4c4>
            knobParamNames[Wavefolder][0] = "GAIN";
 801c632:	f8df e250 	ldr.w	lr, [pc, #592]	; 801c884 <initModeNames+0x4c8>
            knobParamNames[Wavefolder][2] = "OFFSET2";
 801c636:	4f6d      	ldr	r7, [pc, #436]	; (801c7ec <initModeNames+0x430>)
            modeNames[BitCrusher] = "BITCRUSH";
 801c638:	4d6d      	ldr	r5, [pc, #436]	; (801c7f0 <initModeNames+0x434>)
            knobParamNames[Distortion][2] = "MID GAIN";
 801c63a:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
            knobParamNames[Distortion][3] = "MID FREQ";
 801c63e:	f8c3 a32c 	str.w	sl, [r3, #812]	; 0x32c
            shortModeNames[BitCrusher] = "BC";
 801c642:	4a6c      	ldr	r2, [pc, #432]	; (801c7f4 <initModeNames+0x438>)
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
 801c644:	f8df a240 	ldr.w	sl, [pc, #576]	; 801c888 <initModeNames+0x4cc>
            knobParamNames[BitCrusher][1] = "SAMP RATIO";
 801c648:	f8c3 63ec 	str.w	r6, [r3, #1004]	; 0x3ec
            knobParamNames[BitCrusher][8] = "";
            knobParamNames[BitCrusher][9] = "";

            modeNames[Delay] = "DELAY";
            shortModeNames[Delay] = "DL";
            modeNamesDetails[Delay] = "STEREO";
 801c64c:	4e4c      	ldr	r6, [pc, #304]	; (801c780 <initModeNames+0x3c4>)
            modeNames[BitCrusher] = "BITCRUSH";
 801c64e:	f8c8 5028 	str.w	r5, [r8, #40]	; 0x28
            shortModeNames[BitCrusher] = "BC";
 801c652:	f8cc 2028 	str.w	r2, [ip, #40]	; 0x28
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
 801c656:	f8cb a028 	str.w	sl, [fp, #40]	; 0x28
            knobParamNames[SamplerAutoGrab][4] = "";
 801c65a:	f8c3 12cc 	str.w	r1, [r3, #716]	; 0x2cc
            knobParamNames[SamplerAutoGrab][7] = "";
 801c65e:	f8c3 12d8 	str.w	r1, [r3, #728]	; 0x2d8
            knobParamNames[SamplerAutoGrab][8] = "";
 801c662:	f8c3 12dc 	str.w	r1, [r3, #732]	; 0x2dc
            knobParamNames[SamplerAutoGrab][9] = "";
 801c666:	f8c3 12e0 	str.w	r1, [r3, #736]	; 0x2e0
            knobParamNames[Wavefolder][4] = "";
 801c66a:	f8c3 1394 	str.w	r1, [r3, #916]	; 0x394
            knobParamNames[Wavefolder][0] = "GAIN";
 801c66e:	f8c3 e384 	str.w	lr, [r3, #900]	; 0x384
            knobParamNames[Wavefolder][1] = "OFFSET1";
 801c672:	f8c3 9388 	str.w	r9, [r3, #904]	; 0x388
            knobParamNames[Wavefolder][2] = "OFFSET2";
 801c676:	f8c3 738c 	str.w	r7, [r3, #908]	; 0x38c
            knobParamNames[Distortion][0] = "PRE GAIN";
 801c67a:	f8c3 0320 	str.w	r0, [r3, #800]	; 0x320
            knobParamNames[Distortion][4] = "POST GAIN";
 801c67e:	f8c3 4330 	str.w	r4, [r3, #816]	; 0x330
            knobParamNames[Wavefolder][3] = "POST GAIN";
 801c682:	f8c3 4390 	str.w	r4, [r3, #912]	; 0x390
            modeNamesDetails[Delay] = "STEREO";
 801c686:	f8cb 602c 	str.w	r6, [fp, #44]	; 0x2c
            knobParamNames[BitCrusher][4] = "POST GAIN";
 801c68a:	f8c3 43f8 	str.w	r4, [r3, #1016]	; 0x3f8
            knobParamNames[Delay][0] = "DELAY_L";
            knobParamNames[Delay][1] = "DELAY_R";
            knobParamNames[Delay][2] = "HIGHPASS";
            knobParamNames[Delay][3] = "LOWPASS";
            knobParamNames[Delay][4] = "FEEDBACK";
            knobParamNames[Delay][5] = "POST GAIN";
 801c68e:	f8c3 4460 	str.w	r4, [r3, #1120]	; 0x460
            knobParamNames[Delay][6] = "POST GAIN";
 801c692:	f8c3 4464 	str.w	r4, [r3, #1124]	; 0x464
            knobParamNames[Delay][7] = "POST GAIN";
 801c696:	f8c3 4468 	str.w	r4, [r3, #1128]	; 0x468
            knobParamNames[Delay][8] = "POST GAIN";
 801c69a:	f8c3 446c 	str.w	r4, [r3, #1132]	; 0x46c
            knobParamNames[Delay][1] = "DELAY_R";
 801c69e:	4e56      	ldr	r6, [pc, #344]	; (801c7f8 <initModeNames+0x43c>)
            numPages[Reverb] = 1;
            knobParamNames[Reverb][0] = "SIZE";
            knobParamNames[Reverb][1] = "FB LOPASS";
            knobParamNames[Reverb][2] = "IN HIPASS";
            knobParamNames[Reverb][3] = "IN LOPASS";
            knobParamNames[Reverb][4] = "FB GAIN";
 801c6a0:	4c56      	ldr	r4, [pc, #344]	; (801c7fc <initModeNames+0x440>)
            knobParamNames[BitCrusher][2] = "ROUNDING";
 801c6a2:	f8df e1e8 	ldr.w	lr, [pc, #488]	; 801c88c <initModeNames+0x4d0>
            knobParamNames[BitCrusher][3] = "OPERATION";
 801c6a6:	f8df 91e8 	ldr.w	r9, [pc, #488]	; 801c890 <initModeNames+0x4d4>
            modeNames[Delay] = "DELAY";
 801c6aa:	4f55      	ldr	r7, [pc, #340]	; (801c800 <initModeNames+0x444>)
            shortModeNames[Delay] = "DL";
 801c6ac:	4d55      	ldr	r5, [pc, #340]	; (801c804 <initModeNames+0x448>)
            knobParamNames[Delay][0] = "DELAY_L";
 801c6ae:	4a56      	ldr	r2, [pc, #344]	; (801c808 <initModeNames+0x44c>)
            knobParamNames[BitCrusher][5] = "PRE GAIN";
 801c6b0:	f8c3 03fc 	str.w	r0, [r3, #1020]	; 0x3fc
            knobParamNames[Delay][1] = "DELAY_R";
 801c6b4:	f8c3 6450 	str.w	r6, [r3, #1104]	; 0x450
            knobParamNames[Reverb][2] = "IN HIPASS";
 801c6b8:	4854      	ldr	r0, [pc, #336]	; (801c80c <initModeNames+0x450>)
            knobParamNames[Reverb][1] = "FB LOPASS";
 801c6ba:	4e55      	ldr	r6, [pc, #340]	; (801c810 <initModeNames+0x454>)
            knobParamNames[Reverb][4] = "FB GAIN";
 801c6bc:	f8c3 44c0 	str.w	r4, [r3, #1216]	; 0x4c0
            knobParamNames[Delay][3] = "LOWPASS";
 801c6c0:	4c54      	ldr	r4, [pc, #336]	; (801c814 <initModeNames+0x458>)
            modeNames[Delay] = "DELAY";
 801c6c2:	f8c8 702c 	str.w	r7, [r8, #44]	; 0x2c
            shortModeNames[Delay] = "DL";
 801c6c6:	f8cc 502c 	str.w	r5, [ip, #44]	; 0x2c
            modeNames[Reverb] = "REVERB1";
 801c6ca:	f8df a1c8 	ldr.w	sl, [pc, #456]	; 801c894 <initModeNames+0x4d8>
            knobParamNames[BitCrusher][2] = "ROUNDING";
 801c6ce:	f8c3 e3f0 	str.w	lr, [r3, #1008]	; 0x3f0
            knobParamNames[BitCrusher][3] = "OPERATION";
 801c6d2:	f8c3 93f4 	str.w	r9, [r3, #1012]	; 0x3f4
            knobParamNames[Reverb][3] = "IN LOPASS";
 801c6d6:	f8df e1c0 	ldr.w	lr, [pc, #448]	; 801c898 <initModeNames+0x4dc>
            modeNamesDetails[Reverb] = "DATTORRO ALG";
 801c6da:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 801c89c <initModeNames+0x4e0>


            modeNames[Reverb2] = "REVERB2";
 801c6de:	4f4e      	ldr	r7, [pc, #312]	; (801c818 <initModeNames+0x45c>)
            shortModeNames[Reverb2] = "RV";
            modeNamesDetails[Reverb2] = "NREVERB ALG";
 801c6e0:	4d4e      	ldr	r5, [pc, #312]	; (801c81c <initModeNames+0x460>)
            knobParamNames[Delay][0] = "DELAY_L";
 801c6e2:	f8c3 244c 	str.w	r2, [r3, #1100]	; 0x44c
            knobParamNames[Reverb][1] = "FB LOPASS";
 801c6e6:	f8c3 64b4 	str.w	r6, [r3, #1204]	; 0x4b4
            knobParamNames[Delay][2] = "HIGHPASS";
 801c6ea:	4a4d      	ldr	r2, [pc, #308]	; (801c820 <initModeNames+0x464>)
            shortModeNames[Reverb] = "RV";
 801c6ec:	4e4d      	ldr	r6, [pc, #308]	; (801c824 <initModeNames+0x468>)
            knobParamNames[Reverb][2] = "IN HIPASS";
 801c6ee:	f8c3 04b8 	str.w	r0, [r3, #1208]	; 0x4b8
            knobParamNames[Delay][3] = "LOWPASS";
 801c6f2:	f8c3 4458 	str.w	r4, [r3, #1112]	; 0x458
            knobParamNames[Reverb][0] = "SIZE";
 801c6f6:	484c      	ldr	r0, [pc, #304]	; (801c828 <initModeNames+0x46c>)
            knobParamNames[Delay][4] = "FEEDBACK";
 801c6f8:	4c4c      	ldr	r4, [pc, #304]	; (801c82c <initModeNames+0x470>)
            modeNames[Reverb] = "REVERB1";
 801c6fa:	f8c8 a030 	str.w	sl, [r8, #48]	; 0x30
            modeNamesDetails[Reverb] = "DATTORRO ALG";
 801c6fe:	f8cb 9030 	str.w	r9, [fp, #48]	; 0x30
            modeNames[Reverb2] = "REVERB2";
 801c702:	f8c8 7034 	str.w	r7, [r8, #52]	; 0x34
            modeNamesDetails[Reverb2] = "NREVERB ALG";
 801c706:	f8cb 5034 	str.w	r5, [fp, #52]	; 0x34
 801c70a:	e0c9      	b.n	801c8a0 <initModeNames+0x4e4>
 801c70c:	20018980 	.word	0x20018980
 801c710:	200187a0 	.word	0x200187a0
 801c714:	20018884 	.word	0x20018884
 801c718:	0802b314 	.word	0x0802b314
 801c71c:	200189ac 	.word	0x200189ac
 801c720:	0802b318 	.word	0x0802b318
 801c724:	0802b330 	.word	0x0802b330
 801c728:	0802b370 	.word	0x0802b370
 801c72c:	0802b310 	.word	0x0802b310
 801c730:	0802b37c 	.word	0x0802b37c
 801c734:	0802b33c 	.word	0x0802b33c
 801c738:	0802b364 	.word	0x0802b364
 801c73c:	0802b280 	.word	0x0802b280
 801c740:	0802b380 	.word	0x0802b380
 801c744:	0802b39c 	.word	0x0802b39c
 801c748:	0802b328 	.word	0x0802b328
 801c74c:	0802b348 	.word	0x0802b348
 801c750:	0802b358 	.word	0x0802b358
 801c754:	0802b350 	.word	0x0802b350
 801c758:	0802b3b8 	.word	0x0802b3b8
 801c75c:	0802b3d0 	.word	0x0802b3d0
 801c760:	0802b3d4 	.word	0x0802b3d4
 801c764:	0802b3dc 	.word	0x0802b3dc
 801c768:	0802b3ec 	.word	0x0802b3ec
 801c76c:	0802b3f4 	.word	0x0802b3f4
 801c770:	0802b404 	.word	0x0802b404
 801c774:	0802b420 	.word	0x0802b420
 801c778:	0802b41c 	.word	0x0802b41c
 801c77c:	0802b394 	.word	0x0802b394
 801c780:	0802b3b0 	.word	0x0802b3b0
 801c784:	0802b424 	.word	0x0802b424
 801c788:	0802b448 	.word	0x0802b448
 801c78c:	0802b44c 	.word	0x0802b44c
 801c790:	0802b4a0 	.word	0x0802b4a0
 801c794:	0802b410 	.word	0x0802b410
 801c798:	0802b45c 	.word	0x0802b45c
 801c79c:	0802b4a4 	.word	0x0802b4a4
 801c7a0:	0802b494 	.word	0x0802b494
 801c7a4:	0802b4b0 	.word	0x0802b4b0
 801c7a8:	0802b4c4 	.word	0x0802b4c4
 801c7ac:	0802b46c 	.word	0x0802b46c
 801c7b0:	0802b474 	.word	0x0802b474
 801c7b4:	0802b47c 	.word	0x0802b47c
 801c7b8:	0802b4e4 	.word	0x0802b4e4
 801c7bc:	0802b488 	.word	0x0802b488
 801c7c0:	0802b4f0 	.word	0x0802b4f0
 801c7c4:	0802b4f8 	.word	0x0802b4f8
 801c7c8:	0802b554 	.word	0x0802b554
 801c7cc:	0802b518 	.word	0x0802b518
 801c7d0:	0802b51c 	.word	0x0802b51c
 801c7d4:	0802b530 	.word	0x0802b530
 801c7d8:	0802b560 	.word	0x0802b560
 801c7dc:	0802b564 	.word	0x0802b564
 801c7e0:	0802b59c 	.word	0x0802b59c
 801c7e4:	0802b524 	.word	0x0802b524
 801c7e8:	0802b548 	.word	0x0802b548
 801c7ec:	0802b578 	.word	0x0802b578
 801c7f0:	0802b580 	.word	0x0802b580
 801c7f4:	0802b58c 	.word	0x0802b58c
 801c7f8:	0802b5d4 	.word	0x0802b5d4
 801c7fc:	0802b644 	.word	0x0802b644
 801c800:	0802b5c0 	.word	0x0802b5c0
 801c804:	0802b5c8 	.word	0x0802b5c8
 801c808:	0802b5cc 	.word	0x0802b5cc
 801c80c:	0802b62c 	.word	0x0802b62c
 801c810:	0802b620 	.word	0x0802b620
 801c814:	0802b5e8 	.word	0x0802b5e8
 801c818:	0802b64c 	.word	0x0802b64c
 801c81c:	0802b654 	.word	0x0802b654
 801c820:	0802b5dc 	.word	0x0802b5dc
 801c824:	0802b604 	.word	0x0802b604
 801c828:	0802b618 	.word	0x0802b618
 801c82c:	0802b5f0 	.word	0x0802b5f0
 801c830:	20018938 	.word	0x20018938
 801c834:	03020100 	.word	0x03020100
 801c838:	0802b320 	.word	0x0802b320
 801c83c:	20018758 	.word	0x20018758
 801c840:	0802b304 	.word	0x0802b304
 801c844:	200188c8 	.word	0x200188c8
 801c848:	0802b3c4 	.word	0x0802b3c4
 801c84c:	0802b388 	.word	0x0802b388
 801c850:	0802b3a8 	.word	0x0802b3a8
 801c854:	0802b3e4 	.word	0x0802b3e4
 801c858:	0802b3fc 	.word	0x0802b3fc
 801c85c:	0802b458 	.word	0x0802b458
 801c860:	0802b43c 	.word	0x0802b43c
 801c864:	0802b430 	.word	0x0802b430
 801c868:	0802b4b8 	.word	0x0802b4b8
 801c86c:	0802b4d0 	.word	0x0802b4d0
 801c870:	0802b4d4 	.word	0x0802b4d4
 801c874:	0802b504 	.word	0x0802b504
 801c878:	0802b510 	.word	0x0802b510
 801c87c:	0802b53c 	.word	0x0802b53c
 801c880:	0802b570 	.word	0x0802b570
 801c884:	0802b534 	.word	0x0802b534
 801c888:	0802b590 	.word	0x0802b590
 801c88c:	0802b5a8 	.word	0x0802b5a8
 801c890:	0802b5b4 	.word	0x0802b5b4
 801c894:	0802b5fc 	.word	0x0802b5fc
 801c898:	0802b638 	.word	0x0802b638
 801c89c:	0802b608 	.word	0x0802b608
            knobParamNames[BitCrusher][6] = "";
 801c8a0:	f8c3 1400 	str.w	r1, [r3, #1024]	; 0x400
            knobParamNames[BitCrusher][7] = "";
 801c8a4:	f8c3 1404 	str.w	r1, [r3, #1028]	; 0x404
            knobParamNames[BitCrusher][8] = "";
 801c8a8:	f8c3 1408 	str.w	r1, [r3, #1032]	; 0x408
            knobParamNames[BitCrusher][9] = "";
 801c8ac:	f8c3 140c 	str.w	r1, [r3, #1036]	; 0x40c
            knobParamNames[Delay][9] = "";
 801c8b0:	f8c3 1470 	str.w	r1, [r3, #1136]	; 0x470
            knobParamNames[Reverb][3] = "IN LOPASS";
 801c8b4:	f8c3 e4bc 	str.w	lr, [r3, #1212]	; 0x4bc
            knobParamNames[Delay][2] = "HIGHPASS";
 801c8b8:	f8c3 2454 	str.w	r2, [r3, #1108]	; 0x454
            knobParamNames[Delay][4] = "FEEDBACK";
 801c8bc:	f8c3 445c 	str.w	r4, [r3, #1116]	; 0x45c
            knobParamNames[Reverb][0] = "SIZE";
 801c8c0:	f8c3 04b0 	str.w	r0, [r3, #1200]	; 0x4b0
            numPages[Reverb2] = 1;
            knobParamNames[Reverb2][0] = "SIZE";
            knobParamNames[Reverb2][1] = "LOWPASS";
            knobParamNames[Reverb2][2] = "HIGHPASS";
            knobParamNames[Reverb2][3] = "PEAK_FREQ";
 801c8c4:	f8df e2fc 	ldr.w	lr, [pc, #764]	; 801cbc4 <initModeNames+0x808>

            modeNames[LivingString] = "STRING1";
            shortModeNames[LivingString] = "LS";
            modeNamesDetails[LivingString] = "SYMP STRING";
            numPages[LivingString] = 3;
            knobParamNames[LivingString][0] = "FREQ1";
 801c8c8:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 801cbc8 <initModeNames+0x80c>
            knobParamNames[LivingString][5] = "PREP POS";
            knobParamNames[LivingString][6] = "PREP FORCE";
            knobParamNames[LivingString][7] = "LET RING";
            knobParamNames[LivingString][8] = "";
            knobParamNames[LivingString][9] = "";
            knobParamNames[LivingString][10] = "FREQ2";
 801c8cc:	4f8d      	ldr	r7, [pc, #564]	; (801cb04 <initModeNames+0x748>)
            knobParamNames[LivingString][11] = "FREQ3";
 801c8ce:	4d8e      	ldr	r5, [pc, #568]	; (801cb08 <initModeNames+0x74c>)
            knobParamNames[Reverb2][1] = "LOWPASS";
 801c8d0:	4c8e      	ldr	r4, [pc, #568]	; (801cb0c <initModeNames+0x750>)
            knobParamNames[LivingString][12] = "FREQ4";
 801c8d2:	f8df a2f8 	ldr.w	sl, [pc, #760]	; 801cbcc <initModeNames+0x810>
            shortModeNames[Reverb2] = "RV";
 801c8d6:	e9cc 660c 	strd	r6, r6, [ip, #48]	; 0x30
            knobParamNames[Reverb2][0] = "SIZE";
 801c8da:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
            knobParamNames[Reverb2][2] = "HIGHPASS";
 801c8de:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
            knobParamNames[Reverb2][4] = "PEAK_GAIN";
 801c8e2:	4a8b      	ldr	r2, [pc, #556]	; (801cb10 <initModeNames+0x754>)
            knobParamNames[Reverb2][3] = "PEAK_FREQ";
 801c8e4:	f8c3 e520 	str.w	lr, [r3, #1312]	; 0x520
            knobParamNames[Reverb2][4] = "PEAK_GAIN";
 801c8e8:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
            knobParamNames[LivingString][4] = "PICK POS";
 801c8ec:	4a89      	ldr	r2, [pc, #548]	; (801cb14 <initModeNames+0x758>)
            knobParamNames[LivingString][13] = "FREQ5";
            knobParamNames[LivingString][14] = "FREQ6";
 801c8ee:	f8df e2e0 	ldr.w	lr, [pc, #736]	; 801cbd0 <initModeNames+0x814>
            knobParamNames[LivingString][4] = "PICK POS";
 801c8f2:	f8c3 2588 	str.w	r2, [r3, #1416]	; 0x588
            modeNames[LivingString] = "STRING1";
 801c8f6:	4a88      	ldr	r2, [pc, #544]	; (801cb18 <initModeNames+0x75c>)
            knobParamNames[LivingString][13] = "FREQ5";
 801c8f8:	4e88      	ldr	r6, [pc, #544]	; (801cb1c <initModeNames+0x760>)
            modeNames[LivingString] = "STRING1";
 801c8fa:	f8c8 2038 	str.w	r2, [r8, #56]	; 0x38
            knobParamNames[LivingString][14] = "FREQ6";
 801c8fe:	f8c3 e5b0 	str.w	lr, [r3, #1456]	; 0x5b0
            knobParamNames[LivingString][3] = "DAMPING";
 801c902:	4a87      	ldr	r2, [pc, #540]	; (801cb20 <initModeNames+0x764>)

            modeNames[LivingStringSynth] = "STRING2";
            shortModeNames[LivingStringSynth] = "SS";
            modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
 801c904:	f8df e2cc 	ldr.w	lr, [pc, #716]	; 801cbd4 <initModeNames+0x818>
            knobParamNames[Reverb2][1] = "LOWPASS";
 801c908:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
            modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
 801c90c:	f8cb e03c 	str.w	lr, [fp, #60]	; 0x3c
            numPages[LivingStringSynth] = 2;
            knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
 801c910:	4c84      	ldr	r4, [pc, #528]	; (801cb24 <initModeNames+0x768>)
            knobParamNames[LivingString][0] = "FREQ1";
 801c912:	f8c3 9578 	str.w	r9, [r3, #1400]	; 0x578
            knobParamNames[LivingString][10] = "FREQ2";
 801c916:	f8c3 75a0 	str.w	r7, [r3, #1440]	; 0x5a0
            knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
 801c91a:	f8df 92bc 	ldr.w	r9, [pc, #700]	; 801cbd8 <initModeNames+0x81c>
            shortModeNames[LivingString] = "LS";
 801c91e:	4f82      	ldr	r7, [pc, #520]	; (801cb28 <initModeNames+0x76c>)
            knobParamNames[LivingString][11] = "FREQ3";
 801c920:	f8c3 55a4 	str.w	r5, [r3, #1444]	; 0x5a4
            modeNames[LivingStringSynth] = "STRING2";
 801c924:	4881      	ldr	r0, [pc, #516]	; (801cb2c <initModeNames+0x770>)
            modeNamesDetails[LivingString] = "SYMP STRING";
 801c926:	4d82      	ldr	r5, [pc, #520]	; (801cb30 <initModeNames+0x774>)
            knobParamNames[LivingString][13] = "FREQ5";
 801c928:	f8c3 65ac 	str.w	r6, [r3, #1452]	; 0x5ac
            numPages[Vocoder] = 2;
 801c92c:	f8df e2ac 	ldr.w	lr, [pc, #684]	; 801cbdc <initModeNames+0x820>
            shortModeNames[LivingStringSynth] = "SS";
 801c930:	4e80      	ldr	r6, [pc, #512]	; (801cb34 <initModeNames+0x778>)
            knobParamNames[LivingString][3] = "DAMPING";
 801c932:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
            knobParamNames[LivingStringSynth][2] = "DECAY";
            knobParamNames[LivingStringSynth][3] = "DAMPING";
 801c936:	f8c3 25e8 	str.w	r2, [r3, #1512]	; 0x5e8
            numPages[Vocoder] = 2;
 801c93a:	4a7f      	ldr	r2, [pc, #508]	; (801cb38 <initModeNames+0x77c>)
            shortModeNames[LivingString] = "LS";
 801c93c:	f8cc 7038 	str.w	r7, [ip, #56]	; 0x38
            modeNamesDetails[LivingString] = "SYMP STRING";
 801c940:	f8cb 5038 	str.w	r5, [fp, #56]	; 0x38
            knobParamNames[LivingString][5] = "PREP POS";
 801c944:	4f7d      	ldr	r7, [pc, #500]	; (801cb3c <initModeNames+0x780>)
            knobParamNames[LivingString][6] = "PREP FORCE";
 801c946:	4d7e      	ldr	r5, [pc, #504]	; (801cb40 <initModeNames+0x784>)
            modeNames[LivingStringSynth] = "STRING2";
 801c948:	f8c8 003c 	str.w	r0, [r8, #60]	; 0x3c
            shortModeNames[LivingStringSynth] = "SS";
 801c94c:	f8cc 603c 	str.w	r6, [ip, #60]	; 0x3c
            knobParamNames[LivingString][7] = "LET RING";
 801c950:	487c      	ldr	r0, [pc, #496]	; (801cb44 <initModeNames+0x788>)
            knobParamNames[LivingString][2] = "DECAY";
 801c952:	4e7d      	ldr	r6, [pc, #500]	; (801cb48 <initModeNames+0x78c>)
            numPages[Vocoder] = 2;
 801c954:	f8c2 e000 	str.w	lr, [r2]
            knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
 801c958:	f8c3 45dc 	str.w	r4, [r3, #1500]	; 0x5dc
            numPages[Vocoder] = 2;
 801c95c:	f8df e280 	ldr.w	lr, [pc, #640]	; 801cbe0 <initModeNames+0x824>
            knobParamNames[LivingString][1] = "DETUNE";
 801c960:	4c7a      	ldr	r4, [pc, #488]	; (801cb4c <initModeNames+0x790>)
            knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
 801c962:	f8c3 95e0 	str.w	r9, [r3, #1504]	; 0x5e0
            numPages[Vocoder] = 2;
 801c966:	f8df 927c 	ldr.w	r9, [pc, #636]	; 801cbe4 <initModeNames+0x828>
 801c96a:	f8c2 e004 	str.w	lr, [r2, #4]
 801c96e:	f8c2 900c 	str.w	r9, [r2, #12]
            knobParamNames[LivingString][8] = "";
 801c972:	f8c3 1598 	str.w	r1, [r3, #1432]	; 0x598
            knobParamNames[LivingString][9] = "";
 801c976:	f8c3 159c 	str.w	r1, [r3, #1436]	; 0x59c
            knobParamNames[LivingString][12] = "FREQ4";
 801c97a:	f8c3 a5a8 	str.w	sl, [r3, #1448]	; 0x5a8
            knobParamNames[LivingString][1] = "DETUNE";
 801c97e:	f8c3 457c 	str.w	r4, [r3, #1404]	; 0x57c
            knobParamNames[LivingString][2] = "DECAY";
 801c982:	f8c3 6580 	str.w	r6, [r3, #1408]	; 0x580
            knobParamNames[LivingStringSynth][2] = "DECAY";
 801c986:	f8c3 65e4 	str.w	r6, [r3, #1508]	; 0x5e4
            knobParamNames[LivingString][5] = "PREP POS";
 801c98a:	f8c3 758c 	str.w	r7, [r3, #1420]	; 0x58c
            knobParamNames[LivingString][6] = "PREP FORCE";
 801c98e:	f8c3 5590 	str.w	r5, [r3, #1424]	; 0x590
            knobParamNames[LivingString][7] = "LET RING";
 801c992:	f8c3 0594 	str.w	r0, [r3, #1428]	; 0x594
            numPages[Vocoder] = 2;
 801c996:	f8c2 e008 	str.w	lr, [r2, #8]
            knobParamNames[LivingStringSynth][4] = "PICK_POS";
            knobParamNames[LivingStringSynth][5] = "PREP POS";
            knobParamNames[LivingStringSynth][6] = "PREP FORCE";
            knobParamNames[LivingStringSynth][7] = "LET RING";
 801c99a:	f8c3 05f8 	str.w	r0, [r3, #1528]	; 0x5f8
            knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
            knobParamNames[ClassicSynth][14] = "F_LEAK";
            knobParamNames[ClassicSynth][15] = "F_AMOUNT";
            knobParamNames[ClassicSynth][16] = "SAW/PULSE";
            knobParamNames[ClassicSynth][17] = "";
 801c99e:	f8c3 1684 	str.w	r1, [r3, #1668]	; 0x684
            knobParamNames[ClassicSynth][0] = "VOLUME";
 801c9a2:	486b      	ldr	r0, [pc, #428]	; (801cb50 <initModeNames+0x794>)
            knobParamNames[ClassicSynth][18] = "";
 801c9a4:	f8c3 1688 	str.w	r1, [r3, #1672]	; 0x688
            knobParamNames[ClassicSynth][19] = "";
 801c9a8:	f8c3 168c 	str.w	r1, [r3, #1676]	; 0x68c
            numPages[ClassicSynth] = 4;
 801c9ac:	f04f 0104 	mov.w	r1, #4
            knobParamNames[LivingStringSynth][4] = "PICK_POS";
 801c9b0:	f8df 9234 	ldr.w	r9, [pc, #564]	; 801cbe8 <initModeNames+0x82c>
            numPages[ClassicSynth] = 4;
 801c9b4:	7411      	strb	r1, [r2, #16]
            knobParamNames[ClassicSynth][0] = "VOLUME";
 801c9b6:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
            knobParamNames[LivingStringSynth][8] = "FB LEVEL";
 801c9ba:	4a66      	ldr	r2, [pc, #408]	; (801cb54 <initModeNames+0x798>)
            knobParamNames[ClassicSynth][1] = "LOWPASS";
 801c9bc:	4853      	ldr	r0, [pc, #332]	; (801cb0c <initModeNames+0x750>)
            knobParamNames[LivingStringSynth][4] = "PICK_POS";
 801c9be:	f8c3 95ec 	str.w	r9, [r3, #1516]	; 0x5ec
            knobParamNames[LivingStringSynth][5] = "PREP POS";
 801c9c2:	f8c3 75f0 	str.w	r7, [r3, #1520]	; 0x5f0
            knobParamNames[ClassicSynth][4] = "FILTER Q";
 801c9c6:	f8df a224 	ldr.w	sl, [pc, #548]	; 801cbec <initModeNames+0x830>
            knobParamNames[LivingStringSynth][6] = "PREP FORCE";
 801c9ca:	f8c3 55f4 	str.w	r5, [r3, #1524]	; 0x5f4
            knobParamNames[ClassicSynth][10] = "F_ATTACK";
 801c9ce:	f8df 9220 	ldr.w	r9, [pc, #544]	; 801cbf0 <initModeNames+0x834>
            knobParamNames[ClassicSynth][11] = "F_DECAY";
 801c9d2:	f8df e220 	ldr.w	lr, [pc, #544]	; 801cbf4 <initModeNames+0x838>
            knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
 801c9d6:	4f60      	ldr	r7, [pc, #384]	; (801cb58 <initModeNames+0x79c>)
            knobParamNames[ClassicSynth][1] = "LOWPASS";
 801c9d8:	f8c3 0644 	str.w	r0, [r3, #1604]	; 0x644
            knobParamNames[ClassicSynth][3] = "DETUNE";
 801c9dc:	f8c3 464c 	str.w	r4, [r3, #1612]	; 0x64c
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
 801c9e0:	485e      	ldr	r0, [pc, #376]	; (801cb5c <initModeNames+0x7a0>)
            knobParamNames[ClassicSynth][14] = "F_LEAK";
 801c9e2:	4d5f      	ldr	r5, [pc, #380]	; (801cb60 <initModeNames+0x7a4>)
            knobParamNames[ClassicSynth][6] = "DECAY";
 801c9e4:	f8c3 6658 	str.w	r6, [r3, #1624]	; 0x658
            knobParamNames[ClassicSynth][15] = "F_AMOUNT";
 801c9e8:	4c5e      	ldr	r4, [pc, #376]	; (801cb64 <initModeNames+0x7a8>)
            knobParamNames[ClassicSynth][16] = "SAW/PULSE";
 801c9ea:	495f      	ldr	r1, [pc, #380]	; (801cb68 <initModeNames+0x7ac>)
            knobParamNames[LivingStringSynth][8] = "FB LEVEL";
 801c9ec:	f8c3 25fc 	str.w	r2, [r3, #1532]	; 0x5fc
            knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
 801c9f0:	4e5e      	ldr	r6, [pc, #376]	; (801cb6c <initModeNames+0x7b0>)
            modeNames[ClassicSynth] = "POLYSYNTH";
 801c9f2:	4a5f      	ldr	r2, [pc, #380]	; (801cb70 <initModeNames+0x7b4>)
            knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
 801c9f4:	f8c3 6648 	str.w	r6, [r3, #1608]	; 0x648
            modeNames[ClassicSynth] = "POLYSYNTH";
 801c9f8:	f8c8 2040 	str.w	r2, [r8, #64]	; 0x40
            knobParamNames[ClassicSynth][4] = "FILTER Q";
 801c9fc:	f8c3 a650 	str.w	sl, [r3, #1616]	; 0x650
            knobParamNames[ClassicSynth][10] = "F_ATTACK";
 801ca00:	f8c3 9668 	str.w	r9, [r3, #1640]	; 0x668
            modeNamesDetails[ClassicSynth] = "VCO+VCF";
 801ca04:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 801cbf8 <initModeNames+0x83c>

            modeNames[Rhodes] = "RHODES";
 801ca08:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 801cbfc <initModeNames+0x840>
            knobParamNames[ClassicSynth][11] = "F_DECAY";
 801ca0c:	f8c3 e66c 	str.w	lr, [r3, #1644]	; 0x66c
            knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
 801ca10:	f8c3 7670 	str.w	r7, [r3, #1648]	; 0x670
            shortModeNames[Rhodes] = "RD";
 801ca14:	f8df e1e8 	ldr.w	lr, [pc, #488]	; 801cc00 <initModeNames+0x844>
            modeNamesDetails[Rhodes] = "DARK";
 801ca18:	4f56      	ldr	r7, [pc, #344]	; (801cb74 <initModeNames+0x7b8>)
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
 801ca1a:	f8c3 0674 	str.w	r0, [r3, #1652]	; 0x674
            knobParamNames[ClassicSynth][14] = "F_LEAK";
 801ca1e:	f8c3 5678 	str.w	r5, [r3, #1656]	; 0x678
            knobParamNames[LivingStringSynth][9] = "RELEASE";
 801ca22:	4855      	ldr	r0, [pc, #340]	; (801cb78 <initModeNames+0x7bc>)
            knobParamNames[ClassicSynth][5] = "ATTACK";
 801ca24:	4d55      	ldr	r5, [pc, #340]	; (801cb7c <initModeNames+0x7c0>)
            knobParamNames[ClassicSynth][15] = "F_AMOUNT";
 801ca26:	f8c3 467c 	str.w	r4, [r3, #1660]	; 0x67c
            knobParamNames[ClassicSynth][16] = "SAW/PULSE";
 801ca2a:	f8c3 1680 	str.w	r1, [r3, #1664]	; 0x680
            knobParamNames[ClassicSynth][7] = "SUSTAIN";
 801ca2e:	4c54      	ldr	r4, [pc, #336]	; (801cb80 <initModeNames+0x7c4>)
            knobParamNames[ClassicSynth][9] = "LEAK";
 801ca30:	4954      	ldr	r1, [pc, #336]	; (801cb84 <initModeNames+0x7c8>)
            numPages[Rhodes] = 5;
            knobParamNames[Rhodes][0] = "BRIGHTNESS";
 801ca32:	4a55      	ldr	r2, [pc, #340]	; (801cb88 <initModeNames+0x7cc>)
            shortModeNames[ClassicSynth] = "CS";
 801ca34:	4e55      	ldr	r6, [pc, #340]	; (801cb8c <initModeNames+0x7d0>)
            modeNamesDetails[ClassicSynth] = "VCO+VCF";
 801ca36:	f8cb a040 	str.w	sl, [fp, #64]	; 0x40
            shortModeNames[ClassicSynth] = "CS";
 801ca3a:	f8cc 6040 	str.w	r6, [ip, #64]	; 0x40
            modeNames[Rhodes] = "RHODES";
 801ca3e:	f8c8 9044 	str.w	r9, [r8, #68]	; 0x44
            shortModeNames[Rhodes] = "RD";
 801ca42:	f8cc e044 	str.w	lr, [ip, #68]	; 0x44
            modeNamesDetails[Rhodes] = "DARK";
 801ca46:	f8cb 7044 	str.w	r7, [fp, #68]	; 0x44
            numPages[Rhodes] = 5;
 801ca4a:	f04f 0705 	mov.w	r7, #5
            knobParamNames[LivingStringSynth][9] = "RELEASE";
 801ca4e:	f8c3 0600 	str.w	r0, [r3, #1536]	; 0x600
            knobParamNames[ClassicSynth][8] = "RELEASE";
 801ca52:	f8c3 0660 	str.w	r0, [r3, #1632]	; 0x660
            knobParamNames[ClassicSynth][5] = "ATTACK";
 801ca56:	f8c3 5654 	str.w	r5, [r3, #1620]	; 0x654
            knobParamNames[ClassicSynth][7] = "SUSTAIN";
 801ca5a:	f8c3 465c 	str.w	r4, [r3, #1628]	; 0x65c
            knobParamNames[ClassicSynth][9] = "LEAK";
 801ca5e:	f8c3 1664 	str.w	r1, [r3, #1636]	; 0x664
            knobParamNames[Rhodes][0] = "BRIGHTNESS";
 801ca62:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
            knobParamNames[Rhodes][1] = "TREM DEPTH";
 801ca66:	4a4a      	ldr	r2, [pc, #296]	; (801cb90 <initModeNames+0x7d4>)
            numPages[Rhodes] = 5;
 801ca68:	4e33      	ldr	r6, [pc, #204]	; (801cb38 <initModeNames+0x77c>)
            knobParamNames[Rhodes][1] = "TREM DEPTH";
 801ca6a:	f8c3 26a8 	str.w	r2, [r3, #1704]	; 0x6a8
            knobParamNames[Rhodes][2] = "TREM RATE";
 801ca6e:	4a49      	ldr	r2, [pc, #292]	; (801cb94 <initModeNames+0x7d8>)
            numPages[Rhodes] = 5;
 801ca70:	7477      	strb	r7, [r6, #17]
            knobParamNames[Rhodes][2] = "TREM RATE";
 801ca72:	f8c3 26ac 	str.w	r2, [r3, #1708]	; 0x6ac
            knobParamNames[Rhodes][3] = "DRIVE";
 801ca76:	4a48      	ldr	r2, [pc, #288]	; (801cb98 <initModeNames+0x7dc>)
            knobParamNames[Rhodes][4] = "PAN SPREAD";
            knobParamNames[Rhodes][5] = "ATTACK";
            knobParamNames[Rhodes][6] = "DECAY";
 801ca78:	4e33      	ldr	r6, [pc, #204]	; (801cb48 <initModeNames+0x78c>)
            knobParamNames[Rhodes][3] = "DRIVE";
 801ca7a:	f8c3 26b0 	str.w	r2, [r3, #1712]	; 0x6b0
            knobParamNames[Rhodes][4] = "PAN SPREAD";
 801ca7e:	4a47      	ldr	r2, [pc, #284]	; (801cb9c <initModeNames+0x7e0>)
            knobParamNames[Rhodes][7] = "SUSTAIN";
            knobParamNames[Rhodes][8] = "RELEASE";
            knobParamNames[Rhodes][9] = "LEAK";
 801ca80:	f8c3 16c8 	str.w	r1, [r3, #1736]	; 0x6c8
            knobParamNames[Rhodes][4] = "PAN SPREAD";
 801ca84:	f8c3 26b4 	str.w	r2, [r3, #1716]	; 0x6b4
            knobParamNames[Rhodes][16] = "RATIO2";
            knobParamNames[Rhodes][17] = "RATIO3";
            knobParamNames[Rhodes][18] = "RATIO4";
            knobParamNames[Rhodes][19] = "RATIO5";
            knobParamNames[Rhodes][20] = "RATIO6";
            knobParamNames[Rhodes][21] = "FEEDBACK";
 801ca88:	4945      	ldr	r1, [pc, #276]	; (801cba0 <initModeNames+0x7e4>)
            knobParamNames[Rhodes][10] = "INDEX1";
 801ca8a:	4a46      	ldr	r2, [pc, #280]	; (801cba4 <initModeNames+0x7e8>)
            knobParamNames[Rhodes][12] = "INDEX3";
 801ca8c:	f8df a174 	ldr.w	sl, [pc, #372]	; 801cc04 <initModeNames+0x848>
            knobParamNames[Rhodes][13] = "INDEX4";
 801ca90:	f8df 9174 	ldr.w	r9, [pc, #372]	; 801cc08 <initModeNames+0x84c>
            knobParamNames[Rhodes][14] = "INDEX5";
 801ca94:	f8df 8174 	ldr.w	r8, [pc, #372]	; 801cc0c <initModeNames+0x850>
            knobParamNames[Rhodes][15] = "RATIO1";
 801ca98:	f8df e174 	ldr.w	lr, [pc, #372]	; 801cc10 <initModeNames+0x854>
            knobParamNames[Rhodes][5] = "ATTACK";
 801ca9c:	f8c3 56b8 	str.w	r5, [r3, #1720]	; 0x6b8
            knobParamNames[Rhodes][16] = "RATIO2";
 801caa0:	f8df c170 	ldr.w	ip, [pc, #368]	; 801cc14 <initModeNames+0x858>
            knobParamNames[Rhodes][6] = "DECAY";
 801caa4:	f8c3 66bc 	str.w	r6, [r3, #1724]	; 0x6bc
            knobParamNames[Rhodes][17] = "RATIO3";
 801caa8:	4f3f      	ldr	r7, [pc, #252]	; (801cba8 <initModeNames+0x7ec>)
            knobParamNames[Rhodes][7] = "SUSTAIN";
 801caaa:	f8c3 46c0 	str.w	r4, [r3, #1728]	; 0x6c0
            knobParamNames[Rhodes][18] = "RATIO4";
 801caae:	4e3f      	ldr	r6, [pc, #252]	; (801cbac <initModeNames+0x7f0>)
            knobParamNames[Rhodes][8] = "RELEASE";
 801cab0:	f8c3 06c4 	str.w	r0, [r3, #1732]	; 0x6c4
            knobParamNames[Rhodes][19] = "RATIO5";
 801cab4:	4d3e      	ldr	r5, [pc, #248]	; (801cbb0 <initModeNames+0x7f4>)
            knobParamNames[Rhodes][20] = "RATIO6";
 801cab6:	4c3f      	ldr	r4, [pc, #252]	; (801cbb4 <initModeNames+0x7f8>)
            knobParamNames[Rhodes][21] = "FEEDBACK";
 801cab8:	f8c3 16f8 	str.w	r1, [r3, #1784]	; 0x6f8
            knobParamNames[Rhodes][22] = "TUNE SNAP";
 801cabc:	483e      	ldr	r0, [pc, #248]	; (801cbb8 <initModeNames+0x7fc>)
            knobParamNames[Rhodes][23] = "RAND DECAY";
 801cabe:	493f      	ldr	r1, [pc, #252]	; (801cbbc <initModeNames+0x800>)
            knobParamNames[Rhodes][24] = "RAND SUST";
 801cac0:	f8df b154 	ldr.w	fp, [pc, #340]	; 801cc18 <initModeNames+0x85c>
            knobParamNames[Rhodes][10] = "INDEX1";
 801cac4:	f8c3 26cc 	str.w	r2, [r3, #1740]	; 0x6cc
            knobParamNames[Rhodes][11] = "INDEX2";
 801cac8:	4a3d      	ldr	r2, [pc, #244]	; (801cbc0 <initModeNames+0x804>)
            knobParamNames[Rhodes][12] = "INDEX3";
 801caca:	f8c3 a6d4 	str.w	sl, [r3, #1748]	; 0x6d4
            knobParamNames[Rhodes][11] = "INDEX2";
 801cace:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0
            knobParamNames[Rhodes][13] = "INDEX4";
 801cad2:	f8c3 96d8 	str.w	r9, [r3, #1752]	; 0x6d8
            knobParamNames[Rhodes][14] = "INDEX5";
 801cad6:	f8c3 86dc 	str.w	r8, [r3, #1756]	; 0x6dc
            knobParamNames[Rhodes][15] = "RATIO1";
 801cada:	f8c3 e6e0 	str.w	lr, [r3, #1760]	; 0x6e0
            knobParamNames[Rhodes][16] = "RATIO2";
 801cade:	f8c3 c6e4 	str.w	ip, [r3, #1764]	; 0x6e4
            knobParamNames[Rhodes][17] = "RATIO3";
 801cae2:	f8c3 76e8 	str.w	r7, [r3, #1768]	; 0x6e8
            knobParamNames[Rhodes][18] = "RATIO4";
 801cae6:	f8c3 66ec 	str.w	r6, [r3, #1772]	; 0x6ec
            knobParamNames[Rhodes][19] = "RATIO5";
 801caea:	f8c3 56f0 	str.w	r5, [r3, #1776]	; 0x6f0
            knobParamNames[Rhodes][20] = "RATIO6";
 801caee:	f8c3 46f4 	str.w	r4, [r3, #1780]	; 0x6f4
            knobParamNames[Rhodes][22] = "TUNE SNAP";
 801caf2:	f8c3 06fc 	str.w	r0, [r3, #1788]	; 0x6fc
            knobParamNames[Rhodes][23] = "RAND DECAY";
 801caf6:	f8c3 1700 	str.w	r1, [r3, #1792]	; 0x700
            knobParamNames[Rhodes][24] = "RAND SUST";
 801cafa:	f8c3 b704 	str.w	fp, [r3, #1796]	; 0x704
        }
 801cafe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801cb02:	bf00      	nop
 801cb04:	0802b6e0 	.word	0x0802b6e0
 801cb08:	0802b6e8 	.word	0x0802b6e8
 801cb0c:	0802b5e8 	.word	0x0802b5e8
 801cb10:	0802b66c 	.word	0x0802b66c
 801cb14:	0802b6b0 	.word	0x0802b6b0
 801cb18:	0802b678 	.word	0x0802b678
 801cb1c:	0802b6f8 	.word	0x0802b6f8
 801cb20:	0802b6a8 	.word	0x0802b6a8
 801cb24:	0802b720 	.word	0x0802b720
 801cb28:	0802b680 	.word	0x0802b680
 801cb2c:	0802b708 	.word	0x0802b708
 801cb30:	0802b684 	.word	0x0802b684
 801cb34:	0802b808 	.word	0x0802b808
 801cb38:	20018858 	.word	0x20018858
 801cb3c:	0802b6bc 	.word	0x0802b6bc
 801cb40:	0802b6c8 	.word	0x0802b6c8
 801cb44:	0802b6d4 	.word	0x0802b6d4
 801cb48:	0802b6a0 	.word	0x0802b6a0
 801cb4c:	0802b698 	.word	0x0802b698
 801cb50:	0802b318 	.word	0x0802b318
 801cb54:	0802b744 	.word	0x0802b744
 801cb58:	0802b7b4 	.word	0x0802b7b4
 801cb5c:	0802b7c0 	.word	0x0802b7c0
 801cb60:	0802b7cc 	.word	0x0802b7cc
 801cb64:	0802b7d4 	.word	0x0802b7d4
 801cb68:	0802b7e0 	.word	0x0802b7e0
 801cb6c:	0802b770 	.word	0x0802b770
 801cb70:	0802b758 	.word	0x0802b758
 801cb74:	0802b7f8 	.word	0x0802b7f8
 801cb78:	0802b750 	.word	0x0802b750
 801cb7c:	0802b788 	.word	0x0802b788
 801cb80:	0802b790 	.word	0x0802b790
 801cb84:	0802b798 	.word	0x0802b798
 801cb88:	0802b800 	.word	0x0802b800
 801cb8c:	0802b764 	.word	0x0802b764
 801cb90:	0802b80c 	.word	0x0802b80c
 801cb94:	0802b818 	.word	0x0802b818
 801cb98:	0802b824 	.word	0x0802b824
 801cb9c:	0802b82c 	.word	0x0802b82c
 801cba0:	0802b5f0 	.word	0x0802b5f0
 801cba4:	0802b838 	.word	0x0802b838
 801cba8:	0802b870 	.word	0x0802b870
 801cbac:	0802b878 	.word	0x0802b878
 801cbb0:	0802b880 	.word	0x0802b880
 801cbb4:	0802b888 	.word	0x0802b888
 801cbb8:	0802b890 	.word	0x0802b890
 801cbbc:	0802b89c 	.word	0x0802b89c
 801cbc0:	0802b840 	.word	0x0802b840
 801cbc4:	0802b660 	.word	0x0802b660
 801cbc8:	0802b690 	.word	0x0802b690
 801cbcc:	0802b6f0 	.word	0x0802b6f0
 801cbd0:	0802b700 	.word	0x0802b700
 801cbd4:	0802b710 	.word	0x0802b710
 801cbd8:	0802b72c 	.word	0x0802b72c
 801cbdc:	01020302 	.word	0x01020302
 801cbe0:	02020101 	.word	0x02020101
 801cbe4:	02030101 	.word	0x02030101
 801cbe8:	0802b738 	.word	0x0802b738
 801cbec:	0802b77c 	.word	0x0802b77c
 801cbf0:	0802b7a0 	.word	0x0802b7a0
 801cbf4:	0802b7ac 	.word	0x0802b7ac
 801cbf8:	0802b768 	.word	0x0802b768
 801cbfc:	0802b7ec 	.word	0x0802b7ec
 801cc00:	0802b7f4 	.word	0x0802b7f4
 801cc04:	0802b848 	.word	0x0802b848
 801cc08:	0802b850 	.word	0x0802b850
 801cc0c:	0802b858 	.word	0x0802b858
 801cc10:	0802b860 	.word	0x0802b860
 801cc14:	0802b868 	.word	0x0802b868
 801cc18:	0802b8a8 	.word	0x0802b8a8

0801cc1c <buttonCheck>:

        void buttonCheck(void)
        {
#ifndef __cplusplus
            if (codecReady)
 801cc1c:	4ba0      	ldr	r3, [pc, #640]	; (801cea0 <buttonCheck+0x284>)
 801cc1e:	681b      	ldr	r3, [r3, #0]
 801cc20:	2b00      	cmp	r3, #0
 801cc22:	f000 80e7 	beq.w	801cdf4 <buttonCheck+0x1d8>
                 buttonValues[8] = !HAL_GPIO_ReadPin(GPIOG, GPIO_PIN_11); // D
                 buttonValues[9] = !HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_10); // E
                 */

                //A little more efficient since it avoids a function call
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 801cc26:	499f      	ldr	r1, [pc, #636]	; (801cea4 <buttonCheck+0x288>)
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
#else
                {
#endif
                    for (int i = 0; i < NUM_BUTTONS; i++)
 801cc28:	2300      	movs	r3, #0
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 801cc2a:	4a9f      	ldr	r2, [pc, #636]	; (801cea8 <buttonCheck+0x28c>)
        {
 801cc2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 801cc30:	6908      	ldr	r0, [r1, #16]
        {
 801cc32:	b087      	sub	sp, #28
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
                            buttonActionsUI[i][ActionHoldContinuous] = TRUE;
                            writeButtonFlag = i;
                            writeActionFlag = ActionHoldContinuous;
                        }
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
 801cc34:	4f9d      	ldr	r7, [pc, #628]	; (801ceac <buttonCheck+0x290>)
 801cc36:	4694      	mov	ip, r2
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 801cc38:	f480 5000 	eor.w	r0, r0, #8192	; 0x2000
                        {
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
 801cc3c:	4d9c      	ldr	r5, [pc, #624]	; (801ceb0 <buttonCheck+0x294>)
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
 801cc3e:	f8d7 a000 	ldr.w	sl, [r7]
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 801cc42:	f3c0 3040 	ubfx	r0, r0, #13, #1
 801cc46:	4f9b      	ldr	r7, [pc, #620]	; (801ceb4 <buttonCheck+0x298>)
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
 801cc48:	4c9b      	ldr	r4, [pc, #620]	; (801ceb8 <buttonCheck+0x29c>)
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 801cc4a:	7010      	strb	r0, [r2, #0]
                buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
 801cc4c:	6908      	ldr	r0, [r1, #16]
 801cc4e:	f997 7000 	ldrsb.w	r7, [r7]
 801cc52:	f480 5080 	eor.w	r0, r0, #4096	; 0x1000
                buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
 801cc56:	4e99      	ldr	r6, [pc, #612]	; (801cebc <buttonCheck+0x2a0>)
 801cc58:	9701      	str	r7, [sp, #4]
                buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
 801cc5a:	f3c0 3000 	ubfx	r0, r0, #12, #1
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
 801cc5e:	682d      	ldr	r5, [r5, #0]
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
 801cc60:	6824      	ldr	r4, [r4, #0]
                buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
 801cc62:	7050      	strb	r0, [r2, #1]
                buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
 801cc64:	6908      	ldr	r0, [r1, #16]
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
 801cc66:	9405      	str	r4, [sp, #20]
                buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
 801cc68:	f480 4080 	eor.w	r0, r0, #16384	; 0x4000
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
 801cc6c:	9504      	str	r5, [sp, #16]
 801cc6e:	4f94      	ldr	r7, [pc, #592]	; (801cec0 <buttonCheck+0x2a4>)
                buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
 801cc70:	f3c0 3080 	ubfx	r0, r0, #14, #1
 801cc74:	4c93      	ldr	r4, [pc, #588]	; (801cec4 <buttonCheck+0x2a8>)
 801cc76:	f997 b000 	ldrsb.w	fp, [r7]
 801cc7a:	7090      	strb	r0, [r2, #2]
                buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
 801cc7c:	6930      	ldr	r0, [r6, #16]
 801cc7e:	4f92      	ldr	r7, [pc, #584]	; (801cec8 <buttonCheck+0x2ac>)
 801cc80:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
 801cc84:	f8df e268 	ldr.w	lr, [pc, #616]	; 801cef0 <buttonCheck+0x2d4>
 801cc88:	f3c0 20c0 	ubfx	r0, r0, #11, #1
 801cc8c:	70d0      	strb	r0, [r2, #3]
                buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
 801cc8e:	690d      	ldr	r5, [r1, #16]
                buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
 801cc90:	6908      	ldr	r0, [r1, #16]
                buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
 801cc92:	f485 4900 	eor.w	r9, r5, #32768	; 0x8000
                buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
 801cc96:	6936      	ldr	r6, [r6, #16]
                buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
 801cc98:	f080 0802 	eor.w	r8, r0, #2
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
 801cc9c:	488b      	ldr	r0, [pc, #556]	; (801cecc <buttonCheck+0x2b0>)
                buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
 801cc9e:	690d      	ldr	r5, [r1, #16]
                buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
 801cca0:	f086 0680 	eor.w	r6, r6, #128	; 0x80
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
 801cca4:	6900      	ldr	r0, [r0, #16]
                buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
 801cca6:	f3c9 39c0 	ubfx	r9, r9, #15, #1
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
 801ccaa:	6909      	ldr	r1, [r1, #16]
                buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
 801ccac:	f485 6500 	eor.w	r5, r5, #2048	; 0x800
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
 801ccb0:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
                buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
 801ccb4:	f3c8 0840 	ubfx	r8, r8, #1, #1
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
 801ccb8:	f481 6180 	eor.w	r1, r1, #1024	; 0x400
                buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
 801ccbc:	f3c6 16c0 	ubfx	r6, r6, #7, #1
                buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
 801ccc0:	f3c5 25c0 	ubfx	r5, r5, #11, #1
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
 801ccc4:	f3c0 20c0 	ubfx	r0, r0, #11, #1
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
 801ccc8:	f3c1 2180 	ubfx	r1, r1, #10, #1
                buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
 801cccc:	f882 9004 	strb.w	r9, [r2, #4]
                buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
 801ccd0:	f882 8005 	strb.w	r8, [r2, #5]
                buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
 801ccd4:	7196      	strb	r6, [r2, #6]
                buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
 801ccd6:	71d5      	strb	r5, [r2, #7]
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
 801ccd8:	7210      	strb	r0, [r2, #8]
 801ccda:	f8df 8218 	ldr.w	r8, [pc, #536]	; 801cef4 <buttonCheck+0x2d8>
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
 801ccde:	7251      	strb	r1, [r2, #9]
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
 801cce0:	f8df 91f8 	ldr.w	r9, [pc, #504]	; 801cedc <buttonCheck+0x2c0>
 801cce4:	e00f      	b.n	801cd06 <buttonCheck+0xea>
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
 801cce6:	f858 1002 	ldr.w	r1, [r8, r2]
 801ccea:	9804      	ldr	r0, [sp, #16]
 801ccec:	4281      	cmp	r1, r0
 801ccee:	d202      	bcs.n	801ccf6 <buttonCheck+0xda>
 801ccf0:	3101      	adds	r1, #1
 801ccf2:	f848 1002 	str.w	r1, [r8, r2]
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
 801ccf6:	9805      	ldr	r0, [sp, #20]
 801ccf8:	4288      	cmp	r0, r1
 801ccfa:	d801      	bhi.n	801cd00 <buttonCheck+0xe4>
 801ccfc:	2d01      	cmp	r5, #1
 801ccfe:	d07a      	beq.n	801cdf6 <buttonCheck+0x1da>
                    for (int i = 0; i < NUM_BUTTONS; i++)
 801cd00:	3301      	adds	r3, #1
 801cd02:	2b0a      	cmp	r3, #10
 801cd04:	d037      	beq.n	801cd76 <buttonCheck+0x15a>
                        if (buttonValues[i] != buttonValuesPrev[i])
 801cd06:	f81c 1b01 	ldrb.w	r1, [ip], #1
 801cd0a:	f817 2f01 	ldrb.w	r2, [r7, #1]!
 801cd0e:	f854 0f04 	ldr.w	r0, [r4, #4]!
 801cd12:	428a      	cmp	r2, r1
 801cd14:	d001      	beq.n	801cd1a <buttonCheck+0xfe>
                            buttonHysteresis[i]++;
 801cd16:	3001      	adds	r0, #1
 801cd18:	6020      	str	r0, [r4, #0]
                        if (cleanButtonValues[i] == 1)
 801cd1a:	f81e 5003 	ldrb.w	r5, [lr, r3]
 801cd1e:	009a      	lsls	r2, r3, #2
 801cd20:	2d01      	cmp	r5, #1
 801cd22:	d10d      	bne.n	801cd40 <buttonCheck+0x124>
                            writeButtonFlag = i;
 801cd24:	b25e      	sxtb	r6, r3
                            writeActionFlag = ActionHoldContinuous;
 801cd26:	f04f 0b03 	mov.w	fp, #3
                            writeButtonFlag = i;
 801cd2a:	9601      	str	r6, [sp, #4]
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
 801cd2c:	eb09 0602 	add.w	r6, r9, r2
 801cd30:	9602      	str	r6, [sp, #8]
                            buttonActionsUI[i][ActionHoldContinuous] = TRUE;
 801cd32:	4e67      	ldr	r6, [pc, #412]	; (801ced0 <buttonCheck+0x2b4>)
 801cd34:	4416      	add	r6, r2
 801cd36:	9603      	str	r6, [sp, #12]
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
 801cd38:	9e02      	ldr	r6, [sp, #8]
 801cd3a:	70f5      	strb	r5, [r6, #3]
                            buttonActionsUI[i][ActionHoldContinuous] = TRUE;
 801cd3c:	9e03      	ldr	r6, [sp, #12]
 801cd3e:	70f5      	strb	r5, [r6, #3]
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
 801cd40:	4582      	cmp	sl, r0
 801cd42:	d8d0      	bhi.n	801cce6 <buttonCheck+0xca>
                            }
                        }
                        else
                        {
                            cleanButtonValues[i] = buttonValues[i];
                            buttonHysteresis[i] = 0;
 801cd44:	2000      	movs	r0, #0
                            buttonCounters[i] = 0;

                            if (cleanButtonValues[i] == 1)
 801cd46:	2901      	cmp	r1, #1
                            cleanButtonValues[i] = buttonValues[i];
 801cd48:	f80e 1003 	strb.w	r1, [lr, r3]
                            buttonHysteresis[i] = 0;
 801cd4c:	6020      	str	r0, [r4, #0]
                            buttonCounters[i] = 0;
 801cd4e:	f848 0002 	str.w	r0, [r8, r2]
                            if (cleanButtonValues[i] == 1)
 801cd52:	d045      	beq.n	801cde0 <buttonCheck+0x1c4>
                                buttonActionsSFX[i][ActionPress] = TRUE;
                                buttonActionsUI[i][ActionPress] = TRUE;
                                writeButtonFlag = i;
                                writeActionFlag = ActionPress;
                            }
                            else if (cleanButtonValues[i] == 0)
 801cd54:	b959      	cbnz	r1, 801cd6e <buttonCheck+0x152>
                            {
                                buttonActionsSFX[i][ActionRelease] = TRUE;
                                buttonActionsUI[i][ActionRelease] = TRUE;
 801cd56:	4d5e      	ldr	r5, [pc, #376]	; (801ced0 <buttonCheck+0x2b4>)
                                buttonActionsSFX[i][ActionRelease] = TRUE;
 801cd58:	eb09 0002 	add.w	r0, r9, r2
                                writeButtonFlag = i;
                                writeActionFlag = ActionRelease;
 801cd5c:	f04f 0b01 	mov.w	fp, #1
                                buttonActionsUI[i][ActionRelease] = TRUE;
 801cd60:	442a      	add	r2, r5
                                writeButtonFlag = i;
 801cd62:	b25d      	sxtb	r5, r3
 801cd64:	9501      	str	r5, [sp, #4]
                                buttonActionsSFX[i][ActionRelease] = TRUE;
 801cd66:	f04f 0501 	mov.w	r5, #1
 801cd6a:	7045      	strb	r5, [r0, #1]
                                buttonActionsUI[i][ActionRelease] = TRUE;
 801cd6c:	7055      	strb	r5, [r2, #1]
                            }
                            buttonValuesPrev[i] = buttonValues[i];
 801cd6e:	7039      	strb	r1, [r7, #0]
                    for (int i = 0; i < NUM_BUTTONS; i++)
 801cd70:	3301      	adds	r3, #1
 801cd72:	2b0a      	cmp	r3, #10
 801cd74:	d1c7      	bne.n	801cd06 <buttonCheck+0xea>

                    // make some if statements if you want to find the "attack" of the buttons (getting the "press" action)

                    /// DEFINE GLOBAL BUTTON BEHAVIOR HERE

                    if (buttonActionsUI[ButtonLeft][ActionPress] == 1)
 801cd76:	4b56      	ldr	r3, [pc, #344]	; (801ced0 <buttonCheck+0x2b4>)
 801cd78:	4a4e      	ldr	r2, [pc, #312]	; (801ceb4 <buttonCheck+0x298>)
 801cd7a:	791b      	ldrb	r3, [r3, #4]
 801cd7c:	9901      	ldr	r1, [sp, #4]
 801cd7e:	2b01      	cmp	r3, #1
 801cd80:	7011      	strb	r1, [r2, #0]
 801cd82:	4a4f      	ldr	r2, [pc, #316]	; (801cec0 <buttonCheck+0x2a4>)
 801cd84:	f882 b000 	strb.w	fp, [r2]
 801cd88:	f000 815d 	beq.w	801d046 <buttonCheck+0x42a>
                        loadingPreset = 1;
                        OLED_writePreset();
                        writeCurrentPresetToFlash();
                        clearButtonActions();
                    }
                    if (buttonActionsUI[ButtonRight][ActionPress] == 1)
 801cd8c:	4b50      	ldr	r3, [pc, #320]	; (801ced0 <buttonCheck+0x2b4>)
 801cd8e:	7a1b      	ldrb	r3, [r3, #8]
 801cd90:	2b01      	cmp	r3, #1
 801cd92:	f000 8192 	beq.w	801d0ba <buttonCheck+0x49e>
                        loadingPreset = 1;
                        OLED_writePreset();
                        writeCurrentPresetToFlash();
                        clearButtonActions();
                    }
                    if (buttonActionsUI[ButtonD][ActionPress] == 1)
 801cd96:	4b4e      	ldr	r3, [pc, #312]	; (801ced0 <buttonCheck+0x2b4>)
 801cd98:	f893 3020 	ldrb.w	r3, [r3, #32]
 801cd9c:	2b01      	cmp	r3, #1
 801cd9e:	f000 81c7 	beq.w	801d130 <buttonCheck+0x514>
                        }
                        changeTuning();
                        OLED_writeTuning();
                        buttonActionsUI[ButtonD][ActionPress] = 0;
                    }
                    if (buttonActionsUI[ButtonE][ActionPress] == 1)
 801cda2:	4b4b      	ldr	r3, [pc, #300]	; (801ced0 <buttonCheck+0x2b4>)
 801cda4:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801cda8:	2b01      	cmp	r3, #1
 801cdaa:	f000 81fe 	beq.w	801d1aa <buttonCheck+0x58e>
                        changeTuning();
                        OLED_writeTuning();
                        buttonActionsUI[ButtonE][ActionPress] = 0;
                    }

                    if (buttonActionsUI[ButtonEdit][ActionPress])
 801cdae:	4b48      	ldr	r3, [pc, #288]	; (801ced0 <buttonCheck+0x2b4>)
 801cdb0:	781b      	ldrb	r3, [r3, #0]
 801cdb2:	2b00      	cmp	r3, #0
 801cdb4:	f040 81ea 	bne.w	801d18c <buttonCheck+0x570>
                    {
                        OLED_writeEditScreen();
                        setLED_Edit(1);
                        buttonActionsUI[ButtonEdit][ActionPress] = 0;
                    }
                    if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
 801cdb8:	4b45      	ldr	r3, [pc, #276]	; (801ced0 <buttonCheck+0x2b4>)
 801cdba:	78db      	ldrb	r3, [r3, #3]
 801cdbc:	2b01      	cmp	r3, #1
                    {
                        if (buttonActionsUI[ButtonC][ActionPress] == 1)
 801cdbe:	4b44      	ldr	r3, [pc, #272]	; (801ced0 <buttonCheck+0x2b4>)
                    if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
 801cdc0:	d026      	beq.n	801ce10 <buttonCheck+0x1f4>
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
                        }

                        //            OLEDdrawFloatArray(audioDisplayBuffer, -1.0f, 1.0f, 128, displayBufferIndex, 0, BothLines);
                    }
                    if (buttonActionsUI[ButtonEdit][ActionRelease] == 1)
 801cdc2:	785b      	ldrb	r3, [r3, #1]
 801cdc4:	2b01      	cmp	r3, #1
 801cdc6:	d038      	beq.n	801ce3a <buttonCheck+0x21e>
                        buttonActionsUI[ButtonEdit][ActionRelease] = 0;
                        buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
                        buttonActionsSFX[ButtonEdit][ActionHoldContinuous] = 0;

                    }
                    if (buttonActionsUI[ButtonDown][ActionPress] == 1)
 801cdc8:	4b41      	ldr	r3, [pc, #260]	; (801ced0 <buttonCheck+0x2b4>)
 801cdca:	7b1b      	ldrb	r3, [r3, #12]
 801cdcc:	2b01      	cmp	r3, #1
 801cdce:	d044      	beq.n	801ce5a <buttonCheck+0x23e>
                        decrementPage();
                        OLEDwriteString("P", 1, 110, FirstLine);
                        OLEDwriteInt(knobPage, 1, 120, FirstLine);
                        buttonActionsUI[ButtonDown][ActionPress] = 0;
                    }
                    if (buttonActionsUI[ButtonUp][ActionPress] == 1)
 801cdd0:	4b3f      	ldr	r3, [pc, #252]	; (801ced0 <buttonCheck+0x2b4>)
 801cdd2:	7c1b      	ldrb	r3, [r3, #16]
 801cdd4:	2b01      	cmp	r3, #1
 801cdd6:	f000 80e4 	beq.w	801cfa2 <buttonCheck+0x386>
                    //            OLEDwriteString(" ", 1, getCursorX(), SecondLine);
                    //            OLEDwriteString(paramNames[orderedParams[currentParamIndex]], getCursorX(), SecondLine);
                    //            buttonActionsUI[ButtonEdit][ActionPress] = 0;
                    //        }
                }
            }
 801cdda:	b007      	add	sp, #28
 801cddc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                writeButtonFlag = i;
 801cde0:	b258      	sxtb	r0, r3
                                buttonActionsSFX[i][ActionPress] = TRUE;
 801cde2:	f809 1002 	strb.w	r1, [r9, r2]
                                writeActionFlag = ActionPress;
 801cde6:	f04f 0b00 	mov.w	fp, #0
                            buttonValuesPrev[i] = buttonValues[i];
 801cdea:	7039      	strb	r1, [r7, #0]
                                writeButtonFlag = i;
 801cdec:	9001      	str	r0, [sp, #4]
                                buttonActionsUI[i][ActionPress] = TRUE;
 801cdee:	4838      	ldr	r0, [pc, #224]	; (801ced0 <buttonCheck+0x2b4>)
 801cdf0:	5481      	strb	r1, [r0, r2]
 801cdf2:	e7bd      	b.n	801cd70 <buttonCheck+0x154>
 801cdf4:	4770      	bx	lr
                                buttonActionsUI[i][ActionHoldInstant] = TRUE;
 801cdf6:	4836      	ldr	r0, [pc, #216]	; (801ced0 <buttonCheck+0x2b4>)
                                buttonActionsSFX[i][ActionHoldInstant] = TRUE;
 801cdf8:	eb09 0102 	add.w	r1, r9, r2
                                writeActionFlag = ActionHoldInstant;
 801cdfc:	f04f 0b02 	mov.w	fp, #2
                                buttonActionsUI[i][ActionHoldInstant] = TRUE;
 801ce00:	4402      	add	r2, r0
                                writeButtonFlag = i;
 801ce02:	b258      	sxtb	r0, r3
 801ce04:	9001      	str	r0, [sp, #4]
                                buttonActionsSFX[i][ActionHoldInstant] = TRUE;
 801ce06:	f04f 0001 	mov.w	r0, #1
 801ce0a:	7088      	strb	r0, [r1, #2]
                                buttonActionsUI[i][ActionHoldInstant] = TRUE;
 801ce0c:	7090      	strb	r0, [r2, #2]
 801ce0e:	e777      	b.n	801cd00 <buttonCheck+0xe4>
                        if (buttonActionsUI[ButtonC][ActionPress] == 1)
 801ce10:	7f1c      	ldrb	r4, [r3, #28]
 801ce12:	2c01      	cmp	r4, #1
 801ce14:	f000 8264 	beq.w	801d2e0 <buttonCheck+0x6c4>
                        if (buttonActionsUI[ButtonDown][ActionPress])
 801ce18:	4d2d      	ldr	r5, [pc, #180]	; (801ced0 <buttonCheck+0x2b4>)
 801ce1a:	7b2b      	ldrb	r3, [r5, #12]
 801ce1c:	b14b      	cbz	r3, 801ce32 <buttonCheck+0x216>
                            cvAddParam[currentPreset] = -1;
 801ce1e:	4a2d      	ldr	r2, [pc, #180]	; (801ced4 <buttonCheck+0x2b8>)
                            buttonActionsUI[ButtonDown][ActionPress] = 0;
 801ce20:	2300      	movs	r3, #0
                            cvAddParam[currentPreset] = -1;
 801ce22:	20ff      	movs	r0, #255	; 0xff
 801ce24:	4c2c      	ldr	r4, [pc, #176]	; (801ced8 <buttonCheck+0x2bc>)
 801ce26:	7811      	ldrb	r1, [r2, #0]
                            buttonActionsSFX[ButtonDown][ActionPress] = 0;
 801ce28:	4a2c      	ldr	r2, [pc, #176]	; (801cedc <buttonCheck+0x2c0>)
                            cvAddParam[currentPreset] = -1;
 801ce2a:	5460      	strb	r0, [r4, r1]
                            buttonActionsUI[ButtonDown][ActionPress] = 0;
 801ce2c:	732b      	strb	r3, [r5, #12]
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
 801ce2e:	70eb      	strb	r3, [r5, #3]
                            buttonActionsSFX[ButtonDown][ActionPress] = 0;
 801ce30:	7313      	strb	r3, [r2, #12]
                    if (buttonActionsUI[ButtonEdit][ActionRelease] == 1)
 801ce32:	4b27      	ldr	r3, [pc, #156]	; (801ced0 <buttonCheck+0x2b4>)
 801ce34:	785b      	ldrb	r3, [r3, #1]
 801ce36:	2b01      	cmp	r3, #1
 801ce38:	d1ca      	bne.n	801cdd0 <buttonCheck+0x1b4>
                        OLED_writePreset();
 801ce3a:	f7f6 fdeb 	bl	8013a14 <OLED_writePreset>
                        setLED_Edit(0);
 801ce3e:	2000      	movs	r0, #0
 801ce40:	f7f6 fd48 	bl	80138d4 <setLED_Edit>
                        buttonActionsSFX[ButtonEdit][ActionRelease] = 0;
 801ce44:	2300      	movs	r3, #0
 801ce46:	4a25      	ldr	r2, [pc, #148]	; (801cedc <buttonCheck+0x2c0>)
                        buttonActionsUI[ButtonEdit][ActionRelease] = 0;
 801ce48:	4921      	ldr	r1, [pc, #132]	; (801ced0 <buttonCheck+0x2b4>)
                        buttonActionsSFX[ButtonEdit][ActionRelease] = 0;
 801ce4a:	7053      	strb	r3, [r2, #1]
                        buttonActionsUI[ButtonEdit][ActionRelease] = 0;
 801ce4c:	704b      	strb	r3, [r1, #1]
                        buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
 801ce4e:	70cb      	strb	r3, [r1, #3]
                        buttonActionsSFX[ButtonEdit][ActionHoldContinuous] = 0;
 801ce50:	70d3      	strb	r3, [r2, #3]
                    if (buttonActionsUI[ButtonDown][ActionPress] == 1)
 801ce52:	4b1f      	ldr	r3, [pc, #124]	; (801ced0 <buttonCheck+0x2b4>)
 801ce54:	7b1b      	ldrb	r3, [r3, #12]
 801ce56:	2b01      	cmp	r3, #1
 801ce58:	d1ba      	bne.n	801cdd0 <buttonCheck+0x1b4>

            }

            void decrementPage(void)
            {
                if (knobPage == 0) knobPage = numPages[currentPreset] - 1;
 801ce5a:	4f21      	ldr	r7, [pc, #132]	; (801cee0 <buttonCheck+0x2c4>)
 801ce5c:	4d1d      	ldr	r5, [pc, #116]	; (801ced4 <buttonCheck+0x2b8>)
 801ce5e:	783b      	ldrb	r3, [r7, #0]
 801ce60:	7829      	ldrb	r1, [r5, #0]
 801ce62:	2b00      	cmp	r3, #0
 801ce64:	f000 8231 	beq.w	801d2ca <buttonCheck+0x6ae>
                else knobPage--;
 801ce68:	3b01      	subs	r3, #1
 801ce6a:	fa5f f983 	uxtb.w	r9, r3
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 801ce6e:	4b1d      	ldr	r3, [pc, #116]	; (801cee4 <buttonCheck+0x2c8>)
 801ce70:	2064      	movs	r0, #100	; 0x64
 801ce72:	4c19      	ldr	r4, [pc, #100]	; (801ced8 <buttonCheck+0x2bc>)
 801ce74:	464a      	mov	r2, r9
 801ce76:	fb00 3001 	mla	r0, r0, r1, r3
                    {
                        knob = 5;
                    }
                    knobActive[knob] = 0;
                    floatADCUI[knob] = -1.0f;
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801ce7a:	2314      	movs	r3, #20
 801ce7c:	9401      	str	r4, [sp, #4]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801ce7e:	f04f 0a00 	mov.w	sl, #0
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801ce82:	fb13 3309 	smlabb	r3, r3, r9, r3
 801ce86:	4c18      	ldr	r4, [pc, #96]	; (801cee8 <buttonCheck+0x2cc>)
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 801ce88:	9004      	str	r0, [sp, #16]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801ce8a:	18c3      	adds	r3, r0, r3
 801ce8c:	9402      	str	r4, [sp, #8]
 801ce8e:	f8df 8068 	ldr.w	r8, [pc, #104]	; 801cef8 <buttonCheck+0x2dc>
 801ce92:	9305      	str	r3, [sp, #20]
 801ce94:	4b15      	ldr	r3, [pc, #84]	; (801ceec <buttonCheck+0x2d0>)
 801ce96:	f887 9000 	strb.w	r9, [r7]
 801ce9a:	9303      	str	r3, [sp, #12]
 801ce9c:	e043      	b.n	801cf26 <buttonCheck+0x30a>
 801ce9e:	bf00      	nop
 801cea0:	20000508 	.word	0x20000508
 801cea4:	58020400 	.word	0x58020400
 801cea8:	200190b4 	.word	0x200190b4
 801ceac:	200002d0 	.word	0x200002d0
 801ceb0:	200002c8 	.word	0x200002c8
 801ceb4:	200002da 	.word	0x200002da
 801ceb8:	200002cc 	.word	0x200002cc
 801cebc:	58020c00 	.word	0x58020c00
 801cec0:	200002d9 	.word	0x200002d9
 801cec4:	200187a4 	.word	0x200187a4
 801cec8:	20018707 	.word	0x20018707
 801cecc:	58021800 	.word	0x58021800
 801ced0:	2001889c 	.word	0x2001889c
 801ced4:	20000669 	.word	0x20000669
 801ced8:	20018980 	.word	0x20018980
 801cedc:	2001872c 	.word	0x2001872c
 801cee0:	2000066a 	.word	0x2000066a
 801cee4:	20002cb8 	.word	0x20002cb8
 801cee8:	20017950 	.word	0x20017950
 801ceec:	2001886c 	.word	0x2001886c
 801cef0:	200187d0 	.word	0x200187d0
 801cef4:	20018910 	.word	0x20018910
 801cef8:	20018884 	.word	0x20018884
                    knobActive[knob] = 0;
 801cefc:	9b02      	ldr	r3, [sp, #8]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cefe:	ed9b 0a00 	vldr	s0, [fp]
                    knobActive[knob] = 0;
 801cf02:	f843 e02a 	str.w	lr, [r3, sl, lsl #2]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801cf06:	f10a 0a01 	add.w	sl, sl, #1
                    floatADCUI[knob] = -1.0f;
 801cf0a:	edcc 7a00 	vstr	s15, [ip]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cf0e:	f005 fb3b 	bl	8022588 <tExpSmooth_setValAndDest>

                    smoothedADC[knob] = values[knob];
 801cf12:	9b03      	ldr	r3, [sp, #12]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801cf14:	f1ba 0f05 	cmp.w	sl, #5
                    smoothedADC[knob] = values[knob];
 801cf18:	441c      	add	r4, r3
 801cf1a:	f8db 3000 	ldr.w	r3, [fp]
 801cf1e:	6023      	str	r3, [r4, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801cf20:	d02b      	beq.n	801cf7a <buttonCheck+0x35e>
 801cf22:	783a      	ldrb	r2, [r7, #0]
 801cf24:	7829      	ldrb	r1, [r5, #0]
 801cf26:	ea4f 048a 	mov.w	r4, sl, lsl #2
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cf2a:	2614      	movs	r6, #20
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 801cf2c:	2305      	movs	r3, #5
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cf2e:	48b9      	ldr	r0, [pc, #740]	; (801d214 <buttonCheck+0x5f8>)
 801cf30:	fb16 4b09 	smlabb	fp, r6, r9, r4
 801cf34:	9e04      	ldr	r6, [sp, #16]
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 801cf36:	fb13 a302 	smlabb	r3, r3, r2, sl
                    floatADCUI[knob] = -1.0f;
 801cf3a:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cf3e:	44b3      	add	fp, r6
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 801cf40:	9e01      	ldr	r6, [sp, #4]
                    knobActive[knob] = 0;
 801cf42:	f04f 0e00 	mov.w	lr, #0
                    floatADCUI[knob] = -1.0f;
 801cf46:	eb08 0c04 	add.w	ip, r8, r4
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 801cf4a:	5671      	ldrsb	r1, [r6, r1]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cf4c:	4420      	add	r0, r4
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 801cf4e:	428b      	cmp	r3, r1
 801cf50:	d1d4      	bne.n	801cefc <buttonCheck+0x2e0>
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cf52:	9c05      	ldr	r4, [sp, #20]
                    knobActive[knob] = 0;
 801cf54:	2200      	movs	r2, #0
                    floatADCUI[knob] = -1.0f;
 801cf56:	4bb0      	ldr	r3, [pc, #704]	; (801d218 <buttonCheck+0x5fc>)
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801cf58:	f10a 0a01 	add.w	sl, sl, #1
                    knobActive[knob] = 0;
 801cf5c:	9902      	ldr	r1, [sp, #8]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cf5e:	ed94 0a00 	vldr	s0, [r4]
 801cf62:	48ae      	ldr	r0, [pc, #696]	; (801d21c <buttonCheck+0x600>)
                    knobActive[knob] = 0;
 801cf64:	614a      	str	r2, [r1, #20]
                    floatADCUI[knob] = -1.0f;
 801cf66:	f8c8 3014 	str.w	r3, [r8, #20]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cf6a:	f005 fb0d 	bl	8022588 <tExpSmooth_setValAndDest>
                    smoothedADC[knob] = values[knob];
 801cf6e:	6823      	ldr	r3, [r4, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801cf70:	f1ba 0f05 	cmp.w	sl, #5
                    smoothedADC[knob] = values[knob];
 801cf74:	9a03      	ldr	r2, [sp, #12]
 801cf76:	6153      	str	r3, [r2, #20]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801cf78:	d1d3      	bne.n	801cf22 <buttonCheck+0x306>
                        OLEDwriteString("P", 1, 110, FirstLine);
 801cf7a:	2300      	movs	r3, #0
 801cf7c:	226e      	movs	r2, #110	; 0x6e
 801cf7e:	2101      	movs	r1, #1
 801cf80:	48a7      	ldr	r0, [pc, #668]	; (801d220 <buttonCheck+0x604>)
 801cf82:	f7f6 ff25 	bl	8013dd0 <OLEDwriteString>
                        OLEDwriteInt(knobPage, 1, 120, FirstLine);
 801cf86:	2300      	movs	r3, #0
 801cf88:	2278      	movs	r2, #120	; 0x78
 801cf8a:	7838      	ldrb	r0, [r7, #0]
 801cf8c:	2101      	movs	r1, #1
 801cf8e:	f7f6 ff4b 	bl	8013e28 <OLEDwriteInt>
                        buttonActionsUI[ButtonDown][ActionPress] = 0;
 801cf92:	2300      	movs	r3, #0
 801cf94:	4aa3      	ldr	r2, [pc, #652]	; (801d224 <buttonCheck+0x608>)
 801cf96:	7313      	strb	r3, [r2, #12]
                    if (buttonActionsUI[ButtonUp][ActionPress] == 1)
 801cf98:	4ba2      	ldr	r3, [pc, #648]	; (801d224 <buttonCheck+0x608>)
 801cf9a:	7c1b      	ldrb	r3, [r3, #16]
 801cf9c:	2b01      	cmp	r3, #1
 801cf9e:	f47f af1c 	bne.w	801cdda <buttonCheck+0x1be>
                knobPage = (knobPage + 1) % numPages[currentPreset];
 801cfa2:	4fa1      	ldr	r7, [pc, #644]	; (801d228 <buttonCheck+0x60c>)
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 801cfa4:	2464      	movs	r4, #100	; 0x64
                knobPage = (knobPage + 1) % numPages[currentPreset];
 801cfa6:	4da1      	ldr	r5, [pc, #644]	; (801d22c <buttonCheck+0x610>)
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801cfa8:	f04f 0a00 	mov.w	sl, #0
                knobPage = (knobPage + 1) % numPages[currentPreset];
 801cfac:	783b      	ldrb	r3, [r7, #0]
 801cfae:	7829      	ldrb	r1, [r5, #0]
 801cfb0:	4a9f      	ldr	r2, [pc, #636]	; (801d230 <buttonCheck+0x614>)
 801cfb2:	4ea0      	ldr	r6, [pc, #640]	; (801d234 <buttonCheck+0x618>)
 801cfb4:	5c50      	ldrb	r0, [r2, r1]
 801cfb6:	1c5a      	adds	r2, r3, #1
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 801cfb8:	4b9f      	ldr	r3, [pc, #636]	; (801d238 <buttonCheck+0x61c>)
 801cfba:	9601      	str	r6, [sp, #4]
 801cfbc:	fb04 3401 	mla	r4, r4, r1, r3
 801cfc0:	4b9e      	ldr	r3, [pc, #632]	; (801d23c <buttonCheck+0x620>)
 801cfc2:	f8df 82a8 	ldr.w	r8, [pc, #680]	; 801d26c <buttonCheck+0x650>
 801cfc6:	9302      	str	r3, [sp, #8]
 801cfc8:	4626      	mov	r6, r4
 801cfca:	4b9d      	ldr	r3, [pc, #628]	; (801d240 <buttonCheck+0x624>)
 801cfcc:	9404      	str	r4, [sp, #16]
 801cfce:	9303      	str	r3, [sp, #12]
                knobPage = (knobPage + 1) % numPages[currentPreset];
 801cfd0:	fb92 f3f0 	sdiv	r3, r2, r0
 801cfd4:	fb00 2313 	mls	r3, r0, r3, r2
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 801cfd8:	eb03 0983 	add.w	r9, r3, r3, lsl #2
                knobPage = (knobPage + 1) % numPages[currentPreset];
 801cfdc:	b2db      	uxtb	r3, r3
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 801cfde:	ea4f 0989 	mov.w	r9, r9, lsl #2
                knobPage = (knobPage + 1) % numPages[currentPreset];
 801cfe2:	703b      	strb	r3, [r7, #0]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cfe4:	f109 0214 	add.w	r2, r9, #20
 801cfe8:	18a2      	adds	r2, r4, r2
 801cfea:	9205      	str	r2, [sp, #20]
 801cfec:	ea4f 048a 	mov.w	r4, sl, lsl #2
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 801cff0:	2205      	movs	r2, #5
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cff2:	4888      	ldr	r0, [pc, #544]	; (801d214 <buttonCheck+0x5f8>)
                    floatADCUI[knob] = -1.0f;
 801cff4:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801cff8:	eb09 0b04 	add.w	fp, r9, r4
                    knobActive[knob] = 0;
 801cffc:	f04f 0e00 	mov.w	lr, #0
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 801d000:	fb12 a203 	smlabb	r2, r2, r3, sl
                    floatADCUI[knob] = -1.0f;
 801d004:	eb08 0c04 	add.w	ip, r8, r4
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801d008:	44b3      	add	fp, r6
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 801d00a:	9e01      	ldr	r6, [sp, #4]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801d00c:	4420      	add	r0, r4
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 801d00e:	5671      	ldrsb	r1, [r6, r1]
 801d010:	428a      	cmp	r2, r1
 801d012:	f000 812d 	beq.w	801d270 <buttonCheck+0x654>
                    knobActive[knob] = 0;
 801d016:	9b02      	ldr	r3, [sp, #8]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801d018:	ed9b 0a00 	vldr	s0, [fp]
                    knobActive[knob] = 0;
 801d01c:	f843 e02a 	str.w	lr, [r3, sl, lsl #2]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801d020:	f10a 0a01 	add.w	sl, sl, #1
                    floatADCUI[knob] = -1.0f;
 801d024:	edcc 7a00 	vstr	s15, [ip]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801d028:	f005 faae 	bl	8022588 <tExpSmooth_setValAndDest>
                    smoothedADC[knob] = values[knob];
 801d02c:	9b03      	ldr	r3, [sp, #12]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801d02e:	f1ba 0f05 	cmp.w	sl, #5
                    smoothedADC[knob] = values[knob];
 801d032:	441c      	add	r4, r3
 801d034:	f8db 3000 	ldr.w	r3, [fp]
 801d038:	6023      	str	r3, [r4, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801d03a:	f000 812e 	beq.w	801d29a <buttonCheck+0x67e>
 801d03e:	783b      	ldrb	r3, [r7, #0]
 801d040:	7829      	ldrb	r1, [r5, #0]
 801d042:	9e04      	ldr	r6, [sp, #16]
 801d044:	e7d2      	b.n	801cfec <buttonCheck+0x3d0>
                        previousPreset = currentPreset;
 801d046:	4d79      	ldr	r5, [pc, #484]	; (801d22c <buttonCheck+0x610>)
 801d048:	4a7e      	ldr	r2, [pc, #504]	; (801d244 <buttonCheck+0x628>)
 801d04a:	782b      	ldrb	r3, [r5, #0]
 801d04c:	7013      	strb	r3, [r2, #0]
                        if (currentPreset <= 0) currentPreset = (VocodecPresetType)((int)PresetNil - 1);
 801d04e:	2b00      	cmp	r3, #0
 801d050:	f000 8139 	beq.w	801d2c6 <buttonCheck+0x6aa>
                        else currentPreset = (VocodecPresetType)((int)currentPreset - 1);
 801d054:	3b01      	subs	r3, #1
 801d056:	b2db      	uxtb	r3, r3
                        loadingPreset = 1;
 801d058:	2101      	movs	r1, #1
 801d05a:	4a7b      	ldr	r2, [pc, #492]	; (801d248 <buttonCheck+0x62c>)
 801d05c:	702b      	strb	r3, [r5, #0]
 801d05e:	7011      	strb	r1, [r2, #0]
                        OLED_writePreset();
 801d060:	f7f6 fcd8 	bl	8013a14 <OLED_writePreset>
                if((EE_WriteVariable(VirtAddVarTab[0],  currentPreset)) != HAL_OK)
 801d064:	4b79      	ldr	r3, [pc, #484]	; (801d24c <buttonCheck+0x630>)
 801d066:	7829      	ldrb	r1, [r5, #0]
 801d068:	8818      	ldrh	r0, [r3, #0]
 801d06a:	f7f4 fe81 	bl	8011d70 <EE_WriteVariable>
 801d06e:	b108      	cbz	r0, 801d074 <buttonCheck+0x458>
                    Error_Handler();
 801d070:	f7f6 fc2c 	bl	80138cc <Error_Handler>
                        buttonActionsUI[b][a] = 0;
 801d074:	2300      	movs	r3, #0
                        buttonActionsSFX[b][a] = 0;
 801d076:	4a76      	ldr	r2, [pc, #472]	; (801d250 <buttonCheck+0x634>)
                        buttonActionsUI[b][a] = 0;
 801d078:	486a      	ldr	r0, [pc, #424]	; (801d224 <buttonCheck+0x608>)
 801d07a:	21ff      	movs	r1, #255	; 0xff
                        buttonActionsSFX[b][a] = 0;
 801d07c:	6013      	str	r3, [r2, #0]
                        buttonActionsUI[b][a] = 0;
 801d07e:	6083      	str	r3, [r0, #8]
 801d080:	60c3      	str	r3, [r0, #12]
 801d082:	6103      	str	r3, [r0, #16]
 801d084:	6143      	str	r3, [r0, #20]
 801d086:	6183      	str	r3, [r0, #24]
 801d088:	61c3      	str	r3, [r0, #28]
 801d08a:	6203      	str	r3, [r0, #32]
 801d08c:	6243      	str	r3, [r0, #36]	; 0x24
 801d08e:	6283      	str	r3, [r0, #40]	; 0x28
 801d090:	6003      	str	r3, [r0, #0]
 801d092:	6043      	str	r3, [r0, #4]
                        buttonActionsSFX[b][a] = 0;
 801d094:	6053      	str	r3, [r2, #4]
 801d096:	6093      	str	r3, [r2, #8]
 801d098:	60d3      	str	r3, [r2, #12]
 801d09a:	6113      	str	r3, [r2, #16]
 801d09c:	6153      	str	r3, [r2, #20]
 801d09e:	6193      	str	r3, [r2, #24]
 801d0a0:	61d3      	str	r3, [r2, #28]
 801d0a2:	6213      	str	r3, [r2, #32]
 801d0a4:	6253      	str	r3, [r2, #36]	; 0x24
 801d0a6:	6293      	str	r3, [r2, #40]	; 0x28
 801d0a8:	4b6a      	ldr	r3, [pc, #424]	; (801d254 <buttonCheck+0x638>)
 801d0aa:	7019      	strb	r1, [r3, #0]
 801d0ac:	4b6a      	ldr	r3, [pc, #424]	; (801d258 <buttonCheck+0x63c>)
 801d0ae:	7019      	strb	r1, [r3, #0]
                    if (buttonActionsUI[ButtonRight][ActionPress] == 1)
 801d0b0:	4b5c      	ldr	r3, [pc, #368]	; (801d224 <buttonCheck+0x608>)
 801d0b2:	7a1b      	ldrb	r3, [r3, #8]
 801d0b4:	2b01      	cmp	r3, #1
 801d0b6:	f47f ae6e 	bne.w	801cd96 <buttonCheck+0x17a>
                        previousPreset = currentPreset;
 801d0ba:	4d5c      	ldr	r5, [pc, #368]	; (801d22c <buttonCheck+0x610>)
 801d0bc:	4a61      	ldr	r2, [pc, #388]	; (801d244 <buttonCheck+0x628>)
 801d0be:	782b      	ldrb	r3, [r5, #0]
                        if (currentPreset >= PresetNil - 1) currentPreset = (VocodecPresetType)0;
 801d0c0:	2b10      	cmp	r3, #16
                        previousPreset = currentPreset;
 801d0c2:	7013      	strb	r3, [r2, #0]
                        if (currentPreset >= PresetNil - 1) currentPreset = (VocodecPresetType)0;
 801d0c4:	f200 80fd 	bhi.w	801d2c2 <buttonCheck+0x6a6>
                        else currentPreset = (VocodecPresetType)((int)currentPreset + 1);
 801d0c8:	3301      	adds	r3, #1
 801d0ca:	b2db      	uxtb	r3, r3
                        loadingPreset = 1;
 801d0cc:	2101      	movs	r1, #1
 801d0ce:	4a5e      	ldr	r2, [pc, #376]	; (801d248 <buttonCheck+0x62c>)
 801d0d0:	702b      	strb	r3, [r5, #0]
 801d0d2:	7011      	strb	r1, [r2, #0]
                        OLED_writePreset();
 801d0d4:	f7f6 fc9e 	bl	8013a14 <OLED_writePreset>
                if((EE_WriteVariable(VirtAddVarTab[0],  currentPreset)) != HAL_OK)
 801d0d8:	4b5c      	ldr	r3, [pc, #368]	; (801d24c <buttonCheck+0x630>)
 801d0da:	7829      	ldrb	r1, [r5, #0]
 801d0dc:	8818      	ldrh	r0, [r3, #0]
 801d0de:	f7f4 fe47 	bl	8011d70 <EE_WriteVariable>
 801d0e2:	b108      	cbz	r0, 801d0e8 <buttonCheck+0x4cc>
                    Error_Handler();
 801d0e4:	f7f6 fbf2 	bl	80138cc <Error_Handler>
                        buttonActionsUI[b][a] = 0;
 801d0e8:	2300      	movs	r3, #0
                        buttonActionsSFX[b][a] = 0;
 801d0ea:	4a59      	ldr	r2, [pc, #356]	; (801d250 <buttonCheck+0x634>)
                        buttonActionsUI[b][a] = 0;
 801d0ec:	484d      	ldr	r0, [pc, #308]	; (801d224 <buttonCheck+0x608>)
 801d0ee:	21ff      	movs	r1, #255	; 0xff
                        buttonActionsSFX[b][a] = 0;
 801d0f0:	6013      	str	r3, [r2, #0]
                        buttonActionsUI[b][a] = 0;
 801d0f2:	6203      	str	r3, [r0, #32]
 801d0f4:	6243      	str	r3, [r0, #36]	; 0x24
 801d0f6:	6283      	str	r3, [r0, #40]	; 0x28
 801d0f8:	6003      	str	r3, [r0, #0]
 801d0fa:	6043      	str	r3, [r0, #4]
 801d0fc:	6083      	str	r3, [r0, #8]
 801d0fe:	60c3      	str	r3, [r0, #12]
 801d100:	6103      	str	r3, [r0, #16]
 801d102:	6143      	str	r3, [r0, #20]
 801d104:	6183      	str	r3, [r0, #24]
 801d106:	61c3      	str	r3, [r0, #28]
                        buttonActionsSFX[b][a] = 0;
 801d108:	6053      	str	r3, [r2, #4]
 801d10a:	6093      	str	r3, [r2, #8]
 801d10c:	60d3      	str	r3, [r2, #12]
 801d10e:	6113      	str	r3, [r2, #16]
 801d110:	6153      	str	r3, [r2, #20]
 801d112:	6193      	str	r3, [r2, #24]
 801d114:	61d3      	str	r3, [r2, #28]
 801d116:	6213      	str	r3, [r2, #32]
 801d118:	6253      	str	r3, [r2, #36]	; 0x24
 801d11a:	6293      	str	r3, [r2, #40]	; 0x28
 801d11c:	4b4d      	ldr	r3, [pc, #308]	; (801d254 <buttonCheck+0x638>)
 801d11e:	7019      	strb	r1, [r3, #0]
 801d120:	4b4d      	ldr	r3, [pc, #308]	; (801d258 <buttonCheck+0x63c>)
 801d122:	7019      	strb	r1, [r3, #0]
                    if (buttonActionsUI[ButtonD][ActionPress] == 1)
 801d124:	4b3f      	ldr	r3, [pc, #252]	; (801d224 <buttonCheck+0x608>)
 801d126:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d12a:	2b01      	cmp	r3, #1
 801d12c:	f47f ae39 	bne.w	801cda2 <buttonCheck+0x186>
                        if (currentTuning == 0)
 801d130:	4a4a      	ldr	r2, [pc, #296]	; (801d25c <buttonCheck+0x640>)
 801d132:	6813      	ldr	r3, [r2, #0]
 801d134:	2b00      	cmp	r3, #0
 801d136:	f040 80c2 	bne.w	801d2be <buttonCheck+0x6a2>
                            currentTuning = NUM_TUNINGS - 1;
 801d13a:	233e      	movs	r3, #62	; 0x3e
                    centsDeviation[i] = tuningPresets[currentTuning][i];
 801d13c:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801d140:	4c47      	ldr	r4, [pc, #284]	; (801d260 <buttonCheck+0x644>)
 801d142:	4f48      	ldr	r7, [pc, #288]	; (801d264 <buttonCheck+0x648>)
 801d144:	eb04 1401 	add.w	r4, r4, r1, lsl #4
 801d148:	6013      	str	r3, [r2, #0]
 801d14a:	f104 0c30 	add.w	ip, r4, #48	; 0x30
 801d14e:	6820      	ldr	r0, [r4, #0]
 801d150:	3410      	adds	r4, #16
 801d152:	f854 1c0c 	ldr.w	r1, [r4, #-12]
 801d156:	463d      	mov	r5, r7
 801d158:	f854 2c08 	ldr.w	r2, [r4, #-8]
 801d15c:	3710      	adds	r7, #16
 801d15e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 801d162:	4564      	cmp	r4, ip
 801d164:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801d166:	d1f2      	bne.n	801d14e <buttonCheck+0x532>
                if (currentPreset == AutotuneMono)
 801d168:	4b30      	ldr	r3, [pc, #192]	; (801d22c <buttonCheck+0x610>)
 801d16a:	781b      	ldrb	r3, [r3, #0]
 801d16c:	2b03      	cmp	r3, #3
 801d16e:	f000 80b4 	beq.w	801d2da <buttonCheck+0x6be>
                        OLED_writeTuning();
 801d172:	f7f6 fd99 	bl	8013ca8 <OLED_writeTuning>
                        buttonActionsUI[ButtonD][ActionPress] = 0;
 801d176:	2300      	movs	r3, #0
 801d178:	4a2a      	ldr	r2, [pc, #168]	; (801d224 <buttonCheck+0x608>)
 801d17a:	f882 3020 	strb.w	r3, [r2, #32]
                    if (buttonActionsUI[ButtonE][ActionPress] == 1)
 801d17e:	4b29      	ldr	r3, [pc, #164]	; (801d224 <buttonCheck+0x608>)
 801d180:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801d184:	2b01      	cmp	r3, #1
 801d186:	f47f ae12 	bne.w	801cdae <buttonCheck+0x192>
 801d18a:	e00e      	b.n	801d1aa <buttonCheck+0x58e>
                        OLED_writeEditScreen();
 801d18c:	f7f6 fd40 	bl	8013c10 <OLED_writeEditScreen>
                        setLED_Edit(1);
 801d190:	2001      	movs	r0, #1
 801d192:	f7f6 fb9f 	bl	80138d4 <setLED_Edit>
                        buttonActionsUI[ButtonEdit][ActionPress] = 0;
 801d196:	2300      	movs	r3, #0
 801d198:	4a22      	ldr	r2, [pc, #136]	; (801d224 <buttonCheck+0x608>)
 801d19a:	7013      	strb	r3, [r2, #0]
                    if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
 801d19c:	4b21      	ldr	r3, [pc, #132]	; (801d224 <buttonCheck+0x608>)
 801d19e:	78db      	ldrb	r3, [r3, #3]
 801d1a0:	2b01      	cmp	r3, #1
                        if (buttonActionsUI[ButtonC][ActionPress] == 1)
 801d1a2:	4b20      	ldr	r3, [pc, #128]	; (801d224 <buttonCheck+0x608>)
                    if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
 801d1a4:	f47f ae0d 	bne.w	801cdc2 <buttonCheck+0x1a6>
 801d1a8:	e632      	b.n	801ce10 <buttonCheck+0x1f4>
                        currentTuning = (currentTuning + 1) % NUM_TUNINGS;
 801d1aa:	492c      	ldr	r1, [pc, #176]	; (801d25c <buttonCheck+0x640>)
 801d1ac:	4b2e      	ldr	r3, [pc, #184]	; (801d268 <buttonCheck+0x64c>)
 801d1ae:	680a      	ldr	r2, [r1, #0]
                    centsDeviation[i] = tuningPresets[currentTuning][i];
 801d1b0:	4c2b      	ldr	r4, [pc, #172]	; (801d260 <buttonCheck+0x644>)
                        currentTuning = (currentTuning + 1) % NUM_TUNINGS;
 801d1b2:	3201      	adds	r2, #1
 801d1b4:	4f2b      	ldr	r7, [pc, #172]	; (801d264 <buttonCheck+0x648>)
 801d1b6:	fba3 0302 	umull	r0, r3, r3, r2
 801d1ba:	1ad0      	subs	r0, r2, r3
 801d1bc:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 801d1c0:	095b      	lsrs	r3, r3, #5
 801d1c2:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
 801d1c6:	1ad3      	subs	r3, r2, r3
                    centsDeviation[i] = tuningPresets[currentTuning][i];
 801d1c8:	eb03 0243 	add.w	r2, r3, r3, lsl #1
                        currentTuning = (currentTuning + 1) % NUM_TUNINGS;
 801d1cc:	600b      	str	r3, [r1, #0]
                    centsDeviation[i] = tuningPresets[currentTuning][i];
 801d1ce:	eb04 1402 	add.w	r4, r4, r2, lsl #4
 801d1d2:	f104 0c30 	add.w	ip, r4, #48	; 0x30
 801d1d6:	6820      	ldr	r0, [r4, #0]
 801d1d8:	3410      	adds	r4, #16
 801d1da:	f854 1c0c 	ldr.w	r1, [r4, #-12]
 801d1de:	463d      	mov	r5, r7
 801d1e0:	f854 2c08 	ldr.w	r2, [r4, #-8]
 801d1e4:	3710      	adds	r7, #16
 801d1e6:	f854 3c04 	ldr.w	r3, [r4, #-4]
 801d1ea:	4564      	cmp	r4, ip
 801d1ec:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801d1ee:	d1f2      	bne.n	801d1d6 <buttonCheck+0x5ba>
                if (currentPreset == AutotuneMono)
 801d1f0:	4b0e      	ldr	r3, [pc, #56]	; (801d22c <buttonCheck+0x610>)
 801d1f2:	781b      	ldrb	r3, [r3, #0]
 801d1f4:	2b03      	cmp	r3, #3
 801d1f6:	d101      	bne.n	801d1fc <buttonCheck+0x5e0>
                    calculateNoteArray();
 801d1f8:	f7fd fffe 	bl	801b1f8 <calculateNoteArray>
                        OLED_writeTuning();
 801d1fc:	f7f6 fd54 	bl	8013ca8 <OLED_writeTuning>
                        buttonActionsUI[ButtonE][ActionPress] = 0;
 801d200:	2300      	movs	r3, #0
 801d202:	4a08      	ldr	r2, [pc, #32]	; (801d224 <buttonCheck+0x608>)
 801d204:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                    if (buttonActionsUI[ButtonEdit][ActionPress])
 801d208:	4b06      	ldr	r3, [pc, #24]	; (801d224 <buttonCheck+0x608>)
 801d20a:	781b      	ldrb	r3, [r3, #0]
 801d20c:	2b00      	cmp	r3, #0
 801d20e:	f43f add3 	beq.w	801cdb8 <buttonCheck+0x19c>
 801d212:	e7bb      	b.n	801d18c <buttonCheck+0x570>
 801d214:	20018840 	.word	0x20018840
 801d218:	bf800000 	.word	0xbf800000
 801d21c:	20018854 	.word	0x20018854
 801d220:	0802b898 	.word	0x0802b898
 801d224:	2001889c 	.word	0x2001889c
 801d228:	2000066a 	.word	0x2000066a
 801d22c:	20000669 	.word	0x20000669
 801d230:	20018858 	.word	0x20018858
 801d234:	20018980 	.word	0x20018980
 801d238:	20002cb8 	.word	0x20002cb8
 801d23c:	20017950 	.word	0x20017950
 801d240:	2001886c 	.word	0x2001886c
 801d244:	200002d8 	.word	0x200002d8
 801d248:	2000066b 	.word	0x2000066b
 801d24c:	2000001c 	.word	0x2000001c
 801d250:	2001872c 	.word	0x2001872c
 801d254:	200002da 	.word	0x200002da
 801d258:	200002d9 	.word	0x200002d9
 801d25c:	20000664 	.word	0x20000664
 801d260:	0802a53c 	.word	0x0802a53c
 801d264:	20000634 	.word	0x20000634
 801d268:	04104105 	.word	0x04104105
 801d26c:	20018884 	.word	0x20018884
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801d270:	9c05      	ldr	r4, [sp, #20]
                    knobActive[knob] = 0;
 801d272:	2200      	movs	r2, #0
                    floatADCUI[knob] = -1.0f;
 801d274:	4b2d      	ldr	r3, [pc, #180]	; (801d32c <buttonCheck+0x710>)
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801d276:	f10a 0a01 	add.w	sl, sl, #1
                    knobActive[knob] = 0;
 801d27a:	9902      	ldr	r1, [sp, #8]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801d27c:	ed94 0a00 	vldr	s0, [r4]
 801d280:	482b      	ldr	r0, [pc, #172]	; (801d330 <buttonCheck+0x714>)
                    knobActive[knob] = 0;
 801d282:	614a      	str	r2, [r1, #20]
                    floatADCUI[knob] = -1.0f;
 801d284:	f8c8 3014 	str.w	r3, [r8, #20]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 801d288:	f005 f97e 	bl	8022588 <tExpSmooth_setValAndDest>
                    smoothedADC[knob] = values[knob];
 801d28c:	6823      	ldr	r3, [r4, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801d28e:	f1ba 0f05 	cmp.w	sl, #5
                    smoothedADC[knob] = values[knob];
 801d292:	9a03      	ldr	r2, [sp, #12]
 801d294:	6153      	str	r3, [r2, #20]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 801d296:	f47f aed2 	bne.w	801d03e <buttonCheck+0x422>
                        OLEDwriteString("P", 1, 110, FirstLine);
 801d29a:	2300      	movs	r3, #0
 801d29c:	226e      	movs	r2, #110	; 0x6e
 801d29e:	2101      	movs	r1, #1
 801d2a0:	4824      	ldr	r0, [pc, #144]	; (801d334 <buttonCheck+0x718>)
 801d2a2:	f7f6 fd95 	bl	8013dd0 <OLEDwriteString>
                        OLEDwriteInt(knobPage, 1, 120, FirstLine);
 801d2a6:	7838      	ldrb	r0, [r7, #0]
 801d2a8:	2300      	movs	r3, #0
 801d2aa:	2278      	movs	r2, #120	; 0x78
 801d2ac:	2101      	movs	r1, #1
 801d2ae:	f7f6 fdbb 	bl	8013e28 <OLEDwriteInt>
                        buttonActionsUI[ButtonUp][ActionPress] = 0;
 801d2b2:	2300      	movs	r3, #0
 801d2b4:	4a20      	ldr	r2, [pc, #128]	; (801d338 <buttonCheck+0x71c>)
 801d2b6:	7413      	strb	r3, [r2, #16]
            }
 801d2b8:	b007      	add	sp, #28
 801d2ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                            currentTuning = (currentTuning - 1);
 801d2be:	3b01      	subs	r3, #1
 801d2c0:	e73c      	b.n	801d13c <buttonCheck+0x520>
                        if (currentPreset >= PresetNil - 1) currentPreset = (VocodecPresetType)0;
 801d2c2:	2300      	movs	r3, #0
 801d2c4:	e702      	b.n	801d0cc <buttonCheck+0x4b0>
                        if (currentPreset <= 0) currentPreset = (VocodecPresetType)((int)PresetNil - 1);
 801d2c6:	2311      	movs	r3, #17
 801d2c8:	e6c6      	b.n	801d058 <buttonCheck+0x43c>
                if (knobPage == 0) knobPage = numPages[currentPreset] - 1;
 801d2ca:	4b1c      	ldr	r3, [pc, #112]	; (801d33c <buttonCheck+0x720>)
 801d2cc:	f813 9001 	ldrb.w	r9, [r3, r1]
 801d2d0:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
 801d2d4:	fa5f f989 	uxtb.w	r9, r9
 801d2d8:	e5c9      	b.n	801ce6e <buttonCheck+0x252>
                    calculateNoteArray();
 801d2da:	f7fd ff8d 	bl	801b1f8 <calculateNoteArray>
 801d2de:	e748      	b.n	801d172 <buttonCheck+0x556>
                            keyCenter = (keyCenter + 1) % 12;
 801d2e0:	4d17      	ldr	r5, [pc, #92]	; (801d340 <buttonCheck+0x724>)
                            OLEDclearLine(SecondLine);
 801d2e2:	4620      	mov	r0, r4
                            keyCenter = (keyCenter + 1) % 12;
 801d2e4:	4b17      	ldr	r3, [pc, #92]	; (801d344 <buttonCheck+0x728>)
 801d2e6:	782a      	ldrb	r2, [r5, #0]
 801d2e8:	3201      	adds	r2, #1
 801d2ea:	fba3 1302 	umull	r1, r3, r3, r2
 801d2ee:	08db      	lsrs	r3, r3, #3
 801d2f0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801d2f4:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
 801d2f8:	702b      	strb	r3, [r5, #0]
                            OLEDclearLine(SecondLine);
 801d2fa:	f7f6 fd55 	bl	8013da8 <OLEDclearLine>
                            OLEDwriteString("KEY: ", 5, 0, SecondLine);
 801d2fe:	2200      	movs	r2, #0
 801d300:	4623      	mov	r3, r4
 801d302:	2105      	movs	r1, #5
 801d304:	4810      	ldr	r0, [pc, #64]	; (801d348 <buttonCheck+0x72c>)
 801d306:	f7f6 fd63 	bl	8013dd0 <OLEDwriteString>
                            OLEDwritePitchClass(keyCenter+60, 64, SecondLine);
 801d30a:	782b      	ldrb	r3, [r5, #0]
 801d30c:	4621      	mov	r1, r4
 801d30e:	2040      	movs	r0, #64	; 0x40
 801d310:	333c      	adds	r3, #60	; 0x3c
 801d312:	ee00 3a10 	vmov	s0, r3
 801d316:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 801d31a:	f7f6 fdeb 	bl	8013ef4 <OLEDwritePitchClass>
                            buttonActionsUI[ButtonC][ActionPress] = 0;
 801d31e:	2300      	movs	r3, #0
 801d320:	4905      	ldr	r1, [pc, #20]	; (801d338 <buttonCheck+0x71c>)
                            buttonActionsSFX[ButtonC][ActionPress] = 0;
 801d322:	4a0a      	ldr	r2, [pc, #40]	; (801d34c <buttonCheck+0x730>)
                            buttonActionsUI[ButtonC][ActionPress] = 0;
 801d324:	770b      	strb	r3, [r1, #28]
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
 801d326:	70cb      	strb	r3, [r1, #3]
                            buttonActionsSFX[ButtonC][ActionPress] = 0;
 801d328:	7713      	strb	r3, [r2, #28]
 801d32a:	e575      	b.n	801ce18 <buttonCheck+0x1fc>
 801d32c:	bf800000 	.word	0xbf800000
 801d330:	20018854 	.word	0x20018854
 801d334:	0802b898 	.word	0x0802b898
 801d338:	2001889c 	.word	0x2001889c
 801d33c:	20018858 	.word	0x20018858
 801d340:	20000668 	.word	0x20000668
 801d344:	aaaaaaab 	.word	0xaaaaaaab
 801d348:	0802b2fc 	.word	0x0802b2fc
 801d34c:	2001872c 	.word	0x2001872c

0801d350 <adcCheck>:
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
 801d350:	4870      	ldr	r0, [pc, #448]	; (801d514 <adcCheck+0x1c4>)
 801d352:	eddf 4a71 	vldr	s9, [pc, #452]	; 801d518 <adcCheck+0x1c8>
            {
 801d356:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
 801d35a:	8801      	ldrh	r1, [r0, #0]
 801d35c:	8842      	ldrh	r2, [r0, #2]
 801d35e:	8883      	ldrh	r3, [r0, #4]
 801d360:	0989      	lsrs	r1, r1, #6
 801d362:	0992      	lsrs	r2, r2, #6
                if (firstADCPass)
 801d364:	4e6d      	ldr	r6, [pc, #436]	; (801d51c <adcCheck+0x1cc>)
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
 801d366:	099b      	lsrs	r3, r3, #6
 801d368:	ee05 1a10 	vmov	s10, r1
 801d36c:	ee05 2a90 	vmov	s11, r2
 801d370:	88c1      	ldrh	r1, [r0, #6]
 801d372:	ee06 3a10 	vmov	s12, r3
 801d376:	8902      	ldrh	r2, [r0, #8]
 801d378:	8943      	ldrh	r3, [r0, #10]
 801d37a:	0989      	lsrs	r1, r1, #6
 801d37c:	0992      	lsrs	r2, r2, #6
 801d37e:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
 801d382:	099b      	lsrs	r3, r3, #6
 801d384:	ee06 1a90 	vmov	s13, r1
 801d388:	ee07 2a10 	vmov	s14, r2
 801d38c:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 801d390:	ee07 3a90 	vmov	s15, r3
 801d394:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 801d398:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801d39c:	4c60      	ldr	r4, [pc, #384]	; (801d520 <adcCheck+0x1d0>)
 801d39e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
                if (firstADCPass)
 801d3a2:	6832      	ldr	r2, [r6, #0]
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
 801d3a4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801d3a8:	ee25 5a24 	vmul.f32	s10, s10, s9
 801d3ac:	ee65 5aa4 	vmul.f32	s11, s11, s9
 801d3b0:	ee26 6a24 	vmul.f32	s12, s12, s9
 801d3b4:	ee66 6aa4 	vmul.f32	s13, s13, s9
 801d3b8:	ed84 5a00 	vstr	s10, [r4]
 801d3bc:	ee27 7a24 	vmul.f32	s14, s14, s9
 801d3c0:	edc4 5a01 	vstr	s11, [r4, #4]
 801d3c4:	ee67 7aa4 	vmul.f32	s15, s15, s9
 801d3c8:	ed84 6a02 	vstr	s12, [r4, #8]
 801d3cc:	edc4 6a03 	vstr	s13, [r4, #12]
 801d3d0:	ed84 7a04 	vstr	s14, [r4, #16]
 801d3d4:	edc4 7a05 	vstr	s15, [r4, #20]
                if (firstADCPass)
 801d3d8:	b142      	cbz	r2, 801d3ec <adcCheck+0x9c>
 801d3da:	4d52      	ldr	r5, [pc, #328]	; (801d524 <adcCheck+0x1d4>)
                    firstADCPass = 0;
 801d3dc:	2700      	movs	r7, #0
 801d3de:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801d3e0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801d3e2:	e894 0003 	ldmia.w	r4, {r0, r1}
 801d3e6:	6037      	str	r7, [r6, #0]
 801d3e8:	e885 0003 	stmia.w	r5, {r0, r1}
 801d3ec:	4d4c      	ldr	r5, [pc, #304]	; (801d520 <adcCheck+0x1d0>)
            {
 801d3ee:	f04f 0b00 	mov.w	fp, #0
 801d3f2:	4e4c      	ldr	r6, [pc, #304]	; (801d524 <adcCheck+0x1d4>)
 801d3f4:	4c4c      	ldr	r4, [pc, #304]	; (801d528 <adcCheck+0x1d8>)
 801d3f6:	4f4d      	ldr	r7, [pc, #308]	; (801d52c <adcCheck+0x1dc>)
 801d3f8:	f8df 814c 	ldr.w	r8, [pc, #332]	; 801d548 <adcCheck+0x1f8>
 801d3fc:	f8df 914c 	ldr.w	r9, [pc, #332]	; 801d54c <adcCheck+0x1fc>
 801d400:	e033      	b.n	801d46a <adcCheck+0x11a>
                        if (buttonActionsUI[ButtonEdit][ActionHoldContinuous])
 801d402:	4a4b      	ldr	r2, [pc, #300]	; (801d530 <adcCheck+0x1e0>)
 801d404:	78d3      	ldrb	r3, [r2, #3]
 801d406:	b16b      	cbz	r3, 801d424 <adcCheck+0xd4>
                            if (i != 5) cvAddParam[currentPreset] = i + (knobPage * KNOB_PAGE_SIZE);;
 801d408:	f1bb 0f05 	cmp.w	fp, #5
 801d40c:	d008      	beq.n	801d420 <adcCheck+0xd0>
 801d40e:	4b49      	ldr	r3, [pc, #292]	; (801d534 <adcCheck+0x1e4>)
 801d410:	4949      	ldr	r1, [pc, #292]	; (801d538 <adcCheck+0x1e8>)
 801d412:	781b      	ldrb	r3, [r3, #0]
 801d414:	7809      	ldrb	r1, [r1, #0]
 801d416:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801d41a:	4848      	ldr	r0, [pc, #288]	; (801d53c <adcCheck+0x1ec>)
 801d41c:	445b      	add	r3, fp
 801d41e:	5443      	strb	r3, [r0, r1]
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
 801d420:	2300      	movs	r3, #0
 801d422:	70d3      	strb	r3, [r2, #3]
                        lastFloatADC[i] = floatADC[i];
 801d424:	ed15 0a01 	vldr	s0, [r5, #-4]
                        if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 801d428:	f1bb 0f05 	cmp.w	fp, #5
                        lastFloatADC[i] = floatADC[i];
 801d42c:	ed06 0a01 	vstr	s0, [r6, #-4]
                        if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 801d430:	d063      	beq.n	801d4fa <adcCheck+0x1aa>
                        else writeKnobFlag = i;
 801d432:	fa4f f38b 	sxtb.w	r3, fp
                    if (floatADCUI[i] >= 0.0f)
 801d436:	edd4 7a00 	vldr	s15, [r4]
                        knobActive[i] = 1;
 801d43a:	2201      	movs	r2, #1
 801d43c:	4940      	ldr	r1, [pc, #256]	; (801d540 <adcCheck+0x1f0>)
 801d43e:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
                    if (floatADCUI[i] >= 0.0f)
 801d442:	eef5 7ac0 	vcmpe.f32	s15, #0.0
                        knobActive[i] = 1;
 801d446:	f849 202b 	str.w	r2, [r9, fp, lsl #2]
 801d44a:	700b      	strb	r3, [r1, #0]
                    if (floatADCUI[i] >= 0.0f)
 801d44c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d450:	da2a      	bge.n	801d4a8 <adcCheck+0x158>
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 801d452:	4b3c      	ldr	r3, [pc, #240]	; (801d544 <adcCheck+0x1f4>)
 801d454:	eb03 000a 	add.w	r0, r3, sl
 801d458:	f005 f892 	bl	8022580 <tExpSmooth_setDest>
                for (int i = 0; i < 6; i++)
 801d45c:	f10b 0b01 	add.w	fp, fp, #1
 801d460:	3404      	adds	r4, #4
 801d462:	3704      	adds	r7, #4
 801d464:	f1bb 0f06 	cmp.w	fp, #6
 801d468:	d045      	beq.n	801d4f6 <adcCheck+0x1a6>
                    if (fastabsf(floatADC[i] - lastFloatADC[i]) > adcHysteresisThreshold)
 801d46a:	ecf6 7a01 	vldmia	r6!, {s15}
 801d46e:	ecb5 0a01 	vldmia	r5!, {s0}
 801d472:	ee30 0a67 	vsub.f32	s0, s0, s15
 801d476:	f006 fc43 	bl	8023d00 <fastabsf>
 801d47a:	edd8 7a00 	vldr	s15, [r8]
 801d47e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801d482:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d486:	dcbc      	bgt.n	801d402 <adcCheck+0xb2>
                    if (floatADCUI[i] >= 0.0f)
 801d488:	edd4 7a00 	vldr	s15, [r4]
 801d48c:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
 801d490:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801d494:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d498:	da06      	bge.n	801d4a8 <adcCheck+0x158>
 801d49a:	f859 302b 	ldr.w	r3, [r9, fp, lsl #2]
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 801d49e:	2b00      	cmp	r3, #0
 801d4a0:	d0dc      	beq.n	801d45c <adcCheck+0x10c>
 801d4a2:	ed15 0a01 	vldr	s0, [r5, #-4]
 801d4a6:	e7d4      	b.n	801d452 <adcCheck+0x102>
                        if (fastabsf(smoothedADC[i] - floatADCUI[i]) > adcHysteresisThreshold)
 801d4a8:	ed97 0a00 	vldr	s0, [r7]
 801d4ac:	ee30 0a67 	vsub.f32	s0, s0, s15
 801d4b0:	f006 fc26 	bl	8023d00 <fastabsf>
 801d4b4:	edd8 7a00 	vldr	s15, [r8]
 801d4b8:	f859 300a 	ldr.w	r3, [r9, sl]
 801d4bc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801d4c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d4c4:	ddeb      	ble.n	801d49e <adcCheck+0x14e>
                            if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 801d4c6:	f1bb 0f05 	cmp.w	fp, #5
 801d4ca:	d005      	beq.n	801d4d8 <adcCheck+0x188>
                            else writeKnobFlag = i;
 801d4cc:	4a1c      	ldr	r2, [pc, #112]	; (801d540 <adcCheck+0x1f0>)
 801d4ce:	f882 b000 	strb.w	fp, [r2]
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 801d4d2:	2b00      	cmp	r3, #0
 801d4d4:	d0c2      	beq.n	801d45c <adcCheck+0x10c>
 801d4d6:	e7e4      	b.n	801d4a2 <adcCheck+0x152>
                            if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 801d4d8:	4a16      	ldr	r2, [pc, #88]	; (801d534 <adcCheck+0x1e4>)
 801d4da:	4917      	ldr	r1, [pc, #92]	; (801d538 <adcCheck+0x1e8>)
 801d4dc:	7812      	ldrb	r2, [r2, #0]
 801d4de:	7809      	ldrb	r1, [r1, #0]
 801d4e0:	ebc2 1c82 	rsb	ip, r2, r2, lsl #6
 801d4e4:	4815      	ldr	r0, [pc, #84]	; (801d53c <adcCheck+0x1ec>)
 801d4e6:	ebc2 028c 	rsb	r2, r2, ip, lsl #2
 801d4ea:	5c41      	ldrb	r1, [r0, r1]
 801d4ec:	440a      	add	r2, r1
 801d4ee:	4914      	ldr	r1, [pc, #80]	; (801d540 <adcCheck+0x1f0>)
 801d4f0:	700a      	strb	r2, [r1, #0]
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 801d4f2:	2b00      	cmp	r3, #0
 801d4f4:	d1d5      	bne.n	801d4a2 <adcCheck+0x152>
            }
 801d4f6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 801d4fa:	4a0e      	ldr	r2, [pc, #56]	; (801d534 <adcCheck+0x1e4>)
 801d4fc:	4b0e      	ldr	r3, [pc, #56]	; (801d538 <adcCheck+0x1e8>)
 801d4fe:	7812      	ldrb	r2, [r2, #0]
 801d500:	781b      	ldrb	r3, [r3, #0]
 801d502:	ebc2 1182 	rsb	r1, r2, r2, lsl #6
 801d506:	480d      	ldr	r0, [pc, #52]	; (801d53c <adcCheck+0x1ec>)
 801d508:	ebc2 0281 	rsb	r2, r2, r1, lsl #2
 801d50c:	5cc3      	ldrb	r3, [r0, r3]
 801d50e:	4413      	add	r3, r2
 801d510:	b25b      	sxtb	r3, r3
 801d512:	e790      	b.n	801d436 <adcCheck+0xe6>
 801d514:	30001080 	.word	0x30001080
 801d518:	3a800000 	.word	0x3a800000
 801d51c:	200002d4 	.word	0x200002d4
 801d520:	20018714 	.word	0x20018714
 801d524:	20018994 	.word	0x20018994
 801d528:	20018884 	.word	0x20018884
 801d52c:	2001886c 	.word	0x2001886c
 801d530:	2001889c 	.word	0x2001889c
 801d534:	2000066a 	.word	0x2000066a
 801d538:	20000669 	.word	0x20000669
 801d53c:	20018980 	.word	0x20018980
 801d540:	200002db 	.word	0x200002db
 801d544:	20018840 	.word	0x20018840
 801d548:	200002c4 	.word	0x200002c4
 801d54c:	20017950 	.word	0x20017950

0801d550 <resetKnobValues>:
            {
 801d550:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
                    floatADCUI[i] = -1.0f;
 801d554:	4820      	ldr	r0, [pc, #128]	; (801d5d8 <resetKnobValues+0x88>)
                    knobActive[i] = 0;
 801d556:	2600      	movs	r6, #0
 801d558:	f8df 909c 	ldr.w	r9, [pc, #156]	; 801d5f8 <resetKnobValues+0xa8>
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 801d55c:	f04f 0a05 	mov.w	sl, #5
                for (int i = 0; i < NUM_ADC_CHANNELS; i++)
 801d560:	4634      	mov	r4, r6
                    floatADCUI[i] = -1.0f;
 801d562:	f8df b098 	ldr.w	fp, [pc, #152]	; 801d5fc <resetKnobValues+0xac>
                    knobActive[i] = 0;
 801d566:	f849 6b04 	str.w	r6, [r9], #4
 801d56a:	f8df 8088 	ldr.w	r8, [pc, #136]	; 801d5f4 <resetKnobValues+0xa4>
 801d56e:	4d1b      	ldr	r5, [pc, #108]	; (801d5dc <resetKnobValues+0x8c>)
 801d570:	4f1b      	ldr	r7, [pc, #108]	; (801d5e0 <resetKnobValues+0x90>)
 801d572:	4e1c      	ldr	r6, [pc, #112]	; (801d5e4 <resetKnobValues+0x94>)
                    floatADCUI[i] = -1.0f;
 801d574:	f84b 0b04 	str.w	r0, [fp], #4
            {
 801d578:	ed2d 8b02 	vpush	{d8}
                    floatADCUI[i] = -1.0f;
 801d57c:	ee08 0a90 	vmov	s17, r0
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 801d580:	783b      	ldrb	r3, [r7, #0]
                    tExpSmooth_setValAndDest(&adc[i], value);
 801d582:	4628      	mov	r0, r5
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 801d584:	7832      	ldrb	r2, [r6, #0]
 801d586:	3504      	adds	r5, #4
 801d588:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801d58c:	fb1a 4202 	smlabb	r2, sl, r2, r4
                for (int i = 0; i < NUM_ADC_CHANNELS; i++)
 801d590:	3401      	adds	r4, #1
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 801d592:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801d596:	4413      	add	r3, r2
 801d598:	4a13      	ldr	r2, [pc, #76]	; (801d5e8 <resetKnobValues+0x98>)
 801d59a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801d59e:	ed93 8a00 	vldr	s16, [r3]
                    tExpSmooth_setValAndDest(&adc[i], value);
 801d5a2:	eeb0 0a48 	vmov.f32	s0, s16
 801d5a6:	f004 ffef 	bl	8022588 <tExpSmooth_setValAndDest>
                    knobActive[i] = 0;
 801d5aa:	2300      	movs	r3, #0
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 801d5ac:	2c05      	cmp	r4, #5
                    smoothedADC[i] = value;
 801d5ae:	eca8 8a01 	vstmia	r8!, {s16}
                    knobActive[i] = 0;
 801d5b2:	f849 3b04 	str.w	r3, [r9], #4
                    floatADCUI[i] = -1.0f;
 801d5b6:	eceb 8a01 	vstmia	fp!, {s17}
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 801d5ba:	d1e1      	bne.n	801d580 <resetKnobValues+0x30>
                    tExpSmooth_setValAndDest(&adc[i], value);
 801d5bc:	ed9f 8a0b 	vldr	s16, [pc, #44]	; 801d5ec <resetKnobValues+0x9c>
 801d5c0:	480b      	ldr	r0, [pc, #44]	; (801d5f0 <resetKnobValues+0xa0>)
 801d5c2:	eeb0 0a48 	vmov.f32	s0, s16
 801d5c6:	f004 ffdf 	bl	8022588 <tExpSmooth_setValAndDest>
                    smoothedADC[i] = value;
 801d5ca:	4b0a      	ldr	r3, [pc, #40]	; (801d5f4 <resetKnobValues+0xa4>)
 801d5cc:	ed83 8a05 	vstr	s16, [r3, #20]
            }
 801d5d0:	ecbd 8b02 	vpop	{d8}
 801d5d4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d5d8:	bf800000 	.word	0xbf800000
 801d5dc:	20018840 	.word	0x20018840
 801d5e0:	20000669 	.word	0x20000669
 801d5e4:	2000066a 	.word	0x2000066a
 801d5e8:	20002cb8 	.word	0x20002cb8
 801d5ec:	00000000 	.word	0x00000000
 801d5f0:	20018854 	.word	0x20018854
 801d5f4:	2001886c 	.word	0x2001886c
 801d5f8:	20017950 	.word	0x20017950
 801d5fc:	20018884 	.word	0x20018884

0801d600 <UIVocoderButtons>:
            }

            const char* UIVocoderButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 801d600:	4b15      	ldr	r3, [pc, #84]	; (801d658 <UIVocoderButtons+0x58>)
            {
 801d602:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 801d604:	7d1a      	ldrb	r2, [r3, #20]
 801d606:	2a01      	cmp	r2, #1
 801d608:	d01b      	beq.n	801d642 <UIVocoderButtons+0x42>
                const char* writeString = "";
 801d60a:	4814      	ldr	r0, [pc, #80]	; (801d65c <UIVocoderButtons+0x5c>)
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 801d60c:	7e1a      	ldrb	r2, [r3, #24]
 801d60e:	2a01      	cmp	r2, #1
 801d610:	d108      	bne.n	801d624 <UIVocoderButtons+0x24>
                {
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 801d612:	4a13      	ldr	r2, [pc, #76]	; (801d660 <UIVocoderButtons+0x60>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801d614:	2400      	movs	r4, #0
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 801d616:	4813      	ldr	r0, [pc, #76]	; (801d664 <UIVocoderButtons+0x64>)
 801d618:	6811      	ldr	r1, [r2, #0]
 801d61a:	4a13      	ldr	r2, [pc, #76]	; (801d668 <UIVocoderButtons+0x68>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801d61c:	761c      	strb	r4, [r3, #24]
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 801d61e:	42a1      	cmp	r1, r4
 801d620:	bf08      	it	eq
 801d622:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 801d624:	7f1a      	ldrb	r2, [r3, #28]
 801d626:	2a01      	cmp	r2, #1
 801d628:	d108      	bne.n	801d63c <UIVocoderButtons+0x3c>
                {
                    writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
 801d62a:	4a10      	ldr	r2, [pc, #64]	; (801d66c <UIVocoderButtons+0x6c>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801d62c:	2400      	movs	r4, #0
                    writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
 801d62e:	4810      	ldr	r0, [pc, #64]	; (801d670 <UIVocoderButtons+0x70>)
 801d630:	6811      	ldr	r1, [r2, #0]
 801d632:	4a10      	ldr	r2, [pc, #64]	; (801d674 <UIVocoderButtons+0x74>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801d634:	771c      	strb	r4, [r3, #28]
                    writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
 801d636:	42a1      	cmp	r1, r4
 801d638:	bf08      	it	eq
 801d63a:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 801d63c:	f85d 4b04 	ldr.w	r4, [sp], #4
 801d640:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801d642:	4a0d      	ldr	r2, [pc, #52]	; (801d678 <UIVocoderButtons+0x78>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d644:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801d646:	480d      	ldr	r0, [pc, #52]	; (801d67c <UIVocoderButtons+0x7c>)
 801d648:	6811      	ldr	r1, [r2, #0]
 801d64a:	4a0d      	ldr	r2, [pc, #52]	; (801d680 <UIVocoderButtons+0x80>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d64c:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801d64e:	2901      	cmp	r1, #1
 801d650:	bfd8      	it	le
 801d652:	4610      	movle	r0, r2
 801d654:	e7da      	b.n	801d60c <UIVocoderButtons+0xc>
 801d656:	bf00      	nop
 801d658:	2001889c 	.word	0x2001889c
 801d65c:	0802b280 	.word	0x0802b280
 801d660:	200005ac 	.word	0x200005ac
 801d664:	0802b2b4 	.word	0x0802b2b4
 801d668:	0802b2c0 	.word	0x0802b2c0
 801d66c:	20000628 	.word	0x20000628
 801d670:	0802b2cc 	.word	0x0802b2cc
 801d674:	0802b2d4 	.word	0x0802b2d4
 801d678:	20000254 	.word	0x20000254
 801d67c:	0802b2a4 	.word	0x0802b2a4
 801d680:	0802b2ac 	.word	0x0802b2ac

0801d684 <UIVocoderChButtons>:

            const char* UIVocoderChButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 801d684:	4b15      	ldr	r3, [pc, #84]	; (801d6dc <UIVocoderChButtons+0x58>)
            {
 801d686:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 801d688:	7d1a      	ldrb	r2, [r3, #20]
 801d68a:	2a01      	cmp	r2, #1
 801d68c:	d01b      	beq.n	801d6c6 <UIVocoderChButtons+0x42>
                const char* writeString = "";
 801d68e:	4814      	ldr	r0, [pc, #80]	; (801d6e0 <UIVocoderChButtons+0x5c>)
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 801d690:	7e1a      	ldrb	r2, [r3, #24]
 801d692:	2a01      	cmp	r2, #1
 801d694:	d108      	bne.n	801d6a8 <UIVocoderChButtons+0x24>
                {
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 801d696:	4a13      	ldr	r2, [pc, #76]	; (801d6e4 <UIVocoderChButtons+0x60>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801d698:	2400      	movs	r4, #0
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 801d69a:	4813      	ldr	r0, [pc, #76]	; (801d6e8 <UIVocoderChButtons+0x64>)
 801d69c:	6811      	ldr	r1, [r2, #0]
 801d69e:	4a13      	ldr	r2, [pc, #76]	; (801d6ec <UIVocoderChButtons+0x68>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801d6a0:	761c      	strb	r4, [r3, #24]
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 801d6a2:	42a1      	cmp	r1, r4
 801d6a4:	bf08      	it	eq
 801d6a6:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 801d6a8:	7f1a      	ldrb	r2, [r3, #28]
 801d6aa:	2a01      	cmp	r2, #1
 801d6ac:	d108      	bne.n	801d6c0 <UIVocoderChButtons+0x3c>
                {
                    writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
 801d6ae:	4a10      	ldr	r2, [pc, #64]	; (801d6f0 <UIVocoderChButtons+0x6c>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801d6b0:	2400      	movs	r4, #0
                    writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
 801d6b2:	4810      	ldr	r0, [pc, #64]	; (801d6f4 <UIVocoderChButtons+0x70>)
 801d6b4:	6811      	ldr	r1, [r2, #0]
 801d6b6:	4a10      	ldr	r2, [pc, #64]	; (801d6f8 <UIVocoderChButtons+0x74>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801d6b8:	771c      	strb	r4, [r3, #28]
                    writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
 801d6ba:	42a1      	cmp	r1, r4
 801d6bc:	bf08      	it	eq
 801d6be:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 801d6c0:	f85d 4b04 	ldr.w	r4, [sp], #4
 801d6c4:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801d6c6:	4a0d      	ldr	r2, [pc, #52]	; (801d6fc <UIVocoderChButtons+0x78>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d6c8:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801d6ca:	480d      	ldr	r0, [pc, #52]	; (801d700 <UIVocoderChButtons+0x7c>)
 801d6cc:	6811      	ldr	r1, [r2, #0]
 801d6ce:	4a0d      	ldr	r2, [pc, #52]	; (801d704 <UIVocoderChButtons+0x80>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d6d0:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801d6d2:	2901      	cmp	r1, #1
 801d6d4:	bfd8      	it	le
 801d6d6:	4610      	movle	r0, r2
 801d6d8:	e7da      	b.n	801d690 <UIVocoderChButtons+0xc>
 801d6da:	bf00      	nop
 801d6dc:	2001889c 	.word	0x2001889c
 801d6e0:	0802b280 	.word	0x0802b280
 801d6e4:	200005ac 	.word	0x200005ac
 801d6e8:	0802b2b4 	.word	0x0802b2b4
 801d6ec:	0802b2c0 	.word	0x0802b2c0
 801d6f0:	20000624 	.word	0x20000624
 801d6f4:	0802b2cc 	.word	0x0802b2cc
 801d6f8:	0802b2d4 	.word	0x0802b2d4
 801d6fc:	20000254 	.word	0x20000254
 801d700:	0802b2a4 	.word	0x0802b2a4
 801d704:	0802b2ac 	.word	0x0802b2ac

0801d708 <UIPitchShiftButtons>:

            const char* UIPitchShiftButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                return writeString;
            }
 801d708:	4800      	ldr	r0, [pc, #0]	; (801d70c <UIPitchShiftButtons+0x4>)
 801d70a:	4770      	bx	lr
 801d70c:	0802b280 	.word	0x0802b280

0801d710 <UINeartuneButtons>:

            const char* UINeartuneButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
 801d710:	4b0e      	ldr	r3, [pc, #56]	; (801d74c <UINeartuneButtons+0x3c>)
            {
 801d712:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress])
 801d714:	7d1a      	ldrb	r2, [r3, #20]
 801d716:	b1b2      	cbz	r2, 801d746 <UINeartuneButtons+0x36>
                {
                    writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
 801d718:	4a0d      	ldr	r2, [pc, #52]	; (801d750 <UINeartuneButtons+0x40>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d71a:	2400      	movs	r4, #0
                    writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
 801d71c:	480d      	ldr	r0, [pc, #52]	; (801d754 <UINeartuneButtons+0x44>)
 801d71e:	6811      	ldr	r1, [r2, #0]
 801d720:	4a0d      	ldr	r2, [pc, #52]	; (801d758 <UINeartuneButtons+0x48>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d722:	751c      	strb	r4, [r3, #20]
                    writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
 801d724:	42a1      	cmp	r1, r4
 801d726:	bf08      	it	eq
 801d728:	4610      	moveq	r0, r2
                }

                if (buttonActionsUI[ButtonC][ActionPress])
 801d72a:	7f1a      	ldrb	r2, [r3, #28]
 801d72c:	b142      	cbz	r2, 801d740 <UINeartuneButtons+0x30>
                {
                    writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
 801d72e:	4a0b      	ldr	r2, [pc, #44]	; (801d75c <UINeartuneButtons+0x4c>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801d730:	2400      	movs	r4, #0
                    writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
 801d732:	480b      	ldr	r0, [pc, #44]	; (801d760 <UINeartuneButtons+0x50>)
 801d734:	6811      	ldr	r1, [r2, #0]
 801d736:	4a0b      	ldr	r2, [pc, #44]	; (801d764 <UINeartuneButtons+0x54>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801d738:	771c      	strb	r4, [r3, #28]
                    writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
 801d73a:	42a1      	cmp	r1, r4
 801d73c:	bf08      	it	eq
 801d73e:	4610      	moveq	r0, r2
                }


                return writeString;
            }
 801d740:	f85d 4b04 	ldr.w	r4, [sp], #4
 801d744:	4770      	bx	lr
                const char* writeString = "";
 801d746:	4808      	ldr	r0, [pc, #32]	; (801d768 <UINeartuneButtons+0x58>)
 801d748:	e7ef      	b.n	801d72a <UINeartuneButtons+0x1a>
 801d74a:	bf00      	nop
 801d74c:	2001889c 	.word	0x2001889c
 801d750:	2000052c 	.word	0x2000052c
 801d754:	0802b1a8 	.word	0x0802b1a8
 801d758:	0802b1b8 	.word	0x0802b1b8
 801d75c:	20000530 	.word	0x20000530
 801d760:	0802b1c8 	.word	0x0802b1c8
 801d764:	0802b1d8 	.word	0x0802b1d8
 801d768:	0802b280 	.word	0x0802b280

0801d76c <UIAutotuneButtons>:
 801d76c:	4800      	ldr	r0, [pc, #0]	; (801d770 <UIAutotuneButtons+0x4>)
 801d76e:	4770      	bx	lr
 801d770:	0802b280 	.word	0x0802b280

0801d774 <UISamplerBPButtons>:
                const char* writeString = "";
                return writeString;
            }

            const char* UISamplerBPButtons(VocodecButton button, ButtonAction action)
            {
 801d774:	b570      	push	{r4, r5, r6, lr}
                const char* writeString = "";
                if (buttonActionsUI[ButtonC][ActionPress])
 801d776:	4c31      	ldr	r4, [pc, #196]	; (801d83c <UISamplerBPButtons+0xc8>)
 801d778:	7f23      	ldrb	r3, [r4, #28]
 801d77a:	2b00      	cmp	r3, #0
 801d77c:	d144      	bne.n	801d808 <UISamplerBPButtons+0x94>
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
                    buttonActionsUI[ButtonC][ActionPress] = 0;
                }

                if (buttonActionsUI[ButtonB][ActionPress])
 801d77e:	7e23      	ldrb	r3, [r4, #24]
 801d780:	bb83      	cbnz	r3, 801d7e4 <UISamplerBPButtons+0x70>
                {
                    OLEDclearLine(SecondLine);
                    OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
                    buttonActionsUI[ButtonB][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonA][ActionHoldContinuous])
 801d782:	7de3      	ldrb	r3, [r4, #23]
 801d784:	b9db      	cbnz	r3, 801d7be <UISamplerBPButtons+0x4a>
                    OLEDclearLine(SecondLine);
                    OLEDwriteString("RECORDING", 9, 0, SecondLine);
                    OLEDwriteFloat(sampleLength, 84, SecondLine);
                    buttonActionsUI[ButtonA][ActionHoldContinuous] = 0;
                }
                if (buttonActionsUI[ButtonA][ActionRelease])
 801d786:	7d63      	ldrb	r3, [r4, #21]
 801d788:	b1bb      	cbz	r3, 801d7ba <UISamplerBPButtons+0x46>
                {
                    OLEDclearLine(SecondLine);
 801d78a:	2001      	movs	r0, #1
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
 801d78c:	4d2c      	ldr	r5, [pc, #176]	; (801d840 <UISamplerBPButtons+0xcc>)
                    OLEDclearLine(SecondLine);
 801d78e:	f7f6 fb0b 	bl	8013da8 <OLEDclearLine>
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
 801d792:	4b2c      	ldr	r3, [pc, #176]	; (801d844 <UISamplerBPButtons+0xd0>)
 801d794:	2101      	movs	r1, #1
 801d796:	2000      	movs	r0, #0
 801d798:	ed93 0a00 	vldr	s0, [r3]
 801d79c:	f7f6 fbdc 	bl	8013f58 <OLEDwriteFloat>
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
 801d7a0:	4a29      	ldr	r2, [pc, #164]	; (801d848 <UISamplerBPButtons+0xd4>)
 801d7a2:	482a      	ldr	r0, [pc, #168]	; (801d84c <UISamplerBPButtons+0xd8>)
 801d7a4:	2301      	movs	r3, #1
 801d7a6:	6816      	ldr	r6, [r2, #0]
 801d7a8:	2107      	movs	r1, #7
 801d7aa:	2230      	movs	r2, #48	; 0x30
 801d7ac:	2e00      	cmp	r6, #0
 801d7ae:	bf08      	it	eq
 801d7b0:	4628      	moveq	r0, r5
 801d7b2:	f7f6 fb0d 	bl	8013dd0 <OLEDwriteString>
                    buttonActionsUI[ButtonA][ActionRelease] = 0;
 801d7b6:	2300      	movs	r3, #0
 801d7b8:	7563      	strb	r3, [r4, #21]
                }
                return writeString;
            }
 801d7ba:	4825      	ldr	r0, [pc, #148]	; (801d850 <UISamplerBPButtons+0xdc>)
 801d7bc:	bd70      	pop	{r4, r5, r6, pc}
                    OLEDclearLine(SecondLine);
 801d7be:	2001      	movs	r0, #1
 801d7c0:	f7f6 faf2 	bl	8013da8 <OLEDclearLine>
                    OLEDwriteString("RECORDING", 9, 0, SecondLine);
 801d7c4:	2301      	movs	r3, #1
 801d7c6:	2200      	movs	r2, #0
 801d7c8:	2109      	movs	r1, #9
 801d7ca:	4822      	ldr	r0, [pc, #136]	; (801d854 <UISamplerBPButtons+0xe0>)
 801d7cc:	f7f6 fb00 	bl	8013dd0 <OLEDwriteString>
                    OLEDwriteFloat(sampleLength, 84, SecondLine);
 801d7d0:	4b1c      	ldr	r3, [pc, #112]	; (801d844 <UISamplerBPButtons+0xd0>)
 801d7d2:	2101      	movs	r1, #1
 801d7d4:	2054      	movs	r0, #84	; 0x54
 801d7d6:	ed93 0a00 	vldr	s0, [r3]
 801d7da:	f7f6 fbbd 	bl	8013f58 <OLEDwriteFloat>
                    buttonActionsUI[ButtonA][ActionHoldContinuous] = 0;
 801d7de:	2300      	movs	r3, #0
 801d7e0:	75e3      	strb	r3, [r4, #23]
 801d7e2:	e7d0      	b.n	801d786 <UISamplerBPButtons+0x12>
                    OLEDclearLine(SecondLine);
 801d7e4:	2001      	movs	r0, #1
                    OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
 801d7e6:	4d1c      	ldr	r5, [pc, #112]	; (801d858 <UISamplerBPButtons+0xe4>)
                    OLEDclearLine(SecondLine);
 801d7e8:	f7f6 fade 	bl	8013da8 <OLEDclearLine>
                    OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
 801d7ec:	4a1b      	ldr	r2, [pc, #108]	; (801d85c <UISamplerBPButtons+0xe8>)
 801d7ee:	481c      	ldr	r0, [pc, #112]	; (801d860 <UISamplerBPButtons+0xec>)
 801d7f0:	2301      	movs	r3, #1
 801d7f2:	6816      	ldr	r6, [r2, #0]
 801d7f4:	2200      	movs	r2, #0
 801d7f6:	210c      	movs	r1, #12
 801d7f8:	4296      	cmp	r6, r2
 801d7fa:	bf08      	it	eq
 801d7fc:	4628      	moveq	r0, r5
 801d7fe:	f7f6 fae7 	bl	8013dd0 <OLEDwriteString>
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801d802:	2300      	movs	r3, #0
 801d804:	7623      	strb	r3, [r4, #24]
 801d806:	e7bc      	b.n	801d782 <UISamplerBPButtons+0xe>
                    OLEDclearLine(SecondLine);
 801d808:	2001      	movs	r0, #1
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
 801d80a:	4d0d      	ldr	r5, [pc, #52]	; (801d840 <UISamplerBPButtons+0xcc>)
                    OLEDclearLine(SecondLine);
 801d80c:	f7f6 facc 	bl	8013da8 <OLEDclearLine>
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
 801d810:	4b0c      	ldr	r3, [pc, #48]	; (801d844 <UISamplerBPButtons+0xd0>)
 801d812:	2101      	movs	r1, #1
 801d814:	2000      	movs	r0, #0
 801d816:	ed93 0a00 	vldr	s0, [r3]
 801d81a:	f7f6 fb9d 	bl	8013f58 <OLEDwriteFloat>
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
 801d81e:	4a0a      	ldr	r2, [pc, #40]	; (801d848 <UISamplerBPButtons+0xd4>)
 801d820:	480a      	ldr	r0, [pc, #40]	; (801d84c <UISamplerBPButtons+0xd8>)
 801d822:	2301      	movs	r3, #1
 801d824:	6816      	ldr	r6, [r2, #0]
 801d826:	2107      	movs	r1, #7
 801d828:	2230      	movs	r2, #48	; 0x30
 801d82a:	2e00      	cmp	r6, #0
 801d82c:	bf08      	it	eq
 801d82e:	4628      	moveq	r0, r5
 801d830:	f7f6 face 	bl	8013dd0 <OLEDwriteString>
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801d834:	2300      	movs	r3, #0
 801d836:	7723      	strb	r3, [r4, #28]
 801d838:	e7a1      	b.n	801d77e <UISamplerBPButtons+0xa>
 801d83a:	bf00      	nop
 801d83c:	2001889c 	.word	0x2001889c
 801d840:	0802b25c 	.word	0x0802b25c
 801d844:	2000060c 	.word	0x2000060c
 801d848:	200002ac 	.word	0x200002ac
 801d84c:	0802b254 	.word	0x0802b254
 801d850:	0802b280 	.word	0x0802b280
 801d854:	0802b284 	.word	0x0802b284
 801d858:	0802b274 	.word	0x0802b274
 801d85c:	20000534 	.word	0x20000534
 801d860:	0802b264 	.word	0x0802b264

0801d864 <UISamplerKButtons>:

            const char* UISamplerKButtons(VocodecButton button, ButtonAction action)
            {
 801d864:	b510      	push	{r4, lr}
                const char* writeString = "";


                if (buttonActionsUI[ExtraMessage][ActionHoldContinuous] || buttonActionsUI[ButtonA][ActionPress])
 801d866:	4c1d      	ldr	r4, [pc, #116]	; (801d8dc <UISamplerKButtons+0x78>)
 801d868:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
            {
 801d86c:	ed2d 8b02 	vpush	{d8}
                if (buttonActionsUI[ExtraMessage][ActionHoldContinuous] || buttonActionsUI[ButtonA][ActionPress])
 801d870:	b97b      	cbnz	r3, 801d892 <UISamplerKButtons+0x2e>
 801d872:	7d23      	ldrb	r3, [r4, #20]
 801d874:	b96b      	cbnz	r3, 801d892 <UISamplerKButtons+0x2e>
                    OLEDwriteFloat(sampleLength, OLEDgetCursor(), SecondLine);
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 0;
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }

                if (buttonActionsUI[ButtonB][ActionPress])
 801d876:	7e23      	ldrb	r3, [r4, #24]
 801d878:	b35b      	cbz	r3, 801d8d2 <UISamplerKButtons+0x6e>
                {
                    writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
 801d87a:	4b19      	ldr	r3, [pc, #100]	; (801d8e0 <UISamplerKButtons+0x7c>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801d87c:	2100      	movs	r1, #0
                    writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
 801d87e:	4819      	ldr	r0, [pc, #100]	; (801d8e4 <UISamplerKButtons+0x80>)
 801d880:	681a      	ldr	r2, [r3, #0]
 801d882:	4b19      	ldr	r3, [pc, #100]	; (801d8e8 <UISamplerKButtons+0x84>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801d884:	7621      	strb	r1, [r4, #24]
                    writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
 801d886:	428a      	cmp	r2, r1
 801d888:	bf08      	it	eq
 801d88a:	4618      	moveq	r0, r3
                }
                return writeString;
            }
 801d88c:	ecbd 8b02 	vpop	{d8}
 801d890:	bd10      	pop	{r4, pc}
                    OLEDclearLine(SecondLine);
 801d892:	2001      	movs	r0, #1
 801d894:	f7f6 fa88 	bl	8013da8 <OLEDclearLine>
                    OLEDwritePitch(currentSamplerKeyGlobal + LOWEST_SAMPLER_KEY, 0, SecondLine, false);
 801d898:	4b14      	ldr	r3, [pc, #80]	; (801d8ec <UISamplerKButtons+0x88>)
 801d89a:	2200      	movs	r2, #0
 801d89c:	2101      	movs	r1, #1
 801d89e:	681b      	ldr	r3, [r3, #0]
 801d8a0:	4610      	mov	r0, r2
 801d8a2:	3324      	adds	r3, #36	; 0x24
 801d8a4:	ee00 3a10 	vmov	s0, r3
 801d8a8:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 801d8ac:	f7f6 faf0 	bl	8013e90 <OLEDwritePitch>
                    OLEDwriteFloat(sampleLength, OLEDgetCursor(), SecondLine);
 801d8b0:	4b0f      	ldr	r3, [pc, #60]	; (801d8f0 <UISamplerKButtons+0x8c>)
 801d8b2:	ed93 8a00 	vldr	s16, [r3]
 801d8b6:	f7f6 fd09 	bl	80142cc <OLEDgetCursor>
 801d8ba:	2101      	movs	r1, #1
 801d8bc:	eeb0 0a48 	vmov.f32	s0, s16
 801d8c0:	f7f6 fb4a 	bl	8013f58 <OLEDwriteFloat>
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 0;
 801d8c4:	2300      	movs	r3, #0
 801d8c6:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d8ca:	7523      	strb	r3, [r4, #20]
                if (buttonActionsUI[ButtonB][ActionPress])
 801d8cc:	7e23      	ldrb	r3, [r4, #24]
 801d8ce:	2b00      	cmp	r3, #0
 801d8d0:	d1d3      	bne.n	801d87a <UISamplerKButtons+0x16>
                const char* writeString = "";
 801d8d2:	4808      	ldr	r0, [pc, #32]	; (801d8f4 <UISamplerKButtons+0x90>)
            }
 801d8d4:	ecbd 8b02 	vpop	{d8}
 801d8d8:	bd10      	pop	{r4, pc}
 801d8da:	bf00      	nop
 801d8dc:	2001889c 	.word	0x2001889c
 801d8e0:	20000570 	.word	0x20000570
 801d8e4:	0802b290 	.word	0x0802b290
 801d8e8:	0802b298 	.word	0x0802b298
 801d8ec:	20000224 	.word	0x20000224
 801d8f0:	2000060c 	.word	0x2000060c
 801d8f4:	0802b280 	.word	0x0802b280

0801d8f8 <UISamplerAutoButtons>:

            const char* UISamplerAutoButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
 801d8f8:	4b15      	ldr	r3, [pc, #84]	; (801d950 <UISamplerAutoButtons+0x58>)
            {
 801d8fa:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress])
 801d8fc:	7d1a      	ldrb	r2, [r3, #20]
 801d8fe:	b15a      	cbz	r2, 801d918 <UISamplerAutoButtons+0x20>
                {
                    if (samplerMode == PlayLoop)
 801d900:	4a14      	ldr	r2, [pc, #80]	; (801d954 <UISamplerAutoButtons+0x5c>)
 801d902:	7812      	ldrb	r2, [r2, #0]
 801d904:	2a01      	cmp	r2, #1
 801d906:	d021      	beq.n	801d94c <UISamplerAutoButtons+0x54>
                    {
                        writeString = "LOOP";
                    }
                    else if (samplerMode == PlayBackAndForth)
                    {
                        writeString = "BACK'N'FORTH";
 801d908:	4813      	ldr	r0, [pc, #76]	; (801d958 <UISamplerAutoButtons+0x60>)
 801d90a:	4914      	ldr	r1, [pc, #80]	; (801d95c <UISamplerAutoButtons+0x64>)
 801d90c:	2a02      	cmp	r2, #2
 801d90e:	bf08      	it	eq
 801d910:	4608      	moveq	r0, r1
                    }
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d912:	2200      	movs	r2, #0
 801d914:	751a      	strb	r2, [r3, #20]
 801d916:	e000      	b.n	801d91a <UISamplerAutoButtons+0x22>
                const char* writeString = "";
 801d918:	480f      	ldr	r0, [pc, #60]	; (801d958 <UISamplerAutoButtons+0x60>)
                }
                if (buttonActionsUI[ButtonB][ActionPress])
 801d91a:	7e1a      	ldrb	r2, [r3, #24]
 801d91c:	b142      	cbz	r2, 801d930 <UISamplerAutoButtons+0x38>
                {
                    writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
 801d91e:	4a10      	ldr	r2, [pc, #64]	; (801d960 <UISamplerAutoButtons+0x68>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801d920:	2400      	movs	r4, #0
                    writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
 801d922:	4810      	ldr	r0, [pc, #64]	; (801d964 <UISamplerAutoButtons+0x6c>)
 801d924:	6811      	ldr	r1, [r2, #0]
 801d926:	4a10      	ldr	r2, [pc, #64]	; (801d968 <UISamplerAutoButtons+0x70>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801d928:	761c      	strb	r4, [r3, #24]
                    writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
 801d92a:	42a1      	cmp	r1, r4
 801d92c:	bf08      	it	eq
 801d92e:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress])
 801d930:	7f1a      	ldrb	r2, [r3, #28]
 801d932:	b142      	cbz	r2, 801d946 <UISamplerAutoButtons+0x4e>
                {
                    writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
 801d934:	4a0d      	ldr	r2, [pc, #52]	; (801d96c <UISamplerAutoButtons+0x74>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801d936:	2400      	movs	r4, #0
                    writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
 801d938:	480d      	ldr	r0, [pc, #52]	; (801d970 <UISamplerAutoButtons+0x78>)
 801d93a:	6811      	ldr	r1, [r2, #0]
 801d93c:	4a0d      	ldr	r2, [pc, #52]	; (801d974 <UISamplerAutoButtons+0x7c>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801d93e:	771c      	strb	r4, [r3, #28]
                    writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
 801d940:	42a1      	cmp	r1, r4
 801d942:	bf08      	it	eq
 801d944:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 801d946:	f85d 4b04 	ldr.w	r4, [sp], #4
 801d94a:	4770      	bx	lr
                        writeString = "LOOP";
 801d94c:	480a      	ldr	r0, [pc, #40]	; (801d978 <UISamplerAutoButtons+0x80>)
 801d94e:	e7e0      	b.n	801d912 <UISamplerAutoButtons+0x1a>
 801d950:	2001889c 	.word	0x2001889c
 801d954:	200002b0 	.word	0x200002b0
 801d958:	0802b280 	.word	0x0802b280
 801d95c:	0802b214 	.word	0x0802b214
 801d960:	20000620 	.word	0x20000620
 801d964:	0802b224 	.word	0x0802b224
 801d968:	0802b230 	.word	0x0802b230
 801d96c:	200005ec 	.word	0x200005ec
 801d970:	0802b23c 	.word	0x0802b23c
 801d974:	0802b248 	.word	0x0802b248
 801d978:	0802b20c 	.word	0x0802b20c

0801d97c <UIDistortionButtons>:

            const char* UIDistortionButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
 801d97c:	4b08      	ldr	r3, [pc, #32]	; (801d9a0 <UIDistortionButtons+0x24>)
 801d97e:	7d1a      	ldrb	r2, [r3, #20]
 801d980:	b162      	cbz	r2, 801d99c <UIDistortionButtons+0x20>
                {
                    writeString = distortionMode ? "SHAPER" : "TANH";
 801d982:	4a08      	ldr	r2, [pc, #32]	; (801d9a4 <UIDistortionButtons+0x28>)
 801d984:	4808      	ldr	r0, [pc, #32]	; (801d9a8 <UIDistortionButtons+0x2c>)
            {
 801d986:	b410      	push	{r4}
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d988:	2400      	movs	r4, #0
                    writeString = distortionMode ? "SHAPER" : "TANH";
 801d98a:	6811      	ldr	r1, [r2, #0]
 801d98c:	4a07      	ldr	r2, [pc, #28]	; (801d9ac <UIDistortionButtons+0x30>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d98e:	751c      	strb	r4, [r3, #20]
                    writeString = distortionMode ? "SHAPER" : "TANH";
 801d990:	42a1      	cmp	r1, r4
 801d992:	bf08      	it	eq
 801d994:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 801d996:	f85d 4b04 	ldr.w	r4, [sp], #4
 801d99a:	4770      	bx	lr
                const char* writeString = "";
 801d99c:	4804      	ldr	r0, [pc, #16]	; (801d9b0 <UIDistortionButtons+0x34>)
            }
 801d99e:	4770      	bx	lr
 801d9a0:	2001889c 	.word	0x2001889c
 801d9a4:	2000058c 	.word	0x2000058c
 801d9a8:	0802b138 	.word	0x0802b138
 801d9ac:	0802b140 	.word	0x0802b140
 801d9b0:	0802b280 	.word	0x0802b280

0801d9b4 <UIWaveFolderButtons>:

            const char* UIWaveFolderButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
 801d9b4:	4b08      	ldr	r3, [pc, #32]	; (801d9d8 <UIWaveFolderButtons+0x24>)
 801d9b6:	7d1a      	ldrb	r2, [r3, #20]
 801d9b8:	b162      	cbz	r2, 801d9d4 <UIWaveFolderButtons+0x20>
                {
                    writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
 801d9ba:	4a08      	ldr	r2, [pc, #32]	; (801d9dc <UIWaveFolderButtons+0x28>)
 801d9bc:	4808      	ldr	r0, [pc, #32]	; (801d9e0 <UIWaveFolderButtons+0x2c>)
            {
 801d9be:	b410      	push	{r4}
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d9c0:	2400      	movs	r4, #0
                    writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
 801d9c2:	6811      	ldr	r1, [r2, #0]
 801d9c4:	4a07      	ldr	r2, [pc, #28]	; (801d9e4 <UIWaveFolderButtons+0x30>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d9c6:	751c      	strb	r4, [r3, #20]
                    writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
 801d9c8:	42a1      	cmp	r1, r4
 801d9ca:	bf08      	it	eq
 801d9cc:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 801d9ce:	f85d 4b04 	ldr.w	r4, [sp], #4
 801d9d2:	4770      	bx	lr
                const char* writeString = "";
 801d9d4:	4804      	ldr	r0, [pc, #16]	; (801d9e8 <UIWaveFolderButtons+0x34>)
            }
 801d9d6:	4770      	bx	lr
 801d9d8:	2001889c 	.word	0x2001889c
 801d9dc:	2000059c 	.word	0x2000059c
 801d9e0:	0802b2e0 	.word	0x0802b2e0
 801d9e4:	0802b2f0 	.word	0x0802b2f0
 801d9e8:	0802b280 	.word	0x0802b280

0801d9ec <UIBitcrusherButtons>:

            const char* UIBitcrusherButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";

                if (buttonActionsUI[ButtonA][ActionPress])
 801d9ec:	4b08      	ldr	r3, [pc, #32]	; (801da10 <UIBitcrusherButtons+0x24>)
 801d9ee:	7d1a      	ldrb	r2, [r3, #20]
 801d9f0:	b162      	cbz	r2, 801da0c <UIBitcrusherButtons+0x20>
                {
                    writeString = crusherStereo ? "STEREO" : "MONO";
 801d9f2:	4a08      	ldr	r2, [pc, #32]	; (801da14 <UIBitcrusherButtons+0x28>)
 801d9f4:	4808      	ldr	r0, [pc, #32]	; (801da18 <UIBitcrusherButtons+0x2c>)
            {
 801d9f6:	b410      	push	{r4}
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d9f8:	2400      	movs	r4, #0
                    writeString = crusherStereo ? "STEREO" : "MONO";
 801d9fa:	6811      	ldr	r1, [r2, #0]
 801d9fc:	4a07      	ldr	r2, [pc, #28]	; (801da1c <UIBitcrusherButtons+0x30>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801d9fe:	751c      	strb	r4, [r3, #20]
                    writeString = crusherStereo ? "STEREO" : "MONO";
 801da00:	42a1      	cmp	r1, r4
 801da02:	bf08      	it	eq
 801da04:	4610      	moveq	r0, r2
                }


                return writeString;
            }
 801da06:	f85d 4b04 	ldr.w	r4, [sp], #4
 801da0a:	4770      	bx	lr
                const char* writeString = "";
 801da0c:	4804      	ldr	r0, [pc, #16]	; (801da20 <UIBitcrusherButtons+0x34>)
            }
 801da0e:	4770      	bx	lr
 801da10:	2001889c 	.word	0x2001889c
 801da14:	20000578 	.word	0x20000578
 801da18:	0802b3b0 	.word	0x0802b3b0
 801da1c:	0802b2ac 	.word	0x0802b2ac
 801da20:	0802b280 	.word	0x0802b280

0801da24 <UIDelayButtons>:

            const char* UIDelayButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
 801da24:	4b0e      	ldr	r3, [pc, #56]	; (801da60 <UIDelayButtons+0x3c>)
            {
 801da26:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress])
 801da28:	7d1a      	ldrb	r2, [r3, #20]
 801da2a:	b1b2      	cbz	r2, 801da5a <UIDelayButtons+0x36>
                {
                    writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
 801da2c:	4a0d      	ldr	r2, [pc, #52]	; (801da64 <UIDelayButtons+0x40>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801da2e:	2400      	movs	r4, #0
                    writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
 801da30:	480d      	ldr	r0, [pc, #52]	; (801da68 <UIDelayButtons+0x44>)
 801da32:	6811      	ldr	r1, [r2, #0]
 801da34:	4a0d      	ldr	r2, [pc, #52]	; (801da6c <UIDelayButtons+0x48>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801da36:	751c      	strb	r4, [r3, #20]
                    writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
 801da38:	42a1      	cmp	r1, r4
 801da3a:	bf08      	it	eq
 801da3c:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonB][ActionPress])
 801da3e:	7e1a      	ldrb	r2, [r3, #24]
 801da40:	b142      	cbz	r2, 801da54 <UIDelayButtons+0x30>
                {
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 801da42:	4a0b      	ldr	r2, [pc, #44]	; (801da70 <UIDelayButtons+0x4c>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801da44:	2400      	movs	r4, #0
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 801da46:	480b      	ldr	r0, [pc, #44]	; (801da74 <UIDelayButtons+0x50>)
 801da48:	6811      	ldr	r1, [r2, #0]
 801da4a:	4a0b      	ldr	r2, [pc, #44]	; (801da78 <UIDelayButtons+0x54>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801da4c:	761c      	strb	r4, [r3, #24]
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 801da4e:	42a1      	cmp	r1, r4
 801da50:	bf08      	it	eq
 801da52:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 801da54:	f85d 4b04 	ldr.w	r4, [sp], #4
 801da58:	4770      	bx	lr
                const char* writeString = "";
 801da5a:	4808      	ldr	r0, [pc, #32]	; (801da7c <UIDelayButtons+0x58>)
 801da5c:	e7ef      	b.n	801da3e <UIDelayButtons+0x1a>
 801da5e:	bf00      	nop
 801da60:	2001889c 	.word	0x2001889c
 801da64:	20000588 	.word	0x20000588
 801da68:	0802b10c 	.word	0x0802b10c
 801da6c:	0802b118 	.word	0x0802b118
 801da70:	20000538 	.word	0x20000538
 801da74:	0802b124 	.word	0x0802b124
 801da78:	0802b12c 	.word	0x0802b12c
 801da7c:	0802b280 	.word	0x0802b280

0801da80 <UIReverbButtons>:

            const char* UIReverbButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonC][ActionPress])
 801da80:	4b0e      	ldr	r3, [pc, #56]	; (801dabc <UIReverbButtons+0x3c>)
            {
 801da82:	b410      	push	{r4}
                if (buttonActionsUI[ButtonC][ActionPress])
 801da84:	7f1a      	ldrb	r2, [r3, #28]
 801da86:	b1b2      	cbz	r2, 801dab6 <UIReverbButtons+0x36>
                {
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 801da88:	4a0d      	ldr	r2, [pc, #52]	; (801dac0 <UIReverbButtons+0x40>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801da8a:	2400      	movs	r4, #0
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 801da8c:	480d      	ldr	r0, [pc, #52]	; (801dac4 <UIReverbButtons+0x44>)
 801da8e:	6811      	ldr	r1, [r2, #0]
 801da90:	4a0d      	ldr	r2, [pc, #52]	; (801dac8 <UIReverbButtons+0x48>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801da92:	771c      	strb	r4, [r3, #28]
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 801da94:	42a1      	cmp	r1, r4
 801da96:	bf08      	it	eq
 801da98:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonB][ActionPress])
 801da9a:	7e1a      	ldrb	r2, [r3, #24]
 801da9c:	b142      	cbz	r2, 801dab0 <UIReverbButtons+0x30>
                {
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 801da9e:	4a0b      	ldr	r2, [pc, #44]	; (801dacc <UIReverbButtons+0x4c>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801daa0:	2400      	movs	r4, #0
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 801daa2:	480b      	ldr	r0, [pc, #44]	; (801dad0 <UIReverbButtons+0x50>)
 801daa4:	6811      	ldr	r1, [r2, #0]
 801daa6:	4a0b      	ldr	r2, [pc, #44]	; (801dad4 <UIReverbButtons+0x54>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801daa8:	761c      	strb	r4, [r3, #24]
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 801daaa:	42a1      	cmp	r1, r4
 801daac:	bf08      	it	eq
 801daae:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 801dab0:	f85d 4b04 	ldr.w	r4, [sp], #4
 801dab4:	4770      	bx	lr
                const char* writeString = "";
 801dab6:	4808      	ldr	r0, [pc, #32]	; (801dad8 <UIReverbButtons+0x58>)
 801dab8:	e7ef      	b.n	801da9a <UIReverbButtons+0x1a>
 801daba:	bf00      	nop
 801dabc:	2001889c 	.word	0x2001889c
 801dac0:	200005a0 	.word	0x200005a0
 801dac4:	0802b1e8 	.word	0x0802b1e8
 801dac8:	0802b1f0 	.word	0x0802b1f0
 801dacc:	20000538 	.word	0x20000538
 801dad0:	0802b124 	.word	0x0802b124
 801dad4:	0802b12c 	.word	0x0802b12c
 801dad8:	0802b280 	.word	0x0802b280

0801dadc <UIReverb2Buttons>:

            const char* UIReverb2Buttons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonC][ActionPress])
 801dadc:	4b08      	ldr	r3, [pc, #32]	; (801db00 <UIReverb2Buttons+0x24>)
 801dade:	7f1a      	ldrb	r2, [r3, #28]
 801dae0:	b162      	cbz	r2, 801dafc <UIReverb2Buttons+0x20>
                {
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 801dae2:	4a08      	ldr	r2, [pc, #32]	; (801db04 <UIReverb2Buttons+0x28>)
 801dae4:	4808      	ldr	r0, [pc, #32]	; (801db08 <UIReverb2Buttons+0x2c>)
            {
 801dae6:	b410      	push	{r4}
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801dae8:	2400      	movs	r4, #0
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 801daea:	6811      	ldr	r1, [r2, #0]
 801daec:	4a07      	ldr	r2, [pc, #28]	; (801db0c <UIReverb2Buttons+0x30>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801daee:	771c      	strb	r4, [r3, #28]
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 801daf0:	42a1      	cmp	r1, r4
 801daf2:	bf08      	it	eq
 801daf4:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 801daf6:	f85d 4b04 	ldr.w	r4, [sp], #4
 801dafa:	4770      	bx	lr
                const char* writeString = "";
 801dafc:	4804      	ldr	r0, [pc, #16]	; (801db10 <UIReverb2Buttons+0x34>)
            }
 801dafe:	4770      	bx	lr
 801db00:	2001889c 	.word	0x2001889c
 801db04:	200005a0 	.word	0x200005a0
 801db08:	0802b1e8 	.word	0x0802b1e8
 801db0c:	0802b1f0 	.word	0x0802b1f0
 801db10:	0802b280 	.word	0x0802b280

0801db14 <UILivingStringButtons>:

            const char* UILivingStringButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 801db14:	4b15      	ldr	r3, [pc, #84]	; (801db6c <UILivingStringButtons+0x58>)
            {
 801db16:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 801db18:	7d1a      	ldrb	r2, [r3, #20]
 801db1a:	2a01      	cmp	r2, #1
 801db1c:	d01b      	beq.n	801db56 <UILivingStringButtons+0x42>
                const char* writeString = "";
 801db1e:	4814      	ldr	r0, [pc, #80]	; (801db70 <UILivingStringButtons+0x5c>)
                {
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 801db20:	7f1a      	ldrb	r2, [r3, #28]
 801db22:	2a01      	cmp	r2, #1
 801db24:	d108      	bne.n	801db38 <UILivingStringButtons+0x24>
                {
                    writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
 801db26:	4a13      	ldr	r2, [pc, #76]	; (801db74 <UILivingStringButtons+0x60>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801db28:	2400      	movs	r4, #0
                    writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
 801db2a:	4813      	ldr	r0, [pc, #76]	; (801db78 <UILivingStringButtons+0x64>)
 801db2c:	6811      	ldr	r1, [r2, #0]
 801db2e:	4a13      	ldr	r2, [pc, #76]	; (801db7c <UILivingStringButtons+0x68>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801db30:	771c      	strb	r4, [r3, #28]
                    writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
 801db32:	42a1      	cmp	r1, r4
 801db34:	bfd8      	it	le
 801db36:	4610      	movle	r0, r2
                }

                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 801db38:	7e1a      	ldrb	r2, [r3, #24]
 801db3a:	2a01      	cmp	r2, #1
 801db3c:	d108      	bne.n	801db50 <UILivingStringButtons+0x3c>
                {
                    writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
 801db3e:	4a10      	ldr	r2, [pc, #64]	; (801db80 <UILivingStringButtons+0x6c>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801db40:	2400      	movs	r4, #0
                    writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
 801db42:	4810      	ldr	r0, [pc, #64]	; (801db84 <UILivingStringButtons+0x70>)
 801db44:	6811      	ldr	r1, [r2, #0]
 801db46:	4a10      	ldr	r2, [pc, #64]	; (801db88 <UILivingStringButtons+0x74>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801db48:	761c      	strb	r4, [r3, #24]
                    writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
 801db4a:	42a1      	cmp	r1, r4
 801db4c:	bfd8      	it	le
 801db4e:	4610      	movle	r0, r2
                }

                return writeString;
            }
 801db50:	f85d 4b04 	ldr.w	r4, [sp], #4
 801db54:	4770      	bx	lr
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
 801db56:	4a0d      	ldr	r2, [pc, #52]	; (801db8c <UILivingStringButtons+0x78>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801db58:	2400      	movs	r4, #0
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
 801db5a:	480d      	ldr	r0, [pc, #52]	; (801db90 <UILivingStringButtons+0x7c>)
 801db5c:	6811      	ldr	r1, [r2, #0]
 801db5e:	4a0d      	ldr	r2, [pc, #52]	; (801db94 <UILivingStringButtons+0x80>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801db60:	751c      	strb	r4, [r3, #20]
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
 801db62:	42a1      	cmp	r1, r4
 801db64:	bfd8      	it	le
 801db66:	4610      	movle	r0, r2
 801db68:	e7da      	b.n	801db20 <UILivingStringButtons+0xc>
 801db6a:	bf00      	nop
 801db6c:	2001889c 	.word	0x2001889c
 801db70:	0802b280 	.word	0x0802b280
 801db74:	200005b0 	.word	0x200005b0
 801db78:	0802b160 	.word	0x0802b160
 801db7c:	0802b168 	.word	0x0802b168
 801db80:	200005a8 	.word	0x200005a8
 801db84:	0802b174 	.word	0x0802b174
 801db88:	0802b184 	.word	0x0802b184
 801db8c:	200005a4 	.word	0x200005a4
 801db90:	0802b148 	.word	0x0802b148
 801db94:	0802b154 	.word	0x0802b154

0801db98 <UILivingStringSynthButtons>:

            const char* UILivingStringSynthButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 801db98:	4b15      	ldr	r3, [pc, #84]	; (801dbf0 <UILivingStringSynthButtons+0x58>)
            {
 801db9a:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 801db9c:	7d1a      	ldrb	r2, [r3, #20]
 801db9e:	2a01      	cmp	r2, #1
 801dba0:	d01b      	beq.n	801dbda <UILivingStringSynthButtons+0x42>
                const char* writeString = "";
 801dba2:	4814      	ldr	r0, [pc, #80]	; (801dbf4 <UILivingStringSynthButtons+0x5c>)
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 801dba4:	7e1a      	ldrb	r2, [r3, #24]
 801dba6:	2a01      	cmp	r2, #1
 801dba8:	d108      	bne.n	801dbbc <UILivingStringSynthButtons+0x24>
                {
                    writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
 801dbaa:	4a13      	ldr	r2, [pc, #76]	; (801dbf8 <UILivingStringSynthButtons+0x60>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801dbac:	2400      	movs	r4, #0
                    writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
 801dbae:	4813      	ldr	r0, [pc, #76]	; (801dbfc <UILivingStringSynthButtons+0x64>)
 801dbb0:	6811      	ldr	r1, [r2, #0]
 801dbb2:	4a13      	ldr	r2, [pc, #76]	; (801dc00 <UILivingStringSynthButtons+0x68>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801dbb4:	761c      	strb	r4, [r3, #24]
                    writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
 801dbb6:	42a1      	cmp	r1, r4
 801dbb8:	bfd8      	it	le
 801dbba:	4610      	movle	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 801dbbc:	7f1a      	ldrb	r2, [r3, #28]
 801dbbe:	2a01      	cmp	r2, #1
 801dbc0:	d108      	bne.n	801dbd4 <UILivingStringSynthButtons+0x3c>
                {
                    writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
 801dbc2:	4a10      	ldr	r2, [pc, #64]	; (801dc04 <UILivingStringSynthButtons+0x6c>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801dbc4:	2400      	movs	r4, #0
                    writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
 801dbc6:	4810      	ldr	r0, [pc, #64]	; (801dc08 <UILivingStringSynthButtons+0x70>)
 801dbc8:	6811      	ldr	r1, [r2, #0]
 801dbca:	4a10      	ldr	r2, [pc, #64]	; (801dc0c <UILivingStringSynthButtons+0x74>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801dbcc:	771c      	strb	r4, [r3, #28]
                    writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
 801dbce:	42a1      	cmp	r1, r4
 801dbd0:	bfd8      	it	le
 801dbd2:	4610      	movle	r0, r2
                }
                return writeString;
            }
 801dbd4:	f85d 4b04 	ldr.w	r4, [sp], #4
 801dbd8:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dbda:	4a0d      	ldr	r2, [pc, #52]	; (801dc10 <UILivingStringSynthButtons+0x78>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801dbdc:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dbde:	480d      	ldr	r0, [pc, #52]	; (801dc14 <UILivingStringSynthButtons+0x7c>)
 801dbe0:	6811      	ldr	r1, [r2, #0]
 801dbe2:	4a0d      	ldr	r2, [pc, #52]	; (801dc18 <UILivingStringSynthButtons+0x80>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801dbe4:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dbe6:	2901      	cmp	r1, #1
 801dbe8:	bfd8      	it	le
 801dbea:	4610      	movle	r0, r2
 801dbec:	e7da      	b.n	801dba4 <UILivingStringSynthButtons+0xc>
 801dbee:	bf00      	nop
 801dbf0:	2001889c 	.word	0x2001889c
 801dbf4:	0802b280 	.word	0x0802b280
 801dbf8:	2000062c 	.word	0x2000062c
 801dbfc:	0802b190 	.word	0x0802b190
 801dc00:	0802b19c 	.word	0x0802b19c
 801dc04:	200005b4 	.word	0x200005b4
 801dc08:	0802b160 	.word	0x0802b160
 801dc0c:	0802b168 	.word	0x0802b168
 801dc10:	20000254 	.word	0x20000254
 801dc14:	0802b2a4 	.word	0x0802b2a4
 801dc18:	0802b2ac 	.word	0x0802b2ac

0801dc1c <UIClassicSynthButtons>:

            const char* UIClassicSynthButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 801dc1c:	4b0d      	ldr	r3, [pc, #52]	; (801dc54 <UIClassicSynthButtons+0x38>)
 801dc1e:	7d1a      	ldrb	r2, [r3, #20]
 801dc20:	2a01      	cmp	r2, #1
 801dc22:	d006      	beq.n	801dc32 <UIClassicSynthButtons+0x16>
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress])
 801dc24:	7e1a      	ldrb	r2, [r3, #24]
                const char* writeString = "";
 801dc26:	480c      	ldr	r0, [pc, #48]	; (801dc58 <UIClassicSynthButtons+0x3c>)
                if (buttonActionsUI[ButtonB][ActionPress])
 801dc28:	b112      	cbz	r2, 801dc30 <UIClassicSynthButtons+0x14>
                {
                    //writeString = knobPage == 0 ? "SETTINGS" : "ADSR";
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801dc2a:	2200      	movs	r2, #0
 801dc2c:	761a      	strb	r2, [r3, #24]
 801dc2e:	4770      	bx	lr
                }
                return writeString;
            }
 801dc30:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dc32:	4a0a      	ldr	r2, [pc, #40]	; (801dc5c <UIClassicSynthButtons+0x40>)
 801dc34:	480a      	ldr	r0, [pc, #40]	; (801dc60 <UIClassicSynthButtons+0x44>)
            {
 801dc36:	b410      	push	{r4}
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dc38:	6811      	ldr	r1, [r2, #0]
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801dc3a:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dc3c:	4a09      	ldr	r2, [pc, #36]	; (801dc64 <UIClassicSynthButtons+0x48>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801dc3e:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dc40:	2901      	cmp	r1, #1
 801dc42:	bfd8      	it	le
 801dc44:	4610      	movle	r0, r2
                if (buttonActionsUI[ButtonB][ActionPress])
 801dc46:	7e1a      	ldrb	r2, [r3, #24]
 801dc48:	b10a      	cbz	r2, 801dc4e <UIClassicSynthButtons+0x32>
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801dc4a:	2200      	movs	r2, #0
 801dc4c:	761a      	strb	r2, [r3, #24]
            }
 801dc4e:	f85d 4b04 	ldr.w	r4, [sp], #4
 801dc52:	4770      	bx	lr
 801dc54:	2001889c 	.word	0x2001889c
 801dc58:	0802b280 	.word	0x0802b280
 801dc5c:	20000254 	.word	0x20000254
 801dc60:	0802b2a4 	.word	0x0802b2a4
 801dc64:	0802b2ac 	.word	0x0802b2ac

0801dc68 <UIRhodesButtons>:

            const char* UIRhodesButtons(VocodecButton button, ButtonAction action)
            {
 801dc68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 801dc6a:	4c1f      	ldr	r4, [pc, #124]	; (801dce8 <UIRhodesButtons+0x80>)
 801dc6c:	7d23      	ldrb	r3, [r4, #20]
 801dc6e:	2b01      	cmp	r3, #1
 801dc70:	d008      	beq.n	801dc84 <UIRhodesButtons+0x1c>
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 801dc72:	7e25      	ldrb	r5, [r4, #24]
                const char* writeString = "";
 801dc74:	4e1d      	ldr	r6, [pc, #116]	; (801dcec <UIRhodesButtons+0x84>)
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 801dc76:	2d01      	cmp	r5, #1
 801dc78:	d010      	beq.n	801dc9c <UIRhodesButtons+0x34>
                {
                    buttonActionsUI[ButtonB][ActionPress] = 0;
                    OLEDclearLine(SecondLine);
                    OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 801dc7a:	7f25      	ldrb	r5, [r4, #28]
 801dc7c:	2d01      	cmp	r5, #1
 801dc7e:	d01f      	beq.n	801dcc0 <UIRhodesButtons+0x58>
                    OLEDclearLine(SecondLine);
                    OLEDwriteString("STEREO TREMO", 12, 0, SecondLine);
                    OLEDwriteInt(tremoloStereo, 1, 110, SecondLine);
                }
                return writeString;
            }
 801dc80:	4630      	mov	r0, r6
 801dc82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dc84:	4b1a      	ldr	r3, [pc, #104]	; (801dcf0 <UIRhodesButtons+0x88>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801dc86:	2100      	movs	r1, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dc88:	4e1a      	ldr	r6, [pc, #104]	; (801dcf4 <UIRhodesButtons+0x8c>)
 801dc8a:	681a      	ldr	r2, [r3, #0]
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 801dc8c:	7e25      	ldrb	r5, [r4, #24]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dc8e:	4b1a      	ldr	r3, [pc, #104]	; (801dcf8 <UIRhodesButtons+0x90>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 801dc90:	7521      	strb	r1, [r4, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 801dc92:	2a01      	cmp	r2, #1
 801dc94:	bfd8      	it	le
 801dc96:	461e      	movle	r6, r3
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 801dc98:	2d01      	cmp	r5, #1
 801dc9a:	d1ee      	bne.n	801dc7a <UIRhodesButtons+0x12>
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801dc9c:	2700      	movs	r7, #0
                    OLEDclearLine(SecondLine);
 801dc9e:	4628      	mov	r0, r5
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 801dca0:	7627      	strb	r7, [r4, #24]
                    OLEDclearLine(SecondLine);
 801dca2:	f7f6 f881 	bl	8013da8 <OLEDclearLine>
                    OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
 801dca6:	4915      	ldr	r1, [pc, #84]	; (801dcfc <UIRhodesButtons+0x94>)
 801dca8:	462b      	mov	r3, r5
 801dcaa:	4815      	ldr	r0, [pc, #84]	; (801dd00 <UIRhodesButtons+0x98>)
 801dcac:	463a      	mov	r2, r7
 801dcae:	680d      	ldr	r5, [r1, #0]
 801dcb0:	2106      	movs	r1, #6
 801dcb2:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
 801dcb6:	f7f6 f88b 	bl	8013dd0 <OLEDwriteString>
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 801dcba:	7f25      	ldrb	r5, [r4, #28]
 801dcbc:	2d01      	cmp	r5, #1
 801dcbe:	d1df      	bne.n	801dc80 <UIRhodesButtons+0x18>
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801dcc0:	2700      	movs	r7, #0
                    OLEDclearLine(SecondLine);
 801dcc2:	4628      	mov	r0, r5
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 801dcc4:	7727      	strb	r7, [r4, #28]
                    OLEDclearLine(SecondLine);
 801dcc6:	f7f6 f86f 	bl	8013da8 <OLEDclearLine>
                    OLEDwriteString("STEREO TREMO", 12, 0, SecondLine);
 801dcca:	462b      	mov	r3, r5
 801dccc:	463a      	mov	r2, r7
 801dcce:	210c      	movs	r1, #12
 801dcd0:	480c      	ldr	r0, [pc, #48]	; (801dd04 <UIRhodesButtons+0x9c>)
 801dcd2:	f7f6 f87d 	bl	8013dd0 <OLEDwriteString>
                    OLEDwriteInt(tremoloStereo, 1, 110, SecondLine);
 801dcd6:	4a0c      	ldr	r2, [pc, #48]	; (801dd08 <UIRhodesButtons+0xa0>)
 801dcd8:	462b      	mov	r3, r5
 801dcda:	4629      	mov	r1, r5
 801dcdc:	6810      	ldr	r0, [r2, #0]
 801dcde:	226e      	movs	r2, #110	; 0x6e
 801dce0:	f7f6 f8a2 	bl	8013e28 <OLEDwriteInt>
            }
 801dce4:	4630      	mov	r0, r6
 801dce6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801dce8:	2001889c 	.word	0x2001889c
 801dcec:	0802b280 	.word	0x0802b280
 801dcf0:	20000254 	.word	0x20000254
 801dcf4:	0802b2a4 	.word	0x0802b2a4
 801dcf8:	0802b2ac 	.word	0x0802b2ac
 801dcfc:	20000520 	.word	0x20000520
 801dd00:	20017490 	.word	0x20017490
 801dd04:	0802b1fc 	.word	0x0802b1fc
 801dd08:	2000061c 	.word	0x2000061c

0801dd0c <USBH_UserProcess>:
 * user callback definition
 */
static void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)
{
  /* USER CODE BEGIN CALL_BACK_1 */
  switch(id)
 801dd0c:	2904      	cmp	r1, #4
 801dd0e:	d00b      	beq.n	801dd28 <USBH_UserProcess+0x1c>
 801dd10:	2905      	cmp	r1, #5
 801dd12:	d005      	beq.n	801dd20 <USBH_UserProcess+0x14>
 801dd14:	2902      	cmp	r1, #2
 801dd16:	d000      	beq.n	801dd1a <USBH_UserProcess+0xe>

  default:
  break;
  }
  /* USER CODE END CALL_BACK_1 */
}
 801dd18:	4770      	bx	lr
  Appli_state = APPLICATION_READY;
 801dd1a:	4b05      	ldr	r3, [pc, #20]	; (801dd30 <USBH_UserProcess+0x24>)
 801dd1c:	7019      	strb	r1, [r3, #0]
  break;
 801dd1e:	4770      	bx	lr
  Appli_state = APPLICATION_DISCONNECT;
 801dd20:	4b03      	ldr	r3, [pc, #12]	; (801dd30 <USBH_UserProcess+0x24>)
 801dd22:	2204      	movs	r2, #4
 801dd24:	701a      	strb	r2, [r3, #0]
  break;
 801dd26:	4770      	bx	lr
  Appli_state = APPLICATION_START;
 801dd28:	4b01      	ldr	r3, [pc, #4]	; (801dd30 <USBH_UserProcess+0x24>)
 801dd2a:	2201      	movs	r2, #1
 801dd2c:	701a      	strb	r2, [r3, #0]
}
 801dd2e:	4770      	bx	lr
 801dd30:	2000066c 	.word	0x2000066c

0801dd34 <MX_USB_HOST_Init>:
{
 801dd34:	b508      	push	{r3, lr}
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, HOST_FS) != USBH_OK)
 801dd36:	2201      	movs	r2, #1
 801dd38:	490c      	ldr	r1, [pc, #48]	; (801dd6c <MX_USB_HOST_Init+0x38>)
 801dd3a:	480d      	ldr	r0, [pc, #52]	; (801dd70 <MX_USB_HOST_Init+0x3c>)
 801dd3c:	f7f1 f9f4 	bl	800f128 <USBH_Init>
 801dd40:	b988      	cbnz	r0, 801dd66 <MX_USB_HOST_Init+0x32>
  if (USBH_RegisterClass(&hUsbHostFS, USBH_MIDI_CLASS) != USBH_OK)
 801dd42:	490c      	ldr	r1, [pc, #48]	; (801dd74 <MX_USB_HOST_Init+0x40>)
 801dd44:	480a      	ldr	r0, [pc, #40]	; (801dd70 <MX_USB_HOST_Init+0x3c>)
 801dd46:	f7f1 fa55 	bl	800f1f4 <USBH_RegisterClass>
 801dd4a:	b948      	cbnz	r0, 801dd60 <MX_USB_HOST_Init+0x2c>
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
 801dd4c:	4808      	ldr	r0, [pc, #32]	; (801dd70 <MX_USB_HOST_Init+0x3c>)
 801dd4e:	f7f1 fb41 	bl	800f3d4 <USBH_Start>
 801dd52:	b108      	cbz	r0, 801dd58 <MX_USB_HOST_Init+0x24>
    Error_Handler();
 801dd54:	f7f5 fdba 	bl	80138cc <Error_Handler>
}
 801dd58:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnableUSBVoltageDetector();
 801dd5c:	f7ea b922 	b.w	8007fa4 <HAL_PWREx_EnableUSBVoltageDetector>
    Error_Handler();
 801dd60:	f7f5 fdb4 	bl	80138cc <Error_Handler>
 801dd64:	e7f2      	b.n	801dd4c <MX_USB_HOST_Init+0x18>
    Error_Handler();
 801dd66:	f7f5 fdb1 	bl	80138cc <Error_Handler>
 801dd6a:	e7ea      	b.n	801dd42 <MX_USB_HOST_Init+0xe>
 801dd6c:	0801dd0d 	.word	0x0801dd0d
 801dd70:	300010a0 	.word	0x300010a0
 801dd74:	200002dc 	.word	0x200002dc

0801dd78 <MX_USB_HOST_DeInit>:
{
 801dd78:	b508      	push	{r3, lr}
  if (USBH_Stop(&hUsbHostFS) != USBH_OK)
 801dd7a:	4808      	ldr	r0, [pc, #32]	; (801dd9c <MX_USB_HOST_DeInit+0x24>)
 801dd7c:	f7f1 fb34 	bl	800f3e8 <USBH_Stop>
 801dd80:	b948      	cbnz	r0, 801dd96 <MX_USB_HOST_DeInit+0x1e>
  if (USBH_DeInit(&hUsbHostFS) != USBH_OK)
 801dd82:	4806      	ldr	r0, [pc, #24]	; (801dd9c <MX_USB_HOST_DeInit+0x24>)
 801dd84:	f7f1 fa08 	bl	800f198 <USBH_DeInit>
 801dd88:	b108      	cbz	r0, 801dd8e <MX_USB_HOST_DeInit+0x16>
    Error_Handler();
 801dd8a:	f7f5 fd9f 	bl	80138cc <Error_Handler>
}
 801dd8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_DisableUSBVoltageDetector();
 801dd92:	f7ea b90f 	b.w	8007fb4 <HAL_PWREx_DisableUSBVoltageDetector>
    Error_Handler();
 801dd96:	f7f5 fd99 	bl	80138cc <Error_Handler>
 801dd9a:	e7f2      	b.n	801dd82 <MX_USB_HOST_DeInit+0xa>
 801dd9c:	300010a0 	.word	0x300010a0

0801dda0 <MX_USB_HOST_Process>:
{
 801dda0:	b508      	push	{r3, lr}
	MIDI_Application();
 801dda2:	f7f2 fdbd 	bl	8010920 <MIDI_Application>
	USBH_Process(&hUsbHostFS);
 801dda6:	4802      	ldr	r0, [pc, #8]	; (801ddb0 <MX_USB_HOST_Process+0x10>)
}
 801dda8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	USBH_Process(&hUsbHostFS);
 801ddac:	f7f1 bb2e 	b.w	800f40c <USBH_Process>
 801ddb0:	300010a0 	.word	0x300010a0

0801ddb4 <USBH_MIDI_ClassRequest>:
 *         for MIDI class.
 * @param  phost: Host handle
 * @retval USBH Status
 */
static USBH_StatusTypeDef USBH_MIDI_ClassRequest (USBH_HandleTypeDef *phost)
{   
 801ddb4:	b508      	push	{r3, lr}

	phost->pUser(phost, HOST_USER_CLASS_ACTIVE);
 801ddb6:	2102      	movs	r1, #2
 801ddb8:	f8d0 3544 	ldr.w	r3, [r0, #1348]	; 0x544
 801ddbc:	4798      	blx	r3

	return USBH_OK;
}
 801ddbe:	2000      	movs	r0, #0
 801ddc0:	bd08      	pop	{r3, pc}
 801ddc2:	bf00      	nop

0801ddc4 <USBH_MIDI_Process>:
 *         (background process)
 * @param  phost: Host handle
 * @retval USBH Status
 */
static USBH_StatusTypeDef USBH_MIDI_Process (USBH_HandleTypeDef *phost)
{
 801ddc4:	b510      	push	{r4, lr}
	USBH_StatusTypeDef status = USBH_BUSY;
	USBH_StatusTypeDef req_status = USBH_OK;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 801ddc6:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
 801ddca:	69dc      	ldr	r4, [r3, #28]

	switch(MIDI_Handle->state)
 801ddcc:	7823      	ldrb	r3, [r4, #0]
 801ddce:	b153      	cbz	r3, 801dde6 <USBH_MIDI_Process+0x22>
 801ddd0:	2b02      	cmp	r3, #2
 801ddd2:	d106      	bne.n	801dde2 <USBH_MIDI_Process+0x1e>
		//MIDI_ProcessTransmission(phost);
		//MIDI_ProcessReception(phost);
		break;

	case MIDI_ERROR_STATE:
		req_status = USBH_ClrFeature(phost, 0x00);
 801ddd4:	2100      	movs	r1, #0
 801ddd6:	f7f2 fbdf 	bl	8010598 <USBH_ClrFeature>

		if(req_status == USBH_OK )
 801ddda:	b910      	cbnz	r0, 801dde2 <USBH_MIDI_Process+0x1e>
		{
			/*Change the state to waiting*/
			MIDI_Handle->state = MIDI_IDLE_STATE ;
 801dddc:	7020      	strb	r0, [r4, #0]
	USBH_StatusTypeDef status = USBH_BUSY;
 801ddde:	2001      	movs	r0, #1
		break;

	}

	return status;
}
 801dde0:	bd10      	pop	{r4, pc}
	USBH_StatusTypeDef status = USBH_BUSY;
 801dde2:	2001      	movs	r0, #1
}
 801dde4:	bd10      	pop	{r4, pc}
		status = USBH_OK;
 801dde6:	4618      	mov	r0, r3
}
 801dde8:	bd10      	pop	{r4, pc}
 801ddea:	bf00      	nop

0801ddec <USBH_MIDI_SOFProcess>:
  *         The function is for managing SOF callback
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MIDI_SOFProcess (USBH_HandleTypeDef *phost)
{
 801ddec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBH_StatusTypeDef status = USBH_BUSY;
	USBH_StatusTypeDef req_status = USBH_OK;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 801ddf0:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
{
 801ddf4:	b083      	sub	sp, #12
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 801ddf6:	69dc      	ldr	r4, [r3, #28]
	USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
	uint16_t length;
	switch(MIDI_Handle->state)
 801ddf8:	7823      	ldrb	r3, [r4, #0]
 801ddfa:	2b01      	cmp	r3, #1
 801ddfc:	d00a      	beq.n	801de14 <USBH_MIDI_SOFProcess+0x28>
 801ddfe:	2b02      	cmp	r3, #2
 801de00:	d104      	bne.n	801de0c <USBH_MIDI_SOFProcess+0x20>
				break;
		}
		break;

	case MIDI_ERROR_STATE:
		req_status = USBH_ClrFeature(phost, 0x00);
 801de02:	2100      	movs	r1, #0
 801de04:	f7f2 fbc8 	bl	8010598 <USBH_ClrFeature>

		if(req_status == USBH_OK )
 801de08:	b900      	cbnz	r0, 801de0c <USBH_MIDI_SOFProcess+0x20>
		{
			/*Change the state to waiting*/
			MIDI_Handle->state = MIDI_IDLE_STATE ;
 801de0a:	7020      	strb	r0, [r4, #0]
		break;

	}

	return USBH_OK;
}
 801de0c:	2000      	movs	r0, #0
 801de0e:	b003      	add	sp, #12
 801de10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch(MIDI_Handle->data_rx_state)
 801de14:	7e63      	ldrb	r3, [r4, #25]
 801de16:	2b03      	cmp	r3, #3
 801de18:	d06e      	beq.n	801def8 <USBH_MIDI_SOFProcess+0x10c>
 801de1a:	2b04      	cmp	r3, #4
 801de1c:	d1f6      	bne.n	801de0c <USBH_MIDI_SOFProcess+0x20>
				URB_Status = USBH_LL_GetURBState(phost, MIDI_Handle->InPipe);
 801de1e:	7861      	ldrb	r1, [r4, #1]
 801de20:	4605      	mov	r5, r0
 801de22:	f000 fa49 	bl	801e2b8 <USBH_LL_GetURBState>
				if(URB_Status == USBH_URB_DONE )
 801de26:	2801      	cmp	r0, #1
 801de28:	d1f0      	bne.n	801de0c <USBH_MIDI_SOFProcess+0x20>
					length = USBH_LL_GetLastXferSize(phost, MIDI_Handle->InPipe);
 801de2a:	7861      	ldrb	r1, [r4, #1]
 801de2c:	4628      	mov	r0, r5
 801de2e:	f000 f9fb 	bl	801e228 <USBH_LL_GetLastXferSize>
					if(((MIDI_Handle->RxDataLength - length) > 0) && (length > MIDI_Handle->InEpSize))
 801de32:	8ae3      	ldrh	r3, [r4, #22]
 801de34:	b286      	uxth	r6, r0
 801de36:	1b9a      	subs	r2, r3, r6
 801de38:	2a00      	cmp	r2, #0
 801de3a:	dd02      	ble.n	801de42 <USBH_MIDI_SOFProcess+0x56>
 801de3c:	8922      	ldrh	r2, [r4, #8]
 801de3e:	42b2      	cmp	r2, r6
 801de40:	d365      	bcc.n	801df0e <USBH_MIDI_SOFProcess+0x122>
						MIDI_write_buffer = !MIDI_write_buffer;
 801de42:	4837      	ldr	r0, [pc, #220]	; (801df20 <USBH_MIDI_SOFProcess+0x134>)
						MIDI_Handle->data_rx_state = MIDI_IDLE;
 801de44:	2300      	movs	r3, #0
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 801de46:	4937      	ldr	r1, [pc, #220]	; (801df24 <USBH_MIDI_SOFProcess+0x138>)
						MIDI_write_buffer = !MIDI_write_buffer;
 801de48:	6807      	ldr	r7, [r0, #0]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 801de4a:	680a      	ldr	r2, [r1, #0]
						MIDI_write_buffer = !MIDI_write_buffer;
 801de4c:	fab7 fc87 	clz	ip, r7
						MIDI_Handle->data_rx_state = MIDI_IDLE;
 801de50:	7663      	strb	r3, [r4, #25]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 801de52:	fab2 f282 	clz	r2, r2
						MIDI_write_buffer = !MIDI_write_buffer;
 801de56:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 801de5a:	0952      	lsrs	r2, r2, #5
						MIDI_write_buffer = !MIDI_write_buffer;
 801de5c:	f8c0 c000 	str.w	ip, [r0]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 801de60:	600a      	str	r2, [r1, #0]
						for (int i = 0; i < length; i++)
 801de62:	2e00      	cmp	r6, #0
 801de64:	d035      	beq.n	801ded2 <USBH_MIDI_SOFProcess+0xe6>
 801de66:	4830      	ldr	r0, [pc, #192]	; (801df28 <USBH_MIDI_SOFProcess+0x13c>)
								myUSB_FIFO_overflowBit = 1;
 801de68:	f04f 0801 	mov.w	r8, #1
 801de6c:	492f      	ldr	r1, [pc, #188]	; (801df2c <USBH_MIDI_SOFProcess+0x140>)
								myUSB_FIFO_writePointer = 0;
 801de6e:	469e      	mov	lr, r3
 801de70:	eb00 1282 	add.w	r2, r0, r2, lsl #6
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
 801de74:	4f2e      	ldr	r7, [pc, #184]	; (801df30 <USBH_MIDI_SOFProcess+0x144>)
								myUSB_FIFO_overflowBit = 1;
 801de76:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 801df34 <USBH_MIDI_SOFProcess+0x148>
 801de7a:	9401      	str	r4, [sp, #4]
							if ((i % 4) == 0)
 801de7c:	f003 0003 	and.w	r0, r3, #3
 801de80:	3301      	adds	r3, #1
 801de82:	b9d8      	cbnz	r0, 801debc <USBH_MIDI_SOFProcess+0xd0>
								if (MIDI_RX_Buffer[MIDI_read_buffer][i] > 0)
 801de84:	7810      	ldrb	r0, [r2, #0]
 801de86:	b1c8      	cbz	r0, 801debc <USBH_MIDI_SOFProcess+0xd0>
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
 801de88:	f8b1 b000 	ldrh.w	fp, [r1]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
 801de8c:	f892 a001 	ldrb.w	sl, [r2, #1]
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
 801de90:	fa1f fb8b 	uxth.w	fp, fp
									myUSB_FIFO[myUSB_FIFO_writePointer+2] = MIDI_RX_Buffer[MIDI_read_buffer][i+2];
 801de94:	7894      	ldrb	r4, [r2, #2]
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
 801de96:	f807 000b 	strb.w	r0, [r7, fp]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
 801de9a:	8808      	ldrh	r0, [r1, #0]
									myUSB_FIFO[myUSB_FIFO_writePointer+3] = MIDI_RX_Buffer[MIDI_read_buffer][i+3];
 801de9c:	f892 b003 	ldrb.w	fp, [r2, #3]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
 801dea0:	3001      	adds	r0, #1
 801dea2:	f807 a000 	strb.w	sl, [r7, r0]
									myUSB_FIFO[myUSB_FIFO_writePointer+2] = MIDI_RX_Buffer[MIDI_read_buffer][i+2];
 801dea6:	8808      	ldrh	r0, [r1, #0]
 801dea8:	3002      	adds	r0, #2
 801deaa:	543c      	strb	r4, [r7, r0]
									myUSB_FIFO[myUSB_FIFO_writePointer+3] = MIDI_RX_Buffer[MIDI_read_buffer][i+3];
 801deac:	8808      	ldrh	r0, [r1, #0]
 801deae:	3003      	adds	r0, #3
 801deb0:	f807 b000 	strb.w	fp, [r7, r0]
									myUSB_FIFO_writePointer+=4;
 801deb4:	8808      	ldrh	r0, [r1, #0]
 801deb6:	3004      	adds	r0, #4
 801deb8:	b280      	uxth	r0, r0
 801deba:	8008      	strh	r0, [r1, #0]
							if (myUSB_FIFO_writePointer >= 256)
 801debc:	8808      	ldrh	r0, [r1, #0]
 801debe:	3201      	adds	r2, #1
 801dec0:	28ff      	cmp	r0, #255	; 0xff
 801dec2:	d903      	bls.n	801decc <USBH_MIDI_SOFProcess+0xe0>
								myUSB_FIFO_writePointer = 0;
 801dec4:	f8a1 e000 	strh.w	lr, [r1]
								myUSB_FIFO_overflowBit = 1;
 801dec8:	f889 8000 	strb.w	r8, [r9]
						for (int i = 0; i < length; i++)
 801decc:	429e      	cmp	r6, r3
 801dece:	d1d5      	bne.n	801de7c <USBH_MIDI_SOFProcess+0x90>
 801ded0:	9c01      	ldr	r4, [sp, #4]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
 801ded2:	2304      	movs	r3, #4
 801ded4:	7663      	strb	r3, [r4, #25]
 * @retval None
 */
USBH_StatusTypeDef  USBH_MIDI_Receive(USBH_HandleTypeDef *phost, uint8_t *pbuff, uint16_t length)
{
	USBH_StatusTypeDef Status = USBH_BUSY;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 801ded6:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
 801deda:	69db      	ldr	r3, [r3, #28]

	if((MIDI_Handle->state == MIDI_IDLE_STATE) || (MIDI_Handle->state == MIDI_TRANSFER_DATA))
 801dedc:	781a      	ldrb	r2, [r3, #0]
 801dede:	2a01      	cmp	r2, #1
 801dee0:	d894      	bhi.n	801de0c <USBH_MIDI_SOFProcess+0x20>
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
 801dee2:	4a11      	ldr	r2, [pc, #68]	; (801df28 <USBH_MIDI_SOFProcess+0x13c>)
	{
		MIDI_Handle->pRxData = pbuff;
		MIDI_Handle->RxDataLength = length;
 801dee4:	2440      	movs	r4, #64	; 0x40
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
 801dee6:	2001      	movs	r0, #1
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 801dee8:	2103      	movs	r1, #3
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
 801deea:	eb02 128c 	add.w	r2, r2, ip, lsl #6
		MIDI_Handle->RxDataLength = length;
 801deee:	82dc      	strh	r4, [r3, #22]
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
 801def0:	7018      	strb	r0, [r3, #0]
		MIDI_Handle->pRxData = pbuff;
 801def2:	611a      	str	r2, [r3, #16]
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 801def4:	7659      	strb	r1, [r3, #25]
 801def6:	e789      	b.n	801de0c <USBH_MIDI_SOFProcess+0x20>
				USBH_BulkReceiveData (phost,
 801def8:	7863      	ldrb	r3, [r4, #1]
 801defa:	8922      	ldrh	r2, [r4, #8]
 801defc:	6921      	ldr	r1, [r4, #16]
 801defe:	f7f2 fc6b 	bl	80107d8 <USBH_BulkReceiveData>
				MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
 801df02:	2304      	movs	r3, #4
}
 801df04:	2000      	movs	r0, #0
				MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
 801df06:	7663      	strb	r3, [r4, #25]
}
 801df08:	b003      	add	sp, #12
 801df0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						MIDI_Handle->pRxData += length;
 801df0e:	6922      	ldr	r2, [r4, #16]
						MIDI_Handle->RxDataLength -= length ;
 801df10:	1b98      	subs	r0, r3, r6
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 801df12:	2303      	movs	r3, #3
						MIDI_Handle->pRxData += length;
 801df14:	4432      	add	r2, r6
						MIDI_Handle->RxDataLength -= length ;
 801df16:	82e0      	strh	r0, [r4, #22]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 801df18:	7663      	strb	r3, [r4, #25]
						MIDI_Handle->pRxData += length;
 801df1a:	6122      	str	r2, [r4, #16]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 801df1c:	e776      	b.n	801de0c <USBH_MIDI_SOFProcess+0x20>
 801df1e:	bf00      	nop
 801df20:	20000008 	.word	0x20000008
 801df24:	200004d4 	.word	0x200004d4
 801df28:	30000000 	.word	0x30000000
 801df2c:	20000670 	.word	0x20000670
 801df30:	20019124 	.word	0x20019124
 801df34:	2000066d 	.word	0x2000066d

0801df38 <USBH_MIDI_InterfaceDeInit>:
{
 801df38:	b538      	push	{r3, r4, r5, lr}
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 801df3a:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
{
 801df3e:	4605      	mov	r5, r0
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 801df40:	69dc      	ldr	r4, [r3, #28]
	if ( MIDI_Handle->OutPipe)
 801df42:	78a1      	ldrb	r1, [r4, #2]
 801df44:	b949      	cbnz	r1, 801df5a <USBH_MIDI_InterfaceDeInit+0x22>
	if ( MIDI_Handle->InPipe)
 801df46:	7861      	ldrb	r1, [r4, #1]
 801df48:	b991      	cbnz	r1, 801df70 <USBH_MIDI_InterfaceDeInit+0x38>
	if(phost->pActiveClass->pData)
 801df4a:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
 801df4e:	69da      	ldr	r2, [r3, #28]
 801df50:	b10a      	cbz	r2, 801df56 <USBH_MIDI_InterfaceDeInit+0x1e>
		phost->pActiveClass->pData = 0;
 801df52:	2200      	movs	r2, #0
 801df54:	61da      	str	r2, [r3, #28]
}
 801df56:	2000      	movs	r0, #0
 801df58:	bd38      	pop	{r3, r4, r5, pc}
		USBH_ClosePipe(phost, MIDI_Handle->OutPipe);
 801df5a:	f7f2 fc5f 	bl	801081c <USBH_ClosePipe>
		USBH_FreePipe  (phost, MIDI_Handle->OutPipe);
 801df5e:	78a1      	ldrb	r1, [r4, #2]
 801df60:	4628      	mov	r0, r5
 801df62:	f7f2 fcab 	bl	80108bc <USBH_FreePipe>
		MIDI_Handle->OutPipe = 0;     /* Reset the Channel as Free */
 801df66:	2300      	movs	r3, #0
	if ( MIDI_Handle->InPipe)
 801df68:	7861      	ldrb	r1, [r4, #1]
		MIDI_Handle->OutPipe = 0;     /* Reset the Channel as Free */
 801df6a:	70a3      	strb	r3, [r4, #2]
	if ( MIDI_Handle->InPipe)
 801df6c:	2900      	cmp	r1, #0
 801df6e:	d0ec      	beq.n	801df4a <USBH_MIDI_InterfaceDeInit+0x12>
		USBH_ClosePipe(phost, MIDI_Handle->InPipe);
 801df70:	4628      	mov	r0, r5
 801df72:	f7f2 fc53 	bl	801081c <USBH_ClosePipe>
		USBH_FreePipe  (phost, MIDI_Handle->InPipe);
 801df76:	7861      	ldrb	r1, [r4, #1]
 801df78:	4628      	mov	r0, r5
 801df7a:	f7f2 fc9f 	bl	80108bc <USBH_FreePipe>
		MIDI_Handle->InPipe = 0;     /* Reset the Channel as Free */
 801df7e:	2300      	movs	r3, #0
 801df80:	7063      	strb	r3, [r4, #1]
 801df82:	e7e2      	b.n	801df4a <USBH_MIDI_InterfaceDeInit+0x12>

0801df84 <USBH_MIDI_InterfaceInit>:
{	
 801df84:	b5f0      	push	{r4, r5, r6, r7, lr}
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
 801df86:	23ff      	movs	r3, #255	; 0xff
{	
 801df88:	b085      	sub	sp, #20
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
 801df8a:	2203      	movs	r2, #3
 801df8c:	2101      	movs	r1, #1
{	
 801df8e:	4605      	mov	r5, r0
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
 801df90:	f7f1 f948 	bl	800f224 <USBH_FindInterface>
	if(interface == 0xFF) /* No Valid Interface */
 801df94:	28ff      	cmp	r0, #255	; 0xff
 801df96:	d058      	beq.n	801e04a <USBH_MIDI_InterfaceInit+0xc6>
		USBH_SelectInterface (phost, interface);
 801df98:	4601      	mov	r1, r0
 801df9a:	4628      	mov	r0, r5
 801df9c:	f7f1 f938 	bl	800f210 <USBH_SelectInterface>
		phost->pActiveClass->pData = &myMIDIHandle;
 801dfa0:	4c2d      	ldr	r4, [pc, #180]	; (801e058 <USBH_MIDI_InterfaceInit+0xd4>)
 801dfa2:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
 801dfa6:	222a      	movs	r2, #42	; 0x2a
		phost->pActiveClass->pData = &myMIDIHandle;
 801dfa8:	61dc      	str	r4, [r3, #28]
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
 801dfaa:	f895 3324 	ldrb.w	r3, [r5, #804]	; 0x324
 801dfae:	fb02 5203 	mla	r2, r2, r3, r5
 801dfb2:	f892 134e 	ldrb.w	r1, [r2, #846]	; 0x34e
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
 801dfb6:	f8b2 2350 	ldrh.w	r2, [r2, #848]	; 0x350
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
 801dfba:	0608      	lsls	r0, r1, #24
 801dfbc:	d442      	bmi.n	801e044 <USBH_MIDI_InterfaceInit+0xc0>
			myMIDIHandle.OutEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress);
 801dfbe:	70e1      	strb	r1, [r4, #3]
			myMIDIHandle.OutEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
 801dfc0:	80e2      	strh	r2, [r4, #6]
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress & 0x80)
 801dfc2:	222a      	movs	r2, #42	; 0x2a
 801dfc4:	fb02 5303 	mla	r3, r2, r3, r5
 801dfc8:	f893 1356 	ldrb.w	r1, [r3, #854]	; 0x356
 801dfcc:	f8b3 3358 	ldrh.w	r3, [r3, #856]	; 0x358
 801dfd0:	060a      	lsls	r2, r1, #24
 801dfd2:	d43d      	bmi.n	801e050 <USBH_MIDI_InterfaceInit+0xcc>
			myMIDIHandle.OutEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress);
 801dfd4:	70e1      	strb	r1, [r4, #3]
			myMIDIHandle.OutEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].wMaxPacketSize;
 801dfd6:	80e3      	strh	r3, [r4, #6]
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
 801dfd8:	4628      	mov	r0, r5
		USBH_OpenPipe  (phost,
 801dfda:	2702      	movs	r7, #2
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
 801dfdc:	f7f2 fc24 	bl	8010828 <USBH_AllocPipe>
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
 801dfe0:	7921      	ldrb	r1, [r4, #4]
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
 801dfe2:	70a0      	strb	r0, [r4, #2]
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
 801dfe4:	4628      	mov	r0, r5
 801dfe6:	f7f2 fc1f 	bl	8010828 <USBH_AllocPipe>
		USBH_OpenPipe  (phost,
 801dfea:	f8b4 c006 	ldrh.w	ip, [r4, #6]
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
 801dfee:	7060      	strb	r0, [r4, #1]
		myMIDIHandle.state = MIDI_IDLE_STATE;
 801dff0:	2600      	movs	r6, #0
		USBH_OpenPipe  (phost,
 801dff2:	f895 031d 	ldrb.w	r0, [r5, #797]	; 0x31d
 801dff6:	f895 331c 	ldrb.w	r3, [r5, #796]	; 0x31c
 801dffa:	78e2      	ldrb	r2, [r4, #3]
 801dffc:	78a1      	ldrb	r1, [r4, #2]
 801dffe:	9000      	str	r0, [sp, #0]
 801e000:	4628      	mov	r0, r5
 801e002:	e9cd 7c01 	strd	r7, ip, [sp, #4]
 801e006:	f7f2 fbf9 	bl	80107fc <USBH_OpenPipe>
		USBH_OpenPipe  (phost,
 801e00a:	f895 331c 	ldrb.w	r3, [r5, #796]	; 0x31c
 801e00e:	f8b4 c008 	ldrh.w	ip, [r4, #8]
 801e012:	4628      	mov	r0, r5
 801e014:	9701      	str	r7, [sp, #4]
 801e016:	f895 731d 	ldrb.w	r7, [r5, #797]	; 0x31d
 801e01a:	7922      	ldrb	r2, [r4, #4]
 801e01c:	f8cd c008 	str.w	ip, [sp, #8]
 801e020:	7861      	ldrb	r1, [r4, #1]
 801e022:	9700      	str	r7, [sp, #0]
 801e024:	f7f2 fbea 	bl	80107fc <USBH_OpenPipe>
		USBH_LL_SetToggle  (phost, myMIDIHandle.InPipe,0);
 801e028:	4632      	mov	r2, r6
 801e02a:	7861      	ldrb	r1, [r4, #1]
 801e02c:	4628      	mov	r0, r5
		myMIDIHandle.state = MIDI_IDLE_STATE;
 801e02e:	7026      	strb	r6, [r4, #0]
		USBH_LL_SetToggle  (phost, myMIDIHandle.InPipe,0);
 801e030:	f000 f958 	bl	801e2e4 <USBH_LL_SetToggle>
		USBH_LL_SetToggle  (phost, myMIDIHandle.OutPipe,0);
 801e034:	4632      	mov	r2, r6
 801e036:	78a1      	ldrb	r1, [r4, #2]
 801e038:	4628      	mov	r0, r5
 801e03a:	f000 f953 	bl	801e2e4 <USBH_LL_SetToggle>
 801e03e:	4630      	mov	r0, r6
}
 801e040:	b005      	add	sp, #20
 801e042:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myMIDIHandle.InEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress);
 801e044:	7121      	strb	r1, [r4, #4]
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
 801e046:	8122      	strh	r2, [r4, #8]
 801e048:	e7bb      	b.n	801dfc2 <USBH_MIDI_InterfaceInit+0x3e>
		status = USBH_FAIL;
 801e04a:	2002      	movs	r0, #2
}
 801e04c:	b005      	add	sp, #20
 801e04e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myMIDIHandle.InEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress);
 801e050:	7121      	strb	r1, [r4, #4]
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].wMaxPacketSize;
 801e052:	8123      	strh	r3, [r4, #8]
 801e054:	78e1      	ldrb	r1, [r4, #3]
 801e056:	e7bf      	b.n	801dfd8 <USBH_MIDI_InterfaceInit+0x54>
 801e058:	20019108 	.word	0x20019108

0801e05c <USBH_MIDI_Stop>:
  if(phost->gState == HOST_CLASS)
 801e05c:	7802      	ldrb	r2, [r0, #0]
 801e05e:	2a0b      	cmp	r2, #11
 801e060:	d001      	beq.n	801e066 <USBH_MIDI_Stop+0xa>
}
 801e062:	2000      	movs	r0, #0
 801e064:	4770      	bx	lr
{
 801e066:	b538      	push	{r3, r4, r5, lr}
  MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 801e068:	f8d0 24ec 	ldr.w	r2, [r0, #1260]	; 0x4ec
    MIDI_Handle->state = MIDI_IDLE_STATE;
 801e06c:	2300      	movs	r3, #0
 801e06e:	4604      	mov	r4, r0
  MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 801e070:	69d5      	ldr	r5, [r2, #28]
    MIDI_Handle->state = MIDI_IDLE_STATE;
 801e072:	702b      	strb	r3, [r5, #0]
    USBH_ClosePipe(phost, MIDI_Handle->InPipe);
 801e074:	7869      	ldrb	r1, [r5, #1]
 801e076:	f7f2 fbd1 	bl	801081c <USBH_ClosePipe>
    USBH_ClosePipe(phost, MIDI_Handle->OutPipe);
 801e07a:	78a9      	ldrb	r1, [r5, #2]
 801e07c:	4620      	mov	r0, r4
 801e07e:	f7f2 fbcd 	bl	801081c <USBH_ClosePipe>
}
 801e082:	2000      	movs	r0, #0
 801e084:	bd38      	pop	{r3, r4, r5, pc}
 801e086:	bf00      	nop

0801e088 <USBH_MIDI_Receive>:
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 801e088:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
 801e08c:	69db      	ldr	r3, [r3, #28]
	if((MIDI_Handle->state == MIDI_IDLE_STATE) || (MIDI_Handle->state == MIDI_TRANSFER_DATA))
 801e08e:	7818      	ldrb	r0, [r3, #0]
 801e090:	2801      	cmp	r0, #1
 801e092:	d901      	bls.n	801e098 <USBH_MIDI_Receive+0x10>
	USBH_StatusTypeDef Status = USBH_BUSY;
 801e094:	2001      	movs	r0, #1
#if (USBH_USE_OS == 1)
		osMessagePut ( phost->os_event, USBH_CLASS_EVENT, 0);
#endif
	}
	return Status;
}
 801e096:	4770      	bx	lr
{
 801e098:	b430      	push	{r4, r5}
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
 801e09a:	2501      	movs	r5, #1
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 801e09c:	2403      	movs	r4, #3
		MIDI_Handle->pRxData = pbuff;
 801e09e:	6119      	str	r1, [r3, #16]
		Status = USBH_OK;
 801e0a0:	2000      	movs	r0, #0
		MIDI_Handle->RxDataLength = length;
 801e0a2:	82da      	strh	r2, [r3, #22]
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
 801e0a4:	701d      	strb	r5, [r3, #0]
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 801e0a6:	765c      	strb	r4, [r3, #25]
}
 801e0a8:	bc30      	pop	{r4, r5}
 801e0aa:	4770      	bx	lr

0801e0ac <HAL_HCD_MspInit>:
                       LL Driver Callbacks (HCD -> USB Host Library)
*******************************************************************************/
/* MSP Init */

void HAL_HCD_MspInit(HCD_HandleTypeDef* hcdHandle)
{
 801e0ac:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hcdHandle->Instance==USB_OTG_FS)
 801e0ae:	4b1e      	ldr	r3, [pc, #120]	; (801e128 <HAL_HCD_MspInit+0x7c>)
{
 801e0b0:	b088      	sub	sp, #32
  if(hcdHandle->Instance==USB_OTG_FS)
 801e0b2:	6802      	ldr	r2, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801e0b4:	2400      	movs	r4, #0
  if(hcdHandle->Instance==USB_OTG_FS)
 801e0b6:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801e0b8:	9407      	str	r4, [sp, #28]
 801e0ba:	e9cd 4403 	strd	r4, r4, [sp, #12]
 801e0be:	e9cd 4405 	strd	r4, r4, [sp, #20]
  if(hcdHandle->Instance==USB_OTG_FS)
 801e0c2:	d001      	beq.n	801e0c8 <HAL_HCD_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */
//
  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 801e0c4:	b008      	add	sp, #32
 801e0c6:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e0c8:	4d18      	ldr	r5, [pc, #96]	; (801e12c <HAL_HCD_MspInit+0x80>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801e0ca:	2202      	movs	r2, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801e0cc:	2003      	movs	r0, #3
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 801e0ce:	f44f 56c0 	mov.w	r6, #6144	; 0x1800
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e0d2:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801e0d6:	a903      	add	r1, sp, #12
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e0d8:	f043 0301 	orr.w	r3, r3, #1
 801e0dc:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
 801e0e0:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801e0e4:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
 801e0e6:	220a      	movs	r2, #10
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e0e8:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801e0ec:	9006      	str	r0, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801e0ee:	4810      	ldr	r0, [pc, #64]	; (801e130 <HAL_HCD_MspInit+0x84>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801e0f0:	9301      	str	r3, [sp, #4]
 801e0f2:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
 801e0f4:	9207      	str	r2, [sp, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 801e0f6:	9603      	str	r6, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801e0f8:	f7e7 f862 	bl	80051c0 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 801e0fc:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
 801e100:	4622      	mov	r2, r4
 801e102:	2101      	movs	r1, #1
 801e104:	2065      	movs	r0, #101	; 0x65
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 801e106:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 801e10a:	f8c5 30d8 	str.w	r3, [r5, #216]	; 0xd8
 801e10e:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
 801e112:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 801e116:	9302      	str	r3, [sp, #8]
 801e118:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
 801e11a:	f7e4 f8ed 	bl	80022f8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 801e11e:	2065      	movs	r0, #101	; 0x65
 801e120:	f7e4 f930 	bl	8002384 <HAL_NVIC_EnableIRQ>
}
 801e124:	b008      	add	sp, #32
 801e126:	bd70      	pop	{r4, r5, r6, pc}
 801e128:	40080000 	.word	0x40080000
 801e12c:	58024400 	.word	0x58024400
 801e130:	58020000 	.word	0x58020000

0801e134 <HAL_HCD_SOF_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_IncTimer(hhcd->pData);
 801e134:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 801e138:	f7f1 bbd0 	b.w	800f8dc <USBH_LL_IncTimer>

0801e13c <HAL_HCD_Connect_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_Connect(hhcd->pData);
 801e13c:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 801e140:	f7f1 bbe4 	b.w	800f90c <USBH_LL_Connect>

0801e144 <HAL_HCD_Disconnect_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_Disconnect(hhcd->pData);
 801e144:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 801e148:	f7f1 bbec 	b.w	800f924 <USBH_LL_Disconnect>

0801e14c <HAL_HCD_HC_NotifyURBChange_Callback>:
{
  /* To be used with OS to sync URB state with the global state machine */
#if (USBH_USE_OS == 1)
  USBH_LL_NotifyURBChange(hhcd->pData);
#endif
}
 801e14c:	4770      	bx	lr
 801e14e:	bf00      	nop

0801e150 <HAL_HCD_PortEnabled_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortEnabled_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_PortEnabled(hhcd->pData);
 801e150:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 801e154:	f7f1 bbd2 	b.w	800f8fc <USBH_LL_PortEnabled>

0801e158 <HAL_HCD_PortDisabled_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortDisabled_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_PortDisabled(hhcd->pData);
 801e158:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 801e15c:	f7f1 bbd2 	b.w	800f904 <USBH_LL_PortDisabled>

0801e160 <USBH_LL_Init>:
  * @brief  Initialize the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
{
 801e160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Init USB_IP */
  if (phost->id == HOST_FS) {
 801e162:	f890 353c 	ldrb.w	r3, [r0, #1340]	; 0x53c
 801e166:	2b01      	cmp	r3, #1
 801e168:	d001      	beq.n	801e16e <USBH_LL_Init+0xe>
  }

  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
  }
  return USBH_OK;
}
 801e16a:	2000      	movs	r0, #0
 801e16c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 801e16e:	4a10      	ldr	r2, [pc, #64]	; (801e1b0 <USBH_LL_Init+0x50>)
 801e170:	4604      	mov	r4, r0
  hhcd_USB_OTG_FS.Init.Host_channels = 6;
 801e172:	2606      	movs	r6, #6
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 801e174:	4f0f      	ldr	r7, [pc, #60]	; (801e1b4 <USBH_LL_Init+0x54>)
  hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
 801e176:	2502      	movs	r5, #2
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 801e178:	2100      	movs	r1, #0
  phost->pData = &hhcd_USB_OTG_FS;
 801e17a:	f8c0 2540 	str.w	r2, [r0, #1344]	; 0x540
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
 801e17e:	4610      	mov	r0, r2
  hhcd_USB_OTG_FS.pData = phost;
 801e180:	f8c2 42c0 	str.w	r4, [r2, #704]	; 0x2c0
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 801e184:	6017      	str	r7, [r2, #0]
  hhcd_USB_OTG_FS.Init.Host_channels = 6;
 801e186:	6096      	str	r6, [r2, #8]
  hhcd_USB_OTG_FS.Init.dma_enable = ENABLE;
 801e188:	e9c2 3303 	strd	r3, r3, [r2, #12]
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 801e18c:	e9c2 5106 	strd	r5, r1, [r2, #24]
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
 801e190:	f7e7 fbb8 	bl	8005904 <HAL_HCD_Init>
 801e194:	b940      	cbnz	r0, 801e1a8 <USBH_LL_Init+0x48>
  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
 801e196:	4806      	ldr	r0, [pc, #24]	; (801e1b0 <USBH_LL_Init+0x50>)
 801e198:	f7e8 f858 	bl	800624c <HAL_HCD_GetCurrentFrame>
 801e19c:	4601      	mov	r1, r0
 801e19e:	4620      	mov	r0, r4
 801e1a0:	f7f1 fb98 	bl	800f8d4 <USBH_LL_SetTimer>
}
 801e1a4:	2000      	movs	r0, #0
 801e1a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Error_Handler( );
 801e1a8:	f7f5 fb90 	bl	80138cc <Error_Handler>
 801e1ac:	e7f3      	b.n	801e196 <USBH_LL_Init+0x36>
 801e1ae:	bf00      	nop
 801e1b0:	20019224 	.word	0x20019224
 801e1b4:	40080000 	.word	0x40080000

0801e1b8 <USBH_LL_Start>:
  * @brief  Start the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
{
 801e1b8:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Start(phost->pData);
 801e1ba:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 801e1be:	f7e8 f80b 	bl	80061d8 <HAL_HCD_Start>
 801e1c2:	2803      	cmp	r0, #3
 801e1c4:	d802      	bhi.n	801e1cc <USBH_LL_Start+0x14>
 801e1c6:	4b02      	ldr	r3, [pc, #8]	; (801e1d0 <USBH_LL_Start+0x18>)
 801e1c8:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
 801e1ca:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_Start(phost->pData);
 801e1cc:	2002      	movs	r0, #2
}
 801e1ce:	bd08      	pop	{r3, pc}
 801e1d0:	0802b8c0 	.word	0x0802b8c0

0801e1d4 <USBH_LL_Stop>:
  * @brief  Stop the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
{
 801e1d4:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Stop(phost->pData);
 801e1d6:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 801e1da:	f7e8 f813 	bl	8006204 <HAL_HCD_Stop>
 801e1de:	2803      	cmp	r0, #3
 801e1e0:	d802      	bhi.n	801e1e8 <USBH_LL_Stop+0x14>
 801e1e2:	4b02      	ldr	r3, [pc, #8]	; (801e1ec <USBH_LL_Stop+0x18>)
 801e1e4:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
 
  return usb_status;
}
 801e1e6:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_Stop(phost->pData);
 801e1e8:	2002      	movs	r0, #2
}
 801e1ea:	bd08      	pop	{r3, pc}
 801e1ec:	0802b8c0 	.word	0x0802b8c0

0801e1f0 <USBH_LL_GetSpeed>:
  * @brief  Return the USB host speed from the low level driver.
  * @param  phost: Host handle
  * @retval USBH speeds
  */
USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
{
 801e1f0:	b508      	push	{r3, lr}
  USBH_SpeedTypeDef speed = USBH_SPEED_FULL;

  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
 801e1f2:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 801e1f6:	f7e8 f82d 	bl	8006254 <HAL_HCD_GetCurrentSpeed>
 801e1fa:	2802      	cmp	r0, #2
 801e1fc:	d802      	bhi.n	801e204 <USBH_LL_GetSpeed+0x14>
 801e1fe:	4b02      	ldr	r3, [pc, #8]	; (801e208 <USBH_LL_GetSpeed+0x18>)
 801e200:	5c18      	ldrb	r0, [r3, r0]
  default:
   speed = USBH_SPEED_FULL;
    break;
  }
  return  speed;
}
 801e202:	bd08      	pop	{r3, pc}
  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
 801e204:	2001      	movs	r0, #1
}
 801e206:	bd08      	pop	{r3, pc}
 801e208:	0802b8bc 	.word	0x0802b8bc

0801e20c <USBH_LL_ResetPort>:
  * @brief  Reset the Host port of the low level driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef *phost)
{
 801e20c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_ResetPort(phost->pData);
 801e20e:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 801e212:	f7e8 f809 	bl	8006228 <HAL_HCD_ResetPort>
 801e216:	2803      	cmp	r0, #3
 801e218:	d802      	bhi.n	801e220 <USBH_LL_ResetPort+0x14>
 801e21a:	4b02      	ldr	r3, [pc, #8]	; (801e224 <USBH_LL_ResetPort+0x18>)
 801e21c:	5c18      	ldrb	r0, [r3, r0]
  
  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
 801e21e:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_ResetPort(phost->pData);
 801e220:	2002      	movs	r0, #2
}
 801e222:	bd08      	pop	{r3, pc}
 801e224:	0802b8c0 	.word	0x0802b8c0

0801e228 <USBH_LL_GetLastXferSize>:
  * @param  pipe: Pipe index
  * @retval Packet size
  */
uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
 801e228:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 801e22c:	f7e8 b808 	b.w	8006240 <HAL_HCD_HC_GetXferCount>

0801e230 <USBH_LL_OpenPipe>:
  * @param  mps: Endpoint max packet size
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num, uint8_t epnum,
                                    uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 801e230:	b530      	push	{r4, r5, lr}
 801e232:	b085      	sub	sp, #20
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 801e234:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
{
 801e238:	f89d 4020 	ldrb.w	r4, [sp, #32]
 801e23c:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 801e240:	9400      	str	r4, [sp, #0]
{
 801e242:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 801e246:	e9cd 5401 	strd	r5, r4, [sp, #4]
 801e24a:	f7e7 fb0d 	bl	8005868 <HAL_HCD_HC_Init>
 801e24e:	2803      	cmp	r0, #3
 801e250:	d803      	bhi.n	801e25a <USBH_LL_OpenPipe+0x2a>
 801e252:	4b03      	ldr	r3, [pc, #12]	; (801e260 <USBH_LL_OpenPipe+0x30>)
 801e254:	5c18      	ldrb	r0, [r3, r0]
                               dev_address, speed, ep_type, mps);

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
 801e256:	b005      	add	sp, #20
 801e258:	bd30      	pop	{r4, r5, pc}
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 801e25a:	2002      	movs	r0, #2
}
 801e25c:	b005      	add	sp, #20
 801e25e:	bd30      	pop	{r4, r5, pc}
 801e260:	0802b8c0 	.word	0x0802b8c0

0801e264 <USBH_LL_ClosePipe>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 801e264:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
 801e266:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 801e26a:	f7e7 fb39 	bl	80058e0 <HAL_HCD_HC_Halt>
 801e26e:	2803      	cmp	r0, #3
 801e270:	d802      	bhi.n	801e278 <USBH_LL_ClosePipe+0x14>
 801e272:	4b02      	ldr	r3, [pc, #8]	; (801e27c <USBH_LL_ClosePipe+0x18>)
 801e274:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
 801e276:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
 801e278:	2002      	movs	r0, #2
}
 801e27a:	bd08      	pop	{r3, pc}
 801e27c:	0802b8c0 	.word	0x0802b8c0

0801e280 <USBH_LL_SubmitURB>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t direction,
                                     uint8_t ep_type, uint8_t token, uint8_t *pbuff, uint16_t length,
                                     uint8_t do_ping)
{
 801e280:	b530      	push	{r4, r5, lr}
 801e282:	b085      	sub	sp, #20
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 801e284:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
{
 801e288:	f89d 5020 	ldrb.w	r5, [sp, #32]
 801e28c:	9c09      	ldr	r4, [sp, #36]	; 0x24
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 801e28e:	9500      	str	r5, [sp, #0]
 801e290:	9401      	str	r4, [sp, #4]
{
 801e292:	f8bd 5028 	ldrh.w	r5, [sp, #40]	; 0x28
 801e296:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 801e29a:	e9cd 5402 	strd	r5, r4, [sp, #8]
 801e29e:	f7e7 fb91 	bl	80059c4 <HAL_HCD_HC_SubmitRequest>
 801e2a2:	2803      	cmp	r0, #3
 801e2a4:	d803      	bhi.n	801e2ae <USBH_LL_SubmitURB+0x2e>
 801e2a6:	4b03      	ldr	r3, [pc, #12]	; (801e2b4 <USBH_LL_SubmitURB+0x34>)
 801e2a8:	5c18      	ldrb	r0, [r3, r0]
                                        ep_type, token, pbuff, length,
                                        do_ping);
  usb_status =  USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
 801e2aa:	b005      	add	sp, #20
 801e2ac:	bd30      	pop	{r4, r5, pc}
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 801e2ae:	2002      	movs	r0, #2
}
 801e2b0:	b005      	add	sp, #20
 801e2b2:	bd30      	pop	{r4, r5, pc}
 801e2b4:	0802b8c0 	.word	0x0802b8c0

0801e2b8 <USBH_LL_GetURBState>:
  *            @arg URB_ERROR
  *            @arg URB_STALL
  */
USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
 801e2b8:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 801e2bc:	f7e7 bfb8 	b.w	8006230 <HAL_HCD_HC_GetURBState>

0801e2c0 <USBH_LL_DriverVBUS>:
  *           0 : VBUS Active
  *           1 : VBUS Inactive
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
{
 801e2c0:	b508      	push	{r3, lr}
  if (phost->id == HOST_FS) {
 801e2c2:	f890 353c 	ldrb.w	r3, [r0, #1340]	; 0x53c
 801e2c6:	2b01      	cmp	r3, #1
 801e2c8:	d004      	beq.n	801e2d4 <USBH_LL_DriverVBUS+0x14>

  /* USER CODE BEGIN 0 */

  /* USER CODE END 0*/

  HAL_Delay(200);
 801e2ca:	20c8      	movs	r0, #200	; 0xc8
 801e2cc:	f7e2 fbb2 	bl	8000a34 <HAL_Delay>
  return USBH_OK;
}
 801e2d0:	2000      	movs	r0, #0
 801e2d2:	bd08      	pop	{r3, pc}
    MX_DriverVbusFS(state);
 801e2d4:	4608      	mov	r0, r1
 801e2d6:	f000 f819 	bl	801e30c <MX_DriverVbusFS>
  HAL_Delay(200);
 801e2da:	20c8      	movs	r0, #200	; 0xc8
 801e2dc:	f7e2 fbaa 	bl	8000a34 <HAL_Delay>
}
 801e2e0:	2000      	movs	r0, #0
 801e2e2:	bd08      	pop	{r3, pc}

0801e2e4 <USBH_LL_SetToggle>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)
{
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
 801e2e4:	f8d0 3540 	ldr.w	r3, [r0, #1344]	; 0x540

  if(pHandle->hc[pipe].ep_is_in)
 801e2e8:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 801e2ec:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 801e2f0:	f891 303b 	ldrb.w	r3, [r1, #59]	; 0x3b
 801e2f4:	b91b      	cbnz	r3, 801e2fe <USBH_LL_SetToggle+0x1a>
  {
    pHandle->hc[pipe].toggle_in = toggle;
  }
  else
  {
    pHandle->hc[pipe].toggle_out = toggle;
 801e2f6:	f881 2051 	strb.w	r2, [r1, #81]	; 0x51
  }

  return USBH_OK;
}
 801e2fa:	2000      	movs	r0, #0
 801e2fc:	4770      	bx	lr
    pHandle->hc[pipe].toggle_in = toggle;
 801e2fe:	f881 2050 	strb.w	r2, [r1, #80]	; 0x50
}
 801e302:	2000      	movs	r0, #0
 801e304:	4770      	bx	lr
 801e306:	bf00      	nop

0801e308 <USBH_Delay>:
  * @param  Delay: Delay in ms
  * @retval None
  */
void USBH_Delay(uint32_t Delay)
{
  HAL_Delay(Delay);
 801e308:	f7e2 bb94 	b.w	8000a34 <HAL_Delay>

0801e30c <MX_DriverVbusFS>:
  {
    /* Drive low Charge pump */
    data = GPIO_PIN_RESET;
  }
  /* USER CODE END PREPARE_GPIO_DATA_VBUS_FS */
  HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,(GPIO_PinState)data);
 801e30c:	fab0 f280 	clz	r2, r0
 801e310:	2140      	movs	r1, #64	; 0x40
 801e312:	4802      	ldr	r0, [pc, #8]	; (801e31c <MX_DriverVbusFS+0x10>)
 801e314:	0952      	lsrs	r2, r2, #5
 801e316:	f7e7 ba8d 	b.w	8005834 <HAL_GPIO_WritePin>
 801e31a:	bf00      	nop
 801e31c:	58021400 	.word	0x58021400

0801e320 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 801e320:	f8df d034 	ldr.w	sp, [pc, #52]	; 801e358 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 801e324:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 801e326:	e003      	b.n	801e330 <LoopCopyDataInit>

0801e328 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 801e328:	4b0c      	ldr	r3, [pc, #48]	; (801e35c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 801e32a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 801e32c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 801e32e:	3104      	adds	r1, #4

0801e330 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 801e330:	480b      	ldr	r0, [pc, #44]	; (801e360 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 801e332:	4b0c      	ldr	r3, [pc, #48]	; (801e364 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 801e334:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 801e336:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 801e338:	d3f6      	bcc.n	801e328 <CopyDataInit>
  ldr  r2, =_sbss
 801e33a:	4a0b      	ldr	r2, [pc, #44]	; (801e368 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 801e33c:	e002      	b.n	801e344 <LoopFillZerobss>

0801e33e <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 801e33e:	2300      	movs	r3, #0
  str  r3, [r2], #4
 801e340:	f842 3b04 	str.w	r3, [r2], #4

0801e344 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 801e344:	4b09      	ldr	r3, [pc, #36]	; (801e36c <LoopFillZerobss+0x28>)
  cmp  r2, r3
 801e346:	429a      	cmp	r2, r3
  bcc  FillZerobss
 801e348:	d3f9      	bcc.n	801e33e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 801e34a:	f7fd fe9d 	bl	801c088 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 801e34e:	f008 fdfd 	bl	8026f4c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 801e352:	f7f5 f98f 	bl	8013674 <main>
  bx  lr    
 801e356:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 801e358:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 801e35c:	0804b9e0 	.word	0x0804b9e0
  ldr  r0, =_sdata
 801e360:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 801e364:	200004a8 	.word	0x200004a8
  ldr  r2, =_sbss
 801e368:	200004a8 	.word	0x200004a8
  ldr  r3, = _ebss
 801e36c:	20019528 	.word	0x20019528

0801e370 <ADC3_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 801e370:	e7fe      	b.n	801e370 <ADC3_IRQHandler>
 801e372:	0000      	movs	r0, r0
 801e374:	0000      	movs	r0, r0
	...

0801e378 <mayer_fht>:
 REAL f0,g0,f1,g1,f2,g2,f3,g3; */
 int  k,k1,k2,k3,k4,kx;
 REAL *fi,*fn,*gi;
 TRIG_VARS;

 for (k1=1,k2=0;k1<n;k1++)
 801e378:	2901      	cmp	r1, #1
{
 801e37a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e37e:	ed2d 8b02 	vpush	{d8}
 801e382:	b08b      	sub	sp, #44	; 0x2c
 for (k1=1,k2=0;k1<n;k1++)
 801e384:	f340 822e 	ble.w	801e7e4 <mayer_fht+0x46c>
    {
     REAL aa;
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
 801e388:	ea4f 0c61 	mov.w	ip, r1, asr #1
 801e38c:	1d07      	adds	r7, r0, #4
 for (k1=1,k2=0;k1<n;k1++)
 801e38e:	2400      	movs	r4, #0
 801e390:	2601      	movs	r6, #1
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
 801e392:	ea3c 0304 	bics.w	r3, ip, r4
 801e396:	ea8c 0204 	eor.w	r2, ip, r4
 801e39a:	f040 8221 	bne.w	801e7e0 <mayer_fht+0x468>
 801e39e:	4663      	mov	r3, ip
 801e3a0:	105b      	asrs	r3, r3, #1
 801e3a2:	ea83 0402 	eor.w	r4, r3, r2
 801e3a6:	ea23 0502 	bic.w	r5, r3, r2
 801e3aa:	4622      	mov	r2, r4
 801e3ac:	2d00      	cmp	r5, #0
 801e3ae:	d0f7      	beq.n	801e3a0 <mayer_fht+0x28>
     if (k1>k2)
 801e3b0:	42a6      	cmp	r6, r4
 801e3b2:	dd05      	ble.n	801e3c0 <mayer_fht+0x48>
        {
             aa=fz[k1];fz[k1]=fz[k2];fz[k2]=aa;
 801e3b4:	eb00 0384 	add.w	r3, r0, r4, lsl #2
 801e3b8:	683a      	ldr	r2, [r7, #0]
 801e3ba:	681d      	ldr	r5, [r3, #0]
 801e3bc:	603d      	str	r5, [r7, #0]
 801e3be:	601a      	str	r2, [r3, #0]
 for (k1=1,k2=0;k1<n;k1++)
 801e3c0:	3601      	adds	r6, #1
 801e3c2:	3704      	adds	r7, #4
 801e3c4:	42b1      	cmp	r1, r6
 801e3c6:	d1e4      	bne.n	801e392 <mayer_fht+0x1a>
        }
    }
 for ( k=0 ; (1<<k)<n ; k++ );
 801e3c8:	2300      	movs	r3, #0
 801e3ca:	2401      	movs	r4, #1
 801e3cc:	3301      	adds	r3, #1
 801e3ce:	fa04 f203 	lsl.w	r2, r4, r3
 801e3d2:	42b2      	cmp	r2, r6
 801e3d4:	dbfa      	blt.n	801e3cc <mayer_fht+0x54>
 k  &= 1;
 if (k==0)
 801e3d6:	f013 0301 	ands.w	r3, r3, #1
 801e3da:	eb00 0a86 	add.w	sl, r0, r6, lsl #2
 801e3de:	9301      	str	r3, [sp, #4]
 801e3e0:	f000 8202 	beq.w	801e7e8 <mayer_fht+0x470>
             fi[1 ] = (f1+f3);
            }
    }
 else
    {
         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)
 801e3e4:	4550      	cmp	r0, sl
 801e3e6:	d266      	bcs.n	801e4b6 <mayer_fht+0x13e>
 801e3e8:	f100 0320 	add.w	r3, r0, #32
 801e3ec:	f100 0440 	add.w	r4, r0, #64	; 0x40
 801e3f0:	f1c3 021f 	rsb	r2, r3, #31
 801e3f4:	4452      	add	r2, sl
 801e3f6:	f022 021f 	bic.w	r2, r2, #31
             bf0     = (bs1 + bs2);
             bg1     = (bc1 - bc2);     
             bg0     = (bc1 + bc2);
             bf3     = (bs3 - bs4);     
             bf2     = (bs3 + bs4);
             bg3     = SQRT2*bc4;               
 801e3fa:	ed9f 3be7 	vldr	d3, [pc, #924]	; 801e798 <mayer_fht+0x420>
 801e3fe:	4422      	add	r2, r4
             bc3     = fi[4 ] - gi[4 ];
 801e400:	ed53 7a03 	vldr	s15, [r3, #-12]
 801e404:	3320      	adds	r3, #32
             bc4     = fi[6 ] - gi[6 ];
 801e406:	ed13 6a0a 	vldr	s12, [r3, #-40]	; 0xffffffd8
 801e40a:	ed13 7a09 	vldr	s14, [r3, #-36]	; 0xffffffdc
             bc3     = fi[4 ] - gi[4 ];
 801e40e:	ed53 6a0c 	vldr	s13, [r3, #-48]	; 0xffffffd0
             bc4     = fi[6 ] - gi[6 ];
 801e412:	ee36 2a47 	vsub.f32	s4, s12, s14
             bc1     = fi[0 ] - gi[0 ];
 801e416:	ed53 5a0f 	vldr	s11, [r3, #-60]	; 0xffffffc4
             bc3     = fi[4 ] - gi[4 ];
 801e41a:	ee36 0ae7 	vsub.f32	s0, s13, s15
             bc2     = fi[2 ] - gi[2 ];
 801e41e:	ed53 4a0e 	vldr	s9, [r3, #-56]	; 0xffffffc8
             bc1     = fi[0 ] - gi[0 ];
 801e422:	ed13 5a10 	vldr	s10, [r3, #-64]	; 0xffffffc0
             bs3     = fi[4 ] + gi[4 ];
 801e426:	ee76 6aa7 	vadd.f32	s13, s13, s15
             bg3     = SQRT2*bc4;               
 801e42a:	eeb7 2ac2 	vcvt.f64.f32	d2, s4
             bc2     = fi[2 ] - gi[2 ];
 801e42e:	ed53 7a0d 	vldr	s15, [r3, #-52]	; 0xffffffcc
             bg2     = SQRT2*bc3;
 801e432:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
             bc1     = fi[0 ] - gi[0 ];
 801e436:	ee75 1a65 	vsub.f32	s3, s10, s11
             bg3     = SQRT2*bc4;               
 801e43a:	ee22 2b03 	vmul.f64	d2, d2, d3
             bg2     = SQRT2*bc3;
 801e43e:	ee20 0b03 	vmul.f64	d0, d0, d3
             bc2     = fi[2 ] - gi[2 ];
 801e442:	ee34 4ae7 	vsub.f32	s8, s9, s15
             bs1     = fi[0 ] + gi[0 ];
 801e446:	ee35 5a25 	vadd.f32	s10, s10, s11
             bg3     = SQRT2*bc4;               
 801e44a:	eeb7 2bc2 	vcvt.f32.f64	s4, d2
             bs2     = fi[2 ] + gi[2 ];
 801e44e:	ee74 5aa7 	vadd.f32	s11, s9, s15
             bg2     = SQRT2*bc3;
 801e452:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
             bs4     = fi[6 ] + gi[6 ];
 801e456:	ee76 7a07 	vadd.f32	s15, s12, s14
             bg0     = (bc1 + bc2);
 801e45a:	ee31 1a84 	vadd.f32	s2, s3, s8
             bg1     = (bc1 - bc2);     
 801e45e:	ee71 4ac4 	vsub.f32	s9, s3, s8
             bf1     = (bs1 - bs2);     
 801e462:	ee35 7a65 	vsub.f32	s14, s10, s11
             bf2     = (bs3 + bs4);
 801e466:	ee36 6aa7 	vadd.f32	s12, s13, s15
             bf0     = (bs1 + bs2);
 801e46a:	ee75 5a25 	vadd.f32	s11, s10, s11
             bf3     = (bs3 - bs4);     
 801e46e:	ee76 7ae7 	vsub.f32	s15, s13, s15
             fi[4 ] = bf0 - bf2;
             fi[0 ] = bf0 + bf2;
             fi[6 ] = bf1 - bf3;
             fi[2 ] = bf1 + bf3;
             gi[4 ] = bg0 - bg2;
 801e472:	ee31 5a40 	vsub.f32	s10, s2, s0
             gi[0 ] = bg0 + bg2;
             gi[6 ] = bg1 - bg3;
 801e476:	ee74 6ac2 	vsub.f32	s13, s9, s4
             gi[0 ] = bg0 + bg2;
 801e47a:	ee31 0a00 	vadd.f32	s0, s2, s0
             gi[4 ] = bg0 - bg2;
 801e47e:	ed03 5a0b 	vstr	s10, [r3, #-44]	; 0xffffffd4
             gi[2 ] = bg1 + bg3;
 801e482:	ee34 2a82 	vadd.f32	s4, s9, s4
             gi[6 ] = bg1 - bg3;
 801e486:	ed43 6a09 	vstr	s13, [r3, #-36]	; 0xffffffdc
             fi[4 ] = bf0 - bf2;
 801e48a:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[6 ] = bf1 - bf3;
 801e48e:	ee77 6a67 	vsub.f32	s13, s14, s15
             gi[0 ] = bg0 + bg2;
 801e492:	ed03 0a0f 	vstr	s0, [r3, #-60]	; 0xffffffc4
             fi[0 ] = bf0 + bf2;
 801e496:	ee35 6a86 	vadd.f32	s12, s11, s12
             gi[2 ] = bg1 + bg3;
 801e49a:	ed03 2a0d 	vstr	s4, [r3, #-52]	; 0xffffffcc
             fi[2 ] = bf1 + bf3;
 801e49e:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[4 ] = bf0 - bf2;
 801e4a2:	ed03 5a0c 	vstr	s10, [r3, #-48]	; 0xffffffd0
             fi[6 ] = bf1 - bf3;
 801e4a6:	ed43 6a0a 	vstr	s13, [r3, #-40]	; 0xffffffd8
             fi[0 ] = bf0 + bf2;
 801e4aa:	ed03 6a10 	vstr	s12, [r3, #-64]	; 0xffffffc0
             fi[2 ] = bf1 + bf3;
 801e4ae:	ed43 7a0e 	vstr	s15, [r3, #-56]	; 0xffffffc8
         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)
 801e4b2:	429a      	cmp	r2, r3
 801e4b4:	d1a4      	bne.n	801e400 <mayer_fht+0x88>
            }
    }
 if (n<16) return;
 801e4b6:	290f      	cmp	r1, #15
 801e4b8:	f340 818d 	ble.w	801e7d6 <mayer_fht+0x45e>
 801e4bc:	9b01      	ldr	r3, [sp, #4]
 801e4be:	3301      	adds	r3, #1
             fi[0 ]  = f0         + f2;
             fi[k3]  = f1         - f3;
             fi[k1]  = f1         + f3;
             g1      = gi[0 ] - gi[k1];
             g0      = gi[0 ] + gi[k1];
             g3      = SQRT2  * gi[k3];
 801e4c0:	ed9f 8bb5 	vldr	d8, [pc, #724]	; 801e798 <mayer_fht+0x420>
 801e4c4:	009b      	lsls	r3, r3, #2
 801e4c6:	e9cd 0108 	strd	r0, r1, [sp, #32]
 801e4ca:	9306      	str	r3, [sp, #24]
     k  += 2;
 801e4cc:	9901      	ldr	r1, [sp, #4]
     k1  = 1  << k;
 801e4ce:	2501      	movs	r5, #1
             f1      = fi[0 ] - fi[k1];
 801e4d0:	2204      	movs	r2, #4
             g2      = SQRT2  * gi[k2];
             gi[k2]  = g0         - g2;
             gi[0 ]  = g0         + g2;
             gi[k3]  = g1         - g3;
             gi[k1]  = g1         + g3;
             gi     += k4;
 801e4d2:	9808      	ldr	r0, [sp, #32]
     k  += 2;
 801e4d4:	3102      	adds	r1, #2
             gi     += k4;
 801e4d6:	4603      	mov	r3, r0
     k1  = 1  << k;
 801e4d8:	408d      	lsls	r5, r1
             f1      = fi[0 ] - fi[k1];
 801e4da:	fa02 f401 	lsl.w	r4, r2, r1
     k  += 2;
 801e4de:	9101      	str	r1, [sp, #4]
     kx  = k1 >> 1;
 801e4e0:	106f      	asrs	r7, r5, #1
 801e4e2:	eb00 0e04 	add.w	lr, r0, r4
     k3  = k2 + k1;
 801e4e6:	eb05 0145 	add.w	r1, r5, r5, lsl #1
             f1      = fi[0 ] - fi[k1];
 801e4ea:	9403      	str	r4, [sp, #12]
         gi  = fi + kx;
 801e4ec:	eb00 0287 	add.w	r2, r0, r7, lsl #2
     kx  = k1 >> 1;
 801e4f0:	9702      	str	r7, [sp, #8]
             f3      = fi[k2] - fi[k3];
 801e4f2:	0089      	lsls	r1, r1, #2
 801e4f4:	00ee      	lsls	r6, r5, #3
 801e4f6:	eb02 0c04 	add.w	ip, r2, r4
 801e4fa:	460c      	mov	r4, r1
 801e4fc:	9105      	str	r1, [sp, #20]
 801e4fe:	9604      	str	r6, [sp, #16]
 801e500:	1857      	adds	r7, r2, r1
 801e502:	1906      	adds	r6, r0, r4
 801e504:	4601      	mov	r1, r0
 801e506:	00ec      	lsls	r4, r5, #3
 801e508:	1910      	adds	r0, r2, r4
 801e50a:	4421      	add	r1, r4
     k4  = k2 << 1;
 801e50c:	00ac      	lsls	r4, r5, #2
 801e50e:	9407      	str	r4, [sp, #28]
             gi     += k4;
 801e510:	012c      	lsls	r4, r5, #4
             f1      = fi[0 ] - fi[k1];
 801e512:	ed93 6a00 	vldr	s12, [r3]
             f3      = fi[k2] - fi[k3];
 801e516:	edd6 6a00 	vldr	s13, [r6]
             f1      = fi[0 ] - fi[k1];
 801e51a:	ed9e 7a00 	vldr	s14, [lr]
             f3      = fi[k2] - fi[k3];
 801e51e:	edd1 7a00 	vldr	s15, [r1]
             f0      = fi[0 ] + fi[k1];
 801e522:	ee76 5a07 	vadd.f32	s11, s12, s14
             f1      = fi[0 ] - fi[k1];
 801e526:	ee36 7a47 	vsub.f32	s14, s12, s14
             f2      = fi[k2] + fi[k3];
 801e52a:	ee37 6aa6 	vadd.f32	s12, s15, s13
             f3      = fi[k2] - fi[k3];
 801e52e:	ee77 7ae6 	vsub.f32	s15, s15, s13
             fi[k2]  = f0         - f2;
 801e532:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[k3]  = f1         - f3;
 801e536:	ee77 6a67 	vsub.f32	s13, s14, s15
             fi[0 ]  = f0         + f2;
 801e53a:	ee35 6a86 	vadd.f32	s12, s11, s12
             fi[k1]  = f1         + f3;
 801e53e:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[k2]  = f0         - f2;
 801e542:	ed81 5a00 	vstr	s10, [r1]
 801e546:	4421      	add	r1, r4
             fi[0 ]  = f0         + f2;
 801e548:	ed83 6a00 	vstr	s12, [r3]
             fi     += k4;
 801e54c:	4423      	add	r3, r4
             fi[k3]  = f1         - f3;
 801e54e:	edc6 6a00 	vstr	s13, [r6]
 801e552:	4426      	add	r6, r4
             fi[k1]  = f1         + f3;
 801e554:	edce 7a00 	vstr	s15, [lr]
            } while (fi<fn);
 801e558:	4553      	cmp	r3, sl
             g2      = SQRT2  * gi[k2];
 801e55a:	ed90 5a00 	vldr	s10, [r0]
 801e55e:	44a6      	add	lr, r4
             g3      = SQRT2  * gi[k3];
 801e560:	ed97 7a00 	vldr	s14, [r7]
             g2      = SQRT2  * gi[k2];
 801e564:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
             g1      = gi[0 ] - gi[k1];
 801e568:	ed92 6a00 	vldr	s12, [r2]
             g3      = SQRT2  * gi[k3];
 801e56c:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
             g1      = gi[0 ] - gi[k1];
 801e570:	eddc 6a00 	vldr	s13, [ip]
             g2      = SQRT2  * gi[k2];
 801e574:	ee25 5b08 	vmul.f64	d5, d5, d8
             g3      = SQRT2  * gi[k3];
 801e578:	ee27 7b08 	vmul.f64	d7, d7, d8
             g2      = SQRT2  * gi[k2];
 801e57c:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
             g0      = gi[0 ] + gi[k1];
 801e580:	ee76 5a26 	vadd.f32	s11, s12, s13
             g1      = gi[0 ] - gi[k1];
 801e584:	ee76 6a66 	vsub.f32	s13, s12, s13
             g3      = SQRT2  * gi[k3];
 801e588:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
             gi[k2]  = g0         - g2;
 801e58c:	ee35 6ac5 	vsub.f32	s12, s11, s10
             gi[0 ]  = g0         + g2;
 801e590:	ee35 5a85 	vadd.f32	s10, s11, s10
             gi[k3]  = g1         - g3;
 801e594:	ee76 7ac7 	vsub.f32	s15, s13, s14
             gi[k1]  = g1         + g3;
 801e598:	ee36 7a87 	vadd.f32	s14, s13, s14
             gi[k2]  = g0         - g2;
 801e59c:	ed80 6a00 	vstr	s12, [r0]
             gi[0 ]  = g0         + g2;
 801e5a0:	ed82 5a00 	vstr	s10, [r2]
 801e5a4:	4420      	add	r0, r4
             gi[k3]  = g1         - g3;
 801e5a6:	edc7 7a00 	vstr	s15, [r7]
             gi     += k4;
 801e5aa:	4422      	add	r2, r4
             gi[k1]  = g1         + g3;
 801e5ac:	ed8c 7a00 	vstr	s14, [ip]
 801e5b0:	4427      	add	r7, r4
 801e5b2:	44a4      	add	ip, r4
            } while (fi<fn);
 801e5b4:	d3ad      	bcc.n	801e512 <mayer_fht+0x19a>
     TRIG_INIT(k,c1,s1);
 801e5b6:	9b01      	ldr	r3, [sp, #4]
 801e5b8:	2b01      	cmp	r3, #1
 801e5ba:	dd0a      	ble.n	801e5d2 <mayer_fht+0x25a>
 801e5bc:	9e06      	ldr	r6, [sp, #24]
 801e5be:	4978      	ldr	r1, [pc, #480]	; (801e7a0 <mayer_fht+0x428>)
 801e5c0:	4632      	mov	r2, r6
 801e5c2:	4878      	ldr	r0, [pc, #480]	; (801e7a4 <mayer_fht+0x42c>)
 801e5c4:	f008 fd00 	bl	8026fc8 <memcpy>
 801e5c8:	4632      	mov	r2, r6
 801e5ca:	4977      	ldr	r1, [pc, #476]	; (801e7a8 <mayer_fht+0x430>)
 801e5cc:	4877      	ldr	r0, [pc, #476]	; (801e7ac <mayer_fht+0x434>)
 801e5ce:	f008 fcfb 	bl	8026fc8 <memcpy>
     for (ii=1;ii<kx;ii++)
 801e5d2:	9b02      	ldr	r3, [sp, #8]
 801e5d4:	2b01      	cmp	r3, #1
 801e5d6:	f340 80f6 	ble.w	801e7c6 <mayer_fht+0x44e>
 801e5da:	f06f 4840 	mvn.w	r8, #3221225472	; 0xc0000000
 801e5de:	9a08      	ldr	r2, [sp, #32]
        {
         REAL c2,s2;
         TRIG_NEXT(k,c1,s1);
 801e5e0:	f04f 0e01 	mov.w	lr, #1
 801e5e4:	2300      	movs	r3, #0
 801e5e6:	44a8      	add	r8, r5
 801e5e8:	f102 0904 	add.w	r9, r2, #4
 801e5ec:	f8df b1c8 	ldr.w	fp, [pc, #456]	; 801e7b8 <mayer_fht+0x440>
 801e5f0:	eb02 0888 	add.w	r8, r2, r8, lsl #2
 801e5f4:	9a01      	ldr	r2, [sp, #4]
 801e5f6:	486e      	ldr	r0, [pc, #440]	; (801e7b0 <mayer_fht+0x438>)
 801e5f8:	1ad2      	subs	r2, r2, r3
 801e5fa:	0091      	lsls	r1, r2, #2
 801e5fc:	2a01      	cmp	r2, #1
 801e5fe:	eb0b 0501 	add.w	r5, fp, r1
 801e602:	4408      	add	r0, r1
 801e604:	ed95 2a00 	vldr	s4, [r5]
 801e608:	edd0 2a00 	vldr	s5, [r0]
 801e60c:	dd30      	ble.n	801e670 <mayer_fht+0x2f8>
 801e60e:	3302      	adds	r3, #2
 801e610:	fa4e f003 	asr.w	r0, lr, r3
 801e614:	07c5      	lsls	r5, r0, #31
 801e616:	d504      	bpl.n	801e622 <mayer_fht+0x2aa>
 801e618:	3301      	adds	r3, #1
 801e61a:	fa4e f003 	asr.w	r0, lr, r3
 801e61e:	07c0      	lsls	r0, r0, #31
 801e620:	d4fa      	bmi.n	801e618 <mayer_fht+0x2a0>
 801e622:	9801      	ldr	r0, [sp, #4]
 801e624:	3a01      	subs	r2, #1
 801e626:	4e62      	ldr	r6, [pc, #392]	; (801e7b0 <mayer_fht+0x438>)
 801e628:	1ac3      	subs	r3, r0, r3
 801e62a:	4862      	ldr	r0, [pc, #392]	; (801e7b4 <mayer_fht+0x43c>)
 801e62c:	0092      	lsls	r2, r2, #2
 801e62e:	4408      	add	r0, r1
 801e630:	009b      	lsls	r3, r3, #2
 801e632:	eb0b 0502 	add.w	r5, fp, r2
 801e636:	4432      	add	r2, r6
 801e638:	edd0 7a00 	vldr	s15, [r0]
 801e63c:	eb0b 0003 	add.w	r0, fp, r3
 801e640:	4433      	add	r3, r6
 801e642:	edd2 6a00 	vldr	s13, [r2]
 801e646:	ed90 6a00 	vldr	s12, [r0]
 801e64a:	eb0b 0001 	add.w	r0, fp, r1
 801e64e:	edd5 5a00 	vldr	s11, [r5]
 801e652:	4431      	add	r1, r6
 801e654:	ed93 7a00 	vldr	s14, [r3]
 801e658:	ee35 6a86 	vadd.f32	s12, s11, s12
 801e65c:	ee36 7a87 	vadd.f32	s14, s13, s14
 801e660:	ee66 6a27 	vmul.f32	s13, s12, s15
 801e664:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e668:	edc0 6a00 	vstr	s13, [r0]
 801e66c:	edc1 7a00 	vstr	s15, [r1]
 801e670:	9a03      	ldr	r2, [sp, #12]
         c2 = c1*c1 - s1*s1;
 801e672:	ee22 3a42 	vnmul.f32	s6, s4, s4
         s2 = 2*(c1*s1);
 801e676:	ee62 3a22 	vmul.f32	s7, s4, s5
             fn = fz + n;
             fi = fz +ii;
 801e67a:	464b      	mov	r3, r9
 801e67c:	eb02 0709 	add.w	r7, r2, r9
 801e680:	eb02 0608 	add.w	r6, r2, r8
 801e684:	9a05      	ldr	r2, [sp, #20]
         c2 = c1*c1 - s1*s1;
 801e686:	eea2 3aa2 	vfma.f32	s6, s5, s5
         s2 = 2*(c1*s1);
 801e68a:	ee73 3aa3 	vadd.f32	s7, s7, s7
             gi = fz +k1-ii;
 801e68e:	46c4      	mov	ip, r8
 801e690:	eb02 0509 	add.w	r5, r2, r9
 801e694:	eb02 0008 	add.w	r0, r2, r8
 801e698:	9a04      	ldr	r2, [sp, #16]
 801e69a:	4611      	mov	r1, r2
 801e69c:	4442      	add	r2, r8
 801e69e:	4449      	add	r1, r9
                 a       = c2*fi[k1] + s2*gi[k1];
                 f1      = fi[0 ]    - a;
                 f0      = fi[0 ]    + a;
                 g1      = gi[0 ]    - b;
                 g0      = gi[0 ]    + b;
                 b       = s2*fi[k3] - c2*gi[k3];
 801e6a0:	edd0 4a00 	vldr	s9, [r0]
 801e6a4:	edd5 7a00 	vldr	s15, [r5]
 801e6a8:	ee63 1a64 	vnmul.f32	s3, s6, s9
                 a       = c2*fi[k3] + s2*gi[k3];
                 f3      = fi[k2]    - a;
                 f2      = fi[k2]    + a;
                 g3      = gi[k2]    - b;
 801e6ac:	ed92 1a00 	vldr	s2, [r2]
                 a       = c2*fi[k3] + s2*gi[k3];
 801e6b0:	ee64 4aa3 	vmul.f32	s9, s9, s7
                 b       = s2*fi[k1] - c2*gi[k1];
 801e6b4:	edd6 5a00 	vldr	s11, [r6]
                 f3      = fi[k2]    - a;
 801e6b8:	ed91 6a00 	vldr	s12, [r1]
                 b       = s2*fi[k3] - c2*gi[k3];
 801e6bc:	eee7 1aa3 	vfma.f32	s3, s15, s7
                 b       = s2*fi[k1] - c2*gi[k1];
 801e6c0:	ed97 0a00 	vldr	s0, [r7]
                 a       = c2*fi[k3] + s2*gi[k3];
 801e6c4:	eee7 4a83 	vfma.f32	s9, s15, s6
                 f1      = fi[0 ]    - a;
 801e6c8:	edd3 6a00 	vldr	s13, [r3]
                 a       = c2*fi[k1] + s2*gi[k1];
 801e6cc:	ee25 7aa3 	vmul.f32	s14, s11, s7
                 g1      = gi[0 ]    - b;
 801e6d0:	ed9c 5a00 	vldr	s10, [ip]
                 b       = s2*fi[k1] - c2*gi[k1];
 801e6d4:	ee63 5a65 	vnmul.f32	s11, s6, s11
                 a       = c2*fi[k1] + s2*gi[k1];
 801e6d8:	eea0 7a03 	vfma.f32	s14, s0, s6
                 g3      = gi[k2]    - b;
 801e6dc:	ee31 4a61 	vsub.f32	s8, s2, s3
                 f3      = fi[k2]    - a;
 801e6e0:	ee76 7a64 	vsub.f32	s15, s12, s9
                 g2      = gi[k2]    + b;
 801e6e4:	ee71 1a21 	vadd.f32	s3, s2, s3
                 b       = s1*f2     - c1*g3;
                 a       = c1*f2     + s1*g3;
 801e6e8:	ee62 0a04 	vmul.f32	s1, s4, s8
                 f2      = fi[k2]    + a;
 801e6ec:	ee76 4a24 	vadd.f32	s9, s12, s9
                 b       = s1*f2     - c1*g3;
 801e6f0:	ee24 4a62 	vnmul.f32	s8, s8, s5
                 a       = c1*f2     + s1*g3;
 801e6f4:	eeb0 1a60 	vmov.f32	s2, s1
                 b       = s2*fi[k1] - c2*gi[k1];
 801e6f8:	eee0 5a23 	vfma.f32	s11, s0, s7
                 fi[k2]  = f0        - a;
                 fi[0 ]  = f0        + a;
                 gi[k3]  = g1        - b;
                 gi[k1]  = g1        + b;
                 b       = c1*g2     - s1*f3;
                 a       = s1*g2     + c1*f3;
 801e6fc:	ee22 6aa7 	vmul.f32	s12, s5, s15
                 a       = c1*f2     + s1*g3;
 801e700:	eea2 1aa4 	vfma.f32	s2, s5, s9
                 b       = s1*f2     - c1*g3;
 801e704:	eea2 4a24 	vfma.f32	s8, s4, s9
                 b       = c1*g2     - s1*f3;
 801e708:	ee67 7ac2 	vnmul.f32	s15, s15, s4
                 a       = s1*g2     + c1*f3;
 801e70c:	eea2 6a21 	vfma.f32	s12, s4, s3
                 b       = c1*g2     - s1*f3;
 801e710:	eee2 7aa1 	vfma.f32	s15, s5, s3
                 f0      = fi[0 ]    + a;
 801e714:	ee76 1a87 	vadd.f32	s3, s13, s14
                 b       = s1*f2     - c1*g3;
 801e718:	eef0 4a44 	vmov.f32	s9, s8
                 f1      = fi[0 ]    - a;
 801e71c:	ee36 7ac7 	vsub.f32	s14, s13, s14
                 g1      = gi[0 ]    - b;
 801e720:	ee35 4a65 	vsub.f32	s8, s10, s11
                 g0      = gi[0 ]    + b;
 801e724:	ee75 6a25 	vadd.f32	s13, s10, s11
                 fi[k2]  = f0        - a;
 801e728:	ee71 5ac1 	vsub.f32	s11, s3, s2
                 fi[0 ]  = f0        + a;
 801e72c:	ee31 1a81 	vadd.f32	s2, s3, s2
                 gi[k3]  = g1        - b;
 801e730:	ee34 5a64 	vsub.f32	s10, s8, s9
                 fi[k2]  = f0        - a;
 801e734:	edc1 5a00 	vstr	s11, [r1]
                 gi[k1]  = g1        + b;
 801e738:	ee74 4a24 	vadd.f32	s9, s8, s9
                 fi[0 ]  = f0        + a;
 801e73c:	ed83 1a00 	vstr	s2, [r3]
                 gi[k2]  = g0        - a;
                 gi[0 ]  = g0        + a;
                 fi[k3]  = f1        - b;
                 fi[k1]  = f1        + b;
                 gi     += k4;
                 fi     += k4;
 801e740:	4423      	add	r3, r4
                 gi[k2]  = g0        - a;
 801e742:	ee76 5ac6 	vsub.f32	s11, s13, s12
                 gi[k3]  = g1        - b;
 801e746:	ed80 5a00 	vstr	s10, [r0]
                 gi[0 ]  = g0        + a;
 801e74a:	ee36 6a86 	vadd.f32	s12, s13, s12
                } while (fi<fn);
 801e74e:	4553      	cmp	r3, sl
                 fi[k3]  = f1        - b;
 801e750:	ee77 6a67 	vsub.f32	s13, s14, s15
                 gi[k1]  = g1        + b;
 801e754:	edc6 4a00 	vstr	s9, [r6]
                 fi[k1]  = f1        + b;
 801e758:	ee77 7a27 	vadd.f32	s15, s14, s15
                 gi[k2]  = g0        - a;
 801e75c:	edc2 5a00 	vstr	s11, [r2]
 801e760:	4421      	add	r1, r4
                 gi[0 ]  = g0        + a;
 801e762:	ed8c 6a00 	vstr	s12, [ip]
 801e766:	4420      	add	r0, r4
                 fi[k3]  = f1        - b;
 801e768:	edc5 6a00 	vstr	s13, [r5]
 801e76c:	4426      	add	r6, r4
                 fi[k1]  = f1        + b;
 801e76e:	edc7 7a00 	vstr	s15, [r7]
 801e772:	4422      	add	r2, r4
                 gi     += k4;
 801e774:	44a4      	add	ip, r4
 801e776:	4425      	add	r5, r4
 801e778:	4427      	add	r7, r4
                } while (fi<fn);
 801e77a:	d391      	bcc.n	801e6a0 <mayer_fht+0x328>
     for (ii=1;ii<kx;ii++)
 801e77c:	f10e 0e01 	add.w	lr, lr, #1
 801e780:	9b02      	ldr	r3, [sp, #8]
 801e782:	4573      	cmp	r3, lr
 801e784:	d01f      	beq.n	801e7c6 <mayer_fht+0x44e>
         TRIG_NEXT(k,c1,s1);
 801e786:	f01e 0301 	ands.w	r3, lr, #1
 801e78a:	d15f      	bne.n	801e84c <mayer_fht+0x4d4>
 801e78c:	3301      	adds	r3, #1
 801e78e:	fa4e f203 	asr.w	r2, lr, r3
 801e792:	07d6      	lsls	r6, r2, #31
 801e794:	d5fa      	bpl.n	801e78c <mayer_fht+0x414>
 801e796:	e011      	b.n	801e7bc <mayer_fht+0x444>
 801e798:	667f3bcd 	.word	0x667f3bcd
 801e79c:	3ff6a09e 	.word	0x3ff6a09e
 801e7a0:	0802b8cc 	.word	0x0802b8cc
 801e7a4:	20000304 	.word	0x20000304
 801e7a8:	0802b96c 	.word	0x0802b96c
 801e7ac:	20000354 	.word	0x20000354
 801e7b0:	200002fc 	.word	0x200002fc
 801e7b4:	0802b914 	.word	0x0802b914
 801e7b8:	2000034c 	.word	0x2000034c
 801e7bc:	f109 0904 	add.w	r9, r9, #4
 801e7c0:	f1a8 0804 	sub.w	r8, r8, #4
 801e7c4:	e716      	b.n	801e5f4 <mayer_fht+0x27c>
 801e7c6:	9b06      	ldr	r3, [sp, #24]
        }
     TRIG_RESET(k,c1,s1);
    } while (k4<n);
 801e7c8:	9a07      	ldr	r2, [sp, #28]
 801e7ca:	3308      	adds	r3, #8
 801e7cc:	9306      	str	r3, [sp, #24]
 801e7ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e7d0:	4293      	cmp	r3, r2
 801e7d2:	f73f ae7b 	bgt.w	801e4cc <mayer_fht+0x154>
}
 801e7d6:	b00b      	add	sp, #44	; 0x2c
 801e7d8:	ecbd 8b02 	vpop	{d8}
 801e7dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
 801e7e0:	4614      	mov	r4, r2
 801e7e2:	e5e5      	b.n	801e3b0 <mayer_fht+0x38>
 801e7e4:	eb00 0a81 	add.w	sl, r0, r1, lsl #2
         for (fi=fz,fn=fz+n;fi<fn;fi+=4)
 801e7e8:	4582      	cmp	sl, r0
 801e7ea:	d92c      	bls.n	801e846 <mayer_fht+0x4ce>
 801e7ec:	f100 0310 	add.w	r3, r0, #16
 801e7f0:	f100 0420 	add.w	r4, r0, #32
 801e7f4:	f1c3 020f 	rsb	r2, r3, #15
 801e7f8:	4452      	add	r2, sl
 801e7fa:	f022 020f 	bic.w	r2, r2, #15
 801e7fe:	4422      	add	r2, r4
             f1     = fi[0 ]-fi[1 ];
 801e800:	ed13 6a03 	vldr	s12, [r3, #-12]
 801e804:	3310      	adds	r3, #16
             f3     = fi[2 ]-fi[3 ];
 801e806:	ed53 6a06 	vldr	s13, [r3, #-24]	; 0xffffffe8
             f1     = fi[0 ]-fi[1 ];
 801e80a:	ed53 5a08 	vldr	s11, [r3, #-32]	; 0xffffffe0
             f3     = fi[2 ]-fi[3 ];
 801e80e:	ed53 7a05 	vldr	s15, [r3, #-20]	; 0xffffffec
             f1     = fi[0 ]-fi[1 ];
 801e812:	ee35 7ac6 	vsub.f32	s14, s11, s12
             f0     = fi[0 ]+fi[1 ];
 801e816:	ee75 5a86 	vadd.f32	s11, s11, s12
             f2     = fi[2 ]+fi[3 ];
 801e81a:	ee36 6aa7 	vadd.f32	s12, s13, s15
             f3     = fi[2 ]-fi[3 ];
 801e81e:	ee76 7ae7 	vsub.f32	s15, s13, s15
             fi[2 ] = (f0-f2);  
 801e822:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[3 ] = (f1-f3);  
 801e826:	ee77 6a67 	vsub.f32	s13, s14, s15
             fi[0 ] = (f0+f2);
 801e82a:	ee35 6a86 	vadd.f32	s12, s11, s12
             fi[1 ] = (f1+f3);
 801e82e:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[2 ] = (f0-f2);  
 801e832:	ed03 5a06 	vstr	s10, [r3, #-24]	; 0xffffffe8
             fi[3 ] = (f1-f3);  
 801e836:	ed43 6a05 	vstr	s13, [r3, #-20]	; 0xffffffec
             fi[0 ] = (f0+f2);
 801e83a:	ed03 6a08 	vstr	s12, [r3, #-32]	; 0xffffffe0
             fi[1 ] = (f1+f3);
 801e83e:	ed43 7a07 	vstr	s15, [r3, #-28]	; 0xffffffe4
         for (fi=fz,fn=fz+n;fi<fn;fi+=4)
 801e842:	429a      	cmp	r2, r3
 801e844:	d1dc      	bne.n	801e800 <mayer_fht+0x488>
 801e846:	2300      	movs	r3, #0
 801e848:	9301      	str	r3, [sp, #4]
 801e84a:	e634      	b.n	801e4b6 <mayer_fht+0x13e>
         TRIG_NEXT(k,c1,s1);
 801e84c:	2300      	movs	r3, #0
 801e84e:	e7b5      	b.n	801e7bc <mayer_fht+0x444>

0801e850 <mayer_realfft>:
  real[i] = (q-t)*0.5;  real[j] = (q+t)*0.5;
 }
}

void mayer_realfft(int n, REAL *real)
{
 801e850:	b538      	push	{r3, r4, r5, lr}
 801e852:	460c      	mov	r4, r1
 801e854:	4605      	mov	r5, r0
    REAL a,b;
 int i,j,k;
 mayer_fht(real,n);
 801e856:	4601      	mov	r1, r0
 801e858:	4620      	mov	r0, r4
 801e85a:	f7ff fd8d 	bl	801e378 <mayer_fht>
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
 801e85e:	1e2a      	subs	r2, r5, #0
 801e860:	f105 33ff 	add.w	r3, r5, #4294967295	; 0xffffffff
 801e864:	bfb8      	it	lt
 801e866:	3201      	addlt	r2, #1
 801e868:	1052      	asrs	r2, r2, #1
 801e86a:	2a01      	cmp	r2, #1
 801e86c:	dd19      	ble.n	801e8a2 <mayer_realfft+0x52>
 801e86e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  a = real[i];
  b = real[j];
  real[j] = (a-b)*0.5;
 801e872:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 801e876:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 801e87a:	1d21      	adds	r1, r4, #4
 801e87c:	3304      	adds	r3, #4
  a = real[i];
 801e87e:	edd1 7a00 	vldr	s15, [r1]
  b = real[j];
 801e882:	ed73 6a01 	vldmdb	r3!, {s13}
  real[j] = (a-b)*0.5;
 801e886:	ee37 7ae6 	vsub.f32	s14, s15, s13
  real[i] = (a+b)*0.5;
 801e88a:	ee77 7aa6 	vadd.f32	s15, s15, s13
  real[j] = (a-b)*0.5;
 801e88e:	ee27 7a06 	vmul.f32	s14, s14, s12
  real[i] = (a+b)*0.5;
 801e892:	ee67 7a86 	vmul.f32	s15, s15, s12
  real[j] = (a-b)*0.5;
 801e896:	ed83 7a00 	vstr	s14, [r3]
  real[i] = (a+b)*0.5;
 801e89a:	ece1 7a01 	vstmia	r1!, {s15}
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
 801e89e:	428a      	cmp	r2, r1
 801e8a0:	d1ed      	bne.n	801e87e <mayer_realfft+0x2e>
 }
}
 801e8a2:	bd38      	pop	{r3, r4, r5, pc}

0801e8a4 <mayer_realifft>:

void mayer_realifft(int n, REAL *real)
{
    REAL a,b;
 int i,j,k;
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
 801e8a4:	2800      	cmp	r0, #0
 801e8a6:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
{
 801e8aa:	b410      	push	{r4}
 801e8ac:	460c      	mov	r4, r1
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
 801e8ae:	bfb4      	ite	lt
 801e8b0:	1c41      	addlt	r1, r0, #1
 801e8b2:	4601      	movge	r1, r0
 801e8b4:	1049      	asrs	r1, r1, #1
 801e8b6:	2901      	cmp	r1, #1
 801e8b8:	dd13      	ble.n	801e8e2 <mayer_realifft+0x3e>
 801e8ba:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 801e8be:	1d23      	adds	r3, r4, #4
 801e8c0:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 801e8c4:	3204      	adds	r2, #4
  a = real[i];
 801e8c6:	edd3 7a00 	vldr	s15, [r3]
  b = real[j];
 801e8ca:	ed32 7a01 	vldmdb	r2!, {s14}
  real[j] = (a-b);
 801e8ce:	ee77 6ac7 	vsub.f32	s13, s15, s14
  real[i] = (a+b);
 801e8d2:	ee77 7a87 	vadd.f32	s15, s15, s14
  real[j] = (a-b);
 801e8d6:	edc2 6a00 	vstr	s13, [r2]
  real[i] = (a+b);
 801e8da:	ece3 7a01 	vstmia	r3!, {s15}
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
 801e8de:	4299      	cmp	r1, r3
 801e8e0:	d1f1      	bne.n	801e8c6 <mayer_realifft+0x22>
 }
 mayer_fht(real,n);
 801e8e2:	4601      	mov	r1, r0
 801e8e4:	4620      	mov	r0, r4
}
 801e8e6:	f85d 4b04 	ldr.w	r4, [sp], #4
 mayer_fht(real,n);
 801e8ea:	f7ff bd45 	b.w	801e378 <mayer_fht>
 801e8ee:	bf00      	nop

0801e8f0 <tEnvelopeFollower_init>:
//===========================================================================
/* Envelope Follower */
//===========================================================================

void    tEnvelopeFollower_init(tEnvelopeFollower* const ef, float attackThreshold, float decayCoeff)
{
 801e8f0:	b538      	push	{r3, r4, r5, lr}
    tEnvelopeFollower_initToPool(ef, attackThreshold, decayCoeff, &leaf.mempool);
}

void    tEnvelopeFollower_initToPool    (tEnvelopeFollower* const ef, float attackThreshold, float decayCoeff, tMempool* const mp)
{
    _tMempool* m = *mp;
 801e8f2:	4b0c      	ldr	r3, [pc, #48]	; (801e924 <tEnvelopeFollower_init+0x34>)
{
 801e8f4:	4605      	mov	r5, r0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
 801e8f6:	2010      	movs	r0, #16
{
 801e8f8:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 801e8fc:	699c      	ldr	r4, [r3, #24]
{
 801e8fe:	eef0 8a40 	vmov.f32	s17, s0
 801e902:	eeb0 8a60 	vmov.f32	s16, s1
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
 801e906:	4621      	mov	r1, r4
 801e908:	f005 fcd6 	bl	80242b8 <mpool_alloc>
    e->mempool = m;
    
    e->y = 0.0f;
 801e90c:	2300      	movs	r3, #0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
 801e90e:	6028      	str	r0, [r5, #0]
    e->mempool = m;
 801e910:	6004      	str	r4, [r0, #0]
    e->a_thresh = attackThreshold;
 801e912:	edc0 8a02 	vstr	s17, [r0, #8]
    e->d_coeff = decayCoeff;
 801e916:	ed80 8a03 	vstr	s16, [r0, #12]
    e->y = 0.0f;
 801e91a:	6043      	str	r3, [r0, #4]
}
 801e91c:	ecbd 8b02 	vpop	{d8}
 801e920:	bd38      	pop	{r3, r4, r5, pc}
 801e922:	bf00      	nop
 801e924:	200194e8 	.word	0x200194e8

0801e928 <tEnvelopeFollower_free>:
}

void    tEnvelopeFollower_free  (tEnvelopeFollower* const ef)
{
    _tEnvelopeFollower* e = *ef;
 801e928:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)e, e->mempool);
 801e92a:	6801      	ldr	r1, [r0, #0]
 801e92c:	f005 bd78 	b.w	8024420 <mpool_free>

0801e930 <tEnvelopeFollower_tick>:
}

float   tEnvelopeFollower_tick(tEnvelopeFollower* const ef, float x)
{
    _tEnvelopeFollower* e = *ef;
 801e930:	6803      	ldr	r3, [r0, #0]
 801e932:	eeb0 0ac0 	vabs.f32	s0, s0
    
    if (x < 0.0f ) x = -x;  /* Absolute value. */
    
    if ((x >= e->y) && (x > e->a_thresh)) e->y = x;                      /* If we hit a peak, ride the peak to the top. */
 801e936:	edd3 7a01 	vldr	s15, [r3, #4]
 801e93a:	eef4 7ac0 	vcmpe.f32	s15, s0
 801e93e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e942:	d814      	bhi.n	801e96e <tEnvelopeFollower_tick+0x3e>
 801e944:	ed93 7a02 	vldr	s14, [r3, #8]
 801e948:	eeb4 7ac0 	vcmpe.f32	s14, s0
 801e94c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e950:	d50d      	bpl.n	801e96e <tEnvelopeFollower_tick+0x3e>
    //ef->y = envelope_pow[(uint16_t)(ef->y * (float)UINT16_MAX)] * ef->d_coeff; //not quite the right behavior - too much loss of precision?
    //ef->y = powf(ef->y, 1.000009f) * ef->d_coeff;  // too expensive
    
#ifdef NO_DENORMAL_CHECK
#else
    if( e->y < VSF)   e->y = 0.0f;
 801e952:	eddf 7a0e 	vldr	s15, [pc, #56]	; 801e98c <tEnvelopeFollower_tick+0x5c>
 801e956:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801e95a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e95e:	d511      	bpl.n	801e984 <tEnvelopeFollower_tick+0x54>
 801e960:	eddf 7a0b 	vldr	s15, [pc, #44]	; 801e990 <tEnvelopeFollower_tick+0x60>
 801e964:	eeb0 0a67 	vmov.f32	s0, s15
 801e968:	edc3 7a01 	vstr	s15, [r3, #4]
#endif
    return e->y;
}
 801e96c:	4770      	bx	lr
    else                                    e->y = e->y * e->d_coeff;    /* Else, exponential decay of output. */
 801e96e:	ed93 0a03 	vldr	s0, [r3, #12]
 801e972:	ee27 0a80 	vmul.f32	s0, s15, s0
    if( e->y < VSF)   e->y = 0.0f;
 801e976:	eddf 7a05 	vldr	s15, [pc, #20]	; 801e98c <tEnvelopeFollower_tick+0x5c>
 801e97a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801e97e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e982:	d4ed      	bmi.n	801e960 <tEnvelopeFollower_tick+0x30>
 801e984:	ed83 0a01 	vstr	s0, [r3, #4]
 801e988:	4770      	bx	lr
 801e98a:	bf00      	nop
 801e98c:	006ce3ee 	.word	0x006ce3ee
 801e990:	00000000 	.word	0x00000000

0801e994 <tZeroCrossing_init>:


// zero crossing detector

void    tZeroCrossing_init         (tZeroCrossing* const zc, int maxWindowSize)
{
 801e994:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tZeroCrossing_initToPool   (zc, maxWindowSize, &leaf.mempool);
}

void    tZeroCrossing_initToPool   (tZeroCrossing* const zc, int maxWindowSize, tMempool* const mp)
{
    _tMempool* m = *mp;
 801e996:	4b13      	ldr	r3, [pc, #76]	; (801e9e4 <tZeroCrossing_init+0x50>)
{
 801e998:	460d      	mov	r5, r1
 801e99a:	4607      	mov	r7, r0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
 801e99c:	2024      	movs	r0, #36	; 0x24
    _tMempool* m = *mp;
 801e99e:	699e      	ldr	r6, [r3, #24]
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
 801e9a0:	4631      	mov	r1, r6
 801e9a2:	f005 fc89 	bl	80242b8 <mpool_alloc>
    z->mempool = m;

    z->count = 0;
    z->maxWindowSize = maxWindowSize;
    z->currentWindowSize = maxWindowSize;
    z->invCurrentWindowSize = 1.0f / (float)maxWindowSize;
 801e9a6:	ee07 5a90 	vmov	s15, r5
 801e9aa:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
 801e9ae:	4604      	mov	r4, r0
    z->invCurrentWindowSize = 1.0f / (float)maxWindowSize;
 801e9b0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    z->count = 0;
 801e9b4:	2300      	movs	r3, #0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
 801e9b6:	6038      	str	r0, [r7, #0]
    z->position = 0;
    z->prevPosition = maxWindowSize;
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
 801e9b8:	4631      	mov	r1, r6
    z->mempool = m;
 801e9ba:	6006      	str	r6, [r0, #0]
    z->invCurrentWindowSize = 1.0f / (float)maxWindowSize;
 801e9bc:	eec6 7a87 	vdiv.f32	s15, s13, s14
    z->maxWindowSize = maxWindowSize;
 801e9c0:	6085      	str	r5, [r0, #8]
    z->count = 0;
 801e9c2:	6063      	str	r3, [r4, #4]
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
 801e9c4:	00a8      	lsls	r0, r5, #2
    z->position = 0;
 801e9c6:	6223      	str	r3, [r4, #32]
    z->currentWindowSize = maxWindowSize;
 801e9c8:	60e5      	str	r5, [r4, #12]
    z->prevPosition = maxWindowSize;
 801e9ca:	61e5      	str	r5, [r4, #28]
    z->invCurrentWindowSize = 1.0f / (float)maxWindowSize;
 801e9cc:	edc4 7a04 	vstr	s15, [r4, #16]
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
 801e9d0:	f005 fcce 	bl	8024370 <mpool_calloc>
    z->countBuffer = (uint16_t*) mpool_calloc(sizeof(uint16_t) * maxWindowSize, m);
 801e9d4:	4631      	mov	r1, r6
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
 801e9d6:	6160      	str	r0, [r4, #20]
    z->countBuffer = (uint16_t*) mpool_calloc(sizeof(uint16_t) * maxWindowSize, m);
 801e9d8:	0068      	lsls	r0, r5, #1
 801e9da:	f005 fcc9 	bl	8024370 <mpool_calloc>
 801e9de:	61a0      	str	r0, [r4, #24]
}
 801e9e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801e9e2:	bf00      	nop
 801e9e4:	200194e8 	.word	0x200194e8

0801e9e8 <tZeroCrossing_free>:
}

void    tZeroCrossing_free (tZeroCrossing* const zc)
{
 801e9e8:	b510      	push	{r4, lr}
    _tZeroCrossing* z = *zc;
 801e9ea:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)z->inBuffer, z->mempool);
 801e9ec:	6821      	ldr	r1, [r4, #0]
 801e9ee:	6960      	ldr	r0, [r4, #20]
 801e9f0:	f005 fd16 	bl	8024420 <mpool_free>
    mpool_free((char*)z->countBuffer, z->mempool);
 801e9f4:	6821      	ldr	r1, [r4, #0]
 801e9f6:	69a0      	ldr	r0, [r4, #24]
 801e9f8:	f005 fd12 	bl	8024420 <mpool_free>
    mpool_free((char*)z, z->mempool);
 801e9fc:	6821      	ldr	r1, [r4, #0]
 801e9fe:	4620      	mov	r0, r4
}
 801ea00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)z, z->mempool);
 801ea04:	f005 bd0c 	b.w	8024420 <mpool_free>

0801ea08 <tZeroCrossing_tick>:

//returns proportion of zero crossings within window size (0.0 would be none in window, 1.0 would be all zero crossings)
float   tZeroCrossing_tick         (tZeroCrossing* const zc, float input)
{
 801ea08:	b430      	push	{r4, r5}
    _tZeroCrossing* z = *zc;
 801ea0a:	6803      	ldr	r3, [r0, #0]

    z->inBuffer[z->position] = input;
 801ea0c:	6a19      	ldr	r1, [r3, #32]
 801ea0e:	695a      	ldr	r2, [r3, #20]
 801ea10:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 801ea14:	ed82 0a00 	vstr	s0, [r2]
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
 801ea18:	6a18      	ldr	r0, [r3, #32]
    float output = 0.0f;

    //add new value to count
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 801ea1a:	695a      	ldr	r2, [r3, #20]
 801ea1c:	69dc      	ldr	r4, [r3, #28]
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
 801ea1e:	1c45      	adds	r5, r0, #1
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 801ea20:	eb02 0180 	add.w	r1, r2, r0, lsl #2
 801ea24:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
 801ea28:	68dc      	ldr	r4, [r3, #12]
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 801ea2a:	ed91 7a00 	vldr	s14, [r1]
 801ea2e:	edd2 7a00 	vldr	s15, [r2]
    {
        //zero crossing happened, add it to the count array
        z->countBuffer[z->position] = 1;
 801ea32:	699a      	ldr	r2, [r3, #24]
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 801ea34:	ee67 7a87 	vmul.f32	s15, s15, s14
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
 801ea38:	fb95 f1f4 	sdiv	r1, r5, r4
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 801ea3c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
 801ea40:	fb04 5111 	mls	r1, r4, r1, r5
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 801ea44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ea48:	d41c      	bmi.n	801ea84 <tZeroCrossing_tick+0x7c>
        z->count++;
    }
    else
    {
        z->countBuffer[z->position] = 0;
 801ea4a:	2400      	movs	r4, #0
 801ea4c:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
 801ea50:	685a      	ldr	r2, [r3, #4]
    }

    //remove oldest value from count
    if (z->countBuffer[futurePosition] > 0)
 801ea52:	6998      	ldr	r0, [r3, #24]
 801ea54:	f830 0011 	ldrh.w	r0, [r0, r1, lsl #1]
 801ea58:	b110      	cbz	r0, 801ea60 <tZeroCrossing_tick+0x58>
    {
        z->count--;
        if (z->count < 0)
 801ea5a:	3a01      	subs	r2, #1
 801ea5c:	d40d      	bmi.n	801ea7a <tZeroCrossing_tick+0x72>
        z->count--;
 801ea5e:	605a      	str	r2, [r3, #4]
 801ea60:	ee07 2a90 	vmov	s15, r2
 801ea64:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        {
            z->count = 0;
        }
    }

    z->prevPosition = z->position;
 801ea68:	6a1a      	ldr	r2, [r3, #32]
    z->position = futurePosition;

    output = z->count * z->invCurrentWindowSize;
 801ea6a:	ed93 0a04 	vldr	s0, [r3, #16]
    z->position = futurePosition;
 801ea6e:	e9c3 2107 	strd	r2, r1, [r3, #28]

    return output;
}
 801ea72:	ee27 0a80 	vmul.f32	s0, s15, s0
 801ea76:	bc30      	pop	{r4, r5}
 801ea78:	4770      	bx	lr
            z->count = 0;
 801ea7a:	2200      	movs	r2, #0
 801ea7c:	eddf 7a05 	vldr	s15, [pc, #20]	; 801ea94 <tZeroCrossing_tick+0x8c>
 801ea80:	605a      	str	r2, [r3, #4]
 801ea82:	e7f1      	b.n	801ea68 <tZeroCrossing_tick+0x60>
        z->countBuffer[z->position] = 1;
 801ea84:	2401      	movs	r4, #1
 801ea86:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
        z->count++;
 801ea8a:	685a      	ldr	r2, [r3, #4]
 801ea8c:	4422      	add	r2, r4
 801ea8e:	605a      	str	r2, [r3, #4]
 801ea90:	e7df      	b.n	801ea52 <tZeroCrossing_tick+0x4a>
 801ea92:	bf00      	nop
 801ea94:	00000000 	.word	0x00000000

0801ea98 <tPowerFollower_initToPool>:
{
    tPowerFollower_initToPool(pf, factor, &leaf.mempool);
}

void    tPowerFollower_initToPool   (tPowerFollower* const pf, float factor, tMempool* const mp)
{
 801ea98:	b538      	push	{r3, r4, r5, lr}
 801ea9a:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 801ea9e:	680c      	ldr	r4, [r1, #0]
{
 801eaa0:	4605      	mov	r5, r0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
 801eaa2:	2010      	movs	r0, #16
{
 801eaa4:	eeb0 8a40 	vmov.f32	s16, s0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
 801eaa8:	4621      	mov	r1, r4
 801eaaa:	f005 fc05 	bl	80242b8 <mpool_alloc>
    p->mempool = m;
    
    p->curr=0.0f;
    p->factor=factor;
    p->oneminusfactor=1.0f-factor;
 801eaae:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    p->curr=0.0f;
 801eab2:	2300      	movs	r3, #0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
 801eab4:	6028      	str	r0, [r5, #0]
    p->mempool = m;
 801eab6:	6004      	str	r4, [r0, #0]
    p->oneminusfactor=1.0f-factor;
 801eab8:	ee77 7ac8 	vsub.f32	s15, s15, s16
    p->factor=factor;
 801eabc:	ed80 8a01 	vstr	s16, [r0, #4]
    p->curr=0.0f;
 801eac0:	60c3      	str	r3, [r0, #12]
    p->oneminusfactor=1.0f-factor;
 801eac2:	edc0 7a02 	vstr	s15, [r0, #8]
}
 801eac6:	ecbd 8b02 	vpop	{d8}
 801eaca:	bd38      	pop	{r3, r4, r5, pc}

0801eacc <tPowerFollower_free>:

void    tPowerFollower_free (tPowerFollower* const pf)
{
    _tPowerFollower* p = *pf;
 801eacc:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)p, p->mempool);
 801eace:	6801      	ldr	r1, [r0, #0]
 801ead0:	f005 bca6 	b.w	8024420 <mpool_free>

0801ead4 <tPowerFollower_tick>:
    return 0;
}

float   tPowerFollower_tick(tPowerFollower* const pf, float input)
{
    _tPowerFollower* p = *pf;
 801ead4:	6803      	ldr	r3, [r0, #0]
    p->curr = p->factor*input*input+p->oneminusfactor*p->curr;
 801ead6:	ee20 7a00 	vmul.f32	s14, s0, s0
 801eada:	edd3 7a02 	vldr	s15, [r3, #8]
 801eade:	ed93 0a03 	vldr	s0, [r3, #12]
 801eae2:	edd3 6a01 	vldr	s13, [r3, #4]
 801eae6:	ee27 0a80 	vmul.f32	s0, s15, s0
 801eaea:	eea6 0a87 	vfma.f32	s0, s13, s14
 801eaee:	ed83 0a03 	vstr	s0, [r3, #12]
    return p->curr;
}
 801eaf2:	4770      	bx	lr

0801eaf4 <tEnvPD_initToPool>:
{
    tEnvPD_initToPool(xpd, ws, hs, bs, &leaf.mempool);
}

void    tEnvPD_initToPool       (tEnvPD* const xpd, int ws, int hs, int bs, tMempool* const mp)
{
 801eaf4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801eaf8:	ed2d 8b04 	vpush	{d8-d9}
 801eafc:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 801eafe:	460f      	mov	r7, r1
 801eb00:	4605      	mov	r5, r0
    _tMempool* m = *mp;
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
 801eb02:	f241 10ac 	movw	r0, #4524	; 0x11ac
    _tMempool* m = *mp;
 801eb06:	6824      	ldr	r4, [r4, #0]
{
 801eb08:	4690      	mov	r8, r2
 801eb0a:	4699      	mov	r9, r3
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
 801eb0c:	4621      	mov	r1, r4
 801eb0e:	f005 fc2f 	bl	8024370 <mpool_calloc>
    
    int period = hs, npoints = ws;
    
    int i;
    
    if (npoints < 1) npoints = 1024;
 801eb12:	2f00      	cmp	r7, #0
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
 801eb14:	6028      	str	r0, [r5, #0]
 801eb16:	4606      	mov	r6, r0
    x->mempool = m;
 801eb18:	6004      	str	r4, [r0, #0]
    if (npoints < 1) npoints = 1024;
 801eb1a:	dd74      	ble.n	801ec06 <tEnvPD_initToPool+0x112>
 801eb1c:	ee07 7a90 	vmov	s15, r7
 801eb20:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801eb24:	117b      	asrs	r3, r7, #5
 801eb26:	f107 0a40 	add.w	sl, r7, #64	; 0x40
 801eb2a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801eb2e:	3301      	adds	r3, #1
 801eb30:	ee87 8a27 	vdiv.f32	s16, s14, s15
    if (period < 1) period = npoints/2;
 801eb34:	f1b8 0f00 	cmp.w	r8, #0
    if (period < npoints / MAXOVERLAP + 1)
        period = npoints / MAXOVERLAP + 1;
    
    x->x_npoints = npoints;
 801eb38:	f241 1210 	movw	r2, #4368	; 0x1110
    x->x_phase = 0;
 801eb3c:	f241 1004 	movw	r0, #4356	; 0x1104
 801eb40:	f04f 0400 	mov.w	r4, #0
    if (period < 1) period = npoints/2;
 801eb44:	bfd8      	it	le
 801eb46:	ea4f 0867 	movle.w	r8, r7, asr #1
    x->x_period = period;
    
    x->windowSize = npoints;
 801eb4a:	f241 119c 	movw	r1, #4508	; 0x119c
 801eb4e:	1d35      	adds	r5, r6, #4
 801eb50:	ed9f 9a31 	vldr	s18, [pc, #196]	; 801ec18 <tEnvPD_initToPool+0x124>
 801eb54:	4598      	cmp	r8, r3
 801eb56:	eb05 0b87 	add.w	fp, r5, r7, lsl #2
 801eb5a:	bfb8      	it	lt
 801eb5c:	4698      	movlt	r8, r3
    x->x_period = period;
 801eb5e:	f241 1308 	movw	r3, #4360	; 0x1108
 801eb62:	f846 8003 	str.w	r8, [r6, r3]
    x->hopSize = period;
 801eb66:	f506 538d 	add.w	r3, r6, #4512	; 0x11a0
    x->x_npoints = npoints;
 801eb6a:	50b7      	str	r7, [r6, r2]
    x->blockSize = bs;
 801eb6c:	f241 12a4 	movw	r2, #4516	; 0x11a4
    x->x_phase = 0;
 801eb70:	5034      	str	r4, [r6, r0]
 801eb72:	f241 1018 	movw	r0, #4376	; 0x1118
    x->windowSize = npoints;
 801eb76:	5077      	str	r7, [r6, r1]
 801eb78:	4621      	mov	r1, r4
    x->hopSize = period;
 801eb7a:	f8c3 8000 	str.w	r8, [r3]
 801eb7e:	4430      	add	r0, r6
    x->blockSize = bs;
 801eb80:	f846 9002 	str.w	r9, [r6, r2]
 801eb84:	2280      	movs	r2, #128	; 0x80
 801eb86:	f008 fa2a 	bl	8026fde <memset>
    
    for (i = 0; i < MAXOVERLAP; i++) x->x_sumbuf[i] = 0;
 801eb8a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    for (i = 0; i < npoints; i++)
        x->buf[i] = (1.0f - cosf((2 * PI * i) / npoints))/npoints;
 801eb8e:	eef0 8a40 	vmov.f32	s17, s0
 801eb92:	e001      	b.n	801eb98 <tEnvPD_initToPool+0xa4>
 801eb94:	f008 fb44 	bl	8027220 <cosf>
    for (i = 0; i < npoints; i++)
 801eb98:	3401      	adds	r4, #1
        x->buf[i] = (1.0f - cosf((2 * PI * i) / npoints))/npoints;
 801eb9a:	ee38 0ac0 	vsub.f32	s0, s17, s0
 801eb9e:	ee07 4a90 	vmov	s15, r4
 801eba2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801eba6:	ee60 7a08 	vmul.f32	s15, s0, s16
 801ebaa:	ee27 0a09 	vmul.f32	s0, s14, s18
 801ebae:	ece5 7a01 	vstmia	r5!, {s15}
    for (i = 0; i < npoints; i++)
 801ebb2:	45ab      	cmp	fp, r5
 801ebb4:	ee20 0a08 	vmul.f32	s0, s0, s16
 801ebb8:	d1ec      	bne.n	801eb94 <tEnvPD_initToPool+0xa0>
    for (; i < npoints+INITVSTAKEN; i++) x->buf[i] = 0;
 801ebba:	4557      	cmp	r7, sl
 801ebbc:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
 801ebc0:	da08      	bge.n	801ebd4 <tEnvPD_initToPool+0xe0>
 801ebc2:	ebaa 0207 	sub.w	r2, sl, r7
 801ebc6:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 801ebca:	2100      	movs	r1, #0
 801ebcc:	0092      	lsls	r2, r2, #2
 801ebce:	3008      	adds	r0, #8
 801ebd0:	f008 fa05 	bl	8026fde <memset>
    
    x->x_f = 0;
 801ebd4:	f241 1298 	movw	r2, #4504	; 0x1198
 801ebd8:	2400      	movs	r4, #0
    
    x->x_allocforvs = INITVSTAKEN;
 801ebda:	f241 11a8 	movw	r1, #4520	; 0x11a8
 801ebde:	2040      	movs	r0, #64	; 0x40
    x->x_f = 0;
 801ebe0:	4432      	add	r2, r6
    
    // ~ ~ ~ dsp ~ ~ ~
    if (x->x_period % x->blockSize)
 801ebe2:	fb98 f3f9 	sdiv	r3, r8, r9
 801ebe6:	fb09 8313 	mls	r3, r9, r3, r8
    x->x_f = 0;
 801ebea:	6014      	str	r4, [r2, #0]
    x->x_allocforvs = INITVSTAKEN;
 801ebec:	5070      	str	r0, [r6, r1]
    if (x->x_period % x->blockSize)
 801ebee:	b113      	cbz	r3, 801ebf6 <tEnvPD_initToPool+0x102>
    {
        x->x_realperiod = x->x_period + x->blockSize - (x->x_period % x->blockSize);
 801ebf0:	44c8      	add	r8, r9
 801ebf2:	eba8 0803 	sub.w	r8, r8, r3
 801ebf6:	f241 130c 	movw	r3, #4364	; 0x110c
 801ebfa:	f846 8003 	str.w	r8, [r6, r3]
    else
    {
        x->x_realperiod = x->x_period;
    }
    // ~ ~ ~ ~ ~ ~ ~ ~
}
 801ebfe:	ecbd 8b04 	vpop	{d8-d9}
 801ec02:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801ec06:	f44f 6a88 	mov.w	sl, #1088	; 0x440
 801ec0a:	ed9f 8a04 	vldr	s16, [pc, #16]	; 801ec1c <tEnvPD_initToPool+0x128>
 801ec0e:	2321      	movs	r3, #33	; 0x21
    if (npoints < 1) npoints = 1024;
 801ec10:	f44f 6780 	mov.w	r7, #1024	; 0x400
 801ec14:	e78e      	b.n	801eb34 <tEnvPD_initToPool+0x40>
 801ec16:	bf00      	nop
 801ec18:	40c90fdb 	.word	0x40c90fdb
 801ec1c:	3a800000 	.word	0x3a800000

0801ec20 <tEnvPD_tick>:
}

float tEnvPD_tick (tEnvPD* const xpd)
{
    _tEnvPD* x = *xpd;
    return powtodb(x->x_result);
 801ec20:	6802      	ldr	r2, [r0, #0]
 801ec22:	f241 1314 	movw	r3, #4372	; 0x1114
 801ec26:	4413      	add	r3, r2
 801ec28:	ed93 0a00 	vldr	s0, [r3]
 801ec2c:	f005 bad8 	b.w	80241e0 <powtodb>

0801ec30 <tEnvPD_processBlock>:
}

void tEnvPD_processBlock(tEnvPD* const xpd, float* in)
{
 801ec30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int n = x->blockSize;
    
    int count;
    t_sample *sump;
    in += n;
    for (count = x->x_phase, sump = x->x_sumbuf;
 801ec34:	f241 1204 	movw	r2, #4356	; 0x1104
    _tEnvPD* x = *xpd;
 801ec38:	6806      	ldr	r6, [r0, #0]
         count < x->x_npoints; count += x->x_realperiod, sump++)
 801ec3a:	f241 1310 	movw	r3, #4368	; 0x1110
    int n = x->blockSize;
 801ec3e:	f241 10a4 	movw	r0, #4516	; 0x11a4
    for (count = x->x_phase, sump = x->x_sumbuf;
 801ec42:	f241 1918 	movw	r9, #4376	; 0x1118
 801ec46:	58b4      	ldr	r4, [r6, r2]
 801ec48:	58f3      	ldr	r3, [r6, r3]
    int n = x->blockSize;
 801ec4a:	5830      	ldr	r0, [r6, r0]
    for (count = x->x_phase, sump = x->x_sumbuf;
 801ec4c:	44b1      	add	r9, r6
 801ec4e:	429c      	cmp	r4, r3
    in += n;
 801ec50:	eb01 0180 	add.w	r1, r1, r0, lsl #2
    for (count = x->x_phase, sump = x->x_sumbuf;
 801ec54:	46ce      	mov	lr, r9
 801ec56:	da59      	bge.n	801ed0c <tEnvPD_processBlock+0xdc>
 801ec58:	f241 1c0c 	movw	ip, #4364	; 0x110c
 801ec5c:	f241 1710 	movw	r7, #4368	; 0x1110
 801ec60:	f106 0804 	add.w	r8, r6, #4
 801ec64:	464d      	mov	r5, r9
 801ec66:	44b4      	add	ip, r6
 801ec68:	4437      	add	r7, r6
        t_sample *hp = x->buf + count;
        t_sample *fp = in;
        t_sample sum = *sump;
        int i;
        
        for (i = 0; i < n; i++)
 801ec6a:	2800      	cmp	r0, #0
        t_sample *hp = x->buf + count;
 801ec6c:	eb08 0284 	add.w	r2, r8, r4, lsl #2
        t_sample sum = *sump;
 801ec70:	ecb5 7a01 	vldmia	r5!, {s14}
        for (i = 0; i < n; i++)
 801ec74:	dd0c      	ble.n	801ec90 <tEnvPD_processBlock+0x60>
 801ec76:	468a      	mov	sl, r1
 801ec78:	2300      	movs	r3, #0
        {
            fp--;
            sum += *hp++ * (*fp * *fp);
 801ec7a:	ed7a 7a01 	vldmdb	sl!, {s15}
        for (i = 0; i < n; i++)
 801ec7e:	3301      	adds	r3, #1
            sum += *hp++ * (*fp * *fp);
 801ec80:	ecf2 6a01 	vldmia	r2!, {s13}
 801ec84:	ee67 7aa7 	vmul.f32	s15, s15, s15
        for (i = 0; i < n; i++)
 801ec88:	4298      	cmp	r0, r3
            sum += *hp++ * (*fp * *fp);
 801ec8a:	eea6 7aa7 	vfma.f32	s14, s13, s15
        for (i = 0; i < n; i++)
 801ec8e:	d1f4      	bne.n	801ec7a <tEnvPD_processBlock+0x4a>
        }
        *sump = sum;
 801ec90:	ed05 7a01 	vstr	s14, [r5, #-4]
 801ec94:	46aa      	mov	sl, r5
         count < x->x_npoints; count += x->x_realperiod, sump++)
 801ec96:	f8dc 2000 	ldr.w	r2, [ip]
    for (count = x->x_phase, sump = x->x_sumbuf;
 801ec9a:	683b      	ldr	r3, [r7, #0]
         count < x->x_npoints; count += x->x_realperiod, sump++)
 801ec9c:	4414      	add	r4, r2
    for (count = x->x_phase, sump = x->x_sumbuf;
 801ec9e:	42a3      	cmp	r3, r4
 801eca0:	dce3      	bgt.n	801ec6a <tEnvPD_processBlock+0x3a>
    }
    sump[0] = 0;
 801eca2:	2300      	movs	r3, #0
    x->x_phase -= n;
 801eca4:	f241 1204 	movw	r2, #4356	; 0x1104
    sump[0] = 0;
 801eca8:	f8ca 3000 	str.w	r3, [sl]
    x->x_phase -= n;
 801ecac:	58b3      	ldr	r3, [r6, r2]
 801ecae:	1a1b      	subs	r3, r3, r0
    if (x->x_phase < 0)
 801ecb0:	2b00      	cmp	r3, #0
    x->x_phase -= n;
 801ecb2:	50b3      	str	r3, [r6, r2]
    if (x->x_phase < 0)
 801ecb4:	db01      	blt.n	801ecba <tEnvPD_processBlock+0x8a>
             count < x->x_npoints; count += x->x_realperiod, sump++)
            sump[0] = sump[1];
        sump[0] = 0;
        x->x_phase = x->x_realperiod - n;
    }
}
 801ecb6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        x->x_result = x->x_sumbuf[0];
 801ecba:	f241 1314 	movw	r3, #4372	; 0x1114
 801ecbe:	f8d9 4000 	ldr.w	r4, [r9]
        for (count = x->x_realperiod, sump = x->x_sumbuf;
 801ecc2:	f241 110c 	movw	r1, #4364	; 0x110c
             count < x->x_npoints; count += x->x_realperiod, sump++)
 801ecc6:	f241 1210 	movw	r2, #4368	; 0x1110
        x->x_result = x->x_sumbuf[0];
 801ecca:	4433      	add	r3, r6
 801eccc:	601c      	str	r4, [r3, #0]
        for (count = x->x_realperiod, sump = x->x_sumbuf;
 801ecce:	5873      	ldr	r3, [r6, r1]
 801ecd0:	58b2      	ldr	r2, [r6, r2]
 801ecd2:	4293      	cmp	r3, r2
 801ecd4:	da0e      	bge.n	801ecf4 <tEnvPD_processBlock+0xc4>
 801ecd6:	468c      	mov	ip, r1
 801ecd8:	f241 1710 	movw	r7, #4368	; 0x1110
 801ecdc:	44b4      	add	ip, r6
 801ecde:	4437      	add	r7, r6
            sump[0] = sump[1];
 801ece0:	f8de 2004 	ldr.w	r2, [lr, #4]
 801ece4:	f84e 2b04 	str.w	r2, [lr], #4
             count < x->x_npoints; count += x->x_realperiod, sump++)
 801ece8:	f8dc 1000 	ldr.w	r1, [ip]
        for (count = x->x_realperiod, sump = x->x_sumbuf;
 801ecec:	683a      	ldr	r2, [r7, #0]
             count < x->x_npoints; count += x->x_realperiod, sump++)
 801ecee:	440b      	add	r3, r1
        for (count = x->x_realperiod, sump = x->x_sumbuf;
 801ecf0:	429a      	cmp	r2, r3
 801ecf2:	dcf5      	bgt.n	801ece0 <tEnvPD_processBlock+0xb0>
        sump[0] = 0;
 801ecf4:	2100      	movs	r1, #0
        x->x_phase = x->x_realperiod - n;
 801ecf6:	f241 130c 	movw	r3, #4364	; 0x110c
 801ecfa:	f241 1204 	movw	r2, #4356	; 0x1104
        sump[0] = 0;
 801ecfe:	f8ce 1000 	str.w	r1, [lr]
        x->x_phase = x->x_realperiod - n;
 801ed02:	58f3      	ldr	r3, [r6, r3]
 801ed04:	1a18      	subs	r0, r3, r0
 801ed06:	50b0      	str	r0, [r6, r2]
}
 801ed08:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    for (count = x->x_phase, sump = x->x_sumbuf;
 801ed0c:	46ca      	mov	sl, r9
 801ed0e:	e7c8      	b.n	801eca2 <tEnvPD_processBlock+0x72>

0801ed10 <tSNAC_initToPool>:
{
    tSNAC_initToPool(snac, overlaparg, &leaf.mempool);
}

void    tSNAC_initToPool    (tSNAC* const snac, int overlaparg, tMempool* const mp)
{
 801ed10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801ed14:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
 801ed18:	6815      	ldr	r5, [r2, #0]
{
 801ed1a:	4680      	mov	r8, r0
 801ed1c:	460f      	mov	r7, r1
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
 801ed1e:	202c      	movs	r0, #44	; 0x2c
 801ed20:	4629      	mov	r1, r5
    s->mempool = m;
    
    s->biasfactor = DEFBIAS;
    s->timeindex = 0;
    s->periodindex = 0;
    s->periodlength = 0.;
 801ed22:	ed9f 8a40 	vldr	s16, [pc, #256]	; 801ee24 <tSNAC_initToPool+0x114>
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
 801ed26:	f005 fac7 	bl	80242b8 <mpool_alloc>
    s->fidelity = 0.;
    s->minrms = DEFMINRMS;
 801ed2a:	4a3f      	ldr	r2, [pc, #252]	; (801ee28 <tSNAC_initToPool+0x118>)
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
 801ed2c:	4604      	mov	r4, r0
    s->timeindex = 0;
 801ed2e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    s->biasfactor = DEFBIAS;
 801ed32:	483e      	ldr	r0, [pc, #248]	; (801ee2c <tSNAC_initToPool+0x11c>)
    s->periodindex = 0;
 801ed34:	2100      	movs	r1, #0
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
 801ed36:	f8c8 4000 	str.w	r4, [r8]
    s->minrms = DEFMINRMS;
 801ed3a:	62a2      	str	r2, [r4, #40]	; 0x28
    s->timeindex = 0;
 801ed3c:	6163      	str	r3, [r4, #20]
    s->biasfactor = DEFBIAS;
 801ed3e:	6260      	str	r0, [r4, #36]	; 0x24
    s->framesize = SNAC_FRAME_SIZE;

    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 801ed40:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    s->periodindex = 0;
 801ed44:	8361      	strh	r1, [r4, #26]
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 801ed46:	4629      	mov	r1, r5
    s->mempool = m;
 801ed48:	6025      	str	r5, [r4, #0]
    s->periodlength = 0.;
 801ed4a:	ed84 8a07 	vstr	s16, [r4, #28]
    s->fidelity = 0.;
 801ed4e:	ed84 8a08 	vstr	s16, [r4, #32]
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 801ed52:	f005 fb0d 	bl	8024370 <mpool_calloc>
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
 801ed56:	4629      	mov	r1, r5
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 801ed58:	6060      	str	r0, [r4, #4]
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
 801ed5a:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 801ed5e:	f005 fb07 	bl	8024370 <mpool_calloc>
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
 801ed62:	4629      	mov	r1, r5
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
 801ed64:	60a0      	str	r0, [r4, #8]
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
 801ed66:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801ed6a:	f005 fb01 	bl	8024370 <mpool_calloc>
    s->biasbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 801ed6e:	4629      	mov	r1, r5
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
 801ed70:	60e0      	str	r0, [r4, #12]
    s->biasbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 801ed72:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 801ed76:	f005 fafb 	bl	8024370 <mpool_calloc>
 801ed7a:	6120      	str	r0, [r4, #16]
    
    snac_biasbuf(snac);
 801ed7c:	f8d8 4000 	ldr.w	r4, [r8]
static void snac_biasbuf(tSNAC* const snac)
{
    _tSNAC* s = *snac;
    
    int n;
    int maxperiod = (int)(s->framesize * (float)SEEK);
 801ed80:	ed9f 7a2b 	vldr	s14, [pc, #172]	; 801ee30 <tSNAC_initToPool+0x120>
 801ed84:	8ae3      	ldrh	r3, [r4, #22]
 801ed86:	ee07 3a90 	vmov	s15, r3
 801ed8a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801ed8e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ed92:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ed96:	ee17 6a90 	vmov	r6, s15
    float bias = s->biasfactor / logf((float)(maxperiod - 4));
 801ed9a:	1f33      	subs	r3, r6, #4
 801ed9c:	ee00 3a10 	vmov	s0, r3
 801eda0:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 801eda4:	f008 fb02 	bl	80273ac <logf>
 801eda8:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    for(n=0; n<5; n++)    // periods < 5 samples can't be tracked
    {
        biasbuf[n] = 0.0f;
    }
    
    for(n=5; n<maxperiod; n++)
 801edac:	2e05      	cmp	r6, #5
    float *biasbuf = s->biasbuf;
 801edae:	6924      	ldr	r4, [r4, #16]
    float bias = s->biasfactor / logf((float)(maxperiod - 4));
 801edb0:	ee87 0a80 	vdiv.f32	s0, s15, s0
        biasbuf[n] = 0.0f;
 801edb4:	ed84 8a00 	vstr	s16, [r4]
 801edb8:	ed84 8a01 	vstr	s16, [r4, #4]
 801edbc:	ed84 8a02 	vstr	s16, [r4, #8]
 801edc0:	ed84 8a03 	vstr	s16, [r4, #12]
 801edc4:	ed84 8a04 	vstr	s16, [r4, #16]
    for(n=5; n<maxperiod; n++)
 801edc8:	dd1d      	ble.n	801ee06 <tSNAC_initToPool+0xf6>
 801edca:	eef1 8a40 	vneg.f32	s17, s0
 801edce:	eb04 0686 	add.w	r6, r4, r6, lsl #2
    {
        biasbuf[n] = 1.0f - (float)logf(n - 4.f) * bias;
 801edd2:	eef7 9a00 	vmov.f32	s19, #112	; 0x3f800000  1.0
 801edd6:	3414      	adds	r4, #20
 801edd8:	eeb1 9a00 	vmov.f32	s18, #16	; 0x40800000  4.0
    for(n=5; n<maxperiod; n++)
 801eddc:	2505      	movs	r5, #5
 801edde:	eeb0 0a48 	vmov.f32	s0, s16
 801ede2:	e001      	b.n	801ede8 <tSNAC_initToPool+0xd8>
 801ede4:	f008 fae2 	bl	80273ac <logf>
        biasbuf[n] = 1.0f - (float)logf(n - 4.f) * bias;
 801ede8:	eef0 7a69 	vmov.f32	s15, s19
    for(n=5; n<maxperiod; n++)
 801edec:	3501      	adds	r5, #1
 801edee:	ee07 5a10 	vmov	s14, r5
        biasbuf[n] = 1.0f - (float)logf(n - 4.f) * bias;
 801edf2:	eee8 7a80 	vfma.f32	s15, s17, s0
 801edf6:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
 801edfa:	ee30 0a49 	vsub.f32	s0, s0, s18
 801edfe:	ece4 7a01 	vstmia	r4!, {s15}
    for(n=5; n<maxperiod; n++)
 801ee02:	42b4      	cmp	r4, r6
 801ee04:	d1ee      	bne.n	801ede4 <tSNAC_initToPool+0xd4>
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
 801ee06:	2f08      	cmp	r7, #8
 801ee08:	bf18      	it	ne
 801ee0a:	2f04      	cmpne	r7, #4
    _tSNAC* s = *snac;
 801ee0c:	f8d8 3000 	ldr.w	r3, [r8]
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
 801ee10:	d003      	beq.n	801ee1a <tSNAC_initToPool+0x10a>
 801ee12:	1e7a      	subs	r2, r7, #1
 801ee14:	2a01      	cmp	r2, #1
 801ee16:	bf88      	it	hi
 801ee18:	2701      	movhi	r7, #1
    s->overlap = lap;
 801ee1a:	831f      	strh	r7, [r3, #24]
}
 801ee1c:	ecbd 8b04 	vpop	{d8-d9}
 801ee20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801ee24:	00000000 	.word	0x00000000
 801ee28:	3b449ba6 	.word	0x3b449ba6
 801ee2c:	3e4ccccd 	.word	0x3e4ccccd
 801ee30:	3f59999a 	.word	0x3f59999a

0801ee34 <tSNAC_ioSamples>:
{
 801ee34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ee38:	ed2d 8b02 	vpush	{d8}
 801ee3c:	b08b      	sub	sp, #44	; 0x2c
 801ee3e:	460d      	mov	r5, r1
 801ee40:	9204      	str	r2, [sp, #16]
    _tSNAC* s = *snac;
 801ee42:	6802      	ldr	r2, [r0, #0]
{
 801ee44:	9002      	str	r0, [sp, #8]
 801ee46:	9301      	str	r3, [sp, #4]
    int mask = s->framesize - 1;
 801ee48:	8ad0      	ldrh	r0, [r2, #22]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
 801ee4a:	8b13      	ldrh	r3, [r2, #24]
    int timeindex = s->timeindex;
 801ee4c:	8a94      	ldrh	r4, [r2, #20]
    int mask = s->framesize - 1;
 801ee4e:	1e46      	subs	r6, r0, #1
    _tSNAC* s = *snac;
 801ee50:	9203      	str	r2, [sp, #12]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
 801ee52:	fbb0 f3f3 	udiv	r3, r0, r3
 801ee56:	3b01      	subs	r3, #1
 801ee58:	4023      	ands	r3, r4
    float *processbuf = s->processbuf;
 801ee5a:	e9d2 7801 	ldrd	r7, r8, [r2, #4]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
 801ee5e:	9306      	str	r3, [sp, #24]
 801ee60:	d019      	beq.n	801ee96 <tSNAC_ioSamples+0x62>
    while(size--)
 801ee62:	9b01      	ldr	r3, [sp, #4]
 801ee64:	b183      	cbz	r3, 801ee88 <tSNAC_ioSamples+0x54>
 801ee66:	9a04      	ldr	r2, [sp, #16]
 801ee68:	eb05 0c83 	add.w	ip, r5, r3, lsl #2
        inputbuf[timeindex] = *in++;
 801ee6c:	00a3      	lsls	r3, r4, #2
 801ee6e:	f855 0b04 	ldr.w	r0, [r5], #4
        out[outindex++] = processbuf[timeindex++];
 801ee72:	3401      	adds	r4, #1
        inputbuf[timeindex] = *in++;
 801ee74:	18f9      	adds	r1, r7, r3
        out[outindex++] = processbuf[timeindex++];
 801ee76:	4443      	add	r3, r8
    while(size--)
 801ee78:	4565      	cmp	r5, ip
        timeindex &= mask;
 801ee7a:	ea04 0406 	and.w	r4, r4, r6
        inputbuf[timeindex] = *in++;
 801ee7e:	6008      	str	r0, [r1, #0]
        out[outindex++] = processbuf[timeindex++];
 801ee80:	681b      	ldr	r3, [r3, #0]
 801ee82:	f842 3b04 	str.w	r3, [r2], #4
    while(size--)
 801ee86:	d1f1      	bne.n	801ee6c <tSNAC_ioSamples+0x38>
    s->timeindex = timeindex;
 801ee88:	9b03      	ldr	r3, [sp, #12]
 801ee8a:	829c      	strh	r4, [r3, #20]
}
 801ee8c:	b00b      	add	sp, #44	; 0x2c
 801ee8e:	ecbd 8b02 	vpop	{d8}
 801ee92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    float norm = 1.f / sqrtf((float)(framesize * 2));
 801ee96:	ea4f 0e40 	mov.w	lr, r0, lsl #1
 801ee9a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801ee9e:	ee07 ea90 	vmov	s15, lr
 801eea2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801eea6:	eef1 7ac7 	vsqrt.f32	s15, s14
 801eeaa:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    for(n=0; n<framesize; n++)
 801eeae:	b178      	cbz	r0, 801eed0 <tSNAC_ioSamples+0x9c>
 801eeb0:	4642      	mov	r2, r8
 801eeb2:	eb08 0c80 	add.w	ip, r8, r0, lsl #2
    int timeindex = s->timeindex;
 801eeb6:	4623      	mov	r3, r4
        processbuf[n] = inputbuf[tindex] * norm;
 801eeb8:	eb07 0183 	add.w	r1, r7, r3, lsl #2
        tindex++;
 801eebc:	3301      	adds	r3, #1
        processbuf[n] = inputbuf[tindex] * norm;
 801eebe:	edd1 7a00 	vldr	s15, [r1]
        tindex &= mask;
 801eec2:	4033      	ands	r3, r6
        processbuf[n] = inputbuf[tindex] * norm;
 801eec4:	ee67 7a87 	vmul.f32	s15, s15, s14
 801eec8:	ece2 7a01 	vstmia	r2!, {s15}
    for(n=0; n<framesize; n++)
 801eecc:	4594      	cmp	ip, r2
 801eece:	d1f3      	bne.n	801eeb8 <tSNAC_ioSamples+0x84>
    for(n=framesize; n<(framesize<<1); n++) processbuf[n] = 0.;
 801eed0:	4570      	cmp	r0, lr
 801eed2:	da07      	bge.n	801eee4 <tSNAC_ioSamples+0xb0>
 801eed4:	ebae 0200 	sub.w	r2, lr, r0
 801eed8:	2100      	movs	r1, #0
 801eeda:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 801eede:	0092      	lsls	r2, r2, #2
 801eee0:	f008 f87d 	bl	8026fde <memset>
    snac_autocorrelation(snac);
 801eee4:	9b02      	ldr	r3, [sp, #8]
 801eee6:	681b      	ldr	r3, [r3, #0]
    int framesize = s->framesize;
 801eee8:	f8b3 9016 	ldrh.w	r9, [r3, #22]
    float *processbuf = s->processbuf;
 801eeec:	f8d3 a008 	ldr.w	sl, [r3, #8]
    int fftsize = framesize * 2;
 801eef0:	ea4f 0b49 	mov.w	fp, r9, lsl #1
    float *spectrumbuf = s->spectrumbuf;
 801eef4:	68db      	ldr	r3, [r3, #12]
    REALFFT(fftsize, processbuf);
 801eef6:	4651      	mov	r1, sl
 801eef8:	4658      	mov	r0, fp
    float *spectrumbuf = s->spectrumbuf;
 801eefa:	9305      	str	r3, [sp, #20]
    REALFFT(fftsize, processbuf);
 801eefc:	f7ff fca8 	bl	801e850 <mayer_realfft>
    processbuf[0] *= processbuf[0];                      // DC
 801ef00:	edda 7a00 	vldr	s15, [sl]
    processbuf[framesize] *= processbuf[framesize];      // Nyquist
 801ef04:	eb0a 0189 	add.w	r1, sl, r9, lsl #2
    for(n=1; n<framesize; n++)
 801ef08:	f1b9 0f01 	cmp.w	r9, #1
    processbuf[0] *= processbuf[0];                      // DC
 801ef0c:	ee67 7aa7 	vmul.f32	s15, s15, s15
 801ef10:	edca 7a00 	vstr	s15, [sl]
    processbuf[framesize] *= processbuf[framesize];      // Nyquist
 801ef14:	edd1 7a00 	vldr	s15, [r1]
 801ef18:	ee67 7aa7 	vmul.f32	s15, s15, s15
 801ef1c:	edc1 7a00 	vstr	s15, [r1]
    for(n=1; n<framesize; n++)
 801ef20:	dd11      	ble.n	801ef46 <tSNAC_ioSamples+0x112>
 801ef22:	f10a 0304 	add.w	r3, sl, #4
 801ef26:	eb0a 028b 	add.w	r2, sl, fp, lsl #2
        processbuf[fftsize-n] = 0.f;
 801ef2a:	2000      	movs	r0, #0
        + processbuf[fftsize-n] * processbuf[fftsize-n]; // imag coefficients appear reversed
 801ef2c:	ed72 7a01 	vldmdb	r2!, {s15}
        processbuf[n] = processbuf[n] * processbuf[n]
 801ef30:	ed93 7a00 	vldr	s14, [r3]
        + processbuf[fftsize-n] * processbuf[fftsize-n]; // imag coefficients appear reversed
 801ef34:	ee67 7aa7 	vmul.f32	s15, s15, s15
 801ef38:	eee7 7a07 	vfma.f32	s15, s14, s14
        processbuf[n] = processbuf[n] * processbuf[n]
 801ef3c:	ece3 7a01 	vstmia	r3!, {s15}
    for(n=1; n<framesize; n++)
 801ef40:	4299      	cmp	r1, r3
        processbuf[fftsize-n] = 0.f;
 801ef42:	6010      	str	r0, [r2, #0]
    for(n=1; n<framesize; n++)
 801ef44:	d1f2      	bne.n	801ef2c <tSNAC_ioSamples+0xf8>
    for(m=0; m<(framesize>>1); m++)
 801ef46:	ea5f 0969 	movs.w	r9, r9, asr #1
 801ef4a:	d009      	beq.n	801ef60 <tSNAC_ioSamples+0x12c>
 801ef4c:	9a05      	ldr	r2, [sp, #20]
 801ef4e:	eb0a 0989 	add.w	r9, sl, r9, lsl #2
 801ef52:	4653      	mov	r3, sl
        spectrumbuf[m] = processbuf[m];
 801ef54:	f853 1b04 	ldr.w	r1, [r3], #4
    for(m=0; m<(framesize>>1); m++)
 801ef58:	4599      	cmp	r9, r3
        spectrumbuf[m] = processbuf[m];
 801ef5a:	f842 1b04 	str.w	r1, [r2], #4
    for(m=0; m<(framesize>>1); m++)
 801ef5e:	d1f9      	bne.n	801ef54 <tSNAC_ioSamples+0x120>
    REALIFFT(fftsize, processbuf);
 801ef60:	4651      	mov	r1, sl
 801ef62:	4658      	mov	r0, fp
 801ef64:	f7ff fc9e 	bl	801e8a4 <mayer_realifft>
    snac_normalize(snac);
 801ef68:	9b02      	ldr	r3, [sp, #8]
    int seek = framesize * SEEK;
 801ef6a:	eddf 5add 	vldr	s11, [pc, #884]	; 801f2e0 <tSNAC_ioSamples+0x4ac>
    processbuf[0] = 1;
 801ef6e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
    snac_normalize(snac);
 801ef72:	681b      	ldr	r3, [r3, #0]
    int framesize = s->framesize;
 801ef74:	8ad9      	ldrh	r1, [r3, #22]
    float rms = s->minrms / sqrtf(1.0f / (float)framesize);
 801ef76:	edd3 6a0a 	vldr	s13, [r3, #40]	; 0x28
    int seek = framesize * SEEK;
 801ef7a:	ee07 1a90 	vmov	s15, r1
    int framesize = s->framesize;
 801ef7e:	9105      	str	r1, [sp, #20]
    int mask = framesize - 1;
 801ef80:	9805      	ldr	r0, [sp, #20]
    int seek = framesize * SEEK;
 801ef82:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    float *processbuf= s->processbuf;
 801ef86:	6899      	ldr	r1, [r3, #8]
    int framesizeplustimeindex = s->framesize + s->timeindex;
 801ef88:	f8b3 a014 	ldrh.w	sl, [r3, #20]
    int mask = framesize - 1;
 801ef8c:	f100 3eff 	add.w	lr, r0, #4294967295	; 0xffffffff
    int framesizeplustimeindex = s->framesize + s->timeindex;
 801ef90:	9805      	ldr	r0, [sp, #20]
 801ef92:	eeb1 6ae7 	vsqrt.f32	s12, s15
    float rzero = processbuf[0];
 801ef96:	ed91 7a00 	vldr	s14, [r1]
    int framesizeplustimeindex = s->framesize + s->timeindex;
 801ef9a:	eb0a 0b00 	add.w	fp, sl, r0
    float *inputbuf = s->inputbuf;
 801ef9e:	f8d3 9004 	ldr.w	r9, [r3, #4]
    float *processbuf= s->processbuf;
 801efa2:	9107      	str	r1, [sp, #28]
    processbuf[0] = 1;
 801efa4:	600a      	str	r2, [r1, #0]
    int seek = framesize * SEEK;
 801efa6:	ee67 7aa5 	vmul.f32	s15, s15, s11
 801efaa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801efae:	ee17 0a90 	vmov	r0, s15
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 801efb2:	2801      	cmp	r0, #1
    float rms = s->minrms / sqrtf(1.0f / (float)framesize);
 801efb4:	ee26 6a26 	vmul.f32	s12, s12, s13
    float minrzero = rms * rms;
 801efb8:	ee26 6a06 	vmul.f32	s12, s12, s12
    double normintegral = (double)rzero * 2.;
 801efbc:	fe86 6a07 	vmaxnm.f32	s12, s12, s14
 801efc0:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
 801efc4:	ee36 6b06 	vadd.f64	d6, d6, d6
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 801efc8:	dd2b      	ble.n	801f022 <tSNAC_ioSamples+0x1ee>
        processbuf[n] /= (float)normintegral * 0.5f;
 801efca:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
 801efce:	f101 0c04 	add.w	ip, r1, #4
 801efd2:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 801efd6:	2101      	movs	r1, #1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask]; //could this be switched to float resolution without issue? -JS
 801efd8:	ebab 0201 	sub.w	r2, fp, r1
        signal1 = inputbuf[(n + timeindexminusone)&mask];
 801efdc:	eb0a 0301 	add.w	r3, sl, r1
        processbuf[n] /= (float)normintegral * 0.5f;
 801efe0:	eddc 5a00 	vldr	s11, [ip]
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 801efe4:	3101      	adds	r1, #1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask]; //could this be switched to float resolution without issue? -JS
 801efe6:	ea02 020e 	and.w	r2, r2, lr
        signal1 = inputbuf[(n + timeindexminusone)&mask];
 801efea:	ea03 030e 	and.w	r3, r3, lr
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 801efee:	4288      	cmp	r0, r1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask]; //could this be switched to float resolution without issue? -JS
 801eff0:	eb09 0282 	add.w	r2, r9, r2, lsl #2
        signal1 = inputbuf[(n + timeindexminusone)&mask];
 801eff4:	eb09 0383 	add.w	r3, r9, r3, lsl #2
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask]; //could this be switched to float resolution without issue? -JS
 801eff8:	ed92 7a00 	vldr	s14, [r2]
        signal1 = inputbuf[(n + timeindexminusone)&mask];
 801effc:	edd3 7a00 	vldr	s15, [r3]
        normintegral -= (double)(signal1 * signal1 + signal2 * signal2);
 801f000:	ee27 7a07 	vmul.f32	s14, s14, s14
 801f004:	eea7 7aa7 	vfma.f32	s14, s15, s15
 801f008:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
 801f00c:	ee36 6b47 	vsub.f64	d6, d6, d7
        processbuf[n] /= (float)normintegral * 0.5f;
 801f010:	eef7 7bc6 	vcvt.f32.f64	s15, d6
 801f014:	ee67 7a85 	vmul.f32	s15, s15, s10
 801f018:	ee85 7aa7 	vdiv.f32	s14, s11, s15
 801f01c:	ecac 7a01 	vstmia	ip!, {s14}
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 801f020:	d1da      	bne.n	801efd8 <tSNAC_ioSamples+0x1a4>
    for(n = seek; n<framesize; n++) processbuf[n] = 0.;
 801f022:	9b05      	ldr	r3, [sp, #20]
 801f024:	4283      	cmp	r3, r0
 801f026:	dd07      	ble.n	801f038 <tSNAC_ioSamples+0x204>
 801f028:	1a1a      	subs	r2, r3, r0
 801f02a:	9b07      	ldr	r3, [sp, #28]
 801f02c:	2100      	movs	r1, #0
 801f02e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801f032:	0092      	lsls	r2, r2, #2
 801f034:	f007 ffd3 	bl	8026fde <memset>
    snac_pickpeak(snac);
 801f038:	9b02      	ldr	r3, [sp, #8]
    int seek = s->framesize * SEEK;
 801f03a:	ed9f 7aa9 	vldr	s14, [pc, #676]	; 801f2e0 <tSNAC_ioSamples+0x4ac>
    snac_pickpeak(snac);
 801f03e:	681b      	ldr	r3, [r3, #0]
    int seek = s->framesize * SEEK;
 801f040:	8ada      	ldrh	r2, [r3, #22]
    snac_pickpeak(snac);
 801f042:	9307      	str	r3, [sp, #28]
    int seek = s->framesize * SEEK;
 801f044:	ee07 2a90 	vmov	s15, r2
    float *biasbuf = s->biasbuf;
 801f048:	6918      	ldr	r0, [r3, #16]
    float *processbuf= s->processbuf;
 801f04a:	689a      	ldr	r2, [r3, #8]
    int seek = s->framesize * SEEK;
 801f04c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801f050:	ee67 7a87 	vmul.f32	s15, s15, s14
 801f054:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801f058:	ee17 aa90 	vmov	sl, s15
    for(n=1; n<seek; n++)
 801f05c:	f1ba 0f01 	cmp.w	sl, #1
 801f060:	f340 808b 	ble.w	801f17a <tSNAC_ioSamples+0x346>
        if(processbuf[n] < 0.) break;
 801f064:	edd2 7a01 	vldr	s15, [r2, #4]
 801f068:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801f06c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f070:	f100 8083 	bmi.w	801f17a <tSNAC_ioSamples+0x346>
 801f074:	f102 0108 	add.w	r1, r2, #8
    for(n=1; n<seek; n++)
 801f078:	f04f 0901 	mov.w	r9, #1
 801f07c:	e006      	b.n	801f08c <tSNAC_ioSamples+0x258>
        if(processbuf[n] < 0.) break;
 801f07e:	ecf1 7a01 	vldmia	r1!, {s15}
 801f082:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801f086:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f08a:	d404      	bmi.n	801f096 <tSNAC_ioSamples+0x262>
    for(n=1; n<seek; n++)
 801f08c:	f109 0901 	add.w	r9, r9, #1
 801f090:	45ca      	cmp	sl, r9
 801f092:	d1f4      	bne.n	801f07e <tSNAC_ioSamples+0x24a>
 801f094:	46d1      	mov	r9, sl
    for(; n<seek-1; n++)
 801f096:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 801f09a:	45ca      	cmp	sl, r9
 801f09c:	dd6b      	ble.n	801f176 <tSNAC_ioSamples+0x342>
 801f09e:	ea4f 0389 	mov.w	r3, r9, lsl #2
 801f0a2:	2100      	movs	r1, #0
 801f0a4:	9408      	str	r4, [sp, #32]
 801f0a6:	4614      	mov	r4, r2
 801f0a8:	f1a3 0b04 	sub.w	fp, r3, #4
 801f0ac:	4403      	add	r3, r0
 801f0ae:	9509      	str	r5, [sp, #36]	; 0x24
 801f0b0:	4655      	mov	r5, sl
 801f0b2:	9105      	str	r1, [sp, #20]
 801f0b4:	4493      	add	fp, r2
 801f0b6:	ed9f 8a8b 	vldr	s16, [pc, #556]	; 801f2e4 <tSNAC_ioSamples+0x4b0>
 801f0ba:	469a      	mov	sl, r3
 801f0bc:	e005      	b.n	801f0ca <tSNAC_ioSamples+0x296>
 801f0be:	f109 0901 	add.w	r9, r9, #1
 801f0c2:	f10a 0a04 	add.w	sl, sl, #4
 801f0c6:	45a9      	cmp	r9, r5
 801f0c8:	d029      	beq.n	801f11e <tSNAC_ioSamples+0x2ea>
 801f0ca:	4659      	mov	r1, fp
        if(processbuf[n] >= processbuf[n-1])
 801f0cc:	f10b 0b04 	add.w	fp, fp, #4
 801f0d0:	ed91 7a00 	vldr	s14, [r1]
 801f0d4:	eddb 7a00 	vldr	s15, [fp]
 801f0d8:	eef4 7ac7 	vcmpe.f32	s15, s14
 801f0dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f0e0:	dbed      	blt.n	801f0be <tSNAC_ioSamples+0x28a>
            if(processbuf[n] > processbuf[n+1])     // we have a local peak
 801f0e2:	ed9b 7a01 	vldr	s14, [fp, #4]
 801f0e6:	eef4 7ac7 	vcmpe.f32	s15, s14
 801f0ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f0ee:	dde6      	ble.n	801f0be <tSNAC_ioSamples+0x28a>
                biasedpeak = interpolate3max(processbuf, n) * biasbuf[n];
 801f0f0:	4649      	mov	r1, r9
 801f0f2:	4620      	mov	r0, r4
 801f0f4:	f004 fdb8 	bl	8023c68 <interpolate3max>
 801f0f8:	edda 7a00 	vldr	s15, [sl]
 801f0fc:	ee20 0a27 	vmul.f32	s0, s0, s15
                if(biasedpeak > maxvalue)
 801f100:	eeb4 0ac8 	vcmpe.f32	s0, s16
 801f104:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f108:	ddd9      	ble.n	801f0be <tSNAC_ioSamples+0x28a>
 801f10a:	f8cd 9014 	str.w	r9, [sp, #20]
    for(; n<seek-1; n++)
 801f10e:	f109 0901 	add.w	r9, r9, #1
                    maxvalue = biasedpeak;
 801f112:	eeb0 8a40 	vmov.f32	s16, s0
 801f116:	f10a 0a04 	add.w	sl, sl, #4
    for(; n<seek-1; n++)
 801f11a:	45a9      	cmp	r9, r5
 801f11c:	d1d5      	bne.n	801f0ca <tSNAC_ioSamples+0x296>
 801f11e:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 801f122:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
    s->periodindex = peakindex;
 801f126:	9a07      	ldr	r2, [sp, #28]
 801f128:	8353      	strh	r3, [r2, #26]
    _tSNAC* s = *snac;
 801f12a:	9b02      	ldr	r3, [sp, #8]
 801f12c:	f8d3 a000 	ldr.w	sl, [r3]
    if(s->periodindex)
 801f130:	f8ba 901a 	ldrh.w	r9, [sl, #26]
 801f134:	f1b9 0f00 	cmp.w	r9, #0
 801f138:	f43f ae93 	beq.w	801ee62 <tSNAC_ioSamples+0x2e>
        interpolate3phase(s->processbuf, s->periodindex);
 801f13c:	4649      	mov	r1, r9
 801f13e:	f8da 0008 	ldr.w	r0, [sl, #8]
 801f142:	f004 fdaf 	bl	8023ca4 <interpolate3phase>
        periodlength = (float)s->periodindex +
 801f146:	ee07 9a90 	vmov	s15, r9
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
 801f14a:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
        periodlength = (float)s->periodindex +
 801f14e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801f152:	ee37 0a80 	vadd.f32	s0, s15, s0
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
 801f156:	eeb4 0ac7 	vcmpe.f32	s0, s14
 801f15a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f15e:	d40f      	bmi.n	801f180 <tSNAC_ioSamples+0x34c>
        s->periodlength = periodlength;
 801f160:	ed8a 0a07 	vstr	s0, [sl, #28]
        s->fidelity = interpolate3max(s->processbuf, s->periodindex);
 801f164:	f8ba 101a 	ldrh.w	r1, [sl, #26]
 801f168:	f8da 0008 	ldr.w	r0, [sl, #8]
 801f16c:	f004 fd7c 	bl	8023c68 <interpolate3max>
 801f170:	ed8a 0a08 	vstr	s0, [sl, #32]
 801f174:	e675      	b.n	801ee62 <tSNAC_ioSamples+0x2e>
    for(; n<seek-1; n++)
 801f176:	2300      	movs	r3, #0
 801f178:	e7d5      	b.n	801f126 <tSNAC_ioSamples+0x2f2>
    for(n=1; n<seek; n++)
 801f17a:	f04f 0901 	mov.w	r9, #1
 801f17e:	e78a      	b.n	801f096 <tSNAC_ioSamples+0x262>
    if(periodlength < 4.0f) return periodlength;
 801f180:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 801f184:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801f188:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f18c:	d4e8      	bmi.n	801f160 <tSNAC_ioSamples+0x32c>
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
 801f18e:	9b02      	ldr	r3, [sp, #8]
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 801f190:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
 801f194:	eef7 5a04 	vmov.f32	s11, #116	; 0x3fa00000  1.250
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 801f198:	ed9f 6a53 	vldr	s12, [pc, #332]	; 801f2e8 <tSNAC_ioSamples+0x4b4>
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
 801f19c:	f8d3 9000 	ldr.w	r9, [r3]
    int spectrumsize = s->framesize>>1;
 801f1a0:	f8b9 3016 	ldrh.w	r3, [r9, #22]
    float *spectrumbuf = s->spectrumbuf;
 801f1a4:	f8d9 c00c 	ldr.w	ip, [r9, #12]
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
 801f1a8:	ee07 3a10 	vmov	s14, r3
    int spectrumsize = s->framesize>>1;
 801f1ac:	085b      	lsrs	r3, r3, #1
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
 801f1ae:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    if(stopbin >= spectrumsize - 1) stopbin = spectrumsize - 1;
 801f1b2:	1e5a      	subs	r2, r3, #1
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
 801f1b4:	ee37 7a07 	vadd.f32	s14, s14, s14
 801f1b8:	eec7 6a00 	vdiv.f32	s13, s14, s0
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
 801f1bc:	eeb0 7a67 	vmov.f32	s14, s15
 801f1c0:	eea6 7aa5 	vfma.f32	s14, s13, s11
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 801f1c4:	eee6 7a86 	vfma.f32	s15, s13, s12
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
 801f1c8:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 801f1cc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
 801f1d0:	ee17 1a10 	vmov	r1, s14
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 801f1d4:	ee17 3a90 	vmov	r3, s15
 801f1d8:	4291      	cmp	r1, r2
 801f1da:	bfa8      	it	ge
 801f1dc:	4611      	movge	r1, r2
 801f1de:	2b01      	cmp	r3, #1
 801f1e0:	bfb8      	it	lt
 801f1e2:	2301      	movlt	r3, #1
    for(n=startbin; n<stopbin; n++)
 801f1e4:	4299      	cmp	r1, r3
 801f1e6:	dd68      	ble.n	801f2ba <tSNAC_ioSamples+0x486>
 801f1e8:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
    float max = 0.;
 801f1ec:	eddf 6a3d 	vldr	s13, [pc, #244]	; 801f2e4 <tSNAC_ioSamples+0x4b0>
 801f1f0:	441a      	add	r2, r3
 801f1f2:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
 801f1f6:	4610      	mov	r0, r2
        if(spectrumbuf[n] >= spectrumbuf[n-1])
 801f1f8:	3204      	adds	r2, #4
 801f1fa:	ed90 7a00 	vldr	s14, [r0]
 801f1fe:	edd2 7a00 	vldr	s15, [r2]
 801f202:	eef4 7ac7 	vcmpe.f32	s15, s14
 801f206:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f20a:	db0e      	blt.n	801f22a <tSNAC_ioSamples+0x3f6>
            if(spectrumbuf[n] > spectrumbuf[n+1])
 801f20c:	ed92 7a01 	vldr	s14, [r2, #4]
                if(spectrumbuf[n] > max)
 801f210:	eef4 7a47 	vcmp.f32	s15, s14
 801f214:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f218:	dd07      	ble.n	801f22a <tSNAC_ioSamples+0x3f6>
 801f21a:	eef4 7a66 	vcmp.f32	s15, s13
 801f21e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f222:	dd02      	ble.n	801f22a <tSNAC_ioSamples+0x3f6>
                    max = spectrumbuf[n];
 801f224:	eef0 6a67 	vmov.f32	s13, s15
                if(spectrumbuf[n] > max)
 801f228:	9306      	str	r3, [sp, #24]
    for(n=startbin; n<stopbin; n++)
 801f22a:	3301      	adds	r3, #1
 801f22c:	4299      	cmp	r1, r3
 801f22e:	d1e2      	bne.n	801f1f6 <tSNAC_ioSamples+0x3c2>
    for(n=(peakbin-1); n<(peakbin+2); n++)
 801f230:	9906      	ldr	r1, [sp, #24]
 801f232:	1e4b      	subs	r3, r1, #1
 801f234:	1c8a      	adds	r2, r1, #2
 801f236:	ee07 1a90 	vmov	s15, r1
 801f23a:	429a      	cmp	r2, r3
 801f23c:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 801f240:	dd2a      	ble.n	801f298 <tSNAC_ioSamples+0x464>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f242:	009b      	lsls	r3, r3, #2
 801f244:	eb0c 0103 	add.w	r1, ip, r3
 801f248:	ed91 7a00 	vldr	s14, [r1]
 801f24c:	eef1 7ac7 	vsqrt.f32	s15, s14
 801f250:	edc1 7a00 	vstr	s15, [r1]
    for(n=(peakbin-1); n<(peakbin+2); n++)
 801f254:	9906      	ldr	r1, [sp, #24]
 801f256:	428a      	cmp	r2, r1
 801f258:	dd1e      	ble.n	801f298 <tSNAC_ioSamples+0x464>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f25a:	3304      	adds	r3, #4
    for(n=(peakbin-1); n<(peakbin+2); n++)
 801f25c:	1c48      	adds	r0, r1, #1
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f25e:	eb0c 0103 	add.w	r1, ip, r3
    for(n=(peakbin-1); n<(peakbin+2); n++)
 801f262:	4282      	cmp	r2, r0
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f264:	ed91 7a00 	vldr	s14, [r1]
 801f268:	eef1 7ac7 	vsqrt.f32	s15, s14
 801f26c:	edc1 7a00 	vstr	s15, [r1]
    for(n=(peakbin-1); n<(peakbin+2); n++)
 801f270:	dd12      	ble.n	801f298 <tSNAC_ioSamples+0x464>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f272:	1d19      	adds	r1, r3, #4
    for(n=(peakbin-1); n<(peakbin+2); n++)
 801f274:	3001      	adds	r0, #1
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f276:	4461      	add	r1, ip
    for(n=(peakbin-1); n<(peakbin+2); n++)
 801f278:	4282      	cmp	r2, r0
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f27a:	ed91 7a00 	vldr	s14, [r1]
 801f27e:	eef1 7ac7 	vsqrt.f32	s15, s14
 801f282:	edc1 7a00 	vstr	s15, [r1]
    for(n=(peakbin-1); n<(peakbin+2); n++)
 801f286:	dd07      	ble.n	801f298 <tSNAC_ioSamples+0x464>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f288:	3308      	adds	r3, #8
 801f28a:	4463      	add	r3, ip
 801f28c:	ed93 7a00 	vldr	s14, [r3]
 801f290:	eef1 7ac7 	vsqrt.f32	s15, s14
 801f294:	edc3 7a00 	vstr	s15, [r3]
    peaklocation = (float)peakbin + interpolate3phase(spectrumbuf, peakbin);
 801f298:	9906      	ldr	r1, [sp, #24]
 801f29a:	4660      	mov	r0, ip
 801f29c:	f004 fd02 	bl	8023ca4 <interpolate3phase>
    periodlength = (float)(s->framesize * 2.0f) / peaklocation;
 801f2a0:	f8b9 3016 	ldrh.w	r3, [r9, #22]
    peaklocation = (float)peakbin + interpolate3phase(spectrumbuf, peakbin);
 801f2a4:	ee30 8a08 	vadd.f32	s16, s0, s16
    periodlength = (float)(s->framesize * 2.0f) / peaklocation;
 801f2a8:	ee07 3a90 	vmov	s15, r3
 801f2ac:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801f2b0:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801f2b4:	ee87 0a88 	vdiv.f32	s0, s15, s16
 801f2b8:	e752      	b.n	801f160 <tSNAC_ioSamples+0x32c>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f2ba:	ed5c 7a01 	vldr	s15, [ip, #-4]
    for(n=(peakbin-1); n<(peakbin+2); n++)
 801f2be:	2001      	movs	r0, #1
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f2c0:	eddc 6a00 	vldr	s13, [ip]
 801f2c4:	2300      	movs	r3, #0
 801f2c6:	eeb1 7ae7 	vsqrt.f32	s14, s15
    for(n=(peakbin-1); n<(peakbin+2); n++)
 801f2ca:	2202      	movs	r2, #2
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 801f2cc:	ed9f 8a05 	vldr	s16, [pc, #20]	; 801f2e4 <tSNAC_ioSamples+0x4b0>
 801f2d0:	eef1 7ae6 	vsqrt.f32	s15, s13
 801f2d4:	ed0c 7a01 	vstr	s14, [ip, #-4]
 801f2d8:	edcc 7a00 	vstr	s15, [ip]
 801f2dc:	e7c9      	b.n	801f272 <tSNAC_ioSamples+0x43e>
 801f2de:	bf00      	nop
 801f2e0:	3f59999a 	.word	0x3f59999a
 801f2e4:	00000000 	.word	0x00000000
 801f2e8:	3f4ccccd 	.word	0x3f4ccccd

0801f2ec <tPeriodDetection_initToPool>:
{
    tPeriodDetection_initToPool(pd, in, out, bufSize, frameSize, &leaf.mempool);
}

void tPeriodDetection_initToPool (tPeriodDetection* const pd, float* in, float* out, int bufSize, int frameSize, tMempool* const mp)
{
 801f2ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f2f0:	b085      	sub	sp, #20
 801f2f2:	4682      	mov	sl, r0
 801f2f4:	468b      	mov	fp, r1
    _tMempool* m = *mp;
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
 801f2f6:	2068      	movs	r0, #104	; 0x68
{
 801f2f8:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 801f2fa:	461d      	mov	r5, r3
 801f2fc:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    p->inBuffer = in;
    p->outBuffer = out;
    p->bufSize = bufSize;
    p->frameSize = frameSize;
    p->framesPerBuffer = p->bufSize / p->frameSize;
    p->curBlock = 1;
 801f2fe:	f04f 0801 	mov.w	r8, #1
    _tMempool* m = *mp;
 801f302:	f8d6 9000 	ldr.w	r9, [r6]
{
 801f306:	9203      	str	r2, [sp, #12]
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
 801f308:	4649      	mov	r1, r9
 801f30a:	f005 f831 	bl	8024370 <mpool_calloc>
 801f30e:	4604      	mov	r4, r0
    p->lastBlock = 0;
 801f310:	f04f 0c00 	mov.w	ip, #0
    p->outBuffer = out;
 801f314:	9b03      	ldr	r3, [sp, #12]
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
 801f316:	f8ca 4000 	str.w	r4, [sl]
    
    p->hopSize = DEFHOPSIZE;
    p->windowSize = DEFWINDOWSIZE;
    p->fba = FBA;
    
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
 801f31a:	2240      	movs	r2, #64	; 0x40
    p->hopSize = DEFHOPSIZE;
 801f31c:	f04f 1040 	mov.w	r0, #4194368	; 0x400040
    p->fba = FBA;
 801f320:	2114      	movs	r1, #20
    p->index = 0;
 801f322:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
    p->outBuffer = out;
 801f326:	6123      	str	r3, [r4, #16]
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
 801f328:	463b      	mov	r3, r7
    p->hopSize = DEFHOPSIZE;
 801f32a:	63e0      	str	r0, [r4, #60]	; 0x3c
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
 801f32c:	1d20      	adds	r0, r4, #4
    p->fba = FBA;
 801f32e:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
 801f332:	4611      	mov	r1, r2
    p->mempool = m;
 801f334:	f8c4 9000 	str.w	r9, [r4]
    p->inBuffer = in;
 801f338:	f8c4 b00c 	str.w	fp, [r4, #12]
    p->frameSize = frameSize;
 801f33c:	e9c4 7505 	strd	r7, r5, [r4, #20]
    p->framesPerBuffer = p->bufSize / p->frameSize;
 801f340:	fb95 f5f7 	sdiv	r5, r5, r7
    p->lastBlock = 0;
 801f344:	e9c4 8c08 	strd	r8, ip, [r4, #32]
    p->framesPerBuffer = p->bufSize / p->frameSize;
 801f348:	61e5      	str	r5, [r4, #28]
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
 801f34a:	9600      	str	r6, [sp, #0]
 801f34c:	f7ff fbd2 	bl	801eaf4 <tEnvPD_initToPool>
    
    tSNAC_initToPool(&p->snac, DEFOVERLAP, mp);
 801f350:	4632      	mov	r2, r6
 801f352:	4641      	mov	r1, r8
 801f354:	f104 0008 	add.w	r0, r4, #8
 801f358:	f7ff fcda 	bl	801ed10 <tSNAC_initToPool>

    p->history = 0.0f;
    p->alpha = 1.0f;
    p->tolerance = 1.0f;
    p->timeConstant = DEFTIMECONSTANT;
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 801f35c:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 801f35e:	4b0f      	ldr	r3, [pc, #60]	; (801f39c <tPeriodDetection_initToPool+0xb0>)
 801f360:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
 801f364:	ee00 2a10 	vmov	s0, r2
    p->history = 0.0f;
 801f368:	2100      	movs	r1, #0
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 801f36a:	edd3 7a01 	vldr	s15, [r3, #4]
    p->alpha = 1.0f;
 801f36e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 801f372:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    p->timeConstant = DEFTIMECONSTANT;
 801f376:	4a0a      	ldr	r2, [pc, #40]	; (801f3a0 <tPeriodDetection_initToPool+0xb4>)
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 801f378:	ee67 7a87 	vmul.f32	s15, s15, s14
    p->alpha = 1.0f;
 801f37c:	6623      	str	r3, [r4, #96]	; 0x60
    p->tolerance = 1.0f;
 801f37e:	6663      	str	r3, [r4, #100]	; 0x64
    p->history = 0.0f;
 801f380:	65e1      	str	r1, [r4, #92]	; 0x5c
    p->timeConstant = DEFTIMECONSTANT;
 801f382:	6462      	str	r2, [r4, #68]	; 0x44
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 801f384:	ee20 0a27 	vmul.f32	s0, s0, s15
 801f388:	f007 ff8a 	bl	80272a0 <expf>
    p->fidelityThreshold = 0.95f;
 801f38c:	4b05      	ldr	r3, [pc, #20]	; (801f3a4 <tPeriodDetection_initToPool+0xb8>)
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 801f38e:	ed84 0a12 	vstr	s0, [r4, #72]	; 0x48
    p->fidelityThreshold = 0.95f;
 801f392:	65a3      	str	r3, [r4, #88]	; 0x58
}
 801f394:	b005      	add	sp, #20
 801f396:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f39a:	bf00      	nop
 801f39c:	200194e8 	.word	0x200194e8
 801f3a0:	42c80000 	.word	0x42c80000
 801f3a4:	3f733333 	.word	0x3f733333

0801f3a8 <tPeriodDetection_free>:

void tPeriodDetection_free (tPeriodDetection* const pd)
{
 801f3a8:	b538      	push	{r3, r4, r5, lr}
    _tPeriodDetection* p = *pd;
 801f3aa:	6805      	ldr	r5, [r0, #0]
    _tEnvPD* x = *xpd;
 801f3ac:	6868      	ldr	r0, [r5, #4]
    mpool_free((char*)x, x->mempool);
 801f3ae:	6801      	ldr	r1, [r0, #0]
 801f3b0:	f005 f836 	bl	8024420 <mpool_free>
    _tSNAC* s = *snac;
 801f3b4:	68ac      	ldr	r4, [r5, #8]
    mpool_free((char*)s->inputbuf, s->mempool);
 801f3b6:	e9d4 1000 	ldrd	r1, r0, [r4]
 801f3ba:	f005 f831 	bl	8024420 <mpool_free>
    mpool_free((char*)s->processbuf, s->mempool);
 801f3be:	6821      	ldr	r1, [r4, #0]
 801f3c0:	68a0      	ldr	r0, [r4, #8]
 801f3c2:	f005 f82d 	bl	8024420 <mpool_free>
    mpool_free((char*)s->spectrumbuf, s->mempool);
 801f3c6:	6821      	ldr	r1, [r4, #0]
 801f3c8:	68e0      	ldr	r0, [r4, #12]
 801f3ca:	f005 f829 	bl	8024420 <mpool_free>
    mpool_free((char*)s->biasbuf, s->mempool);
 801f3ce:	6821      	ldr	r1, [r4, #0]
 801f3d0:	6920      	ldr	r0, [r4, #16]
 801f3d2:	f005 f825 	bl	8024420 <mpool_free>
    mpool_free((char*)s, s->mempool);
 801f3d6:	6821      	ldr	r1, [r4, #0]
 801f3d8:	4620      	mov	r0, r4
 801f3da:	f005 f821 	bl	8024420 <mpool_free>
    
    tEnvPD_free(&p->env);
    tSNAC_free(&p->snac);
    mpool_free((char*)p, p->mempool);
 801f3de:	6829      	ldr	r1, [r5, #0]
 801f3e0:	4628      	mov	r0, r5
}
 801f3e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    mpool_free((char*)p, p->mempool);
 801f3e6:	f005 b81b 	b.w	8024420 <mpool_free>
 801f3ea:	bf00      	nop

0801f3ec <tPeriodDetection_tick>:

float tPeriodDetection_tick (tPeriodDetection* pd, float sample)
{
 801f3ec:	b538      	push	{r3, r4, r5, lr}
    _tPeriodDetection* p = *pd;
 801f3ee:	6804      	ldr	r4, [r0, #0]
    
    int i, iLast;
    
    i = (p->curBlock*p->frameSize);
 801f3f0:	6962      	ldr	r2, [r4, #20]
 801f3f2:	6a23      	ldr	r3, [r4, #32]
    iLast = (p->lastBlock*p->frameSize)+p->index;
 801f3f4:	6b61      	ldr	r1, [r4, #52]	; 0x34
    i = (p->curBlock*p->frameSize);
 801f3f6:	fb03 f302 	mul.w	r3, r3, r2
    iLast = (p->lastBlock*p->frameSize)+p->index;
 801f3fa:	6a65      	ldr	r5, [r4, #36]	; 0x24
    
    p->i = i;
    p->iLast = iLast;
    
    p->inBuffer[i+p->index] = sample;
 801f3fc:	68e0      	ldr	r0, [r4, #12]
    iLast = (p->lastBlock*p->frameSize)+p->index;
 801f3fe:	fb05 1202 	mla	r2, r5, r2, r1
    p->inBuffer[i+p->index] = sample;
 801f402:	4419      	add	r1, r3
    p->i = i;
 801f404:	62a3      	str	r3, [r4, #40]	; 0x28
    p->inBuffer[i+p->index] = sample;
 801f406:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    p->iLast = iLast;
 801f40a:	6322      	str	r2, [r4, #48]	; 0x30
    p->inBuffer[i+p->index] = sample;
 801f40c:	ed81 0a00 	vstr	s0, [r1]
    
    p->index++;
 801f410:	6b62      	ldr	r2, [r4, #52]	; 0x34
    p->indexstore = p->index;
    if (p->index >= p->frameSize)
 801f412:	6961      	ldr	r1, [r4, #20]
    p->index++;
 801f414:	3201      	adds	r2, #1
    if (p->index >= p->frameSize)
 801f416:	428a      	cmp	r2, r1
    p->index++;
 801f418:	6362      	str	r2, [r4, #52]	; 0x34
    p->indexstore = p->index;
 801f41a:	62e2      	str	r2, [r4, #44]	; 0x2c
    if (p->index >= p->frameSize)
 801f41c:	da02      	bge.n	801f424 <tPeriodDetection_tick+0x38>
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
        p->lastBlock++;
        if (p->lastBlock >= p->framesPerBuffer) p->lastBlock = 0;
    }
    return p->period;
}
 801f41e:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
 801f422:	bd38      	pop	{r3, r4, r5, pc}
        tEnvPD_processBlock(&p->env, &(p->inBuffer[i]));
 801f424:	009d      	lsls	r5, r3, #2
 801f426:	68e1      	ldr	r1, [r4, #12]
        p->index = 0;
 801f428:	2300      	movs	r3, #0
        tEnvPD_processBlock(&p->env, &(p->inBuffer[i]));
 801f42a:	1d20      	adds	r0, r4, #4
 801f42c:	4429      	add	r1, r5
        p->index = 0;
 801f42e:	6363      	str	r3, [r4, #52]	; 0x34
        tEnvPD_processBlock(&p->env, &(p->inBuffer[i]));
 801f430:	f7ff fbfe 	bl	801ec30 <tEnvPD_processBlock>
        tSNAC_ioSamples(&p->snac, &(p->inBuffer[i]), &(p->outBuffer[i]), p->frameSize);
 801f434:	6963      	ldr	r3, [r4, #20]
 801f436:	f104 0008 	add.w	r0, r4, #8
 801f43a:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
 801f43e:	442a      	add	r2, r5
 801f440:	4429      	add	r1, r5
 801f442:	f7ff fcf7 	bl	801ee34 <tSNAC_ioSamples>
    _tSNAC* s = *snac;
 801f446:	68a3      	ldr	r3, [r4, #8]
        if (fidelity > p->fidelityThreshold)
 801f448:	ed94 7a16 	vldr	s14, [r4, #88]	; 0x58
 801f44c:	edd3 7a08 	vldr	s15, [r3, #32]
 801f450:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801f454:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f458:	d501      	bpl.n	801f45e <tPeriodDetection_tick+0x72>
    return(s->periodlength);
 801f45a:	69db      	ldr	r3, [r3, #28]
            p->period = tSNAC_getPeriod(&p->snac);
 801f45c:	63a3      	str	r3, [r4, #56]	; 0x38
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
 801f45e:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
        p->curBlock++;
 801f462:	3301      	adds	r3, #1
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
 801f464:	4293      	cmp	r3, r2
        p->curBlock++;
 801f466:	6223      	str	r3, [r4, #32]
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
 801f468:	db01      	blt.n	801f46e <tPeriodDetection_tick+0x82>
 801f46a:	2300      	movs	r3, #0
 801f46c:	6223      	str	r3, [r4, #32]
        p->lastBlock++;
 801f46e:	6a63      	ldr	r3, [r4, #36]	; 0x24
}
 801f470:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
        p->lastBlock++;
 801f474:	3301      	adds	r3, #1
        if (p->lastBlock >= p->framesPerBuffer) p->lastBlock = 0;
 801f476:	429a      	cmp	r2, r3
 801f478:	bfd8      	it	le
 801f47a:	2300      	movle	r3, #0
 801f47c:	6263      	str	r3, [r4, #36]	; 0x24
}
 801f47e:	bd38      	pop	{r3, r4, r5, pc}

0801f480 <tPeriodDetection_getPeriod>:

float tPeriodDetection_getPeriod(tPeriodDetection* pd)
{
    _tPeriodDetection* p = *pd;
    return p->period;
 801f480:	6803      	ldr	r3, [r0, #0]
}
 801f482:	ed93 0a0e 	vldr	s0, [r3, #56]	; 0x38
 801f486:	4770      	bx	lr

0801f488 <tPeriodDetection_setFidelityThreshold>:
    p->windowSize = ws;
}

void tPeriodDetection_setFidelityThreshold(tPeriodDetection* pd, float threshold)
{
    _tPeriodDetection* p = *pd;
 801f488:	6803      	ldr	r3, [r0, #0]
    p->fidelityThreshold = threshold;
 801f48a:	ed83 0a16 	vstr	s0, [r3, #88]	; 0x58
}
 801f48e:	4770      	bx	lr

0801f490 <tLinearDelay_initToPool>:
{
    tLinearDelay_initToPool(dl, delay, maxDelay, &leaf.mempool);
}

void tLinearDelay_initToPool  (tLinearDelay* const dl, float delay, uint32_t maxDelay, tMempool* const mp)
{
 801f490:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801f492:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 801f496:	6816      	ldr	r6, [r2, #0]
{
 801f498:	460d      	mov	r5, r1
 801f49a:	4607      	mov	r7, r0
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
 801f49c:	202c      	movs	r0, #44	; 0x2c
 801f49e:	4631      	mov	r1, r6
{
 801f4a0:	eeb0 8a40 	vmov.f32	s16, s0
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
 801f4a4:	f004 ff08 	bl	80242b8 <mpool_alloc>
    d->mempool = m;

    d->maxDelay = maxDelay;

    if (delay > maxDelay)   d->delay = maxDelay;
 801f4a8:	ee07 5a90 	vmov	s15, r5
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
 801f4ac:	6038      	str	r0, [r7, #0]
 801f4ae:	4604      	mov	r4, r0
    if (delay > maxDelay)   d->delay = maxDelay;
 801f4b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
    d->mempool = m;
 801f4b4:	6006      	str	r6, [r0, #0]
    d->maxDelay = maxDelay;
 801f4b6:	61c5      	str	r5, [r0, #28]
    if (delay > maxDelay)   d->delay = maxDelay;
 801f4b8:	eef4 7ac8 	vcmpe.f32	s15, s16
 801f4bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f4c0:	d457      	bmi.n	801f572 <tLinearDelay_initToPool+0xe2>
    else if (delay < 0.0f)  d->delay = 0.0f;
 801f4c2:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 801f4c6:	2300      	movs	r3, #0
 801f4c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f4cc:	bf4c      	ite	mi
 801f4ce:	6203      	strmi	r3, [r0, #32]
    else                    d->delay = delay;
 801f4d0:	ed80 8a08 	vstrpl	s16, [r0, #32]

    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 801f4d4:	4631      	mov	r1, r6
 801f4d6:	00a8      	lsls	r0, r5, #2
 801f4d8:	f004 feee 	bl	80242b8 <mpool_alloc>

    d->gain = 1.0f;

    d->lastIn = 0.0f;
 801f4dc:	eddf 7a26 	vldr	s15, [pc, #152]	; 801f578 <tLinearDelay_initToPool+0xe8>
    d->gain = 1.0f;
 801f4e0:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
    d->lastOut = 0.0f;
    
    d->inPoint = 0;
 801f4e4:	2300      	movs	r3, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 801f4e6:	60a0      	str	r0, [r4, #8]

int     tLinearDelay_setDelay (tLinearDelay* const dl, float delay)
{
    _tLinearDelay* d = *dl;

    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 801f4e8:	eeb0 0a67 	vmov.f32	s0, s15
    d->gain = 1.0f;
 801f4ec:	6062      	str	r2, [r4, #4]
    d->lastIn = 0.0f;
 801f4ee:	edc4 7a04 	vstr	s15, [r4, #16]
    d->lastOut = 0.0f;
 801f4f2:	edc4 7a03 	vstr	s15, [r4, #12]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 801f4f6:	edd4 0a08 	vldr	s1, [r4, #32]
    d->outPoint = 0;
 801f4fa:	e9c4 3305 	strd	r3, r3, [r4, #20]
    _tLinearDelay* d = *dl;
 801f4fe:	683d      	ldr	r5, [r7, #0]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 801f500:	edd5 7a07 	vldr	s15, [r5, #28]
 801f504:	eeb8 1a67 	vcvt.f32.u32	s2, s15
 801f508:	f004 fcd4 	bl	8023eb4 <LEAF_clip>

    float outPointer = d->inPoint - d->delay;
 801f50c:	edd5 7a05 	vldr	s15, [r5, #20]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 801f510:	ed85 0a08 	vstr	s0, [r5, #32]
    float outPointer = d->inPoint - d->delay;
 801f514:	eef8 7a67 	vcvt.f32.u32	s15, s15

    while ( outPointer < 0 )
        outPointer += d->maxDelay; // modulo maximum length
 801f518:	69ea      	ldr	r2, [r5, #28]
    float outPointer = d->inPoint - d->delay;
 801f51a:	ee37 0ac0 	vsub.f32	s0, s15, s0
    while ( outPointer < 0 )
 801f51e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801f522:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f526:	d50a      	bpl.n	801f53e <tLinearDelay_initToPool+0xae>
        outPointer += d->maxDelay; // modulo maximum length
 801f528:	ee07 2a90 	vmov	s15, r2
 801f52c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801f530:	ee30 0a27 	vadd.f32	s0, s0, s15
    while ( outPointer < 0 )
 801f534:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801f538:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f53c:	d4f8      	bmi.n	801f530 <tLinearDelay_initToPool+0xa0>

    d->outPoint = (uint32_t) outPointer;   // integer part
 801f53e:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 801f542:	ee17 3a90 	vmov	r3, s15

    d->alpha = outPointer - d->outPoint; // fractional part
    d->omAlpha = 1.0f - d->alpha;
 801f546:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->alpha = outPointer - d->outPoint; // fractional part
 801f54a:	ee07 3a10 	vmov	s14, r3

    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
 801f54e:	4293      	cmp	r3, r2
    d->outPoint = (uint32_t) outPointer;   // integer part
 801f550:	61ab      	str	r3, [r5, #24]
    d->alpha = outPointer - d->outPoint; // fractional part
 801f552:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801f556:	ee30 0a47 	vsub.f32	s0, s0, s14
    d->omAlpha = 1.0f - d->alpha;
 801f55a:	ee77 7ac0 	vsub.f32	s15, s15, s0
    d->alpha = outPointer - d->outPoint; // fractional part
 801f55e:	ed85 0a09 	vstr	s0, [r5, #36]	; 0x24
    d->omAlpha = 1.0f - d->alpha;
 801f562:	edc5 7a0a 	vstr	s15, [r5, #40]	; 0x28
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
 801f566:	d101      	bne.n	801f56c <tLinearDelay_initToPool+0xdc>
 801f568:	2300      	movs	r3, #0
 801f56a:	61ab      	str	r3, [r5, #24]
}
 801f56c:	ecbd 8b02 	vpop	{d8}
 801f570:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (delay > maxDelay)   d->delay = maxDelay;
 801f572:	edc0 7a08 	vstr	s15, [r0, #32]
 801f576:	e7ad      	b.n	801f4d4 <tLinearDelay_initToPool+0x44>
 801f578:	00000000 	.word	0x00000000

0801f57c <tLinearDelay_free>:
{
 801f57c:	b510      	push	{r4, lr}
    _tLinearDelay* d = *dl;
 801f57e:	6804      	ldr	r4, [r0, #0]
    mpool_free((char*)d->buff, d->mempool);
 801f580:	6821      	ldr	r1, [r4, #0]
 801f582:	68a0      	ldr	r0, [r4, #8]
 801f584:	f004 ff4c 	bl	8024420 <mpool_free>
    mpool_free((char*)d, d->mempool);
 801f588:	6821      	ldr	r1, [r4, #0]
 801f58a:	4620      	mov	r0, r4
}
 801f58c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)d, d->mempool);
 801f590:	f004 bf46 	b.w	8024420 <mpool_free>

0801f594 <tLinearDelay_clear>:
    _tLinearDelay* d = *dl;
 801f594:	6801      	ldr	r1, [r0, #0]
    for (uint i = 0; i < d->maxDelay; i++)
 801f596:	69cb      	ldr	r3, [r1, #28]
 801f598:	b14b      	cbz	r3, 801f5ae <tLinearDelay_clear+0x1a>
 801f59a:	2300      	movs	r3, #0
        d->buff[i] = 0;
 801f59c:	2000      	movs	r0, #0
 801f59e:	688a      	ldr	r2, [r1, #8]
 801f5a0:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    for (uint i = 0; i < d->maxDelay; i++)
 801f5a4:	3301      	adds	r3, #1
        d->buff[i] = 0;
 801f5a6:	6010      	str	r0, [r2, #0]
    for (uint i = 0; i < d->maxDelay; i++)
 801f5a8:	69ca      	ldr	r2, [r1, #28]
 801f5aa:	429a      	cmp	r2, r3
 801f5ac:	d8f7      	bhi.n	801f59e <tLinearDelay_clear+0xa>
}
 801f5ae:	4770      	bx	lr

0801f5b0 <tLinearDelay_tick>:
{
 801f5b0:	b410      	push	{r4}
    _tLinearDelay* d = *dl;
 801f5b2:	6803      	ldr	r3, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
 801f5b4:	edd3 7a01 	vldr	s15, [r3, #4]
 801f5b8:	6959      	ldr	r1, [r3, #20]
 801f5ba:	689a      	ldr	r2, [r3, #8]
 801f5bc:	ee27 0a80 	vmul.f32	s0, s15, s0
 801f5c0:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 801f5c4:	ed82 0a00 	vstr	s0, [r2]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
 801f5c8:	695a      	ldr	r2, [r3, #20]
 801f5ca:	69d9      	ldr	r1, [r3, #28]
 801f5cc:	3201      	adds	r2, #1
 801f5ce:	428a      	cmp	r2, r1
 801f5d0:	615a      	str	r2, [r3, #20]
 801f5d2:	d101      	bne.n	801f5d8 <tLinearDelay_tick+0x28>
 801f5d4:	2200      	movs	r2, #0
 801f5d6:	615a      	str	r2, [r3, #20]
    uint32_t idx = (uint32_t) d->outPoint;
 801f5d8:	699a      	ldr	r2, [r3, #24]
    d->lastOut = d->buff[idx] * d->omAlpha;
 801f5da:	6898      	ldr	r0, [r3, #8]
    if ((idx + 1) < d->maxDelay)
 801f5dc:	1c54      	adds	r4, r2, #1
    d->lastOut = d->buff[idx] * d->omAlpha;
 801f5de:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
 801f5e2:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 801f5e6:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    if ((idx + 1) < d->maxDelay)
 801f5ea:	42a1      	cmp	r1, r4
    d->lastOut = d->buff[idx] * d->omAlpha;
 801f5ec:	ed92 0a00 	vldr	s0, [r2]
 801f5f0:	ee20 0a07 	vmul.f32	s0, s0, s14
 801f5f4:	ed83 0a03 	vstr	s0, [r3, #12]
    if ((idx + 1) < d->maxDelay)
 801f5f8:	d909      	bls.n	801f60e <tLinearDelay_tick+0x5e>
        d->lastOut += d->buff[idx+1] * d->alpha;
 801f5fa:	ed92 7a01 	vldr	s14, [r2, #4]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 801f5fe:	619c      	str	r4, [r3, #24]
        d->lastOut += d->buff[idx+1] * d->alpha;
 801f600:	eea7 0a27 	vfma.f32	s0, s14, s15
 801f604:	ed83 0a03 	vstr	s0, [r3, #12]
}
 801f608:	f85d 4b04 	ldr.w	r4, [sp], #4
 801f60c:	4770      	bx	lr
        d->lastOut += d->buff[0] * d->alpha;
 801f60e:	ed90 7a00 	vldr	s14, [r0]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 801f612:	2200      	movs	r2, #0
        d->lastOut += d->buff[0] * d->alpha;
 801f614:	eea7 0a27 	vfma.f32	s0, s14, s15
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 801f618:	619a      	str	r2, [r3, #24]
        d->lastOut += d->buff[0] * d->alpha;
 801f61a:	ed83 0a03 	vstr	s0, [r3, #12]
}
 801f61e:	f85d 4b04 	ldr.w	r4, [sp], #4
 801f622:	4770      	bx	lr

0801f624 <tLinearDelay_tickIn>:
    _tLinearDelay* d = *dl;
 801f624:	6803      	ldr	r3, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
 801f626:	edd3 7a01 	vldr	s15, [r3, #4]
 801f62a:	6959      	ldr	r1, [r3, #20]
 801f62c:	689a      	ldr	r2, [r3, #8]
 801f62e:	ee27 0a80 	vmul.f32	s0, s15, s0
 801f632:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 801f636:	ed82 0a00 	vstr	s0, [r2]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
 801f63a:	695a      	ldr	r2, [r3, #20]
 801f63c:	69d9      	ldr	r1, [r3, #28]
 801f63e:	3201      	adds	r2, #1
 801f640:	428a      	cmp	r2, r1
 801f642:	615a      	str	r2, [r3, #20]
 801f644:	d101      	bne.n	801f64a <tLinearDelay_tickIn+0x26>
 801f646:	2200      	movs	r2, #0
 801f648:	615a      	str	r2, [r3, #20]
}
 801f64a:	4770      	bx	lr

0801f64c <tLinearDelay_tickOut>:
{
 801f64c:	b410      	push	{r4}
    _tLinearDelay* d = *dl;
 801f64e:	6803      	ldr	r3, [r0, #0]
    uint32_t idx = (uint32_t) d->outPoint;
 801f650:	699a      	ldr	r2, [r3, #24]
    d->lastOut = d->buff[idx] * d->omAlpha;
 801f652:	6899      	ldr	r1, [r3, #8]
    if ((idx + 1) < d->maxDelay)
 801f654:	1c50      	adds	r0, r2, #1
    d->lastOut = d->buff[idx] * d->omAlpha;
 801f656:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
 801f65a:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    if ((idx + 1) < d->maxDelay)
 801f65e:	69dc      	ldr	r4, [r3, #28]
 801f660:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    d->lastOut = d->buff[idx] * d->omAlpha;
 801f664:	ed92 0a00 	vldr	s0, [r2]
    if ((idx + 1) < d->maxDelay)
 801f668:	42a0      	cmp	r0, r4
    d->lastOut = d->buff[idx] * d->omAlpha;
 801f66a:	ee20 0a07 	vmul.f32	s0, s0, s14
 801f66e:	ed83 0a03 	vstr	s0, [r3, #12]
    if ((idx + 1) < d->maxDelay)
 801f672:	d209      	bcs.n	801f688 <tLinearDelay_tickOut+0x3c>
        d->lastOut += d->buff[idx+1] * d->alpha;
 801f674:	ed92 7a01 	vldr	s14, [r2, #4]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 801f678:	6198      	str	r0, [r3, #24]
        d->lastOut += d->buff[idx+1] * d->alpha;
 801f67a:	eea7 0a27 	vfma.f32	s0, s14, s15
 801f67e:	ed83 0a03 	vstr	s0, [r3, #12]
}
 801f682:	f85d 4b04 	ldr.w	r4, [sp], #4
 801f686:	4770      	bx	lr
        d->lastOut += d->buff[0] * d->alpha;
 801f688:	ed91 7a00 	vldr	s14, [r1]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 801f68c:	2200      	movs	r2, #0
        d->lastOut += d->buff[0] * d->alpha;
 801f68e:	eea7 0a27 	vfma.f32	s0, s14, s15
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 801f692:	619a      	str	r2, [r3, #24]
        d->lastOut += d->buff[0] * d->alpha;
 801f694:	ed83 0a03 	vstr	s0, [r3, #12]
}
 801f698:	f85d 4b04 	ldr.w	r4, [sp], #4
 801f69c:	4770      	bx	lr
 801f69e:	bf00      	nop

0801f6a0 <tLinearDelay_setDelay>:
{
 801f6a0:	b510      	push	{r4, lr}
    _tLinearDelay* d = *dl;
 801f6a2:	6804      	ldr	r4, [r0, #0]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 801f6a4:	eef0 0a40 	vmov.f32	s1, s0
 801f6a8:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 801f71c <tLinearDelay_setDelay+0x7c>
 801f6ac:	edd4 7a07 	vldr	s15, [r4, #28]
 801f6b0:	eeb8 1a67 	vcvt.f32.u32	s2, s15
 801f6b4:	f004 fbfe 	bl	8023eb4 <LEAF_clip>
    float outPointer = d->inPoint - d->delay;
 801f6b8:	edd4 7a05 	vldr	s15, [r4, #20]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 801f6bc:	ed84 0a08 	vstr	s0, [r4, #32]
    float outPointer = d->inPoint - d->delay;
 801f6c0:	eef8 7a67 	vcvt.f32.u32	s15, s15
        outPointer += d->maxDelay; // modulo maximum length
 801f6c4:	69e2      	ldr	r2, [r4, #28]
    float outPointer = d->inPoint - d->delay;
 801f6c6:	ee37 0ac0 	vsub.f32	s0, s15, s0
    while ( outPointer < 0 )
 801f6ca:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801f6ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f6d2:	d50a      	bpl.n	801f6ea <tLinearDelay_setDelay+0x4a>
        outPointer += d->maxDelay; // modulo maximum length
 801f6d4:	ee07 2a90 	vmov	s15, r2
 801f6d8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801f6dc:	ee30 0a27 	vadd.f32	s0, s0, s15
    while ( outPointer < 0 )
 801f6e0:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801f6e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f6e8:	d4f8      	bmi.n	801f6dc <tLinearDelay_setDelay+0x3c>
    d->outPoint = (uint32_t) outPointer;   // integer part
 801f6ea:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 801f6ee:	ee17 3a90 	vmov	r3, s15
    d->omAlpha = 1.0f - d->alpha;
 801f6f2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->alpha = outPointer - d->outPoint; // fractional part
 801f6f6:	ee07 3a10 	vmov	s14, r3
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
 801f6fa:	4293      	cmp	r3, r2
    d->outPoint = (uint32_t) outPointer;   // integer part
 801f6fc:	61a3      	str	r3, [r4, #24]
    d->alpha = outPointer - d->outPoint; // fractional part
 801f6fe:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801f702:	ee30 0a47 	vsub.f32	s0, s0, s14
    d->omAlpha = 1.0f - d->alpha;
 801f706:	ee77 7ac0 	vsub.f32	s15, s15, s0
    d->alpha = outPointer - d->outPoint; // fractional part
 801f70a:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
    d->omAlpha = 1.0f - d->alpha;
 801f70e:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
 801f712:	d101      	bne.n	801f718 <tLinearDelay_setDelay+0x78>
 801f714:	2300      	movs	r3, #0
 801f716:	61a3      	str	r3, [r4, #24]

    return 0;
}
 801f718:	2000      	movs	r0, #0
 801f71a:	bd10      	pop	{r4, pc}
 801f71c:	00000000 	.word	0x00000000

0801f720 <tLinearDelay_getDelay>:
}

float   tLinearDelay_getDelay (tLinearDelay* const dl)
{
    _tLinearDelay* d = *dl;
    return d->delay;
 801f720:	6803      	ldr	r3, [r0, #0]
}
 801f722:	ed93 0a08 	vldr	s0, [r3, #32]
 801f726:	4770      	bx	lr

0801f728 <tLinearDelay_getLastOut>:

float   tLinearDelay_getLastOut (tLinearDelay* const dl)
{
    _tLinearDelay* d = *dl;
    return d->lastOut;
 801f728:	6803      	ldr	r3, [r0, #0]
}
 801f72a:	ed93 0a03 	vldr	s0, [r3, #12]
 801f72e:	4770      	bx	lr

0801f730 <tTapeDelay_initToPool>:
{
    tTapeDelay_initToPool(dl, delay, maxDelay, &leaf.mempool);
}

void tTapeDelay_initToPool (tTapeDelay* const dl, float delay, uint32_t maxDelay, tMempool* const mp)
{
 801f730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801f732:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 801f736:	6815      	ldr	r5, [r2, #0]
{
 801f738:	4606      	mov	r6, r0
 801f73a:	460f      	mov	r7, r1
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
 801f73c:	202c      	movs	r0, #44	; 0x2c
 801f73e:	4629      	mov	r1, r5
{
 801f740:	eeb0 8a40 	vmov.f32	s16, s0
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
 801f744:	f004 fdb8 	bl	80242b8 <mpool_alloc>
 801f748:	4604      	mov	r4, r0
    d->mempool = m;

    d->maxDelay = maxDelay;

    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 801f74a:	4629      	mov	r1, r5
 801f74c:	00b8      	lsls	r0, r7, #2
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
 801f74e:	6034      	str	r4, [r6, #0]
    d->mempool = m;
 801f750:	6025      	str	r5, [r4, #0]
    d->maxDelay = maxDelay;
 801f752:	61a7      	str	r7, [r4, #24]
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 801f754:	f004 fdb0 	bl	80242b8 <mpool_alloc>

    d->gain = 1.0f;
 801f758:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0

    d->lastIn = 0.0f;
 801f75c:	2300      	movs	r3, #0
    d->lastOut = 0.0f;

    d->idx = 0.0f;
    d->inc = 1.0f;
    d->inPoint = 0;
 801f75e:	2200      	movs	r2, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 801f760:	60a0      	str	r0, [r4, #8]
}

void     tTapeDelay_setDelay (tTapeDelay* const dl, float delay)
{
    _tTapeDelay* d = *dl;
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 801f762:	eef0 0a48 	vmov.f32	s1, s16
    d->gain = 1.0f;
 801f766:	edc4 7a01 	vstr	s15, [r4, #4]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 801f76a:	eeb0 0a67 	vmov.f32	s0, s15
    d->inc = 1.0f;
 801f76e:	edc4 7a08 	vstr	s15, [r4, #32]
    d->inPoint = 0;
 801f772:	6162      	str	r2, [r4, #20]
    d->lastIn = 0.0f;
 801f774:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
 801f776:	60e3      	str	r3, [r4, #12]
    d->idx = 0.0f;
 801f778:	6263      	str	r3, [r4, #36]	; 0x24
    _tTapeDelay* d = *dl;
 801f77a:	6834      	ldr	r4, [r6, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 801f77c:	edd4 7a06 	vldr	s15, [r4, #24]
 801f780:	eeb8 1a67 	vcvt.f32.u32	s2, s15
 801f784:	f004 fb96 	bl	8023eb4 <LEAF_clip>
 801f788:	ed84 0a07 	vstr	s0, [r4, #28]
}
 801f78c:	ecbd 8b02 	vpop	{d8}
 801f790:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801f792:	bf00      	nop

0801f794 <tTapeDelay_free>:
{
 801f794:	b510      	push	{r4, lr}
    _tTapeDelay* d = *dl;
 801f796:	6804      	ldr	r4, [r0, #0]
    mpool_free((char*)d->buff, d->mempool);
 801f798:	6821      	ldr	r1, [r4, #0]
 801f79a:	68a0      	ldr	r0, [r4, #8]
 801f79c:	f004 fe40 	bl	8024420 <mpool_free>
    mpool_free((char*)d, d->mempool);
 801f7a0:	6821      	ldr	r1, [r4, #0]
 801f7a2:	4620      	mov	r0, r4
}
 801f7a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)d, d->mempool);
 801f7a8:	f004 be3a 	b.w	8024420 <mpool_free>

0801f7ac <tTapeDelay_tick>:
{
 801f7ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tTapeDelay* d = *dl;
 801f7ae:	6804      	ldr	r4, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
 801f7b0:	edd4 7a01 	vldr	s15, [r4, #4]
 801f7b4:	6962      	ldr	r2, [r4, #20]
 801f7b6:	68a3      	ldr	r3, [r4, #8]
 801f7b8:	ee27 0a80 	vmul.f32	s0, s15, s0
 801f7bc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801f7c0:	ed83 0a00 	vstr	s0, [r3]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
 801f7c4:	e9d4 2305 	ldrd	r2, r3, [r4, #20]
 801f7c8:	3201      	adds	r2, #1
 801f7ca:	429a      	cmp	r2, r3
 801f7cc:	6162      	str	r2, [r4, #20]
 801f7ce:	d101      	bne.n	801f7d4 <tTapeDelay_tick+0x28>
 801f7d0:	2200      	movs	r2, #0
 801f7d2:	6162      	str	r2, [r4, #20]
    int idx =  (int) d->idx;
 801f7d4:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f7d8:	1e5e      	subs	r6, r3, #1
 801f7da:	68a1      	ldr	r1, [r4, #8]
    int idx =  (int) d->idx;
 801f7dc:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 801f7e0:	ee17 2a10 	vmov	r2, s14
    float alpha = d->idx - idx;
 801f7e4:	eeb8 2ac7 	vcvt.f32.s32	s4, s14
                                              d->buff[(idx + 1) % d->maxDelay],
 801f7e8:	1c57      	adds	r7, r2, #1
                                              d->buff[(idx + 2) % d->maxDelay],
 801f7ea:	f102 0c02 	add.w	ip, r2, #2
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f7ee:	4416      	add	r6, r2
 801f7f0:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 801f7f4:	ee37 2ac2 	vsub.f32	s4, s15, s4
 801f7f8:	edd2 0a00 	vldr	s1, [r2]
                                              d->buff[(idx + 1) % d->maxDelay],
 801f7fc:	fbb7 f0f3 	udiv	r0, r7, r3
 801f800:	fb03 7010 	mls	r0, r3, r0, r7
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f804:	eb01 0280 	add.w	r2, r1, r0, lsl #2
                                              d->buff[(idx + 2) % d->maxDelay],
 801f808:	fbbc f5f3 	udiv	r5, ip, r3
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f80c:	ed92 1a00 	vldr	s2, [r2]
                                              d->buff[(idx + 2) % d->maxDelay],
 801f810:	fb03 c515 	mls	r5, r3, r5, ip
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f814:	fbb6 f2f3 	udiv	r2, r6, r3
 801f818:	fb03 6312 	mls	r3, r3, r2, r6
 801f81c:	eb01 0585 	add.w	r5, r1, r5, lsl #2
 801f820:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 801f824:	edd5 1a00 	vldr	s3, [r5]
 801f828:	ed91 0a00 	vldr	s0, [r1]
 801f82c:	f004 fc5c 	bl	80240e8 <LEAF_interpolate_hermite_x>
    float diff = (d->inPoint - d->idx);
 801f830:	edd4 7a05 	vldr	s15, [r4, #20]
 801f834:	edd4 6a09 	vldr	s13, [r4, #36]	; 0x24
 801f838:	eef8 7a67 	vcvt.f32.u32	s15, s15
    while (diff < 0.f) diff += d->maxDelay;
 801f83c:	ed94 7a06 	vldr	s14, [r4, #24]
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f840:	ed84 0a03 	vstr	s0, [r4, #12]
    while (diff < 0.f) diff += d->maxDelay;
 801f844:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    float diff = (d->inPoint - d->idx);
 801f848:	ee77 7ae6 	vsub.f32	s15, s15, s13
    while (diff < 0.f) diff += d->maxDelay;
 801f84c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801f850:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f854:	d506      	bpl.n	801f864 <tTapeDelay_tick+0xb8>
 801f856:	ee77 7a87 	vadd.f32	s15, s15, s14
 801f85a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801f85e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f862:	d4f8      	bmi.n	801f856 <tTapeDelay_tick+0xaa>
    d->inc = 1.0f + (diff - d->delay) / d->delay; //* SMOOTH_FACTOR;
 801f864:	edd4 5a07 	vldr	s11, [r4, #28]
 801f868:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 801f86c:	ee77 7ae5 	vsub.f32	s15, s15, s11
 801f870:	ee87 6aa5 	vdiv.f32	s12, s15, s11
 801f874:	ee76 7a05 	vadd.f32	s15, s12, s10
    d->idx += d->inc;
 801f878:	ee76 6aa7 	vadd.f32	s13, s13, s15
    d->inc = 1.0f + (diff - d->delay) / d->delay; //* SMOOTH_FACTOR;
 801f87c:	edc4 7a08 	vstr	s15, [r4, #32]
    if (d->idx >= d->maxDelay) d->idx = 0.0f;
 801f880:	eef4 6ac7 	vcmpe.f32	s13, s14
 801f884:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f888:	da02      	bge.n	801f890 <tTapeDelay_tick+0xe4>
    d->idx += d->inc;
 801f88a:	edc4 6a09 	vstr	s13, [r4, #36]	; 0x24
}
 801f88e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (d->idx >= d->maxDelay) d->idx = 0.0f;
 801f890:	2300      	movs	r3, #0
 801f892:	6263      	str	r3, [r4, #36]	; 0x24
}
 801f894:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801f896:	bf00      	nop

0801f898 <tTapeDelay_setDelay>:
{
 801f898:	b510      	push	{r4, lr}
    _tTapeDelay* d = *dl;
 801f89a:	6804      	ldr	r4, [r0, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 801f89c:	eef0 0a40 	vmov.f32	s1, s0
 801f8a0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801f8a4:	edd4 7a06 	vldr	s15, [r4, #24]
 801f8a8:	eeb8 1a67 	vcvt.f32.u32	s2, s15
 801f8ac:	f004 fb02 	bl	8023eb4 <LEAF_clip>
 801f8b0:	ed84 0a07 	vstr	s0, [r4, #28]
}
 801f8b4:	bd10      	pop	{r4, pc}
 801f8b6:	bf00      	nop

0801f8b8 <tTapeDelay_tapOut>:

float tTapeDelay_tapOut (tTapeDelay* const dl, float tapDelay)
{
 801f8b8:	b4f0      	push	{r4, r5, r6, r7}
    _tTapeDelay* d = *dl;
 801f8ba:	6801      	ldr	r1, [r0, #0]

    float tap = (float) d->inPoint - tapDelay - 1.f;
 801f8bc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801f8c0:	edd1 7a05 	vldr	s15, [r1, #20]
 801f8c4:	698b      	ldr	r3, [r1, #24]
 801f8c6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801f8ca:	ee37 0ac0 	vsub.f32	s0, s15, s0

    // Check for wraparound.
    while ( tap < 0.f )   tap += (float)d->maxDelay;
 801f8ce:	eeb4 0ac7 	vcmpe.f32	s0, s14
    float tap = (float) d->inPoint - tapDelay - 1.f;
 801f8d2:	ee70 7a47 	vsub.f32	s15, s0, s14
    while ( tap < 0.f )   tap += (float)d->maxDelay;
 801f8d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f8da:	d50a      	bpl.n	801f8f2 <tTapeDelay_tapOut+0x3a>
 801f8dc:	ee07 3a10 	vmov	s14, r3
 801f8e0:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801f8e4:	ee77 7a87 	vadd.f32	s15, s15, s14
 801f8e8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801f8ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f8f0:	d4f8      	bmi.n	801f8e4 <tTapeDelay_tapOut+0x2c>

    int idx =  (int) tap;
 801f8f2:	eebd 7ae7 	vcvt.s32.f32	s14, s15

    float alpha = tap - idx;

    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f8f6:	6889      	ldr	r1, [r1, #8]
 801f8f8:	1e5d      	subs	r5, r3, #1
    int idx =  (int) tap;
 801f8fa:	ee17 2a10 	vmov	r2, s14
    float alpha = tap - idx;
 801f8fe:	eeb8 2ac7 	vcvt.f32.s32	s4, s14
                                              d->buff[idx],
                                              d->buff[(idx + 1) % d->maxDelay],
 801f902:	1c56      	adds	r6, r2, #1
                                              d->buff[(idx + 2) % d->maxDelay],
 801f904:	1c97      	adds	r7, r2, #2
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f906:	4415      	add	r5, r2
 801f908:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 801f90c:	ee37 2ac2 	vsub.f32	s4, s15, s4
 801f910:	edd2 0a00 	vldr	s1, [r2]
                                              d->buff[(idx + 1) % d->maxDelay],
 801f914:	fbb6 f0f3 	udiv	r0, r6, r3
 801f918:	fb03 6210 	mls	r2, r3, r0, r6
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f91c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
                                              d->buff[(idx + 2) % d->maxDelay],
 801f920:	fbb7 f4f3 	udiv	r4, r7, r3
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f924:	ed92 1a00 	vldr	s2, [r2]
                                              d->buff[(idx + 2) % d->maxDelay],
 801f928:	fb03 7414 	mls	r4, r3, r4, r7
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f92c:	fbb5 f2f3 	udiv	r2, r5, r3
 801f930:	fb03 5312 	mls	r3, r3, r2, r5
 801f934:	eb01 0084 	add.w	r0, r1, r4, lsl #2
 801f938:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 801f93c:	edd0 1a00 	vldr	s3, [r0]
 801f940:	ed91 0a00 	vldr	s0, [r1]
                                              alpha);

    return samp;

}
 801f944:	bcf0      	pop	{r4, r5, r6, r7}
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 801f946:	f004 bbcf 	b.w	80240e8 <LEAF_interpolate_hermite_x>
 801f94a:	bf00      	nop

0801f94c <tOversampler_init>:
    tOversampler_initToPool(osr, ratio, extraQuality, &leaf.mempool);
}

void tOversampler_initToPool (tOversampler* const osr, int ratio, int extraQuality, tMempool* const mp)
{
    _tMempool* m = *mp;
 801f94c:	4b24      	ldr	r3, [pc, #144]	; (801f9e0 <tOversampler_init+0x94>)
{
 801f94e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tMempool* m = *mp;
 801f952:	699e      	ldr	r6, [r3, #24]
{
 801f954:	460d      	mov	r5, r1
 801f956:	4690      	mov	r8, r2
 801f958:	4607      	mov	r7, r0
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
 801f95a:	4631      	mov	r1, r6
 801f95c:	201c      	movs	r0, #28
 801f95e:	f004 fcab 	bl	80242b8 <mpool_alloc>
    os->mempool = m;
    
    uint8_t offset = 0;
    if (extraQuality) offset = 6;
 801f962:	f1b8 0f00 	cmp.w	r8, #0
    if (ratio == 2 || ratio == 4  ||
 801f966:	f1a5 0102 	sub.w	r1, r5, #2
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
 801f96a:	6038      	str	r0, [r7, #0]
    if (extraQuality) offset = 6;
 801f96c:	bf14      	ite	ne
 801f96e:	2705      	movne	r7, #5
 801f970:	f04f 37ff 	moveq.w	r7, #4294967295	; 0xffffffff
    if (ratio == 2 || ratio == 4  ||
 801f974:	291e      	cmp	r1, #30
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
 801f976:	4604      	mov	r4, r0
    os->mempool = m;
 801f978:	6006      	str	r6, [r0, #0]
    if (ratio == 2 || ratio == 4  ||
 801f97a:	d92c      	bls.n	801f9d6 <tOversampler_init+0x8a>
        ratio == 8 || ratio == 16 ||
        ratio == 32 || ratio == 64) {
 801f97c:	2d40      	cmp	r5, #64	; 0x40
 801f97e:	d128      	bne.n	801f9d2 <tOversampler_init+0x86>
        os->ratio = ratio;
        int idx = (int)(log2f(os->ratio))-1+offset;
 801f980:	ee07 5a90 	vmov	s15, r5
        os->ratio = ratio;
 801f984:	6065      	str	r5, [r4, #4]
        int idx = (int)(log2f(os->ratio))-1+offset;
 801f986:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801f98a:	f007 fd77 	bl	802747c <log2f>
 801f98e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
 801f992:	4a14      	ldr	r2, [pc, #80]	; (801f9e4 <tOversampler_init+0x98>)
        os->phaseLength = os->numTaps / os->ratio;
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 801f994:	4631      	mov	r1, r6
        int idx = (int)(log2f(os->ratio))-1+offset;
 801f996:	ee10 3a10 	vmov	r3, s0
 801f99a:	443b      	add	r3, r7
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
 801f99c:	4f12      	ldr	r7, [pc, #72]	; (801f9e8 <tOversampler_init+0x9c>)
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
 801f99e:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 801f9a2:	edd2 7a00 	vldr	s15, [r2]
 801f9a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801f9aa:	ee17 0a90 	vmov	r0, s15
 801f9ae:	edc4 7a05 	vstr	s15, [r4, #20]
        os->phaseLength = os->numTaps / os->ratio;
 801f9b2:	fb90 f5f5 	sdiv	r5, r0, r5
 801f9b6:	61a5      	str	r5, [r4, #24]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 801f9b8:	00c0      	lsls	r0, r0, #3
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
 801f9ba:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
 801f9be:	60a3      	str	r3, [r4, #8]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 801f9c0:	f004 fc7a 	bl	80242b8 <mpool_alloc>
        os->downState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 801f9c4:	6963      	ldr	r3, [r4, #20]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 801f9c6:	60e0      	str	r0, [r4, #12]
        os->downState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 801f9c8:	4631      	mov	r1, r6
 801f9ca:	00d8      	lsls	r0, r3, #3
 801f9cc:	f004 fc74 	bl	80242b8 <mpool_alloc>
 801f9d0:	6120      	str	r0, [r4, #16]
}
 801f9d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (ratio == 2 || ratio == 4  ||
 801f9d6:	4a05      	ldr	r2, [pc, #20]	; (801f9ec <tOversampler_init+0xa0>)
 801f9d8:	40ca      	lsrs	r2, r1
 801f9da:	07d3      	lsls	r3, r2, #31
 801f9dc:	d4d0      	bmi.n	801f980 <tOversampler_init+0x34>
 801f9de:	e7cd      	b.n	801f97c <tOversampler_init+0x30>
 801f9e0:	200194e8 	.word	0x200194e8
 801f9e4:	0804b034 	.word	0x0804b034
 801f9e8:	200003c0 	.word	0x200003c0
 801f9ec:	40004045 	.word	0x40004045

0801f9f0 <tOversampler_free>:
    }
}

void tOversampler_free (tOversampler* const osr)
{
 801f9f0:	b510      	push	{r4, lr}
    _tOversampler* os = *osr;
 801f9f2:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)os->upState, os->mempool);
 801f9f4:	6821      	ldr	r1, [r4, #0]
 801f9f6:	68e0      	ldr	r0, [r4, #12]
 801f9f8:	f004 fd12 	bl	8024420 <mpool_free>
    mpool_free((char*)os->downState, os->mempool);
 801f9fc:	6821      	ldr	r1, [r4, #0]
 801f9fe:	6920      	ldr	r0, [r4, #16]
 801fa00:	f004 fd0e 	bl	8024420 <mpool_free>
    mpool_free((char*)os, os->mempool);
 801fa04:	6821      	ldr	r1, [r4, #0]
 801fa06:	4620      	mov	r0, r4
}
 801fa08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)os, os->mempool);
 801fa0c:	f004 bd08 	b.w	8024420 <mpool_free>

0801fa10 <tOversampler_tick>:

float tOversampler_tick(tOversampler* const osr, float input, float* oversample, float (*effectTick)(float))
{
 801fa10:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tOversampler* os = *osr;
 801fa14:	f8d0 9000 	ldr.w	r9, [r0]
{
 801fa18:	4680      	mov	r8, r0
 801fa1a:	468a      	mov	sl, r1
 801fa1c:	4617      	mov	r7, r2
// From CMSIS DSP Library
void tOversampler_upsample(tOversampler* const osr, float input, float* output)
{
    _tOversampler* os = *osr;
    
    float *pState = os->upState;                 /* State pointer */
 801fa1e:	f8d9 c00c 	ldr.w	ip, [r9, #12]
    float *pStateCur;
    float *ptr1;                               /* Temporary pointer for state buffer */
    float *ptr2;                               /* Temporary pointer for coefficient buffer */
    float sum0;                                /* Accumulators */
    uint32_t i, tapCnt;                    /* Loop counters */
    uint32_t phaseLen = os->phaseLength;            /* Length of each polyphase filter component */
 801fa22:	f8d9 5018 	ldr.w	r5, [r9, #24]
    float *pCoeffs = os->pCoeffs;               /* Coefficient pointer */
 801fa26:	f8d9 e008 	ldr.w	lr, [r9, #8]
    /* os->pState buffer contains previous frame (phaseLen - 1) samples */
    /* pStateCur points to the location where the new input data should be written */
    pStateCur = os->upState + (phaseLen - 1U);
    
    /* Copy new input sample into the state buffer */
    *pStateCur = input;
 801fa2a:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
 801fa2e:	ed03 0a01 	vstr	s0, [r3, #-4]
    
    /* Address modifier index of coefficient buffer */
    j = 1U;
    
    /* Loop over the Interpolation factor. */
    i = os->ratio;
 801fa32:	f8d9 4004 	ldr.w	r4, [r9, #4]
    
    while (i > 0U)
 801fa36:	b32c      	cbz	r4, 801fa84 <tOversampler_tick+0x74>
 801fa38:	f104 0b01 	add.w	fp, r4, #1
    j = 1U;
 801fa3c:	2601      	movs	r6, #1
         Repeat until we've computed numTaps-(4*os->L) coefficients. */
        
        /* Initialize tapCnt with number of samples */
        tapCnt = phaseLen;
        
        while (tapCnt > 0U)
 801fa3e:	eddf 5a38 	vldr	s11, [pc, #224]	; 801fb20 <tOversampler_tick+0x110>
        ptr2 = pCoeffs + (os->ratio - j);
 801fa42:	1ba3      	subs	r3, r4, r6
 801fa44:	ee07 4a90 	vmov	s15, r4
 801fa48:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
 801fa4c:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
        while (tapCnt > 0U)
 801fa50:	2d00      	cmp	r5, #0
 801fa52:	d061      	beq.n	801fb18 <tOversampler_tick+0x108>
            sum0 += *ptr1++ * *ptr2;
            
            /* Upsampling is done by stuffing L-1 zeros between each sample.
             * So instead of multiplying zeros with coefficients,
             * Increment the coefficient pointer by interpolation factor times. */
            ptr2 += os->ratio;
 801fa54:	00a4      	lsls	r4, r4, #2
 801fa56:	462a      	mov	r2, r5
        ptr1 = pState;
 801fa58:	4660      	mov	r0, ip
        sum0 = 0.0f;
 801fa5a:	eddf 7a31 	vldr	s15, [pc, #196]	; 801fb20 <tOversampler_tick+0x110>
            sum0 += *ptr1++ * *ptr2;
 801fa5e:	ed93 7a00 	vldr	s14, [r3]
        while (tapCnt > 0U)
 801fa62:	3a01      	subs	r2, #1
            sum0 += *ptr1++ * *ptr2;
 801fa64:	ecf0 6a01 	vldmia	r0!, {s13}
            ptr2 += os->ratio;
 801fa68:	4423      	add	r3, r4
            sum0 += *ptr1++ * *ptr2;
 801fa6a:	eee6 7a87 	vfma.f32	s15, s13, s14
        while (tapCnt > 0U)
 801fa6e:	d1f6      	bne.n	801fa5e <tOversampler_tick+0x4e>
 801fa70:	ee67 7a86 	vmul.f32	s15, s15, s12
        
        /* The result is in the accumulator, store in the destination buffer. */
        *output++ = sum0 * os->ratio;
        
        /* Increment the address modifier index of coefficient buffer */
        j++;
 801fa74:	3601      	adds	r6, #1
        *output++ = sum0 * os->ratio;
 801fa76:	ece1 7a01 	vstmia	r1!, {s15}
    while (i > 0U)
 801fa7a:	455e      	cmp	r6, fp
 801fa7c:	d002      	beq.n	801fa84 <tOversampler_tick+0x74>
 801fa7e:	f8d9 4004 	ldr.w	r4, [r9, #4]
 801fa82:	e7de      	b.n	801fa42 <tOversampler_tick+0x32>
    
    /* Initialize tapCnt with number of samples */
    tapCnt = (phaseLen - 1U);
    
    /* Copy data */
    while (tapCnt > 0U)
 801fa84:	3d01      	subs	r5, #1
    pState = pState + 1;
 801fa86:	f10c 0c04 	add.w	ip, ip, #4
    pStateCur = os->upState;
 801fa8a:	f8d9 300c 	ldr.w	r3, [r9, #12]
    while (tapCnt > 0U)
 801fa8e:	d005      	beq.n	801fa9c <tOversampler_tick+0x8c>
    {
        *pStateCur++ = *pState++;
 801fa90:	f85c 2b04 	ldr.w	r2, [ip], #4
    while (tapCnt > 0U)
 801fa94:	3d01      	subs	r5, #1
        *pStateCur++ = *pState++;
 801fa96:	f843 2b04 	str.w	r2, [r3], #4
    while (tapCnt > 0U)
 801fa9a:	d1f9      	bne.n	801fa90 <tOversampler_tick+0x80>
    for (int i = 0; i < os->ratio; ++i) {
 801fa9c:	f8d9 3004 	ldr.w	r3, [r9, #4]
 801faa0:	2b00      	cmp	r3, #0
 801faa2:	dd0b      	ble.n	801fabc <tOversampler_tick+0xac>
 801faa4:	4655      	mov	r5, sl
 801faa6:	2400      	movs	r4, #0
        oversample[i] = effectTick(oversample[i]);
 801faa8:	ed95 0a00 	vldr	s0, [r5]
    for (int i = 0; i < os->ratio; ++i) {
 801faac:	3401      	adds	r4, #1
        oversample[i] = effectTick(oversample[i]);
 801faae:	47b8      	blx	r7
 801fab0:	eca5 0a01 	vstmia	r5!, {s0}
    for (int i = 0; i < os->ratio; ++i) {
 801fab4:	f8d9 3004 	ldr.w	r3, [r9, #4]
 801fab8:	42a3      	cmp	r3, r4
 801faba:	dcf5      	bgt.n	801faa8 <tOversampler_tick+0x98>
}

// From CMSIS DSP Library
float tOversampler_downsample(tOversampler *const osr, float* input)
{
    _tOversampler* os = *osr;
 801fabc:	f8d8 4000 	ldr.w	r4, [r8]
    uint32_t i, tapCnt;
    float output;
    
    /* os->pState buffer contains previous frame (numTaps - 1) samples */
    /* pStateCur points to the location where the new input data should be written */
    pStateCur = os->downState + (numTaps - 1U);
 801fac0:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
    float *pState = os->downState;                 /* State pointer */
 801fac4:	e9d4 0604 	ldrd	r0, r6, [r4, #16]
    
    /* Copy decimation factor number of new input samples into the state buffer */
    i = os->ratio;
 801fac8:	e9d4 3501 	ldrd	r3, r5, [r4, #4]
    pStateCur = os->downState + (numTaps - 1U);
 801facc:	4432      	add	r2, r6
 801face:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    
    do
    {
        *pStateCur++ = *input++;
 801fad2:	f85a 1b04 	ldr.w	r1, [sl], #4
        
    } while (--i);
 801fad6:	3b01      	subs	r3, #1
        *pStateCur++ = *input++;
 801fad8:	f842 1b04 	str.w	r1, [r2], #4
    } while (--i);
 801fadc:	d1f9      	bne.n	801fad2 <tOversampler_tick+0xc2>
 801fade:	6861      	ldr	r1, [r4, #4]
 801fae0:	1e73      	subs	r3, r6, #1
 801fae2:	6924      	ldr	r4, [r4, #16]
 801fae4:	461a      	mov	r2, r3
 801fae6:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    
    /* Set accumulator to zero */
    acc0 = 0.0f;
 801faea:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 801fb20 <tOversampler_tick+0x110>
    pb = pCoeffs;
    
    /* Initialize tapCnt with number of taps */
    tapCnt = numTaps;
    
    while (tapCnt > 0U)
 801faee:	b90e      	cbnz	r6, 801faf4 <tOversampler_tick+0xe4>
 801faf0:	e009      	b.n	801fb06 <tOversampler_tick+0xf6>
 801faf2:	3a01      	subs	r2, #1
        
        /* Fetch 1 state variable */
        x0 = *px0++;
        
        /* Perform the multiply-accumulate */
        acc0 += x0 * c0;
 801faf4:	ecb5 7a01 	vldmia	r5!, {s14}
 801faf8:	ecf0 7a01 	vldmia	r0!, {s15}
 801fafc:	eea7 0a27 	vfma.f32	s0, s14, s15
    while (tapCnt > 0U)
 801fb00:	2a00      	cmp	r2, #0
 801fb02:	d1f6      	bne.n	801faf2 <tOversampler_tick+0xe2>
    
    /* Initialize tapCnt with number of taps */
    tapCnt = (numTaps - 1U);
    
    /* Copy data */
    while (tapCnt > 0U)
 801fb04:	b133      	cbz	r3, 801fb14 <tOversampler_tick+0x104>
 801fb06:	4622      	mov	r2, r4
    {
        *pStateCur++ = *pState++;
 801fb08:	f851 0b04 	ldr.w	r0, [r1], #4
    while (tapCnt > 0U)
 801fb0c:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
 801fb0e:	f842 0b04 	str.w	r0, [r2], #4
    while (tapCnt > 0U)
 801fb12:	d1f9      	bne.n	801fb08 <tOversampler_tick+0xf8>
}
 801fb14:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while (tapCnt > 0U)
 801fb18:	eef0 7a65 	vmov.f32	s15, s11
 801fb1c:	e7aa      	b.n	801fa74 <tOversampler_tick+0x64>
 801fb1e:	bf00      	nop
 801fb20:	00000000 	.word	0x00000000

0801fb24 <tOversampler_upsample>:
{
 801fb24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tOversampler* os = *osr;
 801fb28:	f8d0 c000 	ldr.w	ip, [r0]
    float *pState = os->upState;                 /* State pointer */
 801fb2c:	f8dc 700c 	ldr.w	r7, [ip, #12]
    uint32_t phaseLen = os->phaseLength;            /* Length of each polyphase filter component */
 801fb30:	f8dc 5018 	ldr.w	r5, [ip, #24]
    float *pCoeffs = os->pCoeffs;               /* Coefficient pointer */
 801fb34:	f8dc e008 	ldr.w	lr, [ip, #8]
    *pStateCur = input;
 801fb38:	eb07 0385 	add.w	r3, r7, r5, lsl #2
 801fb3c:	ed03 0a01 	vstr	s0, [r3, #-4]
    i = os->ratio;
 801fb40:	f8dc 4004 	ldr.w	r4, [ip, #4]
    while (i > 0U)
 801fb44:	b324      	cbz	r4, 801fb90 <tOversampler_upsample+0x6c>
 801fb46:	f104 0801 	add.w	r8, r4, #1
    j = 1U;
 801fb4a:	2601      	movs	r6, #1
        while (tapCnt > 0U)
 801fb4c:	eddf 5a19 	vldr	s11, [pc, #100]	; 801fbb4 <tOversampler_upsample+0x90>
        ptr2 = pCoeffs + (os->ratio - j);
 801fb50:	1ba3      	subs	r3, r4, r6
 801fb52:	ee07 4a90 	vmov	s15, r4
 801fb56:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
 801fb5a:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
        while (tapCnt > 0U)
 801fb5e:	b32d      	cbz	r5, 801fbac <tOversampler_upsample+0x88>
            ptr2 += os->ratio;
 801fb60:	00a4      	lsls	r4, r4, #2
 801fb62:	462a      	mov	r2, r5
        ptr1 = pState;
 801fb64:	4638      	mov	r0, r7
        sum0 = 0.0f;
 801fb66:	eddf 7a13 	vldr	s15, [pc, #76]	; 801fbb4 <tOversampler_upsample+0x90>
            sum0 += *ptr1++ * *ptr2;
 801fb6a:	ed93 7a00 	vldr	s14, [r3]
        while (tapCnt > 0U)
 801fb6e:	3a01      	subs	r2, #1
            sum0 += *ptr1++ * *ptr2;
 801fb70:	ecf0 6a01 	vldmia	r0!, {s13}
            ptr2 += os->ratio;
 801fb74:	4423      	add	r3, r4
            sum0 += *ptr1++ * *ptr2;
 801fb76:	eee6 7a87 	vfma.f32	s15, s13, s14
        while (tapCnt > 0U)
 801fb7a:	d1f6      	bne.n	801fb6a <tOversampler_upsample+0x46>
 801fb7c:	ee67 7a86 	vmul.f32	s15, s15, s12
        j++;
 801fb80:	3601      	adds	r6, #1
        *output++ = sum0 * os->ratio;
 801fb82:	ece1 7a01 	vstmia	r1!, {s15}
    while (i > 0U)
 801fb86:	4546      	cmp	r6, r8
 801fb88:	d002      	beq.n	801fb90 <tOversampler_upsample+0x6c>
 801fb8a:	f8dc 4004 	ldr.w	r4, [ip, #4]
 801fb8e:	e7df      	b.n	801fb50 <tOversampler_upsample+0x2c>
    while (tapCnt > 0U)
 801fb90:	1e6b      	subs	r3, r5, #1
    pState = pState + 1;
 801fb92:	f107 0204 	add.w	r2, r7, #4
    pStateCur = os->upState;
 801fb96:	f8dc 100c 	ldr.w	r1, [ip, #12]
    while (tapCnt > 0U)
 801fb9a:	d005      	beq.n	801fba8 <tOversampler_upsample+0x84>
        *pStateCur++ = *pState++;
 801fb9c:	f852 0b04 	ldr.w	r0, [r2], #4
    while (tapCnt > 0U)
 801fba0:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
 801fba2:	f841 0b04 	str.w	r0, [r1], #4
    while (tapCnt > 0U)
 801fba6:	d1f9      	bne.n	801fb9c <tOversampler_upsample+0x78>
}
 801fba8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (tapCnt > 0U)
 801fbac:	eef0 7a65 	vmov.f32	s15, s11
 801fbb0:	e7e6      	b.n	801fb80 <tOversampler_upsample+0x5c>
 801fbb2:	bf00      	nop
 801fbb4:	00000000 	.word	0x00000000

0801fbb8 <tOversampler_downsample>:
{
 801fbb8:	b4f0      	push	{r4, r5, r6, r7}
    _tOversampler* os = *osr;
 801fbba:	6806      	ldr	r6, [r0, #0]
    pStateCur = os->downState + (numTaps - 1U);
 801fbbc:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
    float *pState = os->downState;                 /* State pointer */
 801fbc0:	e9d6 0704 	ldrd	r0, r7, [r6, #16]
    i = os->ratio;
 801fbc4:	e9d6 3501 	ldrd	r3, r5, [r6, #4]
    pStateCur = os->downState + (numTaps - 1U);
 801fbc8:	443a      	add	r2, r7
 801fbca:	eb00 0282 	add.w	r2, r0, r2, lsl #2
        *pStateCur++ = *input++;
 801fbce:	f851 4b04 	ldr.w	r4, [r1], #4
    } while (--i);
 801fbd2:	3b01      	subs	r3, #1
        *pStateCur++ = *input++;
 801fbd4:	f842 4b04 	str.w	r4, [r2], #4
    } while (--i);
 801fbd8:	d1f9      	bne.n	801fbce <tOversampler_downsample+0x16>
 801fbda:	1e7b      	subs	r3, r7, #1
 801fbdc:	6871      	ldr	r1, [r6, #4]
 801fbde:	6934      	ldr	r4, [r6, #16]
 801fbe0:	461a      	mov	r2, r3
 801fbe2:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    acc0 = 0.0f;
 801fbe6:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 801fc14 <tOversampler_downsample+0x5c>
    while (tapCnt > 0U)
 801fbea:	b90f      	cbnz	r7, 801fbf0 <tOversampler_downsample+0x38>
 801fbec:	e009      	b.n	801fc02 <tOversampler_downsample+0x4a>
 801fbee:	3a01      	subs	r2, #1
        acc0 += x0 * c0;
 801fbf0:	ecb5 7a01 	vldmia	r5!, {s14}
 801fbf4:	ecf0 7a01 	vldmia	r0!, {s15}
 801fbf8:	eea7 0a27 	vfma.f32	s0, s14, s15
    while (tapCnt > 0U)
 801fbfc:	2a00      	cmp	r2, #0
 801fbfe:	d1f6      	bne.n	801fbee <tOversampler_downsample+0x36>
    while (tapCnt > 0U)
 801fc00:	b133      	cbz	r3, 801fc10 <tOversampler_downsample+0x58>
 801fc02:	4622      	mov	r2, r4
        *pStateCur++ = *pState++;
 801fc04:	f851 0b04 	ldr.w	r0, [r1], #4
    while (tapCnt > 0U)
 801fc08:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
 801fc0a:	f842 0b04 	str.w	r0, [r2], #4
    while (tapCnt > 0U)
 801fc0e:	d1f9      	bne.n	801fc04 <tOversampler_downsample+0x4c>
        /* Decrement loop counter */
        tapCnt--;
    }
    
    return output;
}
 801fc10:	bcf0      	pop	{r4, r5, r6, r7}
 801fc12:	4770      	bx	lr
 801fc14:	00000000 	.word	0x00000000

0801fc18 <tLockhartWavefolder_init>:

//from the paper: Virtual Analog Model of the Lockhart Wavefolder
//by Fabián Esqueda, Henri Pöntynen, Julian D. Parker and Stefan Bilbao

void tLockhartWavefolder_init (tLockhartWavefolder* const wf)
{
 801fc18:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	tLockhartWavefolder_initToPool   (wf,  &leaf.mempool);
}

void tLockhartWavefolder_initToPool (tLockhartWavefolder* const wf, tMempool* const mp)
{
    _tMempool* m = *mp;
 801fc1c:	4b40      	ldr	r3, [pc, #256]	; (801fd20 <tLockhartWavefolder_init+0x108>)
{
 801fc1e:	4605      	mov	r5, r0
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
 801fc20:	20e0      	movs	r0, #224	; 0xe0
    w->Is = 10e-16;
    
    w->a = 2.0*w->RL/w->R;
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
    w->d = (w->RL*w->Is)/w->VT;
    w->half_a = 0.5 * w->a;
 801fc22:	f04f 0800 	mov.w	r8, #0
    _tMempool* m = *mp;
 801fc26:	699c      	ldr	r4, [r3, #24]
    w->half_a = 0.5 * w->a;
 801fc28:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 801fd28 <tLockhartWavefolder_init+0x110>
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
 801fc2c:	4621      	mov	r1, r4
 801fc2e:	f004 fb43 	bl	80242b8 <mpool_alloc>
    w->a = 2.0*w->RL/w->R;
 801fc32:	2200      	movs	r2, #0
 801fc34:	4b3b      	ldr	r3, [pc, #236]	; (801fd24 <tLockhartWavefolder_init+0x10c>)
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
 801fc36:	6028      	str	r0, [r5, #0]
    w->mempool = m;
 801fc38:	6004      	str	r4, [r0, #0]
    w->a = 2.0*w->RL/w->R;
 801fc3a:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
    w->RL = 7.5e3;
 801fc3e:	a528      	add	r5, pc, #160	; (adr r5, 801fce0 <tLockhartWavefolder_init+0xc8>)
 801fc40:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->R = 15e3;
 801fc44:	a328      	add	r3, pc, #160	; (adr r3, 801fce8 <tLockhartWavefolder_init+0xd0>)
 801fc46:	e9d3 2300 	ldrd	r2, r3, [r3]
    w->RL = 7.5e3;
 801fc4a:	e9c0 4508 	strd	r4, r5, [r0, #32]
    w->R = 15e3;
 801fc4e:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
    w->VT = 26e-3;
 801fc52:	a527      	add	r5, pc, #156	; (adr r5, 801fcf0 <tLockhartWavefolder_init+0xd8>)
 801fc54:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->Is = 10e-16;
 801fc58:	a327      	add	r3, pc, #156	; (adr r3, 801fcf8 <tLockhartWavefolder_init+0xe0>)
 801fc5a:	e9d3 2300 	ldrd	r2, r3, [r3]
    w->VT = 26e-3;
 801fc5e:	e9c0 450c 	strd	r4, r5, [r0, #48]	; 0x30
    w->Is = 10e-16;
 801fc62:	e9c0 230e 	strd	r2, r3, [r0, #56]	; 0x38
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 801fc66:	a526      	add	r5, pc, #152	; (adr r5, 801fd00 <tLockhartWavefolder_init+0xe8>)
 801fc68:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->d = (w->RL*w->Is)/w->VT;
 801fc6c:	a326      	add	r3, pc, #152	; (adr r3, 801fd08 <tLockhartWavefolder_init+0xf0>)
 801fc6e:	e9d3 2300 	ldrd	r2, r3, [r3]
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 801fc72:	e9c0 4512 	strd	r4, r5, [r0, #72]	; 0x48
    w->d = (w->RL*w->Is)/w->VT;
 801fc76:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
    w->longthing = (0.5*w->VT/w->b);
    
    
    // Antialiasing error threshold
    w->AAthresh = 10e-10; //10
 801fc7a:	a525      	add	r5, pc, #148	; (adr r5, 801fd10 <tLockhartWavefolder_init+0xf8>)
 801fc7c:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->Ln1 = 0.0;
 801fc80:	2200      	movs	r2, #0
 801fc82:	2300      	movs	r3, #0
    w->longthing = (0.5*w->VT/w->b);
 801fc84:	a724      	add	r7, pc, #144	; (adr r7, 801fd18 <tLockhartWavefolder_init+0x100>)
 801fc86:	e9d7 6700 	ldrd	r6, r7, [r7]
    w->half_a = 0.5 * w->a;
 801fc8a:	e9c0 8918 	strd	r8, r9, [r0, #96]	; 0x60
    w->longthing = (0.5*w->VT/w->b);
 801fc8e:	e9c0 671a 	strd	r6, r7, [r0, #104]	; 0x68
    w->Ln1 = 0.0;
 801fc92:	e9c0 2302 	strd	r2, r3, [r0, #8]
    w->Fn1 = 0.0;
 801fc96:	e9c0 2304 	strd	r2, r3, [r0, #16]
    w->xn1 = 0.0;
 801fc9a:	e9c0 2306 	strd	r2, r3, [r0, #24]

	w->LambertThresh = 10e-10; //12  //was 8


    w->w = 0.0f;
 801fc9e:	e9c0 231e 	strd	r2, r3, [r0, #120]	; 0x78
    w->expw = 0.0f;
 801fca2:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    w->p = 0.0f;
 801fca6:	e9c0 2322 	strd	r2, r3, [r0, #136]	; 0x88
    w->r = 0.0f;
 801fcaa:	e9c0 2324 	strd	r2, r3, [r0, #144]	; 0x90
    w->s= 0.0f;
 801fcae:	e9c0 2326 	strd	r2, r3, [r0, #152]	; 0x98
    w->myerr = 0.0f;
 801fcb2:	e9c0 2328 	strd	r2, r3, [r0, #160]	; 0xa0
    w->l = 0.0f;
 801fcb6:	e9c0 232a 	strd	r2, r3, [r0, #168]	; 0xa8
    w->u = 0.0f;
 801fcba:	e9c0 232c 	strd	r2, r3, [r0, #176]	; 0xb0
    w->Ln = 0.0f;
 801fcbe:	e9c0 232e 	strd	r2, r3, [r0, #184]	; 0xb8
	w->Fn = 0.0f;
 801fcc2:	e9c0 2330 	strd	r2, r3, [r0, #192]	; 0xc0
    w->tempsDenom = 0.0f;
 801fcc6:	e9c0 2332 	strd	r2, r3, [r0, #200]	; 0xc8
    w->tempErrDenom = 0.0f;
 801fcca:	e9c0 2334 	strd	r2, r3, [r0, #208]	; 0xd0
    w->tempOutDenom = 0.0f;
 801fcce:	e9c0 2336 	strd	r2, r3, [r0, #216]	; 0xd8
    w->AAthresh = 10e-10; //10
 801fcd2:	e9c0 4516 	strd	r4, r5, [r0, #88]	; 0x58
	w->LambertThresh = 10e-10; //12  //was 8
 801fcd6:	e9c0 451c 	strd	r4, r5, [r0, #112]	; 0x70
}
 801fcda:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801fcde:	bf00      	nop
 801fce0:	00000000 	.word	0x00000000
 801fce4:	40bd4c00 	.word	0x40bd4c00
 801fce8:	00000000 	.word	0x00000000
 801fcec:	40cd4c00 	.word	0x40cd4c00
 801fcf0:	76c8b439 	.word	0x76c8b439
 801fcf4:	3f9a9fbe 	.word	0x3f9a9fbe
 801fcf8:	9ee75616 	.word	0x9ee75616
 801fcfc:	3cd203af 	.word	0x3cd203af
 801fd00:	b13b13b1 	.word	0xb13b13b1
 801fd04:	40533b13 	.word	0x40533b13
 801fd08:	46f1bc84 	.word	0x46f1bc84
 801fd0c:	3df3d2ab 	.word	0x3df3d2ab
 801fd10:	e826d695 	.word	0xe826d695
 801fd14:	3e112e0b 	.word	0x3e112e0b
 801fd18:	f23033a4 	.word	0xf23033a4
 801fd1c:	3f2626b2 	.word	0x3f2626b2
 801fd20:	200194e8 	.word	0x200194e8
 801fd24:	3ff00000 	.word	0x3ff00000
 801fd28:	3fe00000 	.word	0x3fe00000

0801fd2c <tLockhartWavefolder_free>:

}

void tLockhartWavefolder_free (tLockhartWavefolder* const wf)
{
    _tLockhartWavefolder* w = *wf;
 801fd2c:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)w, w->mempool);
 801fd2e:	6801      	ldr	r1, [r0, #0]
 801fd30:	f004 bb76 	b.w	8024420 <mpool_free>

0801fd34 <tLockhartWavefolder_tick>:
    _tLockhartWavefolder* w = *wf;

    float out = 0.0f;
    
    // Compute Antiderivative
    w->l = (in > 0.0) - (in < 0.0);
 801fd34:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
 801fd38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    w->l = (in > 0.0) - (in < 0.0);
 801fd3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    _tLockhartWavefolder* w = *wf;
 801fd3e:	6806      	ldr	r6, [r0, #0]
{
 801fd40:	4607      	mov	r7, r0
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 801fd42:	f640 34b8 	movw	r4, #3000	; 0xbb8
{
 801fd46:	ed2d 8b0e 	vpush	{d8-d14}
    w->l = (in > 0.0) - (in < 0.0);
 801fd4a:	bfc8      	it	gt
 801fd4c:	2301      	movgt	r3, #1
    w->u = w->d*exp(w->l*w->b*in);
 801fd4e:	eeb7 eac0 	vcvt.f64.f32	d14, s0
    w->l = (in > 0.0) - (in < 0.0);
 801fd52:	bfd8      	it	le
 801fd54:	2300      	movle	r3, #0
 801fd56:	bf4c      	ite	mi
 801fd58:	2201      	movmi	r2, #1
 801fd5a:	2200      	movpl	r2, #0
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 801fd5c:	eeb7 bb00 	vmov.f64	d11, #112	; 0x3f800000  1.0
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 801fd60:	eeb0 9b00 	vmov.f64	d9, #0	; 0x40000000  2.0
    w->l = (in > 0.0) - (in < 0.0);
 801fd64:	1a9b      	subs	r3, r3, r2
    w->u = w->d*exp(w->l*w->b*in);
 801fd66:	ed96 0b12 	vldr	d0, [r6, #72]	; 0x48
    w->l = (in > 0.0) - (in < 0.0);
 801fd6a:	ee07 3a90 	vmov	s15, r3
    w->u = w->d*exp(w->l*w->b*in);
 801fd6e:	ee2e 0b00 	vmul.f64	d0, d14, d0
    w->l = (in > 0.0) - (in < 0.0);
 801fd72:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 801fd76:	ed86 7b2a 	vstr	d7, [r6, #168]	; 0xa8
    w->u = w->d*exp(w->l*w->b*in);
 801fd7a:	ee20 0b07 	vmul.f64	d0, d0, d7
 801fd7e:	f007 fdb7 	bl	80278f0 <exp>
 801fd82:	ed96 cb14 	vldr	d12, [r6, #80]	; 0x50
    	w->u = 10e-5;
    	LEAF_error();
    }
    */

    w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
 801fd86:	ed96 8b02 	vldr	d8, [r6, #8]
    w->u = w->d*exp(w->l*w->b*in);
 801fd8a:	ee20 cb0c 	vmul.f64	d12, d0, d12
 801fd8e:	ed86 cb2c 	vstr	d12, [r6, #176]	; 0xb0
	_tLockhartWavefolder* mwf = *wf;
 801fd92:	683d      	ldr	r5, [r7, #0]
 801fd94:	eeb1 cb4c 	vneg.f64	d12, d12
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 801fd98:	ed95 db1c 	vldr	d13, [r5, #112]	; 0x70
	mwf->w = ln;
 801fd9c:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
 801fda0:	e006      	b.n	801fdb0 <tLockhartWavefolder_tick+0x7c>
        mwf->w = mwf->w - mwf->myerr;
 801fda2:	ee38 8b45 	vsub.f64	d8, d8, d5
    for(int i=0; i<3000; i+=1) { //1000
 801fda6:	3c01      	subs	r4, #1
        mwf->w = mwf->w - mwf->myerr;
 801fda8:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
    for(int i=0; i<3000; i+=1) { //1000
 801fdac:	f000 80c9 	beq.w	801ff42 <tLockhartWavefolder_tick+0x20e>
    	mwf->expw = exp(mwf->w);
 801fdb0:	eeb0 0b48 	vmov.f64	d0, d8
 801fdb4:	f007 fd9c 	bl	80278f0 <exp>
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 801fdb8:	ee38 7b0b 	vadd.f64	d7, d8, d11
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 801fdbc:	ee38 4b09 	vadd.f64	d4, d8, d9
    	mwf->p = mwf->w*mwf->expw - x;
 801fdc0:	eeb0 6b4c 	vmov.f64	d6, d12
    	mwf->tempsDenom = (2.0*(mwf->w+1.0));
 801fdc4:	ee37 1b07 	vadd.f64	d1, d7, d7
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 801fdc8:	ee20 7b07 	vmul.f64	d7, d0, d7
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 801fdcc:	ee84 2b01 	vdiv.f64	d2, d4, d1
    	mwf->p = mwf->w*mwf->expw - x;
 801fdd0:	eea0 6b08 	vfma.f64	d6, d0, d8
        mwf->tempErrDenom = (mwf->r-(mwf->p*mwf->s));
 801fdd4:	eeb0 3b47 	vmov.f64	d3, d7
 801fdd8:	eea6 3b42 	vfms.f64	d3, d6, d2
        mwf->myerr = (mwf->p/mwf->tempErrDenom);
 801fddc:	ee86 5b03 	vdiv.f64	d5, d6, d3
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 801fde0:	eeb0 abc5 	vabs.f64	d10, d5
 801fde4:	eeb4 abcd 	vcmpe.f64	d10, d13
 801fde8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fdec:	d5d9      	bpl.n	801fda2 <tLockhartWavefolder_tick+0x6e>
 801fdee:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
 801fdf2:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
 801fdf6:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
 801fdfa:	ed85 1b32 	vstr	d1, [r5, #200]	; 0xc8
 801fdfe:	ed85 2b26 	vstr	d2, [r5, #152]	; 0x98
 801fe02:	ed85 3b34 	vstr	d3, [r5, #208]	; 0xd0
 801fe06:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
	{
		w->Ln = 10e-5;
		LEAF_error();
	}
*/
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
 801fe0a:	ee2e 5b0e 	vmul.f64	d5, d14, d14
 801fe0e:	ee24 4b08 	vmul.f64	d4, d4, d8
 801fe12:	ed96 7b18 	vldr	d7, [r6, #96]	; 0x60
		LEAF_error();
	}
	*/
    // Check for ill-conditioning

    if (fabs(in-w->xn1)<w->AAthresh)
 801fe16:	ed96 db06 	vldr	d13, [r6, #24]
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
 801fe1a:	ed96 6b1a 	vldr	d6, [r6, #104]	; 0x68
 801fe1e:	ee27 5b45 	vnmul.f64	d5, d7, d5
    if (fabs(in-w->xn1)<w->AAthresh)
 801fe22:	ee3e 3b4d 	vsub.f64	d3, d14, d13
 801fe26:	ed96 7b16 	vldr	d7, [r6, #88]	; 0x58
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
 801fe2a:	eea6 5b04 	vfma.f64	d5, d6, d4
    if (fabs(in-w->xn1)<w->AAthresh)
 801fe2e:	eeb0 6bc3 	vabs.f64	d6, d3
    w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
 801fe32:	ed86 8b2e 	vstr	d8, [r6, #184]	; 0xb8
    if (fabs(in-w->xn1)<w->AAthresh)
 801fe36:	eeb4 6bc7 	vcmpe.f64	d6, d7
 801fe3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
 801fe3e:	ed86 5b30 	vstr	d5, [r6, #192]	; 0xc0
    if (fabs(in-w->xn1)<w->AAthresh)
 801fe42:	d412      	bmi.n	801fe6a <tLockhartWavefolder_tick+0x136>
    	{
    		w->tempOutDenom = 10e-5;
    		LEAF_error();
    	}
    	*/
        out = ((w->Fn-w->Fn1)/w->tempOutDenom);
 801fe44:	ed96 7b04 	vldr	d7, [r6, #16]
    	w->tempOutDenom = (in-w->xn1);
 801fe48:	ed86 3b36 	vstr	d3, [r6, #216]	; 0xd8
        out = ((w->Fn-w->Fn1)/w->tempOutDenom);
 801fe4c:	ee35 7b47 	vsub.f64	d7, d5, d7
 801fe50:	ee87 0b03 	vdiv.f64	d0, d7, d3
 801fe54:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
		*/

    }

    // Update States
    w->Ln1 = w->Ln;
 801fe58:	ed86 8b02 	vstr	d8, [r6, #8]
    w->Fn1 = w->Fn;
 801fe5c:	ed86 5b04 	vstr	d5, [r6, #16]
    w->xn1 = (double)in;
 801fe60:	ed86 eb06 	vstr	d14, [r6, #24]
    
    return out;
}
 801fe64:	ecbd 8b0e 	vpop	{d8-d14}
 801fe68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    	double xn = 0.5*(in+w->xn1);
 801fe6a:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 801fe6e:	f640 34b8 	movw	r4, #3000	; 0xbb8
    	double xn = 0.5*(in+w->xn1);
 801fe72:	ee3e db0d 	vadd.f64	d13, d14, d13
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 801fe76:	eeb7 9b00 	vmov.f64	d9, #112	; 0x3f800000  1.0
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 801fe7a:	eeb0 ab00 	vmov.f64	d10, #0	; 0x40000000  2.0
    	double xn = 0.5*(in+w->xn1);
 801fe7e:	ee2d db07 	vmul.f64	d13, d13, d7
    	w->u = w->d*exp(w->l*w->b*xn);
 801fe82:	ed96 0b2a 	vldr	d0, [r6, #168]	; 0xa8
 801fe86:	ed96 7b12 	vldr	d7, [r6, #72]	; 0x48
 801fe8a:	ee20 0b07 	vmul.f64	d0, d0, d7
 801fe8e:	ee20 0b0d 	vmul.f64	d0, d0, d13
 801fe92:	f007 fd2d 	bl	80278f0 <exp>
 801fe96:	ed96 bb14 	vldr	d11, [r6, #80]	; 0x50
    	w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
 801fe9a:	ed96 8b02 	vldr	d8, [r6, #8]
    	w->u = w->d*exp(w->l*w->b*xn);
 801fe9e:	ee20 bb0b 	vmul.f64	d11, d0, d11
 801fea2:	ed86 bb2c 	vstr	d11, [r6, #176]	; 0xb0
	_tLockhartWavefolder* mwf = *wf;
 801fea6:	683d      	ldr	r5, [r7, #0]
 801fea8:	eeb1 bb4b 	vneg.f64	d11, d11
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 801feac:	ed95 cb1c 	vldr	d12, [r5, #112]	; 0x70
	mwf->w = ln;
 801feb0:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
 801feb4:	e005      	b.n	801fec2 <tLockhartWavefolder_tick+0x18e>
        mwf->w = mwf->w - mwf->myerr;
 801feb6:	ee38 8b45 	vsub.f64	d8, d8, d5
    for(int i=0; i<3000; i+=1) { //1000
 801feba:	3c01      	subs	r4, #1
        mwf->w = mwf->w - mwf->myerr;
 801febc:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
    for(int i=0; i<3000; i+=1) { //1000
 801fec0:	d01e      	beq.n	801ff00 <tLockhartWavefolder_tick+0x1cc>
    	mwf->expw = exp(mwf->w);
 801fec2:	eeb0 0b48 	vmov.f64	d0, d8
 801fec6:	f007 fd13 	bl	80278f0 <exp>
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 801feca:	ee38 7b09 	vadd.f64	d7, d8, d9
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 801fece:	ee38 5b0a 	vadd.f64	d5, d8, d10
    	mwf->p = mwf->w*mwf->expw - x;
 801fed2:	eeb0 6b4b 	vmov.f64	d6, d11
    	mwf->tempsDenom = (2.0*(mwf->w+1.0));
 801fed6:	ee37 2b07 	vadd.f64	d2, d7, d7
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 801feda:	ee20 7b07 	vmul.f64	d7, d0, d7
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 801fede:	ee85 3b02 	vdiv.f64	d3, d5, d2
    	mwf->p = mwf->w*mwf->expw - x;
 801fee2:	eea0 6b08 	vfma.f64	d6, d0, d8
        mwf->tempErrDenom = (mwf->r-(mwf->p*mwf->s));
 801fee6:	eeb0 4b47 	vmov.f64	d4, d7
 801feea:	eea6 4b43 	vfms.f64	d4, d6, d3
        mwf->myerr = (mwf->p/mwf->tempErrDenom);
 801feee:	ee86 5b04 	vdiv.f64	d5, d6, d4
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 801fef2:	eeb0 1bc5 	vabs.f64	d1, d5
 801fef6:	eeb4 1bcc 	vcmpe.f64	d1, d12
 801fefa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fefe:	d5da      	bpl.n	801feb6 <tLockhartWavefolder_tick+0x182>
 801ff00:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
 801ff04:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
 801ff08:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
 801ff0c:	ed85 2b32 	vstr	d2, [r5, #200]	; 0xc8
 801ff10:	ed85 3b26 	vstr	d3, [r5, #152]	; 0x98
 801ff14:	ed85 4b34 	vstr	d4, [r5, #208]	; 0xd0
 801ff18:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
        out = (float)((w->l*w->VT*w->Ln) - (w->a*xn));
 801ff1c:	ed96 5b10 	vldr	d5, [r6, #64]	; 0x40
 801ff20:	ed96 7b2a 	vldr	d7, [r6, #168]	; 0xa8
 801ff24:	ed96 6b0c 	vldr	d6, [r6, #48]	; 0x30
 801ff28:	ee25 db4d 	vnmul.f64	d13, d5, d13
 801ff2c:	ee27 7b06 	vmul.f64	d7, d7, d6
    	w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
 801ff30:	ed86 8b2e 	vstr	d8, [r6, #184]	; 0xb8
 801ff34:	ed96 5b30 	vldr	d5, [r6, #192]	; 0xc0
        out = (float)((w->l*w->VT*w->Ln) - (w->a*xn));
 801ff38:	eea7 db08 	vfma.f64	d13, d7, d8
 801ff3c:	eeb7 0bcd 	vcvt.f32.f64	s0, d13
 801ff40:	e78a      	b.n	801fe58 <tLockhartWavefolder_tick+0x124>
 801ff42:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
 801ff46:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
 801ff4a:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
 801ff4e:	ed85 1b32 	vstr	d1, [r5, #200]	; 0xc8
 801ff52:	ed85 2b26 	vstr	d2, [r5, #152]	; 0x98
 801ff56:	ed85 3b34 	vstr	d3, [r5, #208]	; 0xd0
 801ff5a:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
 801ff5e:	ee38 4b09 	vadd.f64	d4, d8, d9
 801ff62:	e752      	b.n	801fe0a <tLockhartWavefolder_tick+0xd6>

0801ff64 <tCrusher_init>:
// CRUSHER
//============================================================================================================
#define SCALAR 5000.f

void tCrusher_init (tCrusher* const cr)
{
 801ff64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tCrusher_initToPool(cr, &leaf.mempool);
}

void tCrusher_initToPool (tCrusher* const cr, tMempool* const mp)
{
    _tMempool* m = *mp;
 801ff66:	4d15      	ldr	r5, [pc, #84]	; (801ffbc <tCrusher_init+0x58>)
{
 801ff68:	4607      	mov	r7, r0
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
 801ff6a:	2020      	movs	r0, #32
    _tMempool* m = *mp;
 801ff6c:	69ae      	ldr	r6, [r5, #24]
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
 801ff6e:	4631      	mov	r1, r6
 801ff70:	f004 f9a2 	bl	80242b8 <mpool_alloc>
    c->mempool = m;
    
    c->op = 4;
    c->div = SCALAR;
    c->rnd = 0.25f;
 801ff74:	f04f 537a 	mov.w	r3, #1048576000	; 0x3e800000
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
 801ff78:	4604      	mov	r4, r0
    c->div = SCALAR;
 801ff7a:	4a11      	ldr	r2, [pc, #68]	; (801ffc0 <tCrusher_init+0x5c>)
    c->op = 4;
 801ff7c:	2104      	movs	r1, #4
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
 801ff7e:	6038      	str	r0, [r7, #0]
    c->div = SCALAR;
 801ff80:	60e2      	str	r2, [r4, #12]
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
 801ff82:	2010      	movs	r0, #16
    c->op = 4;
 801ff84:	6161      	str	r1, [r4, #20]
    c->rnd = 0.25f;
 801ff86:	6123      	str	r3, [r4, #16]
    c->srr = 0.25f;
 801ff88:	6063      	str	r3, [r4, #4]
    c->mempool = m;
 801ff8a:	6026      	str	r6, [r4, #0]
    _tMempool* m = *mp;
 801ff8c:	69ad      	ldr	r5, [r5, #24]
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
 801ff8e:	4629      	mov	r1, r5
 801ff90:	f004 f992 	bl	80242b8 <mpool_alloc>
    s->invRatio = 1.0f;
 801ff94:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    s->hold = 0.0f;
 801ff98:	2200      	movs	r2, #0
    s->count = 0;
 801ff9a:	2300      	movs	r3, #0
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
 801ff9c:	61e0      	str	r0, [r4, #28]
    tSampleReducer_initToPool(&c->sReducer, mp);
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 801ff9e:	ed9f 7a09 	vldr	s14, [pc, #36]	; 801ffc4 <tCrusher_init+0x60>
    s->mempool = m;
 801ffa2:	6005      	str	r5, [r0, #0]
    s->invRatio = 1.0f;
 801ffa4:	6041      	str	r1, [r0, #4]
    s->hold = 0.0f;
 801ffa6:	6082      	str	r2, [r0, #8]
    s->count = 0;
 801ffa8:	60c3      	str	r3, [r0, #12]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 801ffaa:	eddf 7a07 	vldr	s15, [pc, #28]	; 801ffc8 <tCrusher_init+0x64>
 801ffae:	edd4 6a03 	vldr	s13, [r4, #12]
 801ffb2:	eee6 7a87 	vfma.f32	s15, s13, s14
 801ffb6:	edc4 7a06 	vstr	s15, [r4, #24]
}
 801ffba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801ffbc:	200194e8 	.word	0x200194e8
 801ffc0:	459c4000 	.word	0x459c4000
 801ffc4:	3912ccf6 	.word	0x3912ccf6
 801ffc8:	3e99999a 	.word	0x3e99999a

0801ffcc <tCrusher_free>:
}

void tCrusher_free (tCrusher* const cr)
{
 801ffcc:	b510      	push	{r4, lr}
    _tCrusher* c = *cr;
 801ffce:	6804      	ldr	r4, [r0, #0]
    _tSampleReducer* s = *sr;
 801ffd0:	69e0      	ldr	r0, [r4, #28]
    mpool_free((char*)s, s->mempool);
 801ffd2:	6801      	ldr	r1, [r0, #0]
 801ffd4:	f004 fa24 	bl	8024420 <mpool_free>
    
    tSampleReducer_free(&c->sReducer);
    mpool_free((char*)c, c->mempool);
 801ffd8:	6821      	ldr	r1, [r4, #0]
 801ffda:	4620      	mov	r0, r4
}
 801ffdc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)c, c->mempool);
 801ffe0:	f004 ba1e 	b.w	8024420 <mpool_free>

0801ffe4 <tCrusher_tick>:
{
    _tCrusher* c = *cr;
    
    float sample = input;
    
    sample *= SCALAR; // SCALAR is 5000 by default
 801ffe4:	eddf 7a1e 	vldr	s15, [pc, #120]	; 8020060 <tCrusher_tick+0x7c>
 801ffe8:	ee20 0a27 	vmul.f32	s0, s0, s15
{
 801ffec:	b510      	push	{r4, lr}
    
    sample = (int32_t) sample;
 801ffee:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tCrusher* c = *cr;
 801fff2:	6804      	ldr	r4, [r0, #0]
    
    sample /= c->div;
 801fff4:	edd4 7a03 	vldr	s15, [r4, #12]
    sample = (int32_t) sample;
 801fff8:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    
    sample = LEAF_bitwise_xor(sample, c->op << 23);
 801fffc:	6960      	ldr	r0, [r4, #20]
 801fffe:	05c0      	lsls	r0, r0, #23
 8020000:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8020004:	f003 ff50 	bl	8023ea8 <LEAF_bitwise_xor>
    
    sample = LEAF_clip(-1.f, sample, 1.f);
 8020008:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 802000c:	eef0 0a40 	vmov.f32	s1, s0
 8020010:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8020014:	f003 ff4e 	bl	8023eb4 <LEAF_clip>
    
    sample = LEAF_round(sample, c->rnd);
 8020018:	edd4 0a04 	vldr	s1, [r4, #16]
 802001c:	f003 ff32 	bl	8023e84 <LEAF_round>
    _tSampleReducer* s = *sr;
 8020020:	69e3      	ldr	r3, [r4, #28]
    if (s->count > s->invRatio)
 8020022:	68da      	ldr	r2, [r3, #12]
 8020024:	edd3 7a01 	vldr	s15, [r3, #4]
 8020028:	ee07 2a10 	vmov	s14, r2
 802002c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8020030:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8020034:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020038:	dd08      	ble.n	802004c <tCrusher_tick+0x68>
        s->hold = input;
 802003a:	2201      	movs	r2, #1
 802003c:	ed83 0a02 	vstr	s0, [r3, #8]
    s->count++;
 8020040:	60da      	str	r2, [r3, #12]
    
    sample = tSampleReducer_tick(&c->sReducer, sample);
    
    return sample * c->gain;
 8020042:	edd4 7a06 	vldr	s15, [r4, #24]
    
}
 8020046:	ee20 0a27 	vmul.f32	s0, s0, s15
 802004a:	bd10      	pop	{r4, pc}
 802004c:	3201      	adds	r2, #1
 802004e:	ed93 0a02 	vldr	s0, [r3, #8]
    s->count++;
 8020052:	60da      	str	r2, [r3, #12]
    return sample * c->gain;
 8020054:	edd4 7a06 	vldr	s15, [r4, #24]
}
 8020058:	ee20 0a27 	vmul.f32	s0, s0, s15
 802005c:	bd10      	pop	{r4, pc}
 802005e:	bf00      	nop
 8020060:	459c4000 	.word	0x459c4000

08020064 <tCrusher_setOperation>:

void    tCrusher_setOperation (tCrusher* const cr, float op)
{
    _tCrusher* c = *cr;
    c->op = (uint32_t) (op * 8.0f);
 8020064:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    _tCrusher* c = *cr;
 8020068:	6803      	ldr	r3, [r0, #0]
    c->op = (uint32_t) (op * 8.0f);
 802006a:	ee20 0a27 	vmul.f32	s0, s0, s15
 802006e:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 8020072:	ed83 0a05 	vstr	s0, [r3, #20]
}
 8020076:	4770      	bx	lr

08020078 <tCrusher_setQuality>:

// 0.0 - 1.0
void    tCrusher_setQuality (tCrusher* const cr, float val)
{
 8020078:	b510      	push	{r4, lr}
    _tCrusher* c = *cr;
    
    val = LEAF_clip(0.0f, val, 1.0f);
 802007a:	eef0 0a40 	vmov.f32	s1, s0
 802007e:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 80200b0 <tCrusher_setQuality+0x38>
 8020082:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    _tCrusher* c = *cr;
 8020086:	6804      	ldr	r4, [r0, #0]
    val = LEAF_clip(0.0f, val, 1.0f);
 8020088:	f003 ff14 	bl	8023eb4 <LEAF_clip>
    
    c->div = 0.01f + val * SCALAR;
 802008c:	ed9f 7a09 	vldr	s14, [pc, #36]	; 80200b4 <tCrusher_setQuality+0x3c>
 8020090:	eddf 7a09 	vldr	s15, [pc, #36]	; 80200b8 <tCrusher_setQuality+0x40>
    
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 8020094:	eddf 6a09 	vldr	s13, [pc, #36]	; 80200bc <tCrusher_setQuality+0x44>
    c->div = 0.01f + val * SCALAR;
 8020098:	eee0 7a07 	vfma.f32	s15, s0, s14
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 802009c:	ed9f 7a08 	vldr	s14, [pc, #32]	; 80200c0 <tCrusher_setQuality+0x48>
 80200a0:	eea7 7aa6 	vfma.f32	s14, s15, s13
    c->div = 0.01f + val * SCALAR;
 80200a4:	edc4 7a03 	vstr	s15, [r4, #12]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80200a8:	ed84 7a06 	vstr	s14, [r4, #24]
}
 80200ac:	bd10      	pop	{r4, pc}
 80200ae:	bf00      	nop
 80200b0:	00000000 	.word	0x00000000
 80200b4:	459c4000 	.word	0x459c4000
 80200b8:	3c23d70a 	.word	0x3c23d70a
 80200bc:	3912ccf6 	.word	0x3912ccf6
 80200c0:	3e99999a 	.word	0x3e99999a

080200c4 <tCrusher_setRound>:

// what decimal to round to
void    tCrusher_setRound (tCrusher* const cr, float rnd)
{
    _tCrusher* c = *cr;
    c->rnd = fabsf(rnd);
 80200c4:	eeb0 0ac0 	vabs.f32	s0, s0
    _tCrusher* c = *cr;
 80200c8:	6803      	ldr	r3, [r0, #0]
    c->rnd = fabsf(rnd);
 80200ca:	ed83 0a04 	vstr	s0, [r3, #16]
}
 80200ce:	4770      	bx	lr

080200d0 <tCrusher_setSamplingRatio>:
    if ((ratio <= 1.0f) && (ratio >= 0.0f))
 80200d0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0

void    tCrusher_setSamplingRatio (tCrusher* const cr, float ratio)
{
    _tCrusher* c = *cr;
 80200d4:	6803      	ldr	r3, [r0, #0]
    c->srr = ratio;
 80200d6:	ed83 0a01 	vstr	s0, [r3, #4]
    if ((ratio <= 1.0f) && (ratio >= 0.0f))
 80200da:	eeb4 0a67 	vcmp.f32	s0, s15
 80200de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80200e2:	d809      	bhi.n	80200f8 <tCrusher_setSamplingRatio+0x28>
 80200e4:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80200e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80200ec:	db04      	blt.n	80200f8 <tCrusher_setSamplingRatio+0x28>
        s->invRatio = 1.0f / ratio;
 80200ee:	ee87 7a80 	vdiv.f32	s14, s15, s0
    _tSampleReducer* s = *sr;
 80200f2:	69db      	ldr	r3, [r3, #28]
        s->invRatio = 1.0f / ratio;
 80200f4:	ed83 7a01 	vstr	s14, [r3, #4]
    tSampleReducer_setRatio(&c->sReducer, ratio);

}
 80200f8:	4770      	bx	lr
 80200fa:	bf00      	nop

080200fc <tFeedbackLeveler_init>:
}

/* Feedback Leveler */

void tFeedbackLeveler_init (tFeedbackLeveler* const fb, float targetLevel, float factor, float strength, int mode)
{
 80200fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    tFeedbackLeveler_initToPool(fb, targetLevel, factor, strength, mode, &leaf.mempool);
}

void tFeedbackLeveler_initToPool (tFeedbackLeveler* const fb, float targetLevel, float factor, float strength, int mode, tMempool* const mp)
{
    _tMempool* m = *mp;
 8020100:	4d12      	ldr	r5, [pc, #72]	; (802014c <tFeedbackLeveler_init+0x50>)
{
 8020102:	4680      	mov	r8, r0
 8020104:	460f      	mov	r7, r1
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8020106:	2018      	movs	r0, #24
    _tMempool* m = *mp;
 8020108:	f855 6f18 	ldr.w	r6, [r5, #24]!
{
 802010c:	ed2d 8b04 	vpush	{d8-d9}
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8020110:	4631      	mov	r1, r6
{
 8020112:	eef0 8a40 	vmov.f32	s17, s0
 8020116:	eeb0 9a60 	vmov.f32	s18, s1
 802011a:	eeb0 8a41 	vmov.f32	s16, s2
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 802011e:	f004 f8cb 	bl	80242b8 <mpool_alloc>
    p->mempool = m;
    
    p->curr=0.0f;
 8020122:	2300      	movs	r3, #0
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8020124:	4604      	mov	r4, r0
 8020126:	f8c8 0000 	str.w	r0, [r8]
    p->targetLevel=targetLevel;
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 802012a:	eeb0 0a49 	vmov.f32	s0, s18
    p->mempool = m;
 802012e:	6006      	str	r6, [r0, #0]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8020130:	4629      	mov	r1, r5
    p->targetLevel=targetLevel;
 8020132:	edc4 8a01 	vstr	s17, [r4, #4]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8020136:	3014      	adds	r0, #20
    p->curr=0.0f;
 8020138:	6123      	str	r3, [r4, #16]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 802013a:	f7fe fcad 	bl	801ea98 <tPowerFollower_initToPool>
    p->mode=mode;
 802013e:	60e7      	str	r7, [r4, #12]
    p->strength=strength;
 8020140:	ed84 8a02 	vstr	s16, [r4, #8]
}
 8020144:	ecbd 8b04 	vpop	{d8-d9}
 8020148:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802014c:	200194e8 	.word	0x200194e8

08020150 <tFeedbackLeveler_initToPool>:
{
 8020150:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tMempool* m = *mp;
 8020154:	6815      	ldr	r5, [r2, #0]
{
 8020156:	4680      	mov	r8, r0
 8020158:	460f      	mov	r7, r1
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 802015a:	2018      	movs	r0, #24
 802015c:	4629      	mov	r1, r5
{
 802015e:	4616      	mov	r6, r2
 8020160:	ed2d 8b04 	vpush	{d8-d9}
 8020164:	eef0 8a40 	vmov.f32	s17, s0
 8020168:	eeb0 9a60 	vmov.f32	s18, s1
 802016c:	eeb0 8a41 	vmov.f32	s16, s2
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8020170:	f004 f8a2 	bl	80242b8 <mpool_alloc>
    p->curr=0.0f;
 8020174:	2300      	movs	r3, #0
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8020176:	4604      	mov	r4, r0
 8020178:	f8c8 0000 	str.w	r0, [r8]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 802017c:	eeb0 0a49 	vmov.f32	s0, s18
    p->mempool = m;
 8020180:	6005      	str	r5, [r0, #0]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8020182:	4631      	mov	r1, r6
    p->targetLevel=targetLevel;
 8020184:	edc4 8a01 	vstr	s17, [r4, #4]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8020188:	3014      	adds	r0, #20
    p->curr=0.0f;
 802018a:	6123      	str	r3, [r4, #16]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 802018c:	f7fe fc84 	bl	801ea98 <tPowerFollower_initToPool>
    p->mode=mode;
 8020190:	60e7      	str	r7, [r4, #12]
    p->strength=strength;
 8020192:	ed84 8a02 	vstr	s16, [r4, #8]
}
 8020196:	ecbd 8b04 	vpop	{d8-d9}
 802019a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802019e:	bf00      	nop

080201a0 <tFeedbackLeveler_free>:

void tFeedbackLeveler_free (tFeedbackLeveler* const fb)
{
 80201a0:	b510      	push	{r4, lr}
    _tFeedbackLeveler* p = *fb;
 80201a2:	6804      	ldr	r4, [r0, #0]
    
    tPowerFollower_free(&p->pwrFlw);
 80201a4:	f104 0014 	add.w	r0, r4, #20
 80201a8:	f7fe fc90 	bl	801eacc <tPowerFollower_free>
    mpool_free((char*)p, p->mempool);
 80201ac:	6821      	ldr	r1, [r4, #0]
 80201ae:	4620      	mov	r0, r4
}
 80201b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
 80201b4:	f004 b934 	b.w	8024420 <mpool_free>

080201b8 <tFeedbackLeveler_setMode>:
    tPowerFollower_setFactor(&p->pwrFlw,factor);
}

void     tFeedbackLeveler_setMode(tFeedbackLeveler* const fb, int mode)
{    // 0 for decaying with upwards lev limiting, 1 for constrained absolute level (also downwards limiting)
    _tFeedbackLeveler* p = *fb;
 80201b8:	6803      	ldr	r3, [r0, #0]
    p->mode=mode;
 80201ba:	60d9      	str	r1, [r3, #12]
}
 80201bc:	4770      	bx	lr
 80201be:	bf00      	nop

080201c0 <tFeedbackLeveler_tick>:

float   tFeedbackLeveler_tick(tFeedbackLeveler* const fb, float input)
{
 80201c0:	b510      	push	{r4, lr}
 80201c2:	ed2d 8b02 	vpush	{d8}
    _tFeedbackLeveler* p = *fb;
 80201c6:	6804      	ldr	r4, [r0, #0]
{
 80201c8:	eeb0 8a40 	vmov.f32	s16, s0
    float levdiff=(tPowerFollower_tick(&p->pwrFlw, input)-p->targetLevel);
 80201cc:	f104 0014 	add.w	r0, r4, #20
 80201d0:	f7fe fc80 	bl	801ead4 <tPowerFollower_tick>
 80201d4:	edd4 7a01 	vldr	s15, [r4, #4]
    if (p->mode==0 && levdiff<0.0f) levdiff=0.0f;
 80201d8:	68e3      	ldr	r3, [r4, #12]
    float levdiff=(tPowerFollower_tick(&p->pwrFlw, input)-p->targetLevel);
 80201da:	ee70 7a67 	vsub.f32	s15, s0, s15
    if (p->mode==0 && levdiff<0.0f) levdiff=0.0f;
 80201de:	b943      	cbnz	r3, 80201f2 <tFeedbackLeveler_tick+0x32>
 80201e0:	eef5 7a40 	vcmp.f32	s15, #0.0
 80201e4:	ed9f 7a09 	vldr	s14, [pc, #36]	; 802020c <tFeedbackLeveler_tick+0x4c>
 80201e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80201ec:	bf48      	it	mi
 80201ee:	eef0 7a47 	vmovmi.f32	s15, s14
    p->curr=input*(1.0f-p->strength*levdiff);
 80201f2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80201f6:	ed94 7a02 	vldr	s14, [r4, #8]
 80201fa:	eea7 0a67 	vfms.f32	s0, s14, s15
 80201fe:	ee20 0a08 	vmul.f32	s0, s0, s16
 8020202:	ed84 0a04 	vstr	s0, [r4, #16]
    return p->curr;
}
 8020206:	ecbd 8b02 	vpop	{d8}
 802020a:	bd10      	pop	{r4, pc}
 802020c:	00000000 	.word	0x00000000

08020210 <tFeedbackLeveler_setTargetLevel>:
}


void     tFeedbackLeveler_setTargetLevel   (tFeedbackLeveler* const fb, float TargetLevel)
{
    _tFeedbackLeveler* p = *fb;
 8020210:	6803      	ldr	r3, [r0, #0]
    p->targetLevel=TargetLevel;
 8020212:	ed83 0a01 	vstr	s0, [r3, #4]
}
 8020216:	4770      	bx	lr

08020218 <tTalkbox_lpcDurbin>:
    }

}

void tTalkbox_lpcDurbin(float *r, int p, float *k, float *g)
{
 8020218:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i, j;
    float a[ORD_MAX], at[ORD_MAX], e=r[0];

    for(i=0; i<=p; i++)
 802021c:	f1b1 0900 	subs.w	r9, r1, #0
{
 8020220:	4615      	mov	r5, r2
 8020222:	ed2d 8b04 	vpush	{d8-d9}
 8020226:	b0c7      	sub	sp, #284	; 0x11c
    float a[ORD_MAX], at[ORD_MAX], e=r[0];
 8020228:	edd0 8a00 	vldr	s17, [r0]
{
 802022c:	9301      	str	r3, [sp, #4]
    for(i=0; i<=p; i++)
 802022e:	db7e      	blt.n	802032e <tTalkbox_lpcDurbin+0x116>
    {
        a[i] = 0.0f; //probably don't need to clear at[] or k[]
 8020230:	f109 0201 	add.w	r2, r9, #1
 8020234:	4607      	mov	r7, r0
 8020236:	2100      	movs	r1, #0
 8020238:	a802      	add	r0, sp, #8
 802023a:	0092      	lsls	r2, r2, #2
 802023c:	f006 fecf 	bl	8026fde <memset>
    }
    k[0] = 0.0f;
 8020240:	2300      	movs	r3, #0
    at[0] = 0.0f;
    for(i=1; i<=p; i++)
 8020242:	f1b9 0f00 	cmp.w	r9, #0
    k[0] = 0.0f;
 8020246:	602b      	str	r3, [r5, #0]
    at[0] = 0.0f;
 8020248:	9324      	str	r3, [sp, #144]	; 0x90
    for(i=1; i<=p; i++)
 802024a:	dd50      	ble.n	80202ee <tTalkbox_lpcDurbin+0xd6>
 802024c:	1d3e      	adds	r6, r7, #4
 802024e:	f06f 0a07 	mvn.w	sl, #7
 8020252:	3504      	adds	r5, #4
 8020254:	f10d 0808 	add.w	r8, sp, #8
 8020258:	ebaa 0a07 	sub.w	sl, sl, r7
 802025c:	4634      	mov	r4, r6
 802025e:	2701      	movs	r7, #1
        for(j=1; j<i; j++)
        {
            at[j] = a[j];
            k[i] -= a[j] * r[i-j];
        }
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
 8020260:	eddf 9a38 	vldr	s19, [pc, #224]	; 8020344 <tTalkbox_lpcDurbin+0x12c>
        k[i] = -r[i];
 8020264:	ed94 8a00 	vldr	s16, [r4]
        for(j=1; j<i; j++)
 8020268:	2f01      	cmp	r7, #1
 802026a:	f104 0b04 	add.w	fp, r4, #4
 802026e:	eeb0 9ae8 	vabs.f32	s18, s17
        k[i] = -r[i];
 8020272:	eeb1 8a48 	vneg.f32	s16, s16
 8020276:	eca5 8a01 	vstmia	r5!, {s16}
        for(j=1; j<i; j++)
 802027a:	d04c      	beq.n	8020316 <tTalkbox_lpcDurbin+0xfe>
 802027c:	ab25      	add	r3, sp, #148	; 0x94
 802027e:	eb0a 020b 	add.w	r2, sl, fp
 8020282:	a903      	add	r1, sp, #12
 8020284:	4618      	mov	r0, r3
 8020286:	f006 fe9f 	bl	8026fc8 <memcpy>
 802028a:	a903      	add	r1, sp, #12
 802028c:	4603      	mov	r3, r0
 802028e:	460a      	mov	r2, r1
            k[i] -= a[j] * r[i-j];
 8020290:	ed74 7a01 	vldmdb	r4!, {s15}
            at[j] = a[j];
 8020294:	ecb2 7a01 	vldmia	r2!, {s14}
        for(j=1; j<i; j++)
 8020298:	42a6      	cmp	r6, r4
            k[i] -= a[j] * r[i-j];
 802029a:	eea7 8a67 	vfms.f32	s16, s14, s15
 802029e:	ed05 8a01 	vstr	s16, [r5, #-4]
        for(j=1; j<i; j++)
 80202a2:	d1f5      	bne.n	8020290 <tTalkbox_lpcDurbin+0x78>
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
 80202a4:	eeb4 9ae9 	vcmpe.f32	s18, s19
 80202a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80202ac:	d429      	bmi.n	8020302 <tTalkbox_lpcDurbin+0xea>
        k[i] /= e;
 80202ae:	eec8 6a28 	vdiv.f32	s13, s16, s17
 80202b2:	aa24      	add	r2, sp, #144	; 0x90
 80202b4:	4618      	mov	r0, r3
 80202b6:	eb02 0287 	add.w	r2, r2, r7, lsl #2
 80202ba:	ed45 6a01 	vstr	s13, [r5, #-4]

        a[i] = k[i];
 80202be:	edc8 6a01 	vstr	s13, [r8, #4]
        for(j=1; j<i; j++) a[j] = at[j] + k[i] * at[i-j];
 80202c2:	ed32 7a01 	vldmdb	r2!, {s14}
 80202c6:	ecf0 7a01 	vldmia	r0!, {s15}
 80202ca:	4293      	cmp	r3, r2
 80202cc:	eee7 7a26 	vfma.f32	s15, s14, s13
 80202d0:	ece1 7a01 	vstmia	r1!, {s15}
 80202d4:	d1f5      	bne.n	80202c2 <tTalkbox_lpcDurbin+0xaa>

        e *= 1.0f - k[i] * k[i];
 80202d6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    for(i=1; i<=p; i++)
 80202da:	3701      	adds	r7, #1
 80202dc:	f108 0804 	add.w	r8, r8, #4
 80202e0:	465c      	mov	r4, fp
 80202e2:	45b9      	cmp	r9, r7
        e *= 1.0f - k[i] * k[i];
 80202e4:	eee6 7ae6 	vfms.f32	s15, s13, s13
 80202e8:	ee68 8aa7 	vmul.f32	s17, s17, s15
    for(i=1; i<=p; i++)
 80202ec:	daba      	bge.n	8020264 <tTalkbox_lpcDurbin+0x4c>
    }

    if(e < 1.0e-20f) e = 0.0f;
 80202ee:	eddf 7a15 	vldr	s15, [pc, #84]	; 8020344 <tTalkbox_lpcDurbin+0x12c>
 80202f2:	eef4 8ae7 	vcmpe.f32	s17, s15
 80202f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80202fa:	d402      	bmi.n	8020302 <tTalkbox_lpcDurbin+0xea>
 80202fc:	eef1 7ae8 	vsqrt.f32	s15, s17
 8020300:	e001      	b.n	8020306 <tTalkbox_lpcDurbin+0xee>
        for(j=1; j<i; j++)
 8020302:	eddf 7a11 	vldr	s15, [pc, #68]	; 8020348 <tTalkbox_lpcDurbin+0x130>
    *g = sqrtf(e);
 8020306:	9b01      	ldr	r3, [sp, #4]
 8020308:	edc3 7a00 	vstr	s15, [r3]
}
 802030c:	b047      	add	sp, #284	; 0x11c
 802030e:	ecbd 8b04 	vpop	{d8-d9}
 8020312:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
 8020316:	eeb4 9ae9 	vcmpe.f32	s18, s19
 802031a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802031e:	d4f0      	bmi.n	8020302 <tTalkbox_lpcDurbin+0xea>
        k[i] /= e;
 8020320:	eec8 6a28 	vdiv.f32	s13, s16, s17
 8020324:	ed45 6a01 	vstr	s13, [r5, #-4]
        a[i] = k[i];
 8020328:	edc8 6a01 	vstr	s13, [r8, #4]
 802032c:	e7d3      	b.n	80202d6 <tTalkbox_lpcDurbin+0xbe>
    if(e < 1.0e-20f) e = 0.0f;
 802032e:	eddf 7a05 	vldr	s15, [pc, #20]	; 8020344 <tTalkbox_lpcDurbin+0x12c>
    k[0] = 0.0f;
 8020332:	2300      	movs	r3, #0
    if(e < 1.0e-20f) e = 0.0f;
 8020334:	eef4 8ae7 	vcmpe.f32	s17, s15
    k[0] = 0.0f;
 8020338:	6013      	str	r3, [r2, #0]
    if(e < 1.0e-20f) e = 0.0f;
 802033a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802033e:	d5dd      	bpl.n	80202fc <tTalkbox_lpcDurbin+0xe4>
 8020340:	e7df      	b.n	8020302 <tTalkbox_lpcDurbin+0xea>
 8020342:	bf00      	nop
 8020344:	1e3ce508 	.word	0x1e3ce508
 8020348:	00000000 	.word	0x00000000

0802034c <tTalkboxFloat_free>:
    tTalkboxFloat_update(voc);
    tTalkboxFloat_suspend(voc);
}

void tTalkboxFloat_free (tTalkboxFloat* const voc)
{
 802034c:	b510      	push	{r4, lr}
    _tTalkboxFloat* v = *voc;
 802034e:	6804      	ldr	r4, [r0, #0]

    mpool_free((char*)v->buf1, v->mempool);
 8020350:	6821      	ldr	r1, [r4, #0]
 8020352:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8020354:	f004 f864 	bl	8024420 <mpool_free>
    mpool_free((char*)v->buf0, v->mempool);
 8020358:	6821      	ldr	r1, [r4, #0]
 802035a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802035c:	f004 f860 	bl	8024420 <mpool_free>
    mpool_free((char*)v->window, v->mempool);
 8020360:	6821      	ldr	r1, [r4, #0]
 8020362:	6a20      	ldr	r0, [r4, #32]
 8020364:	f004 f85c 	bl	8024420 <mpool_free>
    mpool_free((char*)v->car1, v->mempool);
 8020368:	6821      	ldr	r1, [r4, #0]
 802036a:	69e0      	ldr	r0, [r4, #28]
 802036c:	f004 f858 	bl	8024420 <mpool_free>
    mpool_free((char*)v->car0, v->mempool);
 8020370:	6821      	ldr	r1, [r4, #0]
 8020372:	69a0      	ldr	r0, [r4, #24]
 8020374:	f004 f854 	bl	8024420 <mpool_free>

    mpool_free((char*)v->dl, v->mempool);
 8020378:	6821      	ldr	r1, [r4, #0]
 802037a:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 802037e:	f004 f84f 	bl	8024420 <mpool_free>
    mpool_free((char*)v->Rt, v->mempool);
 8020382:	6821      	ldr	r1, [r4, #0]
 8020384:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8020388:	f004 f84a 	bl	8024420 <mpool_free>
    mpool_free((char*)v->k, v->mempool);
 802038c:	6821      	ldr	r1, [r4, #0]
 802038e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8020390:	f004 f846 	bl	8024420 <mpool_free>
    mpool_free((char*)v, v->mempool);
 8020394:	6821      	ldr	r1, [r4, #0]
 8020396:	4620      	mov	r0, r4
}
 8020398:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)v, v->mempool);
 802039c:	f004 b840 	b.w	8024420 <mpool_free>

080203a0 <tTalkboxFloat_update>:

void tTalkboxFloat_update(tTalkboxFloat* const voc) ///update internal parameters...
{
 80203a0:	b538      	push	{r3, r4, r5, lr}
    _tTalkboxFloat* v = *voc;
 80203a2:	6804      	ldr	r4, [r0, #0]

    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
    if(n > v->bufsize) n = v->bufsize;

    //O = (VstInt32)(0.0005f * fs);
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 80203a4:	eddf 7a33 	vldr	s15, [pc, #204]	; 8020474 <tTalkboxFloat_update+0xd4>
    float fs = leaf.sampleRate;
 80203a8:	4b33      	ldr	r3, [pc, #204]	; (8020478 <tTalkboxFloat_update+0xd8>)
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 80203aa:	ed9f 7a34 	vldr	s14, [pc, #208]	; 802047c <tTalkboxFloat_update+0xdc>
 80203ae:	eddf 5a34 	vldr	s11, [pc, #208]	; 8020480 <tTalkboxFloat_update+0xe0>
 80203b2:	ed9f 6a34 	vldr	s12, [pc, #208]	; 8020484 <tTalkboxFloat_update+0xe4>
{
 80203b6:	ed2d 8b04 	vpush	{d8-d9}
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 80203ba:	edd4 6a04 	vldr	s13, [r4, #16]
 80203be:	6961      	ldr	r1, [r4, #20]
 80203c0:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80203c4:	edd3 6a00 	vldr	s13, [r3]
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
 80203c8:	eddf 7a2f 	vldr	s15, [pc, #188]	; 8020488 <tTalkboxFloat_update+0xe8>
 80203cc:	fec6 6ae5 	vminnm.f32	s13, s13, s11
 80203d0:	fec6 6a86 	vmaxnm.f32	s13, s13, s12
 80203d4:	ee66 7aa7 	vmul.f32	s15, s13, s15

    if(n != v->N) //recalc hanning window
 80203d8:	6c62      	ldr	r2, [r4, #68]	; 0x44
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
 80203da:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 80203de:	ee27 7a26 	vmul.f32	s14, s14, s13
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
 80203e2:	ee17 3a90 	vmov	r3, s15
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 80203e6:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 80203ea:	428b      	cmp	r3, r1
 80203ec:	bfa8      	it	ge
 80203ee:	460b      	movge	r3, r1
 80203f0:	ed84 7a12 	vstr	s14, [r4, #72]	; 0x48
    if(n != v->N) //recalc hanning window
 80203f4:	429a      	cmp	r2, r3
 80203f6:	d027      	beq.n	8020448 <tTalkboxFloat_update+0xa8>
    {
        v->N = n;
        float dp = TWO_PI / v->N;
 80203f8:	ee07 3a90 	vmov	s15, r3
 80203fc:	ed9f 7a23 	vldr	s14, [pc, #140]	; 802048c <tTalkboxFloat_update+0xec>
        float p = 0.0f;
        for(n=0; n<v->N; n++)
 8020400:	2b00      	cmp	r3, #0
        v->N = n;
 8020402:	6463      	str	r3, [r4, #68]	; 0x44
        float dp = TWO_PI / v->N;
 8020404:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8020408:	eec7 8a27 	vdiv.f32	s17, s14, s15
        for(n=0; n<v->N; n++)
 802040c:	dd1c      	ble.n	8020448 <tTalkboxFloat_update+0xa8>
        float p = 0.0f;
 802040e:	ed9f 8a20 	vldr	s16, [pc, #128]	; 8020490 <tTalkboxFloat_update+0xf0>
        for(n=0; n<v->N; n++)
 8020412:	2500      	movs	r5, #0
 8020414:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
        {
            v->window[n] = 0.5f - 0.5f * cosf(p);
 8020418:	eef6 9a00 	vmov.f32	s19, #96	; 0x3f000000  0.5
 802041c:	eeb0 9a40 	vmov.f32	s18, s0
 8020420:	e001      	b.n	8020426 <tTalkboxFloat_update+0x86>
 8020422:	f006 fefd 	bl	8027220 <cosf>
 8020426:	ee39 0a40 	vsub.f32	s0, s18, s0
 802042a:	6a23      	ldr	r3, [r4, #32]
            p += dp;
 802042c:	ee38 8a28 	vadd.f32	s16, s16, s17
            v->window[n] = 0.5f - 0.5f * cosf(p);
 8020430:	eb03 0385 	add.w	r3, r3, r5, lsl #2
        for(n=0; n<v->N; n++)
 8020434:	3501      	adds	r5, #1
            v->window[n] = 0.5f - 0.5f * cosf(p);
 8020436:	ee60 7a29 	vmul.f32	s15, s0, s19
 802043a:	eeb0 0a48 	vmov.f32	s0, s16
 802043e:	edc3 7a00 	vstr	s15, [r3]
        for(n=0; n<v->N; n++)
 8020442:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8020444:	42ab      	cmp	r3, r5
 8020446:	dcec      	bgt.n	8020422 <tTalkboxFloat_update+0x82>
        }
    }
    v->wet = 0.5f * v->param[0] * v->param[0];
 8020448:	ed94 7a01 	vldr	s14, [r4, #4]
 802044c:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    v->dry = 2.0f * v->param[1] * v->param[1];
 8020450:	edd4 7a02 	vldr	s15, [r4, #8]
    v->wet = 0.5f * v->param[0] * v->param[0];
 8020454:	ee27 7a07 	vmul.f32	s14, s14, s14
    v->dry = 2.0f * v->param[1] * v->param[1];
 8020458:	ee67 7aa7 	vmul.f32	s15, s15, s15
    v->wet = 0.5f * v->param[0] * v->param[0];
 802045c:	ee27 7a26 	vmul.f32	s14, s14, s13
    v->dry = 2.0f * v->param[1] * v->param[1];
 8020460:	ee77 7aa7 	vadd.f32	s15, s15, s15
    v->wet = 0.5f * v->param[0] * v->param[0];
 8020464:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
    v->dry = 2.0f * v->param[1] * v->param[1];
 8020468:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
}
 802046c:	ecbd 8b04 	vpop	{d8-d9}
 8020470:	bd38      	pop	{r3, r4, r5, pc}
 8020472:	bf00      	nop
 8020474:	39d1b717 	.word	0x39d1b717
 8020478:	200194e8 	.word	0x200194e8
 802047c:	38d1b717 	.word	0x38d1b717
 8020480:	47bb8000 	.word	0x47bb8000
 8020484:	45fa0000 	.word	0x45fa0000
 8020488:	3c85c67e 	.word	0x3c85c67e
 802048c:	40c90fdb 	.word	0x40c90fdb
 8020490:	00000000 	.word	0x00000000

08020494 <tTalkboxFloat_initToPool>:
{
 8020494:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
 8020498:	6817      	ldr	r7, [r2, #0]
{
 802049a:	4680      	mov	r8, r0
 802049c:	4689      	mov	r9, r1
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
 802049e:	2090      	movs	r0, #144	; 0x90
 80204a0:	4639      	mov	r1, r7
    v->param[1] = 0.0f;  //dry
 80204a2:	2400      	movs	r4, #0
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
 80204a4:	f003 ff08 	bl	80242b8 <mpool_alloc>
    v->warpOn = 0;
 80204a8:	2500      	movs	r5, #0
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
 80204aa:	4606      	mov	r6, r0
    v->param[0] = 0.5f;  //wet
 80204ac:	f04f 527c 	mov.w	r2, #1056964608	; 0x3f000000
    v->param[3] = 1.0f;  //quality
 80204b0:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
 80204b4:	f8c8 0000 	str.w	r0, [r8]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204b8:	4639      	mov	r1, r7
    v->mempool = m;
 80204ba:	6007      	str	r7, [r0, #0]
    v->bufsize = bufsize;
 80204bc:	f8c0 9014 	str.w	r9, [r0, #20]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204c0:	ea4f 0089 	mov.w	r0, r9, lsl #2
    v->param[0] = 0.5f;  //wet
 80204c4:	6072      	str	r2, [r6, #4]
    v->param[3] = 1.0f;  //quality
 80204c6:	6133      	str	r3, [r6, #16]
    v->param[1] = 0.0f;  //dry
 80204c8:	60b4      	str	r4, [r6, #8]
    v->param[2] = 0; // Swap
 80204ca:	60f4      	str	r4, [r6, #12]
    v->warpFactor = 0.0f;
 80204cc:	6334      	str	r4, [r6, #48]	; 0x30
    v->G = 0.0f;
 80204ce:	f8c6 4084 	str.w	r4, [r6, #132]	; 0x84
    v->freeze = 0;
 80204d2:	e9c6 550d 	strd	r5, r5, [r6, #52]	; 0x34
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204d6:	f003 feef 	bl	80242b8 <mpool_alloc>
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204da:	6973      	ldr	r3, [r6, #20]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204dc:	61b0      	str	r0, [r6, #24]
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204de:	4639      	mov	r1, r7
 80204e0:	0098      	lsls	r0, r3, #2
 80204e2:	f003 fee9 	bl	80242b8 <mpool_alloc>
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204e6:	6973      	ldr	r3, [r6, #20]
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204e8:	61f0      	str	r0, [r6, #28]
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204ea:	4639      	mov	r1, r7
 80204ec:	0098      	lsls	r0, r3, #2
 80204ee:	f003 fee3 	bl	80242b8 <mpool_alloc>
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204f2:	6973      	ldr	r3, [r6, #20]
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204f4:	6230      	str	r0, [r6, #32]
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204f6:	4639      	mov	r1, r7
 80204f8:	0098      	lsls	r0, r3, #2
 80204fa:	f003 fedd 	bl	80242b8 <mpool_alloc>
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 80204fe:	6973      	ldr	r3, [r6, #20]
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8020500:	6270      	str	r0, [r6, #36]	; 0x24
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8020502:	4639      	mov	r1, r7
 8020504:	0098      	lsls	r0, r3, #2
 8020506:	f003 fed7 	bl	80242b8 <mpool_alloc>
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 802050a:	6973      	ldr	r3, [r6, #20]
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 802050c:	62b0      	str	r0, [r6, #40]	; 0x28
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 802050e:	4639      	mov	r1, r7
 8020510:	0098      	lsls	r0, r3, #2
 8020512:	f003 fed1 	bl	80242b8 <mpool_alloc>
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8020516:	6973      	ldr	r3, [r6, #20]
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8020518:	f8c6 0088 	str.w	r0, [r6, #136]	; 0x88
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 802051c:	4639      	mov	r1, r7
 802051e:	0098      	lsls	r0, r3, #2
 8020520:	f003 feca 	bl	80242b8 <mpool_alloc>
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
 8020524:	4639      	mov	r1, r7
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8020526:	f8c6 008c 	str.w	r0, [r6, #140]	; 0x8c
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
 802052a:	2088      	movs	r0, #136	; 0x88
 802052c:	f003 fec4 	bl	80242b8 <mpool_alloc>
 8020530:	62f0      	str	r0, [r6, #44]	; 0x2c
    tTalkboxFloat_update(voc);
 8020532:	4640      	mov	r0, r8
 8020534:	f7ff ff34 	bl	80203a0 <tTalkboxFloat_update>

void tTalkboxFloat_suspend(tTalkboxFloat* const voc) ///clear any buffers...
{
    _tTalkboxFloat* v = *voc;
 8020538:	f8d8 3000 	ldr.w	r3, [r8]
    v->FX = 0;

    v->u0 = v->u1 = v->u2 = v->u3 = v->u4 = 0.0f;
    v->d0 = v->d1 = v->d2 = v->d3 = v->d4 = 0.0f;

    for (int32_t i = 0; i < v->bufsize; i++)
 802053c:	695a      	ldr	r2, [r3, #20]
    v->pos = v->K = 0;
 802053e:	641d      	str	r5, [r3, #64]	; 0x40
    for (int32_t i = 0; i < v->bufsize; i++)
 8020540:	42aa      	cmp	r2, r5
    v->pos = v->K = 0;
 8020542:	64dd      	str	r5, [r3, #76]	; 0x4c
    v->emphasis = 0.0f;
 8020544:	63dc      	str	r4, [r3, #60]	; 0x3c
    v->FX = 0;
 8020546:	659c      	str	r4, [r3, #88]	; 0x58
    v->u0 = v->u1 = v->u2 = v->u3 = v->u4 = 0.0f;
 8020548:	f8c3 4080 	str.w	r4, [r3, #128]	; 0x80
 802054c:	67dc      	str	r4, [r3, #124]	; 0x7c
 802054e:	679c      	str	r4, [r3, #120]	; 0x78
 8020550:	675c      	str	r4, [r3, #116]	; 0x74
 8020552:	671c      	str	r4, [r3, #112]	; 0x70
    v->d0 = v->d1 = v->d2 = v->d3 = v->d4 = 0.0f;
 8020554:	66dc      	str	r4, [r3, #108]	; 0x6c
 8020556:	669c      	str	r4, [r3, #104]	; 0x68
 8020558:	665c      	str	r4, [r3, #100]	; 0x64
 802055a:	661c      	str	r4, [r3, #96]	; 0x60
 802055c:	65dc      	str	r4, [r3, #92]	; 0x5c
    for (int32_t i = 0; i < v->bufsize; i++)
 802055e:	dd12      	ble.n	8020586 <tTalkboxFloat_initToPool+0xf2>
 8020560:	4629      	mov	r1, r5
    {
        v->buf0[i] = 0;
 8020562:	4622      	mov	r2, r4
 8020564:	0088      	lsls	r0, r1, #2
 8020566:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    for (int32_t i = 0; i < v->bufsize; i++)
 8020568:	3101      	adds	r1, #1
        v->buf0[i] = 0;
 802056a:	4404      	add	r4, r0
 802056c:	6022      	str	r2, [r4, #0]
        v->buf1[i] = 0;
 802056e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8020570:	4404      	add	r4, r0
 8020572:	6022      	str	r2, [r4, #0]
        v->car0[i] = 0;
 8020574:	699c      	ldr	r4, [r3, #24]
 8020576:	4404      	add	r4, r0
 8020578:	6022      	str	r2, [r4, #0]
        v->car1[i] = 0;
 802057a:	69dc      	ldr	r4, [r3, #28]
 802057c:	4420      	add	r0, r4
 802057e:	6002      	str	r2, [r0, #0]
    for (int32_t i = 0; i < v->bufsize; i++)
 8020580:	6958      	ldr	r0, [r3, #20]
 8020582:	4281      	cmp	r1, r0
 8020584:	dbee      	blt.n	8020564 <tTalkboxFloat_initToPool+0xd0>
}
 8020586:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802058a:	bf00      	nop

0802058c <tTalkboxFloat_init>:
    tTalkboxFloat_initToPool(voc, bufsize, &leaf.mempool);
 802058c:	4a01      	ldr	r2, [pc, #4]	; (8020594 <tTalkboxFloat_init+0x8>)
 802058e:	f7ff bf81 	b.w	8020494 <tTalkboxFloat_initToPool>
 8020592:	bf00      	nop
 8020594:	20019500 	.word	0x20019500

08020598 <tTalkboxFloat_warpedAutocorrelate>:

// warped autocorrelation adapted from ten.enegatum@liam's post on music-dsp 2004-04-07 09:37:51
//find the order-P autocorrelation array, R, for the sequence x of length L and warping of lambda
//wAutocorrelate(&pfSrc[stIndex],siglen,R,P,0);
void tTalkboxFloat_warpedAutocorrelate(float * x, float* dl, float* Rt, unsigned int L, float * R, unsigned int P, float lambda)
{
 8020598:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    float r1,r2,r1t;
    R[0]=0;
 802059c:	ed9f 7a34 	vldr	s14, [pc, #208]	; 8020670 <tTalkboxFloat_warpedAutocorrelate+0xd8>
{
 80205a0:	f8dd e01c 	ldr.w	lr, [sp, #28]
 80205a4:	9d08      	ldr	r5, [sp, #32]
    R[0]=0;
 80205a6:	ed8e 7a00 	vstr	s14, [lr]
    Rt[0]=0;
 80205aa:	ed82 7a00 	vstr	s14, [r2]
    r1=0;
    r2=0;
    r1t=0;
    for(uint32_t m=0; m<L;m++)
 80205ae:	b1f3      	cbz	r3, 80205ee <tTalkboxFloat_warpedAutocorrelate+0x56>
 80205b0:	4604      	mov	r4, r0
 80205b2:	460e      	mov	r6, r1
 80205b4:	eb00 0783 	add.w	r7, r0, r3, lsl #2
    r2=0;
 80205b8:	eef0 7a47 	vmov.f32	s15, s14
    r1=0;
 80205bc:	eeb0 6a47 	vmov.f32	s12, s14
 80205c0:	e001      	b.n	80205c6 <tTalkboxFloat_warpedAutocorrelate+0x2e>
 80205c2:	ed92 7a00 	vldr	s14, [r2]
    {
                    Rt[0] += (x[m]) * (x[m]);
 80205c6:	edd4 6a00 	vldr	s13, [r4]
 80205ca:	eea6 7aa6 	vfma.f32	s14, s13, s13
 80205ce:	ed82 7a00 	vstr	s14, [r2]

                    dl[m]= r1 - lambda * (x[m]-r2);
 80205d2:	ecb4 7a01 	vldmia	r4!, {s14}
 80205d6:	ee77 7ac7 	vsub.f32	s15, s15, s14
    for(uint32_t m=0; m<L;m++)
 80205da:	42bc      	cmp	r4, r7
                    dl[m]= r1 - lambda * (x[m]-r2);
 80205dc:	eea7 6a80 	vfma.f32	s12, s15, s0
 80205e0:	eef0 7a46 	vmov.f32	s15, s12
 80205e4:	eca6 6a01 	vstmia	r6!, {s12}
                    r1 = x[m];
 80205e8:	ed14 6a01 	vldr	s12, [r4, #-4]
    for(uint32_t m=0; m<L;m++)
 80205ec:	d1e9      	bne.n	80205c2 <tTalkboxFloat_warpedAutocorrelate+0x2a>
                    r2 = dl[m];
    }
    for(uint32_t i=1; i<=P; i++)
 80205ee:	b3d5      	cbz	r5, 8020666 <tTalkboxFloat_warpedAutocorrelate+0xce>
 80205f0:	ea4f 0885 	mov.w	r8, r5, lsl #2
 80205f4:	4694      	mov	ip, r2
 80205f6:	1d15      	adds	r5, r2, #4
 80205f8:	eb01 0783 	add.w	r7, r1, r3, lsl #2
 80205fc:	f108 0804 	add.w	r8, r8, #4
    {
            Rt[i]=0;
 8020600:	ed9f 5a1b 	vldr	s10, [pc, #108]	; 8020670 <tTalkboxFloat_warpedAutocorrelate+0xd8>
 8020604:	eb02 0908 	add.w	r9, r2, r8
 8020608:	eca5 5a01 	vstmia	r5!, {s10}
            r1=0;
            r2=0;
            for(unsigned int m=0; m<L;m++)
 802060c:	b303      	cbz	r3, 8020650 <tTalkboxFloat_warpedAutocorrelate+0xb8>
 802060e:	4606      	mov	r6, r0
 8020610:	460c      	mov	r4, r1
 8020612:	eeb0 7a45 	vmov.f32	s14, s10
            r2=0;
 8020616:	eef0 7a45 	vmov.f32	s15, s10
            r1=0;
 802061a:	eef0 6a45 	vmov.f32	s13, s10
 802061e:	e001      	b.n	8020624 <tTalkboxFloat_warpedAutocorrelate+0x8c>
 8020620:	ed15 7a01 	vldr	s14, [r5, #-4]
            {
                    Rt[i] +=  (dl[m]) * (x[m]);
 8020624:	edd4 5a00 	vldr	s11, [r4]
 8020628:	ecb6 6a01 	vldmia	r6!, {s12}
 802062c:	eea5 7a86 	vfma.f32	s14, s11, s12
 8020630:	ed05 7a01 	vstr	s14, [r5, #-4]

                    r1t = dl[m];
 8020634:	ecb4 7a01 	vldmia	r4!, {s14}
                    dl[m]= r1 - lambda * (r1t-r2);
 8020638:	ee77 7ac7 	vsub.f32	s15, s15, s14
            for(unsigned int m=0; m<L;m++)
 802063c:	42a7      	cmp	r7, r4
                    dl[m]= r1 - lambda * (r1t-r2);
 802063e:	eee7 6a80 	vfma.f32	s13, s15, s0
 8020642:	eef0 7a66 	vmov.f32	s15, s13
                    r1 = r1t;
 8020646:	eef0 6a47 	vmov.f32	s13, s14
                    dl[m]= r1 - lambda * (r1t-r2);
 802064a:	ed44 7a01 	vstr	s15, [r4, #-4]
            for(unsigned int m=0; m<L;m++)
 802064e:	d1e7      	bne.n	8020620 <tTalkboxFloat_warpedAutocorrelate+0x88>
    for(uint32_t i=1; i<=P; i++)
 8020650:	45a9      	cmp	r9, r5
 8020652:	d1d9      	bne.n	8020608 <tTalkboxFloat_warpedAutocorrelate+0x70>
 8020654:	4442      	add	r2, r8
                    r2 = dl[m];
            }
    }
    for(uint32_t i=0; i<=P; i++)
    {
            R[i]=Rt[i];
 8020656:	f85c 3b04 	ldr.w	r3, [ip], #4
    for(uint32_t i=0; i<=P; i++)
 802065a:	4562      	cmp	r2, ip
            R[i]=Rt[i];
 802065c:	f84e 3b04 	str.w	r3, [lr], #4
    for(uint32_t i=0; i<=P; i++)
 8020660:	d1f9      	bne.n	8020656 <tTalkboxFloat_warpedAutocorrelate+0xbe>
    }

}
 8020662:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            R[i]=Rt[i];
 8020666:	6813      	ldr	r3, [r2, #0]
 8020668:	f8ce 3000 	str.w	r3, [lr]
}
 802066c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8020670:	00000000 	.word	0x00000000

08020674 <tTalkboxFloat_lpc>:
    return o;
}


void tTalkboxFloat_lpc(float *buf, float *car, float* dl, float* Rt, int32_t n, int32_t o, float warp, int warpOn, float *k, int freeze, float *G)
{
 8020674:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020678:	ed2d 8b02 	vpush	{d8}
 802067c:	b0c9      	sub	sp, #292	; 0x124
 802067e:	4605      	mov	r5, r0
 8020680:	460c      	mov	r4, r1
 8020682:	9f56      	ldr	r7, [sp, #344]	; 0x158
 8020684:	9e54      	ldr	r6, [sp, #336]	; 0x150
 8020686:	f8dd 8154 	ldr.w	r8, [sp, #340]	; 0x154
 802068a:	f8dd 9164 	ldr.w	r9, [sp, #356]	; 0x164
    float z[ORD_MAX], r[ORD_MAX], x;
    int32_t i, j, nn=n;


    if (warpOn == 0)
 802068e:	2f00      	cmp	r7, #0
 8020690:	d03c      	beq.n	802070c <tTalkboxFloat_lpc+0x98>
            for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
        }
    }
    else
    {
        for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
 8020692:	f1b8 0f00 	cmp.w	r8, #0
 8020696:	4692      	mov	sl, r2
 8020698:	469b      	mov	fp, r3
 802069a:	eeb0 8a40 	vmov.f32	s16, s0
 802069e:	f2c0 80b2 	blt.w	8020806 <tTalkboxFloat_lpc+0x192>
        {
            z[j] = r[j] = 0.0f;
 80206a2:	f108 0701 	add.w	r7, r8, #1
 80206a6:	ab26      	add	r3, sp, #152	; 0x98
 80206a8:	2100      	movs	r1, #0
 80206aa:	00bf      	lsls	r7, r7, #2
 80206ac:	4618      	mov	r0, r3
 80206ae:	9303      	str	r3, [sp, #12]
 80206b0:	463a      	mov	r2, r7
 80206b2:	f006 fc94 	bl	8026fde <memset>
 80206b6:	463a      	mov	r2, r7
 80206b8:	2100      	movs	r1, #0
 80206ba:	a804      	add	r0, sp, #16
 80206bc:	f006 fc8f 	bl	8026fde <memset>
 80206c0:	9b03      	ldr	r3, [sp, #12]
        }
        tTalkboxFloat_warpedAutocorrelate(buf, dl, Rt, n, r, o, warp);
 80206c2:	9300      	str	r3, [sp, #0]
 80206c4:	eeb0 0a48 	vmov.f32	s0, s16
 80206c8:	f8cd 8004 	str.w	r8, [sp, #4]
 80206cc:	465a      	mov	r2, fp
 80206ce:	4651      	mov	r1, sl
 80206d0:	4633      	mov	r3, r6
 80206d2:	4628      	mov	r0, r5
 80206d4:	f7ff ff60 	bl	8020598 <tTalkboxFloat_warpedAutocorrelate>
    }

    r[0] *= 1.001f;  //stability fix
 80206d8:	eddd 7a26 	vldr	s15, [sp, #152]	; 0x98
 80206dc:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 802080c <tTalkboxFloat_lpc+0x198>

    float min = 0.000001f;
    if (!freeze)
 80206e0:	9b58      	ldr	r3, [sp, #352]	; 0x160
    r[0] *= 1.001f;  //stability fix
 80206e2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80206e6:	edcd 7a26 	vstr	s15, [sp, #152]	; 0x98
    if (!freeze)
 80206ea:	bbcb      	cbnz	r3, 8020760 <tTalkboxFloat_lpc+0xec>
    {
        if(r[0] < min)
        {
            for(i=0; i<n; i++)
 80206ec:	2e00      	cmp	r6, #0
 80206ee:	dd65      	ble.n	80207bc <tTalkboxFloat_lpc+0x148>
        if(r[0] < min)
 80206f0:	ed9f 7a47 	vldr	s14, [pc, #284]	; 8020810 <tTalkboxFloat_lpc+0x19c>
            for(i=0; i<n; i++)
 80206f4:	eef4 7a47 	vcmp.f32	s15, s14
 80206f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80206fc:	d55e      	bpl.n	80207bc <tTalkboxFloat_lpc+0x148>
            {
                buf[i] = 0.0f;
 80206fe:	2300      	movs	r3, #0
 8020700:	602b      	str	r3, [r5, #0]
            x -= k[j] * z[j-1];
            z[j] = z[j-1] + k[j] * x;
        }
        buf[i] = z[0] = x;  //output buf[] will be windowed elsewhere
    }
}
 8020702:	b049      	add	sp, #292	; 0x124
 8020704:	ecbd 8b02 	vpop	{d8}
 8020708:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
 802070c:	f1b8 0f00 	cmp.w	r8, #0
 8020710:	dbe2      	blt.n	80206d8 <tTalkboxFloat_lpc+0x64>
 8020712:	ea6f 0a08 	mvn.w	sl, r8
 8020716:	eb00 0186 	add.w	r1, r0, r6, lsl #2
 802071a:	4607      	mov	r7, r0
 802071c:	f10d 0c98 	add.w	ip, sp, #152	; 0x98
 8020720:	f10d 0e10 	add.w	lr, sp, #16
 8020724:	44b2      	add	sl, r6
 8020726:	4630      	mov	r0, r6
            z[j] = r[j] = 0.0f;
 8020728:	f04f 0b00 	mov.w	fp, #0
            for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
 802072c:	2800      	cmp	r0, #0
            z[j] = r[j] = 0.0f;
 802072e:	f84c bb04 	str.w	fp, [ip], #4
 8020732:	f84e bb04 	str.w	fp, [lr], #4
            for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
 8020736:	dd0d      	ble.n	8020754 <tTalkboxFloat_lpc+0xe0>
 8020738:	463a      	mov	r2, r7
 802073a:	462b      	mov	r3, r5
 802073c:	eddf 7a35 	vldr	s15, [pc, #212]	; 8020814 <tTalkboxFloat_lpc+0x1a0>
 8020740:	ecf3 6a01 	vldmia	r3!, {s13}
 8020744:	ecb2 7a01 	vldmia	r2!, {s14}
 8020748:	4299      	cmp	r1, r3
 802074a:	eee6 7a87 	vfma.f32	s15, s13, s14
 802074e:	d1f7      	bne.n	8020740 <tTalkboxFloat_lpc+0xcc>
 8020750:	ed4c 7a01 	vstr	s15, [ip, #-4]
        for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
 8020754:	3801      	subs	r0, #1
 8020756:	3704      	adds	r7, #4
 8020758:	3904      	subs	r1, #4
 802075a:	4582      	cmp	sl, r0
 802075c:	d1e6      	bne.n	802072c <tTalkboxFloat_lpc+0xb8>
 802075e:	e7bb      	b.n	80206d8 <tTalkboxFloat_lpc+0x64>
    for(i=0; i<n; i++)
 8020760:	2e00      	cmp	r6, #0
 8020762:	ddce      	ble.n	8020702 <tTalkboxFloat_lpc+0x8e>
 8020764:	f108 0001 	add.w	r0, r8, #1
 8020768:	9b57      	ldr	r3, [sp, #348]	; 0x15c
 802076a:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 802076e:	0080      	lsls	r0, r0, #2
 8020770:	1d19      	adds	r1, r3, #4
 8020772:	181f      	adds	r7, r3, r0
 8020774:	ab04      	add	r3, sp, #16
 8020776:	4418      	add	r0, r3
        x = G[0] * car[i];
 8020778:	ecb4 7a01 	vldmia	r4!, {s14}
        for(j=o; j>0; j--)  //lattice filter
 802077c:	f1b8 0f00 	cmp.w	r8, #0
        x = G[0] * car[i];
 8020780:	edd9 7a00 	vldr	s15, [r9]
 8020784:	ee27 7a27 	vmul.f32	s14, s14, s15
        for(j=o; j>0; j--)  //lattice filter
 8020788:	dd0d      	ble.n	80207a6 <tTalkboxFloat_lpc+0x132>
 802078a:	4602      	mov	r2, r0
 802078c:	463b      	mov	r3, r7
            x -= k[j] * z[j-1];
 802078e:	ed73 6a01 	vldmdb	r3!, {s13}
 8020792:	ed52 7a02 	vldr	s15, [r2, #-8]
        for(j=o; j>0; j--)  //lattice filter
 8020796:	4299      	cmp	r1, r3
            x -= k[j] * z[j-1];
 8020798:	eea6 7ae7 	vfms.f32	s14, s13, s15
            z[j] = z[j-1] + k[j] * x;
 802079c:	eee6 7a87 	vfma.f32	s15, s13, s14
 80207a0:	ed62 7a01 	vstmdb	r2!, {s15}
        for(j=o; j>0; j--)  //lattice filter
 80207a4:	d1f3      	bne.n	802078e <tTalkboxFloat_lpc+0x11a>
    for(i=0; i<n; i++)
 80207a6:	42a6      	cmp	r6, r4
        buf[i] = z[0] = x;  //output buf[] will be windowed elsewhere
 80207a8:	ed8d 7a04 	vstr	s14, [sp, #16]
 80207ac:	eca5 7a01 	vstmia	r5!, {s14}
    for(i=0; i<n; i++)
 80207b0:	d1e2      	bne.n	8020778 <tTalkboxFloat_lpc+0x104>
}
 80207b2:	b049      	add	sp, #292	; 0x124
 80207b4:	ecbd 8b02 	vpop	{d8}
 80207b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        tTalkbox_lpcDurbin(r, o, k, G);  //calc reflection coeffs
 80207bc:	464b      	mov	r3, r9
 80207be:	9a57      	ldr	r2, [sp, #348]	; 0x15c
 80207c0:	4641      	mov	r1, r8
 80207c2:	a826      	add	r0, sp, #152	; 0x98
 80207c4:	f7ff fd28 	bl	8020218 <tTalkbox_lpcDurbin>
        for(i=0; i<=o; i++)
 80207c8:	f1b8 0f00 	cmp.w	r8, #0
 80207cc:	dbc8      	blt.n	8020760 <tTalkboxFloat_lpc+0xec>
 80207ce:	9b57      	ldr	r3, [sp, #348]	; 0x15c
            if(k[i] > 0.998f) k[i] = 0.998f; else if(k[i] < -0.998f) k[i] = -.998f;
 80207d0:	ed9f 7a11 	vldr	s14, [pc, #68]	; 8020818 <tTalkboxFloat_lpc+0x1a4>
 80207d4:	1d1a      	adds	r2, r3, #4
 80207d6:	eddf 6a11 	vldr	s13, [pc, #68]	; 802081c <tTalkboxFloat_lpc+0x1a8>
 80207da:	eb02 0288 	add.w	r2, r2, r8, lsl #2
 80207de:	e003      	b.n	80207e8 <tTalkboxFloat_lpc+0x174>
 80207e0:	ed03 7a01 	vstr	s14, [r3, #-4]
        for(i=0; i<=o; i++)
 80207e4:	429a      	cmp	r2, r3
 80207e6:	d0bb      	beq.n	8020760 <tTalkboxFloat_lpc+0xec>
            if(k[i] > 0.998f) k[i] = 0.998f; else if(k[i] < -0.998f) k[i] = -.998f;
 80207e8:	ecf3 7a01 	vldmia	r3!, {s15}
 80207ec:	eef4 7ac7 	vcmpe.f32	s15, s14
 80207f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80207f4:	dcf4      	bgt.n	80207e0 <tTalkboxFloat_lpc+0x16c>
 80207f6:	eef4 7ae6 	vcmpe.f32	s15, s13
 80207fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80207fe:	bf48      	it	mi
 8020800:	ed43 6a01 	vstrmi	s13, [r3, #-4]
 8020804:	e7ee      	b.n	80207e4 <tTalkboxFloat_lpc+0x170>
 8020806:	ab26      	add	r3, sp, #152	; 0x98
 8020808:	e75b      	b.n	80206c2 <tTalkboxFloat_lpc+0x4e>
 802080a:	bf00      	nop
 802080c:	3f8020c5 	.word	0x3f8020c5
 8020810:	358637bd 	.word	0x358637bd
 8020814:	00000000 	.word	0x00000000
 8020818:	3f7f7cee 	.word	0x3f7f7cee
 802081c:	bf7f7cee 	.word	0xbf7f7cee

08020820 <tTalkboxFloat_tick>:
{
 8020820:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020824:	ed2d 8b04 	vpush	{d8-d9}
    _tTalkboxFloat* v = *voc;
 8020828:	6804      	ldr	r4, [r0, #0]
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 802082a:	eeb0 5a40 	vmov.f32	s10, s0
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 802082e:	eddf 6a62 	vldr	s13, [pc, #392]	; 80209b8 <tTalkboxFloat_tick+0x198>
{
 8020832:	b086      	sub	sp, #24
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 8020834:	ed94 7a1b 	vldr	s14, [r4, #108]	; 0x6c
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 8020838:	eddf 5a60 	vldr	s11, [pc, #384]	; 80209bc <tTalkboxFloat_tick+0x19c>
 802083c:	edd4 7a17 	vldr	s15, [r4, #92]	; 0x5c
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 8020840:	ed94 6a19 	vldr	s12, [r4, #100]	; 0x64
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 8020844:	eee0 7a25 	vfma.f32	s15, s0, s11
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 8020848:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 802084a:	eea7 6a26 	vfma.f32	s12, s14, s13
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 802084e:	6e21      	ldr	r1, [r4, #96]	; 0x60
    if(v->K++)
 8020850:	6c22      	ldr	r2, [r4, #64]	; 0x40
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 8020852:	6663      	str	r3, [r4, #100]	; 0x64
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 8020854:	65e1      	str	r1, [r4, #92]	; 0x5c
    v->d4 = x;
 8020856:	ed84 0a1b 	vstr	s0, [r4, #108]	; 0x6c
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 802085a:	eea7 5ae5 	vfms.f32	s10, s15, s11
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 802085e:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 8020860:	eea6 7a66 	vfms.f32	s14, s12, s13
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 8020864:	6c63      	ldr	r3, [r4, #68]	; 0x44
    float e=v->emphasis, w, o, x, fx=v->FX;
 8020866:	edd4 6a0f 	vldr	s13, [r4, #60]	; 0x3c
 802086a:	ed94 8a16 	vldr	s16, [r4, #88]	; 0x58
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 802086e:	ed84 5a18 	vstr	s10, [r4, #96]	; 0x60
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 8020872:	ed84 7a1a 	vstr	s14, [r4, #104]	; 0x68
    if(v->K++)
 8020876:	2a00      	cmp	r2, #0
 8020878:	d06b      	beq.n	8020952 <tTalkboxFloat_tick+0x132>
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 802087a:	2b00      	cmp	r3, #0
 802087c:	461e      	mov	r6, r3
        v->car0[p0] = v->car1[p1] = x; //carrier input
 802087e:	69e0      	ldr	r0, [r4, #28]
    x = p + q;
 8020880:	ee77 7a86 	vadd.f32	s15, s15, s12
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 8020884:	bfb8      	it	lt
 8020886:	1c5e      	addlt	r6, r3, #1
        v->K = 0;
 8020888:	2700      	movs	r7, #0
        v->car0[p0] = v->car1[p1] = x; //carrier input
 802088a:	00a9      	lsls	r1, r5, #2
        x = o - e;  e = o;  //6dB/oct pre-emphasis
 802088c:	ee70 8ae6 	vsub.f32	s17, s1, s13
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 8020890:	eb05 0266 	add.w	r2, r5, r6, asr #1
        v->K = 0;
 8020894:	6427      	str	r7, [r4, #64]	; 0x40
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
 8020896:	3501      	adds	r5, #1
 8020898:	eeb0 9a60 	vmov.f32	s18, s1
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 802089c:	fb92 f6f3 	sdiv	r6, r2, r3
 80208a0:	fb03 2616 	mls	r6, r3, r6, r2
        v->car0[p0] = v->car1[p1] = x; //carrier input
 80208a4:	ea4f 0886 	mov.w	r8, r6, lsl #2
 80208a8:	4440      	add	r0, r8
 80208aa:	edc0 7a00 	vstr	s15, [r0]
 80208ae:	69a3      	ldr	r3, [r4, #24]
 80208b0:	440b      	add	r3, r1
 80208b2:	edc3 7a00 	vstr	s15, [r3]
        w = v->window[p0]; fx = v->buf0[p0] * w;  v->buf0[p0] = x * w;  //50% overlapping hanning windows
 80208b6:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
 80208ba:	440a      	add	r2, r1
 80208bc:	440b      	add	r3, r1
 80208be:	edd2 9a00 	vldr	s19, [r2]
 80208c2:	ed93 8a00 	vldr	s16, [r3]
 80208c6:	ee68 7aa9 	vmul.f32	s15, s17, s19
 80208ca:	ee29 8a88 	vmul.f32	s16, s19, s16
 80208ce:	edc3 7a00 	vstr	s15, [r3]
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
 80208d2:	f8d4 c044 	ldr.w	ip, [r4, #68]	; 0x44
 80208d6:	45ac      	cmp	ip, r5
 80208d8:	dd55      	ble.n	8020986 <tTalkboxFloat_tick+0x166>
        w = 1.0f - w;  fx += v->buf1[p1] * w;  v->buf1[p1] = x * w;
 80208da:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80208de:	6aa3      	ldr	r3, [r4, #40]	; 0x28
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
 80208e0:	3601      	adds	r6, #1
        w = 1.0f - w;  fx += v->buf1[p1] * w;  v->buf1[p1] = x * w;
 80208e2:	4498      	add	r8, r3
 80208e4:	ee77 7ae9 	vsub.f32	s15, s15, s19
 80208e8:	ed98 7a00 	vldr	s14, [r8]
 80208ec:	ee68 6aa7 	vmul.f32	s13, s17, s15
 80208f0:	eea7 8a27 	vfma.f32	s16, s14, s15
 80208f4:	edc8 6a00 	vstr	s13, [r8]
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
 80208f8:	6c67      	ldr	r7, [r4, #68]	; 0x44
 80208fa:	42b7      	cmp	r7, r6
 80208fc:	dd2e      	ble.n	802095c <tTalkboxFloat_tick+0x13c>
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 80208fe:	edd4 7a20 	vldr	s15, [r4, #128]	; 0x80
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
 8020902:	eef0 5a48 	vmov.f32	s11, s16
 8020906:	ed9f 6a2d 	vldr	s12, [pc, #180]	; 80209bc <tTalkboxFloat_tick+0x19c>
 802090a:	ed94 0a1c 	vldr	s0, [r4, #112]	; 0x70
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 802090e:	eddf 6a2a 	vldr	s13, [pc, #168]	; 80209b8 <tTalkboxFloat_tick+0x198>
 8020912:	ed94 7a1e 	vldr	s14, [r4, #120]	; 0x78
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
 8020916:	eea8 0a06 	vfma.f32	s0, s16, s12
 802091a:	6f62      	ldr	r2, [r4, #116]	; 0x74
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 802091c:	eea7 7aa6 	vfma.f32	s14, s15, s13
 8020920:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    v->emphasis = e;
 8020922:	ed84 9a0f 	vstr	s18, [r4, #60]	; 0x3c
    v->pos = p0;
 8020926:	64e5      	str	r5, [r4, #76]	; 0x4c
    v->FX = fx;
 8020928:	ed84 8a16 	vstr	s16, [r4, #88]	; 0x58
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
 802092c:	eee0 5a46 	vfms.f32	s11, s0, s12
 8020930:	6722      	str	r2, [r4, #112]	; 0x70
    v->u4 = fx;
 8020932:	ed84 8a20 	vstr	s16, [r4, #128]	; 0x80
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 8020936:	eee7 7a66 	vfms.f32	s15, s14, s13
 802093a:	67a3      	str	r3, [r4, #120]	; 0x78
}
 802093c:	ee30 0a07 	vadd.f32	s0, s0, s14
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
 8020940:	edc4 5a1d 	vstr	s11, [r4, #116]	; 0x74
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 8020944:	edc4 7a1f 	vstr	s15, [r4, #124]	; 0x7c
}
 8020948:	b006      	add	sp, #24
 802094a:	ecbd 8b04 	vpop	{d8-d9}
 802094e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(v->K++)
 8020952:	2301      	movs	r3, #1
    float e=v->emphasis, w, o, x, fx=v->FX;
 8020954:	eeb0 9a66 	vmov.f32	s18, s13
    if(v->K++)
 8020958:	6423      	str	r3, [r4, #64]	; 0x40
 802095a:	e7d0      	b.n	80208fe <tTalkboxFloat_tick+0xde>
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
 802095c:	f104 0684 	add.w	r6, r4, #132	; 0x84
 8020960:	ed94 0a0c 	vldr	s0, [r4, #48]	; 0x30
 8020964:	69e1      	ldr	r1, [r4, #28]
 8020966:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8020968:	e9d4 2322 	ldrd	r2, r3, [r4, #136]	; 0x88
 802096c:	9605      	str	r6, [sp, #20]
 802096e:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8020970:	9604      	str	r6, [sp, #16]
 8020972:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8020974:	9603      	str	r6, [sp, #12]
 8020976:	6b66      	ldr	r6, [r4, #52]	; 0x34
 8020978:	9602      	str	r6, [sp, #8]
 802097a:	6ca6      	ldr	r6, [r4, #72]	; 0x48
 802097c:	e9cd 7600 	strd	r7, r6, [sp]
 8020980:	f7ff fe78 	bl	8020674 <tTalkboxFloat_lpc>
 8020984:	e7bb      	b.n	80208fe <tTalkboxFloat_tick+0xde>
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
 8020986:	f104 0e84 	add.w	lr, r4, #132	; 0x84
 802098a:	ed94 0a0c 	vldr	s0, [r4, #48]	; 0x30
 802098e:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8020992:	463d      	mov	r5, r7
 8020994:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
 8020998:	69a1      	ldr	r1, [r4, #24]
 802099a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802099c:	f8cd e014 	str.w	lr, [sp, #20]
 80209a0:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 80209a2:	9704      	str	r7, [sp, #16]
 80209a4:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 80209a6:	9703      	str	r7, [sp, #12]
 80209a8:	6b67      	ldr	r7, [r4, #52]	; 0x34
 80209aa:	9702      	str	r7, [sp, #8]
 80209ac:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 80209ae:	e9cd c700 	strd	ip, r7, [sp]
 80209b2:	f7ff fe5f 	bl	8020674 <tTalkboxFloat_lpc>
 80209b6:	e790      	b.n	80208da <tTalkboxFloat_tick+0xba>
 80209b8:	3f451eb8 	.word	0x3f451eb8
 80209bc:	3e99999a 	.word	0x3e99999a

080209c0 <tTalkboxFloat_setQuality>:

void tTalkboxFloat_setQuality(tTalkboxFloat* const voc, float quality)
{
    _tTalkboxFloat* v = *voc;
    v->param[3] = quality;
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
 80209c0:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 80209f0 <tTalkboxFloat_setQuality+0x30>
 80209c4:	eddf 7a0b 	vldr	s15, [pc, #44]	; 80209f4 <tTalkboxFloat_setQuality+0x34>
 80209c8:	4b0b      	ldr	r3, [pc, #44]	; (80209f8 <tTalkboxFloat_setQuality+0x38>)
 80209ca:	eee0 7a07 	vfma.f32	s15, s0, s14
    _tTalkboxFloat* v = *voc;
 80209ce:	6802      	ldr	r2, [r0, #0]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
 80209d0:	ed93 7a00 	vldr	s14, [r3]
    v->param[3] = quality;
 80209d4:	ed82 0a04 	vstr	s0, [r2, #16]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
 80209d8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80209dc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80209e0:	ee17 3a90 	vmov	r3, s15
    if (v->O >= ORD_MAX)
 80209e4:	2b21      	cmp	r3, #33	; 0x21
    {
        v->O = ORD_MAX-1;
 80209e6:	bfc8      	it	gt
 80209e8:	2321      	movgt	r3, #33	; 0x21
 80209ea:	6493      	str	r3, [r2, #72]	; 0x48
    }
}
 80209ec:	4770      	bx	lr
 80209ee:	bf00      	nop
 80209f0:	39d1b717 	.word	0x39d1b717
 80209f4:	38d1b717 	.word	0x38d1b717
 80209f8:	200194e8 	.word	0x200194e8

080209fc <tTalkboxFloat_setWarpFactor>:

void tTalkboxFloat_setWarpFactor(tTalkboxFloat* const voc, float warpFactor)
{
    _tTalkboxFloat* v = *voc;
 80209fc:	6803      	ldr	r3, [r0, #0]

    v->warpFactor = warpFactor;
 80209fe:	ed83 0a0c 	vstr	s0, [r3, #48]	; 0x30
}
 8020a02:	4770      	bx	lr

08020a04 <tTalkboxFloat_setWarpOn>:

void tTalkboxFloat_setWarpOn(tTalkboxFloat* const voc, int warpOn)
{
    _tTalkboxFloat* v = *voc;
 8020a04:	6803      	ldr	r3, [r0, #0]

    v->warpOn = warpOn;
 8020a06:	6359      	str	r1, [r3, #52]	; 0x34
}
 8020a08:	4770      	bx	lr
 8020a0a:	bf00      	nop

08020a0c <tTalkboxFloat_setFreeze>:

void tTalkboxFloat_setFreeze(tTalkboxFloat* const voc, int freeze)
{
    _tTalkboxFloat* v = *voc;
 8020a0c:	6803      	ldr	r3, [r0, #0]

    v->freeze = freeze;
 8020a0e:	6399      	str	r1, [r3, #56]	; 0x38
}
 8020a10:	4770      	bx	lr
 8020a12:	bf00      	nop

08020a14 <tRosenbergGlottalPulse_init>:


/// Glottal Pulse (Rosenberg model)

void tRosenbergGlottalPulse_init (tRosenbergGlottalPulse* const gp)
{
 8020a14:	b538      	push	{r3, r4, r5, lr}
    tRosenbergGlottalPulse_initToPool(gp, &leaf.mempool);
}

void tRosenbergGlottalPulse_initToPool (tRosenbergGlottalPulse* const gp, tMempool* const mp)
{
     _tMempool* m = *mp;
 8020a16:	4b08      	ldr	r3, [pc, #32]	; (8020a38 <tRosenbergGlottalPulse_init+0x24>)
{
 8020a18:	4605      	mov	r5, r0
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
 8020a1a:	201c      	movs	r0, #28
     _tMempool* m = *mp;
 8020a1c:	699c      	ldr	r4, [r3, #24]
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
 8020a1e:	4621      	mov	r1, r4
 8020a20:	f003 fc4a 	bl	80242b8 <mpool_alloc>
    g->mempool = m;

    g->phase  = 0.0f;
 8020a24:	2300      	movs	r3, #0
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
 8020a26:	6028      	str	r0, [r5, #0]
    g->mempool = m;
 8020a28:	6004      	str	r4, [r0, #0]
    g->phase  = 0.0f;
 8020a2a:	6043      	str	r3, [r0, #4]
    g->openLength = 0.0f;
 8020a2c:	6083      	str	r3, [r0, #8]
    g->pulseLength = 0.0f;
 8020a2e:	60c3      	str	r3, [r0, #12]
    g->freq = 0.0f;
 8020a30:	6143      	str	r3, [r0, #20]
    g->inc = 0.0f;
 8020a32:	6183      	str	r3, [r0, #24]
}
 8020a34:	bd38      	pop	{r3, r4, r5, pc}
 8020a36:	bf00      	nop
 8020a38:	200194e8 	.word	0x200194e8

08020a3c <tRosenbergGlottalPulse_free>:


}
void tRosenbergGlottalPulse_free (tRosenbergGlottalPulse* const gp)
{
    _tRosenbergGlottalPulse* g = *gp;
 8020a3c:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)g, g->mempool);
 8020a3e:	6801      	ldr	r1, [r0, #0]
 8020a40:	f003 bcee 	b.w	8024420 <mpool_free>

08020a44 <tRosenbergGlottalPulse_tick>:
}

float   tRosenbergGlottalPulse_tick           (tRosenbergGlottalPulse* const gp)
{
 8020a44:	b508      	push	{r3, lr}
    _tRosenbergGlottalPulse* g = *gp;
 8020a46:	6803      	ldr	r3, [r0, #0]

    float output = 0.0f;

    // Phasor increment
    g->phase += g->inc;
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8020a48:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    g->phase += g->inc;
 8020a4c:	ed93 7a01 	vldr	s14, [r3, #4]
 8020a50:	edd3 7a06 	vldr	s15, [r3, #24]
 8020a54:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8020a58:	eeb4 7ae6 	vcmpe.f32	s14, s13
    g->phase += g->inc;
 8020a5c:	ed83 7a01 	vstr	s14, [r3, #4]
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8020a60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020a64:	db51      	blt.n	8020b0a <tRosenbergGlottalPulse_tick+0xc6>
 8020a66:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 8020a6a:	eeb4 7ac6 	vcmpe.f32	s14, s12
 8020a6e:	ee77 7a66 	vsub.f32	s15, s14, s13
 8020a72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020a76:	eeb0 7a67 	vmov.f32	s14, s15
 8020a7a:	daf6      	bge.n	8020a6a <tRosenbergGlottalPulse_tick+0x26>
 8020a7c:	edc3 7a01 	vstr	s15, [r3, #4]
    while (g->phase < 0.0f) g->phase += 1.0f;
 8020a80:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8020a84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020a88:	d53c      	bpl.n	8020b04 <tRosenbergGlottalPulse_tick+0xc0>
 8020a8a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8020a8e:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8020a92:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020a96:	ee37 0aa6 	vadd.f32	s0, s15, s13
 8020a9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020a9e:	eef0 7a40 	vmov.f32	s15, s0
 8020aa2:	d4f6      	bmi.n	8020a92 <tRosenbergGlottalPulse_tick+0x4e>
 8020aa4:	ed83 0a01 	vstr	s0, [r3, #4]

    if (g->phase < g->openLength)
 8020aa8:	edd3 7a02 	vldr	s15, [r3, #8]
 8020aac:	eef4 7ac0 	vcmpe.f32	s15, s0
 8020ab0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020ab4:	dc17      	bgt.n	8020ae6 <tRosenbergGlottalPulse_tick+0xa2>
    {
        output = 0.5f*(1.0f-fastercosf(PI * g->phase));
    }

    else if (g->phase < g->pulseLength)
 8020ab6:	ed93 7a03 	vldr	s14, [r3, #12]
 8020aba:	eeb4 7ac0 	vcmpe.f32	s14, s0
 8020abe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020ac2:	dc02      	bgt.n	8020aca <tRosenbergGlottalPulse_tick+0x86>
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
    }

    else
    {
        output = 0.0f;
 8020ac4:	ed9f 0a12 	vldr	s0, [pc, #72]	; 8020b10 <tRosenbergGlottalPulse_tick+0xcc>
    }
    return output;
}
 8020ac8:	bd08      	pop	{r3, pc}
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
 8020aca:	ed93 7a04 	vldr	s14, [r3, #16]
 8020ace:	ee30 0a67 	vsub.f32	s0, s0, s15
 8020ad2:	eddf 7a10 	vldr	s15, [pc, #64]	; 8020b14 <tRosenbergGlottalPulse_tick+0xd0>
 8020ad6:	ee67 7a27 	vmul.f32	s15, s14, s15
}
 8020ada:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
 8020ade:	ee27 0a80 	vmul.f32	s0, s15, s0
 8020ae2:	f003 b8fb 	b.w	8023cdc <fastercosf>
        output = 0.5f*(1.0f-fastercosf(PI * g->phase));
 8020ae6:	eddf 7a0c 	vldr	s15, [pc, #48]	; 8020b18 <tRosenbergGlottalPulse_tick+0xd4>
 8020aea:	ee20 0a27 	vmul.f32	s0, s0, s15
 8020aee:	f003 f8f5 	bl	8023cdc <fastercosf>
 8020af2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8020af6:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8020afa:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8020afe:	ee20 0a07 	vmul.f32	s0, s0, s14
}
 8020b02:	bd08      	pop	{r3, pc}
    while (g->phase < 0.0f) g->phase += 1.0f;
 8020b04:	eeb0 0a67 	vmov.f32	s0, s15
 8020b08:	e7ce      	b.n	8020aa8 <tRosenbergGlottalPulse_tick+0x64>
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8020b0a:	eef0 7a47 	vmov.f32	s15, s14
 8020b0e:	e7b7      	b.n	8020a80 <tRosenbergGlottalPulse_tick+0x3c>
 8020b10:	00000000 	.word	0x00000000
 8020b14:	3fc90fdb 	.word	0x3fc90fdb
 8020b18:	40490fdb 	.word	0x40490fdb

08020b1c <tRosenbergGlottalPulse_tickHQ>:


float   tRosenbergGlottalPulse_tickHQ           (tRosenbergGlottalPulse* const gp)
{
 8020b1c:	b508      	push	{r3, lr}
    _tRosenbergGlottalPulse* g = *gp;
 8020b1e:	6803      	ldr	r3, [r0, #0]

    float output = 0.0f;

    // Phasor increment
    g->phase += g->inc;
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8020b20:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    g->phase += g->inc;
 8020b24:	ed93 7a01 	vldr	s14, [r3, #4]
 8020b28:	edd3 7a06 	vldr	s15, [r3, #24]
 8020b2c:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8020b30:	eeb4 7ae6 	vcmpe.f32	s14, s13
    g->phase += g->inc;
 8020b34:	ed83 7a01 	vstr	s14, [r3, #4]
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8020b38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b3c:	db4e      	blt.n	8020bdc <tRosenbergGlottalPulse_tickHQ+0xc0>
 8020b3e:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 8020b42:	eeb4 7ac6 	vcmpe.f32	s14, s12
 8020b46:	ee77 7a66 	vsub.f32	s15, s14, s13
 8020b4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b4e:	eeb0 7a67 	vmov.f32	s14, s15
 8020b52:	daf6      	bge.n	8020b42 <tRosenbergGlottalPulse_tickHQ+0x26>
    while (g->phase < 0.0f) g->phase += 1.0f;
 8020b54:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8020b58:	edc3 7a01 	vstr	s15, [r3, #4]
 8020b5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b60:	d543      	bpl.n	8020bea <tRosenbergGlottalPulse_tickHQ+0xce>
 8020b62:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8020b66:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8020b6a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020b6e:	ee37 0aa6 	vadd.f32	s0, s15, s13
 8020b72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b76:	eef0 7a40 	vmov.f32	s15, s0
 8020b7a:	d4f6      	bmi.n	8020b6a <tRosenbergGlottalPulse_tickHQ+0x4e>
 8020b7c:	ed83 0a01 	vstr	s0, [r3, #4]

    if (g->phase < g->openLength)
 8020b80:	edd3 7a02 	vldr	s15, [r3, #8]
 8020b84:	eef4 7ac0 	vcmpe.f32	s15, s0
 8020b88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b8c:	dc17      	bgt.n	8020bbe <tRosenbergGlottalPulse_tickHQ+0xa2>
    {
        output = 0.5f*(1.0f-cosf(PI * g->phase));
    }

    else if (g->phase < g->pulseLength)
 8020b8e:	ed93 7a03 	vldr	s14, [r3, #12]
 8020b92:	eeb4 7ac0 	vcmpe.f32	s14, s0
 8020b96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b9a:	dd0d      	ble.n	8020bb8 <tRosenbergGlottalPulse_tickHQ+0x9c>
    {
        output = cosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
 8020b9c:	ed93 7a04 	vldr	s14, [r3, #16]
 8020ba0:	ee30 0a67 	vsub.f32	s0, s0, s15
 8020ba4:	eddf 7a12 	vldr	s15, [pc, #72]	; 8020bf0 <tRosenbergGlottalPulse_tickHQ+0xd4>
 8020ba8:	ee67 7a27 	vmul.f32	s15, s14, s15
    else
    {
        output = 0.0f;
    }
    return output;
}
 8020bac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        output = cosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
 8020bb0:	ee27 0a80 	vmul.f32	s0, s15, s0
 8020bb4:	f006 bb34 	b.w	8027220 <cosf>
        output = 0.0f;
 8020bb8:	ed9f 0a0e 	vldr	s0, [pc, #56]	; 8020bf4 <tRosenbergGlottalPulse_tickHQ+0xd8>
}
 8020bbc:	bd08      	pop	{r3, pc}
        output = 0.5f*(1.0f-cosf(PI * g->phase));
 8020bbe:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8020bf8 <tRosenbergGlottalPulse_tickHQ+0xdc>
 8020bc2:	ee20 0a27 	vmul.f32	s0, s0, s15
 8020bc6:	f006 fb2b 	bl	8027220 <cosf>
 8020bca:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8020bce:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8020bd2:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8020bd6:	ee20 0a07 	vmul.f32	s0, s0, s14
}
 8020bda:	bd08      	pop	{r3, pc}
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8020bdc:	eef0 7a47 	vmov.f32	s15, s14
    while (g->phase < 0.0f) g->phase += 1.0f;
 8020be0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8020be4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020be8:	d4bb      	bmi.n	8020b62 <tRosenbergGlottalPulse_tickHQ+0x46>
 8020bea:	eeb0 0a67 	vmov.f32	s0, s15
 8020bee:	e7c7      	b.n	8020b80 <tRosenbergGlottalPulse_tickHQ+0x64>
 8020bf0:	3fc90fdb 	.word	0x3fc90fdb
 8020bf4:	00000000 	.word	0x00000000
 8020bf8:	40490fdb 	.word	0x40490fdb

08020bfc <tRosenbergGlottalPulse_setFreq>:

void   tRosenbergGlottalPulse_setFreq           (tRosenbergGlottalPulse* const gp, float freq)
{
    _tRosenbergGlottalPulse* g = *gp;
    g->freq = freq;
    g->inc = freq * leaf.invSampleRate;
 8020bfc:	4a05      	ldr	r2, [pc, #20]	; (8020c14 <tRosenbergGlottalPulse_setFreq+0x18>)
    _tRosenbergGlottalPulse* g = *gp;
 8020bfe:	6803      	ldr	r3, [r0, #0]
    g->inc = freq * leaf.invSampleRate;
 8020c00:	edd2 7a01 	vldr	s15, [r2, #4]
    g->freq = freq;
 8020c04:	ed83 0a05 	vstr	s0, [r3, #20]
    g->inc = freq * leaf.invSampleRate;
 8020c08:	ee27 0a80 	vmul.f32	s0, s15, s0
 8020c0c:	ed83 0a06 	vstr	s0, [r3, #24]
}
 8020c10:	4770      	bx	lr
 8020c12:	bf00      	nop
 8020c14:	200194e8 	.word	0x200194e8

08020c18 <tRosenbergGlottalPulse_setOpenLength>:

void   tRosenbergGlottalPulse_setOpenLength           (tRosenbergGlottalPulse* const gp, float openLength)
{
    _tRosenbergGlottalPulse* g = *gp;
 8020c18:	6803      	ldr	r3, [r0, #0]
    g->openLength = openLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8020c1a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8020c1e:	edd3 7a03 	vldr	s15, [r3, #12]
    g->openLength = openLength;
 8020c22:	ed83 0a02 	vstr	s0, [r3, #8]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8020c26:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8020c2a:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8020c2e:	edc3 7a04 	vstr	s15, [r3, #16]
}
 8020c32:	4770      	bx	lr

08020c34 <tRosenbergGlottalPulse_setPulseLength>:

void   tRosenbergGlottalPulse_setPulseLength           (tRosenbergGlottalPulse* const gp, float pulseLength)
{
    _tRosenbergGlottalPulse* g = *gp;
 8020c34:	6803      	ldr	r3, [r0, #0]
    g->pulseLength = pulseLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8020c36:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8020c3a:	edd3 7a02 	vldr	s15, [r3, #8]
    g->pulseLength = pulseLength;
 8020c3e:	ed83 0a03 	vstr	s0, [r3, #12]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8020c42:	ee30 0a67 	vsub.f32	s0, s0, s15
 8020c46:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8020c4a:	edc3 7a04 	vstr	s15, [r3, #16]
}
 8020c4e:	4770      	bx	lr

08020c50 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>:
void   tRosenbergGlottalPulse_setOpenLengthAndPulseLength           (tRosenbergGlottalPulse* const gp, float openLength, float pulseLength)
{
    _tRosenbergGlottalPulse* g = *gp;
    g->openLength = openLength;
    g->pulseLength = pulseLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8020c50:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    _tRosenbergGlottalPulse* g = *gp;
 8020c54:	6803      	ldr	r3, [r0, #0]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8020c56:	ee30 7ac0 	vsub.f32	s14, s1, s0
    g->openLength = openLength;
 8020c5a:	ed83 0a02 	vstr	s0, [r3, #8]
    g->pulseLength = pulseLength;
 8020c5e:	edc3 0a03 	vstr	s1, [r3, #12]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8020c62:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8020c66:	edc3 7a04 	vstr	s15, [r3, #16]
}
 8020c6a:	4770      	bx	lr

08020c6c <tSOLAD_ioSamples>:
    mpool_free((char*)w, w->mempool);
}

// send one block of input samples, receive one block of output samples
void tSOLAD_ioSamples(tSOLAD* const wp, float* in, float* out, int blocksize)
{
 8020c6c:	b4f0      	push	{r4, r5, r6, r7}
 8020c6e:	ed2d 8b02 	vpush	{d8}
    _tSOLAD* w = *wp;
 8020c72:	6800      	ldr	r0, [r0, #0]
 8020c74:	b29f      	uxth	r7, r3
    
    int i = w->timeindex;
 8020c76:	8884      	ldrh	r4, [r0, #4]
    int n = w->blocksize = blocksize;
 8020c78:	80c3      	strh	r3, [r0, #6]
    
    if(!i) w->delaybuf[LOOPSIZE] = in[0];   // copy one sample for interpolation
 8020c7a:	b924      	cbnz	r4, 8020c86 <tSOLAD_ioSamples+0x1a>
 8020c7c:	6a05      	ldr	r5, [r0, #32]
 8020c7e:	680e      	ldr	r6, [r1, #0]
 8020c80:	f505 4580 	add.w	r5, r5, #16384	; 0x4000
 8020c84:	602e      	str	r6, [r5, #0]
    while(n--) w->delaybuf[i++] = *in++;    // copy one input block to delay buffer
 8020c86:	b167      	cbz	r7, 8020ca2 <tSOLAD_ioSamples+0x36>
 8020c88:	eb01 0787 	add.w	r7, r1, r7, lsl #2
 8020c8c:	ebc1 0c84 	rsb	ip, r1, r4, lsl #2
 8020c90:	eb0c 0601 	add.w	r6, ip, r1
 8020c94:	6a04      	ldr	r4, [r0, #32]
 8020c96:	f851 5b04 	ldr.w	r5, [r1], #4
 8020c9a:	4434      	add	r4, r6
 8020c9c:	428f      	cmp	r7, r1
 8020c9e:	6025      	str	r5, [r4, #0]
 8020ca0:	d1f6      	bne.n	8020c90 <tSOLAD_ioSamples+0x24>
    
    if(w->pitchfactor > 1) pitchup(w, out);
 8020ca2:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
 8020ca6:	edd0 6a02 	vldr	s13, [r0, #8]
 8020caa:	8881      	ldrh	r1, [r0, #4]
 8020cac:	edd0 3a04 	vldr	s7, [r0, #16]
 8020cb0:	eef4 6ac2 	vcmpe.f32	s13, s4
 8020cb4:	f501 5480 	add.w	r4, r1, #4096	; 0x1000
 8020cb8:	edd0 7a03 	vldr	s15, [r0, #12]
 8020cbc:	ee06 4a10 	vmov	s12, r4
 8020cc0:	edd0 5a05 	vldr	s11, [r0, #20]
 8020cc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020cc8:	88c4      	ldrh	r4, [r0, #6]
 8020cca:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 8020cce:	ed90 7a07 	vldr	s14, [r0, #28]
 8020cd2:	ed90 3a06 	vldr	s6, [r0, #24]
 8020cd6:	f340 80b8 	ble.w	8020e4a <tSOLAD_ioSamples+0x1de>
    float xfadelength = w->xfadelength;
    
    float readlagstep = pitchfactor - 1;
    float xfadespeed = pitchfactor * pitchfactor;
    float xfadestep = xfadespeed / xfadelength;
    float limitfactor = (pitchfactor - (float)0.99) / xfadespeed;
 8020cda:	ed9f 5aa1 	vldr	s10, [pc, #644]	; 8020f60 <tSOLAD_ioSamples+0x2f4>
    float xfadespeed = pitchfactor * pitchfactor;
 8020cde:	ee66 1aa6 	vmul.f32	s3, s13, s13
    float readlagstep = pitchfactor - 1;
 8020ce2:	ee36 2ac2 	vsub.f32	s4, s13, s4
    float limitfactor = (pitchfactor - (float)0.99) / xfadespeed;
 8020ce6:	ee76 6ac5 	vsub.f32	s13, s13, s10
 8020cea:	ee86 5aa1 	vdiv.f32	s10, s13, s3
    float limit = period * limitfactor;
 8020cee:	ee25 1a23 	vmul.f32	s2, s10, s7
    float readindex, outputsample;
    
    if((readlag > (period + 2 * limit)) & (xfadevalue < 0))
 8020cf2:	ee71 6a01 	vadd.f32	s13, s2, s2
 8020cf6:	ee76 4aa3 	vadd.f32	s9, s13, s7
 8020cfa:	eef4 4a67 	vcmp.f32	s9, s15
 8020cfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020d02:	f140 808a 	bpl.w	8020e1a <tSOLAD_ioSamples+0x1ae>
 8020d06:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8020d0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020d0e:	f140 8084 	bpl.w	8020e1a <tSOLAD_ioSamples+0x1ae>
 8020d12:	ee77 6ae6 	vsub.f32	s13, s15, s13
    {
        jump = period;                                        // jump forward
 8020d16:	eef0 5a63 	vmov.f32	s11, s7
 8020d1a:	e001      	b.n	8020d20 <tSOLAD_ioSamples+0xb4>
        while((jump * 2) < (readlag - 2 * limit)) jump *= 2;  // use available space
 8020d1c:	eef0 5a47 	vmov.f32	s11, s14
 8020d20:	ee35 7aa5 	vadd.f32	s14, s11, s11
 8020d24:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8020d28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020d2c:	d4f6      	bmi.n	8020d1c <tSOLAD_ioSamples+0xb0>
        readlag -= jump;                                      // reduce read pointer lag
        xfadevalue = 1;                                       // start crossfade
        xfadelength = period - 1;
 8020d2e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        readlag -= jump;                                      // reduce read pointer lag
 8020d32:	ee77 7ae5 	vsub.f32	s15, s15, s11
        xfadelength = period - 1;
 8020d36:	ee33 3ac7 	vsub.f32	s6, s7, s14
        xfadestep = xfadespeed / xfadelength;
 8020d3a:	eec1 0a83 	vdiv.f32	s1, s3, s6
    }
    
    while(n--)
 8020d3e:	1e65      	subs	r5, r4, #1
 8020d40:	2c00      	cmp	r4, #0
 8020d42:	d05a      	beq.n	8020dfa <tSOLAD_ioSamples+0x18e>
 8020d44:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
            {
                xfadelength = readlag / limitfactor;
                if(xfadelength < 1) xfadelength = 1;
                xfadestep = xfadespeed / xfadelength;
                
                jump = -period;         // jump backward
 8020d48:	eeb1 8a63 	vneg.f32	s16, s7
 8020d4c:	ee82 0a85 	vdiv.f32	s0, s5, s10
        if(readlag < limit)  // check if read pointer should jump backward...
 8020d50:	eeb4 1ae7 	vcmpe.f32	s2, s15
 8020d54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020d58:	dd0b      	ble.n	8020d72 <tSOLAD_ioSamples+0x106>
            if((xfadevalue < 0) | (readlag < 0)) // ...but try not to interrupt crossfade
 8020d5a:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
                xfadelength = readlag / limitfactor;
 8020d5e:	ee60 6a27 	vmul.f32	s13, s0, s15
            if((xfadevalue < 0) | (readlag < 0)) // ...but try not to interrupt crossfade
 8020d62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020d66:	d465      	bmi.n	8020e34 <tSOLAD_ioSamples+0x1c8>
 8020d68:	eef5 7a40 	vcmp.f32	s15, #0.0
 8020d6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020d70:	d460      	bmi.n	8020e34 <tSOLAD_ioSamples+0x1c8>
                readlag += period;      // increase read pointer lag
                xfadevalue = 1;         // start crossfade
            }
        }
        
        readindex = refindex - readlag;
 8020d72:	ee76 6a67 	vsub.f32	s13, s12, s15
        outputsample = read_sample(w, readindex);
 8020d76:	6a01      	ldr	r1, [r0, #32]
        
        if(xfadevalue > 0)
 8020d78:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
        {
            outputsample *= (1 - xfadevalue);
 8020d7c:	ee72 8ac7 	vsub.f32	s17, s5, s14
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
 8020d80:	ee36 4ae5 	vsub.f32	s8, s13, s11
}

// read one sample from delay buffer, with linear interpolation
static inline float read_sample(_tSOLAD* const w, float floatindex)
{
    int index = (int)floatindex;
 8020d84:	eefd 4ae6 	vcvt.s32.f32	s9, s13
        if(xfadevalue > 0)
 8020d88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    int index = (int)floatindex;
 8020d8c:	eebd 5ac4 	vcvt.s32.f32	s10, s8
    float fraction = floatindex - (float)index;
    float *buf = w->delaybuf;
    index &= LOOPMASK;
 8020d90:	ee14 4a90 	vmov	r4, s9
    float fraction = floatindex - (float)index;
 8020d94:	eef8 4ae4 	vcvt.f32.s32	s9, s9
    index &= LOOPMASK;
 8020d98:	f3c4 040b 	ubfx	r4, r4, #0, #12
 8020d9c:	ee15 6a10 	vmov	r6, s10
    float fraction = floatindex - (float)index;
 8020da0:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
    
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8020da4:	eb01 0484 	add.w	r4, r1, r4, lsl #2
    float fraction = floatindex - (float)index;
 8020da8:	ee76 6ae4 	vsub.f32	s13, s13, s9
    index &= LOOPMASK;
 8020dac:	f3c6 060b 	ubfx	r6, r6, #0, #12
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8020db0:	edd4 4a00 	vldr	s9, [r4]
    float fraction = floatindex - (float)index;
 8020db4:	ee34 5a45 	vsub.f32	s10, s8, s10
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8020db8:	ed94 4a01 	vldr	s8, [r4, #4]
 8020dbc:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 8020dc0:	ee34 4a64 	vsub.f32	s8, s8, s9
 8020dc4:	eee6 4a84 	vfma.f32	s9, s13, s8
        if(xfadevalue > 0)
 8020dc8:	dd2a      	ble.n	8020e20 <tSOLAD_ioSamples+0x1b4>
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8020dca:	edd1 6a00 	vldr	s13, [r1]
    while(n--)
 8020dce:	3d01      	subs	r5, #1
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8020dd0:	ed91 4a01 	vldr	s8, [r1, #4]
        refindex += 1;
 8020dd4:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
 8020dd8:	1c6f      	adds	r7, r5, #1
        readlag -= readlagstep;
 8020dda:	ee77 7ac2 	vsub.f32	s15, s15, s4
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8020dde:	ee34 4a66 	vsub.f32	s8, s8, s13
 8020de2:	eee5 6a04 	vfma.f32	s13, s10, s8
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
 8020de6:	ee66 6a87 	vmul.f32	s13, s13, s14
            xfadevalue -= xfadestep;
 8020dea:	ee37 7a60 	vsub.f32	s14, s14, s1
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
 8020dee:	eee4 6aa8 	vfma.f32	s13, s9, s17
        *out++ = outputsample;
 8020df2:	ece2 6a01 	vstmia	r2!, {s13}
    while(n--)
 8020df6:	d1ab      	bne.n	8020d50 <tSOLAD_ioSamples+0xe4>
 8020df8:	8881      	ldrh	r1, [r0, #4]
    w->readlag = readlag;               // state variables
 8020dfa:	edc0 7a03 	vstr	s15, [r0, #12]
    w->jump = jump;
 8020dfe:	edc0 5a05 	vstr	s11, [r0, #20]
    w->xfadelength = xfadelength;
 8020e02:	ed80 3a06 	vstr	s6, [r0, #24]
    w->xfadevalue = xfadevalue;
 8020e06:	ed80 7a07 	vstr	s14, [r0, #28]
    w->timeindex += blocksize;
 8020e0a:	440b      	add	r3, r1
    w->timeindex &= LOOPMASK;
 8020e0c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8020e10:	8083      	strh	r3, [r0, #4]
}
 8020e12:	ecbd 8b02 	vpop	{d8}
 8020e16:	bcf0      	pop	{r4, r5, r6, r7}
 8020e18:	4770      	bx	lr
    float xfadestep = xfadespeed / xfadelength;
 8020e1a:	eec1 0a83 	vdiv.f32	s1, s3, s6
 8020e1e:	e78e      	b.n	8020d3e <tSOLAD_ioSamples+0xd2>
    while(n--)
 8020e20:	3d01      	subs	r5, #1
        *out++ = outputsample;
 8020e22:	ece2 4a01 	vstmia	r2!, {s9}
        refindex += 1;
 8020e26:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
 8020e2a:	1c6e      	adds	r6, r5, #1
        readlag -= readlagstep;
 8020e2c:	ee77 7ac2 	vsub.f32	s15, s15, s4
    while(n--)
 8020e30:	d18e      	bne.n	8020d50 <tSOLAD_ioSamples+0xe4>
 8020e32:	e7e1      	b.n	8020df8 <tSOLAD_ioSamples+0x18c>
 8020e34:	fe86 3aa2 	vmaxnm.f32	s6, s13, s5
                jump = -period;         // jump backward
 8020e38:	eef0 5a48 	vmov.f32	s11, s16
                xfadestep = xfadespeed / xfadelength;
 8020e3c:	eec1 0a83 	vdiv.f32	s1, s3, s6
                readlag += period;      // increase read pointer lag
 8020e40:	ee77 7aa3 	vadd.f32	s15, s15, s7
                xfadevalue = 1;         // start crossfade
 8020e44:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8020e48:	e793      	b.n	8020d72 <tSOLAD_ioSamples+0x106>
    if(pitchfactor > 0.5) xfadespeed = pitchfactor;
 8020e4a:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
    while(n--)
 8020e4e:	1e65      	subs	r5, r4, #1
    float readlagstep = 1 - pitchfactor;
 8020e50:	ee72 1a66 	vsub.f32	s3, s4, s13
    else xfadespeed = 1 - pitchfactor;
 8020e54:	eef4 6ac5 	vcmpe.f32	s13, s10
 8020e58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020e5c:	fe76 6aa1 	vselgt.f32	s13, s13, s3
    xfadestep = xfadespeed / xfadelength;
 8020e60:	eec6 0a83 	vdiv.f32	s1, s13, s6
    while(n--)
 8020e64:	2c00      	cmp	r4, #0
 8020e66:	d053      	beq.n	8020f10 <tSOLAD_ioSamples+0x2a4>
        refindex += 1;
 8020e68:	eef0 2a42 	vmov.f32	s5, s4
                xfadelength = period - 1;
 8020e6c:	ee33 2ac2 	vsub.f32	s4, s7, s4
                xfadestep = xfadespeed / xfadelength;
 8020e70:	ee86 0a82 	vdiv.f32	s0, s13, s4
            if(xfadevalue <= 0)      // ...but do not interrupt crossfade
 8020e74:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8020e78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020e7c:	d804      	bhi.n	8020e88 <tSOLAD_ioSamples+0x21c>
 8020e7e:	eef4 7a63 	vcmp.f32	s15, s7
 8020e82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020e86:	dc56      	bgt.n	8020f36 <tSOLAD_ioSamples+0x2ca>
        readindex = refindex - readlag;
 8020e88:	ee36 5a67 	vsub.f32	s10, s12, s15
        outputsample = read_sample(w, readindex);
 8020e8c:	6a04      	ldr	r4, [r0, #32]
        if(xfadevalue > 0)
 8020e8e:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
    int index = (int)floatindex;
 8020e92:	eefd 6ac5 	vcvt.s32.f32	s13, s10
        if(xfadevalue > 0)
 8020e96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    index &= LOOPMASK;
 8020e9a:	ee16 1a90 	vmov	r1, s13
    float fraction = floatindex - (float)index;
 8020e9e:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    index &= LOOPMASK;
 8020ea2:	f3c1 010b 	ubfx	r1, r1, #0, #12
    float fraction = floatindex - (float)index;
 8020ea6:	ee75 6a66 	vsub.f32	s13, s10, s13
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8020eaa:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8020eae:	edd1 4a00 	vldr	s9, [r1]
 8020eb2:	ed91 4a01 	vldr	s8, [r1, #4]
 8020eb6:	ee34 4a64 	vsub.f32	s8, s8, s9
 8020eba:	eee6 4a84 	vfma.f32	s9, s13, s8
        if(xfadevalue > 0)
 8020ebe:	dd30      	ble.n	8020f22 <tSOLAD_ioSamples+0x2b6>
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
 8020ec0:	ee35 5a65 	vsub.f32	s10, s10, s11
    while(n--)
 8020ec4:	3d01      	subs	r5, #1
            outputsample *= (1 - xfadevalue);                               // fadein
 8020ec6:	ee32 1ac7 	vsub.f32	s2, s5, s14
        refindex += 1;
 8020eca:	ee36 6a22 	vadd.f32	s12, s12, s5
    int index = (int)floatindex;
 8020ece:	eefd 6ac5 	vcvt.s32.f32	s13, s10
        readlag += readlagstep;
 8020ed2:	ee77 7aa1 	vadd.f32	s15, s15, s3
    index &= LOOPMASK;
 8020ed6:	ee16 1a90 	vmov	r1, s13
    float fraction = floatindex - (float)index;
 8020eda:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    index &= LOOPMASK;
 8020ede:	f3c1 010b 	ubfx	r1, r1, #0, #12
    float fraction = floatindex - (float)index;
 8020ee2:	ee35 5a66 	vsub.f32	s10, s10, s13
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8020ee6:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 8020eea:	edd4 6a00 	vldr	s13, [r4]
 8020eee:	ed94 4a01 	vldr	s8, [r4, #4]
    while(n--)
 8020ef2:	1c6c      	adds	r4, r5, #1
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8020ef4:	ee34 4a66 	vsub.f32	s8, s8, s13
 8020ef8:	eee5 6a04 	vfma.f32	s13, s10, s8
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
 8020efc:	ee66 6a87 	vmul.f32	s13, s13, s14
            xfadevalue -= xfadestep;
 8020f00:	ee37 7a60 	vsub.f32	s14, s14, s1
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
 8020f04:	eee4 6a81 	vfma.f32	s13, s9, s2
        *out++ = outputsample;
 8020f08:	ece2 6a01 	vstmia	r2!, {s13}
    while(n--)
 8020f0c:	d1b2      	bne.n	8020e74 <tSOLAD_ioSamples+0x208>
 8020f0e:	8881      	ldrh	r1, [r0, #4]
    w->jump = jump;                 // state variables
 8020f10:	edc0 5a05 	vstr	s11, [r0, #20]
    w->readlag = readlag;
 8020f14:	edc0 7a03 	vstr	s15, [r0, #12]
    w->xfadevalue = xfadevalue;
 8020f18:	ed80 7a07 	vstr	s14, [r0, #28]
    w->xfadelength = xfadelength;
 8020f1c:	ed80 3a06 	vstr	s6, [r0, #24]
 8020f20:	e773      	b.n	8020e0a <tSOLAD_ioSamples+0x19e>
    while(n--)
 8020f22:	3d01      	subs	r5, #1
        *out++ = outputsample;
 8020f24:	ece2 4a01 	vstmia	r2!, {s9}
        refindex += 1;
 8020f28:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
 8020f2c:	1c69      	adds	r1, r5, #1
        readlag += readlagstep;
 8020f2e:	ee77 7aa1 	vadd.f32	s15, s15, s3
    while(n--)
 8020f32:	d19f      	bne.n	8020e74 <tSOLAD_ioSamples+0x208>
 8020f34:	e7eb      	b.n	8020f0e <tSOLAD_ioSamples+0x2a2>
                jump = period;                           // jump forward
 8020f36:	eef0 5a63 	vmov.f32	s11, s7
 8020f3a:	e001      	b.n	8020f40 <tSOLAD_ioSamples+0x2d4>
                while((jump * 2) < readlag) jump *= 2;   // use available space
 8020f3c:	eef0 5a47 	vmov.f32	s11, s14
 8020f40:	ee35 7aa5 	vadd.f32	s14, s11, s11
 8020f44:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8020f48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020f4c:	d4f6      	bmi.n	8020f3c <tSOLAD_ioSamples+0x2d0>
                readlag -= jump;                         // reduce read pointer lag
 8020f4e:	ee77 7ae5 	vsub.f32	s15, s15, s11
                xfadestep = xfadespeed / xfadelength;
 8020f52:	eef0 0a40 	vmov.f32	s1, s0
                xfadevalue = 1;                          // start crossfade
 8020f56:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
                xfadelength = period - 1;
 8020f5a:	eeb0 3a42 	vmov.f32	s6, s4
 8020f5e:	e793      	b.n	8020e88 <tSOLAD_ioSamples+0x21c>
 8020f60:	3f7d70a4 	.word	0x3f7d70a4

08020f64 <tRetune_initToPool>:
{
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
}

void tRetune_initToPool (tRetune* const rt, int numVoices, int bufSize, int frameSize, tMempool* const mp)
{
 8020f64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020f68:	ed2d 8b02 	vpush	{d8}
 8020f6c:	b085      	sub	sp, #20
 8020f6e:	4604      	mov	r4, r0
 8020f70:	4689      	mov	r9, r1
    _tMempool* m = *mp;
    _tRetune* r = *rt = (_tRetune*) mpool_alloc(sizeof(_tRetune), m);
 8020f72:	203c      	movs	r0, #60	; 0x3c
{
 8020f74:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
 8020f78:	4617      	mov	r7, r2
 8020f7a:	469a      	mov	sl, r3
    _tMempool* m = *mp;
 8020f7c:	f8d8 6000 	ldr.w	r6, [r8]
    _tRetune* r = *rt = (_tRetune*) mpool_alloc(sizeof(_tRetune), m);
 8020f80:	4631      	mov	r1, r6
 8020f82:	f003 f999 	bl	80242b8 <mpool_alloc>
 8020f86:	4605      	mov	r5, r0
 8020f88:	6020      	str	r0, [r4, #0]
    
    r->bufSize = bufSize;
    r->frameSize = frameSize;
    r->numVoices = numVoices;
    
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
 8020f8a:	4631      	mov	r1, r6
    r->mempool = *mp;
 8020f8c:	f8d8 2000 	ldr.w	r2, [r8]
    r->frameSize = frameSize;
 8020f90:	f8c0 a018 	str.w	sl, [r0, #24]
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
 8020f94:	00b8      	lsls	r0, r7, #2
    r->mempool = *mp;
 8020f96:	602a      	str	r2, [r5, #0]
    r->bufSize = bufSize;
 8020f98:	61ef      	str	r7, [r5, #28]
    r->numVoices = numVoices;
 8020f9a:	f8c5 9038 	str.w	r9, [r5, #56]	; 0x38
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
 8020f9e:	f003 f9e7 	bl	8024370 <mpool_calloc>
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
 8020fa2:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8020fa4:	4631      	mov	r1, r6
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
 8020fa6:	60e8      	str	r0, [r5, #12]
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
 8020fa8:	0098      	lsls	r0, r3, #2
 8020faa:	f003 f9e1 	bl	8024370 <mpool_calloc>
    
    r->hopSize = DEFHOPSIZE;
 8020fae:	f04f 1240 	mov.w	r2, #4194368	; 0x400040
    r->windowSize = DEFWINDOWSIZE;
    r->fba = FBA;
 8020fb2:	2314      	movs	r3, #20
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
 8020fb4:	6128      	str	r0, [r5, #16]
    r->hopSize = DEFHOPSIZE;
 8020fb6:	622a      	str	r2, [r5, #32]
void tRetune_setTimeConstant(tRetune* const rt, float tc)
{
    _tRetune* r = *rt;
    
    r->timeConstant = tc;
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8020fb8:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
    r->fba = FBA;
 8020fbc:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8020fc0:	4b50      	ldr	r3, [pc, #320]	; (8021104 <tRetune_initToPool+0x1a0>)
    _tRetune* r = *rt;
 8020fc2:	6824      	ldr	r4, [r4, #0]
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8020fc4:	ed93 0a01 	vldr	s0, [r3, #4]
 8020fc8:	8c23      	ldrh	r3, [r4, #32]
 8020fca:	ee20 0a07 	vmul.f32	s0, s0, s14
 8020fce:	ee07 3a90 	vmov	s15, r3
    r->timeConstant = tc;
 8020fd2:	4b4d      	ldr	r3, [pc, #308]	; (8021108 <tRetune_initToPool+0x1a4>)
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8020fd4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    r->timeConstant = tc;
 8020fd8:	62e3      	str	r3, [r4, #44]	; 0x2c
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8020fda:	ee20 0a27 	vmul.f32	s0, s0, s15
 8020fde:	f006 f95f 	bl	80272a0 <expf>
    r->inputPeriod = 0.0f;
 8020fe2:	2300      	movs	r3, #0
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8020fe4:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
 8020fe8:	4631      	mov	r1, r6
 8020fea:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    r->inputPeriod = 0.0f;
 8020fec:	636b      	str	r3, [r5, #52]	; 0x34
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
 8020fee:	0080      	lsls	r0, r0, #2
 8020ff0:	f003 f9be 	bl	8024370 <mpool_calloc>
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 8020ff4:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
 8020ff6:	60a8      	str	r0, [r5, #8]
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 8020ff8:	4631      	mov	r1, r6
 8020ffa:	0098      	lsls	r0, r3, #2
 8020ffc:	f003 f9b8 	bl	8024370 <mpool_calloc>
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 8021000:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 8021002:	62a8      	str	r0, [r5, #40]	; 0x28
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 8021004:	4631      	mov	r1, r6
 8021006:	0098      	lsls	r0, r3, #2
 8021008:	f003 f9b2 	bl	8024370 <mpool_calloc>
    for (int i = 0; i < r->numVoices; ++i)
 802100c:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 802100e:	6168      	str	r0, [r5, #20]
    for (int i = 0; i < r->numVoices; ++i)
 8021010:	2b00      	cmp	r3, #0
 8021012:	dd0c      	ble.n	802102e <tRetune_initToPool+0xca>
 8021014:	2400      	movs	r4, #0
        r->outBuffers[i] = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
 8021016:	69e8      	ldr	r0, [r5, #28]
 8021018:	4631      	mov	r1, r6
 802101a:	692f      	ldr	r7, [r5, #16]
 802101c:	0080      	lsls	r0, r0, #2
 802101e:	f003 f9a7 	bl	8024370 <mpool_calloc>
 8021022:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
 8021026:	3401      	adds	r4, #1
 8021028:	6bab      	ldr	r3, [r5, #56]	; 0x38
 802102a:	42a3      	cmp	r3, r4
 802102c:	dcf3      	bgt.n	8021016 <tRetune_initToPool+0xb2>
    tPeriodDetection_initToPool(&r->pd, r->inBuffer, r->outBuffers[0], r->bufSize, r->frameSize, mp);
 802102e:	692a      	ldr	r2, [r5, #16]
 8021030:	1d28      	adds	r0, r5, #4
 8021032:	69eb      	ldr	r3, [r5, #28]
 8021034:	6812      	ldr	r2, [r2, #0]
 8021036:	68e9      	ldr	r1, [r5, #12]
 8021038:	f8cd 8004 	str.w	r8, [sp, #4]
 802103c:	69ac      	ldr	r4, [r5, #24]
 802103e:	9003      	str	r0, [sp, #12]
 8021040:	9400      	str	r4, [sp, #0]
 8021042:	f7fe f953 	bl	801f2ec <tPeriodDetection_initToPool>
    for (int i = 0; i < r->numVoices; ++i)
 8021046:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8021048:	2b00      	cmp	r3, #0
 802104a:	dd56      	ble.n	80210fa <tRetune_initToPool+0x196>
 802104c:	2700      	movs	r7, #0
    w->period = INITPERIOD;
 802104e:	ed9f 8a2f 	vldr	s16, [pc, #188]	; 802110c <tRetune_initToPool+0x1a8>
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8021052:	eddf 8a2f 	vldr	s17, [pc, #188]	; 8021110 <tRetune_initToPool+0x1ac>
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 8021056:	692b      	ldr	r3, [r5, #16]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8021058:	2038      	movs	r0, #56	; 0x38
    _tMempool* m = *mp;
 802105a:	f8d8 a000 	ldr.w	sl, [r8]
    ps->pitchFactor = 1.0f;
 802105e:	f04f 5b7e 	mov.w	fp, #1065353216	; 0x3f800000
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 8021062:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8021066:	4651      	mov	r1, sl
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 8021068:	69ee      	ldr	r6, [r5, #28]
 802106a:	f8d5 9008 	ldr.w	r9, [r5, #8]
 802106e:	9302      	str	r3, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8021070:	f003 f97e 	bl	8024370 <mpool_calloc>
    ps->outBuffer = out;
 8021074:	9902      	ldr	r1, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8021076:	4604      	mov	r4, r0
    ps->curBlock = 1;
 8021078:	f04f 0c01 	mov.w	ip, #1
    ps->lastBlock = 0;
 802107c:	2200      	movs	r2, #0
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 802107e:	f849 4027 	str.w	r4, [r9, r7, lsl #2]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 8021082:	2024      	movs	r0, #36	; 0x24
    ps->mempool = m;
 8021084:	f8c4 a000 	str.w	sl, [r4]
    for (int i = 0; i < r->numVoices; ++i)
 8021088:	4467      	add	r7, ip
    _tPeriodDetection* p = *pd;
 802108a:	686b      	ldr	r3, [r5, #4]
    ps->outBuffer = out;
 802108c:	6121      	str	r1, [r4, #16]
    ps->p = pd;
 802108e:	9903      	ldr	r1, [sp, #12]
    ps->bufSize = bufSize;
 8021090:	61a6      	str	r6, [r4, #24]
    ps->p = pd;
 8021092:	60e1      	str	r1, [r4, #12]
    ps->frameSize = p->frameSize;
 8021094:	695b      	ldr	r3, [r3, #20]
    ps->curBlock = 1;
 8021096:	f8c4 c020 	str.w	ip, [r4, #32]
    ps->frameSize = p->frameSize;
 802109a:	6163      	str	r3, [r4, #20]
    ps->pitchFactor = 1.0f;
 802109c:	f8c4 b02c 	str.w	fp, [r4, #44]	; 0x2c
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
 80210a0:	fb96 f6f3 	sdiv	r6, r6, r3
    ps->index = 0;
 80210a4:	e9c4 2209 	strd	r2, r2, [r4, #36]	; 0x24
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
 80210a8:	61e6      	str	r6, [r4, #28]
    _tMempool* m = *mp;
 80210aa:	f8d8 a000 	ldr.w	sl, [r8]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 80210ae:	4651      	mov	r1, sl
 80210b0:	f003 f95e 	bl	8024370 <mpool_calloc>
 80210b4:	4606      	mov	r6, r0
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 80210b6:	4651      	mov	r1, sl
 80210b8:	f244 0040 	movw	r0, #16448	; 0x4040
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 80210bc:	6066      	str	r6, [r4, #4]
    w->mempool = m;
 80210be:	f8c6 a000 	str.w	sl, [r6]
    w->pitchfactor = 1.;
 80210c2:	f8c6 b008 	str.w	fp, [r6, #8]
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 80210c6:	f003 f953 	bl	8024370 <mpool_calloc>
    w->xfadevalue = -1;
 80210ca:	4a12      	ldr	r2, [pc, #72]	; (8021114 <tRetune_initToPool+0x1b0>)
    w->timeindex = 0;
 80210cc:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 80210d0:	6230      	str	r0, [r6, #32]
    w->xfadevalue = -1;
 80210d2:	61f2      	str	r2, [r6, #28]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 80210d4:	f104 0008 	add.w	r0, r4, #8
    w->timeindex = 0;
 80210d8:	6073      	str	r3, [r6, #4]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 80210da:	4641      	mov	r1, r8
    w->period = INITPERIOD;
 80210dc:	ed86 8a04 	vstr	s16, [r6, #16]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 80210e0:	eeb0 0a68 	vmov.f32	s0, s17
    w->readlag = INITPERIOD;
 80210e4:	ed86 8a03 	vstr	s16, [r6, #12]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 80210e8:	f001 fd5c 	bl	8022ba4 <tHighpass_initToPool>
    _tSOLAD* w = *wp;
 80210ec:	6863      	ldr	r3, [r4, #4]
    w->pitchfactor = pitchfactor;
 80210ee:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80210f2:	609a      	str	r2, [r3, #8]
    for (int i = 0; i < r->numVoices; ++i)
 80210f4:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80210f6:	42bb      	cmp	r3, r7
 80210f8:	dcad      	bgt.n	8021056 <tRetune_initToPool+0xf2>
}
 80210fa:	b005      	add	sp, #20
 80210fc:	ecbd 8b02 	vpop	{d8}
 8021100:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021104:	200194e8 	.word	0x200194e8
 8021108:	42c80000 	.word	0x42c80000
 802110c:	42800000 	.word	0x42800000
 8021110:	42200000 	.word	0x42200000
 8021114:	bf800000 	.word	0xbf800000

08021118 <tRetune_init>:
{
 8021118:	b510      	push	{r4, lr}
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
 802111a:	4c03      	ldr	r4, [pc, #12]	; (8021128 <tRetune_init+0x10>)
{
 802111c:	b082      	sub	sp, #8
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
 802111e:	9400      	str	r4, [sp, #0]
 8021120:	f7ff ff20 	bl	8020f64 <tRetune_initToPool>
}
 8021124:	b002      	add	sp, #8
 8021126:	bd10      	pop	{r4, pc}
 8021128:	20019500 	.word	0x20019500

0802112c <tRetune_free>:
{
 802112c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tRetune* r = *rt;
 802112e:	6804      	ldr	r4, [r0, #0]
    tPeriodDetection_free(&r->pd);
 8021130:	1d20      	adds	r0, r4, #4
 8021132:	f7fe f939 	bl	801f3a8 <tPeriodDetection_free>
    for (int i = 0; i < r->numVoices; ++i)
 8021136:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8021138:	2b00      	cmp	r3, #0
 802113a:	dd1e      	ble.n	802117a <tRetune_free+0x4e>
 802113c:	2500      	movs	r5, #0
    _tPitchShift* ps = *psr;
 802113e:	68a3      	ldr	r3, [r4, #8]
 8021140:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    _tSOLAD* w = *wp;
 8021144:	6877      	ldr	r7, [r6, #4]
    mpool_free((char*)w->delaybuf, w->mempool);
 8021146:	6839      	ldr	r1, [r7, #0]
 8021148:	6a38      	ldr	r0, [r7, #32]
 802114a:	f003 f969 	bl	8024420 <mpool_free>
    mpool_free((char*)w, w->mempool);
 802114e:	6839      	ldr	r1, [r7, #0]
 8021150:	4638      	mov	r0, r7
 8021152:	f003 f965 	bl	8024420 <mpool_free>
    tHighpass_free(&ps->hp);
 8021156:	f106 0008 	add.w	r0, r6, #8
 802115a:	f001 fd43 	bl	8022be4 <tHighpass_free>
    mpool_free((char*)ps, ps->mempool);
 802115e:	6831      	ldr	r1, [r6, #0]
 8021160:	4630      	mov	r0, r6
 8021162:	f003 f95d 	bl	8024420 <mpool_free>
        mpool_free((char*)r->outBuffers[i], r->mempool);
 8021166:	6923      	ldr	r3, [r4, #16]
 8021168:	6821      	ldr	r1, [r4, #0]
 802116a:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
 802116e:	3501      	adds	r5, #1
        mpool_free((char*)r->outBuffers[i], r->mempool);
 8021170:	f003 f956 	bl	8024420 <mpool_free>
    for (int i = 0; i < r->numVoices; ++i)
 8021174:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8021176:	42ab      	cmp	r3, r5
 8021178:	dce1      	bgt.n	802113e <tRetune_free+0x12>
    mpool_free((char*)r->tickOutput, r->mempool);
 802117a:	6821      	ldr	r1, [r4, #0]
 802117c:	6960      	ldr	r0, [r4, #20]
 802117e:	f003 f94f 	bl	8024420 <mpool_free>
    mpool_free((char*)r->pitchFactor, r->mempool);
 8021182:	6821      	ldr	r1, [r4, #0]
 8021184:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8021186:	f003 f94b 	bl	8024420 <mpool_free>
    mpool_free((char*)r->ps, r->mempool);
 802118a:	6821      	ldr	r1, [r4, #0]
 802118c:	68a0      	ldr	r0, [r4, #8]
 802118e:	f003 f947 	bl	8024420 <mpool_free>
    mpool_free((char*)r->inBuffer, r->mempool);
 8021192:	6821      	ldr	r1, [r4, #0]
 8021194:	68e0      	ldr	r0, [r4, #12]
 8021196:	f003 f943 	bl	8024420 <mpool_free>
    mpool_free((char*)r->outBuffers, r->mempool);
 802119a:	6821      	ldr	r1, [r4, #0]
 802119c:	6920      	ldr	r0, [r4, #16]
 802119e:	f003 f93f 	bl	8024420 <mpool_free>
    mpool_free((char*)r, r->mempool);
 80211a2:	6821      	ldr	r1, [r4, #0]
 80211a4:	4620      	mov	r0, r4
}
 80211a6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
 80211aa:	f003 b939 	b.w	8024420 <mpool_free>
 80211ae:	bf00      	nop

080211b0 <tRetune_tick>:
{
 80211b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80211b4:	ed2d 8b04 	vpush	{d8-d9}
    _tRetune* r = *rt;
 80211b8:	6807      	ldr	r7, [r0, #0]
{
 80211ba:	b083      	sub	sp, #12
    r->inputPeriod = tPeriodDetection_tick(&r->pd, sample);
 80211bc:	1d38      	adds	r0, r7, #4
 80211be:	f7fe f915 	bl	801f3ec <tPeriodDetection_tick>
    for (int v = 0; v < r->numVoices; ++v)
 80211c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    r->inputPeriod = tPeriodDetection_tick(&r->pd, sample);
 80211c4:	ed87 0a0d 	vstr	s0, [r7, #52]	; 0x34
    for (int v = 0; v < r->numVoices; ++v)
 80211c8:	2b00      	cmp	r3, #0
 80211ca:	f340 8083 	ble.w	80212d4 <tRetune_tick+0x124>
 80211ce:	2500      	movs	r5, #0
    if(period > MAXPERIOD) period = MAXPERIOD;
 80211d0:	ed9f 9a5f 	vldr	s18, [pc, #380]	; 8021350 <tRetune_tick+0x1a0>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 80211d4:	eddf 9a5f 	vldr	s19, [pc, #380]	; 8021354 <tRetune_tick+0x1a4>
 80211d8:	e005      	b.n	80211e6 <tRetune_tick+0x36>
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
 80211da:	ed86 8a00 	vstr	s16, [r6]
    for (int v = 0; v < r->numVoices; ++v)
 80211de:	3501      	adds	r5, #1
 80211e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80211e2:	42ab      	cmp	r3, r5
 80211e4:	dd76      	ble.n	80212d4 <tRetune_tick+0x124>
    _tPitchShift* ps = *psr;
 80211e6:	68bb      	ldr	r3, [r7, #8]
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
 80211e8:	697e      	ldr	r6, [r7, #20]
    _tPitchShift* ps = *psr;
 80211ea:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
 80211ee:	eb06 0685 	add.w	r6, r6, r5, lsl #2
    _tPeriodDetection* p = *ps->p;
 80211f2:	68e2      	ldr	r2, [r4, #12]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 80211f4:	f104 0008 	add.w	r0, r4, #8
 80211f8:	6923      	ldr	r3, [r4, #16]
    _tPeriodDetection* p = *ps->p;
 80211fa:	6812      	ldr	r2, [r2, #0]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 80211fc:	6b11      	ldr	r1, [r2, #48]	; 0x30
    _tPeriodDetection* p = *ps->p;
 80211fe:	9201      	str	r2, [sp, #4]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8021200:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    i = p->i;
 8021204:	f8d2 8028 	ldr.w	r8, [r2, #40]	; 0x28
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8021208:	ed93 0a00 	vldr	s0, [r3]
 802120c:	f001 fcfe 	bl	8022c0c <tHighpass_tick>
    if (p->indexstore >= ps->frameSize)
 8021210:	9a01      	ldr	r2, [sp, #4]
 8021212:	6963      	ldr	r3, [r4, #20]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8021214:	eeb0 8a40 	vmov.f32	s16, s0
    if (p->indexstore >= ps->frameSize)
 8021218:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 802121a:	429a      	cmp	r2, r3
 802121c:	dbdd      	blt.n	80211da <tRetune_tick+0x2a>
        period = tPeriodDetection_getPeriod(&p);
 802121e:	a801      	add	r0, sp, #4
 8021220:	f7fe f92e 	bl	801f480 <tPeriodDetection_getPeriod>
    _tPeriodDetection* p = *ps->p;
 8021224:	68e3      	ldr	r3, [r4, #12]
        period = tPeriodDetection_getPeriod(&p);
 8021226:	eef0 8a40 	vmov.f32	s17, s0
    _tPeriodDetection* p = *ps->p;
 802122a:	f8d3 9000 	ldr.w	r9, [r3]
    envout = tEnvPD_tick(&p->env);
 802122e:	f109 0004 	add.w	r0, r9, #4
 8021232:	f7fd fcf5 	bl	801ec20 <tEnvPD_tick>
    if (envout >= 1.0f)
 8021236:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802123a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 802123e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021242:	db0e      	blt.n	8021262 <tRetune_tick+0xb2>
        p->lastmax = p->max;
 8021244:	edd9 7a13 	vldr	s15, [r9, #76]	; 0x4c
        if (envout > p->max)
 8021248:	eeb4 0ae7 	vcmpe.f32	s0, s15
        p->lastmax = p->max;
 802124c:	edc9 7a14 	vstr	s15, [r9, #80]	; 0x50
 8021250:	ee30 7a67 	vsub.f32	s14, s0, s15
        if (envout > p->max)
 8021254:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021258:	dd6e      	ble.n	8021338 <tRetune_tick+0x188>
            p->max = envout;
 802125a:	ed89 0a13 	vstr	s0, [r9, #76]	; 0x4c
        p->deltamax = p->max - p->lastmax;
 802125e:	ed89 7a15 	vstr	s14, [r9, #84]	; 0x54
    p->fba = p->fba ? (p->fba - 1) : 0;
 8021262:	f899 3040 	ldrb.w	r3, [r9, #64]	; 0x40
 8021266:	9901      	ldr	r1, [sp, #4]
 8021268:	2b00      	cmp	r3, #0
 802126a:	d039      	beq.n	80212e0 <tRetune_tick+0x130>
 802126c:	3b01      	subs	r3, #1
 802126e:	b2db      	uxtb	r3, r3
 8021270:	f889 3040 	strb.w	r3, [r9, #64]	; 0x40
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 8021274:	b3a3      	cbz	r3, 80212e0 <tRetune_tick+0x130>
 8021276:	6862      	ldr	r2, [r4, #4]
    if(period > MAXPERIOD) period = MAXPERIOD;
 8021278:	88d3      	ldrh	r3, [r2, #6]
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
 802127a:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    if(period > MAXPERIOD) period = MAXPERIOD;
 802127e:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
 8021282:	ee00 3a10 	vmov	s0, r3
 8021286:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 802128a:	ee20 0a09 	vmul.f32	s0, s0, s18
 802128e:	fe80 0a68 	vminnm.f32	s0, s0, s17
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
 8021292:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8021296:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802129a:	dd02      	ble.n	80212a2 <tRetune_tick+0xf2>
 802129c:	ed82 0a04 	vstr	s0, [r2, #16]
 80212a0:	6862      	ldr	r2, [r4, #4]
        tSOLAD_setPitchFactor(&ps->sola, ps->pitchFactor);
 80212a2:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
 80212a6:	ea4f 0888 	mov.w	r8, r8, lsl #2
 80212aa:	1d20      	adds	r0, r4, #4
    for (int v = 0; v < r->numVoices; ++v)
 80212ac:	3501      	adds	r5, #1
    if (pitchfactor <= 0.0f) return;
 80212ae:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80212b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    w->pitchfactor = pitchfactor;
 80212b6:	bf88      	it	hi
 80212b8:	edc2 7a02 	vstrhi	s15, [r2, #8]
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
 80212bc:	68c9      	ldr	r1, [r1, #12]
 80212be:	6922      	ldr	r2, [r4, #16]
 80212c0:	6963      	ldr	r3, [r4, #20]
 80212c2:	4441      	add	r1, r8
 80212c4:	4442      	add	r2, r8
 80212c6:	f7ff fcd1 	bl	8020c6c <tSOLAD_ioSamples>
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
 80212ca:	ed86 8a00 	vstr	s16, [r6]
    for (int v = 0; v < r->numVoices; ++v)
 80212ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80212d0:	42ab      	cmp	r3, r5
 80212d2:	dc88      	bgt.n	80211e6 <tRetune_tick+0x36>
}
 80212d4:	6978      	ldr	r0, [r7, #20]
 80212d6:	b003      	add	sp, #12
 80212d8:	ecbd 8b04 	vpop	{d8-d9}
 80212dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 80212e0:	edd9 7a13 	vldr	s15, [r9, #76]	; 0x4c
 80212e4:	eef4 7ae9 	vcmpe.f32	s15, s19
 80212e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80212ec:	ddc3      	ble.n	8021276 <tRetune_tick+0xc6>
 80212ee:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
 80212f2:	ed99 7a15 	vldr	s14, [r9, #84]	; 0x54
 80212f6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80212fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80212fe:	ddba      	ble.n	8021276 <tRetune_tick+0xc6>
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 8021300:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
            p->fba = 5;
 8021302:	2305      	movs	r3, #5
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 8021304:	ee07 2a90 	vmov	s15, r2
            p->fba = 5;
 8021308:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
    _tSOLAD* w = *wp;
 802130c:	6862      	ldr	r2, [r4, #4]
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 802130e:	eef8 7a67 	vcvt.f32.u32	s15, s15
    if(readlag < w->readlag)               // do not jump backward, only forward
 8021312:	ed92 7a03 	vldr	s14, [r2, #12]
 8021316:	eef4 7ac7 	vcmpe.f32	s15, s14
 802131a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802131e:	d5ab      	bpl.n	8021278 <tRetune_tick+0xc8>
        w->jump = w->readlag - readlag;
 8021320:	ee37 7a67 	vsub.f32	s14, s14, s15
        w->xfadevalue = 1;
 8021324:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
        w->readlag = readlag;
 8021328:	edc2 7a03 	vstr	s15, [r2, #12]
        w->xfadelength = readlag;
 802132c:	edc2 7a06 	vstr	s15, [r2, #24]
        w->jump = w->readlag - readlag;
 8021330:	ed82 7a05 	vstr	s14, [r2, #20]
        w->xfadevalue = 1;
 8021334:	61d3      	str	r3, [r2, #28]
 8021336:	e79e      	b.n	8021276 <tRetune_tick+0xc6>
            p->deltamax = envout - p->max;
 8021338:	ed89 7a15 	vstr	s14, [r9, #84]	; 0x54
            p->max = p->max * ps->radius;
 802133c:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
 8021340:	ee67 6aa6 	vmul.f32	s13, s15, s13
 8021344:	ee36 7ae7 	vsub.f32	s14, s13, s15
 8021348:	edc9 6a13 	vstr	s13, [r9, #76]	; 0x4c
 802134c:	e787      	b.n	802125e <tRetune_tick+0xae>
 802134e:	bf00      	nop
 8021350:	3f4ccccd 	.word	0x3f4ccccd
 8021354:	42700000 	.word	0x42700000

08021358 <tRetune_setPitchFactor>:
{
 8021358:	b410      	push	{r4}
    _tRetune* r = *rt;
 802135a:	6802      	ldr	r2, [r0, #0]
    r->pitchFactor[voice] = pf;
 802135c:	008c      	lsls	r4, r1, #2
 802135e:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8021360:	4420      	add	r0, r4
 8021362:	ed80 0a00 	vstr	s0, [r0]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
 8021366:	6a93      	ldr	r3, [r2, #40]	; 0x28
    _tPitchShift* ps = *psr;
 8021368:	6892      	ldr	r2, [r2, #8]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
 802136a:	4423      	add	r3, r4
    _tPitchShift* ps = *psr;
 802136c:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
 8021370:	681b      	ldr	r3, [r3, #0]
    ps->pitchFactor = pf;
 8021372:	62d3      	str	r3, [r2, #44]	; 0x2c
}
 8021374:	f85d 4b04 	ldr.w	r4, [sp], #4
 8021378:	4770      	bx	lr
 802137a:	bf00      	nop

0802137c <tRetune_setFidelityThreshold>:

void tRetune_setFidelityThreshold(tRetune* const rt, float threshold)
{
    _tRetune* r = *rt;
    
    tPeriodDetection_setFidelityThreshold(&r->pd, threshold);
 802137c:	6800      	ldr	r0, [r0, #0]
 802137e:	3004      	adds	r0, #4
 8021380:	f7fe b882 	b.w	801f488 <tPeriodDetection_setFidelityThreshold>

08021384 <tRetune_getInputPeriod>:

float tRetune_getInputPeriod(tRetune* const rt)
{
    _tRetune* r = *rt;
    
    return (r->inputPeriod * leaf.invSampleRate);
 8021384:	6802      	ldr	r2, [r0, #0]
 8021386:	4b04      	ldr	r3, [pc, #16]	; (8021398 <tRetune_getInputPeriod+0x14>)
 8021388:	ed92 0a0d 	vldr	s0, [r2, #52]	; 0x34
 802138c:	edd3 7a01 	vldr	s15, [r3, #4]
}
 8021390:	ee20 0a27 	vmul.f32	s0, s0, s15
 8021394:	4770      	bx	lr
 8021396:	bf00      	nop
 8021398:	200194e8 	.word	0x200194e8

0802139c <tAutotune_initToPool>:
{
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
}

void tAutotune_initToPool (tAutotune* const rt, int numVoices, int bufSize, int frameSize, tMempool* const mp)
{
 802139c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80213a0:	ed2d 8b02 	vpush	{d8}
 80213a4:	b085      	sub	sp, #20
 80213a6:	4604      	mov	r4, r0
 80213a8:	4689      	mov	r9, r1
    _tMempool* m = *mp;
    _tAutotune* r = *rt = (_tAutotune*) mpool_alloc(sizeof(_tAutotune), m);
 80213aa:	2040      	movs	r0, #64	; 0x40
{
 80213ac:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
 80213b0:	4617      	mov	r7, r2
 80213b2:	469a      	mov	sl, r3
    _tMempool* m = *mp;
 80213b4:	f8d8 6000 	ldr.w	r6, [r8]
    _tAutotune* r = *rt = (_tAutotune*) mpool_alloc(sizeof(_tAutotune), m);
 80213b8:	4631      	mov	r1, r6
 80213ba:	f002 ff7d 	bl	80242b8 <mpool_alloc>
 80213be:	4605      	mov	r5, r0
 80213c0:	6020      	str	r0, [r4, #0]
    
    r->bufSize = bufSize;
    r->frameSize = frameSize;
    r->numVoices = numVoices;
    
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
 80213c2:	4631      	mov	r1, r6
    r->mempool = *mp;
 80213c4:	f8d8 2000 	ldr.w	r2, [r8]
    r->frameSize = frameSize;
 80213c8:	f8c0 a018 	str.w	sl, [r0, #24]
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
 80213cc:	00b8      	lsls	r0, r7, #2
    r->mempool = *mp;
 80213ce:	602a      	str	r2, [r5, #0]
    r->bufSize = bufSize;
 80213d0:	61ef      	str	r7, [r5, #28]
    r->numVoices = numVoices;
 80213d2:	f8c5 903c 	str.w	r9, [r5, #60]	; 0x3c
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
 80213d6:	f002 ff6f 	bl	80242b8 <mpool_alloc>
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
 80213da:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80213dc:	4631      	mov	r1, r6
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
 80213de:	60e8      	str	r0, [r5, #12]
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
 80213e0:	0098      	lsls	r0, r3, #2
 80213e2:	f002 ff69 	bl	80242b8 <mpool_alloc>
    
    r->hopSize = DEFHOPSIZE;
 80213e6:	f04f 1240 	mov.w	r2, #4194368	; 0x400040
    r->windowSize = DEFWINDOWSIZE;
    r->fba = FBA;
 80213ea:	2314      	movs	r3, #20
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
 80213ec:	6128      	str	r0, [r5, #16]
    r->hopSize = DEFHOPSIZE;
 80213ee:	622a      	str	r2, [r5, #32]
void tAutotune_setTimeConstant(tAutotune* const rt, float tc)
{
    _tAutotune* r = *rt;
    
    r->timeConstant = tc;
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 80213f0:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
    r->fba = FBA;
 80213f4:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 80213f8:	4b51      	ldr	r3, [pc, #324]	; (8021540 <tAutotune_initToPool+0x1a4>)
    _tAutotune* r = *rt;
 80213fa:	6824      	ldr	r4, [r4, #0]
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 80213fc:	ed93 0a01 	vldr	s0, [r3, #4]
 8021400:	8c23      	ldrh	r3, [r4, #32]
 8021402:	ee20 0a07 	vmul.f32	s0, s0, s14
 8021406:	ee07 3a90 	vmov	s15, r3
    r->timeConstant = tc;
 802140a:	4b4e      	ldr	r3, [pc, #312]	; (8021544 <tAutotune_initToPool+0x1a8>)
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 802140c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    r->timeConstant = tc;
 8021410:	62e3      	str	r3, [r4, #44]	; 0x2c
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8021412:	ee20 0a27 	vmul.f32	s0, s0, s15
 8021416:	f005 ff43 	bl	80272a0 <expf>
 802141a:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    r->ps = (tPitchShift*) mpool_alloc(sizeof(tPitchShift) * r->numVoices, m);
 802141e:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8021420:	4631      	mov	r1, r6
 8021422:	0080      	lsls	r0, r0, #2
 8021424:	f002 ff48 	bl	80242b8 <mpool_alloc>
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8021428:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->ps = (tPitchShift*) mpool_alloc(sizeof(tPitchShift) * r->numVoices, m);
 802142a:	60a8      	str	r0, [r5, #8]
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 802142c:	4631      	mov	r1, r6
 802142e:	0098      	lsls	r0, r3, #2
 8021430:	f002 ff42 	bl	80242b8 <mpool_alloc>
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8021434:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8021436:	62a8      	str	r0, [r5, #40]	; 0x28
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8021438:	4631      	mov	r1, r6
 802143a:	0098      	lsls	r0, r3, #2
 802143c:	f002 ff3c 	bl	80242b8 <mpool_alloc>
    for (int i = 0; i < r->numVoices; ++i)
 8021440:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8021442:	6168      	str	r0, [r5, #20]
    for (int i = 0; i < r->numVoices; ++i)
 8021444:	2b00      	cmp	r3, #0
 8021446:	dd0c      	ble.n	8021462 <tAutotune_initToPool+0xc6>
 8021448:	2400      	movs	r4, #0
        r->outBuffers[i] = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
 802144a:	69e8      	ldr	r0, [r5, #28]
 802144c:	4631      	mov	r1, r6
 802144e:	692f      	ldr	r7, [r5, #16]
 8021450:	0080      	lsls	r0, r0, #2
 8021452:	f002 ff31 	bl	80242b8 <mpool_alloc>
 8021456:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
 802145a:	3401      	adds	r4, #1
 802145c:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 802145e:	42a3      	cmp	r3, r4
 8021460:	dcf3      	bgt.n	802144a <tAutotune_initToPool+0xae>
    tPeriodDetection_initToPool(&r->pd, r->inBuffer, r->outBuffers[0], r->bufSize, r->frameSize, mp);
 8021462:	692a      	ldr	r2, [r5, #16]
 8021464:	1d28      	adds	r0, r5, #4
 8021466:	69eb      	ldr	r3, [r5, #28]
 8021468:	6812      	ldr	r2, [r2, #0]
 802146a:	68e9      	ldr	r1, [r5, #12]
 802146c:	f8cd 8004 	str.w	r8, [sp, #4]
 8021470:	69ac      	ldr	r4, [r5, #24]
 8021472:	9003      	str	r0, [sp, #12]
 8021474:	9400      	str	r4, [sp, #0]
 8021476:	f7fd ff39 	bl	801f2ec <tPeriodDetection_initToPool>
    for (int i = 0; i < r->numVoices; ++i)
 802147a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 802147c:	2b00      	cmp	r3, #0
 802147e:	dd56      	ble.n	802152e <tAutotune_initToPool+0x192>
 8021480:	2700      	movs	r7, #0
    w->period = INITPERIOD;
 8021482:	ed9f 8a31 	vldr	s16, [pc, #196]	; 8021548 <tAutotune_initToPool+0x1ac>
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8021486:	eddf 8a31 	vldr	s17, [pc, #196]	; 802154c <tAutotune_initToPool+0x1b0>
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 802148a:	692b      	ldr	r3, [r5, #16]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 802148c:	2038      	movs	r0, #56	; 0x38
    _tMempool* m = *mp;
 802148e:	f8d8 a000 	ldr.w	sl, [r8]
    ps->pitchFactor = 1.0f;
 8021492:	f04f 5b7e 	mov.w	fp, #1065353216	; 0x3f800000
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 8021496:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 802149a:	4651      	mov	r1, sl
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 802149c:	69ee      	ldr	r6, [r5, #28]
 802149e:	f8d5 9008 	ldr.w	r9, [r5, #8]
 80214a2:	9302      	str	r3, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 80214a4:	f002 ff64 	bl	8024370 <mpool_calloc>
    ps->outBuffer = out;
 80214a8:	9902      	ldr	r1, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 80214aa:	4604      	mov	r4, r0
    ps->curBlock = 1;
 80214ac:	f04f 0c01 	mov.w	ip, #1
    ps->lastBlock = 0;
 80214b0:	2200      	movs	r2, #0
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 80214b2:	f849 4027 	str.w	r4, [r9, r7, lsl #2]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 80214b6:	2024      	movs	r0, #36	; 0x24
    ps->mempool = m;
 80214b8:	f8c4 a000 	str.w	sl, [r4]
    for (int i = 0; i < r->numVoices; ++i)
 80214bc:	4467      	add	r7, ip
    _tPeriodDetection* p = *pd;
 80214be:	686b      	ldr	r3, [r5, #4]
    ps->outBuffer = out;
 80214c0:	6121      	str	r1, [r4, #16]
    ps->p = pd;
 80214c2:	9903      	ldr	r1, [sp, #12]
    ps->bufSize = bufSize;
 80214c4:	61a6      	str	r6, [r4, #24]
    ps->p = pd;
 80214c6:	60e1      	str	r1, [r4, #12]
    ps->frameSize = p->frameSize;
 80214c8:	695b      	ldr	r3, [r3, #20]
    ps->curBlock = 1;
 80214ca:	f8c4 c020 	str.w	ip, [r4, #32]
    ps->frameSize = p->frameSize;
 80214ce:	6163      	str	r3, [r4, #20]
    ps->pitchFactor = 1.0f;
 80214d0:	f8c4 b02c 	str.w	fp, [r4, #44]	; 0x2c
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
 80214d4:	fb96 f6f3 	sdiv	r6, r6, r3
    ps->index = 0;
 80214d8:	e9c4 2209 	strd	r2, r2, [r4, #36]	; 0x24
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
 80214dc:	61e6      	str	r6, [r4, #28]
    _tMempool* m = *mp;
 80214de:	f8d8 a000 	ldr.w	sl, [r8]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 80214e2:	4651      	mov	r1, sl
 80214e4:	f002 ff44 	bl	8024370 <mpool_calloc>
 80214e8:	4606      	mov	r6, r0
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 80214ea:	4651      	mov	r1, sl
 80214ec:	f244 0040 	movw	r0, #16448	; 0x4040
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 80214f0:	6066      	str	r6, [r4, #4]
    w->mempool = m;
 80214f2:	f8c6 a000 	str.w	sl, [r6]
    w->pitchfactor = 1.;
 80214f6:	f8c6 b008 	str.w	fp, [r6, #8]
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 80214fa:	f002 ff39 	bl	8024370 <mpool_calloc>
    w->xfadevalue = -1;
 80214fe:	4a14      	ldr	r2, [pc, #80]	; (8021550 <tAutotune_initToPool+0x1b4>)
    w->timeindex = 0;
 8021500:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 8021504:	6230      	str	r0, [r6, #32]
    w->xfadevalue = -1;
 8021506:	61f2      	str	r2, [r6, #28]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8021508:	f104 0008 	add.w	r0, r4, #8
    w->timeindex = 0;
 802150c:	6073      	str	r3, [r6, #4]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 802150e:	4641      	mov	r1, r8
    w->period = INITPERIOD;
 8021510:	ed86 8a04 	vstr	s16, [r6, #16]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8021514:	eeb0 0a68 	vmov.f32	s0, s17
    w->readlag = INITPERIOD;
 8021518:	ed86 8a03 	vstr	s16, [r6, #12]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 802151c:	f001 fb42 	bl	8022ba4 <tHighpass_initToPool>
    _tSOLAD* w = *wp;
 8021520:	6863      	ldr	r3, [r4, #4]
    w->pitchfactor = pitchfactor;
 8021522:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8021526:	609a      	str	r2, [r3, #8]
    for (int i = 0; i < r->numVoices; ++i)
 8021528:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 802152a:	42bb      	cmp	r3, r7
 802152c:	dcad      	bgt.n	802148a <tAutotune_initToPool+0xee>
    r->inputPeriod = 0.0f;
 802152e:	2200      	movs	r2, #0
    r->shiftOn = 0;
 8021530:	2300      	movs	r3, #0
    r->inputPeriod = 0.0f;
 8021532:	636a      	str	r2, [r5, #52]	; 0x34
    r->shiftOn = 0;
 8021534:	63ab      	str	r3, [r5, #56]	; 0x38
}
 8021536:	b005      	add	sp, #20
 8021538:	ecbd 8b02 	vpop	{d8}
 802153c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021540:	200194e8 	.word	0x200194e8
 8021544:	42c80000 	.word	0x42c80000
 8021548:	42800000 	.word	0x42800000
 802154c:	42200000 	.word	0x42200000
 8021550:	bf800000 	.word	0xbf800000

08021554 <tAutotune_free>:
{
 8021554:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tAutotune* r = *rt;
 8021556:	6804      	ldr	r4, [r0, #0]
    tPeriodDetection_free(&r->pd);
 8021558:	1d20      	adds	r0, r4, #4
 802155a:	f7fd ff25 	bl	801f3a8 <tPeriodDetection_free>
    for (int i = 0; i < r->numVoices; ++i)
 802155e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8021560:	2b00      	cmp	r3, #0
 8021562:	dd1e      	ble.n	80215a2 <tAutotune_free+0x4e>
 8021564:	2500      	movs	r5, #0
    _tPitchShift* ps = *psr;
 8021566:	68a3      	ldr	r3, [r4, #8]
 8021568:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    _tSOLAD* w = *wp;
 802156c:	6877      	ldr	r7, [r6, #4]
    mpool_free((char*)w->delaybuf, w->mempool);
 802156e:	6839      	ldr	r1, [r7, #0]
 8021570:	6a38      	ldr	r0, [r7, #32]
 8021572:	f002 ff55 	bl	8024420 <mpool_free>
    mpool_free((char*)w, w->mempool);
 8021576:	6839      	ldr	r1, [r7, #0]
 8021578:	4638      	mov	r0, r7
 802157a:	f002 ff51 	bl	8024420 <mpool_free>
    tHighpass_free(&ps->hp);
 802157e:	f106 0008 	add.w	r0, r6, #8
 8021582:	f001 fb2f 	bl	8022be4 <tHighpass_free>
    mpool_free((char*)ps, ps->mempool);
 8021586:	6831      	ldr	r1, [r6, #0]
 8021588:	4630      	mov	r0, r6
 802158a:	f002 ff49 	bl	8024420 <mpool_free>
        mpool_free((char*)r->outBuffers[i], r->mempool);
 802158e:	6923      	ldr	r3, [r4, #16]
 8021590:	6821      	ldr	r1, [r4, #0]
 8021592:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
 8021596:	3501      	adds	r5, #1
        mpool_free((char*)r->outBuffers[i], r->mempool);
 8021598:	f002 ff42 	bl	8024420 <mpool_free>
    for (int i = 0; i < r->numVoices; ++i)
 802159c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 802159e:	42ab      	cmp	r3, r5
 80215a0:	dce1      	bgt.n	8021566 <tAutotune_free+0x12>
    mpool_free((char*)r->tickOutput, r->mempool);
 80215a2:	6821      	ldr	r1, [r4, #0]
 80215a4:	6960      	ldr	r0, [r4, #20]
 80215a6:	f002 ff3b 	bl	8024420 <mpool_free>
    mpool_free((char*)r->freq, r->mempool);
 80215aa:	6821      	ldr	r1, [r4, #0]
 80215ac:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80215ae:	f002 ff37 	bl	8024420 <mpool_free>
    mpool_free((char*)r->ps, r->mempool);
 80215b2:	6821      	ldr	r1, [r4, #0]
 80215b4:	68a0      	ldr	r0, [r4, #8]
 80215b6:	f002 ff33 	bl	8024420 <mpool_free>
    mpool_free((char*)r->inBuffer, r->mempool);
 80215ba:	6821      	ldr	r1, [r4, #0]
 80215bc:	68e0      	ldr	r0, [r4, #12]
 80215be:	f002 ff2f 	bl	8024420 <mpool_free>
    mpool_free((char*)r->outBuffers, r->mempool);
 80215c2:	6821      	ldr	r1, [r4, #0]
 80215c4:	6920      	ldr	r0, [r4, #16]
 80215c6:	f002 ff2b 	bl	8024420 <mpool_free>
    mpool_free((char*)r, r->mempool);
 80215ca:	6821      	ldr	r1, [r4, #0]
 80215cc:	4620      	mov	r0, r4
}
 80215ce:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
 80215d2:	f002 bf25 	b.w	8024420 <mpool_free>
 80215d6:	bf00      	nop

080215d8 <tAutotune_tick>:
{
 80215d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80215dc:	ed2d 8b06 	vpush	{d8-d10}
    _tAutotune* r = *rt;
 80215e0:	6806      	ldr	r6, [r0, #0]
{
 80215e2:	b082      	sub	sp, #8
    float tempPeriod = tPeriodDetection_tick(&r->pd, sample);
 80215e4:	1d30      	adds	r0, r6, #4
 80215e6:	f7fd ff01 	bl	801f3ec <tPeriodDetection_tick>
    if (tempPeriod < 1000.0f) //to avoid trying to follow consonants JS
 80215ea:	eddf 7a75 	vldr	s15, [pc, #468]	; 80217c0 <tAutotune_tick+0x1e8>
 80215ee:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80215f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80215f6:	d501      	bpl.n	80215fc <tAutotune_tick+0x24>
        r->inputPeriod = tempPeriod;
 80215f8:	ed86 0a0d 	vstr	s0, [r6, #52]	; 0x34
    for (int v = 0; v < r->numVoices; ++v)
 80215fc:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 80215fe:	2b00      	cmp	r3, #0
 8021600:	f340 8097 	ble.w	8021732 <tAutotune_tick+0x15a>
 8021604:	2500      	movs	r5, #0
    if(period > MAXPERIOD) period = MAXPERIOD;
 8021606:	eddf 9a6f 	vldr	s19, [pc, #444]	; 80217c4 <tAutotune_tick+0x1ec>
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
 802160a:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 80217cc <tAutotune_tick+0x1f4>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 802160e:	ed9f aa6e 	vldr	s20, [pc, #440]	; 80217c8 <tAutotune_tick+0x1f0>
 8021612:	e006      	b.n	8021622 <tAutotune_tick+0x4a>
        r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 8021614:	edc7 8a00 	vstr	s17, [r7]
    for (int v = 0; v < r->numVoices; ++v)
 8021618:	3501      	adds	r5, #1
 802161a:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 802161c:	42ab      	cmp	r3, r5
 802161e:	f340 8088 	ble.w	8021732 <tAutotune_tick+0x15a>
    _tPitchShift* ps = *psr;
 8021622:	68b1      	ldr	r1, [r6, #8]
 8021624:	00ab      	lsls	r3, r5, #2
        r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 8021626:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    _tPitchShift* ps = *psr;
 8021628:	f851 4025 	ldr.w	r4, [r1, r5, lsl #2]
        r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 802162c:	6977      	ldr	r7, [r6, #20]
 802162e:	eb02 0c03 	add.w	ip, r2, r3
    _tPeriodDetection* p = *ps->p;
 8021632:	68e1      	ldr	r1, [r4, #12]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8021634:	f104 0008 	add.w	r0, r4, #8
 8021638:	6922      	ldr	r2, [r4, #16]
        r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 802163a:	441f      	add	r7, r3
    _tPeriodDetection* p = *ps->p;
 802163c:	6809      	ldr	r1, [r1, #0]
        r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 802163e:	ed9c 8a00 	vldr	s16, [ip]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8021642:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    _tPeriodDetection* p = *ps->p;
 8021644:	9101      	str	r1, [sp, #4]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8021646:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    i = p->i;
 802164a:	f8d1 9028 	ldr.w	r9, [r1, #40]	; 0x28
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 802164e:	ed92 0a00 	vldr	s0, [r2]
 8021652:	f001 fadb 	bl	8022c0c <tHighpass_tick>
    if (p->indexstore >= ps->frameSize)
 8021656:	9a01      	ldr	r2, [sp, #4]
 8021658:	6963      	ldr	r3, [r4, #20]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 802165a:	eef0 8a40 	vmov.f32	s17, s0
    if (p->indexstore >= ps->frameSize)
 802165e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8021660:	429a      	cmp	r2, r3
 8021662:	dbd7      	blt.n	8021614 <tAutotune_tick+0x3c>
        period = tPeriodDetection_getPeriod(&p);
 8021664:	a801      	add	r0, sp, #4
 8021666:	f7fd ff0b 	bl	801f480 <tPeriodDetection_getPeriod>
    _tPeriodDetection* p = *ps->p;
 802166a:	68e3      	ldr	r3, [r4, #12]
        period = tPeriodDetection_getPeriod(&p);
 802166c:	eeb0 9a40 	vmov.f32	s18, s0
    _tPeriodDetection* p = *ps->p;
 8021670:	f8d3 a000 	ldr.w	sl, [r3]
    envout = tEnvPD_tick(&p->env);
 8021674:	f10a 0004 	add.w	r0, sl, #4
 8021678:	f7fd fad2 	bl	801ec20 <tEnvPD_tick>
    if (envout >= 1.0f)
 802167c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8021680:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8021684:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021688:	db0f      	blt.n	80216aa <tAutotune_tick+0xd2>
        p->lastmax = p->max;
 802168a:	edda 7a13 	vldr	s15, [sl, #76]	; 0x4c
        if (envout > p->max)
 802168e:	eeb4 0ae7 	vcmpe.f32	s0, s15
        p->lastmax = p->max;
 8021692:	edca 7a14 	vstr	s15, [sl, #80]	; 0x50
 8021696:	ee30 7a67 	vsub.f32	s14, s0, s15
        if (envout > p->max)
 802169a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802169e:	f340 8083 	ble.w	80217a8 <tAutotune_tick+0x1d0>
            p->max = envout;
 80216a2:	ed8a 0a13 	vstr	s0, [sl, #76]	; 0x4c
        p->deltamax = p->max - p->lastmax;
 80216a6:	ed8a 7a15 	vstr	s14, [sl, #84]	; 0x54
    p->fba = p->fba ? (p->fba - 1) : 0;
 80216aa:	f89a 3040 	ldrb.w	r3, [sl, #64]	; 0x40
 80216ae:	2b00      	cmp	r3, #0
 80216b0:	d04c      	beq.n	802174c <tAutotune_tick+0x174>
 80216b2:	3b01      	subs	r3, #1
 80216b4:	b2db      	uxtb	r3, r3
 80216b6:	f88a 3040 	strb.w	r3, [sl, #64]	; 0x40
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 80216ba:	2b00      	cmp	r3, #0
 80216bc:	d046      	beq.n	802174c <tAutotune_tick+0x174>
 80216be:	6862      	ldr	r2, [r4, #4]
 80216c0:	9901      	ldr	r1, [sp, #4]
    if(period > MAXPERIOD) period = MAXPERIOD;
 80216c2:	88d3      	ldrh	r3, [r2, #6]
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
 80216c4:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
    if(period > MAXPERIOD) period = MAXPERIOD;
 80216c8:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
 80216cc:	ee07 3a90 	vmov	s15, r3
 80216d0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80216d4:	ee67 7aa9 	vmul.f32	s15, s15, s19
 80216d8:	fec7 7ac9 	vminnm.f32	s15, s15, s18
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
 80216dc:	eef4 7ac7 	vcmpe.f32	s15, s14
 80216e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80216e4:	dd02      	ble.n	80216ec <tAutotune_tick+0x114>
 80216e6:	edc2 7a04 	vstr	s15, [r2, #16]
 80216ea:	6862      	ldr	r2, [r4, #4]
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
 80216ec:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80216f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80216f4:	d023      	beq.n	802173e <tAutotune_tick+0x166>
 80216f6:	edd8 7a01 	vldr	s15, [r8, #4]
 80216fa:	ee28 8a27 	vmul.f32	s16, s16, s15
 80216fe:	ee28 8a09 	vmul.f32	s16, s16, s18
    if (pitchfactor <= 0.0f) return;
 8021702:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8021706:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
 802170a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802170e:	d81a      	bhi.n	8021746 <tAutotune_tick+0x16e>
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
 8021710:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8021714:	68c9      	ldr	r1, [r1, #12]
 8021716:	6922      	ldr	r2, [r4, #16]
 8021718:	1d20      	adds	r0, r4, #4
 802171a:	6963      	ldr	r3, [r4, #20]
 802171c:	4449      	add	r1, r9
 802171e:	444a      	add	r2, r9
    for (int v = 0; v < r->numVoices; ++v)
 8021720:	3501      	adds	r5, #1
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
 8021722:	f7ff faa3 	bl	8020c6c <tSOLAD_ioSamples>
        r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 8021726:	edc7 8a00 	vstr	s17, [r7]
    for (int v = 0; v < r->numVoices; ++v)
 802172a:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 802172c:	42ab      	cmp	r3, r5
 802172e:	f73f af78 	bgt.w	8021622 <tAutotune_tick+0x4a>
    return r->tickOutput;
 8021732:	6970      	ldr	r0, [r6, #20]
}
 8021734:	b002      	add	sp, #8
 8021736:	ecbd 8b06 	vpop	{d8-d10}
 802173a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802173e:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 8021742:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
    w->pitchfactor = pitchfactor;
 8021746:	ed82 8a02 	vstr	s16, [r2, #8]
 802174a:	e7e1      	b.n	8021710 <tAutotune_tick+0x138>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 802174c:	edda 7a13 	vldr	s15, [sl, #76]	; 0x4c
 8021750:	eef4 7aca 	vcmpe.f32	s15, s20
 8021754:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021758:	ddb1      	ble.n	80216be <tAutotune_tick+0xe6>
 802175a:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
 802175e:	ed9a 7a15 	vldr	s14, [sl, #84]	; 0x54
 8021762:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8021766:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802176a:	dda8      	ble.n	80216be <tAutotune_tick+0xe6>
            p->fba = 5;
 802176c:	9901      	ldr	r1, [sp, #4]
 802176e:	2305      	movs	r3, #5
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 8021770:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
            p->fba = 5;
 8021772:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 8021776:	ee07 2a90 	vmov	s15, r2
    _tSOLAD* w = *wp;
 802177a:	6862      	ldr	r2, [r4, #4]
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 802177c:	eef8 7a67 	vcvt.f32.u32	s15, s15
    if(readlag < w->readlag)               // do not jump backward, only forward
 8021780:	ed92 7a03 	vldr	s14, [r2, #12]
 8021784:	eef4 7ac7 	vcmpe.f32	s15, s14
 8021788:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802178c:	d599      	bpl.n	80216c2 <tAutotune_tick+0xea>
        w->jump = w->readlag - readlag;
 802178e:	ee37 7a67 	vsub.f32	s14, s14, s15
        w->xfadevalue = 1;
 8021792:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
        w->readlag = readlag;
 8021796:	edc2 7a03 	vstr	s15, [r2, #12]
        w->xfadelength = readlag;
 802179a:	edc2 7a06 	vstr	s15, [r2, #24]
        w->jump = w->readlag - readlag;
 802179e:	ed82 7a05 	vstr	s14, [r2, #20]
        w->xfadevalue = 1;
 80217a2:	61d3      	str	r3, [r2, #28]
 80217a4:	6862      	ldr	r2, [r4, #4]
 80217a6:	e78c      	b.n	80216c2 <tAutotune_tick+0xea>
            p->deltamax = envout - p->max;
 80217a8:	ed8a 7a15 	vstr	s14, [sl, #84]	; 0x54
            p->max = p->max * ps->radius;
 80217ac:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
 80217b0:	ee67 6aa6 	vmul.f32	s13, s15, s13
 80217b4:	ee36 7ae7 	vsub.f32	s14, s13, s15
 80217b8:	edca 6a13 	vstr	s13, [sl, #76]	; 0x4c
 80217bc:	e773      	b.n	80216a6 <tAutotune_tick+0xce>
 80217be:	bf00      	nop
 80217c0:	447a0000 	.word	0x447a0000
 80217c4:	3f4ccccd 	.word	0x3f4ccccd
 80217c8:	42700000 	.word	0x42700000
 80217cc:	200194e8 	.word	0x200194e8

080217d0 <tAutotune_setFreq>:
    r->freq[voice] = f;
 80217d0:	6803      	ldr	r3, [r0, #0]
 80217d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80217d4:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80217d8:	ed81 0a00 	vstr	s0, [r1]
}
 80217dc:	4770      	bx	lr
 80217de:	bf00      	nop

080217e0 <tAutotune_setFidelityThreshold>:

void tAutotune_setFidelityThreshold(tAutotune* const rt, float threshold)
{
    _tAutotune* r = *rt;

    tPeriodDetection_setFidelityThreshold(&r->pd, threshold);
 80217e0:	6800      	ldr	r0, [r0, #0]
 80217e2:	3004      	adds	r0, #4
 80217e4:	f7fd be50 	b.w	801f488 <tPeriodDetection_setFidelityThreshold>

080217e8 <tFormantShifter_initToPool>:
{
    tFormantShifter_initToPool(fsr, order, &leaf.mempool);
}

void tFormantShifter_initToPool (tFormantShifter* const fsr, int order, tMempool* const mp)
{
 80217e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80217ec:	ed2d 8b06 	vpush	{d8-d10}
    _tMempool* m = *mp;
 80217f0:	6815      	ldr	r5, [r2, #0]
{
 80217f2:	4688      	mov	r8, r1
 80217f4:	4681      	mov	r9, r0
    _tFormantShifter* fs = *fsr = (_tFormantShifter*) mpool_alloc(sizeof(_tFormantShifter), m);
 80217f6:	2068      	movs	r0, #104	; 0x68
 80217f8:	4629      	mov	r1, r5
{
 80217fa:	4616      	mov	r6, r2
    _tFormantShifter* fs = *fsr = (_tFormantShifter*) mpool_alloc(sizeof(_tFormantShifter), m);
 80217fc:	f002 fd5c 	bl	80242b8 <mpool_alloc>
 8021800:	4604      	mov	r4, r0
 8021802:	f8c9 0000 	str.w	r0, [r9]
    fs->mempool = m;
    
    fs->ford = order;
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021806:	4629      	mov	r1, r5
 8021808:	ea4f 0088 	mov.w	r0, r8, lsl #2
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
    
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);

    
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 802180c:	eddf 9a4d 	vldr	s19, [pc, #308]	; 8021944 <tFormantShifter_initToPool+0x15c>
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
    fs->fhp = 0.0f;
    fs->flp = 0.0f;
    fs->flpa = powf(0.001f, 10.0f * leaf.invSampleRate);
    fs->fmute = 1.0f;
 8021810:	f04f 577e 	mov.w	r7, #1065353216	; 0x3f800000
    fs->cbi = 0;
    fs->intensity = 1.0f;
    fs->invIntensity = 1.0f;
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
    tHighpass_initToPool(&fs->hp2, 20.0f, mp);
    tFeedbackLeveler_initToPool(&fs->fbl1, 0.8f, .005f, 0.125, 1, mp);
 8021814:	eddf 8a4c 	vldr	s17, [pc, #304]	; 8021948 <tFormantShifter_initToPool+0x160>
 8021818:	ed9f 8a4c 	vldr	s16, [pc, #304]	; 802194c <tFormantShifter_initToPool+0x164>
    fs->ford = order;
 802181c:	e9c4 5800 	strd	r5, r8, [r4]
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021820:	f002 fda6 	bl	8024370 <mpool_calloc>
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021824:	6863      	ldr	r3, [r4, #4]
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021826:	6120      	str	r0, [r4, #16]
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021828:	4629      	mov	r1, r5
 802182a:	0098      	lsls	r0, r3, #2
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 802182c:	f8df 812c 	ldr.w	r8, [pc, #300]	; 802195c <tFormantShifter_initToPool+0x174>
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021830:	f002 fd9e 	bl	8024370 <mpool_calloc>
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021834:	6863      	ldr	r3, [r4, #4]
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021836:	6160      	str	r0, [r4, #20]
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021838:	4629      	mov	r1, r5
 802183a:	0098      	lsls	r0, r3, #2
 802183c:	f002 fd98 	bl	8024370 <mpool_calloc>
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021840:	6863      	ldr	r3, [r4, #4]
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021842:	61a0      	str	r0, [r4, #24]
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021844:	4629      	mov	r1, r5
 8021846:	0098      	lsls	r0, r3, #2
 8021848:	f002 fd92 	bl	8024370 <mpool_calloc>
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 802184c:	6863      	ldr	r3, [r4, #4]
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 802184e:	61e0      	str	r0, [r4, #28]
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021850:	4629      	mov	r1, r5
 8021852:	0098      	lsls	r0, r3, #2
 8021854:	f002 fd8c 	bl	8024370 <mpool_calloc>
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021858:	6863      	ldr	r3, [r4, #4]
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 802185a:	6220      	str	r0, [r4, #32]
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 802185c:	4629      	mov	r1, r5
 802185e:	0098      	lsls	r0, r3, #2
 8021860:	f002 fd86 	bl	8024370 <mpool_calloc>
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021864:	6863      	ldr	r3, [r4, #4]
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021866:	6260      	str	r0, [r4, #36]	; 0x24
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021868:	4629      	mov	r1, r5
 802186a:	0098      	lsls	r0, r3, #2
 802186c:	f002 fd80 	bl	8024370 <mpool_calloc>
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021870:	6863      	ldr	r3, [r4, #4]
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021872:	62a0      	str	r0, [r4, #40]	; 0x28
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021874:	4629      	mov	r1, r5
 8021876:	0098      	lsls	r0, r3, #2
 8021878:	f002 fd7a 	bl	8024370 <mpool_calloc>
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
 802187c:	6863      	ldr	r3, [r4, #4]
 802187e:	4629      	mov	r1, r5
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8021880:	63e0      	str	r0, [r4, #60]	; 0x3c
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
 8021882:	0098      	lsls	r0, r3, #2
 8021884:	f002 fd74 	bl	8024370 <mpool_calloc>
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 8021888:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 802188c:	ed98 aa01 	vldr	s20, [r8, #4]
 8021890:	eeb0 0a69 	vmov.f32	s0, s19
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
 8021894:	63a0      	str	r0, [r4, #56]	; 0x38
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 8021896:	ee6a 0a20 	vmul.f32	s1, s20, s1
 802189a:	f005 fe71 	bl	8027580 <powf>
 802189e:	eeb0 9a40 	vmov.f32	s18, s0
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
 80218a2:	eddf 7a2b 	vldr	s15, [pc, #172]	; 8021950 <tFormantShifter_initToPool+0x168>
 80218a6:	ed98 0a00 	vldr	s0, [r8]
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 80218aa:	ed84 9a02 	vstr	s18, [r4, #8]
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
 80218ae:	ee20 0a27 	vmul.f32	s0, s0, s15
 80218b2:	f005 fbe3 	bl	802707c <atanf>
 80218b6:	eef1 6ac0 	vsqrt.f32	s13, s0
 80218ba:	ed9f 7a26 	vldr	s14, [pc, #152]	; 8021954 <tFormantShifter_initToPool+0x16c>
    fs->fhp = 0.0f;
 80218be:	2300      	movs	r3, #0
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
 80218c0:	eddf 7a25 	vldr	s15, [pc, #148]	; 8021958 <tFormantShifter_initToPool+0x170>
    fs->flpa = powf(0.001f, 10.0f * leaf.invSampleRate);
 80218c4:	ed84 9a0d 	vstr	s18, [r4, #52]	; 0x34
    fs->fhp = 0.0f;
 80218c8:	62e3      	str	r3, [r4, #44]	; 0x2c
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
 80218ca:	eef0 0a4a 	vmov.f32	s1, s20
    fs->flp = 0.0f;
 80218ce:	6323      	str	r3, [r4, #48]	; 0x30
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
 80218d0:	eeb0 0a69 	vmov.f32	s0, s19
    fs->fmute = 1.0f;
 80218d4:	6427      	str	r7, [r4, #64]	; 0x40
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
 80218d6:	eee6 7ac7 	vfms.f32	s15, s13, s14
 80218da:	edc4 7a03 	vstr	s15, [r4, #12]
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
 80218de:	f005 fe4f 	bl	8027580 <powf>
    fs->cbi = 0;
 80218e2:	2300      	movs	r3, #0
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
 80218e4:	ed84 0a11 	vstr	s0, [r4, #68]	; 0x44
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
 80218e8:	4631      	mov	r1, r6
    fs->cbi = 0;
 80218ea:	64a3      	str	r3, [r4, #72]	; 0x48
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
 80218ec:	f104 0058 	add.w	r0, r4, #88	; 0x58
    fs->intensity = 1.0f;
 80218f0:	6527      	str	r7, [r4, #80]	; 0x50
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
 80218f2:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
    fs->invIntensity = 1.0f;
 80218f6:	6567      	str	r7, [r4, #84]	; 0x54
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
 80218f8:	f001 f954 	bl	8022ba4 <tHighpass_initToPool>
    tHighpass_initToPool(&fs->hp2, 20.0f, mp);
 80218fc:	4631      	mov	r1, r6
 80218fe:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8021902:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8021906:	f001 f94d 	bl	8022ba4 <tHighpass_initToPool>
    tFeedbackLeveler_initToPool(&fs->fbl1, 0.8f, .005f, 0.125, 1, mp);
 802190a:	4632      	mov	r2, r6
 802190c:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8021910:	eef0 0a68 	vmov.f32	s1, s17
 8021914:	eeb0 0a48 	vmov.f32	s0, s16
 8021918:	2101      	movs	r1, #1
 802191a:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
 802191e:	f7fe fc17 	bl	8020150 <tFeedbackLeveler_initToPool>
    tFeedbackLeveler_initToPool(&fs->fbl2, 0.8f, .005f, 0.125, 1, mp);
 8021922:	eef0 0a68 	vmov.f32	s1, s17
 8021926:	eeb0 0a48 	vmov.f32	s0, s16
 802192a:	4632      	mov	r2, r6
 802192c:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8021930:	2101      	movs	r1, #1
 8021932:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
}
 8021936:	ecbd 8b06 	vpop	{d8-d10}
 802193a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tFeedbackLeveler_initToPool(&fs->fbl2, 0.8f, .005f, 0.125, 1, mp);
 802193e:	f7fe bc07 	b.w	8020150 <tFeedbackLeveler_initToPool>
 8021942:	bf00      	nop
 8021944:	3a83126f 	.word	0x3a83126f
 8021948:	3ba3d70a 	.word	0x3ba3d70a
 802194c:	3f4ccccd 	.word	0x3f4ccccd
 8021950:	3d86d1e1 	.word	0x3d86d1e1
 8021954:	3f5a0903 	.word	0x3f5a0903
 8021958:	3e4432ca 	.word	0x3e4432ca
 802195c:	200194e8 	.word	0x200194e8

08021960 <tFormantShifter_init>:
    tFormantShifter_initToPool(fsr, order, &leaf.mempool);
 8021960:	4a01      	ldr	r2, [pc, #4]	; (8021968 <tFormantShifter_init+0x8>)
 8021962:	f7ff bf41 	b.w	80217e8 <tFormantShifter_initToPool>
 8021966:	bf00      	nop
 8021968:	20019500 	.word	0x20019500

0802196c <tFormantShifter_free>:

void tFormantShifter_free (tFormantShifter* const fsr)
{
 802196c:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;
 802196e:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)fs->fk, fs->mempool);
 8021970:	6821      	ldr	r1, [r4, #0]
 8021972:	6920      	ldr	r0, [r4, #16]
 8021974:	f002 fd54 	bl	8024420 <mpool_free>
    mpool_free((char*)fs->fb, fs->mempool);
 8021978:	6821      	ldr	r1, [r4, #0]
 802197a:	6960      	ldr	r0, [r4, #20]
 802197c:	f002 fd50 	bl	8024420 <mpool_free>
    mpool_free((char*)fs->fc, fs->mempool);
 8021980:	6821      	ldr	r1, [r4, #0]
 8021982:	69a0      	ldr	r0, [r4, #24]
 8021984:	f002 fd4c 	bl	8024420 <mpool_free>
    mpool_free((char*)fs->frb, fs->mempool);
 8021988:	6821      	ldr	r1, [r4, #0]
 802198a:	69e0      	ldr	r0, [r4, #28]
 802198c:	f002 fd48 	bl	8024420 <mpool_free>
    mpool_free((char*)fs->frc, fs->mempool);
 8021990:	6821      	ldr	r1, [r4, #0]
 8021992:	6a20      	ldr	r0, [r4, #32]
 8021994:	f002 fd44 	bl	8024420 <mpool_free>
    mpool_free((char*)fs->fsig, fs->mempool);
 8021998:	6821      	ldr	r1, [r4, #0]
 802199a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802199c:	f002 fd40 	bl	8024420 <mpool_free>
    mpool_free((char*)fs->fsmooth, fs->mempool);
 80219a0:	6821      	ldr	r1, [r4, #0]
 80219a2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80219a4:	f002 fd3c 	bl	8024420 <mpool_free>
    mpool_free((char*)fs->ftvec, fs->mempool);
 80219a8:	6821      	ldr	r1, [r4, #0]
 80219aa:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80219ac:	f002 fd38 	bl	8024420 <mpool_free>
    mpool_free((char*)fs->fbuff, fs->mempool);
 80219b0:	6821      	ldr	r1, [r4, #0]
 80219b2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80219b4:	f002 fd34 	bl	8024420 <mpool_free>
    tHighpass_free(&fs->hp);
 80219b8:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80219bc:	f001 f912 	bl	8022be4 <tHighpass_free>
    tHighpass_free(&fs->hp2);
 80219c0:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 80219c4:	f001 f90e 	bl	8022be4 <tHighpass_free>
    tFeedbackLeveler_free(&fs->fbl1);
 80219c8:	f104 0060 	add.w	r0, r4, #96	; 0x60
 80219cc:	f7fe fbe8 	bl	80201a0 <tFeedbackLeveler_free>
    tFeedbackLeveler_free(&fs->fbl2);
 80219d0:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80219d4:	f7fe fbe4 	bl	80201a0 <tFeedbackLeveler_free>
    mpool_free((char*)fs, fs->mempool);
 80219d8:	6821      	ldr	r1, [r4, #0]
 80219da:	4620      	mov	r0, r4
}
 80219dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)fs, fs->mempool);
 80219e0:	f002 bd1e 	b.w	8024420 <mpool_free>

080219e4 <tFormantShifter_remove>:
{
    return tFormantShifter_add(fsr, tFormantShifter_remove(fsr, in));
}

float tFormantShifter_remove(tFormantShifter* const fsr, float in)
{
 80219e4:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;
 80219e6:	6804      	ldr	r4, [r0, #0]
    in = tFeedbackLeveler_tick(&fs->fbl1, in);
 80219e8:	f104 0060 	add.w	r0, r4, #96	; 0x60
 80219ec:	f7fe fbe8 	bl	80201c0 <tFeedbackLeveler_tick>
    in = tHighpass_tick(&fs->hp, in * fs->intensity);
 80219f0:	edd4 7a14 	vldr	s15, [r4, #80]	; 0x50
 80219f4:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80219f8:	ee20 0a27 	vmul.f32	s0, s0, s15
 80219fc:	f001 f906 	bl	8022c0c <tHighpass_tick>
    

    float fa, fb, fc, foma, falph, ford, flamb, tf, fk;

    ford = fs->ford;
 8021a00:	edd4 7a01 	vldr	s15, [r4, #4]
    foma = (1.0f - falph);
    flamb = fs->flamb;
    
    tf = in;
    
    fa = tf - fs->fhp;
 8021a04:	edd4 6a0b 	vldr	s13, [r4, #44]	; 0x2c
    foma = (1.0f - falph);
 8021a08:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    ford = fs->ford;
 8021a0c:	eef8 3ae7 	vcvt.f32.s32	s7, s15
    falph = fs->falph;
 8021a10:	ed94 5a02 	vldr	s10, [r4, #8]
    fa = tf - fs->fhp;
 8021a14:	ee70 6a66 	vsub.f32	s13, s0, s13
    fs->fhp = tf;
 8021a18:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
    foma = (1.0f - falph);
 8021a1c:	ee75 5ac5 	vsub.f32	s11, s11, s10
    flamb = fs->flamb;
 8021a20:	ed94 3a03 	vldr	s6, [r4, #12]
    fb = fa;
    for(int i = 0; i < ford; i++)
 8021a24:	eef5 3ac0 	vcmpe.f32	s7, #0.0
    fa = tf - fs->fhp;
 8021a28:	eeb0 0a66 	vmov.f32	s0, s13
    for(int i = 0; i < ford; i++)
 8021a2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021a30:	dd53      	ble.n	8021ada <tFormantShifter_remove+0xf6>
 8021a32:	2100      	movs	r1, #0
        fc = (fb - fs->fc[i])*flamb + fs->fb[i];
        fs->fc[i] = fc;
        fs->fb[i] = fb;
        fk = fa*fc*foma + fs->fk[i]*falph;
        fs->fk[i] = fk;
        tf = fk/(fs->fsig[i] + 0.000001f);
 8021a34:	eddf 2a29 	vldr	s5, [pc, #164]	; 8021adc <tFormantShifter_remove+0xf8>
 8021a38:	008b      	lsls	r3, r1, #2
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
 8021a3a:	6a62      	ldr	r2, [r4, #36]	; 0x24
    for(int i = 0; i < ford; i++)
 8021a3c:	3101      	adds	r1, #1
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
 8021a3e:	ee20 7a00 	vmul.f32	s14, s0, s0
 8021a42:	441a      	add	r2, r3
        fk = fa*fc*foma + fs->fk[i]*falph;
 8021a44:	ee25 6a80 	vmul.f32	s12, s11, s0
    for(int i = 0; i < ford; i++)
 8021a48:	ee07 1a90 	vmov	s15, r1
 8021a4c:	eef8 4ae7 	vcvt.f32.s32	s9, s15
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
 8021a50:	edd2 7a00 	vldr	s15, [r2]
 8021a54:	ee65 7a27 	vmul.f32	s15, s10, s15
    for(int i = 0; i < ford; i++)
 8021a58:	eef4 4ae3 	vcmpe.f32	s9, s7
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
 8021a5c:	eee5 7a87 	vfma.f32	s15, s11, s14
    for(int i = 0; i < ford; i++)
 8021a60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
 8021a64:	edc2 7a00 	vstr	s15, [r2]
        fc = (fb - fs->fc[i])*flamb + fs->fb[i];
 8021a68:	e9d4 0205 	ldrd	r0, r2, [r4, #20]
 8021a6c:	441a      	add	r2, r3
 8021a6e:	4418      	add	r0, r3
 8021a70:	edd2 7a00 	vldr	s15, [r2]
 8021a74:	ed90 7a00 	vldr	s14, [r0]
 8021a78:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8021a7c:	eea7 7a83 	vfma.f32	s14, s15, s6
        fs->fc[i] = fc;
 8021a80:	ed82 7a00 	vstr	s14, [r2]
        fs->fb[i] = fb;
 8021a84:	6962      	ldr	r2, [r4, #20]
 8021a86:	441a      	add	r2, r3
 8021a88:	edc2 6a00 	vstr	s13, [r2]
        fk = fa*fc*foma + fs->fk[i]*falph;
 8021a8c:	6922      	ldr	r2, [r4, #16]
 8021a8e:	441a      	add	r2, r3
 8021a90:	edd2 6a00 	vldr	s13, [r2]
 8021a94:	ee65 6a26 	vmul.f32	s13, s10, s13
 8021a98:	eee6 6a07 	vfma.f32	s13, s12, s14
        fs->fk[i] = fk;
 8021a9c:	edc2 6a00 	vstr	s13, [r2]
        tf = tf*foma + fs->fsmooth[i]*falph;
 8021aa0:	e9d4 0209 	ldrd	r0, r2, [r4, #36]	; 0x24
        tf = fk/(fs->fsig[i] + 0.000001f);
 8021aa4:	4418      	add	r0, r3
        tf = tf*foma + fs->fsmooth[i]*falph;
 8021aa6:	441a      	add	r2, r3
        tf = fk/(fs->fsig[i] + 0.000001f);
 8021aa8:	ed90 6a00 	vldr	s12, [r0]
        tf = tf*foma + fs->fsmooth[i]*falph;
 8021aac:	edd2 7a00 	vldr	s15, [r2]
        tf = fk/(fs->fsig[i] + 0.000001f);
 8021ab0:	ee36 6a22 	vadd.f32	s12, s12, s5
        tf = tf*foma + fs->fsmooth[i]*falph;
 8021ab4:	ee65 7a27 	vmul.f32	s15, s10, s15
        tf = fk/(fs->fsig[i] + 0.000001f);
 8021ab8:	ee86 4a86 	vdiv.f32	s8, s13, s12
        fs->fsmooth[i] = tf;
        fs->fbuff[i] = tf;
        fb = fc - tf*fa;
 8021abc:	eef0 6a47 	vmov.f32	s13, s14
        tf = tf*foma + fs->fsmooth[i]*falph;
 8021ac0:	eee5 7a84 	vfma.f32	s15, s11, s8
        fs->fsmooth[i] = tf;
 8021ac4:	edc2 7a00 	vstr	s15, [r2]
        fb = fc - tf*fa;
 8021ac8:	eee7 6ac0 	vfms.f32	s13, s15, s0
        fs->fbuff[i] = tf;
 8021acc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        fa = fa - tf*fc;
 8021ace:	eea7 0a67 	vfms.f32	s0, s14, s15
        fs->fbuff[i] = tf;
 8021ad2:	4413      	add	r3, r2
 8021ad4:	edc3 7a00 	vstr	s15, [r3]
    for(int i = 0; i < ford; i++)
 8021ad8:	d4ae      	bmi.n	8021a38 <tFormantShifter_remove+0x54>
    }

    //return fa * 0.1f;
    return fa;
}
 8021ada:	bd10      	pop	{r4, pc}
 8021adc:	358637bd 	.word	0x358637bd

08021ae0 <tFormantShifter_add>:

float tFormantShifter_add(tFormantShifter* const fsr, float in)
{
 8021ae0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021ae2:	ed2d 8b02 	vpush	{d8}
    _tFormantShifter* fs = *fsr;
 8021ae6:	6804      	ldr	r4, [r0, #0]
    float fa, fb, fc, ford, flpa, flamb, tf, tf2, f0resp, f1resp, frlamb;
    ford = fs->ford;

    flpa = fs->flpa;
    flamb = fs->flamb;
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
 8021ae8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    flamb = fs->flamb;
 8021aec:	edd4 7a03 	vldr	s15, [r4, #12]
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
 8021af0:	ed94 5a13 	vldr	s10, [r4, #76]	; 0x4c
 8021af4:	ee37 6a87 	vadd.f32	s12, s15, s14
    flpa = fs->flpa;
 8021af8:	ed94 3a0d 	vldr	s6, [r4, #52]	; 0x34
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
 8021afc:	ee77 6a67 	vsub.f32	s13, s14, s15
    ford = fs->ford;
 8021b00:	edd4 7a01 	vldr	s15, [r4, #4]
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
 8021b04:	ee26 6a05 	vmul.f32	s12, s12, s10
    ford = fs->ford;
 8021b08:	eef8 5ae7 	vcvt.f32.s32	s11, s15
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
 8021b0c:	eec6 7a26 	vdiv.f32	s15, s12, s13
    frlamb = (tf-1.0f)/(tf+1.0f);
    
    tf2 = in;
    fa = 0.0f;
    fb = fa;
    for (int i=0; i<ford; i++)
 8021b10:	eef5 5ac0 	vcmpe.f32	s11, #0.0
 8021b14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    frlamb = (tf-1.0f)/(tf+1.0f);
 8021b18:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8021b1c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8021b20:	ee86 5aa7 	vdiv.f32	s10, s13, s15
    for (int i=0; i<ford; i++)
 8021b24:	f340 8107 	ble.w	8021d36 <tFormantShifter_add+0x256>
    fb = fa;
 8021b28:	eddf 6a87 	vldr	s13, [pc, #540]	; 8021d48 <tFormantShifter_add+0x268>
    for (int i=0; i<ford; i++)
 8021b2c:	2100      	movs	r1, #0
 8021b2e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    fa = 0.0f;
 8021b30:	eef0 7a66 	vmov.f32	s15, s13
 8021b34:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
 8021b36:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021b38:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
    for (int i=0; i<ford; i++)
 8021b3c:	ee04 1a90 	vmov	s9, r1
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
        fs->ftvec[i] = tf*fc;
 8021b40:	441a      	add	r2, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021b42:	18c6      	adds	r6, r0, r3
 8021b44:	441d      	add	r5, r3
        tf = fs->fbuff[i];
 8021b46:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    for (int i=0; i<ford; i++)
 8021b48:	eef8 4ae4 	vcvt.f32.s32	s9, s9
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021b4c:	ed96 6a00 	vldr	s12, [r6]
 8021b50:	ed95 7a00 	vldr	s14, [r5]
        tf = fs->fbuff[i];
 8021b54:	4418      	add	r0, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021b56:	ee76 6ac6 	vsub.f32	s13, s13, s12
        tf = fs->fbuff[i];
 8021b5a:	ed90 6a00 	vldr	s12, [r0]
    for (int i=0; i<ford; i++)
 8021b5e:	eef4 4ae5 	vcmpe.f32	s9, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021b62:	eea6 7a85 	vfma.f32	s14, s13, s10
    for (int i=0; i<ford; i++)
 8021b66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->ftvec[i] = tf*fc;
 8021b6a:	ee27 4a06 	vmul.f32	s8, s14, s12
        fb = fc - tf*fa;
 8021b6e:	eea6 7a67 	vfms.f32	s14, s12, s15
        fs->ftvec[i] = tf*fc;
 8021b72:	ed82 4a00 	vstr	s8, [r2]
        fa = fa - fs->ftvec[i];
 8021b76:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8021b78:	4413      	add	r3, r2
        fb = fc - tf*fa;
 8021b7a:	eef0 6a47 	vmov.f32	s13, s14
        fa = fa - fs->ftvec[i];
 8021b7e:	ed93 7a00 	vldr	s14, [r3]
 8021b82:	ee77 7ac7 	vsub.f32	s15, s15, s14
    for (int i=0; i<ford; i++)
 8021b86:	d4d5      	bmi.n	8021b34 <tFormantShifter_add+0x54>
 8021b88:	eeb1 7a67 	vneg.f32	s14, s15
    }
    tf = -fa;
    for (int i=ford-1; i>=0; i--)
 8021b8c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8021b90:	ee75 7ae7 	vsub.f32	s15, s11, s15
 8021b94:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8021b98:	ee17 7a90 	vmov	r7, s15
 8021b9c:	2f00      	cmp	r7, #0
 8021b9e:	f2c0 80c2 	blt.w	8021d26 <tFormantShifter_add+0x246>
    {
        tf = tf + fs->ftvec[i];
 8021ba2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8021ba4:	1c7b      	adds	r3, r7, #1
 8021ba6:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 8021baa:	ed71 7a01 	vldmdb	r1!, {s15}
    for (int i=ford-1; i>=0; i--)
 8021bae:	428a      	cmp	r2, r1
        tf = tf + fs->ftvec[i];
 8021bb0:	ee37 7a27 	vadd.f32	s14, s14, s15
    for (int i=ford-1; i>=0; i--)
 8021bb4:	d1f9      	bne.n	8021baa <tFormantShifter_add+0xca>
    f0resp = tf;
    
    //  second time: compute 1-response
    fa = 1.0f;
    fb = fa;
    for (int i=0; i<ford; i++)
 8021bb6:	eef5 5ac0 	vcmpe.f32	s11, #0.0
 8021bba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021bbe:	f340 80bf 	ble.w	8021d40 <tFormantShifter_add+0x260>
    fb = fa;
 8021bc2:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    for (int i=0; i<ford; i++)
 8021bc6:	2100      	movs	r1, #0
    fa = 1.0f;
 8021bc8:	eef0 7a46 	vmov.f32	s15, s12
 8021bcc:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
 8021bce:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021bd0:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
    for (int i=0; i<ford; i++)
 8021bd4:	ee04 1a10 	vmov	s8, r1
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
        fs->ftvec[i] = tf*fc;
 8021bd8:	441a      	add	r2, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021bda:	18c6      	adds	r6, r0, r3
 8021bdc:	441d      	add	r5, r3
        tf = fs->fbuff[i];
 8021bde:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    for (int i=0; i<ford; i++)
 8021be0:	eeb8 4ac4 	vcvt.f32.s32	s8, s8
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021be4:	edd6 4a00 	vldr	s9, [r6]
 8021be8:	edd5 6a00 	vldr	s13, [r5]
        tf = fs->fbuff[i];
 8021bec:	4418      	add	r0, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021bee:	ee36 6a64 	vsub.f32	s12, s12, s9
        tf = fs->fbuff[i];
 8021bf2:	edd0 4a00 	vldr	s9, [r0]
    for (int i=0; i<ford; i++)
 8021bf6:	eeb4 4ae5 	vcmpe.f32	s8, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021bfa:	eee6 6a05 	vfma.f32	s13, s12, s10
    for (int i=0; i<ford; i++)
 8021bfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->ftvec[i] = tf*fc;
 8021c02:	ee66 3aa4 	vmul.f32	s7, s13, s9
        fb = fc - tf*fa;
 8021c06:	eee4 6ae7 	vfms.f32	s13, s9, s15
        fs->ftvec[i] = tf*fc;
 8021c0a:	edc2 3a00 	vstr	s7, [r2]
        fa = fa - fs->ftvec[i];
 8021c0e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8021c10:	4413      	add	r3, r2
        fb = fc - tf*fa;
 8021c12:	eeb0 6a66 	vmov.f32	s12, s13
        fa = fa - fs->ftvec[i];
 8021c16:	edd3 6a00 	vldr	s13, [r3]
 8021c1a:	ee77 7ae6 	vsub.f32	s15, s15, s13
    for (int i=0; i<ford; i++)
 8021c1e:	d4d5      	bmi.n	8021bcc <tFormantShifter_add+0xec>
    }
    tf = -fa;
    for (int i=ford-1; i>=0; i--)
 8021c20:	2f00      	cmp	r7, #0
 8021c22:	eef1 7a67 	vneg.f32	s15, s15
 8021c26:	db08      	blt.n	8021c3a <tFormantShifter_add+0x15a>
 8021c28:	1c7b      	adds	r3, r7, #1
 8021c2a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    {
        tf = tf + fs->ftvec[i];
 8021c2e:	ed73 6a01 	vldmdb	r3!, {s13}
    for (int i=ford-1; i>=0; i--)
 8021c32:	429a      	cmp	r2, r3
        tf = tf + fs->ftvec[i];
 8021c34:	ee77 7aa6 	vadd.f32	s15, s15, s13
    for (int i=ford-1; i>=0; i--)
 8021c38:	d1f9      	bne.n	8021c2e <tFormantShifter_add+0x14e>
    f1resp = tf;
    
    //  now solve equations for output, based on 0-response and 1-response
    tf = 2.0f*tf2;
    tf2 = tf;
    tf = (1.0f - f1resp + f0resp);
 8021c3a:	ee77 7a67 	vsub.f32	s15, s14, s15
    if (tf!=0.0f)
 8021c3e:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
 8021c42:	eef4 7a66 	vcmp.f32	s15, s13
 8021c46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021c4a:	d066      	beq.n	8021d1a <tFormantShifter_add+0x23a>
    {
        tf2 = (tf2 + f0resp) / tf;
 8021c4c:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
    tf = (1.0f - f1resp + f0resp);
 8021c50:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
        tf2 = (tf2 + f0resp) / tf;
 8021c54:	eea0 7a06 	vfma.f32	s14, s0, s12
    tf = (1.0f - f1resp + f0resp);
 8021c58:	ee77 7aa6 	vadd.f32	s15, s15, s13
        tf2 = (tf2 + f0resp) / tf;
 8021c5c:	ee87 0a27 	vdiv.f32	s0, s14, s15
    }
    
    //  third time: update delay registers
    fa = tf2;
    fb = fa;
    for (int i=0; i<ford; i++)
 8021c60:	eef5 5ac0 	vcmpe.f32	s11, #0.0
 8021c64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021c68:	dd2b      	ble.n	8021cc2 <tFormantShifter_add+0x1e2>
    fb = fa;
 8021c6a:	eeb0 6a40 	vmov.f32	s12, s0
    for (int i=0; i<ford; i++)
 8021c6e:	2100      	movs	r1, #0
    fa = tf2;
 8021c70:	eef0 6a40 	vmov.f32	s13, s0
 8021c74:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
 8021c76:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021c78:	e9d4 0207 	ldrd	r0, r2, [r4, #28]
    for (int i=0; i<ford; i++)
 8021c7c:	ee07 1a90 	vmov	s15, r1
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021c80:	441a      	add	r2, r3
 8021c82:	4418      	add	r0, r3
    for (int i=0; i<ford; i++)
 8021c84:	eef8 4ae7 	vcvt.f32.s32	s9, s15
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021c88:	ed92 7a00 	vldr	s14, [r2]
 8021c8c:	edd0 7a00 	vldr	s15, [r0]
 8021c90:	ee36 7a47 	vsub.f32	s14, s12, s14
    for (int i=0; i<ford; i++)
 8021c94:	eef4 4ae5 	vcmpe.f32	s9, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8021c98:	eee7 7a05 	vfma.f32	s15, s14, s10
    for (int i=0; i<ford; i++)
 8021c9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->frc[i] = fc;
 8021ca0:	edc2 7a00 	vstr	s15, [r2]
        fs->frb[i] = fb;
 8021ca4:	69e2      	ldr	r2, [r4, #28]
 8021ca6:	441a      	add	r2, r3
 8021ca8:	ed82 6a00 	vstr	s12, [r2]
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
 8021cac:	eeb0 6a67 	vmov.f32	s12, s15
        tf = fs->fbuff[i];
 8021cb0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8021cb2:	4413      	add	r3, r2
 8021cb4:	ed93 7a00 	vldr	s14, [r3]
        fb = fc - tf*fa;
 8021cb8:	eea7 6a66 	vfms.f32	s12, s14, s13
        fa = fa - tf*fc;
 8021cbc:	eee7 6ac7 	vfms.f32	s13, s15, s14
    for (int i=0; i<ford; i++)
 8021cc0:	d4d8      	bmi.n	8021c74 <tFormantShifter_add+0x194>
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
    fs->flp = tf;
    
    // Bring up the gain slowly when formant correction goes from disabled
    // to enabled, while things stabilize.
    if (fs->fmute>0.5f)
 8021cc2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
 8021cc6:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
    if (fs->fmute>0.5f)
 8021cca:	ed94 8a10 	vldr	s16, [r4, #64]	; 0x40
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
 8021cce:	eea7 0a03 	vfma.f32	s0, s14, s6
    if (fs->fmute>0.5f)
 8021cd2:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8021cd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    fs->flp = tf;
 8021cda:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    if (fs->fmute>0.5f)
 8021cde:	dd1f      	ble.n	8021d20 <tFormantShifter_add+0x240>
    {
        tf = tf*(fs->fmute - 0.5f)*2.0f;
 8021ce0:	ee78 7a67 	vsub.f32	s15, s16, s15
 8021ce4:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8021ce8:	ee27 0a80 	vmul.f32	s0, s15, s0
 8021cec:	f005 fdae 	bl	802784c <tanhf>
    else
    {
        tf = 0.0f;
    }
    tf2 = fs->fmutealph;
    fs->fmute = (1.0f-tf2) + tf2*fs->fmute;
 8021cf0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8021cf4:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
    // now tf is signal output
    // ...and we're done messing with formants
    //tf = tFeedbackLeveler_tick(&fs->fbl2, tf);
    tf = tHighpass_tick(&fs->hp2, tanhf(tf));
 8021cf8:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    fs->fmute = (1.0f-tf2) + tf2*fs->fmute;
 8021cfc:	ee38 8a67 	vsub.f32	s16, s16, s15
 8021d00:	eee8 7a07 	vfma.f32	s15, s16, s14
 8021d04:	edc4 7a10 	vstr	s15, [r4, #64]	; 0x40
    tf = tHighpass_tick(&fs->hp2, tanhf(tf));
 8021d08:	f000 ff80 	bl	8022c0c <tHighpass_tick>

    return tf * fs->invIntensity;
 8021d0c:	edd4 7a15 	vldr	s15, [r4, #84]	; 0x54
}
 8021d10:	ecbd 8b02 	vpop	{d8}
    return tf * fs->invIntensity;
 8021d14:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 8021d18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        tf2 = 0.0f;
 8021d1a:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 8021d48 <tFormantShifter_add+0x268>
 8021d1e:	e79f      	b.n	8021c60 <tFormantShifter_add+0x180>
 8021d20:	ed9f 0a09 	vldr	s0, [pc, #36]	; 8021d48 <tFormantShifter_add+0x268>
 8021d24:	e7e4      	b.n	8021cf0 <tFormantShifter_add+0x210>
    for (int i=0; i<ford; i++)
 8021d26:	eef5 5ac0 	vcmpe.f32	s11, #0.0
 8021d2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021d2e:	dc05      	bgt.n	8021d3c <tFormantShifter_add+0x25c>
 8021d30:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8021d34:	e781      	b.n	8021c3a <tFormantShifter_add+0x15a>
    for (int i=0; i<ford; i++)
 8021d36:	ed9f 7a04 	vldr	s14, [pc, #16]	; 8021d48 <tFormantShifter_add+0x268>
 8021d3a:	e727      	b.n	8021b8c <tFormantShifter_add+0xac>
 8021d3c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8021d3e:	e740      	b.n	8021bc2 <tFormantShifter_add+0xe2>
    for (int i=0; i<ford; i++)
 8021d40:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8021d44:	e771      	b.n	8021c2a <tFormantShifter_add+0x14a>
 8021d46:	bf00      	nop
 8021d48:	00000000 	.word	0x00000000

08021d4c <tFormantShifter_setShiftFactor>:

// 1.0f is no change, 2.0f is an octave up, 0.5f is an octave down
void tFormantShifter_setShiftFactor(tFormantShifter* const fsr, float shiftFactor)
{
    _tFormantShifter* fs = *fsr;
 8021d4c:	6803      	ldr	r3, [r0, #0]
    fs->shiftFactor = shiftFactor;
 8021d4e:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
 8021d52:	4770      	bx	lr

08021d54 <tFormantShifter_setIntensity>:

void tFormantShifter_setIntensity(tFormantShifter* const fsr, float intensity)
{
 8021d54:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;



    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
 8021d56:	eef0 0a40 	vmov.f32	s1, s0
 8021d5a:	ed9f 1a0d 	vldr	s2, [pc, #52]	; 8021d90 <tFormantShifter_setIntensity+0x3c>
 8021d5e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    _tFormantShifter* fs = *fsr;
 8021d62:	6804      	ldr	r4, [r0, #0]
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
 8021d64:	f002 f8a6 	bl	8023eb4 <LEAF_clip>

   // tFeedbackLeveler_setTargetLevel(&fs->fbl1, fs->intensity);
    //tFeedbackLeveler_setTargetLevel(&fs->fbl2, fs->intensity);
    //make sure you don't divide by zero, doofies
    if (fs->intensity != 0.0f)
 8021d68:	eeb5 0a40 	vcmp.f32	s0, #0.0
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
 8021d6c:	ed84 0a14 	vstr	s0, [r4, #80]	; 0x50
    if (fs->intensity != 0.0f)
 8021d70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021d74:	d104      	bne.n	8021d80 <tFormantShifter_setIntensity+0x2c>
    {
        fs->invIntensity = 1.0f/fs->intensity;
    }
    else
    {
        fs->invIntensity = 1.0f;
 8021d76:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8021d7a:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
    }

}
 8021d7e:	bd10      	pop	{r4, pc}
        fs->invIntensity = 1.0f/fs->intensity;
 8021d80:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8021d84:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8021d88:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
}
 8021d8c:	bd10      	pop	{r4, pc}
 8021d8e:	bf00      	nop
 8021d90:	42c80000 	.word	0x42c80000

08021d94 <tADSR4_init>:


/* ADSR 4 */ // new version of our original table-based ADSR but with the table passed in by the user
// use this if the size of the big ADSR tables is too much.
void    tADSR4_init    (tADSR4* const adsrenv, float attack, float decay, float sustain, float release, float* expBuffer, int bufferSize)
{
 8021d94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

//initialize with an exponential function that decays -- i.e. a call to LEAF_generate_exp(expBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, EXP_BUFFER_SIZE);
//times are in ms
void    tADSR4_initToPool    (tADSR4* const adsrenv, float attack, float decay, float sustain, float release, float* expBuffer, int bufferSize, tMempool* const mp)
{
    _tMempool* m = *mp;
 8021d98:	4d29      	ldr	r5, [pc, #164]	; (8021e40 <tADSR4_init+0xac>)
{
 8021d9a:	4614      	mov	r4, r2
 8021d9c:	4680      	mov	r8, r0
 8021d9e:	460f      	mov	r7, r1
    _tMempool* m = *mp;
 8021da0:	69ae      	ldr	r6, [r5, #24]
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
 8021da2:	2050      	movs	r0, #80	; 0x50
{
 8021da4:	ed2d 8b04 	vpush	{d8-d9}
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
 8021da8:	4631      	mov	r1, r6
{
 8021daa:	eef0 8a61 	vmov.f32	s17, s3
 8021dae:	eef0 9a40 	vmov.f32	s19, s0
 8021db2:	eeb0 9a60 	vmov.f32	s18, s1
 8021db6:	eeb0 8a41 	vmov.f32	s16, s2
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
 8021dba:	f002 fa7d 	bl	80242b8 <mpool_alloc>

    adsr->exp_buff = expBuffer;
    adsr->buff_size = bufferSize;
    adsr->buff_sizeMinusOne = bufferSize - 1;

    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 8021dbe:	eddf 7a21 	vldr	s15, [pc, #132]	; 8021e44 <tADSR4_init+0xb0>
 8021dc2:	ee07 4a10 	vmov	s14, r4
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
 8021dc6:	f8c8 0000 	str.w	r0, [r8]

    adsr->next = 0.0f;

    adsr->whichStage = env_idle;

    adsr->sustain = sustain;
 8021dca:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    adsr->mempool = m;
 8021dce:	6006      	str	r6, [r0, #0]
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 8021dd0:	eeb8 5ac7 	vcvt.f32.s32	s10, s14
 8021dd4:	edd5 6a00 	vldr	s13, [r5]

    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
 8021dd8:	eef4 5a00 	vmov.f32	s11, #64	; 0x3e000000  0.125
    adsr->next = 0.0f;
 8021ddc:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 8021e48 <tADSR4_init+0xb4>
    adsr->buff_sizeMinusOne = bufferSize - 1;
 8021de0:	1e62      	subs	r2, r4, #1
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 8021de2:	ee66 6aa7 	vmul.f32	s13, s13, s15

    adsr->leakFactor = 1.0f;
 8021de6:	ed80 6a13 	vstr	s12, [r0, #76]	; 0x4c
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
 8021dea:	fec9 9a87 	vmaxnm.f32	s19, s19, s14
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
 8021dee:	fe89 9a07 	vmaxnm.f32	s18, s18, s14
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
 8021df2:	fec8 1a87 	vmaxnm.f32	s3, s17, s14
    adsr->sustain = sustain;
 8021df6:	fe88 8a07 	vmaxnm.f32	s16, s16, s14
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 8021dfa:	eec5 7a26 	vdiv.f32	s15, s10, s13
    adsr->sustain = sustain;
 8021dfe:	fe88 8a46 	vminnm.f32	s16, s16, s12
    adsr->next = 0.0f;
 8021e02:	ed80 7a05 	vstr	s14, [r0, #20]
    adsr->whichStage = env_idle;
 8021e06:	2300      	movs	r3, #0
    adsr->exp_buff = expBuffer;
 8021e08:	6047      	str	r7, [r0, #4]
    adsr->buff_size = bufferSize;
 8021e0a:	6084      	str	r4, [r0, #8]
    adsr->buff_sizeMinusOne = bufferSize - 1;
 8021e0c:	60c2      	str	r2, [r0, #12]
    adsr->whichStage = env_idle;
 8021e0e:	6283      	str	r3, [r0, #40]	; 0x28
    adsr->sustain = sustain;
 8021e10:	ed80 8a0b 	vstr	s16, [r0, #44]	; 0x2c
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
 8021e14:	ee87 6aa9 	vdiv.f32	s12, s15, s19
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 8021e18:	edc0 7a04 	vstr	s15, [r0, #16]
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
 8021e1c:	eec7 6a89 	vdiv.f32	s13, s15, s18
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
 8021e20:	ee87 7aa1 	vdiv.f32	s14, s15, s3
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
 8021e24:	ee67 7aa5 	vmul.f32	s15, s15, s11
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
 8021e28:	ed80 6a06 	vstr	s12, [r0, #24]
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
 8021e2c:	edc0 7a09 	vstr	s15, [r0, #36]	; 0x24
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
 8021e30:	edc0 6a07 	vstr	s13, [r0, #28]
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
 8021e34:	ed80 7a08 	vstr	s14, [r0, #32]
}
 8021e38:	ecbd 8b04 	vpop	{d8-d9}
 8021e3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021e40:	200194e8 	.word	0x200194e8
 8021e44:	3a83126f 	.word	0x3a83126f
 8021e48:	00000000 	.word	0x00000000

08021e4c <tADSR4_free>:
}

void    tADSR4_free  (tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
 8021e4c:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)adsr, adsr->mempool);
 8021e4e:	6801      	ldr	r1, [r0, #0]
 8021e50:	f002 bae6 	b.w	8024420 <mpool_free>

08021e54 <tADSR4_setAttack>:
}

void     tADSR4_setAttack(tADSR4* const adsrenv, float attack)
{
    _tADSR4* adsr = *adsrenv;
 8021e54:	6803      	ldr	r3, [r0, #0]
    if (attack < 0.0f)
    {
        attack = 0.0f;
    }

    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
 8021e56:	eddf 7a05 	vldr	s15, [pc, #20]	; 8021e6c <tADSR4_setAttack+0x18>
 8021e5a:	ed93 7a04 	vldr	s14, [r3, #16]
 8021e5e:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
 8021e62:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8021e66:	edc3 7a06 	vstr	s15, [r3, #24]
}
 8021e6a:	4770      	bx	lr
 8021e6c:	00000000 	.word	0x00000000

08021e70 <tADSR4_setDecay>:

void     tADSR4_setDecay(tADSR4* const adsrenv, float decay)
{
    _tADSR4* adsr = *adsrenv;
 8021e70:	6803      	ldr	r3, [r0, #0]

    if (decay < 0.0f)
    {
        decay = 0.0f;
    }
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
 8021e72:	eddf 7a05 	vldr	s15, [pc, #20]	; 8021e88 <tADSR4_setDecay+0x18>
 8021e76:	ed93 7a04 	vldr	s14, [r3, #16]
 8021e7a:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
 8021e7e:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8021e82:	edc3 7a07 	vstr	s15, [r3, #28]
}
 8021e86:	4770      	bx	lr
 8021e88:	00000000 	.word	0x00000000

08021e8c <tADSR4_setSustain>:

void     tADSR4_setSustain(tADSR4* const adsrenv, float sustain)
{
    _tADSR4* adsr = *adsrenv;

    if (sustain > 1.0f)      adsr->sustain = 1.0f;
 8021e8c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tADSR4* adsr = *adsrenv;
 8021e90:	6803      	ldr	r3, [r0, #0]
    if (sustain > 1.0f)      adsr->sustain = 1.0f;
 8021e92:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8021e96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021e9a:	dd02      	ble.n	8021ea2 <tADSR4_setSustain+0x16>
 8021e9c:	edc3 7a0b 	vstr	s15, [r3, #44]	; 0x2c
 8021ea0:	4770      	bx	lr
    else if (sustain < 0.0f) adsr->sustain = 0.0f;
 8021ea2:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8021ea6:	2200      	movs	r2, #0
 8021ea8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021eac:	bf4c      	ite	mi
 8021eae:	62da      	strmi	r2, [r3, #44]	; 0x2c
    else                     adsr->sustain = sustain;
 8021eb0:	ed83 0a0b 	vstrpl	s0, [r3, #44]	; 0x2c
}
 8021eb4:	4770      	bx	lr
 8021eb6:	bf00      	nop

08021eb8 <tADSR4_setRelease>:

void     tADSR4_setRelease(tADSR4* const adsrenv, float release)
{
    _tADSR4* adsr = *adsrenv;
 8021eb8:	6803      	ldr	r3, [r0, #0]

    if (release < 0.0f)
    {
        release = 0.0f;
    }
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
 8021eba:	eddf 7a05 	vldr	s15, [pc, #20]	; 8021ed0 <tADSR4_setRelease+0x18>
 8021ebe:	ed93 7a04 	vldr	s14, [r3, #16]
 8021ec2:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
 8021ec6:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8021eca:	edc3 7a08 	vstr	s15, [r3, #32]
}
 8021ece:	4770      	bx	lr
 8021ed0:	00000000 	.word	0x00000000

08021ed4 <tADSR4_setLeakFactor>:

// 0.999999 is slow leak, 0.9 is fast leak
void     tADSR4_setLeakFactor(tADSR4* const adsrenv, float leakFactor)
{
    _tADSR4* adsr = *adsrenv;
 8021ed4:	6803      	ldr	r3, [r0, #0]


    adsr->leakFactor = leakFactor;
 8021ed6:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
 8021eda:	4770      	bx	lr

08021edc <tADSR4_on>:

void tADSR4_on(tADSR4* const adsrenv, float velocity)
{
    _tADSR4* adsr = *adsrenv;
 8021edc:	6803      	ldr	r3, [r0, #0]

    if (adsr->whichStage != env_idle) // In case ADSR retriggered while it is still happening.
 8021ede:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8021ee0:	b942      	cbnz	r2, 8021ef4 <tADSR4_on+0x18>
        adsr->whichStage = env_ramp;
        adsr->rampPeak = adsr->next;
    }
    else // Normal start.
    {
        adsr->whichStage = env_attack;
 8021ee2:	2101      	movs	r1, #1
    }

    adsr->attackPhase = 0;
 8021ee4:	2200      	movs	r2, #0
 8021ee6:	6299      	str	r1, [r3, #40]	; 0x28
    adsr->decayPhase = 0;
    adsr->releasePhase = 0;
    adsr->gain = velocity;
 8021ee8:	ed83 0a0c 	vstr	s0, [r3, #48]	; 0x30
    adsr->attackPhase = 0;
 8021eec:	63da      	str	r2, [r3, #60]	; 0x3c
    adsr->decayPhase = 0;
 8021eee:	641a      	str	r2, [r3, #64]	; 0x40
    adsr->releasePhase = 0;
 8021ef0:	645a      	str	r2, [r3, #68]	; 0x44
}
 8021ef2:	4770      	bx	lr
        adsr->rampPhase = 0;
 8021ef4:	2000      	movs	r0, #0
        adsr->rampPeak = adsr->next;
 8021ef6:	695a      	ldr	r2, [r3, #20]
        adsr->whichStage = env_ramp;
 8021ef8:	2105      	movs	r1, #5
        adsr->rampPhase = 0;
 8021efa:	6498      	str	r0, [r3, #72]	; 0x48
        adsr->rampPeak = adsr->next;
 8021efc:	635a      	str	r2, [r3, #52]	; 0x34
 8021efe:	e7f1      	b.n	8021ee4 <tADSR4_on+0x8>

08021f00 <tADSR4_off>:

void tADSR4_off(tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
 8021f00:	6803      	ldr	r3, [r0, #0]

    if (adsr->whichStage == env_idle)
 8021f02:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8021f04:	b11a      	cbz	r2, 8021f0e <tADSR4_off+0xe>
    {
        return;
    }
    else
    {
        adsr->whichStage = env_release;
 8021f06:	2104      	movs	r1, #4
        adsr->releasePeak = adsr->next;
 8021f08:	695a      	ldr	r2, [r3, #20]
        adsr->whichStage = env_release;
 8021f0a:	6299      	str	r1, [r3, #40]	; 0x28
        adsr->releasePeak = adsr->next;
 8021f0c:	639a      	str	r2, [r3, #56]	; 0x38
    }
}
 8021f0e:	4770      	bx	lr

08021f10 <tADSR4_tick>:

float   tADSR4_tick(tADSR4* const adsrenv)
{
 8021f10:	b510      	push	{r4, lr}
    _tADSR4* adsr = *adsrenv;
 8021f12:	6804      	ldr	r4, [r0, #0]
{
 8021f14:	ed2d 8b02 	vpush	{d8}

    switch (adsr->whichStage)
 8021f18:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8021f1a:	3b01      	subs	r3, #1
 8021f1c:	2b04      	cmp	r3, #4
 8021f1e:	f200 808c 	bhi.w	802203a <tADSR4_tick+0x12a>
 8021f22:	e8df f003 	tbb	[pc, r3]
 8021f26:	4b22      	.short	0x4b22
 8021f28:	6b3e      	.short	0x6b3e
 8021f2a:	03          	.byte	0x03
 8021f2b:	00          	.byte	0x00
    {
        case env_ramp:
            if (adsr->rampPhase > adsr->buff_sizeMinusOne)
 8021f2c:	edd4 7a03 	vldr	s15, [r4, #12]
 8021f30:	ed94 1a12 	vldr	s2, [r4, #72]	; 0x48
 8021f34:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8021f38:	eeb4 1ae7 	vcmpe.f32	s2, s15
 8021f3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021f40:	f340 80e3 	ble.w	802210a <tADSR4_tick+0x1fa>
            {
                adsr->whichStage = env_attack;
                adsr->next = 0.0f;
 8021f44:	eddf 7aa0 	vldr	s15, [pc, #640]	; 80221c8 <tADSR4_tick+0x2b8>
                adsr->whichStage = env_attack;
 8021f48:	2301      	movs	r3, #1
 8021f4a:	eeb0 8a67 	vmov.f32	s16, s15
 8021f4e:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = 0.0f;
 8021f50:	edc4 7a05 	vstr	s15, [r4, #20]
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->rampPhase)+1)];
                }
                adsr->next = adsr->rampPeak * LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart);
            }

            adsr->rampPhase += adsr->rampInc;
 8021f54:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
            // Increment envelope release;
            adsr->releasePhase += adsr->releaseInc;
            break;
    }
    return adsr->next;
}
 8021f58:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->rampPhase += adsr->rampInc;
 8021f5c:	ee37 1a81 	vadd.f32	s2, s15, s2
 8021f60:	ed84 1a12 	vstr	s2, [r4, #72]	; 0x48
}
 8021f64:	ecbd 8b02 	vpop	{d8}
 8021f68:	bd10      	pop	{r4, pc}
            if (adsr->attackPhase > adsr->buff_sizeMinusOne)
 8021f6a:	edd4 7a03 	vldr	s15, [r4, #12]
 8021f6e:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
 8021f72:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8021f76:	ed94 8a0c 	vldr	s16, [r4, #48]	; 0x30
 8021f7a:	eeb4 1ae7 	vcmpe.f32	s2, s15
 8021f7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021f82:	dd61      	ble.n	8022048 <tADSR4_tick+0x138>
                adsr->whichStage = env_decay;
 8021f84:	2302      	movs	r3, #2
                adsr->next = adsr->gain;
 8021f86:	ed84 8a05 	vstr	s16, [r4, #20]
                adsr->whichStage = env_decay;
 8021f8a:	62a3      	str	r3, [r4, #40]	; 0x28
            adsr->attackPhase += adsr->attackInc;
 8021f8c:	edd4 7a06 	vldr	s15, [r4, #24]
}
 8021f90:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->attackPhase += adsr->attackInc;
 8021f94:	ee37 1a81 	vadd.f32	s2, s15, s2
 8021f98:	ed84 1a0f 	vstr	s2, [r4, #60]	; 0x3c
}
 8021f9c:	ecbd 8b02 	vpop	{d8}
 8021fa0:	bd10      	pop	{r4, pc}
            adsr->next = adsr->next * adsr->leakFactor;
 8021fa2:	ed94 8a05 	vldr	s16, [r4, #20]
 8021fa6:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
 8021faa:	ee28 8a27 	vmul.f32	s16, s16, s15
}
 8021fae:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->next = adsr->next * adsr->leakFactor;
 8021fb2:	ed84 8a05 	vstr	s16, [r4, #20]
}
 8021fb6:	ecbd 8b02 	vpop	{d8}
 8021fba:	bd10      	pop	{r4, pc}
            if (adsr->decayPhase > adsr->buff_sizeMinusOne)
 8021fbc:	edd4 7a03 	vldr	s15, [r4, #12]
 8021fc0:	ed94 1a10 	vldr	s2, [r4, #64]	; 0x40
 8021fc4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8021fc8:	eeb4 1ae7 	vcmpe.f32	s2, s15
 8021fcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021fd0:	dd66      	ble.n	80220a0 <tADSR4_tick+0x190>
                adsr->next = adsr->gain * adsr->sustain;
 8021fd2:	ed94 8a0c 	vldr	s16, [r4, #48]	; 0x30
                adsr->whichStage = env_sustain;
 8021fd6:	2303      	movs	r3, #3
                adsr->next = adsr->gain * adsr->sustain;
 8021fd8:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
                adsr->whichStage = env_sustain;
 8021fdc:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = adsr->gain * adsr->sustain;
 8021fde:	ee28 8a27 	vmul.f32	s16, s16, s15
 8021fe2:	ed84 8a05 	vstr	s16, [r4, #20]
            adsr->decayPhase += adsr->decayInc;
 8021fe6:	edd4 7a07 	vldr	s15, [r4, #28]
}
 8021fea:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->decayPhase += adsr->decayInc;
 8021fee:	ee37 1a81 	vadd.f32	s2, s15, s2
 8021ff2:	ed84 1a10 	vstr	s2, [r4, #64]	; 0x40
}
 8021ff6:	ecbd 8b02 	vpop	{d8}
 8021ffa:	bd10      	pop	{r4, pc}
            if (adsr->releasePhase > adsr->buff_sizeMinusOne)
 8021ffc:	edd4 7a03 	vldr	s15, [r4, #12]
 8022000:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
 8022004:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8022008:	eeb4 1ae7 	vcmpe.f32	s2, s15
 802200c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022010:	f340 80a4 	ble.w	802215c <tADSR4_tick+0x24c>
                adsr->next = 0.0f;
 8022014:	eddf 7a6c 	vldr	s15, [pc, #432]	; 80221c8 <tADSR4_tick+0x2b8>
                adsr->whichStage = env_idle;
 8022018:	2300      	movs	r3, #0
 802201a:	eeb0 8a67 	vmov.f32	s16, s15
 802201e:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = 0.0f;
 8022020:	edc4 7a05 	vstr	s15, [r4, #20]
            adsr->releasePhase += adsr->releaseInc;
 8022024:	edd4 7a08 	vldr	s15, [r4, #32]
}
 8022028:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->releasePhase += adsr->releaseInc;
 802202c:	ee37 1a81 	vadd.f32	s2, s15, s2
 8022030:	ed84 1a11 	vstr	s2, [r4, #68]	; 0x44
}
 8022034:	ecbd 8b02 	vpop	{d8}
 8022038:	bd10      	pop	{r4, pc}
 802203a:	ed94 8a05 	vldr	s16, [r4, #20]
 802203e:	eeb0 0a48 	vmov.f32	s0, s16
 8022042:	ecbd 8b02 	vpop	{d8}
 8022046:	bd10      	pop	{r4, pc}
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
 8022048:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802204c:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->attackPhase;
 802204e:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
 8022052:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->attackPhase - intPart;
 8022056:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
 802205a:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->attackPhase - intPart;
 802205e:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
 8022062:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022066:	f100 80ab 	bmi.w	80221c0 <tADSR4_tick+0x2b0>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->attackPhase)+1)];
 802206a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 802206e:	ee17 3a90 	vmov	r3, s15
 8022072:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8022076:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->gain * (1.0f - LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart)); // inverted and backwards to get proper rising exponential shape/perception
 802207a:	ee16 3a90 	vmov	r3, s13
 802207e:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8022082:	ed92 0a00 	vldr	s0, [r2]
 8022086:	f002 f84d 	bl	8024124 <LEAF_interpolation_linear>
 802208a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802208e:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
 8022092:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8022096:	ee28 8a00 	vmul.f32	s16, s16, s0
 802209a:	ed84 8a05 	vstr	s16, [r4, #20]
 802209e:	e775      	b.n	8021f8c <tADSR4_tick+0x7c>
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
 80220a0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80220a4:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->decayPhase;
 80220a6:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
 80220aa:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->decayPhase - intPart;
 80220ae:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
 80220b2:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->decayPhase - intPart;
 80220b6:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
 80220ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80220be:	d47c      	bmi.n	80221ba <tADSR4_tick+0x2aa>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->decayPhase)+1)];
 80220c0:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 80220c4:	ee17 3a90 	vmov	r3, s15
 80220c8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80220cc:	edd3 0a00 	vldr	s1, [r3]
                float interpValue = (LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart));
 80220d0:	ee16 3a90 	vmov	r3, s13
 80220d4:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80220d8:	ed92 0a00 	vldr	s0, [r2]
 80220dc:	f002 f822 	bl	8024124 <LEAF_interpolation_linear>
                adsr->next = (adsr->gain * (adsr->sustain + (interpValue * (1.0f - adsr->sustain)))) * adsr->leakFactor; // do interpolation !
 80220e0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80220e4:	ed94 8a0b 	vldr	s16, [r4, #44]	; 0x2c
 80220e8:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 80220ec:	ee37 7a48 	vsub.f32	s14, s14, s16
 80220f0:	edd4 6a13 	vldr	s13, [r4, #76]	; 0x4c
 80220f4:	ed94 1a10 	vldr	s2, [r4, #64]	; 0x40
 80220f8:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80220fc:	eea7 8a00 	vfma.f32	s16, s14, s0
 8022100:	ee27 8a88 	vmul.f32	s16, s15, s16
 8022104:	ed84 8a05 	vstr	s16, [r4, #20]
 8022108:	e76d      	b.n	8021fe6 <tADSR4_tick+0xd6>
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
 802210a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802210e:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->rampPhase;
 8022110:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
 8022114:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->rampPhase - intPart;
 8022118:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
 802211c:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->rampPhase - intPart;
 8022120:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
 8022124:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022128:	d444      	bmi.n	80221b4 <tADSR4_tick+0x2a4>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->rampPhase)+1)];
 802212a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 802212e:	ee17 3a90 	vmov	r3, s15
 8022132:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8022136:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->rampPeak * LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart);
 802213a:	ee16 3a90 	vmov	r3, s13
 802213e:	ed94 8a0d 	vldr	s16, [r4, #52]	; 0x34
 8022142:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8022146:	ed92 0a00 	vldr	s0, [r2]
 802214a:	f001 ffeb 	bl	8024124 <LEAF_interpolation_linear>
 802214e:	ee28 8a00 	vmul.f32	s16, s16, s0
 8022152:	ed94 1a12 	vldr	s2, [r4, #72]	; 0x48
 8022156:	ed84 8a05 	vstr	s16, [r4, #20]
 802215a:	e6fb      	b.n	8021f54 <tADSR4_tick+0x44>
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
 802215c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8022160:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->releasePhase;
 8022162:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
 8022166:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->releasePhase - intPart;
 802216a:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
 802216e:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->releasePhase - intPart;
 8022172:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
 8022176:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802217a:	d418      	bmi.n	80221ae <tADSR4_tick+0x29e>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->releasePhase)+1)];
 802217c:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8022180:	ee17 3a90 	vmov	r3, s15
 8022184:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8022188:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->releasePeak * (LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart)); // do interpolation !
 802218c:	ee16 3a90 	vmov	r3, s13
 8022190:	ed94 8a0e 	vldr	s16, [r4, #56]	; 0x38
 8022194:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8022198:	ed92 0a00 	vldr	s0, [r2]
 802219c:	f001 ffc2 	bl	8024124 <LEAF_interpolation_linear>
 80221a0:	ee28 8a00 	vmul.f32	s16, s16, s0
 80221a4:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
 80221a8:	ed84 8a05 	vstr	s16, [r4, #20]
 80221ac:	e73a      	b.n	8022024 <tADSR4_tick+0x114>
                    secondValue = 0.0f;
 80221ae:	eddf 0a06 	vldr	s1, [pc, #24]	; 80221c8 <tADSR4_tick+0x2b8>
 80221b2:	e7eb      	b.n	802218c <tADSR4_tick+0x27c>
                    secondValue = 0.0f;
 80221b4:	eddf 0a04 	vldr	s1, [pc, #16]	; 80221c8 <tADSR4_tick+0x2b8>
 80221b8:	e7bf      	b.n	802213a <tADSR4_tick+0x22a>
                    secondValue = 0.0f;
 80221ba:	eddf 0a03 	vldr	s1, [pc, #12]	; 80221c8 <tADSR4_tick+0x2b8>
 80221be:	e787      	b.n	80220d0 <tADSR4_tick+0x1c0>
                    secondValue = 0.0f;
 80221c0:	eddf 0a01 	vldr	s1, [pc, #4]	; 80221c8 <tADSR4_tick+0x2b8>
 80221c4:	e759      	b.n	802207a <tADSR4_tick+0x16a>
 80221c6:	bf00      	nop
 80221c8:	00000000 	.word	0x00000000

080221cc <tADSR4_tickNoInterp>:

float   tADSR4_tickNoInterp(tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
 80221cc:	6803      	ldr	r3, [r0, #0]

    switch (adsr->whichStage)
 80221ce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80221d0:	3a01      	subs	r2, #1
 80221d2:	2a04      	cmp	r2, #4
 80221d4:	d872      	bhi.n	80222bc <tADSR4_tickNoInterp+0xf0>
 80221d6:	e8df f002 	tbb	[pc, r2]
 80221da:	3d1c      	.short	0x3d1c
 80221dc:	5934      	.short	0x5934
 80221de:	03          	.byte	0x03
 80221df:	00          	.byte	0x00
    {
        case env_ramp:
            if (adsr->rampPhase > adsr->buff_sizeMinusOne)
 80221e0:	edd3 7a03 	vldr	s15, [r3, #12]
 80221e4:	edd3 6a12 	vldr	s13, [r3, #72]	; 0x48
 80221e8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 80221ec:	eef4 6ac7 	vcmpe.f32	s13, s14
 80221f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80221f4:	f340 808b 	ble.w	802230e <tADSR4_tickNoInterp+0x142>
            {
                adsr->whichStage = env_attack;
 80221f8:	2201      	movs	r2, #1
                adsr->next = 0.0f;
 80221fa:	ed9f 0a53 	vldr	s0, [pc, #332]	; 8022348 <tADSR4_tickNoInterp+0x17c>
                adsr->whichStage = env_attack;
 80221fe:	629a      	str	r2, [r3, #40]	; 0x28
            else
            {
                adsr->next = adsr->rampPeak * adsr->exp_buff[(uint32_t)adsr->rampPhase];
            }

            adsr->rampPhase += adsr->rampInc;
 8022200:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
 8022204:	ed83 0a05 	vstr	s0, [r3, #20]
 8022208:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802220c:	edc3 7a12 	vstr	s15, [r3, #72]	; 0x48
            break;
 8022210:	4770      	bx	lr


        case env_attack:

            // If attack done, time to turn around.
            if (adsr->attackPhase > adsr->buff_sizeMinusOne)
 8022212:	edd3 7a03 	vldr	s15, [r3, #12]
 8022216:	edd3 6a0f 	vldr	s13, [r3, #60]	; 0x3c
 802221a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 802221e:	ed93 0a0c 	vldr	s0, [r3, #48]	; 0x30
 8022222:	eef4 6ac7 	vcmpe.f32	s13, s14
 8022226:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802222a:	dd4a      	ble.n	80222c2 <tADSR4_tickNoInterp+0xf6>
            {
                adsr->whichStage = env_decay;
 802222c:	2202      	movs	r2, #2
 802222e:	629a      	str	r2, [r3, #40]	; 0x28
            {
                adsr->next = adsr->gain * (1.0f - adsr->exp_buff[(uint32_t)adsr->attackPhase]); // inverted and backwards to get proper rising exponential shape/perception
            }

            // Increment ADSR attack.
            adsr->attackPhase += adsr->attackInc;
 8022230:	edd3 7a06 	vldr	s15, [r3, #24]
 8022234:	ed83 0a05 	vstr	s0, [r3, #20]
 8022238:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802223c:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
            break;
 8022240:	4770      	bx	lr
            // Increment ADSR decay.
            adsr->decayPhase += adsr->decayInc;
            break;

        case env_sustain:
            adsr->next = adsr->next * adsr->leakFactor;
 8022242:	ed93 0a05 	vldr	s0, [r3, #20]
 8022246:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
 802224a:	ee20 0a27 	vmul.f32	s0, s0, s15
 802224e:	ed83 0a05 	vstr	s0, [r3, #20]
            break;
 8022252:	4770      	bx	lr
            if (adsr->decayPhase > adsr->buff_sizeMinusOne)
 8022254:	edd3 7a03 	vldr	s15, [r3, #12]
 8022258:	edd3 6a10 	vldr	s13, [r3, #64]	; 0x40
 802225c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8022260:	ed93 0a0b 	vldr	s0, [r3, #44]	; 0x2c
 8022264:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
 8022268:	eef4 6ac7 	vcmpe.f32	s13, s14
 802226c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022270:	dd37      	ble.n	80222e2 <tADSR4_tickNoInterp+0x116>
                adsr->next = adsr->gain * adsr->sustain;
 8022272:	ee20 0a27 	vmul.f32	s0, s0, s15
                adsr->whichStage = env_sustain;
 8022276:	2203      	movs	r2, #3
 8022278:	629a      	str	r2, [r3, #40]	; 0x28
            adsr->decayPhase += adsr->decayInc;
 802227a:	edd3 7a07 	vldr	s15, [r3, #28]
 802227e:	ed83 0a05 	vstr	s0, [r3, #20]
 8022282:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8022286:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
            break;
 802228a:	4770      	bx	lr

        case env_release:
            // If release done, finish.
            if (adsr->releasePhase > adsr->buff_sizeMinusOne)
 802228c:	edd3 7a03 	vldr	s15, [r3, #12]
 8022290:	edd3 6a11 	vldr	s13, [r3, #68]	; 0x44
 8022294:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8022298:	eef4 6ac7 	vcmpe.f32	s13, s14
 802229c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80222a0:	dd43      	ble.n	802232a <tADSR4_tickNoInterp+0x15e>
            {
                adsr->whichStage = env_idle;
 80222a2:	2200      	movs	r2, #0
                adsr->next = 0.0f;
 80222a4:	ed9f 0a28 	vldr	s0, [pc, #160]	; 8022348 <tADSR4_tickNoInterp+0x17c>
                adsr->whichStage = env_idle;
 80222a8:	629a      	str	r2, [r3, #40]	; 0x28
            else {
                adsr->next = adsr->releasePeak * adsr->exp_buff[(uint32_t)adsr->releasePhase];
            }

            // Increment envelope release;
            adsr->releasePhase += adsr->releaseInc;
 80222aa:	edd3 7a08 	vldr	s15, [r3, #32]
 80222ae:	ed83 0a05 	vstr	s0, [r3, #20]
 80222b2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80222b6:	edc3 7a11 	vstr	s15, [r3, #68]	; 0x44
            break;
    }
    return adsr->next;
}
 80222ba:	4770      	bx	lr
 80222bc:	ed93 0a05 	vldr	s0, [r3, #20]
 80222c0:	4770      	bx	lr
                adsr->next = adsr->gain * (1.0f - adsr->exp_buff[(uint32_t)adsr->attackPhase]); // inverted and backwards to get proper rising exponential shape/perception
 80222c2:	eebc 7ae6 	vcvt.u32.f32	s14, s13
 80222c6:	685a      	ldr	r2, [r3, #4]
 80222c8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80222cc:	ee17 1a10 	vmov	r1, s14
 80222d0:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 80222d4:	ed92 7a00 	vldr	s14, [r2]
 80222d8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80222dc:	ee20 0a27 	vmul.f32	s0, s0, s15
 80222e0:	e7a6      	b.n	8022230 <tADSR4_tickNoInterp+0x64>
                adsr->next = (adsr->gain * (adsr->sustain + (adsr->exp_buff[(uint32_t)adsr->decayPhase] * (1.0f - adsr->sustain)))) * adsr->leakFactor;
 80222e2:	eefc 5ae6 	vcvt.u32.f32	s11, s13
 80222e6:	685a      	ldr	r2, [r3, #4]
 80222e8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80222ec:	ed93 6a13 	vldr	s12, [r3, #76]	; 0x4c
 80222f0:	ee15 1a90 	vmov	r1, s11
 80222f4:	ee67 7a86 	vmul.f32	s15, s15, s12
 80222f8:	ee37 7a40 	vsub.f32	s14, s14, s0
 80222fc:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8022300:	ed92 6a00 	vldr	s12, [r2]
 8022304:	eea6 0a07 	vfma.f32	s0, s12, s14
 8022308:	ee20 0a27 	vmul.f32	s0, s0, s15
 802230c:	e7b5      	b.n	802227a <tADSR4_tickNoInterp+0xae>
                adsr->next = adsr->rampPeak * adsr->exp_buff[(uint32_t)adsr->rampPhase];
 802230e:	eebc 7ae6 	vcvt.u32.f32	s14, s13
 8022312:	685a      	ldr	r2, [r3, #4]
 8022314:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 8022318:	ee17 1a10 	vmov	r1, s14
 802231c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8022320:	ed92 0a00 	vldr	s0, [r2]
 8022324:	ee20 0a27 	vmul.f32	s0, s0, s15
 8022328:	e76a      	b.n	8022200 <tADSR4_tickNoInterp+0x34>
                adsr->next = adsr->releasePeak * adsr->exp_buff[(uint32_t)adsr->releasePhase];
 802232a:	eebc 7ae6 	vcvt.u32.f32	s14, s13
 802232e:	685a      	ldr	r2, [r3, #4]
 8022330:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 8022334:	ee17 1a10 	vmov	r1, s14
 8022338:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 802233c:	ed92 0a00 	vldr	s0, [r2]
 8022340:	ee20 0a27 	vmul.f32	s0, s0, s15
 8022344:	e7b1      	b.n	80222aa <tADSR4_tickNoInterp+0xde>
 8022346:	bf00      	nop
 8022348:	00000000 	.word	0x00000000

0802234c <tRamp_init>:


/////-----------------
/* Ramp */
void    tRamp_init(tRamp* const r, float time, int samples_per_tick)
{
 802234c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tRamp_initToPool(r, time, samples_per_tick, &leaf.mempool);
}

void    tRamp_initToPool    (tRamp* const r, float time, int samples_per_tick, tMempool* const mp)
{
    _tMempool* m = *mp;
 802234e:	4d17      	ldr	r5, [pc, #92]	; (80223ac <tRamp_init+0x60>)
{
 8022350:	4607      	mov	r7, r0
 8022352:	460c      	mov	r4, r1
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 8022354:	2024      	movs	r0, #36	; 0x24
    _tMempool* m = *mp;
 8022356:	69ae      	ldr	r6, [r5, #24]
{
 8022358:	ed2d 8b02 	vpush	{d8}
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 802235c:	4631      	mov	r1, r6
{
 802235e:	eeb0 8a40 	vmov.f32	s16, s0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 8022362:	f001 ffa9 	bl	80242b8 <mpool_alloc>
    ramp->mempool = m;
    
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8022366:	ed9f 6a12 	vldr	s12, [pc, #72]	; 80223b0 <tRamp_init+0x64>
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 802236a:	6038      	str	r0, [r7, #0]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 802236c:	ee07 4a90 	vmov	s15, r4
    ramp->mempool = m;
 8022370:	6006      	str	r6, [r0, #0]
    ramp->curr = 0.0f;
 8022372:	2300      	movs	r3, #0
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8022374:	edd5 6a00 	vldr	s13, [r5]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8022378:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    }
    else
    {
        ramp->time = time;
    }
    ramp->samples_per_tick = samples_per_tick;
 802237c:	6204      	str	r4, [r0, #32]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 802237e:	ee86 7a26 	vdiv.f32	s14, s12, s13
    ramp->curr = 0.0f;
 8022382:	6103      	str	r3, [r0, #16]
    ramp->dest = 0.0f;
 8022384:	6143      	str	r3, [r0, #20]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
    ramp->inc = (ramp->dest - ramp->curr) * ramp->factor;
 8022386:	6043      	str	r3, [r0, #4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8022388:	ee67 7a87 	vmul.f32	s15, s15, s14
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 802238c:	ed80 7a02 	vstr	s14, [r0, #8]
 8022390:	fe88 0a27 	vmaxnm.f32	s0, s16, s15
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
 8022394:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8022398:	ed80 0a06 	vstr	s0, [r0, #24]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 802239c:	edc0 7a03 	vstr	s15, [r0, #12]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
 80223a0:	ed80 7a07 	vstr	s14, [r0, #28]
}
 80223a4:	ecbd 8b02 	vpop	{d8}
 80223a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80223aa:	bf00      	nop
 80223ac:	200194e8 	.word	0x200194e8
 80223b0:	4479ffff 	.word	0x4479ffff

080223b4 <tRamp_initToPool>:
{
 80223b4:	b570      	push	{r4, r5, r6, lr}
    _tMempool* m = *mp;
 80223b6:	6815      	ldr	r5, [r2, #0]
{
 80223b8:	460c      	mov	r4, r1
 80223ba:	4606      	mov	r6, r0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 80223bc:	2024      	movs	r0, #36	; 0x24
 80223be:	4629      	mov	r1, r5
{
 80223c0:	ed2d 8b02 	vpush	{d8}
 80223c4:	eeb0 8a40 	vmov.f32	s16, s0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 80223c8:	f001 ff76 	bl	80242b8 <mpool_alloc>
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 80223cc:	4b11      	ldr	r3, [pc, #68]	; (8022414 <tRamp_initToPool+0x60>)
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 80223ce:	ee07 4a90 	vmov	s15, r4
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 80223d2:	6030      	str	r0, [r6, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 80223d4:	ed9f 6a10 	vldr	s12, [pc, #64]	; 8022418 <tRamp_initToPool+0x64>
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 80223d8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    ramp->mempool = m;
 80223dc:	6005      	str	r5, [r0, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 80223de:	edd3 6a00 	vldr	s13, [r3]
    ramp->curr = 0.0f;
 80223e2:	2300      	movs	r3, #0
    ramp->samples_per_tick = samples_per_tick;
 80223e4:	6204      	str	r4, [r0, #32]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 80223e6:	ee86 7a26 	vdiv.f32	s14, s12, s13
    ramp->curr = 0.0f;
 80223ea:	6103      	str	r3, [r0, #16]
    ramp->dest = 0.0f;
 80223ec:	6143      	str	r3, [r0, #20]
    ramp->inc = (ramp->dest - ramp->curr) * ramp->factor;
 80223ee:	6043      	str	r3, [r0, #4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 80223f0:	ee67 7a87 	vmul.f32	s15, s15, s14
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 80223f4:	ed80 7a02 	vstr	s14, [r0, #8]
 80223f8:	fe87 0a88 	vmaxnm.f32	s0, s15, s16
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
 80223fc:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8022400:	ed80 0a06 	vstr	s0, [r0, #24]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8022404:	edc0 7a03 	vstr	s15, [r0, #12]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
 8022408:	ed80 7a07 	vstr	s14, [r0, #28]
}
 802240c:	ecbd 8b02 	vpop	{d8}
 8022410:	bd70      	pop	{r4, r5, r6, pc}
 8022412:	bf00      	nop
 8022414:	200194e8 	.word	0x200194e8
 8022418:	4479ffff 	.word	0x4479ffff

0802241c <tRamp_free>:

void    tRamp_free (tRamp* const r)
{
    _tRamp* ramp = *r;
 802241c:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)ramp, ramp->mempool);
 802241e:	6801      	ldr	r1, [r0, #0]
 8022420:	f001 bffe 	b.w	8024420 <mpool_free>

08022424 <tRamp_setDest>:

}

void     tRamp_setDest(tRamp* const ramp, float dest)
{
    _tRamp* r = *ramp;
 8022424:	6803      	ldr	r3, [r0, #0]
    r->dest = dest;
    r->inc = (r->dest - r->curr) * r->factor;
 8022426:	edd3 7a04 	vldr	s15, [r3, #16]
 802242a:	ed93 7a07 	vldr	s14, [r3, #28]
 802242e:	ee70 7a67 	vsub.f32	s15, s0, s15
    r->dest = dest;
 8022432:	ed83 0a05 	vstr	s0, [r3, #20]
    r->inc = (r->dest - r->curr) * r->factor;
 8022436:	ee67 7a87 	vmul.f32	s15, s15, s14
 802243a:	edc3 7a01 	vstr	s15, [r3, #4]
}
 802243e:	4770      	bx	lr

08022440 <tRamp_setVal>:

void     tRamp_setVal(tRamp* const ramp, float val)
{
    _tRamp* r = *ramp;
 8022440:	6803      	ldr	r3, [r0, #0]
    r->curr = val;
    r->inc = (r->dest - r->curr) * r->factor;
 8022442:	edd3 7a05 	vldr	s15, [r3, #20]
 8022446:	ed93 7a07 	vldr	s14, [r3, #28]
 802244a:	ee77 7ac0 	vsub.f32	s15, s15, s0
    r->curr = val;
 802244e:	ed83 0a04 	vstr	s0, [r3, #16]
    r->inc = (r->dest - r->curr) * r->factor;
 8022452:	ee67 7a87 	vmul.f32	s15, s15, s14
 8022456:	edc3 7a01 	vstr	s15, [r3, #4]
}
 802245a:	4770      	bx	lr

0802245c <tRamp_tick>:

float   tRamp_tick(tRamp* const ramp)
{
    _tRamp* r = *ramp;
 802245c:	6803      	ldr	r3, [r0, #0]
    
    r->curr += r->inc;
 802245e:	edd3 7a01 	vldr	s15, [r3, #4]
 8022462:	ed93 0a04 	vldr	s0, [r3, #16]
    
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
 8022466:	eef5 7a40 	vcmp.f32	s15, #0.0
 802246a:	ed93 7a05 	vldr	s14, [r3, #20]
    r->curr += r->inc;
 802246e:	ee37 0a80 	vadd.f32	s0, s15, s0
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
 8022472:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    r->curr += r->inc;
 8022476:	ed83 0a04 	vstr	s0, [r3, #16]
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
 802247a:	dd04      	ble.n	8022486 <tRamp_tick+0x2a>
 802247c:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8022480:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022484:	da0a      	bge.n	802249c <tRamp_tick+0x40>
 8022486:	eef5 7a40 	vcmp.f32	s15, #0.0
 802248a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802248e:	d504      	bpl.n	802249a <tRamp_tick+0x3e>
 8022490:	eeb4 0a47 	vcmp.f32	s0, s14
 8022494:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022498:	d900      	bls.n	802249c <tRamp_tick+0x40>
        r->inc = 0.0f;
        r->curr=r->dest;
    }
    
    return r->curr;
}
 802249a:	4770      	bx	lr
        r->inc = 0.0f;
 802249c:	2200      	movs	r2, #0
        r->curr=r->dest;
 802249e:	eeb0 0a47 	vmov.f32	s0, s14
 80224a2:	ed83 7a04 	vstr	s14, [r3, #16]
        r->inc = 0.0f;
 80224a6:	605a      	str	r2, [r3, #4]
}
 80224a8:	4770      	bx	lr
 80224aa:	bf00      	nop

080224ac <tRamp_sample>:

float   tRamp_sample(tRamp* const ramp)
{
    _tRamp* r = *ramp;
    return r->curr;
 80224ac:	6803      	ldr	r3, [r0, #0]
}
 80224ae:	ed93 0a04 	vldr	s0, [r3, #16]
 80224b2:	4770      	bx	lr

080224b4 <tExpSmooth_init>:



/* Exponential Smoother */
void    tExpSmooth_init(tExpSmooth* const expsmooth, float val, float factor)
{   // factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
 80224b4:	b538      	push	{r3, r4, r5, lr}
    tExpSmooth_initToPool(expsmooth, val, factor, &leaf.mempool);
}

void    tExpSmooth_initToPool   (tExpSmooth* const expsmooth, float val, float factor, tMempool* const mp)
{
    _tMempool* m = *mp;
 80224b6:	4b12      	ldr	r3, [pc, #72]	; (8022500 <tExpSmooth_init+0x4c>)
{   // factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
 80224b8:	4605      	mov	r5, r0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
 80224ba:	2014      	movs	r0, #20
{   // factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
 80224bc:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 80224c0:	699c      	ldr	r4, [r3, #24]
{   // factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
 80224c2:	eef0 8a40 	vmov.f32	s17, s0
 80224c6:	eeb0 8a60 	vmov.f32	s16, s1
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
 80224ca:	4621      	mov	r1, r4
 80224cc:	f001 fef4 	bl	80242b8 <mpool_alloc>
 80224d0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80224d4:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 8022504 <tExpSmooth_init+0x50>
 80224d8:	6028      	str	r0, [r5, #0]
 80224da:	fec8 0a67 	vminnm.f32	s1, s16, s15
 80224de:	fec0 0a87 	vmaxnm.f32	s1, s1, s14
    smooth->curr=val;
    smooth->dest=val;
    if (factor<0) factor=0;
    if (factor>1) factor=1;
    smooth->factor=factor;
    smooth->oneminusfactor=1.0f-factor;
 80224e2:	ee77 7ae0 	vsub.f32	s15, s15, s1
    smooth->mempool = m;
 80224e6:	6004      	str	r4, [r0, #0]
    smooth->curr=val;
 80224e8:	edc0 8a03 	vstr	s17, [r0, #12]
    smooth->dest=val;
 80224ec:	edc0 8a04 	vstr	s17, [r0, #16]
    smooth->factor=factor;
 80224f0:	edc0 0a01 	vstr	s1, [r0, #4]
    smooth->oneminusfactor=1.0f-factor;
 80224f4:	edc0 7a02 	vstr	s15, [r0, #8]
}
 80224f8:	ecbd 8b02 	vpop	{d8}
 80224fc:	bd38      	pop	{r3, r4, r5, pc}
 80224fe:	bf00      	nop
 8022500:	200194e8 	.word	0x200194e8
 8022504:	00000000 	.word	0x00000000

08022508 <tExpSmooth_initToPool>:
{
 8022508:	b538      	push	{r3, r4, r5, lr}
 802250a:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 802250e:	680c      	ldr	r4, [r1, #0]
{
 8022510:	4605      	mov	r5, r0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
 8022512:	2014      	movs	r0, #20
{
 8022514:	eef0 8a40 	vmov.f32	s17, s0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
 8022518:	4621      	mov	r1, r4
{
 802251a:	eeb0 8a60 	vmov.f32	s16, s1
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
 802251e:	f001 fecb 	bl	80242b8 <mpool_alloc>
 8022522:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8022526:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 8022550 <tExpSmooth_initToPool+0x48>
 802252a:	6028      	str	r0, [r5, #0]
 802252c:	fec8 0a67 	vminnm.f32	s1, s16, s15
 8022530:	fec0 0a87 	vmaxnm.f32	s1, s1, s14
    smooth->oneminusfactor=1.0f-factor;
 8022534:	ee77 7ae0 	vsub.f32	s15, s15, s1
    smooth->mempool = m;
 8022538:	6004      	str	r4, [r0, #0]
    smooth->curr=val;
 802253a:	edc0 8a03 	vstr	s17, [r0, #12]
    smooth->dest=val;
 802253e:	edc0 8a04 	vstr	s17, [r0, #16]
    smooth->factor=factor;
 8022542:	edc0 0a01 	vstr	s1, [r0, #4]
    smooth->oneminusfactor=1.0f-factor;
 8022546:	edc0 7a02 	vstr	s15, [r0, #8]
}
 802254a:	ecbd 8b02 	vpop	{d8}
 802254e:	bd38      	pop	{r3, r4, r5, pc}
 8022550:	00000000 	.word	0x00000000

08022554 <tExpSmooth_free>:

void    tExpSmooth_free (tExpSmooth* const expsmooth)
{
    _tExpSmooth* smooth = *expsmooth;
 8022554:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)smooth, smooth->mempool);
 8022556:	6801      	ldr	r1, [r0, #0]
 8022558:	f001 bf62 	b.w	8024420 <mpool_free>

0802255c <tExpSmooth_setFactor>:
}

void     tExpSmooth_setFactor(tExpSmooth* const expsmooth, float factor)
{   // factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
 802255c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8022560:	ed9f 7a06 	vldr	s14, [pc, #24]	; 802257c <tExpSmooth_setFactor+0x20>
    _tExpSmooth* smooth = *expsmooth;
 8022564:	6803      	ldr	r3, [r0, #0]
 8022566:	fe80 0a67 	vminnm.f32	s0, s0, s15
 802256a:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    if (factor<0)
        factor=0;
    else
        if (factor>1) factor=1;
    smooth->factor=factor;
    smooth->oneminusfactor=1.0f-factor;
 802256e:	ee77 7ac0 	vsub.f32	s15, s15, s0
    smooth->factor=factor;
 8022572:	ed83 0a01 	vstr	s0, [r3, #4]
    smooth->oneminusfactor=1.0f-factor;
 8022576:	edc3 7a02 	vstr	s15, [r3, #8]
}
 802257a:	4770      	bx	lr
 802257c:	00000000 	.word	0x00000000

08022580 <tExpSmooth_setDest>:

void     tExpSmooth_setDest(tExpSmooth* const expsmooth, float dest)
{
    _tExpSmooth* smooth = *expsmooth;
 8022580:	6803      	ldr	r3, [r0, #0]
    smooth->dest=dest;
 8022582:	ed83 0a04 	vstr	s0, [r3, #16]
}
 8022586:	4770      	bx	lr

08022588 <tExpSmooth_setValAndDest>:
    smooth->curr=val;
}

void     tExpSmooth_setValAndDest(tExpSmooth* const expsmooth, float val)
{
    _tExpSmooth* smooth = *expsmooth;
 8022588:	6803      	ldr	r3, [r0, #0]
    smooth->curr=val;
 802258a:	ed83 0a03 	vstr	s0, [r3, #12]
    smooth->dest=val;
 802258e:	ed83 0a04 	vstr	s0, [r3, #16]
}
 8022592:	4770      	bx	lr

08022594 <tExpSmooth_tick>:

float   tExpSmooth_tick(tExpSmooth* const expsmooth)
{
    _tExpSmooth* smooth = *expsmooth;
 8022594:	6803      	ldr	r3, [r0, #0]
    smooth->curr = smooth->factor*smooth->dest+smooth->oneminusfactor*smooth->curr;
 8022596:	edd3 7a03 	vldr	s15, [r3, #12]
 802259a:	ed93 0a02 	vldr	s0, [r3, #8]
 802259e:	ed93 7a01 	vldr	s14, [r3, #4]
 80225a2:	ee20 0a27 	vmul.f32	s0, s0, s15
 80225a6:	edd3 7a04 	vldr	s15, [r3, #16]
 80225aa:	eea7 0a27 	vfma.f32	s0, s14, s15
 80225ae:	ed83 0a03 	vstr	s0, [r3, #12]
    return smooth->curr;
}
 80225b2:	4770      	bx	lr

080225b4 <tSlide_init>:

//tSlide is based on the max/msp slide~ object
////

void    tSlide_init          (tSlide* const sl, float upSlide, float downSlide)
{
 80225b4:	b538      	push	{r3, r4, r5, lr}
    tSlide_initToPool    (sl, upSlide, downSlide, &leaf.mempool);
}

void    tSlide_initToPool    (tSlide* const sl, float upSlide, float downSlide, tMempool* const mp)
{
    _tMempool* m = *mp;
 80225b6:	4b12      	ldr	r3, [pc, #72]	; (8022600 <tSlide_init+0x4c>)
{
 80225b8:	4605      	mov	r5, r0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
 80225ba:	201c      	movs	r0, #28
{
 80225bc:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 80225c0:	699c      	ldr	r4, [r3, #24]
{
 80225c2:	eeb0 8a60 	vmov.f32	s16, s1
 80225c6:	eef0 8a40 	vmov.f32	s17, s0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
 80225ca:	4621      	mov	r1, r4
 80225cc:	f001 fe74 	bl	80242b8 <mpool_alloc>

    if (downSlide < 1.0f)
    {
        downSlide = 1.0f;
    }
    s->invUpSlide = 1.0f / upSlide;
 80225d0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    s->prevIn = 0.0f;
 80225d4:	2300      	movs	r3, #0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
 80225d6:	6028      	str	r0, [r5, #0]
    s->mempool = m;
 80225d8:	6004      	str	r4, [r0, #0]
    s->invUpSlide = 1.0f / upSlide;
 80225da:	fec8 8aa7 	vmaxnm.f32	s17, s17, s15
    s->invDownSlide = 1.0f / downSlide;
 80225de:	fec8 0a27 	vmaxnm.f32	s1, s16, s15
    s->invUpSlide = 1.0f / upSlide;
 80225e2:	eec7 6aa8 	vdiv.f32	s13, s15, s17
    s->prevIn = 0.0f;
 80225e6:	60c3      	str	r3, [r0, #12]
    s->currentOut = 0.0f;
 80225e8:	6083      	str	r3, [r0, #8]
    s->prevOut = 0.0f;
 80225ea:	6043      	str	r3, [r0, #4]
    s->dest = 0.0f;
 80225ec:	6183      	str	r3, [r0, #24]
    s->invDownSlide = 1.0f / downSlide;
 80225ee:	ee87 7aa0 	vdiv.f32	s14, s15, s1
    s->invUpSlide = 1.0f / upSlide;
 80225f2:	edc0 6a04 	vstr	s13, [r0, #16]
    s->invDownSlide = 1.0f / downSlide;
 80225f6:	ed80 7a05 	vstr	s14, [r0, #20]
}
 80225fa:	ecbd 8b02 	vpop	{d8}
 80225fe:	bd38      	pop	{r3, r4, r5, pc}
 8022600:	200194e8 	.word	0x200194e8

08022604 <tSlide_free>:
}

void    tSlide_free  (tSlide* const sl)
{
    _tSlide* s = *sl;
 8022604:	6800      	ldr	r0, [r0, #0]

    mpool_free((char*)s, s->mempool);
 8022606:	6801      	ldr	r1, [r0, #0]
 8022608:	f001 bf0a 	b.w	8024420 <mpool_free>

0802260c <tSlide_setDownSlide>:
}

void tSlide_setDownSlide(tSlide* const sl, float downSlide)
{
    _tSlide* s = *sl;
    s->invDownSlide = 1.0f / downSlide;
 802260c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tSlide* s = *sl;
 8022610:	6803      	ldr	r3, [r0, #0]
    s->invDownSlide = 1.0f / downSlide;
 8022612:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8022616:	ed83 0a05 	vstr	s0, [r3, #20]
}
 802261a:	4770      	bx	lr

0802261c <tSlide_setDest>:

void tSlide_setDest(tSlide* const sl, float dest)
{
    _tSlide* s = *sl;
 802261c:	6803      	ldr	r3, [r0, #0]
    s->dest = dest;
 802261e:	ed83 0a06 	vstr	s0, [r3, #24]
}
 8022622:	4770      	bx	lr

08022624 <tSlide_tickNoInput>:

float tSlide_tickNoInput(tSlide* const sl)
{
    _tSlide* s = *sl;
 8022624:	6803      	ldr	r3, [r0, #0]
    float in = s->dest;

    if (in >= s->prevOut)
 8022626:	edd3 7a01 	vldr	s15, [r3, #4]
    float in = s->dest;
 802262a:	ed93 7a06 	vldr	s14, [r3, #24]
    if (in >= s->prevOut)
 802262e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8022632:	ee77 6a67 	vsub.f32	s13, s14, s15
 8022636:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    {
        s->currentOut = s->prevOut + ((in - s->prevOut) * s->invUpSlide);
 802263a:	bf94      	ite	ls
 802263c:	ed93 6a04 	vldrls	s12, [r3, #16]
    }
    else
    {
        s->currentOut = s->prevOut + ((in - s->prevOut) * s->invDownSlide);
 8022640:	ed93 6a05 	vldrhi	s12, [r3, #20]
 8022644:	eee6 7a26 	vfma.f32	s15, s12, s13
    }
#ifdef NO_DENORMAL_CHECK
#else
    if (s->currentOut < VSF) s->currentOut = 0.0f;
 8022648:	eddf 6a0e 	vldr	s13, [pc, #56]	; 8022684 <tSlide_tickNoInput+0x60>
 802264c:	eef4 7ae6 	vcmpe.f32	s15, s13
 8022650:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022654:	d50c      	bpl.n	8022670 <tSlide_tickNoInput+0x4c>
 8022656:	eddf 6a0c 	vldr	s13, [pc, #48]	; 8022688 <tSlide_tickNoInput+0x64>
#endif
    s->prevIn = in;
 802265a:	ed83 7a03 	vstr	s14, [r3, #12]
    if (s->currentOut < VSF) s->currentOut = 0.0f;
 802265e:	eef0 7a66 	vmov.f32	s15, s13
 8022662:	edc3 6a02 	vstr	s13, [r3, #8]
    s->prevOut = s->currentOut;
    return s->currentOut;
}
 8022666:	eeb0 0a67 	vmov.f32	s0, s15
    s->prevOut = s->currentOut;
 802266a:	edc3 7a01 	vstr	s15, [r3, #4]
}
 802266e:	4770      	bx	lr
 8022670:	edc3 7a02 	vstr	s15, [r3, #8]
 8022674:	eeb0 0a67 	vmov.f32	s0, s15
    s->prevIn = in;
 8022678:	ed83 7a03 	vstr	s14, [r3, #12]
    s->prevOut = s->currentOut;
 802267c:	edc3 7a01 	vstr	s15, [r3, #4]
}
 8022680:	4770      	bx	lr
 8022682:	bf00      	nop
 8022684:	006ce3ee 	.word	0x006ce3ee
 8022688:	00000000 	.word	0x00000000

0802268c <tAllpass_initToPool>:
{
    tAllpass_initToPool(ft, initDelay, maxDelay, &leaf.mempool);
}

void    tAllpass_initToPool     (tAllpass* const ft, float initDelay, uint32_t maxDelay, tMempool* const mp)
{
 802268c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022690:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8022694:	6814      	ldr	r4, [r2, #0]
{
 8022696:	4615      	mov	r5, r2
 8022698:	4607      	mov	r7, r0
 802269a:	4688      	mov	r8, r1
 802269c:	eeb0 8a40 	vmov.f32	s16, s0
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
 80226a0:	4621      	mov	r1, r4
 80226a2:	2010      	movs	r0, #16
    f->mempool = m;
    
    f->gain = 0.7f;
 80226a4:	4e09      	ldr	r6, [pc, #36]	; (80226cc <tAllpass_initToPool+0x40>)
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
 80226a6:	f001 fe07 	bl	80242b8 <mpool_alloc>
    
    f->lastOut = 0.0f;
    
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
 80226aa:	462a      	mov	r2, r5
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
 80226ac:	4603      	mov	r3, r0
    f->lastOut = 0.0f;
 80226ae:	2500      	movs	r5, #0
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
 80226b0:	6038      	str	r0, [r7, #0]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
 80226b2:	eeb0 0a48 	vmov.f32	s0, s16
    f->mempool = m;
 80226b6:	6004      	str	r4, [r0, #0]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
 80226b8:	4641      	mov	r1, r8
    f->gain = 0.7f;
 80226ba:	605e      	str	r6, [r3, #4]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
 80226bc:	3008      	adds	r0, #8
    f->lastOut = 0.0f;
 80226be:	60dd      	str	r5, [r3, #12]
}
 80226c0:	ecbd 8b02 	vpop	{d8}
 80226c4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
 80226c8:	f7fc bee2 	b.w	801f490 <tLinearDelay_initToPool>
 80226cc:	3f333333 	.word	0x3f333333

080226d0 <tAllpass_free>:

void    tAllpass_free  (tAllpass* const ft)
{
 80226d0:	b510      	push	{r4, lr}
    _tAllpass* f = *ft;
 80226d2:	6804      	ldr	r4, [r0, #0]
    
    tLinearDelay_free(&f->delay);
 80226d4:	f104 0008 	add.w	r0, r4, #8
 80226d8:	f7fc ff50 	bl	801f57c <tLinearDelay_free>
    mpool_free((char*)f, f->mempool);
 80226dc:	6821      	ldr	r1, [r4, #0]
 80226de:	4620      	mov	r0, r4
}
 80226e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)f, f->mempool);
 80226e4:	f001 be9c 	b.w	8024420 <mpool_free>

080226e8 <tAllpass_setDelay>:

void    tAllpass_setDelay(tAllpass* const ft, float delay)
{
    _tAllpass* f = *ft;
    
    tLinearDelay_setDelay(&f->delay, delay);
 80226e8:	6800      	ldr	r0, [r0, #0]
 80226ea:	3008      	adds	r0, #8
 80226ec:	f7fc bfd8 	b.w	801f6a0 <tLinearDelay_setDelay>

080226f0 <tAllpass_setGain>:
}

void    tAllpass_setGain(tAllpass* const ft, float gain)
{
    _tAllpass* f = *ft;
 80226f0:	6803      	ldr	r3, [r0, #0]
    
    f->gain = gain;
 80226f2:	ed83 0a01 	vstr	s0, [r3, #4]
}
 80226f6:	4770      	bx	lr

080226f8 <tAllpass_tick>:

float   tAllpass_tick(tAllpass* const ft, float input)
{
 80226f8:	b510      	push	{r4, lr}
 80226fa:	ed2d 8b02 	vpush	{d8}
    _tAllpass* f = *ft;
 80226fe:	6804      	ldr	r4, [r0, #0]
{
 8022700:	eeb0 8a40 	vmov.f32	s16, s0
    
    float s1 = (-f->gain) * f->lastOut + input;
    
    float s2 = tLinearDelay_tick(&f->delay, s1) + (f->gain) * input;
 8022704:	edd4 7a03 	vldr	s15, [r4, #12]
 8022708:	f104 0008 	add.w	r0, r4, #8
 802270c:	ed94 7a01 	vldr	s14, [r4, #4]
 8022710:	eea7 0a67 	vfms.f32	s0, s14, s15
 8022714:	f7fc ff4c 	bl	801f5b0 <tLinearDelay_tick>
 8022718:	edd4 7a01 	vldr	s15, [r4, #4]
 802271c:	eea7 0a88 	vfma.f32	s0, s15, s16
    
    f->lastOut = s2;
 8022720:	ed84 0a03 	vstr	s0, [r4, #12]
    
    return f->lastOut;
}
 8022724:	ecbd 8b02 	vpop	{d8}
 8022728:	bd10      	pop	{r4, pc}
 802272a:	bf00      	nop

0802272c <tOnePole_initToPool>:
{
    tOnePole_initToPool(ft, freq, &leaf.mempool);
}

void    tOnePole_initToPool     (tOnePole* const ft, float freq, tMempool* const mp)
{
 802272c:	b570      	push	{r4, r5, r6, lr}
 802272e:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8022732:	680e      	ldr	r6, [r1, #0]
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
    f->mempool = m;
    
    f->gain = 1.0f;
 8022734:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
{
 8022738:	4605      	mov	r5, r0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
 802273a:	2020      	movs	r0, #32
 802273c:	4631      	mov	r1, r6
{
 802273e:	eef0 8a40 	vmov.f32	s17, s0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
 8022742:	f001 fdb9 	bl	80242b8 <mpool_alloc>
}

void        tOnePole_setFreq        (tOnePole* const ft, float freq)
{
    _tOnePole* f = *ft;
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 8022746:	4b12      	ldr	r3, [pc, #72]	; (8022790 <tOnePole_initToPool+0x64>)
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
 8022748:	6028      	str	r0, [r5, #0]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 802274a:	eeb0 1a48 	vmov.f32	s2, s16
    f->gain = 1.0f;
 802274e:	ed80 8a01 	vstr	s16, [r0, #4]
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
 8022752:	4604      	mov	r4, r0
    f->a0 = 1.0;
 8022754:	ed80 8a02 	vstr	s16, [r0, #8]
    f->mempool = m;
 8022758:	6006      	str	r6, [r0, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 802275a:	edd3 0a03 	vldr	s1, [r3, #12]
    _tOnePole* f = *ft;
 802275e:	682d      	ldr	r5, [r5, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 8022760:	ee68 0aa0 	vmul.f32	s1, s17, s1
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 8022764:	eddf 8a0b 	vldr	s17, [pc, #44]	; 8022794 <tOnePole_initToPool+0x68>
 8022768:	eeb0 0a68 	vmov.f32	s0, s17
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 802276c:	edc5 0a04 	vstr	s1, [r5, #16]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 8022770:	f001 fba0 	bl	8023eb4 <LEAF_clip>
    f->a1 = 1.0f - f->b0;
 8022774:	ee38 8a40 	vsub.f32	s16, s16, s0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 8022778:	ed85 0a04 	vstr	s0, [r5, #16]
    f->a1 = 1.0f - f->b0;
 802277c:	ed85 8a03 	vstr	s16, [r5, #12]
    f->lastIn = 0.0f;
 8022780:	edc4 8a06 	vstr	s17, [r4, #24]
    f->lastOut = 0.0f;
 8022784:	edc4 8a07 	vstr	s17, [r4, #28]
}
 8022788:	ecbd 8b02 	vpop	{d8}
 802278c:	bd70      	pop	{r4, r5, r6, pc}
 802278e:	bf00      	nop
 8022790:	200194e8 	.word	0x200194e8
 8022794:	00000000 	.word	0x00000000

08022798 <tOnePole_free>:
    _tOnePole* f = *ft;
 8022798:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)f, f->mempool);
 802279a:	6801      	ldr	r1, [r0, #0]
 802279c:	f001 be40 	b.w	8024420 <mpool_free>

080227a0 <tOnePole_setFreq>:
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 80227a0:	4b0b      	ldr	r3, [pc, #44]	; (80227d0 <tOnePole_setFreq+0x30>)
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 80227a2:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
{
 80227a6:	b510      	push	{r4, lr}
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 80227a8:	edd3 0a03 	vldr	s1, [r3, #12]
    _tOnePole* f = *ft;
 80227ac:	6804      	ldr	r4, [r0, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 80227ae:	ee60 0a20 	vmul.f32	s1, s0, s1
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 80227b2:	ed9f 0a08 	vldr	s0, [pc, #32]	; 80227d4 <tOnePole_setFreq+0x34>
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 80227b6:	edc4 0a04 	vstr	s1, [r4, #16]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 80227ba:	f001 fb7b 	bl	8023eb4 <LEAF_clip>
    f->a1 = 1.0f - f->b0;
 80227be:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 80227c2:	ed84 0a04 	vstr	s0, [r4, #16]
    f->a1 = 1.0f - f->b0;
 80227c6:	ee37 0ac0 	vsub.f32	s0, s15, s0
 80227ca:	ed84 0a03 	vstr	s0, [r4, #12]
}
 80227ce:	bd10      	pop	{r4, pc}
 80227d0:	200194e8 	.word	0x200194e8
 80227d4:	00000000 	.word	0x00000000

080227d8 <tOnePole_tick>:
    f->gain = gain;
}

float   tOnePole_tick(tOnePole* const ft, float input)
{
    _tOnePole* f = *ft;
 80227d8:	6803      	ldr	r3, [r0, #0]
    
    float in = input * f->gain;
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
 80227da:	ed93 6a07 	vldr	s12, [r3, #28]
    float in = input * f->gain;
 80227de:	ed93 7a01 	vldr	s14, [r3, #4]
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
 80227e2:	edd3 7a03 	vldr	s15, [r3, #12]
    float in = input * f->gain;
 80227e6:	ee20 7a07 	vmul.f32	s14, s0, s14
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
 80227ea:	edd3 6a04 	vldr	s13, [r3, #16]
 80227ee:	ee27 0a86 	vmul.f32	s0, s15, s12
    
    f->lastIn = in;
 80227f2:	ed83 7a06 	vstr	s14, [r3, #24]
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
 80227f6:	eea6 0a87 	vfma.f32	s0, s13, s14
    f->lastOut = out;
 80227fa:	ed83 0a07 	vstr	s0, [r3, #28]
    
    return out;
}
 80227fe:	4770      	bx	lr

08022800 <tSVF_init>:
}

// Less efficient, more accurate version of SVF, in which cutoff frequency is taken as floating point Hz value and tanf
// is calculated when frequency changes.
void tSVF_init(tSVF* const svff, SVFType type, float freq, float Q)
{
 8022800:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

}

void    tSVF_initToPool     (tSVF* const svff, SVFType type, float freq, float Q, tMempool* const mp)
{
    _tMempool* m = *mp;
 8022804:	4f38      	ldr	r7, [pc, #224]	; (80228e8 <tSVF_init+0xe8>)
{
 8022806:	460e      	mov	r6, r1
 8022808:	4681      	mov	r9, r0
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
 802280a:	203c      	movs	r0, #60	; 0x3c
    svf->mempool = m;

    svf->type = type;

    svf->ic1eq = 0;
 802280c:	2500      	movs	r5, #0
{
 802280e:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8022812:	f8d7 8018 	ldr.w	r8, [r7, #24]
{
 8022816:	eef0 8a40 	vmov.f32	s17, s0
 802281a:	eeb0 8a60 	vmov.f32	s16, s1
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
 802281e:	4641      	mov	r1, r8
 8022820:	f001 fd4a 	bl	80242b8 <mpool_alloc>
 8022824:	f8c9 0000 	str.w	r0, [r9]
    svf->mempool = m;
 8022828:	f8c0 8000 	str.w	r8, [r0]
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
 802282c:	4604      	mov	r4, r0
    svf->type = type;
 802282e:	7106      	strb	r6, [r0, #4]
    svf->ic2eq = 0;
    svf->Q = Q;
    svf->cutoff = freq;
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8022830:	edd7 7a01 	vldr	s15, [r7, #4]
 8022834:	ed9f 0a2d 	vldr	s0, [pc, #180]	; 80228ec <tSVF_init+0xec>
    svf->Q = Q;
 8022838:	ed80 8a03 	vstr	s16, [r0, #12]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 802283c:	ee27 0a80 	vmul.f32	s0, s15, s0
    svf->cutoff = freq;
 8022840:	edc0 8a02 	vstr	s17, [r0, #8]
    svf->ic1eq = 0;
 8022844:	6105      	str	r5, [r0, #16]
    svf->ic2eq = 0;
 8022846:	6145      	str	r5, [r0, #20]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8022848:	ee20 0a28 	vmul.f32	s0, s0, s17
 802284c:	f004 ffd6 	bl	80277fc <tanf>
    svf->k = 1.0f/Q;
 8022850:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8022854:	ed84 0a06 	vstr	s0, [r4, #24]
    svf->a3 = svf->g*svf->a2;
    svf->cH = 0.0f;
    svf->cB = 0.0f;
    svf->cL = 1.0f;

    if (type == SVFTypeLowpass)
 8022858:	2e01      	cmp	r6, #1
    svf->cH = 0.0f;
 802285a:	62e5      	str	r5, [r4, #44]	; 0x2c
    svf->k = 1.0f/Q;
 802285c:	ee87 7a88 	vdiv.f32	s14, s15, s16
    svf->cB = 0.0f;
 8022860:	6325      	str	r5, [r4, #48]	; 0x30
    svf->cL = 1.0f;
 8022862:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022866:	ee70 6a07 	vadd.f32	s13, s0, s14
    svf->k = 1.0f/Q;
 802286a:	ed84 7a07 	vstr	s14, [r4, #28]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 802286e:	eeb0 7a67 	vmov.f32	s14, s15
 8022872:	eea0 7a26 	vfma.f32	s14, s0, s13
 8022876:	eec7 6a87 	vdiv.f32	s13, s15, s14
    svf->a2 = svf->g*svf->a1;
 802287a:	ee20 7a26 	vmul.f32	s14, s0, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 802287e:	edc4 6a08 	vstr	s13, [r4, #32]
    svf->a3 = svf->g*svf->a2;
 8022882:	ee20 0a07 	vmul.f32	s0, s0, s14
    svf->a2 = svf->g*svf->a1;
 8022886:	ed84 7a09 	vstr	s14, [r4, #36]	; 0x24
    svf->a3 = svf->g*svf->a2;
 802288a:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
    if (type == SVFTypeLowpass)
 802288e:	d016      	beq.n	80228be <tSVF_init+0xbe>
        svf->cH = 0.0f;
        svf->cB = 0.0f;
        svf->cBK = 0.0f;
        svf->cL = 1.0f;
    }
    else if (type == SVFTypeBandpass)
 8022890:	2e02      	cmp	r6, #2
 8022892:	d00c      	beq.n	80228ae <tSVF_init+0xae>
        svf->cB = 1.0f;
        svf->cBK = 0.0f;
        svf->cL = 0.0f;
    }

    else if (type == SVFTypeHighpass)
 8022894:	b1c6      	cbz	r6, 80228c8 <tSVF_init+0xc8>
        svf->cB = 0.0f;
        svf->cBK = -1.0f;
        svf->cL = -1.0f;
    }

    else if (type == SVFTypeNotch)
 8022896:	2e03      	cmp	r6, #3
 8022898:	d01f      	beq.n	80228da <tSVF_init+0xda>
        svf->cBK = -1.0f;
        svf->cL = 0.0f;
    }


    else if (type == SVFTypePeak)
 802289a:	2e04      	cmp	r6, #4
 802289c:	d10b      	bne.n	80228b6 <tSVF_init+0xb6>
    {
        svf->cH = 1.0f;
        svf->cB = 0.0f;
        svf->cBK = -1.0f;
 802289e:	4a14      	ldr	r2, [pc, #80]	; (80228f0 <tSVF_init+0xf0>)
        svf->cL = -2.0f;
 80228a0:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
        svf->cH = 1.0f;
 80228a4:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cBK = -1.0f;
 80228a8:	63a2      	str	r2, [r4, #56]	; 0x38
        svf->cL = -2.0f;
 80228aa:	6363      	str	r3, [r4, #52]	; 0x34
}
 80228ac:	e003      	b.n	80228b6 <tSVF_init+0xb6>
        svf->cB = 1.0f;
 80228ae:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
        svf->cBK = 0.0f;
 80228b2:	63a5      	str	r5, [r4, #56]	; 0x38
        svf->cL = 0.0f;
 80228b4:	6365      	str	r5, [r4, #52]	; 0x34
}
 80228b6:	ecbd 8b02 	vpop	{d8}
 80228ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = 0.0f;
 80228be:	63a5      	str	r5, [r4, #56]	; 0x38
}
 80228c0:	ecbd 8b02 	vpop	{d8}
 80228c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = -1.0f;
 80228c8:	4b09      	ldr	r3, [pc, #36]	; (80228f0 <tSVF_init+0xf0>)
        svf->cH = 1.0f;
 80228ca:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cBK = -1.0f;
 80228ce:	63a3      	str	r3, [r4, #56]	; 0x38
        svf->cL = -1.0f;
 80228d0:	6363      	str	r3, [r4, #52]	; 0x34
}
 80228d2:	ecbd 8b02 	vpop	{d8}
 80228d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = -1.0f;
 80228da:	4b05      	ldr	r3, [pc, #20]	; (80228f0 <tSVF_init+0xf0>)
        svf->cH = 1.0f;
 80228dc:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cL = 0.0f;
 80228e0:	6365      	str	r5, [r4, #52]	; 0x34
        svf->cBK = -1.0f;
 80228e2:	63a3      	str	r3, [r4, #56]	; 0x38
 80228e4:	e7e7      	b.n	80228b6 <tSVF_init+0xb6>
 80228e6:	bf00      	nop
 80228e8:	200194e8 	.word	0x200194e8
 80228ec:	40490fdb 	.word	0x40490fdb
 80228f0:	bf800000 	.word	0xbf800000

080228f4 <tSVF_free>:
    }
}

void    tSVF_free   (tSVF* const svff)
{
    _tSVF* svf = *svff;
 80228f4:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)svf, svf->mempool);
 80228f6:	6801      	ldr	r1, [r0, #0]
 80228f8:	f001 bd92 	b.w	8024420 <mpool_free>

080228fc <tSVF_tick>:
}

float   tSVF_tick(tSVF* const svff, float v0)
{
    _tSVF* svf = *svff;
 80228fc:	6803      	ldr	r3, [r0, #0]
    
    float v1,v2,v3;
    v3 = v0 - svf->ic2eq;
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 80228fe:	eef0 4a00 	vmov.f32	s9, #0	; 0x40000000  2.0
    v3 = v0 - svf->ic2eq;
 8022902:	edd3 6a05 	vldr	s13, [r3, #20]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 8022906:	ed93 6a04 	vldr	s12, [r3, #16]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 802290a:	eef0 5a66 	vmov.f32	s11, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 802290e:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    v3 = v0 - svf->ic2eq;
 8022912:	ee30 4a66 	vsub.f32	s8, s0, s13
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 8022916:	edd3 2a0a 	vldr	s5, [r3, #40]	; 0x28
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
    
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
 802291a:	edd3 3a0e 	vldr	s7, [r3, #56]	; 0x38
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 802291e:	eee6 5a27 	vfma.f32	s11, s12, s15
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 8022922:	ed93 3a08 	vldr	s6, [r3, #32]
 8022926:	ee67 7a84 	vmul.f32	s15, s15, s8
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
 802292a:	ed93 2a07 	vldr	s4, [r3, #28]
 802292e:	ed93 5a0c 	vldr	s10, [r3, #48]	; 0x30
 8022932:	ed93 7a0d 	vldr	s14, [r3, #52]	; 0x34
 8022936:	eea2 5a23 	vfma.f32	s10, s4, s7
 802293a:	edd3 3a0b 	vldr	s7, [r3, #44]	; 0x2c
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 802293e:	eee3 7a06 	vfma.f32	s15, s6, s12
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 8022942:	eee2 5a84 	vfma.f32	s11, s5, s8
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 8022946:	ee97 6aa4 	vfnms.f32	s12, s15, s9
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
 802294a:	ee25 7a87 	vmul.f32	s14, s11, s14
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
 802294e:	eed5 6aa4 	vfnms.f32	s13, s11, s9
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
 8022952:	eea7 7a85 	vfma.f32	s14, s15, s10
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 8022956:	ed83 6a04 	vstr	s12, [r3, #16]
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
 802295a:	edc3 6a05 	vstr	s13, [r3, #20]
}
 802295e:	eea3 7a80 	vfma.f32	s14, s7, s0
 8022962:	eeb0 0a47 	vmov.f32	s0, s14
 8022966:	4770      	bx	lr

08022968 <tSVF_setFreq>:

void     tSVF_setFreq(tSVF* const svff, float freq)
{
    _tSVF* svf = *svff;
    svf->cutoff = freq;
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8022968:	4b14      	ldr	r3, [pc, #80]	; (80229bc <tSVF_setFreq+0x54>)
 802296a:	ed9f 7a15 	vldr	s14, [pc, #84]	; 80229c0 <tSVF_setFreq+0x58>
{
 802296e:	b510      	push	{r4, lr}
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8022970:	edd3 7a01 	vldr	s15, [r3, #4]
    _tSVF* svf = *svff;
 8022974:	6804      	ldr	r4, [r0, #0]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8022976:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->cutoff = freq;
 802297a:	ed84 0a02 	vstr	s0, [r4, #8]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 802297e:	ee27 0a80 	vmul.f32	s0, s15, s0
 8022982:	f004 ff3b 	bl	80277fc <tanf>
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022986:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802298a:	edd4 7a07 	vldr	s15, [r4, #28]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 802298e:	ed84 0a06 	vstr	s0, [r4, #24]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022992:	ee70 7a27 	vadd.f32	s15, s0, s15
 8022996:	eeb0 7a66 	vmov.f32	s14, s13
 802299a:	eea0 7a27 	vfma.f32	s14, s0, s15
 802299e:	eef0 7a47 	vmov.f32	s15, s14
 80229a2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    svf->a2 = svf->g * svf->a1;
 80229a6:	ee60 7a07 	vmul.f32	s15, s0, s14
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 80229aa:	ed84 7a08 	vstr	s14, [r4, #32]
    svf->a3 = svf->g * svf->a2;
 80229ae:	ee20 0a27 	vmul.f32	s0, s0, s15
    svf->a2 = svf->g * svf->a1;
 80229b2:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
 80229b6:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
}
 80229ba:	bd10      	pop	{r4, pc}
 80229bc:	200194e8 	.word	0x200194e8
 80229c0:	40490fdb 	.word	0x40490fdb

080229c4 <tEfficientSVF_init>:
    svf->a3 = svf->g * svf->a2;
}

// Efficient version of tSVF where frequency is set based on 12-bit integer input for lookup in tanh wavetable.
void   tEfficientSVF_init(tEfficientSVF* const svff, SVFType type, uint16_t input, float Q)
{
 80229c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tEfficientSVF_initToPool(svff, type, input, Q, &leaf.mempool);
}

void    tEfficientSVF_initToPool    (tEfficientSVF* const svff, SVFType type, uint16_t input, float Q, tMempool* const mp)
{
    _tMempool* m = *mp;
 80229c6:	4b1b      	ldr	r3, [pc, #108]	; (8022a34 <tEfficientSVF_init+0x70>)
{
 80229c8:	4607      	mov	r7, r0
 80229ca:	460d      	mov	r5, r1
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
 80229cc:	202c      	movs	r0, #44	; 0x2c
{
 80229ce:	4616      	mov	r6, r2
 80229d0:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 80229d4:	699c      	ldr	r4, [r3, #24]
{
 80229d6:	eeb0 8a40 	vmov.f32	s16, s0
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
 80229da:	4621      	mov	r1, r4
 80229dc:	f001 fc6c 	bl	80242b8 <mpool_alloc>
    
    svf->ic1eq = 0;
    svf->ic2eq = 0;
    
    svf->g = __leaf_table_filtertan[input];
    svf->k = 1.0f/Q;
 80229e0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    svf->g = __leaf_table_filtertan[input];
 80229e4:	4a14      	ldr	r2, [pc, #80]	; (8022a38 <tEfficientSVF_init+0x74>)
    svf->ic1eq = 0;
 80229e6:	2300      	movs	r3, #0
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
 80229e8:	6038      	str	r0, [r7, #0]
    svf->k = 1.0f/Q;
 80229ea:	eec7 6a08 	vdiv.f32	s13, s14, s16
    svf->g = __leaf_table_filtertan[input];
 80229ee:	eb02 0286 	add.w	r2, r2, r6, lsl #2
    svf->mempool = m;
 80229f2:	6004      	str	r4, [r0, #0]
    svf->g = __leaf_table_filtertan[input];
 80229f4:	edd2 7a00 	vldr	s15, [r2]
    svf->type = type;
 80229f8:	7105      	strb	r5, [r0, #4]
    svf->g = __leaf_table_filtertan[input];
 80229fa:	edc0 7a06 	vstr	s15, [r0, #24]
    svf->ic1eq = 0;
 80229fe:	6103      	str	r3, [r0, #16]
    svf->ic2eq = 0;
 8022a00:	6143      	str	r3, [r0, #20]
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
 8022a02:	ee37 6aa6 	vadd.f32	s12, s15, s13
    svf->k = 1.0f/Q;
 8022a06:	edc0 6a07 	vstr	s13, [r0, #28]
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
 8022a0a:	eef0 6a47 	vmov.f32	s13, s14
 8022a0e:	eee7 6a86 	vfma.f32	s13, s15, s12
 8022a12:	eeb0 6a66 	vmov.f32	s12, s13
 8022a16:	eec7 6a06 	vdiv.f32	s13, s14, s12
    svf->a2 = svf->g*svf->a1;
 8022a1a:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
 8022a1e:	edc0 6a08 	vstr	s13, [r0, #32]
    svf->a3 = svf->g*svf->a2;
 8022a22:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g*svf->a1;
 8022a26:	ed80 7a09 	vstr	s14, [r0, #36]	; 0x24
    svf->a3 = svf->g*svf->a2;
 8022a2a:	edc0 7a0a 	vstr	s15, [r0, #40]	; 0x28
}
 8022a2e:	ecbd 8b02 	vpop	{d8}
 8022a32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8022a34:	200194e8 	.word	0x200194e8
 8022a38:	0802b9b4 	.word	0x0802b9b4

08022a3c <tEfficientSVF_free>:
}

void    tEfficientSVF_free (tEfficientSVF* const svff)
{
    _tEfficientSVF* svf = *svff;
 8022a3c:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)svf, svf->mempool);
 8022a3e:	6801      	ldr	r1, [r0, #0]
 8022a40:	f001 bcee 	b.w	8024420 <mpool_free>

08022a44 <tEfficientSVF_tick>:
}

float   tEfficientSVF_tick(tEfficientSVF* const svff, float v0)
{
    _tEfficientSVF* svf = *svff;
 8022a44:	6803      	ldr	r3, [r0, #0]
    
    float v1,v2,v3;
    v3 = v0 - svf->ic2eq;
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 8022a46:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
    v3 = v0 - svf->ic2eq;
 8022a4a:	edd3 6a05 	vldr	s13, [r3, #20]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 8022a4e:	ed93 6a04 	vldr	s12, [r3, #16]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 8022a52:	eeb0 7a66 	vmov.f32	s14, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 8022a56:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    v3 = v0 - svf->ic2eq;
 8022a5a:	ee70 5a66 	vsub.f32	s11, s0, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 8022a5e:	ed93 4a08 	vldr	s8, [r3, #32]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 8022a62:	edd3 4a0a 	vldr	s9, [r3, #40]	; 0x28
 8022a66:	eea6 7a27 	vfma.f32	s14, s12, s15
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
    
    if (svf->type == SVFTypeLowpass)        return v2;
 8022a6a:	791a      	ldrb	r2, [r3, #4]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 8022a6c:	ee67 7aa5 	vmul.f32	s15, s15, s11
    if (svf->type == SVFTypeLowpass)        return v2;
 8022a70:	2a01      	cmp	r2, #1
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 8022a72:	eee4 7a06 	vfma.f32	s15, s8, s12
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 8022a76:	eea4 7aa5 	vfma.f32	s14, s9, s11
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 8022a7a:	ee97 6a85 	vfnms.f32	s12, s15, s10
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
 8022a7e:	ee77 5a07 	vadd.f32	s11, s14, s14
 8022a82:	ee75 6ae6 	vsub.f32	s13, s11, s13
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 8022a86:	ed83 6a04 	vstr	s12, [r3, #16]
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
 8022a8a:	edc3 6a05 	vstr	s13, [r3, #20]
    if (svf->type == SVFTypeLowpass)        return v2;
 8022a8e:	d008      	beq.n	8022aa2 <tEfficientSVF_tick+0x5e>
    else if (svf->type == SVFTypeBandpass)  return v1;
 8022a90:	2a02      	cmp	r2, #2
 8022a92:	d009      	beq.n	8022aa8 <tEfficientSVF_tick+0x64>
    else if (svf->type == SVFTypeHighpass)  return v0 - (svf->k * v1) - v2;
 8022a94:	b16a      	cbz	r2, 8022ab2 <tEfficientSVF_tick+0x6e>
    else if (svf->type == SVFTypeNotch)     return v0 - (svf->k * v1);
 8022a96:	2a03      	cmp	r2, #3
 8022a98:	d014      	beq.n	8022ac4 <tEfficientSVF_tick+0x80>
    else if (svf->type == SVFTypePeak)      return v0 - (svf->k * v1) - (2.0f * v2);
 8022a9a:	2a04      	cmp	r2, #4
 8022a9c:	d019      	beq.n	8022ad2 <tEfficientSVF_tick+0x8e>
    else                                    return 0.0f;
 8022a9e:	ed9f 7a10 	vldr	s14, [pc, #64]	; 8022ae0 <tEfficientSVF_tick+0x9c>
    
}
 8022aa2:	eeb0 0a47 	vmov.f32	s0, s14
 8022aa6:	4770      	bx	lr
    else if (svf->type == SVFTypeBandpass)  return v1;
 8022aa8:	eeb0 7a67 	vmov.f32	s14, s15
}
 8022aac:	eeb0 0a47 	vmov.f32	s0, s14
 8022ab0:	4770      	bx	lr
    else if (svf->type == SVFTypeHighpass)  return v0 - (svf->k * v1) - v2;
 8022ab2:	edd3 6a07 	vldr	s13, [r3, #28]
 8022ab6:	eea6 0ae7 	vfms.f32	s0, s13, s15
 8022aba:	ee30 7a47 	vsub.f32	s14, s0, s14
}
 8022abe:	eeb0 0a47 	vmov.f32	s0, s14
 8022ac2:	4770      	bx	lr
    else if (svf->type == SVFTypeNotch)     return v0 - (svf->k * v1);
 8022ac4:	ed93 7a07 	vldr	s14, [r3, #28]
 8022ac8:	eea7 0a67 	vfms.f32	s0, s14, s15
 8022acc:	eeb0 7a40 	vmov.f32	s14, s0
 8022ad0:	e7e7      	b.n	8022aa2 <tEfficientSVF_tick+0x5e>
    else if (svf->type == SVFTypePeak)      return v0 - (svf->k * v1) - (2.0f * v2);
 8022ad2:	ed93 7a07 	vldr	s14, [r3, #28]
 8022ad6:	eea7 0a67 	vfms.f32	s0, s14, s15
 8022ada:	ee30 7a65 	vsub.f32	s14, s0, s11
 8022ade:	e7e0      	b.n	8022aa2 <tEfficientSVF_tick+0x5e>
 8022ae0:	00000000 	.word	0x00000000

08022ae4 <tEfficientSVF_setFreq>:

void     tEfficientSVF_setFreq(tEfficientSVF* const svff, uint16_t input)
{
    _tEfficientSVF* svf = *svff;
    
    svf->g = __leaf_table_filtertan[input];
 8022ae4:	4a10      	ldr	r2, [pc, #64]	; (8022b28 <tEfficientSVF_setFreq+0x44>)
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022ae6:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    _tEfficientSVF* svf = *svff;
 8022aea:	6803      	ldr	r3, [r0, #0]
    svf->g = __leaf_table_filtertan[input];
 8022aec:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022af0:	ed93 7a07 	vldr	s14, [r3, #28]
 8022af4:	eef0 6a46 	vmov.f32	s13, s12
    svf->g = __leaf_table_filtertan[input];
 8022af8:	edd1 7a00 	vldr	s15, [r1]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022afc:	ee37 7a87 	vadd.f32	s14, s15, s14
    svf->g = __leaf_table_filtertan[input];
 8022b00:	edc3 7a06 	vstr	s15, [r3, #24]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022b04:	eee7 6a87 	vfma.f32	s13, s15, s14
 8022b08:	eeb0 7a66 	vmov.f32	s14, s13
 8022b0c:	eec6 6a07 	vdiv.f32	s13, s12, s14
    svf->a2 = svf->g * svf->a1;
 8022b10:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022b14:	edc3 6a08 	vstr	s13, [r3, #32]
    svf->a3 = svf->g * svf->a2;
 8022b18:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g * svf->a1;
 8022b1c:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
 8022b20:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
}
 8022b24:	4770      	bx	lr
 8022b26:	bf00      	nop
 8022b28:	0802b9b4 	.word	0x0802b9b4

08022b2c <tEfficientSVF_setQ>:

void     tEfficientSVF_setQ(tEfficientSVF* const svff, float Q)
{
    _tEfficientSVF* svf = *svff;
    
    svf->k = 1.0f/Q;
 8022b2c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    _tEfficientSVF* svf = *svff;
 8022b30:	6803      	ldr	r3, [r0, #0]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022b32:	edd3 7a06 	vldr	s15, [r3, #24]
    svf->k = 1.0f/Q;
 8022b36:	ee87 0a00 	vdiv.f32	s0, s14, s0
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022b3a:	eeb0 6a47 	vmov.f32	s12, s14
 8022b3e:	ee70 6a27 	vadd.f32	s13, s0, s15
    svf->k = 1.0f/Q;
 8022b42:	ed83 0a07 	vstr	s0, [r3, #28]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022b46:	eea7 6aa6 	vfma.f32	s12, s15, s13
 8022b4a:	eec7 6a06 	vdiv.f32	s13, s14, s12
    svf->a2 = svf->g * svf->a1;
 8022b4e:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8022b52:	edc3 6a08 	vstr	s13, [r3, #32]
    svf->a3 = svf->g * svf->a2;
 8022b56:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g * svf->a1;
 8022b5a:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
 8022b5e:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
}
 8022b62:	4770      	bx	lr

08022b64 <tHighpass_init>:

/* Highpass */
void    tHighpass_init(tHighpass* const ft, float freq)
{
 8022b64:	b570      	push	{r4, r5, r6, lr}
    tHighpass_initToPool(ft, freq, &leaf.mempool);
}

void    tHighpass_initToPool    (tHighpass* const ft, float freq, tMempool* const mp)
{
    _tMempool* m = *mp;
 8022b66:	4c0e      	ldr	r4, [pc, #56]	; (8022ba0 <tHighpass_init+0x3c>)
{
 8022b68:	4606      	mov	r6, r0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 8022b6a:	2014      	movs	r0, #20
    _tMempool* m = *mp;
 8022b6c:	69a5      	ldr	r5, [r4, #24]
{
 8022b6e:	ed2d 8b02 	vpush	{d8}
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 8022b72:	4629      	mov	r1, r5
{
 8022b74:	eeb0 8a40 	vmov.f32	s16, s0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 8022b78:	f001 fbfa 	bl	8024370 <mpool_calloc>
    f->mempool = m;
    
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022b7c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 8022b80:	6030      	str	r0, [r6, #0]
    f->ys = 0.0f;
 8022b82:	2300      	movs	r3, #0
    f->mempool = m;
 8022b84:	6005      	str	r5, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022b86:	ed94 7a03 	vldr	s14, [r4, #12]
    f->xs = 0.0f;
    
    f->frequency = freq;
 8022b8a:	ed80 8a04 	vstr	s16, [r0, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022b8e:	eee8 7a47 	vfms.f32	s15, s16, s14
    f->ys = 0.0f;
 8022b92:	6083      	str	r3, [r0, #8]
    f->xs = 0.0f;
 8022b94:	6043      	str	r3, [r0, #4]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022b96:	edc0 7a03 	vstr	s15, [r0, #12]
}
 8022b9a:	ecbd 8b02 	vpop	{d8}
 8022b9e:	bd70      	pop	{r4, r5, r6, pc}
 8022ba0:	200194e8 	.word	0x200194e8

08022ba4 <tHighpass_initToPool>:
{
 8022ba4:	b538      	push	{r3, r4, r5, lr}
 8022ba6:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8022baa:	680c      	ldr	r4, [r1, #0]
{
 8022bac:	4605      	mov	r5, r0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 8022bae:	2014      	movs	r0, #20
{
 8022bb0:	eeb0 8a40 	vmov.f32	s16, s0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 8022bb4:	4621      	mov	r1, r4
 8022bb6:	f001 fbdb 	bl	8024370 <mpool_calloc>
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022bba:	4b09      	ldr	r3, [pc, #36]	; (8022be0 <tHighpass_initToPool+0x3c>)
 8022bbc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 8022bc0:	6028      	str	r0, [r5, #0]
    f->mempool = m;
 8022bc2:	6004      	str	r4, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022bc4:	ed93 7a03 	vldr	s14, [r3, #12]
    f->ys = 0.0f;
 8022bc8:	2300      	movs	r3, #0
    f->frequency = freq;
 8022bca:	ed80 8a04 	vstr	s16, [r0, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022bce:	eee7 7a48 	vfms.f32	s15, s14, s16
    f->ys = 0.0f;
 8022bd2:	6083      	str	r3, [r0, #8]
    f->xs = 0.0f;
 8022bd4:	6043      	str	r3, [r0, #4]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022bd6:	edc0 7a03 	vstr	s15, [r0, #12]
}
 8022bda:	ecbd 8b02 	vpop	{d8}
 8022bde:	bd38      	pop	{r3, r4, r5, pc}
 8022be0:	200194e8 	.word	0x200194e8

08022be4 <tHighpass_free>:

void    tHighpass_free  (tHighpass* const ft)
{
    _tHighpass* f = *ft;
 8022be4:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)f, f->mempool);
 8022be6:	6801      	ldr	r1, [r0, #0]
 8022be8:	f001 bc1a 	b.w	8024420 <mpool_free>

08022bec <tHighpass_setFreq>:

void     tHighpass_setFreq(tHighpass* const ft, float freq)
{
    _tHighpass* f = *ft;
    f->frequency = freq;
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022bec:	4a06      	ldr	r2, [pc, #24]	; (8022c08 <tHighpass_setFreq+0x1c>)
 8022bee:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft;
 8022bf2:	6803      	ldr	r3, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022bf4:	ed92 7a03 	vldr	s14, [r2, #12]
    f->frequency = freq;
 8022bf8:	ed83 0a04 	vstr	s0, [r3, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8022bfc:	eee7 7a40 	vfms.f32	s15, s14, s0
 8022c00:	edc3 7a03 	vstr	s15, [r3, #12]
    
}
 8022c04:	4770      	bx	lr
 8022c06:	bf00      	nop
 8022c08:	200194e8 	.word	0x200194e8

08022c0c <tHighpass_tick>:
}

// From JOS DC Blocker
float   tHighpass_tick(tHighpass* const ft, float x)
{
    _tHighpass* f = *ft;
 8022c0c:	6803      	ldr	r3, [r0, #0]
    f->ys = x - f->xs + f->R * f->ys;
 8022c0e:	edd3 7a01 	vldr	s15, [r3, #4]
 8022c12:	ed93 7a02 	vldr	s14, [r3, #8]
 8022c16:	edd3 6a03 	vldr	s13, [r3, #12]
    f->xs = x;
 8022c1a:	ed83 0a01 	vstr	s0, [r3, #4]
    f->ys = x - f->xs + f->R * f->ys;
 8022c1e:	eed6 7a87 	vfnms.f32	s15, s13, s14
 8022c22:	ee37 0a80 	vadd.f32	s0, s15, s0
 8022c26:	ed83 0a02 	vstr	s0, [r3, #8]
    return f->ys;
}
 8022c2a:	4770      	bx	lr

08022c2c <tVZFilter_init>:
}

/////

void    tVZFilter_init           (tVZFilter* const vf, VZFilterType type, float freq, float bandWidth)
{
 8022c2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    tVZFilter_initToPool(vf, type, freq, bandWidth, &leaf.mempool);
}

void    tVZFilter_initToPool     (tVZFilter* const vf, VZFilterType type, float freq, float bandWidth, tMempool* const mp)
{
    _tMempool* m = *mp;
 8022c30:	4cc8      	ldr	r4, [pc, #800]	; (8022f54 <tVZFilter_init+0x328>)
{
 8022c32:	4605      	mov	r5, r0
 8022c34:	4688      	mov	r8, r1
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
 8022c36:	2044      	movs	r0, #68	; 0x44
    f->mempool = m;
    
    f->fc   = freq;
    f->type = type;
    f->G    = ONE_OVER_SQRT2;
 8022c38:	4fc7      	ldr	r7, [pc, #796]	; (8022f58 <tVZFilter_init+0x32c>)
{
 8022c3a:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
 8022c3e:	69a6      	ldr	r6, [r4, #24]
{
 8022c40:	eef0 8a40 	vmov.f32	s17, s0
 8022c44:	eeb0 8a60 	vmov.f32	s16, s1
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
 8022c48:	4631      	mov	r1, r6
 8022c4a:	f001 fb35 	bl	80242b8 <mpool_alloc>
    f->invG    = 1.0f/ONE_OVER_SQRT2;
    f->B    = bandWidth;
    f->m    = 0.0f;
 8022c4e:	2300      	movs	r3, #0
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
 8022c50:	6028      	str	r0, [r5, #0]
    f->mempool = m;
 8022c52:	6006      	str	r6, [r0, #0]
    f->type = type;
 8022c54:	f880 8004 	strb.w	r8, [r0, #4]
    f->s1 = 0.0f;
    f->s2 = 0.0f;
    f->sr = leaf.sampleRate;
 8022c58:	6821      	ldr	r1, [r4, #0]
    f->inv_sr = leaf.invSampleRate;
 8022c5a:	6862      	ldr	r2, [r4, #4]
    f->invG    = 1.0f/ONE_OVER_SQRT2;
 8022c5c:	4ebf      	ldr	r6, [pc, #764]	; (8022f5c <tVZFilter_init+0x330>)
    f->fc   = freq;
 8022c5e:	edc0 8a0a 	vstr	s17, [r0, #40]	; 0x28
    f->m    = 0.0f;
 8022c62:	6383      	str	r3, [r0, #56]	; 0x38
    f->s1 = 0.0f;
 8022c64:	6083      	str	r3, [r0, #8]
    f->s2 = 0.0f;
 8022c66:	60c3      	str	r3, [r0, #12]
    f->B    = bandWidth;
 8022c68:	ed80 8a0d 	vstr	s16, [r0, #52]	; 0x34
    f->G    = ONE_OVER_SQRT2;
 8022c6c:	62c7      	str	r7, [r0, #44]	; 0x2c
    f->invG    = 1.0f/ONE_OVER_SQRT2;
 8022c6e:	6306      	str	r6, [r0, #48]	; 0x30
    f->sr = leaf.sampleRate;
 8022c70:	63c1      	str	r1, [r0, #60]	; 0x3c
    f->inv_sr = leaf.invSampleRate;
 8022c72:	6402      	str	r2, [r0, #64]	; 0x40


void   tVZFilter_calcCoeffs           (tVZFilter* const vf)
{

    _tVZFilter* f = *vf;
 8022c74:	682c      	ldr	r4, [r5, #0]
    f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8022c76:	eddf 7aba 	vldr	s15, [pc, #744]	; 8022f60 <tVZFilter_init+0x334>
 8022c7a:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 8022c7e:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
 8022c82:	ee28 8a07 	vmul.f32	s16, s16, s14
 8022c86:	ee28 8a27 	vmul.f32	s16, s16, s15
 8022c8a:	eeb0 0a48 	vmov.f32	s0, s16
 8022c8e:	f004 fdb5 	bl	80277fc <tanf>

      switch( f->type )
 8022c92:	7923      	ldrb	r3, [r4, #4]
    f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8022c94:	eef0 8a40 	vmov.f32	s17, s0
 8022c98:	ed84 0a04 	vstr	s0, [r4, #16]
      switch( f->type )
 8022c9c:	2b0a      	cmp	r3, #10
 8022c9e:	f200 81b5 	bhi.w	802300c <tVZFilter_init+0x3e0>
 8022ca2:	e8df f013 	tbh	[pc, r3, lsl #1]
 8022ca6:	0054      	.short	0x0054
 8022ca8:	006a005f 	.word	0x006a005f
 8022cac:	00ac0075 	.word	0x00ac0075
 8022cb0:	011700e4 	.word	0x011700e4
 8022cb4:	01630137 	.word	0x01630137
 8022cb8:	000b01a8 	.word	0x000b01a8
}

float tVZFilter_BandwidthToR(tVZFilter* const vf, float B)
{
    _tVZFilter* f = *vf;
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8022cbc:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8022cc0:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 8022cc4:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8022cc6:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8022cca:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8022cce:	f004 fc57 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8022cd2:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 8022cd6:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8022cda:	ed9f 7aa1 	vldr	s14, [pc, #644]	; 8022f60 <tVZFilter_init+0x334>
 8022cde:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8022ce2:	ee67 7a87 	vmul.f32	s15, s15, s14
 8022ce6:	ee27 0a80 	vmul.f32	s0, s15, s0
 8022cea:	f004 fd87 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8022cee:	ed95 7a04 	vldr	s14, [r5, #16]
                               // unwarped: r = pow(2, -B/2) -> approximation for low
                               // center-frequencies
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8022cf2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8022cf6:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8022cfa:	edc4 7a07 	vstr	s15, [r4, #28]
 8022cfe:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8022d02:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8022d06:	ee20 0a00 	vmul.f32	s0, s0, s0
 8022d0a:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8022d0e:	ee20 0a07 	vmul.f32	s0, s0, s14
 8022d12:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8022d16:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8022d1a:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8022d1e:	ee77 7aa7 	vadd.f32	s15, s15, s15
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8022d22:	eeb1 7a67 	vneg.f32	s14, s15
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8022d26:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8022d2a:	ed84 7a08 	vstr	s14, [r4, #32]
      f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
 8022d2e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8022d32:	ee77 7aa8 	vadd.f32	s15, s15, s17
 8022d36:	eef0 6a47 	vmov.f32	s13, s14
 8022d3a:	eee7 6aa8 	vfma.f32	s13, s15, s17
 8022d3e:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8022d42:	edc4 7a06 	vstr	s15, [r4, #24]
}
 8022d46:	ecbd 8b04 	vpop	{d8-d9}
 8022d4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8022d4e:	2300      	movs	r3, #0
 8022d50:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 8022d54:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8022d58:	6262      	str	r2, [r4, #36]	; 0x24
            f->R2 = f->invG;
 8022d5a:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8022d5e:	61e3      	str	r3, [r4, #28]
 8022d60:	6223      	str	r3, [r4, #32]
 8022d62:	e7e4      	b.n	8022d2e <tVZFilter_init+0x102>
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8022d64:	2300      	movs	r3, #0
 8022d66:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 8022d6a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8022d6e:	61e2      	str	r2, [r4, #28]
            f->R2 = f->invG;
 8022d70:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8022d74:	6223      	str	r3, [r4, #32]
 8022d76:	6263      	str	r3, [r4, #36]	; 0x24
 8022d78:	e7d9      	b.n	8022d2e <tVZFilter_init+0x102>
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 8022d7a:	2300      	movs	r3, #0
 8022d7c:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 8022d80:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 8022d84:	6222      	str	r2, [r4, #32]
            f->R2 = f->invG;
 8022d86:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 8022d8a:	61e3      	str	r3, [r4, #28]
 8022d8c:	6263      	str	r3, [r4, #36]	; 0x24
 8022d8e:	e7ce      	b.n	8022d2e <tVZFilter_init+0x102>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8022d90:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8022d94:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 8022d98:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8022d9a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8022d9e:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8022da2:	f004 fbed 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8022da6:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 8022daa:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8022dae:	ed9f 7a6c 	vldr	s14, [pc, #432]	; 8022f60 <tVZFilter_init+0x334>
 8022db2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8022db6:	ee67 7a87 	vmul.f32	s15, s15, s14
 8022dba:	ee27 0a80 	vmul.f32	s0, s15, s0
 8022dbe:	f004 fd1d 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8022dc2:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8022dc6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8022dca:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8022dcc:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8022dd0:	61e3      	str	r3, [r4, #28]
 8022dd2:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8022dd4:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8022dd8:	ee20 0a00 	vmul.f32	s0, s0, s0
 8022ddc:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8022de0:	ee20 0a07 	vmul.f32	s0, s0, s14
 8022de4:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8022de8:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8022dec:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8022df0:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8022df4:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8022df8:	edc4 7a08 	vstr	s15, [r4, #32]
 8022dfc:	e797      	b.n	8022d2e <tVZFilter_init+0x102>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8022dfe:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8022e02:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 8022e06:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8022e08:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8022e0c:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8022e10:	f004 fbb6 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8022e14:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 8022e18:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8022e1c:	ed9f 7a50 	vldr	s14, [pc, #320]	; 8022f60 <tVZFilter_init+0x334>
 8022e20:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8022e24:	ee67 7a87 	vmul.f32	s15, s15, s14
 8022e28:	ee27 0a80 	vmul.f32	s0, s15, s0
 8022e2c:	f004 fce6 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8022e30:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8022e34:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8022e38:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8022e3a:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8022e3e:	6223      	str	r3, [r4, #32]
 8022e40:	edc4 7a07 	vstr	s15, [r4, #28]
 8022e44:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8022e48:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8022e4c:	ee20 0a00 	vmul.f32	s0, s0, s0
 8022e50:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8022e54:	ee20 0a07 	vmul.f32	s0, s0, s14
 8022e58:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8022e5c:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8022e60:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8022e64:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8022e68:	edc4 7a05 	vstr	s15, [r4, #20]
 8022e6c:	e75f      	b.n	8022d2e <tVZFilter_init+0x102>
            float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
 8022e6e:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8022e72:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
 8022e76:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8022e7a:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8022e7e:	f004 fb7f 	bl	8027580 <powf>
            float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8022e82:	ee28 0a00 	vmul.f32	s0, s16, s0
 8022e86:	f004 fcb9 	bl	80277fc <tanf>
            float r  = f->g/wl;
 8022e8a:	ee88 0a80 	vdiv.f32	s0, s17, s0
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8022e8e:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
 8022e92:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8022e96:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 8022e9a:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8022e9e:	edc4 7a07 	vstr	s15, [r4, #28]
 8022ea2:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8022ea6:	ee67 6a26 	vmul.f32	s13, s14, s13
            r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
 8022eaa:	ee20 0a00 	vmul.f32	s0, s0, s0
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8022eae:	eee0 7a00 	vfma.f32	s15, s0, s0
 8022eb2:	ee87 6a80 	vdiv.f32	s12, s15, s0
 8022eb6:	ee76 7a65 	vsub.f32	s15, s12, s11
 8022eba:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8022ebe:	eef1 7ac6 	vsqrt.f32	s15, s12
 8022ec2:	ee77 7aa7 	vadd.f32	s15, s15, s15
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8022ec6:	ee27 7a27 	vmul.f32	s14, s14, s15
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8022eca:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8022ece:	ed84 7a08 	vstr	s14, [r4, #32]
 8022ed2:	e72c      	b.n	8022d2e <tVZFilter_init+0x102>
            float A = sqrtf(f->G);
 8022ed4:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
          f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8022ed8:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8022edc:	eddf 7a21 	vldr	s15, [pc, #132]	; 8022f64 <tVZFilter_init+0x338>
            float A = sqrtf(f->G);
 8022ee0:	eeb1 8ac9 	vsqrt.f32	s16, s18
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8022ee4:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
 8022ee8:	ee20 0a27 	vmul.f32	s0, s0, s15
 8022eec:	eef1 7ac8 	vsqrt.f32	s15, s16
          f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8022ef0:	eec8 8aa7 	vdiv.f32	s17, s17, s15
 8022ef4:	edc4 8a04 	vstr	s17, [r4, #16]
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8022ef8:	f004 fe3a 	bl	8027b70 <sinhf>
 8022efc:	ee70 7a00 	vadd.f32	s15, s0, s0
          f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8022f00:	ed84 9a07 	vstr	s18, [r4, #28]
 8022f04:	6265      	str	r5, [r4, #36]	; 0x24
 8022f06:	ee28 8a27 	vmul.f32	s16, s16, s15
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8022f0a:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8022f0e:	ed84 8a08 	vstr	s16, [r4, #32]
 8022f12:	e70c      	b.n	8022d2e <tVZFilter_init+0x102>
          float A = sqrtf(f->G);
 8022f14:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8022f18:	eddf 7a12 	vldr	s15, [pc, #72]	; 8022f64 <tVZFilter_init+0x338>
          float A = sqrtf(f->G);
 8022f1c:	eeb1 8ac9 	vsqrt.f32	s16, s18
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8022f20:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
 8022f24:	ee20 0a27 	vmul.f32	s0, s0, s15
          f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8022f28:	eef1 7ac8 	vsqrt.f32	s15, s16
 8022f2c:	ee68 8aa7 	vmul.f32	s17, s17, s15
 8022f30:	edc4 8a04 	vstr	s17, [r4, #16]
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8022f34:	f004 fe1c 	bl	8027b70 <sinhf>
 8022f38:	ee70 7a00 	vadd.f32	s15, s0, s0
          f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 8022f3c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8022f40:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
 8022f44:	ee28 8a27 	vmul.f32	s16, s16, s15
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8022f48:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 8022f4c:	61e3      	str	r3, [r4, #28]
 8022f4e:	ed84 8a08 	vstr	s16, [r4, #32]
 8022f52:	e6ec      	b.n	8022d2e <tVZFilter_init+0x102>
 8022f54:	200194e8 	.word	0x200194e8
 8022f58:	3f3504f3 	.word	0x3f3504f3
 8022f5c:	3fb504f3 	.word	0x3fb504f3
 8022f60:	40490fdb 	.word	0x40490fdb
 8022f64:	3eb17218 	.word	0x3eb17218
 8022f68:	00000000 	.word	0x00000000
          float x  = 2.0f*f->m-1.0f;
 8022f6c:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8022f70:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
 8022f74:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
            f->R2 = f->invG;
 8022f78:	6b23      	ldr	r3, [r4, #48]	; 0x30
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8022f7a:	ed5f 0a05 	vldr	s1, [pc, #-20]	; 8022f68 <tVZFilter_init+0x33c>
            f->R2 = f->invG;
 8022f7e:	6163      	str	r3, [r4, #20]
          float x  = 2.0f*f->m-1.0f;
 8022f80:	eea7 8a27 	vfma.f32	s16, s14, s15
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8022f84:	eef1 8a48 	vneg.f32	s17, s16
 8022f88:	eeb0 0a68 	vmov.f32	s0, s17
 8022f8c:	f001 f974 	bl	8024278 <maximum>
          f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 8022f90:	ed5f 0a0b 	vldr	s1, [pc, #-44]	; 8022f68 <tVZFilter_init+0x33c>
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8022f94:	ed84 0a07 	vstr	s0, [r4, #28]
          f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 8022f98:	eeb0 0a48 	vmov.f32	s0, s16
 8022f9c:	f001 f970 	bl	8024280 <minimum>
          f->cB = 1.0f-x*x;
 8022fa0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
          float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 8022fa4:	edd4 6a07 	vldr	s13, [r4, #28]
 8022fa8:	edd4 7a05 	vldr	s15, [r4, #20]
          f->cB = 1.0f-x*x;
 8022fac:	eea8 7a88 	vfma.f32	s14, s17, s16
          float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 8022fb0:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
 8022fb4:	ee36 5aa6 	vadd.f32	s10, s13, s13
 8022fb8:	edd4 8a04 	vldr	s17, [r4, #16]
 8022fbc:	ee67 4aa7 	vmul.f32	s9, s15, s15
 8022fc0:	ee27 6a07 	vmul.f32	s12, s14, s14
 8022fc4:	eea6 6aa6 	vfma.f32	s12, s13, s13
 8022fc8:	eea0 6a00 	vfma.f32	s12, s0, s0
 8022fcc:	eea0 6a45 	vfms.f32	s12, s0, s10
 8022fd0:	ee84 5a86 	vdiv.f32	s10, s9, s12
 8022fd4:	eeb1 6ac5 	vsqrt.f32	s12, s10
 8022fd8:	ee26 6a25 	vmul.f32	s12, s12, s11
          f->cL *= s; f->cB *= s; f->cH *= s;
 8022fdc:	ee66 6a86 	vmul.f32	s13, s13, s12
 8022fe0:	ee27 7a06 	vmul.f32	s14, s14, s12
 8022fe4:	ee20 0a06 	vmul.f32	s0, s0, s12
 8022fe8:	edc4 6a07 	vstr	s13, [r4, #28]
 8022fec:	ed84 7a08 	vstr	s14, [r4, #32]
 8022ff0:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 8022ff4:	e69b      	b.n	8022d2e <tVZFilter_init+0x102>
          f->cL = 1.0f;
 8022ff6:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
          f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8022ffa:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
          f->cL = 1.0f;
 8022ffe:	61e3      	str	r3, [r4, #28]
          f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8023000:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cH = 1.0f;
 8023004:	6263      	str	r3, [r4, #36]	; 0x24
          f->cB = f->R2;
 8023006:	edc4 7a08 	vstr	s15, [r4, #32]
 802300a:	e690      	b.n	8022d2e <tVZFilter_init+0x102>
 802300c:	edd4 7a05 	vldr	s15, [r4, #20]
 8023010:	e68d      	b.n	8022d2e <tVZFilter_init+0x102>
 8023012:	bf00      	nop

08023014 <tVZFilter_free>:
    _tVZFilter* f = *vf;
 8023014:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)f, f->mempool);
 8023016:	6801      	ldr	r1, [r0, #0]
 8023018:	f001 ba02 	b.w	8024420 <mpool_free>

0802301c <tVZFilter_setSampleRate>:
    f->inv_sr = 1.0f/sampleRate;
 802301c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    _tVZFilter* f = *vf;
 8023020:	6803      	ldr	r3, [r0, #0]
    f->sr = sampleRate;
 8023022:	ed83 0a0f 	vstr	s0, [r3, #60]	; 0x3c
    f->inv_sr = 1.0f/sampleRate;
 8023026:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802302a:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
}
 802302e:	4770      	bx	lr

08023030 <tVZFilter_tick>:
{
 8023030:	b510      	push	{r4, lr}
    _tVZFilter* f = *vf;
 8023032:	6804      	ldr	r4, [r0, #0]
{
 8023034:	ed2d 8b06 	vpush	{d8-d10}
    yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
 8023038:	ed94 8a02 	vldr	s16, [r4, #8]
 802303c:	edd4 7a05 	vldr	s15, [r4, #20]
 8023040:	ed94 9a04 	vldr	s18, [r4, #16]
 8023044:	eea7 0ac8 	vfms.f32	s0, s15, s16
 8023048:	edd4 9a03 	vldr	s19, [r4, #12]
 802304c:	edd4 7a06 	vldr	s15, [r4, #24]
 8023050:	eea8 0a49 	vfms.f32	s0, s16, s18
 8023054:	ee70 8a69 	vsub.f32	s17, s0, s19
 8023058:	ee68 8aa7 	vmul.f32	s17, s17, s15
    yB = tanhf(f->g*yH) + f->s1;
 802305c:	ee29 aa28 	vmul.f32	s20, s18, s17
 8023060:	eeb0 0a4a 	vmov.f32	s0, s20
 8023064:	f004 fbf2 	bl	802784c <tanhf>
 8023068:	ee38 8a00 	vadd.f32	s16, s16, s0
    yL = tanhf(f->g*yB) + f->s2;
 802306c:	ee29 9a08 	vmul.f32	s18, s18, s16
    f->s1 = f->g*yH + yB; // state update in 1st integrator
 8023070:	ee3a aa08 	vadd.f32	s20, s20, s16
    yL = tanhf(f->g*yB) + f->s2;
 8023074:	eeb0 0a49 	vmov.f32	s0, s18
    f->s1 = f->g*yH + yB; // state update in 1st integrator
 8023078:	ed84 aa02 	vstr	s20, [r4, #8]
    yL = tanhf(f->g*yB) + f->s2;
 802307c:	f004 fbe6 	bl	802784c <tanhf>
    return f->cL*yL + f->cB*yB + f->cH*yH;
 8023080:	edd4 7a08 	vldr	s15, [r4, #32]
    yL = tanhf(f->g*yB) + f->s2;
 8023084:	ee79 9a80 	vadd.f32	s19, s19, s0
    return f->cL*yL + f->cB*yB + f->cH*yH;
 8023088:	ed94 7a07 	vldr	s14, [r4, #28]
 802308c:	ee28 0a27 	vmul.f32	s0, s16, s15
 8023090:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f->s2 = f->g*yB + yL; // state update in 2nd integrator
 8023094:	ee39 9a29 	vadd.f32	s18, s18, s19
    return f->cL*yL + f->cB*yB + f->cH*yH;
 8023098:	eea7 0a29 	vfma.f32	s0, s14, s19
    f->s2 = f->g*yB + yL; // state update in 2nd integrator
 802309c:	ed84 9a03 	vstr	s18, [r4, #12]
}
 80230a0:	eea7 0aa8 	vfma.f32	s0, s15, s17
 80230a4:	ecbd 8b06 	vpop	{d8-d10}
 80230a8:	bd10      	pop	{r4, pc}
 80230aa:	bf00      	nop

080230ac <tVZFilter_tickEfficient>:
    _tVZFilter* f = *vf;
 80230ac:	6803      	ldr	r3, [r0, #0]
    yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
 80230ae:	ed93 7a02 	vldr	s14, [r3, #8]
 80230b2:	edd3 7a05 	vldr	s15, [r3, #20]
 80230b6:	edd3 5a04 	vldr	s11, [r3, #16]
 80230ba:	eea7 0ac7 	vfms.f32	s0, s15, s14
 80230be:	ed93 6a03 	vldr	s12, [r3, #12]
 80230c2:	ed93 4a06 	vldr	s8, [r3, #24]
    return f->cL*yL + f->cB*yB + f->cH*yH;
 80230c6:	edd3 6a09 	vldr	s13, [r3, #36]	; 0x24
 80230ca:	edd3 4a08 	vldr	s9, [r3, #32]
 80230ce:	ed93 5a07 	vldr	s10, [r3, #28]
    yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
 80230d2:	eea7 0a65 	vfms.f32	s0, s14, s11
 80230d6:	ee70 7a46 	vsub.f32	s15, s0, s12
 80230da:	ee67 7a84 	vmul.f32	s15, s15, s8
    yB = (f->g*yH) + f->s1;
 80230de:	eea5 7aa7 	vfma.f32	s14, s11, s15
    return f->cL*yL + f->cB*yB + f->cH*yH;
 80230e2:	ee27 0aa6 	vmul.f32	s0, s15, s13
    yL = (f->g*yB) + f->s2;
 80230e6:	eef0 6a46 	vmov.f32	s13, s12
 80230ea:	eee5 6a87 	vfma.f32	s13, s11, s14
    f->s1 = f->g*yH + yB; // state update in 1st integrator
 80230ee:	eeb0 6a47 	vmov.f32	s12, s14
    return f->cL*yL + f->cB*yB + f->cH*yH;
 80230f2:	eea4 0a87 	vfma.f32	s0, s9, s14
    f->s1 = f->g*yH + yB; // state update in 1st integrator
 80230f6:	eea5 6aa7 	vfma.f32	s12, s11, s15
    f->s2 = f->g*yB + yL; // state update in 2nd integrator
 80230fa:	eef0 7a66 	vmov.f32	s15, s13
}
 80230fe:	eea5 0a26 	vfma.f32	s0, s10, s13
    f->s2 = f->g*yB + yL; // state update in 2nd integrator
 8023102:	eee5 7a87 	vfma.f32	s15, s11, s14
    f->s1 = f->g*yH + yB; // state update in 1st integrator
 8023106:	ed83 6a02 	vstr	s12, [r3, #8]
    f->s2 = f->g*yB + yL; // state update in 2nd integrator
 802310a:	edc3 7a03 	vstr	s15, [r3, #12]
}
 802310e:	4770      	bx	lr

08023110 <tVZFilter_setFreq>:
{
 8023110:	b538      	push	{r3, r4, r5, lr}
    f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 8023112:	4be3      	ldr	r3, [pc, #908]	; (80234a0 <tVZFilter_setFreq+0x390>)
 8023114:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    _tVZFilter* f = *vf;
 8023118:	6804      	ldr	r4, [r0, #0]
{
 802311a:	4605      	mov	r5, r0
    f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 802311c:	eef0 0a40 	vmov.f32	s1, s0
 8023120:	ed9f 0ae0 	vldr	s0, [pc, #896]	; 80234a4 <tVZFilter_setFreq+0x394>
{
 8023124:	ed2d 8b04 	vpush	{d8-d9}
    f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 8023128:	ed93 1a00 	vldr	s2, [r3]
 802312c:	ee21 1a27 	vmul.f32	s2, s2, s15
 8023130:	f000 fec0 	bl	8023eb4 <LEAF_clip>
 8023134:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
    _tVZFilter* f = *vf;
 8023138:	682c      	ldr	r4, [r5, #0]
    f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 802313a:	eddf 7adb 	vldr	s15, [pc, #876]	; 80234a8 <tVZFilter_setFreq+0x398>
 802313e:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 8023142:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
 8023146:	ee28 8a07 	vmul.f32	s16, s16, s14
 802314a:	ee28 8a27 	vmul.f32	s16, s16, s15
 802314e:	eeb0 0a48 	vmov.f32	s0, s16
 8023152:	f004 fb53 	bl	80277fc <tanf>
      switch( f->type )
 8023156:	7923      	ldrb	r3, [r4, #4]
    f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8023158:	eef0 8a40 	vmov.f32	s17, s0
 802315c:	ed84 0a04 	vstr	s0, [r4, #16]
      switch( f->type )
 8023160:	2b0a      	cmp	r3, #10
 8023162:	f200 81b0 	bhi.w	80234c6 <tVZFilter_setFreq+0x3b6>
 8023166:	e8df f013 	tbh	[pc, r3, lsl #1]
 802316a:	0053      	.short	0x0053
 802316c:	0069005e 	.word	0x0069005e
 8023170:	00ab0074 	.word	0x00ab0074
 8023174:	011600e3 	.word	0x011600e3
 8023178:	01560136 	.word	0x01560136
 802317c:	000b01a3 	.word	0x000b01a3
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8023180:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8023184:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 8023188:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 802318a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 802318e:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8023192:	f004 f9f5 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8023196:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 802319a:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 802319e:	ed9f 7ac2 	vldr	s14, [pc, #776]	; 80234a8 <tVZFilter_setFreq+0x398>
 80231a2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80231a6:	ee67 7a87 	vmul.f32	s15, s15, s14
 80231aa:	ee27 0a80 	vmul.f32	s0, s15, s0
 80231ae:	f004 fb25 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 80231b2:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 80231b6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 80231ba:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 80231be:	edc4 7a07 	vstr	s15, [r4, #28]
 80231c2:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 80231c6:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 80231ca:	ee20 0a00 	vmul.f32	s0, s0, s0
 80231ce:	ee77 7ac0 	vsub.f32	s15, s15, s0
 80231d2:	ee20 0a07 	vmul.f32	s0, s0, s14
 80231d6:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80231da:	ee87 7a80 	vdiv.f32	s14, s15, s0
 80231de:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 80231e2:	ee77 7aa7 	vadd.f32	s15, s15, s15
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 80231e6:	eeb1 7a67 	vneg.f32	s14, s15
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 80231ea:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 80231ee:	ed84 7a08 	vstr	s14, [r4, #32]
      f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
 80231f2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80231f6:	ee77 7aa8 	vadd.f32	s15, s15, s17
 80231fa:	eef0 6a47 	vmov.f32	s13, s14
 80231fe:	eee7 6aa8 	vfma.f32	s13, s15, s17
 8023202:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8023206:	edc4 7a06 	vstr	s15, [r4, #24]
}
 802320a:	ecbd 8b04 	vpop	{d8-d9}
 802320e:	bd38      	pop	{r3, r4, r5, pc}
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8023210:	2300      	movs	r3, #0
 8023212:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 8023216:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 802321a:	6262      	str	r2, [r4, #36]	; 0x24
            f->R2 = f->invG;
 802321c:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8023220:	61e3      	str	r3, [r4, #28]
 8023222:	6223      	str	r3, [r4, #32]
 8023224:	e7e5      	b.n	80231f2 <tVZFilter_setFreq+0xe2>
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8023226:	2300      	movs	r3, #0
 8023228:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 802322c:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8023230:	61e2      	str	r2, [r4, #28]
            f->R2 = f->invG;
 8023232:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8023236:	6223      	str	r3, [r4, #32]
 8023238:	6263      	str	r3, [r4, #36]	; 0x24
 802323a:	e7da      	b.n	80231f2 <tVZFilter_setFreq+0xe2>
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 802323c:	2300      	movs	r3, #0
 802323e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 8023242:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 8023246:	6222      	str	r2, [r4, #32]
            f->R2 = f->invG;
 8023248:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 802324c:	61e3      	str	r3, [r4, #28]
 802324e:	6263      	str	r3, [r4, #36]	; 0x24
 8023250:	e7cf      	b.n	80231f2 <tVZFilter_setFreq+0xe2>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8023252:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8023256:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 802325a:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 802325c:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8023260:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8023264:	f004 f98c 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8023268:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 802326c:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8023270:	ed9f 7a8d 	vldr	s14, [pc, #564]	; 80234a8 <tVZFilter_setFreq+0x398>
 8023274:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8023278:	ee67 7a87 	vmul.f32	s15, s15, s14
 802327c:	ee27 0a80 	vmul.f32	s0, s15, s0
 8023280:	f004 fabc 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8023284:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8023288:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 802328c:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 802328e:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8023292:	61e3      	str	r3, [r4, #28]
 8023294:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8023296:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 802329a:	ee20 0a00 	vmul.f32	s0, s0, s0
 802329e:	ee77 7ac0 	vsub.f32	s15, s15, s0
 80232a2:	ee20 0a07 	vmul.f32	s0, s0, s14
 80232a6:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80232aa:	ee87 7a80 	vdiv.f32	s14, s15, s0
 80232ae:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 80232b2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80232b6:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 80232ba:	edc4 7a08 	vstr	s15, [r4, #32]
 80232be:	e798      	b.n	80231f2 <tVZFilter_setFreq+0xe2>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80232c0:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 80232c4:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 80232c8:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80232ca:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80232ce:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80232d2:	f004 f955 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 80232d6:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 80232da:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 80232de:	ed9f 7a72 	vldr	s14, [pc, #456]	; 80234a8 <tVZFilter_setFreq+0x398>
 80232e2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80232e6:	ee67 7a87 	vmul.f32	s15, s15, s14
 80232ea:	ee27 0a80 	vmul.f32	s0, s15, s0
 80232ee:	f004 fa85 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 80232f2:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 80232f6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 80232fa:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 80232fc:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8023300:	6223      	str	r3, [r4, #32]
 8023302:	edc4 7a07 	vstr	s15, [r4, #28]
 8023306:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802330a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 802330e:	ee20 0a00 	vmul.f32	s0, s0, s0
 8023312:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8023316:	ee20 0a07 	vmul.f32	s0, s0, s14
 802331a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802331e:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8023322:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8023326:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802332a:	edc4 7a05 	vstr	s15, [r4, #20]
 802332e:	e760      	b.n	80231f2 <tVZFilter_setFreq+0xe2>
            float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
 8023330:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8023334:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
 8023338:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 802333c:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8023340:	f004 f91e 	bl	8027580 <powf>
            float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8023344:	ee28 0a00 	vmul.f32	s0, s16, s0
 8023348:	f004 fa58 	bl	80277fc <tanf>
            float r  = f->g/wl;
 802334c:	ee88 0a80 	vdiv.f32	s0, s17, s0
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8023350:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
 8023354:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8023358:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 802335c:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8023360:	edc4 7a07 	vstr	s15, [r4, #28]
 8023364:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8023368:	ee67 6a26 	vmul.f32	s13, s14, s13
            r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
 802336c:	ee20 0a00 	vmul.f32	s0, s0, s0
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8023370:	eee0 7a00 	vfma.f32	s15, s0, s0
 8023374:	ee87 6a80 	vdiv.f32	s12, s15, s0
 8023378:	ee76 7a65 	vsub.f32	s15, s12, s11
 802337c:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8023380:	eef1 7ac6 	vsqrt.f32	s15, s12
 8023384:	ee77 7aa7 	vadd.f32	s15, s15, s15
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8023388:	ee27 7a27 	vmul.f32	s14, s14, s15
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 802338c:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8023390:	ed84 7a08 	vstr	s14, [r4, #32]
 8023394:	e72d      	b.n	80231f2 <tVZFilter_setFreq+0xe2>
            float A = sqrtf(f->G);
 8023396:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
          f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 802339a:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 802339e:	eddf 7a43 	vldr	s15, [pc, #268]	; 80234ac <tVZFilter_setFreq+0x39c>
            float A = sqrtf(f->G);
 80233a2:	eeb1 8ac9 	vsqrt.f32	s16, s18
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 80233a6:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
 80233aa:	ee20 0a27 	vmul.f32	s0, s0, s15
 80233ae:	eef1 7ac8 	vsqrt.f32	s15, s16
          f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 80233b2:	eec8 8aa7 	vdiv.f32	s17, s17, s15
 80233b6:	edc4 8a04 	vstr	s17, [r4, #16]
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 80233ba:	f004 fbd9 	bl	8027b70 <sinhf>
 80233be:	ee70 7a00 	vadd.f32	s15, s0, s0
          f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 80233c2:	ed84 9a07 	vstr	s18, [r4, #28]
 80233c6:	6265      	str	r5, [r4, #36]	; 0x24
 80233c8:	ee28 8a27 	vmul.f32	s16, s16, s15
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 80233cc:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 80233d0:	ed84 8a08 	vstr	s16, [r4, #32]
 80233d4:	e70d      	b.n	80231f2 <tVZFilter_setFreq+0xe2>
          float A = sqrtf(f->G);
 80233d6:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 80233da:	eddf 7a34 	vldr	s15, [pc, #208]	; 80234ac <tVZFilter_setFreq+0x39c>
          float A = sqrtf(f->G);
 80233de:	eeb1 8ac9 	vsqrt.f32	s16, s18
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 80233e2:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
 80233e6:	ee20 0a27 	vmul.f32	s0, s0, s15
          f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 80233ea:	eef1 7ac8 	vsqrt.f32	s15, s16
 80233ee:	ee68 8aa7 	vmul.f32	s17, s17, s15
 80233f2:	edc4 8a04 	vstr	s17, [r4, #16]
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 80233f6:	f004 fbbb 	bl	8027b70 <sinhf>
 80233fa:	ee70 7a00 	vadd.f32	s15, s0, s0
          f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 80233fe:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8023402:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
 8023406:	ee28 8a27 	vmul.f32	s16, s16, s15
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 802340a:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 802340e:	61e3      	str	r3, [r4, #28]
 8023410:	ed84 8a08 	vstr	s16, [r4, #32]
 8023414:	e6ed      	b.n	80231f2 <tVZFilter_setFreq+0xe2>
          float x  = 2.0f*f->m-1.0f;
 8023416:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 802341a:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
 802341e:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
            f->R2 = f->invG;
 8023422:	6b23      	ldr	r3, [r4, #48]	; 0x30
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8023424:	eddf 0a1f 	vldr	s1, [pc, #124]	; 80234a4 <tVZFilter_setFreq+0x394>
            f->R2 = f->invG;
 8023428:	6163      	str	r3, [r4, #20]
          float x  = 2.0f*f->m-1.0f;
 802342a:	eea7 8a27 	vfma.f32	s16, s14, s15
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 802342e:	eef1 8a48 	vneg.f32	s17, s16
 8023432:	eeb0 0a68 	vmov.f32	s0, s17
 8023436:	f000 ff1f 	bl	8024278 <maximum>
          f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 802343a:	eddf 0a1a 	vldr	s1, [pc, #104]	; 80234a4 <tVZFilter_setFreq+0x394>
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 802343e:	ed84 0a07 	vstr	s0, [r4, #28]
          f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 8023442:	eeb0 0a48 	vmov.f32	s0, s16
 8023446:	f000 ff1b 	bl	8024280 <minimum>
          f->cB = 1.0f-x*x;
 802344a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
          float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 802344e:	edd4 6a07 	vldr	s13, [r4, #28]
 8023452:	edd4 7a05 	vldr	s15, [r4, #20]
          f->cB = 1.0f-x*x;
 8023456:	eea8 7a88 	vfma.f32	s14, s17, s16
          float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 802345a:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
 802345e:	ee36 5aa6 	vadd.f32	s10, s13, s13
 8023462:	edd4 8a04 	vldr	s17, [r4, #16]
 8023466:	ee67 4aa7 	vmul.f32	s9, s15, s15
 802346a:	ee27 6a07 	vmul.f32	s12, s14, s14
 802346e:	eea6 6aa6 	vfma.f32	s12, s13, s13
 8023472:	eea0 6a00 	vfma.f32	s12, s0, s0
 8023476:	eea0 6a45 	vfms.f32	s12, s0, s10
 802347a:	ee84 5a86 	vdiv.f32	s10, s9, s12
 802347e:	eeb1 6ac5 	vsqrt.f32	s12, s10
 8023482:	ee26 6a25 	vmul.f32	s12, s12, s11
          f->cL *= s; f->cB *= s; f->cH *= s;
 8023486:	ee66 6a86 	vmul.f32	s13, s13, s12
 802348a:	ee27 7a06 	vmul.f32	s14, s14, s12
 802348e:	ee20 0a06 	vmul.f32	s0, s0, s12
 8023492:	edc4 6a07 	vstr	s13, [r4, #28]
 8023496:	ed84 7a08 	vstr	s14, [r4, #32]
 802349a:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 802349e:	e6a8      	b.n	80231f2 <tVZFilter_setFreq+0xe2>
 80234a0:	200194e8 	.word	0x200194e8
 80234a4:	00000000 	.word	0x00000000
 80234a8:	40490fdb 	.word	0x40490fdb
 80234ac:	3eb17218 	.word	0x3eb17218
          f->cL = 1.0f;
 80234b0:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
          f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 80234b4:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
          f->cL = 1.0f;
 80234b8:	61e3      	str	r3, [r4, #28]
          f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 80234ba:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cH = 1.0f;
 80234be:	6263      	str	r3, [r4, #36]	; 0x24
          f->cB = f->R2;
 80234c0:	edc4 7a08 	vstr	s15, [r4, #32]
 80234c4:	e695      	b.n	80231f2 <tVZFilter_setFreq+0xe2>
 80234c6:	edd4 7a05 	vldr	s15, [r4, #20]
 80234ca:	e692      	b.n	80231f2 <tVZFilter_setFreq+0xe2>

080234cc <tVZFilter_setFreqAndBandwidth>:
{
 80234cc:	b538      	push	{r3, r4, r5, lr}
    f->B = LEAF_clip(0.0f,bw, 100.0f);
 80234ce:	ed9f 1ac6 	vldr	s2, [pc, #792]	; 80237e8 <tVZFilter_setFreqAndBandwidth+0x31c>
{
 80234d2:	4605      	mov	r5, r0
    _tVZFilter* f = *vf;
 80234d4:	6804      	ldr	r4, [r0, #0]
{
 80234d6:	ed2d 8b04 	vpush	{d8-d9}
 80234da:	eeb0 8a40 	vmov.f32	s16, s0
    f->B = LEAF_clip(0.0f,bw, 100.0f);
 80234de:	ed9f 0ac6 	vldr	s0, [pc, #792]	; 80237f8 <tVZFilter_setFreqAndBandwidth+0x32c>
 80234e2:	f000 fce7 	bl	8023eb4 <LEAF_clip>
    f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 80234e6:	4bc1      	ldr	r3, [pc, #772]	; (80237ec <tVZFilter_setFreqAndBandwidth+0x320>)
 80234e8:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    f->B = LEAF_clip(0.0f,bw, 100.0f);
 80234ec:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 80234f0:	ed93 1a00 	vldr	s2, [r3]
 80234f4:	eef0 0a48 	vmov.f32	s1, s16
 80234f8:	ed9f 0abf 	vldr	s0, [pc, #764]	; 80237f8 <tVZFilter_setFreqAndBandwidth+0x32c>
 80234fc:	ee21 1a27 	vmul.f32	s2, s2, s15
 8023500:	f000 fcd8 	bl	8023eb4 <LEAF_clip>
 8023504:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
    _tVZFilter* f = *vf;
 8023508:	682c      	ldr	r4, [r5, #0]
    f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 802350a:	eddf 7ab9 	vldr	s15, [pc, #740]	; 80237f0 <tVZFilter_setFreqAndBandwidth+0x324>
 802350e:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 8023512:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
 8023516:	ee28 8a07 	vmul.f32	s16, s16, s14
 802351a:	ee28 8a27 	vmul.f32	s16, s16, s15
 802351e:	eeb0 0a48 	vmov.f32	s0, s16
 8023522:	f004 f96b 	bl	80277fc <tanf>
      switch( f->type )
 8023526:	7923      	ldrb	r3, [r4, #4]
    f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8023528:	eef0 8a40 	vmov.f32	s17, s0
 802352c:	ed84 0a04 	vstr	s0, [r4, #16]
      switch( f->type )
 8023530:	2b0a      	cmp	r3, #10
 8023532:	f200 81b3 	bhi.w	802389c <tVZFilter_setFreqAndBandwidth+0x3d0>
 8023536:	e8df f013 	tbh	[pc, r3, lsl #1]
 802353a:	0053      	.short	0x0053
 802353c:	0069005e 	.word	0x0069005e
 8023540:	00ab0074 	.word	0x00ab0074
 8023544:	011600e3 	.word	0x011600e3
 8023548:	01610136 	.word	0x01610136
 802354c:	000b01a6 	.word	0x000b01a6
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8023550:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8023554:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 8023558:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 802355a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 802355e:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8023562:	f004 f80d 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8023566:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 802356a:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 802356e:	ed9f 7aa0 	vldr	s14, [pc, #640]	; 80237f0 <tVZFilter_setFreqAndBandwidth+0x324>
 8023572:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8023576:	ee67 7a87 	vmul.f32	s15, s15, s14
 802357a:	ee27 0a80 	vmul.f32	s0, s15, s0
 802357e:	f004 f93d 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8023582:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8023586:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 802358a:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 802358e:	edc4 7a07 	vstr	s15, [r4, #28]
 8023592:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8023596:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 802359a:	ee20 0a00 	vmul.f32	s0, s0, s0
 802359e:	ee77 7ac0 	vsub.f32	s15, s15, s0
 80235a2:	ee20 0a07 	vmul.f32	s0, s0, s14
 80235a6:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80235aa:	ee87 7a80 	vdiv.f32	s14, s15, s0
 80235ae:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 80235b2:	ee77 7aa7 	vadd.f32	s15, s15, s15
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 80235b6:	eeb1 7a67 	vneg.f32	s14, s15
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 80235ba:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 80235be:	ed84 7a08 	vstr	s14, [r4, #32]
      f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
 80235c2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80235c6:	ee77 7aa8 	vadd.f32	s15, s15, s17
 80235ca:	eef0 6a47 	vmov.f32	s13, s14
 80235ce:	eee7 6aa8 	vfma.f32	s13, s15, s17
 80235d2:	eec7 7a26 	vdiv.f32	s15, s14, s13
 80235d6:	edc4 7a06 	vstr	s15, [r4, #24]
}
 80235da:	ecbd 8b04 	vpop	{d8-d9}
 80235de:	bd38      	pop	{r3, r4, r5, pc}
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 80235e0:	2300      	movs	r3, #0
 80235e2:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 80235e6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 80235ea:	6262      	str	r2, [r4, #36]	; 0x24
            f->R2 = f->invG;
 80235ec:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 80235f0:	61e3      	str	r3, [r4, #28]
 80235f2:	6223      	str	r3, [r4, #32]
 80235f4:	e7e5      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 80235f6:	2300      	movs	r3, #0
 80235f8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 80235fc:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8023600:	61e2      	str	r2, [r4, #28]
            f->R2 = f->invG;
 8023602:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8023606:	6223      	str	r3, [r4, #32]
 8023608:	6263      	str	r3, [r4, #36]	; 0x24
 802360a:	e7da      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 802360c:	2300      	movs	r3, #0
 802360e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 8023612:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 8023616:	6222      	str	r2, [r4, #32]
            f->R2 = f->invG;
 8023618:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 802361c:	61e3      	str	r3, [r4, #28]
 802361e:	6263      	str	r3, [r4, #36]	; 0x24
 8023620:	e7cf      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8023622:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8023626:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 802362a:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 802362c:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8023630:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8023634:	f003 ffa4 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8023638:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 802363c:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8023640:	ed9f 7a6b 	vldr	s14, [pc, #428]	; 80237f0 <tVZFilter_setFreqAndBandwidth+0x324>
 8023644:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8023648:	ee67 7a87 	vmul.f32	s15, s15, s14
 802364c:	ee27 0a80 	vmul.f32	s0, s15, s0
 8023650:	f004 f8d4 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8023654:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8023658:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 802365c:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 802365e:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8023662:	61e3      	str	r3, [r4, #28]
 8023664:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8023666:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 802366a:	ee20 0a00 	vmul.f32	s0, s0, s0
 802366e:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8023672:	ee20 0a07 	vmul.f32	s0, s0, s14
 8023676:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802367a:	ee87 7a80 	vdiv.f32	s14, s15, s0
 802367e:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8023682:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8023686:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 802368a:	edc4 7a08 	vstr	s15, [r4, #32]
 802368e:	e798      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8023690:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8023694:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 8023698:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 802369a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 802369e:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80236a2:	f003 ff6d 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 80236a6:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 80236aa:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 80236ae:	ed9f 7a50 	vldr	s14, [pc, #320]	; 80237f0 <tVZFilter_setFreqAndBandwidth+0x324>
 80236b2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80236b6:	ee67 7a87 	vmul.f32	s15, s15, s14
 80236ba:	ee27 0a80 	vmul.f32	s0, s15, s0
 80236be:	f004 f89d 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 80236c2:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 80236c6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 80236ca:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 80236cc:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 80236d0:	6223      	str	r3, [r4, #32]
 80236d2:	edc4 7a07 	vstr	s15, [r4, #28]
 80236d6:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 80236da:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 80236de:	ee20 0a00 	vmul.f32	s0, s0, s0
 80236e2:	ee77 7ac0 	vsub.f32	s15, s15, s0
 80236e6:	ee20 0a07 	vmul.f32	s0, s0, s14
 80236ea:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80236ee:	ee87 7a80 	vdiv.f32	s14, s15, s0
 80236f2:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 80236f6:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80236fa:	edc4 7a05 	vstr	s15, [r4, #20]
 80236fe:	e760      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
            float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
 8023700:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8023704:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
 8023708:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 802370c:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8023710:	f003 ff36 	bl	8027580 <powf>
            float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8023714:	ee28 0a00 	vmul.f32	s0, s16, s0
 8023718:	f004 f870 	bl	80277fc <tanf>
            float r  = f->g/wl;
 802371c:	ee88 0a80 	vdiv.f32	s0, s17, s0
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8023720:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
 8023724:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8023728:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 802372c:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8023730:	edc4 7a07 	vstr	s15, [r4, #28]
 8023734:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8023738:	ee67 6a26 	vmul.f32	s13, s14, s13
            r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
 802373c:	ee20 0a00 	vmul.f32	s0, s0, s0
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8023740:	eee0 7a00 	vfma.f32	s15, s0, s0
 8023744:	ee87 6a80 	vdiv.f32	s12, s15, s0
 8023748:	ee76 7a65 	vsub.f32	s15, s12, s11
 802374c:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8023750:	eef1 7ac6 	vsqrt.f32	s15, s12
 8023754:	ee77 7aa7 	vadd.f32	s15, s15, s15
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8023758:	ee27 7a27 	vmul.f32	s14, s14, s15
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 802375c:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8023760:	ed84 7a08 	vstr	s14, [r4, #32]
 8023764:	e72d      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
            float A = sqrtf(f->G);
 8023766:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
          f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 802376a:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 802376e:	eddf 7a21 	vldr	s15, [pc, #132]	; 80237f4 <tVZFilter_setFreqAndBandwidth+0x328>
            float A = sqrtf(f->G);
 8023772:	eeb1 8ac9 	vsqrt.f32	s16, s18
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8023776:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
 802377a:	ee20 0a27 	vmul.f32	s0, s0, s15
 802377e:	eef1 7ac8 	vsqrt.f32	s15, s16
          f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8023782:	eec8 8aa7 	vdiv.f32	s17, s17, s15
 8023786:	edc4 8a04 	vstr	s17, [r4, #16]
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 802378a:	f004 f9f1 	bl	8027b70 <sinhf>
 802378e:	ee70 7a00 	vadd.f32	s15, s0, s0
          f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8023792:	ed84 9a07 	vstr	s18, [r4, #28]
 8023796:	6265      	str	r5, [r4, #36]	; 0x24
 8023798:	ee28 8a27 	vmul.f32	s16, s16, s15
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 802379c:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 80237a0:	ed84 8a08 	vstr	s16, [r4, #32]
 80237a4:	e70d      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
          float A = sqrtf(f->G);
 80237a6:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 80237aa:	eddf 7a12 	vldr	s15, [pc, #72]	; 80237f4 <tVZFilter_setFreqAndBandwidth+0x328>
          float A = sqrtf(f->G);
 80237ae:	eeb1 8ac9 	vsqrt.f32	s16, s18
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 80237b2:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
 80237b6:	ee20 0a27 	vmul.f32	s0, s0, s15
          f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 80237ba:	eef1 7ac8 	vsqrt.f32	s15, s16
 80237be:	ee68 8aa7 	vmul.f32	s17, s17, s15
 80237c2:	edc4 8a04 	vstr	s17, [r4, #16]
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 80237c6:	f004 f9d3 	bl	8027b70 <sinhf>
 80237ca:	ee70 7a00 	vadd.f32	s15, s0, s0
          f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 80237ce:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80237d2:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
 80237d6:	ee28 8a27 	vmul.f32	s16, s16, s15
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 80237da:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 80237de:	61e3      	str	r3, [r4, #28]
 80237e0:	ed84 8a08 	vstr	s16, [r4, #32]
 80237e4:	e6ed      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
 80237e6:	bf00      	nop
 80237e8:	42c80000 	.word	0x42c80000
 80237ec:	200194e8 	.word	0x200194e8
 80237f0:	40490fdb 	.word	0x40490fdb
 80237f4:	3eb17218 	.word	0x3eb17218
 80237f8:	00000000 	.word	0x00000000
          float x  = 2.0f*f->m-1.0f;
 80237fc:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8023800:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
 8023804:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
            f->R2 = f->invG;
 8023808:	6b23      	ldr	r3, [r4, #48]	; 0x30
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 802380a:	ed5f 0a05 	vldr	s1, [pc, #-20]	; 80237f8 <tVZFilter_setFreqAndBandwidth+0x32c>
            f->R2 = f->invG;
 802380e:	6163      	str	r3, [r4, #20]
          float x  = 2.0f*f->m-1.0f;
 8023810:	eea7 8a27 	vfma.f32	s16, s14, s15
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8023814:	eef1 8a48 	vneg.f32	s17, s16
 8023818:	eeb0 0a68 	vmov.f32	s0, s17
 802381c:	f000 fd2c 	bl	8024278 <maximum>
          f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 8023820:	ed5f 0a0b 	vldr	s1, [pc, #-44]	; 80237f8 <tVZFilter_setFreqAndBandwidth+0x32c>
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8023824:	ed84 0a07 	vstr	s0, [r4, #28]
          f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 8023828:	eeb0 0a48 	vmov.f32	s0, s16
 802382c:	f000 fd28 	bl	8024280 <minimum>
          f->cB = 1.0f-x*x;
 8023830:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
          float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 8023834:	edd4 6a07 	vldr	s13, [r4, #28]
 8023838:	edd4 7a05 	vldr	s15, [r4, #20]
          f->cB = 1.0f-x*x;
 802383c:	eea8 7a88 	vfma.f32	s14, s17, s16
          float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 8023840:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
 8023844:	ee36 5aa6 	vadd.f32	s10, s13, s13
 8023848:	edd4 8a04 	vldr	s17, [r4, #16]
 802384c:	ee67 4aa7 	vmul.f32	s9, s15, s15
 8023850:	ee27 6a07 	vmul.f32	s12, s14, s14
 8023854:	eea6 6aa6 	vfma.f32	s12, s13, s13
 8023858:	eea0 6a00 	vfma.f32	s12, s0, s0
 802385c:	eea0 6a45 	vfms.f32	s12, s0, s10
 8023860:	ee84 5a86 	vdiv.f32	s10, s9, s12
 8023864:	eeb1 6ac5 	vsqrt.f32	s12, s10
 8023868:	ee26 6a25 	vmul.f32	s12, s12, s11
          f->cL *= s; f->cB *= s; f->cH *= s;
 802386c:	ee66 6a86 	vmul.f32	s13, s13, s12
 8023870:	ee27 7a06 	vmul.f32	s14, s14, s12
 8023874:	ee20 0a06 	vmul.f32	s0, s0, s12
 8023878:	edc4 6a07 	vstr	s13, [r4, #28]
 802387c:	ed84 7a08 	vstr	s14, [r4, #32]
 8023880:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 8023884:	e69d      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
          f->cL = 1.0f;
 8023886:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
          f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 802388a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
          f->cL = 1.0f;
 802388e:	61e3      	str	r3, [r4, #28]
          f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8023890:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cH = 1.0f;
 8023894:	6263      	str	r3, [r4, #36]	; 0x24
          f->cB = f->R2;
 8023896:	edc4 7a08 	vstr	s15, [r4, #32]
 802389a:	e692      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
 802389c:	edd4 7a05 	vldr	s15, [r4, #20]
 80238a0:	e68f      	b.n	80235c2 <tVZFilter_setFreqAndBandwidth+0xf6>
 80238a2:	bf00      	nop

080238a4 <tVZFilter_setGain>:
{
 80238a4:	b538      	push	{r3, r4, r5, lr}
    f->G = LEAF_clip(0.000001f, gain, 100.0f);
 80238a6:	eef0 0a40 	vmov.f32	s1, s0
 80238aa:	ed9f 1ae3 	vldr	s2, [pc, #908]	; 8023c38 <tVZFilter_setGain+0x394>
 80238ae:	ed9f 0ae3 	vldr	s0, [pc, #908]	; 8023c3c <tVZFilter_setGain+0x398>
{
 80238b2:	4605      	mov	r5, r0
    _tVZFilter* f = *vf;
 80238b4:	6804      	ldr	r4, [r0, #0]
{
 80238b6:	ed2d 8b04 	vpush	{d8-d9}
    f->G = LEAF_clip(0.000001f, gain, 100.0f);
 80238ba:	f000 fafb 	bl	8023eb4 <LEAF_clip>
    f->invG = 1.0f/f->G;
 80238be:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    f->G = LEAF_clip(0.000001f, gain, 100.0f);
 80238c2:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
    f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 80238c6:	eddf 7ade 	vldr	s15, [pc, #888]	; 8023c40 <tVZFilter_setGain+0x39c>
    f->invG = 1.0f/f->G;
 80238ca:	ee86 7a80 	vdiv.f32	s14, s13, s0
 80238ce:	ed84 7a0c 	vstr	s14, [r4, #48]	; 0x30
    _tVZFilter* f = *vf;
 80238d2:	682c      	ldr	r4, [r5, #0]
    f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 80238d4:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 80238d8:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
 80238dc:	ee28 8a07 	vmul.f32	s16, s16, s14
 80238e0:	ee28 8a27 	vmul.f32	s16, s16, s15
 80238e4:	eeb0 0a48 	vmov.f32	s0, s16
 80238e8:	f003 ff88 	bl	80277fc <tanf>
      switch( f->type )
 80238ec:	7923      	ldrb	r3, [r4, #4]
    f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 80238ee:	eef0 8a40 	vmov.f32	s17, s0
 80238f2:	ed84 0a04 	vstr	s0, [r4, #16]
      switch( f->type )
 80238f6:	2b0a      	cmp	r3, #10
 80238f8:	f200 81b3 	bhi.w	8023c62 <tVZFilter_setGain+0x3be>
 80238fc:	e8df f013 	tbh	[pc, r3, lsl #1]
 8023900:	005e0053 	.word	0x005e0053
 8023904:	00740069 	.word	0x00740069
 8023908:	00e300ab 	.word	0x00e300ab
 802390c:	01360116 	.word	0x01360116
 8023910:	01a60156 	.word	0x01a60156
 8023914:	000b      	.short	0x000b
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8023916:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 802391a:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 802391e:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8023920:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8023924:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8023928:	f003 fe2a 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 802392c:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 8023930:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8023934:	ed9f 7ac2 	vldr	s14, [pc, #776]	; 8023c40 <tVZFilter_setGain+0x39c>
 8023938:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802393c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8023940:	ee27 0a80 	vmul.f32	s0, s15, s0
 8023944:	f003 ff5a 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8023948:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802394c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8023950:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8023954:	edc4 7a07 	vstr	s15, [r4, #28]
 8023958:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802395c:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8023960:	ee20 0a00 	vmul.f32	s0, s0, s0
 8023964:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8023968:	ee20 0a07 	vmul.f32	s0, s0, s14
 802396c:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8023970:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8023974:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8023978:	ee77 7aa7 	vadd.f32	s15, s15, s15
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 802397c:	eeb1 7a67 	vneg.f32	s14, s15
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8023980:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8023984:	ed84 7a08 	vstr	s14, [r4, #32]
      f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
 8023988:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802398c:	ee77 7aa8 	vadd.f32	s15, s15, s17
 8023990:	eef0 6a47 	vmov.f32	s13, s14
 8023994:	eee7 6aa8 	vfma.f32	s13, s15, s17
 8023998:	eec7 7a26 	vdiv.f32	s15, s14, s13
 802399c:	edc4 7a06 	vstr	s15, [r4, #24]
}
 80239a0:	ecbd 8b04 	vpop	{d8-d9}
 80239a4:	bd38      	pop	{r3, r4, r5, pc}
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 80239a6:	2300      	movs	r3, #0
 80239a8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 80239ac:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 80239b0:	6262      	str	r2, [r4, #36]	; 0x24
            f->R2 = f->invG;
 80239b2:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 80239b6:	61e3      	str	r3, [r4, #28]
 80239b8:	6223      	str	r3, [r4, #32]
 80239ba:	e7e5      	b.n	8023988 <tVZFilter_setGain+0xe4>
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 80239bc:	2300      	movs	r3, #0
 80239be:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 80239c2:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 80239c6:	61e2      	str	r2, [r4, #28]
            f->R2 = f->invG;
 80239c8:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 80239cc:	6223      	str	r3, [r4, #32]
 80239ce:	6263      	str	r3, [r4, #36]	; 0x24
 80239d0:	e7da      	b.n	8023988 <tVZFilter_setGain+0xe4>
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 80239d2:	2300      	movs	r3, #0
 80239d4:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
            f->R2 = f->invG;
 80239d8:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 80239dc:	6222      	str	r2, [r4, #32]
            f->R2 = f->invG;
 80239de:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 80239e2:	61e3      	str	r3, [r4, #28]
 80239e4:	6263      	str	r3, [r4, #36]	; 0x24
 80239e6:	e7cf      	b.n	8023988 <tVZFilter_setGain+0xe4>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80239e8:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 80239ec:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 80239f0:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80239f2:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80239f6:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80239fa:	f003 fdc1 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 80239fe:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 8023a02:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8023a06:	ed9f 7a8e 	vldr	s14, [pc, #568]	; 8023c40 <tVZFilter_setGain+0x39c>
 8023a0a:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8023a0e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8023a12:	ee27 0a80 	vmul.f32	s0, s15, s0
 8023a16:	f003 fef1 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8023a1a:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8023a1e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8023a22:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8023a24:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8023a28:	61e3      	str	r3, [r4, #28]
 8023a2a:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8023a2c:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8023a30:	ee20 0a00 	vmul.f32	s0, s0, s0
 8023a34:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8023a38:	ee20 0a07 	vmul.f32	s0, s0, s14
 8023a3c:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8023a40:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8023a44:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8023a48:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8023a4c:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8023a50:	edc4 7a08 	vstr	s15, [r4, #32]
 8023a54:	e798      	b.n	8023988 <tVZFilter_setGain+0xe4>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8023a56:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8023a5a:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
    _tVZFilter* f = *vf;
 8023a5e:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8023a60:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8023a64:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8023a68:	f003 fd8a 	bl	8027580 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8023a6c:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
 8023a70:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8023a74:	ed9f 7a72 	vldr	s14, [pc, #456]	; 8023c40 <tVZFilter_setGain+0x39c>
 8023a78:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8023a7c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8023a80:	ee27 0a80 	vmul.f32	s0, s15, s0
 8023a84:	f003 feba 	bl	80277fc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8023a88:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8023a8c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8023a90:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8023a92:	ee80 0a07 	vdiv.f32	s0, s0, s14
            f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8023a96:	6223      	str	r3, [r4, #32]
 8023a98:	edc4 7a07 	vstr	s15, [r4, #28]
 8023a9c:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8023aa0:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8023aa4:	ee20 0a00 	vmul.f32	s0, s0, s0
 8023aa8:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8023aac:	ee20 0a07 	vmul.f32	s0, s0, s14
 8023ab0:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8023ab4:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8023ab8:	eef1 7ac7 	vsqrt.f32	s15, s14
            f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8023abc:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8023ac0:	edc4 7a05 	vstr	s15, [r4, #20]
 8023ac4:	e760      	b.n	8023988 <tVZFilter_setGain+0xe4>
            float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
 8023ac6:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8023aca:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
 8023ace:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8023ad2:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8023ad6:	f003 fd53 	bl	8027580 <powf>
            float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8023ada:	ee28 0a00 	vmul.f32	s0, s16, s0
 8023ade:	f003 fe8d 	bl	80277fc <tanf>
            float r  = f->g/wl;
 8023ae2:	ee88 0a80 	vdiv.f32	s0, s17, s0
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8023ae6:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
 8023aea:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8023aee:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 8023af2:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8023af6:	edc4 7a07 	vstr	s15, [r4, #28]
 8023afa:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8023afe:	ee67 6a26 	vmul.f32	s13, s14, s13
            r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
 8023b02:	ee20 0a00 	vmul.f32	s0, s0, s0
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8023b06:	eee0 7a00 	vfma.f32	s15, s0, s0
 8023b0a:	ee87 6a80 	vdiv.f32	s12, s15, s0
 8023b0e:	ee76 7a65 	vsub.f32	s15, s12, s11
 8023b12:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8023b16:	eef1 7ac6 	vsqrt.f32	s15, s12
 8023b1a:	ee77 7aa7 	vadd.f32	s15, s15, s15
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8023b1e:	ee27 7a27 	vmul.f32	s14, s14, s15
            f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8023b22:	edc4 7a05 	vstr	s15, [r4, #20]
            f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8023b26:	ed84 7a08 	vstr	s14, [r4, #32]
 8023b2a:	e72d      	b.n	8023988 <tVZFilter_setGain+0xe4>
            float A = sqrtf(f->G);
 8023b2c:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
          f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8023b30:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8023b34:	eddf 7a43 	vldr	s15, [pc, #268]	; 8023c44 <tVZFilter_setGain+0x3a0>
            float A = sqrtf(f->G);
 8023b38:	eeb1 8ac9 	vsqrt.f32	s16, s18
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8023b3c:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
 8023b40:	ee20 0a27 	vmul.f32	s0, s0, s15
 8023b44:	eef1 7ac8 	vsqrt.f32	s15, s16
          f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8023b48:	eec8 8aa7 	vdiv.f32	s17, s17, s15
 8023b4c:	edc4 8a04 	vstr	s17, [r4, #16]
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8023b50:	f004 f80e 	bl	8027b70 <sinhf>
 8023b54:	ee70 7a00 	vadd.f32	s15, s0, s0
          f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8023b58:	ed84 9a07 	vstr	s18, [r4, #28]
 8023b5c:	6265      	str	r5, [r4, #36]	; 0x24
 8023b5e:	ee28 8a27 	vmul.f32	s16, s16, s15
          f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8023b62:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8023b66:	ed84 8a08 	vstr	s16, [r4, #32]
 8023b6a:	e70d      	b.n	8023988 <tVZFilter_setGain+0xe4>
          float A = sqrtf(f->G);
 8023b6c:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8023b70:	eddf 7a34 	vldr	s15, [pc, #208]	; 8023c44 <tVZFilter_setGain+0x3a0>
          float A = sqrtf(f->G);
 8023b74:	eeb1 8ac9 	vsqrt.f32	s16, s18
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8023b78:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
 8023b7c:	ee20 0a27 	vmul.f32	s0, s0, s15
          f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8023b80:	eef1 7ac8 	vsqrt.f32	s15, s16
 8023b84:	ee68 8aa7 	vmul.f32	s17, s17, s15
 8023b88:	edc4 8a04 	vstr	s17, [r4, #16]
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8023b8c:	f003 fff0 	bl	8027b70 <sinhf>
 8023b90:	ee70 7a00 	vadd.f32	s15, s0, s0
          f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 8023b94:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8023b98:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
 8023b9c:	ee28 8a27 	vmul.f32	s16, s16, s15
          f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8023ba0:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 8023ba4:	61e3      	str	r3, [r4, #28]
 8023ba6:	ed84 8a08 	vstr	s16, [r4, #32]
 8023baa:	e6ed      	b.n	8023988 <tVZFilter_setGain+0xe4>
          float x  = 2.0f*f->m-1.0f;
 8023bac:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8023bb0:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
 8023bb4:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
            f->R2 = f->invG;
 8023bb8:	6b23      	ldr	r3, [r4, #48]	; 0x30
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8023bba:	eddf 0a23 	vldr	s1, [pc, #140]	; 8023c48 <tVZFilter_setGain+0x3a4>
            f->R2 = f->invG;
 8023bbe:	6163      	str	r3, [r4, #20]
          float x  = 2.0f*f->m-1.0f;
 8023bc0:	eea7 8a27 	vfma.f32	s16, s14, s15
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8023bc4:	eef1 8a48 	vneg.f32	s17, s16
 8023bc8:	eeb0 0a68 	vmov.f32	s0, s17
 8023bcc:	f000 fb54 	bl	8024278 <maximum>
          f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 8023bd0:	eddf 0a1d 	vldr	s1, [pc, #116]	; 8023c48 <tVZFilter_setGain+0x3a4>
          f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8023bd4:	ed84 0a07 	vstr	s0, [r4, #28]
          f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 8023bd8:	eeb0 0a48 	vmov.f32	s0, s16
 8023bdc:	f000 fb50 	bl	8024280 <minimum>
          f->cB = 1.0f-x*x;
 8023be0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
          float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 8023be4:	edd4 6a07 	vldr	s13, [r4, #28]
 8023be8:	edd4 7a05 	vldr	s15, [r4, #20]
          f->cB = 1.0f-x*x;
 8023bec:	eea8 7a88 	vfma.f32	s14, s17, s16
          float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 8023bf0:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
 8023bf4:	ee36 5aa6 	vadd.f32	s10, s13, s13
 8023bf8:	edd4 8a04 	vldr	s17, [r4, #16]
 8023bfc:	ee67 4aa7 	vmul.f32	s9, s15, s15
 8023c00:	ee27 6a07 	vmul.f32	s12, s14, s14
 8023c04:	eea6 6aa6 	vfma.f32	s12, s13, s13
 8023c08:	eea0 6a00 	vfma.f32	s12, s0, s0
 8023c0c:	eea0 6a45 	vfms.f32	s12, s0, s10
 8023c10:	ee84 5a86 	vdiv.f32	s10, s9, s12
 8023c14:	eeb1 6ac5 	vsqrt.f32	s12, s10
 8023c18:	ee26 6a25 	vmul.f32	s12, s12, s11
          f->cL *= s; f->cB *= s; f->cH *= s;
 8023c1c:	ee66 6a86 	vmul.f32	s13, s13, s12
 8023c20:	ee27 7a06 	vmul.f32	s14, s14, s12
 8023c24:	ee20 0a06 	vmul.f32	s0, s0, s12
 8023c28:	edc4 6a07 	vstr	s13, [r4, #28]
 8023c2c:	ed84 7a08 	vstr	s14, [r4, #32]
 8023c30:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 8023c34:	e6a8      	b.n	8023988 <tVZFilter_setGain+0xe4>
 8023c36:	bf00      	nop
 8023c38:	42c80000 	.word	0x42c80000
 8023c3c:	358637bd 	.word	0x358637bd
 8023c40:	40490fdb 	.word	0x40490fdb
 8023c44:	3eb17218 	.word	0x3eb17218
 8023c48:	00000000 	.word	0x00000000
          f->cL = 1.0f;
 8023c4c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
          f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8023c50:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
          f->cL = 1.0f;
 8023c54:	61e3      	str	r3, [r4, #28]
          f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8023c56:	edc4 7a05 	vstr	s15, [r4, #20]
          f->cH = 1.0f;
 8023c5a:	6263      	str	r3, [r4, #36]	; 0x24
          f->cB = f->R2;
 8023c5c:	edc4 7a08 	vstr	s15, [r4, #32]
 8023c60:	e692      	b.n	8023988 <tVZFilter_setGain+0xe4>
 8023c62:	edd4 7a05 	vldr	s15, [r4, #20]
 8023c66:	e68f      	b.n	8023988 <tVZFilter_setGain+0xe4>

08023c68 <interpolate3max>:
    return (0.1640425613334452f * x*x*x) + (-1.098865286222744f * x*x) + (3.148297929334117f * x) + -2.213475204444817f;
}

float interpolate3max(float *buf, const int peakindex)
{
    float a = buf[peakindex-1];
 8023c68:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
    float b = buf[peakindex];
    float c = buf[peakindex+1];
    float realpeak;
    
    realpeak = b + (float)0.125 * (c - a) * (c - a) / ((float)2. * b - a - c);
 8023c6c:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
 8023c70:	eef4 5a00 	vmov.f32	s11, #64	; 0x3e000000  0.125
    float a = buf[peakindex-1];
 8023c74:	440b      	add	r3, r1
 8023c76:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8023c7a:	edd0 7a00 	vldr	s15, [r0]
    float c = buf[peakindex+1];
 8023c7e:	ed90 6a02 	vldr	s12, [r0, #8]
    float b = buf[peakindex];
 8023c82:	edd0 6a01 	vldr	s13, [r0, #4]
    realpeak = b + (float)0.125 * (c - a) * (c - a) / ((float)2. * b - a - c);
 8023c86:	ee36 7a67 	vsub.f32	s14, s12, s15
 8023c8a:	eed6 7a85 	vfnms.f32	s15, s13, s10
 8023c8e:	ee27 7a07 	vmul.f32	s14, s14, s14
 8023c92:	ee27 7a25 	vmul.f32	s14, s14, s11
 8023c96:	ee77 7ac6 	vsub.f32	s15, s15, s12
 8023c9a:	ee87 0a27 	vdiv.f32	s0, s14, s15
    
    return(realpeak);
}
 8023c9e:	ee30 0a26 	vadd.f32	s0, s0, s13
 8023ca2:	4770      	bx	lr

08023ca4 <interpolate3phase>:

float interpolate3phase(float *buf, const int peakindex)
{
    float a = buf[peakindex-1];
 8023ca4:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
    float b = buf[peakindex];
    float c = buf[peakindex+1];
    float fraction;
    
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
 8023ca8:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 8023cac:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    float a = buf[peakindex-1];
 8023cb0:	440b      	add	r3, r1
 8023cb2:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8023cb6:	edd0 7a00 	vldr	s15, [r0]
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
 8023cba:	edd0 5a01 	vldr	s11, [r0, #4]
 8023cbe:	eeb0 0a67 	vmov.f32	s0, s15
    float c = buf[peakindex+1];
 8023cc2:	ed90 7a02 	vldr	s14, [r0, #8]
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
 8023cc6:	ee77 7a67 	vsub.f32	s15, s14, s15
 8023cca:	ee95 0a86 	vfnms.f32	s0, s11, s12
 8023cce:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8023cd2:	ee30 0a47 	vsub.f32	s0, s0, s14
    
    return(fraction);
}
 8023cd6:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8023cda:	4770      	bx	lr

08023cdc <fastercosf>:
    return fResult;
}

float fastercosf(float fAngle)
{
    float fASqr = fAngle*fAngle;
 8023cdc:	ee20 7a00 	vmul.f32	s14, s0, s0
    float fResult = 3.705e-02f;
    fResult *= fASqr;
    fResult -= 4.967e-01f;
 8023ce0:	eddf 6a05 	vldr	s13, [pc, #20]	; 8023cf8 <fastercosf+0x1c>
 8023ce4:	eddf 7a05 	vldr	s15, [pc, #20]	; 8023cfc <fastercosf+0x20>
    fResult *= fASqr;
    fResult += 1.0f;
 8023ce8:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    fResult -= 4.967e-01f;
 8023cec:	eee7 7a26 	vfma.f32	s15, s14, s13
    return fResult;
}
 8023cf0:	eea7 0a27 	vfma.f32	s0, s14, s15
 8023cf4:	4770      	bx	lr
 8023cf6:	bf00      	nop
 8023cf8:	3d17c1be 	.word	0x3d17c1be
 8023cfc:	befe4f76 	.word	0xbefe4f76

08023d00 <fastabsf>:
        unsigned int ui;
    }alias;
    
    alias.f = f;
    alias.ui &= 0x7fffffff;
    return alias.f;
 8023d00:	ee10 3a10 	vmov	r3, s0
 8023d04:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
}
 8023d08:	ee00 3a10 	vmov	s0, r3
 8023d0c:	4770      	bx	lr
 8023d0e:	bf00      	nop

08023d10 <fastexp2f>:

// fast floating-point exp2 function taken from Robert Bristow Johnson's
// post in the music-dsp list on Date: Tue, 02 Sep 2014 16:50:11 -0400
float fastexp2f(float x)
{
    if (x >= -127.0)
 8023d10:	eddf 7a1f 	vldr	s15, [pc, #124]	; 8023d90 <fastexp2f+0x80>
 8023d14:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8023d18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023d1c:	db34      	blt.n	8023d88 <fastexp2f+0x78>
    {
        float accumulator, xPower;
        union {float f; int32_t i;} xBits;
        
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
 8023d1e:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 8023d94 <fastexp2f+0x84>
        xPower = x*x;
        accumulator += 0.24137976293709f*xPower;
        xPower *= x;
        accumulator += 0.05203236900844f*xPower;
        xPower *= x;
        accumulator += 0.01355574723481f*xPower;
 8023d22:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8023d26:	eddf 4a1c 	vldr	s9, [pc, #112]	; 8023d98 <fastexp2f+0x88>
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
 8023d2a:	ee30 7a07 	vadd.f32	s14, s0, s14
        accumulator += 0.01355574723481f*xPower;
 8023d2e:	eddf 5a1b 	vldr	s11, [pc, #108]	; 8023d9c <fastexp2f+0x8c>
 8023d32:	ed9f 6a1b 	vldr	s12, [pc, #108]	; 8023da0 <fastexp2f+0x90>
 8023d36:	ed9f 5a1b 	vldr	s10, [pc, #108]	; 8023da4 <fastexp2f+0x94>
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
 8023d3a:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8023d3e:	ee17 3a10 	vmov	r3, s14
 8023d42:	f5a3 5280 	sub.w	r2, r3, #4096	; 0x1000
 8023d46:	ee07 2a10 	vmov	s14, r2
        
        xBits.i += 127;                                                    /* bias integer part */
 8023d4a:	f46f 6278 	mvn.w	r2, #3968	; 0xf80
        x -= (float)(xBits.i);                                             /* fractional part */
 8023d4e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
        xBits.i += 127;                                                    /* bias integer part */
 8023d52:	4413      	add	r3, r2
        xBits.i<<= 23;                                                     /* move biased int part into exponent bits */
 8023d54:	05db      	lsls	r3, r3, #23
        x -= (float)(xBits.i);                                             /* fractional part */
 8023d56:	ee30 7a47 	vsub.f32	s14, s0, s14
        xPower = x*x;
 8023d5a:	ee67 6a07 	vmul.f32	s13, s14, s14
        accumulator += 0.01355574723481f*xPower;
 8023d5e:	eee6 7aa4 	vfma.f32	s15, s13, s9
 8023d62:	eeb0 0a67 	vmov.f32	s0, s15
        xPower *= x;
 8023d66:	ee67 7a26 	vmul.f32	s15, s14, s13
        accumulator += 0.01355574723481f*xPower;
 8023d6a:	eef0 6a46 	vmov.f32	s13, s12
 8023d6e:	eea7 0aa5 	vfma.f32	s0, s15, s11
 8023d72:	eee7 6a85 	vfma.f32	s13, s15, s10
 8023d76:	eef0 7a40 	vmov.f32	s15, s0
 8023d7a:	eee7 7a26 	vfma.f32	s15, s14, s13
        
        return accumulator * xBits.f;
 8023d7e:	ee07 3a10 	vmov	s14, r3
 8023d82:	ee27 0a87 	vmul.f32	s0, s15, s14
 8023d86:	4770      	bx	lr
    }
    else
    {
        return 0.0f;
 8023d88:	ed9f 0a07 	vldr	s0, [pc, #28]	; 8023da8 <fastexp2f+0x98>
    }
}
 8023d8c:	4770      	bx	lr
 8023d8e:	bf00      	nop
 8023d90:	c2fe0000 	.word	0xc2fe0000
 8023d94:	45800000 	.word	0x45800000
 8023d98:	3e772c42 	.word	0x3e772c42
 8023d9c:	3d551fe5 	.word	0x3d551fe5
 8023da0:	3f316a8e 	.word	0x3f316a8e
 8023da4:	3c5e18ed 	.word	0x3c5e18ed
 8023da8:	00000000 	.word	0x00000000

08023dac <LEAF_crossfade>:
 when t = 0, volumes[0] = 0.707, volumes[1] = 0.707 (equal-power cross fade)
 when t = 1, volumes[0] = 1, volumes[1] = 0
 */

void LEAF_crossfade(float fade, float* volumes) {
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
 8023dac:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8023db0:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 8023db4:	ee30 7a27 	vadd.f32	s14, s0, s15
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
 8023db8:	ee77 7ac0 	vsub.f32	s15, s15, s0
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
 8023dbc:	ee27 7a26 	vmul.f32	s14, s14, s13
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
 8023dc0:	ee67 7aa6 	vmul.f32	s15, s15, s13
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
 8023dc4:	eef1 6ac7 	vsqrt.f32	s13, s14
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
 8023dc8:	eeb1 7ae7 	vsqrt.f32	s14, s15
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
 8023dcc:	edc0 6a00 	vstr	s13, [r0]
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
 8023dd0:	ed80 7a01 	vstr	s14, [r0, #4]
}
 8023dd4:	4770      	bx	lr
 8023dd6:	bf00      	nop

08023dd8 <LEAF_frequencyToMidi>:
}
#endif

float LEAF_frequencyToMidi(float f)
{
    return (69.0f + 12.0f * log2f(f * INV_440));
 8023dd8:	eddf 7a07 	vldr	s15, [pc, #28]	; 8023df8 <LEAF_frequencyToMidi+0x20>
{
 8023ddc:	b508      	push	{r3, lr}
    return (69.0f + 12.0f * log2f(f * INV_440));
 8023dde:	ee20 0a27 	vmul.f32	s0, s0, s15
 8023de2:	f003 fb4b 	bl	802747c <log2f>
 8023de6:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
 8023dea:	eddf 7a04 	vldr	s15, [pc, #16]	; 8023dfc <LEAF_frequencyToMidi+0x24>
}
 8023dee:	eee0 7a07 	vfma.f32	s15, s0, s14
 8023df2:	eeb0 0a67 	vmov.f32	s0, s15
 8023df6:	bd08      	pop	{r3, pc}
 8023df8:	3b14f209 	.word	0x3b14f209
 8023dfc:	428a0000 	.word	0x428a0000

08023e00 <LEAF_shaper>:

// Jones shaper
float LEAF_shaper(float input, float m_drive)
{
    float fx = input * 2.0f;    // prescale
 8023e00:	ee30 0a00 	vadd.f32	s0, s0, s0
 8023e04:	eddf 6a1a 	vldr	s13, [pc, #104]	; 8023e70 <LEAF_shaper+0x70>
 8023e08:	eddf 7a1a 	vldr	s15, [pc, #104]	; 8023e74 <LEAF_shaper+0x74>
    
    xc = LEAF_clip(-SQRT8, fx, SQRT8);
    xc2 = xc*xc;
    c = 0.5f*fx*(3.0f - (xc2));
    xc4 = xc2 * xc2;
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 8023e0c:	eeb5 7a00 	vmov.f32	s14, #80	; 0x3e800000  0.250
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8023e10:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 8023e14:	ed9f 4a18 	vldr	s8, [pc, #96]	; 8023e78 <LEAF_shaper+0x78>
 8023e18:	fec0 7a67 	vminnm.f32	s15, s0, s15
 8023e1c:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
    xc2 = xc*xc;
 8023e20:	ee67 7aa7 	vmul.f32	s15, s15, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8023e24:	eddf 4a15 	vldr	s9, [pc, #84]	; 8023e7c <LEAF_shaper+0x7c>
 8023e28:	ee20 6a06 	vmul.f32	s12, s0, s12
    shaperOut *= 0.5f;    // post_scale
 8023e2c:	ed9f 5a14 	vldr	s10, [pc, #80]	; 8023e80 <LEAF_shaper+0x80>
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8023e30:	eef6 6a08 	vmov.f32	s13, #104	; 0x3f400000  0.750
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 8023e34:	ee67 3aa7 	vmul.f32	s7, s15, s15
 8023e38:	ee27 7a67 	vnmul.f32	s14, s14, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8023e3c:	ee27 0aa4 	vmul.f32	s0, s15, s9
    c = 0.5f*fx*(3.0f - (xc2));
 8023e40:	eef0 5a08 	vmov.f32	s11, #8	; 0x40400000  3.0
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 8023e44:	eea3 7a84 	vfma.f32	s14, s7, s8
 8023e48:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    c = 0.5f*fx*(3.0f - (xc2));
 8023e4c:	ee75 5ae7 	vsub.f32	s11, s11, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8023e50:	ee70 0aa6 	vadd.f32	s1, s1, s13
 8023e54:	eef0 7a40 	vmov.f32	s15, s0
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 8023e58:	ee37 7a24 	vadd.f32	s14, s14, s9
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8023e5c:	eee5 7a86 	vfma.f32	s15, s11, s12
    shaperOut *= 0.5f;    // post_scale
 8023e60:	ee20 0a85 	vmul.f32	s0, s1, s10
 8023e64:	ee27 0a00 	vmul.f32	s0, s14, s0
    return shaperOut;
}
 8023e68:	ee20 0a27 	vmul.f32	s0, s0, s15
 8023e6c:	4770      	bx	lr
 8023e6e:	bf00      	nop
 8023e70:	c03504f3 	.word	0xc03504f3
 8023e74:	403504f3 	.word	0x403504f3
 8023e78:	3c800000 	.word	0x3c800000
 8023e7c:	3d4ccccd 	.word	0x3d4ccccd
 8023e80:	3f272f05 	.word	0x3f272f05

08023e84 <LEAF_round>:

// round input to nearest rnd
float LEAF_round (float input, float rnd)
{
    rnd = fabsf(rnd);
 8023e84:	eef0 0ae0 	vabs.f32	s1, s1
    
    if (rnd <= 0.0000001f) return input;
 8023e88:	eddf 7a06 	vldr	s15, [pc, #24]	; 8023ea4 <LEAF_round+0x20>
 8023e8c:	eef4 0ae7 	vcmpe.f32	s1, s15
 8023e90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023e94:	d905      	bls.n	8023ea2 <LEAF_round+0x1e>
    
    float scale = 1.f / rnd;
    
    return roundf(input * scale) / scale;
 8023e96:	eec0 7a20 	vdiv.f32	s15, s0, s1
 8023e9a:	feb8 0a67 	vrinta.f32	s0, s15
 8023e9e:	ee20 0a20 	vmul.f32	s0, s0, s1
}
 8023ea2:	4770      	bx	lr
 8023ea4:	33d6bf95 	.word	0x33d6bf95

08023ea8 <LEAF_bitwise_xor>:
{
    union unholy_t unholy;
    unholy.f = input;
    unholy.i = (unholy.i ^ op);
    
    return unholy.f;
 8023ea8:	ee10 3a10 	vmov	r3, s0
 8023eac:	4058      	eors	r0, r3
}
 8023eae:	ee00 0a10 	vmov	s0, r0
 8023eb2:	4770      	bx	lr

08023eb4 <LEAF_clip>:

float   LEAF_clip(float min, float val, float max)
{
    float tempmin = min;
    float tempmax = max;
    if (min > max)
 8023eb4:	eeb4 0ac1 	vcmpe.f32	s0, s2
 8023eb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023ebc:	dd05      	ble.n	8023eca <LEAF_clip+0x16>
 8023ebe:	eef0 7a40 	vmov.f32	s15, s0
    {
        tempmin = max;
 8023ec2:	eeb0 0a41 	vmov.f32	s0, s2
        tempmax = min;
 8023ec6:	eeb0 1a67 	vmov.f32	s2, s15
    }
    if (val < tempmin)
 8023eca:	eeb4 0ae0 	vcmpe.f32	s0, s1
 8023ece:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023ed2:	dc01      	bgt.n	8023ed8 <LEAF_clip+0x24>
 8023ed4:	fe81 0a60 	vminnm.f32	s0, s2, s1
    }
    else
    {
        return val;
    }
}
 8023ed8:	4770      	bx	lr
 8023eda:	bf00      	nop

08023edc <LEAF_clipInt>:

int   LEAF_clipInt(int min, int val, int max)
{
    int tempmin = min;
    int tempmax = max;
    if (min > max)
 8023edc:	4290      	cmp	r0, r2
 8023ede:	dd02      	ble.n	8023ee6 <LEAF_clipInt+0xa>
 8023ee0:	4603      	mov	r3, r0
 8023ee2:	4610      	mov	r0, r2
 8023ee4:	461a      	mov	r2, r3
    {
        tempmin = max;
        tempmax = min;
    }
    if (val < tempmin) {
 8023ee6:	4288      	cmp	r0, r1
 8023ee8:	dc03      	bgt.n	8023ef2 <LEAF_clipInt+0x16>
 8023eea:	428a      	cmp	r2, r1
 8023eec:	bfa8      	it	ge
 8023eee:	460a      	movge	r2, r1
 8023ef0:	4610      	mov	r0, r2
    } else if (val > tempmax) {
        return tempmax;
    } else {
        return val;
    }
}
 8023ef2:	4770      	bx	lr

08023ef4 <LEAF_isPrime>:

int     LEAF_isPrime(uint64_t number )
{
    if ( number == 2 ) return 1;
 8023ef4:	2900      	cmp	r1, #0
 8023ef6:	bf08      	it	eq
 8023ef8:	2802      	cmpeq	r0, #2
 8023efa:	d02a      	beq.n	8023f52 <LEAF_isPrime+0x5e>
    if ( number & 1 ) {
 8023efc:	f000 0201 	and.w	r2, r0, #1
 8023f00:	2300      	movs	r3, #0
 8023f02:	4313      	orrs	r3, r2
{
 8023f04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023f08:	4606      	mov	r6, r0
    if ( number & 1 ) {
 8023f0a:	d01f      	beq.n	8023f4c <LEAF_isPrime+0x58>
 8023f0c:	460f      	mov	r7, r1
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
 8023f0e:	f7dc fb71 	bl	80005f4 <__aeabi_ul2d>
 8023f12:	2403      	movs	r4, #3
 8023f14:	2500      	movs	r5, #0
 8023f16:	ec41 0b17 	vmov	d7, r0, r1
 8023f1a:	eeb1 7bc7 	vsqrt.f64	d7, d7
 8023f1e:	eefd 7bc7 	vcvt.s32.f64	s15, d7
 8023f22:	ee17 8a90 	vmov	r8, s15
 8023f26:	f108 0801 	add.w	r8, r8, #1
 8023f2a:	e006      	b.n	8023f3a <LEAF_isPrime+0x46>
            if ( (number % i) == 0 ) return 0;
 8023f2c:	f7dc fb98 	bl	8000660 <__aeabi_uldivmod>
 8023f30:	3402      	adds	r4, #2
 8023f32:	f145 0500 	adc.w	r5, r5, #0
 8023f36:	4313      	orrs	r3, r2
 8023f38:	d008      	beq.n	8023f4c <LEAF_isPrime+0x58>
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
 8023f3a:	45a0      	cmp	r8, r4
            if ( (number % i) == 0 ) return 0;
 8023f3c:	4622      	mov	r2, r4
 8023f3e:	462b      	mov	r3, r5
 8023f40:	4630      	mov	r0, r6
 8023f42:	4639      	mov	r1, r7
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
 8023f44:	dcf2      	bgt.n	8023f2c <LEAF_isPrime+0x38>
    if ( number == 2 ) return 1;
 8023f46:	2001      	movs	r0, #1
        return 1; // prime
    }
    else return 0; // even
}
 8023f48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else return 0; // even
 8023f4c:	2000      	movs	r0, #0
}
 8023f4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( number == 2 ) return 1;
 8023f52:	2001      	movs	r0, #1
}
 8023f54:	4770      	bx	lr
 8023f56:	bf00      	nop

08023f58 <LEAF_tanh>:

// Adapted from MusicDSP: http://www.musicdsp.org/showone.php?id=238
float LEAF_tanh(float x)
{
    
    if( x < -3.0f )
 8023f58:	eef8 7a08 	vmov.f32	s15, #136	; 0xc0400000 -3.0
 8023f5c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8023f60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023f64:	d418      	bmi.n	8023f98 <LEAF_tanh+0x40>
        return -1.0f;
    else if( x > 3.0f )
 8023f66:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
 8023f6a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8023f6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023f72:	dc0e      	bgt.n	8023f92 <LEAF_tanh+0x3a>
        return 1.0f;
    else
        return x * ( 27.0f + x * x ) / ( 27.0f + 9.0f * x * x );
 8023f74:	ee60 6a00 	vmul.f32	s13, s0, s0
 8023f78:	eef3 7a0b 	vmov.f32	s15, #59	; 0x41d80000  27.0
 8023f7c:	eeb2 6a02 	vmov.f32	s12, #34	; 0x41100000  9.0
 8023f80:	ee36 7aa7 	vadd.f32	s14, s13, s15
 8023f84:	eee6 7a86 	vfma.f32	s15, s13, s12
 8023f88:	ee27 7a00 	vmul.f32	s14, s14, s0
 8023f8c:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8023f90:	4770      	bx	lr
        return 1.0f;
 8023f92:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
}
 8023f96:	4770      	bx	lr
        return -1.0f;
 8023f98:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8023f9c:	4770      	bx	lr
 8023f9e:	bf00      	nop

08023fa0 <LEAF_generate_exp>:


//0.001 base gives a good curve that goes from 1 to near zero
void LEAF_generate_exp(float* buffer, float base, float start, float end, float offset, int size)
{
    float increment = (end - start) / (float)size;
 8023fa0:	ee07 1a90 	vmov	s15, r1
 8023fa4:	ee31 1a60 	vsub.f32	s2, s2, s1
    float x = start;
    for (int i = 0; i < size; i++)
 8023fa8:	2900      	cmp	r1, #0
    float increment = (end - start) / (float)size;
 8023faa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
{
 8023fae:	b538      	push	{r3, r4, r5, lr}
 8023fb0:	ed2d 8b04 	vpush	{d8-d9}
    float increment = (end - start) / (float)size;
 8023fb4:	eec1 8a27 	vdiv.f32	s17, s2, s15
    for (int i = 0; i < size; i++)
 8023fb8:	dd16      	ble.n	8023fe8 <LEAF_generate_exp+0x48>
 8023fba:	4604      	mov	r4, r0
 8023fbc:	eb00 0581 	add.w	r5, r0, r1, lsl #2
 8023fc0:	eeb0 8a60 	vmov.f32	s16, s1
 8023fc4:	eeb0 9a40 	vmov.f32	s18, s0
 8023fc8:	eef0 9a61 	vmov.f32	s19, s3
    {
        buffer[i] = powf(base, x) + offset;
 8023fcc:	eef0 0a48 	vmov.f32	s1, s16
 8023fd0:	eeb0 0a49 	vmov.f32	s0, s18
 8023fd4:	f003 fad4 	bl	8027580 <powf>
 8023fd8:	ee30 0a29 	vadd.f32	s0, s0, s19
        x += increment;
 8023fdc:	ee38 8a28 	vadd.f32	s16, s16, s17
        buffer[i] = powf(base, x) + offset;
 8023fe0:	eca4 0a01 	vstmia	r4!, {s0}
    for (int i = 0; i < size; i++)
 8023fe4:	42a5      	cmp	r5, r4
 8023fe6:	d1f1      	bne.n	8023fcc <LEAF_generate_exp+0x2c>
    }
}
 8023fe8:	ecbd 8b04 	vpop	{d8-d9}
 8023fec:	bd38      	pop	{r3, r4, r5, pc}
 8023fee:	bf00      	nop

08023ff0 <LEAF_generate_atodbPositiveClipped>:
    }
}


void LEAF_generate_atodbPositiveClipped(float* buffer, float lowerThreshold, float range, int size)
{
 8023ff0:	b538      	push	{r3, r4, r5, lr}
    alias.ui &= 0x7fffffff;
 8023ff2:	ee10 3a10 	vmov	r3, s0
    float increment = 1.0f / (float)size;
 8023ff6:	ee07 1a90 	vmov	s15, r1
 8023ffa:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    float x = 0.0f;
    float scalar = range / fastabsf(lowerThreshold);
    for (int i = 0; i < size; i++)
 8023ffe:	2900      	cmp	r1, #0
    alias.ui &= 0x7fffffff;
 8024000:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    float increment = 1.0f / (float)size;
 8024004:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    float scalar = range / fastabsf(lowerThreshold);
 8024008:	ee06 3a90 	vmov	s13, r3
{
 802400c:	ed2d 8b08 	vpush	{d8-d11}
    float scalar = range / fastabsf(lowerThreshold);
 8024010:	eec0 9aa6 	vdiv.f32	s19, s1, s13
    float increment = 1.0f / (float)size;
 8024014:	eec7 aa27 	vdiv.f32	s21, s14, s15
    for (int i = 0; i < size; i++)
 8024018:	dd29      	ble.n	802406e <LEAF_generate_atodbPositiveClipped+0x7e>
 802401a:	ed9f 9a1b 	vldr	s18, [pc, #108]	; 8024088 <LEAF_generate_atodbPositiveClipped+0x98>
 802401e:	4604      	mov	r4, r0
 8024020:	eb00 0581 	add.w	r5, r0, r1, lsl #2
 8024024:	fe80 aa49 	vminnm.f32	s20, s0, s18
    {
        float temp = atodb(x);
        temp = LEAF_clip(lowerThreshold, temp, 0.0f);
        buffer[i] = (temp-lowerThreshold) * scalar;
 8024028:	ee7a ba40 	vsub.f32	s23, s20, s0
 802402c:	eef0 8a40 	vmov.f32	s17, s0
}


float atodb(float a)
{
    return 20.0f*log10f(a);
 8024030:	eeb3 ba04 	vmov.f32	s22, #52	; 0x41a00000  20.0
        buffer[i] = (temp-lowerThreshold) * scalar;
 8024034:	ee6b baa9 	vmul.f32	s23, s23, s19
    float x = 0.0f;
 8024038:	eeb0 8a49 	vmov.f32	s16, s18
 802403c:	fe80 9a09 	vmaxnm.f32	s18, s0, s18
    return 20.0f*log10f(a);
 8024040:	eeb0 0a48 	vmov.f32	s0, s16
 8024044:	f003 fd20 	bl	8027a88 <log10f>
 8024048:	ee20 0a0b 	vmul.f32	s0, s0, s22
    if (val < tempmin)
 802404c:	eeb4 aac0 	vcmpe.f32	s20, s0
        buffer[i] = (temp-lowerThreshold) * scalar;
 8024050:	fec9 7a40 	vminnm.f32	s15, s18, s0
 8024054:	ee77 7ae8 	vsub.f32	s15, s15, s17
    if (val < tempmin)
 8024058:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        buffer[i] = (temp-lowerThreshold) * scalar;
 802405c:	ee67 7aa9 	vmul.f32	s15, s15, s19
    if (val < tempmin)
 8024060:	dc08      	bgt.n	8024074 <LEAF_generate_atodbPositiveClipped+0x84>
        buffer[i] = (temp-lowerThreshold) * scalar;
 8024062:	ece4 7a01 	vstmia	r4!, {s15}
    for (int i = 0; i < size; i++)
 8024066:	42ac      	cmp	r4, r5
        x += increment;
 8024068:	ee38 8a2a 	vadd.f32	s16, s16, s21
    for (int i = 0; i < size; i++)
 802406c:	d1e8      	bne.n	8024040 <LEAF_generate_atodbPositiveClipped+0x50>
}
 802406e:	ecbd 8b08 	vpop	{d8-d11}
 8024072:	bd38      	pop	{r3, r4, r5, pc}
        buffer[i] = (temp-lowerThreshold) * scalar;
 8024074:	ece4 ba01 	vstmia	r4!, {s23}
    for (int i = 0; i < size; i++)
 8024078:	42a5      	cmp	r5, r4
        x += increment;
 802407a:	ee38 8a2a 	vadd.f32	s16, s16, s21
    for (int i = 0; i < size; i++)
 802407e:	d1df      	bne.n	8024040 <LEAF_generate_atodbPositiveClipped+0x50>
}
 8024080:	ecbd 8b08 	vpop	{d8-d11}
 8024084:	bd38      	pop	{r3, r4, r5, pc}
 8024086:	bf00      	nop
 8024088:	00000000 	.word	0x00000000

0802408c <LEAF_midiToFrequency>:
    if( f <= -1500.0f ) return (0);
 802408c:	eddf 7a10 	vldr	s15, [pc, #64]	; 80240d0 <LEAF_midiToFrequency+0x44>
 8024090:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8024094:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024098:	d917      	bls.n	80240ca <LEAF_midiToFrequency+0x3e>
 802409a:	eef0 7a40 	vmov.f32	s15, s0
    else return ( powf(2.0f, (f - 69.0f) * 0.083333333333333f) * 440.0f );
 802409e:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 80240d4 <LEAF_midiToFrequency+0x48>
 80240a2:	eddf 0a0d 	vldr	s1, [pc, #52]	; 80240d8 <LEAF_midiToFrequency+0x4c>
 80240a6:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80240aa:	fec7 7ae0 	vminnm.f32	s15, s15, s1
 80240ae:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80240b2:	eddf 0a0a 	vldr	s1, [pc, #40]	; 80240dc <LEAF_midiToFrequency+0x50>
{
 80240b6:	b508      	push	{r3, lr}
    else return ( powf(2.0f, (f - 69.0f) * 0.083333333333333f) * 440.0f );
 80240b8:	ee67 0aa0 	vmul.f32	s1, s15, s1
 80240bc:	f003 fa60 	bl	8027580 <powf>
 80240c0:	eddf 7a07 	vldr	s15, [pc, #28]	; 80240e0 <LEAF_midiToFrequency+0x54>
 80240c4:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 80240c8:	bd08      	pop	{r3, pc}
    if( f <= -1500.0f ) return (0);
 80240ca:	ed9f 0a06 	vldr	s0, [pc, #24]	; 80240e4 <LEAF_midiToFrequency+0x58>
}
 80240ce:	4770      	bx	lr
 80240d0:	c4bb8000 	.word	0xc4bb8000
 80240d4:	428a0000 	.word	0x428a0000
 80240d8:	44bb6000 	.word	0x44bb6000
 80240dc:	3daaaaab 	.word	0x3daaaaab
 80240e0:	43dc0000 	.word	0x43dc0000
 80240e4:	00000000 	.word	0x00000000

080240e8 <LEAF_interpolate_hermite_x>:
    float y0my1 = yy0 - yy1;
 80240e8:	ee70 7a60 	vsub.f32	s15, s0, s1
    float c1 = 0.5f * (yy2 - yy0);
 80240ec:	ee31 7a40 	vsub.f32	s14, s2, s0
    float c3 = (yy1 - yy2) + 0.5f * (yy3 - y0my1 - yy2);
 80240f0:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 80240f4:	ee71 1ae7 	vsub.f32	s3, s3, s15
 80240f8:	ee70 6ac1 	vsub.f32	s13, s1, s2
    float c2 = y0my1 + c1 - c3;
 80240fc:	eee7 7a06 	vfma.f32	s15, s14, s12
    float c3 = (yy1 - yy2) + 0.5f * (yy3 - y0my1 - yy2);
 8024100:	ee31 1ac1 	vsub.f32	s2, s3, s2
 8024104:	eee1 6a06 	vfma.f32	s13, s2, s12
    float c2 = y0my1 + c1 - c3;
 8024108:	ee77 7ae6 	vsub.f32	s15, s15, s13
    return ((c3 * xx + c2) * xx + c1) * xx + c0;
 802410c:	eee6 7a82 	vfma.f32	s15, s13, s4
 8024110:	ee67 7a82 	vmul.f32	s15, s15, s4
 8024114:	eee7 7a06 	vfma.f32	s15, s14, s12
}
 8024118:	eee7 0a82 	vfma.f32	s1, s15, s4
 802411c:	eeb0 0a60 	vmov.f32	s0, s1
 8024120:	4770      	bx	lr
 8024122:	bf00      	nop

08024124 <LEAF_interpolation_linear>:
{
 8024124:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8024128:	ed9f 7a07 	vldr	s14, [pc, #28]	; 8024148 <LEAF_interpolation_linear+0x24>
 802412c:	fe81 1a67 	vminnm.f32	s2, s2, s15
 8024130:	fe81 1a07 	vmaxnm.f32	s2, s2, s14
    float omAlpha = 1.0f - alpha;
 8024134:	ee77 7ac1 	vsub.f32	s15, s15, s2
    out += B * alpha;
 8024138:	ee20 1a81 	vmul.f32	s2, s1, s2
}
 802413c:	eea7 1a80 	vfma.f32	s2, s15, s0
 8024140:	eeb0 0a41 	vmov.f32	s0, s2
 8024144:	4770      	bx	lr
 8024146:	bf00      	nop
 8024148:	00000000 	.word	0x00000000

0802414c <mtof>:
    if (f <= -1500.0f) return(0);
 802414c:	eddf 7a0c 	vldr	s15, [pc, #48]	; 8024180 <mtof+0x34>
 8024150:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8024154:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024158:	d90f      	bls.n	802417a <mtof+0x2e>
    else return (8.17579891564f * expf(0.0577622650f * f));
 802415a:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 8024184 <mtof+0x38>
 802415e:	eddf 7a0a 	vldr	s15, [pc, #40]	; 8024188 <mtof+0x3c>
 8024162:	fe80 0a47 	vminnm.f32	s0, s0, s14
{
 8024166:	b508      	push	{r3, lr}
    else return (8.17579891564f * expf(0.0577622650f * f));
 8024168:	ee20 0a27 	vmul.f32	s0, s0, s15
 802416c:	f003 f898 	bl	80272a0 <expf>
 8024170:	eddf 7a06 	vldr	s15, [pc, #24]	; 802418c <mtof+0x40>
 8024174:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 8024178:	bd08      	pop	{r3, pc}
    if (f <= -1500.0f) return(0);
 802417a:	ed9f 0a05 	vldr	s0, [pc, #20]	; 8024190 <mtof+0x44>
}
 802417e:	4770      	bx	lr
 8024180:	c4bb8000 	.word	0xc4bb8000
 8024184:	44bb6000 	.word	0x44bb6000
 8024188:	3d6c9820 	.word	0x3d6c9820
 802418c:	4102d013 	.word	0x4102d013
 8024190:	00000000 	.word	0x00000000

08024194 <faster_mtof>:
 8024194:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8024198:	eddf 6a0e 	vldr	s13, [pc, #56]	; 80241d4 <faster_mtof+0x40>
 802419c:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 80241d8 <faster_mtof+0x44>
 80241a0:	eee0 7a26 	vfma.f32	s15, s0, s13
 80241a4:	ee27 0aa7 	vmul.f32	s0, s15, s15
 80241a8:	ee20 0a00 	vmul.f32	s0, s0, s0
 80241ac:	ee20 0a00 	vmul.f32	s0, s0, s0
 80241b0:	ee20 0a00 	vmul.f32	s0, s0, s0
 80241b4:	ee20 0a00 	vmul.f32	s0, s0, s0
 80241b8:	ee20 0a00 	vmul.f32	s0, s0, s0
 80241bc:	ee20 0a00 	vmul.f32	s0, s0, s0
 80241c0:	ee20 0a00 	vmul.f32	s0, s0, s0
 80241c4:	ee20 0a00 	vmul.f32	s0, s0, s0
 80241c8:	ee20 0a00 	vmul.f32	s0, s0, s0
 80241cc:	ee20 0a07 	vmul.f32	s0, s0, s14
 80241d0:	4770      	bx	lr
 80241d2:	bf00      	nop
 80241d4:	386c9820 	.word	0x386c9820
 80241d8:	4102d013 	.word	0x4102d013
 80241dc:	00000000 	.word	0x00000000

080241e0 <powtodb>:
{
 80241e0:	b508      	push	{r3, lr}
 80241e2:	ed2d 8b02 	vpush	{d8}
    if (f <= 0) return (0);
 80241e6:	ed9f 8a12 	vldr	s16, [pc, #72]	; 8024230 <powtodb+0x50>
 80241ea:	eeb4 0ac8 	vcmpe.f32	s0, s16
 80241ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80241f2:	d910      	bls.n	8024216 <powtodb+0x36>
        float val = 100.0f + 10.0f/LOGTEN * logf(f);
 80241f4:	f003 f8da 	bl	80273ac <logf>
 80241f8:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
 80241fc:	ed9f 7b08 	vldr	d7, [pc, #32]	; 8024220 <powtodb+0x40>
 8024200:	ed9f 0b09 	vldr	d0, [pc, #36]	; 8024228 <powtodb+0x48>
 8024204:	eea6 0b07 	vfma.f64	d0, d6, d7
 8024208:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
        return (val < 0.0f ? 0.0f : val);
 802420c:	fe80 0a08 	vmaxnm.f32	s0, s0, s16
}
 8024210:	ecbd 8b02 	vpop	{d8}
 8024214:	bd08      	pop	{r3, pc}
    if (f <= 0) return (0);
 8024216:	eeb0 0a48 	vmov.f32	s0, s16
}
 802421a:	ecbd 8b02 	vpop	{d8}
 802421e:	bd08      	pop	{r3, pc}
 8024220:	ed384f8a 	.word	0xed384f8a
 8024224:	40115f2c 	.word	0x40115f2c
 8024228:	00000000 	.word	0x00000000
 802422c:	40590000 	.word	0x40590000
 8024230:	00000000 	.word	0x00000000

08024234 <fastdbtoa>:


float fastdbtoa(float db)
{
    //return powf(10.0f, db * 0.05f);
    return expf(0.115129254649702f * db); //faster version from http://openaudio.blogspot.com/2017/02/faster-log10-and-pow.html
 8024234:	eddf 7a02 	vldr	s15, [pc, #8]	; 8024240 <fastdbtoa+0xc>
 8024238:	ee20 0a27 	vmul.f32	s0, s0, s15
 802423c:	f003 b830 	b.w	80272a0 <expf>
 8024240:	3debc8e3 	.word	0x3debc8e3

08024244 <fasterdbtoa>:
    x = 1.0f + (x * 0.00390625f);
 8024244:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8024248:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 8024274 <fasterdbtoa+0x30>
 802424c:	eee0 7a07 	vfma.f32	s15, s0, s14
    x *= x; x *= x; x *= x; x *= x;
 8024250:	ee27 0aa7 	vmul.f32	s0, s15, s15
 8024254:	ee20 0a00 	vmul.f32	s0, s0, s0
 8024258:	ee20 0a00 	vmul.f32	s0, s0, s0
 802425c:	ee20 0a00 	vmul.f32	s0, s0, s0
    x *= x; x *= x; x *= x; x *= x;
 8024260:	ee20 0a00 	vmul.f32	s0, s0, s0
 8024264:	ee20 0a00 	vmul.f32	s0, s0, s0
 8024268:	ee20 0a00 	vmul.f32	s0, s0, s0

float fasterdbtoa(float db)
{
    //return powf(10.0f, db * 0.05f);
    return fasterexpf(0.115129254649702f * db); //faster version from http://openaudio.blogspot.com/2017/02/faster-log10-and-pow.html
}
 802426c:	ee20 0a00 	vmul.f32	s0, s0, s0
 8024270:	4770      	bx	lr
 8024272:	bf00      	nop
 8024274:	39ebc8e3 	.word	0x39ebc8e3

08024278 <maximum>:


float maximum (float num1, float num2)
{
    return (num1 > num2 ) ? num1 : num2;
}
 8024278:	fe80 0a80 	vmaxnm.f32	s0, s1, s0
 802427c:	4770      	bx	lr
 802427e:	bf00      	nop

08024280 <minimum>:

float minimum (float num1, float num2)
{
    return (num1 < num2 ) ? num1 : num2;
}
 8024280:	fe80 0ac0 	vminnm.f32	s0, s1, s0
 8024284:	4770      	bx	lr
 8024286:	bf00      	nop

08024288 <leaf_pool_init>:
    */
    //is zeroing out the memory necessary? This takes a long time on large pools - JS
}

void leaf_pool_init(char* memory, size_t size)
{
 8024288:	b470      	push	{r4, r5, r6}
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 802428a:	4b0a      	ldr	r3, [pc, #40]	; (80242b4 <leaf_pool_init+0x2c>)
 802428c:	2610      	movs	r6, #16
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
 802428e:	f1a1 0410 	sub.w	r4, r1, #16
    pool->usize  = 0;
 8024292:	2200      	movs	r2, #0
    pool->msize  = size;
 8024294:	6259      	str	r1, [r3, #36]	; 0x24
}

static inline mpool_node_t* create_node(char* block_location, mpool_node_t* next, mpool_node_t* prev, size_t size)
{
    mpool_node_t* node = (mpool_node_t*)block_location;
    node->pool = block_location + leaf.header_size;
 8024296:	1985      	adds	r5, r0, r6
    leaf.mempool = &leaf._internal_mempool;
 8024298:	f103 011c 	add.w	r1, r3, #28
    pool->mpool = (char*)memory;
 802429c:	61d8      	str	r0, [r3, #28]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 802429e:	62de      	str	r6, [r3, #44]	; 0x2c
    pool->usize  = 0;
 80242a0:	621a      	str	r2, [r3, #32]
    node->pool = block_location + leaf.header_size;
 80242a2:	6005      	str	r5, [r0, #0]
    node->next = next;
    node->prev = prev;
    node->size = size;
 80242a4:	60c4      	str	r4, [r0, #12]
    node->prev = prev;
 80242a6:	e9c0 2201 	strd	r2, r2, [r0, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
 80242aa:	6298      	str	r0, [r3, #40]	; 0x28
    leaf.mempool = &leaf._internal_mempool;
 80242ac:	6199      	str	r1, [r3, #24]
}
 80242ae:	bc70      	pop	{r4, r5, r6}
 80242b0:	4770      	bx	lr
 80242b2:	bf00      	nop
 80242b4:	200194e8 	.word	0x200194e8

080242b8 <mpool_alloc>:
{
 80242b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pool->head == NULL)
 80242ba:	68cb      	ldr	r3, [r1, #12]
 80242bc:	2b00      	cmp	r3, #0
 80242be:	d038      	beq.n	8024332 <mpool_alloc+0x7a>
    return (size + (MPOOL_ALIGN_SIZE - 1)) & ~(MPOOL_ALIGN_SIZE - 1);
 80242c0:	1dc5      	adds	r5, r0, #7
 80242c2:	f025 0507 	bic.w	r5, r5, #7
    while (node_to_alloc->size < size_to_alloc)
 80242c6:	e002      	b.n	80242ce <mpool_alloc+0x16>
        if (node_to_alloc == NULL)
 80242c8:	4623      	mov	r3, r4
 80242ca:	2c00      	cmp	r4, #0
 80242cc:	d031      	beq.n	8024332 <mpool_alloc+0x7a>
    while (node_to_alloc->size < size_to_alloc)
 80242ce:	68da      	ldr	r2, [r3, #12]
 80242d0:	685c      	ldr	r4, [r3, #4]
 80242d2:	42aa      	cmp	r2, r5
 80242d4:	d3f8      	bcc.n	80242c8 <mpool_alloc+0x10>
    if (leftover > leaf.header_size)
 80242d6:	4e25      	ldr	r6, [pc, #148]	; (802436c <mpool_alloc+0xb4>)
    size_t leftover = node_to_alloc->size - size_to_alloc;
 80242d8:	1b57      	subs	r7, r2, r5
    node_to_alloc->size = size_to_alloc;
 80242da:	60dd      	str	r5, [r3, #12]
    if (leftover > leaf.header_size)
 80242dc:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80242de:	42b8      	cmp	r0, r7
 80242e0:	d332      	bcc.n	8024348 <mpool_alloc+0x90>
        node_to_alloc->size += leftover;
 80242e2:	46a4      	mov	ip, r4
 80242e4:	60da      	str	r2, [r3, #12]
    if (pool->head == node_to_alloc)
 80242e6:	68ca      	ldr	r2, [r1, #12]
 80242e8:	429a      	cmp	r2, r3
        pool->head = new_node;
 80242ea:	bf08      	it	eq
 80242ec:	f8c1 c00c 	streq.w	ip, [r1, #12]
 80242f0:	e9d3 0201 	ldrd	r0, r2, [r3, #4]
}

static inline void delink_node(mpool_node_t* node)
{
    // If there is a node after the node to remove
    if (node->next != NULL)
 80242f4:	b108      	cbz	r0, 80242fa <mpool_alloc+0x42>
    {
        // Close the link
        node->next->prev = node->prev;
 80242f6:	6082      	str	r2, [r0, #8]
 80242f8:	689a      	ldr	r2, [r3, #8]
    }
    // If there is a node before the node to remove
    if (node->prev != NULL)
 80242fa:	b10a      	cbz	r2, 8024300 <mpool_alloc+0x48>
    {
        // Close the link
        node->prev->next = node->next;
 80242fc:	6858      	ldr	r0, [r3, #4]
 80242fe:	6050      	str	r0, [r2, #4]
    }
    
    node->next = NULL;
 8024300:	2200      	movs	r2, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
 8024302:	68dc      	ldr	r4, [r3, #12]
    node->prev = NULL;
 8024304:	e9c3 2201 	strd	r2, r2, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
 8024308:	6848      	ldr	r0, [r1, #4]
 802430a:	6af5      	ldr	r5, [r6, #44]	; 0x2c
 802430c:	4428      	add	r0, r5
 802430e:	4420      	add	r0, r4
 8024310:	6048      	str	r0, [r1, #4]
    if (leaf.clearOnAllocation > 0)
 8024312:	6971      	ldr	r1, [r6, #20]
 8024314:	4291      	cmp	r1, r2
 8024316:	dd0a      	ble.n	802432e <mpool_alloc+0x76>
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 8024318:	68d9      	ldr	r1, [r3, #12]
        char* new_pool = (char*)node_to_alloc->pool;
 802431a:	6818      	ldr	r0, [r3, #0]
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 802431c:	b141      	cbz	r1, 8024330 <mpool_alloc+0x78>
 802431e:	3801      	subs	r0, #1
 8024320:	4614      	mov	r4, r2
 8024322:	f800 4f01 	strb.w	r4, [r0, #1]!
 8024326:	3201      	adds	r2, #1
 8024328:	68d9      	ldr	r1, [r3, #12]
 802432a:	4291      	cmp	r1, r2
 802432c:	d8f9      	bhi.n	8024322 <mpool_alloc+0x6a>
 802432e:	6818      	ldr	r0, [r3, #0]
}
 8024330:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((pool->msize - pool->usize) > asize)
 8024332:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
 8024336:	1a9b      	subs	r3, r3, r2
 8024338:	4283      	cmp	r3, r0
            LEAF_internalErrorCallback(LEAFMempoolFragmentation);
 802433a:	bf8c      	ite	hi
 802433c:	2001      	movhi	r0, #1
            LEAF_internalErrorCallback(LEAFMempoolOverrun);
 802433e:	2000      	movls	r0, #0
 8024340:	f002 fdf4 	bl	8026f2c <LEAF_internalErrorCallback>
        return NULL;
 8024344:	2000      	movs	r0, #0
}
 8024346:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 8024348:	680a      	ldr	r2, [r1, #0]
        offset += leaf.header_size + node_to_alloc->size;
 802434a:	4405      	add	r5, r0
                               node_to_alloc->prev,
 802434c:	f8d3 e008 	ldr.w	lr, [r3, #8]
        new_node = create_node(&pool->mpool[offset],
 8024350:	1a3f      	subs	r7, r7, r0
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 8024352:	eba3 0c02 	sub.w	ip, r3, r2
        offset += leaf.header_size + node_to_alloc->size;
 8024356:	4465      	add	r5, ip
        new_node = create_node(&pool->mpool[offset],
 8024358:	eb02 0c05 	add.w	ip, r2, r5
    node->pool = block_location + leaf.header_size;
 802435c:	4460      	add	r0, ip
 802435e:	5150      	str	r0, [r2, r5]
    node->size = size;
 8024360:	f8cc 700c 	str.w	r7, [ip, #12]
    node->prev = prev;
 8024364:	e9cc 4e01 	strd	r4, lr, [ip, #4]
 8024368:	e7bd      	b.n	80242e6 <mpool_alloc+0x2e>
 802436a:	bf00      	nop
 802436c:	200194e8 	.word	0x200194e8

08024370 <mpool_calloc>:
{
 8024370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pool->head == NULL)
 8024372:	68cb      	ldr	r3, [r1, #12]
 8024374:	2b00      	cmp	r3, #0
 8024376:	d035      	beq.n	80243e4 <mpool_calloc+0x74>
    return (size + (MPOOL_ALIGN_SIZE - 1)) & ~(MPOOL_ALIGN_SIZE - 1);
 8024378:	1dc5      	adds	r5, r0, #7
 802437a:	f025 0507 	bic.w	r5, r5, #7
    while (node_to_alloc->size < size_to_alloc)
 802437e:	e002      	b.n	8024386 <mpool_calloc+0x16>
        if (node_to_alloc == NULL)
 8024380:	4623      	mov	r3, r4
 8024382:	2c00      	cmp	r4, #0
 8024384:	d02e      	beq.n	80243e4 <mpool_calloc+0x74>
    while (node_to_alloc->size < size_to_alloc)
 8024386:	68da      	ldr	r2, [r3, #12]
 8024388:	685c      	ldr	r4, [r3, #4]
 802438a:	42aa      	cmp	r2, r5
 802438c:	d3f8      	bcc.n	8024380 <mpool_calloc+0x10>
    if (leftover > leaf.header_size)
 802438e:	4f23      	ldr	r7, [pc, #140]	; (802441c <mpool_calloc+0xac>)
    size_t leftover = node_to_alloc->size - size_to_alloc;
 8024390:	1b56      	subs	r6, r2, r5
    node_to_alloc->size = size_to_alloc;
 8024392:	60dd      	str	r5, [r3, #12]
    if (leftover > leaf.header_size)
 8024394:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8024396:	42b0      	cmp	r0, r6
 8024398:	d32f      	bcc.n	80243fa <mpool_calloc+0x8a>
        node_to_alloc->size += leftover;
 802439a:	46a4      	mov	ip, r4
 802439c:	60da      	str	r2, [r3, #12]
    if (pool->head == node_to_alloc)
 802439e:	68ca      	ldr	r2, [r1, #12]
 80243a0:	429a      	cmp	r2, r3
        pool->head = new_node;
 80243a2:	bf08      	it	eq
 80243a4:	f8c1 c00c 	streq.w	ip, [r1, #12]
 80243a8:	e9d3 0201 	ldrd	r0, r2, [r3, #4]
    if (node->next != NULL)
 80243ac:	b108      	cbz	r0, 80243b2 <mpool_calloc+0x42>
        node->next->prev = node->prev;
 80243ae:	6082      	str	r2, [r0, #8]
 80243b0:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
 80243b2:	b10a      	cbz	r2, 80243b8 <mpool_calloc+0x48>
        node->prev->next = node->next;
 80243b4:	6858      	ldr	r0, [r3, #4]
 80243b6:	6050      	str	r0, [r2, #4]
    node->next = NULL;
 80243b8:	2200      	movs	r2, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
 80243ba:	68dc      	ldr	r4, [r3, #12]
    node->prev = NULL;
 80243bc:	e9c3 2201 	strd	r2, r2, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
 80243c0:	6848      	ldr	r0, [r1, #4]
 80243c2:	6afd      	ldr	r5, [r7, #44]	; 0x2c
 80243c4:	4428      	add	r0, r5
 80243c6:	4420      	add	r0, r4
 80243c8:	6048      	str	r0, [r1, #4]
    for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 80243ca:	68d9      	ldr	r1, [r3, #12]
    char* new_pool = (char*)node_to_alloc->pool;
 80243cc:	6818      	ldr	r0, [r3, #0]
    for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 80243ce:	b141      	cbz	r1, 80243e2 <mpool_calloc+0x72>
 80243d0:	3801      	subs	r0, #1
 80243d2:	4614      	mov	r4, r2
 80243d4:	f800 4f01 	strb.w	r4, [r0, #1]!
 80243d8:	3201      	adds	r2, #1
 80243da:	68d9      	ldr	r1, [r3, #12]
 80243dc:	4291      	cmp	r1, r2
 80243de:	d8f9      	bhi.n	80243d4 <mpool_calloc+0x64>
 80243e0:	6818      	ldr	r0, [r3, #0]
}
 80243e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((pool->msize - pool->usize) > asize)
 80243e4:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
 80243e8:	1a9b      	subs	r3, r3, r2
 80243ea:	4283      	cmp	r3, r0
            LEAF_internalErrorCallback(LEAFMempoolFragmentation);
 80243ec:	bf8c      	ite	hi
 80243ee:	2001      	movhi	r0, #1
            LEAF_internalErrorCallback(LEAFMempoolOverrun);
 80243f0:	2000      	movls	r0, #0
 80243f2:	f002 fd9b 	bl	8026f2c <LEAF_internalErrorCallback>
        return NULL;
 80243f6:	2000      	movs	r0, #0
}
 80243f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 80243fa:	680a      	ldr	r2, [r1, #0]
        offset += leaf.header_size + node_to_alloc->size;
 80243fc:	4405      	add	r5, r0
                               node_to_alloc->prev,
 80243fe:	f8d3 e008 	ldr.w	lr, [r3, #8]
        new_node = create_node(&pool->mpool[offset],
 8024402:	1a36      	subs	r6, r6, r0
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 8024404:	eba3 0c02 	sub.w	ip, r3, r2
        offset += leaf.header_size + node_to_alloc->size;
 8024408:	4465      	add	r5, ip
        new_node = create_node(&pool->mpool[offset],
 802440a:	eb02 0c05 	add.w	ip, r2, r5
    node->pool = block_location + leaf.header_size;
 802440e:	4460      	add	r0, ip
 8024410:	5150      	str	r0, [r2, r5]
    node->size = size;
 8024412:	f8cc 600c 	str.w	r6, [ip, #12]
    node->prev = prev;
 8024416:	e9cc 4e01 	strd	r4, lr, [ip, #4]
 802441a:	e7c0      	b.n	802439e <mpool_calloc+0x2e>
 802441c:	200194e8 	.word	0x200194e8

08024420 <mpool_free>:
{
 8024420:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
 8024424:	4f33      	ldr	r7, [pc, #204]	; (80244f4 <mpool_free+0xd4>)
    pool->usize -= leaf.header_size + freed_node->size;
 8024426:	684a      	ldr	r2, [r1, #4]
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
 8024428:	6afc      	ldr	r4, [r7, #44]	; 0x2c
    mpool_node_t* other_node = pool->head;
 802442a:	68cb      	ldr	r3, [r1, #12]
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
 802442c:	1b00      	subs	r0, r0, r4
    pool->usize -= leaf.header_size + freed_node->size;
 802442e:	1b12      	subs	r2, r2, r4
 8024430:	68c4      	ldr	r4, [r0, #12]
 8024432:	1b12      	subs	r2, r2, r4
 8024434:	604a      	str	r2, [r1, #4]
    while (other_node != NULL)
 8024436:	2b00      	cmp	r3, #0
 8024438:	d03e      	beq.n	80244b8 <mpool_free+0x98>
        if ((long) other_node < (long) pool->mpool ||
 802443a:	680a      	ldr	r2, [r1, #0]
 802443c:	4293      	cmp	r3, r2
 802443e:	db1f      	blt.n	8024480 <mpool_free+0x60>
            (long) other_node >= (((long) pool->mpool) + pool->msize))
 8024440:	688c      	ldr	r4, [r1, #8]
 8024442:	461d      	mov	r5, r3
 8024444:	4422      	add	r2, r4
        if ((long) other_node < (long) pool->mpool ||
 8024446:	429a      	cmp	r2, r3
 8024448:	d91a      	bls.n	8024480 <mpool_free+0x60>
    node->next = NULL;
 802444a:	f04f 0c00 	mov.w	ip, #0
        if (((long) freed_node) + (leaf.header_size + freed_node->size) == (long) other_node)
 802444e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8024450:	68c4      	ldr	r4, [r0, #12]
        next_node = other_node->next;
 8024452:	685e      	ldr	r6, [r3, #4]
        if (((long) freed_node) + (leaf.header_size + freed_node->size) == (long) other_node)
 8024454:	eb02 0e04 	add.w	lr, r2, r4
 8024458:	f8d3 800c 	ldr.w	r8, [r3, #12]
 802445c:	eb0e 0900 	add.w	r9, lr, r0
 8024460:	45a9      	cmp	r9, r5
 8024462:	d030      	beq.n	80244c6 <mpool_free+0xa6>
        else if (((long) other_node) + (leaf.header_size + other_node->size) == (long) freed_node)
 8024464:	442a      	add	r2, r5
 8024466:	4442      	add	r2, r8
 8024468:	4290      	cmp	r0, r2
 802446a:	d00e      	beq.n	802448a <mpool_free+0x6a>
    while (other_node != NULL)
 802446c:	b31e      	cbz	r6, 80244b6 <mpool_free+0x96>
        if ((long) other_node < (long) pool->mpool ||
 802446e:	680b      	ldr	r3, [r1, #0]
 8024470:	42b3      	cmp	r3, r6
 8024472:	dc05      	bgt.n	8024480 <mpool_free+0x60>
            (long) other_node >= (((long) pool->mpool) + pool->msize))
 8024474:	688c      	ldr	r4, [r1, #8]
 8024476:	4635      	mov	r5, r6
 8024478:	441c      	add	r4, r3
 802447a:	4633      	mov	r3, r6
        if ((long) other_node < (long) pool->mpool ||
 802447c:	42b4      	cmp	r4, r6
 802447e:	d8e6      	bhi.n	802444e <mpool_free+0x2e>
            LEAF_internalErrorCallback(LEAFInvalidFree);
 8024480:	2002      	movs	r0, #2
}
 8024482:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            LEAF_internalErrorCallback(LEAFInvalidFree);
 8024486:	f002 bd51 	b.w	8026f2c <LEAF_internalErrorCallback>
            other_node->size += leaf.header_size + freed_node->size;
 802448a:	eb0e 0408 	add.w	r4, lr, r8
 802448e:	60dc      	str	r4, [r3, #12]
            if (other_node != pool->head)
 8024490:	68ca      	ldr	r2, [r1, #12]
 8024492:	429a      	cmp	r2, r3
 8024494:	d02b      	beq.n	80244ee <mpool_free+0xce>
 8024496:	689a      	ldr	r2, [r3, #8]
    if (node->next != NULL)
 8024498:	b10e      	cbz	r6, 802449e <mpool_free+0x7e>
        node->next->prev = node->prev;
 802449a:	60b2      	str	r2, [r6, #8]
 802449c:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
 802449e:	b10a      	cbz	r2, 80244a4 <mpool_free+0x84>
        node->prev->next = node->next;
 80244a0:	6858      	ldr	r0, [r3, #4]
 80244a2:	6050      	str	r0, [r2, #4]
    node->next = NULL;
 80244a4:	f8c3 c004 	str.w	ip, [r3, #4]
 80244a8:	4618      	mov	r0, r3
    node->prev = NULL;
 80244aa:	f8c3 c008 	str.w	ip, [r3, #8]
                other_node->next = pool->head;
 80244ae:	68ca      	ldr	r2, [r1, #12]
 80244b0:	605a      	str	r2, [r3, #4]
    while (other_node != NULL)
 80244b2:	2e00      	cmp	r6, #0
 80244b4:	d1db      	bne.n	802446e <mpool_free+0x4e>
 80244b6:	68cb      	ldr	r3, [r1, #12]
    freed_node->next = pool->head;
 80244b8:	6043      	str	r3, [r0, #4]
    if (pool->head != NULL) pool->head->prev = freed_node;
 80244ba:	68cb      	ldr	r3, [r1, #12]
 80244bc:	b103      	cbz	r3, 80244c0 <mpool_free+0xa0>
 80244be:	6098      	str	r0, [r3, #8]
    pool->head = freed_node;
 80244c0:	60c8      	str	r0, [r1, #12]
}
 80244c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            freed_node->size += leaf.header_size + other_node->size;
 80244c6:	4444      	add	r4, r8
 80244c8:	4422      	add	r2, r4
 80244ca:	60c2      	str	r2, [r0, #12]
            if (other_node == pool->head) pool->head = pool->head->next;
 80244cc:	68ca      	ldr	r2, [r1, #12]
 80244ce:	429a      	cmp	r2, r3
 80244d0:	d00a      	beq.n	80244e8 <mpool_free+0xc8>
 80244d2:	e9d3 4201 	ldrd	r4, r2, [r3, #4]
    if (node->next != NULL)
 80244d6:	b10c      	cbz	r4, 80244dc <mpool_free+0xbc>
        node->next->prev = node->prev;
 80244d8:	60a2      	str	r2, [r4, #8]
 80244da:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
 80244dc:	b10a      	cbz	r2, 80244e2 <mpool_free+0xc2>
        node->prev->next = node->next;
 80244de:	685c      	ldr	r4, [r3, #4]
 80244e0:	6054      	str	r4, [r2, #4]
    node->prev = NULL;
 80244e2:	e9c3 cc01 	strd	ip, ip, [r3, #4]
 80244e6:	e7c1      	b.n	802446c <mpool_free+0x4c>
            if (other_node == pool->head) pool->head = pool->head->next;
 80244e8:	685a      	ldr	r2, [r3, #4]
 80244ea:	60ca      	str	r2, [r1, #12]
 80244ec:	e7f1      	b.n	80244d2 <mpool_free+0xb2>
                pool->head = pool->head->next;
 80244ee:	4618      	mov	r0, r3
 80244f0:	60ce      	str	r6, [r1, #12]
 80244f2:	e7bb      	b.n	802446c <mpool_free+0x4c>
 80244f4:	200194e8 	.word	0x200194e8

080244f8 <tMempool_init>:
}

void tMempool_init(tMempool* const mp, char* memory, size_t size)
{
 80244f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    tMempool_freeFromPool(mp, &leaf.mempool);
}

void    tMempool_initToPool     (tMempool* const mp, char* memory, size_t size, tMempool* const mem)
{
    _tMempool* mm = *mem;
 80244fc:	4e3d      	ldr	r6, [pc, #244]	; (80245f4 <tMempool_init+0xfc>)
{
 80244fe:	b082      	sub	sp, #8
 8024500:	4607      	mov	r7, r0
 8024502:	460d      	mov	r5, r1
    _tMempool* mm = *mem;
 8024504:	f8d6 c018 	ldr.w	ip, [r6, #24]
    if (pool->head == NULL)
 8024508:	f8dc 300c 	ldr.w	r3, [ip, #12]
 802450c:	b91b      	cbnz	r3, 8024516 <tMempool_init+0x1e>
 802450e:	e04c      	b.n	80245aa <tMempool_init+0xb2>
        if (node_to_alloc == NULL)
 8024510:	4623      	mov	r3, r4
 8024512:	2c00      	cmp	r4, #0
 8024514:	d049      	beq.n	80245aa <tMempool_init+0xb2>
    while (node_to_alloc->size < size_to_alloc)
 8024516:	68d8      	ldr	r0, [r3, #12]
 8024518:	685c      	ldr	r4, [r3, #4]
 802451a:	280f      	cmp	r0, #15
 802451c:	d9f8      	bls.n	8024510 <tMempool_init+0x18>
    node_to_alloc->size = size_to_alloc;
 802451e:	2110      	movs	r1, #16
    size_t leftover = node_to_alloc->size - size_to_alloc;
 8024520:	f1a0 0e10 	sub.w	lr, r0, #16
    node_to_alloc->size = size_to_alloc;
 8024524:	60d9      	str	r1, [r3, #12]
    if (leftover > leaf.header_size)
 8024526:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 8024528:	458e      	cmp	lr, r1
 802452a:	d84d      	bhi.n	80245c8 <tMempool_init+0xd0>
        node_to_alloc->size += leftover;
 802452c:	46a6      	mov	lr, r4
 802452e:	60d8      	str	r0, [r3, #12]
    if (pool->head == node_to_alloc)
 8024530:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8024534:	428b      	cmp	r3, r1
        pool->head = new_node;
 8024536:	bf08      	it	eq
 8024538:	f8cc e00c 	streq.w	lr, [ip, #12]
 802453c:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
    if (node->next != NULL)
 8024540:	b108      	cbz	r0, 8024546 <tMempool_init+0x4e>
        node->next->prev = node->prev;
 8024542:	6081      	str	r1, [r0, #8]
 8024544:	6899      	ldr	r1, [r3, #8]
    if (node->prev != NULL)
 8024546:	b109      	cbz	r1, 802454c <tMempool_init+0x54>
        node->prev->next = node->next;
 8024548:	6858      	ldr	r0, [r3, #4]
 802454a:	6048      	str	r0, [r1, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
 802454c:	68d9      	ldr	r1, [r3, #12]
    node->next = NULL;
 802454e:	2000      	movs	r0, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
 8024550:	9101      	str	r1, [sp, #4]
    node->prev = NULL;
 8024552:	e9c3 0001 	strd	r0, r0, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
 8024556:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 8024558:	f8dc 4004 	ldr.w	r4, [ip, #4]
 802455c:	440c      	add	r4, r1
 802455e:	4621      	mov	r1, r4
 8024560:	9c01      	ldr	r4, [sp, #4]
 8024562:	440c      	add	r4, r1
 8024564:	f8cc 4004 	str.w	r4, [ip, #4]
    if (leaf.clearOnAllocation > 0)
 8024568:	6971      	ldr	r1, [r6, #20]
 802456a:	4281      	cmp	r1, r0
 802456c:	dd0a      	ble.n	8024584 <tMempool_init+0x8c>
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 802456e:	68dc      	ldr	r4, [r3, #12]
        char* new_pool = (char*)node_to_alloc->pool;
 8024570:	6819      	ldr	r1, [r3, #0]
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 8024572:	b144      	cbz	r4, 8024586 <tMempool_init+0x8e>
 8024574:	3901      	subs	r1, #1
 8024576:	4684      	mov	ip, r0
 8024578:	f801 cf01 	strb.w	ip, [r1, #1]!
 802457c:	3001      	adds	r0, #1
 802457e:	68dc      	ldr	r4, [r3, #12]
 8024580:	42a0      	cmp	r0, r4
 8024582:	d3f9      	bcc.n	8024578 <tMempool_init+0x80>
 8024584:	6819      	ldr	r1, [r3, #0]
    pool->usize  = 0;
 8024586:	2000      	movs	r0, #0
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 8024588:	2310      	movs	r3, #16
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
 802458a:	6039      	str	r1, [r7, #0]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 802458c:	62f3      	str	r3, [r6, #44]	; 0x2c
    pool->mpool = (char*)memory;
 802458e:	600d      	str	r5, [r1, #0]
    pool->usize  = 0;
 8024590:	e9c1 0201 	strd	r0, r2, [r1, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
 8024594:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    node->next = next;
 8024596:	6068      	str	r0, [r5, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
 8024598:	1ad2      	subs	r2, r2, r3
    node->pool = block_location + leaf.header_size;
 802459a:	442b      	add	r3, r5
    node->size = size;
 802459c:	e9c5 0202 	strd	r0, r2, [r5, #8]
    node->pool = block_location + leaf.header_size;
 80245a0:	602b      	str	r3, [r5, #0]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
 80245a2:	60cd      	str	r5, [r1, #12]
}
 80245a4:	b002      	add	sp, #8
 80245a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if ((pool->msize - pool->usize) > asize)
 80245aa:	e9dc 2301 	ldrd	r2, r3, [ip, #4]
 80245ae:	1a9b      	subs	r3, r3, r2
 80245b0:	2b10      	cmp	r3, #16
            LEAF_internalErrorCallback(LEAFMempoolFragmentation);
 80245b2:	bf8c      	ite	hi
 80245b4:	2001      	movhi	r0, #1
            LEAF_internalErrorCallback(LEAFMempoolOverrun);
 80245b6:	2000      	movls	r0, #0
 80245b8:	f002 fcb8 	bl	8026f2c <LEAF_internalErrorCallback>
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
 80245bc:	2300      	movs	r3, #0
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 80245be:	2210      	movs	r2, #16
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
 80245c0:	603b      	str	r3, [r7, #0]
    pool->mpool = (char*)memory;
 80245c2:	601d      	str	r5, [r3, #0]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 80245c4:	62f2      	str	r2, [r6, #44]	; 0x2c
 80245c6:	deff      	udf	#255	; 0xff
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 80245c8:	f8dc 9000 	ldr.w	r9, [ip]
        new_node = create_node(&pool->mpool[offset],
 80245cc:	ebae 0001 	sub.w	r0, lr, r1
        offset += leaf.header_size + node_to_alloc->size;
 80245d0:	f101 0810 	add.w	r8, r1, #16
                               node_to_alloc->prev,
 80245d4:	f8d3 a008 	ldr.w	sl, [r3, #8]
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 80245d8:	eba3 0e09 	sub.w	lr, r3, r9
        offset += leaf.header_size + node_to_alloc->size;
 80245dc:	44f0      	add	r8, lr
        new_node = create_node(&pool->mpool[offset],
 80245de:	eb09 0e08 	add.w	lr, r9, r8
    node->pool = block_location + leaf.header_size;
 80245e2:	4471      	add	r1, lr
 80245e4:	f849 1008 	str.w	r1, [r9, r8]
    node->size = size;
 80245e8:	f8ce 000c 	str.w	r0, [lr, #12]
    node->prev = prev;
 80245ec:	e9ce 4a01 	strd	r4, sl, [lr, #4]
 80245f0:	e79e      	b.n	8024530 <tMempool_init+0x38>
 80245f2:	bf00      	nop
 80245f4:	200194e8 	.word	0x200194e8

080245f8 <tSimplePoly_initToPool>:
{
    tSimplePoly_initToPool(polyh, maxNumVoices, &leaf.mempool);
}

void    tSimplePoly_initToPool            (tSimplePoly* const polyh, int maxNumVoices, tMempool* const mp)
{
 80245f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
 80245fc:	6816      	ldr	r6, [r2, #0]
{
 80245fe:	4680      	mov	r8, r0
 8024600:	460c      	mov	r4, r1
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
 8024602:	f240 401c 	movw	r0, #1052	; 0x41c
 8024606:	4631      	mov	r1, r6
{
 8024608:	4617      	mov	r7, r2
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
 802460a:	f7ff fe55 	bl	80242b8 <mpool_alloc>
 802460e:	4605      	mov	r5, r0
    poly->maxNumVoices = maxNumVoices;

    for (int i = 0; i < 128; i++)
    {
        poly->notes[i][0] = -1;
        poly->notes[i][1] = 0;
 8024610:	2100      	movs	r1, #0
        poly->notes[i][0] = -1;
 8024612:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8024616:	462b      	mov	r3, r5
 8024618:	f505 6280 	add.w	r2, r5, #1024	; 0x400
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
 802461c:	f8c8 5000 	str.w	r5, [r8]
    poly->mempool = m;
 8024620:	602e      	str	r6, [r5, #0]
    poly->maxNumVoices = maxNumVoices;
 8024622:	e9c5 4402 	strd	r4, r4, [r5, #8]
        poly->notes[i][1] = 0;
 8024626:	e9c3 0107 	strd	r0, r1, [r3, #28]
 802462a:	3308      	adds	r3, #8
    for (int i = 0; i < 128; i++)
 802462c:	4293      	cmp	r3, r2
 802462e:	d1fa      	bne.n	8024626 <tSimplePoly_initToPool+0x2e>
    }
    poly->stealing_on = 1;
 8024630:	2301      	movs	r3, #1
    poly->recover_stolen = 1;
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
 8024632:	00a0      	lsls	r0, r4, #2
 8024634:	4631      	mov	r1, r6
    poly->recover_stolen = 1;
 8024636:	e9c5 3305 	strd	r3, r3, [r5, #20]
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
 802463a:	f7ff fe3d 	bl	80242b8 <mpool_alloc>

    for (int i = 0; i < poly->maxNumVoices; ++i)
 802463e:	68eb      	ldr	r3, [r5, #12]
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
 8024640:	4680      	mov	r8, r0
 8024642:	6128      	str	r0, [r5, #16]
    for (int i = 0; i < poly->maxNumVoices; ++i)
 8024644:	2b00      	cmp	r3, #0
 8024646:	dd14      	ble.n	8024672 <tSimplePoly_initToPool+0x7a>
 8024648:	2400      	movs	r4, #0
    {
        poly->voices[i] = (int*) mpool_alloc(sizeof(int) * 3, m);
        poly->voices[i][0] = -1;
 802464a:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 802464e:	e001      	b.n	8024654 <tSimplePoly_initToPool+0x5c>
 8024650:	f8d5 8010 	ldr.w	r8, [r5, #16]
        poly->voices[i] = (int*) mpool_alloc(sizeof(int) * 3, m);
 8024654:	4631      	mov	r1, r6
 8024656:	200c      	movs	r0, #12
 8024658:	f7ff fe2e 	bl	80242b8 <mpool_alloc>
 802465c:	f848 0024 	str.w	r0, [r8, r4, lsl #2]
        poly->voices[i][0] = -1;
 8024660:	692b      	ldr	r3, [r5, #16]
 8024662:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
    for (int i = 0; i < poly->maxNumVoices; ++i)
 8024666:	3401      	adds	r4, #1
        poly->voices[i][0] = -1;
 8024668:	f8c3 9000 	str.w	r9, [r3]
    for (int i = 0; i < poly->maxNumVoices; ++i)
 802466c:	68eb      	ldr	r3, [r5, #12]
 802466e:	42a3      	cmp	r3, r4
 8024670:	dcee      	bgt.n	8024650 <tSimplePoly_initToPool+0x58>
    _tMempool* m = *mp;
 8024672:	683e      	ldr	r6, [r7, #0]
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
 8024674:	f44f 7004 	mov.w	r0, #528	; 0x210
    ns->ordered = 0;
 8024678:	2400      	movs	r4, #0
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
 802467a:	4631      	mov	r1, r6
 802467c:	f7ff fe1c 	bl	80242b8 <mpool_alloc>
    ns->capacity = STACK_SIZE;
 8024680:	2180      	movs	r1, #128	; 0x80
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
 8024682:	4603      	mov	r3, r0
 8024684:	6068      	str	r0, [r5, #4]
 8024686:	f44f 7200 	mov.w	r2, #512	; 0x200
 802468a:	3004      	adds	r0, #4
    ns->capacity = STACK_SIZE;
 802468c:	f8a3 1208 	strh.w	r1, [r3, #520]	; 0x208
 8024690:	21ff      	movs	r1, #255	; 0xff
    ns->mempool = m;
 8024692:	601e      	str	r6, [r3, #0]
    ns->ordered = 0;
 8024694:	f8c3 420c 	str.w	r4, [r3, #524]	; 0x20c
    ns->pos = 0;
 8024698:	f8c3 4204 	str.w	r4, [r3, #516]	; 0x204
    }
    tStack_initToPool(&poly->stack, mp);

}
 802469c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80246a0:	f002 bc9d 	b.w	8026fde <memset>

080246a4 <tSimplePoly_init>:
    tSimplePoly_initToPool(polyh, maxNumVoices, &leaf.mempool);
 80246a4:	4a01      	ldr	r2, [pc, #4]	; (80246ac <tSimplePoly_init+0x8>)
 80246a6:	f7ff bfa7 	b.w	80245f8 <tSimplePoly_initToPool>
 80246aa:	bf00      	nop
 80246ac:	20019500 	.word	0x20019500

080246b0 <tSimplePoly_noteOn>:
    mpool_free((char*)poly->voices, poly->mempool);
    mpool_free((char*)poly, poly->mempool);
}

int tSimplePoly_noteOn(tSimplePoly* const polyh, int note, uint8_t vel)
{
 80246b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tSimplePoly* poly = *polyh;
 80246b4:	6806      	ldr	r6, [r0, #0]
    _tStack* ns = *stack;
 80246b6:	f8d6 c004 	ldr.w	ip, [r6, #4]
    for (int i = 0; i < ns->size; i++)
 80246ba:	f8bc 7206 	ldrh.w	r7, [ip, #518]	; 0x206
 80246be:	b18f      	cbz	r7, 80246e4 <tSimplePoly_noteOn+0x34>
 80246c0:	b28d      	uxth	r5, r1
        if (ns->data[i] == noteVal)    return i;
 80246c2:	f8dc 3004 	ldr.w	r3, [ip, #4]
 80246c6:	429d      	cmp	r5, r3
 80246c8:	f000 809f 	beq.w	802480a <tSimplePoly_noteOn+0x15a>
 80246cc:	f10c 0004 	add.w	r0, ip, #4
    for (int i = 0; i < ns->size; i++)
 80246d0:	2300      	movs	r3, #0
 80246d2:	e004      	b.n	80246de <tSimplePoly_noteOn+0x2e>
        if (ns->data[i] == noteVal)    return i;
 80246d4:	f850 4f04 	ldr.w	r4, [r0, #4]!
 80246d8:	42ac      	cmp	r4, r5
 80246da:	f000 8096 	beq.w	802480a <tSimplePoly_noteOn+0x15a>
    for (int i = 0; i < ns->size; i++)
 80246de:	3301      	adds	r3, #1
 80246e0:	42bb      	cmp	r3, r7
 80246e2:	d1f7      	bne.n	80246d4 <tSimplePoly_noteOn+0x24>
    if (tStack_contains(&poly->stack, note) >= 0) return -1;
    else
    {
        alteredVoice = -1;
        int found = 0;
        for (int i = 0; i < poly->numVoices; i++)
 80246e4:	f8d6 8008 	ldr.w	r8, [r6, #8]
 80246e8:	f1b8 0f00 	cmp.w	r8, #0
 80246ec:	dd29      	ble.n	8024742 <tSimplePoly_noteOn+0x92>
        {
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
 80246ee:	6933      	ldr	r3, [r6, #16]
 80246f0:	f8d3 9000 	ldr.w	r9, [r3]
 80246f4:	f8d9 b000 	ldr.w	fp, [r9]
 80246f8:	f1bb 3fff 	cmp.w	fp, #4294967295	; 0xffffffff
 80246fc:	f000 8089 	beq.w	8024812 <tSimplePoly_noteOn+0x162>
 8024700:	469e      	mov	lr, r3
        for (int i = 0; i < poly->numVoices; i++)
 8024702:	2000      	movs	r0, #0
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
 8024704:	461c      	mov	r4, r3
 8024706:	e005      	b.n	8024714 <tSimplePoly_noteOn+0x64>
 8024708:	f854 3f04 	ldr.w	r3, [r4, #4]!
 802470c:	681d      	ldr	r5, [r3, #0]
 802470e:	3501      	adds	r5, #1
 8024710:	f000 8082 	beq.w	8024818 <tSimplePoly_noteOn+0x168>
        for (int i = 0; i < poly->numVoices; i++)
 8024714:	3001      	adds	r0, #1
 8024716:	4540      	cmp	r0, r8
 8024718:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 802471c:	d1f4      	bne.n	8024708 <tSimplePoly_noteOn+0x58>
        if (!found)
        {
            //second preference is grabbing one that is in release phase but not finished sounding yet
            for (int i = 0 ; i < poly->numVoices; i++)
            {
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
 802471e:	f11b 0f02 	cmn.w	fp, #2
            for (int i = 0 ; i < poly->numVoices; i++)
 8024722:	f04f 0300 	mov.w	r3, #0
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
 8024726:	d107      	bne.n	8024738 <tSimplePoly_noteOn+0x88>
 8024728:	e0b4      	b.n	8024894 <tSimplePoly_noteOn+0x1e4>
 802472a:	f85e 9f04 	ldr.w	r9, [lr, #4]!
 802472e:	f8d9 4000 	ldr.w	r4, [r9]
 8024732:	3402      	adds	r4, #2
 8024734:	f000 80af 	beq.w	8024896 <tSimplePoly_noteOn+0x1e6>
            for (int i = 0 ; i < poly->numVoices; i++)
 8024738:	3301      	adds	r3, #1
 802473a:	4298      	cmp	r0, r3
 802473c:	ea4f 0583 	mov.w	r5, r3, lsl #2
 8024740:	d1f3      	bne.n	802472a <tSimplePoly_noteOn+0x7a>
                    tStack_add(&poly->stack, note);
                    break;
                }
            }
        }
        if ((!found) && (poly->stealing_on)) //steal
 8024742:	6973      	ldr	r3, [r6, #20]
 8024744:	2b00      	cmp	r3, #0
 8024746:	d060      	beq.n	802480a <tSimplePoly_noteOn+0x15a>
        {
            for (int j = tStack_getSize(&poly->stack) - 1; j >= 0; j--)
 8024748:	1e78      	subs	r0, r7, #1
 802474a:	2f00      	cmp	r7, #0
 802474c:	d05f      	beq.n	802480e <tSimplePoly_noteOn+0x15e>
    return ns->data[which];
 802474e:	eb0c 0380 	add.w	r3, ip, r0, lsl #2
            {
                whichNote = tStack_get(&poly->stack, j);
                whichVoice = poly->notes[whichNote][0];
 8024752:	685b      	ldr	r3, [r3, #4]
 8024754:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 8024758:	69db      	ldr	r3, [r3, #28]
                if (whichVoice >= 0)
 802475a:	2b00      	cmp	r3, #0
 802475c:	da0b      	bge.n	8024776 <tSimplePoly_noteOn+0xc6>
 802475e:	eb0c 0787 	add.w	r7, ip, r7, lsl #2
            for (int j = tStack_getSize(&poly->stack) - 1; j >= 0; j--)
 8024762:	f110 30ff 	adds.w	r0, r0, #4294967295	; 0xffffffff
 8024766:	d352      	bcc.n	802480e <tSimplePoly_noteOn+0x15e>
                whichVoice = poly->notes[whichNote][0];
 8024768:	f857 3d04 	ldr.w	r3, [r7, #-4]!
 802476c:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 8024770:	69db      	ldr	r3, [r3, #28]
                if (whichVoice >= 0)
 8024772:	2b00      	cmp	r3, #0
 8024774:	dbf5      	blt.n	8024762 <tSimplePoly_noteOn+0xb2>
                {
                    oldNote = poly->voices[whichVoice][0];
 8024776:	6930      	ldr	r0, [r6, #16]
                    poly->voices[whichVoice][0] = note;
                    poly->voices[whichVoice][1] = vel;
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
                    poly->notes[note][0] = whichVoice;
 8024778:	eb06 05c1 	add.w	r5, r6, r1, lsl #3
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
 802477c:	f06f 0702 	mvn.w	r7, #2
                    oldNote = poly->voices[whichVoice][0];
 8024780:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 8024784:	6820      	ldr	r0, [r4, #0]
                    poly->voices[whichVoice][0] = note;
 8024786:	6021      	str	r1, [r4, #0]
                    poly->voices[whichVoice][1] = vel;
 8024788:	6934      	ldr	r4, [r6, #16]
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
 802478a:	eb06 00c0 	add.w	r0, r6, r0, lsl #3
                    poly->voices[whichVoice][1] = vel;
 802478e:	f854 c023 	ldr.w	ip, [r4, r3, lsl #2]
 8024792:	f8cc 2004 	str.w	r2, [ip, #4]
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
 8024796:	61c7      	str	r7, [r0, #28]
 8024798:	b28f      	uxth	r7, r1
                    poly->notes[note][0] = whichVoice;
 802479a:	61eb      	str	r3, [r5, #28]
                    poly->notes[note][1] = vel;
 802479c:	622a      	str	r2, [r5, #32]

                    poly->voices[whichVoice][2] = note;
 802479e:	6932      	ldr	r2, [r6, #16]
 80247a0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80247a4:	6091      	str	r1, [r2, #8]
    _tStack* ns = *stack;
 80247a6:	6871      	ldr	r1, [r6, #4]
    if (ns->ordered)
 80247a8:	f8d1 420c 	ldr.w	r4, [r1, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
 80247ac:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
    if (ns->ordered)
 80247b0:	b1a4      	cbz	r4, 80247dc <tSimplePoly_noteOn+0x12c>
        for (j = 0; j < ns->size; j++)
 80247b2:	f1bc 0f00 	cmp.w	ip, #0
 80247b6:	f000 80a3 	beq.w	8024900 <tSimplePoly_noteOn+0x250>
 80247ba:	2200      	movs	r2, #0
 80247bc:	eb01 0582 	add.w	r5, r1, r2, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80247c0:	1c50      	adds	r0, r2, #1
            if (noteVal > ns->data[j])
 80247c2:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80247c4:	4604      	mov	r4, r0
            if (noteVal > ns->data[j])
 80247c6:	42be      	cmp	r6, r7
 80247c8:	da04      	bge.n	80247d4 <tSimplePoly_noteOn+0x124>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80247ca:	68aa      	ldr	r2, [r5, #8]
 80247cc:	1c55      	adds	r5, r2, #1
 80247ce:	d005      	beq.n	80247dc <tSimplePoly_noteOn+0x12c>
 80247d0:	42ba      	cmp	r2, r7
 80247d2:	dc03      	bgt.n	80247dc <tSimplePoly_noteOn+0x12c>
        for (j = 0; j < ns->size; j++)
 80247d4:	b2c2      	uxtb	r2, r0
 80247d6:	4562      	cmp	r2, ip
 80247d8:	d3f0      	bcc.n	80247bc <tSimplePoly_noteOn+0x10c>
    int whereToInsert = 0;
 80247da:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
 80247dc:	fa5f f28c 	uxtb.w	r2, ip
 80247e0:	4294      	cmp	r4, r2
 80247e2:	da08      	bge.n	80247f6 <tSimplePoly_noteOn+0x146>
 80247e4:	1e56      	subs	r6, r2, #1
 80247e6:	eb01 0082 	add.w	r0, r1, r2, lsl #2
        ns->data[j] = ns->data[(j - 1)];
 80247ea:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
 80247ee:	b2f2      	uxtb	r2, r6
        ns->data[j] = ns->data[(j - 1)];
 80247f0:	6045      	str	r5, [r0, #4]
    for (j = ns->size; j > whereToInsert; j--)
 80247f2:	42a2      	cmp	r2, r4
 80247f4:	dcf6      	bgt.n	80247e4 <tSimplePoly_noteOn+0x134>
    ns->data[whereToInsert] = noteVal;
 80247f6:	eb01 0484 	add.w	r4, r1, r4, lsl #2
    ns->size++;
 80247fa:	f10c 0c01 	add.w	ip, ip, #1
 80247fe:	4618      	mov	r0, r3
    ns->data[whereToInsert] = noteVal;
 8024800:	6067      	str	r7, [r4, #4]
    ns->size++;
 8024802:	f8a1 c206 	strh.w	ip, [r1, #518]	; 0x206
                }
            }
        }
        return alteredVoice;
    }
}
 8024806:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (tStack_contains(&poly->stack, note) >= 0) return -1;
 802480a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 802480e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for (int i = 0; i < poly->numVoices; i++)
 8024812:	2000      	movs	r0, #0
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
 8024814:	464b      	mov	r3, r9
 8024816:	4682      	mov	sl, r0
                poly->voices[i][0] = note;
 8024818:	6019      	str	r1, [r3, #0]
                poly->notes[note][0] = i;
 802481a:	eb06 04c1 	add.w	r4, r6, r1, lsl #3
                poly->voices[i][1] = vel;
 802481e:	6935      	ldr	r5, [r6, #16]
 8024820:	b28f      	uxth	r7, r1
 8024822:	f855 500a 	ldr.w	r5, [r5, sl]
 8024826:	606a      	str	r2, [r5, #4]
                poly->notes[note][0] = i;
 8024828:	61e0      	str	r0, [r4, #28]
                poly->notes[note][1] = vel;
 802482a:	6222      	str	r2, [r4, #32]
                poly->voices[i][2] = note; // voices[i][2] is the output midi note, (avoiding the -1 when a voice is inactive)
 802482c:	6933      	ldr	r3, [r6, #16]
 802482e:	f853 300a 	ldr.w	r3, [r3, sl]
 8024832:	6099      	str	r1, [r3, #8]
    _tStack* ns = *stack;
 8024834:	6872      	ldr	r2, [r6, #4]
    if (ns->ordered)
 8024836:	f8d2 420c 	ldr.w	r4, [r2, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
 802483a:	f8b2 c206 	ldrh.w	ip, [r2, #518]	; 0x206
    if (ns->ordered)
 802483e:	b19c      	cbz	r4, 8024868 <tSimplePoly_noteOn+0x1b8>
        for (j = 0; j < ns->size; j++)
 8024840:	f1bc 0f00 	cmp.w	ip, #0
 8024844:	d05e      	beq.n	8024904 <tSimplePoly_noteOn+0x254>
 8024846:	2300      	movs	r3, #0
 8024848:	eb02 0583 	add.w	r5, r2, r3, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 802484c:	1c59      	adds	r1, r3, #1
            if (noteVal > ns->data[j])
 802484e:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 8024850:	460c      	mov	r4, r1
            if (noteVal > ns->data[j])
 8024852:	42be      	cmp	r6, r7
 8024854:	da04      	bge.n	8024860 <tSimplePoly_noteOn+0x1b0>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 8024856:	68ab      	ldr	r3, [r5, #8]
 8024858:	1c5d      	adds	r5, r3, #1
 802485a:	d005      	beq.n	8024868 <tSimplePoly_noteOn+0x1b8>
 802485c:	42bb      	cmp	r3, r7
 802485e:	dc03      	bgt.n	8024868 <tSimplePoly_noteOn+0x1b8>
        for (j = 0; j < ns->size; j++)
 8024860:	b2cb      	uxtb	r3, r1
 8024862:	459c      	cmp	ip, r3
 8024864:	d8f0      	bhi.n	8024848 <tSimplePoly_noteOn+0x198>
    int whereToInsert = 0;
 8024866:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
 8024868:	fa5f f38c 	uxtb.w	r3, ip
 802486c:	42a3      	cmp	r3, r4
 802486e:	dd08      	ble.n	8024882 <tSimplePoly_noteOn+0x1d2>
 8024870:	1e5e      	subs	r6, r3, #1
 8024872:	eb02 0183 	add.w	r1, r2, r3, lsl #2
        ns->data[j] = ns->data[(j - 1)];
 8024876:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
 802487a:	b2f3      	uxtb	r3, r6
        ns->data[j] = ns->data[(j - 1)];
 802487c:	604d      	str	r5, [r1, #4]
    for (j = ns->size; j > whereToInsert; j--)
 802487e:	42a3      	cmp	r3, r4
 8024880:	dcf6      	bgt.n	8024870 <tSimplePoly_noteOn+0x1c0>
    ns->data[whereToInsert] = noteVal;
 8024882:	eb02 0484 	add.w	r4, r2, r4, lsl #2
    ns->size++;
 8024886:	f10c 0c01 	add.w	ip, ip, #1
    ns->data[whereToInsert] = noteVal;
 802488a:	6067      	str	r7, [r4, #4]
    ns->size++;
 802488c:	f8a2 c206 	strh.w	ip, [r2, #518]	; 0x206
}
 8024890:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
 8024894:	461d      	mov	r5, r3
                    poly->voices[i][0] = note;
 8024896:	f8c9 1000 	str.w	r1, [r9]
                    poly->notes[note][0] = i;
 802489a:	eb06 04c1 	add.w	r4, r6, r1, lsl #3
                    poly->voices[i][1] = vel;
 802489e:	6937      	ldr	r7, [r6, #16]
 80248a0:	597f      	ldr	r7, [r7, r5]
 80248a2:	607a      	str	r2, [r7, #4]
 80248a4:	b28f      	uxth	r7, r1
                    poly->notes[note][0] = i;
 80248a6:	61e3      	str	r3, [r4, #28]
                    poly->notes[note][1] = vel;
 80248a8:	6222      	str	r2, [r4, #32]
                    poly->voices[i][2] = note; // voices[i][2] is the output midi note, (avoiding the -1 when a voice is inactive)
 80248aa:	6932      	ldr	r2, [r6, #16]
 80248ac:	5952      	ldr	r2, [r2, r5]
 80248ae:	6091      	str	r1, [r2, #8]
    _tStack* ns = *stack;
 80248b0:	6871      	ldr	r1, [r6, #4]
    if (ns->ordered)
 80248b2:	f8d1 420c 	ldr.w	r4, [r1, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
 80248b6:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
    if (ns->ordered)
 80248ba:	b19c      	cbz	r4, 80248e4 <tSimplePoly_noteOn+0x234>
        for (j = 0; j < ns->size; j++)
 80248bc:	f1bc 0f00 	cmp.w	ip, #0
 80248c0:	d01e      	beq.n	8024900 <tSimplePoly_noteOn+0x250>
 80248c2:	2200      	movs	r2, #0
 80248c4:	eb01 0582 	add.w	r5, r1, r2, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80248c8:	1c50      	adds	r0, r2, #1
            if (noteVal > ns->data[j])
 80248ca:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80248cc:	4604      	mov	r4, r0
            if (noteVal > ns->data[j])
 80248ce:	42be      	cmp	r6, r7
 80248d0:	da04      	bge.n	80248dc <tSimplePoly_noteOn+0x22c>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80248d2:	68aa      	ldr	r2, [r5, #8]
 80248d4:	1c56      	adds	r6, r2, #1
 80248d6:	d005      	beq.n	80248e4 <tSimplePoly_noteOn+0x234>
 80248d8:	42ba      	cmp	r2, r7
 80248da:	dc03      	bgt.n	80248e4 <tSimplePoly_noteOn+0x234>
        for (j = 0; j < ns->size; j++)
 80248dc:	b2c2      	uxtb	r2, r0
 80248de:	4562      	cmp	r2, ip
 80248e0:	d3f0      	bcc.n	80248c4 <tSimplePoly_noteOn+0x214>
    int whereToInsert = 0;
 80248e2:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
 80248e4:	fa5f f28c 	uxtb.w	r2, ip
 80248e8:	4294      	cmp	r4, r2
 80248ea:	da84      	bge.n	80247f6 <tSimplePoly_noteOn+0x146>
 80248ec:	1e56      	subs	r6, r2, #1
 80248ee:	eb01 0082 	add.w	r0, r1, r2, lsl #2
        ns->data[j] = ns->data[(j - 1)];
 80248f2:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
 80248f6:	b2f2      	uxtb	r2, r6
        ns->data[j] = ns->data[(j - 1)];
 80248f8:	6045      	str	r5, [r0, #4]
    for (j = ns->size; j > whereToInsert; j--)
 80248fa:	42a2      	cmp	r2, r4
 80248fc:	dcf6      	bgt.n	80248ec <tSimplePoly_noteOn+0x23c>
 80248fe:	e77a      	b.n	80247f6 <tSimplePoly_noteOn+0x146>
    int whereToInsert = 0;
 8024900:	4664      	mov	r4, ip
 8024902:	e778      	b.n	80247f6 <tSimplePoly_noteOn+0x146>
 8024904:	4664      	mov	r4, ip
 8024906:	e7bc      	b.n	8024882 <tSimplePoly_noteOn+0x1d2>

08024908 <tSimplePoly_noteOff>:



int tSimplePoly_noteOff(tSimplePoly* const polyh, uint8_t note)
{
 8024908:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tSimplePoly* poly = *polyh;
 802490c:	6805      	ldr	r5, [r0, #0]
    _tStack* ns = *stack;
 802490e:	f8d5 c004 	ldr.w	ip, [r5, #4]
    for (int i = 0; i < ns->size; i++)
 8024912:	f8bc 0206 	ldrh.w	r0, [ip, #518]	; 0x206
 8024916:	b178      	cbz	r0, 8024938 <tSimplePoly_noteOff+0x30>
        if (ns->data[i] == noteVal)    return i;
 8024918:	f8dc 3004 	ldr.w	r3, [ip, #4]
 802491c:	428b      	cmp	r3, r1
 802491e:	f000 8092 	beq.w	8024a46 <tSimplePoly_noteOff+0x13e>
 8024922:	f10c 0304 	add.w	r3, ip, #4
    for (int i = 0; i < ns->size; i++)
 8024926:	2600      	movs	r6, #0
 8024928:	e003      	b.n	8024932 <tSimplePoly_noteOff+0x2a>
        if (ns->data[i] == noteVal)    return i;
 802492a:	f853 2f04 	ldr.w	r2, [r3, #4]!
 802492e:	428a      	cmp	r2, r1
 8024930:	d01f      	beq.n	8024972 <tSimplePoly_noteOff+0x6a>
    for (int i = 0; i < ns->size; i++)
 8024932:	3601      	adds	r6, #1
 8024934:	42b0      	cmp	r0, r6
 8024936:	d1f8      	bne.n	802492a <tSimplePoly_noteOff+0x22>
    int16_t noteToTest = -1;

    tStack_remove(&poly->stack, note);
    poly->notes[note][0] = -1;
 8024938:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
 802493c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8024940:	61d8      	str	r0, [r3, #28]

    int deactivatedVoice = -1;
    for (int i = 0; i < poly->maxNumVoices; i++)
 8024942:	68ee      	ldr	r6, [r5, #12]
 8024944:	2e00      	cmp	r6, #0
 8024946:	dd12      	ble.n	802496e <tSimplePoly_noteOff+0x66>
    {
        if (poly->voices[i][0] == note)
 8024948:	692b      	ldr	r3, [r5, #16]
 802494a:	681a      	ldr	r2, [r3, #0]
 802494c:	6814      	ldr	r4, [r2, #0]
 802494e:	42a1      	cmp	r1, r4
 8024950:	d06f      	beq.n	8024a32 <tSimplePoly_noteOff+0x12a>
    for (int i = 0; i < poly->maxNumVoices; i++)
 8024952:	2000      	movs	r0, #0
 8024954:	e004      	b.n	8024960 <tSimplePoly_noteOff+0x58>
        if (poly->voices[i][0] == note)
 8024956:	f853 2f04 	ldr.w	r2, [r3, #4]!
 802495a:	6814      	ldr	r4, [r2, #0]
 802495c:	428c      	cmp	r4, r1
 802495e:	d030      	beq.n	80249c2 <tSimplePoly_noteOff+0xba>
    for (int i = 0; i < poly->maxNumVoices; i++)
 8024960:	3001      	adds	r0, #1
 8024962:	4286      	cmp	r6, r0
 8024964:	ea4f 0780 	mov.w	r7, r0, lsl #2
 8024968:	d1f5      	bne.n	8024956 <tSimplePoly_noteOff+0x4e>
                {
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
                    poly->voices[deactivatedVoice][2] = noteToTest;
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
                    return -1;
 802496a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
                }
            }
        }
    }
    return deactivatedVoice;
}
 802496e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        for (k = 0; k < (ns->size - foundIndex); k++)
 8024972:	eba0 0806 	sub.w	r8, r0, r6
 8024976:	f1b8 0f00 	cmp.w	r8, #0
 802497a:	dd58      	ble.n	8024a2e <tSimplePoly_noteOff+0x126>
            if ((k+foundIndex) >= (ns->capacity - 1))
 802497c:	f8bc e208 	ldrh.w	lr, [ip, #520]	; 0x208
 8024980:	2200      	movs	r2, #0
                    ns->data[k + foundIndex + 1] = -1;
 8024982:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 8024986:	3801      	subs	r0, #1
            if ((k+foundIndex) >= (ns->capacity - 1))
 8024988:	4613      	mov	r3, r2
 802498a:	44ce      	add	lr, r9
 802498c:	e006      	b.n	802499c <tSimplePoly_noteOff+0x94>
        for (k = 0; k < (ns->size - foundIndex); k++)
 802498e:	3201      	adds	r2, #1
                ns->data[k + foundIndex] = -1;
 8024990:	f8c4 9004 	str.w	r9, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
 8024994:	b2d2      	uxtb	r2, r2
 8024996:	4542      	cmp	r2, r8
 8024998:	4613      	mov	r3, r2
 802499a:	da0f      	bge.n	80249bc <tSimplePoly_noteOff+0xb4>
            if ((k+foundIndex) >= (ns->capacity - 1))
 802499c:	4433      	add	r3, r6
 802499e:	4573      	cmp	r3, lr
 80249a0:	eb0c 0483 	add.w	r4, ip, r3, lsl #2
 80249a4:	daf3      	bge.n	802498e <tSimplePoly_noteOff+0x86>
        for (k = 0; k < (ns->size - foundIndex); k++)
 80249a6:	3201      	adds	r2, #1
                if ((k + foundIndex) == (ns->size - 1))
 80249a8:	4283      	cmp	r3, r0
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
 80249aa:	68a7      	ldr	r7, [r4, #8]
        for (k = 0; k < (ns->size - foundIndex); k++)
 80249ac:	b2d2      	uxtb	r2, r2
                    ns->data[k + foundIndex + 1] = -1;
 80249ae:	bf08      	it	eq
 80249b0:	f8c4 9008 	streq.w	r9, [r4, #8]
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
 80249b4:	6067      	str	r7, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
 80249b6:	4542      	cmp	r2, r8
 80249b8:	4613      	mov	r3, r2
 80249ba:	dbef      	blt.n	802499c <tSimplePoly_noteOff+0x94>
        ns->size--;
 80249bc:	f8ac 0206 	strh.w	r0, [ip, #518]	; 0x206
 80249c0:	e7ba      	b.n	8024938 <tSimplePoly_noteOff+0x30>
            poly->voices[i][0] = -1;
 80249c2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
            poly->voices[i][1] = 0;
 80249c6:	2100      	movs	r1, #0
            poly->voices[i][0] = -1;
 80249c8:	6013      	str	r3, [r2, #0]
            poly->voices[i][1] = 0;
 80249ca:	692b      	ldr	r3, [r5, #16]
 80249cc:	59db      	ldr	r3, [r3, r7]
 80249ce:	6059      	str	r1, [r3, #4]
    if (poly->recover_stolen)
 80249d0:	69ab      	ldr	r3, [r5, #24]
 80249d2:	2b00      	cmp	r3, #0
 80249d4:	d0cb      	beq.n	802496e <tSimplePoly_noteOff+0x66>
    _tStack* ns = *stack;
 80249d6:	6869      	ldr	r1, [r5, #4]
    return ns->size;
 80249d8:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 80249dc:	f1bc 0f00 	cmp.w	ip, #0
 80249e0:	d0c5      	beq.n	802496e <tSimplePoly_noteOff+0x66>
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
 80249e2:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
 80249e6:	1cdc      	adds	r4, r3, #3
 80249e8:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
 80249ec:	6852      	ldr	r2, [r2, #4]
 80249ee:	3203      	adds	r2, #3
 80249f0:	d00d      	beq.n	8024a0e <tSimplePoly_noteOff+0x106>
 80249f2:	3104      	adds	r1, #4
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 80249f4:	2200      	movs	r2, #0
 80249f6:	3201      	adds	r2, #1
 80249f8:	4562      	cmp	r2, ip
 80249fa:	d0b8      	beq.n	802496e <tSimplePoly_noteOff+0x66>
                noteToTest = tStack_get(&poly->stack, j);
 80249fc:	f851 3f04 	ldr.w	r3, [r1, #4]!
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
 8024a00:	b21b      	sxth	r3, r3
 8024a02:	1cdc      	adds	r4, r3, #3
 8024a04:	eb05 06c4 	add.w	r6, r5, r4, lsl #3
 8024a08:	6876      	ldr	r6, [r6, #4]
 8024a0a:	3603      	adds	r6, #3
 8024a0c:	d1f3      	bne.n	80249f6 <tSimplePoly_noteOff+0xee>
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
 8024a0e:	692a      	ldr	r2, [r5, #16]
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
 8024a10:	eb05 01c3 	add.w	r1, r5, r3, lsl #3
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
 8024a14:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
 8024a18:	59d2      	ldr	r2, [r2, r7]
 8024a1a:	6013      	str	r3, [r2, #0]
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
 8024a1c:	692a      	ldr	r2, [r5, #16]
 8024a1e:	6a09      	ldr	r1, [r1, #32]
 8024a20:	59d2      	ldr	r2, [r2, r7]
 8024a22:	6051      	str	r1, [r2, #4]
                    poly->voices[deactivatedVoice][2] = noteToTest;
 8024a24:	692a      	ldr	r2, [r5, #16]
 8024a26:	59d2      	ldr	r2, [r2, r7]
 8024a28:	6093      	str	r3, [r2, #8]
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
 8024a2a:	6060      	str	r0, [r4, #4]
 8024a2c:	e79d      	b.n	802496a <tSimplePoly_noteOff+0x62>
 8024a2e:	3801      	subs	r0, #1
 8024a30:	e7c4      	b.n	80249bc <tSimplePoly_noteOff+0xb4>
            poly->voices[i][0] = -1;
 8024a32:	6010      	str	r0, [r2, #0]
            poly->voices[i][1] = 0;
 8024a34:	2700      	movs	r7, #0
 8024a36:	692b      	ldr	r3, [r5, #16]
 8024a38:	681b      	ldr	r3, [r3, #0]
 8024a3a:	605f      	str	r7, [r3, #4]
    if (poly->recover_stolen)
 8024a3c:	69a8      	ldr	r0, [r5, #24]
 8024a3e:	2800      	cmp	r0, #0
 8024a40:	d095      	beq.n	802496e <tSimplePoly_noteOff+0x66>
    for (int i = 0; i < poly->maxNumVoices; i++)
 8024a42:	4638      	mov	r0, r7
 8024a44:	e7c7      	b.n	80249d6 <tSimplePoly_noteOff+0xce>
        if (ns->data[i] == noteVal)    return i;
 8024a46:	4680      	mov	r8, r0
    for (int i = 0; i < ns->size; i++)
 8024a48:	2600      	movs	r6, #0
 8024a4a:	e797      	b.n	802497c <tSimplePoly_noteOff+0x74>

08024a4c <tSimplePoly_deactivateVoice>:


void tSimplePoly_deactivateVoice(tSimplePoly* const polyh, uint8_t voice)
{
 8024a4c:	b4f0      	push	{r4, r5, r6, r7}
    _tSimplePoly* poly = *polyh;
 8024a4e:	6803      	ldr	r3, [r0, #0]

    if (poly->voices[voice][0] == -2) //only do this if the voice is waiting for deactivation (not already reassigned while waiting)
 8024a50:	b208      	sxth	r0, r1
 8024a52:	691a      	ldr	r2, [r3, #16]
 8024a54:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
 8024a58:	6822      	ldr	r2, [r4, #0]
 8024a5a:	3202      	adds	r2, #2
 8024a5c:	d001      	beq.n	8024a62 <tSimplePoly_deactivateVoice+0x16>
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
                }
            }
        }
    }
}
 8024a5e:	bcf0      	pop	{r4, r5, r6, r7}
 8024a60:	4770      	bx	lr
        poly->voices[voice][0] = -1;
 8024a62:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8024a66:	0085      	lsls	r5, r0, #2
        poly->voices[voice][1] = 0;
 8024a68:	2200      	movs	r2, #0
        poly->voices[voice][0] = -1;
 8024a6a:	6026      	str	r6, [r4, #0]
        poly->voices[voice][1] = 0;
 8024a6c:	691c      	ldr	r4, [r3, #16]
 8024a6e:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 8024a72:	6042      	str	r2, [r0, #4]
        if (poly->recover_stolen)
 8024a74:	6998      	ldr	r0, [r3, #24]
 8024a76:	2800      	cmp	r0, #0
 8024a78:	d0f1      	beq.n	8024a5e <tSimplePoly_deactivateVoice+0x12>
    _tStack* ns = *stack;
 8024a7a:	6858      	ldr	r0, [r3, #4]
    return ns->size;
 8024a7c:	f8b0 6206 	ldrh.w	r6, [r0, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 8024a80:	2e00      	cmp	r6, #0
 8024a82:	d0ec      	beq.n	8024a5e <tSimplePoly_deactivateVoice+0x12>
 8024a84:	4607      	mov	r7, r0
 8024a86:	f8df c054 	ldr.w	ip, [pc, #84]	; 8024adc <tSimplePoly_deactivateVoice+0x90>
    return ns->data[which];
 8024a8a:	eb00 0082 	add.w	r0, r0, r2, lsl #2
                noteToTest = tStack_get(&poly->stack, j);
 8024a8e:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
 8024a92:	eb03 04c0 	add.w	r4, r3, r0, lsl #3
                noteToTest = tStack_get(&poly->stack, j);
 8024a96:	f8ac 0000 	strh.w	r0, [ip]
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
 8024a9a:	69e4      	ldr	r4, [r4, #28]
 8024a9c:	3403      	adds	r4, #3
 8024a9e:	d004      	beq.n	8024aaa <tSimplePoly_deactivateVoice+0x5e>
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 8024aa0:	3201      	adds	r2, #1
 8024aa2:	42b2      	cmp	r2, r6
 8024aa4:	dadb      	bge.n	8024a5e <tSimplePoly_deactivateVoice+0x12>
{
 8024aa6:	4638      	mov	r0, r7
 8024aa8:	e7ef      	b.n	8024a8a <tSimplePoly_deactivateVoice+0x3e>
                    poly->voices[voice][0] = noteToTest; //set the newly free voice to use the old stolen note
 8024aaa:	691c      	ldr	r4, [r3, #16]
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 8024aac:	3201      	adds	r2, #1
                    poly->voices[voice][0] = noteToTest; //set the newly free voice to use the old stolen note
 8024aae:	5964      	ldr	r4, [r4, r5]
 8024ab0:	6020      	str	r0, [r4, #0]
                    poly->voices[voice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
 8024ab2:	f9bc 0000 	ldrsh.w	r0, [ip]
 8024ab6:	691c      	ldr	r4, [r3, #16]
 8024ab8:	eb03 06c0 	add.w	r6, r3, r0, lsl #3
 8024abc:	5967      	ldr	r7, [r4, r5]
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
 8024abe:	4634      	mov	r4, r6
                    poly->voices[voice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
 8024ac0:	6a36      	ldr	r6, [r6, #32]
 8024ac2:	607e      	str	r6, [r7, #4]
                    poly->voices[voice][2] = noteToTest;
 8024ac4:	691e      	ldr	r6, [r3, #16]
 8024ac6:	5976      	ldr	r6, [r6, r5]
 8024ac8:	60b0      	str	r0, [r6, #8]
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
 8024aca:	61e1      	str	r1, [r4, #28]
 8024acc:	685f      	ldr	r7, [r3, #4]
 8024ace:	f8b7 6206 	ldrh.w	r6, [r7, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 8024ad2:	4296      	cmp	r6, r2
 8024ad4:	ddc3      	ble.n	8024a5e <tSimplePoly_deactivateVoice+0x12>
{
 8024ad6:	4638      	mov	r0, r7
 8024ad8:	e7d7      	b.n	8024a8a <tSimplePoly_deactivateVoice+0x3e>
 8024ada:	bf00      	nop
 8024adc:	2000039c 	.word	0x2000039c

08024ae0 <tSimplePoly_markPendingNoteOff>:
    return voiceWithThatNote;
}


int tSimplePoly_markPendingNoteOff(tSimplePoly* const polyh, uint8_t note)
{
 8024ae0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tSimplePoly* poly = *polyh;
 8024ae4:	6805      	ldr	r5, [r0, #0]
    _tStack* ns = *stack;
 8024ae6:	f8d5 c004 	ldr.w	ip, [r5, #4]
    for (int i = 0; i < ns->size; i++)
 8024aea:	f8bc 0206 	ldrh.w	r0, [ip, #518]	; 0x206
 8024aee:	b170      	cbz	r0, 8024b0e <tSimplePoly_markPendingNoteOff+0x2e>
        if (ns->data[i] == noteVal)    return i;
 8024af0:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8024af4:	428b      	cmp	r3, r1
 8024af6:	d05c      	beq.n	8024bb2 <tSimplePoly_markPendingNoteOff+0xd2>
 8024af8:	f10c 0304 	add.w	r3, ip, #4
    for (int i = 0; i < ns->size; i++)
 8024afc:	2600      	movs	r6, #0
 8024afe:	e003      	b.n	8024b08 <tSimplePoly_markPendingNoteOff+0x28>
        if (ns->data[i] == noteVal)    return i;
 8024b00:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8024b04:	4291      	cmp	r1, r2
 8024b06:	d006      	beq.n	8024b16 <tSimplePoly_markPendingNoteOff+0x36>
    for (int i = 0; i < ns->size; i++)
 8024b08:	3601      	adds	r6, #1
 8024b0a:	42b0      	cmp	r0, r6
 8024b0c:	d1f8      	bne.n	8024b00 <tSimplePoly_markPendingNoteOff+0x20>
    int deactivatedVoice = -1;
 8024b0e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        }


    }
    return deactivatedVoice;
}
 8024b12:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        for (k = 0; k < (ns->size - foundIndex); k++)
 8024b16:	eba0 0806 	sub.w	r8, r0, r6
 8024b1a:	f1b8 0f00 	cmp.w	r8, #0
 8024b1e:	dd46      	ble.n	8024bae <tSimplePoly_markPendingNoteOff+0xce>
            if ((k+foundIndex) >= (ns->capacity - 1))
 8024b20:	f8bc e208 	ldrh.w	lr, [ip, #520]	; 0x208
 8024b24:	2200      	movs	r2, #0
                    ns->data[k + foundIndex + 1] = -1;
 8024b26:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 8024b2a:	3801      	subs	r0, #1
            if ((k+foundIndex) >= (ns->capacity - 1))
 8024b2c:	4613      	mov	r3, r2
 8024b2e:	44ce      	add	lr, r9
 8024b30:	e006      	b.n	8024b40 <tSimplePoly_markPendingNoteOff+0x60>
        for (k = 0; k < (ns->size - foundIndex); k++)
 8024b32:	3201      	adds	r2, #1
                ns->data[k + foundIndex] = -1;
 8024b34:	f8c4 9004 	str.w	r9, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
 8024b38:	b2d2      	uxtb	r2, r2
 8024b3a:	4590      	cmp	r8, r2
 8024b3c:	4613      	mov	r3, r2
 8024b3e:	dd0f      	ble.n	8024b60 <tSimplePoly_markPendingNoteOff+0x80>
            if ((k+foundIndex) >= (ns->capacity - 1))
 8024b40:	4433      	add	r3, r6
 8024b42:	4573      	cmp	r3, lr
 8024b44:	eb0c 0483 	add.w	r4, ip, r3, lsl #2
 8024b48:	daf3      	bge.n	8024b32 <tSimplePoly_markPendingNoteOff+0x52>
        for (k = 0; k < (ns->size - foundIndex); k++)
 8024b4a:	3201      	adds	r2, #1
                if ((k + foundIndex) == (ns->size - 1))
 8024b4c:	4283      	cmp	r3, r0
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
 8024b4e:	68a7      	ldr	r7, [r4, #8]
        for (k = 0; k < (ns->size - foundIndex); k++)
 8024b50:	b2d2      	uxtb	r2, r2
                    ns->data[k + foundIndex + 1] = -1;
 8024b52:	bf08      	it	eq
 8024b54:	f8c4 9008 	streq.w	r9, [r4, #8]
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
 8024b58:	6067      	str	r7, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
 8024b5a:	4590      	cmp	r8, r2
 8024b5c:	4613      	mov	r3, r2
 8024b5e:	dcef      	bgt.n	8024b40 <tSimplePoly_markPendingNoteOff+0x60>
        poly->notes[note][0] = -2;
 8024b60:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
 8024b64:	f06f 0201 	mvn.w	r2, #1
        ns->size--;
 8024b68:	f8ac 0206 	strh.w	r0, [ip, #518]	; 0x206
        poly->notes[note][0] = -2;
 8024b6c:	61da      	str	r2, [r3, #28]
        for (int i = 0; i < poly->maxNumVoices; i++)
 8024b6e:	68ee      	ldr	r6, [r5, #12]
 8024b70:	2e00      	cmp	r6, #0
 8024b72:	ddcc      	ble.n	8024b0e <tSimplePoly_markPendingNoteOff+0x2e>
            if (poly->voices[i][0] == note)
 8024b74:	692b      	ldr	r3, [r5, #16]
 8024b76:	681a      	ldr	r2, [r3, #0]
 8024b78:	6810      	ldr	r0, [r2, #0]
 8024b7a:	4281      	cmp	r1, r0
 8024b7c:	d00c      	beq.n	8024b98 <tSimplePoly_markPendingNoteOff+0xb8>
        for (int i = 0; i < poly->maxNumVoices; i++)
 8024b7e:	2000      	movs	r0, #0
 8024b80:	e004      	b.n	8024b8c <tSimplePoly_markPendingNoteOff+0xac>
            if (poly->voices[i][0] == note)
 8024b82:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8024b86:	6814      	ldr	r4, [r2, #0]
 8024b88:	428c      	cmp	r4, r1
 8024b8a:	d007      	beq.n	8024b9c <tSimplePoly_markPendingNoteOff+0xbc>
        for (int i = 0; i < poly->maxNumVoices; i++)
 8024b8c:	3001      	adds	r0, #1
 8024b8e:	42b0      	cmp	r0, r6
 8024b90:	ea4f 0780 	mov.w	r7, r0, lsl #2
 8024b94:	d1f5      	bne.n	8024b82 <tSimplePoly_markPendingNoteOff+0xa2>
 8024b96:	e7ba      	b.n	8024b0e <tSimplePoly_markPendingNoteOff+0x2e>
 8024b98:	2000      	movs	r0, #0
            if (poly->voices[i][0] == note)
 8024b9a:	4607      	mov	r7, r0
                poly->voices[i][0] = -2;
 8024b9c:	f06f 0301 	mvn.w	r3, #1
                poly->voices[i][1] = 0;
 8024ba0:	2100      	movs	r1, #0
                poly->voices[i][0] = -2;
 8024ba2:	6013      	str	r3, [r2, #0]
                poly->voices[i][1] = 0;
 8024ba4:	692b      	ldr	r3, [r5, #16]
 8024ba6:	59db      	ldr	r3, [r3, r7]
 8024ba8:	6059      	str	r1, [r3, #4]
}
 8024baa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8024bae:	3801      	subs	r0, #1
 8024bb0:	e7d6      	b.n	8024b60 <tSimplePoly_markPendingNoteOff+0x80>
        if (ns->data[i] == noteVal)    return i;
 8024bb2:	4680      	mov	r8, r0
    for (int i = 0; i < ns->size; i++)
 8024bb4:	2600      	movs	r6, #0
 8024bb6:	e7b3      	b.n	8024b20 <tSimplePoly_markPendingNoteOff+0x40>

08024bb8 <tSimplePoly_setNumVoices>:

void tSimplePoly_setNumVoices(tSimplePoly* const polyh, uint8_t numVoices)
{
    _tSimplePoly* poly = *polyh;
 8024bb8:	6802      	ldr	r2, [r0, #0]
    poly->numVoices = (numVoices > poly->maxNumVoices) ? poly->maxNumVoices : numVoices;
 8024bba:	68d3      	ldr	r3, [r2, #12]
 8024bbc:	4299      	cmp	r1, r3
 8024bbe:	bfa8      	it	ge
 8024bc0:	4619      	movge	r1, r3
 8024bc2:	6091      	str	r1, [r2, #8]
}
 8024bc4:	4770      	bx	lr
 8024bc6:	bf00      	nop

08024bc8 <tSimplePoly_getNumVoices>:


int tSimplePoly_getNumVoices(tSimplePoly* const polyh)
{
    _tSimplePoly* poly = *polyh;
    return poly->numVoices;
 8024bc8:	6803      	ldr	r3, [r0, #0]
}
 8024bca:	6898      	ldr	r0, [r3, #8]
 8024bcc:	4770      	bx	lr
 8024bce:	bf00      	nop

08024bd0 <tSimplePoly_getNumActiveVoices>:

int tSimplePoly_getNumActiveVoices(tSimplePoly* const polyh)
{
 8024bd0:	b508      	push	{r3, lr}
    _tSimplePoly* poly = *polyh;
 8024bd2:	6803      	ldr	r3, [r0, #0]
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
 8024bd4:	ed9f 0a09 	vldr	s0, [pc, #36]	; 8024bfc <tSimplePoly_getNumActiveVoices+0x2c>
    return ns->size;
 8024bd8:	685a      	ldr	r2, [r3, #4]
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
 8024bda:	ed93 1a02 	vldr	s2, [r3, #8]
    return ns->size;
 8024bde:	f8b2 3206 	ldrh.w	r3, [r2, #518]	; 0x206
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
 8024be2:	eeb8 1ac1 	vcvt.f32.s32	s2, s2
    return ns->size;
 8024be6:	ee00 3a90 	vmov	s1, r3
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
 8024bea:	eef8 0ae0 	vcvt.f32.s32	s1, s1
 8024bee:	f7ff f961 	bl	8023eb4 <LEAF_clip>
}
 8024bf2:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8024bf6:	ee17 0a90 	vmov	r0, s15
 8024bfa:	bd08      	pop	{r3, pc}
 8024bfc:	00000000 	.word	0x00000000

08024c00 <tSimplePoly_getPitch>:


int tSimplePoly_getPitch(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][2];
 8024c00:	6803      	ldr	r3, [r0, #0]
 8024c02:	691b      	ldr	r3, [r3, #16]
 8024c04:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
 8024c08:	6898      	ldr	r0, [r3, #8]
 8024c0a:	4770      	bx	lr

08024c0c <tSimplePoly_getPitchAndCheckActive>:

//this one returns negative one if the voice is inactive
int tSimplePoly_getPitchAndCheckActive(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][0];
 8024c0c:	6803      	ldr	r3, [r0, #0]
 8024c0e:	691b      	ldr	r3, [r3, #16]
 8024c10:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
 8024c14:	6818      	ldr	r0, [r3, #0]
 8024c16:	4770      	bx	lr

08024c18 <tSimplePoly_getVelocity>:

int tSimplePoly_getVelocity(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][1];
 8024c18:	6803      	ldr	r3, [r0, #0]
 8024c1a:	691b      	ldr	r3, [r3, #16]
 8024c1c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
 8024c20:	6858      	ldr	r0, [r3, #4]
 8024c22:	4770      	bx	lr

08024c24 <tSimplePoly_isOn>:

int tSimplePoly_isOn(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return (poly->voices[voice][0] > 0) ? 1 : 0;
 8024c24:	6803      	ldr	r3, [r0, #0]
 8024c26:	691b      	ldr	r3, [r3, #16]
 8024c28:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8024c2c:	6818      	ldr	r0, [r3, #0]
}
 8024c2e:	2800      	cmp	r0, #0
 8024c30:	bfd4      	ite	le
 8024c32:	2000      	movle	r0, #0
 8024c34:	2001      	movgt	r0, #1
 8024c36:	4770      	bx	lr

08024c38 <tCycle_init>:
    c->inc = c->freq * leaf.invSampleRate;
}

// Cycle
void    tCycle_init(tCycle* const cy)
{
 8024c38:	b538      	push	{r3, r4, r5, lr}
    tCycle_initToPool(cy, &leaf.mempool);
}

void    tCycle_initToPool   (tCycle* const cy, tMempool* const mp)
{
    _tMempool* m = *mp;
 8024c3a:	4b06      	ldr	r3, [pc, #24]	; (8024c54 <tCycle_init+0x1c>)
{
 8024c3c:	4605      	mov	r5, r0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
 8024c3e:	2010      	movs	r0, #16
    _tMempool* m = *mp;
 8024c40:	699c      	ldr	r4, [r3, #24]
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
 8024c42:	4621      	mov	r1, r4
 8024c44:	f7ff fb38 	bl	80242b8 <mpool_alloc>
    c->mempool = m;
    
    c->inc      =  0.0f;
 8024c48:	2300      	movs	r3, #0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
 8024c4a:	6028      	str	r0, [r5, #0]
    c->mempool = m;
 8024c4c:	6004      	str	r4, [r0, #0]
    c->inc      =  0.0f;
 8024c4e:	6083      	str	r3, [r0, #8]
    c->phase    =  0.0f;
 8024c50:	6043      	str	r3, [r0, #4]
}
 8024c52:	bd38      	pop	{r3, r4, r5, pc}
 8024c54:	200194e8 	.word	0x200194e8

08024c58 <tCycle_initToPool>:
{
 8024c58:	b538      	push	{r3, r4, r5, lr}
    _tMempool* m = *mp;
 8024c5a:	680c      	ldr	r4, [r1, #0]
{
 8024c5c:	4605      	mov	r5, r0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
 8024c5e:	2010      	movs	r0, #16
 8024c60:	4621      	mov	r1, r4
 8024c62:	f7ff fb29 	bl	80242b8 <mpool_alloc>
    c->inc      =  0.0f;
 8024c66:	2300      	movs	r3, #0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
 8024c68:	6028      	str	r0, [r5, #0]
    c->mempool = m;
 8024c6a:	6004      	str	r4, [r0, #0]
    c->inc      =  0.0f;
 8024c6c:	6083      	str	r3, [r0, #8]
    c->phase    =  0.0f;
 8024c6e:	6043      	str	r3, [r0, #4]
}
 8024c70:	bd38      	pop	{r3, r4, r5, pc}
 8024c72:	bf00      	nop

08024c74 <tCycle_free>:

void    tCycle_free (tCycle* const cy)
{
    _tCycle* c = *cy;
 8024c74:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)c, c->mempool);
 8024c76:	6801      	ldr	r1, [r0, #0]
 8024c78:	f7ff bbd2 	b.w	8024420 <mpool_free>

08024c7c <tCycle_setFreq>:
{
    _tCycle* c = *cy;
    
    c->freq  = freq;

    c->inc = freq * leaf.invSampleRate;
 8024c7c:	4a05      	ldr	r2, [pc, #20]	; (8024c94 <tCycle_setFreq+0x18>)
    _tCycle* c = *cy;
 8024c7e:	6803      	ldr	r3, [r0, #0]
    c->inc = freq * leaf.invSampleRate;
 8024c80:	edd2 7a01 	vldr	s15, [r2, #4]
    c->freq  = freq;
 8024c84:	ed83 0a03 	vstr	s0, [r3, #12]
    c->inc = freq * leaf.invSampleRate;
 8024c88:	ee27 0a80 	vmul.f32	s0, s15, s0
 8024c8c:	ed83 0a02 	vstr	s0, [r3, #8]
}
 8024c90:	4770      	bx	lr
 8024c92:	bf00      	nop
 8024c94:	200194e8 	.word	0x200194e8

08024c98 <tCycle_tick>:

//need to check bounds and wrap table properly to allow through-zero FM
float   tCycle_tick(tCycle* const cy)
{
    _tCycle* c = *cy;
 8024c98:	6803      	ldr	r3, [r0, #0]
    float samp0;
    float samp1;
    
    // Phasor increment
    c->phase += c->inc;
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8024c9a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    c->phase += c->inc;
 8024c9e:	ed93 7a01 	vldr	s14, [r3, #4]
 8024ca2:	edd3 7a02 	vldr	s15, [r3, #8]
 8024ca6:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8024caa:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c->phase += c->inc;
 8024cae:	ed83 7a01 	vstr	s14, [r3, #4]
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8024cb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024cb6:	db3f      	blt.n	8024d38 <tCycle_tick+0xa0>
 8024cb8:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 8024cbc:	eeb4 7ac6 	vcmpe.f32	s14, s12
 8024cc0:	ee77 7a66 	vsub.f32	s15, s14, s13
 8024cc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024cc8:	eeb0 7a67 	vmov.f32	s14, s15
 8024ccc:	daf6      	bge.n	8024cbc <tCycle_tick+0x24>
    while (c->phase < 0.0f) c->phase += 1.0f;
 8024cce:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8024cd2:	edc3 7a01 	vstr	s15, [r3, #4]
 8024cd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024cda:	d534      	bpl.n	8024d46 <tCycle_tick+0xae>
 8024cdc:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8024ce0:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
 8024ce4:	eef4 7ae6 	vcmpe.f32	s15, s13
 8024ce8:	ee37 7a86 	vadd.f32	s14, s15, s12
 8024cec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024cf0:	eef0 7a47 	vmov.f32	s15, s14
 8024cf4:	d4f6      	bmi.n	8024ce4 <tCycle_tick+0x4c>
 8024cf6:	ed83 7a01 	vstr	s14, [r3, #4]

    // Wavetable synthesis

    temp = SINE_TABLE_SIZE * c->phase;
 8024cfa:	eddf 7a14 	vldr	s15, [pc, #80]	; 8024d4c <tCycle_tick+0xb4>
    intPart = (int)temp;
    fracPart = temp - (float)intPart;
    samp0 = __leaf_table_sinewave[intPart];
 8024cfe:	4a14      	ldr	r2, [pc, #80]	; (8024d50 <tCycle_tick+0xb8>)
    temp = SINE_TABLE_SIZE * c->phase;
 8024d00:	ee27 7a27 	vmul.f32	s14, s14, s15
    intPart = (int)temp;
 8024d04:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8024d08:	ee17 3a90 	vmov	r3, s15
    fracPart = temp - (float)intPart;
 8024d0c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
 8024d10:	1c59      	adds	r1, r3, #1
    samp0 = __leaf_table_sinewave[intPart];
 8024d12:	eb02 0083 	add.w	r0, r2, r3, lsl #2
    fracPart = temp - (float)intPart;
 8024d16:	ee37 7a67 	vsub.f32	s14, s14, s15
    if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
 8024d1a:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
    samp0 = __leaf_table_sinewave[intPart];
 8024d1e:	ed90 0a00 	vldr	s0, [r0]
    if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
 8024d22:	bfa8      	it	ge
 8024d24:	2100      	movge	r1, #0
    samp1 = __leaf_table_sinewave[intPart];
 8024d26:	eb02 0281 	add.w	r2, r2, r1, lsl #2

    return (samp0 + (samp1 - samp0) * fracPart);
 8024d2a:	edd2 7a00 	vldr	s15, [r2]
 8024d2e:	ee77 7ac0 	vsub.f32	s15, s15, s0
}
 8024d32:	eea7 0a87 	vfma.f32	s0, s15, s14
 8024d36:	4770      	bx	lr
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8024d38:	eef0 7a47 	vmov.f32	s15, s14
    while (c->phase < 0.0f) c->phase += 1.0f;
 8024d3c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8024d40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024d44:	d4ca      	bmi.n	8024cdc <tCycle_tick+0x44>
 8024d46:	eeb0 7a67 	vmov.f32	s14, s15
 8024d4a:	e7d6      	b.n	8024cfa <tCycle_tick+0x62>
 8024d4c:	45000000 	.word	0x45000000
 8024d50:	08049034 	.word	0x08049034

08024d54 <tSawtooth_init>:
}

//=====================================================================
// Sawtooth
void    tSawtooth_init(tSawtooth* const cy)
{
 8024d54:	b570      	push	{r4, r5, r6, lr}
    tSawtooth_initToPool(cy, &leaf.mempool);
}

void    tSawtooth_initToPool    (tSawtooth* const cy, tMempool* const mp)
{
    _tMempool* m = *mp;
 8024d56:	4d0e      	ldr	r5, [pc, #56]	; (8024d90 <tSawtooth_init+0x3c>)
{
 8024d58:	4604      	mov	r4, r0
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
 8024d5a:	2018      	movs	r0, #24
    _tMempool* m = *mp;
 8024d5c:	69ae      	ldr	r6, [r5, #24]
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
 8024d5e:	4631      	mov	r1, r6
 8024d60:	f7ff faaa 	bl	80242b8 <mpool_alloc>
    c->mempool = m;
    
    c->inc      = 0.0f;
 8024d64:	2300      	movs	r3, #0
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
 8024d66:	6020      	str	r0, [r4, #0]
 8024d68:	2103      	movs	r1, #3
    c->mempool = m;
 8024d6a:	6006      	str	r6, [r0, #0]
    c->phase    = 0.0f;
 8024d6c:	6043      	str	r3, [r0, #4]

void    tSawtooth_setFreq(tSawtooth* const cy, float freq)
{
    _tSawtooth* c = *cy;
    
    c->freq  = freq;
 8024d6e:	ed9f 7a09 	vldr	s14, [pc, #36]	; 8024d94 <tSawtooth_init+0x40>
    
    c->inc = c->freq * leaf.invSampleRate;
 8024d72:	edd5 7a01 	vldr	s15, [r5, #4]
    c->inc      = 0.0f;
 8024d76:	6083      	str	r3, [r0, #8]
    c->inc = c->freq * leaf.invSampleRate;
 8024d78:	ee67 7a87 	vmul.f32	s15, s15, s14
    _tSawtooth* c = *cy;
 8024d7c:	6823      	ldr	r3, [r4, #0]
    c->w = c->freq * INV_20;
    for (c->oct = 0; c->w > 2.0f; c->oct++)
    {
        c->w = 0.5f * c->w;
    }
    c->w = 2.0f - c->w;
 8024d7e:	4a06      	ldr	r2, [pc, #24]	; (8024d98 <tSawtooth_init+0x44>)
    c->freq  = freq;
 8024d80:	ed83 7a03 	vstr	s14, [r3, #12]
    c->inc = c->freq * leaf.invSampleRate;
 8024d84:	edc3 7a02 	vstr	s15, [r3, #8]
 8024d88:	6119      	str	r1, [r3, #16]
    c->w = 2.0f - c->w;
 8024d8a:	615a      	str	r2, [r3, #20]
}
 8024d8c:	bd70      	pop	{r4, r5, r6, pc}
 8024d8e:	bf00      	nop
 8024d90:	200194e8 	.word	0x200194e8
 8024d94:	435c0000 	.word	0x435c0000
 8024d98:	3f200000 	.word	0x3f200000

08024d9c <tSawtooth_free>:
    _tSawtooth* c = *cy;
 8024d9c:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)c, c->mempool);
 8024d9e:	6801      	ldr	r1, [r0, #0]
 8024da0:	f7ff bb3e 	b.w	8024420 <mpool_free>

08024da4 <tSawtooth_setFreq>:
    c->w = c->freq * INV_20;
 8024da4:	eddf 7a16 	vldr	s15, [pc, #88]	; 8024e00 <tSawtooth_setFreq+0x5c>
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 8024da8:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
    c->inc = c->freq * leaf.invSampleRate;
 8024dac:	4b15      	ldr	r3, [pc, #84]	; (8024e04 <tSawtooth_setFreq+0x60>)
    c->w = c->freq * INV_20;
 8024dae:	ee60 7a27 	vmul.f32	s15, s0, s15
    _tSawtooth* c = *cy;
 8024db2:	6802      	ldr	r2, [r0, #0]
    c->inc = c->freq * leaf.invSampleRate;
 8024db4:	edd3 6a01 	vldr	s13, [r3, #4]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 8024db8:	2300      	movs	r3, #0
    c->freq  = freq;
 8024dba:	ed82 0a03 	vstr	s0, [r2, #12]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 8024dbe:	eef4 7ac7 	vcmpe.f32	s15, s14
    c->w = c->freq * INV_20;
 8024dc2:	edc2 7a05 	vstr	s15, [r2, #20]
    c->inc = c->freq * leaf.invSampleRate;
 8024dc6:	ee66 6a80 	vmul.f32	s13, s13, s0
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 8024dca:	6113      	str	r3, [r2, #16]
 8024dcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c->inc = c->freq * leaf.invSampleRate;
 8024dd0:	edc2 6a02 	vstr	s13, [r2, #8]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 8024dd4:	dd0c      	ble.n	8024df0 <tSawtooth_setFreq+0x4c>
        c->w = 0.5f * c->w;
 8024dd6:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 8024dda:	2301      	movs	r3, #1
        c->w = 0.5f * c->w;
 8024ddc:	ee67 7aa6 	vmul.f32	s15, s15, s13
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 8024de0:	4619      	mov	r1, r3
 8024de2:	3301      	adds	r3, #1
 8024de4:	eef4 7ac7 	vcmpe.f32	s15, s14
 8024de8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024dec:	dcf6      	bgt.n	8024ddc <tSawtooth_setFreq+0x38>
 8024dee:	6111      	str	r1, [r2, #16]
    c->w = 2.0f - c->w;
 8024df0:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 8024df4:	ee77 7a67 	vsub.f32	s15, s14, s15
 8024df8:	edc2 7a05 	vstr	s15, [r2, #20]
}
 8024dfc:	4770      	bx	lr
 8024dfe:	bf00      	nop
 8024e00:	3d4ccccd 	.word	0x3d4ccccd
 8024e04:	200194e8 	.word	0x200194e8

08024e08 <tSawtooth_tick>:

float   tSawtooth_tick(tSawtooth* const cy)
{
 8024e08:	b410      	push	{r4}
    _tSawtooth* c = *cy;
 8024e0a:	6802      	ldr	r2, [r0, #0]
    
    // Phasor increment
    c->phase += c->inc;
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8024e0c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    c->phase += c->inc;
 8024e10:	ed92 7a01 	vldr	s14, [r2, #4]
 8024e14:	edd2 7a02 	vldr	s15, [r2, #8]
 8024e18:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8024e1c:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c->phase += c->inc;
 8024e20:	ed82 7a01 	vstr	s14, [r2, #4]
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8024e24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024e28:	db3e      	blt.n	8024ea8 <tSawtooth_tick+0xa0>
 8024e2a:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 8024e2e:	eeb4 7ac6 	vcmpe.f32	s14, s12
 8024e32:	ee77 7a66 	vsub.f32	s15, s14, s13
 8024e36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024e3a:	eeb0 7a67 	vmov.f32	s14, s15
 8024e3e:	daf6      	bge.n	8024e2e <tSawtooth_tick+0x26>
    while (c->phase < 0.0f) c->phase += 1.0f;
 8024e40:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8024e44:	edc2 7a01 	vstr	s15, [r2, #4]
 8024e48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024e4c:	d533      	bpl.n	8024eb6 <tSawtooth_tick+0xae>
 8024e4e:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8024e52:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
 8024e56:	eef4 7ae6 	vcmpe.f32	s15, s13
 8024e5a:	ee37 7a86 	vadd.f32	s14, s15, s12
 8024e5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024e62:	eef0 7a47 	vmov.f32	s15, s14
 8024e66:	d4f6      	bmi.n	8024e56 <tSawtooth_tick+0x4e>
 8024e68:	ed82 7a01 	vstr	s14, [r2, #4]
    
    float out = 0.0f;
    
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
 8024e6c:	eef0 7a47 	vmov.f32	s15, s14
    
    // Wavetable synthesis
    out = __leaf_table_sawtooth[c->oct+1][idx] +
 8024e70:	6911      	ldr	r1, [r2, #16]
 8024e72:	4812      	ldr	r0, [pc, #72]	; (8024ebc <tSawtooth_tick+0xb4>)
 8024e74:	1c4c      	adds	r4, r1, #1
 8024e76:	ed92 7a05 	vldr	s14, [r2, #20]
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
 8024e7a:	eefe 7aea 	vcvt.s32.f32	s15, s15, #11
 8024e7e:	ee17 3a90 	vmov	r3, s15
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
 8024e82:	eb03 21c1 	add.w	r1, r3, r1, lsl #11
    out = __leaf_table_sawtooth[c->oct+1][idx] +
 8024e86:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
    
    return out;
}
 8024e8a:	f85d 4b04 	ldr.w	r4, [sp], #4
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
 8024e8e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    out = __leaf_table_sawtooth[c->oct+1][idx] +
 8024e92:	eb00 0383 	add.w	r3, r0, r3, lsl #2
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
 8024e96:	edd1 7a00 	vldr	s15, [r1]
    out = __leaf_table_sawtooth[c->oct+1][idx] +
 8024e9a:	ed93 0a00 	vldr	s0, [r3]
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
 8024e9e:	ee77 7ac0 	vsub.f32	s15, s15, s0
}
 8024ea2:	eea7 0a87 	vfma.f32	s0, s15, s14
 8024ea6:	4770      	bx	lr
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8024ea8:	eef0 7a47 	vmov.f32	s15, s14
    while (c->phase < 0.0f) c->phase += 1.0f;
 8024eac:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8024eb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024eb4:	d4cb      	bmi.n	8024e4e <tSawtooth_tick+0x46>
 8024eb6:	eeb0 7a67 	vmov.f32	s14, s15
 8024eba:	e7d7      	b.n	8024e6c <tSawtooth_tick+0x64>
 8024ebc:	08033034 	.word	0x08033034

08024ec0 <tNoise_init>:
    return p->phase;
}

/* Noise */
void    tNoise_init(tNoise* const ns, NoiseType type)
{
 8024ec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tNoise_initToPool(ns, type, &leaf.mempool);
}

void    tNoise_initToPool   (tNoise* const ns, NoiseType type, tMempool* const mp)
{
    _tMempool* m = *mp;
 8024ec2:	4c07      	ldr	r4, [pc, #28]	; (8024ee0 <tNoise_init+0x20>)
{
 8024ec4:	4607      	mov	r7, r0
 8024ec6:	460e      	mov	r6, r1
    _tNoise* n = *ns = (_tNoise*) mpool_alloc(sizeof(_tNoise), m);
 8024ec8:	2018      	movs	r0, #24
    _tMempool* m = *mp;
 8024eca:	69a5      	ldr	r5, [r4, #24]
    _tNoise* n = *ns = (_tNoise*) mpool_alloc(sizeof(_tNoise), m);
 8024ecc:	4629      	mov	r1, r5
 8024ece:	f7ff f9f3 	bl	80242b8 <mpool_alloc>
 8024ed2:	6038      	str	r0, [r7, #0]
    n->mempool = m;
 8024ed4:	6005      	str	r5, [r0, #0]
    
    n->type = type;
 8024ed6:	7106      	strb	r6, [r0, #4]
    n->rand = leaf.random;
 8024ed8:	6923      	ldr	r3, [r4, #16]
 8024eda:	6143      	str	r3, [r0, #20]
}
 8024edc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8024ede:	bf00      	nop
 8024ee0:	200194e8 	.word	0x200194e8

08024ee4 <tNoise_free>:
}

void    tNoise_free (tNoise* const ns)
{
    _tNoise* n = *ns;
 8024ee4:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)n, n->mempool);
 8024ee6:	6801      	ldr	r1, [r0, #0]
 8024ee8:	f7ff ba9a 	b.w	8024420 <mpool_free>

08024eec <tNoise_tick>:
}

float   tNoise_tick(tNoise* const ns)
{
 8024eec:	b510      	push	{r4, lr}
    _tNoise* n = *ns;
 8024eee:	6804      	ldr	r4, [r0, #0]
    
    float rand = (n->rand() * 2.0f) - 1.0f;
 8024ef0:	6963      	ldr	r3, [r4, #20]
 8024ef2:	4798      	blx	r3
 8024ef4:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 8024ef8:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
    
    if (n->type == PinkNoise)
 8024efc:	7923      	ldrb	r3, [r4, #4]
 8024efe:	2b01      	cmp	r3, #1
    float rand = (n->rand() * 2.0f) - 1.0f;
 8024f00:	eee0 7a07 	vfma.f32	s15, s0, s14
 8024f04:	eeb0 0a67 	vmov.f32	s0, s15
    if (n->type == PinkNoise)
 8024f08:	d000      	beq.n	8024f0c <tNoise_tick+0x20>
    }
    else // WhiteNoise
    {
        return rand;
    }
}
 8024f0a:	bd10      	pop	{r4, pc}
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8024f0c:	eddf 7a18 	vldr	s15, [pc, #96]	; 8024f70 <tNoise_tick+0x84>
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8024f10:	eddf 6a18 	vldr	s13, [pc, #96]	; 8024f74 <tNoise_tick+0x88>
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8024f14:	ee60 7a27 	vmul.f32	s15, s0, s15
 8024f18:	ed94 5a02 	vldr	s10, [r4, #8]
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8024f1c:	ee60 6a26 	vmul.f32	s13, s0, s13
 8024f20:	edd4 5a03 	vldr	s11, [r4, #12]
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8024f24:	ed9f 7a14 	vldr	s14, [pc, #80]	; 8024f78 <tNoise_tick+0x8c>
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8024f28:	ed9f 6a14 	vldr	s12, [pc, #80]	; 8024f7c <tNoise_tick+0x90>
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8024f2c:	eee5 7a07 	vfma.f32	s15, s10, s14
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8024f30:	ed9f 7a13 	vldr	s14, [pc, #76]	; 8024f80 <tNoise_tick+0x94>
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8024f34:	eee5 6a86 	vfma.f32	s13, s11, s12
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8024f38:	edd4 4a04 	vldr	s9, [r4, #16]
 8024f3c:	ee20 7a07 	vmul.f32	s14, s0, s14
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
 8024f40:	eddf 5a10 	vldr	s11, [pc, #64]	; 8024f84 <tNoise_tick+0x98>
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8024f44:	ed9f 5a10 	vldr	s10, [pc, #64]	; 8024f88 <tNoise_tick+0x9c>
        return (tmp * 0.05f);
 8024f48:	ed9f 6a10 	vldr	s12, [pc, #64]	; 8024f8c <tNoise_tick+0xa0>
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8024f4c:	eea4 7a85 	vfma.f32	s14, s9, s10
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8024f50:	edc4 7a02 	vstr	s15, [r4, #8]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
 8024f54:	ee77 7aa6 	vadd.f32	s15, s15, s13
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8024f58:	edc4 6a03 	vstr	s13, [r4, #12]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
 8024f5c:	eee0 7a25 	vfma.f32	s15, s0, s11
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8024f60:	ed84 7a04 	vstr	s14, [r4, #16]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
 8024f64:	ee37 0a87 	vadd.f32	s0, s15, s14
        return (tmp * 0.05f);
 8024f68:	ee20 0a06 	vmul.f32	s0, s0, s12
}
 8024f6c:	bd10      	pop	{r4, pc}
 8024f6e:	bf00      	nop
 8024f70:	3dcad8a1 	.word	0x3dcad8a1
 8024f74:	3e97d0ff 	.word	0x3e97d0ff
 8024f78:	3f7f65fe 	.word	0x3f7f65fe
 8024f7c:	3f76872b 	.word	0x3f76872b
 8024f80:	3f86be97 	.word	0x3f86be97
 8024f84:	3e3d3c36 	.word	0x3e3d3c36
 8024f88:	3f11eb85 	.word	0x3f11eb85
 8024f8c:	3d4ccccd 	.word	0x3d4ccccd

08024f90 <tComplexLivingString_initToPool>:
}

void    tComplexLivingString_initToPool    (tComplexLivingString* const pl, float freq, float pickPos, float prepPos, float prepIndex,
                                     float dampFreq, float decay, float targetLev, float levSmoothFactor,
                                     float levStrength, int levMode, tMempool* const mp)
{
 8024f90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024f94:	ed2d 8b0c 	vpush	{d8-d13}
    _tMempool* m = *mp;
 8024f98:	f8d2 9000 	ldr.w	r9, [r2]
{
 8024f9c:	b083      	sub	sp, #12
 8024f9e:	4606      	mov	r6, r0
 8024fa0:	460f      	mov	r7, r1
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
 8024fa2:	2070      	movs	r0, #112	; 0x70
 8024fa4:	4649      	mov	r1, r9
{
 8024fa6:	eef0 8a42 	vmov.f32	s17, s4
 8024faa:	4615      	mov	r5, r2
 8024fac:	eef0 9a41 	vmov.f32	s19, s2
    p->mempool = m;

    p->curr=0.0f;
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01f, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8024fb0:	f8df 821c 	ldr.w	r8, [pc, #540]	; 80251d0 <tComplexLivingString_initToPool+0x240>
{
 8024fb4:	eeb0 ba43 	vmov.f32	s22, s6
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01f, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8024fb8:	ed9f aa82 	vldr	s20, [pc, #520]	; 80251c4 <tComplexLivingString_initToPool+0x234>
{
 8024fbc:	eef0 ba63 	vmov.f32	s23, s7
    p->curr=0.0f;
 8024fc0:	eddf ca81 	vldr	s25, [pc, #516]	; 80251c8 <tComplexLivingString_initToPool+0x238>
{
 8024fc4:	eeb0 ca44 	vmov.f32	s24, s8
 8024fc8:	eeb0 da61 	vmov.f32	s26, s3
 8024fcc:	eef0 da62 	vmov.f32	s27, s5
 8024fd0:	eef0 aa40 	vmov.f32	s21, s0
 8024fd4:	eeb0 9a60 	vmov.f32	s18, s1
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
 8024fd8:	f7ff f96e 	bl	80242b8 <mpool_alloc>
 8024fdc:	4604      	mov	r4, r0
 8024fde:	6030      	str	r0, [r6, #0]
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01f, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8024fe0:	eef0 0a4a 	vmov.f32	s1, s20
 8024fe4:	4629      	mov	r1, r5
    p->mempool = m;
 8024fe6:	f8c4 9000 	str.w	r9, [r4]
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01f, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8024fea:	3064      	adds	r0, #100	; 0x64
 8024fec:	ed98 0a00 	vldr	s0, [r8]
 8024ff0:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
    p->curr=0.0f;
 8024ff4:	edc4 ca0a 	vstr	s25, [r4, #40]	; 0x28
    tComplexLivingString_setPickPos(pl, pickPos);
    tComplexLivingString_setPrepPos(pl, prepPos);

    p->prepPos=prepPos;
    p->pickPos=pickPos;
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
 8024ff8:	f104 0b2c 	add.w	fp, r4, #44	; 0x2c
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01f, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8024ffc:	ee80 0a2a 	vdiv.f32	s0, s0, s21
    tLinearDelay_initToPool(&p->delMF,p->waveLengthInSamples, 2400, mp);
 8025000:	f104 0a34 	add.w	sl, r4, #52	; 0x34
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01f, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8025004:	f7fd fa80 	bl	8022508 <tExpSmooth_initToPool>
void     tComplexLivingString_setFreq(tComplexLivingString* const pl, float freq)
{    // NOTE: It is faster to set wavelength in samples directly
    _tComplexLivingString* p = *pl;
    if (freq<20.0f) freq=20.0f;
    else if (freq>10000.0f) freq=10000.0f;
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8025008:	ed98 7a00 	vldr	s14, [r8]
 802500c:	eddf 7a6f 	vldr	s15, [pc, #444]	; 80251cc <tComplexLivingString_initToPool+0x23c>
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
 8025010:	f104 0238 	add.w	r2, r4, #56	; 0x38
    _tComplexLivingString* p = *pl;
 8025014:	6833      	ldr	r3, [r6, #0]
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
 8025016:	f104 0140 	add.w	r1, r4, #64	; 0x40
    p->waveLengthInSamples = leaf.sampleRate/freq;
 802501a:	feca 7ae7 	vminnm.f32	s15, s21, s15
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
 802501e:	9200      	str	r2, [sp, #0]
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8025020:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
 8025024:	f103 0064 	add.w	r0, r3, #100	; 0x64
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
 8025028:	9101      	str	r1, [sp, #4]
    tLinearDelay_initToPool(&p->delUF,p->waveLengthInSamples, 2400, mp);
 802502a:	f104 0930 	add.w	r9, r4, #48	; 0x30
    tLinearDelay_initToPool(&p->delUB,p->waveLengthInSamples, 2400, mp);
 802502e:	f104 083c 	add.w	r8, r4, #60	; 0x3c
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8025032:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
 8025036:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802503a:	ed83 0a02 	vstr	s0, [r3, #8]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
 802503e:	f7fd fa9f 	bl	8022580 <tExpSmooth_setDest>
    tExpSmooth_initToPool(&p->pickPosSmooth, pickPos, 0.01f, mp); // smoother for pick position
 8025042:	4629      	mov	r1, r5
 8025044:	eef0 0a4a 	vmov.f32	s1, s20
 8025048:	f104 0068 	add.w	r0, r4, #104	; 0x68
 802504c:	eeb0 0a49 	vmov.f32	s0, s18
    p->freq = freq;
 8025050:	edc4 aa01 	vstr	s21, [r4, #4]
    tExpSmooth_initToPool(&p->pickPosSmooth, pickPos, 0.01f, mp); // smoother for pick position
 8025054:	f7fd fa58 	bl	8022508 <tExpSmooth_initToPool>
    tExpSmooth_initToPool(&p->prepPosSmooth, prepPos, 0.01f, mp); // smoother for pick position
 8025058:	eef0 0a4a 	vmov.f32	s1, s20
 802505c:	4629      	mov	r1, r5
 802505e:	eeb0 0a69 	vmov.f32	s0, s19
 8025062:	f104 006c 	add.w	r0, r4, #108	; 0x6c
 8025066:	f7fd fa4f 	bl	8022508 <tExpSmooth_initToPool>
 802506a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
}

void     tComplexLivingString_setPickPos(tComplexLivingString* const pl, float pickPos)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
 802506e:	6833      	ldr	r3, [r6, #0]
 8025070:	fe89 0a40 	vminnm.f32	s0, s18, s0
    if (pickPos<0.5f) pickPos=0.5f;
    else if (pickPos>1.f) pickPos=1.f;
    p->pickPos = pickPos;
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
 8025074:	f103 0068 	add.w	r0, r3, #104	; 0x68
 8025078:	fe80 0a08 	vmaxnm.f32	s0, s0, s16
    p->pickPos = pickPos;
 802507c:	ed83 0a03 	vstr	s0, [r3, #12]
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
 8025080:	f7fd fa7e 	bl	8022580 <tExpSmooth_setDest>
}

void     tComplexLivingString_setPrepPos(tComplexLivingString* const pl, float prepPos)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
 8025084:	6833      	ldr	r3, [r6, #0]
 8025086:	fe89 0ac8 	vminnm.f32	s0, s19, s16
 802508a:	fe80 0a2c 	vmaxnm.f32	s0, s0, s25
    if (prepPos<0.f) prepPos=0.f;
    else if (prepPos>0.5f) prepPos=0.5f;
    p->prepPos = prepPos;
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
 802508e:	f103 006c 	add.w	r0, r3, #108	; 0x6c
    p->prepPos = prepPos;
 8025092:	ed83 0a04 	vstr	s0, [r3, #16]
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
 8025096:	f7fd fa73 	bl	8022580 <tExpSmooth_setDest>
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
 802509a:	4658      	mov	r0, fp
 802509c:	462a      	mov	r2, r5
 802509e:	ed94 0a02 	vldr	s0, [r4, #8]
    p->prepPos=prepPos;
 80250a2:	edc4 9a04 	vstr	s19, [r4, #16]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
 80250a6:	f44f 6116 	mov.w	r1, #2400	; 0x960
    p->pickPos=pickPos;
 80250aa:	ed84 9a03 	vstr	s18, [r4, #12]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
 80250ae:	f7fa f9ef 	bl	801f490 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delMF,p->waveLengthInSamples, 2400, mp);
 80250b2:	4650      	mov	r0, sl
 80250b4:	462a      	mov	r2, r5
 80250b6:	ed94 0a02 	vldr	s0, [r4, #8]
 80250ba:	f44f 6116 	mov.w	r1, #2400	; 0x960
 80250be:	f7fa f9e7 	bl	801f490 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delUF,p->waveLengthInSamples, 2400, mp);
 80250c2:	4648      	mov	r0, r9
 80250c4:	462a      	mov	r2, r5
 80250c6:	ed94 0a02 	vldr	s0, [r4, #8]
 80250ca:	f44f 6116 	mov.w	r1, #2400	; 0x960
 80250ce:	f7fa f9df 	bl	801f490 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delUB,p->waveLengthInSamples, 2400, mp);
 80250d2:	4640      	mov	r0, r8
 80250d4:	462a      	mov	r2, r5
 80250d6:	ed94 0a02 	vldr	s0, [r4, #8]
 80250da:	f44f 6116 	mov.w	r1, #2400	; 0x960
 80250de:	f7fa f9d7 	bl	801f490 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
 80250e2:	9800      	ldr	r0, [sp, #0]
 80250e4:	462a      	mov	r2, r5
 80250e6:	ed94 0a02 	vldr	s0, [r4, #8]
 80250ea:	f44f 6116 	mov.w	r1, #2400	; 0x960
 80250ee:	f7fa f9cf 	bl	801f490 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
 80250f2:	9e01      	ldr	r6, [sp, #4]
 80250f4:	462a      	mov	r2, r5
 80250f6:	ed94 0a02 	vldr	s0, [r4, #8]
 80250fa:	f44f 6116 	mov.w	r1, #2400	; 0x960
 80250fe:	4630      	mov	r0, r6
 8025100:	f7fa f9c6 	bl	801f490 <tLinearDelay_initToPool>
    tLinearDelay_clear(&p->delLF);
 8025104:	4658      	mov	r0, fp
 8025106:	f7fa fa45 	bl	801f594 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delMF);
 802510a:	4650      	mov	r0, sl
 802510c:	f7fa fa42 	bl	801f594 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delUF);
 8025110:	4648      	mov	r0, r9
 8025112:	f7fa fa3f 	bl	801f594 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delUB);
 8025116:	4640      	mov	r0, r8
 8025118:	f7fa fa3c 	bl	801f594 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delMB);
 802511c:	9800      	ldr	r0, [sp, #0]
 802511e:	f7fa fa39 	bl	801f594 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delLB);
 8025122:	4630      	mov	r0, r6
 8025124:	f7fa fa36 	bl	801f594 <tLinearDelay_clear>
    tOnePole_initToPool(&p->bridgeFilter, dampFreq, mp);
 8025128:	4629      	mov	r1, r5
 802512a:	eeb0 0a68 	vmov.f32	s0, s17
 802512e:	f104 0044 	add.w	r0, r4, #68	; 0x44
    p->dampFreq = dampFreq;
 8025132:	edc4 8a07 	vstr	s17, [r4, #28]
    tOnePole_initToPool(&p->bridgeFilter, dampFreq, mp);
 8025136:	f7fd faf9 	bl	802272c <tOnePole_initToPool>
    tOnePole_initToPool(&p->nutFilter, dampFreq, mp);
 802513a:	4629      	mov	r1, r5
 802513c:	eeb0 0a68 	vmov.f32	s0, s17
 8025140:	f104 0048 	add.w	r0, r4, #72	; 0x48
 8025144:	f7fd faf2 	bl	802272c <tOnePole_initToPool>
    tOnePole_initToPool(&p->prepFilterU, dampFreq, mp);
 8025148:	4629      	mov	r1, r5
 802514a:	eeb0 0a68 	vmov.f32	s0, s17
 802514e:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 8025152:	f7fd faeb 	bl	802272c <tOnePole_initToPool>
    tOnePole_initToPool(&p->prepFilterL, dampFreq, mp);
 8025156:	4629      	mov	r1, r5
 8025158:	eeb0 0a68 	vmov.f32	s0, s17
 802515c:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8025160:	f7fd fae4 	bl	802272c <tOnePole_initToPool>
    tHighpass_initToPool(&p->DCblockerU,13, mp);
 8025164:	4629      	mov	r1, r5
 8025166:	f104 0058 	add.w	r0, r4, #88	; 0x58
 802516a:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
 802516e:	f7fd fd19 	bl	8022ba4 <tHighpass_initToPool>
    tHighpass_initToPool(&p->DCblockerL,13, mp);
 8025172:	4629      	mov	r1, r5
 8025174:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8025178:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
 802517c:	f7fd fd12 	bl	8022ba4 <tHighpass_initToPool>
    tFeedbackLeveler_initToPool(&p->fbLevU, targetLev, levSmoothFactor, levStrength, levMode, mp);
 8025180:	462a      	mov	r2, r5
 8025182:	4639      	mov	r1, r7
 8025184:	eeb0 1a4c 	vmov.f32	s2, s24
 8025188:	eef0 0a6b 	vmov.f32	s1, s23
 802518c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8025190:	eeb0 0a4b 	vmov.f32	s0, s22
    p->decay=decay;
 8025194:	edc4 da08 	vstr	s27, [r4, #32]
    p->prepIndex = prepIndex;
 8025198:	ed84 da06 	vstr	s26, [r4, #24]
    tFeedbackLeveler_initToPool(&p->fbLevU, targetLev, levSmoothFactor, levStrength, levMode, mp);
 802519c:	f7fa ffd8 	bl	8020150 <tFeedbackLeveler_initToPool>
    tFeedbackLeveler_initToPool(&p->fbLevL, targetLev, levSmoothFactor, levStrength, levMode, mp);
 80251a0:	eeb0 1a4c 	vmov.f32	s2, s24
 80251a4:	eef0 0a6b 	vmov.f32	s1, s23
 80251a8:	462a      	mov	r2, r5
 80251aa:	eeb0 0a4b 	vmov.f32	s0, s22
 80251ae:	4639      	mov	r1, r7
 80251b0:	f104 0060 	add.w	r0, r4, #96	; 0x60
 80251b4:	f7fa ffcc 	bl	8020150 <tFeedbackLeveler_initToPool>
    p->levMode=levMode;
 80251b8:	6267      	str	r7, [r4, #36]	; 0x24
}
 80251ba:	b003      	add	sp, #12
 80251bc:	ecbd 8b0c 	vpop	{d8-d13}
 80251c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80251c4:	3c23d70a 	.word	0x3c23d70a
 80251c8:	00000000 	.word	0x00000000
 80251cc:	461c4000 	.word	0x461c4000
 80251d0:	200194e8 	.word	0x200194e8

080251d4 <tComplexLivingString_free>:
{
 80251d4:	b510      	push	{r4, lr}
    _tComplexLivingString* p = *pl;
 80251d6:	6804      	ldr	r4, [r0, #0]
    tExpSmooth_free(&p->wlSmooth);
 80251d8:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80251dc:	f7fd f9ba 	bl	8022554 <tExpSmooth_free>
    tExpSmooth_free(&p->pickPosSmooth);
 80251e0:	f104 0068 	add.w	r0, r4, #104	; 0x68
 80251e4:	f7fd f9b6 	bl	8022554 <tExpSmooth_free>
    tExpSmooth_free(&p->prepPosSmooth);
 80251e8:	f104 006c 	add.w	r0, r4, #108	; 0x6c
 80251ec:	f7fd f9b2 	bl	8022554 <tExpSmooth_free>
    tLinearDelay_free(&p->delLF);
 80251f0:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 80251f4:	f7fa f9c2 	bl	801f57c <tLinearDelay_free>
    tLinearDelay_free(&p->delMF);
 80251f8:	f104 0034 	add.w	r0, r4, #52	; 0x34
 80251fc:	f7fa f9be 	bl	801f57c <tLinearDelay_free>
    tLinearDelay_free(&p->delUF);
 8025200:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8025204:	f7fa f9ba 	bl	801f57c <tLinearDelay_free>
    tLinearDelay_free(&p->delUB);
 8025208:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 802520c:	f7fa f9b6 	bl	801f57c <tLinearDelay_free>
    tLinearDelay_free(&p->delMB);
 8025210:	f104 0038 	add.w	r0, r4, #56	; 0x38
 8025214:	f7fa f9b2 	bl	801f57c <tLinearDelay_free>
    tLinearDelay_free(&p->delLB);
 8025218:	f104 0040 	add.w	r0, r4, #64	; 0x40
 802521c:	f7fa f9ae 	bl	801f57c <tLinearDelay_free>
    tOnePole_free(&p->bridgeFilter);
 8025220:	f104 0044 	add.w	r0, r4, #68	; 0x44
 8025224:	f7fd fab8 	bl	8022798 <tOnePole_free>
    tOnePole_free(&p->nutFilter);
 8025228:	f104 0048 	add.w	r0, r4, #72	; 0x48
 802522c:	f7fd fab4 	bl	8022798 <tOnePole_free>
    tOnePole_free(&p->prepFilterU);
 8025230:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 8025234:	f7fd fab0 	bl	8022798 <tOnePole_free>
    tOnePole_free(&p->prepFilterL);
 8025238:	f104 0050 	add.w	r0, r4, #80	; 0x50
 802523c:	f7fd faac 	bl	8022798 <tOnePole_free>
    tHighpass_free(&p->DCblockerU);
 8025240:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8025244:	f7fd fcce 	bl	8022be4 <tHighpass_free>
    tHighpass_free(&p->DCblockerL);
 8025248:	f104 0054 	add.w	r0, r4, #84	; 0x54
 802524c:	f7fd fcca 	bl	8022be4 <tHighpass_free>
    tFeedbackLeveler_free(&p->fbLevU);
 8025250:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8025254:	f7fa ffa4 	bl	80201a0 <tFeedbackLeveler_free>
    tFeedbackLeveler_free(&p->fbLevL);
 8025258:	f104 0060 	add.w	r0, r4, #96	; 0x60
 802525c:	f7fa ffa0 	bl	80201a0 <tFeedbackLeveler_free>
    mpool_free((char*)p, p->mempool);
 8025260:	6821      	ldr	r1, [r4, #0]
 8025262:	4620      	mov	r0, r4
}
 8025264:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
 8025268:	f7ff b8da 	b.w	8024420 <mpool_free>

0802526c <tComplexLivingString_setFreq>:
    p->waveLengthInSamples = leaf.sampleRate/freq;
 802526c:	4b09      	ldr	r3, [pc, #36]	; (8025294 <tComplexLivingString_setFreq+0x28>)
 802526e:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
 8025272:	eddf 7a09 	vldr	s15, [pc, #36]	; 8025298 <tComplexLivingString_setFreq+0x2c>
 8025276:	ed93 7a00 	vldr	s14, [r3]
 802527a:	fec0 7a67 	vminnm.f32	s15, s0, s15
 802527e:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
 8025282:	ee87 0a27 	vdiv.f32	s0, s14, s15
    _tComplexLivingString* p = *pl;
 8025286:	6803      	ldr	r3, [r0, #0]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
 8025288:	f103 0064 	add.w	r0, r3, #100	; 0x64
    p->waveLengthInSamples = leaf.sampleRate/freq;
 802528c:	ed83 0a02 	vstr	s0, [r3, #8]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
 8025290:	f7fd b976 	b.w	8022580 <tExpSmooth_setDest>
 8025294:	200194e8 	.word	0x200194e8
 8025298:	461c4000 	.word	0x461c4000

0802529c <tComplexLivingString_setPickPos>:
{    // between 0 and 1
 802529c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tComplexLivingString* p = *pl;
 80252a0:	6803      	ldr	r3, [r0, #0]
 80252a2:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
 80252a6:	f103 0068 	add.w	r0, r3, #104	; 0x68
 80252aa:	fe80 0a67 	vminnm.f32	s0, s0, s15
 80252ae:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    p->pickPos = pickPos;
 80252b2:	ed83 0a03 	vstr	s0, [r3, #12]
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
 80252b6:	f7fd b963 	b.w	8022580 <tExpSmooth_setDest>
 80252ba:	bf00      	nop

080252bc <tComplexLivingString_setPrepPos>:
{    // between 0 and 1
 80252bc:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    _tComplexLivingString* p = *pl;
 80252c0:	6803      	ldr	r3, [r0, #0]
 80252c2:	ed9f 7a06 	vldr	s14, [pc, #24]	; 80252dc <tComplexLivingString_setPrepPos+0x20>
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
 80252c6:	f103 006c 	add.w	r0, r3, #108	; 0x6c
 80252ca:	fe80 0a67 	vminnm.f32	s0, s0, s15
 80252ce:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    p->prepPos = prepPos;
 80252d2:	ed83 0a04 	vstr	s0, [r3, #16]
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
 80252d6:	f7fd b953 	b.w	8022580 <tExpSmooth_setDest>
 80252da:	bf00      	nop
 80252dc:	00000000 	.word	0x00000000

080252e0 <tComplexLivingString_setPrepIndex>:
}

void     tComplexLivingString_setPrepIndex(tComplexLivingString* const pl, float prepIndex)
{    // between 0 and 1
 80252e0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tComplexLivingString* p = *pl;
 80252e4:	6803      	ldr	r3, [r0, #0]
    if (prepIndex<0.f) prepIndex=0.f;
    else if (prepIndex>1.f) prepIndex=1.f;
    p->prepIndex = prepIndex;
 80252e6:	ed9f 7a04 	vldr	s14, [pc, #16]	; 80252f8 <tComplexLivingString_setPrepIndex+0x18>
 80252ea:	fe80 0a67 	vminnm.f32	s0, s0, s15
 80252ee:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
 80252f2:	ed83 0a06 	vstr	s0, [r3, #24]
}
 80252f6:	4770      	bx	lr
 80252f8:	00000000 	.word	0x00000000

080252fc <tComplexLivingString_setDampFreq>:

void     tComplexLivingString_setDampFreq(tComplexLivingString* const pl, float dampFreq)
{
 80252fc:	b510      	push	{r4, lr}
 80252fe:	ed2d 8b02 	vpush	{d8}
 8025302:	eeb0 8a40 	vmov.f32	s16, s0
    _tComplexLivingString* p = *pl;
 8025306:	6804      	ldr	r4, [r0, #0]
    tOnePole_setFreq(&p->bridgeFilter, dampFreq);
 8025308:	f104 0044 	add.w	r0, r4, #68	; 0x44
 802530c:	f7fd fa48 	bl	80227a0 <tOnePole_setFreq>
    tOnePole_setFreq(&p->nutFilter, dampFreq);
 8025310:	eeb0 0a48 	vmov.f32	s0, s16
 8025314:	f104 0048 	add.w	r0, r4, #72	; 0x48
 8025318:	f7fd fa42 	bl	80227a0 <tOnePole_setFreq>
    tOnePole_setFreq(&p->prepFilterU, dampFreq);
 802531c:	eeb0 0a48 	vmov.f32	s0, s16
 8025320:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 8025324:	f7fd fa3c 	bl	80227a0 <tOnePole_setFreq>
    tOnePole_setFreq(&p->prepFilterL, dampFreq);
 8025328:	eeb0 0a48 	vmov.f32	s0, s16
 802532c:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
 8025330:	ecbd 8b02 	vpop	{d8}
 8025334:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&p->prepFilterL, dampFreq);
 8025338:	f7fd ba32 	b.w	80227a0 <tOnePole_setFreq>

0802533c <tComplexLivingString_setDecay>:

void     tComplexLivingString_setDecay(tComplexLivingString* const pl, float decay)
{
    _tComplexLivingString* p = *pl;
 802533c:	6803      	ldr	r3, [r0, #0]
    p->decay=decay;
 802533e:	ed83 0a08 	vstr	s0, [r3, #32]
}
 8025342:	4770      	bx	lr

08025344 <tComplexLivingString_setTargetLev>:

void     tComplexLivingString_setTargetLev(tComplexLivingString* const pl, float targetLev)
{
 8025344:	b510      	push	{r4, lr}
 8025346:	ed2d 8b02 	vpush	{d8}
 802534a:	eeb0 8a40 	vmov.f32	s16, s0
    _tComplexLivingString* p = *pl;
 802534e:	6804      	ldr	r4, [r0, #0]
    tFeedbackLeveler_setTargetLevel(&p->fbLevU, targetLev);
 8025350:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8025354:	f7fa ff5c 	bl	8020210 <tFeedbackLeveler_setTargetLevel>
    tFeedbackLeveler_setTargetLevel(&p->fbLevL, targetLev);
 8025358:	eeb0 0a48 	vmov.f32	s0, s16
 802535c:	f104 0060 	add.w	r0, r4, #96	; 0x60
}
 8025360:	ecbd 8b02 	vpop	{d8}
 8025364:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tFeedbackLeveler_setTargetLevel(&p->fbLevL, targetLev);
 8025368:	f7fa bf52 	b.w	8020210 <tFeedbackLeveler_setTargetLevel>

0802536c <tComplexLivingString_setLevMode>:
    tFeedbackLeveler_setStrength(&p->fbLevU, levStrength);
    tFeedbackLeveler_setStrength(&p->fbLevL, levStrength);
}

void     tComplexLivingString_setLevMode(tComplexLivingString* const pl, int levMode)
{
 802536c:	b538      	push	{r3, r4, r5, lr}
    _tComplexLivingString* p = *pl;
 802536e:	6804      	ldr	r4, [r0, #0]
{
 8025370:	460d      	mov	r5, r1
    tFeedbackLeveler_setMode(&p->fbLevU, levMode);
 8025372:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8025376:	f7fa ff1f 	bl	80201b8 <tFeedbackLeveler_setMode>
    tFeedbackLeveler_setMode(&p->fbLevL, levMode);
 802537a:	4629      	mov	r1, r5
 802537c:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8025380:	f7fa ff1a 	bl	80201b8 <tFeedbackLeveler_setMode>
    p->levMode=levMode;
 8025384:	6265      	str	r5, [r4, #36]	; 0x24
}
 8025386:	bd38      	pop	{r3, r4, r5, pc}

08025388 <tComplexLivingString_tick>:

float   tComplexLivingString_tick(tComplexLivingString* const pl, float input)
{
 8025388:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802538c:	ed2d 8b08 	vpush	{d8-d11}
    _tComplexLivingString* p = *pl;
 8025390:	6804      	ldr	r4, [r0, #0]
{
 8025392:	eef0 8a40 	vmov.f32	s17, s0

    // from pickPos upwards=forwards
    float fromLF=tLinearDelay_tickOut(&p->delLF);
 8025396:	f104 0a2c 	add.w	sl, r4, #44	; 0x2c
    float fromMF=tLinearDelay_tickOut(&p->delMF);
 802539a:	f104 0834 	add.w	r8, r4, #52	; 0x34
    float fromUF=tLinearDelay_tickOut(&p->delUF);
 802539e:	f104 0630 	add.w	r6, r4, #48	; 0x30
    float fromUB=tLinearDelay_tickOut(&p->delUB);
 80253a2:	f104 053c 	add.w	r5, r4, #60	; 0x3c
    float fromLF=tLinearDelay_tickOut(&p->delLF);
 80253a6:	4650      	mov	r0, sl
    float fromMB=tLinearDelay_tickOut(&p->delMB);
 80253a8:	f104 0738 	add.w	r7, r4, #56	; 0x38
    float fromLF=tLinearDelay_tickOut(&p->delLF);
 80253ac:	f7fa f94e 	bl	801f64c <tLinearDelay_tickOut>
    float fromMF=tLinearDelay_tickOut(&p->delMF);
 80253b0:	4640      	mov	r0, r8
    float fromLF=tLinearDelay_tickOut(&p->delLF);
 80253b2:	eeb0 9a40 	vmov.f32	s18, s0
    float fromMF=tLinearDelay_tickOut(&p->delMF);
 80253b6:	f7fa f949 	bl	801f64c <tLinearDelay_tickOut>
    float fromUF=tLinearDelay_tickOut(&p->delUF);
 80253ba:	4630      	mov	r0, r6
    float fromLB=tLinearDelay_tickOut(&p->delLB);
 80253bc:	f104 0940 	add.w	r9, r4, #64	; 0x40
    float fromMF=tLinearDelay_tickOut(&p->delMF);
 80253c0:	eef0 aa40 	vmov.f32	s21, s0
    float fromUF=tLinearDelay_tickOut(&p->delUF);
 80253c4:	f7fa f942 	bl	801f64c <tLinearDelay_tickOut>
    float fromUB=tLinearDelay_tickOut(&p->delUB);
 80253c8:	4628      	mov	r0, r5
    float fromUF=tLinearDelay_tickOut(&p->delUF);
 80253ca:	eef0 9a40 	vmov.f32	s19, s0
    float fromUB=tLinearDelay_tickOut(&p->delUB);
 80253ce:	f7fa f93d 	bl	801f64c <tLinearDelay_tickOut>
    float fromMB=tLinearDelay_tickOut(&p->delMB);
 80253d2:	4638      	mov	r0, r7
    float fromUB=tLinearDelay_tickOut(&p->delUB);
 80253d4:	eeb0 aa40 	vmov.f32	s20, s0
    float fromMB=tLinearDelay_tickOut(&p->delMB);
 80253d8:	f7fa f938 	bl	801f64c <tLinearDelay_tickOut>
    float fromLB=tLinearDelay_tickOut(&p->delLB);
 80253dc:	4648      	mov	r0, r9
    float fromMB=tLinearDelay_tickOut(&p->delMB);
 80253de:	eef0 ba40 	vmov.f32	s23, s0
    float fromLB=tLinearDelay_tickOut(&p->delLB);
 80253e2:	f7fa f933 	bl	801f64c <tLinearDelay_tickOut>

    // into upper part of string, from bridge, going backwards
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
 80253e6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80253e8:	f104 0b5c 	add.w	fp, r4, #92	; 0x5c
    float fromLB=tLinearDelay_tickOut(&p->delLB);
 80253ec:	eeb0 ba40 	vmov.f32	s22, s0
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
 80253f0:	2b00      	cmp	r3, #0
 80253f2:	f040 80a8 	bne.w	8025546 <tComplexLivingString_tick+0x1be>
 80253f6:	ed94 8a08 	vldr	s16, [r4, #32]
 80253fa:	eeb0 0a69 	vmov.f32	s0, s19
 80253fe:	f104 0044 	add.w	r0, r4, #68	; 0x44
 8025402:	f7fd f9e9 	bl	80227d8 <tOnePole_tick>
 8025406:	f104 0058 	add.w	r0, r4, #88	; 0x58
 802540a:	f7fd fbff 	bl	8022c0c <tHighpass_tick>
 802540e:	4658      	mov	r0, fp
 8025410:	ee20 0a08 	vmul.f32	s0, s0, s16
    float fromLowerPrep=-tOnePole_tick(&p->prepFilterL, fromLF);
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
    tLinearDelay_tickIn(&p->delLB, intoLower);

    // into lower part of string, from nut, going forwards toward prep position
    float fromNut=-tFeedbackLeveler_tick(&p->fbLevL, (p->levMode==0?p->decay:1.0f)*tHighpass_tick(&p->DCblockerL, tOnePole_tick(&p->nutFilter, fromLB)));
 8025414:	f104 0b60 	add.w	fp, r4, #96	; 0x60
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
 8025418:	f7fa fed2 	bl	80201c0 <tFeedbackLeveler_tick>
 802541c:	eef1 9a40 	vneg.f32	s19, s0
    tLinearDelay_tickIn(&p->delUB, fromBridge);
 8025420:	4628      	mov	r0, r5
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
 8025422:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    tLinearDelay_tickIn(&p->delUB, fromBridge);
 8025426:	eeb0 0a69 	vmov.f32	s0, s19
 802542a:	f7fa f8fb 	bl	801f624 <tLinearDelay_tickIn>
    tLinearDelay_tickIn(&p->delMB, fromUB+input);
 802542e:	ee3a 0a28 	vadd.f32	s0, s20, s17
 8025432:	4638      	mov	r0, r7
 8025434:	f7fa f8f6 	bl	801f624 <tLinearDelay_tickIn>
    float fromLowerPrep=-tOnePole_tick(&p->prepFilterL, fromLF);
 8025438:	f104 0050 	add.w	r0, r4, #80	; 0x50
 802543c:	eeb0 0a49 	vmov.f32	s0, s18
 8025440:	f7fd f9ca 	bl	80227d8 <tOnePole_tick>
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
 8025444:	ed94 7a06 	vldr	s14, [r4, #24]
    tLinearDelay_tickIn(&p->delLB, intoLower);
 8025448:	4648      	mov	r0, r9
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
 802544a:	ee78 7a47 	vsub.f32	s15, s16, s14
 802544e:	ee67 7aab 	vmul.f32	s15, s15, s23
    tLinearDelay_tickIn(&p->delLB, intoLower);
 8025452:	eee0 7a47 	vfms.f32	s15, s0, s14
 8025456:	eeb0 0a67 	vmov.f32	s0, s15
 802545a:	f7fa f8e3 	bl	801f624 <tLinearDelay_tickIn>
    float fromNut=-tFeedbackLeveler_tick(&p->fbLevL, (p->levMode==0?p->decay:1.0f)*tHighpass_tick(&p->DCblockerL, tOnePole_tick(&p->nutFilter, fromLB)));
 802545e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8025460:	b90b      	cbnz	r3, 8025466 <tComplexLivingString_tick+0xde>
 8025462:	ed94 8a08 	vldr	s16, [r4, #32]
 8025466:	eeb0 0a4b 	vmov.f32	s0, s22
 802546a:	f104 0048 	add.w	r0, r4, #72	; 0x48
 802546e:	f7fd f9b3 	bl	80227d8 <tOnePole_tick>
 8025472:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8025476:	f7fd fbc9 	bl	8022c0c <tHighpass_tick>
 802547a:	4658      	mov	r0, fp
 802547c:	ee20 0a08 	vmul.f32	s0, s0, s16
 8025480:	f7fa fe9e 	bl	80201c0 <tFeedbackLeveler_tick>
    tLinearDelay_tickIn(&p->delLF, fromNut);
 8025484:	4650      	mov	r0, sl
 8025486:	eeb1 0a40 	vneg.f32	s0, s0
 802548a:	f7fa f8cb 	bl	801f624 <tLinearDelay_tickIn>

    // into middle part of string, from prep going toward pick position
    float fromUpperPrep=-tOnePole_tick(&p->prepFilterU, fromUB);
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
 802548e:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    float fromUpperPrep=-tOnePole_tick(&p->prepFilterU, fromUB);
 8025492:	eeb0 0a4a 	vmov.f32	s0, s20
 8025496:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 802549a:	f7fd f99d 	bl	80227d8 <tOnePole_tick>
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
 802549e:	edd4 7a06 	vldr	s15, [r4, #24]

    //pick position, take input and add it into the waveguide, going to come out of middle segment
    tLinearDelay_tickIn(&p->delMF, intoMiddle + input);
 80254a2:	4640      	mov	r0, r8
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
 80254a4:	ee38 7a67 	vsub.f32	s14, s16, s15
    tLinearDelay_tickIn(&p->delMF, intoMiddle + input);
 80254a8:	eee7 8a09 	vfma.f32	s17, s14, s18
 80254ac:	eee0 8a67 	vfms.f32	s17, s0, s15
 80254b0:	eeb0 0a68 	vmov.f32	s0, s17
 80254b4:	f7fa f8b6 	bl	801f624 <tLinearDelay_tickIn>

    //take output of middle segment and put it into upper segment connecting to the bridge
    tLinearDelay_tickIn(&p->delUF, fromMF);
 80254b8:	eeb0 0a6a 	vmov.f32	s0, s21
 80254bc:	4630      	mov	r0, r6
 80254be:	f7fa f8b1 	bl	801f624 <tLinearDelay_tickIn>

    // update all delay lengths
    float pickP=tExpSmooth_tick(&p->pickPosSmooth);
 80254c2:	f104 0068 	add.w	r0, r4, #104	; 0x68
 80254c6:	f7fd f865 	bl	8022594 <tExpSmooth_tick>
    float prepP=tExpSmooth_tick(&p->prepPosSmooth);
 80254ca:	f104 006c 	add.w	r0, r4, #108	; 0x6c
    float pickP=tExpSmooth_tick(&p->pickPosSmooth);
 80254ce:	eeb0 9a40 	vmov.f32	s18, s0
    float prepP=tExpSmooth_tick(&p->prepPosSmooth);
 80254d2:	f7fd f85f 	bl	8022594 <tExpSmooth_tick>
 80254d6:	eef0 8a40 	vmov.f32	s17, s0
    float wLen=tExpSmooth_tick(&p->wlSmooth);
 80254da:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80254de:	f7fd f859 	bl	8022594 <tExpSmooth_tick>
 80254e2:	eef0 7a40 	vmov.f32	s15, s0

    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
    float lowLen = prepP*wLen; // the length from prep to nut
    float upLen = (1.0f-pickP)*wLen; // the length from pick to bridge
 80254e6:	ee38 8a49 	vsub.f32	s16, s16, s18


    tLinearDelay_setDelay(&p->delLF, lowLen);
 80254ea:	4650      	mov	r0, sl
    float lowLen = prepP*wLen; // the length from prep to nut
 80254ec:	ee28 aa80 	vmul.f32	s20, s17, s0
    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
 80254f0:	ee79 8a68 	vsub.f32	s17, s18, s17
    float upLen = (1.0f-pickP)*wLen; // the length from pick to bridge
 80254f4:	ee28 8a00 	vmul.f32	s16, s16, s0
    tLinearDelay_setDelay(&p->delLF, lowLen);
 80254f8:	eeb0 0a4a 	vmov.f32	s0, s20
    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
 80254fc:	ee68 8aa7 	vmul.f32	s17, s17, s15
    tLinearDelay_setDelay(&p->delLF, lowLen);
 8025500:	f7fa f8ce 	bl	801f6a0 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delLB, lowLen);
 8025504:	eeb0 0a4a 	vmov.f32	s0, s20
 8025508:	4648      	mov	r0, r9
 802550a:	f7fa f8c9 	bl	801f6a0 <tLinearDelay_setDelay>

    tLinearDelay_setDelay(&p->delMF, midLen);
 802550e:	4640      	mov	r0, r8
 8025510:	eeb0 0a68 	vmov.f32	s0, s17
 8025514:	f7fa f8c4 	bl	801f6a0 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delMB, midLen);
 8025518:	eeb0 0a68 	vmov.f32	s0, s17
 802551c:	4638      	mov	r0, r7
 802551e:	f7fa f8bf 	bl	801f6a0 <tLinearDelay_setDelay>

    tLinearDelay_setDelay(&p->delUF, upLen);
 8025522:	eeb0 0a48 	vmov.f32	s0, s16
 8025526:	4630      	mov	r0, r6
 8025528:	f7fa f8ba 	bl	801f6a0 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delUB, upLen);
 802552c:	eeb0 0a48 	vmov.f32	s0, s16
 8025530:	4628      	mov	r0, r5
 8025532:	f7fa f8b5 	bl	801f6a0 <tLinearDelay_setDelay>

    //update this to allow pickup position variation
    p->curr = fromBridge;
    return p->curr;
}
 8025536:	eeb0 0a69 	vmov.f32	s0, s19
    p->curr = fromBridge;
 802553a:	edc4 9a0a 	vstr	s19, [r4, #40]	; 0x28
}
 802553e:	ecbd 8b08 	vpop	{d8-d11}
 8025542:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
 8025546:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 802554a:	e756      	b.n	80253fa <tComplexLivingString_tick+0x72>

0802554c <tNReverb_initToPool>:
{
    tNReverb_initToPool(rev, t60, &leaf.mempool);
}

void    tNReverb_initToPool     (tNReverb* const rev, float t60, tMempool* const mp)
{
 802554c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025550:	ed2d 8b04 	vpush	{d8-d9}
 8025554:	eef0 9a40 	vmov.f32	s19, s0
    _tMempool* m = *mp;
 8025558:	680c      	ldr	r4, [r1, #0]
{
 802555a:	b093      	sub	sp, #76	; 0x4c
 802555c:	4605      	mov	r5, r0
 802555e:	460e      	mov	r6, r1
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
 8025560:	4621      	mov	r1, r4
{
 8025562:	9001      	str	r0, [sp, #4]
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
 8025564:	2074      	movs	r0, #116	; 0x74
 8025566:	f7fe fea7 	bl	80242b8 <mpool_alloc>
    r->mempool = m;
    
    if (t60 <= 0.0f) t60 = 0.001f;
 802556a:	eef5 9ac0 	vcmpe.f32	s19, #0.0
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
 802556e:	6028      	str	r0, [r5, #0]
 8025570:	4682      	mov	sl, r0
    r->mempool = m;
 8025572:	6004      	str	r4, [r0, #0]
    if (t60 <= 0.0f) t60 = 0.001f;
 8025574:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025578:	f240 80ac 	bls.w	80256d4 <tNReverb_initToPool+0x188>
 802557c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8025580:	eec7 8aa9 	vdiv.f32	s17, s15, s19
    
    r->inv_441 = 1.0f/44100.0f;
    
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
 8025584:	f8df c170 	ldr.w	ip, [pc, #368]	; 80256f8 <tNReverb_initToPool+0x1ac>
 8025588:	af03      	add	r7, sp, #12
    double scaler = leaf.sampleRate / 25641.0f;
 802558a:	f8df 8170 	ldr.w	r8, [pc, #368]	; 80256fc <tNReverb_initToPool+0x1b0>
 802558e:	ac02      	add	r4, sp, #8
 8025590:	ed9f 7a53 	vldr	s14, [pc, #332]	; 80256e0 <tNReverb_initToPool+0x194>
 8025594:	f10d 090c 	add.w	r9, sp, #12
 8025598:	edd8 7a00 	vldr	s15, [r8]
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
 802559c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    double scaler = leaf.sampleRate / 25641.0f;
 80255a0:	ee67 7a87 	vmul.f32	s15, s15, s14
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
 80255a4:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80255a6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80255aa:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80255ac:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80255b0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80255b4:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80255b6:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
    r->inv_441 = 1.0f/44100.0f;
 80255ba:	4b4a      	ldr	r3, [pc, #296]	; (80256e4 <tNReverb_initToPool+0x198>)
 80255bc:	ee17 5a90 	vmov	r5, s15
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
 80255c0:	e887 0007 	stmia.w	r7, {r0, r1, r2}
 80255c4:	af11      	add	r7, sp, #68	; 0x44
    r->inv_441 = 1.0f/44100.0f;
 80255c6:	f8ca 3010 	str.w	r3, [sl, #16]
    
    int delay, i;
    
    for (i=0; i < 15; i++)
    {
        delay = (int) scaler * lengths[i];
 80255ca:	f854 3f04 	ldr.w	r3, [r4, #4]!
 80255ce:	fb03 fb05 	mul.w	fp, r3, r5
        if ( (delay & 1) == 0)
 80255d2:	f01b 0f01 	tst.w	fp, #1
 80255d6:	d104      	bne.n	80255e2 <tNReverb_initToPool+0x96>
            delay++;
 80255d8:	f10b 0b01 	add.w	fp, fp, #1
 80255dc:	e001      	b.n	80255e2 <tNReverb_initToPool+0x96>
        while ( !LEAF_isPrime(delay) )
            delay += 2;
 80255de:	f10b 0b02 	add.w	fp, fp, #2
        while ( !LEAF_isPrime(delay) )
 80255e2:	4658      	mov	r0, fp
 80255e4:	17c1      	asrs	r1, r0, #31
 80255e6:	f7fe fc85 	bl	8023ef4 <LEAF_isPrime>
 80255ea:	2800      	cmp	r0, #0
 80255ec:	d0f7      	beq.n	80255de <tNReverb_initToPool+0x92>
    for (i=0; i < 15; i++)
 80255ee:	42a7      	cmp	r7, r4
        lengths[i] = delay;
 80255f0:	f8c4 b000 	str.w	fp, [r4]
    for (i=0; i < 15; i++)
 80255f4:	d1e9      	bne.n	80255ca <tNReverb_initToPool+0x7e>
    
    for ( i=0; i<6; i++ )
    {
        tLinearDelay_initToPool(&r->combDelays[i], lengths[i], lengths[i] * 2, mp);
        tLinearDelay_clear(&r->combDelays[i]);
        r->combCoeffs[i] = powf(10.0f, (-3.0f * (float)lengths[i] * leaf.invSampleRate / t60));
 80255f6:	eeb8 9a08 	vmov.f32	s18, #136	; 0xc0400000 -3.0
 80255fa:	f10a 0550 	add.w	r5, sl, #80	; 0x50
 80255fe:	f10a 0768 	add.w	r7, sl, #104	; 0x68
        tLinearDelay_initToPool(&r->combDelays[i], lengths[i], lengths[i] * 2, mp);
 8025602:	f859 1b04 	ldr.w	r1, [r9], #4
 8025606:	f1a5 0b1c 	sub.w	fp, r5, #28
 802560a:	4632      	mov	r2, r6
 802560c:	ee07 1a90 	vmov	s15, r1
 8025610:	4658      	mov	r0, fp
 8025612:	0049      	lsls	r1, r1, #1
 8025614:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 8025618:	eeb0 0a48 	vmov.f32	s0, s16
 802561c:	f7f9 ff38 	bl	801f490 <tLinearDelay_initToPool>
        tLinearDelay_clear(&r->combDelays[i]);
 8025620:	4658      	mov	r0, fp
 8025622:	f7f9 ffb7 	bl	801f594 <tLinearDelay_clear>
        r->combCoeffs[i] = powf(10.0f, (-3.0f * (float)lengths[i] * leaf.invSampleRate / t60));
 8025626:	edd8 7a01 	vldr	s15, [r8, #4]
 802562a:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 802562e:	ee67 7a89 	vmul.f32	s15, s15, s18
 8025632:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8025636:	ee67 0a88 	vmul.f32	s1, s15, s16
 802563a:	f001 ffa1 	bl	8027580 <powf>
 802563e:	eca5 0a01 	vstmia	r5!, {s0}
    for ( i=0; i<6; i++ )
 8025642:	42bd      	cmp	r5, r7
 8025644:	d1dd      	bne.n	8025602 <tNReverb_initToPool+0xb6>
 8025646:	af09      	add	r7, sp, #36	; 0x24
 8025648:	f10a 0514 	add.w	r5, sl, #20
    }
    
    for ( i=0; i<8; i++ )
    {
        tLinearDelay_initToPool(&r->allpassDelays[i], lengths[i+6], lengths[i+6] * 2, mp);
 802564c:	f857 3b04 	ldr.w	r3, [r7], #4
 8025650:	4628      	mov	r0, r5
 8025652:	4632      	mov	r2, r6
 8025654:	ee07 3a90 	vmov	s15, r3
 8025658:	0059      	lsls	r1, r3, #1
 802565a:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 802565e:	f7f9 ff17 	bl	801f490 <tLinearDelay_initToPool>
        tLinearDelay_clear(&r->allpassDelays[i]);
 8025662:	4628      	mov	r0, r5
 8025664:	f7f9 ff96 	bl	801f594 <tLinearDelay_clear>
    for ( i=0; i<8; i++ )
 8025668:	42a7      	cmp	r7, r4
 802566a:	f105 0504 	add.w	r5, r5, #4
 802566e:	d1ed      	bne.n	802564c <tNReverb_initToPool+0x100>

void    tNReverb_setT60(tNReverb* const rev, float t60)
{
    _tNReverb* r = *rev;
    
    if (t60 <= 0.0f)           t60 = 0.001f;
 8025670:	eef5 9ac0 	vcmpe.f32	s19, #0.0
    _tNReverb* r = *rev;
 8025674:	9b01      	ldr	r3, [sp, #4]
 8025676:	681b      	ldr	r3, [r3, #0]
    if (t60 <= 0.0f)           t60 = 0.001f;
 8025678:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802567c:	d803      	bhi.n	8025686 <tNReverb_initToPool+0x13a>
 802567e:	eddf 8a1a 	vldr	s17, [pc, #104]	; 80256e8 <tNReverb_initToPool+0x19c>
 8025682:	eddf 9a1a 	vldr	s19, [pc, #104]	; 80256ec <tNReverb_initToPool+0x1a0>
    
    r->t60 = t60;
    
    for (int i=0; i<6; i++)   r->combCoeffs[i] = powf(10.0f, (-3.0f * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
 8025686:	eeb8 8a08 	vmov.f32	s16, #136	; 0xc0400000 -3.0
 802568a:	f103 0450 	add.w	r4, r3, #80	; 0x50
 802568e:	f103 0568 	add.w	r5, r3, #104	; 0x68
    r->t60 = t60;
 8025692:	edc3 9a02 	vstr	s19, [r3, #8]
    for (int i=0; i<6; i++)   r->combCoeffs[i] = powf(10.0f, (-3.0f * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
 8025696:	f1a4 001c 	sub.w	r0, r4, #28
 802569a:	f7fa f841 	bl	801f720 <tLinearDelay_getDelay>
 802569e:	edd8 0a01 	vldr	s1, [r8, #4]
 80256a2:	ee60 0a88 	vmul.f32	s1, s1, s16
 80256a6:	ee60 0aa8 	vmul.f32	s1, s1, s17
 80256aa:	ee60 0a80 	vmul.f32	s1, s1, s0
 80256ae:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 80256b2:	f001 ff65 	bl	8027580 <powf>
 80256b6:	eca4 0a01 	vstmia	r4!, {s0}
 80256ba:	42a5      	cmp	r5, r4
 80256bc:	d1eb      	bne.n	8025696 <tNReverb_initToPool+0x14a>
    r->allpassCoeff = 0.7f;
 80256be:	4a0c      	ldr	r2, [pc, #48]	; (80256f0 <tNReverb_initToPool+0x1a4>)
    r->mix = 0.3f;
 80256c0:	4b0c      	ldr	r3, [pc, #48]	; (80256f4 <tNReverb_initToPool+0x1a8>)
    r->allpassCoeff = 0.7f;
 80256c2:	f8ca 204c 	str.w	r2, [sl, #76]	; 0x4c
    r->mix = 0.3f;
 80256c6:	f8ca 3004 	str.w	r3, [sl, #4]
}
 80256ca:	b013      	add	sp, #76	; 0x4c
 80256cc:	ecbd 8b04 	vpop	{d8-d9}
 80256d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80256d4:	eddf 8a04 	vldr	s17, [pc, #16]	; 80256e8 <tNReverb_initToPool+0x19c>
    if (t60 <= 0.0f) t60 = 0.001f;
 80256d8:	eddf 9a04 	vldr	s19, [pc, #16]	; 80256ec <tNReverb_initToPool+0x1a0>
 80256dc:	e752      	b.n	8025584 <tNReverb_initToPool+0x38>
 80256de:	bf00      	nop
 80256e0:	382393f9 	.word	0x382393f9
 80256e4:	37be37c6 	.word	0x37be37c6
 80256e8:	4479ffff 	.word	0x4479ffff
 80256ec:	3a83126f 	.word	0x3a83126f
 80256f0:	3f333333 	.word	0x3f333333
 80256f4:	3e99999a 	.word	0x3e99999a
 80256f8:	08029010 	.word	0x08029010
 80256fc:	200194e8 	.word	0x200194e8

08025700 <tNReverb_free>:
{
 8025700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tNReverb* r = *rev;
 8025702:	6807      	ldr	r7, [r0, #0]
 8025704:	f107 0534 	add.w	r5, r7, #52	; 0x34
 8025708:	f107 064c 	add.w	r6, r7, #76	; 0x4c
 802570c:	462c      	mov	r4, r5
        tLinearDelay_free(&r->combDelays[i]);
 802570e:	4620      	mov	r0, r4
 8025710:	3404      	adds	r4, #4
 8025712:	f7f9 ff33 	bl	801f57c <tLinearDelay_free>
    for (int i = 0; i < 6; i++)
 8025716:	42b4      	cmp	r4, r6
 8025718:	d1f9      	bne.n	802570e <tNReverb_free+0xe>
 802571a:	f107 0414 	add.w	r4, r7, #20
        tLinearDelay_free(&r->allpassDelays[i]);
 802571e:	4620      	mov	r0, r4
 8025720:	3404      	adds	r4, #4
 8025722:	f7f9 ff2b 	bl	801f57c <tLinearDelay_free>
    for (int i = 0; i < 8; i++)
 8025726:	42a5      	cmp	r5, r4
 8025728:	d1f9      	bne.n	802571e <tNReverb_free+0x1e>
    mpool_free((char*)r, r->mempool);
 802572a:	6839      	ldr	r1, [r7, #0]
 802572c:	4638      	mov	r0, r7
}
 802572e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
 8025732:	f7fe be75 	b.w	8024420 <mpool_free>
 8025736:	bf00      	nop

08025738 <tNReverb_setT60>:
    if (t60 <= 0.0f)           t60 = 0.001f;
 8025738:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
 802573c:	b570      	push	{r4, r5, r6, lr}
    if (t60 <= 0.0f)           t60 = 0.001f;
 802573e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 8025742:	ed2d 8b02 	vpush	{d8}
    _tNReverb* r = *rev;
 8025746:	6803      	ldr	r3, [r0, #0]
    if (t60 <= 0.0f)           t60 = 0.001f;
 8025748:	d923      	bls.n	8025792 <tNReverb_setT60+0x5a>
 802574a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802574e:	eec7 8a80 	vdiv.f32	s17, s15, s0
 8025752:	f103 0450 	add.w	r4, r3, #80	; 0x50
 8025756:	f103 0668 	add.w	r6, r3, #104	; 0x68
 802575a:	4d10      	ldr	r5, [pc, #64]	; (802579c <tNReverb_setT60+0x64>)
    r->t60 = t60;
 802575c:	ed83 0a02 	vstr	s0, [r3, #8]
    for (int i=0; i<6; i++)   r->combCoeffs[i] = powf(10.0f, (-3.0f * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
 8025760:	eeb8 8a08 	vmov.f32	s16, #136	; 0xc0400000 -3.0
 8025764:	f1a4 001c 	sub.w	r0, r4, #28
 8025768:	f7f9 ffda 	bl	801f720 <tLinearDelay_getDelay>
 802576c:	edd5 0a01 	vldr	s1, [r5, #4]
 8025770:	ee60 0a88 	vmul.f32	s1, s1, s16
 8025774:	ee60 0aa8 	vmul.f32	s1, s1, s17
 8025778:	ee60 0a80 	vmul.f32	s1, s1, s0
 802577c:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8025780:	f001 fefe 	bl	8027580 <powf>
 8025784:	eca4 0a01 	vstmia	r4!, {s0}
 8025788:	42a6      	cmp	r6, r4
 802578a:	d1eb      	bne.n	8025764 <tNReverb_setT60+0x2c>
    
}
 802578c:	ecbd 8b02 	vpop	{d8}
 8025790:	bd70      	pop	{r4, r5, r6, pc}
 8025792:	eddf 8a03 	vldr	s17, [pc, #12]	; 80257a0 <tNReverb_setT60+0x68>
    if (t60 <= 0.0f)           t60 = 0.001f;
 8025796:	ed9f 0a03 	vldr	s0, [pc, #12]	; 80257a4 <tNReverb_setT60+0x6c>
 802579a:	e7da      	b.n	8025752 <tNReverb_setT60+0x1a>
 802579c:	200194e8 	.word	0x200194e8
 80257a0:	4479ffff 	.word	0x4479ffff
 80257a4:	3a83126f 	.word	0x3a83126f

080257a8 <tNReverb_setMix>:

void    tNReverb_setMix(tNReverb* const rev, float mix)
{
    _tNReverb* r = *rev;
 80257a8:	6803      	ldr	r3, [r0, #0]
    r->mix = mix;
 80257aa:	ed83 0a01 	vstr	s0, [r3, #4]
}
 80257ae:	4770      	bx	lr

080257b0 <tNReverb_tickStereo>:

    return out;
}

void   tNReverb_tickStereo(tNReverb* const rev, float input, float* output)
{
 80257b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80257b4:	ed2d 8b06 	vpush	{d8-d10}
    _tNReverb* r = *rev;
 80257b8:	6805      	ldr	r5, [r0, #0]
{
 80257ba:	eeb0 9a40 	vmov.f32	s18, s0
 80257be:	4688      	mov	r8, r1
    r->lastIn = input;

    float temp, temp0, temp1, temp2, temp3, out;
    int i;

    temp0 = 0.0;
 80257c0:	ed9f 8a4c 	vldr	s16, [pc, #304]	; 80258f4 <tNReverb_tickStereo+0x144>
 80257c4:	f105 0450 	add.w	r4, r5, #80	; 0x50
 80257c8:	f105 0768 	add.w	r7, r5, #104	; 0x68
    r->lastIn = input;
 80257cc:	ed85 0a1b 	vstr	s0, [r5, #108]	; 0x6c
 80257d0:	f1a4 061c 	sub.w	r6, r4, #28
    for ( i=0; i<6; i++ )
    {
        temp = input + (r->combCoeffs[i] * tLinearDelay_getLastOut(&r->combDelays[i]));
 80257d4:	ecf4 8a01 	vldmia	r4!, {s17}
 80257d8:	4630      	mov	r0, r6
 80257da:	f7f9 ffa5 	bl	801f728 <tLinearDelay_getLastOut>
        temp0 += tLinearDelay_tick(&r->combDelays[i],temp);
 80257de:	eef0 7a49 	vmov.f32	s15, s18
 80257e2:	4630      	mov	r0, r6
 80257e4:	eee8 7a80 	vfma.f32	s15, s17, s0
 80257e8:	eeb0 0a67 	vmov.f32	s0, s15
 80257ec:	f7f9 fee0 	bl	801f5b0 <tLinearDelay_tick>
    for ( i=0; i<6; i++ )
 80257f0:	42bc      	cmp	r4, r7
        temp0 += tLinearDelay_tick(&r->combDelays[i],temp);
 80257f2:	ee38 8a00 	vadd.f32	s16, s16, s0
    for ( i=0; i<6; i++ )
 80257f6:	d1eb      	bne.n	80257d0 <tNReverb_tickStereo+0x20>
 80257f8:	f105 0414 	add.w	r4, r5, #20
 80257fc:	f105 0620 	add.w	r6, r5, #32
    }

    for ( i=0; i<3; i++ )
    {
        temp = tLinearDelay_getLastOut(&r->allpassDelays[i]);
 8025800:	4620      	mov	r0, r4
 8025802:	f7f9 ff91 	bl	801f728 <tLinearDelay_getLastOut>
        temp1 = r->allpassCoeff * temp;
        temp1 += temp0;
 8025806:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
        temp = tLinearDelay_getLastOut(&r->allpassDelays[i]);
 802580a:	eef0 8a40 	vmov.f32	s17, s0
        tLinearDelay_tick(&r->allpassDelays[i], temp1);
 802580e:	4620      	mov	r0, r4
        temp1 += temp0;
 8025810:	eea7 8a80 	vfma.f32	s16, s15, s0
 8025814:	3404      	adds	r4, #4
        tLinearDelay_tick(&r->allpassDelays[i], temp1);
 8025816:	eeb0 0a48 	vmov.f32	s0, s16
 802581a:	f7f9 fec9 	bl	801f5b0 <tLinearDelay_tick>
        temp0 = -(r->allpassCoeff * temp1) + temp;
 802581e:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    for ( i=0; i<3; i++ )
 8025822:	42a6      	cmp	r6, r4
        temp0 = -(r->allpassCoeff * temp1) + temp;
 8025824:	eee7 8ac8 	vfms.f32	s17, s15, s16
 8025828:	eeb0 8a68 	vmov.f32	s16, s17
    for ( i=0; i<3; i++ )
 802582c:	d1e8      	bne.n	8025800 <tNReverb_tickStereo+0x50>
    }

    // One-pole lowpass filter.
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
 802582e:	eddf 7a32 	vldr	s15, [pc, #200]	; 80258f8 <tNReverb_tickStereo+0x148>

    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
 8025832:	4630      	mov	r0, r6
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
 8025834:	ed95 7a1a 	vldr	s14, [r5, #104]	; 0x68
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
    temp1 = -(r->allpassCoeff * temp1) + temp;

    float drymix = ( 1.0f - r->mix ) * input;

    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
 8025838:	f105 0724 	add.w	r7, r5, #36	; 0x24
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
 802583c:	ee28 8aa7 	vmul.f32	s16, s17, s15
 8025840:	eddf 7a2e 	vldr	s15, [pc, #184]	; 80258fc <tNReverb_tickStereo+0x14c>
    float drymix = ( 1.0f - r->mix ) * input;
 8025844:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
    out = output[0];


    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
 8025848:	f105 0428 	add.w	r4, r5, #40	; 0x28
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
 802584c:	eea7 8a27 	vfma.f32	s16, s14, s15
 8025850:	ed85 8a1a 	vstr	s16, [r5, #104]	; 0x68
    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
 8025854:	f7f9 ff68 	bl	801f728 <tLinearDelay_getLastOut>
    temp1 += r->lowpassState;
 8025858:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
 802585c:	ed95 8a1a 	vldr	s16, [r5, #104]	; 0x68
    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
 8025860:	eef0 8a40 	vmov.f32	s17, s0
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
 8025864:	4630      	mov	r0, r6
    temp1 += r->lowpassState;
 8025866:	eea7 8a80 	vfma.f32	s16, s15, s0
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
 802586a:	eeb0 0a48 	vmov.f32	s0, s16
 802586e:	f7f9 fe9f 	bl	801f5b0 <tLinearDelay_tick>
    temp1 = -(r->allpassCoeff * temp1) + temp;
 8025872:	ed95 7a13 	vldr	s14, [r5, #76]	; 0x4c
    float drymix = ( 1.0f - r->mix ) * input;
 8025876:	edd5 7a01 	vldr	s15, [r5, #4]
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
 802587a:	4638      	mov	r0, r7
    temp1 = -(r->allpassCoeff * temp1) + temp;
 802587c:	eee7 8a48 	vfms.f32	s17, s14, s16
    float drymix = ( 1.0f - r->mix ) * input;
 8025880:	ee3a aa67 	vsub.f32	s20, s20, s15
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
 8025884:	f7f9 ff50 	bl	801f728 <tLinearDelay_getLastOut>
    temp2 += temp1;
 8025888:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
 802588c:	eef0 9a40 	vmov.f32	s19, s0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
 8025890:	4638      	mov	r0, r7
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
 8025892:	eeea 9a09 	vfma.f32	s19, s20, s18
    temp2 += temp1;
 8025896:	eeb0 8a68 	vmov.f32	s16, s17
 802589a:	eea7 8a80 	vfma.f32	s16, s15, s0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
 802589e:	eeb0 0a48 	vmov.f32	s0, s16
 80258a2:	f7f9 fe85 	bl	801f5b0 <tLinearDelay_tick>
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
 80258a6:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
 80258aa:	4620      	mov	r0, r4
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
 80258ac:	eee7 9ac8 	vfms.f32	s19, s15, s16
 80258b0:	edc8 9a00 	vstr	s19, [r8]
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
 80258b4:	f7f9 ff38 	bl	801f728 <tLinearDelay_getLastOut>
    temp3 = r->allpassCoeff * temp;
    temp3 += temp1;
 80258b8:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
 80258bc:	eeb0 8a40 	vmov.f32	s16, s0
    tLinearDelay_tick(&r->allpassDelays[5], temp3 );
 80258c0:	4620      	mov	r0, r4
    temp3 += temp1;
 80258c2:	eee7 8a80 	vfma.f32	s17, s15, s0
    output[1] = r->mix *( - ( r->allpassCoeff * temp3 ) + temp + drymix);
 80258c6:	eeaa 8a09 	vfma.f32	s16, s20, s18
    tLinearDelay_tick(&r->allpassDelays[5], temp3 );
 80258ca:	eeb0 0a68 	vmov.f32	s0, s17
 80258ce:	f7f9 fe6f 	bl	801f5b0 <tLinearDelay_tick>
    output[1] = r->mix *( - ( r->allpassCoeff * temp3 ) + temp + drymix);
 80258d2:	ed95 7a13 	vldr	s14, [r5, #76]	; 0x4c
 80258d6:	edd5 7a01 	vldr	s15, [r5, #4]
 80258da:	eea7 8a68 	vfms.f32	s16, s14, s17
 80258de:	ee28 8a27 	vmul.f32	s16, s16, s15
 80258e2:	ed88 8a01 	vstr	s16, [r8, #4]

    r->lastOut = out;
 80258e6:	edc5 9a1c 	vstr	s19, [r5, #112]	; 0x70
}
 80258ea:	ecbd 8b06 	vpop	{d8-d10}
 80258ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80258f2:	bf00      	nop
 80258f4:	00000000 	.word	0x00000000
 80258f8:	3e99999a 	.word	0x3e99999a
 80258fc:	3f333333 	.word	0x3f333333

08025900 <tDattorroReverb_initToPool>:
{
    tDattorroReverb_initToPool(rev, &leaf.mempool);
}

void    tDattorroReverb_initToPool        (tDattorroReverb* const rev, tMempool* const mp)
{
 8025900:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8025904:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
 8025908:	680d      	ldr	r5, [r1, #0]
{
 802590a:	460e      	mov	r6, r1
 802590c:	4681      	mov	r9, r0
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
 802590e:	2088      	movs	r0, #136	; 0x88
 8025910:	4629      	mov	r1, r5
    r->mempool = m;
    
    r->size_max = 2.0f;
    r->size = 1.f;
 8025912:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
 8025916:	f7fe fccf 	bl	80242b8 <mpool_alloc>
    r->t = r->size * leaf.sampleRate * 0.001f;
 802591a:	4ac4      	ldr	r2, [pc, #784]	; (8025c2c <tDattorroReverb_initToPool+0x32c>)
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
 802591c:	f8c9 0000 	str.w	r0, [r9]
 8025920:	4604      	mov	r4, r0
    r->mempool = m;
 8025922:	6005      	str	r5, [r0, #0]
    r->size_max = 2.0f;
 8025924:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    r->t = r->size * leaf.sampleRate * 0.001f;
 8025928:	edd2 7a00 	vldr	s15, [r2]
    r->frozen = 0;
 802592c:	2300      	movs	r3, #0
    r->t = r->size * leaf.sampleRate * 0.001f;
 802592e:	eddf 6ac0 	vldr	s13, [pc, #768]	; 8025c30 <tDattorroReverb_initToPool+0x330>
    // INPUT
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
 8025932:	3038      	adds	r0, #56	; 0x38
 8025934:	ed9f 7abf 	vldr	s14, [pc, #764]	; 8025c34 <tDattorroReverb_initToPool+0x334>
 8025938:	4632      	mov	r2, r6
    r->t = r->size * leaf.sampleRate * 0.001f;
 802593a:	ee67 7aa6 	vmul.f32	s15, s15, s13
    r->size_max = 2.0f;
 802593e:	f840 1c18 	str.w	r1, [r0, #-24]
    r->frozen = 0;
 8025942:	f840 3c20 	str.w	r3, [r0, #-32]
    tOnePole_initToPool(&r->in_filter, 1.f, mp);
    
    for (int i = 0; i < 4; i++)
    {
        tAllpass_initToPool(&r->in_allpass[i], SAMP(in_allpass_delays[i]), SAMP(20.f), mp); // * r->size_max
 8025946:	eeb3 8a04 	vmov.f32	s16, #52	; 0x41a00000  20.0
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
 802594a:	ed9f 0abb 	vldr	s0, [pc, #748]	; 8025c38 <tDattorroReverb_initToPool+0x338>
 802594e:	f104 0540 	add.w	r5, r4, #64	; 0x40
 8025952:	ee27 7a87 	vmul.f32	s14, s15, s14
    r->t = r->size * leaf.sampleRate * 0.001f;
 8025956:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
    r->size = 1.f;
 802595a:	edc4 8a07 	vstr	s17, [r4, #28]
 802595e:	f104 0a50 	add.w	sl, r4, #80	; 0x50
 8025962:	f8df 831c 	ldr.w	r8, [pc, #796]	; 8025c80 <tDattorroReverb_initToPool+0x380>
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
 8025966:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 802596a:	4fb4      	ldr	r7, [pc, #720]	; (8025c3c <tDattorroReverb_initToPool+0x33c>)
 802596c:	ee17 1a90 	vmov	r1, s15
 8025970:	f7f9 fede 	bl	801f730 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->in_filter, 1.f, mp);
 8025974:	4631      	mov	r1, r6
 8025976:	eeb0 0a68 	vmov.f32	s0, s17
 802597a:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 802597e:	f7fc fed5 	bl	802272c <tOnePole_initToPool>
        tAllpass_initToPool(&r->in_allpass[i], SAMP(in_allpass_delays[i]), SAMP(20.f), mp); // * r->size_max
 8025982:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8025986:	4628      	mov	r0, r5
 8025988:	ecb8 0a01 	vldmia	r8!, {s0}
 802598c:	4632      	mov	r2, r6
 802598e:	ee27 7a88 	vmul.f32	s14, s15, s16
 8025992:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025996:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 802599a:	ee17 1a90 	vmov	r1, s15
 802599e:	f7fc fe75 	bl	802268c <tAllpass_initToPool>
        tAllpass_setGain(&r->in_allpass[i], in_allpass_gains[i]);
 80259a2:	4628      	mov	r0, r5
 80259a4:	3504      	adds	r5, #4
 80259a6:	ecb7 0a01 	vldmia	r7!, {s0}
 80259aa:	f7fc fea1 	bl	80226f0 <tAllpass_setGain>
    for (int i = 0; i < 4; i++)
 80259ae:	4555      	cmp	r5, sl
 80259b0:	d1e7      	bne.n	8025982 <tDattorroReverb_initToPool+0x82>
    }
    
    // FEEDBACK 1
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
 80259b2:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 80259b6:	4632      	mov	r2, r6
 80259b8:	ed9f 9aa1 	vldr	s18, [pc, #644]	; 8025c40 <tDattorroReverb_initToPool+0x340>
 80259bc:	4628      	mov	r0, r5
 80259be:	ed9f 0aa1 	vldr	s0, [pc, #644]	; 8025c44 <tDattorroReverb_initToPool+0x344>
    tAllpass_setGain(&r->f1_allpass, 0.7f);
    
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
 80259c2:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
 80259c6:	ee27 7a89 	vmul.f32	s14, s15, s18
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
 80259ca:	eddf 8a9a 	vldr	s17, [pc, #616]	; 8025c34 <tDattorroReverb_initToPool+0x334>
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
 80259ce:	ee27 0a80 	vmul.f32	s0, s15, s0
    
    tOnePole_initToPool(&r->f1_filter, 1.f, mp);
    
    tHighpass_initToPool(&r->f1_hp, 20.f, mp);
    
    tCycle_initToPool(&r->f1_lfo, mp);
 80259d2:	f104 0868 	add.w	r8, r4, #104	; 0x68
    tCycle_setFreq(&r->f1_lfo, 0.1f);
    
    // FEEDBACK 2
    tAllpass_initToPool(&r->f2_allpass, SAMP(22.58f), SAMP(100.f), mp); // * r->size_max
 80259d6:	f104 076c 	add.w	r7, r4, #108	; 0x6c
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
 80259da:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 80259de:	ee17 1a90 	vmov	r1, s15
 80259e2:	f7fc fe53 	bl	802268c <tAllpass_initToPool>
    tAllpass_setGain(&r->f1_allpass, 0.7f);
 80259e6:	4628      	mov	r0, r5
 80259e8:	ed9f 0a97 	vldr	s0, [pc, #604]	; 8025c48 <tDattorroReverb_initToPool+0x348>
    
    tOnePole_initToPool(&r->f2_filter, 1.f, mp);
    
    tHighpass_initToPool(&r->f2_hp, 20.f, mp);
    
    tCycle_initToPool(&r->f2_lfo, mp);
 80259ec:	f104 0584 	add.w	r5, r4, #132	; 0x84
    tAllpass_setGain(&r->f1_allpass, 0.7f);
 80259f0:	f7fc fe7e 	bl	80226f0 <tAllpass_setGain>
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
 80259f4:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 80259f8:	edd4 7a08 	vldr	s15, [r4, #32]
 80259fc:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8025a00:	ed9f 0a92 	vldr	s0, [pc, #584]	; 8025c4c <tDattorroReverb_initToPool+0x34c>
 8025a04:	4632      	mov	r2, r6
 8025a06:	ee67 7a27 	vmul.f32	s15, s14, s15
 8025a0a:	ee27 0a00 	vmul.f32	s0, s14, s0
 8025a0e:	eeb0 7a48 	vmov.f32	s14, s16
 8025a12:	eea7 7aa8 	vfma.f32	s14, s15, s17
 8025a16:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025a1a:	ee17 1a90 	vmov	r1, s15
 8025a1e:	f7f9 fe87 	bl	801f730 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f1_delay_2, SAMP(89.24f), SAMP(100.0f) * r->size_max + 1, mp);
 8025a22:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025a26:	edd4 7a08 	vldr	s15, [r4, #32]
 8025a2a:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8025a2e:	ed9f 0a88 	vldr	s0, [pc, #544]	; 8025c50 <tDattorroReverb_initToPool+0x350>
 8025a32:	4632      	mov	r2, r6
 8025a34:	ee67 7a27 	vmul.f32	s15, s14, s15
 8025a38:	ee27 0a00 	vmul.f32	s0, s14, s0
 8025a3c:	eeb0 7a48 	vmov.f32	s14, s16
 8025a40:	eea7 7a89 	vfma.f32	s14, s15, s18
 8025a44:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025a48:	ee17 1a90 	vmov	r1, s15
 8025a4c:	f7f9 fe70 	bl	801f730 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f1_delay_3, SAMP(125.f), SAMP(200.0f) * r->size_max + 1, mp);
 8025a50:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025a54:	edd4 7a08 	vldr	s15, [r4, #32]
 8025a58:	4632      	mov	r2, r6
 8025a5a:	ed9f 0a7e 	vldr	s0, [pc, #504]	; 8025c54 <tDattorroReverb_initToPool+0x354>
 8025a5e:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8025a62:	ee67 7a27 	vmul.f32	s15, s14, s15
 8025a66:	ee27 0a00 	vmul.f32	s0, s14, s0
 8025a6a:	eeb0 7a48 	vmov.f32	s14, s16
 8025a6e:	eea7 7aa8 	vfma.f32	s14, s15, s17
 8025a72:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025a76:	ee17 1a90 	vmov	r1, s15
 8025a7a:	f7f9 fe59 	bl	801f730 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->f1_filter, 1.f, mp);
 8025a7e:	eeb0 0a48 	vmov.f32	s0, s16
 8025a82:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8025a86:	4631      	mov	r1, r6
 8025a88:	f7fc fe50 	bl	802272c <tOnePole_initToPool>
    tHighpass_initToPool(&r->f1_hp, 20.f, mp);
 8025a8c:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8025a90:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8025a94:	4631      	mov	r1, r6
 8025a96:	f7fd f885 	bl	8022ba4 <tHighpass_initToPool>
    tCycle_initToPool(&r->f1_lfo, mp);
 8025a9a:	4631      	mov	r1, r6
 8025a9c:	4640      	mov	r0, r8
 8025a9e:	f7ff f8db 	bl	8024c58 <tCycle_initToPool>
    tCycle_setFreq(&r->f1_lfo, 0.1f);
 8025aa2:	4640      	mov	r0, r8
 8025aa4:	ed9f 0a6c 	vldr	s0, [pc, #432]	; 8025c58 <tDattorroReverb_initToPool+0x358>
 8025aa8:	f7ff f8e8 	bl	8024c7c <tCycle_setFreq>
    tAllpass_initToPool(&r->f2_allpass, SAMP(22.58f), SAMP(100.f), mp); // * r->size_max
 8025aac:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8025ab0:	ed9f 0a6a 	vldr	s0, [pc, #424]	; 8025c5c <tDattorroReverb_initToPool+0x35c>
 8025ab4:	4632      	mov	r2, r6
 8025ab6:	ee27 7a89 	vmul.f32	s14, s15, s18
 8025aba:	4638      	mov	r0, r7
 8025abc:	ee27 0a80 	vmul.f32	s0, s15, s0
 8025ac0:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025ac4:	ee17 1a90 	vmov	r1, s15
 8025ac8:	f7fc fde0 	bl	802268c <tAllpass_initToPool>
    tAllpass_setGain(&r->f2_allpass, 0.7f);
 8025acc:	4638      	mov	r0, r7
 8025ace:	ed9f 0a5e 	vldr	s0, [pc, #376]	; 8025c48 <tDattorroReverb_initToPool+0x348>
 8025ad2:	f7fc fe0d 	bl	80226f0 <tAllpass_setGain>
    tTapeDelay_initToPool(&r->f2_delay_1, SAMP(149.62f), SAMP(200.f) * r->size_max + 1, mp);
 8025ad6:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025ada:	edd4 7a08 	vldr	s15, [r4, #32]
 8025ade:	f104 0070 	add.w	r0, r4, #112	; 0x70
 8025ae2:	ed9f 0a5f 	vldr	s0, [pc, #380]	; 8025c60 <tDattorroReverb_initToPool+0x360>
 8025ae6:	4632      	mov	r2, r6
 8025ae8:	ee67 7a27 	vmul.f32	s15, s14, s15
 8025aec:	ee27 0a00 	vmul.f32	s0, s14, s0
 8025af0:	eeb0 7a48 	vmov.f32	s14, s16
 8025af4:	eea7 7aa8 	vfma.f32	s14, s15, s17
 8025af8:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025afc:	ee17 1a90 	vmov	r1, s15
 8025b00:	f7f9 fe16 	bl	801f730 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f2_delay_2, SAMP(60.48f), SAMP(100.f) * r->size_max + 1, mp);
 8025b04:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025b08:	edd4 7a08 	vldr	s15, [r4, #32]
 8025b0c:	f104 0078 	add.w	r0, r4, #120	; 0x78
 8025b10:	ed9f 0a54 	vldr	s0, [pc, #336]	; 8025c64 <tDattorroReverb_initToPool+0x364>
 8025b14:	4632      	mov	r2, r6
 8025b16:	ee67 7a27 	vmul.f32	s15, s14, s15
 8025b1a:	ee27 0a00 	vmul.f32	s0, s14, s0
 8025b1e:	eeb0 7a48 	vmov.f32	s14, s16
 8025b22:	eea7 7a89 	vfma.f32	s14, s15, s18
 8025b26:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025b2a:	ee17 1a90 	vmov	r1, s15
 8025b2e:	f7f9 fdff 	bl	801f730 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f2_delay_3, SAMP(106.28f), SAMP(200.f) * r->size_max + 1, mp);
 8025b32:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025b36:	edd4 7a08 	vldr	s15, [r4, #32]
 8025b3a:	4632      	mov	r2, r6
 8025b3c:	ed9f 0a4a 	vldr	s0, [pc, #296]	; 8025c68 <tDattorroReverb_initToPool+0x368>
 8025b40:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 8025b44:	ee67 7a27 	vmul.f32	s15, s14, s15
 8025b48:	ee27 0a00 	vmul.f32	s0, s14, s0
 8025b4c:	eeb0 7a48 	vmov.f32	s14, s16
 8025b50:	eea7 7aa8 	vfma.f32	s14, s15, s17
 8025b54:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025b58:	ee17 1a90 	vmov	r1, s15
 8025b5c:	f7f9 fde8 	bl	801f730 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->f2_filter, 1.f, mp);
 8025b60:	eeb0 0a48 	vmov.f32	s0, s16
 8025b64:	f104 0074 	add.w	r0, r4, #116	; 0x74
 8025b68:	4631      	mov	r1, r6
 8025b6a:	f7fc fddf 	bl	802272c <tOnePole_initToPool>
    tHighpass_initToPool(&r->f2_hp, 20.f, mp);
 8025b6e:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8025b72:	f104 0080 	add.w	r0, r4, #128	; 0x80
 8025b76:	4631      	mov	r1, r6
 8025b78:	f7fd f814 	bl	8022ba4 <tHighpass_initToPool>
    tCycle_initToPool(&r->f2_lfo, mp);
 8025b7c:	4631      	mov	r1, r6
 8025b7e:	4628      	mov	r0, r5
 8025b80:	f7ff f86a 	bl	8024c58 <tCycle_initToPool>
    tCycle_setFreq(&r->f2_lfo, 0.07f);
 8025b84:	4628      	mov	r0, r5
 8025b86:	ed9f 0a39 	vldr	s0, [pc, #228]	; 8025c6c <tDattorroReverb_initToPool+0x36c>
 8025b8a:	f7ff f877 	bl	8024c7c <tCycle_setFreq>
}

void    tDattorroReverb_setMix            (tDattorroReverb* const rev, float mix)
{
    _tDattorroReverb* r = *rev;
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
 8025b8e:	eeb0 1a48 	vmov.f32	s2, s16
    _tDattorroReverb* r = *rev;
 8025b92:	f8d9 4000 	ldr.w	r4, [r9]
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
 8025b96:	eef6 0a00 	vmov.f32	s1, #96	; 0x3f000000  0.5
 8025b9a:	ed9f 0a27 	vldr	s0, [pc, #156]	; 8025c38 <tDattorroReverb_initToPool+0x338>
 8025b9e:	f7fe f989 	bl	8023eb4 <LEAF_clip>

void    tDattorroReverb_setInputDelay     (tDattorroReverb* const rev, float preDelay)
{
    _tDattorroReverb* r = *rev;
    
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
 8025ba2:	eddf 0a25 	vldr	s1, [pc, #148]	; 8025c38 <tDattorroReverb_initToPool+0x338>
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
 8025ba6:	ed84 0a05 	vstr	s0, [r4, #20]
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
 8025baa:	eeb0 1a68 	vmov.f32	s2, s17
    _tDattorroReverb* r = *rev;
 8025bae:	f8d9 4000 	ldr.w	r4, [r9]
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
 8025bb2:	eeb0 0a60 	vmov.f32	s0, s1
 8025bb6:	f7fe f97d 	bl	8023eb4 <LEAF_clip>
    
    tTapeDelay_setDelay(&r->in_delay, SAMP(r->predelay));
 8025bba:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8025bbe:	f104 0038 	add.w	r0, r4, #56	; 0x38
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
 8025bc2:	ed84 0a01 	vstr	s0, [r4, #4]
    tTapeDelay_setDelay(&r->in_delay, SAMP(r->predelay));
 8025bc6:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025bca:	f7f9 fe65 	bl	801f898 <tTapeDelay_setDelay>
}

void    tDattorroReverb_setInputFilter    (tDattorroReverb* const rev, float freq)
{
    _tDattorroReverb* r = *rev;
 8025bce:	f8d9 4000 	ldr.w	r4, [r9]
    
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8025bd2:	ed9f 1a27 	vldr	s2, [pc, #156]	; 8025c70 <tDattorroReverb_initToPool+0x370>
 8025bd6:	eddf 0a27 	vldr	s1, [pc, #156]	; 8025c74 <tDattorroReverb_initToPool+0x374>
 8025bda:	ed9f 0a17 	vldr	s0, [pc, #92]	; 8025c38 <tDattorroReverb_initToPool+0x338>
 8025bde:	f7fe f969 	bl	8023eb4 <LEAF_clip>
    
    tOnePole_setFreq(&r->in_filter, r->input_filter);
 8025be2:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8025be6:	ed84 0a02 	vstr	s0, [r4, #8]
    tOnePole_setFreq(&r->in_filter, r->input_filter);
 8025bea:	f7fc fdd9 	bl	80227a0 <tOnePole_setFreq>
}

void    tDattorroReverb_setFeedbackFilter (tDattorroReverb* const rev, float freq)
{
    _tDattorroReverb* r = *rev;
 8025bee:	f8d9 4000 	ldr.w	r4, [r9]
    
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8025bf2:	ed9f 1a1f 	vldr	s2, [pc, #124]	; 8025c70 <tDattorroReverb_initToPool+0x370>
 8025bf6:	eddf 0a20 	vldr	s1, [pc, #128]	; 8025c78 <tDattorroReverb_initToPool+0x378>
 8025bfa:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 8025c38 <tDattorroReverb_initToPool+0x338>
 8025bfe:	f7fe f959 	bl	8023eb4 <LEAF_clip>
    
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
 8025c02:	f104 0058 	add.w	r0, r4, #88	; 0x58
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8025c06:	ed84 0a03 	vstr	s0, [r4, #12]
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
 8025c0a:	f7fc fdc9 	bl	80227a0 <tOnePole_setFreq>
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
 8025c0e:	ed94 0a03 	vldr	s0, [r4, #12]
 8025c12:	f104 0074 	add.w	r0, r4, #116	; 0x74
 8025c16:	f7fc fdc3 	bl	80227a0 <tOnePole_setFreq>
}

void    tDattorroReverb_setFeedbackGain   (tDattorroReverb* const rev, float gain)
{
    _tDattorroReverb* r = *rev;
 8025c1a:	f8d9 3000 	ldr.w	r3, [r9]
    r->feedback_gain = gain;
 8025c1e:	4a17      	ldr	r2, [pc, #92]	; (8025c7c <tDattorroReverb_initToPool+0x37c>)
 8025c20:	611a      	str	r2, [r3, #16]
}
 8025c22:	ecbd 8b04 	vpop	{d8-d9}
 8025c26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8025c2a:	bf00      	nop
 8025c2c:	200194e8 	.word	0x200194e8
 8025c30:	3a83126f 	.word	0x3a83126f
 8025c34:	43480000 	.word	0x43480000
 8025c38:	00000000 	.word	0x00000000
 8025c3c:	200003b0 	.word	0x200003b0
 8025c40:	42c80000 	.word	0x42c80000
 8025c44:	41f4147b 	.word	0x41f4147b
 8025c48:	3f333333 	.word	0x3f333333
 8025c4c:	430db0a4 	.word	0x430db0a4
 8025c50:	42b27ae1 	.word	0x42b27ae1
 8025c54:	42fa0000 	.word	0x42fa0000
 8025c58:	3dcccccd 	.word	0x3dcccccd
 8025c5c:	41b4a3d7 	.word	0x41b4a3d7
 8025c60:	43159eb8 	.word	0x43159eb8
 8025c64:	4271eb85 	.word	0x4271eb85
 8025c68:	42d48f5c 	.word	0x42d48f5c
 8025c6c:	3d8f5c29 	.word	0x3d8f5c29
 8025c70:	469c4000 	.word	0x469c4000
 8025c74:	461c4000 	.word	0x461c4000
 8025c78:	459c4000 	.word	0x459c4000
 8025c7c:	3ecccccd 	.word	0x3ecccccd
 8025c80:	200003a0 	.word	0x200003a0

08025c84 <tDattorroReverb_free>:
{
 8025c84:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
 8025c86:	6804      	ldr	r4, [r0, #0]
    tTapeDelay_free(&r->in_delay);
 8025c88:	f104 0038 	add.w	r0, r4, #56	; 0x38
 8025c8c:	f7f9 fd82 	bl	801f794 <tTapeDelay_free>
    tOnePole_free(&r->in_filter);
 8025c90:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 8025c94:	f7fc fd80 	bl	8022798 <tOnePole_free>
        tAllpass_free(&r->in_allpass[i]);
 8025c98:	f104 0040 	add.w	r0, r4, #64	; 0x40
 8025c9c:	f7fc fd18 	bl	80226d0 <tAllpass_free>
 8025ca0:	f104 0044 	add.w	r0, r4, #68	; 0x44
 8025ca4:	f7fc fd14 	bl	80226d0 <tAllpass_free>
 8025ca8:	f104 0048 	add.w	r0, r4, #72	; 0x48
 8025cac:	f7fc fd10 	bl	80226d0 <tAllpass_free>
 8025cb0:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 8025cb4:	f7fc fd0c 	bl	80226d0 <tAllpass_free>
    tAllpass_free(&r->f1_allpass);
 8025cb8:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8025cbc:	f7fc fd08 	bl	80226d0 <tAllpass_free>
    tTapeDelay_free(&r->f1_delay_1);
 8025cc0:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8025cc4:	f7f9 fd66 	bl	801f794 <tTapeDelay_free>
    tTapeDelay_free(&r->f1_delay_2);
 8025cc8:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8025ccc:	f7f9 fd62 	bl	801f794 <tTapeDelay_free>
    tTapeDelay_free(&r->f1_delay_3);
 8025cd0:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8025cd4:	f7f9 fd5e 	bl	801f794 <tTapeDelay_free>
    tOnePole_free(&r->f1_filter);
 8025cd8:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8025cdc:	f7fc fd5c 	bl	8022798 <tOnePole_free>
    tHighpass_free(&r->f1_hp);
 8025ce0:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8025ce4:	f7fc ff7e 	bl	8022be4 <tHighpass_free>
    tCycle_free(&r->f1_lfo);
 8025ce8:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8025cec:	f7fe ffc2 	bl	8024c74 <tCycle_free>
    tAllpass_free(&r->f2_allpass);
 8025cf0:	f104 006c 	add.w	r0, r4, #108	; 0x6c
 8025cf4:	f7fc fcec 	bl	80226d0 <tAllpass_free>
    tTapeDelay_free(&r->f2_delay_1);
 8025cf8:	f104 0070 	add.w	r0, r4, #112	; 0x70
 8025cfc:	f7f9 fd4a 	bl	801f794 <tTapeDelay_free>
    tTapeDelay_free(&r->f2_delay_2);
 8025d00:	f104 0078 	add.w	r0, r4, #120	; 0x78
 8025d04:	f7f9 fd46 	bl	801f794 <tTapeDelay_free>
    tTapeDelay_free(&r->f2_delay_3);
 8025d08:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 8025d0c:	f7f9 fd42 	bl	801f794 <tTapeDelay_free>
    tOnePole_free(&r->f2_filter);
 8025d10:	f104 0074 	add.w	r0, r4, #116	; 0x74
 8025d14:	f7fc fd40 	bl	8022798 <tOnePole_free>
    tHighpass_free(&r->f2_hp);
 8025d18:	f104 0080 	add.w	r0, r4, #128	; 0x80
 8025d1c:	f7fc ff62 	bl	8022be4 <tHighpass_free>
    tCycle_free(&r->f2_lfo);
 8025d20:	f104 0084 	add.w	r0, r4, #132	; 0x84
 8025d24:	f7fe ffa6 	bl	8024c74 <tCycle_free>
    mpool_free((char*)r, r->mempool);
 8025d28:	6821      	ldr	r1, [r4, #0]
 8025d2a:	4620      	mov	r0, r4
}
 8025d2c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)r, r->mempool);
 8025d30:	f7fe bb76 	b.w	8024420 <mpool_free>

08025d34 <tDattorroReverb_tickStereo>:
{
 8025d34:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025d38:	ed2d 8b06 	vpush	{d8-d10}
    _tDattorroReverb* r = *rev;
 8025d3c:	6804      	ldr	r4, [r0, #0]
{
 8025d3e:	468a      	mov	sl, r1
        input = 0.0f;
 8025d40:	eddf 9abf 	vldr	s19, [pc, #764]	; 8026040 <tDattorroReverb_tickStereo+0x30c>
    if (r->frozen)
 8025d44:	69a3      	ldr	r3, [r4, #24]
    in_sample = tTapeDelay_tick(&r->in_delay, input);
 8025d46:	f104 0038 	add.w	r0, r4, #56	; 0x38
 8025d4a:	f104 0540 	add.w	r5, r4, #64	; 0x40
 8025d4e:	f104 0650 	add.w	r6, r4, #80	; 0x50
        input = 0.0f;
 8025d52:	2b00      	cmp	r3, #0
 8025d54:	fe40 9a29 	vseleq.f32	s19, s0, s19
    in_sample = tTapeDelay_tick(&r->in_delay, input);
 8025d58:	eeb0 0a69 	vmov.f32	s0, s19
 8025d5c:	f7f9 fd26 	bl	801f7ac <tTapeDelay_tick>
    in_sample = tOnePole_tick(&r->in_filter, in_sample);
 8025d60:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 8025d64:	f7fc fd38 	bl	80227d8 <tOnePole_tick>
 8025d68:	eeb0 8a40 	vmov.f32	s16, s0
        in_sample = tAllpass_tick(&r->in_allpass[i], in_sample);
 8025d6c:	4628      	mov	r0, r5
 8025d6e:	3504      	adds	r5, #4
 8025d70:	eeb0 0a48 	vmov.f32	s0, s16
 8025d74:	f7fc fcc0 	bl	80226f8 <tAllpass_tick>
    for (int i = 0; i < 4; i++)
 8025d78:	42b5      	cmp	r5, r6
        in_sample = tAllpass_tick(&r->in_allpass[i], in_sample);
 8025d7a:	eeb0 8a40 	vmov.f32	s16, s0
    for (int i = 0; i < 4; i++)
 8025d7e:	d1f5      	bne.n	8025d6c <tDattorroReverb_tickStereo+0x38>
        f1_sample = in_sample + r->f2_last; // + f2_last_out;
 8025d80:	edd4 8a0d 	vldr	s17, [r4, #52]	; 0x34
        tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
 8025d84:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8025d88:	ed94 9a09 	vldr	s18, [r4, #36]	; 0x24
        f1_sample = tTapeDelay_tick(&r->f1_delay_1, f1_sample);
 8025d8c:	f104 0654 	add.w	r6, r4, #84	; 0x54
        f1_sample = in_sample + r->f2_last; // + f2_last_out;
 8025d90:	ee70 8a28 	vadd.f32	s17, s0, s17
        tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
 8025d94:	f7fe ff80 	bl	8024c98 <tCycle_tick>
 8025d98:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 8025d9c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8025da0:	ed9f 7aa8 	vldr	s14, [pc, #672]	; 8026044 <tDattorroReverb_tickStereo+0x310>
 8025da4:	4628      	mov	r0, r5
        f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
 8025da6:	f104 095c 	add.w	r9, r4, #92	; 0x5c
        tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
 8025daa:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8025dae:	ee27 0a80 	vmul.f32	s0, s15, s0
 8025db2:	eea9 0a07 	vfma.f32	s0, s18, s14
 8025db6:	f7fc fc97 	bl	80226e8 <tAllpass_setDelay>
        f1_sample = tAllpass_tick(&r->f1_allpass, f1_sample);
 8025dba:	eeb0 0a68 	vmov.f32	s0, s17
 8025dbe:	4628      	mov	r0, r5
 8025dc0:	f7fc fc9a 	bl	80226f8 <tAllpass_tick>
        f1_sample = tTapeDelay_tick(&r->f1_delay_1, f1_sample);
 8025dc4:	4630      	mov	r0, r6
 8025dc6:	f7f9 fcf1 	bl	801f7ac <tTapeDelay_tick>
        f1_sample = tOnePole_tick(&r->f1_filter, f1_sample);
 8025dca:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8025dce:	f7fc fd03 	bl	80227d8 <tOnePole_tick>
        f1_sample = f1_sample + r->f1_delay_2_last * 0.5f;
 8025dd2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8025dd6:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
        f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
 8025dda:	4648      	mov	r0, r9
        f1_sample = f1_sample + r->f1_delay_2_last * 0.5f;
 8025ddc:	eea7 0a27 	vfma.f32	s0, s14, s15
 8025de0:	eef0 8a40 	vmov.f32	s17, s0
        f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
 8025de4:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025de8:	f7f9 fce0 	bl	801f7ac <tTapeDelay_tick>
 8025dec:	eef0 7a40 	vmov.f32	s15, s0
        f1_sample = tHighpass_tick(&r->f1_hp, f1_sample);
 8025df0:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8025df4:	ee38 0a80 	vadd.f32	s0, s17, s0
        r->f1_delay_2_last = f1_delay_2_sample;
 8025df8:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
        f1_sample = tHighpass_tick(&r->f1_hp, f1_sample);
 8025dfc:	f7fc ff06 	bl	8022c0c <tHighpass_tick>
        if (r->frozen)
 8025e00:	69a3      	ldr	r3, [r4, #24]
        f1_sample *= r->feedback_gain;
 8025e02:	edd4 7a04 	vldr	s15, [r4, #16]
        if (r->frozen)
 8025e06:	2b00      	cmp	r3, #0
 8025e08:	f040 8114 	bne.w	8026034 <tDattorroReverb_tickStereo+0x300>
        f1_sample *= r->feedback_gain;
 8025e0c:	ee27 0a80 	vmul.f32	s0, s15, s0
        r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
 8025e10:	f104 0860 	add.w	r8, r4, #96	; 0x60
        tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
 8025e14:	f104 076c 	add.w	r7, r4, #108	; 0x6c
        f2_sample = tTapeDelay_tick(&r->f2_delay_1, f2_sample);
 8025e18:	f104 0570 	add.w	r5, r4, #112	; 0x70
        f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
 8025e1c:	f104 0b78 	add.w	fp, r4, #120	; 0x78
        r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
 8025e20:	4640      	mov	r0, r8
 8025e22:	f7f9 fcc3 	bl	801f7ac <tTapeDelay_tick>
        tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
 8025e26:	f104 0084 	add.w	r0, r4, #132	; 0x84
        r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
 8025e2a:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
        f2_sample = in_sample + r->f1_last;
 8025e2e:	ee30 8a08 	vadd.f32	s16, s0, s16
        tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
 8025e32:	edd4 8a09 	vldr	s17, [r4, #36]	; 0x24
 8025e36:	f7fe ff2f 	bl	8024c98 <tCycle_tick>
 8025e3a:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 8025e3e:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8025e42:	ed9f 7a81 	vldr	s14, [pc, #516]	; 8026048 <tDattorroReverb_tickStereo+0x314>
 8025e46:	4638      	mov	r0, r7
 8025e48:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8025e4c:	ee27 0a80 	vmul.f32	s0, s15, s0
 8025e50:	eea8 0a87 	vfma.f32	s0, s17, s14
 8025e54:	f7fc fc48 	bl	80226e8 <tAllpass_setDelay>
        f2_sample = tAllpass_tick(&r->f2_allpass, f2_sample);
 8025e58:	eeb0 0a48 	vmov.f32	s0, s16
 8025e5c:	4638      	mov	r0, r7
 8025e5e:	f7fc fc4b 	bl	80226f8 <tAllpass_tick>
        f2_sample = tTapeDelay_tick(&r->f2_delay_1, f2_sample);
 8025e62:	4628      	mov	r0, r5
 8025e64:	f7f9 fca2 	bl	801f7ac <tTapeDelay_tick>
        f2_sample = tOnePole_tick(&r->f2_filter, f2_sample);
 8025e68:	f104 0074 	add.w	r0, r4, #116	; 0x74
 8025e6c:	f7fc fcb4 	bl	80227d8 <tOnePole_tick>
        f2_sample = f2_sample + r->f2_delay_2_last * 0.5f;
 8025e70:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8025e74:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
        f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
 8025e78:	4658      	mov	r0, fp
        f2_sample = f2_sample + r->f2_delay_2_last * 0.5f;
 8025e7a:	eea7 0a27 	vfma.f32	s0, s14, s15
 8025e7e:	eeb0 8a40 	vmov.f32	s16, s0
        f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
 8025e82:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025e86:	f7f9 fc91 	bl	801f7ac <tTapeDelay_tick>
 8025e8a:	eef0 7a40 	vmov.f32	s15, s0
        f2_sample = tHighpass_tick(&r->f2_hp, f2_sample);
 8025e8e:	f104 0080 	add.w	r0, r4, #128	; 0x80
 8025e92:	ee38 0a00 	vadd.f32	s0, s16, s0
        r->f2_delay_2_last = f2_delay_2_sample;
 8025e96:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        f2_sample = tHighpass_tick(&r->f2_hp, f2_sample);
 8025e9a:	f7fc feb7 	bl	8022c0c <tHighpass_tick>
        if (r->frozen)
 8025e9e:	69a3      	ldr	r3, [r4, #24]
        f2_sample *= r->feedback_gain;
 8025ea0:	edd4 7a04 	vldr	s15, [r4, #16]
        if (r->frozen)
 8025ea4:	2b00      	cmp	r3, #0
 8025ea6:	f000 80c8 	beq.w	802603a <tDattorroReverb_tickStereo+0x306>
            f2_sample = 0.0f;
 8025eaa:	ed9f 0a65 	vldr	s0, [pc, #404]	; 8026040 <tDattorroReverb_tickStereo+0x30c>
        r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
 8025eae:	f104 077c 	add.w	r7, r4, #124	; 0x7c
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8025eb2:	ed9f aa66 	vldr	s20, [pc, #408]	; 802604c <tDattorroReverb_tickStereo+0x318>
        r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
 8025eb6:	4638      	mov	r0, r7
 8025eb8:	f7f9 fc78 	bl	801f7ac <tTapeDelay_tick>
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
 8025ebc:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025ec0:	eddf 7a63 	vldr	s15, [pc, #396]	; 8026050 <tDattorroReverb_tickStereo+0x31c>
 8025ec4:	4630      	mov	r0, r6
        r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
 8025ec6:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
 8025eca:	ee27 0a27 	vmul.f32	s0, s14, s15
 8025ece:	f7f9 fcf3 	bl	801f8b8 <tTapeDelay_tapOut>
    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(99.8f));
 8025ed2:	eddf 7a60 	vldr	s15, [pc, #384]	; 8026054 <tDattorroReverb_tickStereo+0x320>
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
 8025ed6:	eeb0 8a40 	vmov.f32	s16, s0
    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(99.8f));
 8025eda:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8025ede:	4630      	mov	r0, r6
 8025ee0:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025ee4:	f7f9 fce8 	bl	801f8b8 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(64.2f));
 8025ee8:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025eec:	eddf 7a5a 	vldr	s15, [pc, #360]	; 8026058 <tDattorroReverb_tickStereo+0x324>
 8025ef0:	ee38 8a00 	vadd.f32	s16, s16, s0
 8025ef4:	4648      	mov	r0, r9
 8025ef6:	ee27 0a27 	vmul.f32	s0, s14, s15
 8025efa:	f7f9 fcdd 	bl	801f8b8 <tTapeDelay_tapOut>
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
 8025efe:	eddf 7a57 	vldr	s15, [pc, #348]	; 802605c <tDattorroReverb_tickStereo+0x328>
    f1_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(64.2f));
 8025f02:	eef0 8a40 	vmov.f32	s17, s0
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
 8025f06:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8025f0a:	4640      	mov	r0, r8
 8025f0c:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025f10:	f7f9 fcd2 	bl	801f8b8 <tTapeDelay_tapOut>
 8025f14:	ee30 9a08 	vadd.f32	s18, s0, s16
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
 8025f18:	eddf 7a51 	vldr	s15, [pc, #324]	; 8026060 <tDattorroReverb_tickStereo+0x32c>
 8025f1c:	4628      	mov	r0, r5
 8025f1e:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
 8025f22:	ee39 9a68 	vsub.f32	s18, s18, s17
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
 8025f26:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025f2a:	f7f9 fcc5 	bl	801f8b8 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8025f2e:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
 8025f32:	ee39 9a40 	vsub.f32	s18, s18, s0
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8025f36:	4658      	mov	r0, fp
 8025f38:	ee27 0a8a 	vmul.f32	s0, s15, s20
 8025f3c:	f7f9 fcbc 	bl	801f8b8 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
 8025f40:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025f44:	eddf 7a47 	vldr	s15, [pc, #284]	; 8026064 <tDattorroReverb_tickStereo+0x330>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8025f48:	ee39 9a40 	vsub.f32	s18, s18, s0
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
 8025f4c:	4638      	mov	r0, r7
 8025f4e:	ee27 0a27 	vmul.f32	s0, s14, s15
 8025f52:	f7f9 fcb1 	bl	801f8b8 <tTapeDelay_tapOut>
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
 8025f56:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025f5a:	eddf 7a43 	vldr	s15, [pc, #268]	; 8026068 <tDattorroReverb_tickStereo+0x334>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
 8025f5e:	ee39 9a40 	vsub.f32	s18, s18, s0
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
 8025f62:	4628      	mov	r0, r5
 8025f64:	ee27 0a27 	vmul.f32	s0, s14, s15
 8025f68:	f7f9 fca6 	bl	801f8b8 <tTapeDelay_tapOut>
    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(121.7f));
 8025f6c:	eddf 7a3f 	vldr	s15, [pc, #252]	; 802606c <tDattorroReverb_tickStereo+0x338>
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
 8025f70:	eef0 8a40 	vmov.f32	s17, s0
    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(121.7f));
 8025f74:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8025f78:	4628      	mov	r0, r5
 8025f7a:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025f7e:	f7f9 fc9b 	bl	801f8b8 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8025f82:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8025f86:	ee78 8a80 	vadd.f32	s17, s17, s0
 8025f8a:	4658      	mov	r0, fp
 8025f8c:	ee27 0a8a 	vmul.f32	s0, s15, s20
 8025f90:	f7f9 fc92 	bl	801f8b8 <tTapeDelay_tapOut>
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
 8025f94:	eddf 7a36 	vldr	s15, [pc, #216]	; 8026070 <tDattorroReverb_tickStereo+0x33c>
    f2_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8025f98:	eeb0 aa40 	vmov.f32	s20, s0
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
 8025f9c:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8025fa0:	4638      	mov	r0, r7
 8025fa2:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025fa6:	f7f9 fc87 	bl	801f8b8 <tTapeDelay_tapOut>
 8025faa:	ee30 8a28 	vadd.f32	s16, s0, s17
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
 8025fae:	eddf 7a31 	vldr	s15, [pc, #196]	; 8026074 <tDattorroReverb_tickStereo+0x340>
 8025fb2:	4630      	mov	r0, r6
 8025fb4:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
 8025fb8:	ee38 8a4a 	vsub.f32	s16, s16, s20
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
 8025fbc:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025fc0:	f7f9 fc7a 	bl	801f8b8 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
 8025fc4:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025fc8:	eddf 7a2b 	vldr	s15, [pc, #172]	; 8026078 <tDattorroReverb_tickStereo+0x344>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
 8025fcc:	ee38 8a40 	vsub.f32	s16, s16, s0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
 8025fd0:	4648      	mov	r0, r9
 8025fd2:	ee27 0a27 	vmul.f32	s0, s14, s15
 8025fd6:	f7f9 fc6f 	bl	801f8b8 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
 8025fda:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
 8025fde:	eddf 7a27 	vldr	s15, [pc, #156]	; 802607c <tDattorroReverb_tickStereo+0x348>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
 8025fe2:	ee38 8a40 	vsub.f32	s16, s16, s0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
 8025fe6:	4640      	mov	r0, r8
 8025fe8:	ee27 0a27 	vmul.f32	s0, s14, s15
 8025fec:	f7f9 fc64 	bl	801f8b8 <tTapeDelay_tapOut>
    output[0] = input * (1.0f - r->mix) + f1_sample  * r->mix;
 8025ff0:	ed94 6a05 	vldr	s12, [r4, #20]
 8025ff4:	eddf 6a22 	vldr	s13, [pc, #136]	; 8026080 <tDattorroReverb_tickStereo+0x34c>
 8025ff8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
 8025ffc:	ee38 0a40 	vsub.f32	s0, s16, s0
    output[0] = input * (1.0f - r->mix) + f1_sample  * r->mix;
 8026000:	ee66 7a26 	vmul.f32	s15, s12, s13
 8026004:	ee37 6a46 	vsub.f32	s12, s14, s12
 8026008:	ee27 9a89 	vmul.f32	s18, s15, s18
 802600c:	eea6 9a29 	vfma.f32	s18, s12, s19
 8026010:	ed8a 9a00 	vstr	s18, [sl]
    output[1] = input * (1.0f - r->mix) + f2_sample * r->mix;
 8026014:	edd4 7a05 	vldr	s15, [r4, #20]
 8026018:	ee67 6aa6 	vmul.f32	s13, s15, s13
 802601c:	ee37 7a67 	vsub.f32	s14, s14, s15
 8026020:	ee20 0a26 	vmul.f32	s0, s0, s13
 8026024:	eea7 0a29 	vfma.f32	s0, s14, s19
 8026028:	ed8a 0a01 	vstr	s0, [sl, #4]
}
 802602c:	ecbd 8b06 	vpop	{d8-d10}
 8026030:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            f1_sample = 0.0f;
 8026034:	ed9f 0a02 	vldr	s0, [pc, #8]	; 8026040 <tDattorroReverb_tickStereo+0x30c>
 8026038:	e6ea      	b.n	8025e10 <tDattorroReverb_tickStereo+0xdc>
        f2_sample *= r->feedback_gain;
 802603a:	ee27 0a80 	vmul.f32	s0, s15, s0
 802603e:	e736      	b.n	8025eae <tDattorroReverb_tickStereo+0x17a>
 8026040:	00000000 	.word	0x00000000
 8026044:	41f4147b 	.word	0x41f4147b
 8026048:	41b4a3d7 	.word	0x41b4a3d7
 802604c:	40c9999a 	.word	0x40c9999a
 8026050:	410e6666 	.word	0x410e6666
 8026054:	42c7999a 	.word	0x42c7999a
 8026058:	42806666 	.word	0x42806666
 802605c:	42860000 	.word	0x42860000
 8026060:	4285999a 	.word	0x4285999a
 8026064:	420f3333 	.word	0x420f3333
 8026068:	413ccccd 	.word	0x413ccccd
 802606c:	42f36666 	.word	0x42f36666
 8026070:	42b36666 	.word	0x42b36666
 8026074:	428d999a 	.word	0x428d999a
 8026078:	41333333 	.word	0x41333333
 802607c:	40833333 	.word	0x40833333
 8026080:	3e0f5c29 	.word	0x3e0f5c29

08026084 <tDattorroReverb_setMix>:
{
 8026084:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
 8026086:	6804      	ldr	r4, [r0, #0]
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
 8026088:	eef0 0a40 	vmov.f32	s1, s0
 802608c:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8026090:	ed9f 0a03 	vldr	s0, [pc, #12]	; 80260a0 <tDattorroReverb_setMix+0x1c>
 8026094:	f7fd ff0e 	bl	8023eb4 <LEAF_clip>
 8026098:	ed84 0a05 	vstr	s0, [r4, #20]
}
 802609c:	bd10      	pop	{r4, pc}
 802609e:	bf00      	nop
 80260a0:	00000000 	.word	0x00000000

080260a4 <tDattorroReverb_setFreeze>:
{
 80260a4:	b570      	push	{r4, r5, r6, lr}
    _tDattorroReverb* r = *rev;
 80260a6:	6804      	ldr	r4, [r0, #0]
    r->frozen = freeze;
 80260a8:	61a1      	str	r1, [r4, #24]
 80260aa:	f104 006c 	add.w	r0, r4, #108	; 0x6c
 80260ae:	f104 0650 	add.w	r6, r4, #80	; 0x50
 80260b2:	f104 0568 	add.w	r5, r4, #104	; 0x68
 80260b6:	3484      	adds	r4, #132	; 0x84
    if (freeze)
 80260b8:	b9a1      	cbnz	r1, 80260e4 <tDattorroReverb_setFreeze+0x40>
        tAllpass_setGain(&r->f2_allpass, 0.7f);
 80260ba:	ed9f 0a15 	vldr	s0, [pc, #84]	; 8026110 <tDattorroReverb_setFreeze+0x6c>
 80260be:	f7fc fb17 	bl	80226f0 <tAllpass_setGain>
        tAllpass_setGain(&r->f1_allpass, 0.7f);
 80260c2:	4630      	mov	r0, r6
 80260c4:	ed9f 0a12 	vldr	s0, [pc, #72]	; 8026110 <tDattorroReverb_setFreeze+0x6c>
 80260c8:	f7fc fb12 	bl	80226f0 <tAllpass_setGain>
        tCycle_setFreq(&r->f1_lfo, 0.1f);
 80260cc:	4628      	mov	r0, r5
 80260ce:	ed9f 0a11 	vldr	s0, [pc, #68]	; 8026114 <tDattorroReverb_setFreeze+0x70>
 80260d2:	f7fe fdd3 	bl	8024c7c <tCycle_setFreq>
        tCycle_setFreq(&r->f2_lfo, 0.07f);
 80260d6:	4620      	mov	r0, r4
 80260d8:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 8026118 <tDattorroReverb_setFreeze+0x74>
}
 80260dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        tCycle_setFreq(&r->f2_lfo, 0.07f);
 80260e0:	f7fe bdcc 	b.w	8024c7c <tCycle_setFreq>
        tAllpass_setGain(&r->f2_allpass, 1.0f);
 80260e4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80260e8:	f7fc fb02 	bl	80226f0 <tAllpass_setGain>
        tAllpass_setGain(&r->f1_allpass, 1.0f);
 80260ec:	4630      	mov	r0, r6
 80260ee:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80260f2:	f7fc fafd 	bl	80226f0 <tAllpass_setGain>
        tCycle_setFreq(&r->f1_lfo, 0.0f);
 80260f6:	4628      	mov	r0, r5
 80260f8:	ed9f 0a08 	vldr	s0, [pc, #32]	; 802611c <tDattorroReverb_setFreeze+0x78>
 80260fc:	f7fe fdbe 	bl	8024c7c <tCycle_setFreq>
        tCycle_setFreq(&r->f2_lfo, 0.0f);
 8026100:	4620      	mov	r0, r4
 8026102:	ed9f 0a06 	vldr	s0, [pc, #24]	; 802611c <tDattorroReverb_setFreeze+0x78>
}
 8026106:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        tCycle_setFreq(&r->f2_lfo, 0.0f);
 802610a:	f7fe bdb7 	b.w	8024c7c <tCycle_setFreq>
 802610e:	bf00      	nop
 8026110:	3f333333 	.word	0x3f333333
 8026114:	3dcccccd 	.word	0x3dcccccd
 8026118:	3d8f5c29 	.word	0x3d8f5c29
 802611c:	00000000 	.word	0x00000000

08026120 <tDattorroReverb_setHP>:
{
 8026120:	b510      	push	{r4, lr}
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
 8026122:	eef0 0a40 	vmov.f32	s1, s0
 8026126:	ed9f 1a0c 	vldr	s2, [pc, #48]	; 8026158 <tDattorroReverb_setHP+0x38>
 802612a:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
{
 802612e:	ed2d 8b02 	vpush	{d8}
    _tDattorroReverb* r = *rev;
 8026132:	6804      	ldr	r4, [r0, #0]
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
 8026134:	f7fd febe 	bl	8023eb4 <LEAF_clip>
 8026138:	eeb0 8a40 	vmov.f32	s16, s0
    tHighpass_setFreq(&r->f1_hp, newFreq);
 802613c:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8026140:	f7fc fd54 	bl	8022bec <tHighpass_setFreq>
    tHighpass_setFreq(&r->f2_hp, newFreq);
 8026144:	f104 0080 	add.w	r0, r4, #128	; 0x80
 8026148:	eeb0 0a48 	vmov.f32	s0, s16
}
 802614c:	ecbd 8b02 	vpop	{d8}
 8026150:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tHighpass_setFreq(&r->f2_hp, newFreq);
 8026154:	f7fc bd4a 	b.w	8022bec <tHighpass_setFreq>
 8026158:	469c4000 	.word	0x469c4000

0802615c <tDattorroReverb_setSize>:
{
 802615c:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
 802615e:	6804      	ldr	r4, [r0, #0]
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
 8026160:	ed94 1a08 	vldr	s2, [r4, #32]
 8026164:	ee61 0a00 	vmul.f32	s1, s2, s0
 8026168:	ed9f 0a26 	vldr	s0, [pc, #152]	; 8026204 <tDattorroReverb_setSize+0xa8>
 802616c:	f7fd fea2 	bl	8023eb4 <LEAF_clip>
    r->t = r->size * leaf.sampleRate * 0.001f;
 8026170:	4b25      	ldr	r3, [pc, #148]	; (8026208 <tDattorroReverb_setSize+0xac>)
 8026172:	eddf 6a26 	vldr	s13, [pc, #152]	; 802620c <tDattorroReverb_setSize+0xb0>
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
 8026176:	f104 0054 	add.w	r0, r4, #84	; 0x54
    r->t = r->size * leaf.sampleRate * 0.001f;
 802617a:	edd3 7a00 	vldr	s15, [r3]
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
 802617e:	ed84 0a07 	vstr	s0, [r4, #28]
    r->t = r->size * leaf.sampleRate * 0.001f;
 8026182:	ee67 7aa6 	vmul.f32	s15, s15, s13
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
 8026186:	ed9f 7a22 	vldr	s14, [pc, #136]	; 8026210 <tDattorroReverb_setSize+0xb4>
    r->t = r->size * leaf.sampleRate * 0.001f;
 802618a:	ee27 0a80 	vmul.f32	s0, s15, s0
 802618e:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
 8026192:	ee20 0a07 	vmul.f32	s0, s0, s14
 8026196:	f7f9 fb7f 	bl	801f898 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f1_delay_2, SAMP(89.24f));
 802619a:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 802619e:	eddf 7a1d 	vldr	s15, [pc, #116]	; 8026214 <tDattorroReverb_setSize+0xb8>
 80261a2:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 80261a6:	ee20 0a27 	vmul.f32	s0, s0, s15
 80261aa:	f7f9 fb75 	bl	801f898 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f1_delay_3, SAMP(125.f));
 80261ae:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 80261b2:	eddf 7a19 	vldr	s15, [pc, #100]	; 8026218 <tDattorroReverb_setSize+0xbc>
 80261b6:	f104 0060 	add.w	r0, r4, #96	; 0x60
 80261ba:	ee20 0a27 	vmul.f32	s0, s0, s15
 80261be:	f7f9 fb6b 	bl	801f898 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_1, SAMP(149.62f));
 80261c2:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 80261c6:	eddf 7a15 	vldr	s15, [pc, #84]	; 802621c <tDattorroReverb_setSize+0xc0>
 80261ca:	f104 0070 	add.w	r0, r4, #112	; 0x70
 80261ce:	ee20 0a27 	vmul.f32	s0, s0, s15
 80261d2:	f7f9 fb61 	bl	801f898 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_2, SAMP(60.48f));
 80261d6:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 80261da:	eddf 7a11 	vldr	s15, [pc, #68]	; 8026220 <tDattorroReverb_setSize+0xc4>
 80261de:	f104 0078 	add.w	r0, r4, #120	; 0x78
 80261e2:	ee20 0a27 	vmul.f32	s0, s0, s15
 80261e6:	f7f9 fb57 	bl	801f898 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_3, SAMP(106.28f));
 80261ea:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 80261ee:	eddf 7a0d 	vldr	s15, [pc, #52]	; 8026224 <tDattorroReverb_setSize+0xc8>
 80261f2:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 80261f6:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 80261fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tTapeDelay_setDelay(&r->f2_delay_3, SAMP(106.28f));
 80261fe:	f7f9 bb4b 	b.w	801f898 <tTapeDelay_setDelay>
 8026202:	bf00      	nop
 8026204:	3c23d70a 	.word	0x3c23d70a
 8026208:	200194e8 	.word	0x200194e8
 802620c:	3a83126f 	.word	0x3a83126f
 8026210:	430db0a4 	.word	0x430db0a4
 8026214:	42b27ae1 	.word	0x42b27ae1
 8026218:	42fa0000 	.word	0x42fa0000
 802621c:	43159eb8 	.word	0x43159eb8
 8026220:	4271eb85 	.word	0x4271eb85
 8026224:	42d48f5c 	.word	0x42d48f5c

08026228 <tDattorroReverb_setInputFilter>:
{
 8026228:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
 802622a:	6804      	ldr	r4, [r0, #0]
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
 802622c:	eef0 0a40 	vmov.f32	s1, s0
 8026230:	ed9f 1a06 	vldr	s2, [pc, #24]	; 802624c <tDattorroReverb_setInputFilter+0x24>
 8026234:	ed9f 0a06 	vldr	s0, [pc, #24]	; 8026250 <tDattorroReverb_setInputFilter+0x28>
 8026238:	f7fd fe3c 	bl	8023eb4 <LEAF_clip>
    tOnePole_setFreq(&r->in_filter, r->input_filter);
 802623c:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8026240:	ed84 0a02 	vstr	s0, [r4, #8]
}
 8026244:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&r->in_filter, r->input_filter);
 8026248:	f7fc baaa 	b.w	80227a0 <tOnePole_setFreq>
 802624c:	469c4000 	.word	0x469c4000
 8026250:	00000000 	.word	0x00000000

08026254 <tDattorroReverb_setFeedbackFilter>:
{
 8026254:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
 8026256:	6804      	ldr	r4, [r0, #0]
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8026258:	eef0 0a40 	vmov.f32	s1, s0
 802625c:	ed9f 1a09 	vldr	s2, [pc, #36]	; 8026284 <tDattorroReverb_setFeedbackFilter+0x30>
 8026260:	ed9f 0a09 	vldr	s0, [pc, #36]	; 8026288 <tDattorroReverb_setFeedbackFilter+0x34>
 8026264:	f7fd fe26 	bl	8023eb4 <LEAF_clip>
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
 8026268:	f104 0058 	add.w	r0, r4, #88	; 0x58
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
 802626c:	ed84 0a03 	vstr	s0, [r4, #12]
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
 8026270:	f7fc fa96 	bl	80227a0 <tOnePole_setFreq>
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
 8026274:	ed94 0a03 	vldr	s0, [r4, #12]
 8026278:	f104 0074 	add.w	r0, r4, #116	; 0x74
}
 802627c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
 8026280:	f7fc ba8e 	b.w	80227a0 <tOnePole_setFreq>
 8026284:	469c4000 	.word	0x469c4000
 8026288:	00000000 	.word	0x00000000

0802628c <tDattorroReverb_setFeedbackGain>:
    _tDattorroReverb* r = *rev;
 802628c:	6803      	ldr	r3, [r0, #0]
    r->feedback_gain = gain;
 802628e:	ed83 0a04 	vstr	s0, [r3, #16]
}
 8026292:	4770      	bx	lr

08026294 <tBuffer_initToPool>:
{
    tBuffer_initToPool(sb, length, &leaf.mempool);
}

void  tBuffer_initToPool (tBuffer* const sb, uint32_t length, tMempool* const mp)
{
 8026294:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
 8026296:	6815      	ldr	r5, [r2, #0]
{
 8026298:	460e      	mov	r6, r1
 802629a:	4607      	mov	r7, r0
    _tBuffer* s = *sb = (_tBuffer*) mpool_alloc(sizeof(_tBuffer), m);
 802629c:	201c      	movs	r0, #28
 802629e:	4629      	mov	r1, r5
 80262a0:	f7fe f80a 	bl	80242b8 <mpool_alloc>
 80262a4:	4604      	mov	r4, r0
    s->mempool = m;
    
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
 80262a6:	4629      	mov	r1, r5
 80262a8:	00b0      	lsls	r0, r6, #2
    _tBuffer* s = *sb = (_tBuffer*) mpool_alloc(sizeof(_tBuffer), m);
 80262aa:	603c      	str	r4, [r7, #0]
    s->mempool = m;
 80262ac:	6025      	str	r5, [r4, #0]
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
 80262ae:	f7fe f803 	bl	80242b8 <mpool_alloc>
    
    s->bufferLength = length;
    s->recordedLength = 0;
 80262b2:	2300      	movs	r3, #0
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
 80262b4:	6060      	str	r0, [r4, #4]
    s->active = 0;
 80262b6:	61a3      	str	r3, [r4, #24]
    s->idx = 0;
 80262b8:	60a3      	str	r3, [r4, #8]
    s->mode = RecordOneShot;
 80262ba:	7523      	strb	r3, [r4, #20]
    s->recordedLength = 0;
 80262bc:	e9c4 6303 	strd	r6, r3, [r4, #12]
}
 80262c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80262c2:	bf00      	nop

080262c4 <tBuffer_free>:

void  tBuffer_free (tBuffer* const sb)
{
 80262c4:	b510      	push	{r4, lr}
    _tBuffer* s = *sb;
 80262c6:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)s->buff, s->mempool);
 80262c8:	e9d4 1000 	ldrd	r1, r0, [r4]
 80262cc:	f7fe f8a8 	bl	8024420 <mpool_free>
    mpool_free((char*)s, s->mempool);
 80262d0:	6821      	ldr	r1, [r4, #0]
 80262d2:	4620      	mov	r0, r4
}
 80262d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)s, s->mempool);
 80262d8:	f7fe b8a2 	b.w	8024420 <mpool_free>

080262dc <tBuffer_tick>:

void tBuffer_tick (tBuffer* const sb, float sample)
{
    _tBuffer* s = *sb;
 80262dc:	6803      	ldr	r3, [r0, #0]
    
    if (s->active == 1)
 80262de:	699a      	ldr	r2, [r3, #24]
 80262e0:	2a01      	cmp	r2, #1
 80262e2:	d000      	beq.n	80262e6 <tBuffer_tick+0xa>
                s->idx = 0;
            }
        }
        s->recordedLength = s->idx;
    }
}
 80262e4:	4770      	bx	lr
        s->buff[s->idx] = sample;
 80262e6:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
 80262ea:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 80262ee:	ed82 0a00 	vstr	s0, [r2]
        if (s->idx >= s->bufferLength)
 80262f2:	e9d3 2102 	ldrd	r2, r1, [r3, #8]
        s->idx += 1;
 80262f6:	3201      	adds	r2, #1
        if (s->idx >= s->bufferLength)
 80262f8:	428a      	cmp	r2, r1
        s->idx += 1;
 80262fa:	609a      	str	r2, [r3, #8]
        if (s->idx >= s->bufferLength)
 80262fc:	d304      	bcc.n	8026308 <tBuffer_tick+0x2c>
            if (s->mode == RecordOneShot)
 80262fe:	7d19      	ldrb	r1, [r3, #20]
 8026300:	b921      	cbnz	r1, 802630c <tBuffer_tick+0x30>
    s->idx = 0;
}

void  tBuffer_stop(tBuffer* const sb)
{
    _tBuffer* s = *sb;
 8026302:	6802      	ldr	r2, [r0, #0]
    s->active = 0;
 8026304:	6191      	str	r1, [r2, #24]
 8026306:	689a      	ldr	r2, [r3, #8]
        s->recordedLength = s->idx;
 8026308:	611a      	str	r2, [r3, #16]
}
 802630a:	4770      	bx	lr
            else if (s->mode == RecordLoop)
 802630c:	2901      	cmp	r1, #1
 802630e:	d1fb      	bne.n	8026308 <tBuffer_tick+0x2c>
                s->idx = 0;
 8026310:	2100      	movs	r1, #0
 8026312:	460a      	mov	r2, r1
 8026314:	6099      	str	r1, [r3, #8]
 8026316:	e7f7      	b.n	8026308 <tBuffer_tick+0x2c>

08026318 <tBuffer_get>:
    if ((idx < 0) || (idx >= (int) s->bufferLength)) return 0.f;
 8026318:	2900      	cmp	r1, #0
 802631a:	db09      	blt.n	8026330 <tBuffer_get+0x18>
    _tBuffer* s = *sb;
 802631c:	6803      	ldr	r3, [r0, #0]
    if ((idx < 0) || (idx >= (int) s->bufferLength)) return 0.f;
 802631e:	68da      	ldr	r2, [r3, #12]
 8026320:	428a      	cmp	r2, r1
 8026322:	dd05      	ble.n	8026330 <tBuffer_get+0x18>
    return s->buff[idx];
 8026324:	685b      	ldr	r3, [r3, #4]
 8026326:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 802632a:	ed91 0a00 	vldr	s0, [r1]
 802632e:	4770      	bx	lr
    if ((idx < 0) || (idx >= (int) s->bufferLength)) return 0.f;
 8026330:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8026338 <tBuffer_get+0x20>
}
 8026334:	4770      	bx	lr
 8026336:	bf00      	nop
 8026338:	00000000 	.word	0x00000000

0802633c <tBuffer_record>:
    _tBuffer* s = *sb;
 802633c:	6803      	ldr	r3, [r0, #0]
    s->active = 1;
 802633e:	2101      	movs	r1, #1
    s->idx = 0;
 8026340:	2200      	movs	r2, #0
    s->active = 1;
 8026342:	6199      	str	r1, [r3, #24]
    s->idx = 0;
 8026344:	609a      	str	r2, [r3, #8]
}
 8026346:	4770      	bx	lr

08026348 <tBuffer_stop>:
    _tBuffer* s = *sb;
 8026348:	6803      	ldr	r3, [r0, #0]
    s->active = 0;
 802634a:	2200      	movs	r2, #0
 802634c:	619a      	str	r2, [r3, #24]
}
 802634e:	4770      	bx	lr

08026350 <tBuffer_getRecordPosition>:

int   tBuffer_getRecordPosition(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->idx;
 8026350:	6803      	ldr	r3, [r0, #0]
}
 8026352:	6898      	ldr	r0, [r3, #8]
 8026354:	4770      	bx	lr
 8026356:	bf00      	nop

08026358 <tBuffer_setRecordPosition>:

void   tBuffer_setRecordPosition(tBuffer* const sb, int pos)
{
    _tBuffer* s = *sb;
 8026358:	6803      	ldr	r3, [r0, #0]
    s->idx = pos;
 802635a:	6099      	str	r1, [r3, #8]
}
 802635c:	4770      	bx	lr
 802635e:	bf00      	nop

08026360 <tBuffer_setRecordMode>:

void  tBuffer_setRecordMode (tBuffer* const sb, RecordMode mode)
{
    _tBuffer* s = *sb;
 8026360:	6803      	ldr	r3, [r0, #0]
    s->mode = mode;
 8026362:	7519      	strb	r1, [r3, #20]
}
 8026364:	4770      	bx	lr
 8026366:	bf00      	nop

08026368 <tBuffer_getRecordedLength>:
}

uint32_t tBuffer_getRecordedLength(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->recordedLength;
 8026368:	6803      	ldr	r3, [r0, #0]
}
 802636a:	6918      	ldr	r0, [r3, #16]
 802636c:	4770      	bx	lr
 802636e:	bf00      	nop

08026370 <tBuffer_setRecordedLength>:

void tBuffer_setRecordedLength(tBuffer* const sb, int length)
{
    _tBuffer* s = *sb;
 8026370:	6803      	ldr	r3, [r0, #0]
    s->recordedLength = length;
 8026372:	6119      	str	r1, [r3, #16]
}
 8026374:	4770      	bx	lr
 8026376:	bf00      	nop

08026378 <tBuffer_isActive>:

int tBuffer_isActive(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->active;
 8026378:	6803      	ldr	r3, [r0, #0]
}
 802637a:	6998      	ldr	r0, [r3, #24]
 802637c:	4770      	bx	lr
 802637e:	bf00      	nop

08026380 <tSampler_init>:
static void handleStartEndChange(tSampler* const sp);

static void attemptStartEndChange(tSampler* const sp);

void tSampler_init(tSampler* const sp, tBuffer* const b)
{
 8026380:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tSampler_initToPool(sp, b, &leaf.mempool);
}

void tSampler_initToPool(tSampler* const sp, tBuffer* const b, tMempool* const mp)
{
    _tMempool* m = *mp;
 8026384:	4e23      	ldr	r6, [pc, #140]	; (8026414 <tSampler_init+0x94>)
{
 8026386:	4681      	mov	r9, r0
 8026388:	4688      	mov	r8, r1
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
 802638a:	2054      	movs	r0, #84	; 0x54
    
    _tBuffer* s = *b;
    
    p->samp = s;
    
    p->active = 0;
 802638c:	2500      	movs	r5, #0
{
 802638e:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8026392:	f856 7f18 	ldr.w	r7, [r6, #24]!
    p->start = 0;
    p->end = 0;
    
    p->len = p->end - p->start;
    
    p->idx = 0.f;
 8026396:	ed9f 8a20 	vldr	s16, [pc, #128]	; 8026418 <tSampler_init+0x98>
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
 802639a:	4639      	mov	r1, r7
 802639c:	f7fd ff8c 	bl	80242b8 <mpool_alloc>
 80263a0:	4604      	mov	r4, r0
 80263a2:	f8c9 0000 	str.w	r0, [r9]
    
    p->mode = PlayNormal;
    
    p->cfxlen = 500; // default 300 sample crossfade
    
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 80263a6:	4632      	mov	r2, r6
    p->mempool = m;
 80263a8:	6007      	str	r7, [r0, #0]
    p->inc = 1.f;
 80263aa:	f04f 5e7e 	mov.w	lr, #1065353216	; 0x3f800000
    _tBuffer* s = *b;
 80263ae:	f8d8 3000 	ldr.w	r3, [r8]
    p->iinc = 1.f;
 80263b2:	f04f 5c7e 	mov.w	ip, #1065353216	; 0x3f800000
 80263b6:	f240 1001 	movw	r0, #257	; 0x101
    p->cfxlen = 500; // default 300 sample crossfade
 80263ba:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 80263be:	f104 0608 	add.w	r6, r4, #8
    p->samp = s;
 80263c2:	6063      	str	r3, [r4, #4]
    p->flip = 1;
 80263c4:	2301      	movs	r3, #1
    p->inc = 1.f;
 80263c6:	f8c4 e010 	str.w	lr, [r4, #16]
    p->iinc = 1.f;
 80263ca:	f8c4 c018 	str.w	ip, [r4, #24]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 80263ce:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
    p->flip = 1;
 80263d2:	77a3      	strb	r3, [r4, #30]
    p->iinc = 1.f;
 80263d4:	83a0      	strh	r0, [r4, #28]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 80263d6:	4630      	mov	r0, r6
    p->cfxlen = 500; // default 300 sample crossfade
 80263d8:	6361      	str	r1, [r4, #52]	; 0x34
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 80263da:	4619      	mov	r1, r3
    p->idx = 0.f;
 80263dc:	ed84 8a03 	vstr	s16, [r4, #12]
    p->active = 0;
 80263e0:	6465      	str	r5, [r4, #68]	; 0x44
    p->start = 0;
 80263e2:	6225      	str	r5, [r4, #32]
    p->end = 0;
 80263e4:	62a5      	str	r5, [r4, #40]	; 0x28
    p->len = p->end - p->start;
 80263e6:	6325      	str	r5, [r4, #48]	; 0x30
    p->mode = PlayNormal;
 80263e8:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 80263ec:	f7fb ffe2 	bl	80223b4 <tRamp_initToPool>
    tRamp_setVal(&p->gain, 0.f);
 80263f0:	eeb0 0a48 	vmov.f32	s0, s16
 80263f4:	4630      	mov	r0, r6
 80263f6:	f7fc f823 	bl	8022440 <tRamp_setVal>
    
    p->targetstart = -1;
    p->targetend = -1;
    
    p->inCrossfade = 0;
    p->flipStart = -1;
 80263fa:	4b08      	ldr	r3, [pc, #32]	; (802641c <tSampler_init+0x9c>)
    p->targetstart = -1;
 80263fc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    p->inCrossfade = 0;
 8026400:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
    p->flipStart = -1;
 8026404:	64e3      	str	r3, [r4, #76]	; 0x4c
    p->targetstart = -1;
 8026406:	6262      	str	r2, [r4, #36]	; 0x24
    p->targetend = -1;
 8026408:	62e2      	str	r2, [r4, #44]	; 0x2c
    p->flipIdx = -1;
 802640a:	6523      	str	r3, [r4, #80]	; 0x50
}
 802640c:	ecbd 8b02 	vpop	{d8}
 8026410:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8026414:	200194e8 	.word	0x200194e8
 8026418:	00000000 	.word	0x00000000
 802641c:	bf800000 	.word	0xbf800000

08026420 <tSampler_free>:
}

void tSampler_free (tSampler* const sp)
{
 8026420:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
 8026422:	6804      	ldr	r4, [r0, #0]
    tRamp_free(&p->gain);
 8026424:	f104 0008 	add.w	r0, r4, #8
 8026428:	f7fb fff8 	bl	802241c <tRamp_free>
    
    mpool_free((char*)p, p->mempool);
 802642c:	6821      	ldr	r1, [r4, #0]
 802642e:	4620      	mov	r0, r4
}
 8026430:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
 8026434:	f7fd bff4 	b.w	8024420 <mpool_free>

08026438 <tSampler_setMode>:
    return p->last;
}

void tSampler_setMode      (tSampler* const sp, PlayMode mode)
{
    _tSampler* p = *sp;
 8026438:	6803      	ldr	r3, [r0, #0]
    p->mode = mode;
 802643a:	f883 103c 	strb.w	r1, [r3, #60]	; 0x3c
}
 802643e:	4770      	bx	lr

08026440 <tSampler_setCrossfadeLength>:

void tSampler_setCrossfadeLength  (tSampler* const sp, uint32_t length)
{
 8026440:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
 8026442:	6804      	ldr	r4, [r0, #0]
    
    uint32_t cfxlen = LEAF_clip(0, length, p->len * 0.25f);
 8026444:	ee07 1a90 	vmov	s15, r1
 8026448:	ed9f 0a07 	vldr	s0, [pc, #28]	; 8026468 <tSampler_setCrossfadeLength+0x28>
 802644c:	ed94 1a0c 	vldr	s2, [r4, #48]	; 0x30
 8026450:	eef8 0a67 	vcvt.f32.u32	s1, s15
 8026454:	eebb 1acf 	vcvt.f32.u32	s2, s2, #2
 8026458:	f7fd fd2c 	bl	8023eb4 <LEAF_clip>
 802645c:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 8026460:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    
    p->cfxlen = cfxlen;
}
 8026464:	bd10      	pop	{r4, pc}
 8026466:	bf00      	nop
 8026468:	00000000 	.word	0x00000000

0802646c <tSampler_play>:

void tSampler_play         (tSampler* const sp)
{
 802646c:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
 802646e:	6804      	ldr	r4, [r0, #0]
    
    if (p->active != 0)
 8026470:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8026472:	f104 0008 	add.w	r0, r4, #8
 8026476:	bb93      	cbnz	r3, 80264de <tSampler_play+0x72>
        
        tRamp_setDest(&p->gain, 0.f);
    }
    else
    {
        p->active = 1;
 8026478:	2201      	movs	r2, #1
        p->retrigger = 0;
 802647a:	6423      	str	r3, [r4, #64]	; 0x40
        
        tRamp_setDest(&p->gain, 1.f);
 802647c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
        p->active = 1;
 8026480:	6462      	str	r2, [r4, #68]	; 0x44
        tRamp_setDest(&p->gain, 1.f);
 8026482:	f7fb ffcf 	bl	8022424 <tRamp_setDest>
        
        if (p->dir > 0)
 8026486:	f994 301c 	ldrsb.w	r3, [r4, #28]
 802648a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 802648c:	2b00      	cmp	r3, #0
 802648e:	6a22      	ldr	r2, [r4, #32]
        {
            if (p->flip > 0)    p->idx = p->start;
 8026490:	f994 301d 	ldrsb.w	r3, [r4, #29]
        if (p->dir > 0)
 8026494:	dd2e      	ble.n	80264f4 <tSampler_play+0x88>
            if (p->flip > 0)    p->idx = p->start;
 8026496:	2b00      	cmp	r3, #0
 8026498:	dd2e      	ble.n	80264f8 <tSampler_play+0x8c>
            else                p->idx = p->end;
        }
        else
        {
            if (p->flip > 0)    p->idx = p->end;
            else                p->idx = p->start;
 802649a:	ee07 2a90 	vmov	s15, r2
 802649e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80264a2:	edc4 7a03 	vstr	s15, [r4, #12]

static void handleStartEndChange(tSampler* const sp)
{
    _tSampler* p = *sp;
    
    p->len = abs(p->end - p->start);
 80264a6:	1a8b      	subs	r3, r1, r2
    
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 80264a8:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
    p->len = abs(p->end - p->start);
 80264ac:	2b00      	cmp	r3, #0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 80264ae:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
 80264b2:	bfb8      	it	lt
 80264b4:	425b      	neglt	r3, r3
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 80264b6:	ee07 3a10 	vmov	s14, r3
    p->len = abs(p->end - p->start);
 80264ba:	6323      	str	r3, [r4, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 80264bc:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
 80264c0:	eef4 7ac7 	vcmpe.f32	s15, s14
 80264c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80264c8:	dd03      	ble.n	80264d2 <tSampler_play+0x66>
 80264ca:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 80264ce:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
    
    if (p->start > p->end)
 80264d2:	4291      	cmp	r1, r2
    {
        p->flip = -1;
 80264d4:	bfb4      	ite	lt
 80264d6:	23ff      	movlt	r3, #255	; 0xff
    }
    else
    {
        p->flip = 1;
 80264d8:	2301      	movge	r3, #1
 80264da:	7763      	strb	r3, [r4, #29]
}
 80264dc:	bd10      	pop	{r4, pc}
        p->active = -1;
 80264de:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
        p->retrigger = 1;
 80264e2:	2301      	movs	r3, #1
        tRamp_setDest(&p->gain, 0.f);
 80264e4:	ed9f 0a08 	vldr	s0, [pc, #32]	; 8026508 <tSampler_play+0x9c>
        p->retrigger = 1;
 80264e8:	e9c4 3210 	strd	r3, r2, [r4, #64]	; 0x40
}
 80264ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        tRamp_setDest(&p->gain, 0.f);
 80264f0:	f7fb bf98 	b.w	8022424 <tRamp_setDest>
            if (p->flip > 0)    p->idx = p->end;
 80264f4:	2b00      	cmp	r3, #0
 80264f6:	ddd0      	ble.n	802649a <tSampler_play+0x2e>
 80264f8:	ee07 1a90 	vmov	s15, r1
 80264fc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026500:	edc4 7a03 	vstr	s15, [r4, #12]
 8026504:	e7cf      	b.n	80264a6 <tSampler_play+0x3a>
 8026506:	bf00      	nop
 8026508:	00000000 	.word	0x00000000

0802650c <tSampler_stop>:
    _tSampler* p = *sp;
 802650c:	6800      	ldr	r0, [r0, #0]
    p->active = -1;
 802650e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    tRamp_setDest(&p->gain, 0.f);
 8026512:	ed9f 0a03 	vldr	s0, [pc, #12]	; 8026520 <tSampler_stop+0x14>
    p->active = -1;
 8026516:	6443      	str	r3, [r0, #68]	; 0x44
    tRamp_setDest(&p->gain, 0.f);
 8026518:	3008      	adds	r0, #8
 802651a:	f7fb bf83 	b.w	8022424 <tRamp_setDest>
 802651e:	bf00      	nop
 8026520:	00000000 	.word	0x00000000

08026524 <tSampler_setStart>:
        tSampler_setEnd(sp, p->targetend);
    }
}

void tSampler_setStart     (tSampler* const sp, int32_t start)
{
 8026524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
 8026526:	6804      	ldr	r4, [r0, #0]
    if (start == p->end)
    {
        return;
    }
    */
    if (p->active) // only bother with these checks if we're actually playing
 8026528:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802652a:	2b00      	cmp	r3, #0
 802652c:	d042      	beq.n	80265b4 <tSampler_setStart+0x90>
    {
        if (start > p->end)
 802652e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8026530:	428b      	cmp	r3, r1
 8026532:	db1d      	blt.n	8026570 <tSampler_setStart+0x4c>
 8026534:	2501      	movs	r5, #1
 8026536:	2700      	movs	r7, #0
        {
            tempflip = -1;
        }
        else
        {
            tempflip = 1;
 8026538:	462e      	mov	r6, r5
        }
        
        int dir = p->bnf * p->dir * tempflip;
        
        uint32_t cfxlen = p->cfxlen;
 802653a:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802653e:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 8026542:	eef8 6a47 	vcvt.f32.u32	s13, s14
        
        if (p->inCrossfade || p->flipStart >= 0)
 8026546:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802654a:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
 802654e:	eef4 7ae6 	vcmpe.f32	s15, s13
 8026552:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026556:	bf48      	it	mi
 8026558:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
 802655c:	b932      	cbnz	r2, 802656c <tSampler_setStart+0x48>
 802655e:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
 8026562:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8026566:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802656a:	db06      	blt.n	802657a <tSampler_setStart+0x56>
        }
    }
    
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
    handleStartEndChange(sp);
    p->targetstart = -1;
 802656c:	6261      	str	r1, [r4, #36]	; 0x24
    
}
 802656e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (start > p->end)
 8026570:	2701      	movs	r7, #1
 8026572:	2500      	movs	r5, #0
            tempflip = -1;
 8026574:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8026578:	e7df      	b.n	802653a <tSampler_setStart+0x16>
        int dir = p->bnf * p->dir * tempflip;
 802657a:	f994 201e 	ldrsb.w	r2, [r4, #30]
 802657e:	f994 c01c 	ldrsb.w	ip, [r4, #28]
 8026582:	fb12 f20c 	smulbb	r2, r2, ip
 8026586:	fb06 f202 	mul.w	r2, r6, r2
        if ((tempflip > 0) && (dir > 0)) // start is start and we're playing forward
 802658a:	2a00      	cmp	r2, #0
 802658c:	dd3c      	ble.n	8026608 <tSampler_setStart+0xe4>
 802658e:	2d00      	cmp	r5, #0
 8026590:	d03a      	beq.n	8026608 <tSampler_setStart+0xe4>
            if (start > p->idx)// start given is after current index or we're in a crossfade
 8026592:	ee07 1a90 	vmov	s15, r1
 8026596:	edd4 6a03 	vldr	s13, [r4, #12]
 802659a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802659e:	eef4 7ae6 	vcmpe.f32	s15, s13
 80265a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80265a6:	dc3e      	bgt.n	8026626 <tSampler_setStart+0x102>
        if (tempflip != p->flip && p->flipStart < 0)
 80265a8:	f994 301d 	ldrsb.w	r3, [r4, #29]
 80265ac:	42b3      	cmp	r3, r6
 80265ae:	d001      	beq.n	80265b4 <tSampler_setStart+0x90>
            p->flipIdx = 0;
 80265b0:	2300      	movs	r3, #0
 80265b2:	6523      	str	r3, [r4, #80]	; 0x50
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
 80265b4:	6863      	ldr	r3, [r4, #4]
 80265b6:	4605      	mov	r5, r0
 80265b8:	2000      	movs	r0, #0
 80265ba:	691a      	ldr	r2, [r3, #16]
 80265bc:	3a01      	subs	r2, #1
 80265be:	f7fd fc8d 	bl	8023edc <LEAF_clipInt>
 80265c2:	6220      	str	r0, [r4, #32]
    handleStartEndChange(sp);
 80265c4:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
 80265c6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80265c8:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 80265ca:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
 80265ce:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 80265d0:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
 80265d4:	2900      	cmp	r1, #0
 80265d6:	bfb8      	it	lt
 80265d8:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 80265da:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
 80265de:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 80265e0:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
 80265e4:	eef4 7ac7 	vcmpe.f32	s15, s14
 80265e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80265ec:	dd03      	ble.n	80265f6 <tSampler_setStart+0xd2>
 80265ee:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 80265f2:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
 80265f6:	4282      	cmp	r2, r0
 80265f8:	bfac      	ite	ge
 80265fa:	2201      	movge	r2, #1
 80265fc:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetstart = -1;
 8026600:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8026604:	775a      	strb	r2, [r3, #29]
 8026606:	e7b1      	b.n	802656c <tSampler_setStart+0x48>
        else if ((tempflip < 0) && (dir < 0)) // start is end and we're playing in reverse
 8026608:	2a00      	cmp	r2, #0
 802660a:	dacd      	bge.n	80265a8 <tSampler_setStart+0x84>
 802660c:	2f00      	cmp	r7, #0
 802660e:	d0cb      	beq.n	80265a8 <tSampler_setStart+0x84>
            if (start < p->idx)// start given is before current index or we're in a crossfade
 8026610:	ee07 1a90 	vmov	s15, r1
 8026614:	edd4 6a03 	vldr	s13, [r4, #12]
 8026618:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802661c:	eef4 7ae6 	vcmpe.f32	s15, s13
 8026620:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026624:	d5c0      	bpl.n	80265a8 <tSampler_setStart+0x84>
                float tempLen = abs(p->end - start) * 0.25f;
 8026626:	1a5b      	subs	r3, r3, r1
                if (cfxlen > tempLen)
 8026628:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetstart = start;
 802662c:	6261      	str	r1, [r4, #36]	; 0x24
                float tempLen = abs(p->end - start) * 0.25f;
 802662e:	2b00      	cmp	r3, #0
 8026630:	bfb8      	it	lt
 8026632:	425b      	neglt	r3, r3
 8026634:	ee07 3a90 	vmov	s15, r3
 8026638:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
 802663c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8026640:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026644:	dd93      	ble.n	802656e <tSampler_setStart+0x4a>
                    p->cfxlen = tempLen;
 8026646:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 802664a:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
 802664e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08026650 <tSampler_setEnd>:

void tSampler_setEnd       (tSampler* const sp, int32_t end)
{
 8026650:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
 8026652:	6804      	ldr	r4, [r0, #0]
    if (end == p->start)
    {
        return;
    }
    */
    if (p->active) // only bother with these checks if we're actually playing
 8026654:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8026656:	2b00      	cmp	r3, #0
 8026658:	d042      	beq.n	80266e0 <tSampler_setEnd+0x90>
    {
        if (p->start > end)
 802665a:	6a23      	ldr	r3, [r4, #32]
 802665c:	428b      	cmp	r3, r1
 802665e:	dc1d      	bgt.n	802669c <tSampler_setEnd+0x4c>
 8026660:	2501      	movs	r5, #1
 8026662:	2700      	movs	r7, #0
        {
            tempflip = -1;
        }
        else
        {
            tempflip = 1;
 8026664:	462e      	mov	r6, r5
        }
        
        int dir = p->bnf * p->dir * tempflip;
        
        uint32_t cfxlen = p->cfxlen;
 8026666:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802666a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 802666e:	eef8 6a47 	vcvt.f32.u32	s13, s14
        
        if (p->inCrossfade || p->flipStart >= 0)
 8026672:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 8026676:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
 802667a:	eef4 7ae6 	vcmpe.f32	s15, s13
 802667e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026682:	bf48      	it	mi
 8026684:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
 8026688:	b932      	cbnz	r2, 8026698 <tSampler_setEnd+0x48>
 802668a:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
 802668e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8026692:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026696:	db06      	blt.n	80266a6 <tSampler_setEnd+0x56>
        }
    }
    
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
    handleStartEndChange(sp);
    p->targetend = -1;
 8026698:	62e1      	str	r1, [r4, #44]	; 0x2c
}
 802669a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (p->start > end)
 802669c:	2701      	movs	r7, #1
 802669e:	2500      	movs	r5, #0
            tempflip = -1;
 80266a0:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 80266a4:	e7df      	b.n	8026666 <tSampler_setEnd+0x16>
        int dir = p->bnf * p->dir * tempflip;
 80266a6:	f994 201e 	ldrsb.w	r2, [r4, #30]
 80266aa:	f994 c01c 	ldrsb.w	ip, [r4, #28]
 80266ae:	fb12 f20c 	smulbb	r2, r2, ip
 80266b2:	fb06 f202 	mul.w	r2, r6, r2
        if (tempflip > 0 && dir < 0) // end is end and we're playing in reverse
 80266b6:	2a00      	cmp	r2, #0
 80266b8:	da3c      	bge.n	8026734 <tSampler_setEnd+0xe4>
 80266ba:	2d00      	cmp	r5, #0
 80266bc:	d03a      	beq.n	8026734 <tSampler_setEnd+0xe4>
            if (end < p->idx) // end given is before current index or we're in a crossfade
 80266be:	ee07 1a90 	vmov	s15, r1
 80266c2:	edd4 6a03 	vldr	s13, [r4, #12]
 80266c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80266ca:	eef4 7ae6 	vcmpe.f32	s15, s13
 80266ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80266d2:	d43e      	bmi.n	8026752 <tSampler_setEnd+0x102>
        if (tempflip != p->flip && p->flipStart < 0)
 80266d4:	f994 301d 	ldrsb.w	r3, [r4, #29]
 80266d8:	42b3      	cmp	r3, r6
 80266da:	d001      	beq.n	80266e0 <tSampler_setEnd+0x90>
            p->flipIdx = 0;
 80266dc:	2300      	movs	r3, #0
 80266de:	6523      	str	r3, [r4, #80]	; 0x50
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
 80266e0:	6863      	ldr	r3, [r4, #4]
 80266e2:	4605      	mov	r5, r0
 80266e4:	2000      	movs	r0, #0
 80266e6:	691a      	ldr	r2, [r3, #16]
 80266e8:	3a01      	subs	r2, #1
 80266ea:	f7fd fbf7 	bl	8023edc <LEAF_clipInt>
 80266ee:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
 80266f0:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
 80266f2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80266f4:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 80266f6:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
 80266fa:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 80266fc:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
 8026700:	2900      	cmp	r1, #0
 8026702:	bfb8      	it	lt
 8026704:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 8026706:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
 802670a:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802670c:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
 8026710:	eef4 7ac7 	vcmpe.f32	s15, s14
 8026714:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026718:	dd03      	ble.n	8026722 <tSampler_setEnd+0xd2>
 802671a:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 802671e:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
 8026722:	4282      	cmp	r2, r0
 8026724:	bfac      	ite	ge
 8026726:	2201      	movge	r2, #1
 8026728:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetend = -1;
 802672c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8026730:	775a      	strb	r2, [r3, #29]
 8026732:	e7b1      	b.n	8026698 <tSampler_setEnd+0x48>
        else if (tempflip < 0 && dir > 0) // end is start and we're playing forward
 8026734:	2a00      	cmp	r2, #0
 8026736:	ddcd      	ble.n	80266d4 <tSampler_setEnd+0x84>
 8026738:	2f00      	cmp	r7, #0
 802673a:	d0cb      	beq.n	80266d4 <tSampler_setEnd+0x84>
            if (end > p->idx) // end given is after current index or we're in a crossfade
 802673c:	ee07 1a90 	vmov	s15, r1
 8026740:	edd4 6a03 	vldr	s13, [r4, #12]
 8026744:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026748:	eef4 7ae6 	vcmpe.f32	s15, s13
 802674c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026750:	ddc0      	ble.n	80266d4 <tSampler_setEnd+0x84>
                float tempLen = abs(end - p->start) * 0.25f;
 8026752:	1acb      	subs	r3, r1, r3
                if (cfxlen > tempLen)
 8026754:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetend = end;
 8026758:	62e1      	str	r1, [r4, #44]	; 0x2c
                float tempLen = abs(end - p->start) * 0.25f;
 802675a:	2b00      	cmp	r3, #0
 802675c:	bfb8      	it	lt
 802675e:	425b      	neglt	r3, r3
 8026760:	ee07 3a90 	vmov	s15, r3
 8026764:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
 8026768:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802676c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026770:	dd93      	ble.n	802669a <tSampler_setEnd+0x4a>
                    p->cfxlen = tempLen;
 8026772:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8026776:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
 802677a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0802677c <tSampler_tick>:
{
 802677c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026780:	ed2d 8b06 	vpush	{d8-d10}
    _tSampler* p = *sp;
 8026784:	6804      	ldr	r4, [r0, #0]
{
 8026786:	b087      	sub	sp, #28
 8026788:	4605      	mov	r5, r0
    if (p->targetstart >= 0)
 802678a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 802678c:	2900      	cmp	r1, #0
 802678e:	db01      	blt.n	8026794 <tSampler_tick+0x18>
        tSampler_setStart(sp, p->targetstart);
 8026790:	f7ff fec8 	bl	8026524 <tSampler_setStart>
    if (p->targetend >= 0)
 8026794:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8026796:	2900      	cmp	r1, #0
 8026798:	db02      	blt.n	80267a0 <tSampler_tick+0x24>
        tSampler_setEnd(sp, p->targetend);
 802679a:	4628      	mov	r0, r5
 802679c:	f7ff ff58 	bl	8026650 <tSampler_setEnd>
    if (p->active == 0)         return 0.f;
 80267a0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80267a2:	2b00      	cmp	r3, #0
 80267a4:	f000 8133 	beq.w	8026a0e <tSampler_tick+0x292>
    if ((p->inc == 0.0f) || (p->len < 2))
 80267a8:	edd4 7a04 	vldr	s15, [r4, #16]
 80267ac:	eef5 7a40 	vcmp.f32	s15, #0.0
 80267b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80267b4:	f000 8122 	beq.w	80269fc <tSampler_tick+0x280>
 80267b8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80267ba:	2b01      	cmp	r3, #1
 80267bc:	f240 811e 	bls.w	80269fc <tSampler_tick+0x280>
    if (p->flip < 0)
 80267c0:	f994 701d 	ldrsb.w	r7, [r4, #29]
    float* buff = p->samp->buff;
 80267c4:	6862      	ldr	r2, [r4, #4]
    int myStart = p->start;
 80267c6:	6a21      	ldr	r1, [r4, #32]
    if (p->flip < 0)
 80267c8:	2f00      	cmp	r7, #0
    float* buff = p->samp->buff;
 80267ca:	f8d2 a004 	ldr.w	sl, [r2, #4]
    int myStart = p->start;
 80267ce:	9101      	str	r1, [sp, #4]
    int myEnd = p->end;
 80267d0:	f8d4 9028 	ldr.w	r9, [r4, #40]	; 0x28
    if (p->flip < 0)
 80267d4:	db02      	blt.n	80267dc <tSampler_tick+0x60>
 80267d6:	464b      	mov	r3, r9
    int myStart = p->start;
 80267d8:	4689      	mov	r9, r1
    int myEnd = p->end;
 80267da:	9301      	str	r3, [sp, #4]
    int dir = p->bnf * p->dir * p->flip;
 80267dc:	f994 101c 	ldrsb.w	r1, [r4, #28]
 80267e0:	f994 301e 	ldrsb.w	r3, [r4, #30]
    int idx = (int) p->idx;
 80267e4:	edd4 7a03 	vldr	s15, [r4, #12]
    int dir = p->bnf * p->dir * p->flip;
 80267e8:	fb13 f301 	smulbb	r3, r3, r1
    int length = p->samp->recordedLength;
 80267ec:	f8d2 b010 	ldr.w	fp, [r2, #16]
    int idx = (int) p->idx;
 80267f0:	eebd 9ae7 	vcvt.s32.f32	s18, s15
    int dir = p->bnf * p->dir * p->flip;
 80267f4:	fb07 f703 	mul.w	r7, r7, r3
    int i4 = idx+(2*dir);
 80267f8:	007b      	lsls	r3, r7, #1
    float alpha = rev + (p->idx - idx) * dir;
 80267fa:	ee06 7a90 	vmov	s13, r7
    if (dir < 0) rev = 1;
 80267fe:	0ffe      	lsrs	r6, r7, #31
    float alpha = rev + (p->idx - idx) * dir;
 8026800:	eeb8 7ac9 	vcvt.f32.s32	s14, s18
    int i4 = idx+(2*dir);
 8026804:	9302      	str	r3, [sp, #8]
    idx += rev;
 8026806:	ee19 3a10 	vmov	r3, s18
 802680a:	f1c6 0101 	rsb	r1, r6, #1
    float alpha = rev + (p->idx - idx) * dir;
 802680e:	eef8 9ae6 	vcvt.f32.s32	s19, s13
    idx += rev;
 8026812:	eb03 0806 	add.w	r8, r3, r6
    float alpha = rev + (p->idx - idx) * dir;
 8026816:	ee06 6a90 	vmov	s13, r6
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
 802681a:	fb06 f60b 	mul.w	r6, r6, fp
    float alpha = rev + (p->idx - idx) * dir;
 802681e:	ee77 7ac7 	vsub.f32	s15, s15, s14
    int i1 = idx-(1*dir);
 8026822:	eba8 0307 	sub.w	r3, r8, r7
 8026826:	9103      	str	r1, [sp, #12]
 8026828:	fb01 f10b 	mul.w	r1, r1, fp
    int i3 = idx+(1*dir);
 802682c:	eb07 0e08 	add.w	lr, r7, r8
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
 8026830:	429e      	cmp	r6, r3
    float alpha = rev + (p->idx - idx) * dir;
 8026832:	eef8 8ae6 	vcvt.f32.s32	s17, s13
    int i4 = idx+(2*dir);
 8026836:	eb07 020e 	add.w	r2, r7, lr
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
 802683a:	bfcc      	ite	gt
 802683c:	185b      	addgt	r3, r3, r1
 802683e:	1b9b      	suble	r3, r3, r6
    i2 = (i2 < length*rev) ? i2 + (length * (1-rev)) : i2 - (length * rev);
 8026840:	4546      	cmp	r6, r8
    float alpha = rev + (p->idx - idx) * dir;
 8026842:	eee7 8aa9 	vfma.f32	s17, s15, s19
    i2 = (i2 < length*rev) ? i2 + (length * (1-rev)) : i2 - (length * rev);
 8026846:	bfcc      	ite	gt
 8026848:	eb08 0c01 	addgt.w	ip, r8, r1
 802684c:	eba8 0c06 	suble.w	ip, r8, r6
    i3 = (i3 < length*(1-rev)) ? i3 + (length * rev) : i3 - (length * (1-rev));
 8026850:	458e      	cmp	lr, r1
 8026852:	f280 80ed 	bge.w	8026a30 <tSampler_tick+0x2b4>
 8026856:	eb06 000e 	add.w	r0, r6, lr
    i4 = (i4 < length*(1-rev)) ? i4 + (length * rev) : i4 - (length * (1-rev));
 802685a:	428a      	cmp	r2, r1
 802685c:	f280 80e4 	bge.w	8026a28 <tSampler_tick+0x2ac>
 8026860:	4432      	add	r2, r6
    sample = LEAF_interpolate_hermite_x (buff[i1],
 8026862:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
 8026866:	eeb0 2a68 	vmov.f32	s4, s17
 802686a:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
 802686e:	9102      	str	r1, [sp, #8]
 8026870:	eb0a 0c8c 	add.w	ip, sl, ip, lsl #2
 8026874:	ed90 1a00 	vldr	s2, [r0]
 8026878:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
 802687c:	edd2 1a00 	vldr	s3, [r2]
 8026880:	eddc 0a00 	vldr	s1, [ip]
 8026884:	ed93 0a00 	vldr	s0, [r3]
 8026888:	f7fd fc2e 	bl	80240e8 <LEAF_interpolate_hermite_x>
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802688c:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
    int32_t cfxlen = p->cfxlen;
 8026890:	6b60      	ldr	r0, [r4, #52]	; 0x34
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 8026892:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
 8026896:	eef8 0a47 	vcvt.f32.u32	s1, s14
 802689a:	9902      	ldr	r1, [sp, #8]
 802689c:	ee07 0a10 	vmov	s14, r0
    sample = LEAF_interpolate_hermite_x (buff[i1],
 80268a0:	eeb0 8a40 	vmov.f32	s16, s0
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 80268a4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80268a8:	ee60 7aa7 	vmul.f32	s15, s1, s15
 80268ac:	eef4 7ac7 	vcmpe.f32	s15, s14
 80268b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80268b4:	d503      	bpl.n	80268be <tSampler_tick+0x142>
 80268b6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80268ba:	ee17 0a90 	vmov	r0, s15
    if (myStart >= cfxlen) fadeLeftStart = myStart - cfxlen;
 80268be:	4581      	cmp	r9, r0
 80268c0:	f2c0 80ae 	blt.w	8026a20 <tSampler_tick+0x2a4>
 80268c4:	eba9 0c00 	sub.w	ip, r9, r0
 80268c8:	f8cd 9008 	str.w	r9, [sp, #8]
    if (p->mode == PlayLoop)
 80268cc:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
 80268d0:	2a01      	cmp	r2, #1
 80268d2:	f000 80d7 	beq.w	8026a84 <tSampler_tick+0x308>
 80268d6:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
    float inc = fmodf(p->inc, (float)p->len);
 80268da:	ed94 0a04 	vldr	s0, [r4, #16]
 80268de:	f001 f87b 	bl	80279d8 <fmodf>
    p->idx += (dir * inc);
 80268e2:	edd4 7a03 	vldr	s15, [r4, #12]
    if (p->flipStart >= 0)
 80268e6:	eef5 8ac0 	vcmpe.f32	s17, #0.0
    p->idx += (dir * inc);
 80268ea:	eee9 7a80 	vfma.f32	s15, s19, s0
    if (p->flipStart >= 0)
 80268ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    p->idx += (dir * inc);
 80268f2:	edc4 7a03 	vstr	s15, [r4, #12]
    if (p->flipStart >= 0)
 80268f6:	db28      	blt.n	802694a <tSampler_tick+0x1ce>
        p->flipIdx += (-dir * inc);
 80268f8:	427b      	negs	r3, r7
 80268fa:	edd4 6a14 	vldr	s13, [r4, #80]	; 0x50
 80268fe:	ee07 3a10 	vmov	s14, r3
 8026902:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8026906:	eee7 6a00 	vfma.f32	s13, s14, s0
 802690a:	eeb0 7a66 	vmov.f32	s14, s13
        if((int)p->flipIdx < 0)
 802690e:	eefd 6ae6 	vcvt.s32.f32	s13, s13
        p->flipIdx += (-dir * inc);
 8026912:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
        if((int)p->flipIdx < 0)
 8026916:	ee16 3a90 	vmov	r3, s13
 802691a:	2b00      	cmp	r3, #0
 802691c:	da07      	bge.n	802692e <tSampler_tick+0x1b2>
            p->idx += (float)length;
 802691e:	ee07 ba10 	vmov	s14, fp
 8026922:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8026926:	ee77 7a87 	vadd.f32	s15, s15, s14
 802692a:	edc4 7a03 	vstr	s15, [r4, #12]
        if((int)p->idx >= length)
 802692e:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8026932:	ee17 3a10 	vmov	r3, s14
 8026936:	455b      	cmp	r3, fp
 8026938:	db07      	blt.n	802694a <tSampler_tick+0x1ce>
            p->idx -= (float)length;
 802693a:	ee07 ba10 	vmov	s14, fp
 802693e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8026942:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8026946:	edc4 7a03 	vstr	s15, [r4, #12]
    _tSampler* p = *sp;
 802694a:	682e      	ldr	r6, [r5, #0]
    if (p->targetstart >= 0)
 802694c:	6a71      	ldr	r1, [r6, #36]	; 0x24
 802694e:	2900      	cmp	r1, #0
 8026950:	db02      	blt.n	8026958 <tSampler_tick+0x1dc>
        tSampler_setStart(sp, p->targetstart);
 8026952:	4628      	mov	r0, r5
 8026954:	f7ff fde6 	bl	8026524 <tSampler_setStart>
    if (p->targetend >= 0)
 8026958:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 802695a:	2900      	cmp	r1, #0
 802695c:	db02      	blt.n	8026964 <tSampler_tick+0x1e8>
        tSampler_setEnd(sp, p->targetend);
 802695e:	4628      	mov	r0, r5
 8026960:	f7ff fe76 	bl	8026650 <tSampler_setEnd>
    if (p->mode == PlayLoop)
 8026964:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 8026968:	f104 0508 	add.w	r5, r4, #8
 802696c:	2b01      	cmp	r3, #1
 802696e:	d063      	beq.n	8026a38 <tSampler_tick+0x2bc>
    else if (p->mode == PlayBackAndForth)
 8026970:	2b02      	cmp	r3, #2
 8026972:	f000 8116 	beq.w	8026ba2 <tSampler_tick+0x426>
    if (p->mode == PlayNormal)
 8026976:	bb7b      	cbnz	r3, 80269d8 <tSampler_tick+0x25c>
        if (p->idx < myStart)
 8026978:	ee07 9a90 	vmov	s15, r9
 802697c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8026980:	edd4 7a03 	vldr	s15, [r4, #12]
 8026984:	eef4 7ac7 	vcmpe.f32	s15, s14
 8026988:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802698c:	f140 80ee 	bpl.w	8026b6c <tSampler_tick+0x3f0>
            p->idx = myEnd;
 8026990:	ed84 7a03 	vstr	s14, [r4, #12]
        float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
 8026994:	2f00      	cmp	r7, #0
 8026996:	ed94 7a06 	vldr	s14, [r4, #24]
 802699a:	f2c0 80de 	blt.w	8026b5a <tSampler_tick+0x3de>
 802699e:	9b01      	ldr	r3, [sp, #4]
 80269a0:	eba3 0308 	sub.w	r3, r3, r8
 80269a4:	ee07 3a90 	vmov	s15, r3
 80269a8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80269ac:	ee67 7a87 	vmul.f32	s15, s15, s14
        if (ticksToEnd < (0.007f * leaf.sampleRate))
 80269b0:	4bd9      	ldr	r3, [pc, #868]	; (8026d18 <tSampler_tick+0x59c>)
 80269b2:	eddf 6ada 	vldr	s13, [pc, #872]	; 8026d1c <tSampler_tick+0x5a0>
 80269b6:	ed93 7a00 	vldr	s14, [r3]
 80269ba:	ee27 7a26 	vmul.f32	s14, s14, s13
 80269be:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80269c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80269c6:	dd07      	ble.n	80269d8 <tSampler_tick+0x25c>
            tRamp_setDest(&p->gain, 0.f);
 80269c8:	ed9f 0ad5 	vldr	s0, [pc, #852]	; 8026d20 <tSampler_tick+0x5a4>
 80269cc:	4628      	mov	r0, r5
 80269ce:	f7fb fd29 	bl	8022424 <tRamp_setDest>
            p->active = -1;
 80269d2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80269d6:	6463      	str	r3, [r4, #68]	; 0x44
    sample = sample * tRamp_tick(&p->gain);
 80269d8:	4628      	mov	r0, r5
 80269da:	f7fb fd3f 	bl	802245c <tRamp_tick>
    if (p->active < 0)
 80269de:	6c63      	ldr	r3, [r4, #68]	; 0x44
    sample = sample * tRamp_tick(&p->gain);
 80269e0:	ee20 8a08 	vmul.f32	s16, s0, s16
    if (p->active < 0)
 80269e4:	2b00      	cmp	r3, #0
 80269e6:	f2c0 80f3 	blt.w	8026bd0 <tSampler_tick+0x454>
}
 80269ea:	eeb0 0a48 	vmov.f32	s0, s16
    p->last = sample;
 80269ee:	ed84 8a05 	vstr	s16, [r4, #20]
}
 80269f2:	b007      	add	sp, #28
 80269f4:	ecbd 8b06 	vpop	{d8-d10}
 80269f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return p->last;
 80269fc:	ed94 8a05 	vldr	s16, [r4, #20]
}
 8026a00:	eeb0 0a48 	vmov.f32	s0, s16
 8026a04:	b007      	add	sp, #28
 8026a06:	ecbd 8b06 	vpop	{d8-d10}
 8026a0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (p->active == 0)         return 0.f;
 8026a0e:	ed9f 8ac4 	vldr	s16, [pc, #784]	; 8026d20 <tSampler_tick+0x5a4>
}
 8026a12:	eeb0 0a48 	vmov.f32	s0, s16
 8026a16:	b007      	add	sp, #28
 8026a18:	ecbd 8b06 	vpop	{d8-d10}
 8026a1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026a20:	9002      	str	r0, [sp, #8]
    int32_t fadeLeftStart = 0;
 8026a22:	f04f 0c00 	mov.w	ip, #0
 8026a26:	e751      	b.n	80268cc <tSampler_tick+0x150>
    i4 = (i4 < length*(1-rev)) ? i4 + (length * rev) : i4 - (length * (1-rev));
 8026a28:	eba6 0e0b 	sub.w	lr, r6, fp
 8026a2c:	4472      	add	r2, lr
 8026a2e:	e718      	b.n	8026862 <tSampler_tick+0xe6>
    i3 = (i3 < length*(1-rev)) ? i3 + (length * rev) : i3 - (length * (1-rev));
 8026a30:	eba6 000b 	sub.w	r0, r6, fp
 8026a34:	4470      	add	r0, lr
 8026a36:	e710      	b.n	802685a <tSampler_tick+0xde>
        if((int)p->idx < myStart)
 8026a38:	edd4 7a03 	vldr	s15, [r4, #12]
 8026a3c:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8026a40:	ee17 3a10 	vmov	r3, s14
 8026a44:	454b      	cmp	r3, r9
 8026a46:	da0e      	bge.n	8026a66 <tSampler_tick+0x2ea>
            p->idx += (float)(fadeRightEnd - fadeLeftEnd);
 8026a48:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 8026a4c:	1a9b      	subs	r3, r3, r2
 8026a4e:	ee07 3a10 	vmov	s14, r3
 8026a52:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8026a56:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026a5a:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8026a5e:	edc4 7a03 	vstr	s15, [r4, #12]
 8026a62:	ee17 3a10 	vmov	r3, s14
        if((int)p->idx > myEnd)
 8026a66:	9a01      	ldr	r2, [sp, #4]
 8026a68:	429a      	cmp	r2, r3
 8026a6a:	4611      	mov	r1, r2
 8026a6c:	dab4      	bge.n	80269d8 <tSampler_tick+0x25c>
            p->idx -= (float)(fadeRightEnd - fadeLeftEnd);
 8026a6e:	9a02      	ldr	r2, [sp, #8]
 8026a70:	1a8b      	subs	r3, r1, r2
 8026a72:	ee07 3a10 	vmov	s14, r3
 8026a76:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8026a7a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8026a7e:	edc4 7a03 	vstr	s15, [r4, #12]
 8026a82:	e7a9      	b.n	80269d8 <tSampler_tick+0x25c>
 8026a84:	ee07 0a90 	vmov	s15, r0
        if ((fadeLeftStart <= idx) && (idx <= fadeLeftEnd))
 8026a88:	45c4      	cmp	ip, r8
 8026a8a:	eeb8 aae7 	vcvt.f32.s32	s20, s15
 8026a8e:	dc78      	bgt.n	8026b82 <tSampler_tick+0x406>
 8026a90:	9b02      	ldr	r3, [sp, #8]
 8026a92:	4598      	cmp	r8, r3
 8026a94:	dc75      	bgt.n	8026b82 <tSampler_tick+0x406>
            offset = fadeLeftEnd - idx;
 8026a96:	eba3 0308 	sub.w	r3, r3, r8
            p->inCrossfade = 1;
 8026a9a:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
            cdx = fadeRightEnd - offset;
 8026a9e:	9a01      	ldr	r2, [sp, #4]
            offset = fadeLeftEnd - idx;
 8026aa0:	9304      	str	r3, [sp, #16]
            cdx = fadeRightEnd - offset;
 8026aa2:	1ad3      	subs	r3, r2, r3
            int c1 = cdx-(1*dir);
 8026aa4:	eba3 0e07 	sub.w	lr, r3, r7
            c1 = (c1 < length * rev) ? c1 + (length * (1-rev)) : c1 - (length * rev);
 8026aa8:	4576      	cmp	r6, lr
 8026aaa:	f340 812d 	ble.w	8026d08 <tSampler_tick+0x58c>
 8026aae:	448e      	add	lr, r1
            c2 = (c2 < length * rev) ? c2 + (length * (1-rev)) : c2 - (length * rev);
 8026ab0:	429e      	cmp	r6, r3
 8026ab2:	bfcc      	ite	gt
 8026ab4:	eb03 0c01 	addgt.w	ip, r3, r1
 8026ab8:	eba3 0c06 	suble.w	ip, r3, r6
            int c3 = cdx+(1*dir);
 8026abc:	443b      	add	r3, r7
            c3 = (c3 < length * (1-rev)) ? c3 + (length * rev) : c3 - (length * (1-rev));
 8026abe:	428b      	cmp	r3, r1
 8026ac0:	f280 811e 	bge.w	8026d00 <tSampler_tick+0x584>
 8026ac4:	18f2      	adds	r2, r6, r3
            int c4 = cdx+(2*dir);
 8026ac6:	443b      	add	r3, r7
            c4 = (c4 < length * (1-rev)) ? c4 + (length * rev) : c4 - (length * (1-rev));
 8026ac8:	428b      	cmp	r3, r1
 8026aca:	f280 8120 	bge.w	8026d0e <tSampler_tick+0x592>
 8026ace:	4433      	add	r3, r6
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
 8026ad0:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
 8026ad4:	eeb0 2a68 	vmov.f32	s4, s17
 8026ad8:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
 8026adc:	9105      	str	r1, [sp, #20]
 8026ade:	eb0a 008c 	add.w	r0, sl, ip, lsl #2
 8026ae2:	edd3 1a00 	vldr	s3, [r3]
 8026ae6:	eb0a 038e 	add.w	r3, sl, lr, lsl #2
 8026aea:	ed92 1a00 	vldr	s2, [r2]
 8026aee:	edd0 0a00 	vldr	s1, [r0]
 8026af2:	ed93 0a00 	vldr	s0, [r3]
 8026af6:	f7fd faf7 	bl	80240e8 <LEAF_interpolate_hermite_x>
            crossfadeMix = (float) offset / (float) cfxlen;
 8026afa:	eddd 7a04 	vldr	s15, [sp, #16]
 8026afe:	9905      	ldr	r1, [sp, #20]
 8026b00:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8026b04:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8026b08:	ee86 7a8a 	vdiv.f32	s14, s13, s20
 8026b0c:	ee20 0a07 	vmul.f32	s0, s0, s14
 8026b10:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8026b14:	eea8 0a27 	vfma.f32	s0, s16, s15
 8026b18:	eeb0 8a40 	vmov.f32	s16, s0
        float flipLength = fabsf(p->flipIdx - p->flipStart);
 8026b1c:	ed94 7a14 	vldr	s14, [r4, #80]	; 0x50
 8026b20:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
 8026b24:	ee77 7a68 	vsub.f32	s15, s14, s17
 8026b28:	eef0 7ae7 	vabs.f32	s15, s15
        if (flipLength > cfxlen)
 8026b2c:	eef4 7aca 	vcmpe.f32	s15, s20
 8026b30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026b34:	dd5e      	ble.n	8026bf4 <tSampler_tick+0x478>
            p->flipStart = -1;
 8026b36:	4b7b      	ldr	r3, [pc, #492]	; (8026d24 <tSampler_tick+0x5a8>)
    float inc = fmodf(p->inc, (float)p->len);
 8026b38:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 8026b3c:	ed94 0a04 	vldr	s0, [r4, #16]
 8026b40:	eef8 0a67 	vcvt.f32.u32	s1, s15
            p->flipStart = -1;
 8026b44:	64e3      	str	r3, [r4, #76]	; 0x4c
            p->flipIdx = -1;
 8026b46:	6523      	str	r3, [r4, #80]	; 0x50
    float inc = fmodf(p->inc, (float)p->len);
 8026b48:	f000 ff46 	bl	80279d8 <fmodf>
    p->idx += (dir * inc);
 8026b4c:	edd4 7a03 	vldr	s15, [r4, #12]
 8026b50:	eee9 7a80 	vfma.f32	s15, s19, s0
 8026b54:	edc4 7a03 	vstr	s15, [r4, #12]
 8026b58:	e6f7      	b.n	802694a <tSampler_tick+0x1ce>
        float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
 8026b5a:	eba8 0309 	sub.w	r3, r8, r9
 8026b5e:	ee07 3a90 	vmov	s15, r3
 8026b62:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026b66:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026b6a:	e721      	b.n	80269b0 <tSampler_tick+0x234>
        else if (p->idx > myEnd)
 8026b6c:	ed9d 7a01 	vldr	s14, [sp, #4]
 8026b70:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8026b74:	eef4 7ac7 	vcmpe.f32	s15, s14
 8026b78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026b7c:	f77f af0a 	ble.w	8026994 <tSampler_tick+0x218>
 8026b80:	e706      	b.n	8026990 <tSampler_tick+0x214>
    int32_t fadeRightStart = fadeRightEnd - cfxlen;
 8026b82:	9b01      	ldr	r3, [sp, #4]
 8026b84:	1a18      	subs	r0, r3, r0
        else if ((fadeRightStart <= idx) && (idx <= fadeRightEnd))
 8026b86:	4580      	cmp	r8, r0
 8026b88:	f2c0 80b6 	blt.w	8026cf8 <tSampler_tick+0x57c>
 8026b8c:	4543      	cmp	r3, r8
 8026b8e:	f2c0 80b3 	blt.w	8026cf8 <tSampler_tick+0x57c>
            offset = idx - fadeRightStart;
 8026b92:	eba8 0300 	sub.w	r3, r8, r0
            p->inCrossfade = 1;
 8026b96:	2201      	movs	r2, #1
            offset = idx - fadeRightStart;
 8026b98:	9304      	str	r3, [sp, #16]
            cdx = fadeLeftStart + offset;
 8026b9a:	4463      	add	r3, ip
            p->inCrossfade = 1;
 8026b9c:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
 8026ba0:	e780      	b.n	8026aa4 <tSampler_tick+0x328>
        if (p->idx < myStart)
 8026ba2:	ee07 9a90 	vmov	s15, r9
 8026ba6:	ed94 7a03 	vldr	s14, [r4, #12]
 8026baa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026bae:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8026bb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026bb6:	d576      	bpl.n	8026ca6 <tSampler_tick+0x52a>
            p->idx = myStart + 1;
 8026bb8:	f109 0901 	add.w	r9, r9, #1
            p->bnf = -p->bnf;
 8026bbc:	7fa3      	ldrb	r3, [r4, #30]
            p->idx = myStart + 1;
 8026bbe:	ee07 9a90 	vmov	s15, r9
            p->bnf = -p->bnf;
 8026bc2:	425b      	negs	r3, r3
            p->idx = myStart + 1;
 8026bc4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            p->bnf = -p->bnf;
 8026bc8:	77a3      	strb	r3, [r4, #30]
            p->idx = myStart + 1;
 8026bca:	edc4 7a03 	vstr	s15, [r4, #12]
 8026bce:	e703      	b.n	80269d8 <tSampler_tick+0x25c>
        if (tRamp_sample(&p->gain) <= 0.00001f)
 8026bd0:	4628      	mov	r0, r5
 8026bd2:	f7fb fc6b 	bl	80224ac <tRamp_sample>
 8026bd6:	eddf 7a54 	vldr	s15, [pc, #336]	; 8026d28 <tSampler_tick+0x5ac>
 8026bda:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8026bde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026be2:	f63f af02 	bhi.w	80269ea <tSampler_tick+0x26e>
            if (p->retrigger == 1)
 8026be6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8026be8:	2b01      	cmp	r3, #1
 8026bea:	f000 809f 	beq.w	8026d2c <tSampler_tick+0x5b0>
                p->active = 0;
 8026bee:	2300      	movs	r3, #0
 8026bf0:	6463      	str	r3, [r4, #68]	; 0x44
 8026bf2:	e6fa      	b.n	80269ea <tSampler_tick+0x26e>
        if (p->flipIdx >= 0)
 8026bf4:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 8026bf8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026bfc:	db4e      	blt.n	8026c9c <tSampler_tick+0x520>
            if (p->flipStart == -1)
 8026bfe:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
 8026c02:	eef4 8a66 	vcmp.f32	s17, s13
 8026c06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026c0a:	d06a      	beq.n	8026ce2 <tSampler_tick+0x566>
 8026c0c:	ee7a 7a67 	vsub.f32	s15, s20, s15
 8026c10:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8026c14:	eec7 8a8a 	vdiv.f32	s17, s15, s20
 8026c18:	ee76 7ae8 	vsub.f32	s15, s13, s17
 8026c1c:	ee27 8a88 	vmul.f32	s16, s15, s16
            int fdx = (int) p->flipIdx;
 8026c20:	eefd 7ac7 	vcvt.s32.f32	s15, s14
            idx += (1-rev);
 8026c24:	ee19 2a10 	vmov	r2, s18
            int f3 = fdx-(1*dir);
 8026c28:	0078      	lsls	r0, r7, #1
            idx += (1-rev);
 8026c2a:	f102 0801 	add.w	r8, r2, #1
            int fdx = (int) p->flipIdx;
 8026c2e:	ee17 3a90 	vmov	r3, s15
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
 8026c32:	eddd 7a03 	vldr	s15, [sp, #12]
 8026c36:	eeb8 2ae7 	vcvt.f32.s32	s4, s15
 8026c3a:	ee07 3a90 	vmov	s15, r3
            int f1 = fdx+(1*dir);
 8026c3e:	18fa      	adds	r2, r7, r3
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
 8026c40:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            int f3 = fdx-(1*dir);
 8026c44:	1a10      	subs	r0, r2, r0
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
 8026c46:	428a      	cmp	r2, r1
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
 8026c48:	ee37 7ac7 	vsub.f32	s14, s15, s14
            int f4 = fdx-(2*dir);
 8026c4c:	eba0 0c07 	sub.w	ip, r0, r7
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
 8026c50:	eea9 2a87 	vfma.f32	s4, s19, s14
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
 8026c54:	da41      	bge.n	8026cda <tSampler_tick+0x55e>
 8026c56:	4432      	add	r2, r6
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
 8026c58:	428b      	cmp	r3, r1
 8026c5a:	da3a      	bge.n	8026cd2 <tSampler_tick+0x556>
 8026c5c:	4433      	add	r3, r6
            f3 = (f3 < length*rev) ? f3 + (length * (1-rev)) : f3 - (length * rev);
 8026c5e:	4286      	cmp	r6, r0
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
 8026c60:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
            f3 = (f3 < length*rev) ? f3 + (length * (1-rev)) : f3 - (length * rev);
 8026c64:	bfcc      	ite	gt
 8026c66:	1840      	addgt	r0, r0, r1
 8026c68:	1b80      	suble	r0, r0, r6
            f4 = (f4 < length*rev) ? f4 + (length * (1-rev)) : f4 - (length * rev);
 8026c6a:	4566      	cmp	r6, ip
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
 8026c6c:	edd3 0a00 	vldr	s1, [r3]
 8026c70:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
            f4 = (f4 < length*rev) ? f4 + (length * (1-rev)) : f4 - (length * rev);
 8026c74:	bfcc      	ite	gt
 8026c76:	4461      	addgt	r1, ip
 8026c78:	ebac 0106 	suble.w	r1, ip, r6
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
 8026c7c:	ed90 1a00 	vldr	s2, [r0]
 8026c80:	eb0a 0181 	add.w	r1, sl, r1, lsl #2
 8026c84:	eb0a 0a82 	add.w	sl, sl, r2, lsl #2
 8026c88:	edd1 1a00 	vldr	s3, [r1]
 8026c8c:	ed9a 0a00 	vldr	s0, [sl]
 8026c90:	f7fd fa2a 	bl	80240e8 <LEAF_interpolate_hermite_x>
 8026c94:	eea0 8a28 	vfma.f32	s16, s0, s17
 8026c98:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
 8026c9c:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 8026ca0:	eef8 0a67 	vcvt.f32.u32	s1, s15
 8026ca4:	e619      	b.n	80268da <tSampler_tick+0x15e>
        else if (p->idx > myEnd)
 8026ca6:	eddd 7a01 	vldr	s15, [sp, #4]
 8026caa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026cae:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8026cb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026cb6:	f77f ae8f 	ble.w	80269d8 <tSampler_tick+0x25c>
            p->idx = myEnd - 1;
 8026cba:	9b01      	ldr	r3, [sp, #4]
 8026cbc:	3b01      	subs	r3, #1
 8026cbe:	ee07 3a90 	vmov	s15, r3
            p->bnf = -p->bnf;
 8026cc2:	7fa3      	ldrb	r3, [r4, #30]
            p->idx = myEnd - 1;
 8026cc4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            p->bnf = -p->bnf;
 8026cc8:	425b      	negs	r3, r3
 8026cca:	77a3      	strb	r3, [r4, #30]
            p->idx = myEnd - 1;
 8026ccc:	edc4 7a03 	vstr	s15, [r4, #12]
 8026cd0:	e682      	b.n	80269d8 <tSampler_tick+0x25c>
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
 8026cd2:	eba6 0e0b 	sub.w	lr, r6, fp
 8026cd6:	4473      	add	r3, lr
 8026cd8:	e7c1      	b.n	8026c5e <tSampler_tick+0x4e2>
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
 8026cda:	eba6 0e0b 	sub.w	lr, r6, fp
 8026cde:	4472      	add	r2, lr
 8026ce0:	e7ba      	b.n	8026c58 <tSampler_tick+0x4dc>
                p->flipStart = p->idx;
 8026ce2:	ed94 7a03 	vldr	s14, [r4, #12]
                p->flipIdx = p->idx;
 8026ce6:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 8026cea:	ed9f 8a0d 	vldr	s16, [pc, #52]	; 8026d20 <tSampler_tick+0x5a4>
                p->flipStart = p->idx;
 8026cee:	ed84 7a13 	vstr	s14, [r4, #76]	; 0x4c
                p->flipIdx = p->idx;
 8026cf2:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
 8026cf6:	e793      	b.n	8026c20 <tSampler_tick+0x4a4>
        else p->inCrossfade = 0;
 8026cf8:	2300      	movs	r3, #0
 8026cfa:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
 8026cfe:	e70d      	b.n	8026b1c <tSampler_tick+0x3a0>
            c3 = (c3 < length * (1-rev)) ? c3 + (length * rev) : c3 - (length * (1-rev));
 8026d00:	eba6 020b 	sub.w	r2, r6, fp
 8026d04:	441a      	add	r2, r3
 8026d06:	e6de      	b.n	8026ac6 <tSampler_tick+0x34a>
            c1 = (c1 < length * rev) ? c1 + (length * (1-rev)) : c1 - (length * rev);
 8026d08:	ebae 0e06 	sub.w	lr, lr, r6
 8026d0c:	e6d0      	b.n	8026ab0 <tSampler_tick+0x334>
            c4 = (c4 < length * (1-rev)) ? c4 + (length * rev) : c4 - (length * (1-rev));
 8026d0e:	eba6 000b 	sub.w	r0, r6, fp
 8026d12:	4403      	add	r3, r0
 8026d14:	e6dc      	b.n	8026ad0 <tSampler_tick+0x354>
 8026d16:	bf00      	nop
 8026d18:	200194e8 	.word	0x200194e8
 8026d1c:	3be56042 	.word	0x3be56042
 8026d20:	00000000 	.word	0x00000000
 8026d24:	bf800000 	.word	0xbf800000
 8026d28:	3727c5ac 	.word	0x3727c5ac
                p->retrigger = 0;
 8026d2c:	2200      	movs	r2, #0
                p->active = 1;
 8026d2e:	6463      	str	r3, [r4, #68]	; 0x44
                tRamp_setDest(&p->gain, 1.f);
 8026d30:	4628      	mov	r0, r5
 8026d32:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
                p->retrigger = 0;
 8026d36:	6422      	str	r2, [r4, #64]	; 0x40
                tRamp_setDest(&p->gain, 1.f);
 8026d38:	f7fb fb74 	bl	8022424 <tRamp_setDest>
                if (p->dir > 0)
 8026d3c:	f994 301c 	ldrsb.w	r3, [r4, #28]
 8026d40:	2b00      	cmp	r3, #0
                    if (p->flip > 0)    p->idx = p->start;
 8026d42:	f994 301d 	ldrsb.w	r3, [r4, #29]
                if (p->dir > 0)
 8026d46:	dd08      	ble.n	8026d5a <tSampler_tick+0x5de>
                    if (p->flip > 0)    p->idx = p->start;
 8026d48:	2b00      	cmp	r3, #0
 8026d4a:	dd08      	ble.n	8026d5e <tSampler_tick+0x5e2>
                    else                p->idx = p->start;
 8026d4c:	edd4 7a08 	vldr	s15, [r4, #32]
 8026d50:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026d54:	edc4 7a03 	vstr	s15, [r4, #12]
 8026d58:	e647      	b.n	80269ea <tSampler_tick+0x26e>
                    if (p->flip > 0)    p->idx = p->end;
 8026d5a:	2b00      	cmp	r3, #0
 8026d5c:	ddf6      	ble.n	8026d4c <tSampler_tick+0x5d0>
 8026d5e:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
 8026d62:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026d66:	edc4 7a03 	vstr	s15, [r4, #12]
 8026d6a:	e63e      	b.n	80269ea <tSampler_tick+0x26e>

08026d6c <tSampler_setLength>:

void    tSampler_setLength    (tSampler* const sp, int32_t length)
{
 8026d6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
 8026d6e:	6804      	ldr	r4, [r0, #0]
    if (length == 0) length = 1;
 8026d70:	2900      	cmp	r1, #0
 8026d72:	bf14      	ite	ne
 8026d74:	460a      	movne	r2, r1
 8026d76:	2201      	moveq	r2, #1
    tSampler_setEnd(sp, p->start + length);
 8026d78:	6a23      	ldr	r3, [r4, #32]
    if (p->active) // only bother with these checks if we're actually playing
 8026d7a:	6c65      	ldr	r5, [r4, #68]	; 0x44
    tSampler_setEnd(sp, p->start + length);
 8026d7c:	1899      	adds	r1, r3, r2
    if (p->active) // only bother with these checks if we're actually playing
 8026d7e:	2d00      	cmp	r5, #0
 8026d80:	d041      	beq.n	8026e06 <tSampler_setLength+0x9a>
        if (p->start > end)
 8026d82:	428b      	cmp	r3, r1
 8026d84:	dc1d      	bgt.n	8026dc2 <tSampler_setLength+0x56>
 8026d86:	2501      	movs	r5, #1
 8026d88:	2700      	movs	r7, #0
            tempflip = 1;
 8026d8a:	462e      	mov	r6, r5
        uint32_t cfxlen = p->cfxlen;
 8026d8c:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 8026d90:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 8026d94:	eef8 6a47 	vcvt.f32.u32	s13, s14
        if (p->inCrossfade || p->flipStart >= 0)
 8026d98:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 8026d9c:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
 8026da0:	eef4 7ae6 	vcmpe.f32	s15, s13
 8026da4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026da8:	bf48      	it	mi
 8026daa:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
 8026dae:	b933      	cbnz	r3, 8026dbe <tSampler_setLength+0x52>
 8026db0:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
 8026db4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8026db8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026dbc:	db06      	blt.n	8026dcc <tSampler_setLength+0x60>
    p->targetend = -1;
 8026dbe:	62e1      	str	r1, [r4, #44]	; 0x2c
}
 8026dc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (p->start > end)
 8026dc2:	2701      	movs	r7, #1
 8026dc4:	2500      	movs	r5, #0
            tempflip = -1;
 8026dc6:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8026dca:	e7df      	b.n	8026d8c <tSampler_setLength+0x20>
        int dir = p->bnf * p->dir * tempflip;
 8026dcc:	f994 301e 	ldrsb.w	r3, [r4, #30]
 8026dd0:	f994 c01c 	ldrsb.w	ip, [r4, #28]
 8026dd4:	fb13 f30c 	smulbb	r3, r3, ip
 8026dd8:	fb06 f303 	mul.w	r3, r6, r3
        if (tempflip > 0 && dir < 0) // end is end and we're playing in reverse
 8026ddc:	2b00      	cmp	r3, #0
 8026dde:	da3c      	bge.n	8026e5a <tSampler_setLength+0xee>
 8026de0:	2d00      	cmp	r5, #0
 8026de2:	d03a      	beq.n	8026e5a <tSampler_setLength+0xee>
            if (end < p->idx) // end given is before current index or we're in a crossfade
 8026de4:	ee07 1a90 	vmov	s15, r1
 8026de8:	edd4 6a03 	vldr	s13, [r4, #12]
 8026dec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026df0:	eef4 7ae6 	vcmpe.f32	s15, s13
 8026df4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026df8:	d43e      	bmi.n	8026e78 <tSampler_setLength+0x10c>
        if (tempflip != p->flip && p->flipStart < 0)
 8026dfa:	f994 301d 	ldrsb.w	r3, [r4, #29]
 8026dfe:	429e      	cmp	r6, r3
 8026e00:	d001      	beq.n	8026e06 <tSampler_setLength+0x9a>
            p->flipIdx = 0;
 8026e02:	2300      	movs	r3, #0
 8026e04:	6523      	str	r3, [r4, #80]	; 0x50
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
 8026e06:	6863      	ldr	r3, [r4, #4]
 8026e08:	4605      	mov	r5, r0
 8026e0a:	2000      	movs	r0, #0
 8026e0c:	691a      	ldr	r2, [r3, #16]
 8026e0e:	3a01      	subs	r2, #1
 8026e10:	f7fd f864 	bl	8023edc <LEAF_clipInt>
 8026e14:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
 8026e16:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
 8026e18:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8026e1a:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 8026e1c:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
 8026e20:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 8026e22:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
 8026e26:	2900      	cmp	r1, #0
 8026e28:	bfb8      	it	lt
 8026e2a:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 8026e2c:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
 8026e30:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 8026e32:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
 8026e36:	eef4 7ac7 	vcmpe.f32	s15, s14
 8026e3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026e3e:	dd03      	ble.n	8026e48 <tSampler_setLength+0xdc>
 8026e40:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8026e44:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
 8026e48:	4282      	cmp	r2, r0
 8026e4a:	bfac      	ite	ge
 8026e4c:	2201      	movge	r2, #1
 8026e4e:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetend = -1;
 8026e52:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8026e56:	775a      	strb	r2, [r3, #29]
 8026e58:	e7b1      	b.n	8026dbe <tSampler_setLength+0x52>
        else if (tempflip < 0 && dir > 0) // end is start and we're playing forward
 8026e5a:	2b00      	cmp	r3, #0
 8026e5c:	ddcd      	ble.n	8026dfa <tSampler_setLength+0x8e>
 8026e5e:	2f00      	cmp	r7, #0
 8026e60:	d0cb      	beq.n	8026dfa <tSampler_setLength+0x8e>
            if (end > p->idx) // end given is after current index or we're in a crossfade
 8026e62:	ee07 1a90 	vmov	s15, r1
 8026e66:	edd4 6a03 	vldr	s13, [r4, #12]
 8026e6a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026e6e:	eef4 7ae6 	vcmpe.f32	s15, s13
 8026e72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026e76:	ddc0      	ble.n	8026dfa <tSampler_setLength+0x8e>
                float tempLen = abs(end - p->start) * 0.25f;
 8026e78:	2a00      	cmp	r2, #0
                if (cfxlen > tempLen)
 8026e7a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetend = end;
 8026e7e:	62e1      	str	r1, [r4, #44]	; 0x2c
                float tempLen = abs(end - p->start) * 0.25f;
 8026e80:	bfb8      	it	lt
 8026e82:	4252      	neglt	r2, r2
 8026e84:	ee07 2a90 	vmov	s15, r2
 8026e88:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
 8026e8c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8026e90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026e94:	d594      	bpl.n	8026dc0 <tSampler_setLength+0x54>
                    p->cfxlen = tempLen;
 8026e96:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8026e9a:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
 8026e9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08026ea0 <tSampler_setRate>:

void tSampler_setRate      (tSampler* const sp, float rate)
{
    _tSampler* p = *sp;
    
    if (rate < 0.f)
 8026ea0:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
    _tSampler* p = *sp;
 8026ea4:	6803      	ldr	r3, [r0, #0]
    if (rate < 0.f)
 8026ea6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026eaa:	d40a      	bmi.n	8026ec2 <tSampler_setRate+0x22>
        rate = -rate;
        p->dir = -1;
    }
    else
    {
        p->dir = 1;
 8026eac:	2201      	movs	r2, #1
    }
    
    p->inc = rate;
    p->iinc = 1.f / p->inc;
 8026eae:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8026eb2:	771a      	strb	r2, [r3, #28]
    p->inc = rate;
 8026eb4:	ed83 0a04 	vstr	s0, [r3, #16]
    p->iinc = 1.f / p->inc;
 8026eb8:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8026ebc:	edc3 7a06 	vstr	s15, [r3, #24]
}
 8026ec0:	4770      	bx	lr
        rate = -rate;
 8026ec2:	eeb1 0a40 	vneg.f32	s0, s0
        p->dir = -1;
 8026ec6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8026eca:	e7f0      	b.n	8026eae <tSampler_setRate+0xe>

08026ecc <LEAF_defaultErrorCallback>:

void LEAF_defaultErrorCallback(LEAFErrorType whichone)
{
    // Not sure what this should do if anything
    // Maybe fine as a placeholder
}
 8026ecc:	4770      	bx	lr
 8026ece:	bf00      	nop

08026ed0 <LEAF_init>:
{
 8026ed0:	b538      	push	{r3, r4, r5, lr}
 8026ed2:	460c      	mov	r4, r1
 8026ed4:	4605      	mov	r5, r0
    leaf_pool_init(memory, memorysize);
 8026ed6:	4611      	mov	r1, r2
 8026ed8:	4620      	mov	r0, r4
{
 8026eda:	461c      	mov	r4, r3
 8026edc:	ed2d 8b02 	vpush	{d8}
 8026ee0:	eeb0 8a40 	vmov.f32	s16, s0
    leaf_pool_init(memory, memorysize);
 8026ee4:	f7fd f9d0 	bl	8024288 <leaf_pool_init>
    leaf.invSampleRate = 1.0f/sr;
 8026ee8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
 8026eec:	eddf 7a0c 	vldr	s15, [pc, #48]	; 8026f20 <LEAF_init+0x50>
    leaf.sampleRate = sr;
 8026ef0:	4a0c      	ldr	r2, [pc, #48]	; (8026f24 <LEAF_init+0x54>)
    leaf.clearOnAllocation = 0;
 8026ef2:	2100      	movs	r1, #0
    leaf.errorCallback = &LEAF_defaultErrorCallback;
 8026ef4:	480c      	ldr	r0, [pc, #48]	; (8026f28 <LEAF_init+0x58>)
    leaf.invSampleRate = 1.0f/sr;
 8026ef6:	ee86 7a88 	vdiv.f32	s14, s13, s16
    leaf.blockSize = blocksize;
 8026efa:	6095      	str	r5, [r2, #8]
    leaf.sampleRate = sr;
 8026efc:	ed82 8a00 	vstr	s16, [r2]
    leaf.random = random;
 8026f00:	6114      	str	r4, [r2, #16]
    leaf.errorCallback = &LEAF_defaultErrorCallback;
 8026f02:	6310      	str	r0, [r2, #48]	; 0x30
    leaf.clearOnAllocation = 0;
 8026f04:	6151      	str	r1, [r2, #20]
        leaf.errorState[i] = 0;
 8026f06:	63d1      	str	r1, [r2, #60]	; 0x3c
 8026f08:	e9c2 110d 	strd	r1, r1, [r2, #52]	; 0x34
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
 8026f0c:	ee67 7a27 	vmul.f32	s15, s14, s15
    leaf.invSampleRate = 1.0f/sr;
 8026f10:	ed82 7a01 	vstr	s14, [r2, #4]
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
 8026f14:	edc2 7a03 	vstr	s15, [r2, #12]
}
 8026f18:	ecbd 8b02 	vpop	{d8}
 8026f1c:	bd38      	pop	{r3, r4, r5, pc}
 8026f1e:	bf00      	nop
 8026f20:	40c90fdb 	.word	0x40c90fdb
 8026f24:	200194e8 	.word	0x200194e8
 8026f28:	08026ecd 	.word	0x08026ecd

08026f2c <LEAF_internalErrorCallback>:

void LEAF_internalErrorCallback(LEAFErrorType whichone)
{
    leaf.errorState[whichone] = 1;
 8026f2c:	4b03      	ldr	r3, [pc, #12]	; (8026f3c <LEAF_internalErrorCallback+0x10>)
 8026f2e:	2101      	movs	r1, #1
 8026f30:	eb03 0280 	add.w	r2, r3, r0, lsl #2
    leaf.errorCallback(whichone);
 8026f34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    leaf.errorState[whichone] = 1;
 8026f36:	6351      	str	r1, [r2, #52]	; 0x34
    leaf.errorCallback(whichone);
 8026f38:	4718      	bx	r3
 8026f3a:	bf00      	nop
 8026f3c:	200194e8 	.word	0x200194e8

08026f40 <__errno>:
 8026f40:	4b01      	ldr	r3, [pc, #4]	; (8026f48 <__errno+0x8>)
 8026f42:	6818      	ldr	r0, [r3, #0]
 8026f44:	4770      	bx	lr
 8026f46:	bf00      	nop
 8026f48:	20000440 	.word	0x20000440

08026f4c <__libc_init_array>:
 8026f4c:	b570      	push	{r4, r5, r6, lr}
 8026f4e:	4e0d      	ldr	r6, [pc, #52]	; (8026f84 <__libc_init_array+0x38>)
 8026f50:	4c0d      	ldr	r4, [pc, #52]	; (8026f88 <__libc_init_array+0x3c>)
 8026f52:	1ba4      	subs	r4, r4, r6
 8026f54:	10a4      	asrs	r4, r4, #2
 8026f56:	2500      	movs	r5, #0
 8026f58:	42a5      	cmp	r5, r4
 8026f5a:	d109      	bne.n	8026f70 <__libc_init_array+0x24>
 8026f5c:	4e0b      	ldr	r6, [pc, #44]	; (8026f8c <__libc_init_array+0x40>)
 8026f5e:	4c0c      	ldr	r4, [pc, #48]	; (8026f90 <__libc_init_array+0x44>)
 8026f60:	f002 f840 	bl	8028fe4 <_init>
 8026f64:	1ba4      	subs	r4, r4, r6
 8026f66:	10a4      	asrs	r4, r4, #2
 8026f68:	2500      	movs	r5, #0
 8026f6a:	42a5      	cmp	r5, r4
 8026f6c:	d105      	bne.n	8026f7a <__libc_init_array+0x2e>
 8026f6e:	bd70      	pop	{r4, r5, r6, pc}
 8026f70:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8026f74:	4798      	blx	r3
 8026f76:	3501      	adds	r5, #1
 8026f78:	e7ee      	b.n	8026f58 <__libc_init_array+0xc>
 8026f7a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8026f7e:	4798      	blx	r3
 8026f80:	3501      	adds	r5, #1
 8026f82:	e7f2      	b.n	8026f6a <__libc_init_array+0x1e>
 8026f84:	0804b9d8 	.word	0x0804b9d8
 8026f88:	0804b9d8 	.word	0x0804b9d8
 8026f8c:	0804b9d8 	.word	0x0804b9d8
 8026f90:	0804b9dc 	.word	0x0804b9dc

08026f94 <__itoa>:
 8026f94:	1e93      	subs	r3, r2, #2
 8026f96:	2b22      	cmp	r3, #34	; 0x22
 8026f98:	b510      	push	{r4, lr}
 8026f9a:	460c      	mov	r4, r1
 8026f9c:	d904      	bls.n	8026fa8 <__itoa+0x14>
 8026f9e:	2300      	movs	r3, #0
 8026fa0:	700b      	strb	r3, [r1, #0]
 8026fa2:	461c      	mov	r4, r3
 8026fa4:	4620      	mov	r0, r4
 8026fa6:	bd10      	pop	{r4, pc}
 8026fa8:	2a0a      	cmp	r2, #10
 8026faa:	d109      	bne.n	8026fc0 <__itoa+0x2c>
 8026fac:	2800      	cmp	r0, #0
 8026fae:	da07      	bge.n	8026fc0 <__itoa+0x2c>
 8026fb0:	232d      	movs	r3, #45	; 0x2d
 8026fb2:	700b      	strb	r3, [r1, #0]
 8026fb4:	4240      	negs	r0, r0
 8026fb6:	2101      	movs	r1, #1
 8026fb8:	4421      	add	r1, r4
 8026fba:	f000 f821 	bl	8027000 <__utoa>
 8026fbe:	e7f1      	b.n	8026fa4 <__itoa+0x10>
 8026fc0:	2100      	movs	r1, #0
 8026fc2:	e7f9      	b.n	8026fb8 <__itoa+0x24>

08026fc4 <itoa>:
 8026fc4:	f7ff bfe6 	b.w	8026f94 <__itoa>

08026fc8 <memcpy>:
 8026fc8:	b510      	push	{r4, lr}
 8026fca:	1e43      	subs	r3, r0, #1
 8026fcc:	440a      	add	r2, r1
 8026fce:	4291      	cmp	r1, r2
 8026fd0:	d100      	bne.n	8026fd4 <memcpy+0xc>
 8026fd2:	bd10      	pop	{r4, pc}
 8026fd4:	f811 4b01 	ldrb.w	r4, [r1], #1
 8026fd8:	f803 4f01 	strb.w	r4, [r3, #1]!
 8026fdc:	e7f7      	b.n	8026fce <memcpy+0x6>

08026fde <memset>:
 8026fde:	4402      	add	r2, r0
 8026fe0:	4603      	mov	r3, r0
 8026fe2:	4293      	cmp	r3, r2
 8026fe4:	d100      	bne.n	8026fe8 <memset+0xa>
 8026fe6:	4770      	bx	lr
 8026fe8:	f803 1b01 	strb.w	r1, [r3], #1
 8026fec:	e7f9      	b.n	8026fe2 <memset+0x4>

08026fee <stpcpy>:
 8026fee:	4603      	mov	r3, r0
 8026ff0:	f811 2b01 	ldrb.w	r2, [r1], #1
 8026ff4:	4618      	mov	r0, r3
 8026ff6:	f803 2b01 	strb.w	r2, [r3], #1
 8026ffa:	2a00      	cmp	r2, #0
 8026ffc:	d1f8      	bne.n	8026ff0 <stpcpy+0x2>
 8026ffe:	4770      	bx	lr

08027000 <__utoa>:
 8027000:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027002:	4b1d      	ldr	r3, [pc, #116]	; (8027078 <__utoa+0x78>)
 8027004:	b08b      	sub	sp, #44	; 0x2c
 8027006:	4605      	mov	r5, r0
 8027008:	460c      	mov	r4, r1
 802700a:	466e      	mov	r6, sp
 802700c:	f103 0c20 	add.w	ip, r3, #32
 8027010:	6818      	ldr	r0, [r3, #0]
 8027012:	6859      	ldr	r1, [r3, #4]
 8027014:	4637      	mov	r7, r6
 8027016:	c703      	stmia	r7!, {r0, r1}
 8027018:	3308      	adds	r3, #8
 802701a:	4563      	cmp	r3, ip
 802701c:	463e      	mov	r6, r7
 802701e:	d1f7      	bne.n	8027010 <__utoa+0x10>
 8027020:	6818      	ldr	r0, [r3, #0]
 8027022:	791b      	ldrb	r3, [r3, #4]
 8027024:	713b      	strb	r3, [r7, #4]
 8027026:	1e93      	subs	r3, r2, #2
 8027028:	2b22      	cmp	r3, #34	; 0x22
 802702a:	6038      	str	r0, [r7, #0]
 802702c:	f04f 0300 	mov.w	r3, #0
 8027030:	d904      	bls.n	802703c <__utoa+0x3c>
 8027032:	7023      	strb	r3, [r4, #0]
 8027034:	461c      	mov	r4, r3
 8027036:	4620      	mov	r0, r4
 8027038:	b00b      	add	sp, #44	; 0x2c
 802703a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802703c:	1e66      	subs	r6, r4, #1
 802703e:	fbb5 f0f2 	udiv	r0, r5, r2
 8027042:	af0a      	add	r7, sp, #40	; 0x28
 8027044:	fb02 5510 	mls	r5, r2, r0, r5
 8027048:	443d      	add	r5, r7
 802704a:	1c59      	adds	r1, r3, #1
 802704c:	f815 5c28 	ldrb.w	r5, [r5, #-40]
 8027050:	f806 5f01 	strb.w	r5, [r6, #1]!
 8027054:	4605      	mov	r5, r0
 8027056:	b968      	cbnz	r0, 8027074 <__utoa+0x74>
 8027058:	5460      	strb	r0, [r4, r1]
 802705a:	4423      	add	r3, r4
 802705c:	4622      	mov	r2, r4
 802705e:	1b19      	subs	r1, r3, r4
 8027060:	1b10      	subs	r0, r2, r4
 8027062:	4281      	cmp	r1, r0
 8027064:	dde7      	ble.n	8027036 <__utoa+0x36>
 8027066:	7811      	ldrb	r1, [r2, #0]
 8027068:	7818      	ldrb	r0, [r3, #0]
 802706a:	f802 0b01 	strb.w	r0, [r2], #1
 802706e:	f803 1901 	strb.w	r1, [r3], #-1
 8027072:	e7f4      	b.n	802705e <__utoa+0x5e>
 8027074:	460b      	mov	r3, r1
 8027076:	e7e2      	b.n	802703e <__utoa+0x3e>
 8027078:	0804b0b4 	.word	0x0804b0b4

0802707c <atanf>:
 802707c:	b538      	push	{r3, r4, r5, lr}
 802707e:	ee10 5a10 	vmov	r5, s0
 8027082:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
 8027086:	f1b4 4fa1 	cmp.w	r4, #1350565888	; 0x50800000
 802708a:	eef0 7a40 	vmov.f32	s15, s0
 802708e:	db0f      	blt.n	80270b0 <atanf+0x34>
 8027090:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8027094:	dd04      	ble.n	80270a0 <atanf+0x24>
 8027096:	ee70 7a00 	vadd.f32	s15, s0, s0
 802709a:	eeb0 0a67 	vmov.f32	s0, s15
 802709e:	bd38      	pop	{r3, r4, r5, pc}
 80270a0:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 80271d4 <atanf+0x158>
 80270a4:	eddf 7a4c 	vldr	s15, [pc, #304]	; 80271d8 <atanf+0x15c>
 80270a8:	2d00      	cmp	r5, #0
 80270aa:	fe77 7a87 	vselgt.f32	s15, s15, s14
 80270ae:	e7f4      	b.n	802709a <atanf+0x1e>
 80270b0:	4b4a      	ldr	r3, [pc, #296]	; (80271dc <atanf+0x160>)
 80270b2:	429c      	cmp	r4, r3
 80270b4:	dc10      	bgt.n	80270d8 <atanf+0x5c>
 80270b6:	f1b4 5f44 	cmp.w	r4, #822083584	; 0x31000000
 80270ba:	da0a      	bge.n	80270d2 <atanf+0x56>
 80270bc:	ed9f 7a48 	vldr	s14, [pc, #288]	; 80271e0 <atanf+0x164>
 80270c0:	ee30 7a07 	vadd.f32	s14, s0, s14
 80270c4:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80270c8:	eeb4 7ae6 	vcmpe.f32	s14, s13
 80270cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80270d0:	dce3      	bgt.n	802709a <atanf+0x1e>
 80270d2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80270d6:	e013      	b.n	8027100 <atanf+0x84>
 80270d8:	f000 f960 	bl	802739c <fabsf>
 80270dc:	4b41      	ldr	r3, [pc, #260]	; (80271e4 <atanf+0x168>)
 80270de:	429c      	cmp	r4, r3
 80270e0:	dc4f      	bgt.n	8027182 <atanf+0x106>
 80270e2:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
 80270e6:	429c      	cmp	r4, r3
 80270e8:	dc41      	bgt.n	802716e <atanf+0xf2>
 80270ea:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 80270ee:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 80270f2:	eea0 7a27 	vfma.f32	s14, s0, s15
 80270f6:	2300      	movs	r3, #0
 80270f8:	ee30 0a27 	vadd.f32	s0, s0, s15
 80270fc:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8027100:	1c5a      	adds	r2, r3, #1
 8027102:	ee27 6aa7 	vmul.f32	s12, s15, s15
 8027106:	ed9f 7a38 	vldr	s14, [pc, #224]	; 80271e8 <atanf+0x16c>
 802710a:	eddf 5a38 	vldr	s11, [pc, #224]	; 80271ec <atanf+0x170>
 802710e:	ed9f 5a38 	vldr	s10, [pc, #224]	; 80271f0 <atanf+0x174>
 8027112:	ee66 6a06 	vmul.f32	s13, s12, s12
 8027116:	eee6 5a87 	vfma.f32	s11, s13, s14
 802711a:	ed9f 7a36 	vldr	s14, [pc, #216]	; 80271f4 <atanf+0x178>
 802711e:	eea5 7aa6 	vfma.f32	s14, s11, s13
 8027122:	eddf 5a35 	vldr	s11, [pc, #212]	; 80271f8 <atanf+0x17c>
 8027126:	eee7 5a26 	vfma.f32	s11, s14, s13
 802712a:	ed9f 7a34 	vldr	s14, [pc, #208]	; 80271fc <atanf+0x180>
 802712e:	eea5 7aa6 	vfma.f32	s14, s11, s13
 8027132:	eddf 5a33 	vldr	s11, [pc, #204]	; 8027200 <atanf+0x184>
 8027136:	eee7 5a26 	vfma.f32	s11, s14, s13
 802713a:	ed9f 7a32 	vldr	s14, [pc, #200]	; 8027204 <atanf+0x188>
 802713e:	eea6 5a87 	vfma.f32	s10, s13, s14
 8027142:	ed9f 7a31 	vldr	s14, [pc, #196]	; 8027208 <atanf+0x18c>
 8027146:	eea5 7a26 	vfma.f32	s14, s10, s13
 802714a:	ed9f 5a30 	vldr	s10, [pc, #192]	; 802720c <atanf+0x190>
 802714e:	eea7 5a26 	vfma.f32	s10, s14, s13
 8027152:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 8027210 <atanf+0x194>
 8027156:	eea5 7a26 	vfma.f32	s14, s10, s13
 802715a:	ee27 7a26 	vmul.f32	s14, s14, s13
 802715e:	eea5 7a86 	vfma.f32	s14, s11, s12
 8027162:	ee27 7a27 	vmul.f32	s14, s14, s15
 8027166:	d121      	bne.n	80271ac <atanf+0x130>
 8027168:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802716c:	e795      	b.n	802709a <atanf+0x1e>
 802716e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8027172:	ee30 7a67 	vsub.f32	s14, s0, s15
 8027176:	ee30 0a27 	vadd.f32	s0, s0, s15
 802717a:	2301      	movs	r3, #1
 802717c:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8027180:	e7be      	b.n	8027100 <atanf+0x84>
 8027182:	4b24      	ldr	r3, [pc, #144]	; (8027214 <atanf+0x198>)
 8027184:	429c      	cmp	r4, r3
 8027186:	dc0b      	bgt.n	80271a0 <atanf+0x124>
 8027188:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
 802718c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8027190:	eea0 7a27 	vfma.f32	s14, s0, s15
 8027194:	2302      	movs	r3, #2
 8027196:	ee70 6a67 	vsub.f32	s13, s0, s15
 802719a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 802719e:	e7af      	b.n	8027100 <atanf+0x84>
 80271a0:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 80271a4:	eec7 7a00 	vdiv.f32	s15, s14, s0
 80271a8:	2303      	movs	r3, #3
 80271aa:	e7a9      	b.n	8027100 <atanf+0x84>
 80271ac:	4a1a      	ldr	r2, [pc, #104]	; (8027218 <atanf+0x19c>)
 80271ae:	491b      	ldr	r1, [pc, #108]	; (802721c <atanf+0x1a0>)
 80271b0:	009b      	lsls	r3, r3, #2
 80271b2:	441a      	add	r2, r3
 80271b4:	440b      	add	r3, r1
 80271b6:	edd3 6a00 	vldr	s13, [r3]
 80271ba:	ee37 7a66 	vsub.f32	s14, s14, s13
 80271be:	2d00      	cmp	r5, #0
 80271c0:	ee77 7a67 	vsub.f32	s15, s14, s15
 80271c4:	ed92 7a00 	vldr	s14, [r2]
 80271c8:	ee77 7a67 	vsub.f32	s15, s14, s15
 80271cc:	bfb8      	it	lt
 80271ce:	eef1 7a67 	vneglt.f32	s15, s15
 80271d2:	e762      	b.n	802709a <atanf+0x1e>
 80271d4:	bfc90fdb 	.word	0xbfc90fdb
 80271d8:	3fc90fdb 	.word	0x3fc90fdb
 80271dc:	3edfffff 	.word	0x3edfffff
 80271e0:	7149f2ca 	.word	0x7149f2ca
 80271e4:	3f97ffff 	.word	0x3f97ffff
 80271e8:	3c8569d7 	.word	0x3c8569d7
 80271ec:	3d4bda59 	.word	0x3d4bda59
 80271f0:	bd6ef16b 	.word	0xbd6ef16b
 80271f4:	3d886b35 	.word	0x3d886b35
 80271f8:	3dba2e6e 	.word	0x3dba2e6e
 80271fc:	3e124925 	.word	0x3e124925
 8027200:	3eaaaaab 	.word	0x3eaaaaab
 8027204:	bd15a221 	.word	0xbd15a221
 8027208:	bd9d8795 	.word	0xbd9d8795
 802720c:	bde38e38 	.word	0xbde38e38
 8027210:	be4ccccd 	.word	0xbe4ccccd
 8027214:	401bffff 	.word	0x401bffff
 8027218:	0804b0dc 	.word	0x0804b0dc
 802721c:	0804b0ec 	.word	0x0804b0ec

08027220 <cosf>:
 8027220:	ee10 3a10 	vmov	r3, s0
 8027224:	b507      	push	{r0, r1, r2, lr}
 8027226:	4a1c      	ldr	r2, [pc, #112]	; (8027298 <cosf+0x78>)
 8027228:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802722c:	4293      	cmp	r3, r2
 802722e:	dc04      	bgt.n	802723a <cosf+0x1a>
 8027230:	eddf 0a1a 	vldr	s1, [pc, #104]	; 802729c <cosf+0x7c>
 8027234:	f001 f888 	bl	8028348 <__kernel_cosf>
 8027238:	e004      	b.n	8027244 <cosf+0x24>
 802723a:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802723e:	db04      	blt.n	802724a <cosf+0x2a>
 8027240:	ee30 0a40 	vsub.f32	s0, s0, s0
 8027244:	b003      	add	sp, #12
 8027246:	f85d fb04 	ldr.w	pc, [sp], #4
 802724a:	4668      	mov	r0, sp
 802724c:	f000 fee2 	bl	8028014 <__ieee754_rem_pio2f>
 8027250:	f000 0003 	and.w	r0, r0, #3
 8027254:	2801      	cmp	r0, #1
 8027256:	d007      	beq.n	8027268 <cosf+0x48>
 8027258:	2802      	cmp	r0, #2
 802725a:	d00e      	beq.n	802727a <cosf+0x5a>
 802725c:	b9a0      	cbnz	r0, 8027288 <cosf+0x68>
 802725e:	eddd 0a01 	vldr	s1, [sp, #4]
 8027262:	ed9d 0a00 	vldr	s0, [sp]
 8027266:	e7e5      	b.n	8027234 <cosf+0x14>
 8027268:	eddd 0a01 	vldr	s1, [sp, #4]
 802726c:	ed9d 0a00 	vldr	s0, [sp]
 8027270:	f001 fb4a 	bl	8028908 <__kernel_sinf>
 8027274:	eeb1 0a40 	vneg.f32	s0, s0
 8027278:	e7e4      	b.n	8027244 <cosf+0x24>
 802727a:	eddd 0a01 	vldr	s1, [sp, #4]
 802727e:	ed9d 0a00 	vldr	s0, [sp]
 8027282:	f001 f861 	bl	8028348 <__kernel_cosf>
 8027286:	e7f5      	b.n	8027274 <cosf+0x54>
 8027288:	2001      	movs	r0, #1
 802728a:	eddd 0a01 	vldr	s1, [sp, #4]
 802728e:	ed9d 0a00 	vldr	s0, [sp]
 8027292:	f001 fb39 	bl	8028908 <__kernel_sinf>
 8027296:	e7d5      	b.n	8027244 <cosf+0x24>
 8027298:	3f490fd8 	.word	0x3f490fd8
 802729c:	00000000 	.word	0x00000000

080272a0 <expf>:
 80272a0:	ee10 2a10 	vmov	r2, s0
 80272a4:	f240 412a 	movw	r1, #1066	; 0x42a
 80272a8:	f3c2 530a 	ubfx	r3, r2, #20, #11
 80272ac:	428b      	cmp	r3, r1
 80272ae:	e92d 0830 	stmdb	sp!, {r4, r5, fp}
 80272b2:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
 80272b6:	d92e      	bls.n	8027316 <expf+0x76>
 80272b8:	f512 0f00 	cmn.w	r2, #8388608	; 0x800000
 80272bc:	d061      	beq.n	8027382 <expf+0xe2>
 80272be:	f5b3 6fff 	cmp.w	r3, #2040	; 0x7f8
 80272c2:	d304      	bcc.n	80272ce <expf+0x2e>
 80272c4:	ee30 0a00 	vadd.f32	s0, s0, s0
 80272c8:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
 80272cc:	4770      	bx	lr
 80272ce:	eddf 7a2e 	vldr	s15, [pc, #184]	; 8027388 <expf+0xe8>
 80272d2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80272d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80272da:	dd04      	ble.n	80272e6 <expf+0x46>
 80272dc:	2000      	movs	r0, #0
 80272de:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
 80272e2:	f001 bc63 	b.w	8028bac <__math_oflowf>
 80272e6:	eddf 7a29 	vldr	s15, [pc, #164]	; 802738c <expf+0xec>
 80272ea:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80272ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80272f2:	d504      	bpl.n	80272fe <expf+0x5e>
 80272f4:	2000      	movs	r0, #0
 80272f6:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
 80272fa:	f001 bc4b 	b.w	8028b94 <__math_uflowf>
 80272fe:	eddf 7a24 	vldr	s15, [pc, #144]	; 8027390 <expf+0xf0>
 8027302:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8027306:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802730a:	d504      	bpl.n	8027316 <expf+0x76>
 802730c:	2000      	movs	r0, #0
 802730e:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
 8027312:	f001 bc45 	b.w	8028ba0 <__math_may_uflowf>
 8027316:	491f      	ldr	r1, [pc, #124]	; (8027394 <expf+0xf4>)
 8027318:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
 802731c:	ed91 5b4a 	vldr	d5, [r1, #296]	; 0x128
 8027320:	ed91 7b48 	vldr	d7, [r1, #288]	; 0x120
 8027324:	eeb0 4b47 	vmov.f64	d4, d7
 8027328:	eea5 4b06 	vfma.f64	d4, d5, d6
 802732c:	ec55 4b14 	vmov	r4, r5, d4
 8027330:	ee34 7b47 	vsub.f64	d7, d4, d7
 8027334:	f004 021f 	and.w	r2, r4, #31
 8027338:	ee95 7b06 	vfnms.f64	d7, d5, d6
 802733c:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 8027340:	ed91 6b50 	vldr	d6, [r1, #320]	; 0x140
 8027344:	e9d2 4500 	ldrd	r4, r5, [r2]
 8027348:	eea6 0b07 	vfma.f64	d0, d6, d7
 802734c:	ee14 0a10 	vmov	r0, s8
 8027350:	ed91 5b4c 	vldr	d5, [r1, #304]	; 0x130
 8027354:	ed91 6b4e 	vldr	d6, [r1, #312]	; 0x138
 8027358:	f04f 0b00 	mov.w	fp, #0
 802735c:	eb1b 0204 	adds.w	r2, fp, r4
 8027360:	ea4f 3cc0 	mov.w	ip, r0, lsl #15
 8027364:	eb4c 0305 	adc.w	r3, ip, r5
 8027368:	eea5 6b07 	vfma.f64	d6, d5, d7
 802736c:	ee27 7b07 	vmul.f64	d7, d7, d7
 8027370:	eea6 0b07 	vfma.f64	d0, d6, d7
 8027374:	ec43 2b17 	vmov	d7, r2, r3
 8027378:	ee20 0b07 	vmul.f64	d0, d0, d7
 802737c:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 8027380:	e7a2      	b.n	80272c8 <expf+0x28>
 8027382:	ed9f 0a05 	vldr	s0, [pc, #20]	; 8027398 <expf+0xf8>
 8027386:	e79f      	b.n	80272c8 <expf+0x28>
 8027388:	42b17217 	.word	0x42b17217
 802738c:	c2cff1b4 	.word	0xc2cff1b4
 8027390:	c2ce8ecf 	.word	0xc2ce8ecf
 8027394:	0804b100 	.word	0x0804b100
 8027398:	00000000 	.word	0x00000000

0802739c <fabsf>:
 802739c:	ee10 3a10 	vmov	r3, s0
 80273a0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80273a4:	ee00 3a10 	vmov	s0, r3
 80273a8:	4770      	bx	lr
	...

080273ac <logf>:
 80273ac:	ee10 3a10 	vmov	r3, s0
 80273b0:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 80273b4:	b410      	push	{r4}
 80273b6:	d057      	beq.n	8027468 <logf+0xbc>
 80273b8:	f5a3 0200 	sub.w	r2, r3, #8388608	; 0x800000
 80273bc:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80273c0:	d31a      	bcc.n	80273f8 <logf+0x4c>
 80273c2:	005a      	lsls	r2, r3, #1
 80273c4:	d104      	bne.n	80273d0 <logf+0x24>
 80273c6:	2001      	movs	r0, #1
 80273c8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80273cc:	f001 bbf4 	b.w	8028bb8 <__math_divzerof>
 80273d0:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 80273d4:	d045      	beq.n	8027462 <logf+0xb6>
 80273d6:	2b00      	cmp	r3, #0
 80273d8:	db02      	blt.n	80273e0 <logf+0x34>
 80273da:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
 80273de:	d303      	bcc.n	80273e8 <logf+0x3c>
 80273e0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80273e4:	f001 bbf8 	b.w	8028bd8 <__math_invalidf>
 80273e8:	eddf 7a21 	vldr	s15, [pc, #132]	; 8027470 <logf+0xc4>
 80273ec:	ee20 0a27 	vmul.f32	s0, s0, s15
 80273f0:	ee10 3a10 	vmov	r3, s0
 80273f4:	f1a3 6338 	sub.w	r3, r3, #192937984	; 0xb800000
 80273f8:	f103 4240 	add.w	r2, r3, #3221225472	; 0xc0000000
 80273fc:	491d      	ldr	r1, [pc, #116]	; (8027474 <logf+0xc8>)
 80273fe:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
 8027402:	f502 024d 	add.w	r2, r2, #13434880	; 0xcd0000
 8027406:	f3c2 40c3 	ubfx	r0, r2, #19, #4
 802740a:	0dd4      	lsrs	r4, r2, #23
 802740c:	eb01 1000 	add.w	r0, r1, r0, lsl #4
 8027410:	05e4      	lsls	r4, r4, #23
 8027412:	ed90 5b00 	vldr	d5, [r0]
 8027416:	1b1b      	subs	r3, r3, r4
 8027418:	ee07 3a90 	vmov	s15, r3
 802741c:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 8027420:	eea5 6b07 	vfma.f64	d6, d5, d7
 8027424:	ed91 5b44 	vldr	d5, [r1, #272]	; 0x110
 8027428:	ee26 3b06 	vmul.f64	d3, d6, d6
 802742c:	ed91 7b46 	vldr	d7, [r1, #280]	; 0x118
 8027430:	eea5 7b06 	vfma.f64	d7, d5, d6
 8027434:	ed91 5b42 	vldr	d5, [r1, #264]	; 0x108
 8027438:	15d2      	asrs	r2, r2, #23
 802743a:	ed91 4b40 	vldr	d4, [r1, #256]	; 0x100
 802743e:	eea5 7b03 	vfma.f64	d7, d5, d3
 8027442:	eeb0 5b47 	vmov.f64	d5, d7
 8027446:	ed90 0b02 	vldr	d0, [r0, #8]
 802744a:	ee07 2a90 	vmov	s15, r2
 802744e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 8027452:	eea7 0b04 	vfma.f64	d0, d7, d4
 8027456:	ee30 0b06 	vadd.f64	d0, d0, d6
 802745a:	eea3 0b05 	vfma.f64	d0, d3, d5
 802745e:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 8027462:	f85d 4b04 	ldr.w	r4, [sp], #4
 8027466:	4770      	bx	lr
 8027468:	ed9f 0a03 	vldr	s0, [pc, #12]	; 8027478 <logf+0xcc>
 802746c:	e7f9      	b.n	8027462 <logf+0xb6>
 802746e:	bf00      	nop
 8027470:	4b000000 	.word	0x4b000000
 8027474:	0804b368 	.word	0x0804b368
 8027478:	00000000 	.word	0x00000000

0802747c <log2f>:
 802747c:	ee10 2a10 	vmov	r2, s0
 8027480:	f1b2 5f7e 	cmp.w	r2, #1065353216	; 0x3f800000
 8027484:	b410      	push	{r4}
 8027486:	d057      	beq.n	8027538 <log2f+0xbc>
 8027488:	f5a2 0300 	sub.w	r3, r2, #8388608	; 0x800000
 802748c:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 8027490:	d31a      	bcc.n	80274c8 <log2f+0x4c>
 8027492:	0053      	lsls	r3, r2, #1
 8027494:	d104      	bne.n	80274a0 <log2f+0x24>
 8027496:	2001      	movs	r0, #1
 8027498:	f85d 4b04 	ldr.w	r4, [sp], #4
 802749c:	f001 bb8c 	b.w	8028bb8 <__math_divzerof>
 80274a0:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 80274a4:	d045      	beq.n	8027532 <log2f+0xb6>
 80274a6:	2a00      	cmp	r2, #0
 80274a8:	db02      	blt.n	80274b0 <log2f+0x34>
 80274aa:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 80274ae:	d303      	bcc.n	80274b8 <log2f+0x3c>
 80274b0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80274b4:	f001 bb90 	b.w	8028bd8 <__math_invalidf>
 80274b8:	eddf 7a21 	vldr	s15, [pc, #132]	; 8027540 <log2f+0xc4>
 80274bc:	ee20 0a27 	vmul.f32	s0, s0, s15
 80274c0:	ee10 3a10 	vmov	r3, s0
 80274c4:	f1a3 6238 	sub.w	r2, r3, #192937984	; 0xb800000
 80274c8:	f102 4340 	add.w	r3, r2, #3221225472	; 0xc0000000
 80274cc:	491d      	ldr	r1, [pc, #116]	; (8027544 <log2f+0xc8>)
 80274ce:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
 80274d2:	f503 034d 	add.w	r3, r3, #13434880	; 0xcd0000
 80274d6:	f3c3 40c3 	ubfx	r0, r3, #19, #4
 80274da:	0ddc      	lsrs	r4, r3, #23
 80274dc:	eb01 1000 	add.w	r0, r1, r0, lsl #4
 80274e0:	05e4      	lsls	r4, r4, #23
 80274e2:	ed90 5b00 	vldr	d5, [r0]
 80274e6:	1b12      	subs	r2, r2, r4
 80274e8:	ee07 2a90 	vmov	s15, r2
 80274ec:	ed91 4b42 	vldr	d4, [r1, #264]	; 0x108
 80274f0:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 80274f4:	eea5 6b07 	vfma.f64	d6, d5, d7
 80274f8:	eeb0 7b46 	vmov.f64	d7, d6
 80274fc:	ee26 5b06 	vmul.f64	d5, d6, d6
 8027500:	ed91 6b44 	vldr	d6, [r1, #272]	; 0x110
 8027504:	eea4 6b07 	vfma.f64	d6, d4, d7
 8027508:	ed91 4b40 	vldr	d4, [r1, #256]	; 0x100
 802750c:	15db      	asrs	r3, r3, #23
 802750e:	eea4 6b05 	vfma.f64	d6, d4, d5
 8027512:	ed90 4b02 	vldr	d4, [r0, #8]
 8027516:	ee00 3a10 	vmov	s0, r3
 802751a:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
 802751e:	ee30 0b04 	vadd.f64	d0, d0, d4
 8027522:	ed91 4b46 	vldr	d4, [r1, #280]	; 0x118
 8027526:	eea4 0b07 	vfma.f64	d0, d4, d7
 802752a:	eea5 0b06 	vfma.f64	d0, d5, d6
 802752e:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 8027532:	f85d 4b04 	ldr.w	r4, [sp], #4
 8027536:	4770      	bx	lr
 8027538:	ed9f 0a03 	vldr	s0, [pc, #12]	; 8027548 <log2f+0xcc>
 802753c:	e7f9      	b.n	8027532 <log2f+0xb6>
 802753e:	bf00      	nop
 8027540:	4b000000 	.word	0x4b000000
 8027544:	0804b248 	.word	0x0804b248
 8027548:	00000000 	.word	0x00000000

0802754c <checkint>:
 802754c:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 8027550:	2b7e      	cmp	r3, #126	; 0x7e
 8027552:	dd10      	ble.n	8027576 <checkint+0x2a>
 8027554:	2b96      	cmp	r3, #150	; 0x96
 8027556:	dc0c      	bgt.n	8027572 <checkint+0x26>
 8027558:	2201      	movs	r2, #1
 802755a:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 802755e:	fa02 f303 	lsl.w	r3, r2, r3
 8027562:	1e5a      	subs	r2, r3, #1
 8027564:	4202      	tst	r2, r0
 8027566:	d106      	bne.n	8027576 <checkint+0x2a>
 8027568:	4203      	tst	r3, r0
 802756a:	bf0c      	ite	eq
 802756c:	2002      	moveq	r0, #2
 802756e:	2001      	movne	r0, #1
 8027570:	4770      	bx	lr
 8027572:	2002      	movs	r0, #2
 8027574:	4770      	bx	lr
 8027576:	2000      	movs	r0, #0
 8027578:	4770      	bx	lr
 802757a:	0000      	movs	r0, r0
 802757c:	0000      	movs	r0, r0
	...

08027580 <powf>:
 8027580:	ee10 1a10 	vmov	r1, s0
 8027584:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
 8027588:	ee10 4a90 	vmov	r4, s1
 802758c:	f5a1 0300 	sub.w	r3, r1, #8388608	; 0x800000
 8027590:	0062      	lsls	r2, r4, #1
 8027592:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 8027596:	eef0 4a60 	vmov.f32	s9, s1
 802759a:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
 802759e:	4b92      	ldr	r3, [pc, #584]	; (80277e8 <powf+0x268>)
 80275a0:	d255      	bcs.n	802764e <powf+0xce>
 80275a2:	4298      	cmp	r0, r3
 80275a4:	d855      	bhi.n	8027652 <powf+0xd2>
 80275a6:	2000      	movs	r0, #0
 80275a8:	f101 4340 	add.w	r3, r1, #3221225472	; 0xc0000000
 80275ac:	4a8f      	ldr	r2, [pc, #572]	; (80277ec <powf+0x26c>)
 80275ae:	eebf 2b00 	vmov.f64	d2, #240	; 0xbf800000 -1.0
 80275b2:	f503 034d 	add.w	r3, r3, #13434880	; 0xcd0000
 80275b6:	f3c3 44c3 	ubfx	r4, r3, #19, #4
 80275ba:	0ddb      	lsrs	r3, r3, #23
 80275bc:	eb02 1404 	add.w	r4, r2, r4, lsl #4
 80275c0:	05db      	lsls	r3, r3, #23
 80275c2:	ed94 6b00 	vldr	d6, [r4]
 80275c6:	1ac9      	subs	r1, r1, r3
 80275c8:	ee07 1a90 	vmov	s15, r1
 80275cc:	ed92 5b40 	vldr	d5, [r2, #256]	; 0x100
 80275d0:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 80275d4:	eea6 2b07 	vfma.f64	d2, d6, d7
 80275d8:	ed92 7b42 	vldr	d7, [r2, #264]	; 0x108
 80275dc:	ee22 6b02 	vmul.f64	d6, d2, d2
 80275e0:	eea2 7b05 	vfma.f64	d7, d2, d5
 80275e4:	15db      	asrs	r3, r3, #23
 80275e6:	ed94 5b02 	vldr	d5, [r4, #8]
 80275ea:	ee00 3a10 	vmov	s0, r3
 80275ee:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
 80275f2:	ee30 0b05 	vadd.f64	d0, d0, d5
 80275f6:	ed92 5b48 	vldr	d5, [r2, #288]	; 0x120
 80275fa:	ed92 3b44 	vldr	d3, [r2, #272]	; 0x110
 80275fe:	eea2 0b05 	vfma.f64	d0, d2, d5
 8027602:	ed92 5b46 	vldr	d5, [r2, #280]	; 0x118
 8027606:	eea2 5b03 	vfma.f64	d5, d2, d3
 802760a:	eea6 0b05 	vfma.f64	d0, d6, d5
 802760e:	ee26 6b06 	vmul.f64	d6, d6, d6
 8027612:	eea7 0b06 	vfma.f64	d0, d7, d6
 8027616:	eeb7 7ae4 	vcvt.f64.f32	d7, s9
 802761a:	ee20 0b07 	vmul.f64	d0, d0, d7
 802761e:	ee10 3a90 	vmov	r3, s1
 8027622:	2500      	movs	r5, #0
 8027624:	0bda      	lsrs	r2, r3, #15
 8027626:	2300      	movs	r3, #0
 8027628:	b292      	uxth	r2, r2
 802762a:	f248 04be 	movw	r4, #32958	; 0x80be
 802762e:	429d      	cmp	r5, r3
 8027630:	bf08      	it	eq
 8027632:	4294      	cmpeq	r4, r2
 8027634:	f080 8094 	bcs.w	8027760 <powf+0x1e0>
 8027638:	ed9f 7b65 	vldr	d7, [pc, #404]	; 80277d0 <powf+0x250>
 802763c:	eeb4 0bc7 	vcmpe.f64	d0, d7
 8027640:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027644:	dd76      	ble.n	8027734 <powf+0x1b4>
 8027646:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
 802764a:	f001 baaf 	b.w	8028bac <__math_oflowf>
 802764e:	4298      	cmp	r0, r3
 8027650:	d92d      	bls.n	80276ae <powf+0x12e>
 8027652:	b952      	cbnz	r2, 802766a <powf+0xea>
 8027654:	f481 0380 	eor.w	r3, r1, #4194304	; 0x400000
 8027658:	005b      	lsls	r3, r3, #1
 802765a:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
 802765e:	f240 80ae 	bls.w	80277be <powf+0x23e>
 8027662:	ee30 0a24 	vadd.f32	s0, s0, s9
 8027666:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
 802766a:	f1b1 5f7e 	cmp.w	r1, #1065353216	; 0x3f800000
 802766e:	d105      	bne.n	802767c <powf+0xfc>
 8027670:	f484 0480 	eor.w	r4, r4, #4194304	; 0x400000
 8027674:	0064      	lsls	r4, r4, #1
 8027676:	f514 0f00 	cmn.w	r4, #8388608	; 0x800000
 802767a:	e7f0      	b.n	802765e <powf+0xde>
 802767c:	004b      	lsls	r3, r1, #1
 802767e:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 8027682:	d8ee      	bhi.n	8027662 <powf+0xe2>
 8027684:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
 8027688:	d1eb      	bne.n	8027662 <powf+0xe2>
 802768a:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 802768e:	f000 8096 	beq.w	80277be <powf+0x23e>
 8027692:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 8027696:	ea6f 0404 	mvn.w	r4, r4
 802769a:	bf34      	ite	cc
 802769c:	2300      	movcc	r3, #0
 802769e:	2301      	movcs	r3, #1
 80276a0:	0fe4      	lsrs	r4, r4, #31
 80276a2:	42a3      	cmp	r3, r4
 80276a4:	f040 808e 	bne.w	80277c4 <powf+0x244>
 80276a8:	ee24 0aa4 	vmul.f32	s0, s9, s9
 80276ac:	e7db      	b.n	8027666 <powf+0xe6>
 80276ae:	004d      	lsls	r5, r1, #1
 80276b0:	1e6a      	subs	r2, r5, #1
 80276b2:	429a      	cmp	r2, r3
 80276b4:	d91b      	bls.n	80276ee <powf+0x16e>
 80276b6:	2900      	cmp	r1, #0
 80276b8:	ee20 0a00 	vmul.f32	s0, s0, s0
 80276bc:	da0e      	bge.n	80276dc <powf+0x15c>
 80276be:	ee10 0a90 	vmov	r0, s1
 80276c2:	f7ff ff43 	bl	802754c <checkint>
 80276c6:	2801      	cmp	r0, #1
 80276c8:	d108      	bne.n	80276dc <powf+0x15c>
 80276ca:	eeb1 0a40 	vneg.f32	s0, s0
 80276ce:	b93d      	cbnz	r5, 80276e0 <powf+0x160>
 80276d0:	2c00      	cmp	r4, #0
 80276d2:	dac8      	bge.n	8027666 <powf+0xe6>
 80276d4:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
 80276d8:	f001 ba6e 	b.w	8028bb8 <__math_divzerof>
 80276dc:	2000      	movs	r0, #0
 80276de:	e7f6      	b.n	80276ce <powf+0x14e>
 80276e0:	2c00      	cmp	r4, #0
 80276e2:	dac0      	bge.n	8027666 <powf+0xe6>
 80276e4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80276e8:	ee87 0a80 	vdiv.f32	s0, s15, s0
 80276ec:	e7bb      	b.n	8027666 <powf+0xe6>
 80276ee:	2900      	cmp	r1, #0
 80276f0:	da1e      	bge.n	8027730 <powf+0x1b0>
 80276f2:	ee10 0a90 	vmov	r0, s1
 80276f6:	f7ff ff29 	bl	802754c <checkint>
 80276fa:	b918      	cbnz	r0, 8027704 <powf+0x184>
 80276fc:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
 8027700:	f001 ba6a 	b.w	8028bd8 <__math_invalidf>
 8027704:	2801      	cmp	r0, #1
 8027706:	bf0c      	ite	eq
 8027708:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 802770c:	2000      	movne	r0, #0
 802770e:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8027712:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8027716:	f4bf af47 	bcs.w	80275a8 <powf+0x28>
 802771a:	eddf 0a35 	vldr	s1, [pc, #212]	; 80277f0 <powf+0x270>
 802771e:	ee20 0a20 	vmul.f32	s0, s0, s1
 8027722:	ee10 3a10 	vmov	r3, s0
 8027726:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802772a:	f1a3 6138 	sub.w	r1, r3, #192937984	; 0xb800000
 802772e:	e73b      	b.n	80275a8 <powf+0x28>
 8027730:	2000      	movs	r0, #0
 8027732:	e7ee      	b.n	8027712 <powf+0x192>
 8027734:	ed9f 7b28 	vldr	d7, [pc, #160]	; 80277d8 <powf+0x258>
 8027738:	eeb4 0bc7 	vcmpe.f64	d0, d7
 802773c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027740:	d803      	bhi.n	802774a <powf+0x1ca>
 8027742:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
 8027746:	f001 ba25 	b.w	8028b94 <__math_uflowf>
 802774a:	ed9f 7b25 	vldr	d7, [pc, #148]	; 80277e0 <powf+0x260>
 802774e:	eeb4 0bc7 	vcmpe.f64	d0, d7
 8027752:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027756:	d503      	bpl.n	8027760 <powf+0x1e0>
 8027758:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
 802775c:	f001 ba20 	b.w	8028ba0 <__math_may_uflowf>
 8027760:	4924      	ldr	r1, [pc, #144]	; (80277f4 <powf+0x274>)
 8027762:	ed91 7b40 	vldr	d7, [r1, #256]	; 0x100
 8027766:	ee30 6b07 	vadd.f64	d6, d0, d7
 802776a:	ec55 4b16 	vmov	r4, r5, d6
 802776e:	ee36 7b47 	vsub.f64	d7, d6, d7
 8027772:	f004 021f 	and.w	r2, r4, #31
 8027776:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 802777a:	ed91 6b46 	vldr	d6, [r1, #280]	; 0x118
 802777e:	ee30 0b47 	vsub.f64	d0, d0, d7
 8027782:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
 8027786:	e9d2 6700 	ldrd	r6, r7, [r2]
 802778a:	eea0 7b06 	vfma.f64	d7, d0, d6
 802778e:	1824      	adds	r4, r4, r0
 8027790:	ed91 5b42 	vldr	d5, [r1, #264]	; 0x108
 8027794:	ed91 6b44 	vldr	d6, [r1, #272]	; 0x110
 8027798:	2000      	movs	r0, #0
 802779a:	1982      	adds	r2, r0, r6
 802779c:	ea4f 31c4 	mov.w	r1, r4, lsl #15
 80277a0:	eb41 0307 	adc.w	r3, r1, r7
 80277a4:	eea0 6b05 	vfma.f64	d6, d0, d5
 80277a8:	ee20 0b00 	vmul.f64	d0, d0, d0
 80277ac:	eea6 7b00 	vfma.f64	d7, d6, d0
 80277b0:	ec43 2b16 	vmov	d6, r2, r3
 80277b4:	ee27 0b06 	vmul.f64	d0, d7, d6
 80277b8:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 80277bc:	e753      	b.n	8027666 <powf+0xe6>
 80277be:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80277c2:	e750      	b.n	8027666 <powf+0xe6>
 80277c4:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 80277f8 <powf+0x278>
 80277c8:	e74d      	b.n	8027666 <powf+0xe6>
 80277ca:	bf00      	nop
 80277cc:	f3af 8000 	nop.w
 80277d0:	ffd1d571 	.word	0xffd1d571
 80277d4:	405fffff 	.word	0x405fffff
 80277d8:	00000000 	.word	0x00000000
 80277dc:	c062c000 	.word	0xc062c000
 80277e0:	00000000 	.word	0x00000000
 80277e4:	c062a000 	.word	0xc062a000
 80277e8:	fefffffe 	.word	0xfefffffe
 80277ec:	0804b488 	.word	0x0804b488
 80277f0:	4b000000 	.word	0x4b000000
 80277f4:	0804b100 	.word	0x0804b100
 80277f8:	00000000 	.word	0x00000000

080277fc <tanf>:
 80277fc:	ee10 3a10 	vmov	r3, s0
 8027800:	b507      	push	{r0, r1, r2, lr}
 8027802:	4a10      	ldr	r2, [pc, #64]	; (8027844 <tanf+0x48>)
 8027804:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8027808:	4293      	cmp	r3, r2
 802780a:	dc05      	bgt.n	8027818 <tanf+0x1c>
 802780c:	eddf 0a0e 	vldr	s1, [pc, #56]	; 8027848 <tanf+0x4c>
 8027810:	2001      	movs	r0, #1
 8027812:	f001 f8c1 	bl	8028998 <__kernel_tanf>
 8027816:	e004      	b.n	8027822 <tanf+0x26>
 8027818:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802781c:	db04      	blt.n	8027828 <tanf+0x2c>
 802781e:	ee30 0a40 	vsub.f32	s0, s0, s0
 8027822:	b003      	add	sp, #12
 8027824:	f85d fb04 	ldr.w	pc, [sp], #4
 8027828:	4668      	mov	r0, sp
 802782a:	f000 fbf3 	bl	8028014 <__ieee754_rem_pio2f>
 802782e:	0040      	lsls	r0, r0, #1
 8027830:	f000 0002 	and.w	r0, r0, #2
 8027834:	f1c0 0001 	rsb	r0, r0, #1
 8027838:	eddd 0a01 	vldr	s1, [sp, #4]
 802783c:	ed9d 0a00 	vldr	s0, [sp]
 8027840:	e7e7      	b.n	8027812 <tanf+0x16>
 8027842:	bf00      	nop
 8027844:	3f490fda 	.word	0x3f490fda
 8027848:	00000000 	.word	0x00000000

0802784c <tanhf>:
 802784c:	b510      	push	{r4, lr}
 802784e:	ee10 4a10 	vmov	r4, s0
 8027852:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 8027856:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802785a:	ed2d 8b02 	vpush	{d8}
 802785e:	eef0 7a40 	vmov.f32	s15, s0
 8027862:	db0c      	blt.n	802787e <tanhf+0x32>
 8027864:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8027868:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802786c:	2c00      	cmp	r4, #0
 802786e:	bfac      	ite	ge
 8027870:	ee30 0a07 	vaddge.f32	s0, s0, s14
 8027874:	ee30 0a47 	vsublt.f32	s0, s0, s14
 8027878:	ecbd 8b02 	vpop	{d8}
 802787c:	bd10      	pop	{r4, pc}
 802787e:	4a1b      	ldr	r2, [pc, #108]	; (80278ec <tanhf+0xa0>)
 8027880:	4293      	cmp	r3, r2
 8027882:	dc30      	bgt.n	80278e6 <tanhf+0x9a>
 8027884:	f1b3 5f10 	cmp.w	r3, #603979776	; 0x24000000
 8027888:	da06      	bge.n	8027898 <tanhf+0x4c>
 802788a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802788e:	ee37 0a80 	vadd.f32	s0, s15, s0
 8027892:	ee20 0a27 	vmul.f32	s0, s0, s15
 8027896:	e7ef      	b.n	8027878 <tanhf+0x2c>
 8027898:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802789c:	eeb0 8a00 	vmov.f32	s16, #0	; 0x40000000  2.0
 80278a0:	db12      	blt.n	80278c8 <tanhf+0x7c>
 80278a2:	f7ff fd7b 	bl	802739c <fabsf>
 80278a6:	ee30 0a00 	vadd.f32	s0, s0, s0
 80278aa:	f001 f9b9 	bl	8028c20 <expm1f>
 80278ae:	ee30 0a08 	vadd.f32	s0, s0, s16
 80278b2:	eec8 7a00 	vdiv.f32	s15, s16, s0
 80278b6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80278ba:	ee30 0a67 	vsub.f32	s0, s0, s15
 80278be:	2c00      	cmp	r4, #0
 80278c0:	bfb8      	it	lt
 80278c2:	eeb1 0a40 	vneglt.f32	s0, s0
 80278c6:	e7d7      	b.n	8027878 <tanhf+0x2c>
 80278c8:	f7ff fd68 	bl	802739c <fabsf>
 80278cc:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
 80278d0:	ee20 0a27 	vmul.f32	s0, s0, s15
 80278d4:	f001 f9a4 	bl	8028c20 <expm1f>
 80278d8:	ee70 7a08 	vadd.f32	s15, s0, s16
 80278dc:	eeb1 7a40 	vneg.f32	s14, s0
 80278e0:	ee87 0a27 	vdiv.f32	s0, s14, s15
 80278e4:	e7eb      	b.n	80278be <tanhf+0x72>
 80278e6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80278ea:	e7e8      	b.n	80278be <tanhf+0x72>
 80278ec:	41afffff 	.word	0x41afffff

080278f0 <exp>:
 80278f0:	b510      	push	{r4, lr}
 80278f2:	ed2d 8b04 	vpush	{d8-d9}
 80278f6:	eeb0 8b40 	vmov.f64	d8, d0
 80278fa:	4c33      	ldr	r4, [pc, #204]	; (80279c8 <exp+0xd8>)
 80278fc:	b08a      	sub	sp, #40	; 0x28
 80278fe:	f000 f9a3 	bl	8027c48 <__ieee754_exp>
 8027902:	f994 3000 	ldrsb.w	r3, [r4]
 8027906:	eeb0 9b40 	vmov.f64	d9, d0
 802790a:	3301      	adds	r3, #1
 802790c:	d029      	beq.n	8027962 <exp+0x72>
 802790e:	eeb0 0b48 	vmov.f64	d0, d8
 8027912:	f001 f970 	bl	8028bf6 <finite>
 8027916:	b320      	cbz	r0, 8027962 <exp+0x72>
 8027918:	ed9f 7b27 	vldr	d7, [pc, #156]	; 80279b8 <exp+0xc8>
 802791c:	eeb4 8bc7 	vcmpe.f64	d8, d7
 8027920:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027924:	dd2e      	ble.n	8027984 <exp+0x94>
 8027926:	2303      	movs	r3, #3
 8027928:	9300      	str	r3, [sp, #0]
 802792a:	4b28      	ldr	r3, [pc, #160]	; (80279cc <exp+0xdc>)
 802792c:	9301      	str	r3, [sp, #4]
 802792e:	2300      	movs	r3, #0
 8027930:	9308      	str	r3, [sp, #32]
 8027932:	f994 3000 	ldrsb.w	r3, [r4]
 8027936:	ed8d 8b04 	vstr	d8, [sp, #16]
 802793a:	ed8d 8b02 	vstr	d8, [sp, #8]
 802793e:	b9b3      	cbnz	r3, 802796e <exp+0x7e>
 8027940:	4b23      	ldr	r3, [pc, #140]	; (80279d0 <exp+0xe0>)
 8027942:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 8027946:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802794a:	4668      	mov	r0, sp
 802794c:	f001 f95b 	bl	8028c06 <matherr>
 8027950:	b198      	cbz	r0, 802797a <exp+0x8a>
 8027952:	9b08      	ldr	r3, [sp, #32]
 8027954:	b11b      	cbz	r3, 802795e <exp+0x6e>
 8027956:	f7ff faf3 	bl	8026f40 <__errno>
 802795a:	9b08      	ldr	r3, [sp, #32]
 802795c:	6003      	str	r3, [r0, #0]
 802795e:	ed9d 9b06 	vldr	d9, [sp, #24]
 8027962:	eeb0 0b49 	vmov.f64	d0, d9
 8027966:	b00a      	add	sp, #40	; 0x28
 8027968:	ecbd 8b04 	vpop	{d8-d9}
 802796c:	bd10      	pop	{r4, pc}
 802796e:	4919      	ldr	r1, [pc, #100]	; (80279d4 <exp+0xe4>)
 8027970:	2000      	movs	r0, #0
 8027972:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8027976:	2b02      	cmp	r3, #2
 8027978:	d1e7      	bne.n	802794a <exp+0x5a>
 802797a:	f7ff fae1 	bl	8026f40 <__errno>
 802797e:	2322      	movs	r3, #34	; 0x22
 8027980:	6003      	str	r3, [r0, #0]
 8027982:	e7e6      	b.n	8027952 <exp+0x62>
 8027984:	ed9f 7b0e 	vldr	d7, [pc, #56]	; 80279c0 <exp+0xd0>
 8027988:	eeb4 8bc7 	vcmpe.f64	d8, d7
 802798c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027990:	d5e7      	bpl.n	8027962 <exp+0x72>
 8027992:	2304      	movs	r3, #4
 8027994:	9300      	str	r3, [sp, #0]
 8027996:	4b0d      	ldr	r3, [pc, #52]	; (80279cc <exp+0xdc>)
 8027998:	9301      	str	r3, [sp, #4]
 802799a:	2300      	movs	r3, #0
 802799c:	9308      	str	r3, [sp, #32]
 802799e:	2200      	movs	r2, #0
 80279a0:	2300      	movs	r3, #0
 80279a2:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80279a6:	ed8d 8b04 	vstr	d8, [sp, #16]
 80279aa:	ed8d 8b02 	vstr	d8, [sp, #8]
 80279ae:	f994 3000 	ldrsb.w	r3, [r4]
 80279b2:	e7e0      	b.n	8027976 <exp+0x86>
 80279b4:	f3af 8000 	nop.w
 80279b8:	fefa39ef 	.word	0xfefa39ef
 80279bc:	40862e42 	.word	0x40862e42
 80279c0:	d52d3051 	.word	0xd52d3051
 80279c4:	c0874910 	.word	0xc0874910
 80279c8:	200004a4 	.word	0x200004a4
 80279cc:	0804b5b0 	.word	0x0804b5b0
 80279d0:	47efffff 	.word	0x47efffff
 80279d4:	7ff00000 	.word	0x7ff00000

080279d8 <fmodf>:
 80279d8:	b500      	push	{lr}
 80279da:	ed2d 8b02 	vpush	{d8}
 80279de:	b08b      	sub	sp, #44	; 0x2c
 80279e0:	eeb0 8a40 	vmov.f32	s16, s0
 80279e4:	eef0 8a60 	vmov.f32	s17, s1
 80279e8:	f000 fa36 	bl	8027e58 <__ieee754_fmodf>
 80279ec:	4b24      	ldr	r3, [pc, #144]	; (8027a80 <fmodf+0xa8>)
 80279ee:	f993 3000 	ldrsb.w	r3, [r3]
 80279f2:	1c5a      	adds	r2, r3, #1
 80279f4:	d02d      	beq.n	8027a52 <fmodf+0x7a>
 80279f6:	eef4 8a68 	vcmp.f32	s17, s17
 80279fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80279fe:	d628      	bvs.n	8027a52 <fmodf+0x7a>
 8027a00:	eeb4 8a48 	vcmp.f32	s16, s16
 8027a04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027a08:	d623      	bvs.n	8027a52 <fmodf+0x7a>
 8027a0a:	eef5 8a40 	vcmp.f32	s17, #0.0
 8027a0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027a12:	d11e      	bne.n	8027a52 <fmodf+0x7a>
 8027a14:	2201      	movs	r2, #1
 8027a16:	9200      	str	r2, [sp, #0]
 8027a18:	eeb7 0ac8 	vcvt.f64.f32	d0, s16
 8027a1c:	4a19      	ldr	r2, [pc, #100]	; (8027a84 <fmodf+0xac>)
 8027a1e:	9201      	str	r2, [sp, #4]
 8027a20:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
 8027a24:	2200      	movs	r2, #0
 8027a26:	9208      	str	r2, [sp, #32]
 8027a28:	ed8d 0b02 	vstr	d0, [sp, #8]
 8027a2c:	ed8d 7b04 	vstr	d7, [sp, #16]
 8027a30:	b9a3      	cbnz	r3, 8027a5c <fmodf+0x84>
 8027a32:	ed8d 0b06 	vstr	d0, [sp, #24]
 8027a36:	4668      	mov	r0, sp
 8027a38:	f001 f8e5 	bl	8028c06 <matherr>
 8027a3c:	b1b0      	cbz	r0, 8027a6c <fmodf+0x94>
 8027a3e:	9b08      	ldr	r3, [sp, #32]
 8027a40:	b11b      	cbz	r3, 8027a4a <fmodf+0x72>
 8027a42:	f7ff fa7d 	bl	8026f40 <__errno>
 8027a46:	9b08      	ldr	r3, [sp, #32]
 8027a48:	6003      	str	r3, [r0, #0]
 8027a4a:	ed9d 0b06 	vldr	d0, [sp, #24]
 8027a4e:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 8027a52:	b00b      	add	sp, #44	; 0x2c
 8027a54:	ecbd 8b02 	vpop	{d8}
 8027a58:	f85d fb04 	ldr.w	pc, [sp], #4
 8027a5c:	ed9f 7b06 	vldr	d7, [pc, #24]	; 8027a78 <fmodf+0xa0>
 8027a60:	2b02      	cmp	r3, #2
 8027a62:	ee87 6b07 	vdiv.f64	d6, d7, d7
 8027a66:	ed8d 6b06 	vstr	d6, [sp, #24]
 8027a6a:	d1e4      	bne.n	8027a36 <fmodf+0x5e>
 8027a6c:	f7ff fa68 	bl	8026f40 <__errno>
 8027a70:	2321      	movs	r3, #33	; 0x21
 8027a72:	6003      	str	r3, [r0, #0]
 8027a74:	e7e3      	b.n	8027a3e <fmodf+0x66>
 8027a76:	bf00      	nop
	...
 8027a80:	200004a4 	.word	0x200004a4
 8027a84:	0804b5b4 	.word	0x0804b5b4

08027a88 <log10f>:
 8027a88:	b500      	push	{lr}
 8027a8a:	ed2d 8b02 	vpush	{d8}
 8027a8e:	b08b      	sub	sp, #44	; 0x2c
 8027a90:	eeb0 8a40 	vmov.f32	s16, s0
 8027a94:	f000 fa68 	bl	8027f68 <__ieee754_log10f>
 8027a98:	4b2f      	ldr	r3, [pc, #188]	; (8027b58 <log10f+0xd0>)
 8027a9a:	f993 3000 	ldrsb.w	r3, [r3]
 8027a9e:	1c5a      	adds	r2, r3, #1
 8027aa0:	d055      	beq.n	8027b4e <log10f+0xc6>
 8027aa2:	eeb4 8a48 	vcmp.f32	s16, s16
 8027aa6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027aaa:	d650      	bvs.n	8027b4e <log10f+0xc6>
 8027aac:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8027ab0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027ab4:	d84b      	bhi.n	8027b4e <log10f+0xc6>
 8027ab6:	4a29      	ldr	r2, [pc, #164]	; (8027b5c <log10f+0xd4>)
 8027ab8:	9201      	str	r2, [sp, #4]
 8027aba:	eeb7 7ac8 	vcvt.f64.f32	d7, s16
 8027abe:	2200      	movs	r2, #0
 8027ac0:	9208      	str	r2, [sp, #32]
 8027ac2:	ed8d 7b04 	vstr	d7, [sp, #16]
 8027ac6:	ed8d 7b02 	vstr	d7, [sp, #8]
 8027aca:	b993      	cbnz	r3, 8027af2 <log10f+0x6a>
 8027acc:	4924      	ldr	r1, [pc, #144]	; (8027b60 <log10f+0xd8>)
 8027ace:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8027ad2:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8027ad6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027ada:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8027ade:	d025      	beq.n	8027b2c <log10f+0xa4>
 8027ae0:	2201      	movs	r2, #1
 8027ae2:	2b02      	cmp	r3, #2
 8027ae4:	9200      	str	r2, [sp, #0]
 8027ae6:	d116      	bne.n	8027b16 <log10f+0x8e>
 8027ae8:	f7ff fa2a 	bl	8026f40 <__errno>
 8027aec:	2321      	movs	r3, #33	; 0x21
 8027aee:	6003      	str	r3, [r0, #0]
 8027af0:	e016      	b.n	8027b20 <log10f+0x98>
 8027af2:	491c      	ldr	r1, [pc, #112]	; (8027b64 <log10f+0xdc>)
 8027af4:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8027af8:	2000      	movs	r0, #0
 8027afa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027afe:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8027b02:	d1ed      	bne.n	8027ae0 <log10f+0x58>
 8027b04:	2202      	movs	r2, #2
 8027b06:	4293      	cmp	r3, r2
 8027b08:	9200      	str	r2, [sp, #0]
 8027b0a:	d111      	bne.n	8027b30 <log10f+0xa8>
 8027b0c:	f7ff fa18 	bl	8026f40 <__errno>
 8027b10:	2322      	movs	r3, #34	; 0x22
 8027b12:	6003      	str	r3, [r0, #0]
 8027b14:	e011      	b.n	8027b3a <log10f+0xb2>
 8027b16:	4668      	mov	r0, sp
 8027b18:	f001 f875 	bl	8028c06 <matherr>
 8027b1c:	2800      	cmp	r0, #0
 8027b1e:	d0e3      	beq.n	8027ae8 <log10f+0x60>
 8027b20:	4811      	ldr	r0, [pc, #68]	; (8027b68 <log10f+0xe0>)
 8027b22:	f001 f875 	bl	8028c10 <nan>
 8027b26:	ed8d 0b06 	vstr	d0, [sp, #24]
 8027b2a:	e006      	b.n	8027b3a <log10f+0xb2>
 8027b2c:	2302      	movs	r3, #2
 8027b2e:	9300      	str	r3, [sp, #0]
 8027b30:	4668      	mov	r0, sp
 8027b32:	f001 f868 	bl	8028c06 <matherr>
 8027b36:	2800      	cmp	r0, #0
 8027b38:	d0e8      	beq.n	8027b0c <log10f+0x84>
 8027b3a:	9b08      	ldr	r3, [sp, #32]
 8027b3c:	b11b      	cbz	r3, 8027b46 <log10f+0xbe>
 8027b3e:	f7ff f9ff 	bl	8026f40 <__errno>
 8027b42:	9b08      	ldr	r3, [sp, #32]
 8027b44:	6003      	str	r3, [r0, #0]
 8027b46:	ed9d 0b06 	vldr	d0, [sp, #24]
 8027b4a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 8027b4e:	b00b      	add	sp, #44	; 0x2c
 8027b50:	ecbd 8b02 	vpop	{d8}
 8027b54:	f85d fb04 	ldr.w	pc, [sp], #4
 8027b58:	200004a4 	.word	0x200004a4
 8027b5c:	0804b5ba 	.word	0x0804b5ba
 8027b60:	c7efffff 	.word	0xc7efffff
 8027b64:	fff00000 	.word	0xfff00000
 8027b68:	0804b5c0 	.word	0x0804b5c0
 8027b6c:	00000000 	.word	0x00000000

08027b70 <sinhf>:
 8027b70:	b530      	push	{r4, r5, lr}
 8027b72:	ed2d 8b02 	vpush	{d8}
 8027b76:	4c32      	ldr	r4, [pc, #200]	; (8027c40 <sinhf+0xd0>)
 8027b78:	b08b      	sub	sp, #44	; 0x2c
 8027b7a:	eef0 8a40 	vmov.f32	s17, s0
 8027b7e:	f000 fb75 	bl	802826c <__ieee754_sinhf>
 8027b82:	f994 3000 	ldrsb.w	r3, [r4]
 8027b86:	3301      	adds	r3, #1
 8027b88:	eeb0 8a40 	vmov.f32	s16, s0
 8027b8c:	d030      	beq.n	8027bf0 <sinhf+0x80>
 8027b8e:	f001 f971 	bl	8028e74 <finitef>
 8027b92:	4605      	mov	r5, r0
 8027b94:	bb60      	cbnz	r0, 8027bf0 <sinhf+0x80>
 8027b96:	eeb0 0a68 	vmov.f32	s0, s17
 8027b9a:	f001 f96b 	bl	8028e74 <finitef>
 8027b9e:	b338      	cbz	r0, 8027bf0 <sinhf+0x80>
 8027ba0:	2303      	movs	r3, #3
 8027ba2:	9300      	str	r3, [sp, #0]
 8027ba4:	4b27      	ldr	r3, [pc, #156]	; (8027c44 <sinhf+0xd4>)
 8027ba6:	9301      	str	r3, [sp, #4]
 8027ba8:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
 8027bac:	f994 3000 	ldrsb.w	r3, [r4]
 8027bb0:	9508      	str	r5, [sp, #32]
 8027bb2:	ed8d 7b04 	vstr	d7, [sp, #16]
 8027bb6:	ed8d 7b02 	vstr	d7, [sp, #8]
 8027bba:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 8027bbe:	b9eb      	cbnz	r3, 8027bfc <sinhf+0x8c>
 8027bc0:	ed9f 7b17 	vldr	d7, [pc, #92]	; 8027c20 <sinhf+0xb0>
 8027bc4:	ed9f 6b18 	vldr	d6, [pc, #96]	; 8027c28 <sinhf+0xb8>
 8027bc8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027bcc:	fe37 7b06 	vselgt.f64	d7, d7, d6
 8027bd0:	ed8d 7b06 	vstr	d7, [sp, #24]
 8027bd4:	4668      	mov	r0, sp
 8027bd6:	f001 f816 	bl	8028c06 <matherr>
 8027bda:	b1d8      	cbz	r0, 8027c14 <sinhf+0xa4>
 8027bdc:	9b08      	ldr	r3, [sp, #32]
 8027bde:	b11b      	cbz	r3, 8027be8 <sinhf+0x78>
 8027be0:	f7ff f9ae 	bl	8026f40 <__errno>
 8027be4:	9b08      	ldr	r3, [sp, #32]
 8027be6:	6003      	str	r3, [r0, #0]
 8027be8:	ed9d 8b06 	vldr	d8, [sp, #24]
 8027bec:	eeb7 8bc8 	vcvt.f32.f64	s16, d8
 8027bf0:	eeb0 0a48 	vmov.f32	s0, s16
 8027bf4:	b00b      	add	sp, #44	; 0x2c
 8027bf6:	ecbd 8b02 	vpop	{d8}
 8027bfa:	bd30      	pop	{r4, r5, pc}
 8027bfc:	ed9f 7b0c 	vldr	d7, [pc, #48]	; 8027c30 <sinhf+0xc0>
 8027c00:	ed9f 6b0d 	vldr	d6, [pc, #52]	; 8027c38 <sinhf+0xc8>
 8027c04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027c08:	fe37 7b06 	vselgt.f64	d7, d7, d6
 8027c0c:	2b02      	cmp	r3, #2
 8027c0e:	ed8d 7b06 	vstr	d7, [sp, #24]
 8027c12:	d1df      	bne.n	8027bd4 <sinhf+0x64>
 8027c14:	f7ff f994 	bl	8026f40 <__errno>
 8027c18:	2322      	movs	r3, #34	; 0x22
 8027c1a:	6003      	str	r3, [r0, #0]
 8027c1c:	e7de      	b.n	8027bdc <sinhf+0x6c>
 8027c1e:	bf00      	nop
 8027c20:	e0000000 	.word	0xe0000000
 8027c24:	47efffff 	.word	0x47efffff
 8027c28:	e0000000 	.word	0xe0000000
 8027c2c:	c7efffff 	.word	0xc7efffff
 8027c30:	00000000 	.word	0x00000000
 8027c34:	7ff00000 	.word	0x7ff00000
 8027c38:	00000000 	.word	0x00000000
 8027c3c:	fff00000 	.word	0xfff00000
 8027c40:	200004a4 	.word	0x200004a4
 8027c44:	0804b5c1 	.word	0x0804b5c1

08027c48 <__ieee754_exp>:
 8027c48:	ee10 1a90 	vmov	r1, s1
 8027c4c:	4b7a      	ldr	r3, [pc, #488]	; (8027e38 <__ieee754_exp+0x1f0>)
 8027c4e:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 8027c52:	429a      	cmp	r2, r3
 8027c54:	b082      	sub	sp, #8
 8027c56:	ea4f 70d1 	mov.w	r0, r1, lsr #31
 8027c5a:	d928      	bls.n	8027cae <__ieee754_exp+0x66>
 8027c5c:	4b77      	ldr	r3, [pc, #476]	; (8027e3c <__ieee754_exp+0x1f4>)
 8027c5e:	429a      	cmp	r2, r3
 8027c60:	d90f      	bls.n	8027c82 <__ieee754_exp+0x3a>
 8027c62:	ee10 3a10 	vmov	r3, s0
 8027c66:	f3c1 0113 	ubfx	r1, r1, #0, #20
 8027c6a:	430b      	orrs	r3, r1
 8027c6c:	d003      	beq.n	8027c76 <__ieee754_exp+0x2e>
 8027c6e:	ee30 0b00 	vadd.f64	d0, d0, d0
 8027c72:	b002      	add	sp, #8
 8027c74:	4770      	bx	lr
 8027c76:	ed9f 7b56 	vldr	d7, [pc, #344]	; 8027dd0 <__ieee754_exp+0x188>
 8027c7a:	2800      	cmp	r0, #0
 8027c7c:	fe00 0b07 	vseleq.f64	d0, d0, d7
 8027c80:	e7f7      	b.n	8027c72 <__ieee754_exp+0x2a>
 8027c82:	ed9f 7b55 	vldr	d7, [pc, #340]	; 8027dd8 <__ieee754_exp+0x190>
 8027c86:	eeb4 0bc7 	vcmpe.f64	d0, d7
 8027c8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027c8e:	dd04      	ble.n	8027c9a <__ieee754_exp+0x52>
 8027c90:	ed9f 0b53 	vldr	d0, [pc, #332]	; 8027de0 <__ieee754_exp+0x198>
 8027c94:	ee20 0b00 	vmul.f64	d0, d0, d0
 8027c98:	e7eb      	b.n	8027c72 <__ieee754_exp+0x2a>
 8027c9a:	ed9f 7b53 	vldr	d7, [pc, #332]	; 8027de8 <__ieee754_exp+0x1a0>
 8027c9e:	eeb4 0bc7 	vcmpe.f64	d0, d7
 8027ca2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027ca6:	d505      	bpl.n	8027cb4 <__ieee754_exp+0x6c>
 8027ca8:	ed9f 0b49 	vldr	d0, [pc, #292]	; 8027dd0 <__ieee754_exp+0x188>
 8027cac:	e7e1      	b.n	8027c72 <__ieee754_exp+0x2a>
 8027cae:	4b64      	ldr	r3, [pc, #400]	; (8027e40 <__ieee754_exp+0x1f8>)
 8027cb0:	429a      	cmp	r2, r3
 8027cb2:	d956      	bls.n	8027d62 <__ieee754_exp+0x11a>
 8027cb4:	4b63      	ldr	r3, [pc, #396]	; (8027e44 <__ieee754_exp+0x1fc>)
 8027cb6:	429a      	cmp	r2, r3
 8027cb8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8027cbc:	d838      	bhi.n	8027d30 <__ieee754_exp+0xe8>
 8027cbe:	4b62      	ldr	r3, [pc, #392]	; (8027e48 <__ieee754_exp+0x200>)
 8027cc0:	4413      	add	r3, r2
 8027cc2:	ed93 6b00 	vldr	d6, [r3]
 8027cc6:	4b61      	ldr	r3, [pc, #388]	; (8027e4c <__ieee754_exp+0x204>)
 8027cc8:	ee30 6b46 	vsub.f64	d6, d0, d6
 8027ccc:	4413      	add	r3, r2
 8027cce:	ed93 7b00 	vldr	d7, [r3]
 8027cd2:	f1c0 0301 	rsb	r3, r0, #1
 8027cd6:	1a1b      	subs	r3, r3, r0
 8027cd8:	ee36 0b47 	vsub.f64	d0, d6, d7
 8027cdc:	ed9f 4b44 	vldr	d4, [pc, #272]	; 8027df0 <__ieee754_exp+0x1a8>
 8027ce0:	ee20 5b00 	vmul.f64	d5, d0, d0
 8027ce4:	ed9f 3b44 	vldr	d3, [pc, #272]	; 8027df8 <__ieee754_exp+0x1b0>
 8027ce8:	eea5 3b04 	vfma.f64	d3, d5, d4
 8027cec:	ed9f 4b44 	vldr	d4, [pc, #272]	; 8027e00 <__ieee754_exp+0x1b8>
 8027cf0:	eea3 4b05 	vfma.f64	d4, d3, d5
 8027cf4:	ed9f 3b44 	vldr	d3, [pc, #272]	; 8027e08 <__ieee754_exp+0x1c0>
 8027cf8:	eea4 3b05 	vfma.f64	d3, d4, d5
 8027cfc:	ed9f 4b44 	vldr	d4, [pc, #272]	; 8027e10 <__ieee754_exp+0x1c8>
 8027d00:	eea3 4b05 	vfma.f64	d4, d3, d5
 8027d04:	eeb0 3b40 	vmov.f64	d3, d0
 8027d08:	eea4 3b45 	vfms.f64	d3, d4, d5
 8027d0c:	eeb0 4b00 	vmov.f64	d4, #0	; 0x40000000  2.0
 8027d10:	eeb0 5b43 	vmov.f64	d5, d3
 8027d14:	ee20 2b03 	vmul.f64	d2, d0, d3
 8027d18:	eeb7 3b00 	vmov.f64	d3, #112	; 0x3f800000  1.0
 8027d1c:	bba3      	cbnz	r3, 8027d88 <__ieee754_exp+0x140>
 8027d1e:	ee35 5b44 	vsub.f64	d5, d5, d4
 8027d22:	ee82 7b05 	vdiv.f64	d7, d2, d5
 8027d26:	ee37 0b40 	vsub.f64	d0, d7, d0
 8027d2a:	ee33 0b40 	vsub.f64	d0, d3, d0
 8027d2e:	e7a0      	b.n	8027c72 <__ieee754_exp+0x2a>
 8027d30:	4b47      	ldr	r3, [pc, #284]	; (8027e50 <__ieee754_exp+0x208>)
 8027d32:	4413      	add	r3, r2
 8027d34:	ed93 7b00 	vldr	d7, [r3]
 8027d38:	ed9f 6b37 	vldr	d6, [pc, #220]	; 8027e18 <__ieee754_exp+0x1d0>
 8027d3c:	ed9f 5b38 	vldr	d5, [pc, #224]	; 8027e20 <__ieee754_exp+0x1d8>
 8027d40:	eea0 7b06 	vfma.f64	d7, d0, d6
 8027d44:	ed9f 6b38 	vldr	d6, [pc, #224]	; 8027e28 <__ieee754_exp+0x1e0>
 8027d48:	eefd 7bc7 	vcvt.s32.f64	s15, d7
 8027d4c:	ee17 3a90 	vmov	r3, s15
 8027d50:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 8027d54:	eea7 0b46 	vfms.f64	d0, d7, d6
 8027d58:	ee27 7b05 	vmul.f64	d7, d7, d5
 8027d5c:	eeb0 6b40 	vmov.f64	d6, d0
 8027d60:	e7ba      	b.n	8027cd8 <__ieee754_exp+0x90>
 8027d62:	4b3c      	ldr	r3, [pc, #240]	; (8027e54 <__ieee754_exp+0x20c>)
 8027d64:	429a      	cmp	r2, r3
 8027d66:	d80d      	bhi.n	8027d84 <__ieee754_exp+0x13c>
 8027d68:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
 8027d6c:	ed9f 5b1c 	vldr	d5, [pc, #112]	; 8027de0 <__ieee754_exp+0x198>
 8027d70:	ee30 5b05 	vadd.f64	d5, d0, d5
 8027d74:	eeb4 5bc4 	vcmpe.f64	d5, d4
 8027d78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027d7c:	dd02      	ble.n	8027d84 <__ieee754_exp+0x13c>
 8027d7e:	ee30 0b04 	vadd.f64	d0, d0, d4
 8027d82:	e776      	b.n	8027c72 <__ieee754_exp+0x2a>
 8027d84:	2300      	movs	r3, #0
 8027d86:	e7a9      	b.n	8027cdc <__ieee754_exp+0x94>
 8027d88:	f46f 717f 	mvn.w	r1, #1020	; 0x3fc
 8027d8c:	ee34 5b45 	vsub.f64	d5, d4, d5
 8027d90:	428b      	cmp	r3, r1
 8027d92:	ee82 4b05 	vdiv.f64	d4, d2, d5
 8027d96:	ee37 7b44 	vsub.f64	d7, d7, d4
 8027d9a:	ee37 7b46 	vsub.f64	d7, d7, d6
 8027d9e:	ee33 7b47 	vsub.f64	d7, d3, d7
 8027da2:	ed8d 7b00 	vstr	d7, [sp]
 8027da6:	9a01      	ldr	r2, [sp, #4]
 8027da8:	e9dd 0100 	ldrd	r0, r1, [sp]
 8027dac:	db04      	blt.n	8027db8 <__ieee754_exp+0x170>
 8027dae:	eb02 5103 	add.w	r1, r2, r3, lsl #20
 8027db2:	ec41 0b10 	vmov	d0, r0, r1
 8027db6:	e75c      	b.n	8027c72 <__ieee754_exp+0x2a>
 8027db8:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 8027dbc:	eb02 5103 	add.w	r1, r2, r3, lsl #20
 8027dc0:	ed9f 7b1b 	vldr	d7, [pc, #108]	; 8027e30 <__ieee754_exp+0x1e8>
 8027dc4:	ec41 0b10 	vmov	d0, r0, r1
 8027dc8:	ee20 0b07 	vmul.f64	d0, d0, d7
 8027dcc:	e751      	b.n	8027c72 <__ieee754_exp+0x2a>
 8027dce:	bf00      	nop
	...
 8027dd8:	fefa39ef 	.word	0xfefa39ef
 8027ddc:	40862e42 	.word	0x40862e42
 8027de0:	8800759c 	.word	0x8800759c
 8027de4:	7e37e43c 	.word	0x7e37e43c
 8027de8:	d52d3051 	.word	0xd52d3051
 8027dec:	c0874910 	.word	0xc0874910
 8027df0:	72bea4d0 	.word	0x72bea4d0
 8027df4:	3e663769 	.word	0x3e663769
 8027df8:	c5d26bf1 	.word	0xc5d26bf1
 8027dfc:	bebbbd41 	.word	0xbebbbd41
 8027e00:	af25de2c 	.word	0xaf25de2c
 8027e04:	3f11566a 	.word	0x3f11566a
 8027e08:	16bebd93 	.word	0x16bebd93
 8027e0c:	bf66c16c 	.word	0xbf66c16c
 8027e10:	5555553e 	.word	0x5555553e
 8027e14:	3fc55555 	.word	0x3fc55555
 8027e18:	652b82fe 	.word	0x652b82fe
 8027e1c:	3ff71547 	.word	0x3ff71547
 8027e20:	35793c76 	.word	0x35793c76
 8027e24:	3dea39ef 	.word	0x3dea39ef
 8027e28:	fee00000 	.word	0xfee00000
 8027e2c:	3fe62e42 	.word	0x3fe62e42
 8027e30:	00000000 	.word	0x00000000
 8027e34:	01700000 	.word	0x01700000
 8027e38:	40862e41 	.word	0x40862e41
 8027e3c:	7fefffff 	.word	0x7fefffff
 8027e40:	3fd62e42 	.word	0x3fd62e42
 8027e44:	3ff0a2b1 	.word	0x3ff0a2b1
 8027e48:	0804b5d8 	.word	0x0804b5d8
 8027e4c:	0804b5e8 	.word	0x0804b5e8
 8027e50:	0804b5c8 	.word	0x0804b5c8
 8027e54:	3e2fffff 	.word	0x3e2fffff

08027e58 <__ieee754_fmodf>:
 8027e58:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027e5a:	ee10 6a90 	vmov	r6, s1
 8027e5e:	f036 4500 	bics.w	r5, r6, #2147483648	; 0x80000000
 8027e62:	ee10 3a10 	vmov	r3, s0
 8027e66:	d009      	beq.n	8027e7c <__ieee754_fmodf+0x24>
 8027e68:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 8027e6c:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8027e70:	ee10 7a10 	vmov	r7, s0
 8027e74:	da02      	bge.n	8027e7c <__ieee754_fmodf+0x24>
 8027e76:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 8027e7a:	dd0a      	ble.n	8027e92 <__ieee754_fmodf+0x3a>
 8027e7c:	ee07 3a90 	vmov	s15, r3
 8027e80:	ee67 0aa0 	vmul.f32	s1, s15, s1
 8027e84:	eec0 7aa0 	vdiv.f32	s15, s1, s1
 8027e88:	ee17 3a90 	vmov	r3, s15
 8027e8c:	ee00 3a10 	vmov	s0, r3
 8027e90:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8027e92:	42a9      	cmp	r1, r5
 8027e94:	dbfa      	blt.n	8027e8c <__ieee754_fmodf+0x34>
 8027e96:	f003 4400 	and.w	r4, r3, #2147483648	; 0x80000000
 8027e9a:	d105      	bne.n	8027ea8 <__ieee754_fmodf+0x50>
 8027e9c:	4a30      	ldr	r2, [pc, #192]	; (8027f60 <__ieee754_fmodf+0x108>)
 8027e9e:	0fe3      	lsrs	r3, r4, #31
 8027ea0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8027ea4:	681b      	ldr	r3, [r3, #0]
 8027ea6:	e7f1      	b.n	8027e8c <__ieee754_fmodf+0x34>
 8027ea8:	4b2e      	ldr	r3, [pc, #184]	; (8027f64 <__ieee754_fmodf+0x10c>)
 8027eaa:	4299      	cmp	r1, r3
 8027eac:	dc3e      	bgt.n	8027f2c <__ieee754_fmodf+0xd4>
 8027eae:	020a      	lsls	r2, r1, #8
 8027eb0:	f06f 007d 	mvn.w	r0, #125	; 0x7d
 8027eb4:	2a00      	cmp	r2, #0
 8027eb6:	dc36      	bgt.n	8027f26 <__ieee754_fmodf+0xce>
 8027eb8:	429d      	cmp	r5, r3
 8027eba:	dc3a      	bgt.n	8027f32 <__ieee754_fmodf+0xda>
 8027ebc:	022b      	lsls	r3, r5, #8
 8027ebe:	f06f 027d 	mvn.w	r2, #125	; 0x7d
 8027ec2:	005b      	lsls	r3, r3, #1
 8027ec4:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 8027ec8:	d5fb      	bpl.n	8027ec2 <__ieee754_fmodf+0x6a>
 8027eca:	f110 0f7e 	cmn.w	r0, #126	; 0x7e
 8027ece:	bfbb      	ittet	lt
 8027ed0:	f06f 037d 	mvnlt.w	r3, #125	; 0x7d
 8027ed4:	1a1b      	sublt	r3, r3, r0
 8027ed6:	f3c7 0116 	ubfxge	r1, r7, #0, #23
 8027eda:	4099      	lsllt	r1, r3
 8027edc:	bfa8      	it	ge
 8027ede:	f441 0100 	orrge.w	r1, r1, #8388608	; 0x800000
 8027ee2:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
 8027ee6:	bfb5      	itete	lt
 8027ee8:	f06f 037d 	mvnlt.w	r3, #125	; 0x7d
 8027eec:	f3c6 0516 	ubfxge	r5, r6, #0, #23
 8027ef0:	1a9b      	sublt	r3, r3, r2
 8027ef2:	f445 0500 	orrge.w	r5, r5, #8388608	; 0x800000
 8027ef6:	bfb8      	it	lt
 8027ef8:	409d      	lsllt	r5, r3
 8027efa:	1a80      	subs	r0, r0, r2
 8027efc:	1b4b      	subs	r3, r1, r5
 8027efe:	b9d8      	cbnz	r0, 8027f38 <__ieee754_fmodf+0xe0>
 8027f00:	ea33 0323 	bics.w	r3, r3, r3, asr #32
 8027f04:	bf28      	it	cs
 8027f06:	460b      	movcs	r3, r1
 8027f08:	2b00      	cmp	r3, #0
 8027f0a:	d0c7      	beq.n	8027e9c <__ieee754_fmodf+0x44>
 8027f0c:	4915      	ldr	r1, [pc, #84]	; (8027f64 <__ieee754_fmodf+0x10c>)
 8027f0e:	428b      	cmp	r3, r1
 8027f10:	dd1a      	ble.n	8027f48 <__ieee754_fmodf+0xf0>
 8027f12:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
 8027f16:	db1a      	blt.n	8027f4e <__ieee754_fmodf+0xf6>
 8027f18:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8027f1c:	4323      	orrs	r3, r4
 8027f1e:	327f      	adds	r2, #127	; 0x7f
 8027f20:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 8027f24:	e7b2      	b.n	8027e8c <__ieee754_fmodf+0x34>
 8027f26:	3801      	subs	r0, #1
 8027f28:	0052      	lsls	r2, r2, #1
 8027f2a:	e7c3      	b.n	8027eb4 <__ieee754_fmodf+0x5c>
 8027f2c:	15c8      	asrs	r0, r1, #23
 8027f2e:	387f      	subs	r0, #127	; 0x7f
 8027f30:	e7c2      	b.n	8027eb8 <__ieee754_fmodf+0x60>
 8027f32:	15ea      	asrs	r2, r5, #23
 8027f34:	3a7f      	subs	r2, #127	; 0x7f
 8027f36:	e7c8      	b.n	8027eca <__ieee754_fmodf+0x72>
 8027f38:	2b00      	cmp	r3, #0
 8027f3a:	da02      	bge.n	8027f42 <__ieee754_fmodf+0xea>
 8027f3c:	0049      	lsls	r1, r1, #1
 8027f3e:	3801      	subs	r0, #1
 8027f40:	e7dc      	b.n	8027efc <__ieee754_fmodf+0xa4>
 8027f42:	d0ab      	beq.n	8027e9c <__ieee754_fmodf+0x44>
 8027f44:	0059      	lsls	r1, r3, #1
 8027f46:	e7fa      	b.n	8027f3e <__ieee754_fmodf+0xe6>
 8027f48:	005b      	lsls	r3, r3, #1
 8027f4a:	3a01      	subs	r2, #1
 8027f4c:	e7df      	b.n	8027f0e <__ieee754_fmodf+0xb6>
 8027f4e:	f1c2 22ff 	rsb	r2, r2, #4278255360	; 0xff00ff00
 8027f52:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
 8027f56:	3282      	adds	r2, #130	; 0x82
 8027f58:	4113      	asrs	r3, r2
 8027f5a:	4323      	orrs	r3, r4
 8027f5c:	e796      	b.n	8027e8c <__ieee754_fmodf+0x34>
 8027f5e:	bf00      	nop
 8027f60:	0804b5f8 	.word	0x0804b5f8
 8027f64:	007fffff 	.word	0x007fffff

08027f68 <__ieee754_log10f>:
 8027f68:	b508      	push	{r3, lr}
 8027f6a:	ee10 2a10 	vmov	r2, s0
 8027f6e:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 8027f72:	ed2d 8b02 	vpush	{d8}
 8027f76:	d108      	bne.n	8027f8a <__ieee754_log10f+0x22>
 8027f78:	ed9f 7a20 	vldr	s14, [pc, #128]	; 8027ffc <__ieee754_log10f+0x94>
 8027f7c:	eddf 7a20 	vldr	s15, [pc, #128]	; 8028000 <__ieee754_log10f+0x98>
 8027f80:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8027f84:	ecbd 8b02 	vpop	{d8}
 8027f88:	bd08      	pop	{r3, pc}
 8027f8a:	2a00      	cmp	r2, #0
 8027f8c:	da02      	bge.n	8027f94 <__ieee754_log10f+0x2c>
 8027f8e:	ee30 7a40 	vsub.f32	s14, s0, s0
 8027f92:	e7f3      	b.n	8027f7c <__ieee754_log10f+0x14>
 8027f94:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8027f98:	db02      	blt.n	8027fa0 <__ieee754_log10f+0x38>
 8027f9a:	ee30 0a00 	vadd.f32	s0, s0, s0
 8027f9e:	e7f1      	b.n	8027f84 <__ieee754_log10f+0x1c>
 8027fa0:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 8027fa4:	bfbf      	itttt	lt
 8027fa6:	eddf 7a17 	vldrlt	s15, [pc, #92]	; 8028004 <__ieee754_log10f+0x9c>
 8027faa:	ee60 7a27 	vmullt.f32	s15, s0, s15
 8027fae:	f06f 0118 	mvnlt.w	r1, #24
 8027fb2:	ee17 2a90 	vmovlt	r2, s15
 8027fb6:	ea4f 53e2 	mov.w	r3, r2, asr #23
 8027fba:	bfa8      	it	ge
 8027fbc:	2100      	movge	r1, #0
 8027fbe:	3b7f      	subs	r3, #127	; 0x7f
 8027fc0:	440b      	add	r3, r1
 8027fc2:	0fd9      	lsrs	r1, r3, #31
 8027fc4:	440b      	add	r3, r1
 8027fc6:	f3c2 0216 	ubfx	r2, r2, #0, #23
 8027fca:	f1c1 017f 	rsb	r1, r1, #127	; 0x7f
 8027fce:	ee07 3a90 	vmov	s15, r3
 8027fd2:	ea42 53c1 	orr.w	r3, r2, r1, lsl #23
 8027fd6:	ee00 3a10 	vmov	s0, r3
 8027fda:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 8027fde:	f7ff f9e5 	bl	80273ac <logf>
 8027fe2:	eddf 7a09 	vldr	s15, [pc, #36]	; 8028008 <__ieee754_log10f+0xa0>
 8027fe6:	ee20 0a27 	vmul.f32	s0, s0, s15
 8027fea:	eddf 7a08 	vldr	s15, [pc, #32]	; 802800c <__ieee754_log10f+0xa4>
 8027fee:	eea8 0a27 	vfma.f32	s0, s16, s15
 8027ff2:	eddf 7a07 	vldr	s15, [pc, #28]	; 8028010 <__ieee754_log10f+0xa8>
 8027ff6:	eea8 0a27 	vfma.f32	s0, s16, s15
 8027ffa:	e7c3      	b.n	8027f84 <__ieee754_log10f+0x1c>
 8027ffc:	cc000000 	.word	0xcc000000
 8028000:	00000000 	.word	0x00000000
 8028004:	4c000000 	.word	0x4c000000
 8028008:	3ede5bd9 	.word	0x3ede5bd9
 802800c:	355427db 	.word	0x355427db
 8028010:	3e9a2080 	.word	0x3e9a2080

08028014 <__ieee754_rem_pio2f>:
 8028014:	b5f0      	push	{r4, r5, r6, r7, lr}
 8028016:	ee10 6a10 	vmov	r6, s0
 802801a:	4b86      	ldr	r3, [pc, #536]	; (8028234 <__ieee754_rem_pio2f+0x220>)
 802801c:	f026 4400 	bic.w	r4, r6, #2147483648	; 0x80000000
 8028020:	429c      	cmp	r4, r3
 8028022:	b087      	sub	sp, #28
 8028024:	4605      	mov	r5, r0
 8028026:	dc05      	bgt.n	8028034 <__ieee754_rem_pio2f+0x20>
 8028028:	2300      	movs	r3, #0
 802802a:	ed85 0a00 	vstr	s0, [r5]
 802802e:	6043      	str	r3, [r0, #4]
 8028030:	2000      	movs	r0, #0
 8028032:	e020      	b.n	8028076 <__ieee754_rem_pio2f+0x62>
 8028034:	4b80      	ldr	r3, [pc, #512]	; (8028238 <__ieee754_rem_pio2f+0x224>)
 8028036:	429c      	cmp	r4, r3
 8028038:	dc38      	bgt.n	80280ac <__ieee754_rem_pio2f+0x98>
 802803a:	2e00      	cmp	r6, #0
 802803c:	f024 040f 	bic.w	r4, r4, #15
 8028040:	ed9f 7a7e 	vldr	s14, [pc, #504]	; 802823c <__ieee754_rem_pio2f+0x228>
 8028044:	4b7e      	ldr	r3, [pc, #504]	; (8028240 <__ieee754_rem_pio2f+0x22c>)
 8028046:	dd18      	ble.n	802807a <__ieee754_rem_pio2f+0x66>
 8028048:	429c      	cmp	r4, r3
 802804a:	ee70 7a47 	vsub.f32	s15, s0, s14
 802804e:	bf09      	itett	eq
 8028050:	ed9f 7a7c 	vldreq	s14, [pc, #496]	; 8028244 <__ieee754_rem_pio2f+0x230>
 8028054:	ed9f 7a7c 	vldrne	s14, [pc, #496]	; 8028248 <__ieee754_rem_pio2f+0x234>
 8028058:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
 802805c:	ed9f 7a7b 	vldreq	s14, [pc, #492]	; 802824c <__ieee754_rem_pio2f+0x238>
 8028060:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8028064:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8028068:	edc0 6a00 	vstr	s13, [r0]
 802806c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8028070:	edc0 7a01 	vstr	s15, [r0, #4]
 8028074:	2001      	movs	r0, #1
 8028076:	b007      	add	sp, #28
 8028078:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802807a:	429c      	cmp	r4, r3
 802807c:	ee70 7a07 	vadd.f32	s15, s0, s14
 8028080:	bf09      	itett	eq
 8028082:	ed9f 7a70 	vldreq	s14, [pc, #448]	; 8028244 <__ieee754_rem_pio2f+0x230>
 8028086:	ed9f 7a70 	vldrne	s14, [pc, #448]	; 8028248 <__ieee754_rem_pio2f+0x234>
 802808a:	ee77 7a87 	vaddeq.f32	s15, s15, s14
 802808e:	ed9f 7a6f 	vldreq	s14, [pc, #444]	; 802824c <__ieee754_rem_pio2f+0x238>
 8028092:	ee77 6a87 	vadd.f32	s13, s15, s14
 8028096:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802809a:	edc0 6a00 	vstr	s13, [r0]
 802809e:	ee77 7a87 	vadd.f32	s15, s15, s14
 80280a2:	edc0 7a01 	vstr	s15, [r0, #4]
 80280a6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80280aa:	e7e4      	b.n	8028076 <__ieee754_rem_pio2f+0x62>
 80280ac:	4b68      	ldr	r3, [pc, #416]	; (8028250 <__ieee754_rem_pio2f+0x23c>)
 80280ae:	429c      	cmp	r4, r3
 80280b0:	dc71      	bgt.n	8028196 <__ieee754_rem_pio2f+0x182>
 80280b2:	f7ff f973 	bl	802739c <fabsf>
 80280b6:	ed9f 7a67 	vldr	s14, [pc, #412]	; 8028254 <__ieee754_rem_pio2f+0x240>
 80280ba:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 80280be:	eee0 7a07 	vfma.f32	s15, s0, s14
 80280c2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80280c6:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 80280ca:	ee17 0a90 	vmov	r0, s15
 80280ce:	eddf 7a5b 	vldr	s15, [pc, #364]	; 802823c <__ieee754_rem_pio2f+0x228>
 80280d2:	eeb1 7a46 	vneg.f32	s14, s12
 80280d6:	eea7 0a27 	vfma.f32	s0, s14, s15
 80280da:	281f      	cmp	r0, #31
 80280dc:	eddf 7a5a 	vldr	s15, [pc, #360]	; 8028248 <__ieee754_rem_pio2f+0x234>
 80280e0:	ee66 7a27 	vmul.f32	s15, s12, s15
 80280e4:	ee70 6a67 	vsub.f32	s13, s0, s15
 80280e8:	ee16 3a90 	vmov	r3, s13
 80280ec:	dc1c      	bgt.n	8028128 <__ieee754_rem_pio2f+0x114>
 80280ee:	1e47      	subs	r7, r0, #1
 80280f0:	4959      	ldr	r1, [pc, #356]	; (8028258 <__ieee754_rem_pio2f+0x244>)
 80280f2:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 80280f6:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
 80280fa:	428a      	cmp	r2, r1
 80280fc:	d014      	beq.n	8028128 <__ieee754_rem_pio2f+0x114>
 80280fe:	602b      	str	r3, [r5, #0]
 8028100:	ed95 7a00 	vldr	s14, [r5]
 8028104:	ee30 0a47 	vsub.f32	s0, s0, s14
 8028108:	2e00      	cmp	r6, #0
 802810a:	ee30 0a67 	vsub.f32	s0, s0, s15
 802810e:	ed85 0a01 	vstr	s0, [r5, #4]
 8028112:	dab0      	bge.n	8028076 <__ieee754_rem_pio2f+0x62>
 8028114:	eeb1 7a47 	vneg.f32	s14, s14
 8028118:	eeb1 0a40 	vneg.f32	s0, s0
 802811c:	ed85 7a00 	vstr	s14, [r5]
 8028120:	ed85 0a01 	vstr	s0, [r5, #4]
 8028124:	4240      	negs	r0, r0
 8028126:	e7a6      	b.n	8028076 <__ieee754_rem_pio2f+0x62>
 8028128:	15e4      	asrs	r4, r4, #23
 802812a:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802812e:	1aa2      	subs	r2, r4, r2
 8028130:	2a08      	cmp	r2, #8
 8028132:	dde4      	ble.n	80280fe <__ieee754_rem_pio2f+0xea>
 8028134:	eddf 7a43 	vldr	s15, [pc, #268]	; 8028244 <__ieee754_rem_pio2f+0x230>
 8028138:	eef0 6a40 	vmov.f32	s13, s0
 802813c:	eee7 6a27 	vfma.f32	s13, s14, s15
 8028140:	ee30 0a66 	vsub.f32	s0, s0, s13
 8028144:	eea7 0a27 	vfma.f32	s0, s14, s15
 8028148:	eddf 7a40 	vldr	s15, [pc, #256]	; 802824c <__ieee754_rem_pio2f+0x238>
 802814c:	ee96 0a27 	vfnms.f32	s0, s12, s15
 8028150:	ee76 5ac0 	vsub.f32	s11, s13, s0
 8028154:	eef0 7a40 	vmov.f32	s15, s0
 8028158:	ee15 3a90 	vmov	r3, s11
 802815c:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8028160:	1aa4      	subs	r4, r4, r2
 8028162:	2c19      	cmp	r4, #25
 8028164:	dc04      	bgt.n	8028170 <__ieee754_rem_pio2f+0x15c>
 8028166:	edc5 5a00 	vstr	s11, [r5]
 802816a:	eeb0 0a66 	vmov.f32	s0, s13
 802816e:	e7c7      	b.n	8028100 <__ieee754_rem_pio2f+0xec>
 8028170:	eddf 5a3a 	vldr	s11, [pc, #232]	; 802825c <__ieee754_rem_pio2f+0x248>
 8028174:	eeb0 0a66 	vmov.f32	s0, s13
 8028178:	eea7 0a25 	vfma.f32	s0, s14, s11
 802817c:	ee76 7ac0 	vsub.f32	s15, s13, s0
 8028180:	eee7 7a25 	vfma.f32	s15, s14, s11
 8028184:	ed9f 7a36 	vldr	s14, [pc, #216]	; 8028260 <__ieee754_rem_pio2f+0x24c>
 8028188:	eed6 7a07 	vfnms.f32	s15, s12, s14
 802818c:	ee30 7a67 	vsub.f32	s14, s0, s15
 8028190:	ed85 7a00 	vstr	s14, [r5]
 8028194:	e7b4      	b.n	8028100 <__ieee754_rem_pio2f+0xec>
 8028196:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802819a:	db06      	blt.n	80281aa <__ieee754_rem_pio2f+0x196>
 802819c:	ee70 7a40 	vsub.f32	s15, s0, s0
 80281a0:	edc0 7a01 	vstr	s15, [r0, #4]
 80281a4:	edc0 7a00 	vstr	s15, [r0]
 80281a8:	e742      	b.n	8028030 <__ieee754_rem_pio2f+0x1c>
 80281aa:	15e2      	asrs	r2, r4, #23
 80281ac:	3a86      	subs	r2, #134	; 0x86
 80281ae:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
 80281b2:	ee07 3a90 	vmov	s15, r3
 80281b6:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 80281ba:	eddf 6a2a 	vldr	s13, [pc, #168]	; 8028264 <__ieee754_rem_pio2f+0x250>
 80281be:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80281c2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80281c6:	ed8d 7a03 	vstr	s14, [sp, #12]
 80281ca:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80281ce:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 80281d2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80281d6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80281da:	ed8d 7a04 	vstr	s14, [sp, #16]
 80281de:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80281e2:	eef5 7a40 	vcmp.f32	s15, #0.0
 80281e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80281ea:	edcd 7a05 	vstr	s15, [sp, #20]
 80281ee:	d11e      	bne.n	802822e <__ieee754_rem_pio2f+0x21a>
 80281f0:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80281f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80281f8:	bf0c      	ite	eq
 80281fa:	2301      	moveq	r3, #1
 80281fc:	2302      	movne	r3, #2
 80281fe:	491a      	ldr	r1, [pc, #104]	; (8028268 <__ieee754_rem_pio2f+0x254>)
 8028200:	9101      	str	r1, [sp, #4]
 8028202:	2102      	movs	r1, #2
 8028204:	9100      	str	r1, [sp, #0]
 8028206:	a803      	add	r0, sp, #12
 8028208:	4629      	mov	r1, r5
 802820a:	f000 f8fb 	bl	8028404 <__kernel_rem_pio2f>
 802820e:	2e00      	cmp	r6, #0
 8028210:	f6bf af31 	bge.w	8028076 <__ieee754_rem_pio2f+0x62>
 8028214:	edd5 7a00 	vldr	s15, [r5]
 8028218:	eef1 7a67 	vneg.f32	s15, s15
 802821c:	edc5 7a00 	vstr	s15, [r5]
 8028220:	edd5 7a01 	vldr	s15, [r5, #4]
 8028224:	eef1 7a67 	vneg.f32	s15, s15
 8028228:	edc5 7a01 	vstr	s15, [r5, #4]
 802822c:	e77a      	b.n	8028124 <__ieee754_rem_pio2f+0x110>
 802822e:	2303      	movs	r3, #3
 8028230:	e7e5      	b.n	80281fe <__ieee754_rem_pio2f+0x1ea>
 8028232:	bf00      	nop
 8028234:	3f490fd8 	.word	0x3f490fd8
 8028238:	4016cbe3 	.word	0x4016cbe3
 802823c:	3fc90f80 	.word	0x3fc90f80
 8028240:	3fc90fd0 	.word	0x3fc90fd0
 8028244:	37354400 	.word	0x37354400
 8028248:	37354443 	.word	0x37354443
 802824c:	2e85a308 	.word	0x2e85a308
 8028250:	43490f80 	.word	0x43490f80
 8028254:	3f22f984 	.word	0x3f22f984
 8028258:	0804b600 	.word	0x0804b600
 802825c:	2e85a300 	.word	0x2e85a300
 8028260:	248d3132 	.word	0x248d3132
 8028264:	43800000 	.word	0x43800000
 8028268:	0804b680 	.word	0x0804b680

0802826c <__ieee754_sinhf>:
 802826c:	b510      	push	{r4, lr}
 802826e:	ee10 3a10 	vmov	r3, s0
 8028272:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 8028276:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802827a:	ed2d 8b02 	vpush	{d8}
 802827e:	eef0 7a40 	vmov.f32	s15, s0
 8028282:	db06      	blt.n	8028292 <__ieee754_sinhf+0x26>
 8028284:	ee70 7a00 	vadd.f32	s15, s0, s0
 8028288:	ecbd 8b02 	vpop	{d8}
 802828c:	eeb0 0a67 	vmov.f32	s0, s15
 8028290:	bd10      	pop	{r4, pc}
 8028292:	2b00      	cmp	r3, #0
 8028294:	4b28      	ldr	r3, [pc, #160]	; (8028338 <__ieee754_sinhf+0xcc>)
 8028296:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
 802829a:	eebe 8a00 	vmov.f32	s16, #224	; 0xbf000000 -0.5
 802829e:	fe28 8a88 	vselge.f32	s16, s17, s16
 80282a2:	429c      	cmp	r4, r3
 80282a4:	dc2a      	bgt.n	80282fc <__ieee754_sinhf+0x90>
 80282a6:	f1b4 5f46 	cmp.w	r4, #830472192	; 0x31800000
 80282aa:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 80282ae:	da08      	bge.n	80282c2 <__ieee754_sinhf+0x56>
 80282b0:	ed9f 7a22 	vldr	s14, [pc, #136]	; 802833c <__ieee754_sinhf+0xd0>
 80282b4:	ee30 7a07 	vadd.f32	s14, s0, s14
 80282b8:	eeb4 7ae8 	vcmpe.f32	s14, s17
 80282bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80282c0:	dce2      	bgt.n	8028288 <__ieee754_sinhf+0x1c>
 80282c2:	eeb0 0a67 	vmov.f32	s0, s15
 80282c6:	f7ff f869 	bl	802739c <fabsf>
 80282ca:	f000 fca9 	bl	8028c20 <expm1f>
 80282ce:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 80282d2:	bfbb      	ittet	lt
 80282d4:	ee20 7a00 	vmullt.f32	s14, s0, s0
 80282d8:	ee70 8a28 	vaddlt.f32	s17, s0, s17
 80282dc:	ee70 8a28 	vaddge.f32	s17, s0, s17
 80282e0:	eec7 7a28 	vdivlt.f32	s15, s14, s17
 80282e4:	bfad      	iteet	ge
 80282e6:	eec0 7a28 	vdivge.f32	s15, s0, s17
 80282ea:	eeb0 7a00 	vmovlt.f32	s14, #0	; 0x40000000  2.0
 80282ee:	eed0 7a07 	vfnmslt.f32	s15, s0, s14
 80282f2:	ee77 7a80 	vaddge.f32	s15, s15, s0
 80282f6:	ee67 7a88 	vmul.f32	s15, s15, s16
 80282fa:	e7c5      	b.n	8028288 <__ieee754_sinhf+0x1c>
 80282fc:	4b10      	ldr	r3, [pc, #64]	; (8028340 <__ieee754_sinhf+0xd4>)
 80282fe:	429c      	cmp	r4, r3
 8028300:	dc06      	bgt.n	8028310 <__ieee754_sinhf+0xa4>
 8028302:	f7ff f84b 	bl	802739c <fabsf>
 8028306:	f7fe ffcb 	bl	80272a0 <expf>
 802830a:	ee60 7a08 	vmul.f32	s15, s0, s16
 802830e:	e7bb      	b.n	8028288 <__ieee754_sinhf+0x1c>
 8028310:	4b0c      	ldr	r3, [pc, #48]	; (8028344 <__ieee754_sinhf+0xd8>)
 8028312:	429c      	cmp	r4, r3
 8028314:	dc0a      	bgt.n	802832c <__ieee754_sinhf+0xc0>
 8028316:	f7ff f841 	bl	802739c <fabsf>
 802831a:	ee20 0a28 	vmul.f32	s0, s0, s17
 802831e:	f7fe ffbf 	bl	80272a0 <expf>
 8028322:	ee68 7a00 	vmul.f32	s15, s16, s0
 8028326:	ee67 7a80 	vmul.f32	s15, s15, s0
 802832a:	e7ad      	b.n	8028288 <__ieee754_sinhf+0x1c>
 802832c:	ed9f 7a03 	vldr	s14, [pc, #12]	; 802833c <__ieee754_sinhf+0xd0>
 8028330:	ee60 7a07 	vmul.f32	s15, s0, s14
 8028334:	e7a8      	b.n	8028288 <__ieee754_sinhf+0x1c>
 8028336:	bf00      	nop
 8028338:	41afffff 	.word	0x41afffff
 802833c:	7cf0bdc2 	.word	0x7cf0bdc2
 8028340:	42b17217 	.word	0x42b17217
 8028344:	42b2d4fc 	.word	0x42b2d4fc

08028348 <__kernel_cosf>:
 8028348:	ee10 3a10 	vmov	r3, s0
 802834c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8028350:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8028354:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8028358:	da05      	bge.n	8028366 <__kernel_cosf+0x1e>
 802835a:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802835e:	ee17 2a90 	vmov	r2, s15
 8028362:	2a00      	cmp	r2, #0
 8028364:	d03b      	beq.n	80283de <__kernel_cosf+0x96>
 8028366:	ee20 6a00 	vmul.f32	s12, s0, s0
 802836a:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 802836e:	eddf 5a1d 	vldr	s11, [pc, #116]	; 80283e4 <__kernel_cosf+0x9c>
 8028372:	4a1d      	ldr	r2, [pc, #116]	; (80283e8 <__kernel_cosf+0xa0>)
 8028374:	ee66 7a07 	vmul.f32	s15, s12, s14
 8028378:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 80283ec <__kernel_cosf+0xa4>
 802837c:	eea6 7a25 	vfma.f32	s14, s12, s11
 8028380:	4293      	cmp	r3, r2
 8028382:	eddf 5a1b 	vldr	s11, [pc, #108]	; 80283f0 <__kernel_cosf+0xa8>
 8028386:	eee7 5a06 	vfma.f32	s11, s14, s12
 802838a:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 80283f4 <__kernel_cosf+0xac>
 802838e:	eea5 7a86 	vfma.f32	s14, s11, s12
 8028392:	eddf 5a19 	vldr	s11, [pc, #100]	; 80283f8 <__kernel_cosf+0xb0>
 8028396:	eee7 5a06 	vfma.f32	s11, s14, s12
 802839a:	ed9f 7a18 	vldr	s14, [pc, #96]	; 80283fc <__kernel_cosf+0xb4>
 802839e:	eea5 7a86 	vfma.f32	s14, s11, s12
 80283a2:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 80283a6:	ee27 7a06 	vmul.f32	s14, s14, s12
 80283aa:	eee6 0a07 	vfma.f32	s1, s12, s14
 80283ae:	dc04      	bgt.n	80283ba <__kernel_cosf+0x72>
 80283b0:	ee77 0ae0 	vsub.f32	s1, s15, s1
 80283b4:	ee36 0ae0 	vsub.f32	s0, s13, s1
 80283b8:	4770      	bx	lr
 80283ba:	4a11      	ldr	r2, [pc, #68]	; (8028400 <__kernel_cosf+0xb8>)
 80283bc:	4293      	cmp	r3, r2
 80283be:	bfda      	itte	le
 80283c0:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
 80283c4:	ee07 3a10 	vmovle	s14, r3
 80283c8:	eeb5 7a02 	vmovgt.f32	s14, #82	; 0x3e900000  0.2812500
 80283cc:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80283d0:	ee36 0ac7 	vsub.f32	s0, s13, s14
 80283d4:	ee77 7ae0 	vsub.f32	s15, s15, s1
 80283d8:	ee30 0a67 	vsub.f32	s0, s0, s15
 80283dc:	4770      	bx	lr
 80283de:	eeb0 0a66 	vmov.f32	s0, s13
 80283e2:	4770      	bx	lr
 80283e4:	ad47d74e 	.word	0xad47d74e
 80283e8:	3e999999 	.word	0x3e999999
 80283ec:	310f74f6 	.word	0x310f74f6
 80283f0:	b493f27c 	.word	0xb493f27c
 80283f4:	37d00d01 	.word	0x37d00d01
 80283f8:	bab60b61 	.word	0xbab60b61
 80283fc:	3d2aaaab 	.word	0x3d2aaaab
 8028400:	3f480000 	.word	0x3f480000

08028404 <__kernel_rem_pio2f>:
 8028404:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028408:	ed2d 8b04 	vpush	{d8-d9}
 802840c:	b0d7      	sub	sp, #348	; 0x15c
 802840e:	469b      	mov	fp, r3
 8028410:	460e      	mov	r6, r1
 8028412:	4bbe      	ldr	r3, [pc, #760]	; (802870c <__kernel_rem_pio2f+0x308>)
 8028414:	9964      	ldr	r1, [sp, #400]	; 0x190
 8028416:	9002      	str	r0, [sp, #8]
 8028418:	f853 9021 	ldr.w	r9, [r3, r1, lsl #2]
 802841c:	9865      	ldr	r0, [sp, #404]	; 0x194
 802841e:	ed9f 7abf 	vldr	s14, [pc, #764]	; 802871c <__kernel_rem_pio2f+0x318>
 8028422:	1ed1      	subs	r1, r2, #3
 8028424:	2308      	movs	r3, #8
 8028426:	fb91 f1f3 	sdiv	r1, r1, r3
 802842a:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
 802842e:	f10b 3aff 	add.w	sl, fp, #4294967295	; 0xffffffff
 8028432:	1c4c      	adds	r4, r1, #1
 8028434:	eba2 04c4 	sub.w	r4, r2, r4, lsl #3
 8028438:	eba1 050a 	sub.w	r5, r1, sl
 802843c:	aa1a      	add	r2, sp, #104	; 0x68
 802843e:	eb09 070a 	add.w	r7, r9, sl
 8028442:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
 8028446:	4696      	mov	lr, r2
 8028448:	2300      	movs	r3, #0
 802844a:	42bb      	cmp	r3, r7
 802844c:	dd0f      	ble.n	802846e <__kernel_rem_pio2f+0x6a>
 802844e:	af42      	add	r7, sp, #264	; 0x108
 8028450:	2200      	movs	r2, #0
 8028452:	454a      	cmp	r2, r9
 8028454:	dc27      	bgt.n	80284a6 <__kernel_rem_pio2f+0xa2>
 8028456:	f10d 0c68 	add.w	ip, sp, #104	; 0x68
 802845a:	eb0b 0302 	add.w	r3, fp, r2
 802845e:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
 8028462:	9d02      	ldr	r5, [sp, #8]
 8028464:	eddf 7aad 	vldr	s15, [pc, #692]	; 802871c <__kernel_rem_pio2f+0x318>
 8028468:	f04f 0c00 	mov.w	ip, #0
 802846c:	e015      	b.n	802849a <__kernel_rem_pio2f+0x96>
 802846e:	42dd      	cmn	r5, r3
 8028470:	bf5d      	ittte	pl
 8028472:	f85c 2023 	ldrpl.w	r2, [ip, r3, lsl #2]
 8028476:	ee07 2a90 	vmovpl	s15, r2
 802847a:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 802847e:	eef0 7a47 	vmovmi.f32	s15, s14
 8028482:	ecee 7a01 	vstmia	lr!, {s15}
 8028486:	3301      	adds	r3, #1
 8028488:	e7df      	b.n	802844a <__kernel_rem_pio2f+0x46>
 802848a:	ecf5 6a01 	vldmia	r5!, {s13}
 802848e:	ed33 7a01 	vldmdb	r3!, {s14}
 8028492:	eee6 7a87 	vfma.f32	s15, s13, s14
 8028496:	f10c 0c01 	add.w	ip, ip, #1
 802849a:	45d4      	cmp	ip, sl
 802849c:	ddf5      	ble.n	802848a <__kernel_rem_pio2f+0x86>
 802849e:	ece7 7a01 	vstmia	r7!, {s15}
 80284a2:	3201      	adds	r2, #1
 80284a4:	e7d5      	b.n	8028452 <__kernel_rem_pio2f+0x4e>
 80284a6:	ab06      	add	r3, sp, #24
 80284a8:	eb03 0389 	add.w	r3, r3, r9, lsl #2
 80284ac:	9304      	str	r3, [sp, #16]
 80284ae:	eddf 8a9a 	vldr	s17, [pc, #616]	; 8028718 <__kernel_rem_pio2f+0x314>
 80284b2:	ed9f 9a98 	vldr	s18, [pc, #608]	; 8028714 <__kernel_rem_pio2f+0x310>
 80284b6:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 80284ba:	9303      	str	r3, [sp, #12]
 80284bc:	464d      	mov	r5, r9
 80284be:	ab56      	add	r3, sp, #344	; 0x158
 80284c0:	f105 4780 	add.w	r7, r5, #1073741824	; 0x40000000
 80284c4:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 80284c8:	3f01      	subs	r7, #1
 80284ca:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
 80284ce:	00bf      	lsls	r7, r7, #2
 80284d0:	ab56      	add	r3, sp, #344	; 0x158
 80284d2:	19da      	adds	r2, r3, r7
 80284d4:	3a4c      	subs	r2, #76	; 0x4c
 80284d6:	2300      	movs	r3, #0
 80284d8:	1ae9      	subs	r1, r5, r3
 80284da:	2900      	cmp	r1, #0
 80284dc:	dc4c      	bgt.n	8028578 <__kernel_rem_pio2f+0x174>
 80284de:	4620      	mov	r0, r4
 80284e0:	f000 fd14 	bl	8028f0c <scalbnf>
 80284e4:	eeb0 8a40 	vmov.f32	s16, s0
 80284e8:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 80284ec:	ee28 0a00 	vmul.f32	s0, s16, s0
 80284f0:	f000 fcca 	bl	8028e88 <floorf>
 80284f4:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 80284f8:	eea0 8a67 	vfms.f32	s16, s0, s15
 80284fc:	2c00      	cmp	r4, #0
 80284fe:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 8028502:	edcd 7a01 	vstr	s15, [sp, #4]
 8028506:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802850a:	ee38 8a67 	vsub.f32	s16, s16, s15
 802850e:	dd48      	ble.n	80285a2 <__kernel_rem_pio2f+0x19e>
 8028510:	1e69      	subs	r1, r5, #1
 8028512:	ab06      	add	r3, sp, #24
 8028514:	f1c4 0008 	rsb	r0, r4, #8
 8028518:	f853 c021 	ldr.w	ip, [r3, r1, lsl #2]
 802851c:	9a01      	ldr	r2, [sp, #4]
 802851e:	fa4c f300 	asr.w	r3, ip, r0
 8028522:	441a      	add	r2, r3
 8028524:	4083      	lsls	r3, r0
 8028526:	9201      	str	r2, [sp, #4]
 8028528:	ebac 0203 	sub.w	r2, ip, r3
 802852c:	ab06      	add	r3, sp, #24
 802852e:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
 8028532:	f1c4 0307 	rsb	r3, r4, #7
 8028536:	fa42 f803 	asr.w	r8, r2, r3
 802853a:	f1b8 0f00 	cmp.w	r8, #0
 802853e:	dd41      	ble.n	80285c4 <__kernel_rem_pio2f+0x1c0>
 8028540:	9b01      	ldr	r3, [sp, #4]
 8028542:	2000      	movs	r0, #0
 8028544:	3301      	adds	r3, #1
 8028546:	9301      	str	r3, [sp, #4]
 8028548:	4601      	mov	r1, r0
 802854a:	4285      	cmp	r5, r0
 802854c:	dc6d      	bgt.n	802862a <__kernel_rem_pio2f+0x226>
 802854e:	2c00      	cmp	r4, #0
 8028550:	dd04      	ble.n	802855c <__kernel_rem_pio2f+0x158>
 8028552:	2c01      	cmp	r4, #1
 8028554:	d07e      	beq.n	8028654 <__kernel_rem_pio2f+0x250>
 8028556:	2c02      	cmp	r4, #2
 8028558:	f000 8086 	beq.w	8028668 <__kernel_rem_pio2f+0x264>
 802855c:	f1b8 0f02 	cmp.w	r8, #2
 8028560:	d130      	bne.n	80285c4 <__kernel_rem_pio2f+0x1c0>
 8028562:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8028566:	ee30 8a48 	vsub.f32	s16, s0, s16
 802856a:	b359      	cbz	r1, 80285c4 <__kernel_rem_pio2f+0x1c0>
 802856c:	4620      	mov	r0, r4
 802856e:	f000 fccd 	bl	8028f0c <scalbnf>
 8028572:	ee38 8a40 	vsub.f32	s16, s16, s0
 8028576:	e025      	b.n	80285c4 <__kernel_rem_pio2f+0x1c0>
 8028578:	ee60 7a28 	vmul.f32	s15, s0, s17
 802857c:	a806      	add	r0, sp, #24
 802857e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8028582:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028586:	eea7 0ac9 	vfms.f32	s0, s15, s18
 802858a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802858e:	ee10 1a10 	vmov	r1, s0
 8028592:	ed32 0a01 	vldmdb	r2!, {s0}
 8028596:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
 802859a:	ee37 0a80 	vadd.f32	s0, s15, s0
 802859e:	3301      	adds	r3, #1
 80285a0:	e79a      	b.n	80284d8 <__kernel_rem_pio2f+0xd4>
 80285a2:	d106      	bne.n	80285b2 <__kernel_rem_pio2f+0x1ae>
 80285a4:	1e6b      	subs	r3, r5, #1
 80285a6:	aa06      	add	r2, sp, #24
 80285a8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80285ac:	ea4f 2822 	mov.w	r8, r2, asr #8
 80285b0:	e7c3      	b.n	802853a <__kernel_rem_pio2f+0x136>
 80285b2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 80285b6:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80285ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80285be:	da31      	bge.n	8028624 <__kernel_rem_pio2f+0x220>
 80285c0:	f04f 0800 	mov.w	r8, #0
 80285c4:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80285c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80285cc:	f040 80a8 	bne.w	8028720 <__kernel_rem_pio2f+0x31c>
 80285d0:	1e6b      	subs	r3, r5, #1
 80285d2:	4618      	mov	r0, r3
 80285d4:	2200      	movs	r2, #0
 80285d6:	4548      	cmp	r0, r9
 80285d8:	da4d      	bge.n	8028676 <__kernel_rem_pio2f+0x272>
 80285da:	2a00      	cmp	r2, #0
 80285dc:	f000 8087 	beq.w	80286ee <__kernel_rem_pio2f+0x2ea>
 80285e0:	aa06      	add	r2, sp, #24
 80285e2:	3c08      	subs	r4, #8
 80285e4:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 80285e8:	2900      	cmp	r1, #0
 80285ea:	f000 808d 	beq.w	8028708 <__kernel_rem_pio2f+0x304>
 80285ee:	4620      	mov	r0, r4
 80285f0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80285f4:	9302      	str	r3, [sp, #8]
 80285f6:	f000 fc89 	bl	8028f0c <scalbnf>
 80285fa:	9b02      	ldr	r3, [sp, #8]
 80285fc:	ed9f 7a46 	vldr	s14, [pc, #280]	; 8028718 <__kernel_rem_pio2f+0x314>
 8028600:	0099      	lsls	r1, r3, #2
 8028602:	aa42      	add	r2, sp, #264	; 0x108
 8028604:	1850      	adds	r0, r2, r1
 8028606:	1d05      	adds	r5, r0, #4
 8028608:	461c      	mov	r4, r3
 802860a:	2c00      	cmp	r4, #0
 802860c:	f280 80b8 	bge.w	8028780 <__kernel_rem_pio2f+0x37c>
 8028610:	2500      	movs	r5, #0
 8028612:	1b5c      	subs	r4, r3, r5
 8028614:	2c00      	cmp	r4, #0
 8028616:	f2c0 80d8 	blt.w	80287ca <__kernel_rem_pio2f+0x3c6>
 802861a:	4f3d      	ldr	r7, [pc, #244]	; (8028710 <__kernel_rem_pio2f+0x30c>)
 802861c:	eddf 7a3f 	vldr	s15, [pc, #252]	; 802871c <__kernel_rem_pio2f+0x318>
 8028620:	2400      	movs	r4, #0
 8028622:	e0c6      	b.n	80287b2 <__kernel_rem_pio2f+0x3ae>
 8028624:	f04f 0802 	mov.w	r8, #2
 8028628:	e78a      	b.n	8028540 <__kernel_rem_pio2f+0x13c>
 802862a:	ab06      	add	r3, sp, #24
 802862c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8028630:	b949      	cbnz	r1, 8028646 <__kernel_rem_pio2f+0x242>
 8028632:	b12b      	cbz	r3, 8028640 <__kernel_rem_pio2f+0x23c>
 8028634:	aa06      	add	r2, sp, #24
 8028636:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
 802863a:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 802863e:	2301      	movs	r3, #1
 8028640:	3001      	adds	r0, #1
 8028642:	4619      	mov	r1, r3
 8028644:	e781      	b.n	802854a <__kernel_rem_pio2f+0x146>
 8028646:	aa06      	add	r2, sp, #24
 8028648:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 802864c:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 8028650:	460b      	mov	r3, r1
 8028652:	e7f5      	b.n	8028640 <__kernel_rem_pio2f+0x23c>
 8028654:	1e68      	subs	r0, r5, #1
 8028656:	ab06      	add	r3, sp, #24
 8028658:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 802865c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8028660:	aa06      	add	r2, sp, #24
 8028662:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 8028666:	e779      	b.n	802855c <__kernel_rem_pio2f+0x158>
 8028668:	1e68      	subs	r0, r5, #1
 802866a:	ab06      	add	r3, sp, #24
 802866c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8028670:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8028674:	e7f4      	b.n	8028660 <__kernel_rem_pio2f+0x25c>
 8028676:	a906      	add	r1, sp, #24
 8028678:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 802867c:	3801      	subs	r0, #1
 802867e:	430a      	orrs	r2, r1
 8028680:	e7a9      	b.n	80285d6 <__kernel_rem_pio2f+0x1d2>
 8028682:	f10c 0c01 	add.w	ip, ip, #1
 8028686:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 802868a:	2a00      	cmp	r2, #0
 802868c:	d0f9      	beq.n	8028682 <__kernel_rem_pio2f+0x27e>
 802868e:	eb0b 0305 	add.w	r3, fp, r5
 8028692:	aa1a      	add	r2, sp, #104	; 0x68
 8028694:	009b      	lsls	r3, r3, #2
 8028696:	1898      	adds	r0, r3, r2
 8028698:	3004      	adds	r0, #4
 802869a:	1c69      	adds	r1, r5, #1
 802869c:	3704      	adds	r7, #4
 802869e:	2200      	movs	r2, #0
 80286a0:	4465      	add	r5, ip
 80286a2:	9005      	str	r0, [sp, #20]
 80286a4:	428d      	cmp	r5, r1
 80286a6:	f6ff af0a 	blt.w	80284be <__kernel_rem_pio2f+0xba>
 80286aa:	a81a      	add	r0, sp, #104	; 0x68
 80286ac:	eb02 0c03 	add.w	ip, r2, r3
 80286b0:	4484      	add	ip, r0
 80286b2:	9803      	ldr	r0, [sp, #12]
 80286b4:	f8dd e008 	ldr.w	lr, [sp, #8]
 80286b8:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
 80286bc:	9001      	str	r0, [sp, #4]
 80286be:	ee07 0a90 	vmov	s15, r0
 80286c2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80286c6:	9805      	ldr	r0, [sp, #20]
 80286c8:	edcc 7a00 	vstr	s15, [ip]
 80286cc:	eddf 7a13 	vldr	s15, [pc, #76]	; 802871c <__kernel_rem_pio2f+0x318>
 80286d0:	eb00 0802 	add.w	r8, r0, r2
 80286d4:	f04f 0c00 	mov.w	ip, #0
 80286d8:	45d4      	cmp	ip, sl
 80286da:	dd0c      	ble.n	80286f6 <__kernel_rem_pio2f+0x2f2>
 80286dc:	eb02 0c07 	add.w	ip, r2, r7
 80286e0:	a842      	add	r0, sp, #264	; 0x108
 80286e2:	4484      	add	ip, r0
 80286e4:	edcc 7a01 	vstr	s15, [ip, #4]
 80286e8:	3101      	adds	r1, #1
 80286ea:	3204      	adds	r2, #4
 80286ec:	e7da      	b.n	80286a4 <__kernel_rem_pio2f+0x2a0>
 80286ee:	9b04      	ldr	r3, [sp, #16]
 80286f0:	f04f 0c01 	mov.w	ip, #1
 80286f4:	e7c7      	b.n	8028686 <__kernel_rem_pio2f+0x282>
 80286f6:	ecfe 6a01 	vldmia	lr!, {s13}
 80286fa:	ed38 7a01 	vldmdb	r8!, {s14}
 80286fe:	f10c 0c01 	add.w	ip, ip, #1
 8028702:	eee6 7a87 	vfma.f32	s15, s13, s14
 8028706:	e7e7      	b.n	80286d8 <__kernel_rem_pio2f+0x2d4>
 8028708:	3b01      	subs	r3, #1
 802870a:	e769      	b.n	80285e0 <__kernel_rem_pio2f+0x1dc>
 802870c:	0804b9c4 	.word	0x0804b9c4
 8028710:	0804b998 	.word	0x0804b998
 8028714:	43800000 	.word	0x43800000
 8028718:	3b800000 	.word	0x3b800000
 802871c:	00000000 	.word	0x00000000
 8028720:	4260      	negs	r0, r4
 8028722:	eeb0 0a48 	vmov.f32	s0, s16
 8028726:	f000 fbf1 	bl	8028f0c <scalbnf>
 802872a:	ed1f 7a06 	vldr	s14, [pc, #-24]	; 8028714 <__kernel_rem_pio2f+0x310>
 802872e:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8028732:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028736:	db1a      	blt.n	802876e <__kernel_rem_pio2f+0x36a>
 8028738:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 8028718 <__kernel_rem_pio2f+0x314>
 802873c:	ee60 7a27 	vmul.f32	s15, s0, s15
 8028740:	aa06      	add	r2, sp, #24
 8028742:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8028746:	a906      	add	r1, sp, #24
 8028748:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802874c:	3408      	adds	r4, #8
 802874e:	eea7 0ac7 	vfms.f32	s0, s15, s14
 8028752:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8028756:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802875a:	ee10 3a10 	vmov	r3, s0
 802875e:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
 8028762:	1c6b      	adds	r3, r5, #1
 8028764:	ee17 2a90 	vmov	r2, s15
 8028768:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 802876c:	e73f      	b.n	80285ee <__kernel_rem_pio2f+0x1ea>
 802876e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8028772:	aa06      	add	r2, sp, #24
 8028774:	ee10 3a10 	vmov	r3, s0
 8028778:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
 802877c:	462b      	mov	r3, r5
 802877e:	e736      	b.n	80285ee <__kernel_rem_pio2f+0x1ea>
 8028780:	aa06      	add	r2, sp, #24
 8028782:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
 8028786:	9202      	str	r2, [sp, #8]
 8028788:	ee07 2a90 	vmov	s15, r2
 802878c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028790:	3c01      	subs	r4, #1
 8028792:	ee67 7a80 	vmul.f32	s15, s15, s0
 8028796:	ee20 0a07 	vmul.f32	s0, s0, s14
 802879a:	ed65 7a01 	vstmdb	r5!, {s15}
 802879e:	e734      	b.n	802860a <__kernel_rem_pio2f+0x206>
 80287a0:	eb00 0c84 	add.w	ip, r0, r4, lsl #2
 80287a4:	ecf7 6a01 	vldmia	r7!, {s13}
 80287a8:	ed9c 7a00 	vldr	s14, [ip]
 80287ac:	eee6 7a87 	vfma.f32	s15, s13, s14
 80287b0:	3401      	adds	r4, #1
 80287b2:	454c      	cmp	r4, r9
 80287b4:	dc01      	bgt.n	80287ba <__kernel_rem_pio2f+0x3b6>
 80287b6:	42a5      	cmp	r5, r4
 80287b8:	daf2      	bge.n	80287a0 <__kernel_rem_pio2f+0x39c>
 80287ba:	aa56      	add	r2, sp, #344	; 0x158
 80287bc:	eb02 0485 	add.w	r4, r2, r5, lsl #2
 80287c0:	ed44 7a28 	vstr	s15, [r4, #-160]	; 0xffffff60
 80287c4:	3501      	adds	r5, #1
 80287c6:	3804      	subs	r0, #4
 80287c8:	e723      	b.n	8028612 <__kernel_rem_pio2f+0x20e>
 80287ca:	9a64      	ldr	r2, [sp, #400]	; 0x190
 80287cc:	2a03      	cmp	r2, #3
 80287ce:	d84d      	bhi.n	802886c <__kernel_rem_pio2f+0x468>
 80287d0:	e8df f002 	tbb	[pc, r2]
 80287d4:	021f1f3e 	.word	0x021f1f3e
 80287d8:	aa56      	add	r2, sp, #344	; 0x158
 80287da:	4411      	add	r1, r2
 80287dc:	399c      	subs	r1, #156	; 0x9c
 80287de:	4608      	mov	r0, r1
 80287e0:	461c      	mov	r4, r3
 80287e2:	2c00      	cmp	r4, #0
 80287e4:	dc5f      	bgt.n	80288a6 <__kernel_rem_pio2f+0x4a2>
 80287e6:	4608      	mov	r0, r1
 80287e8:	461c      	mov	r4, r3
 80287ea:	2c01      	cmp	r4, #1
 80287ec:	dc6b      	bgt.n	80288c6 <__kernel_rem_pio2f+0x4c2>
 80287ee:	ed5f 7a35 	vldr	s15, [pc, #-212]	; 802871c <__kernel_rem_pio2f+0x318>
 80287f2:	2b01      	cmp	r3, #1
 80287f4:	dc77      	bgt.n	80288e6 <__kernel_rem_pio2f+0x4e2>
 80287f6:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 80287fa:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
 80287fe:	f1b8 0f00 	cmp.w	r8, #0
 8028802:	d176      	bne.n	80288f2 <__kernel_rem_pio2f+0x4ee>
 8028804:	edc6 6a00 	vstr	s13, [r6]
 8028808:	ed86 7a01 	vstr	s14, [r6, #4]
 802880c:	edc6 7a02 	vstr	s15, [r6, #8]
 8028810:	e02c      	b.n	802886c <__kernel_rem_pio2f+0x468>
 8028812:	aa56      	add	r2, sp, #344	; 0x158
 8028814:	4411      	add	r1, r2
 8028816:	ed1f 7a3f 	vldr	s14, [pc, #-252]	; 802871c <__kernel_rem_pio2f+0x318>
 802881a:	399c      	subs	r1, #156	; 0x9c
 802881c:	4618      	mov	r0, r3
 802881e:	2800      	cmp	r0, #0
 8028820:	da32      	bge.n	8028888 <__kernel_rem_pio2f+0x484>
 8028822:	f1b8 0f00 	cmp.w	r8, #0
 8028826:	d035      	beq.n	8028894 <__kernel_rem_pio2f+0x490>
 8028828:	eef1 7a47 	vneg.f32	s15, s14
 802882c:	edc6 7a00 	vstr	s15, [r6]
 8028830:	eddd 7a2e 	vldr	s15, [sp, #184]	; 0xb8
 8028834:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8028838:	a82f      	add	r0, sp, #188	; 0xbc
 802883a:	2101      	movs	r1, #1
 802883c:	428b      	cmp	r3, r1
 802883e:	da2c      	bge.n	802889a <__kernel_rem_pio2f+0x496>
 8028840:	f1b8 0f00 	cmp.w	r8, #0
 8028844:	d001      	beq.n	802884a <__kernel_rem_pio2f+0x446>
 8028846:	eef1 7a67 	vneg.f32	s15, s15
 802884a:	edc6 7a01 	vstr	s15, [r6, #4]
 802884e:	e00d      	b.n	802886c <__kernel_rem_pio2f+0x468>
 8028850:	aa56      	add	r2, sp, #344	; 0x158
 8028852:	4411      	add	r1, r2
 8028854:	ed5f 7a4f 	vldr	s15, [pc, #-316]	; 802871c <__kernel_rem_pio2f+0x318>
 8028858:	399c      	subs	r1, #156	; 0x9c
 802885a:	2b00      	cmp	r3, #0
 802885c:	da0e      	bge.n	802887c <__kernel_rem_pio2f+0x478>
 802885e:	f1b8 0f00 	cmp.w	r8, #0
 8028862:	d001      	beq.n	8028868 <__kernel_rem_pio2f+0x464>
 8028864:	eef1 7a67 	vneg.f32	s15, s15
 8028868:	edc6 7a00 	vstr	s15, [r6]
 802886c:	9b01      	ldr	r3, [sp, #4]
 802886e:	f003 0007 	and.w	r0, r3, #7
 8028872:	b057      	add	sp, #348	; 0x15c
 8028874:	ecbd 8b04 	vpop	{d8-d9}
 8028878:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802887c:	ed31 7a01 	vldmdb	r1!, {s14}
 8028880:	3b01      	subs	r3, #1
 8028882:	ee77 7a87 	vadd.f32	s15, s15, s14
 8028886:	e7e8      	b.n	802885a <__kernel_rem_pio2f+0x456>
 8028888:	ed71 7a01 	vldmdb	r1!, {s15}
 802888c:	3801      	subs	r0, #1
 802888e:	ee37 7a27 	vadd.f32	s14, s14, s15
 8028892:	e7c4      	b.n	802881e <__kernel_rem_pio2f+0x41a>
 8028894:	eef0 7a47 	vmov.f32	s15, s14
 8028898:	e7c8      	b.n	802882c <__kernel_rem_pio2f+0x428>
 802889a:	ecb0 7a01 	vldmia	r0!, {s14}
 802889e:	3101      	adds	r1, #1
 80288a0:	ee77 7a87 	vadd.f32	s15, s15, s14
 80288a4:	e7ca      	b.n	802883c <__kernel_rem_pio2f+0x438>
 80288a6:	ed50 7a02 	vldr	s15, [r0, #-8]
 80288aa:	ed70 6a01 	vldmdb	r0!, {s13}
 80288ae:	ee37 7aa6 	vadd.f32	s14, s15, s13
 80288b2:	3c01      	subs	r4, #1
 80288b4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80288b8:	ed00 7a01 	vstr	s14, [r0, #-4]
 80288bc:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80288c0:	edc0 7a00 	vstr	s15, [r0]
 80288c4:	e78d      	b.n	80287e2 <__kernel_rem_pio2f+0x3de>
 80288c6:	ed50 7a02 	vldr	s15, [r0, #-8]
 80288ca:	ed70 6a01 	vldmdb	r0!, {s13}
 80288ce:	ee37 7aa6 	vadd.f32	s14, s15, s13
 80288d2:	3c01      	subs	r4, #1
 80288d4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80288d8:	ed00 7a01 	vstr	s14, [r0, #-4]
 80288dc:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80288e0:	edc0 7a00 	vstr	s15, [r0]
 80288e4:	e781      	b.n	80287ea <__kernel_rem_pio2f+0x3e6>
 80288e6:	ed31 7a01 	vldmdb	r1!, {s14}
 80288ea:	3b01      	subs	r3, #1
 80288ec:	ee77 7a87 	vadd.f32	s15, s15, s14
 80288f0:	e77f      	b.n	80287f2 <__kernel_rem_pio2f+0x3ee>
 80288f2:	eef1 6a66 	vneg.f32	s13, s13
 80288f6:	eeb1 7a47 	vneg.f32	s14, s14
 80288fa:	edc6 6a00 	vstr	s13, [r6]
 80288fe:	ed86 7a01 	vstr	s14, [r6, #4]
 8028902:	eef1 7a67 	vneg.f32	s15, s15
 8028906:	e781      	b.n	802880c <__kernel_rem_pio2f+0x408>

08028908 <__kernel_sinf>:
 8028908:	ee10 3a10 	vmov	r3, s0
 802890c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8028910:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8028914:	da04      	bge.n	8028920 <__kernel_sinf+0x18>
 8028916:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802891a:	ee17 3a90 	vmov	r3, s15
 802891e:	b35b      	cbz	r3, 8028978 <__kernel_sinf+0x70>
 8028920:	ee20 7a00 	vmul.f32	s14, s0, s0
 8028924:	eddf 7a15 	vldr	s15, [pc, #84]	; 802897c <__kernel_sinf+0x74>
 8028928:	ed9f 6a15 	vldr	s12, [pc, #84]	; 8028980 <__kernel_sinf+0x78>
 802892c:	eea7 6a27 	vfma.f32	s12, s14, s15
 8028930:	eddf 7a14 	vldr	s15, [pc, #80]	; 8028984 <__kernel_sinf+0x7c>
 8028934:	eee6 7a07 	vfma.f32	s15, s12, s14
 8028938:	ed9f 6a13 	vldr	s12, [pc, #76]	; 8028988 <__kernel_sinf+0x80>
 802893c:	eea7 6a87 	vfma.f32	s12, s15, s14
 8028940:	eddf 7a12 	vldr	s15, [pc, #72]	; 802898c <__kernel_sinf+0x84>
 8028944:	ee60 6a07 	vmul.f32	s13, s0, s14
 8028948:	eee6 7a07 	vfma.f32	s15, s12, s14
 802894c:	b930      	cbnz	r0, 802895c <__kernel_sinf+0x54>
 802894e:	ed9f 6a10 	vldr	s12, [pc, #64]	; 8028990 <__kernel_sinf+0x88>
 8028952:	eea7 6a27 	vfma.f32	s12, s14, s15
 8028956:	eea6 0a26 	vfma.f32	s0, s12, s13
 802895a:	4770      	bx	lr
 802895c:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 8028960:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 8028964:	eee0 7a86 	vfma.f32	s15, s1, s12
 8028968:	eed7 0a87 	vfnms.f32	s1, s15, s14
 802896c:	eddf 7a09 	vldr	s15, [pc, #36]	; 8028994 <__kernel_sinf+0x8c>
 8028970:	eee6 0aa7 	vfma.f32	s1, s13, s15
 8028974:	ee30 0a60 	vsub.f32	s0, s0, s1
 8028978:	4770      	bx	lr
 802897a:	bf00      	nop
 802897c:	2f2ec9d3 	.word	0x2f2ec9d3
 8028980:	b2d72f34 	.word	0xb2d72f34
 8028984:	3638ef1b 	.word	0x3638ef1b
 8028988:	b9500d01 	.word	0xb9500d01
 802898c:	3c088889 	.word	0x3c088889
 8028990:	be2aaaab 	.word	0xbe2aaaab
 8028994:	3e2aaaab 	.word	0x3e2aaaab

08028998 <__kernel_tanf>:
 8028998:	b508      	push	{r3, lr}
 802899a:	ee10 3a10 	vmov	r3, s0
 802899e:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 80289a2:	f1b2 5f46 	cmp.w	r2, #830472192	; 0x31800000
 80289a6:	eef0 7a40 	vmov.f32	s15, s0
 80289aa:	da17      	bge.n	80289dc <__kernel_tanf+0x44>
 80289ac:	eebd 7ac0 	vcvt.s32.f32	s14, s0
 80289b0:	ee17 1a10 	vmov	r1, s14
 80289b4:	bb41      	cbnz	r1, 8028a08 <__kernel_tanf+0x70>
 80289b6:	1c43      	adds	r3, r0, #1
 80289b8:	4313      	orrs	r3, r2
 80289ba:	d108      	bne.n	80289ce <__kernel_tanf+0x36>
 80289bc:	f7fe fcee 	bl	802739c <fabsf>
 80289c0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80289c4:	eec7 7a00 	vdiv.f32	s15, s14, s0
 80289c8:	eeb0 0a67 	vmov.f32	s0, s15
 80289cc:	bd08      	pop	{r3, pc}
 80289ce:	2801      	cmp	r0, #1
 80289d0:	d0fa      	beq.n	80289c8 <__kernel_tanf+0x30>
 80289d2:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 80289d6:	eec7 7a00 	vdiv.f32	s15, s14, s0
 80289da:	e7f5      	b.n	80289c8 <__kernel_tanf+0x30>
 80289dc:	494e      	ldr	r1, [pc, #312]	; (8028b18 <__kernel_tanf+0x180>)
 80289de:	428a      	cmp	r2, r1
 80289e0:	dd12      	ble.n	8028a08 <__kernel_tanf+0x70>
 80289e2:	2b00      	cmp	r3, #0
 80289e4:	ed9f 7a4d 	vldr	s14, [pc, #308]	; 8028b1c <__kernel_tanf+0x184>
 80289e8:	bfb8      	it	lt
 80289ea:	eef1 7a40 	vneglt.f32	s15, s0
 80289ee:	ee77 7a67 	vsub.f32	s15, s14, s15
 80289f2:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 8028b20 <__kernel_tanf+0x188>
 80289f6:	bfb8      	it	lt
 80289f8:	eef1 0a60 	vneglt.f32	s1, s1
 80289fc:	ee77 0a60 	vsub.f32	s1, s14, s1
 8028a00:	ee70 7aa7 	vadd.f32	s15, s1, s15
 8028a04:	eddf 0a47 	vldr	s1, [pc, #284]	; 8028b24 <__kernel_tanf+0x18c>
 8028a08:	ed9f 6a47 	vldr	s12, [pc, #284]	; 8028b28 <__kernel_tanf+0x190>
 8028a0c:	eddf 5a47 	vldr	s11, [pc, #284]	; 8028b2c <__kernel_tanf+0x194>
 8028a10:	ed9f 5a47 	vldr	s10, [pc, #284]	; 8028b30 <__kernel_tanf+0x198>
 8028a14:	4940      	ldr	r1, [pc, #256]	; (8028b18 <__kernel_tanf+0x180>)
 8028a16:	ee67 6aa7 	vmul.f32	s13, s15, s15
 8028a1a:	428a      	cmp	r2, r1
 8028a1c:	ee26 7aa6 	vmul.f32	s14, s13, s13
 8028a20:	ee67 4aa6 	vmul.f32	s9, s15, s13
 8028a24:	eee7 5a06 	vfma.f32	s11, s14, s12
 8028a28:	ed9f 6a42 	vldr	s12, [pc, #264]	; 8028b34 <__kernel_tanf+0x19c>
 8028a2c:	eea5 6a87 	vfma.f32	s12, s11, s14
 8028a30:	eddf 5a41 	vldr	s11, [pc, #260]	; 8028b38 <__kernel_tanf+0x1a0>
 8028a34:	eee6 5a07 	vfma.f32	s11, s12, s14
 8028a38:	ed9f 6a40 	vldr	s12, [pc, #256]	; 8028b3c <__kernel_tanf+0x1a4>
 8028a3c:	eea5 6a87 	vfma.f32	s12, s11, s14
 8028a40:	eddf 5a3f 	vldr	s11, [pc, #252]	; 8028b40 <__kernel_tanf+0x1a8>
 8028a44:	eee6 5a07 	vfma.f32	s11, s12, s14
 8028a48:	ed9f 6a3e 	vldr	s12, [pc, #248]	; 8028b44 <__kernel_tanf+0x1ac>
 8028a4c:	eea7 6a05 	vfma.f32	s12, s14, s10
 8028a50:	ed9f 5a3d 	vldr	s10, [pc, #244]	; 8028b48 <__kernel_tanf+0x1b0>
 8028a54:	eea6 5a07 	vfma.f32	s10, s12, s14
 8028a58:	ed9f 6a3c 	vldr	s12, [pc, #240]	; 8028b4c <__kernel_tanf+0x1b4>
 8028a5c:	eea5 6a07 	vfma.f32	s12, s10, s14
 8028a60:	ed9f 5a3b 	vldr	s10, [pc, #236]	; 8028b50 <__kernel_tanf+0x1b8>
 8028a64:	eea6 5a07 	vfma.f32	s10, s12, s14
 8028a68:	ed9f 6a3a 	vldr	s12, [pc, #232]	; 8028b54 <__kernel_tanf+0x1bc>
 8028a6c:	eea5 6a07 	vfma.f32	s12, s10, s14
 8028a70:	eeb0 7a46 	vmov.f32	s14, s12
 8028a74:	eea5 7aa6 	vfma.f32	s14, s11, s13
 8028a78:	eeb0 6a60 	vmov.f32	s12, s1
 8028a7c:	eea7 6a24 	vfma.f32	s12, s14, s9
 8028a80:	ed9f 7a35 	vldr	s14, [pc, #212]	; 8028b58 <__kernel_tanf+0x1c0>
 8028a84:	eee6 0a26 	vfma.f32	s1, s12, s13
 8028a88:	eee4 0a87 	vfma.f32	s1, s9, s14
 8028a8c:	ee77 6aa0 	vadd.f32	s13, s15, s1
 8028a90:	dd1d      	ble.n	8028ace <__kernel_tanf+0x136>
 8028a92:	ee07 0a10 	vmov	s14, r0
 8028a96:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8028a9a:	ee66 5aa6 	vmul.f32	s11, s13, s13
 8028a9e:	ee76 6a87 	vadd.f32	s13, s13, s14
 8028aa2:	179b      	asrs	r3, r3, #30
 8028aa4:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 8028aa8:	f003 0302 	and.w	r3, r3, #2
 8028aac:	f1c3 0301 	rsb	r3, r3, #1
 8028ab0:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 8028ab4:	ee76 0a60 	vsub.f32	s1, s12, s1
 8028ab8:	ee77 7ae0 	vsub.f32	s15, s15, s1
 8028abc:	eea7 7ae6 	vfms.f32	s14, s15, s13
 8028ac0:	ee07 3a90 	vmov	s15, r3
 8028ac4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028ac8:	ee67 7a27 	vmul.f32	s15, s14, s15
 8028acc:	e77c      	b.n	80289c8 <__kernel_tanf+0x30>
 8028ace:	2801      	cmp	r0, #1
 8028ad0:	d01f      	beq.n	8028b12 <__kernel_tanf+0x17a>
 8028ad2:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8028ad6:	eec7 5a26 	vdiv.f32	s11, s14, s13
 8028ada:	4b20      	ldr	r3, [pc, #128]	; (8028b5c <__kernel_tanf+0x1c4>)
 8028adc:	ee16 2a90 	vmov	r2, s13
 8028ae0:	401a      	ands	r2, r3
 8028ae2:	ee06 2a10 	vmov	s12, r2
 8028ae6:	ee15 2a90 	vmov	r2, s11
 8028aea:	4013      	ands	r3, r2
 8028aec:	ee07 3a10 	vmov	s14, r3
 8028af0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8028af4:	eee6 6a07 	vfma.f32	s13, s12, s14
 8028af8:	ee76 7a67 	vsub.f32	s15, s12, s15
 8028afc:	ee70 0ae7 	vsub.f32	s1, s1, s15
 8028b00:	eef0 7a66 	vmov.f32	s15, s13
 8028b04:	eee7 7a20 	vfma.f32	s15, s14, s1
 8028b08:	eea7 7aa5 	vfma.f32	s14, s15, s11
 8028b0c:	eef0 7a47 	vmov.f32	s15, s14
 8028b10:	e75a      	b.n	80289c8 <__kernel_tanf+0x30>
 8028b12:	eef0 7a66 	vmov.f32	s15, s13
 8028b16:	e757      	b.n	80289c8 <__kernel_tanf+0x30>
 8028b18:	3f2ca13f 	.word	0x3f2ca13f
 8028b1c:	3f490fda 	.word	0x3f490fda
 8028b20:	33222168 	.word	0x33222168
 8028b24:	00000000 	.word	0x00000000
 8028b28:	37d95384 	.word	0x37d95384
 8028b2c:	3895c07a 	.word	0x3895c07a
 8028b30:	b79bae5f 	.word	0xb79bae5f
 8028b34:	398137b9 	.word	0x398137b9
 8028b38:	3abede48 	.word	0x3abede48
 8028b3c:	3c11371f 	.word	0x3c11371f
 8028b40:	3d5d0dd1 	.word	0x3d5d0dd1
 8028b44:	38a3f445 	.word	0x38a3f445
 8028b48:	3a1a26c8 	.word	0x3a1a26c8
 8028b4c:	3b6b6916 	.word	0x3b6b6916
 8028b50:	3cb327a4 	.word	0x3cb327a4
 8028b54:	3e088889 	.word	0x3e088889
 8028b58:	3eaaaaab 	.word	0x3eaaaaab
 8028b5c:	fffff000 	.word	0xfffff000

08028b60 <with_errnof>:
 8028b60:	b510      	push	{r4, lr}
 8028b62:	ed2d 8b02 	vpush	{d8}
 8028b66:	eeb0 8a40 	vmov.f32	s16, s0
 8028b6a:	4604      	mov	r4, r0
 8028b6c:	f7fe f9e8 	bl	8026f40 <__errno>
 8028b70:	eeb0 0a48 	vmov.f32	s0, s16
 8028b74:	ecbd 8b02 	vpop	{d8}
 8028b78:	6004      	str	r4, [r0, #0]
 8028b7a:	bd10      	pop	{r4, pc}

08028b7c <xflowf>:
 8028b7c:	b130      	cbz	r0, 8028b8c <xflowf+0x10>
 8028b7e:	eef1 7a40 	vneg.f32	s15, s0
 8028b82:	2022      	movs	r0, #34	; 0x22
 8028b84:	ee27 0a80 	vmul.f32	s0, s15, s0
 8028b88:	f7ff bfea 	b.w	8028b60 <with_errnof>
 8028b8c:	eef0 7a40 	vmov.f32	s15, s0
 8028b90:	e7f7      	b.n	8028b82 <xflowf+0x6>
	...

08028b94 <__math_uflowf>:
 8028b94:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8028b9c <__math_uflowf+0x8>
 8028b98:	f7ff bff0 	b.w	8028b7c <xflowf>
 8028b9c:	10000000 	.word	0x10000000

08028ba0 <__math_may_uflowf>:
 8028ba0:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8028ba8 <__math_may_uflowf+0x8>
 8028ba4:	f7ff bfea 	b.w	8028b7c <xflowf>
 8028ba8:	1a200000 	.word	0x1a200000

08028bac <__math_oflowf>:
 8028bac:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8028bb4 <__math_oflowf+0x8>
 8028bb0:	f7ff bfe4 	b.w	8028b7c <xflowf>
 8028bb4:	70000000 	.word	0x70000000

08028bb8 <__math_divzerof>:
 8028bb8:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8028bbc:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8028bc0:	2800      	cmp	r0, #0
 8028bc2:	fe40 7a27 	vseleq.f32	s15, s0, s15
 8028bc6:	ed9f 0a03 	vldr	s0, [pc, #12]	; 8028bd4 <__math_divzerof+0x1c>
 8028bca:	2022      	movs	r0, #34	; 0x22
 8028bcc:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8028bd0:	f7ff bfc6 	b.w	8028b60 <with_errnof>
 8028bd4:	00000000 	.word	0x00000000

08028bd8 <__math_invalidf>:
 8028bd8:	eef0 7a40 	vmov.f32	s15, s0
 8028bdc:	ee30 7a40 	vsub.f32	s14, s0, s0
 8028be0:	eef4 7a67 	vcmp.f32	s15, s15
 8028be4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028be8:	ee87 0a07 	vdiv.f32	s0, s14, s14
 8028bec:	d602      	bvs.n	8028bf4 <__math_invalidf+0x1c>
 8028bee:	2021      	movs	r0, #33	; 0x21
 8028bf0:	f7ff bfb6 	b.w	8028b60 <with_errnof>
 8028bf4:	4770      	bx	lr

08028bf6 <finite>:
 8028bf6:	ee10 3a90 	vmov	r3, s1
 8028bfa:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
 8028bfe:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
 8028c02:	0fc0      	lsrs	r0, r0, #31
 8028c04:	4770      	bx	lr

08028c06 <matherr>:
 8028c06:	2000      	movs	r0, #0
 8028c08:	4770      	bx	lr
 8028c0a:	0000      	movs	r0, r0
 8028c0c:	0000      	movs	r0, r0
	...

08028c10 <nan>:
 8028c10:	ed9f 0b01 	vldr	d0, [pc, #4]	; 8028c18 <nan+0x8>
 8028c14:	4770      	bx	lr
 8028c16:	bf00      	nop
 8028c18:	00000000 	.word	0x00000000
 8028c1c:	7ff80000 	.word	0x7ff80000

08028c20 <expm1f>:
 8028c20:	ee10 2a10 	vmov	r2, s0
 8028c24:	4984      	ldr	r1, [pc, #528]	; (8028e38 <expm1f+0x218>)
 8028c26:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 8028c2a:	428b      	cmp	r3, r1
 8028c2c:	d923      	bls.n	8028c76 <expm1f+0x56>
 8028c2e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8028c32:	d902      	bls.n	8028c3a <expm1f+0x1a>
 8028c34:	ee30 0a00 	vadd.f32	s0, s0, s0
 8028c38:	4770      	bx	lr
 8028c3a:	d105      	bne.n	8028c48 <expm1f+0x28>
 8028c3c:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8028c40:	2a00      	cmp	r2, #0
 8028c42:	fe20 0a27 	vselge.f32	s0, s0, s15
 8028c46:	4770      	bx	lr
 8028c48:	2a00      	cmp	r2, #0
 8028c4a:	db08      	blt.n	8028c5e <expm1f+0x3e>
 8028c4c:	4a7b      	ldr	r2, [pc, #492]	; (8028e3c <expm1f+0x21c>)
 8028c4e:	4293      	cmp	r3, r2
 8028c50:	f240 80ea 	bls.w	8028e28 <expm1f+0x208>
 8028c54:	ed9f 0a7a 	vldr	s0, [pc, #488]	; 8028e40 <expm1f+0x220>
 8028c58:	ee20 0a00 	vmul.f32	s0, s0, s0
 8028c5c:	4770      	bx	lr
 8028c5e:	eddf 7a79 	vldr	s15, [pc, #484]	; 8028e44 <expm1f+0x224>
 8028c62:	ee70 7a27 	vadd.f32	s15, s0, s15
 8028c66:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8028c6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028c6e:	d554      	bpl.n	8028d1a <expm1f+0xfa>
 8028c70:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8028c74:	4770      	bx	lr
 8028c76:	4974      	ldr	r1, [pc, #464]	; (8028e48 <expm1f+0x228>)
 8028c78:	428b      	cmp	r3, r1
 8028c7a:	d96c      	bls.n	8028d56 <expm1f+0x136>
 8028c7c:	4973      	ldr	r1, [pc, #460]	; (8028e4c <expm1f+0x22c>)
 8028c7e:	428b      	cmp	r3, r1
 8028c80:	d84b      	bhi.n	8028d1a <expm1f+0xfa>
 8028c82:	ed9f 7a73 	vldr	s14, [pc, #460]	; 8028e50 <expm1f+0x230>
 8028c86:	2a00      	cmp	r2, #0
 8028c88:	bfa7      	ittee	ge
 8028c8a:	ee30 7a47 	vsubge.f32	s14, s0, s14
 8028c8e:	eddf 7a71 	vldrge	s15, [pc, #452]	; 8028e54 <expm1f+0x234>
 8028c92:	eddf 7a71 	vldrlt	s15, [pc, #452]	; 8028e58 <expm1f+0x238>
 8028c96:	ee30 7a07 	vaddlt.f32	s14, s0, s14
 8028c9a:	bfac      	ite	ge
 8028c9c:	2301      	movge	r3, #1
 8028c9e:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 8028ca2:	ee37 0a67 	vsub.f32	s0, s14, s15
 8028ca6:	ee37 7a40 	vsub.f32	s14, s14, s0
 8028caa:	ee77 7a67 	vsub.f32	s15, s14, s15
 8028cae:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
 8028cb2:	ee20 5a25 	vmul.f32	s10, s0, s11
 8028cb6:	eddf 6a69 	vldr	s13, [pc, #420]	; 8028e5c <expm1f+0x23c>
 8028cba:	ed9f 6a69 	vldr	s12, [pc, #420]	; 8028e60 <expm1f+0x240>
 8028cbe:	ee20 7a05 	vmul.f32	s14, s0, s10
 8028cc2:	eea7 6a26 	vfma.f32	s12, s14, s13
 8028cc6:	eddf 6a67 	vldr	s13, [pc, #412]	; 8028e64 <expm1f+0x244>
 8028cca:	eee6 6a07 	vfma.f32	s13, s12, s14
 8028cce:	ed9f 6a66 	vldr	s12, [pc, #408]	; 8028e68 <expm1f+0x248>
 8028cd2:	eea6 6a87 	vfma.f32	s12, s13, s14
 8028cd6:	eddf 6a65 	vldr	s13, [pc, #404]	; 8028e6c <expm1f+0x24c>
 8028cda:	eee6 6a07 	vfma.f32	s13, s12, s14
 8028cde:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8028ce2:	eef0 4a46 	vmov.f32	s9, s12
 8028ce6:	eee6 4a87 	vfma.f32	s9, s13, s14
 8028cea:	eef0 6a64 	vmov.f32	s13, s9
 8028cee:	eef0 4a08 	vmov.f32	s9, #8	; 0x40400000  3.0
 8028cf2:	eee5 4a66 	vfms.f32	s9, s10, s13
 8028cf6:	ee36 5ae4 	vsub.f32	s10, s13, s9
 8028cfa:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 8028cfe:	eee0 6a64 	vfms.f32	s13, s0, s9
 8028d02:	eef0 4a66 	vmov.f32	s9, s13
 8028d06:	eec5 6a24 	vdiv.f32	s13, s10, s9
 8028d0a:	ee66 6a87 	vmul.f32	s13, s13, s14
 8028d0e:	bb83      	cbnz	r3, 8028d72 <expm1f+0x152>
 8028d10:	eef0 7a47 	vmov.f32	s15, s14
 8028d14:	eed0 7a26 	vfnms.f32	s15, s0, s13
 8028d18:	e026      	b.n	8028d68 <expm1f+0x148>
 8028d1a:	eddf 7a55 	vldr	s15, [pc, #340]	; 8028e70 <expm1f+0x250>
 8028d1e:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 8028d22:	ee20 7a27 	vmul.f32	s14, s0, s15
 8028d26:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8028d2a:	2a00      	cmp	r2, #0
 8028d2c:	fe66 7aa7 	vselge.f32	s15, s13, s15
 8028d30:	ee77 7a87 	vadd.f32	s15, s15, s14
 8028d34:	ed9f 7a46 	vldr	s14, [pc, #280]	; 8028e50 <expm1f+0x230>
 8028d38:	eddf 6a46 	vldr	s13, [pc, #280]	; 8028e54 <expm1f+0x234>
 8028d3c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8028d40:	ee17 3a90 	vmov	r3, s15
 8028d44:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028d48:	eea7 0ac7 	vfms.f32	s0, s15, s14
 8028d4c:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8028d50:	eeb0 7a40 	vmov.f32	s14, s0
 8028d54:	e7a5      	b.n	8028ca2 <expm1f+0x82>
 8028d56:	f1b3 5f4c 	cmp.w	r3, #855638016	; 0x33000000
 8028d5a:	d208      	bcs.n	8028d6e <expm1f+0x14e>
 8028d5c:	eddf 7a38 	vldr	s15, [pc, #224]	; 8028e40 <expm1f+0x220>
 8028d60:	ee70 7a27 	vadd.f32	s15, s0, s15
 8028d64:	ee77 7ae7 	vsub.f32	s15, s15, s15
 8028d68:	ee30 0a67 	vsub.f32	s0, s0, s15
 8028d6c:	4770      	bx	lr
 8028d6e:	2300      	movs	r3, #0
 8028d70:	e79d      	b.n	8028cae <expm1f+0x8e>
 8028d72:	ee76 6ae7 	vsub.f32	s13, s13, s15
 8028d76:	1c5a      	adds	r2, r3, #1
 8028d78:	eed6 7a80 	vfnms.f32	s15, s13, s0
 8028d7c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8028d80:	d106      	bne.n	8028d90 <expm1f+0x170>
 8028d82:	ee70 7a67 	vsub.f32	s15, s0, s15
 8028d86:	eebe 0a00 	vmov.f32	s0, #224	; 0xbf000000 -0.5
 8028d8a:	eea7 0aa5 	vfma.f32	s0, s15, s11
 8028d8e:	4770      	bx	lr
 8028d90:	2b01      	cmp	r3, #1
 8028d92:	d118      	bne.n	8028dc6 <expm1f+0x1a6>
 8028d94:	eebd 7a00 	vmov.f32	s14, #208	; 0xbe800000 -0.250
 8028d98:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8028d9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028da0:	bf41      	itttt	mi
 8028da2:	ee30 0a25 	vaddmi.f32	s0, s0, s11
 8028da6:	ee37 0ac0 	vsubmi.f32	s0, s15, s0
 8028daa:	eef8 7a00 	vmovmi.f32	s15, #128	; 0xc0000000 -2.0
 8028dae:	ee20 0a27 	vmulmi.f32	s0, s0, s15
 8028db2:	bf5f      	itttt	pl
 8028db4:	ee30 0a67 	vsubpl.f32	s0, s0, s15
 8028db8:	eef0 7a00 	vmovpl.f32	s15, #0	; 0x40000000  2.0
 8028dbc:	eea0 6a27 	vfmapl.f32	s12, s0, s15
 8028dc0:	eeb0 0a46 	vmovpl.f32	s0, s12
 8028dc4:	4770      	bx	lr
 8028dc6:	1c5a      	adds	r2, r3, #1
 8028dc8:	2a39      	cmp	r2, #57	; 0x39
 8028dca:	ea4f 51c3 	mov.w	r1, r3, lsl #23
 8028dce:	d90b      	bls.n	8028de8 <expm1f+0x1c8>
 8028dd0:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8028dd4:	ee36 0a40 	vsub.f32	s0, s12, s0
 8028dd8:	ee10 3a10 	vmov	r3, s0
 8028ddc:	440b      	add	r3, r1
 8028dde:	ee00 3a10 	vmov	s0, r3
 8028de2:	ee30 0a46 	vsub.f32	s0, s0, s12
 8028de6:	4770      	bx	lr
 8028de8:	2b16      	cmp	r3, #22
 8028dea:	dc11      	bgt.n	8028e10 <expm1f+0x1f0>
 8028dec:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8028df0:	fa42 f303 	asr.w	r3, r2, r3
 8028df4:	f1c3 537e 	rsb	r3, r3, #1065353216	; 0x3f800000
 8028df8:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8028dfc:	ee07 3a90 	vmov	s15, r3
 8028e00:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8028e04:	ee10 3a10 	vmov	r3, s0
 8028e08:	440b      	add	r3, r1
 8028e0a:	ee00 3a10 	vmov	s0, r3
 8028e0e:	4770      	bx	lr
 8028e10:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
 8028e14:	05db      	lsls	r3, r3, #23
 8028e16:	ee07 3a10 	vmov	s14, r3
 8028e1a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8028e1e:	ee30 0a67 	vsub.f32	s0, s0, s15
 8028e22:	ee30 0a06 	vadd.f32	s0, s0, s12
 8028e26:	e7ed      	b.n	8028e04 <expm1f+0x1e4>
 8028e28:	eddf 7a11 	vldr	s15, [pc, #68]	; 8028e70 <expm1f+0x250>
 8028e2c:	ee20 7a27 	vmul.f32	s14, s0, s15
 8028e30:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8028e34:	e77c      	b.n	8028d30 <expm1f+0x110>
 8028e36:	bf00      	nop
 8028e38:	4195b843 	.word	0x4195b843
 8028e3c:	42b17217 	.word	0x42b17217
 8028e40:	7149f2ca 	.word	0x7149f2ca
 8028e44:	0da24260 	.word	0x0da24260
 8028e48:	3eb17218 	.word	0x3eb17218
 8028e4c:	3f851591 	.word	0x3f851591
 8028e50:	3f317180 	.word	0x3f317180
 8028e54:	3717f7d1 	.word	0x3717f7d1
 8028e58:	b717f7d1 	.word	0xb717f7d1
 8028e5c:	b457edbb 	.word	0xb457edbb
 8028e60:	36867e54 	.word	0x36867e54
 8028e64:	b8a670cd 	.word	0xb8a670cd
 8028e68:	3ad00d01 	.word	0x3ad00d01
 8028e6c:	bd088889 	.word	0xbd088889
 8028e70:	3fb8aa3b 	.word	0x3fb8aa3b

08028e74 <finitef>:
 8028e74:	ee10 3a10 	vmov	r3, s0
 8028e78:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 8028e7c:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 8028e80:	bfac      	ite	ge
 8028e82:	2000      	movge	r0, #0
 8028e84:	2001      	movlt	r0, #1
 8028e86:	4770      	bx	lr

08028e88 <floorf>:
 8028e88:	ee10 3a10 	vmov	r3, s0
 8028e8c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 8028e90:	0dca      	lsrs	r2, r1, #23
 8028e92:	3a7f      	subs	r2, #127	; 0x7f
 8028e94:	2a16      	cmp	r2, #22
 8028e96:	dc2a      	bgt.n	8028eee <floorf+0x66>
 8028e98:	2a00      	cmp	r2, #0
 8028e9a:	da11      	bge.n	8028ec0 <floorf+0x38>
 8028e9c:	eddf 7a18 	vldr	s15, [pc, #96]	; 8028f00 <floorf+0x78>
 8028ea0:	ee30 0a27 	vadd.f32	s0, s0, s15
 8028ea4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8028ea8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028eac:	dd05      	ble.n	8028eba <floorf+0x32>
 8028eae:	2b00      	cmp	r3, #0
 8028eb0:	da23      	bge.n	8028efa <floorf+0x72>
 8028eb2:	4a14      	ldr	r2, [pc, #80]	; (8028f04 <floorf+0x7c>)
 8028eb4:	2900      	cmp	r1, #0
 8028eb6:	bf18      	it	ne
 8028eb8:	4613      	movne	r3, r2
 8028eba:	ee00 3a10 	vmov	s0, r3
 8028ebe:	4770      	bx	lr
 8028ec0:	4911      	ldr	r1, [pc, #68]	; (8028f08 <floorf+0x80>)
 8028ec2:	4111      	asrs	r1, r2
 8028ec4:	420b      	tst	r3, r1
 8028ec6:	d0fa      	beq.n	8028ebe <floorf+0x36>
 8028ec8:	eddf 7a0d 	vldr	s15, [pc, #52]	; 8028f00 <floorf+0x78>
 8028ecc:	ee30 0a27 	vadd.f32	s0, s0, s15
 8028ed0:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8028ed4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028ed8:	ddef      	ble.n	8028eba <floorf+0x32>
 8028eda:	2b00      	cmp	r3, #0
 8028edc:	bfbe      	ittt	lt
 8028ede:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
 8028ee2:	fa40 f202 	asrlt.w	r2, r0, r2
 8028ee6:	189b      	addlt	r3, r3, r2
 8028ee8:	ea23 0301 	bic.w	r3, r3, r1
 8028eec:	e7e5      	b.n	8028eba <floorf+0x32>
 8028eee:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8028ef2:	d3e4      	bcc.n	8028ebe <floorf+0x36>
 8028ef4:	ee30 0a00 	vadd.f32	s0, s0, s0
 8028ef8:	4770      	bx	lr
 8028efa:	2300      	movs	r3, #0
 8028efc:	e7dd      	b.n	8028eba <floorf+0x32>
 8028efe:	bf00      	nop
 8028f00:	7149f2ca 	.word	0x7149f2ca
 8028f04:	bf800000 	.word	0xbf800000
 8028f08:	007fffff 	.word	0x007fffff

08028f0c <scalbnf>:
 8028f0c:	b508      	push	{r3, lr}
 8028f0e:	ee10 2a10 	vmov	r2, s0
 8028f12:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 8028f16:	ed2d 8b02 	vpush	{d8}
 8028f1a:	eef0 0a40 	vmov.f32	s1, s0
 8028f1e:	d004      	beq.n	8028f2a <scalbnf+0x1e>
 8028f20:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8028f24:	d306      	bcc.n	8028f34 <scalbnf+0x28>
 8028f26:	ee70 0a00 	vadd.f32	s1, s0, s0
 8028f2a:	ecbd 8b02 	vpop	{d8}
 8028f2e:	eeb0 0a60 	vmov.f32	s0, s1
 8028f32:	bd08      	pop	{r3, pc}
 8028f34:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8028f38:	d21c      	bcs.n	8028f74 <scalbnf+0x68>
 8028f3a:	4b1f      	ldr	r3, [pc, #124]	; (8028fb8 <scalbnf+0xac>)
 8028f3c:	eddf 7a1f 	vldr	s15, [pc, #124]	; 8028fbc <scalbnf+0xb0>
 8028f40:	4298      	cmp	r0, r3
 8028f42:	ee60 0a27 	vmul.f32	s1, s0, s15
 8028f46:	db10      	blt.n	8028f6a <scalbnf+0x5e>
 8028f48:	ee10 2a90 	vmov	r2, s1
 8028f4c:	f3c2 53c7 	ubfx	r3, r2, #23, #8
 8028f50:	3b19      	subs	r3, #25
 8028f52:	4403      	add	r3, r0
 8028f54:	2bfe      	cmp	r3, #254	; 0xfe
 8028f56:	dd0f      	ble.n	8028f78 <scalbnf+0x6c>
 8028f58:	ed9f 8a19 	vldr	s16, [pc, #100]	; 8028fc0 <scalbnf+0xb4>
 8028f5c:	eeb0 0a48 	vmov.f32	s0, s16
 8028f60:	f000 f834 	bl	8028fcc <copysignf>
 8028f64:	ee60 0a08 	vmul.f32	s1, s0, s16
 8028f68:	e7df      	b.n	8028f2a <scalbnf+0x1e>
 8028f6a:	eddf 7a16 	vldr	s15, [pc, #88]	; 8028fc4 <scalbnf+0xb8>
 8028f6e:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8028f72:	e7da      	b.n	8028f2a <scalbnf+0x1e>
 8028f74:	0ddb      	lsrs	r3, r3, #23
 8028f76:	e7ec      	b.n	8028f52 <scalbnf+0x46>
 8028f78:	2b00      	cmp	r3, #0
 8028f7a:	dd06      	ble.n	8028f8a <scalbnf+0x7e>
 8028f7c:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8028f80:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 8028f84:	ee00 3a90 	vmov	s1, r3
 8028f88:	e7cf      	b.n	8028f2a <scalbnf+0x1e>
 8028f8a:	f113 0f16 	cmn.w	r3, #22
 8028f8e:	da06      	bge.n	8028f9e <scalbnf+0x92>
 8028f90:	f24c 3350 	movw	r3, #50000	; 0xc350
 8028f94:	4298      	cmp	r0, r3
 8028f96:	dcdf      	bgt.n	8028f58 <scalbnf+0x4c>
 8028f98:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 8028fc4 <scalbnf+0xb8>
 8028f9c:	e7de      	b.n	8028f5c <scalbnf+0x50>
 8028f9e:	3319      	adds	r3, #25
 8028fa0:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8028fa4:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 8028fa8:	eddf 7a07 	vldr	s15, [pc, #28]	; 8028fc8 <scalbnf+0xbc>
 8028fac:	ee07 3a10 	vmov	s14, r3
 8028fb0:	ee67 0a27 	vmul.f32	s1, s14, s15
 8028fb4:	e7b9      	b.n	8028f2a <scalbnf+0x1e>
 8028fb6:	bf00      	nop
 8028fb8:	ffff3cb0 	.word	0xffff3cb0
 8028fbc:	4c000000 	.word	0x4c000000
 8028fc0:	7149f2ca 	.word	0x7149f2ca
 8028fc4:	0da24260 	.word	0x0da24260
 8028fc8:	33000000 	.word	0x33000000

08028fcc <copysignf>:
 8028fcc:	ee10 3a10 	vmov	r3, s0
 8028fd0:	ee10 2a90 	vmov	r2, s1
 8028fd4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8028fd8:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 8028fdc:	4313      	orrs	r3, r2
 8028fde:	ee00 3a10 	vmov	s0, r3
 8028fe2:	4770      	bx	lr

08028fe4 <_init>:
 8028fe4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028fe6:	bf00      	nop
 8028fe8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8028fea:	bc08      	pop	{r3}
 8028fec:	469e      	mov	lr, r3
 8028fee:	4770      	bx	lr

08028ff0 <_fini>:
 8028ff0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028ff2:	bf00      	nop
 8028ff4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8028ff6:	bc08      	pop	{r3}
 8028ff8:	469e      	mov	lr, r3
 8028ffa:	4770      	bx	lr
