
cube_for_new_genera_brain4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .init         0000000c  00008000  00008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         00027b10  00008010  00008010  00008010  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .fini         0000000c  0002fb20  0002fb20  0002fb20  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00022a18  0002fb30  0002fb30  0002fb30  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.exidx    00000008  00052548  00052548  00052548  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .eh_frame     00000004  00052550  00052550  00052550  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .init_array   00000004  00062554  00062554  00052554  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  00062558  00062558  00052558  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000499  0006255c  0006255c  0005255c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .RAM_D2       000015e8  00062a00  00062a00  00052a00  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 10 .RAM_D1       0007eb58  00064000  00064000  00054000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 11 .SDRAM        02000000  000e2b60  000e2b60  000d2b60  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 12 .RAM_D3       00000201  020e2b60  020e2b60  020d2b60  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          00019030  020e2d68  020e2d68  020d2d61  2**3
                  ALLOC
 14 .comment      0000007b  00000000  00000000  020d2d61  2**0
                  CONTENTS, READONLY
 15 .debug_aranges 00004478  00000000  00000000  020d2ddc  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_info   000c7a4a  00000000  00000000  020d7254  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_abbrev 00010fa3  00000000  00000000  0219ec9e  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   0005336d  00000000  00000000  021afc41  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_frame  00010498  00000000  00000000  02202fb0  2**2
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_str    0018d73d  00000000  00000000  02213448  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_loc    000684b4  00000000  00000000  023a0b85  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_ranges 000107a8  00000000  00000000  02409039  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_macro  00049607  00000000  00000000  024197e1  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .ARM.attributes 0000002e  00000000  00000000  02462de8  2**0
                  CONTENTS, READONLY

Disassembly of section .init:

00008000 <_init>:
    8000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8002:	bf00      	nop
    8004:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8006:	bc08      	pop	{r3}
    8008:	469e      	mov	lr, r3
    800a:	4770      	bx	lr

Disassembly of section .text:

00008010 <exit>:
    8010:	b508      	push	{r3, lr}
    8012:	4b07      	ldr	r3, [pc, #28]	; (8030 <exit+0x20>)
    8014:	4604      	mov	r4, r0
    8016:	b113      	cbz	r3, 801e <exit+0xe>
    8018:	2100      	movs	r1, #0
    801a:	f3af 8000 	nop.w
    801e:	4b05      	ldr	r3, [pc, #20]	; (8034 <exit+0x24>)
    8020:	6818      	ldr	r0, [r3, #0]
    8022:	6a83      	ldr	r3, [r0, #40]	; 0x28
    8024:	b103      	cbz	r3, 8028 <exit+0x18>
    8026:	4798      	blx	r3
    8028:	4620      	mov	r0, r4
    802a:	f019 fcc5 	bl	219b8 <_exit>
    802e:	bf00      	nop
    8030:	00000000 	.word	0x00000000
    8034:	00051be4 	.word	0x00051be4

00008038 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
    8038:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* USER CODE BEGIN 1 */
  MPU_Conf();
    803a:	f011 f9c1 	bl	193c0 <MPU_Conf>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    803e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8042:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
    8046:	4c7e      	ldr	r4, [pc, #504]	; (8240 <main+0x208>)
    8048:	2500      	movs	r5, #0
    804a:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
    804e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8052:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
    8056:	6963      	ldr	r3, [r4, #20]
    8058:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    805c:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
    805e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8062:	f3bf 8f6f 	isb	sy

  /* Enable I-Cache---------------------------------------------------------*/
  SCB_EnableICache();

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();
    8066:	f011 f869 	bl	1913c <SCB_EnableDCache>

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
    806a:	f000 f991 	bl	8390 <HAL_Init>
  __ASM volatile ("dsb 0xF":::"memory");
    806e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8072:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_DisableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
    8076:	6963      	ldr	r3, [r4, #20]
    8078:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    807c:	6163      	str	r3, [r4, #20]
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
    807e:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
    8082:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8086:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
    808a:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    808e:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
    8092:	6963      	ldr	r3, [r4, #20]
    8094:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    8098:	6163      	str	r3, [r4, #20]
    809a:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
    809e:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
                                            /* clean & invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80a2:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
    80a6:	f3c3 06c9 	ubfx	r6, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    80aa:	f3c3 334e 	ubfx	r3, r3, #13, #15
    80ae:	07b7      	lsls	r7, r6, #30
    80b0:	0158      	lsls	r0, r3, #5
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80b2:	ea00 050c 	and.w	r5, r0, ip
    80b6:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
    80b8:	4632      	mov	r2, r6
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80ba:	ea41 0305 	orr.w	r3, r1, r5
                       ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
    80be:	3a01      	subs	r2, #1
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80c0:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
    80c4:	f8c4 3274 	str.w	r3, [r4, #628]	; 0x274
      } while (ways-- != 0U);
    80c8:	1c53      	adds	r3, r2, #1
    80ca:	d1f6      	bne.n	80ba <main+0x82>
    80cc:	3820      	subs	r0, #32
    } while(sets-- != 0U);
    80ce:	f110 0f20 	cmn.w	r0, #32
    80d2:	d1ee      	bne.n	80b2 <main+0x7a>
    80d4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    80d8:	f3bf 8f6f 	isb	sy
  /* Enable D-Cache---------------------------------------------------------*/
  SCB_DisableDCache();
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
    80dc:	f011 f85e 	bl	1919c <SystemClock_Config>


  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
    80e0:	f010 fdb4 	bl	18c4c <MX_GPIO_Init>
  MX_BDMA_Init();
    80e4:	f00f f90a 	bl	172fc <MX_BDMA_Init>
  MX_DMA_Init();
    80e8:	f00f fa1a 	bl	17520 <MX_DMA_Init>
  MX_FMC_Init();
    80ec:	f00f fdda 	bl	17ca4 <MX_FMC_Init>
  MX_ADC1_Init();
    80f0:	f00e fb52 	bl	16798 <MX_ADC1_Init>
  MX_I2C2_Init();
    80f4:	f010 fed6 	bl	18ea4 <MX_I2C2_Init>
  MX_SDMMC1_SD_Init();
    80f8:	f012 f840 	bl	1a17c <MX_SDMMC1_SD_Init>
  MX_FATFS_Init();
    80fc:	f00f fdb8 	bl	17c70 <MX_FATFS_Init>
  MX_SAI1_Init();
    8100:	f011 feb4 	bl	19e6c <MX_SAI1_Init>
  MX_RNG_Init();
    8104:	f011 fe84 	bl	19e10 <MX_RNG_Init>
  MX_I2C4_Init();
    8108:	f010 fefa 	bl	18f00 <MX_I2C4_Init>
  MX_USB_HOST_Init();
    810c:	f01b fa6c 	bl	235e8 <MX_USB_HOST_Init>
  MX_TIM3_Init();
    8110:	f019 fc58 	bl	219c4 <MX_TIM3_Init>
  MX_TIM4_Init();
    8114:	f019 fcd4 	bl	21ac0 <MX_TIM4_Init>
  __ASM volatile ("dsb 0xF":::"memory");
    8118:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    811c:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
    8120:	2500      	movs	r5, #0
    8122:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
    8126:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    812a:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
    812e:	6963      	ldr	r3, [r4, #20]
    8130:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    8134:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
    8136:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    813a:	f3bf 8f6f 	isb	sy
  // otherwise turning on -o3 optimization causes unreliable behavior where it's not set up correctly and never reaches the USB interrupt for connection
  /* Enable I-Cache---------------------------------------------------------*/
  SCB_EnableICache();

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();
    813e:	f010 fffd 	bl	1913c <SCB_EnableDCache>


  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
    8142:	2104      	movs	r1, #4
    8144:	483f      	ldr	r0, [pc, #252]	; (8244 <main+0x20c>)
    8146:	f00a fadf 	bl	12708 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);
    814a:	4629      	mov	r1, r5
    814c:	483e      	ldr	r0, [pc, #248]	; (8248 <main+0x210>)
    814e:	f00a fadb 	bl	12708 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);
    8152:	2104      	movs	r1, #4
    8154:	483c      	ldr	r0, [pc, #240]	; (8248 <main+0x210>)
    8156:	f00a fad7 	bl	12708 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_3);
    815a:	2108      	movs	r1, #8
    815c:	483a      	ldr	r0, [pc, #232]	; (8248 <main+0x210>)
    815e:	f00a fad3 	bl	12708 <HAL_TIM_PWM_Start>

  //HAL_Delay(1);
  // Emulated EEPROM Init
  HAL_FLASH_Unlock();
    8162:	f003 fb1f 	bl	b7a4 <HAL_FLASH_Unlock>
  if( EE_Init() != EE_OK)
    8166:	f00f fa6f 	bl	17648 <EE_Init>
    816a:	4605      	mov	r5, r0
    816c:	b100      	cbz	r0, 8170 <main+0x138>
    816e:	e7fe      	b.n	816e <main+0x136>
  {
    Error_Handler();
  }
  if((EE_ReadVariable(VirtAddVarTab[0],  &VarDataTab)) != HAL_OK) // read what the preset was before last power-off
    8170:	4c36      	ldr	r4, [pc, #216]	; (824c <main+0x214>)
    8172:	4937      	ldr	r1, [pc, #220]	; (8250 <main+0x218>)
    8174:	8820      	ldrh	r0, [r4, #0]
    8176:	f00f fc3f 	bl	179f8 <EE_ReadVariable>
    817a:	2800      	cmp	r0, #0
    817c:	d13e      	bne.n	81fc <main+0x1c4>
	  if((EE_WriteVariable(VirtAddVarTab[0],  0)) != HAL_OK)
	{
		Error_Handler();
	}
  }
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
    817e:	4b34      	ldr	r3, [pc, #208]	; (8250 <main+0x218>)
*/
/* helper function to initialize measuring unit (cycle counter) */
static void CycleCounterInit( void )
{
  /* Enable TRC */
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    8180:	4a34      	ldr	r2, [pc, #208]	; (8254 <main+0x21c>)
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
    8182:	881b      	ldrh	r3, [r3, #0]
    8184:	4834      	ldr	r0, [pc, #208]	; (8258 <main+0x220>)
    8186:	2b12      	cmp	r3, #18

  /* Unlock DWT registers */
  if ((*(uint32_t*)0xE0001FB4) & 1)
    8188:	4934      	ldr	r1, [pc, #208]	; (825c <main+0x224>)
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
    818a:	bf28      	it	cs
    818c:	2300      	movcs	r3, #0
    818e:	7003      	strb	r3, [r0, #0]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    8190:	68d3      	ldr	r3, [r2, #12]
  if ((*(uint32_t*)0xE0001FB4) & 1)
    8192:	6809      	ldr	r1, [r1, #0]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    8194:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    8198:	60d3      	str	r3, [r2, #12]
  if ((*(uint32_t*)0xE0001FB4) & 1)
    819a:	07cb      	lsls	r3, r1, #31
    819c:	d502      	bpl.n	81a4 <main+0x16c>
    *(uint32_t*)0xE0001FB0 = 0xC5ACCE55;
    819e:	4b30      	ldr	r3, [pc, #192]	; (8260 <main+0x228>)
    81a0:	4a30      	ldr	r2, [pc, #192]	; (8264 <main+0x22c>)
    81a2:	601a      	str	r2, [r3, #0]

  /* clear the cycle counter */
  DWT->CYCCNT = 0;
    81a4:	4830      	ldr	r0, [pc, #192]	; (8268 <main+0x230>)
    81a6:	2500      	movs	r5, #0

  /* start the cycle counter */
  DWT->CTRL = 0x40000001;
    81a8:	4c30      	ldr	r4, [pc, #192]	; (826c <main+0x234>)
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    81aa:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  DWT->CYCCNT = 0;
    81ae:	6045      	str	r5, [r0, #4]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    81b0:	462a      	mov	r2, r5
  DWT->CTRL = 0x40000001;
    81b2:	6004      	str	r4, [r0, #0]

  for (int i = 0; i < 4; i++)
  {
	  cycleCountAverages[i][0] = 0.0f;
    81b4:	2400      	movs	r4, #0
    81b6:	4b2e      	ldr	r3, [pc, #184]	; (8270 <main+0x238>)
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    81b8:	482e      	ldr	r0, [pc, #184]	; (8274 <main+0x23c>)
	  cycleCountAverages[i][0] = 0.0f;
    81ba:	601c      	str	r4, [r3, #0]
	  cycleCountAverages[i][1] = 0.0f;
    81bc:	605c      	str	r4, [r3, #4]
	  cycleCountAverages[i][2] = 0.0f;
    81be:	609c      	str	r4, [r3, #8]
	  cycleCountAverages[i][0] = 0.0f;
    81c0:	60dc      	str	r4, [r3, #12]
	  cycleCountAverages[i][1] = 0.0f;
    81c2:	611c      	str	r4, [r3, #16]
	  cycleCountAverages[i][2] = 0.0f;
    81c4:	615c      	str	r4, [r3, #20]
	  cycleCountAverages[i][0] = 0.0f;
    81c6:	619c      	str	r4, [r3, #24]
	  cycleCountAverages[i][1] = 0.0f;
    81c8:	61dc      	str	r4, [r3, #28]
	  cycleCountAverages[i][2] = 0.0f;
    81ca:	621c      	str	r4, [r3, #32]
	  cycleCountAverages[i][0] = 0.0f;
    81cc:	625c      	str	r4, [r3, #36]	; 0x24
	  cycleCountAverages[i][1] = 0.0f;
    81ce:	629c      	str	r4, [r3, #40]	; 0x28
	  cycleCountAverages[i][2] = 0.0f;
    81d0:	62dc      	str	r4, [r3, #44]	; 0x2c
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    81d2:	f004 f82f 	bl	c234 <HAL_GPIO_WritePin>
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
    81d6:	eef1 3a10 	vmrs	r3, fpscr
  tempFPURegisterVal |= (1<<24); // set the FTZ (flush-to-zero) bit in the FPU control register  // this makes checking for denormals not necessary as they are automatically set to zero by the hardware
    81da:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
    81de:	eee1 3a10 	vmsr	fpscr, r3
  HAL_ADCEx_Calibration_Start(&hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED);
    81e2:	f240 72ff 	movw	r2, #2047	; 0x7ff
    81e6:	4629      	mov	r1, r5
    81e8:	4823      	ldr	r0, [pc, #140]	; (8278 <main+0x240>)
    81ea:	f001 fa9b 	bl	9724 <HAL_ADCEx_Calibration_Start>
  if (HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&ADC_values, NUM_ADC_CHANNELS) != HAL_OK)
    81ee:	2206      	movs	r2, #6
    81f0:	4922      	ldr	r1, [pc, #136]	; (827c <main+0x244>)
    81f2:	4821      	ldr	r0, [pc, #132]	; (8278 <main+0x240>)
    81f4:	f000 f936 	bl	8464 <HAL_ADC_Start_DMA>
    81f8:	b138      	cbz	r0, 820a <main+0x1d2>
    81fa:	e7fe      	b.n	81fa <main+0x1c2>
	  if((EE_WriteVariable(VirtAddVarTab[0],  0)) != HAL_OK)
    81fc:	4629      	mov	r1, r5
    81fe:	8820      	ldrh	r0, [r4, #0]
    8200:	f00f fc36 	bl	17a70 <EE_WriteVariable>
    8204:	2800      	cmp	r0, #0
    8206:	d0ba      	beq.n	817e <main+0x146>
    8208:	e7fe      	b.n	8208 <main+0x1d0>
    820a:	4c1d      	ldr	r4, [pc, #116]	; (8280 <main+0x248>)
  HAL_Delay(10);
    820c:	200a      	movs	r0, #10
    820e:	f000 f8f7 	bl	8400 <HAL_Delay>
  OLED_init(&hi2c4);
    8212:	4620      	mov	r0, r4
    8214:	f011 fa1a 	bl	1964c <OLED_init>
  SDRAM_Initialization_sequence();
    8218:	f011 f860 	bl	192dc <SDRAM_Initialization_sequence>
  audioInit(&hi2c2, &hsai_BlockA1, &hsai_BlockB1);
    821c:	4a19      	ldr	r2, [pc, #100]	; (8284 <main+0x24c>)
    821e:	491a      	ldr	r1, [pc, #104]	; (8288 <main+0x250>)
    8220:	481a      	ldr	r0, [pc, #104]	; (828c <main+0x254>)
    8222:	f00e ff91 	bl	17148 <audioInit>
  OLED_writePreset();
    8226:	f011 f997 	bl	19558 <OLED_writePreset>
    MX_USB_HOST_Process();
    822a:	f01b fa13 	bl	23654 <MX_USB_HOST_Process>
    OLED_process(); // process what to write to the screen but don't actually draw
    822e:	f011 fd7d 	bl	19d2c <OLED_process>
 	if (hi2c4.State == HAL_I2C_STATE_READY)
    8232:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    8236:	2b20      	cmp	r3, #32
    8238:	d1f7      	bne.n	822a <main+0x1f2>
	  OLED_draw();
    823a:	f011 fb51 	bl	198e0 <OLED_draw>
    823e:	e7f4      	b.n	822a <main+0x1f2>
    8240:	e000ed00 	.word	0xe000ed00
    8244:	020faf48 	.word	0x020faf48
    8248:	020faf08 	.word	0x020faf08
    824c:	00062574 	.word	0x00062574
    8250:	020e2dd0 	.word	0x020e2dd0
    8254:	e000edf0 	.word	0xe000edf0
    8258:	020e2f19 	.word	0x020e2f19
    825c:	e0001fb4 	.word	0xe0001fb4
    8260:	e0001fb0 	.word	0xe0001fb0
    8264:	c5acce55 	.word	0xc5acce55
    8268:	e0001000 	.word	0xe0001000
    826c:	40000001 	.word	0x40000001
    8270:	020e4428 	.word	0x020e4428
    8274:	58020800 	.word	0x58020800
    8278:	020e2fd4 	.word	0x020e2fd4
    827c:	00063a80 	.word	0x00063a80
    8280:	020e3f0c 	.word	0x020e3f0c
    8284:	020e4570 	.word	0x020e4570
    8288:	020e46f8 	.word	0x020e46f8
    828c:	020e3f58 	.word	0x020e3f58

00008290 <__do_global_dtors_aux>:
    8290:	b510      	push	{r4, lr}
    8292:	4c05      	ldr	r4, [pc, #20]	; (82a8 <__do_global_dtors_aux+0x18>)
    8294:	7823      	ldrb	r3, [r4, #0]
    8296:	b933      	cbnz	r3, 82a6 <__do_global_dtors_aux+0x16>
    8298:	4b04      	ldr	r3, [pc, #16]	; (82ac <__do_global_dtors_aux+0x1c>)
    829a:	b113      	cbz	r3, 82a2 <__do_global_dtors_aux+0x12>
    829c:	4804      	ldr	r0, [pc, #16]	; (82b0 <__do_global_dtors_aux+0x20>)
    829e:	f3af 8000 	nop.w
    82a2:	2301      	movs	r3, #1
    82a4:	7023      	strb	r3, [r4, #0]
    82a6:	bd10      	pop	{r4, pc}
    82a8:	020e2d68 	.word	0x020e2d68
    82ac:	00000000 	.word	0x00000000
    82b0:	00052550 	.word	0x00052550

000082b4 <frame_dummy>:
    82b4:	b508      	push	{r3, lr}
    82b6:	4b03      	ldr	r3, [pc, #12]	; (82c4 <frame_dummy+0x10>)
    82b8:	b11b      	cbz	r3, 82c2 <frame_dummy+0xe>
    82ba:	4903      	ldr	r1, [pc, #12]	; (82c8 <frame_dummy+0x14>)
    82bc:	4803      	ldr	r0, [pc, #12]	; (82cc <frame_dummy+0x18>)
    82be:	f3af 8000 	nop.w
    82c2:	bd08      	pop	{r3, pc}
    82c4:	00000000 	.word	0x00000000
    82c8:	020e2d6c 	.word	0x020e2d6c
    82cc:	00052550 	.word	0x00052550

000082d0 <_mainCRTStartup>:
    82d0:	4b15      	ldr	r3, [pc, #84]	; (8328 <_mainCRTStartup+0x58>)
    82d2:	2b00      	cmp	r3, #0
    82d4:	bf08      	it	eq
    82d6:	4b13      	ldreq	r3, [pc, #76]	; (8324 <_mainCRTStartup+0x54>)
    82d8:	469d      	mov	sp, r3
    82da:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
    82de:	2100      	movs	r1, #0
    82e0:	468b      	mov	fp, r1
    82e2:	460f      	mov	r7, r1
    82e4:	4813      	ldr	r0, [pc, #76]	; (8334 <_mainCRTStartup+0x64>)
    82e6:	4a14      	ldr	r2, [pc, #80]	; (8338 <_mainCRTStartup+0x68>)
    82e8:	1a12      	subs	r2, r2, r0
    82ea:	f024 fafa 	bl	2c8e2 <memset>
    82ee:	4b0f      	ldr	r3, [pc, #60]	; (832c <_mainCRTStartup+0x5c>)
    82f0:	2b00      	cmp	r3, #0
    82f2:	d000      	beq.n	82f6 <_mainCRTStartup+0x26>
    82f4:	4798      	blx	r3
    82f6:	4b0e      	ldr	r3, [pc, #56]	; (8330 <_mainCRTStartup+0x60>)
    82f8:	2b00      	cmp	r3, #0
    82fa:	d000      	beq.n	82fe <_mainCRTStartup+0x2e>
    82fc:	4798      	blx	r3
    82fe:	2000      	movs	r0, #0
    8300:	2100      	movs	r1, #0
    8302:	0004      	movs	r4, r0
    8304:	000d      	movs	r5, r1
    8306:	480d      	ldr	r0, [pc, #52]	; (833c <_mainCRTStartup+0x6c>)
    8308:	2800      	cmp	r0, #0
    830a:	d002      	beq.n	8312 <_mainCRTStartup+0x42>
    830c:	480c      	ldr	r0, [pc, #48]	; (8340 <_mainCRTStartup+0x70>)
    830e:	f3af 8000 	nop.w
    8312:	f024 fa9d 	bl	2c850 <__libc_init_array>
    8316:	0020      	movs	r0, r4
    8318:	0029      	movs	r1, r5
    831a:	f7ff fe8d 	bl	8038 <main>
    831e:	f7ff fe77 	bl	8010 <exit>
    8322:	bf00      	nop
    8324:	00080000 	.word	0x00080000
	...
    8334:	020e2d61 	.word	0x020e2d61
    8338:	020fbd98 	.word	0x020fbd98
	...

00008344 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
    8344:	4b0f      	ldr	r3, [pc, #60]	; (8384 <HAL_InitTick+0x40>)
    8346:	781b      	ldrb	r3, [r3, #0]
    8348:	b90b      	cbnz	r3, 834e <HAL_InitTick+0xa>
  {
    return HAL_ERROR;
    834a:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
    834c:	4770      	bx	lr
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
    834e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    8352:	490d      	ldr	r1, [pc, #52]	; (8388 <HAL_InitTick+0x44>)
    8354:	fbb2 f3f3 	udiv	r3, r2, r3
{
    8358:	b510      	push	{r4, lr}
    835a:	4604      	mov	r4, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
    835c:	6808      	ldr	r0, [r1, #0]
    835e:	fbb0 f0f3 	udiv	r0, r0, r3
    8362:	f001 fbab 	bl	9abc <HAL_SYSTICK_Config>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
    8366:	2c0f      	cmp	r4, #15
    8368:	d800      	bhi.n	836c <HAL_InitTick+0x28>
    836a:	b108      	cbz	r0, 8370 <HAL_InitTick+0x2c>
    return HAL_ERROR;
    836c:	2001      	movs	r0, #1
}
    836e:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    8370:	2200      	movs	r2, #0
    8372:	4621      	mov	r1, r4
    8374:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8378:	f001 fb2c 	bl	99d4 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
    837c:	4b03      	ldr	r3, [pc, #12]	; (838c <HAL_InitTick+0x48>)
    837e:	2000      	movs	r0, #0
    8380:	601c      	str	r4, [r3, #0]
}
    8382:	bd10      	pop	{r4, pc}
    8384:	0006255c 	.word	0x0006255c
    8388:	0006280c 	.word	0x0006280c
    838c:	00062560 	.word	0x00062560

00008390 <HAL_Init>:
{
    8390:	b530      	push	{r4, r5, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
    8392:	2003      	movs	r0, #3
{
    8394:	b083      	sub	sp, #12
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
    8396:	f001 fb01 	bl	999c <HAL_NVIC_SetPriorityGrouping>
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    839a:	4c12      	ldr	r4, [pc, #72]	; (83e4 <HAL_Init+0x54>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    839c:	f006 fa1e 	bl	e7dc <HAL_RCC_GetSysClockFreq>
    83a0:	4a11      	ldr	r2, [pc, #68]	; (83e8 <HAL_Init+0x58>)
    83a2:	4912      	ldr	r1, [pc, #72]	; (83ec <HAL_Init+0x5c>)
    83a4:	6993      	ldr	r3, [r2, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83a6:	6992      	ldr	r2, [r2, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83a8:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemCoreClock = common_system_clock;
    83ac:	4d10      	ldr	r5, [pc, #64]	; (83f0 <HAL_Init+0x60>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83ae:	f002 020f 	and.w	r2, r2, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83b2:	5ccb      	ldrb	r3, [r1, r3]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83b4:	5c8a      	ldrb	r2, [r1, r2]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83b6:	f003 031f 	and.w	r3, r3, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83ba:	f002 021f 	and.w	r2, r2, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83be:	fa20 f303 	lsr.w	r3, r0, r3
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
    83c2:	2000      	movs	r0, #0
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83c4:	fa23 f202 	lsr.w	r2, r3, r2
  SystemCoreClock = common_system_clock;
    83c8:	602b      	str	r3, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83ca:	6022      	str	r2, [r4, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
    83cc:	f7ff ffba 	bl	8344 <HAL_InitTick>
    83d0:	b110      	cbz	r0, 83d8 <HAL_Init+0x48>
    return HAL_ERROR;
    83d2:	2001      	movs	r0, #1
}
    83d4:	b003      	add	sp, #12
    83d6:	bd30      	pop	{r4, r5, pc}
    83d8:	9001      	str	r0, [sp, #4]
  HAL_MspInit();
    83da:	f019 fadb 	bl	21994 <HAL_MspInit>
  return HAL_OK;
    83de:	9801      	ldr	r0, [sp, #4]
}
    83e0:	b003      	add	sp, #12
    83e2:	bd30      	pop	{r4, r5, pc}
    83e4:	00062810 	.word	0x00062810
    83e8:	58024400 	.word	0x58024400
    83ec:	00030cdc 	.word	0x00030cdc
    83f0:	0006280c 	.word	0x0006280c

000083f4 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
    83f4:	4b01      	ldr	r3, [pc, #4]	; (83fc <HAL_GetTick+0x8>)
    83f6:	6818      	ldr	r0, [r3, #0]
}
    83f8:	4770      	bx	lr
    83fa:	bf00      	nop
    83fc:	020e2f24 	.word	0x020e2f24

00008400 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
    8400:	b538      	push	{r3, r4, r5, lr}
    8402:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
    8404:	f7ff fff6 	bl	83f4 <HAL_GetTick>
    8408:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
    840a:	1c63      	adds	r3, r4, #1
    840c:	d002      	beq.n	8414 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
    840e:	4b04      	ldr	r3, [pc, #16]	; (8420 <HAL_Delay+0x20>)
    8410:	781b      	ldrb	r3, [r3, #0]
    8412:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
    8414:	f7ff ffee 	bl	83f4 <HAL_GetTick>
    8418:	1b40      	subs	r0, r0, r5
    841a:	42a0      	cmp	r0, r4
    841c:	d3fa      	bcc.n	8414 <HAL_Delay+0x14>
  {
  }
}
    841e:	bd38      	pop	{r3, r4, r5, pc}
    8420:	0006255c 	.word	0x0006255c

00008424 <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
    8424:	4b01      	ldr	r3, [pc, #4]	; (842c <HAL_GetREVID+0x8>)
    8426:	6818      	ldr	r0, [r3, #0]
}
    8428:	0c00      	lsrs	r0, r0, #16
    842a:	4770      	bx	lr
    842c:	5c001000 	.word	0x5c001000

00008430 <HAL_SetFMCMemorySwappingConfig>:
  * @retval HAL state
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
    8430:	f030 7380 	bics.w	r3, r0, #16777216	; 0x1000000
{
    8434:	b510      	push	{r4, lr}
    8436:	4604      	mov	r4, r0
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
    8438:	d002      	beq.n	8440 <HAL_SetFMCMemorySwappingConfig+0x10>
    843a:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
    843e:	d106      	bne.n	844e <HAL_SetFMCMemorySwappingConfig+0x1e>
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
    8440:	4b06      	ldr	r3, [pc, #24]	; (845c <HAL_SetFMCMemorySwappingConfig+0x2c>)
    8442:	6818      	ldr	r0, [r3, #0]
    8444:	f020 7040 	bic.w	r0, r0, #50331648	; 0x3000000
    8448:	4320      	orrs	r0, r4
    844a:	6018      	str	r0, [r3, #0]
}
    844c:	bd10      	pop	{r4, pc}
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
    844e:	f44f 6181 	mov.w	r1, #1032	; 0x408
    8452:	4803      	ldr	r0, [pc, #12]	; (8460 <HAL_SetFMCMemorySwappingConfig+0x30>)
    8454:	f010 ffde 	bl	19414 <assert_failed>
    8458:	e7f2      	b.n	8440 <HAL_SetFMCMemorySwappingConfig+0x10>
    845a:	bf00      	nop
    845c:	52004000 	.word	0x52004000
    8460:	0002fb30 	.word	0x0002fb30

00008464 <HAL_ADC_Start_DMA>:
  * @param pData Destination Buffer address.
  * @param Length Number of data to be transferred from ADC peripheral to memory
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
{
    8464:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef tmp_hal_status;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8468:	4b6a      	ldr	r3, [pc, #424]	; (8614 <HAL_ADC_Start_DMA+0x1b0>)
{
    846a:	460e      	mov	r6, r1
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    846c:	6801      	ldr	r1, [r0, #0]
{
    846e:	4604      	mov	r4, r0
    8470:	4617      	mov	r7, r2
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8472:	4299      	cmp	r1, r3
    8474:	d037      	beq.n	84e6 <HAL_ADC_Start_DMA+0x82>
    8476:	f503 7380 	add.w	r3, r3, #256	; 0x100
    847a:	4299      	cmp	r1, r3
    847c:	d033      	beq.n	84e6 <HAL_ADC_Start_DMA+0x82>
    847e:	4866      	ldr	r0, [pc, #408]	; (8618 <HAL_ADC_Start_DMA+0x1b4>)

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    8480:	4a64      	ldr	r2, [pc, #400]	; (8614 <HAL_ADC_Start_DMA+0x1b0>)
    8482:	4b66      	ldr	r3, [pc, #408]	; (861c <HAL_ADC_Start_DMA+0x1b8>)
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultimode(ADC_Common_TypeDef *ADCxy_COMMON)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    8484:	6885      	ldr	r5, [r0, #8]
    8486:	4291      	cmp	r1, r2
    8488:	bf18      	it	ne
    848a:	4299      	cmpne	r1, r3
    848c:	d002      	beq.n	8494 <HAL_ADC_Start_DMA+0x30>
    848e:	4b64      	ldr	r3, [pc, #400]	; (8620 <HAL_ADC_Start_DMA+0x1bc>)
    8490:	4299      	cmp	r1, r3
    8492:	d12a      	bne.n	84ea <HAL_ADC_Start_DMA+0x86>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    8494:	688b      	ldr	r3, [r1, #8]
    8496:	075a      	lsls	r2, r3, #29
    8498:	d430      	bmi.n	84fc <HAL_ADC_Start_DMA+0x98>

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
  {
    /* Process locked */
    __HAL_LOCK(hadc);
    849a:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    849e:	2b01      	cmp	r3, #1
    84a0:	d02c      	beq.n	84fc <HAL_ADC_Start_DMA+0x98>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    84a2:	f005 051f 	and.w	r5, r5, #31
    84a6:	2301      	movs	r3, #1

    /* Ensure that multimode regular conversions are not enabled.   */
    /* Otherwise, dedicated API HAL_ADCEx_MultiModeStart_DMA() must be used.  */
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    84a8:	2d09      	cmp	r5, #9
    __HAL_LOCK(hadc);
    84aa:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    84ae:	d905      	bls.n	84bc <HAL_ADC_Start_DMA+0x58>
        LL_ADC_REG_StartConversion(hadc->Instance);
      }
      else
      {
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
    84b0:	2300      	movs	r3, #0
    84b2:	2001      	movs	r0, #1
    84b4:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    tmp_hal_status = HAL_BUSY;
  }

  /* Return function status */
  return tmp_hal_status;
}
    84b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    84bc:	f240 2021 	movw	r0, #545	; 0x221
    84c0:	40e8      	lsrs	r0, r5
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
    84c2:	07c3      	lsls	r3, r0, #31
    84c4:	d5f4      	bpl.n	84b0 <HAL_ADC_Start_DMA+0x4c>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    84c6:	688b      	ldr	r3, [r1, #8]
    84c8:	07d8      	lsls	r0, r3, #31
    84ca:	d41a      	bmi.n	8502 <HAL_ADC_Start_DMA+0x9e>
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
    84cc:	688a      	ldr	r2, [r1, #8]
    84ce:	4b55      	ldr	r3, [pc, #340]	; (8624 <HAL_ADC_Start_DMA+0x1c0>)
    84d0:	421a      	tst	r2, r3
    84d2:	d05b      	beq.n	858c <HAL_ADC_Start_DMA+0x128>
        }

        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    84d4:	6d63      	ldr	r3, [r4, #84]	; 0x54
    84d6:	f043 0310 	orr.w	r3, r3, #16
    84da:	6563      	str	r3, [r4, #84]	; 0x54

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    84dc:	6da3      	ldr	r3, [r4, #88]	; 0x58
    84de:	f043 0301 	orr.w	r3, r3, #1
    84e2:	65a3      	str	r3, [r4, #88]	; 0x58
    84e4:	e7e4      	b.n	84b0 <HAL_ADC_Start_DMA+0x4c>
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    84e6:	4850      	ldr	r0, [pc, #320]	; (8628 <HAL_ADC_Start_DMA+0x1c4>)
    84e8:	e7ca      	b.n	8480 <HAL_ADC_Start_DMA+0x1c>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    84ea:	f240 71a7 	movw	r1, #1959	; 0x7a7
    84ee:	484f      	ldr	r0, [pc, #316]	; (862c <HAL_ADC_Start_DMA+0x1c8>)
    84f0:	f010 ff90 	bl	19414 <assert_failed>
    84f4:	6821      	ldr	r1, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    84f6:	688b      	ldr	r3, [r1, #8]
    84f8:	075a      	lsls	r2, r3, #29
    84fa:	d5ce      	bpl.n	849a <HAL_ADC_Start_DMA+0x36>
    tmp_hal_status = HAL_BUSY;
    84fc:	2002      	movs	r0, #2
}
    84fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    8502:	4b46      	ldr	r3, [pc, #280]	; (861c <HAL_ADC_Start_DMA+0x1b8>)
    8504:	1ac9      	subs	r1, r1, r3
    8506:	bf18      	it	ne
    8508:	2101      	movne	r1, #1
        ADC_STATE_CLR_SET(hadc->State,
    850a:	6d62      	ldr	r2, [r4, #84]	; 0x54
    850c:	4b48      	ldr	r3, [pc, #288]	; (8630 <HAL_ADC_Start_DMA+0x1cc>)
    850e:	4013      	ands	r3, r2
    8510:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    8514:	6563      	str	r3, [r4, #84]	; 0x54
            || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    8516:	b105      	cbz	r5, 851a <HAL_ADC_Start_DMA+0xb6>
    8518:	b119      	cbz	r1, 8522 <HAL_ADC_Start_DMA+0xbe>
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
    851a:	6d63      	ldr	r3, [r4, #84]	; 0x54
    851c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
    8520:	6563      	str	r3, [r4, #84]	; 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
    8522:	6d63      	ldr	r3, [r4, #84]	; 0x54
    8524:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
    8528:	d02e      	beq.n	8588 <HAL_ADC_Start_DMA+0x124>
          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
    852a:	6da3      	ldr	r3, [r4, #88]	; 0x58
    852c:	f023 0306 	bic.w	r3, r3, #6
    8530:	65a3      	str	r3, [r4, #88]	; 0x58
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
    8532:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
    8534:	463b      	mov	r3, r7
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
    8536:	483f      	ldr	r0, [pc, #252]	; (8634 <HAL_ADC_Start_DMA+0x1d0>)
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
    8538:	4632      	mov	r2, r6
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    853a:	4f3f      	ldr	r7, [pc, #252]	; (8638 <HAL_ADC_Start_DMA+0x1d4>)
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
    853c:	251c      	movs	r5, #28
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
    853e:	63c8      	str	r0, [r1, #60]	; 0x3c
        __HAL_UNLOCK(hadc);
    8540:	2100      	movs	r1, #0
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    8542:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
    8544:	4e3d      	ldr	r6, [pc, #244]	; (863c <HAL_ADC_Start_DMA+0x1d8>)
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    8546:	6407      	str	r7, [r0, #64]	; 0x40
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
    8548:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    854a:	64c6      	str	r6, [r0, #76]	; 0x4c
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
    854c:	6820      	ldr	r0, [r4, #0]
    854e:	6005      	str	r5, [r0, #0]
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
    8550:	6820      	ldr	r0, [r4, #0]
        __HAL_UNLOCK(hadc);
    8552:	f884 1050 	strb.w	r1, [r4, #80]	; 0x50
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
    8556:	6841      	ldr	r1, [r0, #4]
    8558:	f041 0110 	orr.w	r1, r1, #16
    855c:	6041      	str	r1, [r0, #4]
        LL_ADC_REG_SetDataTransferMode(hadc->Instance, (uint32_t)hadc->Init.ConversionDataManagement);
    855e:	6820      	ldr	r0, [r4, #0]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DMNGT, DataTransferMode);
    8560:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    8562:	68c1      	ldr	r1, [r0, #12]
    8564:	f021 0103 	bic.w	r1, r1, #3
    8568:	4329      	orrs	r1, r5
    856a:	60c1      	str	r1, [r0, #12]
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
    856c:	6821      	ldr	r1, [r4, #0]
    856e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    8570:	3140      	adds	r1, #64	; 0x40
    8572:	f002 fab3 	bl	aadc <HAL_DMA_Start_IT>
        LL_ADC_REG_StartConversion(hadc->Instance);
    8576:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(ADCx->CR,
    8578:	4b31      	ldr	r3, [pc, #196]	; (8640 <HAL_ADC_Start_DMA+0x1dc>)
    857a:	6891      	ldr	r1, [r2, #8]
    857c:	400b      	ands	r3, r1
    857e:	f043 0304 	orr.w	r3, r3, #4
    8582:	6093      	str	r3, [r2, #8]
}
    8584:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          ADC_CLEAR_ERRORCODE(hadc);
    8588:	65a3      	str	r3, [r4, #88]	; 0x58
    858a:	e7d2      	b.n	8532 <HAL_ADC_Start_DMA+0xce>
  MODIFY_REG(ADCx->CR,
    858c:	688a      	ldr	r2, [r1, #8]
    858e:	4b2c      	ldr	r3, [pc, #176]	; (8640 <HAL_ADC_Start_DMA+0x1dc>)
    8590:	4013      	ands	r3, r2
    8592:	f043 0301 	orr.w	r3, r3, #1
    8596:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
    8598:	f7ff ff2c 	bl	83f4 <HAL_GetTick>
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    859c:	6823      	ldr	r3, [r4, #0]
    859e:	4a1d      	ldr	r2, [pc, #116]	; (8614 <HAL_ADC_Start_DMA+0x1b0>)
    tickstart = HAL_GetTick();
    85a0:	4680      	mov	r8, r0
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    85a2:	4293      	cmp	r3, r2
    85a4:	d022      	beq.n	85ec <HAL_ADC_Start_DMA+0x188>
    85a6:	f502 7280 	add.w	r2, r2, #256	; 0x100
    85aa:	4293      	cmp	r3, r2
    85ac:	d01e      	beq.n	85ec <HAL_ADC_Start_DMA+0x188>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    85ae:	4a1a      	ldr	r2, [pc, #104]	; (8618 <HAL_ADC_Start_DMA+0x1b4>)
    85b0:	6892      	ldr	r2, [r2, #8]
  MODIFY_REG(ADCx->CR,
    85b2:	f8df 908c 	ldr.w	r9, [pc, #140]	; 8640 <HAL_ADC_Start_DMA+0x1dc>
    85b6:	e00c      	b.n	85d2 <HAL_ADC_Start_DMA+0x16e>
    85b8:	689a      	ldr	r2, [r3, #8]
    85ba:	ea02 0209 	and.w	r2, r2, r9
    85be:	f042 0201 	orr.w	r2, r2, #1
    85c2:	609a      	str	r2, [r3, #8]
        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
    85c4:	f7ff ff16 	bl	83f4 <HAL_GetTick>
    85c8:	eba0 0008 	sub.w	r0, r0, r8
    85cc:	2802      	cmp	r0, #2
    85ce:	d881      	bhi.n	84d4 <HAL_ADC_Start_DMA+0x70>
    85d0:	6823      	ldr	r3, [r4, #0]
      while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
    85d2:	681a      	ldr	r2, [r3, #0]
    85d4:	07d2      	lsls	r2, r2, #31
    85d6:	d418      	bmi.n	860a <HAL_ADC_Start_DMA+0x1a6>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    85d8:	689a      	ldr	r2, [r3, #8]
    85da:	07d1      	lsls	r1, r2, #31
    85dc:	d5ec      	bpl.n	85b8 <HAL_ADC_Start_DMA+0x154>
        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
    85de:	f7ff ff09 	bl	83f4 <HAL_GetTick>
    85e2:	eba0 0008 	sub.w	r0, r0, r8
    85e6:	2802      	cmp	r0, #2
    85e8:	d9f2      	bls.n	85d0 <HAL_ADC_Start_DMA+0x16c>
    85ea:	e773      	b.n	84d4 <HAL_ADC_Start_DMA+0x70>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    85ec:	490e      	ldr	r1, [pc, #56]	; (8628 <HAL_ADC_Start_DMA+0x1c4>)
    if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
    85ee:	4a0b      	ldr	r2, [pc, #44]	; (861c <HAL_ADC_Start_DMA+0x1b8>)
    85f0:	6889      	ldr	r1, [r1, #8]
         || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    85f2:	f011 0f1f 	tst.w	r1, #31
    85f6:	bf0c      	ite	eq
    85f8:	2101      	moveq	r1, #1
    85fa:	2100      	movne	r1, #0
    85fc:	4293      	cmp	r3, r2
    85fe:	bf18      	it	ne
    8600:	f041 0101 	orrne.w	r1, r1, #1
    8604:	2900      	cmp	r1, #0
    8606:	d1d4      	bne.n	85b2 <HAL_ADC_Start_DMA+0x14e>
    8608:	e77f      	b.n	850a <HAL_ADC_Start_DMA+0xa6>
    860a:	4904      	ldr	r1, [pc, #16]	; (861c <HAL_ADC_Start_DMA+0x1b8>)
    860c:	1a59      	subs	r1, r3, r1
    860e:	bf18      	it	ne
    8610:	2101      	movne	r1, #1
    8612:	e77a      	b.n	850a <HAL_ADC_Start_DMA+0xa6>
    8614:	40022000 	.word	0x40022000
    8618:	58026300 	.word	0x58026300
    861c:	40022100 	.word	0x40022100
    8620:	58026000 	.word	0x58026000
    8624:	8000003f 	.word	0x8000003f
    8628:	40022300 	.word	0x40022300
    862c:	0002fb64 	.word	0x0002fb64
    8630:	fffff0fe 	.word	0xfffff0fe
    8634:	00008655 	.word	0x00008655
    8638:	00008645 	.word	0x00008645
    863c:	000086bd 	.word	0x000086bd
    8640:	7fffffc0 	.word	0x7fffffc0

00008644 <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)
{
    8644:	b508      	push	{r3, lr}

  /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
    8646:	6b80      	ldr	r0, [r0, #56]	; 0x38
    8648:	f010 fe46 	bl	192d8 <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
    864c:	bd08      	pop	{r3, pc}
    864e:	bf00      	nop

00008650 <HAL_ADC_ErrorCallback>:
    8650:	4770      	bx	lr
    8652:	bf00      	nop

00008654 <ADC_DMAConvCplt>:
{
    8654:	b510      	push	{r4, lr}
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
    8656:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
    8658:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    865a:	f012 0f50 	tst.w	r2, #80	; 0x50
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
    865e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
    8660:	d11d      	bne.n	869e <ADC_DMAConvCplt+0x4a>
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
    8662:	6819      	ldr	r1, [r3, #0]
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
    8664:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    8668:	655a      	str	r2, [r3, #84]	; 0x54
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
    866a:	680a      	ldr	r2, [r1, #0]
    866c:	f012 0f08 	tst.w	r2, #8
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
    8670:	68ca      	ldr	r2, [r1, #12]
    8672:	d01b      	beq.n	86ac <ADC_DMAConvCplt+0x58>
    8674:	f412 6f40 	tst.w	r2, #3072	; 0xc00
    8678:	d10d      	bne.n	8696 <ADC_DMAConvCplt+0x42>
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_CONT) == 0UL)
    867a:	68ca      	ldr	r2, [r1, #12]
    867c:	0494      	lsls	r4, r2, #18
    867e:	d40a      	bmi.n	8696 <ADC_DMAConvCplt+0x42>
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
    8680:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    8682:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    8686:	655a      	str	r2, [r3, #84]	; 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
    8688:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    868a:	04d1      	lsls	r1, r2, #19
    868c:	d403      	bmi.n	8696 <ADC_DMAConvCplt+0x42>
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
    868e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    8690:	f042 0201 	orr.w	r2, r2, #1
    8694:	655a      	str	r2, [r3, #84]	; 0x54
    HAL_ADC_ConvCpltCallback(hadc);
    8696:	4618      	mov	r0, r3
    8698:	f010 fe1c 	bl	192d4 <HAL_ADC_ConvCpltCallback>
}
    869c:	bd10      	pop	{r4, pc}
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
    869e:	06d2      	lsls	r2, r2, #27
    86a0:	d407      	bmi.n	86b2 <ADC_DMAConvCplt+0x5e>
      hadc->DMA_Handle->XferErrorCallback(hdma);
    86a2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
    86a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      hadc->DMA_Handle->XferErrorCallback(hdma);
    86a8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    86aa:	4718      	bx	r3
      if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMNGT) == 0UL)
    86ac:	0790      	lsls	r0, r2, #30
    86ae:	d1f2      	bne.n	8696 <ADC_DMAConvCplt+0x42>
    86b0:	e7e6      	b.n	8680 <ADC_DMAConvCplt+0x2c>
      HAL_ADC_ErrorCallback(hadc);
    86b2:	4618      	mov	r0, r3
    86b4:	f7ff ffcc 	bl	8650 <HAL_ADC_ErrorCallback>
}
    86b8:	bd10      	pop	{r4, pc}
    86ba:	bf00      	nop

000086bc <ADC_DMAError>:
  * @brief  DMA error callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAError(DMA_HandleTypeDef *hdma)
{
    86bc:	b508      	push	{r3, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
    86be:	6b83      	ldr	r3, [r0, #56]	; 0x38

  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
    86c0:	6d5a      	ldr	r2, [r3, #84]	; 0x54

  /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
    86c2:	4618      	mov	r0, r3
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
    86c4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    86c8:	655a      	str	r2, [r3, #84]	; 0x54
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
    86ca:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    86cc:	f042 0204 	orr.w	r2, r2, #4
    86d0:	659a      	str	r2, [r3, #88]	; 0x58
  HAL_ADC_ErrorCallback(hadc);
    86d2:	f7ff ffbd 	bl	8650 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
    86d6:	bd08      	pop	{r3, pc}

000086d8 <HAL_ADC_ConfigChannel>:
{
    86d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    86da:	4605      	mov	r5, r0
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    86dc:	4ab3      	ldr	r2, [pc, #716]	; (89ac <HAL_ADC_ConfigChannel+0x2d4>)
    86de:	48b4      	ldr	r0, [pc, #720]	; (89b0 <HAL_ADC_ConfigChannel+0x2d8>)
{
    86e0:	b083      	sub	sp, #12
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    86e2:	682b      	ldr	r3, [r5, #0]
  __IO uint32_t wait_loop_index = 0;
    86e4:	2600      	movs	r6, #0
{
    86e6:	460c      	mov	r4, r1
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    86e8:	4283      	cmp	r3, r0
    86ea:	bf18      	it	ne
    86ec:	4293      	cmpne	r3, r2
  __IO uint32_t wait_loop_index = 0;
    86ee:	9601      	str	r6, [sp, #4]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    86f0:	d003      	beq.n	86fa <HAL_ADC_ConfigChannel+0x22>
    86f2:	4ab0      	ldr	r2, [pc, #704]	; (89b4 <HAL_ADC_ConfigChannel+0x2dc>)
    86f4:	4293      	cmp	r3, r2
    86f6:	f040 8153 	bne.w	89a0 <HAL_ADC_ConfigChannel+0x2c8>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
    86fa:	6862      	ldr	r2, [r4, #4]
    86fc:	f422 7340 	bic.w	r3, r2, #768	; 0x300
    8700:	f422 7180 	bic.w	r1, r2, #256	; 0x100
    8704:	1f98      	subs	r0, r3, #6
    8706:	bf18      	it	ne
    8708:	2001      	movne	r0, #1
    870a:	2918      	cmp	r1, #24
    870c:	f240 8119 	bls.w	8942 <HAL_ADC_ConfigChannel+0x26a>
    8710:	2301      	movs	r3, #1
    8712:	f422 7600 	bic.w	r6, r2, #512	; 0x200
    8716:	f5a2 7100 	sub.w	r1, r2, #512	; 0x200
    871a:	f5b6 7680 	subs.w	r6, r6, #256	; 0x100
    871e:	bf18      	it	ne
    8720:	2601      	movne	r6, #1
    8722:	2918      	cmp	r1, #24
    8724:	f240 8107 	bls.w	8936 <HAL_ADC_ConfigChannel+0x25e>
    8728:	2201      	movs	r2, #1
    872a:	4003      	ands	r3, r0
    872c:	421e      	tst	r6, r3
    872e:	d002      	beq.n	8736 <HAL_ADC_ConfigChannel+0x5e>
    8730:	2a00      	cmp	r2, #0
    8732:	f040 8404 	bne.w	8f3e <HAL_ADC_ConfigChannel+0x866>
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
    8736:	68a3      	ldr	r3, [r4, #8]
    8738:	2b07      	cmp	r3, #7
    873a:	f200 8256 	bhi.w	8bea <HAL_ADC_ConfigChannel+0x512>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
    873e:	68e3      	ldr	r3, [r4, #12]
    8740:	f240 72ff 	movw	r2, #2047	; 0x7ff
    8744:	4293      	cmp	r3, r2
    8746:	d003      	beq.n	8750 <HAL_ADC_ConfigChannel+0x78>
    8748:	4a9b      	ldr	r2, [pc, #620]	; (89b8 <HAL_ADC_ConfigChannel+0x2e0>)
    874a:	4293      	cmp	r3, r2
    874c:	f040 8111 	bne.w	8972 <HAL_ADC_ConfigChannel+0x29a>
  assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
    8750:	6923      	ldr	r3, [r4, #16]
    8752:	2b04      	cmp	r3, #4
    8754:	f200 8116 	bhi.w	8984 <HAL_ADC_ConfigChannel+0x2ac>
  if (hadc->Init.OversamplingMode == ENABLE)
    8758:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
    875c:	6961      	ldr	r1, [r4, #20]
    875e:	2b01      	cmp	r3, #1
    8760:	682a      	ldr	r2, [r5, #0]
  if((DBGMCU->IDCODE & 0x30000000UL) == 0x10000000UL) /* Rev.Y */
    8762:	4b96      	ldr	r3, [pc, #600]	; (89bc <HAL_ADC_ConfigChannel+0x2e4>)
    8764:	f000 8223 	beq.w	8bae <HAL_ADC_ConfigChannel+0x4d6>
    8768:	681b      	ldr	r3, [r3, #0]
    876a:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
    876e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
    8772:	f040 810d 	bne.w	8990 <HAL_ADC_ConfigChannel+0x2b8>
      return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
    8776:	68d2      	ldr	r2, [r2, #12]
    8778:	f64f 73ff 	movw	r3, #65535	; 0xffff
    877c:	0852      	lsrs	r2, r2, #1
    877e:	f002 020e 	and.w	r2, r2, #14
    8782:	40d3      	lsrs	r3, r2
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
    8784:	4299      	cmp	r1, r3
    8786:	f200 813f 	bhi.w	8a08 <HAL_ADC_ConfigChannel+0x330>
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
    878a:	4b8b      	ldr	r3, [pc, #556]	; (89b8 <HAL_ADC_ConfigChannel+0x2e0>)
    878c:	68e2      	ldr	r2, [r4, #12]
    878e:	429a      	cmp	r2, r3
    8790:	f000 8152 	beq.w	8a38 <HAL_ADC_ConfigChannel+0x360>
    assert_param(IS_ADC_CHANNEL(sConfig->Channel));
    8794:	6821      	ldr	r1, [r4, #0]
    8796:	4b8a      	ldr	r3, [pc, #552]	; (89c0 <HAL_ADC_ConfigChannel+0x2e8>)
    8798:	4e8a      	ldr	r6, [pc, #552]	; (89c4 <HAL_ADC_ConfigChannel+0x2ec>)
    879a:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
    879e:	2901      	cmp	r1, #1
    87a0:	bf18      	it	ne
    87a2:	4299      	cmpne	r1, r3
    87a4:	4888      	ldr	r0, [pc, #544]	; (89c8 <HAL_ADC_ConfigChannel+0x2f0>)
    87a6:	bf14      	ite	ne
    87a8:	2301      	movne	r3, #1
    87aa:	2300      	moveq	r3, #0
    87ac:	42b1      	cmp	r1, r6
    87ae:	bf0c      	ite	eq
    87b0:	2300      	moveq	r3, #0
    87b2:	f003 0301 	andne.w	r3, r3, #1
    87b6:	4e85      	ldr	r6, [pc, #532]	; (89cc <HAL_ADC_ConfigChannel+0x2f4>)
    87b8:	4281      	cmp	r1, r0
    87ba:	bf0c      	ite	eq
    87bc:	2300      	moveq	r3, #0
    87be:	f003 0301 	andne.w	r3, r3, #1
    87c2:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
    87c6:	42b1      	cmp	r1, r6
    87c8:	bf0c      	ite	eq
    87ca:	2300      	moveq	r3, #0
    87cc:	f003 0301 	andne.w	r3, r3, #1
    87d0:	3018      	adds	r0, #24
    87d2:	4e7f      	ldr	r6, [pc, #508]	; (89d0 <HAL_ADC_ConfigChannel+0x2f8>)
    87d4:	4281      	cmp	r1, r0
    87d6:	bf0c      	ite	eq
    87d8:	2300      	moveq	r3, #0
    87da:	f003 0301 	andne.w	r3, r3, #1
    87de:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
    87e2:	42b1      	cmp	r1, r6
    87e4:	bf0c      	ite	eq
    87e6:	2300      	moveq	r3, #0
    87e8:	f003 0301 	andne.w	r3, r3, #1
    87ec:	3060      	adds	r0, #96	; 0x60
    87ee:	4e79      	ldr	r6, [pc, #484]	; (89d4 <HAL_ADC_ConfigChannel+0x2fc>)
    87f0:	4281      	cmp	r1, r0
    87f2:	bf0c      	ite	eq
    87f4:	2300      	moveq	r3, #0
    87f6:	f003 0301 	andne.w	r3, r3, #1
    87fa:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
    87fe:	42b1      	cmp	r1, r6
    8800:	bf0c      	ite	eq
    8802:	2300      	moveq	r3, #0
    8804:	f003 0301 	andne.w	r3, r3, #1
    8808:	f500 70c0 	add.w	r0, r0, #384	; 0x180
    880c:	4e72      	ldr	r6, [pc, #456]	; (89d8 <HAL_ADC_ConfigChannel+0x300>)
    880e:	4281      	cmp	r1, r0
    8810:	bf0c      	ite	eq
    8812:	2300      	moveq	r3, #0
    8814:	f003 0301 	andne.w	r3, r3, #1
    8818:	f100 6008 	add.w	r0, r0, #142606336	; 0x8800000
    881c:	42b1      	cmp	r1, r6
    881e:	bf0c      	ite	eq
    8820:	2300      	moveq	r3, #0
    8822:	f003 0301 	andne.w	r3, r3, #1
    8826:	f500 60c0 	add.w	r0, r0, #1536	; 0x600
    882a:	f106 6606 	add.w	r6, r6, #140509184	; 0x8600000
    882e:	4281      	cmp	r1, r0
    8830:	bf0c      	ite	eq
    8832:	2300      	moveq	r3, #0
    8834:	f003 0301 	andne.w	r3, r3, #1
    8838:	4868      	ldr	r0, [pc, #416]	; (89dc <HAL_ADC_ConfigChannel+0x304>)
    883a:	f506 6640 	add.w	r6, r6, #3072	; 0xc00
    883e:	42b1      	cmp	r1, r6
    8840:	bf0c      	ite	eq
    8842:	2300      	moveq	r3, #0
    8844:	f003 0301 	andne.w	r3, r3, #1
    8848:	4e65      	ldr	r6, [pc, #404]	; (89e0 <HAL_ADC_ConfigChannel+0x308>)
    884a:	4281      	cmp	r1, r0
    884c:	bf0c      	ite	eq
    884e:	2300      	moveq	r3, #0
    8850:	f003 0301 	andne.w	r3, r3, #1
    8854:	4863      	ldr	r0, [pc, #396]	; (89e4 <HAL_ADC_ConfigChannel+0x30c>)
    8856:	42b1      	cmp	r1, r6
    8858:	bf0c      	ite	eq
    885a:	2300      	moveq	r3, #0
    885c:	f003 0301 	andne.w	r3, r3, #1
    8860:	4e61      	ldr	r6, [pc, #388]	; (89e8 <HAL_ADC_ConfigChannel+0x310>)
    8862:	4281      	cmp	r1, r0
    8864:	bf0c      	ite	eq
    8866:	2300      	moveq	r3, #0
    8868:	f003 0301 	andne.w	r3, r3, #1
    886c:	485f      	ldr	r0, [pc, #380]	; (89ec <HAL_ADC_ConfigChannel+0x314>)
    886e:	4960      	ldr	r1, [pc, #384]	; (89f0 <HAL_ADC_ConfigChannel+0x318>)
    8870:	42b2      	cmp	r2, r6
    8872:	bf0c      	ite	eq
    8874:	2300      	moveq	r3, #0
    8876:	f003 0301 	andne.w	r3, r3, #1
    887a:	4282      	cmp	r2, r0
    887c:	bf0c      	ite	eq
    887e:	2300      	moveq	r3, #0
    8880:	f003 0301 	andne.w	r3, r3, #1
    8884:	428a      	cmp	r2, r1
    8886:	bf0c      	ite	eq
    8888:	2300      	moveq	r3, #0
    888a:	f003 0301 	andne.w	r3, r3, #1
    888e:	2b00      	cmp	r3, #0
    8890:	d166      	bne.n	8960 <HAL_ADC_ConfigChannel+0x288>
  __HAL_LOCK(hadc);
    8892:	f895 3050 	ldrb.w	r3, [r5, #80]	; 0x50
    8896:	2b01      	cmp	r3, #1
    8898:	f000 82a2 	beq.w	8de0 <HAL_ADC_ConfigChannel+0x708>
    889c:	2001      	movs	r0, #1
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
    889e:	682a      	ldr	r2, [r5, #0]
  __HAL_LOCK(hadc);
    88a0:	f885 0050 	strb.w	r0, [r5, #80]	; 0x50
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    88a4:	6893      	ldr	r3, [r2, #8]
    88a6:	075b      	lsls	r3, r3, #29
    88a8:	d451      	bmi.n	894e <HAL_ADC_ConfigChannel+0x276>
    hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
    88aa:	6823      	ldr	r3, [r4, #0]
    88ac:	f3c3 0113 	ubfx	r1, r3, #0, #20
    88b0:	2900      	cmp	r1, #0
    88b2:	f040 81a2 	bne.w	8bfa <HAL_ADC_ConfigChannel+0x522>
    88b6:	f3c3 6384 	ubfx	r3, r3, #26, #5
    88ba:	4098      	lsls	r0, r3
    88bc:	69d3      	ldr	r3, [r2, #28]
  MODIFY_REG(*preg,
    88be:	271f      	movs	r7, #31
    88c0:	4318      	orrs	r0, r3
    88c2:	61d0      	str	r0, [r2, #28]
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
    88c4:	6862      	ldr	r2, [r4, #4]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
    88c6:	6829      	ldr	r1, [r5, #0]
    88c8:	0990      	lsrs	r0, r2, #6
  MODIFY_REG(*preg,
    88ca:	6823      	ldr	r3, [r4, #0]
    88cc:	403a      	ands	r2, r7
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
    88ce:	3130      	adds	r1, #48	; 0x30
    88d0:	f000 000c 	and.w	r0, r0, #12
  MODIFY_REG(*preg,
    88d4:	f3c3 6384 	ubfx	r3, r3, #26, #5
    88d8:	4097      	lsls	r7, r2
    88da:	5846      	ldr	r6, [r0, r1]
    88dc:	4093      	lsls	r3, r2
    88de:	ea26 0207 	bic.w	r2, r6, r7
    88e2:	4313      	orrs	r3, r2
    88e4:	5043      	str	r3, [r0, r1]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
    88e6:	682b      	ldr	r3, [r5, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    88e8:	689a      	ldr	r2, [r3, #8]
    88ea:	0757      	lsls	r7, r2, #29
    88ec:	f100 8183 	bmi.w	8bf6 <HAL_ADC_ConfigChannel+0x51e>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    88f0:	689e      	ldr	r6, [r3, #8]
    88f2:	f016 0608 	ands.w	r6, r6, #8
    88f6:	f000 80f1 	beq.w	8adc <HAL_ADC_ConfigChannel+0x404>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    88fa:	689a      	ldr	r2, [r3, #8]
    88fc:	07d6      	lsls	r6, r2, #31
    88fe:	d418      	bmi.n	8932 <HAL_ADC_ConfigChannel+0x25a>
  MODIFY_REG(ADCx->DIFSEL,
    8900:	68e1      	ldr	r1, [r4, #12]
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
    8902:	6826      	ldr	r6, [r4, #0]
    8904:	f001 0018 	and.w	r0, r1, #24
    8908:	4a3a      	ldr	r2, [pc, #232]	; (89f4 <HAL_ADC_ConfigChannel+0x31c>)
    890a:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    890e:	40c2      	lsrs	r2, r0
    8910:	f3c6 0013 	ubfx	r0, r6, #0, #20
    8914:	4032      	ands	r2, r6
    8916:	ea21 0100 	bic.w	r1, r1, r0
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
    891a:	4827      	ldr	r0, [pc, #156]	; (89b8 <HAL_ADC_ConfigChannel+0x2e0>)
    891c:	430a      	orrs	r2, r1
    891e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    8922:	68e3      	ldr	r3, [r4, #12]
    8924:	4283      	cmp	r3, r0
    8926:	f000 821c 	beq.w	8d62 <HAL_ADC_ConfigChannel+0x68a>
      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
    892a:	6822      	ldr	r2, [r4, #0]
    892c:	2a00      	cmp	r2, #0
    892e:	f2c0 81b6 	blt.w	8c9e <HAL_ADC_ConfigChannel+0x5c6>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    8932:	2000      	movs	r0, #0
    8934:	e00f      	b.n	8956 <HAL_ADC_ConfigChannel+0x27e>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
    8936:	4a30      	ldr	r2, [pc, #192]	; (89f8 <HAL_ADC_ConfigChannel+0x320>)
    8938:	40ca      	lsrs	r2, r1
    893a:	43d2      	mvns	r2, r2
    893c:	f002 0201 	and.w	r2, r2, #1
    8940:	e6f3      	b.n	872a <HAL_ADC_ConfigChannel+0x52>
    8942:	4b2e      	ldr	r3, [pc, #184]	; (89fc <HAL_ADC_ConfigChannel+0x324>)
    8944:	40cb      	lsrs	r3, r1
    8946:	43db      	mvns	r3, r3
    8948:	f003 0301 	and.w	r3, r3, #1
    894c:	e6e1      	b.n	8712 <HAL_ADC_ConfigChannel+0x3a>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    894e:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    8950:	f043 0320 	orr.w	r3, r3, #32
    8954:	656b      	str	r3, [r5, #84]	; 0x54
  __HAL_UNLOCK(hadc);
    8956:	2300      	movs	r3, #0
    8958:	f885 3050 	strb.w	r3, [r5, #80]	; 0x50
}
    895c:	b003      	add	sp, #12
    895e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_CHANNEL(sConfig->Channel));
    8960:	4b27      	ldr	r3, [pc, #156]	; (8a00 <HAL_ADC_ConfigChannel+0x328>)
    8962:	429a      	cmp	r2, r3
    8964:	d095      	beq.n	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8966:	f640 2174 	movw	r1, #2676	; 0xa74
    896a:	4826      	ldr	r0, [pc, #152]	; (8a04 <HAL_ADC_ConfigChannel+0x32c>)
    896c:	f010 fd52 	bl	19414 <assert_failed>
    8970:	e78f      	b.n	8892 <HAL_ADC_ConfigChannel+0x1ba>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
    8972:	f640 2161 	movw	r1, #2657	; 0xa61
    8976:	4823      	ldr	r0, [pc, #140]	; (8a04 <HAL_ADC_ConfigChannel+0x32c>)
    8978:	f010 fd4c 	bl	19414 <assert_failed>
  assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
    897c:	6923      	ldr	r3, [r4, #16]
    897e:	2b04      	cmp	r3, #4
    8980:	f67f aeea 	bls.w	8758 <HAL_ADC_ConfigChannel+0x80>
    8984:	f640 2162 	movw	r1, #2658	; 0xa62
    8988:	481e      	ldr	r0, [pc, #120]	; (8a04 <HAL_ADC_ConfigChannel+0x32c>)
    898a:	f010 fd43 	bl	19414 <assert_failed>
    898e:	e6e3      	b.n	8758 <HAL_ADC_ConfigChannel+0x80>
    if ((uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES)) == 0x0000001CUL)
    8990:	68d3      	ldr	r3, [r2, #12]
    8992:	f003 031c 	and.w	r3, r3, #28
    8996:	2b1c      	cmp	r3, #28
    8998:	f47f aeed 	bne.w	8776 <HAL_ADC_ConfigChannel+0x9e>
    899c:	23ff      	movs	r3, #255	; 0xff
    899e:	e6f1      	b.n	8784 <HAL_ADC_ConfigChannel+0xac>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    89a0:	f640 215e 	movw	r1, #2654	; 0xa5e
    89a4:	4817      	ldr	r0, [pc, #92]	; (8a04 <HAL_ADC_ConfigChannel+0x32c>)
    89a6:	f010 fd35 	bl	19414 <assert_failed>
    89aa:	e6a6      	b.n	86fa <HAL_ADC_ConfigChannel+0x22>
    89ac:	40022100 	.word	0x40022100
    89b0:	40022000 	.word	0x40022000
    89b4:	58026000 	.word	0x58026000
    89b8:	47ff0000 	.word	0x47ff0000
    89bc:	5c001000 	.word	0x5c001000
    89c0:	04300002 	.word	0x04300002
    89c4:	08600004 	.word	0x08600004
    89c8:	0c900008 	.word	0x0c900008
    89cc:	10c00010 	.word	0x10c00010
    89d0:	19200040 	.word	0x19200040
    89d4:	21800100 	.word	0x21800100
    89d8:	2a000400 	.word	0x2a000400
    89dc:	36902000 	.word	0x36902000
    89e0:	3ac04000 	.word	0x3ac04000
    89e4:	3ef08000 	.word	0x3ef08000
    89e8:	43210000 	.word	0x43210000
    89ec:	47520000 	.word	0x47520000
    89f0:	4b840000 	.word	0x4b840000
    89f4:	000fffff 	.word	0x000fffff
    89f8:	01041001 	.word	0x01041001
    89fc:	01041000 	.word	0x01041000
    8a00:	4fb80000 	.word	0x4fb80000
    8a04:	0002fb64 	.word	0x0002fb64
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
    8a08:	f640 216a 	movw	r1, #2666	; 0xa6a
    8a0c:	48bd      	ldr	r0, [pc, #756]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8a0e:	f010 fd01 	bl	19414 <assert_failed>
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
    8a12:	6923      	ldr	r3, [r4, #16]
    8a14:	2b04      	cmp	r3, #4
    8a16:	f43f aeb8 	beq.w	878a <HAL_ADC_ConfigChannel+0xb2>
    8a1a:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
    8a1e:	2b01      	cmp	r3, #1
    8a20:	f47f aeb3 	bne.w	878a <HAL_ADC_ConfigChannel+0xb2>
    8a24:	f640 216f 	movw	r1, #2671	; 0xa6f
    8a28:	48b6      	ldr	r0, [pc, #728]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8a2a:	f010 fcf3 	bl	19414 <assert_failed>
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
    8a2e:	4bb6      	ldr	r3, [pc, #728]	; (8d08 <HAL_ADC_ConfigChannel+0x630>)
    8a30:	68e2      	ldr	r2, [r4, #12]
    8a32:	429a      	cmp	r2, r3
    8a34:	f47f aeae 	bne.w	8794 <HAL_ADC_ConfigChannel+0xbc>
    if (hadc->Instance == ADC1)
    8a38:	682b      	ldr	r3, [r5, #0]
    8a3a:	4ab4      	ldr	r2, [pc, #720]	; (8d0c <HAL_ADC_ConfigChannel+0x634>)
    8a3c:	4293      	cmp	r3, r2
    8a3e:	f000 81d8 	beq.w	8df2 <HAL_ADC_ConfigChannel+0x71a>
    if (hadc->Instance == ADC2)
    8a42:	4ab3      	ldr	r2, [pc, #716]	; (8d10 <HAL_ADC_ConfigChannel+0x638>)
    8a44:	4293      	cmp	r3, r2
    8a46:	f000 80e7 	beq.w	8c18 <HAL_ADC_ConfigChannel+0x540>
    if (hadc->Instance == ADC3)
    8a4a:	4ab2      	ldr	r2, [pc, #712]	; (8d14 <HAL_ADC_ConfigChannel+0x63c>)
    8a4c:	4293      	cmp	r3, r2
    8a4e:	f47f af20 	bne.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
      assert_param(IS_ADC3_DIFF_CHANNEL(sConfig->Channel));
    8a52:	6822      	ldr	r2, [r4, #0]
    8a54:	4bb0      	ldr	r3, [pc, #704]	; (8d18 <HAL_ADC_ConfigChannel+0x640>)
    8a56:	48b1      	ldr	r0, [pc, #708]	; (8d1c <HAL_ADC_ConfigChannel+0x644>)
    8a58:	49b1      	ldr	r1, [pc, #708]	; (8d20 <HAL_ADC_ConfigChannel+0x648>)
    8a5a:	429a      	cmp	r2, r3
    8a5c:	bf18      	it	ne
    8a5e:	4282      	cmpne	r2, r0
    8a60:	48b0      	ldr	r0, [pc, #704]	; (8d24 <HAL_ADC_ConfigChannel+0x64c>)
    8a62:	bf14      	ite	ne
    8a64:	2301      	movne	r3, #1
    8a66:	2300      	moveq	r3, #0
    8a68:	428a      	cmp	r2, r1
    8a6a:	bf0c      	ite	eq
    8a6c:	2300      	moveq	r3, #0
    8a6e:	f003 0301 	andne.w	r3, r3, #1
    8a72:	f101 6106 	add.w	r1, r1, #140509184	; 0x8600000
    8a76:	4282      	cmp	r2, r0
    8a78:	bf0c      	ite	eq
    8a7a:	2300      	moveq	r3, #0
    8a7c:	f003 0301 	andne.w	r3, r3, #1
    8a80:	3118      	adds	r1, #24
    8a82:	48a9      	ldr	r0, [pc, #676]	; (8d28 <HAL_ADC_ConfigChannel+0x650>)
    8a84:	428a      	cmp	r2, r1
    8a86:	bf0c      	ite	eq
    8a88:	2300      	moveq	r3, #0
    8a8a:	f003 0301 	andne.w	r3, r3, #1
    8a8e:	f101 51ca 	add.w	r1, r1, #423624704	; 0x19400000
    8a92:	4282      	cmp	r2, r0
    8a94:	bf0c      	ite	eq
    8a96:	2300      	moveq	r3, #0
    8a98:	f003 0301 	andne.w	r3, r3, #1
    8a9c:	f501 61fc 	add.w	r1, r1, #2016	; 0x7e0
    8aa0:	48a2      	ldr	r0, [pc, #648]	; (8d2c <HAL_ADC_ConfigChannel+0x654>)
    8aa2:	428a      	cmp	r2, r1
    8aa4:	bf0c      	ite	eq
    8aa6:	2300      	moveq	r3, #0
    8aa8:	f003 0301 	andne.w	r3, r3, #1
    8aac:	49a0      	ldr	r1, [pc, #640]	; (8d30 <HAL_ADC_ConfigChannel+0x658>)
    8aae:	4282      	cmp	r2, r0
    8ab0:	bf0c      	ite	eq
    8ab2:	2300      	moveq	r3, #0
    8ab4:	f003 0301 	andne.w	r3, r3, #1
    8ab8:	428a      	cmp	r2, r1
    8aba:	bf0c      	ite	eq
    8abc:	2300      	moveq	r3, #0
    8abe:	f003 0301 	andne.w	r3, r3, #1
    8ac2:	2b00      	cmp	r3, #0
    8ac4:	f43f aee5 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8ac8:	4b9a      	ldr	r3, [pc, #616]	; (8d34 <HAL_ADC_ConfigChannel+0x65c>)
    8aca:	429a      	cmp	r2, r3
    8acc:	f43f aee1 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8ad0:	f640 2184 	movw	r1, #2692	; 0xa84
    8ad4:	488b      	ldr	r0, [pc, #556]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8ad6:	f010 fc9d 	bl	19414 <assert_failed>
    8ada:	e6da      	b.n	8892 <HAL_ADC_ConfigChannel+0x1ba>
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
    8adc:	6821      	ldr	r1, [r4, #0]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8ade:	3314      	adds	r3, #20
  MODIFY_REG(*preg,
    8ae0:	2207      	movs	r2, #7
    8ae2:	68a7      	ldr	r7, [r4, #8]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8ae4:	0dc8      	lsrs	r0, r1, #23
  MODIFY_REG(*preg,
    8ae6:	f3c1 5104 	ubfx	r1, r1, #20, #5
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8aea:	f000 0004 	and.w	r0, r0, #4
  MODIFY_REG(*preg,
    8aee:	fa02 fc01 	lsl.w	ip, r2, r1
    8af2:	fa07 f101 	lsl.w	r1, r7, r1
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
    8af6:	4f90      	ldr	r7, [pc, #576]	; (8d38 <HAL_ADC_ConfigChannel+0x660>)
    8af8:	58c2      	ldr	r2, [r0, r3]
    8afa:	ea22 020c 	bic.w	r2, r2, ip
    8afe:	430a      	orrs	r2, r1
    8b00:	50c2      	str	r2, [r0, r3]
    8b02:	683b      	ldr	r3, [r7, #0]
    8b04:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
    8b08:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
    8b0c:	f000 8120 	beq.w	8d50 <HAL_ADC_ConfigChannel+0x678>
    8b10:	682b      	ldr	r3, [r5, #0]
    8b12:	6962      	ldr	r2, [r4, #20]
    8b14:	68d9      	ldr	r1, [r3, #12]
    8b16:	f011 0f10 	tst.w	r1, #16
    8b1a:	68d9      	ldr	r1, [r3, #12]
    8b1c:	f040 81ce 	bne.w	8ebc <HAL_ADC_ConfigChannel+0x7e4>
    8b20:	f3c1 0182 	ubfx	r1, r1, #2, #3
    8b24:	0049      	lsls	r1, r1, #1
    8b26:	fa02 f101 	lsl.w	r1, r2, r1
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
    8b2a:	6920      	ldr	r0, [r4, #16]
    8b2c:	6822      	ldr	r2, [r4, #0]
    8b2e:	2804      	cmp	r0, #4
    8b30:	f000 81a8 	beq.w	8e84 <HAL_ADC_ConfigChannel+0x7ac>
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
    8b34:	3360      	adds	r3, #96	; 0x60
  MODIFY_REG(*preg,
    8b36:	f002 42f8 	and.w	r2, r2, #2080374784	; 0x7c000000
    8b3a:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
    8b3e:	430a      	orrs	r2, r1
    8b40:	f007 4100 	and.w	r1, r7, #2147483648	; 0x80000000
    8b44:	430a      	orrs	r2, r1
    8b46:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetSignedSaturation));
    8b4a:	7e63      	ldrb	r3, [r4, #25]
    8b4c:	2b01      	cmp	r3, #1
    8b4e:	d905      	bls.n	8b5c <HAL_ADC_ConfigChannel+0x484>
    8b50:	f640 21b2 	movw	r1, #2738	; 0xab2
    8b54:	486b      	ldr	r0, [pc, #428]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8b56:	f010 fc5d 	bl	19414 <assert_failed>
    8b5a:	7e63      	ldrb	r3, [r4, #25]
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSignedSaturation == ENABLE) ? LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE : LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
    8b5c:	682a      	ldr	r2, [r5, #0]
    8b5e:	2b01      	cmp	r3, #1
    8b60:	6921      	ldr	r1, [r4, #16]
   register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
    8b62:	f102 0260 	add.w	r2, r2, #96	; 0x60
    8b66:	bf14      	ite	ne
    8b68:	2000      	movne	r0, #0
    8b6a:	f04f 4000 	moveq.w	r0, #2147483648	; 0x80000000
   MODIFY_REG(*preg, ADC_OFR1_SSATE, OffsetSignedSaturation);
    8b6e:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
    8b72:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    8b76:	4303      	orrs	r3, r0
    8b78:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetRightShift));
    8b7c:	7e23      	ldrb	r3, [r4, #24]
    8b7e:	2b01      	cmp	r3, #1
    8b80:	d905      	bls.n	8b8e <HAL_ADC_ConfigChannel+0x4b6>
    8b82:	f640 21b6 	movw	r1, #2742	; 0xab6
    8b86:	485f      	ldr	r0, [pc, #380]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8b88:	f010 fc44 	bl	19414 <assert_failed>
    8b8c:	7e23      	ldrb	r3, [r4, #24]
        LL_ADC_SetDataRightShift(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetRightShift == ENABLE) ? LL_ADC_OFFSET_RSHIFT_ENABLE : LL_ADC_OFFSET_RSHIFT_DISABLE);
    8b8e:	2b01      	cmp	r3, #1
    8b90:	682a      	ldr	r2, [r5, #0]
    8b92:	6921      	ldr	r1, [r4, #16]
    8b94:	d104      	bne.n	8ba0 <HAL_ADC_ConfigChannel+0x4c8>
    8b96:	f001 011f 	and.w	r1, r1, #31
    8b9a:	f44f 6600 	mov.w	r6, #2048	; 0x800
    8b9e:	408e      	lsls	r6, r1
  MODIFY_REG(ADCx->CFGR2, (ADC_CFGR2_RSHIFT1 | ADC_CFGR2_RSHIFT2 | ADC_CFGR2_RSHIFT3 | ADC_CFGR2_RSHIFT4), RigthShift << (Offsety & 0x1FUL));
    8ba0:	6913      	ldr	r3, [r2, #16]
    8ba2:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    8ba6:	431e      	orrs	r6, r3
    8ba8:	6116      	str	r6, [r2, #16]
    8baa:	682b      	ldr	r3, [r5, #0]
    8bac:	e6a5      	b.n	88fa <HAL_ADC_ConfigChannel+0x222>
  if((DBGMCU->IDCODE & 0x30000000UL) == 0x10000000UL) /* Rev.Y */
    8bae:	681b      	ldr	r3, [r3, #0]
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset/(hadc->Init.Oversampling.Ratio+1U)));
    8bb0:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    8bb2:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
    8bb6:	3001      	adds	r0, #1
    8bb8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
    8bbc:	fbb1 f1f0 	udiv	r1, r1, r0
    8bc0:	d123      	bne.n	8c0a <HAL_ADC_ConfigChannel+0x532>
      return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
    8bc2:	68d2      	ldr	r2, [r2, #12]
    8bc4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8bc8:	0852      	lsrs	r2, r2, #1
    8bca:	f002 020e 	and.w	r2, r2, #14
    8bce:	40d3      	lsrs	r3, r2
    8bd0:	4299      	cmp	r1, r3
    8bd2:	f200 8108 	bhi.w	8de6 <HAL_ADC_ConfigChannel+0x70e>
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
    8bd6:	6923      	ldr	r3, [r4, #16]
    8bd8:	2b04      	cmp	r3, #4
    8bda:	f43f add6 	beq.w	878a <HAL_ADC_ConfigChannel+0xb2>
    8bde:	f640 216f 	movw	r1, #2671	; 0xa6f
    8be2:	4848      	ldr	r0, [pc, #288]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8be4:	f010 fc16 	bl	19414 <assert_failed>
    8be8:	e721      	b.n	8a2e <HAL_ADC_ConfigChannel+0x356>
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
    8bea:	f44f 6126 	mov.w	r1, #2656	; 0xa60
    8bee:	4845      	ldr	r0, [pc, #276]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8bf0:	f010 fc10 	bl	19414 <assert_failed>
    8bf4:	e5a3      	b.n	873e <HAL_ADC_ConfigChannel+0x66>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    8bf6:	689a      	ldr	r2, [r3, #8]
    8bf8:	e67f      	b.n	88fa <HAL_ADC_ConfigChannel+0x222>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    8bfa:	fa93 f3a3 	rbit	r3, r3
    hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
    8bfe:	fab3 f383 	clz	r3, r3
    8c02:	f003 031f 	and.w	r3, r3, #31
    8c06:	4098      	lsls	r0, r3
    8c08:	e658      	b.n	88bc <HAL_ADC_ConfigChannel+0x1e4>
    if ((uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES)) == 0x0000001CUL)
    8c0a:	68d3      	ldr	r3, [r2, #12]
    8c0c:	f003 031c 	and.w	r3, r3, #28
    8c10:	2b1c      	cmp	r3, #28
    8c12:	d1d6      	bne.n	8bc2 <HAL_ADC_ConfigChannel+0x4ea>
    8c14:	23ff      	movs	r3, #255	; 0xff
    8c16:	e7db      	b.n	8bd0 <HAL_ADC_ConfigChannel+0x4f8>
      assert_param(IS_ADC2_DIFF_CHANNEL(sConfig->Channel));
    8c18:	6822      	ldr	r2, [r4, #0]
    8c1a:	4b3f      	ldr	r3, [pc, #252]	; (8d18 <HAL_ADC_ConfigChannel+0x640>)
    8c1c:	493f      	ldr	r1, [pc, #252]	; (8d1c <HAL_ADC_ConfigChannel+0x644>)
    8c1e:	4840      	ldr	r0, [pc, #256]	; (8d20 <HAL_ADC_ConfigChannel+0x648>)
    8c20:	429a      	cmp	r2, r3
    8c22:	bf18      	it	ne
    8c24:	428a      	cmpne	r2, r1
    8c26:	493f      	ldr	r1, [pc, #252]	; (8d24 <HAL_ADC_ConfigChannel+0x64c>)
    8c28:	bf14      	ite	ne
    8c2a:	2301      	movne	r3, #1
    8c2c:	2300      	moveq	r3, #0
    8c2e:	4282      	cmp	r2, r0
    8c30:	bf0c      	ite	eq
    8c32:	2300      	moveq	r3, #0
    8c34:	f003 0301 	andne.w	r3, r3, #1
    8c38:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
    8c3c:	428a      	cmp	r2, r1
    8c3e:	bf0c      	ite	eq
    8c40:	2300      	moveq	r3, #0
    8c42:	f003 0301 	andne.w	r3, r3, #1
    8c46:	3018      	adds	r0, #24
    8c48:	4937      	ldr	r1, [pc, #220]	; (8d28 <HAL_ADC_ConfigChannel+0x650>)
    8c4a:	4282      	cmp	r2, r0
    8c4c:	bf0c      	ite	eq
    8c4e:	2300      	moveq	r3, #0
    8c50:	f003 0301 	andne.w	r3, r3, #1
    8c54:	f100 50ca 	add.w	r0, r0, #423624704	; 0x19400000
    8c58:	428a      	cmp	r2, r1
    8c5a:	bf0c      	ite	eq
    8c5c:	2300      	moveq	r3, #0
    8c5e:	f003 0301 	andne.w	r3, r3, #1
    8c62:	f500 60fc 	add.w	r0, r0, #2016	; 0x7e0
    8c66:	f101 6106 	add.w	r1, r1, #140509184	; 0x8600000
    8c6a:	4282      	cmp	r2, r0
    8c6c:	bf0c      	ite	eq
    8c6e:	2300      	moveq	r3, #0
    8c70:	f003 0301 	andne.w	r3, r3, #1
    8c74:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
    8c78:	428a      	cmp	r2, r1
    8c7a:	bf0c      	ite	eq
    8c7c:	2300      	moveq	r3, #0
    8c7e:	f003 0301 	andne.w	r3, r3, #1
    8c82:	2b00      	cmp	r3, #0
    8c84:	f43f ae05 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8c88:	4b2c      	ldr	r3, [pc, #176]	; (8d3c <HAL_ADC_ConfigChannel+0x664>)
    8c8a:	429a      	cmp	r2, r3
    8c8c:	f43f ae01 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8c90:	f640 217e 	movw	r1, #2686	; 0xa7e
    8c94:	481b      	ldr	r0, [pc, #108]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8c96:	f010 fbbd 	bl	19414 <assert_failed>
    8c9a:	682b      	ldr	r3, [r5, #0]
    8c9c:	e6d5      	b.n	8a4a <HAL_ADC_ConfigChannel+0x372>
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8c9e:	6829      	ldr	r1, [r5, #0]
    8ca0:	4b1a      	ldr	r3, [pc, #104]	; (8d0c <HAL_ADC_ConfigChannel+0x634>)
    8ca2:	4299      	cmp	r1, r3
    8ca4:	f000 813d 	beq.w	8f22 <HAL_ADC_ConfigChannel+0x84a>
    8ca8:	f503 7380 	add.w	r3, r3, #256	; 0x100
    8cac:	4299      	cmp	r1, r3
    8cae:	f000 8138 	beq.w	8f22 <HAL_ADC_ConfigChannel+0x84a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8cb2:	4e18      	ldr	r6, [pc, #96]	; (8d14 <HAL_ADC_ConfigChannel+0x63c>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8cb4:	4c22      	ldr	r4, [pc, #136]	; (8d40 <HAL_ADC_ConfigChannel+0x668>)
    8cb6:	68a0      	ldr	r0, [r4, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8cb8:	68b3      	ldr	r3, [r6, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8cba:	f000 76e0 	and.w	r6, r0, #29360128	; 0x1c00000
    8cbe:	43db      	mvns	r3, r3
    8cc0:	f003 0301 	and.w	r3, r3, #1
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    8cc4:	2b00      	cmp	r3, #0
    8cc6:	f000 8141 	beq.w	8f4c <HAL_ADC_ConfigChannel+0x874>
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
    8cca:	4b1e      	ldr	r3, [pc, #120]	; (8d44 <HAL_ADC_ConfigChannel+0x66c>)
    8ccc:	429a      	cmp	r2, r3
    8cce:	f000 8160 	beq.w	8f92 <HAL_ADC_ConfigChannel+0x8ba>
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
    8cd2:	4b1d      	ldr	r3, [pc, #116]	; (8d48 <HAL_ADC_ConfigChannel+0x670>)
    8cd4:	429a      	cmp	r2, r3
    8cd6:	f000 817e 	beq.w	8fd6 <HAL_ADC_ConfigChannel+0x8fe>
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
    8cda:	4b1c      	ldr	r3, [pc, #112]	; (8d4c <HAL_ADC_ConfigChannel+0x674>)
    8cdc:	429a      	cmp	r2, r3
    8cde:	f47f ae28 	bne.w	8932 <HAL_ADC_ConfigChannel+0x25a>
            if (ADC_VREFINT_INSTANCE(hadc))
    8ce2:	0243      	lsls	r3, r0, #9
    8ce4:	f53f ae25 	bmi.w	8932 <HAL_ADC_ConfigChannel+0x25a>
    8ce8:	4b0a      	ldr	r3, [pc, #40]	; (8d14 <HAL_ADC_ConfigChannel+0x63c>)
    8cea:	4299      	cmp	r1, r3
    8cec:	f47f ae21 	bne.w	8932 <HAL_ADC_ConfigChannel+0x25a>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
    8cf0:	68a2      	ldr	r2, [r4, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
    8cf2:	f446 0380 	orr.w	r3, r6, #4194304	; 0x400000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    8cf6:	2000      	movs	r0, #0
    8cf8:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
    8cfc:	4313      	orrs	r3, r2
    8cfe:	60a3      	str	r3, [r4, #8]
    8d00:	e629      	b.n	8956 <HAL_ADC_ConfigChannel+0x27e>
    8d02:	bf00      	nop
    8d04:	0002fb64 	.word	0x0002fb64
    8d08:	47ff0000 	.word	0x47ff0000
    8d0c:	40022000 	.word	0x40022000
    8d10:	40022100 	.word	0x40022100
    8d14:	58026000 	.word	0x58026000
    8d18:	04300002 	.word	0x04300002
    8d1c:	08600004 	.word	0x08600004
    8d20:	0c900008 	.word	0x0c900008
    8d24:	10c00010 	.word	0x10c00010
    8d28:	2a000400 	.word	0x2a000400
    8d2c:	36902000 	.word	0x36902000
    8d30:	3ac04000 	.word	0x3ac04000
    8d34:	3ef08000 	.word	0x3ef08000
    8d38:	5c001000 	.word	0x5c001000
    8d3c:	4b840000 	.word	0x4b840000
    8d40:	58026300 	.word	0x58026300
    8d44:	cb840000 	.word	0xcb840000
    8d48:	c7520000 	.word	0xc7520000
    8d4c:	cfb80000 	.word	0xcfb80000
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
    8d50:	682b      	ldr	r3, [r5, #0]
    8d52:	6962      	ldr	r2, [r4, #20]
    8d54:	68d9      	ldr	r1, [r3, #12]
    8d56:	f3c1 0182 	ubfx	r1, r1, #2, #3
    8d5a:	0049      	lsls	r1, r1, #1
    8d5c:	fa02 f101 	lsl.w	r1, r2, r1
    8d60:	e6e3      	b.n	8b2a <HAL_ADC_ConfigChannel+0x452>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8d62:	6822      	ldr	r2, [r4, #0]
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8d64:	6829      	ldr	r1, [r5, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8d66:	f3c2 0313 	ubfx	r3, r2, #0, #20
    8d6a:	2b00      	cmp	r3, #0
    8d6c:	f000 80ac 	beq.w	8ec8 <HAL_ADC_ConfigChannel+0x7f0>
    8d70:	fa92 f3a2 	rbit	r3, r2
    8d74:	fab3 f383 	clz	r3, r3
    8d78:	3301      	adds	r3, #1
    8d7a:	f003 031f 	and.w	r3, r3, #31
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8d7e:	2b09      	cmp	r3, #9
    8d80:	f200 80ea 	bhi.w	8f58 <HAL_ADC_ConfigChannel+0x880>
    8d84:	fa92 f3a2 	rbit	r3, r2
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8d88:	fab3 f383 	clz	r3, r3
    8d8c:	fa92 f0a2 	rbit	r0, r2
    8d90:	2601      	movs	r6, #1
    8d92:	fab0 f080 	clz	r0, r0
    8d96:	3301      	adds	r3, #1
    8d98:	4430      	add	r0, r6
    8d9a:	069b      	lsls	r3, r3, #26
    8d9c:	f000 001f 	and.w	r0, r0, #31
    8da0:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
    8da4:	fa06 f000 	lsl.w	r0, r6, r0
    8da8:	4303      	orrs	r3, r0
    8daa:	fa92 f2a2 	rbit	r2, r2
    8dae:	fab2 f282 	clz	r2, r2
    8db2:	4432      	add	r2, r6
    8db4:	f002 021f 	and.w	r2, r2, #31
    8db8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    8dbc:	0512      	lsls	r2, r2, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8dbe:	431a      	orrs	r2, r3
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8dc0:	3114      	adds	r1, #20
  MODIFY_REG(*preg,
    8dc2:	2707      	movs	r7, #7
    8dc4:	68a3      	ldr	r3, [r4, #8]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8dc6:	0dd6      	lsrs	r6, r2, #23
  MODIFY_REG(*preg,
    8dc8:	f3c2 5204 	ubfx	r2, r2, #20, #5
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8dcc:	f006 0604 	and.w	r6, r6, #4
  MODIFY_REG(*preg,
    8dd0:	4097      	lsls	r7, r2
    8dd2:	4093      	lsls	r3, r2
    8dd4:	5870      	ldr	r0, [r6, r1]
    8dd6:	ea20 0207 	bic.w	r2, r0, r7
    8dda:	431a      	orrs	r2, r3
    8ddc:	5072      	str	r2, [r6, r1]
    8dde:	e5a4      	b.n	892a <HAL_ADC_ConfigChannel+0x252>
  __HAL_LOCK(hadc);
    8de0:	2002      	movs	r0, #2
}
    8de2:	b003      	add	sp, #12
    8de4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset/(hadc->Init.Oversampling.Ratio+1U)));
    8de6:	f640 2166 	movw	r1, #2662	; 0xa66
    8dea:	4883      	ldr	r0, [pc, #524]	; (8ff8 <HAL_ADC_ConfigChannel+0x920>)
    8dec:	f010 fb12 	bl	19414 <assert_failed>
    8df0:	e60f      	b.n	8a12 <HAL_ADC_ConfigChannel+0x33a>
      assert_param(IS_ADC1_DIFF_CHANNEL(sConfig->Channel));
    8df2:	6822      	ldr	r2, [r4, #0]
    8df4:	4b81      	ldr	r3, [pc, #516]	; (8ffc <HAL_ADC_ConfigChannel+0x924>)
    8df6:	4882      	ldr	r0, [pc, #520]	; (9000 <HAL_ADC_ConfigChannel+0x928>)
    8df8:	4982      	ldr	r1, [pc, #520]	; (9004 <HAL_ADC_ConfigChannel+0x92c>)
    8dfa:	429a      	cmp	r2, r3
    8dfc:	bf18      	it	ne
    8dfe:	4282      	cmpne	r2, r0
    8e00:	4881      	ldr	r0, [pc, #516]	; (9008 <HAL_ADC_ConfigChannel+0x930>)
    8e02:	bf14      	ite	ne
    8e04:	2301      	movne	r3, #1
    8e06:	2300      	moveq	r3, #0
    8e08:	428a      	cmp	r2, r1
    8e0a:	bf0c      	ite	eq
    8e0c:	2300      	moveq	r3, #0
    8e0e:	f003 0301 	andne.w	r3, r3, #1
    8e12:	f101 6106 	add.w	r1, r1, #140509184	; 0x8600000
    8e16:	4282      	cmp	r2, r0
    8e18:	bf0c      	ite	eq
    8e1a:	2300      	moveq	r3, #0
    8e1c:	f003 0301 	andne.w	r3, r3, #1
    8e20:	3118      	adds	r1, #24
    8e22:	487a      	ldr	r0, [pc, #488]	; (900c <HAL_ADC_ConfigChannel+0x934>)
    8e24:	428a      	cmp	r2, r1
    8e26:	bf0c      	ite	eq
    8e28:	2300      	moveq	r3, #0
    8e2a:	f003 0301 	andne.w	r3, r3, #1
    8e2e:	f101 51ca 	add.w	r1, r1, #423624704	; 0x19400000
    8e32:	4282      	cmp	r2, r0
    8e34:	bf0c      	ite	eq
    8e36:	2300      	moveq	r3, #0
    8e38:	f003 0301 	andne.w	r3, r3, #1
    8e3c:	f501 61fc 	add.w	r1, r1, #2016	; 0x7e0
    8e40:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
    8e44:	428a      	cmp	r2, r1
    8e46:	bf0c      	ite	eq
    8e48:	2300      	moveq	r3, #0
    8e4a:	f003 0301 	andne.w	r3, r3, #1
    8e4e:	4970      	ldr	r1, [pc, #448]	; (9010 <HAL_ADC_ConfigChannel+0x938>)
    8e50:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
    8e54:	4282      	cmp	r2, r0
    8e56:	bf0c      	ite	eq
    8e58:	2300      	moveq	r3, #0
    8e5a:	f003 0301 	andne.w	r3, r3, #1
    8e5e:	428a      	cmp	r2, r1
    8e60:	bf0c      	ite	eq
    8e62:	2300      	moveq	r3, #0
    8e64:	f003 0301 	andne.w	r3, r3, #1
    8e68:	2b00      	cmp	r3, #0
    8e6a:	f43f ad12 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8e6e:	4b69      	ldr	r3, [pc, #420]	; (9014 <HAL_ADC_ConfigChannel+0x93c>)
    8e70:	429a      	cmp	r2, r3
    8e72:	f43f ad0e 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8e76:	f640 217a 	movw	r1, #2682	; 0xa7a
    8e7a:	485f      	ldr	r0, [pc, #380]	; (8ff8 <HAL_ADC_ConfigChannel+0x920>)
    8e7c:	f010 faca 	bl	19414 <assert_failed>
    8e80:	682b      	ldr	r3, [r5, #0]
    8e82:	e5de      	b.n	8a42 <HAL_ADC_ConfigChannel+0x36a>
          if (((hadc->Instance->OFR1) & ADC_OFR1_OFFSET1_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    8e84:	6e19      	ldr	r1, [r3, #96]	; 0x60
    8e86:	0692      	lsls	r2, r2, #26
    8e88:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    8e8c:	4291      	cmp	r1, r2
    8e8e:	d040      	beq.n	8f12 <HAL_ADC_ConfigChannel+0x83a>
          if (((hadc->Instance->OFR2) & ADC_OFR2_OFFSET2_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    8e90:	6e59      	ldr	r1, [r3, #100]	; 0x64
    8e92:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    8e96:	4291      	cmp	r1, r2
    8e98:	d033      	beq.n	8f02 <HAL_ADC_ConfigChannel+0x82a>
          if (((hadc->Instance->OFR3) & ADC_OFR3_OFFSET3_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    8e9a:	6e99      	ldr	r1, [r3, #104]	; 0x68
    8e9c:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    8ea0:	4291      	cmp	r1, r2
    8ea2:	d026      	beq.n	8ef2 <HAL_ADC_ConfigChannel+0x81a>
          if (((hadc->Instance->OFR4) & ADC_OFR4_OFFSET4_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    8ea4:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
    8ea6:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    8eaa:	4291      	cmp	r1, r2
    8eac:	f47f ad25 	bne.w	88fa <HAL_ADC_ConfigChannel+0x222>
            CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_SSATE);
    8eb0:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    8eb2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    8eb6:	66da      	str	r2, [r3, #108]	; 0x6c
    8eb8:	682b      	ldr	r3, [r5, #0]
    8eba:	e51e      	b.n	88fa <HAL_ADC_ConfigChannel+0x222>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
    8ebc:	0849      	lsrs	r1, r1, #1
    8ebe:	f001 0108 	and.w	r1, r1, #8
    8ec2:	fa02 f101 	lsl.w	r1, r2, r1
    8ec6:	e630      	b.n	8b2a <HAL_ADC_ConfigChannel+0x452>
    8ec8:	2601      	movs	r6, #1
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8eca:	0e92      	lsrs	r2, r2, #26
    8ecc:	4432      	add	r2, r6
    8ece:	f002 001f 	and.w	r0, r2, #31
    8ed2:	0693      	lsls	r3, r2, #26
    8ed4:	4086      	lsls	r6, r0
    8ed6:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8eda:	2809      	cmp	r0, #9
    8edc:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    8ee0:	ea43 0306 	orr.w	r3, r3, r6
    8ee4:	f67f af6a 	bls.w	8dbc <HAL_ADC_ConfigChannel+0x6e4>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8ee8:	3a1e      	subs	r2, #30
    8eea:	0512      	lsls	r2, r2, #20
    8eec:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    8ef0:	e765      	b.n	8dbe <HAL_ADC_ConfigChannel+0x6e6>
            CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_SSATE);
    8ef2:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    8ef4:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    8ef8:	669a      	str	r2, [r3, #104]	; 0x68
    8efa:	6822      	ldr	r2, [r4, #0]
    8efc:	682b      	ldr	r3, [r5, #0]
    8efe:	0692      	lsls	r2, r2, #26
    8f00:	e7d0      	b.n	8ea4 <HAL_ADC_ConfigChannel+0x7cc>
            CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_SSATE);
    8f02:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    8f04:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    8f08:	665a      	str	r2, [r3, #100]	; 0x64
    8f0a:	6822      	ldr	r2, [r4, #0]
    8f0c:	682b      	ldr	r3, [r5, #0]
    8f0e:	0692      	lsls	r2, r2, #26
    8f10:	e7c3      	b.n	8e9a <HAL_ADC_ConfigChannel+0x7c2>
            CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_SSATE);
    8f12:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    8f14:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    8f18:	661a      	str	r2, [r3, #96]	; 0x60
    8f1a:	6822      	ldr	r2, [r4, #0]
    8f1c:	682b      	ldr	r3, [r5, #0]
    8f1e:	0692      	lsls	r2, r2, #26
    8f20:	e7b6      	b.n	8e90 <HAL_ADC_ConfigChannel+0x7b8>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8f22:	4b3d      	ldr	r3, [pc, #244]	; (9018 <HAL_ADC_ConfigChannel+0x940>)
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8f24:	4e3d      	ldr	r6, [pc, #244]	; (901c <HAL_ADC_ConfigChannel+0x944>)
    8f26:	4f3e      	ldr	r7, [pc, #248]	; (9020 <HAL_ADC_ConfigChannel+0x948>)
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8f28:	461c      	mov	r4, r3
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8f2a:	6898      	ldr	r0, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8f2c:	68bf      	ldr	r7, [r7, #8]
    8f2e:	68b3      	ldr	r3, [r6, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8f30:	f000 76e0 	and.w	r6, r0, #29360128	; 0x1c00000
    8f34:	433b      	orrs	r3, r7
    8f36:	43db      	mvns	r3, r3
    8f38:	f003 0301 	and.w	r3, r3, #1
    8f3c:	e6c2      	b.n	8cc4 <HAL_ADC_ConfigChannel+0x5ec>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
    8f3e:	f640 215f 	movw	r1, #2655	; 0xa5f
    8f42:	482d      	ldr	r0, [pc, #180]	; (8ff8 <HAL_ADC_ConfigChannel+0x920>)
    8f44:	f010 fa66 	bl	19414 <assert_failed>
    8f48:	f7ff bbf5 	b.w	8736 <HAL_ADC_ConfigChannel+0x5e>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    8f4c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
          tmp_hal_status = HAL_ERROR;
    8f4e:	2001      	movs	r0, #1
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    8f50:	f043 0320 	orr.w	r3, r3, #32
    8f54:	656b      	str	r3, [r5, #84]	; 0x54
    8f56:	e4fe      	b.n	8956 <HAL_ADC_ConfigChannel+0x27e>
    8f58:	fa92 f3a2 	rbit	r3, r2
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8f5c:	fab3 f383 	clz	r3, r3
    8f60:	fa92 f0a2 	rbit	r0, r2
    8f64:	2601      	movs	r6, #1
    8f66:	fab0 f080 	clz	r0, r0
    8f6a:	3301      	adds	r3, #1
    8f6c:	4430      	add	r0, r6
    8f6e:	069b      	lsls	r3, r3, #26
    8f70:	f000 001f 	and.w	r0, r0, #31
    8f74:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
    8f78:	fa06 f000 	lsl.w	r0, r6, r0
    8f7c:	4303      	orrs	r3, r0
    8f7e:	fa92 f2a2 	rbit	r2, r2
    8f82:	fab2 f282 	clz	r2, r2
    8f86:	4432      	add	r2, r6
    8f88:	f002 021f 	and.w	r2, r2, #31
    8f8c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    8f90:	e7aa      	b.n	8ee8 <HAL_ADC_ConfigChannel+0x810>
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
    8f92:	0200      	lsls	r0, r0, #8
    8f94:	f53f accd 	bmi.w	8932 <HAL_ADC_ConfigChannel+0x25a>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
    8f98:	4b22      	ldr	r3, [pc, #136]	; (9024 <HAL_ADC_ConfigChannel+0x94c>)
    8f9a:	4299      	cmp	r1, r3
    8f9c:	f47f acc9 	bne.w	8932 <HAL_ADC_ConfigChannel+0x25a>
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
    8fa0:	4b21      	ldr	r3, [pc, #132]	; (9028 <HAL_ADC_ConfigChannel+0x950>)
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
    8fa2:	f446 0200 	orr.w	r2, r6, #8388608	; 0x800000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
    8fa6:	68a1      	ldr	r1, [r4, #8]
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
    8fa8:	681b      	ldr	r3, [r3, #0]
    8faa:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
    8fae:	481f      	ldr	r0, [pc, #124]	; (902c <HAL_ADC_ConfigChannel+0x954>)
    8fb0:	099b      	lsrs	r3, r3, #6
    8fb2:	430a      	orrs	r2, r1
    8fb4:	fba0 1303 	umull	r1, r3, r0, r3
    8fb8:	60a2      	str	r2, [r4, #8]
    8fba:	099b      	lsrs	r3, r3, #6
    8fbc:	005b      	lsls	r3, r3, #1
    8fbe:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0UL)
    8fc0:	9b01      	ldr	r3, [sp, #4]
    8fc2:	2b00      	cmp	r3, #0
    8fc4:	f43f acb5 	beq.w	8932 <HAL_ADC_ConfigChannel+0x25a>
                wait_loop_index--;
    8fc8:	9b01      	ldr	r3, [sp, #4]
    8fca:	3b01      	subs	r3, #1
    8fcc:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0UL)
    8fce:	9b01      	ldr	r3, [sp, #4]
    8fd0:	2b00      	cmp	r3, #0
    8fd2:	d1f9      	bne.n	8fc8 <HAL_ADC_ConfigChannel+0x8f0>
    8fd4:	e4ad      	b.n	8932 <HAL_ADC_ConfigChannel+0x25a>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
    8fd6:	01c2      	lsls	r2, r0, #7
    8fd8:	f53f acab 	bmi.w	8932 <HAL_ADC_ConfigChannel+0x25a>
    8fdc:	4b11      	ldr	r3, [pc, #68]	; (9024 <HAL_ADC_ConfigChannel+0x94c>)
    8fde:	4299      	cmp	r1, r3
    8fe0:	f47f aca7 	bne.w	8932 <HAL_ADC_ConfigChannel+0x25a>
    8fe4:	68a2      	ldr	r2, [r4, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
    8fe6:	f046 7380 	orr.w	r3, r6, #16777216	; 0x1000000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    8fea:	2000      	movs	r0, #0
    8fec:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
    8ff0:	4313      	orrs	r3, r2
    8ff2:	60a3      	str	r3, [r4, #8]
    8ff4:	e4af      	b.n	8956 <HAL_ADC_ConfigChannel+0x27e>
    8ff6:	bf00      	nop
    8ff8:	0002fb64 	.word	0x0002fb64
    8ffc:	04300002 	.word	0x04300002
    9000:	08600004 	.word	0x08600004
    9004:	0c900008 	.word	0x0c900008
    9008:	10c00010 	.word	0x10c00010
    900c:	2a000400 	.word	0x2a000400
    9010:	43210000 	.word	0x43210000
    9014:	4b840000 	.word	0x4b840000
    9018:	40022300 	.word	0x40022300
    901c:	40022100 	.word	0x40022100
    9020:	40022000 	.word	0x40022000
    9024:	58026000 	.word	0x58026000
    9028:	0006280c 	.word	0x0006280c
    902c:	053e2d63 	.word	0x053e2d63

00009030 <ADC_Disable>:
{
    9030:	b538      	push	{r3, r4, r5, lr}
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
    9032:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
    9034:	6899      	ldr	r1, [r3, #8]
    9036:	0789      	lsls	r1, r1, #30
    9038:	d502      	bpl.n	9040 <ADC_Disable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    903a:	689b      	ldr	r3, [r3, #8]
  return HAL_OK;
    903c:	2000      	movs	r0, #0
}
    903e:	bd38      	pop	{r3, r4, r5, pc}
    9040:	6899      	ldr	r1, [r3, #8]
    9042:	07ca      	lsls	r2, r1, #31
    9044:	d524      	bpl.n	9090 <ADC_Disable+0x60>
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
    9046:	6899      	ldr	r1, [r3, #8]
    9048:	4604      	mov	r4, r0
    904a:	f001 010d 	and.w	r1, r1, #13
    904e:	2901      	cmp	r1, #1
    9050:	d008      	beq.n	9064 <ADC_Disable+0x34>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    9052:	6d63      	ldr	r3, [r4, #84]	; 0x54
        return HAL_ERROR;
    9054:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    9056:	f043 0310 	orr.w	r3, r3, #16
    905a:	6563      	str	r3, [r4, #84]	; 0x54
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    905c:	6da3      	ldr	r3, [r4, #88]	; 0x58
    905e:	4303      	orrs	r3, r0
    9060:	65a3      	str	r3, [r4, #88]	; 0x58
}
    9062:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG(ADCx->CR,
    9064:	6898      	ldr	r0, [r3, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
    9066:	2103      	movs	r1, #3
    9068:	4a0a      	ldr	r2, [pc, #40]	; (9094 <ADC_Disable+0x64>)
    906a:	4002      	ands	r2, r0
    906c:	f042 0202 	orr.w	r2, r2, #2
    9070:	609a      	str	r2, [r3, #8]
    9072:	6823      	ldr	r3, [r4, #0]
    9074:	6019      	str	r1, [r3, #0]
    tickstart = HAL_GetTick();
    9076:	f7ff f9bd 	bl	83f4 <HAL_GetTick>
    907a:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
    907c:	e004      	b.n	9088 <ADC_Disable+0x58>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
    907e:	f7ff f9b9 	bl	83f4 <HAL_GetTick>
    9082:	1b40      	subs	r0, r0, r5
    9084:	2802      	cmp	r0, #2
    9086:	d8e4      	bhi.n	9052 <ADC_Disable+0x22>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
    9088:	6823      	ldr	r3, [r4, #0]
    908a:	689b      	ldr	r3, [r3, #8]
    908c:	07db      	lsls	r3, r3, #31
    908e:	d4f6      	bmi.n	907e <ADC_Disable+0x4e>
  return HAL_OK;
    9090:	2000      	movs	r0, #0
}
    9092:	bd38      	pop	{r3, r4, r5, pc}
    9094:	7fffffc0 	.word	0x7fffffc0

00009098 <ADC_ConfigureBoostMode>:
  *         stopped.
  * @param  hadc ADC handle
  * @retval None.
  */
void ADC_ConfigureBoostMode(ADC_HandleTypeDef* hadc)
{
    9098:	b538      	push	{r3, r4, r5, lr}
  uint32_t freq;
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
    909a:	4a52      	ldr	r2, [pc, #328]	; (91e4 <ADC_ConfigureBoostMode+0x14c>)
{
    909c:	4605      	mov	r5, r0
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
    909e:	6803      	ldr	r3, [r0, #0]
    90a0:	4293      	cmp	r3, r2
    90a2:	d027      	beq.n	90f4 <ADC_ConfigureBoostMode+0x5c>
    90a4:	f502 7280 	add.w	r2, r2, #256	; 0x100
    90a8:	4293      	cmp	r3, r2
    90aa:	d023      	beq.n	90f4 <ADC_ConfigureBoostMode+0x5c>
    90ac:	4b4e      	ldr	r3, [pc, #312]	; (91e8 <ADC_ConfigureBoostMode+0x150>)
    90ae:	689b      	ldr	r3, [r3, #8]
    90b0:	f413 3f40 	tst.w	r3, #196608	; 0x30000
    90b4:	bf14      	ite	ne
    90b6:	2301      	movne	r3, #1
    90b8:	2300      	moveq	r3, #0
    90ba:	b323      	cbz	r3, 9106 <ADC_ConfigureBoostMode+0x6e>
  {
    freq = HAL_RCC_GetHCLKFreq();
    90bc:	f005 fe2a 	bl	ed14 <HAL_RCC_GetHCLKFreq>
    switch(hadc->Init.ClockPrescaler)
    90c0:	686b      	ldr	r3, [r5, #4]
    freq = HAL_RCC_GetHCLKFreq();
    90c2:	4604      	mov	r4, r0
    switch(hadc->Init.ClockPrescaler)
    90c4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    90c8:	d062      	beq.n	9190 <ADC_ConfigureBoostMode+0xf8>
    90ca:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
    90ce:	d072      	beq.n	91b6 <ADC_ConfigureBoostMode+0x11e>
    90d0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    90d4:	d05c      	beq.n	9190 <ADC_ConfigureBoostMode+0xf8>
  else /* if(freq > 25000000UL) */
  {
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
  }
#else
  if(HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
    90d6:	f7ff f9a5 	bl	8424 <HAL_GetREVID>
    90da:	f241 0303 	movw	r3, #4099	; 0x1003
    90de:	4298      	cmp	r0, r3
    90e0:	d832      	bhi.n	9148 <ADC_ConfigureBoostMode+0xb0>
  {
    if(freq > 20000000UL)
    90e2:	4a42      	ldr	r2, [pc, #264]	; (91ec <ADC_ConfigureBoostMode+0x154>)
    90e4:	682b      	ldr	r3, [r5, #0]
    90e6:	4294      	cmp	r4, r2
    90e8:	d928      	bls.n	913c <ADC_ConfigureBoostMode+0xa4>
    {
      SET_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
    90ea:	689a      	ldr	r2, [r3, #8]
    90ec:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    90f0:	609a      	str	r2, [r3, #8]
    {
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    }
  }
#endif /* ADC_VER_V5_3 */
}
    90f2:	bd38      	pop	{r3, r4, r5, pc}
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
    90f4:	4b3e      	ldr	r3, [pc, #248]	; (91f0 <ADC_ConfigureBoostMode+0x158>)
    90f6:	689b      	ldr	r3, [r3, #8]
    90f8:	f413 3f40 	tst.w	r3, #196608	; 0x30000
    90fc:	bf14      	ite	ne
    90fe:	2301      	movne	r3, #1
    9100:	2300      	moveq	r3, #0
    9102:	2b00      	cmp	r3, #0
    9104:	d1da      	bne.n	90bc <ADC_ConfigureBoostMode+0x24>
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
    9106:	f44f 2000 	mov.w	r0, #524288	; 0x80000
    910a:	f007 f8bb 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
    switch(hadc->Init.ClockPrescaler)
    910e:	686b      	ldr	r3, [r5, #4]
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
    9110:	4604      	mov	r4, r0
    switch(hadc->Init.ClockPrescaler)
    9112:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
    9116:	d049      	beq.n	91ac <ADC_ConfigureBoostMode+0x114>
    9118:	d93e      	bls.n	9198 <ADC_ConfigureBoostMode+0x100>
    911a:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
    911e:	d04e      	beq.n	91be <ADC_ConfigureBoostMode+0x126>
    9120:	d927      	bls.n	9172 <ADC_ConfigureBoostMode+0xda>
    9122:	f5b3 1f20 	cmp.w	r3, #2621440	; 0x280000
    9126:	d048      	beq.n	91ba <ADC_ConfigureBoostMode+0x122>
    9128:	f5b3 1f30 	cmp.w	r3, #2883584	; 0x2c0000
    912c:	d1d3      	bne.n	90d6 <ADC_ConfigureBoostMode+0x3e>
  if(HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
    912e:	f7ff f979 	bl	8424 <HAL_GetREVID>
    9132:	f241 0303 	movw	r3, #4099	; 0x1003
    9136:	4298      	cmp	r0, r3
    9138:	d805      	bhi.n	9146 <ADC_ConfigureBoostMode+0xae>
    913a:	682b      	ldr	r3, [r5, #0]
      CLEAR_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
    913c:	689a      	ldr	r2, [r3, #8]
    913e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    9142:	609a      	str	r2, [r3, #8]
}
    9144:	bd38      	pop	{r3, r4, r5, pc}
        freq /= 256UL;
    9146:	0a24      	lsrs	r4, r4, #8
    freq /= 2U; /* divider by 2 for Rev.V */
    9148:	0864      	lsrs	r4, r4, #1
    if (freq <= 6250000UL)
    914a:	4a2a      	ldr	r2, [pc, #168]	; (91f4 <ADC_ConfigureBoostMode+0x15c>)
    914c:	682b      	ldr	r3, [r5, #0]
    914e:	4294      	cmp	r4, r2
    9150:	d90a      	bls.n	9168 <ADC_ConfigureBoostMode+0xd0>
    else if(freq <= 12500000UL)
    9152:	4a29      	ldr	r2, [pc, #164]	; (91f8 <ADC_ConfigureBoostMode+0x160>)
    9154:	4294      	cmp	r4, r2
    9156:	d914      	bls.n	9182 <ADC_ConfigureBoostMode+0xea>
    else if(freq <= 25000000UL)
    9158:	4a28      	ldr	r2, [pc, #160]	; (91fc <ADC_ConfigureBoostMode+0x164>)
    915a:	4294      	cmp	r4, r2
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
    915c:	689a      	ldr	r2, [r3, #8]
    else if(freq <= 25000000UL)
    915e:	d932      	bls.n	91c6 <ADC_ConfigureBoostMode+0x12e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    9160:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    9164:	609a      	str	r2, [r3, #8]
}
    9166:	bd38      	pop	{r3, r4, r5, pc}
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, 0UL);
    9168:	689a      	ldr	r2, [r3, #8]
    916a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    916e:	609a      	str	r2, [r3, #8]
}
    9170:	bd38      	pop	{r3, r4, r5, pc}
    switch(hadc->Init.ClockPrescaler)
    9172:	f5b3 1fe0 	cmp.w	r3, #1835008	; 0x1c0000
    9176:	d024      	beq.n	91c2 <ADC_ConfigureBoostMode+0x12a>
    9178:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
    917c:	d1ab      	bne.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 32UL;
    917e:	0944      	lsrs	r4, r0, #5
        break;
    9180:	e7a9      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_0);
    9182:	689a      	ldr	r2, [r3, #8]
    9184:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    9188:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    918c:	609a      	str	r2, [r3, #8]
}
    918e:	bd38      	pop	{r3, r4, r5, pc}
        freq /= (hadc->Init.ClockPrescaler >> ADC_CCR_CKMODE_Pos);
    9190:	0c1b      	lsrs	r3, r3, #16
    9192:	fbb4 f4f3 	udiv	r4, r4, r3
        break;
    9196:	e79e      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
    switch(hadc->Init.ClockPrescaler)
    9198:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
    919c:	d006      	beq.n	91ac <ADC_ConfigureBoostMode+0x114>
    919e:	d818      	bhi.n	91d2 <ADC_ConfigureBoostMode+0x13a>
    91a0:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    91a4:	d002      	beq.n	91ac <ADC_ConfigureBoostMode+0x114>
    91a6:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
    91aa:	d194      	bne.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= ((hadc->Init.ClockPrescaler >> ADC_CCR_PRESC_Pos) << 1UL);
    91ac:	0c9b      	lsrs	r3, r3, #18
    91ae:	005b      	lsls	r3, r3, #1
    91b0:	fbb4 f4f3 	udiv	r4, r4, r3
        break;
    91b4:	e78f      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 4UL;
    91b6:	0884      	lsrs	r4, r0, #2
        break;
    91b8:	e78d      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 128UL;
    91ba:	09c4      	lsrs	r4, r0, #7
        break;
    91bc:	e78b      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 64UL;
    91be:	0984      	lsrs	r4, r0, #6
        break;
    91c0:	e789      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 16UL;
    91c2:	0904      	lsrs	r4, r0, #4
      break;
    91c4:	e787      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
    91c6:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    91ca:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    91ce:	609a      	str	r2, [r3, #8]
}
    91d0:	bd38      	pop	{r3, r4, r5, pc}
    switch(hadc->Init.ClockPrescaler)
    91d2:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    91d6:	d0e9      	beq.n	91ac <ADC_ConfigureBoostMode+0x114>
    91d8:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
    91dc:	f47f af7b 	bne.w	90d6 <ADC_ConfigureBoostMode+0x3e>
    91e0:	e7e4      	b.n	91ac <ADC_ConfigureBoostMode+0x114>
    91e2:	bf00      	nop
    91e4:	40022000 	.word	0x40022000
    91e8:	58026300 	.word	0x58026300
    91ec:	01312d00 	.word	0x01312d00
    91f0:	40022300 	.word	0x40022300
    91f4:	005f5e10 	.word	0x005f5e10
    91f8:	00bebc20 	.word	0x00bebc20
    91fc:	017d7840 	.word	0x017d7840

00009200 <HAL_ADC_Init>:
{
    9200:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint32_t wait_loop_index = 0UL;
    9202:	2300      	movs	r3, #0
{
    9204:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0UL;
    9206:	9301      	str	r3, [sp, #4]
  if (hadc == NULL)
    9208:	2800      	cmp	r0, #0
    920a:	f000 81ab 	beq.w	9564 <HAL_ADC_Init+0x364>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    920e:	6803      	ldr	r3, [r0, #0]
    9210:	4604      	mov	r4, r0
    9212:	499a      	ldr	r1, [pc, #616]	; (947c <HAL_ADC_Init+0x27c>)
    9214:	4a9a      	ldr	r2, [pc, #616]	; (9480 <HAL_ADC_Init+0x280>)
    9216:	428b      	cmp	r3, r1
    9218:	bf18      	it	ne
    921a:	4293      	cmpne	r3, r2
    921c:	d003      	beq.n	9226 <HAL_ADC_Init+0x26>
    921e:	4a99      	ldr	r2, [pc, #612]	; (9484 <HAL_ADC_Init+0x284>)
    9220:	4293      	cmp	r3, r2
    9222:	f040 81b0 	bne.w	9586 <HAL_ADC_Init+0x386>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
    9226:	6862      	ldr	r2, [r4, #4]
    9228:	f422 2300 	bic.w	r3, r2, #524288	; 0x80000
    922c:	f422 3540 	bic.w	r5, r2, #196608	; 0x30000
    9230:	f422 1080 	bic.w	r0, r2, #1048576	; 0x100000
    9234:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
    9238:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    923c:	bf18      	it	ne
    923e:	2d00      	cmpne	r5, #0
    9240:	bf14      	ite	ne
    9242:	2301      	movne	r3, #1
    9244:	2300      	moveq	r3, #0
    9246:	f5b2 1fe0 	cmp.w	r2, #1835008	; 0x1c0000
    924a:	bf0c      	ite	eq
    924c:	2300      	moveq	r3, #0
    924e:	f003 0301 	andne.w	r3, r3, #1
    9252:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
    9256:	bf0c      	ite	eq
    9258:	2300      	moveq	r3, #0
    925a:	f003 0301 	andne.w	r3, r3, #1
    925e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    9262:	bf0c      	ite	eq
    9264:	2300      	moveq	r3, #0
    9266:	f003 0301 	andne.w	r3, r3, #1
    926a:	b12b      	cbz	r3, 9278 <HAL_ADC_Init+0x78>
    926c:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
    9270:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    9274:	f040 81e0 	bne.w	9638 <HAL_ADC_Init+0x438>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
    9278:	68a2      	ldr	r2, [r4, #8]
    927a:	2a10      	cmp	r2, #16
    927c:	f200 817d 	bhi.w	957a <HAL_ADC_Init+0x37a>
    9280:	4b81      	ldr	r3, [pc, #516]	; (9488 <HAL_ADC_Init+0x288>)
    9282:	40d3      	lsrs	r3, r2
    9284:	07de      	lsls	r6, r3, #31
    9286:	f140 8178 	bpl.w	957a <HAL_ADC_Init+0x37a>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
    928a:	68e3      	ldr	r3, [r4, #12]
    928c:	2b01      	cmp	r3, #1
    928e:	f200 80e0 	bhi.w	9452 <HAL_ADC_Init+0x252>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    9292:	7d63      	ldrb	r3, [r4, #21]
    9294:	2b01      	cmp	r3, #1
    9296:	f200 80cc 	bhi.w	9432 <HAL_ADC_Init+0x232>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
    929a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    929c:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    92a0:	f040 80d1 	bne.w	9446 <HAL_ADC_Init+0x246>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
    92a4:	6a62      	ldr	r2, [r4, #36]	; 0x24
    92a6:	f5b2 6fd0 	cmp.w	r2, #1664	; 0x680
    92aa:	bf18      	it	ne
    92ac:	f5b2 6fb8 	cmpne.w	r2, #1472	; 0x5c0
    92b0:	f022 0040 	bic.w	r0, r2, #64	; 0x40
    92b4:	f022 0180 	bic.w	r1, r2, #128	; 0x80
    92b8:	f422 7590 	bic.w	r5, r2, #288	; 0x120
    92bc:	bf14      	ite	ne
    92be:	2301      	movne	r3, #1
    92c0:	2300      	moveq	r3, #0
    92c2:	f5b0 6f84 	cmp.w	r0, #1056	; 0x420
    92c6:	bf0c      	ite	eq
    92c8:	2300      	moveq	r3, #0
    92ca:	f003 0301 	andne.w	r3, r3, #1
    92ce:	f422 7080 	bic.w	r0, r2, #256	; 0x100
    92d2:	f5b1 6f88 	cmp.w	r1, #1088	; 0x440
    92d6:	bf0c      	ite	eq
    92d8:	2300      	moveq	r3, #0
    92da:	f003 0301 	andne.w	r3, r3, #1
    92de:	f022 0160 	bic.w	r1, r2, #96	; 0x60
    92e2:	f5b5 6f90 	cmp.w	r5, #1152	; 0x480
    92e6:	bf0c      	ite	eq
    92e8:	2300      	moveq	r3, #0
    92ea:	f003 0301 	andne.w	r3, r3, #1
    92ee:	f5b0 6f9c 	cmp.w	r0, #1248	; 0x4e0
    92f2:	bf0c      	ite	eq
    92f4:	2300      	moveq	r3, #0
    92f6:	f003 0301 	andne.w	r3, r3, #1
    92fa:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    92fe:	bf0c      	ite	eq
    9300:	2300      	moveq	r3, #0
    9302:	f003 0301 	andne.w	r3, r3, #1
    9306:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
    930a:	bf0c      	ite	eq
    930c:	2300      	moveq	r3, #0
    930e:	f003 0301 	andne.w	r3, r3, #1
    9312:	b11b      	cbz	r3, 931c <HAL_ADC_Init+0x11c>
    9314:	f432 6380 	bics.w	r3, r2, #1024	; 0x400
    9318:	f040 8194 	bne.w	9644 <HAL_ADC_Init+0x444>
  assert_param(IS_ADC_CONVERSIONDATAMGT(hadc->Init.ConversionDataManagement));
    931c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    931e:	2b03      	cmp	r3, #3
    9320:	f200 8165 	bhi.w	95ee <HAL_ADC_Init+0x3ee>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
    9324:	6923      	ldr	r3, [r4, #16]
    9326:	2b04      	cmp	r3, #4
    9328:	d006      	beq.n	9338 <HAL_ADC_Init+0x138>
    932a:	2b08      	cmp	r3, #8
    932c:	d004      	beq.n	9338 <HAL_ADC_Init+0x138>
    932e:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
    9332:	4856      	ldr	r0, [pc, #344]	; (948c <HAL_ADC_Init+0x28c>)
    9334:	f010 f86e 	bl	19414 <assert_failed>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
    9338:	6b23      	ldr	r3, [r4, #48]	; 0x30
    933a:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
    933e:	f040 8092 	bne.w	9466 <HAL_ADC_Init+0x266>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
    9342:	7d23      	ldrb	r3, [r4, #20]
    9344:	2b01      	cmp	r3, #1
    9346:	d86a      	bhi.n	941e <HAL_ADC_Init+0x21e>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
    9348:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    934c:	2b01      	cmp	r3, #1
    934e:	d85d      	bhi.n	940c <HAL_ADC_Init+0x20c>
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
    9350:	68e3      	ldr	r3, [r4, #12]
    9352:	2b00      	cmp	r3, #0
    9354:	d141      	bne.n	93da <HAL_ADC_Init+0x1da>
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
    9356:	7f23      	ldrb	r3, [r4, #28]
    9358:	2b01      	cmp	r3, #1
    935a:	d04e      	beq.n	93fa <HAL_ADC_Init+0x1fa>
  if (hadc->State == HAL_ADC_STATE_RESET)
    935c:	6d65      	ldr	r5, [r4, #84]	; 0x54
    935e:	2d00      	cmp	r5, #0
    9360:	f000 8104 	beq.w	956c <HAL_ADC_Init+0x36c>
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
    9364:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
    9366:	689a      	ldr	r2, [r3, #8]
    9368:	0095      	lsls	r5, r2, #2
    936a:	d504      	bpl.n	9376 <HAL_ADC_Init+0x176>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
    936c:	6899      	ldr	r1, [r3, #8]
    936e:	4a48      	ldr	r2, [pc, #288]	; (9490 <HAL_ADC_Init+0x290>)
    9370:	400a      	ands	r2, r1
    9372:	609a      	str	r2, [r3, #8]
    9374:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
    9376:	689a      	ldr	r2, [r3, #8]
    9378:	00d0      	lsls	r0, r2, #3
    937a:	d416      	bmi.n	93aa <HAL_ADC_Init+0x1aa>
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
    937c:	4a45      	ldr	r2, [pc, #276]	; (9494 <HAL_ADC_Init+0x294>)
  MODIFY_REG(ADCx->CR,
    937e:	6898      	ldr	r0, [r3, #8]
    9380:	6812      	ldr	r2, [r2, #0]
    9382:	4d45      	ldr	r5, [pc, #276]	; (9498 <HAL_ADC_Init+0x298>)
    9384:	0992      	lsrs	r2, r2, #6
    9386:	4945      	ldr	r1, [pc, #276]	; (949c <HAL_ADC_Init+0x29c>)
    9388:	fba5 5202 	umull	r5, r2, r5, r2
    938c:	4001      	ands	r1, r0
    938e:	0992      	lsrs	r2, r2, #6
    9390:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
    9394:	6099      	str	r1, [r3, #8]
    9396:	9201      	str	r2, [sp, #4]
    while (wait_loop_index != 0UL)
    9398:	9b01      	ldr	r3, [sp, #4]
    939a:	b12b      	cbz	r3, 93a8 <HAL_ADC_Init+0x1a8>
      wait_loop_index--;
    939c:	9b01      	ldr	r3, [sp, #4]
    939e:	3b01      	subs	r3, #1
    93a0:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
    93a2:	9b01      	ldr	r3, [sp, #4]
    93a4:	2b00      	cmp	r3, #0
    93a6:	d1f9      	bne.n	939c <HAL_ADC_Init+0x19c>
    93a8:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
    93aa:	689a      	ldr	r2, [r3, #8]
    93ac:	00d1      	lsls	r1, r2, #3
    93ae:	f100 80d7 	bmi.w	9560 <HAL_ADC_Init+0x360>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    93b2:	6d62      	ldr	r2, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
    93b4:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    93b6:	f042 0210 	orr.w	r2, r2, #16
    93ba:	6562      	str	r2, [r4, #84]	; 0x54
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    93bc:	6da2      	ldr	r2, [r4, #88]	; 0x58
    93be:	432a      	orrs	r2, r5
    93c0:	65a2      	str	r2, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    93c2:	689a      	ldr	r2, [r3, #8]
    93c4:	0752      	lsls	r2, r2, #29
    93c6:	d56b      	bpl.n	94a0 <HAL_ADC_Init+0x2a0>
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
    93c8:	6d63      	ldr	r3, [r4, #84]	; 0x54
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    93ca:	6d63      	ldr	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
    93cc:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    93ce:	f043 0310 	orr.w	r3, r3, #16
}
    93d2:	4628      	mov	r0, r5
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    93d4:	6563      	str	r3, [r4, #84]	; 0x54
}
    93d6:	b003      	add	sp, #12
    93d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
    93da:	69a3      	ldr	r3, [r4, #24]
    93dc:	3b01      	subs	r3, #1
    93de:	2b0f      	cmp	r3, #15
    93e0:	f200 80ff 	bhi.w	95e2 <HAL_ADC_Init+0x3e2>
    assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
    93e4:	7f23      	ldrb	r3, [r4, #28]
    93e6:	2b01      	cmp	r3, #1
    93e8:	f200 80d3 	bhi.w	9592 <HAL_ADC_Init+0x392>
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
    93ec:	2b01      	cmp	r3, #1
    93ee:	d1b5      	bne.n	935c <HAL_ADC_Init+0x15c>
      assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
    93f0:	6a23      	ldr	r3, [r4, #32]
    93f2:	3b01      	subs	r3, #1
    93f4:	2b07      	cmp	r3, #7
    93f6:	f200 810f 	bhi.w	9618 <HAL_ADC_Init+0x418>
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
    93fa:	7d63      	ldrb	r3, [r4, #21]
    93fc:	2b01      	cmp	r3, #1
    93fe:	d1ad      	bne.n	935c <HAL_ADC_Init+0x15c>
    9400:	f240 11bf 	movw	r1, #447	; 0x1bf
    9404:	4821      	ldr	r0, [pc, #132]	; (948c <HAL_ADC_Init+0x28c>)
    9406:	f010 f805 	bl	19414 <assert_failed>
    940a:	e7a7      	b.n	935c <HAL_ADC_Init+0x15c>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
    940c:	f240 11b1 	movw	r1, #433	; 0x1b1
    9410:	481e      	ldr	r0, [pc, #120]	; (948c <HAL_ADC_Init+0x28c>)
    9412:	f00f ffff 	bl	19414 <assert_failed>
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
    9416:	68e3      	ldr	r3, [r4, #12]
    9418:	2b00      	cmp	r3, #0
    941a:	d09c      	beq.n	9356 <HAL_ADC_Init+0x156>
    941c:	e7dd      	b.n	93da <HAL_ADC_Init+0x1da>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
    941e:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
    9422:	481a      	ldr	r0, [pc, #104]	; (948c <HAL_ADC_Init+0x28c>)
    9424:	f00f fff6 	bl	19414 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
    9428:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    942c:	2b01      	cmp	r3, #1
    942e:	d98f      	bls.n	9350 <HAL_ADC_Init+0x150>
    9430:	e7ec      	b.n	940c <HAL_ADC_Init+0x20c>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    9432:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
    9436:	4815      	ldr	r0, [pc, #84]	; (948c <HAL_ADC_Init+0x28c>)
    9438:	f00f ffec 	bl	19414 <assert_failed>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
    943c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    943e:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    9442:	f43f af2f 	beq.w	92a4 <HAL_ADC_Init+0xa4>
    9446:	f240 11ab 	movw	r1, #427	; 0x1ab
    944a:	4810      	ldr	r0, [pc, #64]	; (948c <HAL_ADC_Init+0x28c>)
    944c:	f00f ffe2 	bl	19414 <assert_failed>
    9450:	e728      	b.n	92a4 <HAL_ADC_Init+0xa4>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
    9452:	f240 11a9 	movw	r1, #425	; 0x1a9
    9456:	480d      	ldr	r0, [pc, #52]	; (948c <HAL_ADC_Init+0x28c>)
    9458:	f00f ffdc 	bl	19414 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    945c:	7d63      	ldrb	r3, [r4, #21]
    945e:	2b01      	cmp	r3, #1
    9460:	f67f af1b 	bls.w	929a <HAL_ADC_Init+0x9a>
    9464:	e7e5      	b.n	9432 <HAL_ADC_Init+0x232>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
    9466:	f240 11af 	movw	r1, #431	; 0x1af
    946a:	4808      	ldr	r0, [pc, #32]	; (948c <HAL_ADC_Init+0x28c>)
    946c:	f00f ffd2 	bl	19414 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
    9470:	7d23      	ldrb	r3, [r4, #20]
    9472:	2b01      	cmp	r3, #1
    9474:	f67f af68 	bls.w	9348 <HAL_ADC_Init+0x148>
    9478:	e7d1      	b.n	941e <HAL_ADC_Init+0x21e>
    947a:	bf00      	nop
    947c:	40022000 	.word	0x40022000
    9480:	40022100 	.word	0x40022100
    9484:	58026000 	.word	0x58026000
    9488:	00011111 	.word	0x00011111
    948c:	0002fb64 	.word	0x0002fb64
    9490:	5fffffc0 	.word	0x5fffffc0
    9494:	0006280c 	.word	0x0006280c
    9498:	053e2d63 	.word	0x053e2d63
    949c:	6fffffc0 	.word	0x6fffffc0
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
    94a0:	6d62      	ldr	r2, [r4, #84]	; 0x54
    94a2:	06d7      	lsls	r7, r2, #27
    94a4:	d491      	bmi.n	93ca <HAL_ADC_Init+0x1ca>
    ADC_STATE_CLR_SET(hadc->State,
    94a6:	6d62      	ldr	r2, [r4, #84]	; 0x54
    94a8:	f422 7281 	bic.w	r2, r2, #258	; 0x102
    94ac:	f042 0202 	orr.w	r2, r2, #2
    94b0:	6562      	str	r2, [r4, #84]	; 0x54
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    94b2:	689a      	ldr	r2, [r3, #8]
    94b4:	07d6      	lsls	r6, r2, #31
    94b6:	d413      	bmi.n	94e0 <HAL_ADC_Init+0x2e0>
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    94b8:	4a91      	ldr	r2, [pc, #580]	; (9700 <HAL_ADC_Init+0x500>)
    94ba:	4293      	cmp	r3, r2
    94bc:	f000 80b2 	beq.w	9624 <HAL_ADC_Init+0x424>
    94c0:	f502 7280 	add.w	r2, r2, #256	; 0x100
    94c4:	4293      	cmp	r3, r2
    94c6:	f000 80ad 	beq.w	9624 <HAL_ADC_Init+0x424>
    94ca:	4b8e      	ldr	r3, [pc, #568]	; (9704 <HAL_ADC_Init+0x504>)
    94cc:	689b      	ldr	r3, [r3, #8]
    94ce:	07d9      	lsls	r1, r3, #31
    94d0:	d406      	bmi.n	94e0 <HAL_ADC_Init+0x2e0>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
    94d2:	4a8d      	ldr	r2, [pc, #564]	; (9708 <HAL_ADC_Init+0x508>)
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
    94d4:	6893      	ldr	r3, [r2, #8]
    94d6:	6861      	ldr	r1, [r4, #4]
    94d8:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
    94dc:	430b      	orrs	r3, r1
    94de:	6093      	str	r3, [r2, #8]
    if((HAL_GetREVID() > REV_ID_Y) && (ADC_RESOLUTION_8B == hadc->Init.Resolution))
    94e0:	f7fe ffa0 	bl	8424 <HAL_GetREVID>
    94e4:	f241 0303 	movw	r3, #4099	; 0x1003
    94e8:	4298      	cmp	r0, r3
    94ea:	f240 8086 	bls.w	95fa <HAL_ADC_Init+0x3fa>
    94ee:	68a2      	ldr	r2, [r4, #8]
    94f0:	7d61      	ldrb	r1, [r4, #21]
    94f2:	7f20      	ldrb	r0, [r4, #28]
    94f4:	2a10      	cmp	r2, #16
    94f6:	ea4f 3141 	mov.w	r1, r1, lsl #13
    94fa:	6b26      	ldr	r6, [r4, #48]	; 0x30
    94fc:	ea4f 4300 	mov.w	r3, r0, lsl #16
    9500:	f000 80e0 	beq.w	96c4 <HAL_ADC_Init+0x4c4>
                  hadc->Init.Overrun                                                    |
    9504:	430a      	orrs	r2, r1
    9506:	4332      	orrs	r2, r6
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
    9508:	431a      	orrs	r2, r3
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
    950a:	2801      	cmp	r0, #1
    950c:	d103      	bne.n	9516 <HAL_ADC_Init+0x316>
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
    950e:	6a23      	ldr	r3, [r4, #32]
    9510:	3b01      	subs	r3, #1
    9512:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
    9516:	6a63      	ldr	r3, [r4, #36]	; 0x24
    9518:	b123      	cbz	r3, 9524 <HAL_ADC_Init+0x324>
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
    951a:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
    951e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    9520:	430b      	orrs	r3, r1
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
    9522:	431a      	orrs	r2, r3
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
    9524:	6821      	ldr	r1, [r4, #0]
    9526:	4b79      	ldr	r3, [pc, #484]	; (970c <HAL_ADC_Init+0x50c>)
    9528:	68c8      	ldr	r0, [r1, #12]
    952a:	4003      	ands	r3, r0
    952c:	4313      	orrs	r3, r2
    952e:	60cb      	str	r3, [r1, #12]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
    9530:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    9532:	689a      	ldr	r2, [r3, #8]
    9534:	f012 0f04 	tst.w	r2, #4
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    9538:	689a      	ldr	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    953a:	d101      	bne.n	9540 <HAL_ADC_Init+0x340>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    953c:	0712      	lsls	r2, r2, #28
    953e:	d532      	bpl.n	95a6 <HAL_ADC_Init+0x3a6>
    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
    9540:	68e2      	ldr	r2, [r4, #12]
    9542:	2a01      	cmp	r2, #1
    9544:	d060      	beq.n	9608 <HAL_ADC_Init+0x408>
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
    9546:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    9548:	f022 020f 	bic.w	r2, r2, #15
    954c:	631a      	str	r2, [r3, #48]	; 0x30
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
    954e:	6d63      	ldr	r3, [r4, #84]	; 0x54
}
    9550:	4628      	mov	r0, r5
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
    9552:	f023 0303 	bic.w	r3, r3, #3
    9556:	f043 0301 	orr.w	r3, r3, #1
    955a:	6563      	str	r3, [r4, #84]	; 0x54
}
    955c:	b003      	add	sp, #12
    955e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9560:	2500      	movs	r5, #0
    9562:	e72e      	b.n	93c2 <HAL_ADC_Init+0x1c2>
    return HAL_ERROR;
    9564:	2501      	movs	r5, #1
}
    9566:	4628      	mov	r0, r5
    9568:	b003      	add	sp, #12
    956a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    HAL_ADC_MspInit(hadc);
    956c:	4620      	mov	r0, r4
    956e:	f00d f9b7 	bl	168e0 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
    9572:	65a5      	str	r5, [r4, #88]	; 0x58
    hadc->Lock = HAL_UNLOCKED;
    9574:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
    9578:	e6f4      	b.n	9364 <HAL_ADC_Init+0x164>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
    957a:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
    957e:	4864      	ldr	r0, [pc, #400]	; (9710 <HAL_ADC_Init+0x510>)
    9580:	f00f ff48 	bl	19414 <assert_failed>
    9584:	e681      	b.n	928a <HAL_ADC_Init+0x8a>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    9586:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
    958a:	4861      	ldr	r0, [pc, #388]	; (9710 <HAL_ADC_Init+0x510>)
    958c:	f00f ff42 	bl	19414 <assert_failed>
    9590:	e649      	b.n	9226 <HAL_ADC_Init+0x26>
    assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
    9592:	f44f 71db 	mov.w	r1, #438	; 0x1b6
    9596:	485e      	ldr	r0, [pc, #376]	; (9710 <HAL_ADC_Init+0x510>)
    9598:	f00f ff3c 	bl	19414 <assert_failed>
    959c:	7f23      	ldrb	r3, [r4, #28]
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
    959e:	2b01      	cmp	r3, #1
    95a0:	f47f aedc 	bne.w	935c <HAL_ADC_Init+0x15c>
    95a4:	e724      	b.n	93f0 <HAL_ADC_Init+0x1f0>
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
    95a6:	68d9      	ldr	r1, [r3, #12]
    95a8:	4a5a      	ldr	r2, [pc, #360]	; (9714 <HAL_ADC_Init+0x514>)
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
    95aa:	7d20      	ldrb	r0, [r4, #20]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
    95ac:	400a      	ands	r2, r1
    95ae:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    95b0:	ea42 3280 	orr.w	r2, r2, r0, lsl #14
    95b4:	430a      	orrs	r2, r1
    95b6:	60da      	str	r2, [r3, #12]
      if (hadc->Init.OversamplingMode == ENABLE)
    95b8:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    95bc:	2b01      	cmp	r3, #1
    95be:	d047      	beq.n	9650 <HAL_ADC_Init+0x450>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
    95c0:	6822      	ldr	r2, [r4, #0]
    95c2:	6913      	ldr	r3, [r2, #16]
    95c4:	f023 0301 	bic.w	r3, r3, #1
    95c8:	6113      	str	r3, [r2, #16]
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
    95ca:	6822      	ldr	r2, [r4, #0]
      ADC_ConfigureBoostMode(hadc);
    95cc:	4620      	mov	r0, r4
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
    95ce:	6b61      	ldr	r1, [r4, #52]	; 0x34
    95d0:	6913      	ldr	r3, [r2, #16]
    95d2:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    95d6:	430b      	orrs	r3, r1
    95d8:	6113      	str	r3, [r2, #16]
      ADC_ConfigureBoostMode(hadc);
    95da:	f7ff fd5d 	bl	9098 <ADC_ConfigureBoostMode>
    95de:	6823      	ldr	r3, [r4, #0]
    95e0:	e7ae      	b.n	9540 <HAL_ADC_Init+0x340>
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
    95e2:	f240 11b5 	movw	r1, #437	; 0x1b5
    95e6:	484a      	ldr	r0, [pc, #296]	; (9710 <HAL_ADC_Init+0x510>)
    95e8:	f00f ff14 	bl	19414 <assert_failed>
    95ec:	e6fa      	b.n	93e4 <HAL_ADC_Init+0x1e4>
  assert_param(IS_ADC_CONVERSIONDATAMGT(hadc->Init.ConversionDataManagement));
    95ee:	f240 11ad 	movw	r1, #429	; 0x1ad
    95f2:	4847      	ldr	r0, [pc, #284]	; (9710 <HAL_ADC_Init+0x510>)
    95f4:	f00f ff0e 	bl	19414 <assert_failed>
    95f8:	e694      	b.n	9324 <HAL_ADC_Init+0x124>
    95fa:	7d62      	ldrb	r2, [r4, #21]
    95fc:	7f20      	ldrb	r0, [r4, #28]
    95fe:	0351      	lsls	r1, r2, #13
    9600:	6b26      	ldr	r6, [r4, #48]	; 0x30
    9602:	68a2      	ldr	r2, [r4, #8]
    9604:	0403      	lsls	r3, r0, #16
    9606:	e77d      	b.n	9504 <HAL_ADC_Init+0x304>
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
    9608:	6b19      	ldr	r1, [r3, #48]	; 0x30
    960a:	69a2      	ldr	r2, [r4, #24]
    960c:	f021 010f 	bic.w	r1, r1, #15
    9610:	3a01      	subs	r2, #1
    9612:	430a      	orrs	r2, r1
    9614:	631a      	str	r2, [r3, #48]	; 0x30
    9616:	e79a      	b.n	954e <HAL_ADC_Init+0x34e>
      assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
    9618:	f44f 71dd 	mov.w	r1, #442	; 0x1ba
    961c:	483c      	ldr	r0, [pc, #240]	; (9710 <HAL_ADC_Init+0x510>)
    961e:	f00f fef9 	bl	19414 <assert_failed>
    9622:	e698      	b.n	9356 <HAL_ADC_Init+0x156>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    9624:	4a36      	ldr	r2, [pc, #216]	; (9700 <HAL_ADC_Init+0x500>)
    9626:	4b3c      	ldr	r3, [pc, #240]	; (9718 <HAL_ADC_Init+0x518>)
    9628:	6892      	ldr	r2, [r2, #8]
    962a:	689b      	ldr	r3, [r3, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    962c:	4313      	orrs	r3, r2
    962e:	07d8      	lsls	r0, r3, #31
    9630:	f53f af56 	bmi.w	94e0 <HAL_ADC_Init+0x2e0>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
    9634:	4a39      	ldr	r2, [pc, #228]	; (971c <HAL_ADC_Init+0x51c>)
    9636:	e74d      	b.n	94d4 <HAL_ADC_Init+0x2d4>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
    9638:	f240 11a7 	movw	r1, #423	; 0x1a7
    963c:	4834      	ldr	r0, [pc, #208]	; (9710 <HAL_ADC_Init+0x510>)
    963e:	f00f fee9 	bl	19414 <assert_failed>
    9642:	e619      	b.n	9278 <HAL_ADC_Init+0x78>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
    9644:	f44f 71d6 	mov.w	r1, #428	; 0x1ac
    9648:	4831      	ldr	r0, [pc, #196]	; (9710 <HAL_ADC_Init+0x510>)
    964a:	f00f fee3 	bl	19414 <assert_failed>
    964e:	e665      	b.n	931c <HAL_ADC_Init+0x11c>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
    9650:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    9652:	3b01      	subs	r3, #1
    9654:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    9658:	d245      	bcs.n	96e6 <HAL_ADC_Init+0x4e6>
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
    965a:	6c22      	ldr	r2, [r4, #64]	; 0x40
    965c:	f032 0160 	bics.w	r1, r2, #96	; 0x60
    9660:	bf14      	ite	ne
    9662:	2301      	movne	r3, #1
    9664:	2300      	moveq	r3, #0
    9666:	2980      	cmp	r1, #128	; 0x80
    9668:	bf0c      	ite	eq
    966a:	2300      	moveq	r3, #0
    966c:	f003 0301 	andne.w	r3, r3, #1
    9670:	b113      	cbz	r3, 9678 <HAL_ADC_Init+0x478>
    9672:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    9676:	d13c      	bne.n	96f2 <HAL_ADC_Init+0x4f2>
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
    9678:	6c63      	ldr	r3, [r4, #68]	; 0x44
    967a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    967e:	d12c      	bne.n	96da <HAL_ADC_Init+0x4da>
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
    9680:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    9682:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    9686:	2b01      	cmp	r3, #1
    9688:	d121      	bne.n	96ce <HAL_ADC_Init+0x4ce>
      if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
    968a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    968c:	6c66      	ldr	r6, [r4, #68]	; 0x44
    968e:	b10b      	cbz	r3, 9694 <HAL_ADC_Init+0x494>
            || (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE))
    9690:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9692:	b933      	cbnz	r3, 96a2 <HAL_ADC_Init+0x4a2>
          assert_param((hadc->Init.Oversampling.TriggeredMode == ADC_TRIGGEREDMODE_SINGLE_TRIGGER));
    9694:	b12e      	cbz	r6, 96a2 <HAL_ADC_Init+0x4a2>
    9696:	f240 218b 	movw	r1, #651	; 0x28b
    969a:	481d      	ldr	r0, [pc, #116]	; (9710 <HAL_ADC_Init+0x510>)
    969c:	f00f feba 	bl	19414 <assert_failed>
    96a0:	6c66      	ldr	r6, [r4, #68]	; 0x44
       MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
    96a2:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    96a4:	6820      	ldr	r0, [r4, #0]
    96a6:	6c23      	ldr	r3, [r4, #64]	; 0x40
    96a8:	6907      	ldr	r7, [r0, #16]
    96aa:	4313      	orrs	r3, r2
    96ac:	491c      	ldr	r1, [pc, #112]	; (9720 <HAL_ADC_Init+0x520>)
    96ae:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    96b0:	4039      	ands	r1, r7
    96b2:	f043 0301 	orr.w	r3, r3, #1
    96b6:	3a01      	subs	r2, #1
    96b8:	430b      	orrs	r3, r1
    96ba:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    96be:	4333      	orrs	r3, r6
    96c0:	6103      	str	r3, [r0, #16]
    96c2:	e782      	b.n	95ca <HAL_ADC_Init+0x3ca>
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
    96c4:	f046 021c 	orr.w	r2, r6, #28
    96c8:	430a      	orrs	r2, r1
    96ca:	431a      	orrs	r2, r3
    96cc:	e71d      	b.n	950a <HAL_ADC_Init+0x30a>
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
    96ce:	f240 2185 	movw	r1, #645	; 0x285
    96d2:	480f      	ldr	r0, [pc, #60]	; (9710 <HAL_ADC_Init+0x510>)
    96d4:	f00f fe9e 	bl	19414 <assert_failed>
    96d8:	e7d7      	b.n	968a <HAL_ADC_Init+0x48a>
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
    96da:	f44f 7121 	mov.w	r1, #644	; 0x284
    96de:	480c      	ldr	r0, [pc, #48]	; (9710 <HAL_ADC_Init+0x510>)
    96e0:	f00f fe98 	bl	19414 <assert_failed>
    96e4:	e7cc      	b.n	9680 <HAL_ADC_Init+0x480>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
    96e6:	f240 2182 	movw	r1, #642	; 0x282
    96ea:	4809      	ldr	r0, [pc, #36]	; (9710 <HAL_ADC_Init+0x510>)
    96ec:	f00f fe92 	bl	19414 <assert_failed>
    96f0:	e7b3      	b.n	965a <HAL_ADC_Init+0x45a>
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
    96f2:	f240 2183 	movw	r1, #643	; 0x283
    96f6:	4806      	ldr	r0, [pc, #24]	; (9710 <HAL_ADC_Init+0x510>)
    96f8:	f00f fe8c 	bl	19414 <assert_failed>
    96fc:	e7bc      	b.n	9678 <HAL_ADC_Init+0x478>
    96fe:	bf00      	nop
    9700:	40022000 	.word	0x40022000
    9704:	58026000 	.word	0x58026000
    9708:	58026300 	.word	0x58026300
    970c:	fff0c003 	.word	0xfff0c003
    9710:	0002fb64 	.word	0x0002fb64
    9714:	ffffbffc 	.word	0xffffbffc
    9718:	40022100 	.word	0x40022100
    971c:	40022300 	.word	0x40022300
    9720:	fc00f81e 	.word	0xfc00f81e

00009724 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t CalibrationMode, uint32_t SingleDiff)
{
    9724:	b5f0      	push	{r4, r5, r6, r7, lr}
    9726:	4604      	mov	r4, r0
    9728:	4616      	mov	r6, r2
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    972a:	4835      	ldr	r0, [pc, #212]	; (9800 <HAL_ADCEx_Calibration_Start+0xdc>)
{
    972c:	b083      	sub	sp, #12
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    972e:	6823      	ldr	r3, [r4, #0]
  __IO uint32_t wait_loop_index = 0UL;
    9730:	2700      	movs	r7, #0
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    9732:	4a34      	ldr	r2, [pc, #208]	; (9804 <HAL_ADCEx_Calibration_Start+0xe0>)
{
    9734:	460d      	mov	r5, r1
  __IO uint32_t wait_loop_index = 0UL;
    9736:	9701      	str	r7, [sp, #4]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    9738:	4283      	cmp	r3, r0
    973a:	bf18      	it	ne
    973c:	4293      	cmpne	r3, r2
    973e:	d002      	beq.n	9746 <HAL_ADCEx_Calibration_Start+0x22>
    9740:	4a31      	ldr	r2, [pc, #196]	; (9808 <HAL_ADCEx_Calibration_Start+0xe4>)
    9742:	4293      	cmp	r3, r2
    9744:	d14b      	bne.n	97de <HAL_ADCEx_Calibration_Start+0xba>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
    9746:	f240 73ff 	movw	r3, #2047	; 0x7ff
    974a:	429e      	cmp	r6, r3
    974c:	d002      	beq.n	9754 <HAL_ADCEx_Calibration_Start+0x30>
    974e:	4b2f      	ldr	r3, [pc, #188]	; (980c <HAL_ADCEx_Calibration_Start+0xe8>)
    9750:	429e      	cmp	r6, r3
    9752:	d139      	bne.n	97c8 <HAL_ADCEx_Calibration_Start+0xa4>

  /* Process locked */
  __HAL_LOCK(hadc);
    9754:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    9758:	2b01      	cmp	r3, #1
    975a:	d03d      	beq.n	97d8 <HAL_ADCEx_Calibration_Start+0xb4>
    975c:	2301      	movs	r3, #1

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
    975e:	4620      	mov	r0, r4
  __HAL_LOCK(hadc);
    9760:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  tmp_hal_status = ADC_Disable(hadc);
    9764:	f7ff fc64 	bl	9030 <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
    9768:	bb28      	cbnz	r0, 97b6 <HAL_ADCEx_Calibration_Start+0x92>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
    976a:	6d61      	ldr	r1, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
    976c:	f405 3380 	and.w	r3, r5, #65536	; 0x10000
    9770:	4a27      	ldr	r2, [pc, #156]	; (9810 <HAL_ADCEx_Calibration_Start+0xec>)
    9772:	f006 4680 	and.w	r6, r6, #1073741824	; 0x40000000
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);

    /* Start ADC calibration in mode single-ended or differential */
    LL_ADC_StartCalibration(hadc->Instance , CalibrationMode, SingleDiff );
    9776:	6827      	ldr	r7, [r4, #0]
    9778:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    ADC_STATE_CLR_SET(hadc->State,
    977c:	400a      	ands	r2, r1
    977e:	4d25      	ldr	r5, [pc, #148]	; (9814 <HAL_ADCEx_Calibration_Start+0xf0>)
    9780:	4333      	orrs	r3, r6

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
    9782:	4925      	ldr	r1, [pc, #148]	; (9818 <HAL_ADCEx_Calibration_Start+0xf4>)
    ADC_STATE_CLR_SET(hadc->State,
    9784:	f042 0202 	orr.w	r2, r2, #2
    9788:	6562      	str	r2, [r4, #84]	; 0x54
    978a:	68ba      	ldr	r2, [r7, #8]
    978c:	4015      	ands	r5, r2
    978e:	432b      	orrs	r3, r5
    9790:	60bb      	str	r3, [r7, #8]
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    9792:	6822      	ldr	r2, [r4, #0]
    9794:	e005      	b.n	97a2 <HAL_ADCEx_Calibration_Start+0x7e>
      wait_loop_index++;
    9796:	9b01      	ldr	r3, [sp, #4]
    9798:	3301      	adds	r3, #1
    979a:	9301      	str	r3, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
    979c:	9b01      	ldr	r3, [sp, #4]
    979e:	428b      	cmp	r3, r1
    97a0:	d822      	bhi.n	97e8 <HAL_ADCEx_Calibration_Start+0xc4>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
    97a2:	6893      	ldr	r3, [r2, #8]
    97a4:	2b00      	cmp	r3, #0
    97a6:	dbf6      	blt.n	9796 <HAL_ADCEx_Calibration_Start+0x72>
        return HAL_ERROR;
      }
    }

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
    97a8:	6d63      	ldr	r3, [r4, #84]	; 0x54
    97aa:	f023 0303 	bic.w	r3, r3, #3
    97ae:	f043 0301 	orr.w	r3, r3, #1
    97b2:	6563      	str	r3, [r4, #84]	; 0x54
    97b4:	e003      	b.n	97be <HAL_ADCEx_Calibration_Start+0x9a>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    97b6:	6d63      	ldr	r3, [r4, #84]	; 0x54
    97b8:	f043 0310 	orr.w	r3, r3, #16
    97bc:	6563      	str	r3, [r4, #84]	; 0x54
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
    97be:	2300      	movs	r3, #0
    97c0:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50

  /* Return function status */
  return tmp_hal_status;
}
    97c4:	b003      	add	sp, #12
    97c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
    97c8:	218f      	movs	r1, #143	; 0x8f
    97ca:	4814      	ldr	r0, [pc, #80]	; (981c <HAL_ADCEx_Calibration_Start+0xf8>)
    97cc:	f00f fe22 	bl	19414 <assert_failed>
  __HAL_LOCK(hadc);
    97d0:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    97d4:	2b01      	cmp	r3, #1
    97d6:	d1c1      	bne.n	975c <HAL_ADCEx_Calibration_Start+0x38>
    97d8:	2002      	movs	r0, #2
}
    97da:	b003      	add	sp, #12
    97dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    97de:	218e      	movs	r1, #142	; 0x8e
    97e0:	480e      	ldr	r0, [pc, #56]	; (981c <HAL_ADCEx_Calibration_Start+0xf8>)
    97e2:	f00f fe17 	bl	19414 <assert_failed>
    97e6:	e7ae      	b.n	9746 <HAL_ADCEx_Calibration_Start+0x22>
        ADC_STATE_CLR_SET(hadc->State,
    97e8:	6d63      	ldr	r3, [r4, #84]	; 0x54
        __HAL_UNLOCK(hadc);
    97ea:	2200      	movs	r2, #0
        return HAL_ERROR;
    97ec:	2001      	movs	r0, #1
        ADC_STATE_CLR_SET(hadc->State,
    97ee:	f023 0312 	bic.w	r3, r3, #18
        __HAL_UNLOCK(hadc);
    97f2:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
        ADC_STATE_CLR_SET(hadc->State,
    97f6:	f043 0310 	orr.w	r3, r3, #16
    97fa:	6563      	str	r3, [r4, #84]	; 0x54
}
    97fc:	b003      	add	sp, #12
    97fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9800:	40022000 	.word	0x40022000
    9804:	40022100 	.word	0x40022100
    9808:	58026000 	.word	0x58026000
    980c:	47ff0000 	.word	0x47ff0000
    9810:	ffffeefd 	.word	0xffffeefd
    9814:	3ffeffc0 	.word	0x3ffeffc0
    9818:	25c3f7ff 	.word	0x25c3f7ff
    981c:	0002fb9c 	.word	0x0002fb9c

00009820 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param multimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, ADC_MultiModeTypeDef *multimode)
{
    9820:	b570      	push	{r4, r5, r6, lr}
  ADC_Common_TypeDef *tmpADC_Common;
  ADC_HandleTypeDef  tmphadcSlave;
  uint32_t tmphadcSlave_conversion_on_going;

  /* Check the parameters */
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
    9822:	4b58      	ldr	r3, [pc, #352]	; (9984 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
{
    9824:	4604      	mov	r4, r0
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
    9826:	6802      	ldr	r2, [r0, #0]
{
    9828:	460d      	mov	r5, r1
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
    982a:	429a      	cmp	r2, r3
    982c:	d004      	beq.n	9838 <HAL_ADCEx_MultiModeConfigChannel+0x18>
    982e:	f640 01bd 	movw	r1, #2237	; 0x8bd
    9832:	4855      	ldr	r0, [pc, #340]	; (9988 <HAL_ADCEx_MultiModeConfigChannel+0x168>)
    9834:	f00f fdee 	bl	19414 <assert_failed>
  assert_param(IS_ADC_MULTIMODE(multimode->Mode));
    9838:	682b      	ldr	r3, [r5, #0]
    983a:	2b09      	cmp	r3, #9
    983c:	d933      	bls.n	98a6 <HAL_ADCEx_MultiModeConfigChannel+0x86>
    983e:	f640 01be 	movw	r1, #2238	; 0x8be
    9842:	4851      	ldr	r0, [pc, #324]	; (9988 <HAL_ADCEx_MultiModeConfigChannel+0x168>)
    9844:	f00f fde6 	bl	19414 <assert_failed>
    9848:	682b      	ldr	r3, [r5, #0]
  if (multimode->Mode != ADC_MODE_INDEPENDENT)
    984a:	b1cb      	cbz	r3, 9880 <HAL_ADCEx_MultiModeConfigChannel+0x60>
  {
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
    984c:	686b      	ldr	r3, [r5, #4]
    984e:	f433 4200 	bics.w	r2, r3, #32768	; 0x8000
    9852:	d002      	beq.n	985a <HAL_ADCEx_MultiModeConfigChannel+0x3a>
    9854:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
    9858:	d15c      	bne.n	9914 <HAL_ADCEx_MultiModeConfigChannel+0xf4>
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
    985a:	68ab      	ldr	r3, [r5, #8]
    985c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    9860:	bf18      	it	ne
    9862:	f5b3 6fe0 	cmpne.w	r3, #1792	; 0x700
    9866:	bf14      	ite	ne
    9868:	2201      	movne	r2, #1
    986a:	2200      	moveq	r2, #0
    986c:	f433 7140 	bics.w	r1, r3, #768	; 0x300
    9870:	bf08      	it	eq
    9872:	2200      	moveq	r2, #0
    9874:	b122      	cbz	r2, 9880 <HAL_ADCEx_MultiModeConfigChannel+0x60>
    9876:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    987a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    987e:	d179      	bne.n	9974 <HAL_ADCEx_MultiModeConfigChannel+0x154>
  }

  /* Process locked */
  __HAL_LOCK(hadc);
    9880:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    9884:	2b01      	cmp	r3, #1
    9886:	d04b      	beq.n	9920 <HAL_ADCEx_MultiModeConfigChannel+0x100>

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
    9888:	4a3e      	ldr	r2, [pc, #248]	; (9984 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
  __HAL_LOCK(hadc);
    988a:	2001      	movs	r0, #1
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
    988c:	6823      	ldr	r3, [r4, #0]
  __HAL_LOCK(hadc);
    988e:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
    9892:	4293      	cmp	r3, r2
    9894:	d00d      	beq.n	98b2 <HAL_ADCEx_MultiModeConfigChannel+0x92>

  if (tmphadcSlave.Instance == NULL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    9896:	6d63      	ldr	r3, [r4, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
    9898:	2200      	movs	r2, #0
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    989a:	f043 0320 	orr.w	r3, r3, #32
    __HAL_UNLOCK(hadc);
    989e:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    98a2:	6563      	str	r3, [r4, #84]	; 0x54
  /* Process unlocked */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return tmp_hal_status;
}
    98a4:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_ADC_MULTIMODE(multimode->Mode));
    98a6:	f240 22ef 	movw	r2, #751	; 0x2ef
    98aa:	40da      	lsrs	r2, r3
    98ac:	07d6      	lsls	r6, r2, #31
    98ae:	d4cc      	bmi.n	984a <HAL_ADCEx_MultiModeConfigChannel+0x2a>
    98b0:	e7c5      	b.n	983e <HAL_ADCEx_MultiModeConfigChannel+0x1e>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    98b2:	4a36      	ldr	r2, [pc, #216]	; (998c <HAL_ADCEx_MultiModeConfigChannel+0x16c>)
    98b4:	6891      	ldr	r1, [r2, #8]
    98b6:	0749      	lsls	r1, r1, #29
    98b8:	d509      	bpl.n	98ce <HAL_ADCEx_MultiModeConfigChannel+0xae>
    98ba:	689b      	ldr	r3, [r3, #8]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    98bc:	6d63      	ldr	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
    98be:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    98c0:	f043 0320 	orr.w	r3, r3, #32
    98c4:	6563      	str	r3, [r4, #84]	; 0x54
  __HAL_UNLOCK(hadc);
    98c6:	2300      	movs	r3, #0
    98c8:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
}
    98cc:	bd70      	pop	{r4, r5, r6, pc}
    98ce:	6899      	ldr	r1, [r3, #8]
    98d0:	0748      	lsls	r0, r1, #29
    98d2:	d4f3      	bmi.n	98bc <HAL_ADCEx_MultiModeConfigChannel+0x9c>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
    98d4:	6829      	ldr	r1, [r5, #0]
    MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, multimode->DualModeData);
    98d6:	482e      	ldr	r0, [pc, #184]	; (9990 <HAL_ADCEx_MultiModeConfigChannel+0x170>)
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
    98d8:	b321      	cbz	r1, 9924 <HAL_ADCEx_MultiModeConfigChannel+0x104>
    MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, multimode->DualModeData);
    98da:	6881      	ldr	r1, [r0, #8]
    98dc:	686e      	ldr	r6, [r5, #4]
    98de:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
    98e2:	4331      	orrs	r1, r6
    98e4:	6081      	str	r1, [r0, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    98e6:	6821      	ldr	r1, [r4, #0]
    98e8:	4299      	cmp	r1, r3
    98ea:	d03a      	beq.n	9962 <HAL_ADCEx_MultiModeConfigChannel+0x142>
    98ec:	4291      	cmp	r1, r2
    98ee:	d038      	beq.n	9962 <HAL_ADCEx_MultiModeConfigChannel+0x142>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    98f0:	4b28      	ldr	r3, [pc, #160]	; (9994 <HAL_ADCEx_MultiModeConfigChannel+0x174>)
    98f2:	689b      	ldr	r3, [r3, #8]
    98f4:	43db      	mvns	r3, r3
    98f6:	f003 0301 	and.w	r3, r3, #1
    98fa:	2b00      	cmp	r3, #0
    98fc:	d040      	beq.n	9980 <HAL_ADCEx_MultiModeConfigChannel+0x160>
        MODIFY_REG(tmpADC_Common->CCR,
    98fe:	4924      	ldr	r1, [pc, #144]	; (9990 <HAL_ADCEx_MultiModeConfigChannel+0x170>)
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9900:	2000      	movs	r0, #0
        MODIFY_REG(tmpADC_Common->CCR,
    9902:	682b      	ldr	r3, [r5, #0]
    9904:	688e      	ldr	r6, [r1, #8]
    9906:	68ad      	ldr	r5, [r5, #8]
    9908:	4a23      	ldr	r2, [pc, #140]	; (9998 <HAL_ADCEx_MultiModeConfigChannel+0x178>)
    990a:	432b      	orrs	r3, r5
    990c:	4032      	ands	r2, r6
    990e:	4313      	orrs	r3, r2
    9910:	608b      	str	r3, [r1, #8]
    9912:	e7d8      	b.n	98c6 <HAL_ADCEx_MultiModeConfigChannel+0xa6>
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
    9914:	f640 01c1 	movw	r1, #2241	; 0x8c1
    9918:	481b      	ldr	r0, [pc, #108]	; (9988 <HAL_ADCEx_MultiModeConfigChannel+0x168>)
    991a:	f00f fd7b 	bl	19414 <assert_failed>
    991e:	e79c      	b.n	985a <HAL_ADCEx_MultiModeConfigChannel+0x3a>
  __HAL_LOCK(hadc);
    9920:	2002      	movs	r0, #2
}
    9922:	bd70      	pop	{r4, r5, r6, pc}
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DAMDF);
    9924:	6881      	ldr	r1, [r0, #8]
    9926:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
    992a:	6081      	str	r1, [r0, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    992c:	6821      	ldr	r1, [r4, #0]
    992e:	4299      	cmp	r1, r3
    9930:	d00e      	beq.n	9950 <HAL_ADCEx_MultiModeConfigChannel+0x130>
    9932:	4291      	cmp	r1, r2
    9934:	d00c      	beq.n	9950 <HAL_ADCEx_MultiModeConfigChannel+0x130>
    9936:	4b17      	ldr	r3, [pc, #92]	; (9994 <HAL_ADCEx_MultiModeConfigChannel+0x174>)
    9938:	689b      	ldr	r3, [r3, #8]
    993a:	43db      	mvns	r3, r3
    993c:	f003 0301 	and.w	r3, r3, #1
    9940:	b1f3      	cbz	r3, 9980 <HAL_ADCEx_MultiModeConfigChannel+0x160>
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
    9942:	4a13      	ldr	r2, [pc, #76]	; (9990 <HAL_ADCEx_MultiModeConfigChannel+0x170>)
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9944:	2000      	movs	r0, #0
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
    9946:	4b14      	ldr	r3, [pc, #80]	; (9998 <HAL_ADCEx_MultiModeConfigChannel+0x178>)
    9948:	6891      	ldr	r1, [r2, #8]
    994a:	400b      	ands	r3, r1
    994c:	6093      	str	r3, [r2, #8]
    994e:	e7ba      	b.n	98c6 <HAL_ADCEx_MultiModeConfigChannel+0xa6>
    9950:	4a0c      	ldr	r2, [pc, #48]	; (9984 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
    9952:	4b0e      	ldr	r3, [pc, #56]	; (998c <HAL_ADCEx_MultiModeConfigChannel+0x16c>)
    9954:	6892      	ldr	r2, [r2, #8]
    9956:	689b      	ldr	r3, [r3, #8]
    9958:	4313      	orrs	r3, r2
    995a:	43db      	mvns	r3, r3
    995c:	f003 0301 	and.w	r3, r3, #1
    9960:	e7ee      	b.n	9940 <HAL_ADCEx_MultiModeConfigChannel+0x120>
    9962:	4a08      	ldr	r2, [pc, #32]	; (9984 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
    9964:	4b09      	ldr	r3, [pc, #36]	; (998c <HAL_ADCEx_MultiModeConfigChannel+0x16c>)
    9966:	6892      	ldr	r2, [r2, #8]
    9968:	689b      	ldr	r3, [r3, #8]
    996a:	4313      	orrs	r3, r2
    996c:	43db      	mvns	r3, r3
    996e:	f003 0301 	and.w	r3, r3, #1
    9972:	e7c2      	b.n	98fa <HAL_ADCEx_MultiModeConfigChannel+0xda>
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
    9974:	f640 01c2 	movw	r1, #2242	; 0x8c2
    9978:	4803      	ldr	r0, [pc, #12]	; (9988 <HAL_ADCEx_MultiModeConfigChannel+0x168>)
    997a:	f00f fd4b 	bl	19414 <assert_failed>
    997e:	e77f      	b.n	9880 <HAL_ADCEx_MultiModeConfigChannel+0x60>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9980:	2000      	movs	r0, #0
    9982:	e7a0      	b.n	98c6 <HAL_ADCEx_MultiModeConfigChannel+0xa6>
    9984:	40022000 	.word	0x40022000
    9988:	0002fb9c 	.word	0x0002fb9c
    998c:	40022100 	.word	0x40022100
    9990:	40022300 	.word	0x40022300
    9994:	58026000 	.word	0x58026000
    9998:	fffff0e0 	.word	0xfffff0e0

0000999c <HAL_NVIC_SetPriorityGrouping>:
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
    999c:	1ec3      	subs	r3, r0, #3
    999e:	2b04      	cmp	r3, #4
{
    99a0:	b510      	push	{r4, lr}
    99a2:	4604      	mov	r4, r0
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
    99a4:	d903      	bls.n	99ae <HAL_NVIC_SetPriorityGrouping+0x12>
    99a6:	2192      	movs	r1, #146	; 0x92
    99a8:	4807      	ldr	r0, [pc, #28]	; (99c8 <HAL_NVIC_SetPriorityGrouping+0x2c>)
    99aa:	f00f fd33 	bl	19414 <assert_failed>
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
    99ae:	4907      	ldr	r1, [pc, #28]	; (99cc <HAL_NVIC_SetPriorityGrouping+0x30>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
    99b0:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
    99b4:	0224      	lsls	r4, r4, #8
    99b6:	4b06      	ldr	r3, [pc, #24]	; (99d0 <HAL_NVIC_SetPriorityGrouping+0x34>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
    99b8:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
    99ba:	f404 64e0 	and.w	r4, r4, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
    99be:	4002      	ands	r2, r0
    99c0:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
    99c2:	431c      	orrs	r4, r3
  SCB->AIRCR =  reg_value;
    99c4:	60cc      	str	r4, [r1, #12]

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
    99c6:	bd10      	pop	{r4, pc}
    99c8:	0002fbd8 	.word	0x0002fbd8
    99cc:	e000ed00 	.word	0xe000ed00
    99d0:	05fa0000 	.word	0x05fa0000

000099d4 <HAL_NVIC_SetPriority>:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
    99d4:	2a0f      	cmp	r2, #15
{
    99d6:	b570      	push	{r4, r5, r6, lr}
    99d8:	4616      	mov	r6, r2
    99da:	4605      	mov	r5, r0
    99dc:	460c      	mov	r4, r1
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
    99de:	d832      	bhi.n	9a46 <HAL_NVIC_SetPriority+0x72>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
    99e0:	2c0f      	cmp	r4, #15
    99e2:	d82b      	bhi.n	9a3c <HAL_NVIC_SetPriority+0x68>
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
    99e4:	4b1a      	ldr	r3, [pc, #104]	; (9a50 <HAL_NVIC_SetPriority+0x7c>)
    99e6:	68db      	ldr	r3, [r3, #12]
    99e8:	f3c3 2302 	ubfx	r3, r3, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
    99ec:	f1c3 0107 	rsb	r1, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
    99f0:	1d1a      	adds	r2, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
    99f2:	2904      	cmp	r1, #4
    99f4:	bf28      	it	cs
    99f6:	2104      	movcs	r1, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
    99f8:	2a06      	cmp	r2, #6
    99fa:	d917      	bls.n	9a2c <HAL_NVIC_SetPriority+0x58>
    99fc:	3b03      	subs	r3, #3
    99fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9a02:	409a      	lsls	r2, r3
    9a04:	ea26 0602 	bic.w	r6, r6, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
    9a08:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  if ((int32_t)(IRQn) >= 0)
    9a0c:	2d00      	cmp	r5, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
    9a0e:	fa02 f201 	lsl.w	r2, r2, r1
    9a12:	ea24 0202 	bic.w	r2, r4, r2
    9a16:	fa02 f203 	lsl.w	r2, r2, r3
    9a1a:	ea42 0206 	orr.w	r2, r2, r6
    9a1e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9a22:	b2d2      	uxtb	r2, r2
  if ((int32_t)(IRQn) >= 0)
    9a24:	db05      	blt.n	9a32 <HAL_NVIC_SetPriority+0x5e>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9a26:	4b0b      	ldr	r3, [pc, #44]	; (9a54 <HAL_NVIC_SetPriority+0x80>)
    9a28:	555a      	strb	r2, [r3, r5]

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
    9a2a:	bd70      	pop	{r4, r5, r6, pc}
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
    9a2c:	2600      	movs	r6, #0
    9a2e:	4633      	mov	r3, r6
    9a30:	e7ea      	b.n	9a08 <HAL_NVIC_SetPriority+0x34>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9a32:	f005 050f 	and.w	r5, r5, #15
    9a36:	4b08      	ldr	r3, [pc, #32]	; (9a58 <HAL_NVIC_SetPriority+0x84>)
    9a38:	555a      	strb	r2, [r3, r5]
    9a3a:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
    9a3c:	21ab      	movs	r1, #171	; 0xab
    9a3e:	4807      	ldr	r0, [pc, #28]	; (9a5c <HAL_NVIC_SetPriority+0x88>)
    9a40:	f00f fce8 	bl	19414 <assert_failed>
    9a44:	e7ce      	b.n	99e4 <HAL_NVIC_SetPriority+0x10>
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
    9a46:	21aa      	movs	r1, #170	; 0xaa
    9a48:	4804      	ldr	r0, [pc, #16]	; (9a5c <HAL_NVIC_SetPriority+0x88>)
    9a4a:	f00f fce3 	bl	19414 <assert_failed>
    9a4e:	e7c7      	b.n	99e0 <HAL_NVIC_SetPriority+0xc>
    9a50:	e000ed00 	.word	0xe000ed00
    9a54:	e000e400 	.word	0xe000e400
    9a58:	e000ed14 	.word	0xe000ed14
    9a5c:	0002fbd8 	.word	0x0002fbd8

00009a60 <HAL_NVIC_EnableIRQ>:
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9a60:	2800      	cmp	r0, #0
    9a62:	db08      	blt.n	9a76 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9a64:	f000 011f 	and.w	r1, r0, #31
    9a68:	2301      	movs	r3, #1
    9a6a:	0940      	lsrs	r0, r0, #5
    9a6c:	4a04      	ldr	r2, [pc, #16]	; (9a80 <HAL_NVIC_EnableIRQ+0x20>)
    9a6e:	408b      	lsls	r3, r1
    9a70:	f842 3020 	str.w	r3, [r2, r0, lsl #2]

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
    9a74:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9a76:	21be      	movs	r1, #190	; 0xbe
    9a78:	4802      	ldr	r0, [pc, #8]	; (9a84 <HAL_NVIC_EnableIRQ+0x24>)
    9a7a:	f00f bccb 	b.w	19414 <assert_failed>
    9a7e:	bf00      	nop
    9a80:	e000e100 	.word	0xe000e100
    9a84:	0002fbd8 	.word	0x0002fbd8

00009a88 <HAL_NVIC_DisableIRQ>:
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9a88:	2800      	cmp	r0, #0
    9a8a:	db0e      	blt.n	9aaa <HAL_NVIC_DisableIRQ+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9a8c:	0943      	lsrs	r3, r0, #5
    9a8e:	2201      	movs	r2, #1
    9a90:	f000 001f 	and.w	r0, r0, #31
    9a94:	4907      	ldr	r1, [pc, #28]	; (9ab4 <HAL_NVIC_DisableIRQ+0x2c>)
    9a96:	3320      	adds	r3, #32
    9a98:	fa02 f000 	lsl.w	r0, r2, r0
    9a9c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    9aa0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    9aa4:	f3bf 8f6f 	isb	sy

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
    9aa8:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9aaa:	21ce      	movs	r1, #206	; 0xce
    9aac:	4802      	ldr	r0, [pc, #8]	; (9ab8 <HAL_NVIC_DisableIRQ+0x30>)
    9aae:	f00f bcb1 	b.w	19414 <assert_failed>
    9ab2:	bf00      	nop
    9ab4:	e000e100 	.word	0xe000e100
    9ab8:	0002fbd8 	.word	0x0002fbd8

00009abc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
    9abc:	3801      	subs	r0, #1
    9abe:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
    9ac2:	d20d      	bcs.n	9ae0 <HAL_SYSTICK_Config+0x24>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    9ac4:	4b07      	ldr	r3, [pc, #28]	; (9ae4 <HAL_SYSTICK_Config+0x28>)
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    9ac6:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    9ac8:	2107      	movs	r1, #7
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
    9aca:	b430      	push	{r4, r5}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9acc:	25f0      	movs	r5, #240	; 0xf0
    9ace:	4c06      	ldr	r4, [pc, #24]	; (9ae8 <HAL_SYSTICK_Config+0x2c>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    9ad0:	6058      	str	r0, [r3, #4]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
    9ad2:	4610      	mov	r0, r2
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9ad4:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    9ad8:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    9ada:	6019      	str	r1, [r3, #0]
   return SysTick_Config(TicksNumb);
}
    9adc:	bc30      	pop	{r4, r5}
    9ade:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
    9ae0:	2001      	movs	r0, #1
    9ae2:	4770      	bx	lr
    9ae4:	e000e010 	.word	0xe000e010
    9ae8:	e000ed00 	.word	0xe000ed00

00009aec <HAL_MPU_Disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    9aec:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
    9af0:	4a04      	ldr	r2, [pc, #16]	; (9b04 <HAL_MPU_Disable+0x18>)

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
    9af2:	2000      	movs	r0, #0
    9af4:	4904      	ldr	r1, [pc, #16]	; (9b08 <HAL_MPU_Disable+0x1c>)
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
    9af6:	6a53      	ldr	r3, [r2, #36]	; 0x24
    9af8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    9afc:	6253      	str	r3, [r2, #36]	; 0x24
  MPU->CTRL = 0;
    9afe:	6048      	str	r0, [r1, #4]
}
    9b00:	4770      	bx	lr
    9b02:	bf00      	nop
    9b04:	e000ed00 	.word	0xe000ed00
    9b08:	e000ed90 	.word	0xe000ed90

00009b0c <HAL_MPU_Enable>:
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
    9b0c:	4a06      	ldr	r2, [pc, #24]	; (9b28 <HAL_MPU_Enable+0x1c>)
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
    9b0e:	f040 0001 	orr.w	r0, r0, #1
    9b12:	4b06      	ldr	r3, [pc, #24]	; (9b2c <HAL_MPU_Enable+0x20>)
    9b14:	6058      	str	r0, [r3, #4]
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
    9b16:	6a53      	ldr	r3, [r2, #36]	; 0x24
    9b18:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    9b1c:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
    9b1e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    9b22:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
    9b26:	4770      	bx	lr
    9b28:	e000ed00 	.word	0xe000ed00
    9b2c:	e000ed90 	.word	0xe000ed90

00009b30 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
    9b30:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
    9b32:	7843      	ldrb	r3, [r0, #1]
{
    9b34:	4604      	mov	r4, r0
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
    9b36:	2b0f      	cmp	r3, #15
    9b38:	d86f      	bhi.n	9c1a <HAL_MPU_ConfigRegion+0xea>
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
    9b3a:	7823      	ldrb	r3, [r4, #0]
    9b3c:	2b01      	cmp	r3, #1
    9b3e:	d904      	bls.n	9b4a <HAL_MPU_ConfigRegion+0x1a>
    9b40:	f44f 7197 	mov.w	r1, #302	; 0x12e
    9b44:	4849      	ldr	r0, [pc, #292]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9b46:	f00f fc65 	bl	19414 <assert_failed>

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
    9b4a:	7862      	ldrb	r2, [r4, #1]
    9b4c:	4b48      	ldr	r3, [pc, #288]	; (9c70 <HAL_MPU_ConfigRegion+0x140>)
    9b4e:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
    9b50:	7822      	ldrb	r2, [r4, #0]
    9b52:	2a00      	cmp	r2, #0
    9b54:	d039      	beq.n	9bca <HAL_MPU_ConfigRegion+0x9a>
  {
    /* Check the parameters */
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
    9b56:	7b23      	ldrb	r3, [r4, #12]
    9b58:	2b01      	cmp	r3, #1
    9b5a:	d839      	bhi.n	9bd0 <HAL_MPU_ConfigRegion+0xa0>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    9b5c:	7ae3      	ldrb	r3, [r4, #11]
    9b5e:	1f5a      	subs	r2, r3, #5
    9b60:	2a01      	cmp	r2, #1
    9b62:	d901      	bls.n	9b68 <HAL_MPU_ConfigRegion+0x38>
    9b64:	2b03      	cmp	r3, #3
    9b66:	d86d      	bhi.n	9c44 <HAL_MPU_ConfigRegion+0x114>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    9b68:	7aa3      	ldrb	r3, [r4, #10]
    9b6a:	2b02      	cmp	r3, #2
    9b6c:	d861      	bhi.n	9c32 <HAL_MPU_ConfigRegion+0x102>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    9b6e:	7b63      	ldrb	r3, [r4, #13]
    9b70:	2b01      	cmp	r3, #1
    9b72:	d849      	bhi.n	9c08 <HAL_MPU_ConfigRegion+0xd8>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    9b74:	7ba3      	ldrb	r3, [r4, #14]
    9b76:	2b01      	cmp	r3, #1
    9b78:	d83d      	bhi.n	9bf6 <HAL_MPU_ConfigRegion+0xc6>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    9b7a:	7be3      	ldrb	r3, [r4, #15]
    9b7c:	2b01      	cmp	r3, #1
    9b7e:	d831      	bhi.n	9be4 <HAL_MPU_ConfigRegion+0xb4>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    9b80:	7a63      	ldrb	r3, [r4, #9]
    9b82:	2bff      	cmp	r3, #255	; 0xff
    9b84:	d067      	beq.n	9c56 <HAL_MPU_ConfigRegion+0x126>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    9b86:	7a23      	ldrb	r3, [r4, #8]
    9b88:	3b04      	subs	r3, #4
    9b8a:	2b1b      	cmp	r3, #27
    9b8c:	d84b      	bhi.n	9c26 <HAL_MPU_ConfigRegion+0xf6>

    MPU->RBAR = MPU_Init->BaseAddress;
    9b8e:	6863      	ldr	r3, [r4, #4]
    9b90:	4a37      	ldr	r2, [pc, #220]	; (9c70 <HAL_MPU_ConfigRegion+0x140>)
    9b92:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
    9b94:	7ae3      	ldrb	r3, [r4, #11]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
    9b96:	7b21      	ldrb	r1, [r4, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
    9b98:	061b      	lsls	r3, r3, #24
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
    9b9a:	7825      	ldrb	r5, [r4, #0]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
    9b9c:	7aa0      	ldrb	r0, [r4, #10]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
    9b9e:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
    9ba2:	7b61      	ldrb	r1, [r4, #13]
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
    9ba4:	7ba6      	ldrb	r6, [r4, #14]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
    9ba6:	432b      	orrs	r3, r5
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
    9ba8:	7be5      	ldrb	r5, [r4, #15]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
    9baa:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
    9bae:	7a60      	ldrb	r0, [r4, #9]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
    9bb0:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
    9bb4:	7a21      	ldrb	r1, [r4, #8]
    9bb6:	ea43 4346 	orr.w	r3, r3, r6, lsl #17
    9bba:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
    9bbe:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    9bc2:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
    9bc6:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
    9bc8:	bd70      	pop	{r4, r5, r6, pc}
    MPU->RBAR = 0x00;
    9bca:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
    9bcc:	611a      	str	r2, [r3, #16]
}
    9bce:	bd70      	pop	{r4, r5, r6, pc}
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
    9bd0:	f44f 719b 	mov.w	r1, #310	; 0x136
    9bd4:	4825      	ldr	r0, [pc, #148]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9bd6:	f00f fc1d 	bl	19414 <assert_failed>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    9bda:	7ae3      	ldrb	r3, [r4, #11]
    9bdc:	1f5a      	subs	r2, r3, #5
    9bde:	2a01      	cmp	r2, #1
    9be0:	d8c0      	bhi.n	9b64 <HAL_MPU_ConfigRegion+0x34>
    9be2:	e7c1      	b.n	9b68 <HAL_MPU_ConfigRegion+0x38>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    9be4:	f240 113b 	movw	r1, #315	; 0x13b
    9be8:	4820      	ldr	r0, [pc, #128]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9bea:	f00f fc13 	bl	19414 <assert_failed>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    9bee:	7a63      	ldrb	r3, [r4, #9]
    9bf0:	2bff      	cmp	r3, #255	; 0xff
    9bf2:	d1c8      	bne.n	9b86 <HAL_MPU_ConfigRegion+0x56>
    9bf4:	e02f      	b.n	9c56 <HAL_MPU_ConfigRegion+0x126>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    9bf6:	f44f 719d 	mov.w	r1, #314	; 0x13a
    9bfa:	481c      	ldr	r0, [pc, #112]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9bfc:	f00f fc0a 	bl	19414 <assert_failed>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    9c00:	7be3      	ldrb	r3, [r4, #15]
    9c02:	2b01      	cmp	r3, #1
    9c04:	d9bc      	bls.n	9b80 <HAL_MPU_ConfigRegion+0x50>
    9c06:	e7ed      	b.n	9be4 <HAL_MPU_ConfigRegion+0xb4>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    9c08:	f240 1139 	movw	r1, #313	; 0x139
    9c0c:	4817      	ldr	r0, [pc, #92]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c0e:	f00f fc01 	bl	19414 <assert_failed>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    9c12:	7ba3      	ldrb	r3, [r4, #14]
    9c14:	2b01      	cmp	r3, #1
    9c16:	d9b0      	bls.n	9b7a <HAL_MPU_ConfigRegion+0x4a>
    9c18:	e7ed      	b.n	9bf6 <HAL_MPU_ConfigRegion+0xc6>
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
    9c1a:	f240 112d 	movw	r1, #301	; 0x12d
    9c1e:	4813      	ldr	r0, [pc, #76]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c20:	f00f fbf8 	bl	19414 <assert_failed>
    9c24:	e789      	b.n	9b3a <HAL_MPU_ConfigRegion+0xa>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    9c26:	f240 113d 	movw	r1, #317	; 0x13d
    9c2a:	4810      	ldr	r0, [pc, #64]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c2c:	f00f fbf2 	bl	19414 <assert_failed>
    9c30:	e7ad      	b.n	9b8e <HAL_MPU_ConfigRegion+0x5e>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    9c32:	f44f 719c 	mov.w	r1, #312	; 0x138
    9c36:	480d      	ldr	r0, [pc, #52]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c38:	f00f fbec 	bl	19414 <assert_failed>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    9c3c:	7b63      	ldrb	r3, [r4, #13]
    9c3e:	2b01      	cmp	r3, #1
    9c40:	d998      	bls.n	9b74 <HAL_MPU_ConfigRegion+0x44>
    9c42:	e7e1      	b.n	9c08 <HAL_MPU_ConfigRegion+0xd8>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    9c44:	f240 1137 	movw	r1, #311	; 0x137
    9c48:	4808      	ldr	r0, [pc, #32]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c4a:	f00f fbe3 	bl	19414 <assert_failed>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    9c4e:	7aa3      	ldrb	r3, [r4, #10]
    9c50:	2b02      	cmp	r3, #2
    9c52:	d98c      	bls.n	9b6e <HAL_MPU_ConfigRegion+0x3e>
    9c54:	e7ed      	b.n	9c32 <HAL_MPU_ConfigRegion+0x102>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    9c56:	f44f 719e 	mov.w	r1, #316	; 0x13c
    9c5a:	4804      	ldr	r0, [pc, #16]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c5c:	f00f fbda 	bl	19414 <assert_failed>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    9c60:	7a23      	ldrb	r3, [r4, #8]
    9c62:	3b04      	subs	r3, #4
    9c64:	2b1b      	cmp	r3, #27
    9c66:	d992      	bls.n	9b8e <HAL_MPU_ConfigRegion+0x5e>
    9c68:	e7dd      	b.n	9c26 <HAL_MPU_ConfigRegion+0xf6>
    9c6a:	bf00      	nop
    9c6c:	0002fbd8 	.word	0x0002fbd8
    9c70:	e000ed90 	.word	0xe000ed90

00009c74 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    9c74:	4b35      	ldr	r3, [pc, #212]	; (9d4c <DMA_CalcBaseAndBitshift+0xd8>)
{
    9c76:	4601      	mov	r1, r0
    9c78:	b430      	push	{r4, r5}
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    9c7a:	4c35      	ldr	r4, [pc, #212]	; (9d50 <DMA_CalcBaseAndBitshift+0xdc>)
    9c7c:	6802      	ldr	r2, [r0, #0]
    9c7e:	4835      	ldr	r0, [pc, #212]	; (9d54 <DMA_CalcBaseAndBitshift+0xe0>)
    9c80:	42a2      	cmp	r2, r4
    9c82:	bf18      	it	ne
    9c84:	429a      	cmpne	r2, r3
    9c86:	4d34      	ldr	r5, [pc, #208]	; (9d58 <DMA_CalcBaseAndBitshift+0xe4>)
    9c88:	f104 0448 	add.w	r4, r4, #72	; 0x48
    9c8c:	bf0c      	ite	eq
    9c8e:	2301      	moveq	r3, #1
    9c90:	2300      	movne	r3, #0
    9c92:	4282      	cmp	r2, r0
    9c94:	bf08      	it	eq
    9c96:	f043 0301 	orreq.w	r3, r3, #1
    9c9a:	3048      	adds	r0, #72	; 0x48
    9c9c:	42aa      	cmp	r2, r5
    9c9e:	bf08      	it	eq
    9ca0:	f043 0301 	orreq.w	r3, r3, #1
    9ca4:	3548      	adds	r5, #72	; 0x48
    9ca6:	42a2      	cmp	r2, r4
    9ca8:	bf08      	it	eq
    9caa:	f043 0301 	orreq.w	r3, r3, #1
    9cae:	3448      	adds	r4, #72	; 0x48
    9cb0:	4282      	cmp	r2, r0
    9cb2:	bf08      	it	eq
    9cb4:	f043 0301 	orreq.w	r3, r3, #1
    9cb8:	f500 7062 	add.w	r0, r0, #904	; 0x388
    9cbc:	42aa      	cmp	r2, r5
    9cbe:	bf08      	it	eq
    9cc0:	f043 0301 	orreq.w	r3, r3, #1
    9cc4:	f505 7562 	add.w	r5, r5, #904	; 0x388
    9cc8:	42a2      	cmp	r2, r4
    9cca:	bf08      	it	eq
    9ccc:	f043 0301 	orreq.w	r3, r3, #1
    9cd0:	f504 7462 	add.w	r4, r4, #904	; 0x388
    9cd4:	4282      	cmp	r2, r0
    9cd6:	bf08      	it	eq
    9cd8:	f043 0301 	orreq.w	r3, r3, #1
    9cdc:	3048      	adds	r0, #72	; 0x48
    9cde:	42aa      	cmp	r2, r5
    9ce0:	bf08      	it	eq
    9ce2:	f043 0301 	orreq.w	r3, r3, #1
    9ce6:	3548      	adds	r5, #72	; 0x48
    9ce8:	42a2      	cmp	r2, r4
    9cea:	bf08      	it	eq
    9cec:	f043 0301 	orreq.w	r3, r3, #1
    9cf0:	3448      	adds	r4, #72	; 0x48
    9cf2:	4282      	cmp	r2, r0
    9cf4:	bf08      	it	eq
    9cf6:	f043 0301 	orreq.w	r3, r3, #1
    9cfa:	3048      	adds	r0, #72	; 0x48
    9cfc:	42aa      	cmp	r2, r5
    9cfe:	bf08      	it	eq
    9d00:	f043 0301 	orreq.w	r3, r3, #1
    9d04:	42a2      	cmp	r2, r4
    9d06:	bf08      	it	eq
    9d08:	f043 0301 	orreq.w	r3, r3, #1
    9d0c:	4282      	cmp	r2, r0
    9d0e:	bf08      	it	eq
    9d10:	f043 0301 	orreq.w	r3, r3, #1
    9d14:	b913      	cbnz	r3, 9d1c <DMA_CalcBaseAndBitshift+0xa8>
    9d16:	4b11      	ldr	r3, [pc, #68]	; (9d5c <DMA_CalcBaseAndBitshift+0xe8>)
    9d18:	429a      	cmp	r2, r3
    9d1a:	d112      	bne.n	9d42 <DMA_CalcBaseAndBitshift+0xce>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    9d1c:	b2d3      	uxtb	r3, r2
    9d1e:	4d10      	ldr	r5, [pc, #64]	; (9d60 <DMA_CalcBaseAndBitshift+0xec>)
    9d20:	4810      	ldr	r0, [pc, #64]	; (9d64 <DMA_CalcBaseAndBitshift+0xf0>)
    9d22:	3b10      	subs	r3, #16

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    9d24:	4c10      	ldr	r4, [pc, #64]	; (9d68 <DMA_CalcBaseAndBitshift+0xf4>)
    9d26:	4010      	ands	r0, r2
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    9d28:	fba5 5303 	umull	r5, r3, r5, r3
    9d2c:	091b      	lsrs	r3, r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    9d2e:	f003 0207 	and.w	r2, r3, #7

    if (stream_number > 3U)
    9d32:	2b03      	cmp	r3, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    9d34:	5ca2      	ldrb	r2, [r4, r2]
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
    9d36:	bf88      	it	hi
    9d38:	3004      	addhi	r0, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    9d3a:	65ca      	str	r2, [r1, #92]	; 0x5c
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
    9d3c:	6588      	str	r0, [r1, #88]	; 0x58
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
  }

  return hdma->StreamBaseAddress;
}
    9d3e:	bc30      	pop	{r4, r5}
    9d40:	4770      	bx	lr
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
    9d42:	f022 00ff 	bic.w	r0, r2, #255	; 0xff
    9d46:	6588      	str	r0, [r1, #88]	; 0x58
    9d48:	e7f9      	b.n	9d3e <DMA_CalcBaseAndBitshift+0xca>
    9d4a:	bf00      	nop
    9d4c:	40020010 	.word	0x40020010
    9d50:	40020028 	.word	0x40020028
    9d54:	40020040 	.word	0x40020040
    9d58:	40020058 	.word	0x40020058
    9d5c:	400204b8 	.word	0x400204b8
    9d60:	aaaaaaab 	.word	0xaaaaaaab
    9d64:	fffffc00 	.word	0xfffffc00
    9d68:	0002fc4c 	.word	0x0002fc4c

00009d6c <HAL_DMA_Init>:
{
    9d6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9d70:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
    9d72:	f7fe fb3f 	bl	83f4 <HAL_GetTick>
  if(hdma == NULL)
    9d76:	2d00      	cmp	r5, #0
    9d78:	f000 82ba 	beq.w	a2f0 <HAL_DMA_Init+0x584>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
    9d7c:	682a      	ldr	r2, [r5, #0]
    9d7e:	4604      	mov	r4, r0
    9d80:	4b9e      	ldr	r3, [pc, #632]	; (9ffc <HAL_DMA_Init+0x290>)
    9d82:	489f      	ldr	r0, [pc, #636]	; (a000 <HAL_DMA_Init+0x294>)
    9d84:	499f      	ldr	r1, [pc, #636]	; (a004 <HAL_DMA_Init+0x298>)
    9d86:	429a      	cmp	r2, r3
    9d88:	bf18      	it	ne
    9d8a:	4282      	cmpne	r2, r0
    9d8c:	f100 0030 	add.w	r0, r0, #48	; 0x30
    9d90:	bf14      	ite	ne
    9d92:	2301      	movne	r3, #1
    9d94:	2300      	moveq	r3, #0
    9d96:	428a      	cmp	r2, r1
    9d98:	bf0c      	ite	eq
    9d9a:	2300      	moveq	r3, #0
    9d9c:	f003 0301 	andne.w	r3, r3, #1
    9da0:	3130      	adds	r1, #48	; 0x30
    9da2:	4282      	cmp	r2, r0
    9da4:	bf0c      	ite	eq
    9da6:	2300      	moveq	r3, #0
    9da8:	f003 0301 	andne.w	r3, r3, #1
    9dac:	3030      	adds	r0, #48	; 0x30
    9dae:	428a      	cmp	r2, r1
    9db0:	bf0c      	ite	eq
    9db2:	2300      	moveq	r3, #0
    9db4:	f003 0301 	andne.w	r3, r3, #1
    9db8:	3130      	adds	r1, #48	; 0x30
    9dba:	4282      	cmp	r2, r0
    9dbc:	bf0c      	ite	eq
    9dbe:	2300      	moveq	r3, #0
    9dc0:	f003 0301 	andne.w	r3, r3, #1
    9dc4:	3030      	adds	r0, #48	; 0x30
    9dc6:	428a      	cmp	r2, r1
    9dc8:	bf0c      	ite	eq
    9dca:	2300      	moveq	r3, #0
    9dcc:	f003 0301 	andne.w	r3, r3, #1
    9dd0:	f501 715c 	add.w	r1, r1, #880	; 0x370
    9dd4:	4282      	cmp	r2, r0
    9dd6:	bf0c      	ite	eq
    9dd8:	2300      	moveq	r3, #0
    9dda:	f003 0301 	andne.w	r3, r3, #1
    9dde:	f500 705c 	add.w	r0, r0, #880	; 0x370
    9de2:	428a      	cmp	r2, r1
    9de4:	bf0c      	ite	eq
    9de6:	2300      	moveq	r3, #0
    9de8:	f003 0301 	andne.w	r3, r3, #1
    9dec:	3130      	adds	r1, #48	; 0x30
    9dee:	4282      	cmp	r2, r0
    9df0:	bf0c      	ite	eq
    9df2:	2300      	moveq	r3, #0
    9df4:	f003 0301 	andne.w	r3, r3, #1
    9df8:	3030      	adds	r0, #48	; 0x30
    9dfa:	428a      	cmp	r2, r1
    9dfc:	bf0c      	ite	eq
    9dfe:	2300      	moveq	r3, #0
    9e00:	f003 0301 	andne.w	r3, r3, #1
    9e04:	3130      	adds	r1, #48	; 0x30
    9e06:	4282      	cmp	r2, r0
    9e08:	bf0c      	ite	eq
    9e0a:	2300      	moveq	r3, #0
    9e0c:	f003 0301 	andne.w	r3, r3, #1
    9e10:	3030      	adds	r0, #48	; 0x30
    9e12:	428a      	cmp	r2, r1
    9e14:	bf0c      	ite	eq
    9e16:	2300      	moveq	r3, #0
    9e18:	f003 0301 	andne.w	r3, r3, #1
    9e1c:	3130      	adds	r1, #48	; 0x30
    9e1e:	4282      	cmp	r2, r0
    9e20:	bf0c      	ite	eq
    9e22:	2300      	moveq	r3, #0
    9e24:	f003 0301 	andne.w	r3, r3, #1
    9e28:	3030      	adds	r0, #48	; 0x30
    9e2a:	428a      	cmp	r2, r1
    9e2c:	bf0c      	ite	eq
    9e2e:	2300      	moveq	r3, #0
    9e30:	f003 0301 	andne.w	r3, r3, #1
    9e34:	4974      	ldr	r1, [pc, #464]	; (a008 <HAL_DMA_Init+0x29c>)
    9e36:	4282      	cmp	r2, r0
    9e38:	bf0c      	ite	eq
    9e3a:	2300      	moveq	r3, #0
    9e3c:	f003 0301 	andne.w	r3, r3, #1
    9e40:	4872      	ldr	r0, [pc, #456]	; (a00c <HAL_DMA_Init+0x2a0>)
    9e42:	428a      	cmp	r2, r1
    9e44:	bf0c      	ite	eq
    9e46:	2300      	moveq	r3, #0
    9e48:	f003 0301 	andne.w	r3, r3, #1
    9e4c:	3128      	adds	r1, #40	; 0x28
    9e4e:	4282      	cmp	r2, r0
    9e50:	bf0c      	ite	eq
    9e52:	2300      	moveq	r3, #0
    9e54:	f003 0301 	andne.w	r3, r3, #1
    9e58:	3028      	adds	r0, #40	; 0x28
    9e5a:	428a      	cmp	r2, r1
    9e5c:	bf0c      	ite	eq
    9e5e:	2300      	moveq	r3, #0
    9e60:	f003 0301 	andne.w	r3, r3, #1
    9e64:	3128      	adds	r1, #40	; 0x28
    9e66:	4282      	cmp	r2, r0
    9e68:	bf0c      	ite	eq
    9e6a:	2300      	moveq	r3, #0
    9e6c:	f003 0301 	andne.w	r3, r3, #1
    9e70:	3028      	adds	r0, #40	; 0x28
    9e72:	428a      	cmp	r2, r1
    9e74:	bf0c      	ite	eq
    9e76:	2300      	moveq	r3, #0
    9e78:	f003 0301 	andne.w	r3, r3, #1
    9e7c:	3128      	adds	r1, #40	; 0x28
    9e7e:	4282      	cmp	r2, r0
    9e80:	bf0c      	ite	eq
    9e82:	2300      	moveq	r3, #0
    9e84:	f003 0301 	andne.w	r3, r3, #1
    9e88:	428a      	cmp	r2, r1
    9e8a:	bf0c      	ite	eq
    9e8c:	2300      	moveq	r3, #0
    9e8e:	f003 0301 	andne.w	r3, r3, #1
    9e92:	b11b      	cbz	r3, 9e9c <HAL_DMA_Init+0x130>
    9e94:	4b5e      	ldr	r3, [pc, #376]	; (a010 <HAL_DMA_Init+0x2a4>)
    9e96:	429a      	cmp	r2, r3
    9e98:	f040 836b 	bne.w	a572 <HAL_DMA_Init+0x806>
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    9e9c:	68ab      	ldr	r3, [r5, #8]
    9e9e:	f033 0240 	bics.w	r2, r3, #64	; 0x40
    9ea2:	d002      	beq.n	9eaa <HAL_DMA_Init+0x13e>
    9ea4:	2b80      	cmp	r3, #128	; 0x80
    9ea6:	f040 8226 	bne.w	a2f6 <HAL_DMA_Init+0x58a>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    9eaa:	68eb      	ldr	r3, [r5, #12]
    9eac:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    9eb0:	f040 8114 	bne.w	a0dc <HAL_DMA_Init+0x370>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    9eb4:	692b      	ldr	r3, [r5, #16]
    9eb6:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
    9eba:	f040 8105 	bne.w	a0c8 <HAL_DMA_Init+0x35c>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    9ebe:	696b      	ldr	r3, [r5, #20]
    9ec0:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
    9ec4:	d003      	beq.n	9ece <HAL_DMA_Init+0x162>
    9ec6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    9eca:	f040 821e 	bne.w	a30a <HAL_DMA_Init+0x59e>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    9ece:	69ab      	ldr	r3, [r5, #24]
    9ed0:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
    9ed4:	d003      	beq.n	9ede <HAL_DMA_Init+0x172>
    9ed6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    9eda:	f040 8220 	bne.w	a31e <HAL_DMA_Init+0x5b2>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
    9ede:	69ea      	ldr	r2, [r5, #28]
    9ee0:	f032 0320 	bics.w	r3, r2, #32
    9ee4:	f422 2100 	bic.w	r1, r2, #524288	; 0x80000
    9ee8:	bf14      	ite	ne
    9eea:	2301      	movne	r3, #1
    9eec:	2300      	moveq	r3, #0
    9eee:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
    9ef2:	bf0c      	ite	eq
    9ef4:	2300      	moveq	r3, #0
    9ef6:	f003 0301 	andne.w	r3, r3, #1
    9efa:	b11b      	cbz	r3, 9f04 <HAL_DMA_Init+0x198>
    9efc:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    9f00:	f040 8212 	bne.w	a328 <HAL_DMA_Init+0x5bc>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    9f04:	6a2b      	ldr	r3, [r5, #32]
    9f06:	f433 3340 	bics.w	r3, r3, #196608	; 0x30000
    9f0a:	f040 824e 	bne.w	a3aa <HAL_DMA_Init+0x63e>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    9f0e:	682a      	ldr	r2, [r5, #0]
    9f10:	4b3a      	ldr	r3, [pc, #232]	; (9ffc <HAL_DMA_Init+0x290>)
    9f12:	483b      	ldr	r0, [pc, #236]	; (a000 <HAL_DMA_Init+0x294>)
    9f14:	493b      	ldr	r1, [pc, #236]	; (a004 <HAL_DMA_Init+0x298>)
    9f16:	4282      	cmp	r2, r0
    9f18:	bf18      	it	ne
    9f1a:	429a      	cmpne	r2, r3
    9f1c:	f100 0030 	add.w	r0, r0, #48	; 0x30
    9f20:	bf0c      	ite	eq
    9f22:	2301      	moveq	r3, #1
    9f24:	2300      	movne	r3, #0
    9f26:	428a      	cmp	r2, r1
    9f28:	bf08      	it	eq
    9f2a:	f043 0301 	orreq.w	r3, r3, #1
    9f2e:	3130      	adds	r1, #48	; 0x30
    9f30:	4282      	cmp	r2, r0
    9f32:	bf08      	it	eq
    9f34:	f043 0301 	orreq.w	r3, r3, #1
    9f38:	3030      	adds	r0, #48	; 0x30
    9f3a:	428a      	cmp	r2, r1
    9f3c:	bf08      	it	eq
    9f3e:	f043 0301 	orreq.w	r3, r3, #1
    9f42:	3130      	adds	r1, #48	; 0x30
    9f44:	4282      	cmp	r2, r0
    9f46:	bf08      	it	eq
    9f48:	f043 0301 	orreq.w	r3, r3, #1
    9f4c:	3030      	adds	r0, #48	; 0x30
    9f4e:	428a      	cmp	r2, r1
    9f50:	bf08      	it	eq
    9f52:	f043 0301 	orreq.w	r3, r3, #1
    9f56:	f501 715c 	add.w	r1, r1, #880	; 0x370
    9f5a:	4282      	cmp	r2, r0
    9f5c:	bf08      	it	eq
    9f5e:	f043 0301 	orreq.w	r3, r3, #1
    9f62:	f500 705c 	add.w	r0, r0, #880	; 0x370
    9f66:	428a      	cmp	r2, r1
    9f68:	bf08      	it	eq
    9f6a:	f043 0301 	orreq.w	r3, r3, #1
    9f6e:	3130      	adds	r1, #48	; 0x30
    9f70:	4282      	cmp	r2, r0
    9f72:	bf08      	it	eq
    9f74:	f043 0301 	orreq.w	r3, r3, #1
    9f78:	3030      	adds	r0, #48	; 0x30
    9f7a:	428a      	cmp	r2, r1
    9f7c:	bf08      	it	eq
    9f7e:	f043 0301 	orreq.w	r3, r3, #1
    9f82:	3130      	adds	r1, #48	; 0x30
    9f84:	4282      	cmp	r2, r0
    9f86:	bf08      	it	eq
    9f88:	f043 0301 	orreq.w	r3, r3, #1
    9f8c:	3030      	adds	r0, #48	; 0x30
    9f8e:	428a      	cmp	r2, r1
    9f90:	bf08      	it	eq
    9f92:	f043 0301 	orreq.w	r3, r3, #1
    9f96:	3130      	adds	r1, #48	; 0x30
    9f98:	4282      	cmp	r2, r0
    9f9a:	bf08      	it	eq
    9f9c:	f043 0301 	orreq.w	r3, r3, #1
    9fa0:	428a      	cmp	r2, r1
    9fa2:	bf08      	it	eq
    9fa4:	f043 0301 	orreq.w	r3, r3, #1
    9fa8:	b91b      	cbnz	r3, 9fb2 <HAL_DMA_Init+0x246>
    9faa:	4b1a      	ldr	r3, [pc, #104]	; (a014 <HAL_DMA_Init+0x2a8>)
    9fac:	429a      	cmp	r2, r3
    9fae:	f040 8259 	bne.w	a464 <HAL_DMA_Init+0x6f8>
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
    9fb2:	686b      	ldr	r3, [r5, #4]
    9fb4:	2b73      	cmp	r3, #115	; 0x73
    9fb6:	f200 809b 	bhi.w	a0f0 <HAL_DMA_Init+0x384>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    9fba:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    9fbc:	f033 0204 	bics.w	r2, r3, #4
    9fc0:	f040 809f 	bne.w	a102 <HAL_DMA_Init+0x396>
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
    9fc4:	b16b      	cbz	r3, 9fe2 <HAL_DMA_Init+0x276>
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    9fc6:	6aab      	ldr	r3, [r5, #40]	; 0x28
    9fc8:	2b03      	cmp	r3, #3
    9fca:	f200 81e9 	bhi.w	a3a0 <HAL_DMA_Init+0x634>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    9fce:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    9fd0:	f033 73c0 	bics.w	r3, r3, #25165824	; 0x1800000
    9fd4:	f040 822a 	bne.w	a42c <HAL_DMA_Init+0x6c0>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    9fd8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    9fda:	f433 03c0 	bics.w	r3, r3, #6291456	; 0x600000
    9fde:	f040 81a8 	bne.w	a332 <HAL_DMA_Init+0x5c6>
    __HAL_UNLOCK(hdma);
    9fe2:	2000      	movs	r0, #0
    __HAL_DMA_DISABLE(hdma);
    9fe4:	682a      	ldr	r2, [r5, #0]
    __HAL_UNLOCK(hdma);
    9fe6:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_BUSY;
    9fea:	2002      	movs	r0, #2
    9fec:	f885 0035 	strb.w	r0, [r5, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
    9ff0:	6813      	ldr	r3, [r2, #0]
    9ff2:	f023 0301 	bic.w	r3, r3, #1
    9ff6:	6013      	str	r3, [r2, #0]
    9ff8:	e014      	b.n	a024 <HAL_DMA_Init+0x2b8>
    9ffa:	bf00      	nop
    9ffc:	40020010 	.word	0x40020010
    a000:	40020028 	.word	0x40020028
    a004:	40020040 	.word	0x40020040
    a008:	58025408 	.word	0x58025408
    a00c:	5802541c 	.word	0x5802541c
    a010:	58025494 	.word	0x58025494
    a014:	400204b8 	.word	0x400204b8
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
    a018:	f7fe f9ec 	bl	83f4 <HAL_GetTick>
    a01c:	1b00      	subs	r0, r0, r4
    a01e:	2805      	cmp	r0, #5
    a020:	f200 815e 	bhi.w	a2e0 <HAL_DMA_Init+0x574>
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
    a024:	682b      	ldr	r3, [r5, #0]
    a026:	681a      	ldr	r2, [r3, #0]
    a028:	07d0      	lsls	r0, r2, #31
    a02a:	d4f5      	bmi.n	a018 <HAL_DMA_Init+0x2ac>
    registerValue |=  hdma->Init.Direction           |
    a02c:	e9d5 2002 	ldrd	r2, r0, [r5, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    a030:	6929      	ldr	r1, [r5, #16]
    registerValue |=  hdma->Init.Direction           |
    a032:	4302      	orrs	r2, r0
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a034:	e9d5 4005 	ldrd	r4, r0, [r5, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    a038:	430a      	orrs	r2, r1
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a03a:	69e9      	ldr	r1, [r5, #28]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    a03c:	4322      	orrs	r2, r4
            hdma->Init.Mode                | hdma->Init.Priority;
    a03e:	6a2c      	ldr	r4, [r5, #32]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a040:	4302      	orrs	r2, r0
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
    a042:	6818      	ldr	r0, [r3, #0]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a044:	430a      	orrs	r2, r1
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    a046:	49bd      	ldr	r1, [pc, #756]	; (a33c <HAL_DMA_Init+0x5d0>)
    a048:	4001      	ands	r1, r0
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a04a:	6a68      	ldr	r0, [r5, #36]	; 0x24
            hdma->Init.Mode                | hdma->Init.Priority;
    a04c:	4322      	orrs	r2, r4
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a04e:	2804      	cmp	r0, #4
    registerValue |=  hdma->Init.Direction           |
    a050:	ea42 0201 	orr.w	r2, r2, r1
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a054:	d103      	bne.n	a05e <HAL_DMA_Init+0x2f2>
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
    a056:	e9d5 100b 	ldrd	r1, r0, [r5, #44]	; 0x2c
    a05a:	4301      	orrs	r1, r0
    a05c:	430a      	orrs	r2, r1
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
    a05e:	48b8      	ldr	r0, [pc, #736]	; (a340 <HAL_DMA_Init+0x5d4>)
    a060:	49b8      	ldr	r1, [pc, #736]	; (a344 <HAL_DMA_Init+0x5d8>)
    a062:	6800      	ldr	r0, [r0, #0]
    a064:	4001      	ands	r1, r0
    a066:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
    a06a:	d30a      	bcc.n	a082 <HAL_DMA_Init+0x316>
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
    a06c:	6868      	ldr	r0, [r5, #4]
    a06e:	f1a0 0429 	sub.w	r4, r0, #41	; 0x29
    a072:	2c1f      	cmp	r4, #31
    a074:	f240 818c 	bls.w	a390 <HAL_DMA_Init+0x624>
    a078:	384f      	subs	r0, #79	; 0x4f
    a07a:	2803      	cmp	r0, #3
    a07c:	d801      	bhi.n	a082 <HAL_DMA_Init+0x316>
        registerValue |= DMA_SxCR_TRBUFF;
    a07e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
    a082:	601a      	str	r2, [r3, #0]
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
    a084:	6829      	ldr	r1, [r5, #0]
    registerValue |= hdma->Init.FIFOMode;
    a086:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
    a088:	694b      	ldr	r3, [r1, #20]
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a08a:	2a04      	cmp	r2, #4
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
    a08c:	f023 0307 	bic.w	r3, r3, #7
    registerValue |= hdma->Init.FIFOMode;
    a090:	ea43 0302 	orr.w	r3, r3, r2
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a094:	d144      	bne.n	a120 <HAL_DMA_Init+0x3b4>
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
    a096:	e9d5 200a 	ldrd	r2, r0, [r5, #40]	; 0x28
      registerValue |= hdma->Init.FIFOThreshold;
    a09a:	4313      	orrs	r3, r2
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
    a09c:	2800      	cmp	r0, #0
    a09e:	d03f      	beq.n	a120 <HAL_DMA_Init+0x3b4>
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
    a0a0:	69ac      	ldr	r4, [r5, #24]
    a0a2:	2c00      	cmp	r4, #0
    a0a4:	d036      	beq.n	a114 <HAL_DMA_Init+0x3a8>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    a0a6:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
    a0aa:	f000 823e 	beq.w	a52a <HAL_DMA_Init+0x7be>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
    a0ae:	2a02      	cmp	r2, #2
    a0b0:	d903      	bls.n	a0ba <HAL_DMA_Init+0x34e>
    a0b2:	2a03      	cmp	r2, #3
    a0b4:	d134      	bne.n	a120 <HAL_DMA_Init+0x3b4>
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
        break;

      case DMA_FIFO_THRESHOLD_FULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
    a0b6:	01c2      	lsls	r2, r0, #7
    a0b8:	d532      	bpl.n	a120 <HAL_DMA_Init+0x3b4>
          hdma->State = HAL_DMA_STATE_READY;
    a0ba:	2301      	movs	r3, #1
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    a0bc:	2240      	movs	r2, #64	; 0x40
          return HAL_ERROR;
    a0be:	4618      	mov	r0, r3
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    a0c0:	656a      	str	r2, [r5, #84]	; 0x54
          hdma->State = HAL_DMA_STATE_READY;
    a0c2:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
          return HAL_ERROR;
    a0c6:	e109      	b.n	a2dc <HAL_DMA_Init+0x570>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    a0c8:	21e4      	movs	r1, #228	; 0xe4
    a0ca:	489f      	ldr	r0, [pc, #636]	; (a348 <HAL_DMA_Init+0x5dc>)
    a0cc:	f00f f9a2 	bl	19414 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    a0d0:	696b      	ldr	r3, [r5, #20]
    a0d2:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
    a0d6:	f47f aef6 	bne.w	9ec6 <HAL_DMA_Init+0x15a>
    a0da:	e6f8      	b.n	9ece <HAL_DMA_Init+0x162>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    a0dc:	21e3      	movs	r1, #227	; 0xe3
    a0de:	489a      	ldr	r0, [pc, #616]	; (a348 <HAL_DMA_Init+0x5dc>)
    a0e0:	f00f f998 	bl	19414 <assert_failed>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    a0e4:	692b      	ldr	r3, [r5, #16]
    a0e6:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
    a0ea:	f43f aee8 	beq.w	9ebe <HAL_DMA_Init+0x152>
    a0ee:	e7eb      	b.n	a0c8 <HAL_DMA_Init+0x35c>
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
    a0f0:	21ec      	movs	r1, #236	; 0xec
    a0f2:	4895      	ldr	r0, [pc, #596]	; (a348 <HAL_DMA_Init+0x5dc>)
    a0f4:	f00f f98e 	bl	19414 <assert_failed>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    a0f8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    a0fa:	f033 0204 	bics.w	r2, r3, #4
    a0fe:	f43f af61 	beq.w	9fc4 <HAL_DMA_Init+0x258>
    a102:	21ed      	movs	r1, #237	; 0xed
    a104:	4890      	ldr	r0, [pc, #576]	; (a348 <HAL_DMA_Init+0x5dc>)
    a106:	f00f f985 	bl	19414 <assert_failed>
    a10a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
    a10c:	2b00      	cmp	r3, #0
    a10e:	f43f af68 	beq.w	9fe2 <HAL_DMA_Init+0x276>
    a112:	e758      	b.n	9fc6 <HAL_DMA_Init+0x25a>
    switch (hdma->Init.FIFOThreshold)
    a114:	2a01      	cmp	r2, #1
    a116:	f000 8203 	beq.w	a520 <HAL_DMA_Init+0x7b4>
    a11a:	d3cc      	bcc.n	a0b6 <HAL_DMA_Init+0x34a>
    a11c:	2a02      	cmp	r2, #2
    a11e:	d0ca      	beq.n	a0b6 <HAL_DMA_Init+0x34a>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
    a120:	614b      	str	r3, [r1, #20]
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    a122:	4628      	mov	r0, r5
    a124:	f7ff fda6 	bl	9c74 <DMA_CalcBaseAndBitshift>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
    a128:	6dea      	ldr	r2, [r5, #92]	; 0x5c
    a12a:	233f      	movs	r3, #63	; 0x3f
    a12c:	f002 021f 	and.w	r2, r2, #31
    a130:	4093      	lsls	r3, r2
    a132:	6083      	str	r3, [r0, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    a134:	682a      	ldr	r2, [r5, #0]
    a136:	4b85      	ldr	r3, [pc, #532]	; (a34c <HAL_DMA_Init+0x5e0>)
    a138:	4885      	ldr	r0, [pc, #532]	; (a350 <HAL_DMA_Init+0x5e4>)
    a13a:	4986      	ldr	r1, [pc, #536]	; (a354 <HAL_DMA_Init+0x5e8>)
    a13c:	4282      	cmp	r2, r0
    a13e:	bf18      	it	ne
    a140:	429a      	cmpne	r2, r3
    a142:	4e85      	ldr	r6, [pc, #532]	; (a358 <HAL_DMA_Init+0x5ec>)
    a144:	4c85      	ldr	r4, [pc, #532]	; (a35c <HAL_DMA_Init+0x5f0>)
    a146:	f100 0060 	add.w	r0, r0, #96	; 0x60
    a14a:	bf0c      	ite	eq
    a14c:	2301      	moveq	r3, #1
    a14e:	2300      	movne	r3, #0
    a150:	f8df e21c 	ldr.w	lr, [pc, #540]	; a370 <HAL_DMA_Init+0x604>
    a154:	428a      	cmp	r2, r1
    a156:	bf08      	it	eq
    a158:	f043 0301 	orreq.w	r3, r3, #1
    a15c:	3160      	adds	r1, #96	; 0x60
    a15e:	f8df c214 	ldr.w	ip, [pc, #532]	; a374 <HAL_DMA_Init+0x608>
    a162:	42b2      	cmp	r2, r6
    a164:	bf08      	it	eq
    a166:	f043 0301 	orreq.w	r3, r3, #1
    a16a:	4f7d      	ldr	r7, [pc, #500]	; (a360 <HAL_DMA_Init+0x5f4>)
    a16c:	f506 767a 	add.w	r6, r6, #1000	; 0x3e8
    a170:	f8df 8204 	ldr.w	r8, [pc, #516]	; a378 <HAL_DMA_Init+0x60c>
    a174:	42a2      	cmp	r2, r4
    a176:	bf08      	it	eq
    a178:	f043 0301 	orreq.w	r3, r3, #1
    a17c:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
    a180:	f8df a1f8 	ldr.w	sl, [pc, #504]	; a37c <HAL_DMA_Init+0x610>
    a184:	4282      	cmp	r2, r0
    a186:	bf08      	it	eq
    a188:	f043 0301 	orreq.w	r3, r3, #1
    a18c:	f500 707a 	add.w	r0, r0, #1000	; 0x3e8
    a190:	f8df 91ec 	ldr.w	r9, [pc, #492]	; a380 <HAL_DMA_Init+0x614>
    a194:	428a      	cmp	r2, r1
    a196:	bf08      	it	eq
    a198:	f043 0301 	orreq.w	r3, r3, #1
    a19c:	f501 717a 	add.w	r1, r1, #1000	; 0x3e8
    a1a0:	4572      	cmp	r2, lr
    a1a2:	bf08      	it	eq
    a1a4:	f043 0301 	orreq.w	r3, r3, #1
    a1a8:	f8df e1d8 	ldr.w	lr, [pc, #472]	; a384 <HAL_DMA_Init+0x618>
    a1ac:	4562      	cmp	r2, ip
    a1ae:	bf08      	it	eq
    a1b0:	f043 0301 	orreq.w	r3, r3, #1
    a1b4:	eba2 0e0e 	sub.w	lr, r2, lr
    a1b8:	f8df c1cc 	ldr.w	ip, [pc, #460]	; a388 <HAL_DMA_Init+0x61c>
    a1bc:	42ba      	cmp	r2, r7
    a1be:	bf08      	it	eq
    a1c0:	f043 0301 	orreq.w	r3, r3, #1
    a1c4:	fabe fe8e 	clz	lr, lr
    a1c8:	eba2 070c 	sub.w	r7, r2, ip
    a1cc:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    a1d0:	42b2      	cmp	r2, r6
    a1d2:	bf08      	it	eq
    a1d4:	f043 0301 	orreq.w	r3, r3, #1
    a1d8:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
    a1dc:	eba2 060a 	sub.w	r6, r2, sl
    a1e0:	fab7 f787 	clz	r7, r7
    a1e4:	42a2      	cmp	r2, r4
    a1e6:	bf08      	it	eq
    a1e8:	f043 0301 	orreq.w	r3, r3, #1
    a1ec:	f10a 0a28 	add.w	sl, sl, #40	; 0x28
    a1f0:	eba2 040c 	sub.w	r4, r2, ip
    a1f4:	097f      	lsrs	r7, r7, #5
    a1f6:	4282      	cmp	r2, r0
    a1f8:	bf08      	it	eq
    a1fa:	f043 0301 	orreq.w	r3, r3, #1
    a1fe:	fab6 f686 	clz	r6, r6
    a202:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    a206:	fab4 f484 	clz	r4, r4
    a20a:	428a      	cmp	r2, r1
    a20c:	bf08      	it	eq
    a20e:	f043 0301 	orreq.w	r3, r3, #1
    a212:	0976      	lsrs	r6, r6, #5
    a214:	eba2 000a 	sub.w	r0, r2, sl
    a218:	eba2 010c 	sub.w	r1, r2, ip
    a21c:	4542      	cmp	r2, r8
    a21e:	bf08      	it	eq
    a220:	f043 0301 	orreq.w	r3, r3, #1
    a224:	0964      	lsrs	r4, r4, #5
    a226:	fab0 f080 	clz	r0, r0
    a22a:	f10c 0c14 	add.w	ip, ip, #20
    a22e:	454a      	cmp	r2, r9
    a230:	bf08      	it	eq
    a232:	f043 0301 	orreq.w	r3, r3, #1
    a236:	fab1 f181 	clz	r1, r1
    a23a:	0940      	lsrs	r0, r0, #5
    a23c:	eba2 0c0c 	sub.w	ip, r2, ip
    a240:	ea4e 0303 	orr.w	r3, lr, r3
    a244:	0949      	lsrs	r1, r1, #5
    a246:	f8df 8144 	ldr.w	r8, [pc, #324]	; a38c <HAL_DMA_Init+0x620>
    a24a:	fabc fc8c 	clz	ip, ip
    a24e:	433b      	orrs	r3, r7
    a250:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
    a254:	eba2 0808 	sub.w	r8, r2, r8
    a258:	4333      	orrs	r3, r6
    a25a:	fab8 f888 	clz	r8, r8
    a25e:	4323      	orrs	r3, r4
    a260:	ea4f 1858 	mov.w	r8, r8, lsr #5
    a264:	4303      	orrs	r3, r0
    a266:	430b      	orrs	r3, r1
    a268:	ea5c 0303 	orrs.w	r3, ip, r3
    a26c:	d102      	bne.n	a274 <HAL_DMA_Init+0x508>
    a26e:	f1b8 0f00 	cmp.w	r8, #0
    a272:	d02e      	beq.n	a2d2 <HAL_DMA_Init+0x566>
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    a274:	ea47 070e 	orr.w	r7, r7, lr
    a278:	b2d3      	uxtb	r3, r2
    a27a:	433e      	orrs	r6, r7
    a27c:	4334      	orrs	r4, r6
    a27e:	4320      	orrs	r0, r4
    a280:	4301      	orrs	r1, r0
    a282:	ea5c 0101 	orrs.w	r1, ip, r1
    a286:	d103      	bne.n	a290 <HAL_DMA_Init+0x524>
    a288:	f1b8 0f00 	cmp.w	r8, #0
    a28c:	f000 80d3 	beq.w	a436 <HAL_DMA_Init+0x6ca>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a290:	4834      	ldr	r0, [pc, #208]	; (a364 <HAL_DMA_Init+0x5f8>)
    a292:	3b08      	subs	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a294:	4a34      	ldr	r2, [pc, #208]	; (a368 <HAL_DMA_Init+0x5fc>)
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a296:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a298:	fba0 0303 	umull	r0, r3, r0, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a29c:	4833      	ldr	r0, [pc, #204]	; (a36c <HAL_DMA_Init+0x600>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a29e:	091b      	lsrs	r3, r3, #4
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a2a0:	6668      	str	r0, [r5, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a2a2:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a2a4:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a2a8:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a2aa:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a2ae:	662a      	str	r2, [r5, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a2b0:	66ab      	str	r3, [r5, #104]	; 0x68
    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
    a2b2:	68ab      	ldr	r3, [r5, #8]
    a2b4:	2b80      	cmp	r3, #128	; 0x80
    a2b6:	d07d      	beq.n	a3b4 <HAL_DMA_Init+0x648>
    a2b8:	792b      	ldrb	r3, [r5, #4]
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
    a2ba:	6013      	str	r3, [r2, #0]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    a2bc:	e9d5 3219 	ldrd	r3, r2, [r5, #100]	; 0x64
    a2c0:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
    a2c2:	6868      	ldr	r0, [r5, #4]
    a2c4:	1e41      	subs	r1, r0, #1
    a2c6:	2907      	cmp	r1, #7
    a2c8:	d978      	bls.n	a3bc <HAL_DMA_Init+0x650>
      hdma->DMAmuxRequestGen = 0U;
    a2ca:	2300      	movs	r3, #0
      hdma->DMAmuxRequestGenStatus = 0U;
    a2cc:	e9c5 331b 	strd	r3, r3, [r5, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatusMask = 0U;
    a2d0:	676b      	str	r3, [r5, #116]	; 0x74
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    a2d2:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
    a2d4:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    a2d6:	6568      	str	r0, [r5, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
    a2d8:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
}
    a2dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
    a2e0:	2220      	movs	r2, #32
        hdma->State = HAL_DMA_STATE_ERROR;
    a2e2:	2303      	movs	r3, #3
        return HAL_ERROR;
    a2e4:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
    a2e6:	656a      	str	r2, [r5, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_ERROR;
    a2e8:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
}
    a2ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return HAL_ERROR;
    a2f0:	2001      	movs	r0, #1
}
    a2f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    a2f6:	21e2      	movs	r1, #226	; 0xe2
    a2f8:	4813      	ldr	r0, [pc, #76]	; (a348 <HAL_DMA_Init+0x5dc>)
    a2fa:	f00f f88b 	bl	19414 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    a2fe:	68eb      	ldr	r3, [r5, #12]
    a300:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    a304:	f43f add6 	beq.w	9eb4 <HAL_DMA_Init+0x148>
    a308:	e6e8      	b.n	a0dc <HAL_DMA_Init+0x370>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    a30a:	21e5      	movs	r1, #229	; 0xe5
    a30c:	480e      	ldr	r0, [pc, #56]	; (a348 <HAL_DMA_Init+0x5dc>)
    a30e:	f00f f881 	bl	19414 <assert_failed>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    a312:	69ab      	ldr	r3, [r5, #24]
    a314:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
    a318:	f47f addd 	bne.w	9ed6 <HAL_DMA_Init+0x16a>
    a31c:	e5df      	b.n	9ede <HAL_DMA_Init+0x172>
    a31e:	21e6      	movs	r1, #230	; 0xe6
    a320:	4809      	ldr	r0, [pc, #36]	; (a348 <HAL_DMA_Init+0x5dc>)
    a322:	f00f f877 	bl	19414 <assert_failed>
    a326:	e5da      	b.n	9ede <HAL_DMA_Init+0x172>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
    a328:	21e7      	movs	r1, #231	; 0xe7
    a32a:	4807      	ldr	r0, [pc, #28]	; (a348 <HAL_DMA_Init+0x5dc>)
    a32c:	f00f f872 	bl	19414 <assert_failed>
    a330:	e5e8      	b.n	9f04 <HAL_DMA_Init+0x198>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    a332:	21f4      	movs	r1, #244	; 0xf4
    a334:	4804      	ldr	r0, [pc, #16]	; (a348 <HAL_DMA_Init+0x5dc>)
    a336:	f00f f86d 	bl	19414 <assert_failed>
    a33a:	e652      	b.n	9fe2 <HAL_DMA_Init+0x276>
    a33c:	fe10803f 	.word	0xfe10803f
    a340:	5c001000 	.word	0x5c001000
    a344:	ffff0000 	.word	0xffff0000
    a348:	0002fc14 	.word	0x0002fc14
    a34c:	40020010 	.word	0x40020010
    a350:	40020028 	.word	0x40020028
    a354:	40020040 	.word	0x40020040
    a358:	40020058 	.word	0x40020058
    a35c:	40020070 	.word	0x40020070
    a360:	40020428 	.word	0x40020428
    a364:	cccccccd 	.word	0xcccccccd
    a368:	16009600 	.word	0x16009600
    a36c:	58025880 	.word	0x58025880
    a370:	400200b8 	.word	0x400200b8
    a374:	40020410 	.word	0x40020410
    a378:	400204a0 	.word	0x400204a0
    a37c:	58025430 	.word	0x58025430
    a380:	400204b8 	.word	0x400204b8
    a384:	58025408 	.word	0x58025408
    a388:	5802541c 	.word	0x5802541c
    a38c:	58025494 	.word	0x58025494
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
    a390:	497a      	ldr	r1, [pc, #488]	; (a57c <HAL_DMA_Init+0x810>)
    a392:	40e1      	lsrs	r1, r4
    a394:	07c9      	lsls	r1, r1, #31
    a396:	f57f ae6f 	bpl.w	a078 <HAL_DMA_Init+0x30c>
        registerValue |= DMA_SxCR_TRBUFF;
    a39a:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    a39e:	e670      	b.n	a082 <HAL_DMA_Init+0x316>
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    a3a0:	21f2      	movs	r1, #242	; 0xf2
    a3a2:	4877      	ldr	r0, [pc, #476]	; (a580 <HAL_DMA_Init+0x814>)
    a3a4:	f00f f836 	bl	19414 <assert_failed>
    a3a8:	e611      	b.n	9fce <HAL_DMA_Init+0x262>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    a3aa:	21e8      	movs	r1, #232	; 0xe8
    a3ac:	4874      	ldr	r0, [pc, #464]	; (a580 <HAL_DMA_Init+0x814>)
    a3ae:	f00f f831 	bl	19414 <assert_failed>
    a3b2:	e5ac      	b.n	9f0e <HAL_DMA_Init+0x1a2>
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
    a3b4:	2100      	movs	r1, #0
    a3b6:	460b      	mov	r3, r1
    a3b8:	6069      	str	r1, [r5, #4]
    a3ba:	e77e      	b.n	a2ba <HAL_DMA_Init+0x54e>
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    a3bc:	682a      	ldr	r2, [r5, #0]
    a3be:	4b71      	ldr	r3, [pc, #452]	; (a584 <HAL_DMA_Init+0x818>)
    a3c0:	4e71      	ldr	r6, [pc, #452]	; (a588 <HAL_DMA_Init+0x81c>)
    a3c2:	4c72      	ldr	r4, [pc, #456]	; (a58c <HAL_DMA_Init+0x820>)
    a3c4:	42b2      	cmp	r2, r6
    a3c6:	bf18      	it	ne
    a3c8:	429a      	cmpne	r2, r3
    a3ca:	f106 0628 	add.w	r6, r6, #40	; 0x28
    a3ce:	bf0c      	ite	eq
    a3d0:	2301      	moveq	r3, #1
    a3d2:	2300      	movne	r3, #0
    a3d4:	42a2      	cmp	r2, r4
    a3d6:	bf08      	it	eq
    a3d8:	f043 0301 	orreq.w	r3, r3, #1
    a3dc:	3428      	adds	r4, #40	; 0x28
    a3de:	42b2      	cmp	r2, r6
    a3e0:	bf08      	it	eq
    a3e2:	f043 0301 	orreq.w	r3, r3, #1
    a3e6:	3628      	adds	r6, #40	; 0x28
    a3e8:	42a2      	cmp	r2, r4
    a3ea:	bf08      	it	eq
    a3ec:	f043 0301 	orreq.w	r3, r3, #1
    a3f0:	3428      	adds	r4, #40	; 0x28
    a3f2:	42b2      	cmp	r2, r6
    a3f4:	bf08      	it	eq
    a3f6:	f043 0301 	orreq.w	r3, r3, #1
    a3fa:	42a2      	cmp	r2, r4
    a3fc:	bf08      	it	eq
    a3fe:	f043 0301 	orreq.w	r3, r3, #1
    a402:	b91b      	cbnz	r3, a40c <HAL_DMA_Init+0x6a0>
    a404:	4b62      	ldr	r3, [pc, #392]	; (a590 <HAL_DMA_Init+0x824>)
    a406:	429a      	cmp	r2, r3
    a408:	f040 809e 	bne.w	a548 <HAL_DMA_Init+0x7dc>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a40c:	4b61      	ldr	r3, [pc, #388]	; (a594 <HAL_DMA_Init+0x828>)

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
    a40e:	4c62      	ldr	r4, [pc, #392]	; (a598 <HAL_DMA_Init+0x82c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a410:	4403      	add	r3, r0
    a412:	009b      	lsls	r3, r3, #2
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    a414:	2201      	movs	r2, #1
      hdma->DMAmuxRequestGen->RGCR = 0U;
    a416:	2000      	movs	r0, #0
    a418:	672c      	str	r4, [r5, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    a41a:	fa02 f101 	lsl.w	r1, r2, r1
    a41e:	66eb      	str	r3, [r5, #108]	; 0x6c
    a420:	6769      	str	r1, [r5, #116]	; 0x74
      hdma->DMAmuxRequestGen->RGCR = 0U;
    a422:	6018      	str	r0, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    a424:	e9d5 321c 	ldrd	r3, r2, [r5, #112]	; 0x70
    a428:	605a      	str	r2, [r3, #4]
    a42a:	e752      	b.n	a2d2 <HAL_DMA_Init+0x566>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    a42c:	21f3      	movs	r1, #243	; 0xf3
    a42e:	4854      	ldr	r0, [pc, #336]	; (a580 <HAL_DMA_Init+0x814>)
    a430:	f00e fff0 	bl	19414 <assert_failed>
    a434:	e5d0      	b.n	9fd8 <HAL_DMA_Init+0x26c>
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a436:	4959      	ldr	r1, [pc, #356]	; (a59c <HAL_DMA_Init+0x830>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a438:	3b10      	subs	r3, #16
    a43a:	4859      	ldr	r0, [pc, #356]	; (a5a0 <HAL_DMA_Init+0x834>)
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a43c:	4411      	add	r1, r2
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a43e:	fba0 0303 	umull	r0, r3, r0, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a442:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a444:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a448:	d800      	bhi.n	a44c <HAL_DMA_Init+0x6e0>
      stream_number += 8U;
    a44a:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a44c:	4a55      	ldr	r2, [pc, #340]	; (a5a4 <HAL_DMA_Init+0x838>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a44e:	f003 041f 	and.w	r4, r3, #31
    a452:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    a454:	4854      	ldr	r0, [pc, #336]	; (a5a8 <HAL_DMA_Init+0x83c>)
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a456:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a458:	40a1      	lsls	r1, r4
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    a45a:	6668      	str	r0, [r5, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a45c:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a45e:	66a9      	str	r1, [r5, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a460:	662a      	str	r2, [r5, #96]	; 0x60
    a462:	e726      	b.n	a2b2 <HAL_DMA_Init+0x546>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
    a464:	4b47      	ldr	r3, [pc, #284]	; (a584 <HAL_DMA_Init+0x818>)
    a466:	429a      	cmp	r2, r3
    a468:	d01e      	beq.n	a4a8 <HAL_DMA_Init+0x73c>
    a46a:	3314      	adds	r3, #20
    a46c:	429a      	cmp	r2, r3
    a46e:	d01b      	beq.n	a4a8 <HAL_DMA_Init+0x73c>
    a470:	4b46      	ldr	r3, [pc, #280]	; (a58c <HAL_DMA_Init+0x820>)
    a472:	494e      	ldr	r1, [pc, #312]	; (a5ac <HAL_DMA_Init+0x840>)
    a474:	4c4e      	ldr	r4, [pc, #312]	; (a5b0 <HAL_DMA_Init+0x844>)
    a476:	428a      	cmp	r2, r1
    a478:	bf18      	it	ne
    a47a:	429a      	cmpne	r2, r3
    a47c:	484d      	ldr	r0, [pc, #308]	; (a5b4 <HAL_DMA_Init+0x848>)
    a47e:	f101 013c 	add.w	r1, r1, #60	; 0x3c
    a482:	bf0c      	ite	eq
    a484:	2301      	moveq	r3, #1
    a486:	2300      	movne	r3, #0
    a488:	42a2      	cmp	r2, r4
    a48a:	bf08      	it	eq
    a48c:	f043 0301 	orreq.w	r3, r3, #1
    a490:	4282      	cmp	r2, r0
    a492:	bf08      	it	eq
    a494:	f043 0301 	orreq.w	r3, r3, #1
    a498:	428a      	cmp	r2, r1
    a49a:	bf08      	it	eq
    a49c:	f043 0301 	orreq.w	r3, r3, #1
    a4a0:	b913      	cbnz	r3, a4a8 <HAL_DMA_Init+0x73c>
    a4a2:	4b3b      	ldr	r3, [pc, #236]	; (a590 <HAL_DMA_Init+0x824>)
    a4a4:	429a      	cmp	r2, r3
    a4a6:	d15d      	bne.n	a564 <HAL_DMA_Init+0x7f8>
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    a4a8:	686b      	ldr	r3, [r5, #4]
    a4aa:	2b11      	cmp	r3, #17
    a4ac:	d853      	bhi.n	a556 <HAL_DMA_Init+0x7ea>
    hdma->State = HAL_DMA_STATE_BUSY;
    a4ae:	2302      	movs	r3, #2
    __HAL_UNLOCK(hdma);
    a4b0:	2100      	movs	r1, #0
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
    a4b2:	4f41      	ldr	r7, [pc, #260]	; (a5b8 <HAL_DMA_Init+0x84c>)
    hdma->State = HAL_DMA_STATE_BUSY;
    a4b4:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a4b8:	68ab      	ldr	r3, [r5, #8]
    __HAL_UNLOCK(hdma);
    a4ba:	f885 1034 	strb.w	r1, [r5, #52]	; 0x34
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a4be:	2b40      	cmp	r3, #64	; 0x40
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
    a4c0:	6811      	ldr	r1, [r2, #0]
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
    a4c2:	ea07 0701 	and.w	r7, r7, r1
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a4c6:	d044      	beq.n	a552 <HAL_DMA_Init+0x7e6>
    a4c8:	2b80      	cmp	r3, #128	; 0x80
    a4ca:	bf14      	ite	ne
    a4cc:	2100      	movne	r1, #0
    a4ce:	f44f 4180 	moveq.w	r1, #16384	; 0x4000
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
    a4d2:	692b      	ldr	r3, [r5, #16]
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    a4d4:	4628      	mov	r0, r5
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
    a4d6:	68ec      	ldr	r4, [r5, #12]
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
    a4d8:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
    a4da:	696e      	ldr	r6, [r5, #20]
    a4dc:	ea43 03d4 	orr.w	r3, r3, r4, lsr #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
    a4e0:	69ac      	ldr	r4, [r5, #24]
    a4e2:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
    a4e6:	69ee      	ldr	r6, [r5, #28]
    a4e8:	ea43 03d4 	orr.w	r3, r3, r4, lsr #3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
    a4ec:	6a2c      	ldr	r4, [r5, #32]
    a4ee:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
    a4f2:	4e32      	ldr	r6, [pc, #200]	; (a5bc <HAL_DMA_Init+0x850>)
    a4f4:	ea43 1314 	orr.w	r3, r3, r4, lsr #4
    a4f8:	4c31      	ldr	r4, [pc, #196]	; (a5c0 <HAL_DMA_Init+0x854>)
    a4fa:	433b      	orrs	r3, r7
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a4fc:	430b      	orrs	r3, r1
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
    a4fe:	6013      	str	r3, [r2, #0]
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
    a500:	682b      	ldr	r3, [r5, #0]
    a502:	441e      	add	r6, r3
    a504:	fba4 2306 	umull	r2, r3, r4, r6
    a508:	091b      	lsrs	r3, r3, #4
    a50a:	009b      	lsls	r3, r3, #2
    a50c:	65eb      	str	r3, [r5, #92]	; 0x5c
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    a50e:	f7ff fbb1 	bl	9c74 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    a512:	6dea      	ldr	r2, [r5, #92]	; 0x5c
    a514:	2301      	movs	r3, #1
    a516:	f002 021f 	and.w	r2, r2, #31
    a51a:	4093      	lsls	r3, r2
    a51c:	6043      	str	r3, [r0, #4]
    a51e:	e609      	b.n	a134 <HAL_DMA_Init+0x3c8>
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
    a520:	f1b0 7fc0 	cmp.w	r0, #25165824	; 0x1800000
    a524:	f47f adfc 	bne.w	a120 <HAL_DMA_Init+0x3b4>
    a528:	e5c7      	b.n	a0ba <HAL_DMA_Init+0x34e>
    switch (hdma->Init.FIFOThreshold)
    a52a:	2a03      	cmp	r2, #3
    a52c:	f63f adf8 	bhi.w	a120 <HAL_DMA_Init+0x3b4>
    a530:	a401      	add	r4, pc, #4	; (adr r4, a538 <HAL_DMA_Init+0x7cc>)
    a532:	f854 f022 	ldr.w	pc, [r4, r2, lsl #2]
    a536:	bf00      	nop
    a538:	0000a0bb 	.word	0x0000a0bb
    a53c:	0000a0b7 	.word	0x0000a0b7
    a540:	0000a0bb 	.word	0x0000a0bb
    a544:	0000a521 	.word	0x0000a521
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    a548:	4b1e      	ldr	r3, [pc, #120]	; (a5c4 <HAL_DMA_Init+0x858>)
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    a54a:	4c1f      	ldr	r4, [pc, #124]	; (a5c8 <HAL_DMA_Init+0x85c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    a54c:	4403      	add	r3, r0
    a54e:	009b      	lsls	r3, r3, #2
    a550:	e760      	b.n	a414 <HAL_DMA_Init+0x6a8>
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a552:	2110      	movs	r1, #16
    a554:	e7bd      	b.n	a4d2 <HAL_DMA_Init+0x766>
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    a556:	f44f 71b3 	mov.w	r1, #358	; 0x166
    a55a:	4809      	ldr	r0, [pc, #36]	; (a580 <HAL_DMA_Init+0x814>)
    a55c:	f00e ff5a 	bl	19414 <assert_failed>
    a560:	682a      	ldr	r2, [r5, #0]
    a562:	e7a4      	b.n	a4ae <HAL_DMA_Init+0x742>
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    a564:	2240      	movs	r2, #64	; 0x40
    hdma->State     = HAL_DMA_STATE_ERROR;
    a566:	2303      	movs	r3, #3
    return HAL_ERROR;
    a568:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    a56a:	656a      	str	r2, [r5, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
    a56c:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
    return HAL_ERROR;
    a570:	e6b4      	b.n	a2dc <HAL_DMA_Init+0x570>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
    a572:	21e1      	movs	r1, #225	; 0xe1
    a574:	4802      	ldr	r0, [pc, #8]	; (a580 <HAL_DMA_Init+0x814>)
    a576:	f00e ff4d 	bl	19414 <assert_failed>
    a57a:	e48f      	b.n	9e9c <HAL_DMA_Init+0x130>
    a57c:	c3c0003f 	.word	0xc3c0003f
    a580:	0002fc14 	.word	0x0002fc14
    a584:	58025408 	.word	0x58025408
    a588:	5802541c 	.word	0x5802541c
    a58c:	58025430 	.word	0x58025430
    a590:	58025494 	.word	0x58025494
    a594:	1600963f 	.word	0x1600963f
    a598:	58025940 	.word	0x58025940
    a59c:	bffdfbf0 	.word	0xbffdfbf0
    a5a0:	aaaaaaab 	.word	0xaaaaaaab
    a5a4:	10008200 	.word	0x10008200
    a5a8:	40020880 	.word	0x40020880
    a5ac:	58025444 	.word	0x58025444
    a5b0:	58025458 	.word	0x58025458
    a5b4:	5802546c 	.word	0x5802546c
    a5b8:	fffe000f 	.word	0xfffe000f
    a5bc:	a7fdabf8 	.word	0xa7fdabf8
    a5c0:	cccccccd 	.word	0xcccccccd
    a5c4:	1000823f 	.word	0x1000823f
    a5c8:	40020940 	.word	0x40020940

0000a5cc <HAL_DMA_DeInit>:
  if(hdma == NULL)
    a5cc:	2800      	cmp	r0, #0
    a5ce:	f000 821c 	beq.w	aa0a <HAL_DMA_DeInit+0x43e>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a5d2:	49a7      	ldr	r1, [pc, #668]	; (a870 <HAL_DMA_DeInit+0x2a4>)
{
    a5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_DMA_DISABLE(hdma);
    a5d8:	6802      	ldr	r2, [r0, #0]
    a5da:	4604      	mov	r4, r0
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a5dc:	4da5      	ldr	r5, [pc, #660]	; (a874 <HAL_DMA_DeInit+0x2a8>)
  __HAL_DMA_DISABLE(hdma);
    a5de:	6813      	ldr	r3, [r2, #0]
    a5e0:	f023 0301 	bic.w	r3, r3, #1
    a5e4:	6013      	str	r3, [r2, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a5e6:	4ba4      	ldr	r3, [pc, #656]	; (a878 <HAL_DMA_DeInit+0x2ac>)
    a5e8:	6802      	ldr	r2, [r0, #0]
    a5ea:	48a4      	ldr	r0, [pc, #656]	; (a87c <HAL_DMA_DeInit+0x2b0>)
    a5ec:	4282      	cmp	r2, r0
    a5ee:	bf18      	it	ne
    a5f0:	429a      	cmpne	r2, r3
    a5f2:	f100 0048 	add.w	r0, r0, #72	; 0x48
    a5f6:	bf0c      	ite	eq
    a5f8:	2301      	moveq	r3, #1
    a5fa:	2300      	movne	r3, #0
    a5fc:	428a      	cmp	r2, r1
    a5fe:	bf08      	it	eq
    a600:	f043 0301 	orreq.w	r3, r3, #1
    a604:	3148      	adds	r1, #72	; 0x48
    a606:	42aa      	cmp	r2, r5
    a608:	bf08      	it	eq
    a60a:	f043 0301 	orreq.w	r3, r3, #1
    a60e:	3548      	adds	r5, #72	; 0x48
    a610:	4282      	cmp	r2, r0
    a612:	bf08      	it	eq
    a614:	f043 0301 	orreq.w	r3, r3, #1
    a618:	3048      	adds	r0, #72	; 0x48
    a61a:	428a      	cmp	r2, r1
    a61c:	bf08      	it	eq
    a61e:	f043 0301 	orreq.w	r3, r3, #1
    a622:	f501 7162 	add.w	r1, r1, #904	; 0x388
    a626:	42aa      	cmp	r2, r5
    a628:	bf08      	it	eq
    a62a:	f043 0301 	orreq.w	r3, r3, #1
    a62e:	f505 7562 	add.w	r5, r5, #904	; 0x388
    a632:	4282      	cmp	r2, r0
    a634:	bf08      	it	eq
    a636:	f043 0301 	orreq.w	r3, r3, #1
    a63a:	f500 7062 	add.w	r0, r0, #904	; 0x388
    a63e:	428a      	cmp	r2, r1
    a640:	bf08      	it	eq
    a642:	f043 0301 	orreq.w	r3, r3, #1
    a646:	3148      	adds	r1, #72	; 0x48
    a648:	42aa      	cmp	r2, r5
    a64a:	bf08      	it	eq
    a64c:	f043 0301 	orreq.w	r3, r3, #1
    a650:	3548      	adds	r5, #72	; 0x48
    a652:	4282      	cmp	r2, r0
    a654:	bf08      	it	eq
    a656:	f043 0301 	orreq.w	r3, r3, #1
    a65a:	3048      	adds	r0, #72	; 0x48
    a65c:	428a      	cmp	r2, r1
    a65e:	bf08      	it	eq
    a660:	f043 0301 	orreq.w	r3, r3, #1
    a664:	3148      	adds	r1, #72	; 0x48
    a666:	42aa      	cmp	r2, r5
    a668:	bf08      	it	eq
    a66a:	f043 0301 	orreq.w	r3, r3, #1
    a66e:	4282      	cmp	r2, r0
    a670:	bf08      	it	eq
    a672:	f043 0301 	orreq.w	r3, r3, #1
    a676:	428a      	cmp	r2, r1
    a678:	bf08      	it	eq
    a67a:	f043 0301 	orreq.w	r3, r3, #1
    a67e:	b91b      	cbnz	r3, a688 <HAL_DMA_DeInit+0xbc>
    a680:	4b7f      	ldr	r3, [pc, #508]	; (a880 <HAL_DMA_DeInit+0x2b4>)
    a682:	429a      	cmp	r2, r3
    a684:	f040 81c3 	bne.w	aa0e <HAL_DMA_DeInit+0x442>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
    a688:	2100      	movs	r1, #0
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
    a68a:	2521      	movs	r5, #33	; 0x21
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a68c:	4b7a      	ldr	r3, [pc, #488]	; (a878 <HAL_DMA_DeInit+0x2ac>)
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
    a68e:	6011      	str	r1, [r2, #0]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
    a690:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a692:	487a      	ldr	r0, [pc, #488]	; (a87c <HAL_DMA_DeInit+0x2b0>)
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
    a694:	6051      	str	r1, [r2, #4]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
    a696:	6822      	ldr	r2, [r4, #0]
    a698:	6091      	str	r1, [r2, #8]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
    a69a:	6822      	ldr	r2, [r4, #0]
    a69c:	60d1      	str	r1, [r2, #12]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
    a69e:	6822      	ldr	r2, [r4, #0]
    a6a0:	6111      	str	r1, [r2, #16]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
    a6a2:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a6a4:	4972      	ldr	r1, [pc, #456]	; (a870 <HAL_DMA_DeInit+0x2a4>)
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
    a6a6:	6155      	str	r5, [r2, #20]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a6a8:	6822      	ldr	r2, [r4, #0]
    a6aa:	4d72      	ldr	r5, [pc, #456]	; (a874 <HAL_DMA_DeInit+0x2a8>)
    a6ac:	4282      	cmp	r2, r0
    a6ae:	bf18      	it	ne
    a6b0:	429a      	cmpne	r2, r3
    a6b2:	f100 0048 	add.w	r0, r0, #72	; 0x48
    a6b6:	bf0c      	ite	eq
    a6b8:	2301      	moveq	r3, #1
    a6ba:	2300      	movne	r3, #0
    a6bc:	428a      	cmp	r2, r1
    a6be:	bf08      	it	eq
    a6c0:	f043 0301 	orreq.w	r3, r3, #1
    a6c4:	3148      	adds	r1, #72	; 0x48
    a6c6:	42aa      	cmp	r2, r5
    a6c8:	bf08      	it	eq
    a6ca:	f043 0301 	orreq.w	r3, r3, #1
    a6ce:	3548      	adds	r5, #72	; 0x48
    a6d0:	4282      	cmp	r2, r0
    a6d2:	bf08      	it	eq
    a6d4:	f043 0301 	orreq.w	r3, r3, #1
    a6d8:	3048      	adds	r0, #72	; 0x48
    a6da:	428a      	cmp	r2, r1
    a6dc:	bf08      	it	eq
    a6de:	f043 0301 	orreq.w	r3, r3, #1
    a6e2:	f501 7162 	add.w	r1, r1, #904	; 0x388
    a6e6:	42aa      	cmp	r2, r5
    a6e8:	bf08      	it	eq
    a6ea:	f043 0301 	orreq.w	r3, r3, #1
    a6ee:	f505 7562 	add.w	r5, r5, #904	; 0x388
    a6f2:	4282      	cmp	r2, r0
    a6f4:	bf08      	it	eq
    a6f6:	f043 0301 	orreq.w	r3, r3, #1
    a6fa:	f500 7062 	add.w	r0, r0, #904	; 0x388
    a6fe:	428a      	cmp	r2, r1
    a700:	bf08      	it	eq
    a702:	f043 0301 	orreq.w	r3, r3, #1
    a706:	3148      	adds	r1, #72	; 0x48
    a708:	42aa      	cmp	r2, r5
    a70a:	bf08      	it	eq
    a70c:	f043 0301 	orreq.w	r3, r3, #1
    a710:	3548      	adds	r5, #72	; 0x48
    a712:	4282      	cmp	r2, r0
    a714:	bf08      	it	eq
    a716:	f043 0301 	orreq.w	r3, r3, #1
    a71a:	3048      	adds	r0, #72	; 0x48
    a71c:	428a      	cmp	r2, r1
    a71e:	bf08      	it	eq
    a720:	f043 0301 	orreq.w	r3, r3, #1
    a724:	3148      	adds	r1, #72	; 0x48
    a726:	42aa      	cmp	r2, r5
    a728:	bf08      	it	eq
    a72a:	f043 0301 	orreq.w	r3, r3, #1
    a72e:	4282      	cmp	r2, r0
    a730:	bf08      	it	eq
    a732:	f043 0301 	orreq.w	r3, r3, #1
    a736:	428a      	cmp	r2, r1
    a738:	bf08      	it	eq
    a73a:	f043 0301 	orreq.w	r3, r3, #1
    a73e:	b91b      	cbnz	r3, a748 <HAL_DMA_DeInit+0x17c>
    a740:	4b4f      	ldr	r3, [pc, #316]	; (a880 <HAL_DMA_DeInit+0x2b4>)
    a742:	429a      	cmp	r2, r3
    a744:	f040 819d 	bne.w	aa82 <HAL_DMA_DeInit+0x4b6>
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a748:	b2d3      	uxtb	r3, r2
    a74a:	4d4e      	ldr	r5, [pc, #312]	; (a884 <HAL_DMA_DeInit+0x2b8>)
    a74c:	494e      	ldr	r1, [pc, #312]	; (a888 <HAL_DMA_DeInit+0x2bc>)
    a74e:	3b10      	subs	r3, #16
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a750:	484e      	ldr	r0, [pc, #312]	; (a88c <HAL_DMA_DeInit+0x2c0>)
    a752:	4011      	ands	r1, r2
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a754:	fba5 5303 	umull	r5, r3, r5, r3
    a758:	091b      	lsrs	r3, r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a75a:	f003 0207 	and.w	r2, r3, #7
    if (stream_number > 3U)
    a75e:	2b03      	cmp	r3, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a760:	5c82      	ldrb	r2, [r0, r2]
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
    a762:	bf88      	it	hi
    a764:	3104      	addhi	r1, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a766:	65e2      	str	r2, [r4, #92]	; 0x5c
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
    a768:	65a1      	str	r1, [r4, #88]	; 0x58
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
    a76a:	f002 021f 	and.w	r2, r2, #31
    a76e:	233f      	movs	r3, #63	; 0x3f
    a770:	fa03 f202 	lsl.w	r2, r3, r2
    a774:	608a      	str	r2, [r1, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    a776:	6822      	ldr	r2, [r4, #0]
    a778:	4b3f      	ldr	r3, [pc, #252]	; (a878 <HAL_DMA_DeInit+0x2ac>)
    a77a:	4840      	ldr	r0, [pc, #256]	; (a87c <HAL_DMA_DeInit+0x2b0>)
    a77c:	493c      	ldr	r1, [pc, #240]	; (a870 <HAL_DMA_DeInit+0x2a4>)
    a77e:	4282      	cmp	r2, r0
    a780:	bf18      	it	ne
    a782:	429a      	cmpne	r2, r3
    a784:	4e3b      	ldr	r6, [pc, #236]	; (a874 <HAL_DMA_DeInit+0x2a8>)
    a786:	4d42      	ldr	r5, [pc, #264]	; (a890 <HAL_DMA_DeInit+0x2c4>)
    a788:	f100 0060 	add.w	r0, r0, #96	; 0x60
    a78c:	bf0c      	ite	eq
    a78e:	2301      	moveq	r3, #1
    a790:	2300      	movne	r3, #0
    a792:	f8df e104 	ldr.w	lr, [pc, #260]	; a898 <HAL_DMA_DeInit+0x2cc>
    a796:	428a      	cmp	r2, r1
    a798:	bf08      	it	eq
    a79a:	f043 0301 	orreq.w	r3, r3, #1
    a79e:	3160      	adds	r1, #96	; 0x60
    a7a0:	f8df c0f8 	ldr.w	ip, [pc, #248]	; a89c <HAL_DMA_DeInit+0x2d0>
    a7a4:	42b2      	cmp	r2, r6
    a7a6:	bf08      	it	eq
    a7a8:	f043 0301 	orreq.w	r3, r3, #1
    a7ac:	4f39      	ldr	r7, [pc, #228]	; (a894 <HAL_DMA_DeInit+0x2c8>)
    a7ae:	f506 767a 	add.w	r6, r6, #1000	; 0x3e8
    a7b2:	f8df 80ec 	ldr.w	r8, [pc, #236]	; a8a0 <HAL_DMA_DeInit+0x2d4>
    a7b6:	42aa      	cmp	r2, r5
    a7b8:	bf08      	it	eq
    a7ba:	f043 0301 	orreq.w	r3, r3, #1
    a7be:	f505 757a 	add.w	r5, r5, #1000	; 0x3e8
    a7c2:	f8df a0e0 	ldr.w	sl, [pc, #224]	; a8a4 <HAL_DMA_DeInit+0x2d8>
    a7c6:	4282      	cmp	r2, r0
    a7c8:	bf08      	it	eq
    a7ca:	f043 0301 	orreq.w	r3, r3, #1
    a7ce:	f500 707a 	add.w	r0, r0, #1000	; 0x3e8
    a7d2:	f8df 90ac 	ldr.w	r9, [pc, #172]	; a880 <HAL_DMA_DeInit+0x2b4>
    a7d6:	428a      	cmp	r2, r1
    a7d8:	bf08      	it	eq
    a7da:	f043 0301 	orreq.w	r3, r3, #1
    a7de:	f501 717a 	add.w	r1, r1, #1000	; 0x3e8
    a7e2:	4572      	cmp	r2, lr
    a7e4:	bf08      	it	eq
    a7e6:	f043 0301 	orreq.w	r3, r3, #1
    a7ea:	f8df e0bc 	ldr.w	lr, [pc, #188]	; a8a8 <HAL_DMA_DeInit+0x2dc>
    a7ee:	4562      	cmp	r2, ip
    a7f0:	bf08      	it	eq
    a7f2:	f043 0301 	orreq.w	r3, r3, #1
    a7f6:	eba2 0e0e 	sub.w	lr, r2, lr
    a7fa:	f8df c0b0 	ldr.w	ip, [pc, #176]	; a8ac <HAL_DMA_DeInit+0x2e0>
    a7fe:	42ba      	cmp	r2, r7
    a800:	bf08      	it	eq
    a802:	f043 0301 	orreq.w	r3, r3, #1
    a806:	fabe fe8e 	clz	lr, lr
    a80a:	eba2 070c 	sub.w	r7, r2, ip
    a80e:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    a812:	42b2      	cmp	r2, r6
    a814:	bf08      	it	eq
    a816:	f043 0301 	orreq.w	r3, r3, #1
    a81a:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
    a81e:	eba2 060a 	sub.w	r6, r2, sl
    a822:	fab7 f787 	clz	r7, r7
    a826:	42aa      	cmp	r2, r5
    a828:	bf08      	it	eq
    a82a:	f043 0301 	orreq.w	r3, r3, #1
    a82e:	f10a 0a28 	add.w	sl, sl, #40	; 0x28
    a832:	eba2 050c 	sub.w	r5, r2, ip
    a836:	097f      	lsrs	r7, r7, #5
    a838:	4282      	cmp	r2, r0
    a83a:	bf08      	it	eq
    a83c:	f043 0301 	orreq.w	r3, r3, #1
    a840:	fab6 f686 	clz	r6, r6
    a844:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    a848:	fab5 f585 	clz	r5, r5
    a84c:	428a      	cmp	r2, r1
    a84e:	bf08      	it	eq
    a850:	f043 0301 	orreq.w	r3, r3, #1
    a854:	0976      	lsrs	r6, r6, #5
    a856:	eba2 000a 	sub.w	r0, r2, sl
    a85a:	eba2 010c 	sub.w	r1, r2, ip
    a85e:	4542      	cmp	r2, r8
    a860:	bf08      	it	eq
    a862:	f043 0301 	orreq.w	r3, r3, #1
    a866:	096d      	lsrs	r5, r5, #5
    a868:	fab0 f080 	clz	r0, r0
    a86c:	e020      	b.n	a8b0 <HAL_DMA_DeInit+0x2e4>
    a86e:	bf00      	nop
    a870:	40020040 	.word	0x40020040
    a874:	40020058 	.word	0x40020058
    a878:	40020010 	.word	0x40020010
    a87c:	40020028 	.word	0x40020028
    a880:	400204b8 	.word	0x400204b8
    a884:	aaaaaaab 	.word	0xaaaaaaab
    a888:	fffffc00 	.word	0xfffffc00
    a88c:	0002fc4c 	.word	0x0002fc4c
    a890:	40020070 	.word	0x40020070
    a894:	40020428 	.word	0x40020428
    a898:	400200b8 	.word	0x400200b8
    a89c:	40020410 	.word	0x40020410
    a8a0:	400204a0 	.word	0x400204a0
    a8a4:	58025430 	.word	0x58025430
    a8a8:	58025408 	.word	0x58025408
    a8ac:	5802541c 	.word	0x5802541c
    a8b0:	f10c 0c14 	add.w	ip, ip, #20
    a8b4:	454a      	cmp	r2, r9
    a8b6:	bf08      	it	eq
    a8b8:	f043 0301 	orreq.w	r3, r3, #1
    a8bc:	fab1 f181 	clz	r1, r1
    a8c0:	0940      	lsrs	r0, r0, #5
    a8c2:	eba2 0c0c 	sub.w	ip, r2, ip
    a8c6:	ea4e 0303 	orr.w	r3, lr, r3
    a8ca:	0949      	lsrs	r1, r1, #5
    a8cc:	f8df 81e4 	ldr.w	r8, [pc, #484]	; aab4 <HAL_DMA_DeInit+0x4e8>
    a8d0:	fabc fc8c 	clz	ip, ip
    a8d4:	433b      	orrs	r3, r7
    a8d6:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
    a8da:	eba2 0808 	sub.w	r8, r2, r8
    a8de:	4333      	orrs	r3, r6
    a8e0:	fab8 f888 	clz	r8, r8
    a8e4:	432b      	orrs	r3, r5
    a8e6:	ea4f 1858 	mov.w	r8, r8, lsr #5
    a8ea:	4303      	orrs	r3, r0
    a8ec:	430b      	orrs	r3, r1
    a8ee:	ea5c 0303 	orrs.w	r3, ip, r3
    a8f2:	d102      	bne.n	a8fa <HAL_DMA_DeInit+0x32e>
    a8f4:	f1b8 0f00 	cmp.w	r8, #0
    a8f8:	d02b      	beq.n	a952 <HAL_DMA_DeInit+0x386>
  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    a8fa:	ea47 070e 	orr.w	r7, r7, lr
    a8fe:	b2d3      	uxtb	r3, r2
    a900:	433e      	orrs	r6, r7
    a902:	4335      	orrs	r5, r6
    a904:	4328      	orrs	r0, r5
    a906:	4301      	orrs	r1, r0
    a908:	ea5c 0101 	orrs.w	r1, ip, r1
    a90c:	d102      	bne.n	a914 <HAL_DMA_DeInit+0x348>
    a90e:	f1b8 0f00 	cmp.w	r8, #0
    a912:	d063      	beq.n	a9dc <HAL_DMA_DeInit+0x410>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a914:	4861      	ldr	r0, [pc, #388]	; (aa9c <HAL_DMA_DeInit+0x4d0>)
    a916:	3b08      	subs	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a918:	4a61      	ldr	r2, [pc, #388]	; (aaa0 <HAL_DMA_DeInit+0x4d4>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a91a:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a91c:	fba0 0303 	umull	r0, r3, r0, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a920:	4860      	ldr	r0, [pc, #384]	; (aaa4 <HAL_DMA_DeInit+0x4d8>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a922:	091b      	lsrs	r3, r3, #4
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a924:	6660      	str	r0, [r4, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a926:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a928:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a92c:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a92e:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a932:	6622      	str	r2, [r4, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a934:	66a3      	str	r3, [r4, #104]	; 0x68
    if(hdma->DMAmuxChannel != 0U)
    a936:	b122      	cbz	r2, a942 <HAL_DMA_DeInit+0x376>
      hdma->DMAmuxChannel->CCR = 0U;
    a938:	2300      	movs	r3, #0
    a93a:	6013      	str	r3, [r2, #0]
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    a93c:	e9d4 3219 	ldrd	r3, r2, [r4, #100]	; 0x64
    a940:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
    a942:	6860      	ldr	r0, [r4, #4]
    a944:	1e41      	subs	r1, r0, #1
    a946:	2907      	cmp	r1, #7
    a948:	d912      	bls.n	a970 <HAL_DMA_DeInit+0x3a4>
    hdma->DMAmuxRequestGen = 0U;
    a94a:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
    a94c:	e9c4 331b 	strd	r3, r3, [r4, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatusMask = 0U;
    a950:	6763      	str	r3, [r4, #116]	; 0x74
  hdma->XferCpltCallback       = NULL;
    a952:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    a954:	6563      	str	r3, [r4, #84]	; 0x54
  return HAL_OK;
    a956:	4618      	mov	r0, r3
  hdma->State = HAL_DMA_STATE_RESET;
    a958:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_UNLOCK(hdma);
    a95c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  hdma->XferHalfCpltCallback   = NULL;
    a960:	e9c4 330f 	strd	r3, r3, [r4, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
    a964:	e9c4 3311 	strd	r3, r3, [r4, #68]	; 0x44
  hdma->XferAbortCallback      = NULL;
    a968:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
}
    a96c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    a970:	6822      	ldr	r2, [r4, #0]
    a972:	4b4d      	ldr	r3, [pc, #308]	; (aaa8 <HAL_DMA_DeInit+0x4dc>)
    a974:	4e4d      	ldr	r6, [pc, #308]	; (aaac <HAL_DMA_DeInit+0x4e0>)
    a976:	4d4e      	ldr	r5, [pc, #312]	; (aab0 <HAL_DMA_DeInit+0x4e4>)
    a978:	42b2      	cmp	r2, r6
    a97a:	bf18      	it	ne
    a97c:	429a      	cmpne	r2, r3
    a97e:	f106 0628 	add.w	r6, r6, #40	; 0x28
    a982:	bf0c      	ite	eq
    a984:	2301      	moveq	r3, #1
    a986:	2300      	movne	r3, #0
    a988:	42aa      	cmp	r2, r5
    a98a:	bf08      	it	eq
    a98c:	f043 0301 	orreq.w	r3, r3, #1
    a990:	3528      	adds	r5, #40	; 0x28
    a992:	42b2      	cmp	r2, r6
    a994:	bf08      	it	eq
    a996:	f043 0301 	orreq.w	r3, r3, #1
    a99a:	3628      	adds	r6, #40	; 0x28
    a99c:	42aa      	cmp	r2, r5
    a99e:	bf08      	it	eq
    a9a0:	f043 0301 	orreq.w	r3, r3, #1
    a9a4:	3528      	adds	r5, #40	; 0x28
    a9a6:	42b2      	cmp	r2, r6
    a9a8:	bf08      	it	eq
    a9aa:	f043 0301 	orreq.w	r3, r3, #1
    a9ae:	42aa      	cmp	r2, r5
    a9b0:	bf08      	it	eq
    a9b2:	f043 0301 	orreq.w	r3, r3, #1
    a9b6:	b913      	cbnz	r3, a9be <HAL_DMA_DeInit+0x3f2>
    a9b8:	4b3e      	ldr	r3, [pc, #248]	; (aab4 <HAL_DMA_DeInit+0x4e8>)
    a9ba:	429a      	cmp	r2, r3
    a9bc:	d169      	bne.n	aa92 <HAL_DMA_DeInit+0x4c6>
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a9be:	4a3e      	ldr	r2, [pc, #248]	; (aab8 <HAL_DMA_DeInit+0x4ec>)
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
    a9c0:	4d3e      	ldr	r5, [pc, #248]	; (aabc <HAL_DMA_DeInit+0x4f0>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a9c2:	4402      	add	r2, r0
    a9c4:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    a9c6:	2301      	movs	r3, #1
      hdma->DMAmuxRequestGen->RGCR = 0U;
    a9c8:	2000      	movs	r0, #0
    a9ca:	6725      	str	r5, [r4, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    a9cc:	fa03 f101 	lsl.w	r1, r3, r1
    a9d0:	6761      	str	r1, [r4, #116]	; 0x74
      hdma->DMAmuxRequestGen->RGCR = 0U;
    a9d2:	6010      	str	r0, [r2, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    a9d4:	e9d4 321c 	ldrd	r3, r2, [r4, #112]	; 0x70
    a9d8:	605a      	str	r2, [r3, #4]
    a9da:	e7b6      	b.n	a94a <HAL_DMA_DeInit+0x37e>
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a9dc:	4938      	ldr	r1, [pc, #224]	; (aac0 <HAL_DMA_DeInit+0x4f4>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a9de:	3b10      	subs	r3, #16
    a9e0:	4838      	ldr	r0, [pc, #224]	; (aac4 <HAL_DMA_DeInit+0x4f8>)
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a9e2:	4411      	add	r1, r2
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a9e4:	fba0 0303 	umull	r0, r3, r0, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a9e8:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a9ea:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a9ee:	d800      	bhi.n	a9f2 <HAL_DMA_DeInit+0x426>
      stream_number += 8U;
    a9f0:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a9f2:	4a35      	ldr	r2, [pc, #212]	; (aac8 <HAL_DMA_DeInit+0x4fc>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a9f4:	f003 051f 	and.w	r5, r3, #31
    a9f8:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    a9fa:	4834      	ldr	r0, [pc, #208]	; (aacc <HAL_DMA_DeInit+0x500>)
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a9fc:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a9fe:	40a9      	lsls	r1, r5
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    aa00:	6660      	str	r0, [r4, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    aa02:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    aa04:	66a1      	str	r1, [r4, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    aa06:	6622      	str	r2, [r4, #96]	; 0x60
    aa08:	e795      	b.n	a936 <HAL_DMA_DeInit+0x36a>
    return HAL_ERROR;
    aa0a:	2001      	movs	r0, #1
}
    aa0c:	4770      	bx	lr
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
    aa0e:	4b26      	ldr	r3, [pc, #152]	; (aaa8 <HAL_DMA_DeInit+0x4dc>)
    aa10:	4926      	ldr	r1, [pc, #152]	; (aaac <HAL_DMA_DeInit+0x4e0>)
    aa12:	4827      	ldr	r0, [pc, #156]	; (aab0 <HAL_DMA_DeInit+0x4e4>)
    aa14:	428a      	cmp	r2, r1
    aa16:	bf18      	it	ne
    aa18:	429a      	cmpne	r2, r3
    aa1a:	f101 0128 	add.w	r1, r1, #40	; 0x28
    aa1e:	4d2c      	ldr	r5, [pc, #176]	; (aad0 <HAL_DMA_DeInit+0x504>)
    aa20:	bf0c      	ite	eq
    aa22:	2301      	moveq	r3, #1
    aa24:	2300      	movne	r3, #0
    aa26:	4282      	cmp	r2, r0
    aa28:	bf08      	it	eq
    aa2a:	f043 0301 	orreq.w	r3, r3, #1
    aa2e:	303c      	adds	r0, #60	; 0x3c
    aa30:	428a      	cmp	r2, r1
    aa32:	bf08      	it	eq
    aa34:	f043 0301 	orreq.w	r3, r3, #1
    aa38:	313c      	adds	r1, #60	; 0x3c
    aa3a:	42aa      	cmp	r2, r5
    aa3c:	bf08      	it	eq
    aa3e:	f043 0301 	orreq.w	r3, r3, #1
    aa42:	4282      	cmp	r2, r0
    aa44:	bf08      	it	eq
    aa46:	f043 0301 	orreq.w	r3, r3, #1
    aa4a:	428a      	cmp	r2, r1
    aa4c:	bf08      	it	eq
    aa4e:	f043 0301 	orreq.w	r3, r3, #1
    aa52:	b913      	cbnz	r3, aa5a <HAL_DMA_DeInit+0x48e>
    aa54:	4b17      	ldr	r3, [pc, #92]	; (aab4 <HAL_DMA_DeInit+0x4e8>)
    aa56:	429a      	cmp	r2, r3
    aa58:	d118      	bne.n	aa8c <HAL_DMA_DeInit+0x4c0>
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
    aa5a:	2300      	movs	r3, #0
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    aa5c:	4620      	mov	r0, r4
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
    aa5e:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
    aa60:	6822      	ldr	r2, [r4, #0]
    aa62:	6053      	str	r3, [r2, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
    aa64:	6822      	ldr	r2, [r4, #0]
    aa66:	6093      	str	r3, [r2, #8]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
    aa68:	6822      	ldr	r2, [r4, #0]
    aa6a:	60d3      	str	r3, [r2, #12]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
    aa6c:	6822      	ldr	r2, [r4, #0]
    aa6e:	6113      	str	r3, [r2, #16]
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    aa70:	f7ff f900 	bl	9c74 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    aa74:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    aa76:	2301      	movs	r3, #1
    aa78:	f002 021f 	and.w	r2, r2, #31
    aa7c:	4093      	lsls	r3, r2
    aa7e:	6043      	str	r3, [r0, #4]
    aa80:	e679      	b.n	a776 <HAL_DMA_DeInit+0x1aa>
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
    aa82:	f022 01ff 	bic.w	r1, r2, #255	; 0xff
    aa86:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    aa88:	65a1      	str	r1, [r4, #88]	; 0x58
    aa8a:	e66e      	b.n	a76a <HAL_DMA_DeInit+0x19e>
    return HAL_ERROR;
    aa8c:	2001      	movs	r0, #1
}
    aa8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    aa92:	4a10      	ldr	r2, [pc, #64]	; (aad4 <HAL_DMA_DeInit+0x508>)
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    aa94:	4d10      	ldr	r5, [pc, #64]	; (aad8 <HAL_DMA_DeInit+0x50c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    aa96:	4402      	add	r2, r0
    aa98:	0092      	lsls	r2, r2, #2
    aa9a:	e794      	b.n	a9c6 <HAL_DMA_DeInit+0x3fa>
    aa9c:	cccccccd 	.word	0xcccccccd
    aaa0:	16009600 	.word	0x16009600
    aaa4:	58025880 	.word	0x58025880
    aaa8:	58025408 	.word	0x58025408
    aaac:	5802541c 	.word	0x5802541c
    aab0:	58025430 	.word	0x58025430
    aab4:	58025494 	.word	0x58025494
    aab8:	1600963f 	.word	0x1600963f
    aabc:	58025940 	.word	0x58025940
    aac0:	bffdfbf0 	.word	0xbffdfbf0
    aac4:	aaaaaaab 	.word	0xaaaaaaab
    aac8:	10008200 	.word	0x10008200
    aacc:	40020880 	.word	0x40020880
    aad0:	58025458 	.word	0x58025458
    aad4:	1000823f 	.word	0x1000823f
    aad8:	40020940 	.word	0x40020940

0000aadc <HAL_DMA_Start_IT>:
{
    aadc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    aade:	461d      	mov	r5, r3
    aae0:	460e      	mov	r6, r1
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    aae2:	f64f 73fe 	movw	r3, #65534	; 0xfffe
{
    aae6:	4604      	mov	r4, r0
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    aae8:	1e69      	subs	r1, r5, #1
{
    aaea:	4617      	mov	r7, r2
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    aaec:	4299      	cmp	r1, r3
    aaee:	d813      	bhi.n	ab18 <HAL_DMA_Start_IT+0x3c>
  if(hdma == NULL)
    aaf0:	b1cc      	cbz	r4, ab26 <HAL_DMA_Start_IT+0x4a>
  __HAL_LOCK(hdma);
    aaf2:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
    aaf6:	2b01      	cmp	r3, #1
    aaf8:	f000 826f 	beq.w	afda <HAL_DMA_Start_IT+0x4fe>
    aafc:	2001      	movs	r0, #1
  if(HAL_DMA_STATE_READY == hdma->State)
    aafe:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    ab02:	4283      	cmp	r3, r0
  __HAL_LOCK(hdma);
    ab04:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
    ab08:	d012      	beq.n	ab30 <HAL_DMA_Start_IT+0x54>
    __HAL_UNLOCK(hdma);
    ab0a:	2200      	movs	r2, #0
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    ab0c:	f44f 6300 	mov.w	r3, #2048	; 0x800
    __HAL_UNLOCK(hdma);
    ab10:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    ab14:	6563      	str	r3, [r4, #84]	; 0x54
}
    ab16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    ab18:	f240 21a7 	movw	r1, #679	; 0x2a7
    ab1c:	4803      	ldr	r0, [pc, #12]	; (ab2c <HAL_DMA_Start_IT+0x50>)
    ab1e:	f00e fc79 	bl	19414 <assert_failed>
  if(hdma == NULL)
    ab22:	2c00      	cmp	r4, #0
    ab24:	d1e5      	bne.n	aaf2 <HAL_DMA_Start_IT+0x16>
    return HAL_ERROR;
    ab26:	2001      	movs	r0, #1
}
    ab28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ab2a:	bf00      	nop
    ab2c:	0002fc14 	.word	0x0002fc14
    hdma->State = HAL_DMA_STATE_BUSY;
    ab30:	2002      	movs	r0, #2
    __HAL_DMA_DISABLE(hdma);
    ab32:	6822      	ldr	r2, [r4, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
    ab34:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    ab38:	2000      	movs	r0, #0
    ab3a:	6560      	str	r0, [r4, #84]	; 0x54
    __HAL_DMA_DISABLE(hdma);
    ab3c:	6813      	ldr	r3, [r2, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    ab3e:	489e      	ldr	r0, [pc, #632]	; (adb8 <HAL_DMA_Start_IT+0x2dc>)
    __HAL_DMA_DISABLE(hdma);
    ab40:	f023 0301 	bic.w	r3, r3, #1
    ab44:	6013      	str	r3, [r2, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    ab46:	4a9d      	ldr	r2, [pc, #628]	; (adbc <HAL_DMA_Start_IT+0x2e0>)
    ab48:	6821      	ldr	r1, [r4, #0]
    ab4a:	4b9d      	ldr	r3, [pc, #628]	; (adc0 <HAL_DMA_Start_IT+0x2e4>)
    ab4c:	4291      	cmp	r1, r2
    ab4e:	bf18      	it	ne
    ab50:	4281      	cmpne	r1, r0
    ab52:	f102 0230 	add.w	r2, r2, #48	; 0x30
    ab56:	bf0c      	ite	eq
    ab58:	2001      	moveq	r0, #1
    ab5a:	2000      	movne	r0, #0
    ab5c:	4299      	cmp	r1, r3
    ab5e:	bf08      	it	eq
    ab60:	f040 0001 	orreq.w	r0, r0, #1
    ab64:	3330      	adds	r3, #48	; 0x30
    ab66:	4291      	cmp	r1, r2
    ab68:	bf08      	it	eq
    ab6a:	f040 0001 	orreq.w	r0, r0, #1
    ab6e:	3230      	adds	r2, #48	; 0x30
    ab70:	4299      	cmp	r1, r3
    ab72:	bf08      	it	eq
    ab74:	f040 0001 	orreq.w	r0, r0, #1
    ab78:	3330      	adds	r3, #48	; 0x30
    ab7a:	4291      	cmp	r1, r2
    ab7c:	bf08      	it	eq
    ab7e:	f040 0001 	orreq.w	r0, r0, #1
    ab82:	3230      	adds	r2, #48	; 0x30
    ab84:	4299      	cmp	r1, r3
    ab86:	bf08      	it	eq
    ab88:	f040 0001 	orreq.w	r0, r0, #1
    ab8c:	f503 735c 	add.w	r3, r3, #880	; 0x370
    ab90:	4291      	cmp	r1, r2
    ab92:	bf08      	it	eq
    ab94:	f040 0001 	orreq.w	r0, r0, #1
    ab98:	f502 725c 	add.w	r2, r2, #880	; 0x370
    ab9c:	4299      	cmp	r1, r3
    ab9e:	bf08      	it	eq
    aba0:	f040 0001 	orreq.w	r0, r0, #1
    aba4:	3330      	adds	r3, #48	; 0x30
    aba6:	4291      	cmp	r1, r2
    aba8:	bf08      	it	eq
    abaa:	f040 0001 	orreq.w	r0, r0, #1
    abae:	3230      	adds	r2, #48	; 0x30
    abb0:	4299      	cmp	r1, r3
    abb2:	bf08      	it	eq
    abb4:	f040 0001 	orreq.w	r0, r0, #1
    abb8:	3330      	adds	r3, #48	; 0x30
    abba:	4291      	cmp	r1, r2
    abbc:	bf08      	it	eq
    abbe:	f040 0001 	orreq.w	r0, r0, #1
    abc2:	3230      	adds	r2, #48	; 0x30
    abc4:	4299      	cmp	r1, r3
    abc6:	bf08      	it	eq
    abc8:	f040 0001 	orreq.w	r0, r0, #1
    abcc:	3330      	adds	r3, #48	; 0x30
    abce:	4291      	cmp	r1, r2
    abd0:	bf08      	it	eq
    abd2:	f040 0001 	orreq.w	r0, r0, #1
    abd6:	3230      	adds	r2, #48	; 0x30
    abd8:	4299      	cmp	r1, r3
    abda:	bf08      	it	eq
    abdc:	f040 0001 	orreq.w	r0, r0, #1
    abe0:	4b78      	ldr	r3, [pc, #480]	; (adc4 <HAL_DMA_Start_IT+0x2e8>)
    abe2:	4291      	cmp	r1, r2
    abe4:	bf08      	it	eq
    abe6:	f040 0001 	orreq.w	r0, r0, #1
    abea:	4a77      	ldr	r2, [pc, #476]	; (adc8 <HAL_DMA_Start_IT+0x2ec>)
    abec:	4299      	cmp	r1, r3
    abee:	bf08      	it	eq
    abf0:	f040 0001 	orreq.w	r0, r0, #1
    abf4:	3328      	adds	r3, #40	; 0x28
    abf6:	4291      	cmp	r1, r2
    abf8:	bf08      	it	eq
    abfa:	f040 0001 	orreq.w	r0, r0, #1
    abfe:	3228      	adds	r2, #40	; 0x28
    ac00:	4299      	cmp	r1, r3
    ac02:	bf08      	it	eq
    ac04:	f040 0001 	orreq.w	r0, r0, #1
    ac08:	3328      	adds	r3, #40	; 0x28
    ac0a:	4291      	cmp	r1, r2
    ac0c:	bf08      	it	eq
    ac0e:	f040 0001 	orreq.w	r0, r0, #1
    ac12:	3228      	adds	r2, #40	; 0x28
    ac14:	4299      	cmp	r1, r3
    ac16:	bf08      	it	eq
    ac18:	f040 0001 	orreq.w	r0, r0, #1
    ac1c:	3328      	adds	r3, #40	; 0x28
    ac1e:	4291      	cmp	r1, r2
    ac20:	bf08      	it	eq
    ac22:	f040 0001 	orreq.w	r0, r0, #1
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
    ac26:	6da2      	ldr	r2, [r4, #88]	; 0x58
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    ac28:	4299      	cmp	r1, r3
    ac2a:	bf08      	it	eq
    ac2c:	f040 0001 	orreq.w	r0, r0, #1
    ac30:	b910      	cbnz	r0, ac38 <HAL_DMA_Start_IT+0x15c>
    ac32:	3314      	adds	r3, #20
    ac34:	4299      	cmp	r1, r3
    ac36:	d108      	bne.n	ac4a <HAL_DMA_Start_IT+0x16e>
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    ac38:	e9d4 3119 	ldrd	r3, r1, [r4, #100]	; 0x64
    ac3c:	6059      	str	r1, [r3, #4]
    if(hdma->DMAmuxRequestGen != 0U)
    ac3e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    ac40:	b113      	cbz	r3, ac48 <HAL_DMA_Start_IT+0x16c>
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    ac42:	e9d4 311c 	ldrd	r3, r1, [r4, #112]	; 0x70
    ac46:	6059      	str	r1, [r3, #4]
    ac48:	6821      	ldr	r1, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    ac4a:	4b5b      	ldr	r3, [pc, #364]	; (adb8 <HAL_DMA_Start_IT+0x2dc>)
    ac4c:	f8df c16c 	ldr.w	ip, [pc, #364]	; adbc <HAL_DMA_Start_IT+0x2e0>
    ac50:	485b      	ldr	r0, [pc, #364]	; (adc0 <HAL_DMA_Start_IT+0x2e4>)
    ac52:	4561      	cmp	r1, ip
    ac54:	bf18      	it	ne
    ac56:	4299      	cmpne	r1, r3
    ac58:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    ac5c:	bf0c      	ite	eq
    ac5e:	2301      	moveq	r3, #1
    ac60:	2300      	movne	r3, #0
    ac62:	4281      	cmp	r1, r0
    ac64:	bf08      	it	eq
    ac66:	f043 0301 	orreq.w	r3, r3, #1
    ac6a:	3030      	adds	r0, #48	; 0x30
    ac6c:	4561      	cmp	r1, ip
    ac6e:	bf08      	it	eq
    ac70:	f043 0301 	orreq.w	r3, r3, #1
    ac74:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    ac78:	4281      	cmp	r1, r0
    ac7a:	bf08      	it	eq
    ac7c:	f043 0301 	orreq.w	r3, r3, #1
    ac80:	3030      	adds	r0, #48	; 0x30
    ac82:	4561      	cmp	r1, ip
    ac84:	bf08      	it	eq
    ac86:	f043 0301 	orreq.w	r3, r3, #1
    ac8a:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    ac8e:	4281      	cmp	r1, r0
    ac90:	bf08      	it	eq
    ac92:	f043 0301 	orreq.w	r3, r3, #1
    ac96:	f500 705c 	add.w	r0, r0, #880	; 0x370
    ac9a:	4561      	cmp	r1, ip
    ac9c:	bf08      	it	eq
    ac9e:	f043 0301 	orreq.w	r3, r3, #1
    aca2:	f50c 7c5c 	add.w	ip, ip, #880	; 0x370
    aca6:	4281      	cmp	r1, r0
    aca8:	bf08      	it	eq
    acaa:	f043 0301 	orreq.w	r3, r3, #1
    acae:	3030      	adds	r0, #48	; 0x30
    acb0:	4561      	cmp	r1, ip
    acb2:	bf08      	it	eq
    acb4:	f043 0301 	orreq.w	r3, r3, #1
    acb8:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    acbc:	4281      	cmp	r1, r0
    acbe:	bf08      	it	eq
    acc0:	f043 0301 	orreq.w	r3, r3, #1
    acc4:	3030      	adds	r0, #48	; 0x30
    acc6:	4561      	cmp	r1, ip
    acc8:	bf08      	it	eq
    acca:	f043 0301 	orreq.w	r3, r3, #1
    acce:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    acd2:	4281      	cmp	r1, r0
    acd4:	bf08      	it	eq
    acd6:	f043 0301 	orreq.w	r3, r3, #1
    acda:	3030      	adds	r0, #48	; 0x30
    acdc:	4561      	cmp	r1, ip
    acde:	bf08      	it	eq
    ace0:	f043 0301 	orreq.w	r3, r3, #1
    ace4:	4281      	cmp	r1, r0
    ace6:	bf08      	it	eq
    ace8:	f043 0301 	orreq.w	r3, r3, #1
    acec:	b91b      	cbnz	r3, acf6 <HAL_DMA_Start_IT+0x21a>
    acee:	4b37      	ldr	r3, [pc, #220]	; (adcc <HAL_DMA_Start_IT+0x2f0>)
    acf0:	4299      	cmp	r1, r3
    acf2:	f040 8174 	bne.w	afde <HAL_DMA_Start_IT+0x502>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
    acf6:	6de1      	ldr	r1, [r4, #92]	; 0x5c
    acf8:	233f      	movs	r3, #63	; 0x3f
    acfa:	f001 011f 	and.w	r1, r1, #31
    acfe:	408b      	lsls	r3, r1
    ad00:	6093      	str	r3, [r2, #8]
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
    ad02:	6822      	ldr	r2, [r4, #0]
    ad04:	6813      	ldr	r3, [r2, #0]
    ad06:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
    ad0a:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
    ad0c:	6823      	ldr	r3, [r4, #0]
    ad0e:	605d      	str	r5, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
    ad10:	68a3      	ldr	r3, [r4, #8]
    ad12:	2b40      	cmp	r3, #64	; 0x40
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
    ad14:	6823      	ldr	r3, [r4, #0]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
    ad16:	f000 815b 	beq.w	afd0 <HAL_DMA_Start_IT+0x4f4>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
    ad1a:	609e      	str	r6, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
    ad1c:	6823      	ldr	r3, [r4, #0]
    ad1e:	60df      	str	r7, [r3, #12]
    ad20:	6821      	ldr	r1, [r4, #0]
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    ad22:	4b25      	ldr	r3, [pc, #148]	; (adb8 <HAL_DMA_Start_IT+0x2dc>)
    ad24:	4825      	ldr	r0, [pc, #148]	; (adbc <HAL_DMA_Start_IT+0x2e0>)
    ad26:	4a26      	ldr	r2, [pc, #152]	; (adc0 <HAL_DMA_Start_IT+0x2e4>)
    ad28:	4281      	cmp	r1, r0
    ad2a:	bf18      	it	ne
    ad2c:	4299      	cmpne	r1, r3
    ad2e:	4d28      	ldr	r5, [pc, #160]	; (add0 <HAL_DMA_Start_IT+0x2f4>)
    ad30:	f100 0048 	add.w	r0, r0, #72	; 0x48
    ad34:	bf0c      	ite	eq
    ad36:	2301      	moveq	r3, #1
    ad38:	2300      	movne	r3, #0
    ad3a:	4291      	cmp	r1, r2
    ad3c:	bf08      	it	eq
    ad3e:	f043 0301 	orreq.w	r3, r3, #1
    ad42:	3248      	adds	r2, #72	; 0x48
    ad44:	42a9      	cmp	r1, r5
    ad46:	bf08      	it	eq
    ad48:	f043 0301 	orreq.w	r3, r3, #1
    ad4c:	3548      	adds	r5, #72	; 0x48
    ad4e:	4281      	cmp	r1, r0
    ad50:	bf08      	it	eq
    ad52:	f043 0301 	orreq.w	r3, r3, #1
    ad56:	3048      	adds	r0, #72	; 0x48
    ad58:	4291      	cmp	r1, r2
    ad5a:	bf08      	it	eq
    ad5c:	f043 0301 	orreq.w	r3, r3, #1
    ad60:	f502 7262 	add.w	r2, r2, #904	; 0x388
    ad64:	42a9      	cmp	r1, r5
    ad66:	bf08      	it	eq
    ad68:	f043 0301 	orreq.w	r3, r3, #1
    ad6c:	f505 7562 	add.w	r5, r5, #904	; 0x388
    ad70:	4281      	cmp	r1, r0
    ad72:	bf08      	it	eq
    ad74:	f043 0301 	orreq.w	r3, r3, #1
    ad78:	f500 7062 	add.w	r0, r0, #904	; 0x388
    ad7c:	4291      	cmp	r1, r2
    ad7e:	bf08      	it	eq
    ad80:	f043 0301 	orreq.w	r3, r3, #1
    ad84:	3248      	adds	r2, #72	; 0x48
    ad86:	42a9      	cmp	r1, r5
    ad88:	bf08      	it	eq
    ad8a:	f043 0301 	orreq.w	r3, r3, #1
    ad8e:	3548      	adds	r5, #72	; 0x48
    ad90:	4281      	cmp	r1, r0
    ad92:	bf08      	it	eq
    ad94:	f043 0301 	orreq.w	r3, r3, #1
    ad98:	3048      	adds	r0, #72	; 0x48
    ad9a:	4291      	cmp	r1, r2
    ad9c:	bf08      	it	eq
    ad9e:	f043 0301 	orreq.w	r3, r3, #1
    ada2:	3248      	adds	r2, #72	; 0x48
    ada4:	42a9      	cmp	r1, r5
    ada6:	bf08      	it	eq
    ada8:	f043 0301 	orreq.w	r3, r3, #1
    adac:	4281      	cmp	r1, r0
    adae:	bf08      	it	eq
    adb0:	f043 0301 	orreq.w	r3, r3, #1
    adb4:	e00e      	b.n	add4 <HAL_DMA_Start_IT+0x2f8>
    adb6:	bf00      	nop
    adb8:	40020010 	.word	0x40020010
    adbc:	40020028 	.word	0x40020028
    adc0:	40020040 	.word	0x40020040
    adc4:	58025408 	.word	0x58025408
    adc8:	5802541c 	.word	0x5802541c
    adcc:	400204b8 	.word	0x400204b8
    add0:	40020058 	.word	0x40020058
    add4:	4291      	cmp	r1, r2
    add6:	bf08      	it	eq
    add8:	f043 0301 	orreq.w	r3, r3, #1
    addc:	b91b      	cbnz	r3, ade6 <HAL_DMA_Start_IT+0x30a>
    adde:	4b9a      	ldr	r3, [pc, #616]	; (b048 <HAL_DMA_Start_IT+0x56c>)
    ade0:	4299      	cmp	r1, r3
    ade2:	f040 8145 	bne.w	b070 <HAL_DMA_Start_IT+0x594>
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
    ade6:	680b      	ldr	r3, [r1, #0]
    ade8:	f023 031e 	bic.w	r3, r3, #30
    adec:	f043 0316 	orr.w	r3, r3, #22
    adf0:	600b      	str	r3, [r1, #0]
      if(hdma->XferHalfCpltCallback != NULL)
    adf2:	6c23      	ldr	r3, [r4, #64]	; 0x40
    adf4:	b123      	cbz	r3, ae00 <HAL_DMA_Start_IT+0x324>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
    adf6:	6822      	ldr	r2, [r4, #0]
    adf8:	6813      	ldr	r3, [r2, #0]
    adfa:	f043 0308 	orr.w	r3, r3, #8
    adfe:	6013      	str	r3, [r2, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    ae00:	6821      	ldr	r1, [r4, #0]
    ae02:	4b92      	ldr	r3, [pc, #584]	; (b04c <HAL_DMA_Start_IT+0x570>)
    ae04:	4a92      	ldr	r2, [pc, #584]	; (b050 <HAL_DMA_Start_IT+0x574>)
    ae06:	4d93      	ldr	r5, [pc, #588]	; (b054 <HAL_DMA_Start_IT+0x578>)
    ae08:	4291      	cmp	r1, r2
    ae0a:	bf18      	it	ne
    ae0c:	4299      	cmpne	r1, r3
    ae0e:	4892      	ldr	r0, [pc, #584]	; (b058 <HAL_DMA_Start_IT+0x57c>)
    ae10:	f102 0248 	add.w	r2, r2, #72	; 0x48
    ae14:	bf0c      	ite	eq
    ae16:	2301      	moveq	r3, #1
    ae18:	2300      	movne	r3, #0
    ae1a:	42a9      	cmp	r1, r5
    ae1c:	bf08      	it	eq
    ae1e:	f043 0301 	orreq.w	r3, r3, #1
    ae22:	3548      	adds	r5, #72	; 0x48
    ae24:	4281      	cmp	r1, r0
    ae26:	bf08      	it	eq
    ae28:	f043 0301 	orreq.w	r3, r3, #1
    ae2c:	3048      	adds	r0, #72	; 0x48
    ae2e:	4291      	cmp	r1, r2
    ae30:	bf08      	it	eq
    ae32:	f043 0301 	orreq.w	r3, r3, #1
    ae36:	3248      	adds	r2, #72	; 0x48
    ae38:	42a9      	cmp	r1, r5
    ae3a:	bf08      	it	eq
    ae3c:	f043 0301 	orreq.w	r3, r3, #1
    ae40:	f505 7562 	add.w	r5, r5, #904	; 0x388
    ae44:	4281      	cmp	r1, r0
    ae46:	bf08      	it	eq
    ae48:	f043 0301 	orreq.w	r3, r3, #1
    ae4c:	f500 7062 	add.w	r0, r0, #904	; 0x388
    ae50:	4291      	cmp	r1, r2
    ae52:	bf08      	it	eq
    ae54:	f043 0301 	orreq.w	r3, r3, #1
    ae58:	f502 7262 	add.w	r2, r2, #904	; 0x388
    ae5c:	42a9      	cmp	r1, r5
    ae5e:	bf08      	it	eq
    ae60:	f043 0301 	orreq.w	r3, r3, #1
    ae64:	3548      	adds	r5, #72	; 0x48
    ae66:	4281      	cmp	r1, r0
    ae68:	bf08      	it	eq
    ae6a:	f043 0301 	orreq.w	r3, r3, #1
    ae6e:	3048      	adds	r0, #72	; 0x48
    ae70:	4291      	cmp	r1, r2
    ae72:	bf08      	it	eq
    ae74:	f043 0301 	orreq.w	r3, r3, #1
    ae78:	3248      	adds	r2, #72	; 0x48
    ae7a:	42a9      	cmp	r1, r5
    ae7c:	bf08      	it	eq
    ae7e:	f043 0301 	orreq.w	r3, r3, #1
    ae82:	3548      	adds	r5, #72	; 0x48
    ae84:	4281      	cmp	r1, r0
    ae86:	bf08      	it	eq
    ae88:	f043 0301 	orreq.w	r3, r3, #1
    ae8c:	3048      	adds	r0, #72	; 0x48
    ae8e:	4291      	cmp	r1, r2
    ae90:	bf08      	it	eq
    ae92:	f043 0301 	orreq.w	r3, r3, #1
    ae96:	f102 52c0 	add.w	r2, r2, #402653184	; 0x18000000
    ae9a:	42a9      	cmp	r1, r5
    ae9c:	bf08      	it	eq
    ae9e:	f043 0301 	orreq.w	r3, r3, #1
    aea2:	f502 429f 	add.w	r2, r2, #20352	; 0x4f80
    aea6:	4d6d      	ldr	r5, [pc, #436]	; (b05c <HAL_DMA_Start_IT+0x580>)
    aea8:	4281      	cmp	r1, r0
    aeaa:	bf08      	it	eq
    aeac:	f043 0301 	orreq.w	r3, r3, #1
    aeb0:	486b      	ldr	r0, [pc, #428]	; (b060 <HAL_DMA_Start_IT+0x584>)
    aeb2:	4291      	cmp	r1, r2
    aeb4:	bf08      	it	eq
    aeb6:	f043 0301 	orreq.w	r3, r3, #1
    aeba:	323c      	adds	r2, #60	; 0x3c
    aebc:	42a9      	cmp	r1, r5
    aebe:	bf08      	it	eq
    aec0:	f043 0301 	orreq.w	r3, r3, #1
    aec4:	353c      	adds	r5, #60	; 0x3c
    aec6:	4281      	cmp	r1, r0
    aec8:	bf08      	it	eq
    aeca:	f043 0301 	orreq.w	r3, r3, #1
    aece:	303c      	adds	r0, #60	; 0x3c
    aed0:	4291      	cmp	r1, r2
    aed2:	bf08      	it	eq
    aed4:	f043 0301 	orreq.w	r3, r3, #1
    aed8:	323c      	adds	r2, #60	; 0x3c
    aeda:	42a9      	cmp	r1, r5
    aedc:	bf08      	it	eq
    aede:	f043 0301 	orreq.w	r3, r3, #1
    aee2:	4281      	cmp	r1, r0
    aee4:	bf08      	it	eq
    aee6:	f043 0301 	orreq.w	r3, r3, #1
    aeea:	4291      	cmp	r1, r2
    aeec:	bf08      	it	eq
    aeee:	f043 0301 	orreq.w	r3, r3, #1
    aef2:	b913      	cbnz	r3, aefa <HAL_DMA_Start_IT+0x41e>
    aef4:	4b5b      	ldr	r3, [pc, #364]	; (b064 <HAL_DMA_Start_IT+0x588>)
    aef6:	4299      	cmp	r1, r3
    aef8:	d10e      	bne.n	af18 <HAL_DMA_Start_IT+0x43c>
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
    aefa:	6e23      	ldr	r3, [r4, #96]	; 0x60
    aefc:	681a      	ldr	r2, [r3, #0]
    aefe:	03d2      	lsls	r2, r2, #15
    af00:	d503      	bpl.n	af0a <HAL_DMA_Start_IT+0x42e>
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
    af02:	681a      	ldr	r2, [r3, #0]
    af04:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    af08:	601a      	str	r2, [r3, #0]
      if(hdma->DMAmuxRequestGen != 0U)
    af0a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    af0c:	b11b      	cbz	r3, af16 <HAL_DMA_Start_IT+0x43a>
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
    af0e:	681a      	ldr	r2, [r3, #0]
    af10:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    af14:	601a      	str	r2, [r3, #0]
    af16:	6821      	ldr	r1, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
    af18:	4b4c      	ldr	r3, [pc, #304]	; (b04c <HAL_DMA_Start_IT+0x570>)
    af1a:	484d      	ldr	r0, [pc, #308]	; (b050 <HAL_DMA_Start_IT+0x574>)
    af1c:	4a4d      	ldr	r2, [pc, #308]	; (b054 <HAL_DMA_Start_IT+0x578>)
    af1e:	4281      	cmp	r1, r0
    af20:	bf18      	it	ne
    af22:	4299      	cmpne	r1, r3
    af24:	4d4c      	ldr	r5, [pc, #304]	; (b058 <HAL_DMA_Start_IT+0x57c>)
    af26:	4c50      	ldr	r4, [pc, #320]	; (b068 <HAL_DMA_Start_IT+0x58c>)
    af28:	f100 0060 	add.w	r0, r0, #96	; 0x60
    af2c:	bf0c      	ite	eq
    af2e:	2301      	moveq	r3, #1
    af30:	2300      	movne	r3, #0
    af32:	4291      	cmp	r1, r2
    af34:	bf08      	it	eq
    af36:	f043 0301 	orreq.w	r3, r3, #1
    af3a:	3260      	adds	r2, #96	; 0x60
    af3c:	42a9      	cmp	r1, r5
    af3e:	bf08      	it	eq
    af40:	f043 0301 	orreq.w	r3, r3, #1
    af44:	3560      	adds	r5, #96	; 0x60
    af46:	42a1      	cmp	r1, r4
    af48:	bf08      	it	eq
    af4a:	f043 0301 	orreq.w	r3, r3, #1
    af4e:	f504 7468 	add.w	r4, r4, #928	; 0x3a0
    af52:	4281      	cmp	r1, r0
    af54:	bf08      	it	eq
    af56:	f043 0301 	orreq.w	r3, r3, #1
    af5a:	f500 7068 	add.w	r0, r0, #928	; 0x3a0
    af5e:	4291      	cmp	r1, r2
    af60:	bf08      	it	eq
    af62:	f043 0301 	orreq.w	r3, r3, #1
    af66:	f502 7268 	add.w	r2, r2, #928	; 0x3a0
    af6a:	42a9      	cmp	r1, r5
    af6c:	bf08      	it	eq
    af6e:	f043 0301 	orreq.w	r3, r3, #1
    af72:	f505 7568 	add.w	r5, r5, #928	; 0x3a0
    af76:	42a1      	cmp	r1, r4
    af78:	bf08      	it	eq
    af7a:	f043 0301 	orreq.w	r3, r3, #1
    af7e:	3460      	adds	r4, #96	; 0x60
    af80:	4281      	cmp	r1, r0
    af82:	bf08      	it	eq
    af84:	f043 0301 	orreq.w	r3, r3, #1
    af88:	3060      	adds	r0, #96	; 0x60
    af8a:	4291      	cmp	r1, r2
    af8c:	bf08      	it	eq
    af8e:	f043 0301 	orreq.w	r3, r3, #1
    af92:	3260      	adds	r2, #96	; 0x60
    af94:	42a9      	cmp	r1, r5
    af96:	bf08      	it	eq
    af98:	f043 0301 	orreq.w	r3, r3, #1
    af9c:	42a1      	cmp	r1, r4
    af9e:	bf08      	it	eq
    afa0:	f043 0301 	orreq.w	r3, r3, #1
    afa4:	4281      	cmp	r1, r0
    afa6:	bf08      	it	eq
    afa8:	f043 0301 	orreq.w	r3, r3, #1
    afac:	4291      	cmp	r1, r2
    afae:	bf08      	it	eq
    afb0:	f043 0301 	orreq.w	r3, r3, #1
    afb4:	b933      	cbnz	r3, afc4 <HAL_DMA_Start_IT+0x4e8>
    afb6:	3030      	adds	r0, #48	; 0x30
    afb8:	1a08      	subs	r0, r1, r0
    afba:	fab0 f080 	clz	r0, r0
    afbe:	0940      	lsrs	r0, r0, #5
    afc0:	2800      	cmp	r0, #0
    afc2:	d03c      	beq.n	b03e <HAL_DMA_Start_IT+0x562>
    afc4:	680b      	ldr	r3, [r1, #0]
  HAL_StatusTypeDef status = HAL_OK;
    afc6:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
    afc8:	f043 0301 	orr.w	r3, r3, #1
    afcc:	600b      	str	r3, [r1, #0]
}
    afce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
    afd0:	609f      	str	r7, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
    afd2:	6823      	ldr	r3, [r4, #0]
    afd4:	60de      	str	r6, [r3, #12]
    afd6:	6821      	ldr	r1, [r4, #0]
    afd8:	e6a3      	b.n	ad22 <HAL_DMA_Start_IT+0x246>
  __HAL_LOCK(hdma);
    afda:	2002      	movs	r0, #2
}
    afdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
    afde:	4b23      	ldr	r3, [pc, #140]	; (b06c <HAL_DMA_Start_IT+0x590>)
    afe0:	f8df c078 	ldr.w	ip, [pc, #120]	; b05c <HAL_DMA_Start_IT+0x580>
    afe4:	481e      	ldr	r0, [pc, #120]	; (b060 <HAL_DMA_Start_IT+0x584>)
    afe6:	4561      	cmp	r1, ip
    afe8:	bf18      	it	ne
    afea:	4299      	cmpne	r1, r3
    afec:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    aff0:	bf0c      	ite	eq
    aff2:	2301      	moveq	r3, #1
    aff4:	2300      	movne	r3, #0
    aff6:	4281      	cmp	r1, r0
    aff8:	bf08      	it	eq
    affa:	f043 0301 	orreq.w	r3, r3, #1
    affe:	3028      	adds	r0, #40	; 0x28
    b000:	4561      	cmp	r1, ip
    b002:	bf08      	it	eq
    b004:	f043 0301 	orreq.w	r3, r3, #1
    b008:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    b00c:	4281      	cmp	r1, r0
    b00e:	bf08      	it	eq
    b010:	f043 0301 	orreq.w	r3, r3, #1
    b014:	3028      	adds	r0, #40	; 0x28
    b016:	4561      	cmp	r1, ip
    b018:	bf08      	it	eq
    b01a:	f043 0301 	orreq.w	r3, r3, #1
    b01e:	4281      	cmp	r1, r0
    b020:	bf08      	it	eq
    b022:	f043 0301 	orreq.w	r3, r3, #1
    b026:	b91b      	cbnz	r3, b030 <HAL_DMA_Start_IT+0x554>
    b028:	4b0e      	ldr	r3, [pc, #56]	; (b064 <HAL_DMA_Start_IT+0x588>)
    b02a:	4299      	cmp	r1, r3
    b02c:	f47f ae79 	bne.w	ad22 <HAL_DMA_Start_IT+0x246>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
    b030:	6de1      	ldr	r1, [r4, #92]	; 0x5c
    b032:	2301      	movs	r3, #1
    b034:	f001 011f 	and.w	r1, r1, #31
    b038:	408b      	lsls	r3, r1
    b03a:	6053      	str	r3, [r2, #4]
    b03c:	e666      	b.n	ad0c <HAL_DMA_Start_IT+0x230>
    __HAL_DMA_ENABLE(hdma);
    b03e:	680b      	ldr	r3, [r1, #0]
    b040:	f043 0301 	orr.w	r3, r3, #1
    b044:	600b      	str	r3, [r1, #0]
}
    b046:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b048:	400204b8 	.word	0x400204b8
    b04c:	40020010 	.word	0x40020010
    b050:	40020028 	.word	0x40020028
    b054:	40020040 	.word	0x40020040
    b058:	40020058 	.word	0x40020058
    b05c:	5802541c 	.word	0x5802541c
    b060:	58025430 	.word	0x58025430
    b064:	58025494 	.word	0x58025494
    b068:	40020070 	.word	0x40020070
    b06c:	58025408 	.word	0x58025408
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
    b070:	680b      	ldr	r3, [r1, #0]
    b072:	f023 030e 	bic.w	r3, r3, #14
    b076:	f043 030a 	orr.w	r3, r3, #10
    b07a:	600b      	str	r3, [r1, #0]
      if(hdma->XferHalfCpltCallback != NULL)
    b07c:	6c23      	ldr	r3, [r4, #64]	; 0x40
    b07e:	2b00      	cmp	r3, #0
    b080:	f43f aebe 	beq.w	ae00 <HAL_DMA_Start_IT+0x324>
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
    b084:	6822      	ldr	r2, [r4, #0]
    b086:	6813      	ldr	r3, [r2, #0]
    b088:	f043 0304 	orr.w	r3, r3, #4
    b08c:	6013      	str	r3, [r2, #0]
    b08e:	e6b7      	b.n	ae00 <HAL_DMA_Start_IT+0x324>

0000b090 <HAL_DMA_Abort_IT>:
  if(hdma == NULL)
    b090:	2800      	cmp	r0, #0
    b092:	d06a      	beq.n	b16a <HAL_DMA_Abort_IT+0xda>
{
    b094:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if(hdma->State != HAL_DMA_STATE_BUSY)
    b098:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
    b09c:	4603      	mov	r3, r0
    b09e:	2a02      	cmp	r2, #2
    b0a0:	d004      	beq.n	b0ac <HAL_DMA_Abort_IT+0x1c>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
    b0a2:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
    b0a4:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
    b0a6:	655a      	str	r2, [r3, #84]	; 0x54
}
    b0a8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    b0ac:	6802      	ldr	r2, [r0, #0]
    b0ae:	4986      	ldr	r1, [pc, #536]	; (b2c8 <HAL_DMA_Abort_IT+0x238>)
    b0b0:	428a      	cmp	r2, r1
    b0b2:	d050      	beq.n	b156 <HAL_DMA_Abort_IT+0xc6>
    b0b4:	4885      	ldr	r0, [pc, #532]	; (b2cc <HAL_DMA_Abort_IT+0x23c>)
    b0b6:	4282      	cmp	r2, r0
    b0b8:	d04d      	beq.n	b156 <HAL_DMA_Abort_IT+0xc6>
    b0ba:	f8df 8228 	ldr.w	r8, [pc, #552]	; b2e4 <HAL_DMA_Abort_IT+0x254>
    b0be:	f8df 9220 	ldr.w	r9, [pc, #544]	; b2e0 <HAL_DMA_Abort_IT+0x250>
    b0c2:	f8df e230 	ldr.w	lr, [pc, #560]	; b2f4 <HAL_DMA_Abort_IT+0x264>
    b0c6:	454a      	cmp	r2, r9
    b0c8:	bf18      	it	ne
    b0ca:	4542      	cmpne	r2, r8
    b0cc:	f8df c228 	ldr.w	ip, [pc, #552]	; b2f8 <HAL_DMA_Abort_IT+0x268>
    b0d0:	4f7f      	ldr	r7, [pc, #508]	; (b2d0 <HAL_DMA_Abort_IT+0x240>)
    b0d2:	bf0c      	ite	eq
    b0d4:	f04f 0a01 	moveq.w	sl, #1
    b0d8:	f04f 0a00 	movne.w	sl, #0
    b0dc:	4c7d      	ldr	r4, [pc, #500]	; (b2d4 <HAL_DMA_Abort_IT+0x244>)
    b0de:	4572      	cmp	r2, lr
    b0e0:	bf08      	it	eq
    b0e2:	f04a 0a01 	orreq.w	sl, sl, #1
    b0e6:	f8df b214 	ldr.w	fp, [pc, #532]	; b2fc <HAL_DMA_Abort_IT+0x26c>
    b0ea:	4e7b      	ldr	r6, [pc, #492]	; (b2d8 <HAL_DMA_Abort_IT+0x248>)
    b0ec:	4562      	cmp	r2, ip
    b0ee:	bf08      	it	eq
    b0f0:	f04a 0a01 	orreq.w	sl, sl, #1
    b0f4:	4d79      	ldr	r5, [pc, #484]	; (b2dc <HAL_DMA_Abort_IT+0x24c>)
    b0f6:	42ba      	cmp	r2, r7
    b0f8:	bf08      	it	eq
    b0fa:	f04a 0a01 	orreq.w	sl, sl, #1
    b0fe:	42a2      	cmp	r2, r4
    b100:	bf08      	it	eq
    b102:	f04a 0a01 	orreq.w	sl, sl, #1
    b106:	f504 7456 	add.w	r4, r4, #856	; 0x358
    b10a:	42a2      	cmp	r2, r4
    b10c:	bf08      	it	eq
    b10e:	f04a 0a01 	orreq.w	sl, sl, #1
    b112:	3418      	adds	r4, #24
    b114:	42a2      	cmp	r2, r4
    b116:	bf08      	it	eq
    b118:	f04a 0a01 	orreq.w	sl, sl, #1
    b11c:	3418      	adds	r4, #24
    b11e:	42a2      	cmp	r2, r4
    b120:	bf08      	it	eq
    b122:	f04a 0a01 	orreq.w	sl, sl, #1
    b126:	3460      	adds	r4, #96	; 0x60
    b128:	455a      	cmp	r2, fp
    b12a:	bf08      	it	eq
    b12c:	f04a 0a01 	orreq.w	sl, sl, #1
    b130:	42b2      	cmp	r2, r6
    b132:	bf08      	it	eq
    b134:	f04a 0a01 	orreq.w	sl, sl, #1
    b138:	42aa      	cmp	r2, r5
    b13a:	bf08      	it	eq
    b13c:	f04a 0a01 	orreq.w	sl, sl, #1
    b140:	42a2      	cmp	r2, r4
    b142:	bf08      	it	eq
    b144:	f04a 0a01 	orreq.w	sl, sl, #1
    b148:	f1ba 0f00 	cmp.w	sl, #0
    b14c:	d103      	bne.n	b156 <HAL_DMA_Abort_IT+0xc6>
    b14e:	f8df a1b0 	ldr.w	sl, [pc, #432]	; b300 <HAL_DMA_Abort_IT+0x270>
    b152:	4552      	cmp	r2, sl
    b154:	d10b      	bne.n	b16e <HAL_DMA_Abort_IT+0xde>
      hdma->State = HAL_DMA_STATE_ABORT;
    b156:	2104      	movs	r1, #4
  return HAL_OK;
    b158:	2000      	movs	r0, #0
      hdma->State = HAL_DMA_STATE_ABORT;
    b15a:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
    b15e:	6813      	ldr	r3, [r2, #0]
    b160:	f023 0301 	bic.w	r3, r3, #1
    b164:	6013      	str	r3, [r2, #0]
}
    b166:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return HAL_ERROR;
    b16a:	2001      	movs	r0, #1
}
    b16c:	4770      	bx	lr
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
    b16e:	6814      	ldr	r4, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b170:	4856      	ldr	r0, [pc, #344]	; (b2cc <HAL_DMA_Abort_IT+0x23c>)
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
    b172:	f024 040e 	bic.w	r4, r4, #14
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b176:	4d5a      	ldr	r5, [pc, #360]	; (b2e0 <HAL_DMA_Abort_IT+0x250>)
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
    b178:	6014      	str	r4, [r2, #0]
      __HAL_DMA_DISABLE(hdma);
    b17a:	681a      	ldr	r2, [r3, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b17c:	4c59      	ldr	r4, [pc, #356]	; (b2e4 <HAL_DMA_Abort_IT+0x254>)
      __HAL_DMA_DISABLE(hdma);
    b17e:	6811      	ldr	r1, [r2, #0]
    b180:	f021 0101 	bic.w	r1, r1, #1
    b184:	6011      	str	r1, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b186:	4a50      	ldr	r2, [pc, #320]	; (b2c8 <HAL_DMA_Abort_IT+0x238>)
    b188:	6819      	ldr	r1, [r3, #0]
    b18a:	4281      	cmp	r1, r0
    b18c:	bf18      	it	ne
    b18e:	4291      	cmpne	r1, r2
    b190:	f100 0048 	add.w	r0, r0, #72	; 0x48
    b194:	bf0c      	ite	eq
    b196:	2201      	moveq	r2, #1
    b198:	2200      	movne	r2, #0
    b19a:	42a9      	cmp	r1, r5
    b19c:	bf08      	it	eq
    b19e:	f042 0201 	orreq.w	r2, r2, #1
    b1a2:	3548      	adds	r5, #72	; 0x48
    b1a4:	42a1      	cmp	r1, r4
    b1a6:	bf08      	it	eq
    b1a8:	f042 0201 	orreq.w	r2, r2, #1
    b1ac:	3448      	adds	r4, #72	; 0x48
    b1ae:	4281      	cmp	r1, r0
    b1b0:	bf08      	it	eq
    b1b2:	f042 0201 	orreq.w	r2, r2, #1
    b1b6:	3048      	adds	r0, #72	; 0x48
    b1b8:	42a9      	cmp	r1, r5
    b1ba:	bf08      	it	eq
    b1bc:	f042 0201 	orreq.w	r2, r2, #1
    b1c0:	f505 7562 	add.w	r5, r5, #904	; 0x388
    b1c4:	42a1      	cmp	r1, r4
    b1c6:	bf08      	it	eq
    b1c8:	f042 0201 	orreq.w	r2, r2, #1
    b1cc:	f504 7462 	add.w	r4, r4, #904	; 0x388
    b1d0:	4281      	cmp	r1, r0
    b1d2:	bf08      	it	eq
    b1d4:	f042 0201 	orreq.w	r2, r2, #1
    b1d8:	f500 7062 	add.w	r0, r0, #904	; 0x388
    b1dc:	42a9      	cmp	r1, r5
    b1de:	bf08      	it	eq
    b1e0:	f042 0201 	orreq.w	r2, r2, #1
    b1e4:	3548      	adds	r5, #72	; 0x48
    b1e6:	42a1      	cmp	r1, r4
    b1e8:	bf08      	it	eq
    b1ea:	f042 0201 	orreq.w	r2, r2, #1
    b1ee:	3448      	adds	r4, #72	; 0x48
    b1f0:	4281      	cmp	r1, r0
    b1f2:	bf08      	it	eq
    b1f4:	f042 0201 	orreq.w	r2, r2, #1
    b1f8:	3048      	adds	r0, #72	; 0x48
    b1fa:	42a9      	cmp	r1, r5
    b1fc:	bf08      	it	eq
    b1fe:	f042 0201 	orreq.w	r2, r2, #1
    b202:	3548      	adds	r5, #72	; 0x48
    b204:	42a1      	cmp	r1, r4
    b206:	bf08      	it	eq
    b208:	f042 0201 	orreq.w	r2, r2, #1
    b20c:	3448      	adds	r4, #72	; 0x48
    b20e:	4281      	cmp	r1, r0
    b210:	bf08      	it	eq
    b212:	f042 0201 	orreq.w	r2, r2, #1
    b216:	f100 50c0 	add.w	r0, r0, #402653184	; 0x18000000
    b21a:	42a9      	cmp	r1, r5
    b21c:	bf08      	it	eq
    b21e:	f042 0201 	orreq.w	r2, r2, #1
    b222:	f500 409f 	add.w	r0, r0, #20352	; 0x4f80
    b226:	4d30      	ldr	r5, [pc, #192]	; (b2e8 <HAL_DMA_Abort_IT+0x258>)
    b228:	42a1      	cmp	r1, r4
    b22a:	bf08      	it	eq
    b22c:	f042 0201 	orreq.w	r2, r2, #1
    b230:	4c2e      	ldr	r4, [pc, #184]	; (b2ec <HAL_DMA_Abort_IT+0x25c>)
    b232:	4281      	cmp	r1, r0
    b234:	bf08      	it	eq
    b236:	f042 0201 	orreq.w	r2, r2, #1
    b23a:	303c      	adds	r0, #60	; 0x3c
    b23c:	42a9      	cmp	r1, r5
    b23e:	bf08      	it	eq
    b240:	f042 0201 	orreq.w	r2, r2, #1
    b244:	353c      	adds	r5, #60	; 0x3c
    b246:	42a1      	cmp	r1, r4
    b248:	bf08      	it	eq
    b24a:	f042 0201 	orreq.w	r2, r2, #1
    b24e:	343c      	adds	r4, #60	; 0x3c
    b250:	4281      	cmp	r1, r0
    b252:	bf08      	it	eq
    b254:	f042 0201 	orreq.w	r2, r2, #1
    b258:	303c      	adds	r0, #60	; 0x3c
    b25a:	42a9      	cmp	r1, r5
    b25c:	bf08      	it	eq
    b25e:	f042 0201 	orreq.w	r2, r2, #1
    b262:	42a1      	cmp	r1, r4
    b264:	bf08      	it	eq
    b266:	f042 0201 	orreq.w	r2, r2, #1
    b26a:	4281      	cmp	r1, r0
    b26c:	bf08      	it	eq
    b26e:	f042 0201 	orreq.w	r2, r2, #1
    b272:	b912      	cbnz	r2, b27a <HAL_DMA_Abort_IT+0x1ea>
    b274:	4a1e      	ldr	r2, [pc, #120]	; (b2f0 <HAL_DMA_Abort_IT+0x260>)
    b276:	4291      	cmp	r1, r2
    b278:	d117      	bne.n	b2aa <HAL_DMA_Abort_IT+0x21a>
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
    b27a:	6e18      	ldr	r0, [r3, #96]	; 0x60
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    b27c:	2201      	movs	r2, #1
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
    b27e:	6801      	ldr	r1, [r0, #0]
    b280:	f421 7180 	bic.w	r1, r1, #256	; 0x100
    b284:	6001      	str	r1, [r0, #0]
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
    b286:	e9d3 0116 	ldrd	r0, r1, [r3, #88]	; 0x58
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    b28a:	f001 011f 	and.w	r1, r1, #31
    b28e:	408a      	lsls	r2, r1
    b290:	6042      	str	r2, [r0, #4]
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    b292:	e9d3 2119 	ldrd	r2, r1, [r3, #100]	; 0x64
    b296:	6051      	str	r1, [r2, #4]
        if(hdma->DMAmuxRequestGen != 0U)
    b298:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    b29a:	b132      	cbz	r2, b2aa <HAL_DMA_Abort_IT+0x21a>
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
    b29c:	6811      	ldr	r1, [r2, #0]
    b29e:	f421 7180 	bic.w	r1, r1, #256	; 0x100
    b2a2:	6011      	str	r1, [r2, #0]
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    b2a4:	e9d3 211c 	ldrd	r2, r1, [r3, #112]	; 0x70
    b2a8:	6051      	str	r1, [r2, #4]
      __HAL_UNLOCK(hdma);
    b2aa:	2400      	movs	r4, #0
      hdma->State = HAL_DMA_STATE_READY;
    b2ac:	2101      	movs	r1, #1
      if(hdma->XferAbortCallback != NULL)
    b2ae:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      __HAL_UNLOCK(hdma);
    b2b0:	f883 4034 	strb.w	r4, [r3, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
    b2b4:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      if(hdma->XferAbortCallback != NULL)
    b2b8:	b11a      	cbz	r2, b2c2 <HAL_DMA_Abort_IT+0x232>
    b2ba:	4618      	mov	r0, r3
        hdma->XferAbortCallback(hdma);
    b2bc:	4790      	blx	r2
  return HAL_OK;
    b2be:	4620      	mov	r0, r4
    b2c0:	e6f2      	b.n	b0a8 <HAL_DMA_Abort_IT+0x18>
    b2c2:	4610      	mov	r0, r2
    b2c4:	e6f0      	b.n	b0a8 <HAL_DMA_Abort_IT+0x18>
    b2c6:	bf00      	nop
    b2c8:	40020010 	.word	0x40020010
    b2cc:	40020028 	.word	0x40020028
    b2d0:	400200a0 	.word	0x400200a0
    b2d4:	400200b8 	.word	0x400200b8
    b2d8:	40020470 	.word	0x40020470
    b2dc:	40020488 	.word	0x40020488
    b2e0:	40020040 	.word	0x40020040
    b2e4:	40020058 	.word	0x40020058
    b2e8:	5802541c 	.word	0x5802541c
    b2ec:	58025430 	.word	0x58025430
    b2f0:	58025494 	.word	0x58025494
    b2f4:	40020070 	.word	0x40020070
    b2f8:	40020088 	.word	0x40020088
    b2fc:	40020458 	.word	0x40020458
    b300:	400204b8 	.word	0x400204b8

0000b304 <HAL_DMA_GetState>:
  return hdma->State;
    b304:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
    b308:	4770      	bx	lr
    b30a:	bf00      	nop

0000b30c <HAL_DMA_GetError>:
  return hdma->ErrorCode;
    b30c:	6d40      	ldr	r0, [r0, #84]	; 0x54
}
    b30e:	4770      	bx	lr

0000b310 <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA Stream.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
    b310:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b312:	4605      	mov	r5, r0
  uint32_t syncSignalID = 0;
  uint32_t syncPolarity = 0;

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
    b314:	4baa      	ldr	r3, [pc, #680]	; (b5c0 <HAL_DMAEx_ConfigMuxSync+0x2b0>)
    b316:	48ab      	ldr	r0, [pc, #684]	; (b5c4 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
{
    b318:	460c      	mov	r4, r1
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
    b31a:	682a      	ldr	r2, [r5, #0]
    b31c:	49aa      	ldr	r1, [pc, #680]	; (b5c8 <HAL_DMAEx_ConfigMuxSync+0x2b8>)
    b31e:	429a      	cmp	r2, r3
    b320:	bf18      	it	ne
    b322:	4282      	cmpne	r2, r0
    b324:	f100 0030 	add.w	r0, r0, #48	; 0x30
    b328:	bf14      	ite	ne
    b32a:	2301      	movne	r3, #1
    b32c:	2300      	moveq	r3, #0
    b32e:	428a      	cmp	r2, r1
    b330:	bf0c      	ite	eq
    b332:	2300      	moveq	r3, #0
    b334:	f003 0301 	andne.w	r3, r3, #1
    b338:	3130      	adds	r1, #48	; 0x30
    b33a:	4282      	cmp	r2, r0
    b33c:	bf0c      	ite	eq
    b33e:	2300      	moveq	r3, #0
    b340:	f003 0301 	andne.w	r3, r3, #1
    b344:	3030      	adds	r0, #48	; 0x30
    b346:	428a      	cmp	r2, r1
    b348:	bf0c      	ite	eq
    b34a:	2300      	moveq	r3, #0
    b34c:	f003 0301 	andne.w	r3, r3, #1
    b350:	3130      	adds	r1, #48	; 0x30
    b352:	4282      	cmp	r2, r0
    b354:	bf0c      	ite	eq
    b356:	2300      	moveq	r3, #0
    b358:	f003 0301 	andne.w	r3, r3, #1
    b35c:	3030      	adds	r0, #48	; 0x30
    b35e:	428a      	cmp	r2, r1
    b360:	bf0c      	ite	eq
    b362:	2300      	moveq	r3, #0
    b364:	f003 0301 	andne.w	r3, r3, #1
    b368:	f501 715c 	add.w	r1, r1, #880	; 0x370
    b36c:	4282      	cmp	r2, r0
    b36e:	bf0c      	ite	eq
    b370:	2300      	moveq	r3, #0
    b372:	f003 0301 	andne.w	r3, r3, #1
    b376:	f500 705c 	add.w	r0, r0, #880	; 0x370
    b37a:	428a      	cmp	r2, r1
    b37c:	bf0c      	ite	eq
    b37e:	2300      	moveq	r3, #0
    b380:	f003 0301 	andne.w	r3, r3, #1
    b384:	3130      	adds	r1, #48	; 0x30
    b386:	4282      	cmp	r2, r0
    b388:	bf0c      	ite	eq
    b38a:	2300      	moveq	r3, #0
    b38c:	f003 0301 	andne.w	r3, r3, #1
    b390:	3030      	adds	r0, #48	; 0x30
    b392:	428a      	cmp	r2, r1
    b394:	bf0c      	ite	eq
    b396:	2300      	moveq	r3, #0
    b398:	f003 0301 	andne.w	r3, r3, #1
    b39c:	3130      	adds	r1, #48	; 0x30
    b39e:	4282      	cmp	r2, r0
    b3a0:	bf0c      	ite	eq
    b3a2:	2300      	moveq	r3, #0
    b3a4:	f003 0301 	andne.w	r3, r3, #1
    b3a8:	3030      	adds	r0, #48	; 0x30
    b3aa:	428a      	cmp	r2, r1
    b3ac:	bf0c      	ite	eq
    b3ae:	2300      	moveq	r3, #0
    b3b0:	f003 0301 	andne.w	r3, r3, #1
    b3b4:	3130      	adds	r1, #48	; 0x30
    b3b6:	4282      	cmp	r2, r0
    b3b8:	bf0c      	ite	eq
    b3ba:	2300      	moveq	r3, #0
    b3bc:	f003 0301 	andne.w	r3, r3, #1
    b3c0:	3030      	adds	r0, #48	; 0x30
    b3c2:	428a      	cmp	r2, r1
    b3c4:	bf0c      	ite	eq
    b3c6:	2300      	moveq	r3, #0
    b3c8:	f003 0301 	andne.w	r3, r3, #1
    b3cc:	497f      	ldr	r1, [pc, #508]	; (b5cc <HAL_DMAEx_ConfigMuxSync+0x2bc>)
    b3ce:	4282      	cmp	r2, r0
    b3d0:	bf0c      	ite	eq
    b3d2:	2300      	moveq	r3, #0
    b3d4:	f003 0301 	andne.w	r3, r3, #1
    b3d8:	487d      	ldr	r0, [pc, #500]	; (b5d0 <HAL_DMAEx_ConfigMuxSync+0x2c0>)
    b3da:	428a      	cmp	r2, r1
    b3dc:	bf0c      	ite	eq
    b3de:	2300      	moveq	r3, #0
    b3e0:	f003 0301 	andne.w	r3, r3, #1
    b3e4:	3128      	adds	r1, #40	; 0x28
    b3e6:	4282      	cmp	r2, r0
    b3e8:	bf0c      	ite	eq
    b3ea:	2300      	moveq	r3, #0
    b3ec:	f003 0301 	andne.w	r3, r3, #1
    b3f0:	3028      	adds	r0, #40	; 0x28
    b3f2:	428a      	cmp	r2, r1
    b3f4:	bf0c      	ite	eq
    b3f6:	2300      	moveq	r3, #0
    b3f8:	f003 0301 	andne.w	r3, r3, #1
    b3fc:	3128      	adds	r1, #40	; 0x28
    b3fe:	4282      	cmp	r2, r0
    b400:	bf0c      	ite	eq
    b402:	2300      	moveq	r3, #0
    b404:	f003 0301 	andne.w	r3, r3, #1
    b408:	3028      	adds	r0, #40	; 0x28
    b40a:	428a      	cmp	r2, r1
    b40c:	bf0c      	ite	eq
    b40e:	2300      	moveq	r3, #0
    b410:	f003 0301 	andne.w	r3, r3, #1
    b414:	3128      	adds	r1, #40	; 0x28
    b416:	4282      	cmp	r2, r0
    b418:	bf0c      	ite	eq
    b41a:	2300      	moveq	r3, #0
    b41c:	f003 0301 	andne.w	r3, r3, #1
    b420:	428a      	cmp	r2, r1
    b422:	bf0c      	ite	eq
    b424:	2300      	moveq	r3, #0
    b426:	f003 0301 	andne.w	r3, r3, #1
    b42a:	b11b      	cbz	r3, b434 <HAL_DMAEx_ConfigMuxSync+0x124>
    b42c:	4b69      	ldr	r3, [pc, #420]	; (b5d4 <HAL_DMAEx_ConfigMuxSync+0x2c4>)
    b42e:	429a      	cmp	r2, r3
    b430:	f040 80c0 	bne.w	b5b4 <HAL_DMAEx_ConfigMuxSync+0x2a4>
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
    b434:	7a23      	ldrb	r3, [r4, #8]
    b436:	2b01      	cmp	r3, #1
    b438:	d904      	bls.n	b444 <HAL_DMAEx_ConfigMuxSync+0x134>
    b43a:	f44f 71ca 	mov.w	r1, #404	; 0x194
    b43e:	4866      	ldr	r0, [pc, #408]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b440:	f00d ffe8 	bl	19414 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
    b444:	7a63      	ldrb	r3, [r4, #9]
    b446:	2b01      	cmp	r3, #1
    b448:	d904      	bls.n	b454 <HAL_DMAEx_ConfigMuxSync+0x144>
    b44a:	f240 1195 	movw	r1, #405	; 0x195
    b44e:	4862      	ldr	r0, [pc, #392]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b450:	f00d ffe0 	bl	19414 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
    b454:	68e3      	ldr	r3, [r4, #12]
    b456:	3b01      	subs	r3, #1
    b458:	2b1f      	cmp	r3, #31
    b45a:	f200 808d 	bhi.w	b578 <HAL_DMAEx_ConfigMuxSync+0x268>

  if(pSyncConfig->SyncEnable == ENABLE)
    b45e:	7a23      	ldrb	r3, [r4, #8]
    b460:	2b01      	cmp	r3, #1
    b462:	d02f      	beq.n	b4c4 <HAL_DMAEx_ConfigMuxSync+0x1b4>
  uint32_t syncPolarity = 0;
    b464:	2200      	movs	r2, #0
  uint32_t syncSignalID = 0;
    b466:	4611      	mov	r1, r2
    syncSignalID = pSyncConfig->SyncSignalID;
    syncPolarity = pSyncConfig->SyncPolarity;
  }

  /*Check if the DMA state is ready */
  if(hdma->State == HAL_DMA_STATE_READY)
    b468:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
    b46c:	b2db      	uxtb	r3, r3
    b46e:	2b01      	cmp	r3, #1
    b470:	d004      	beq.n	b47c <HAL_DMAEx_ConfigMuxSync+0x16c>
    return HAL_OK;
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    b472:	f44f 6300 	mov.w	r3, #2048	; 0x800

    /* Return error status */
    return HAL_ERROR;
    b476:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    b478:	656b      	str	r3, [r5, #84]	; 0x54
  }
}
    b47a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hdma);
    b47c:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
    b480:	2801      	cmp	r0, #1
    b482:	f000 8086 	beq.w	b592 <HAL_DMAEx_ConfigMuxSync+0x282>
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
    b486:	6e2f      	ldr	r7, [r5, #96]	; 0x60
    __HAL_UNLOCK(hdma);
    b488:	2600      	movs	r6, #0
    __HAL_LOCK(hdma);
    b48a:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
    b48e:	683b      	ldr	r3, [r7, #0]
    return HAL_OK;
    b490:	4630      	mov	r0, r6
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
    b492:	f423 3381 	bic.w	r3, r3, #66048	; 0x10200
    b496:	603b      	str	r3, [r7, #0]
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
    b498:	68e7      	ldr	r7, [r4, #12]
    b49a:	7a23      	ldrb	r3, [r4, #8]
    b49c:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
    b4a0:	6e2f      	ldr	r7, [r5, #96]	; 0x60
    b4a2:	041b      	lsls	r3, r3, #16
    b4a4:	f894 e009 	ldrb.w	lr, [r4, #9]
    b4a8:	683c      	ldr	r4, [r7, #0]
    b4aa:	ea43 43cc 	orr.w	r3, r3, ip, lsl #19
    b4ae:	b2e4      	uxtb	r4, r4
    b4b0:	ea43 234e 	orr.w	r3, r3, lr, lsl #9
    b4b4:	4323      	orrs	r3, r4
    b4b6:	4313      	orrs	r3, r2
    b4b8:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    b4bc:	603b      	str	r3, [r7, #0]
    __HAL_UNLOCK(hdma);
    b4be:	f885 6034 	strb.w	r6, [r5, #52]	; 0x34
}
    b4c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
    b4c4:	6863      	ldr	r3, [r4, #4]
    b4c6:	f433 23c0 	bics.w	r3, r3, #393216	; 0x60000
    b4ca:	d164      	bne.n	b596 <HAL_DMAEx_ConfigMuxSync+0x286>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    b4cc:	682a      	ldr	r2, [r5, #0]
    b4ce:	4b3c      	ldr	r3, [pc, #240]	; (b5c0 <HAL_DMAEx_ConfigMuxSync+0x2b0>)
    b4d0:	493c      	ldr	r1, [pc, #240]	; (b5c4 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
    b4d2:	483d      	ldr	r0, [pc, #244]	; (b5c8 <HAL_DMAEx_ConfigMuxSync+0x2b8>)
    b4d4:	428a      	cmp	r2, r1
    b4d6:	bf18      	it	ne
    b4d8:	429a      	cmpne	r2, r3
    b4da:	f101 0130 	add.w	r1, r1, #48	; 0x30
    b4de:	bf0c      	ite	eq
    b4e0:	2301      	moveq	r3, #1
    b4e2:	2300      	movne	r3, #0
    b4e4:	4282      	cmp	r2, r0
    b4e6:	bf08      	it	eq
    b4e8:	f043 0301 	orreq.w	r3, r3, #1
    b4ec:	3030      	adds	r0, #48	; 0x30
    b4ee:	428a      	cmp	r2, r1
    b4f0:	bf08      	it	eq
    b4f2:	f043 0301 	orreq.w	r3, r3, #1
    b4f6:	3130      	adds	r1, #48	; 0x30
    b4f8:	4282      	cmp	r2, r0
    b4fa:	bf08      	it	eq
    b4fc:	f043 0301 	orreq.w	r3, r3, #1
    b500:	3030      	adds	r0, #48	; 0x30
    b502:	428a      	cmp	r2, r1
    b504:	bf08      	it	eq
    b506:	f043 0301 	orreq.w	r3, r3, #1
    b50a:	3130      	adds	r1, #48	; 0x30
    b50c:	4282      	cmp	r2, r0
    b50e:	bf08      	it	eq
    b510:	f043 0301 	orreq.w	r3, r3, #1
    b514:	f500 705c 	add.w	r0, r0, #880	; 0x370
    b518:	428a      	cmp	r2, r1
    b51a:	bf08      	it	eq
    b51c:	f043 0301 	orreq.w	r3, r3, #1
    b520:	f501 715c 	add.w	r1, r1, #880	; 0x370
    b524:	4282      	cmp	r2, r0
    b526:	bf08      	it	eq
    b528:	f043 0301 	orreq.w	r3, r3, #1
    b52c:	3030      	adds	r0, #48	; 0x30
    b52e:	428a      	cmp	r2, r1
    b530:	bf08      	it	eq
    b532:	f043 0301 	orreq.w	r3, r3, #1
    b536:	3130      	adds	r1, #48	; 0x30
    b538:	4282      	cmp	r2, r0
    b53a:	bf08      	it	eq
    b53c:	f043 0301 	orreq.w	r3, r3, #1
    b540:	3030      	adds	r0, #48	; 0x30
    b542:	428a      	cmp	r2, r1
    b544:	bf08      	it	eq
    b546:	f043 0301 	orreq.w	r3, r3, #1
    b54a:	3130      	adds	r1, #48	; 0x30
    b54c:	4282      	cmp	r2, r0
    b54e:	bf08      	it	eq
    b550:	f043 0301 	orreq.w	r3, r3, #1
    b554:	3030      	adds	r0, #48	; 0x30
    b556:	428a      	cmp	r2, r1
    b558:	bf08      	it	eq
    b55a:	f043 0301 	orreq.w	r3, r3, #1
    b55e:	6821      	ldr	r1, [r4, #0]
    b560:	4282      	cmp	r2, r0
    b562:	bf08      	it	eq
    b564:	f043 0301 	orreq.w	r3, r3, #1
    b568:	b913      	cbnz	r3, b570 <HAL_DMAEx_ConfigMuxSync+0x260>
    b56a:	4b1c      	ldr	r3, [pc, #112]	; (b5dc <HAL_DMAEx_ConfigMuxSync+0x2cc>)
    b56c:	429a      	cmp	r2, r3
    b56e:	d118      	bne.n	b5a2 <HAL_DMAEx_ConfigMuxSync+0x292>
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    b570:	2907      	cmp	r1, #7
    b572:	d807      	bhi.n	b584 <HAL_DMAEx_ConfigMuxSync+0x274>
    syncPolarity = pSyncConfig->SyncPolarity;
    b574:	6862      	ldr	r2, [r4, #4]
    b576:	e777      	b.n	b468 <HAL_DMAEx_ConfigMuxSync+0x158>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
    b578:	f44f 71cb 	mov.w	r1, #406	; 0x196
    b57c:	4816      	ldr	r0, [pc, #88]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b57e:	f00d ff49 	bl	19414 <assert_failed>
    b582:	e76c      	b.n	b45e <HAL_DMAEx_ConfigMuxSync+0x14e>
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    b584:	f44f 71cf 	mov.w	r1, #414	; 0x19e
    b588:	4813      	ldr	r0, [pc, #76]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b58a:	f00d ff43 	bl	19414 <assert_failed>
    b58e:	6821      	ldr	r1, [r4, #0]
    b590:	e7f0      	b.n	b574 <HAL_DMAEx_ConfigMuxSync+0x264>
    __HAL_LOCK(hdma);
    b592:	2002      	movs	r0, #2
}
    b594:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
    b596:	f44f 71cd 	mov.w	r1, #410	; 0x19a
    b59a:	480f      	ldr	r0, [pc, #60]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b59c:	f00d ff3a 	bl	19414 <assert_failed>
    b5a0:	e794      	b.n	b4cc <HAL_DMAEx_ConfigMuxSync+0x1bc>
      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    b5a2:	290f      	cmp	r1, #15
    b5a4:	d9e6      	bls.n	b574 <HAL_DMAEx_ConfigMuxSync+0x264>
    b5a6:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
    b5aa:	480b      	ldr	r0, [pc, #44]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b5ac:	f00d ff32 	bl	19414 <assert_failed>
    b5b0:	6821      	ldr	r1, [r4, #0]
    b5b2:	e7df      	b.n	b574 <HAL_DMAEx_ConfigMuxSync+0x264>
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
    b5b4:	f240 1193 	movw	r1, #403	; 0x193
    b5b8:	4807      	ldr	r0, [pc, #28]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b5ba:	f00d ff2b 	bl	19414 <assert_failed>
    b5be:	e739      	b.n	b434 <HAL_DMAEx_ConfigMuxSync+0x124>
    b5c0:	40020010 	.word	0x40020010
    b5c4:	40020028 	.word	0x40020028
    b5c8:	40020040 	.word	0x40020040
    b5cc:	58025408 	.word	0x58025408
    b5d0:	5802541c 	.word	0x5802541c
    b5d4:	58025494 	.word	0x58025494
    b5d8:	0002fc54 	.word	0x0002fc54
    b5dc:	400204b8 	.word	0x400204b8

0000b5e0 <FLASH_WaitForLastOperation.constprop.3>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
    b5e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b5e2:	4605      	mov	r5, r0
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag, errorflag;
  uint32_t tickstart = HAL_GetTick();
    b5e4:	f7fc ff06 	bl	83f4 <HAL_GetTick>
    b5e8:	4606      	mov	r6, r0

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    b5ea:	1e6b      	subs	r3, r5, #1
    b5ec:	2b01      	cmp	r3, #1
    b5ee:	d80e      	bhi.n	b60e <FLASH_WaitForLastOperation.constprop.3+0x2e>

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
    b5f0:	2d01      	cmp	r5, #1
    b5f2:	d111      	bne.n	b618 <FLASH_WaitForLastOperation.constprop.3+0x38>
  else
  {
    bsyflag = FLASH_FLAG_QW_BANK2;
  }

  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b5f4:	4c2b      	ldr	r4, [pc, #172]	; (b6a4 <FLASH_WaitForLastOperation.constprop.3+0xc4>)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    b5f6:	f24c 3550 	movw	r5, #50000	; 0xc350
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b5fa:	6923      	ldr	r3, [r4, #16]
    b5fc:	075b      	lsls	r3, r3, #29
    b5fe:	d53a      	bpl.n	b676 <FLASH_WaitForLastOperation.constprop.3+0x96>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    b600:	f7fc fef8 	bl	83f4 <HAL_GetTick>
    b604:	1b80      	subs	r0, r0, r6
    b606:	42a8      	cmp	r0, r5
    b608:	d9f7      	bls.n	b5fa <FLASH_WaitForLastOperation.constprop.3+0x1a>
      {
        return HAL_TIMEOUT;
    b60a:	2003      	movs	r0, #3
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    }
  }

  return HAL_OK;
}
    b60c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    b60e:	f240 3192 	movw	r1, #914	; 0x392
    b612:	4825      	ldr	r0, [pc, #148]	; (b6a8 <FLASH_WaitForLastOperation.constprop.3+0xc8>)
    b614:	f00d fefe 	bl	19414 <assert_failed>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b618:	4c22      	ldr	r4, [pc, #136]	; (b6a4 <FLASH_WaitForLastOperation.constprop.3+0xc4>)
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    b61a:	f24c 3750 	movw	r7, #50000	; 0xc350
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b61e:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
    b622:	075a      	lsls	r2, r3, #29
    b624:	d508      	bpl.n	b638 <FLASH_WaitForLastOperation.constprop.3+0x58>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    b626:	f7fc fee5 	bl	83f4 <HAL_GetTick>
    b62a:	1b80      	subs	r0, r0, r6
    b62c:	42b8      	cmp	r0, r7
    b62e:	d8ec      	bhi.n	b60a <FLASH_WaitForLastOperation.constprop.3+0x2a>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b630:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
    b634:	075a      	lsls	r2, r3, #29
    b636:	d4f6      	bmi.n	b626 <FLASH_WaitForLastOperation.constprop.3+0x46>
  if (Bank == FLASH_BANK_1)
    b638:	2d01      	cmp	r5, #1
    b63a:	d01c      	beq.n	b676 <FLASH_WaitForLastOperation.constprop.3+0x96>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b63c:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b640:	481a      	ldr	r0, [pc, #104]	; (b6ac <FLASH_WaitForLastOperation.constprop.3+0xcc>)
    b642:	4018      	ands	r0, r3
    b644:	d00b      	beq.n	b65e <FLASH_WaitForLastOperation.constprop.3+0x7e>
    pFlash.ErrorCode |= errorflag;
    b646:	491a      	ldr	r1, [pc, #104]	; (b6b0 <FLASH_WaitForLastOperation.constprop.3+0xd0>)
    return HAL_ERROR;
    b648:	2001      	movs	r0, #1
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b64a:	4d1a      	ldr	r5, [pc, #104]	; (b6b4 <FLASH_WaitForLastOperation.constprop.3+0xd4>)
    pFlash.ErrorCode |= errorflag;
    b64c:	698a      	ldr	r2, [r1, #24]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b64e:	402b      	ands	r3, r5
    pFlash.ErrorCode |= errorflag;
    b650:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    b654:	431a      	orrs	r2, r3
    b656:	618a      	str	r2, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    b658:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
}
    b65c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
    b65e:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
    b662:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
    b666:	d004      	beq.n	b672 <FLASH_WaitForLastOperation.constprop.3+0x92>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    b668:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    b66c:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
}
    b670:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
    b672:	4618      	mov	r0, r3
}
    b674:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b676:	4a0b      	ldr	r2, [pc, #44]	; (b6a4 <FLASH_WaitForLastOperation.constprop.3+0xc4>)
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b678:	480c      	ldr	r0, [pc, #48]	; (b6ac <FLASH_WaitForLastOperation.constprop.3+0xcc>)
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b67a:	6913      	ldr	r3, [r2, #16]
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b67c:	4018      	ands	r0, r3
    b67e:	d107      	bne.n	b690 <FLASH_WaitForLastOperation.constprop.3+0xb0>
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
    b680:	6913      	ldr	r3, [r2, #16]
    b682:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
    b686:	d0f4      	beq.n	b672 <FLASH_WaitForLastOperation.constprop.3+0x92>
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
    b688:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    b68c:	6153      	str	r3, [r2, #20]
}
    b68e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pFlash.ErrorCode |= errorflag;
    b690:	4c07      	ldr	r4, [pc, #28]	; (b6b0 <FLASH_WaitForLastOperation.constprop.3+0xd0>)
    return HAL_ERROR;
    b692:	2001      	movs	r0, #1
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b694:	4907      	ldr	r1, [pc, #28]	; (b6b4 <FLASH_WaitForLastOperation.constprop.3+0xd4>)
    b696:	400b      	ands	r3, r1
    pFlash.ErrorCode |= errorflag;
    b698:	69a1      	ldr	r1, [r4, #24]
    b69a:	4319      	orrs	r1, r3
    b69c:	61a1      	str	r1, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    b69e:	6153      	str	r3, [r2, #20]
}
    b6a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b6a2:	bf00      	nop
    b6a4:	52002000 	.word	0x52002000
    b6a8:	0002fc90 	.word	0x0002fc90
    b6ac:	15ee0000 	.word	0x15ee0000
    b6b0:	020e2f28 	.word	0x020e2f28
    b6b4:	17ee0000 	.word	0x17ee0000

0000b6b8 <HAL_FLASH_Program>:
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    b6b8:	2801      	cmp	r0, #1
{
    b6ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b6be:	460c      	mov	r4, r1
    b6c0:	4616      	mov	r6, r2
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    b6c2:	d003      	beq.n	b6cc <HAL_FLASH_Program+0x14>
    b6c4:	219b      	movs	r1, #155	; 0x9b
    b6c6:	4834      	ldr	r0, [pc, #208]	; (b798 <HAL_FLASH_Program+0xe0>)
    b6c8:	f00d fea4 	bl	19414 <assert_failed>
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
    b6cc:	f104 4778 	add.w	r7, r4, #4160749568	; 0xf8000000
    b6d0:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
    b6d4:	d24f      	bcs.n	b776 <HAL_FLASH_Program+0xbe>
  __HAL_LOCK(&pFlash);
    b6d6:	4d31      	ldr	r5, [pc, #196]	; (b79c <HAL_FLASH_Program+0xe4>)
    b6d8:	7d2b      	ldrb	r3, [r5, #20]
    b6da:	2b01      	cmp	r3, #1
    b6dc:	d053      	beq.n	b786 <HAL_FLASH_Program+0xce>
    b6de:	f04f 0801 	mov.w	r8, #1
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
    b6e2:	f5b7 1f80 	cmp.w	r7, #1048576	; 0x100000
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    b6e6:	f04f 0300 	mov.w	r3, #0
  __HAL_LOCK(&pFlash);
    b6ea:	f885 8014 	strb.w	r8, [r5, #20]
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
    b6ee:	d336      	bcc.n	b75e <HAL_FLASH_Program+0xa6>
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    b6f0:	2002      	movs	r0, #2
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    b6f2:	61ab      	str	r3, [r5, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    b6f4:	f7ff ff74 	bl	b5e0 <FLASH_WaitForLastOperation.constprop.3>
  if(status == HAL_OK)
    b6f8:	bb68      	cbnz	r0, b756 <HAL_FLASH_Program+0x9e>
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
    b6fa:	4a29      	ldr	r2, [pc, #164]	; (b7a0 <HAL_FLASH_Program+0xe8>)
    bank = FLASH_BANK_2;
    b6fc:	f04f 0802 	mov.w	r8, #2
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
    b700:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
    b704:	ea43 0308 	orr.w	r3, r3, r8
    b708:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
    b70c:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    b710:	f3bf 8f4f 	dsb	sy
        *dest_addr = *src_addr;
    b714:	6833      	ldr	r3, [r6, #0]
    b716:	6023      	str	r3, [r4, #0]
    b718:	6873      	ldr	r3, [r6, #4]
    b71a:	6063      	str	r3, [r4, #4]
    b71c:	68b3      	ldr	r3, [r6, #8]
    b71e:	60a3      	str	r3, [r4, #8]
    b720:	68f3      	ldr	r3, [r6, #12]
    b722:	60e3      	str	r3, [r4, #12]
    b724:	6933      	ldr	r3, [r6, #16]
    b726:	6123      	str	r3, [r4, #16]
    b728:	6973      	ldr	r3, [r6, #20]
    b72a:	6163      	str	r3, [r4, #20]
    b72c:	69b3      	ldr	r3, [r6, #24]
    b72e:	61a3      	str	r3, [r4, #24]
    b730:	69f3      	ldr	r3, [r6, #28]
    b732:	61e3      	str	r3, [r4, #28]
  __ASM volatile ("isb 0xF":::"memory");
    b734:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    b738:	f3bf 8f4f 	dsb	sy
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    b73c:	4640      	mov	r0, r8
    b73e:	f7ff ff4f 	bl	b5e0 <FLASH_WaitForLastOperation.constprop.3>
      if(bank == FLASH_BANK_1)
    b742:	f1b8 0f01 	cmp.w	r8, #1
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
    b746:	4a16      	ldr	r2, [pc, #88]	; (b7a0 <HAL_FLASH_Program+0xe8>)
      if(bank == FLASH_BANK_1)
    b748:	d020      	beq.n	b78c <HAL_FLASH_Program+0xd4>
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
    b74a:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
    b74e:	f023 0302 	bic.w	r3, r3, #2
    b752:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
  __HAL_UNLOCK(&pFlash);
    b756:	2300      	movs	r3, #0
    b758:	752b      	strb	r3, [r5, #20]
}
    b75a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    b75e:	4640      	mov	r0, r8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    b760:	61ab      	str	r3, [r5, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    b762:	f7ff ff3d 	bl	b5e0 <FLASH_WaitForLastOperation.constprop.3>
  if(status == HAL_OK)
    b766:	2800      	cmp	r0, #0
    b768:	d1f5      	bne.n	b756 <HAL_FLASH_Program+0x9e>
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
    b76a:	4a0d      	ldr	r2, [pc, #52]	; (b7a0 <HAL_FLASH_Program+0xe8>)
    b76c:	68d3      	ldr	r3, [r2, #12]
    b76e:	f043 0302 	orr.w	r3, r3, #2
    b772:	60d3      	str	r3, [r2, #12]
    b774:	e7ca      	b.n	b70c <HAL_FLASH_Program+0x54>
  __HAL_LOCK(&pFlash);
    b776:	4d09      	ldr	r5, [pc, #36]	; (b79c <HAL_FLASH_Program+0xe4>)
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
    b778:	219c      	movs	r1, #156	; 0x9c
    b77a:	4807      	ldr	r0, [pc, #28]	; (b798 <HAL_FLASH_Program+0xe0>)
    b77c:	f00d fe4a 	bl	19414 <assert_failed>
  __HAL_LOCK(&pFlash);
    b780:	7d2b      	ldrb	r3, [r5, #20]
    b782:	2b01      	cmp	r3, #1
    b784:	d1ab      	bne.n	b6de <HAL_FLASH_Program+0x26>
    b786:	2002      	movs	r0, #2
}
    b788:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
    b78c:	68d3      	ldr	r3, [r2, #12]
    b78e:	f023 0302 	bic.w	r3, r3, #2
    b792:	60d3      	str	r3, [r2, #12]
    b794:	e7df      	b.n	b756 <HAL_FLASH_Program+0x9e>
    b796:	bf00      	nop
    b798:	0002fc90 	.word	0x0002fc90
    b79c:	020e2f28 	.word	0x020e2f28
    b7a0:	52002000 	.word	0x52002000

0000b7a4 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
    b7a4:	4b0f      	ldr	r3, [pc, #60]	; (b7e4 <HAL_FLASH_Unlock+0x40>)
    b7a6:	68da      	ldr	r2, [r3, #12]
    b7a8:	07d2      	lsls	r2, r2, #31
    b7aa:	d506      	bpl.n	b7ba <HAL_FLASH_Unlock+0x16>
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
    b7ac:	490e      	ldr	r1, [pc, #56]	; (b7e8 <HAL_FLASH_Unlock+0x44>)
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
    b7ae:	4a0f      	ldr	r2, [pc, #60]	; (b7ec <HAL_FLASH_Unlock+0x48>)
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
    b7b0:	6059      	str	r1, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
    b7b2:	605a      	str	r2, [r3, #4]
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
    b7b4:	68db      	ldr	r3, [r3, #12]
    b7b6:	07db      	lsls	r3, r3, #31
    b7b8:	d411      	bmi.n	b7de <HAL_FLASH_Unlock+0x3a>
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
    b7ba:	4b0a      	ldr	r3, [pc, #40]	; (b7e4 <HAL_FLASH_Unlock+0x40>)
    b7bc:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    b7c0:	f010 0001 	ands.w	r0, r0, #1
    b7c4:	d00a      	beq.n	b7dc <HAL_FLASH_Unlock+0x38>
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
    b7c6:	4908      	ldr	r1, [pc, #32]	; (b7e8 <HAL_FLASH_Unlock+0x44>)
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
    b7c8:	4a08      	ldr	r2, [pc, #32]	; (b7ec <HAL_FLASH_Unlock+0x48>)
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
    b7ca:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
    b7ce:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
    b7d2:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
      return HAL_ERROR;
    b7d6:	f000 0001 	and.w	r0, r0, #1
    b7da:	4770      	bx	lr
    b7dc:	4770      	bx	lr
    b7de:	2001      	movs	r0, #1
}
    b7e0:	4770      	bx	lr
    b7e2:	bf00      	nop
    b7e4:	52002000 	.word	0x52002000
    b7e8:	45670123 	.word	0x45670123
    b7ec:	cdef89ab 	.word	0xcdef89ab

0000b7f0 <FLASH_WaitForLastOperation>:
{
    b7f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b7f4:	460d      	mov	r5, r1
    b7f6:	4606      	mov	r6, r0
  uint32_t tickstart = HAL_GetTick();
    b7f8:	f7fc fdfc 	bl	83f4 <HAL_GetTick>
    b7fc:	4680      	mov	r8, r0
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    b7fe:	1e6b      	subs	r3, r5, #1
    b800:	2b01      	cmp	r3, #1
    b802:	d857      	bhi.n	b8b4 <FLASH_WaitForLastOperation+0xc4>
    bsyflag = FLASH_FLAG_QW_BANK2;
    b804:	2d01      	cmp	r5, #1
    b806:	4c36      	ldr	r4, [pc, #216]	; (b8e0 <FLASH_WaitForLastOperation+0xf0>)
    b808:	bf08      	it	eq
    b80a:	2404      	moveq	r4, #4
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b80c:	4f35      	ldr	r7, [pc, #212]	; (b8e4 <FLASH_WaitForLastOperation+0xf4>)
    b80e:	2c04      	cmp	r4, #4
    b810:	d02d      	beq.n	b86e <FLASH_WaitForLastOperation+0x7e>
    b812:	1c70      	adds	r0, r6, #1
    b814:	d11b      	bne.n	b84e <FLASH_WaitForLastOperation+0x5e>
    b816:	4a33      	ldr	r2, [pc, #204]	; (b8e4 <FLASH_WaitForLastOperation+0xf4>)
    b818:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
    b81c:	ea24 0303 	bic.w	r3, r4, r3
    b820:	0759      	lsls	r1, r3, #29
    b822:	d5f9      	bpl.n	b818 <FLASH_WaitForLastOperation+0x28>
  if (Bank == FLASH_BANK_1)
    b824:	2d01      	cmp	r5, #1
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b826:	4a2f      	ldr	r2, [pc, #188]	; (b8e4 <FLASH_WaitForLastOperation+0xf4>)
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b828:	482f      	ldr	r0, [pc, #188]	; (b8e8 <FLASH_WaitForLastOperation+0xf8>)
  if (Bank == FLASH_BANK_1)
    b82a:	d02a      	beq.n	b882 <FLASH_WaitForLastOperation+0x92>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b82c:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b830:	4018      	ands	r0, r3
    b832:	d031      	beq.n	b898 <FLASH_WaitForLastOperation+0xa8>
    pFlash.ErrorCode |= errorflag;
    b834:	4c2d      	ldr	r4, [pc, #180]	; (b8ec <FLASH_WaitForLastOperation+0xfc>)
    return HAL_ERROR;
    b836:	2001      	movs	r0, #1
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b838:	4d2d      	ldr	r5, [pc, #180]	; (b8f0 <FLASH_WaitForLastOperation+0x100>)
    pFlash.ErrorCode |= errorflag;
    b83a:	69a1      	ldr	r1, [r4, #24]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b83c:	402b      	ands	r3, r5
    pFlash.ErrorCode |= errorflag;
    b83e:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
    b842:	4319      	orrs	r1, r3
    b844:	61a1      	str	r1, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    b846:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
}
    b84a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b84e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
    b852:	ea24 0303 	bic.w	r3, r4, r3
    b856:	075b      	lsls	r3, r3, #29
    b858:	d4e4      	bmi.n	b824 <FLASH_WaitForLastOperation+0x34>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    b85a:	f7fc fdcb 	bl	83f4 <HAL_GetTick>
    b85e:	eba0 0008 	sub.w	r0, r0, r8
    b862:	42b0      	cmp	r0, r6
    b864:	d801      	bhi.n	b86a <FLASH_WaitForLastOperation+0x7a>
    b866:	2e00      	cmp	r6, #0
    b868:	d1d1      	bne.n	b80e <FLASH_WaitForLastOperation+0x1e>
        return HAL_TIMEOUT;
    b86a:	2003      	movs	r0, #3
    b86c:	e7ed      	b.n	b84a <FLASH_WaitForLastOperation+0x5a>
    b86e:	1c70      	adds	r0, r6, #1
    b870:	d127      	bne.n	b8c2 <FLASH_WaitForLastOperation+0xd2>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b872:	4a1c      	ldr	r2, [pc, #112]	; (b8e4 <FLASH_WaitForLastOperation+0xf4>)
    b874:	6913      	ldr	r3, [r2, #16]
    b876:	0759      	lsls	r1, r3, #29
    b878:	d4fc      	bmi.n	b874 <FLASH_WaitForLastOperation+0x84>
  if (Bank == FLASH_BANK_1)
    b87a:	2d01      	cmp	r5, #1
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b87c:	4a19      	ldr	r2, [pc, #100]	; (b8e4 <FLASH_WaitForLastOperation+0xf4>)
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b87e:	481a      	ldr	r0, [pc, #104]	; (b8e8 <FLASH_WaitForLastOperation+0xf8>)
  if (Bank == FLASH_BANK_1)
    b880:	d1d4      	bne.n	b82c <FLASH_WaitForLastOperation+0x3c>
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b882:	6913      	ldr	r3, [r2, #16]
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b884:	4018      	ands	r0, r3
    b886:	d120      	bne.n	b8ca <FLASH_WaitForLastOperation+0xda>
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
    b888:	6915      	ldr	r5, [r2, #16]
    b88a:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
    b88e:	d00e      	beq.n	b8ae <FLASH_WaitForLastOperation+0xbe>
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
    b890:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    b894:	6153      	str	r3, [r2, #20]
    b896:	e7d8      	b.n	b84a <FLASH_WaitForLastOperation+0x5a>
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
    b898:	f8d2 5110 	ldr.w	r5, [r2, #272]	; 0x110
    b89c:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
    b8a0:	d005      	beq.n	b8ae <FLASH_WaitForLastOperation+0xbe>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    b8a2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    b8a6:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
}
    b8aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return HAL_OK;
    b8ae:	4628      	mov	r0, r5
}
    b8b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    b8b4:	f240 3192 	movw	r1, #914	; 0x392
    b8b8:	480e      	ldr	r0, [pc, #56]	; (b8f4 <FLASH_WaitForLastOperation+0x104>)
    b8ba:	f00d fdab 	bl	19414 <assert_failed>
    bsyflag = FLASH_FLAG_QW_BANK2;
    b8be:	4c08      	ldr	r4, [pc, #32]	; (b8e0 <FLASH_WaitForLastOperation+0xf0>)
    b8c0:	e7a4      	b.n	b80c <FLASH_WaitForLastOperation+0x1c>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b8c2:	693b      	ldr	r3, [r7, #16]
    b8c4:	075b      	lsls	r3, r3, #29
    b8c6:	d4c8      	bmi.n	b85a <FLASH_WaitForLastOperation+0x6a>
    b8c8:	e7ac      	b.n	b824 <FLASH_WaitForLastOperation+0x34>
    pFlash.ErrorCode |= errorflag;
    b8ca:	4c08      	ldr	r4, [pc, #32]	; (b8ec <FLASH_WaitForLastOperation+0xfc>)
    return HAL_ERROR;
    b8cc:	4628      	mov	r0, r5
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b8ce:	4908      	ldr	r1, [pc, #32]	; (b8f0 <FLASH_WaitForLastOperation+0x100>)
    b8d0:	400b      	ands	r3, r1
    pFlash.ErrorCode |= errorflag;
    b8d2:	69a1      	ldr	r1, [r4, #24]
    b8d4:	4319      	orrs	r1, r3
    b8d6:	61a1      	str	r1, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    b8d8:	6153      	str	r3, [r2, #20]
}
    b8da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b8de:	bf00      	nop
    b8e0:	80000004 	.word	0x80000004
    b8e4:	52002000 	.word	0x52002000
    b8e8:	15ee0000 	.word	0x15ee0000
    b8ec:	020e2f28 	.word	0x020e2f28
    b8f0:	17ee0000 	.word	0x17ee0000
    b8f4:	0002fc90 	.word	0x0002fc90

0000b8f8 <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)
{
    b8f8:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
#if defined (FLASH_CR_PSIZE)
  assert_param(IS_VOLTAGERANGE(VoltageRange));
    b8fa:	f030 0330 	bics.w	r3, r0, #48	; 0x30
{
    b8fe:	4605      	mov	r5, r0
    b900:	460c      	mov	r4, r1
  assert_param(IS_VOLTAGERANGE(VoltageRange));
    b902:	d004      	beq.n	b90e <FLASH_MassErase+0x16>
    b904:	f44f 7144 	mov.w	r1, #784	; 0x310
    b908:	4826      	ldr	r0, [pc, #152]	; (b9a4 <FLASH_MassErase+0xac>)
    b90a:	f00d fd83 	bl	19414 <assert_failed>
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));
    b90e:	1e63      	subs	r3, r4, #1
    b910:	2b02      	cmp	r3, #2
    b912:	d826      	bhi.n	b962 <FLASH_MassErase+0x6a>

  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
    b914:	f004 0303 	and.w	r3, r4, #3
    b918:	2b03      	cmp	r3, #3
    b91a:	d02b      	beq.n	b974 <FLASH_MassErase+0x7c>
    FLASH->OPTCR |= FLASH_OPTCR_MER;
  }
  else
  {
    /* Proceed to erase Flash Bank  */
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
    b91c:	07e2      	lsls	r2, r4, #31
    b91e:	d50b      	bpl.n	b938 <FLASH_MassErase+0x40>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank1 */
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
    b920:	4b21      	ldr	r3, [pc, #132]	; (b9a8 <FLASH_MassErase+0xb0>)
    b922:	68da      	ldr	r2, [r3, #12]
    b924:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    b928:	60da      	str	r2, [r3, #12]
      FLASH->CR1 |=  VoltageRange;
    b92a:	68da      	ldr	r2, [r3, #12]
    b92c:	432a      	orrs	r2, r5
    b92e:	60da      	str	r2, [r3, #12]
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank1 */
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
    b930:	68da      	ldr	r2, [r3, #12]
    b932:	f042 0288 	orr.w	r2, r2, #136	; 0x88
    b936:	60da      	str	r2, [r3, #12]
    }
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
    b938:	07a3      	lsls	r3, r4, #30
    b93a:	d511      	bpl.n	b960 <FLASH_MassErase+0x68>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank2 */
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
    b93c:	4b1a      	ldr	r3, [pc, #104]	; (b9a8 <FLASH_MassErase+0xb0>)
    b93e:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    b942:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    b946:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
      FLASH->CR2 |= VoltageRange;
    b94a:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    b94e:	4315      	orrs	r5, r2
    b950:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
    b954:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    b958:	f042 0288 	orr.w	r2, r2, #136	; 0x88
    b95c:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    }
  }
}
    b960:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_FLASH_BANK(Banks));
    b962:	f44f 7145 	mov.w	r1, #788	; 0x314
    b966:	480f      	ldr	r0, [pc, #60]	; (b9a4 <FLASH_MassErase+0xac>)
    b968:	f00d fd54 	bl	19414 <assert_failed>
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
    b96c:	f004 0303 	and.w	r3, r4, #3
    b970:	2b03      	cmp	r3, #3
    b972:	d1d3      	bne.n	b91c <FLASH_MassErase+0x24>
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
    b974:	4b0c      	ldr	r3, [pc, #48]	; (b9a8 <FLASH_MassErase+0xb0>)
    b976:	68da      	ldr	r2, [r3, #12]
    b978:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    b97c:	60da      	str	r2, [r3, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
    b97e:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    b982:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    b986:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    FLASH->CR1 |= VoltageRange;
    b98a:	68da      	ldr	r2, [r3, #12]
    b98c:	432a      	orrs	r2, r5
    b98e:	60da      	str	r2, [r3, #12]
    FLASH->CR2 |= VoltageRange;
    b990:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    b994:	4315      	orrs	r5, r2
    b996:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
    FLASH->OPTCR |= FLASH_OPTCR_MER;
    b99a:	699a      	ldr	r2, [r3, #24]
    b99c:	f042 0210 	orr.w	r2, r2, #16
    b9a0:	619a      	str	r2, [r3, #24]
}
    b9a2:	bd38      	pop	{r3, r4, r5, pc}
    b9a4:	0002fccc 	.word	0x0002fccc
    b9a8:	52002000 	.word	0x52002000

0000b9ac <HAL_FLASHEx_Erase>:
{
    b9ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    b9b0:	6803      	ldr	r3, [r0, #0]
{
    b9b2:	b083      	sub	sp, #12
    b9b4:	4604      	mov	r4, r0
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    b9b6:	2b01      	cmp	r3, #1
{
    b9b8:	9101      	str	r1, [sp, #4]
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    b9ba:	d903      	bls.n	b9c4 <HAL_FLASHEx_Erase+0x18>
    b9bc:	21ac      	movs	r1, #172	; 0xac
    b9be:	487d      	ldr	r0, [pc, #500]	; (bbb4 <HAL_FLASHEx_Erase+0x208>)
    b9c0:	f00d fd28 	bl	19414 <assert_failed>
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
    b9c4:	6863      	ldr	r3, [r4, #4]
    b9c6:	3b01      	subs	r3, #1
    b9c8:	2b02      	cmp	r3, #2
    b9ca:	f200 80a1 	bhi.w	bb10 <HAL_FLASHEx_Erase+0x164>
  __HAL_LOCK(&pFlash);
    b9ce:	f8df 81ec 	ldr.w	r8, [pc, #492]	; bbbc <HAL_FLASHEx_Erase+0x210>
    b9d2:	f898 3014 	ldrb.w	r3, [r8, #20]
    b9d6:	2b01      	cmp	r3, #1
    b9d8:	f000 80a5 	beq.w	bb26 <HAL_FLASHEx_Erase+0x17a>
    b9dc:	2501      	movs	r5, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    b9de:	2300      	movs	r3, #0
  __HAL_LOCK(&pFlash);
    b9e0:	f888 5014 	strb.w	r5, [r8, #20]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    b9e4:	f8c8 3018 	str.w	r3, [r8, #24]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
    b9e8:	6862      	ldr	r2, [r4, #4]
    b9ea:	07d0      	lsls	r0, r2, #31
    b9ec:	f100 80a0 	bmi.w	bb30 <HAL_FLASHEx_Erase+0x184>
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    b9f0:	0793      	lsls	r3, r2, #30
    b9f2:	d50d      	bpl.n	ba10 <HAL_FLASHEx_Erase+0x64>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    b9f4:	2102      	movs	r1, #2
    b9f6:	f24c 3050 	movw	r0, #50000	; 0xc350
    b9fa:	f7ff fef9 	bl	b7f0 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
    b9fe:	b138      	cbz	r0, ba10 <HAL_FLASHEx_Erase+0x64>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    ba00:	2301      	movs	r3, #1
  __HAL_UNLOCK(&pFlash);
    ba02:	2200      	movs	r2, #0
}
    ba04:	4618      	mov	r0, r3
  __HAL_UNLOCK(&pFlash);
    ba06:	f888 2014 	strb.w	r2, [r8, #20]
}
    ba0a:	b003      	add	sp, #12
    ba0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
    ba10:	6825      	ldr	r5, [r4, #0]
    ba12:	2d01      	cmp	r5, #1
    ba14:	f000 80a2 	beq.w	bb5c <HAL_FLASHEx_Erase+0x1b0>
      *SectorError = 0xFFFFFFFFU;
    ba18:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    ba1c:	9a01      	ldr	r2, [sp, #4]
    ba1e:	6013      	str	r3, [r2, #0]
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
    ba20:	e9d4 6302 	ldrd	r6, r3, [r4, #8]
    ba24:	4433      	add	r3, r6
    ba26:	42b3      	cmp	r3, r6
    ba28:	f240 8096 	bls.w	bb58 <HAL_FLASHEx_Erase+0x1ac>
    ba2c:	0237      	lsls	r7, r6, #8
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)
{
  assert_param(IS_FLASH_SECTOR(Sector));
    ba2e:	f8df 9184 	ldr.w	r9, [pc, #388]	; bbb4 <HAL_FLASHEx_Erase+0x208>

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
    ba32:	4d61      	ldr	r5, [pc, #388]	; (bbb8 <HAL_FLASHEx_Erase+0x20c>)
    ba34:	e03d      	b.n	bab2 <HAL_FLASHEx_Erase+0x106>
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));
    ba36:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    ba3a:	2901      	cmp	r1, #1
    ba3c:	d904      	bls.n	ba48 <HAL_FLASHEx_Erase+0x9c>
    ba3e:	f240 3157 	movw	r1, #855	; 0x357
    ba42:	4648      	mov	r0, r9
    ba44:	f00d fce6 	bl	19414 <assert_failed>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
    ba48:	f03b 0330 	bics.w	r3, fp, #48	; 0x30
    ba4c:	d004      	beq.n	ba58 <HAL_FLASHEx_Erase+0xac>
    ba4e:	f240 3159 	movw	r1, #857	; 0x359
    ba52:	4648      	mov	r0, r9
    ba54:	f00d fcde 	bl	19414 <assert_failed>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
    ba58:	f01a 0f01 	tst.w	sl, #1
    ba5c:	d00a      	beq.n	ba74 <HAL_FLASHEx_Erase+0xc8>
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
    ba5e:	68e9      	ldr	r1, [r5, #12]
    ba60:	f421 61e6 	bic.w	r1, r1, #1840	; 0x730
    ba64:	60e9      	str	r1, [r5, #12]

    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
    ba66:	68e9      	ldr	r1, [r5, #12]
    ba68:	f041 0184 	orr.w	r1, r1, #132	; 0x84
    ba6c:	ea41 010b 	orr.w	r1, r1, fp
    ba70:	4339      	orrs	r1, r7
    ba72:	60e9      	str	r1, [r5, #12]

    FLASH->CR1 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
    ba74:	f01a 0f02 	tst.w	sl, #2
    ba78:	d00e      	beq.n	ba98 <HAL_FLASHEx_Erase+0xec>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank2 */
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
    ba7a:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    ba7e:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
    ba82:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c

    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
    ba86:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    ba8a:	f043 0384 	orr.w	r3, r3, #132	; 0x84
    ba8e:	ea43 030b 	orr.w	r3, r3, fp
    ba92:	433b      	orrs	r3, r7
    ba94:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
    ba98:	6863      	ldr	r3, [r4, #4]
    ba9a:	07da      	lsls	r2, r3, #31
    ba9c:	d415      	bmi.n	baca <HAL_FLASHEx_Erase+0x11e>
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    ba9e:	0798      	lsls	r0, r3, #30
    baa0:	d427      	bmi.n	baf2 <HAL_FLASHEx_Erase+0x146>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
    baa2:	68e3      	ldr	r3, [r4, #12]
    baa4:	3601      	adds	r6, #1
    baa6:	68a2      	ldr	r2, [r4, #8]
    baa8:	f507 7780 	add.w	r7, r7, #256	; 0x100
    baac:	4413      	add	r3, r2
    baae:	42b3      	cmp	r3, r6
    bab0:	d952      	bls.n	bb58 <HAL_FLASHEx_Erase+0x1ac>
  assert_param(IS_FLASH_SECTOR(Sector));
    bab2:	2e07      	cmp	r6, #7
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
    bab4:	f8d4 a004 	ldr.w	sl, [r4, #4]
    bab8:	f8d4 b010 	ldr.w	fp, [r4, #16]
  assert_param(IS_FLASH_SECTOR(Sector));
    babc:	d9bb      	bls.n	ba36 <HAL_FLASHEx_Erase+0x8a>
    babe:	f240 3156 	movw	r1, #854	; 0x356
    bac2:	4648      	mov	r0, r9
    bac4:	f00d fca6 	bl	19414 <assert_failed>
    bac8:	e7b5      	b.n	ba36 <HAL_FLASHEx_Erase+0x8a>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
    baca:	2101      	movs	r1, #1
    bacc:	f24c 3050 	movw	r0, #50000	; 0xc350
    bad0:	f7ff fe8e 	bl	b7f0 <FLASH_WaitForLastOperation>
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    bad4:	68ea      	ldr	r2, [r5, #12]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
    bad6:	4603      	mov	r3, r0
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    bad8:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    badc:	f022 0204 	bic.w	r2, r2, #4
    bae0:	60ea      	str	r2, [r5, #12]
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    bae2:	6862      	ldr	r2, [r4, #4]
    bae4:	0791      	lsls	r1, r2, #30
    bae6:	d404      	bmi.n	baf2 <HAL_FLASHEx_Erase+0x146>
        if(status != HAL_OK)
    bae8:	2b00      	cmp	r3, #0
    baea:	d0da      	beq.n	baa2 <HAL_FLASHEx_Erase+0xf6>
          *SectorError = sector_index;
    baec:	9a01      	ldr	r2, [sp, #4]
    baee:	6016      	str	r6, [r2, #0]
          break;
    baf0:	e787      	b.n	ba02 <HAL_FLASHEx_Erase+0x56>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
    baf2:	2102      	movs	r1, #2
    baf4:	f24c 3050 	movw	r0, #50000	; 0xc350
    baf8:	f7ff fe7a 	bl	b7f0 <FLASH_WaitForLastOperation>
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    bafc:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
    bb00:	4603      	mov	r3, r0
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    bb02:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    bb06:	f022 0204 	bic.w	r2, r2, #4
    bb0a:	f8c5 210c 	str.w	r2, [r5, #268]	; 0x10c
    bb0e:	e7eb      	b.n	bae8 <HAL_FLASHEx_Erase+0x13c>
  __HAL_LOCK(&pFlash);
    bb10:	f8df 80a8 	ldr.w	r8, [pc, #168]	; bbbc <HAL_FLASHEx_Erase+0x210>
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
    bb14:	21ad      	movs	r1, #173	; 0xad
    bb16:	4827      	ldr	r0, [pc, #156]	; (bbb4 <HAL_FLASHEx_Erase+0x208>)
    bb18:	f00d fc7c 	bl	19414 <assert_failed>
  __HAL_LOCK(&pFlash);
    bb1c:	f898 3014 	ldrb.w	r3, [r8, #20]
    bb20:	2b01      	cmp	r3, #1
    bb22:	f47f af5b 	bne.w	b9dc <HAL_FLASHEx_Erase+0x30>
    bb26:	2302      	movs	r3, #2
}
    bb28:	4618      	mov	r0, r3
    bb2a:	b003      	add	sp, #12
    bb2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
    bb30:	4629      	mov	r1, r5
    bb32:	f24c 3050 	movw	r0, #50000	; 0xc350
    bb36:	f7ff fe5b 	bl	b7f0 <FLASH_WaitForLastOperation>
    bb3a:	b158      	cbz	r0, bb54 <HAL_FLASHEx_Erase+0x1a8>
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    bb3c:	6863      	ldr	r3, [r4, #4]
    bb3e:	079a      	lsls	r2, r3, #30
    bb40:	f57f af5e 	bpl.w	ba00 <HAL_FLASHEx_Erase+0x54>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    bb44:	2102      	movs	r1, #2
    bb46:	f24c 3050 	movw	r0, #50000	; 0xc350
    bb4a:	9501      	str	r5, [sp, #4]
    bb4c:	f7ff fe50 	bl	b7f0 <FLASH_WaitForLastOperation>
    bb50:	9b01      	ldr	r3, [sp, #4]
    bb52:	e756      	b.n	ba02 <HAL_FLASHEx_Erase+0x56>
    bb54:	6862      	ldr	r2, [r4, #4]
    bb56:	e74b      	b.n	b9f0 <HAL_FLASHEx_Erase+0x44>
    bb58:	2300      	movs	r3, #0
    bb5a:	e752      	b.n	ba02 <HAL_FLASHEx_Erase+0x56>
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
    bb5c:	6861      	ldr	r1, [r4, #4]
    bb5e:	6920      	ldr	r0, [r4, #16]
    bb60:	f7ff feca 	bl	b8f8 <FLASH_MassErase>
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
    bb64:	6862      	ldr	r2, [r4, #4]
    bb66:	f012 0301 	ands.w	r3, r2, #1
    bb6a:	d114      	bne.n	bb96 <HAL_FLASHEx_Erase+0x1ea>
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    bb6c:	0791      	lsls	r1, r2, #30
    bb6e:	f57f af48 	bpl.w	ba02 <HAL_FLASHEx_Erase+0x56>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    bb72:	2102      	movs	r1, #2
    bb74:	f24c 3050 	movw	r0, #50000	; 0xc350
    bb78:	9301      	str	r3, [sp, #4]
    bb7a:	f7ff fe39 	bl	b7f0 <FLASH_WaitForLastOperation>
        FLASH->CR2 &= (~FLASH_CR_BER);
    bb7e:	490e      	ldr	r1, [pc, #56]	; (bbb8 <HAL_FLASHEx_Erase+0x20c>)
          status = HAL_ERROR;
    bb80:	2800      	cmp	r0, #0
    bb82:	9b01      	ldr	r3, [sp, #4]
        FLASH->CR2 &= (~FLASH_CR_BER);
    bb84:	f8d1 210c 	ldr.w	r2, [r1, #268]	; 0x10c
          status = HAL_ERROR;
    bb88:	bf18      	it	ne
    bb8a:	2301      	movne	r3, #1
        FLASH->CR2 &= (~FLASH_CR_BER);
    bb8c:	f022 0208 	bic.w	r2, r2, #8
    bb90:	f8c1 210c 	str.w	r2, [r1, #268]	; 0x10c
    bb94:	e735      	b.n	ba02 <HAL_FLASHEx_Erase+0x56>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
    bb96:	4629      	mov	r1, r5
    bb98:	f24c 3050 	movw	r0, #50000	; 0xc350
    bb9c:	f7ff fe28 	bl	b7f0 <FLASH_WaitForLastOperation>
        FLASH->CR1 &= (~FLASH_CR_BER);
    bba0:	4905      	ldr	r1, [pc, #20]	; (bbb8 <HAL_FLASHEx_Erase+0x20c>)
          status = HAL_ERROR;
    bba2:	1c03      	adds	r3, r0, #0
        FLASH->CR1 &= (~FLASH_CR_BER);
    bba4:	68ca      	ldr	r2, [r1, #12]
          status = HAL_ERROR;
    bba6:	bf18      	it	ne
    bba8:	2301      	movne	r3, #1
        FLASH->CR1 &= (~FLASH_CR_BER);
    bbaa:	f022 0208 	bic.w	r2, r2, #8
    bbae:	60ca      	str	r2, [r1, #12]
    bbb0:	6862      	ldr	r2, [r4, #4]
    bbb2:	e7db      	b.n	bb6c <HAL_FLASHEx_Erase+0x1c0>
    bbb4:	0002fccc 	.word	0x0002fccc
    bbb8:	52002000 	.word	0x52002000
    bbbc:	020e2f28 	.word	0x020e2f28

0000bbc0 <HAL_GPIO_Init>:
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    bbc0:	4abf      	ldr	r2, [pc, #764]	; (bec0 <HAL_GPIO_Init+0x300>)
    bbc2:	4bc0      	ldr	r3, [pc, #768]	; (bec4 <HAL_GPIO_Init+0x304>)
    bbc4:	4290      	cmp	r0, r2
    bbc6:	bf18      	it	ne
    bbc8:	4298      	cmpne	r0, r3
{
    bbca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bbce:	4607      	mov	r7, r0
    bbd0:	b089      	sub	sp, #36	; 0x24
    bbd2:	4689      	mov	r9, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    bbd4:	bf14      	ite	ne
    bbd6:	f04f 0b01 	movne.w	fp, #1
    bbda:	f04f 0b00 	moveq.w	fp, #0
    bbde:	d027      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bbe0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bbe4:	4298      	cmp	r0, r3
    bbe6:	d023      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bbe8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bbec:	4298      	cmp	r0, r3
    bbee:	d01f      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bbf0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bbf4:	4298      	cmp	r0, r3
    bbf6:	d01b      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bbf8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bbfc:	4298      	cmp	r0, r3
    bbfe:	d017      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bc00:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bc04:	4298      	cmp	r0, r3
    bc06:	d013      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bc08:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bc0c:	4298      	cmp	r0, r3
    bc0e:	d00f      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bc10:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
    bc14:	f503 6300 	add.w	r3, r3, #2048	; 0x800
    bc18:	4290      	cmp	r0, r2
    bc1a:	bf18      	it	ne
    bc1c:	4298      	cmpne	r0, r3
    bc1e:	d007      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bc20:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bc24:	4298      	cmp	r0, r3
    bc26:	d003      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bc28:	21bb      	movs	r1, #187	; 0xbb
    bc2a:	48a7      	ldr	r0, [pc, #668]	; (bec8 <HAL_GPIO_Init+0x308>)
    bc2c:	f00d fbf2 	bl	19414 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    bc30:	f8d9 2000 	ldr.w	r2, [r9]
    bc34:	b293      	uxth	r3, r2
    bc36:	2b00      	cmp	r3, #0
    bc38:	f000 8168 	beq.w	bf0c <HAL_GPIO_Init+0x34c>
    bc3c:	4ba3      	ldr	r3, [pc, #652]	; (becc <HAL_GPIO_Init+0x30c>)
    bc3e:	4013      	ands	r3, r2
    bc40:	2b00      	cmp	r3, #0
    bc42:	f040 8163 	bne.w	bf0c <HAL_GPIO_Init+0x34c>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    bc46:	f8d9 2004 	ldr.w	r2, [r9, #4]
    bc4a:	4ba1      	ldr	r3, [pc, #644]	; (bed0 <HAL_GPIO_Init+0x310>)
    bc4c:	4ca1      	ldr	r4, [pc, #644]	; (bed4 <HAL_GPIO_Init+0x314>)
    bc4e:	f1a2 0011 	sub.w	r0, r2, #17
    bc52:	429a      	cmp	r2, r3
    bc54:	bf18      	it	ne
    bc56:	2a03      	cmpne	r2, #3
    bc58:	f422 1100 	bic.w	r1, r2, #2097152	; 0x200000
    bc5c:	bf8c      	ite	hi
    bc5e:	2301      	movhi	r3, #1
    bc60:	2300      	movls	r3, #0
    bc62:	42a2      	cmp	r2, r4
    bc64:	bf0c      	ite	eq
    bc66:	2300      	moveq	r3, #0
    bc68:	f003 0301 	andne.w	r3, r3, #1
    bc6c:	4a9a      	ldr	r2, [pc, #616]	; (bed8 <HAL_GPIO_Init+0x318>)
    bc6e:	2801      	cmp	r0, #1
    bc70:	bf94      	ite	ls
    bc72:	2300      	movls	r3, #0
    bc74:	f003 0301 	andhi.w	r3, r3, #1
    bc78:	4291      	cmp	r1, r2
    bc7a:	bf0c      	ite	eq
    bc7c:	2300      	moveq	r3, #0
    bc7e:	f003 0301 	andne.w	r3, r3, #1
    bc82:	b11b      	cbz	r3, bc8c <HAL_GPIO_Init+0xcc>
    bc84:	4b95      	ldr	r3, [pc, #596]	; (bedc <HAL_GPIO_Init+0x31c>)
    bc86:	4299      	cmp	r1, r3
    bc88:	f040 8193 	bne.w	bfb2 <HAL_GPIO_Init+0x3f2>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    bc8c:	f8d9 3008 	ldr.w	r3, [r9, #8]
    bc90:	2b02      	cmp	r3, #2
    bc92:	f200 8170 	bhi.w	bf76 <HAL_GPIO_Init+0x3b6>

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
    bc96:	f8d9 1000 	ldr.w	r1, [r9]
    bc9a:	2900      	cmp	r1, #0
    bc9c:	f000 810d 	beq.w	beba <HAL_GPIO_Init+0x2fa>

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    bca0:	4b8f      	ldr	r3, [pc, #572]	; (bee0 <HAL_GPIO_Init+0x320>)
    bca2:	f04f 0800 	mov.w	r8, #0
    bca6:	4a8f      	ldr	r2, [pc, #572]	; (bee4 <HAL_GPIO_Init+0x324>)
    bca8:	488f      	ldr	r0, [pc, #572]	; (bee8 <HAL_GPIO_Init+0x328>)
    bcaa:	429f      	cmp	r7, r3
    bcac:	bf18      	it	ne
    bcae:	4297      	cmpne	r7, r2
    bcb0:	4d8e      	ldr	r5, [pc, #568]	; (beec <HAL_GPIO_Init+0x32c>)
    bcb2:	f5a2 52c0 	sub.w	r2, r2, #6144	; 0x1800
    bcb6:	4c8e      	ldr	r4, [pc, #568]	; (bef0 <HAL_GPIO_Init+0x330>)
    bcb8:	bf14      	ite	ne
    bcba:	2301      	movne	r3, #1
    bcbc:	2300      	moveq	r3, #0
    bcbe:	42af      	cmp	r7, r5
    bcc0:	bf0c      	ite	eq
    bcc2:	2300      	moveq	r3, #0
    bcc4:	f003 0301 	andne.w	r3, r3, #1
    bcc8:	4287      	cmp	r7, r0
    bcca:	bf18      	it	ne
    bccc:	4297      	cmpne	r7, r2
    bcce:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
    bcd2:	bf14      	ite	ne
    bcd4:	2201      	movne	r2, #1
    bcd6:	2200      	moveq	r2, #0
    bcd8:	9305      	str	r3, [sp, #20]
    bcda:	4b86      	ldr	r3, [pc, #536]	; (bef4 <HAL_GPIO_Init+0x334>)
    bcdc:	9200      	str	r2, [sp, #0]
    bcde:	42a7      	cmp	r7, r4
    bce0:	bf18      	it	ne
    bce2:	429f      	cmpne	r7, r3
    bce4:	4a84      	ldr	r2, [pc, #528]	; (bef8 <HAL_GPIO_Init+0x338>)
    bce6:	bf14      	ite	ne
    bce8:	2301      	movne	r3, #1
    bcea:	2300      	moveq	r3, #0
    bcec:	4287      	cmp	r7, r0
    bcee:	bf18      	it	ne
    bcf0:	4297      	cmpne	r7, r2
    bcf2:	9301      	str	r3, [sp, #4]
    bcf4:	bf14      	ite	ne
    bcf6:	2201      	movne	r2, #1
    bcf8:	2200      	moveq	r2, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bcfa:	4b80      	ldr	r3, [pc, #512]	; (befc <HAL_GPIO_Init+0x33c>)
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    bcfc:	9204      	str	r2, [sp, #16]
    bcfe:	4a80      	ldr	r2, [pc, #512]	; (bf00 <HAL_GPIO_Init+0x340>)
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
    bd00:	2401      	movs	r4, #1
    bd02:	fa04 f408 	lsl.w	r4, r4, r8
    if (iocurrent != 0x00U)
    bd06:	ea14 0a01 	ands.w	sl, r4, r1
    bd0a:	f000 80d0 	beq.w	beae <HAL_GPIO_Init+0x2ee>
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    bd0e:	f8d9 1004 	ldr.w	r1, [r9, #4]
    bd12:	ea4f 0648 	mov.w	r6, r8, lsl #1
    bd16:	2503      	movs	r5, #3
    bd18:	f021 0110 	bic.w	r1, r1, #16
    bd1c:	40b5      	lsls	r5, r6
    bd1e:	3901      	subs	r1, #1
    bd20:	43ed      	mvns	r5, r5
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    bd22:	2901      	cmp	r1, #1
    bd24:	d814      	bhi.n	bd50 <HAL_GPIO_Init+0x190>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    bd26:	f8d9 100c 	ldr.w	r1, [r9, #12]
    bd2a:	2903      	cmp	r1, #3
    bd2c:	f200 80f3 	bhi.w	bf16 <HAL_GPIO_Init+0x356>
        temp = GPIOx->OSPEEDR;
    bd30:	68b8      	ldr	r0, [r7, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
    bd32:	40b1      	lsls	r1, r6
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    bd34:	4028      	ands	r0, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
    bd36:	4301      	orrs	r1, r0
        GPIOx->OSPEEDR = temp;
    bd38:	60b9      	str	r1, [r7, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    bd3a:	f8d9 1004 	ldr.w	r1, [r9, #4]
        temp = GPIOx->OTYPER;
    bd3e:	6878      	ldr	r0, [r7, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    bd40:	f3c1 1100 	ubfx	r1, r1, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
    bd44:	ea20 0004 	bic.w	r0, r0, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    bd48:	fa01 f408 	lsl.w	r4, r1, r8
    bd4c:	4304      	orrs	r4, r0
        GPIOx->OTYPER = temp;
    bd4e:	607c      	str	r4, [r7, #4]
      temp = GPIOx->PUPDR;
    bd50:	68f8      	ldr	r0, [r7, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
    bd52:	f8d9 1008 	ldr.w	r1, [r9, #8]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    bd56:	4028      	ands	r0, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
    bd58:	40b1      	lsls	r1, r6
    bd5a:	4301      	orrs	r1, r0
      GPIOx->PUPDR = temp;
    bd5c:	60f9      	str	r1, [r7, #12]
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    bd5e:	f8d9 1004 	ldr.w	r1, [r9, #4]
    bd62:	f021 0010 	bic.w	r0, r1, #16
    bd66:	2802      	cmp	r0, #2
    bd68:	d120      	bne.n	bdac <HAL_GPIO_Init+0x1ec>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    bd6a:	f1bb 0f00 	cmp.w	fp, #0
    bd6e:	d003      	beq.n	bd78 <HAL_GPIO_Init+0x1b8>
    bd70:	9900      	ldr	r1, [sp, #0]
    bd72:	2900      	cmp	r1, #0
    bd74:	f040 80da 	bne.w	bf2c <HAL_GPIO_Init+0x36c>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    bd78:	f8d9 e010 	ldr.w	lr, [r9, #16]
    bd7c:	f1be 0f0f 	cmp.w	lr, #15
    bd80:	f200 80ee 	bhi.w	bf60 <HAL_GPIO_Init+0x3a0>
        temp = GPIOx->AFR[position >> 3U];
    bd84:	ea4f 00d8 	mov.w	r0, r8, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
    bd88:	f008 0107 	and.w	r1, r8, #7
    bd8c:	f04f 0c0f 	mov.w	ip, #15
    bd90:	eb07 0080 	add.w	r0, r7, r0, lsl #2
    bd94:	0089      	lsls	r1, r1, #2
        temp = GPIOx->AFR[position >> 3U];
    bd96:	6a04      	ldr	r4, [r0, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
    bd98:	fa0c fc01 	lsl.w	ip, ip, r1
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
    bd9c:	fa0e f101 	lsl.w	r1, lr, r1
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
    bda0:	ea24 040c 	bic.w	r4, r4, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
    bda4:	4321      	orrs	r1, r4
        GPIOx->AFR[position >> 3U] = temp;
    bda6:	6201      	str	r1, [r0, #32]
    bda8:	f8d9 1004 	ldr.w	r1, [r9, #4]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    bdac:	f001 0103 	and.w	r1, r1, #3
      temp = GPIOx->MODER;
    bdb0:	6838      	ldr	r0, [r7, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    bdb2:	fa01 f606 	lsl.w	r6, r1, r6
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
    bdb6:	4005      	ands	r5, r0
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    bdb8:	4335      	orrs	r5, r6
      GPIOx->MODER = temp;
    bdba:	603d      	str	r5, [r7, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
    bdbc:	f8d9 1004 	ldr.w	r1, [r9, #4]
    bdc0:	00cc      	lsls	r4, r1, #3
    bdc2:	d572      	bpl.n	beaa <HAL_GPIO_Init+0x2ea>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bdc4:	f8d3 40f4 	ldr.w	r4, [r3, #244]	; 0xf4
    bdc8:	f028 0503 	bic.w	r5, r8, #3

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    bdcc:	f008 0103 	and.w	r1, r8, #3
    bdd0:	200f      	movs	r0, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bdd2:	f044 0402 	orr.w	r4, r4, #2
    bdd6:	4415      	add	r5, r2
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    bdd8:	0089      	lsls	r1, r1, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bdda:	f8c3 40f4 	str.w	r4, [r3, #244]	; 0xf4
    bdde:	f8d3 40f4 	ldr.w	r4, [r3, #244]	; 0xf4
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    bde2:	fa00 f601 	lsl.w	r6, r0, r1
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bde6:	f004 0402 	and.w	r4, r4, #2
    bdea:	9407      	str	r4, [sp, #28]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    bdec:	4c34      	ldr	r4, [pc, #208]	; (bec0 <HAL_GPIO_Init+0x300>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bdee:	9807      	ldr	r0, [sp, #28]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    bdf0:	42a7      	cmp	r7, r4
        temp = SYSCFG->EXTICR[position >> 2U];
    bdf2:	68a8      	ldr	r0, [r5, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    bdf4:	ea20 0006 	bic.w	r0, r0, r6
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    bdf8:	d027      	beq.n	be4a <HAL_GPIO_Init+0x28a>
    bdfa:	f1bb 0f00 	cmp.w	fp, #0
    bdfe:	f000 80bf 	beq.w	bf80 <HAL_GPIO_Init+0x3c0>
    be02:	4c39      	ldr	r4, [pc, #228]	; (bee8 <HAL_GPIO_Init+0x328>)
    be04:	42a7      	cmp	r7, r4
    be06:	f000 80a6 	beq.w	bf56 <HAL_GPIO_Init+0x396>
    be0a:	9c00      	ldr	r4, [sp, #0]
    be0c:	2c00      	cmp	r4, #0
    be0e:	f000 80c1 	beq.w	bf94 <HAL_GPIO_Init+0x3d4>
    be12:	4c37      	ldr	r4, [pc, #220]	; (bef0 <HAL_GPIO_Init+0x330>)
    be14:	42a7      	cmp	r7, r4
    be16:	f000 80c2 	beq.w	bf9e <HAL_GPIO_Init+0x3de>
    be1a:	9c01      	ldr	r4, [sp, #4]
    be1c:	2c00      	cmp	r4, #0
    be1e:	f000 80b4 	beq.w	bf8a <HAL_GPIO_Init+0x3ca>
    be22:	4c38      	ldr	r4, [pc, #224]	; (bf04 <HAL_GPIO_Init+0x344>)
    be24:	42a7      	cmp	r7, r4
    be26:	f000 80bf 	beq.w	bfa8 <HAL_GPIO_Init+0x3e8>
    be2a:	9c04      	ldr	r4, [sp, #16]
    be2c:	2c00      	cmp	r4, #0
    be2e:	f000 80c5 	beq.w	bfbc <HAL_GPIO_Init+0x3fc>
    be32:	4c2b      	ldr	r4, [pc, #172]	; (bee0 <HAL_GPIO_Init+0x320>)
    be34:	42a7      	cmp	r7, r4
    be36:	f000 80c6 	beq.w	bfc6 <HAL_GPIO_Init+0x406>
    be3a:	4c2a      	ldr	r4, [pc, #168]	; (bee4 <HAL_GPIO_Init+0x324>)
    be3c:	42a7      	cmp	r7, r4
    be3e:	bf0c      	ite	eq
    be40:	2409      	moveq	r4, #9
    be42:	240a      	movne	r4, #10
    be44:	fa04 f101 	lsl.w	r1, r4, r1
    be48:	4308      	orrs	r0, r1
        SYSCFG->EXTICR[position >> 2U] = temp;
    be4a:	60a8      	str	r0, [r5, #8]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
        temp &= ~(iocurrent);
    be4c:	ea6f 050a 	mvn.w	r5, sl
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
    be50:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI_CurrentCPU->IMR1;
    be54:	492c      	ldr	r1, [pc, #176]	; (bf08 <HAL_GPIO_Init+0x348>)
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
    be56:	03c0      	lsls	r0, r0, #15
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->IMR1 = temp;
    be58:	4c2b      	ldr	r4, [pc, #172]	; (bf08 <HAL_GPIO_Init+0x348>)
        temp = EXTI_CurrentCPU->IMR1;
    be5a:	6809      	ldr	r1, [r1, #0]
        temp &= ~(iocurrent);
    be5c:	bf54      	ite	pl
    be5e:	4029      	andpl	r1, r5
          temp |= iocurrent;
    be60:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI_CurrentCPU->IMR1 = temp;
    be64:	6021      	str	r1, [r4, #0]

        temp = EXTI_CurrentCPU->EMR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
    be66:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI_CurrentCPU->EMR1;
    be6a:	6861      	ldr	r1, [r4, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
    be6c:	0386      	lsls	r6, r0, #14
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->EMR1 = temp;
    be6e:	4c26      	ldr	r4, [pc, #152]	; (bf08 <HAL_GPIO_Init+0x348>)

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
    be70:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
    be74:	bf54      	ite	pl
    be76:	4029      	andpl	r1, r5
          temp |= iocurrent;
    be78:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI_CurrentCPU->EMR1 = temp;
    be7c:	6061      	str	r1, [r4, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
    be7e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
    be82:	f8d9 4004 	ldr.w	r4, [r9, #4]
        temp = EXTI->RTSR1;
    be86:	6800      	ldr	r0, [r0, #0]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
    be88:	02e4      	lsls	r4, r4, #11
        temp &= ~(iocurrent);
    be8a:	bf54      	ite	pl
    be8c:	4028      	andpl	r0, r5
          temp |= iocurrent;
    be8e:	ea4a 0000 	orrmi.w	r0, sl, r0
        EXTI->RTSR1 = temp;
    be92:	6008      	str	r0, [r1, #0]

        temp = EXTI->FTSR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
    be94:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI->FTSR1;
    be98:	6849      	ldr	r1, [r1, #4]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
    be9a:	0280      	lsls	r0, r0, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
    be9c:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
    bea0:	bf54      	ite	pl
    bea2:	4029      	andpl	r1, r5
          temp |= iocurrent;
    bea4:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI->FTSR1 = temp;
    bea8:	6041      	str	r1, [r0, #4]
    beaa:	f8d9 1000 	ldr.w	r1, [r9]
      }
    }

    position++;
    beae:	f108 0801 	add.w	r8, r8, #1
  while (((GPIO_Init->Pin) >> position) != 0x00U)
    beb2:	fa31 f008 	lsrs.w	r0, r1, r8
    beb6:	f47f af23 	bne.w	bd00 <HAL_GPIO_Init+0x140>
  }
}
    beba:	b009      	add	sp, #36	; 0x24
    bebc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bec0:	58020000 	.word	0x58020000
    bec4:	58020400 	.word	0x58020400
    bec8:	0002fd0c 	.word	0x0002fd0c
    becc:	ffff0000 	.word	0xffff0000
    bed0:	11210000 	.word	0x11210000
    bed4:	11220000 	.word	0x11220000
    bed8:	11110000 	.word	0x11110000
    bedc:	11120000 	.word	0x11120000
    bee0:	58022000 	.word	0x58022000
    bee4:	58022400 	.word	0x58022400
    bee8:	58020800 	.word	0x58020800
    beec:	58022800 	.word	0x58022800
    bef0:	58021000 	.word	0x58021000
    bef4:	58021400 	.word	0x58021400
    bef8:	58021c00 	.word	0x58021c00
    befc:	58024400 	.word	0x58024400
    bf00:	58000400 	.word	0x58000400
    bf04:	58021800 	.word	0x58021800
    bf08:	58000080 	.word	0x58000080
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    bf0c:	21bc      	movs	r1, #188	; 0xbc
    bf0e:	4830      	ldr	r0, [pc, #192]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bf10:	f00d fa80 	bl	19414 <assert_failed>
    bf14:	e697      	b.n	bc46 <HAL_GPIO_Init+0x86>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    bf16:	21ce      	movs	r1, #206	; 0xce
    bf18:	482d      	ldr	r0, [pc, #180]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bf1a:	e9cd 3202 	strd	r3, r2, [sp, #8]
    bf1e:	f00d fa79 	bl	19414 <assert_failed>
    bf22:	f8d9 100c 	ldr.w	r1, [r9, #12]
    bf26:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    bf2a:	e701      	b.n	bd30 <HAL_GPIO_Init+0x170>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    bf2c:	9901      	ldr	r1, [sp, #4]
    bf2e:	2900      	cmp	r1, #0
    bf30:	f43f af22 	beq.w	bd78 <HAL_GPIO_Init+0x1b8>
    bf34:	9904      	ldr	r1, [sp, #16]
    bf36:	2900      	cmp	r1, #0
    bf38:	f43f af1e 	beq.w	bd78 <HAL_GPIO_Init+0x1b8>
    bf3c:	9905      	ldr	r1, [sp, #20]
    bf3e:	2900      	cmp	r1, #0
    bf40:	f43f af1a 	beq.w	bd78 <HAL_GPIO_Init+0x1b8>
    bf44:	21e6      	movs	r1, #230	; 0xe6
    bf46:	4822      	ldr	r0, [pc, #136]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bf48:	e9cd 3202 	strd	r3, r2, [sp, #8]
    bf4c:	f00d fa62 	bl	19414 <assert_failed>
    bf50:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    bf54:	e710      	b.n	bd78 <HAL_GPIO_Init+0x1b8>
    bf56:	2402      	movs	r4, #2
    bf58:	fa04 f101 	lsl.w	r1, r4, r1
    bf5c:	4308      	orrs	r0, r1
    bf5e:	e774      	b.n	be4a <HAL_GPIO_Init+0x28a>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    bf60:	21e7      	movs	r1, #231	; 0xe7
    bf62:	481b      	ldr	r0, [pc, #108]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bf64:	e9cd 3202 	strd	r3, r2, [sp, #8]
    bf68:	f00d fa54 	bl	19414 <assert_failed>
    bf6c:	f8d9 e010 	ldr.w	lr, [r9, #16]
    bf70:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    bf74:	e706      	b.n	bd84 <HAL_GPIO_Init+0x1c4>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    bf76:	21be      	movs	r1, #190	; 0xbe
    bf78:	4815      	ldr	r0, [pc, #84]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bf7a:	f00d fa4b 	bl	19414 <assert_failed>
    bf7e:	e68a      	b.n	bc96 <HAL_GPIO_Init+0xd6>
    bf80:	2401      	movs	r4, #1
    bf82:	fa04 f101 	lsl.w	r1, r4, r1
    bf86:	4308      	orrs	r0, r1
    bf88:	e75f      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bf8a:	2405      	movs	r4, #5
    bf8c:	fa04 f101 	lsl.w	r1, r4, r1
    bf90:	4308      	orrs	r0, r1
    bf92:	e75a      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bf94:	2403      	movs	r4, #3
    bf96:	fa04 f101 	lsl.w	r1, r4, r1
    bf9a:	4308      	orrs	r0, r1
    bf9c:	e755      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bf9e:	2404      	movs	r4, #4
    bfa0:	fa04 f101 	lsl.w	r1, r4, r1
    bfa4:	4308      	orrs	r0, r1
    bfa6:	e750      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bfa8:	2406      	movs	r4, #6
    bfaa:	fa04 f101 	lsl.w	r1, r4, r1
    bfae:	4308      	orrs	r0, r1
    bfb0:	e74b      	b.n	be4a <HAL_GPIO_Init+0x28a>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    bfb2:	21bd      	movs	r1, #189	; 0xbd
    bfb4:	4806      	ldr	r0, [pc, #24]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bfb6:	f00d fa2d 	bl	19414 <assert_failed>
    bfba:	e667      	b.n	bc8c <HAL_GPIO_Init+0xcc>
    bfbc:	2407      	movs	r4, #7
    bfbe:	fa04 f101 	lsl.w	r1, r4, r1
    bfc2:	4308      	orrs	r0, r1
    bfc4:	e741      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bfc6:	2408      	movs	r4, #8
    bfc8:	fa04 f101 	lsl.w	r1, r4, r1
    bfcc:	4308      	orrs	r0, r1
    bfce:	e73c      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bfd0:	0002fd0c 	.word	0x0002fd0c

0000bfd4 <HAL_GPIO_DeInit>:
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    bfd4:	4a80      	ldr	r2, [pc, #512]	; (c1d8 <HAL_GPIO_DeInit+0x204>)
    bfd6:	4b81      	ldr	r3, [pc, #516]	; (c1dc <HAL_GPIO_DeInit+0x208>)
    bfd8:	4290      	cmp	r0, r2
    bfda:	bf18      	it	ne
    bfdc:	4298      	cmpne	r0, r3
{
    bfde:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bfe2:	4604      	mov	r4, r0
    bfe4:	b083      	sub	sp, #12
    bfe6:	460d      	mov	r5, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    bfe8:	bf14      	ite	ne
    bfea:	f04f 0801 	movne.w	r8, #1
    bfee:	f04f 0800 	moveq.w	r8, #0
    bff2:	d028      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    bff4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bff8:	4298      	cmp	r0, r3
    bffa:	d024      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    bffc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c000:	4298      	cmp	r0, r3
    c002:	d020      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c004:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c008:	4298      	cmp	r0, r3
    c00a:	d01c      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c00c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c010:	4298      	cmp	r0, r3
    c012:	d018      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c014:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c018:	4298      	cmp	r0, r3
    c01a:	d014      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c01c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c020:	4298      	cmp	r0, r3
    c022:	d010      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c024:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
    c028:	f503 6300 	add.w	r3, r3, #2048	; 0x800
    c02c:	4290      	cmp	r0, r2
    c02e:	bf18      	it	ne
    c030:	4298      	cmpne	r0, r3
    c032:	d008      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c034:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c038:	4298      	cmp	r0, r3
    c03a:	d004      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c03c:	f240 113f 	movw	r1, #319	; 0x13f
    c040:	4867      	ldr	r0, [pc, #412]	; (c1e0 <HAL_GPIO_DeInit+0x20c>)
    c042:	f00d f9e7 	bl	19414 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c046:	b2ab      	uxth	r3, r5
    c048:	2b00      	cmp	r3, #0
    c04a:	d046      	beq.n	c0da <HAL_GPIO_DeInit+0x106>
    c04c:	4b65      	ldr	r3, [pc, #404]	; (c1e4 <HAL_GPIO_DeInit+0x210>)
    c04e:	402b      	ands	r3, r5
    c050:	2b00      	cmp	r3, #0
    c052:	d142      	bne.n	c0da <HAL_GPIO_DeInit+0x106>
{
    c054:	2300      	movs	r3, #0
    c056:	f8df b1a8 	ldr.w	fp, [pc, #424]	; c200 <HAL_GPIO_DeInit+0x22c>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    c05a:	f8df a17c 	ldr.w	sl, [pc, #380]	; c1d8 <HAL_GPIO_DeInit+0x204>
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
    c05e:	f8df 91a4 	ldr.w	r9, [pc, #420]	; c204 <HAL_GPIO_DeInit+0x230>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    c062:	f8cd 8004 	str.w	r8, [sp, #4]
    iocurrent = GPIO_Pin & (1UL << position) ;
    c066:	f04f 0801 	mov.w	r8, #1
    c06a:	fa08 f003 	lsl.w	r0, r8, r3
    if (iocurrent != 0x00U)
    c06e:	ea10 0105 	ands.w	r1, r0, r5
    c072:	f000 8081 	beq.w	c178 <HAL_GPIO_DeInit+0x1a4>
    c076:	f023 0703 	bic.w	r7, r3, #3
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
    c07a:	f003 0203 	and.w	r2, r3, #3
    c07e:	f04f 0c0f 	mov.w	ip, #15
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    c082:	4554      	cmp	r4, sl
    c084:	445f      	add	r7, fp
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
    c086:	ea4f 0282 	mov.w	r2, r2, lsl #2
      tmp = SYSCFG->EXTICR[position >> 2U];
    c08a:	f8d7 e008 	ldr.w	lr, [r7, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
    c08e:	fa0c fc02 	lsl.w	ip, ip, r2
    c092:	ea0c 0e0e 	and.w	lr, ip, lr
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    c096:	d02a      	beq.n	c0ee <HAL_GPIO_DeInit+0x11a>
    c098:	9e01      	ldr	r6, [sp, #4]
    c09a:	b1de      	cbz	r6, c0d4 <HAL_GPIO_DeInit+0x100>
    c09c:	4e52      	ldr	r6, [pc, #328]	; (c1e8 <HAL_GPIO_DeInit+0x214>)
    c09e:	42b4      	cmp	r4, r6
    c0a0:	d077      	beq.n	c192 <HAL_GPIO_DeInit+0x1be>
    c0a2:	4e52      	ldr	r6, [pc, #328]	; (c1ec <HAL_GPIO_DeInit+0x218>)
    c0a4:	42b4      	cmp	r4, r6
    c0a6:	d079      	beq.n	c19c <HAL_GPIO_DeInit+0x1c8>
    c0a8:	4e51      	ldr	r6, [pc, #324]	; (c1f0 <HAL_GPIO_DeInit+0x21c>)
    c0aa:	42b4      	cmp	r4, r6
    c0ac:	d06c      	beq.n	c188 <HAL_GPIO_DeInit+0x1b4>
    c0ae:	4e51      	ldr	r6, [pc, #324]	; (c1f4 <HAL_GPIO_DeInit+0x220>)
    c0b0:	42b4      	cmp	r4, r6
    c0b2:	d07d      	beq.n	c1b0 <HAL_GPIO_DeInit+0x1dc>
    c0b4:	4e50      	ldr	r6, [pc, #320]	; (c1f8 <HAL_GPIO_DeInit+0x224>)
    c0b6:	42b4      	cmp	r4, r6
    c0b8:	d07f      	beq.n	c1ba <HAL_GPIO_DeInit+0x1e6>
    c0ba:	4e50      	ldr	r6, [pc, #320]	; (c1fc <HAL_GPIO_DeInit+0x228>)
    c0bc:	42b4      	cmp	r4, r6
    c0be:	d072      	beq.n	c1a6 <HAL_GPIO_DeInit+0x1d2>
    c0c0:	f8df 8144 	ldr.w	r8, [pc, #324]	; c208 <HAL_GPIO_DeInit+0x234>
    c0c4:	4544      	cmp	r4, r8
    c0c6:	d07d      	beq.n	c1c4 <HAL_GPIO_DeInit+0x1f0>
    c0c8:	f8df 8140 	ldr.w	r8, [pc, #320]	; c20c <HAL_GPIO_DeInit+0x238>
    c0cc:	4544      	cmp	r4, r8
    c0ce:	d07e      	beq.n	c1ce <HAL_GPIO_DeInit+0x1fa>
    c0d0:	f04f 080a 	mov.w	r8, #10
    c0d4:	fa08 f202 	lsl.w	r2, r8, r2
    c0d8:	e00a      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c0da:	f44f 71a0 	mov.w	r1, #320	; 0x140
    c0de:	4840      	ldr	r0, [pc, #256]	; (c1e0 <HAL_GPIO_DeInit+0x20c>)
    c0e0:	f00d f998 	bl	19414 <assert_failed>
  while ((GPIO_Pin >> position) != 0x00U)
    c0e4:	2d00      	cmp	r5, #0
    c0e6:	d1b5      	bne.n	c054 <HAL_GPIO_DeInit+0x80>
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    }

    position++;
  }
}
    c0e8:	b003      	add	sp, #12
    c0ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c0ee:	2200      	movs	r2, #0
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    c0f0:	4596      	cmp	lr, r2
    c0f2:	d11d      	bne.n	c130 <HAL_GPIO_DeInit+0x15c>
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
    c0f4:	f8d9 e000 	ldr.w	lr, [r9]
    c0f8:	43c9      	mvns	r1, r1
        EXTI->RTSR1 &= ~(iocurrent);
    c0fa:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
    c0fe:	ea0e 0e01 	and.w	lr, lr, r1
    c102:	f8c9 e000 	str.w	lr, [r9]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
    c106:	f8d9 e004 	ldr.w	lr, [r9, #4]
    c10a:	ea01 0e0e 	and.w	lr, r1, lr
    c10e:	f8c9 e004 	str.w	lr, [r9, #4]
        EXTI->RTSR1 &= ~(iocurrent);
    c112:	f8d2 e000 	ldr.w	lr, [r2]
    c116:	ea01 0e0e 	and.w	lr, r1, lr
    c11a:	f8c2 e000 	str.w	lr, [r2]
        EXTI->FTSR1 &= ~(iocurrent);
    c11e:	f8d2 e004 	ldr.w	lr, [r2, #4]
    c122:	ea01 010e 	and.w	r1, r1, lr
    c126:	6051      	str	r1, [r2, #4]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
    c128:	68ba      	ldr	r2, [r7, #8]
    c12a:	ea22 020c 	bic.w	r2, r2, ip
    c12e:	60ba      	str	r2, [r7, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    c130:	2103      	movs	r1, #3
    c132:	005a      	lsls	r2, r3, #1
    c134:	f8d4 e000 	ldr.w	lr, [r4]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    c138:	f04f 0c0f 	mov.w	ip, #15
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    c13c:	fa01 f202 	lsl.w	r2, r1, r2
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    c140:	fa23 f701 	lsr.w	r7, r3, r1
    c144:	f003 0107 	and.w	r1, r3, #7
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    c148:	ea4e 0e02 	orr.w	lr, lr, r2
    c14c:	eb04 0787 	add.w	r7, r4, r7, lsl #2
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    c150:	0089      	lsls	r1, r1, #2
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    c152:	43d2      	mvns	r2, r2
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    c154:	f8c4 e000 	str.w	lr, [r4]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    c158:	fa0c fc01 	lsl.w	ip, ip, r1
    c15c:	6a39      	ldr	r1, [r7, #32]
    c15e:	ea21 010c 	bic.w	r1, r1, ip
    c162:	6239      	str	r1, [r7, #32]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    c164:	68e1      	ldr	r1, [r4, #12]
    c166:	4011      	ands	r1, r2
    c168:	60e1      	str	r1, [r4, #12]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
    c16a:	6861      	ldr	r1, [r4, #4]
    c16c:	ea21 0000 	bic.w	r0, r1, r0
    c170:	6060      	str	r0, [r4, #4]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    c172:	68a1      	ldr	r1, [r4, #8]
    c174:	400a      	ands	r2, r1
    c176:	60a2      	str	r2, [r4, #8]
    position++;
    c178:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00U)
    c17a:	fa35 f203 	lsrs.w	r2, r5, r3
    c17e:	f47f af72 	bne.w	c066 <HAL_GPIO_DeInit+0x92>
}
    c182:	b003      	add	sp, #12
    c184:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c188:	f04f 0804 	mov.w	r8, #4
    c18c:	fa08 f202 	lsl.w	r2, r8, r2
    c190:	e7ae      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c192:	f04f 0802 	mov.w	r8, #2
    c196:	fa08 f202 	lsl.w	r2, r8, r2
    c19a:	e7a9      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c19c:	f04f 0803 	mov.w	r8, #3
    c1a0:	fa08 f202 	lsl.w	r2, r8, r2
    c1a4:	e7a4      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1a6:	f04f 0807 	mov.w	r8, #7
    c1aa:	fa08 f202 	lsl.w	r2, r8, r2
    c1ae:	e79f      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1b0:	f04f 0805 	mov.w	r8, #5
    c1b4:	fa08 f202 	lsl.w	r2, r8, r2
    c1b8:	e79a      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1ba:	f04f 0806 	mov.w	r8, #6
    c1be:	fa08 f202 	lsl.w	r2, r8, r2
    c1c2:	e795      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1c4:	f04f 0808 	mov.w	r8, #8
    c1c8:	fa08 f202 	lsl.w	r2, r8, r2
    c1cc:	e790      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1ce:	f04f 0809 	mov.w	r8, #9
    c1d2:	fa08 f202 	lsl.w	r2, r8, r2
    c1d6:	e78b      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1d8:	58020000 	.word	0x58020000
    c1dc:	58020400 	.word	0x58020400
    c1e0:	0002fd0c 	.word	0x0002fd0c
    c1e4:	ffff0000 	.word	0xffff0000
    c1e8:	58020800 	.word	0x58020800
    c1ec:	58020c00 	.word	0x58020c00
    c1f0:	58021000 	.word	0x58021000
    c1f4:	58021400 	.word	0x58021400
    c1f8:	58021800 	.word	0x58021800
    c1fc:	58021c00 	.word	0x58021c00
    c200:	58000400 	.word	0x58000400
    c204:	58000080 	.word	0x58000080
    c208:	58022000 	.word	0x58022000
    c20c:	58022400 	.word	0x58022400

0000c210 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
    c210:	b538      	push	{r3, r4, r5, lr}
    c212:	4605      	mov	r5, r0
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c214:	460c      	mov	r4, r1
    c216:	b129      	cbz	r1, c224 <HAL_GPIO_ReadPin+0x14>

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
    c218:	692b      	ldr	r3, [r5, #16]
    c21a:	421c      	tst	r4, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
    c21c:	bf14      	ite	ne
    c21e:	2001      	movne	r0, #1
    c220:	2000      	moveq	r0, #0
    c222:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c224:	f240 118d 	movw	r1, #397	; 0x18d
    c228:	4801      	ldr	r0, [pc, #4]	; (c230 <HAL_GPIO_ReadPin+0x20>)
    c22a:	f00d f8f3 	bl	19414 <assert_failed>
    c22e:	e7f3      	b.n	c218 <HAL_GPIO_ReadPin+0x8>
    c230:	0002fd0c 	.word	0x0002fd0c

0000c234 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
    c234:	b570      	push	{r4, r5, r6, lr}
    c236:	4606      	mov	r6, r0
    c238:	4615      	mov	r5, r2
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c23a:	460c      	mov	r4, r1
    c23c:	b161      	cbz	r1, c258 <HAL_GPIO_WritePin+0x24>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
    c23e:	2d01      	cmp	r5, #1
    c240:	d803      	bhi.n	c24a <HAL_GPIO_WritePin+0x16>

  if (PinState != GPIO_PIN_RESET)
    c242:	b905      	cbnz	r5, c246 <HAL_GPIO_WritePin+0x12>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
    c244:	0424      	lsls	r4, r4, #16
    c246:	61b4      	str	r4, [r6, #24]
  }
}
    c248:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN_ACTION(PinState));
    c24a:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
    c24e:	4805      	ldr	r0, [pc, #20]	; (c264 <HAL_GPIO_WritePin+0x30>)
    c250:	f00d f8e0 	bl	19414 <assert_failed>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
    c254:	61b4      	str	r4, [r6, #24]
}
    c256:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c258:	f240 11ad 	movw	r1, #429	; 0x1ad
    c25c:	4801      	ldr	r0, [pc, #4]	; (c264 <HAL_GPIO_WritePin+0x30>)
    c25e:	f00d f8d9 	bl	19414 <assert_failed>
    c262:	e7ec      	b.n	c23e <HAL_GPIO_WritePin+0xa>
    c264:	0002fd0c 	.word	0x0002fd0c

0000c268 <HAL_HCD_HC_Init>:
                                  uint8_t epnum,
                                  uint8_t dev_address,
                                  uint8_t speed,
                                  uint8_t ep_type,
                                  uint16_t mps)
{
    c268:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef status;

  __HAL_LOCK(hhcd);
    c26c:	f890 42b8 	ldrb.w	r4, [r0, #696]	; 0x2b8
{
    c270:	b085      	sub	sp, #20
  __HAL_LOCK(hhcd);
    c272:	2c01      	cmp	r4, #1
{
    c274:	f89d c038 	ldrb.w	ip, [sp, #56]	; 0x38
    c278:	f89d e03c 	ldrb.w	lr, [sp, #60]	; 0x3c
    c27c:	f8bd 9040 	ldrh.w	r9, [sp, #64]	; 0x40
  __HAL_LOCK(hhcd);
    c280:	d029      	beq.n	c2d6 <HAL_HCD_HC_Init+0x6e>
    c282:	4605      	mov	r5, r0
  hhcd->hc[ch_num].do_ping = 0U;
    c284:	eb01 0481 	add.w	r4, r1, r1, lsl #2
  __HAL_LOCK(hhcd);
    c288:	f04f 0801 	mov.w	r8, #1
  hhcd->hc[ch_num].max_packet = mps;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].ep_type = ep_type;
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;

  if ((epnum & 0x80U) == 0x80U)
    c28c:	09d0      	lsrs	r0, r2, #7
  hhcd->hc[ch_num].do_ping = 0U;
    c28e:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
    c292:	f002 0a7f 	and.w	sl, r2, #127	; 0x7f
  __HAL_LOCK(hhcd);
    c296:	f885 82b8 	strb.w	r8, [r5, #696]	; 0x2b8
  hhcd->hc[ch_num].do_ping = 0U;
    c29a:	f04f 0800 	mov.w	r8, #0
  hhcd->hc[ch_num].dev_addr = dev_address;
    c29e:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  hhcd->hc[ch_num].max_packet = mps;
    c2a2:	f8a4 9040 	strh.w	r9, [r4, #64]	; 0x40
  hhcd->hc[ch_num].ch_num = ch_num;
    c2a6:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  hhcd->hc[ch_num].ep_type = ep_type;
    c2aa:	f884 e03f 	strb.w	lr, [r4, #63]	; 0x3f
  else
  {
    hhcd->hc[ch_num].ep_is_in = 0U;
  }

  hhcd->hc[ch_num].speed = speed;
    c2ae:	f884 c03c 	strb.w	ip, [r4, #60]	; 0x3c
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
    c2b2:	f884 a03a 	strb.w	sl, [r4, #58]	; 0x3a
    c2b6:	f884 003b 	strb.w	r0, [r4, #59]	; 0x3b
  hhcd->hc[ch_num].do_ping = 0U;
    c2ba:	f884 803d 	strb.w	r8, [r4, #61]	; 0x3d

  status =  USB_HC_Init(hhcd->Instance,
    c2be:	6828      	ldr	r0, [r5, #0]
    c2c0:	f8cd c000 	str.w	ip, [sp]
    c2c4:	e9cd e901 	strd	lr, r9, [sp, #4]
    c2c8:	f008 fb74 	bl	149b4 <USB_HC_Init>
                        epnum,
                        dev_address,
                        speed,
                        ep_type,
                        mps);
  __HAL_UNLOCK(hhcd);
    c2cc:	f885 82b8 	strb.w	r8, [r5, #696]	; 0x2b8

  return status;
}
    c2d0:	b005      	add	sp, #20
    c2d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __HAL_LOCK(hhcd);
    c2d6:	2002      	movs	r0, #2
}
    c2d8:	b005      	add	sp, #20
    c2da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c2de:	bf00      	nop

0000c2e0 <HAL_HCD_HC_Halt>:
  */
HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
  HAL_StatusTypeDef status = HAL_OK;

  __HAL_LOCK(hhcd);
    c2e0:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
    c2e4:	2b01      	cmp	r3, #1
    c2e6:	d00b      	beq.n	c300 <HAL_HCD_HC_Halt+0x20>
    c2e8:	2301      	movs	r3, #1
{
    c2ea:	b510      	push	{r4, lr}
    c2ec:	4604      	mov	r4, r0
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
    c2ee:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
    c2f0:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
    c2f4:	f008 fcb4 	bl	14c60 <USB_HC_Halt>
  __HAL_UNLOCK(hhcd);
    c2f8:	2000      	movs	r0, #0
    c2fa:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return status;
}
    c2fe:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
    c300:	2002      	movs	r0, #2
}
    c302:	4770      	bx	lr

0000c304 <HAL_HCD_Init>:
  if (hhcd == NULL)
    c304:	2800      	cmp	r0, #0
    c306:	d057      	beq.n	c3b8 <HAL_HCD_Init+0xb4>
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    c308:	4b2c      	ldr	r3, [pc, #176]	; (c3bc <HAL_HCD_Init+0xb8>)
{
    c30a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    c30e:	6804      	ldr	r4, [r0, #0]
{
    c310:	b08a      	sub	sp, #40	; 0x28
    c312:	4607      	mov	r7, r0
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    c314:	429c      	cmp	r4, r3
    c316:	d008      	beq.n	c32a <HAL_HCD_Init+0x26>
    c318:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
    c31c:	429c      	cmp	r4, r3
    c31e:	d004      	beq.n	c32a <HAL_HCD_Init+0x26>
    c320:	217a      	movs	r1, #122	; 0x7a
    c322:	4827      	ldr	r0, [pc, #156]	; (c3c0 <HAL_HCD_Init+0xbc>)
    c324:	f00d f876 	bl	19414 <assert_failed>
    c328:	683c      	ldr	r4, [r7, #0]
  if (hhcd->State == HAL_HCD_STATE_RESET)
    c32a:	f897 32b9 	ldrb.w	r3, [r7, #697]	; 0x2b9
    c32e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    c332:	2b00      	cmp	r3, #0
    c334:	d039      	beq.n	c3aa <HAL_HCD_Init+0xa6>
    c336:	4620      	mov	r0, r4
  hhcd->State = HAL_HCD_STATE_BUSY;
    c338:	2303      	movs	r3, #3
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    c33a:	466d      	mov	r5, sp
    c33c:	f107 0804 	add.w	r8, r7, #4
  hhcd->State = HAL_HCD_STATE_BUSY;
    c340:	f887 32b9 	strb.w	r3, [r7, #697]	; 0x2b9
  if ((USBx->CID & (0x1U << 8)) == 0U)
    c344:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    c346:	463c      	mov	r4, r7
  if ((USBx->CID & (0x1U << 8)) == 0U)
    c348:	f413 7380 	ands.w	r3, r3, #256	; 0x100
    hhcd->Init.dma_enable = 0U;
    c34c:	bf08      	it	eq
    c34e:	613b      	streq	r3, [r7, #16]
  __HAL_HCD_DISABLE(hhcd);
    c350:	f008 fa2a 	bl	147a8 <USB_DisableGlobalInt>
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    c354:	f854 6b10 	ldr.w	r6, [r4], #16
    c358:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    c35a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c35c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    c35e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c360:	e894 0003 	ldmia.w	r4, {r0, r1}
    c364:	e885 0003 	stmia.w	r5, {r0, r1}
    c368:	4630      	mov	r0, r6
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
    c36a:	463e      	mov	r6, r7
    c36c:	466d      	mov	r5, sp
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    c36e:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
    c372:	f008 f9a7 	bl	146c4 <USB_CoreInit>
  (void)USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE);
    c376:	2101      	movs	r1, #1
    c378:	6838      	ldr	r0, [r7, #0]
    c37a:	f008 fa1d 	bl	147b8 <USB_SetCurrentMode>
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
    c37e:	f856 cb10 	ldr.w	ip, [r6], #16
    c382:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    c384:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c386:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    c388:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c38a:	e894 0003 	ldmia.w	r4, {r0, r1}
    c38e:	e885 0003 	stmia.w	r5, {r0, r1}
    c392:	4660      	mov	r0, ip
    c394:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
    c398:	f008 fa26 	bl	147e8 <USB_HostInit>
  hhcd->State = HAL_HCD_STATE_READY;
    c39c:	2301      	movs	r3, #1
  return HAL_OK;
    c39e:	2000      	movs	r0, #0
  hhcd->State = HAL_HCD_STATE_READY;
    c3a0:	f887 32b9 	strb.w	r3, [r7, #697]	; 0x2b9
}
    c3a4:	b00a      	add	sp, #40	; 0x28
    c3a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    HAL_HCD_MspInit(hhcd);
    c3aa:	4638      	mov	r0, r7
    hhcd->Lock = HAL_UNLOCKED;
    c3ac:	f887 22b8 	strb.w	r2, [r7, #696]	; 0x2b8
    HAL_HCD_MspInit(hhcd);
    c3b0:	f017 fad6 	bl	23960 <HAL_HCD_MspInit>
    c3b4:	6838      	ldr	r0, [r7, #0]
    c3b6:	e7bf      	b.n	c338 <HAL_HCD_Init+0x34>
    return HAL_ERROR;
    c3b8:	2001      	movs	r0, #1
}
    c3ba:	4770      	bx	lr
    c3bc:	40080000 	.word	0x40080000
    c3c0:	0002fd48 	.word	0x0002fd48

0000c3c4 <HAL_HCD_HC_SubmitRequest>:
                                           uint8_t ep_type,
                                           uint8_t token,
                                           uint8_t *pbuff,
                                           uint16_t length,
                                           uint8_t do_ping)
{
    c3c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    c3c6:	460c      	mov	r4, r1
  hhcd->hc[ch_num].ep_is_in = direction;
    c3c8:	0089      	lsls	r1, r1, #2
{
    c3ca:	f89d c014 	ldrb.w	ip, [sp, #20]
  hhcd->hc[ch_num].ep_is_in = direction;
    c3ce:	190d      	adds	r5, r1, r4
{
    c3d0:	9f06      	ldr	r7, [sp, #24]
    c3d2:	f8bd 601c 	ldrh.w	r6, [sp, #28]
  hhcd->hc[ch_num].ep_is_in = direction;
    c3d6:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
{
    c3da:	f89d e020 	ldrb.w	lr, [sp, #32]
  hhcd->hc[ch_num].ep_is_in = direction;
    c3de:	f885 203b 	strb.w	r2, [r5, #59]	; 0x3b
  hhcd->hc[ch_num].ep_type  = ep_type;
    c3e2:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f

  if (token == 0U)
    c3e6:	f1bc 0f00 	cmp.w	ip, #0
    c3ea:	d137      	bne.n	c45c <HAL_HCD_HC_SubmitRequest+0x98>
  {
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
    hhcd->hc[ch_num].do_ping = do_ping;
    c3ec:	f885 e03d 	strb.w	lr, [r5, #61]	; 0x3d
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
    c3f0:	f04f 0e03 	mov.w	lr, #3
    c3f4:	190d      	adds	r5, r1, r4
    c3f6:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
    c3fa:	f885 e042 	strb.w	lr, [r5, #66]	; 0x42
  {
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
  }

  /* Manage Data Toggle */
  switch (ep_type)
    c3fe:	2b03      	cmp	r3, #3
    c400:	d815      	bhi.n	c42e <HAL_HCD_HC_SubmitRequest+0x6a>
    c402:	e8df f003 	tbb	[pc, r3]
    c406:	3902      	.short	0x3902
    c408:	2e2e      	.short	0x2e2e
  {
    case EP_TYPE_CTRL:
      if ((token == 1U) && (direction == 0U)) /*send data */
    c40a:	f1bc 0f01 	cmp.w	ip, #1
    c40e:	d10e      	bne.n	c42e <HAL_HCD_HC_SubmitRequest+0x6a>
    c410:	b96a      	cbnz	r2, c42e <HAL_HCD_HC_SubmitRequest+0x6a>
      {
        if (length == 0U)
        {
          /* For Status OUT stage, Length==0, Status Out PID = 1 */
          hhcd->hc[ch_num].toggle_out = 1U;
    c412:	190b      	adds	r3, r1, r4
        if (length == 0U)
    c414:	2e00      	cmp	r6, #0
    c416:	d13e      	bne.n	c496 <HAL_HCD_HC_SubmitRequest+0xd2>
          hhcd->hc[ch_num].toggle_out = 1U;
    c418:	2201      	movs	r2, #1
    c41a:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    c41e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
        }
        else
        {
          /* Put the PID 1 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    c422:	190b      	adds	r3, r1, r4
    c424:	2202      	movs	r2, #2
    c426:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    c42a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    default:
      break;
  }

  hhcd->hc[ch_num].xfer_buff = pbuff;
    c42e:	190b      	adds	r3, r1, r4
  hhcd->hc[ch_num].urb_state = URB_IDLE;
  hhcd->hc[ch_num].xfer_count = 0U;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].state = HC_IDLE;

  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    c430:	2128      	movs	r1, #40	; 0x28
  hhcd->hc[ch_num].urb_state = URB_IDLE;
    c432:	2200      	movs	r2, #0
  hhcd->hc[ch_num].xfer_buff = pbuff;
    c434:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    c438:	fb01 0104 	mla	r1, r1, r4, r0
  hhcd->hc[ch_num].xfer_buff = pbuff;
    c43c:	645f      	str	r7, [r3, #68]	; 0x44
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    c43e:	3138      	adds	r1, #56	; 0x38
  hhcd->hc[ch_num].xfer_len  = length;
    c440:	649e      	str	r6, [r3, #72]	; 0x48
  hhcd->hc[ch_num].ch_num = ch_num;
    c442:	f883 4039 	strb.w	r4, [r3, #57]	; 0x39
  hhcd->hc[ch_num].urb_state = URB_IDLE;
    c446:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  hhcd->hc[ch_num].xfer_count = 0U;
    c44a:	64da      	str	r2, [r3, #76]	; 0x4c
  hhcd->hc[ch_num].state = HC_IDLE;
    c44c:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    c450:	7c02      	ldrb	r2, [r0, #16]
    c452:	6800      	ldr	r0, [r0, #0]
}
    c454:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    c458:	f008 bb48 	b.w	14aec <USB_HC_StartXfer>
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    c45c:	f04f 0e02 	mov.w	lr, #2
    c460:	e7c8      	b.n	c3f4 <HAL_HCD_HC_SubmitRequest+0x30>
        if (hhcd->hc[ch_num].toggle_out == 0U)
    c462:	190b      	adds	r3, r1, r4
    c464:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
      if (direction == 0U)
    c468:	b96a      	cbnz	r2, c486 <HAL_HCD_HC_SubmitRequest+0xc2>
        if (hhcd->hc[ch_num].toggle_out == 0U)
    c46a:	f893 5051 	ldrb.w	r5, [r3, #81]	; 0x51
    c46e:	b13d      	cbz	r5, c480 <HAL_HCD_HC_SubmitRequest+0xbc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    c470:	2202      	movs	r2, #2
    c472:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    c476:	e7da      	b.n	c42e <HAL_HCD_HC_SubmitRequest+0x6a>
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
    c478:	190b      	adds	r3, r1, r4
    c47a:	2200      	movs	r2, #0
    c47c:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    c480:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      break;
    c484:	e7d3      	b.n	c42e <HAL_HCD_HC_SubmitRequest+0x6a>
        if (hhcd->hc[ch_num].toggle_in == 0U)
    c486:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
    c48a:	2a00      	cmp	r2, #0
    c48c:	d0f8      	beq.n	c480 <HAL_HCD_HC_SubmitRequest+0xbc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    c48e:	2202      	movs	r2, #2
    c490:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    c494:	e7cb      	b.n	c42e <HAL_HCD_HC_SubmitRequest+0x6a>
        if (hhcd->hc[ch_num].toggle_out == 0U)
    c496:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    c49a:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
    c49e:	2a00      	cmp	r2, #0
    c4a0:	d0ee      	beq.n	c480 <HAL_HCD_HC_SubmitRequest+0xbc>
    c4a2:	e7be      	b.n	c422 <HAL_HCD_HC_SubmitRequest+0x5e>

0000c4a4 <HAL_HCD_Start>:
  * @brief  Start the host driver.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
{
    c4a4:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(hhcd);
    c4a6:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
    c4aa:	2b01      	cmp	r3, #1
    c4ac:	d00e      	beq.n	c4cc <HAL_HCD_Start+0x28>
    c4ae:	4604      	mov	r4, r0
    c4b0:	2501      	movs	r5, #1
  __HAL_HCD_ENABLE(hhcd);
    c4b2:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
    c4b4:	f884 52b8 	strb.w	r5, [r4, #696]	; 0x2b8
  __HAL_HCD_ENABLE(hhcd);
    c4b8:	f008 f96e 	bl	14798 <USB_EnableGlobalInt>
  (void)USB_DriveVbus(hhcd->Instance, 1U);
    c4bc:	4629      	mov	r1, r5
    c4be:	6820      	ldr	r0, [r4, #0]
    c4c0:	f008 fa42 	bl	14948 <USB_DriveVbus>
  __HAL_UNLOCK(hhcd);
    c4c4:	2000      	movs	r0, #0
    c4c6:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return HAL_OK;
}
    c4ca:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hhcd);
    c4cc:	2002      	movs	r0, #2
}
    c4ce:	bd38      	pop	{r3, r4, r5, pc}

0000c4d0 <HAL_HCD_Stop>:
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
{
  __HAL_LOCK(hhcd);
    c4d0:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
    c4d4:	2b01      	cmp	r3, #1
    c4d6:	d00b      	beq.n	c4f0 <HAL_HCD_Stop+0x20>
    c4d8:	2301      	movs	r3, #1
{
    c4da:	b510      	push	{r4, lr}
    c4dc:	4604      	mov	r4, r0
  (void)USB_StopHost(hhcd->Instance);
    c4de:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
    c4e0:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
  (void)USB_StopHost(hhcd->Instance);
    c4e4:	f008 fc14 	bl	14d10 <USB_StopHost>
  __HAL_UNLOCK(hhcd);
    c4e8:	2000      	movs	r0, #0
    c4ea:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return HAL_OK;
}
    c4ee:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
    c4f0:	2002      	movs	r0, #2
}
    c4f2:	4770      	bx	lr

0000c4f4 <HAL_HCD_ResetPort>:
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
{
  return (USB_ResetPort(hhcd->Instance));
    c4f4:	6800      	ldr	r0, [r0, #0]
    c4f6:	f008 ba07 	b.w	14908 <USB_ResetPort>
    c4fa:	bf00      	nop

0000c4fc <HAL_HCD_HC_GetURBState>:
  *            URB_ERROR/
  *            URB_STALL
  */
HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
  return hhcd->hc[chnum].urb_state;
    c4fc:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    c500:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
    c504:	f891 005c 	ldrb.w	r0, [r1, #92]	; 0x5c
    c508:	4770      	bx	lr
    c50a:	bf00      	nop

0000c50c <HAL_HCD_HC_GetXferCount>:
  *         This parameter can be a value from 1 to 15
  * @retval last transfer size in byte
  */
uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
  return hhcd->hc[chnum].xfer_count;
    c50c:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    c510:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
    c514:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
    c516:	4770      	bx	lr

0000c518 <HAL_HCD_GetCurrentFrame>:
  * @param  hhcd HCD handle
  * @retval Current Host frame number
  */
uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
{
  return (USB_GetCurrentFrame(hhcd->Instance));
    c518:	6800      	ldr	r0, [r0, #0]
    c51a:	f008 ba45 	b.w	149a8 <USB_GetCurrentFrame>
    c51e:	bf00      	nop

0000c520 <HAL_HCD_GetCurrentSpeed>:
  * @param  hhcd HCD handle
  * @retval Enumeration speed
  */
uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
{
  return (USB_GetHostSpeed(hhcd->Instance));
    c520:	6800      	ldr	r0, [r0, #0]
    c522:	f008 ba35 	b.w	14990 <USB_GetHostSpeed>
    c526:	bf00      	nop

0000c528 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
    c528:	b570      	push	{r4, r5, r6, lr}
    c52a:	4604      	mov	r4, r0
    c52c:	460d      	mov	r5, r1
    c52e:	4616      	mov	r6, r2
    c530:	1c6b      	adds	r3, r5, #1
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
    c532:	6822      	ldr	r2, [r4, #0]
    c534:	d12e      	bne.n	c594 <I2C_WaitOnTXISFlagUntilTimeout+0x6c>
    c536:	6993      	ldr	r3, [r2, #24]
    c538:	0798      	lsls	r0, r3, #30
    c53a:	d42e      	bmi.n	c59a <I2C_WaitOnTXISFlagUntilTimeout+0x72>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
    c53c:	6993      	ldr	r3, [r2, #24]
    c53e:	06d9      	lsls	r1, r3, #27
    c540:	d5f9      	bpl.n	c536 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    c542:	6993      	ldr	r3, [r2, #24]
    c544:	069d      	lsls	r5, r3, #26
    c546:	d5fc      	bpl.n	c542 <I2C_WaitOnTXISFlagUntilTimeout+0x1a>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    c548:	2310      	movs	r3, #16

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    c54a:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    c54c:	61d3      	str	r3, [r2, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    c54e:	6823      	ldr	r3, [r4, #0]
    c550:	61d9      	str	r1, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    c552:	6823      	ldr	r3, [r4, #0]
    c554:	699a      	ldr	r2, [r3, #24]
    c556:	0791      	lsls	r1, r2, #30
    c558:	d502      	bpl.n	c560 <I2C_WaitOnTXISFlagUntilTimeout+0x38>
    hi2c->Instance->TXDR = 0x00U;
    c55a:	2200      	movs	r2, #0
    c55c:	629a      	str	r2, [r3, #40]	; 0x28
    c55e:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    c560:	699a      	ldr	r2, [r3, #24]
    c562:	07d2      	lsls	r2, r2, #31
    c564:	d404      	bmi.n	c570 <I2C_WaitOnTXISFlagUntilTimeout+0x48>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    c566:	699a      	ldr	r2, [r3, #24]
    c568:	f042 0201 	orr.w	r2, r2, #1
    c56c:	619a      	str	r2, [r3, #24]
    c56e:	6823      	ldr	r3, [r4, #0]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
    c570:	685a      	ldr	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;
    c572:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
    c574:	4e1b      	ldr	r6, [pc, #108]	; (c5e4 <I2C_WaitOnTXISFlagUntilTimeout+0xbc>)
    hi2c->State = HAL_I2C_STATE_READY;
    c576:	2520      	movs	r5, #32
      return HAL_ERROR;
    c578:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
    c57a:	4032      	ands	r2, r6
    c57c:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    c57e:	6c63      	ldr	r3, [r4, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    c580:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    c584:	f043 0304 	orr.w	r3, r3, #4
    c588:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
    c58a:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
    c58e:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
    c592:	bd70      	pop	{r4, r5, r6, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
    c594:	6993      	ldr	r3, [r2, #24]
    c596:	079b      	lsls	r3, r3, #30
    c598:	d501      	bpl.n	c59e <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  return HAL_OK;
    c59a:	2000      	movs	r0, #0
}
    c59c:	bd70      	pop	{r4, r5, r6, pc}
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
    c59e:	6993      	ldr	r3, [r2, #24]
    c5a0:	06db      	lsls	r3, r3, #27
    c5a2:	d407      	bmi.n	c5b4 <I2C_WaitOnTXISFlagUntilTimeout+0x8c>
    c5a4:	e00a      	b.n	c5bc <I2C_WaitOnTXISFlagUntilTimeout+0x94>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c5a6:	f7fb ff25 	bl	83f4 <HAL_GetTick>
    c5aa:	1b80      	subs	r0, r0, r6
    c5ac:	4285      	cmp	r5, r0
    c5ae:	d30c      	bcc.n	c5ca <I2C_WaitOnTXISFlagUntilTimeout+0xa2>
    c5b0:	b15d      	cbz	r5, c5ca <I2C_WaitOnTXISFlagUntilTimeout+0xa2>
    c5b2:	6822      	ldr	r2, [r4, #0]
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    c5b4:	6993      	ldr	r3, [r2, #24]
    c5b6:	0698      	lsls	r0, r3, #26
    c5b8:	d5f5      	bpl.n	c5a6 <I2C_WaitOnTXISFlagUntilTimeout+0x7e>
    c5ba:	e7c5      	b.n	c548 <I2C_WaitOnTXISFlagUntilTimeout+0x20>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c5bc:	f7fb ff1a 	bl	83f4 <HAL_GetTick>
    c5c0:	1b80      	subs	r0, r0, r6
    c5c2:	42a8      	cmp	r0, r5
    c5c4:	d801      	bhi.n	c5ca <I2C_WaitOnTXISFlagUntilTimeout+0xa2>
    c5c6:	2d00      	cmp	r5, #0
    c5c8:	d1b2      	bne.n	c530 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c5ca:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    c5cc:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
    c5ce:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
    c5d0:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c5d2:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
    c5d4:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c5d8:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    c5da:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
    c5de:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    c5e2:	bd70      	pop	{r4, r5, r6, pc}
    c5e4:	fe00e800 	.word	0xfe00e800

0000c5e8 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
    c5e8:	b570      	push	{r4, r5, r6, lr}
    c5ea:	4604      	mov	r4, r0
    c5ec:	460d      	mov	r5, r1
    c5ee:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    c5f0:	6822      	ldr	r2, [r4, #0]
    c5f2:	6993      	ldr	r3, [r2, #24]
    c5f4:	069b      	lsls	r3, r3, #26
    c5f6:	d44d      	bmi.n	c694 <I2C_WaitOnSTOPFlagUntilTimeout+0xac>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
    c5f8:	6993      	ldr	r3, [r2, #24]
    c5fa:	06d9      	lsls	r1, r3, #27
    c5fc:	d52a      	bpl.n	c654 <I2C_WaitOnSTOPFlagUntilTimeout+0x6c>
    c5fe:	1c6b      	adds	r3, r5, #1
    c600:	d13c      	bne.n	c67c <I2C_WaitOnSTOPFlagUntilTimeout+0x94>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    c602:	6993      	ldr	r3, [r2, #24]
    c604:	069d      	lsls	r5, r3, #26
    c606:	d5fc      	bpl.n	c602 <I2C_WaitOnSTOPFlagUntilTimeout+0x1a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    c608:	2310      	movs	r3, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    c60a:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    c60c:	61d3      	str	r3, [r2, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    c60e:	6823      	ldr	r3, [r4, #0]
    c610:	61d9      	str	r1, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    c612:	6823      	ldr	r3, [r4, #0]
    c614:	699a      	ldr	r2, [r3, #24]
    c616:	0791      	lsls	r1, r2, #30
    c618:	d502      	bpl.n	c620 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
    hi2c->Instance->TXDR = 0x00U;
    c61a:	2200      	movs	r2, #0
    c61c:	629a      	str	r2, [r3, #40]	; 0x28
    c61e:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    c620:	699a      	ldr	r2, [r3, #24]
    c622:	07d2      	lsls	r2, r2, #31
    c624:	d404      	bmi.n	c630 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    c626:	699a      	ldr	r2, [r3, #24]
    c628:	f042 0201 	orr.w	r2, r2, #1
    c62c:	619a      	str	r2, [r3, #24]
    c62e:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
    c630:	685a      	ldr	r2, [r3, #4]
    hi2c->Mode = HAL_I2C_MODE_NONE;
    c632:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
    c634:	4e18      	ldr	r6, [pc, #96]	; (c698 <I2C_WaitOnSTOPFlagUntilTimeout+0xb0>)
    hi2c->State = HAL_I2C_STATE_READY;
    c636:	2520      	movs	r5, #32
      return HAL_ERROR;
    c638:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
    c63a:	4032      	ands	r2, r6
    c63c:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    c63e:	6c63      	ldr	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(hi2c);
    c640:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    c644:	f043 0304 	orr.w	r3, r3, #4
    c648:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
    c64a:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
    c64e:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
    c652:	bd70      	pop	{r4, r5, r6, pc}
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c654:	f7fb fece 	bl	83f4 <HAL_GetTick>
    c658:	1b80      	subs	r0, r0, r6
    c65a:	42a8      	cmp	r0, r5
    c65c:	d801      	bhi.n	c662 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
    c65e:	2d00      	cmp	r5, #0
    c660:	d1c6      	bne.n	c5f0 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c662:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    c664:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
    c666:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
    c668:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c66a:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
    c66c:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c670:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    c672:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
    c676:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    c67a:	bd70      	pop	{r4, r5, r6, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    c67c:	6993      	ldr	r3, [r2, #24]
    c67e:	0698      	lsls	r0, r3, #26
    c680:	d4c2      	bmi.n	c608 <I2C_WaitOnSTOPFlagUntilTimeout+0x20>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c682:	f7fb feb7 	bl	83f4 <HAL_GetTick>
    c686:	1b80      	subs	r0, r0, r6
    c688:	4285      	cmp	r5, r0
    c68a:	d3ea      	bcc.n	c662 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
    c68c:	2d00      	cmp	r5, #0
    c68e:	d0e8      	beq.n	c662 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
    c690:	6822      	ldr	r2, [r4, #0]
    c692:	e7b4      	b.n	c5fe <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
    c694:	2000      	movs	r0, #0
}
    c696:	bd70      	pop	{r4, r5, r6, pc}
    c698:	fe00e800 	.word	0xfe00e800

0000c69c <HAL_I2C_Init>:
  if (hi2c == NULL)
    c69c:	2800      	cmp	r0, #0
    c69e:	f000 80d2 	beq.w	c846 <HAL_I2C_Init+0x1aa>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c6a2:	496f      	ldr	r1, [pc, #444]	; (c860 <HAL_I2C_Init+0x1c4>)
{
    c6a4:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c6a6:	4b6f      	ldr	r3, [pc, #444]	; (c864 <HAL_I2C_Init+0x1c8>)
    c6a8:	4604      	mov	r4, r0
    c6aa:	6802      	ldr	r2, [r0, #0]
    c6ac:	486e      	ldr	r0, [pc, #440]	; (c868 <HAL_I2C_Init+0x1cc>)
    c6ae:	429a      	cmp	r2, r3
    c6b0:	bf18      	it	ne
    c6b2:	4282      	cmpne	r2, r0
    c6b4:	bf14      	ite	ne
    c6b6:	2301      	movne	r3, #1
    c6b8:	2300      	moveq	r3, #0
    c6ba:	428a      	cmp	r2, r1
    c6bc:	bf0c      	ite	eq
    c6be:	2300      	moveq	r3, #0
    c6c0:	f003 0301 	andne.w	r3, r3, #1
    c6c4:	b11b      	cbz	r3, c6ce <HAL_I2C_Init+0x32>
    c6c6:	4b69      	ldr	r3, [pc, #420]	; (c86c <HAL_I2C_Init+0x1d0>)
    c6c8:	429a      	cmp	r2, r3
    c6ca:	f040 80be 	bne.w	c84a <HAL_I2C_Init+0x1ae>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    c6ce:	68a3      	ldr	r3, [r4, #8]
    c6d0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    c6d4:	d271      	bcs.n	c7ba <HAL_I2C_Init+0x11e>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    c6d6:	68e3      	ldr	r3, [r4, #12]
    c6d8:	3b01      	subs	r3, #1
    c6da:	2b01      	cmp	r3, #1
    c6dc:	d85e      	bhi.n	c79c <HAL_I2C_Init+0x100>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    c6de:	6923      	ldr	r3, [r4, #16]
    c6e0:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
    c6e4:	d17c      	bne.n	c7e0 <HAL_I2C_Init+0x144>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    c6e6:	6963      	ldr	r3, [r4, #20]
    c6e8:	2bff      	cmp	r3, #255	; 0xff
    c6ea:	d870      	bhi.n	c7ce <HAL_I2C_Init+0x132>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    c6ec:	69a3      	ldr	r3, [r4, #24]
    c6ee:	2b07      	cmp	r3, #7
    c6f0:	f200 809e 	bhi.w	c830 <HAL_I2C_Init+0x194>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    c6f4:	69e3      	ldr	r3, [r4, #28]
    c6f6:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
    c6fa:	f040 808e 	bne.w	c81a <HAL_I2C_Init+0x17e>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    c6fe:	6a23      	ldr	r3, [r4, #32]
    c700:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
    c704:	d17c      	bne.n	c800 <HAL_I2C_Init+0x164>
  if (hi2c->State == HAL_I2C_STATE_RESET)
    c706:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    c70a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    c70e:	2b00      	cmp	r3, #0
    c710:	d070      	beq.n	c7f4 <HAL_I2C_Init+0x158>
  __HAL_I2C_DISABLE(hi2c);
    c712:	6822      	ldr	r2, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
    c714:	2324      	movs	r3, #36	; 0x24
    c716:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
    c71a:	6813      	ldr	r3, [r2, #0]
    c71c:	f023 0301 	bic.w	r3, r3, #1
    c720:	6013      	str	r3, [r2, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
    c722:	e9d4 2300 	ldrd	r2, r3, [r4]
    c726:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    c72a:	6113      	str	r3, [r2, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
    c72c:	6822      	ldr	r2, [r4, #0]
    c72e:	6893      	ldr	r3, [r2, #8]
    c730:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    c734:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
    c736:	68e3      	ldr	r3, [r4, #12]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    c738:	6822      	ldr	r2, [r4, #0]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
    c73a:	2b01      	cmp	r3, #1
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    c73c:	68a3      	ldr	r3, [r4, #8]
    c73e:	bf0c      	ite	eq
    c740:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
    c744:	f443 4304 	orrne.w	r3, r3, #33792	; 0x8400
    c748:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    c74a:	68e3      	ldr	r3, [r4, #12]
    c74c:	6825      	ldr	r5, [r4, #0]
    c74e:	2b02      	cmp	r3, #2
    c750:	d02e      	beq.n	c7b0 <HAL_I2C_Init+0x114>
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    c752:	6868      	ldr	r0, [r5, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    c754:	2200      	movs	r2, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    c756:	4b46      	ldr	r3, [pc, #280]	; (c870 <HAL_I2C_Init+0x1d4>)
  hi2c->State = HAL_I2C_STATE_READY;
    c758:	2120      	movs	r1, #32
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    c75a:	4303      	orrs	r3, r0
  return HAL_OK;
    c75c:	4610      	mov	r0, r2
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    c75e:	606b      	str	r3, [r5, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
    c760:	6825      	ldr	r5, [r4, #0]
    c762:	68eb      	ldr	r3, [r5, #12]
    c764:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    c768:	60eb      	str	r3, [r5, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
    c76a:	e9d4 3504 	ldrd	r3, r5, [r4, #16]
    c76e:	432b      	orrs	r3, r5
    c770:	69a5      	ldr	r5, [r4, #24]
    c772:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    c776:	6825      	ldr	r5, [r4, #0]
    c778:	60eb      	str	r3, [r5, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
    c77a:	e9d4 3507 	ldrd	r3, r5, [r4, #28]
    c77e:	432b      	orrs	r3, r5
    c780:	6825      	ldr	r5, [r4, #0]
    c782:	602b      	str	r3, [r5, #0]
  __HAL_I2C_ENABLE(hi2c);
    c784:	6825      	ldr	r5, [r4, #0]
    c786:	682b      	ldr	r3, [r5, #0]
    c788:	f043 0301 	orr.w	r3, r3, #1
    c78c:	602b      	str	r3, [r5, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    c78e:	6462      	str	r2, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
    c790:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
    c794:	6322      	str	r2, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
    c796:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    c79a:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    c79c:	f240 11e3 	movw	r1, #483	; 0x1e3
    c7a0:	4834      	ldr	r0, [pc, #208]	; (c874 <HAL_I2C_Init+0x1d8>)
    c7a2:	f00c fe37 	bl	19414 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    c7a6:	6923      	ldr	r3, [r4, #16]
    c7a8:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
    c7ac:	d09b      	beq.n	c6e6 <HAL_I2C_Init+0x4a>
    c7ae:	e017      	b.n	c7e0 <HAL_I2C_Init+0x144>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
    c7b0:	f44f 6300 	mov.w	r3, #2048	; 0x800
    c7b4:	606b      	str	r3, [r5, #4]
    c7b6:	6825      	ldr	r5, [r4, #0]
    c7b8:	e7cb      	b.n	c752 <HAL_I2C_Init+0xb6>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    c7ba:	f44f 71f1 	mov.w	r1, #482	; 0x1e2
    c7be:	482d      	ldr	r0, [pc, #180]	; (c874 <HAL_I2C_Init+0x1d8>)
    c7c0:	f00c fe28 	bl	19414 <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    c7c4:	68e3      	ldr	r3, [r4, #12]
    c7c6:	3b01      	subs	r3, #1
    c7c8:	2b01      	cmp	r3, #1
    c7ca:	d988      	bls.n	c6de <HAL_I2C_Init+0x42>
    c7cc:	e7e6      	b.n	c79c <HAL_I2C_Init+0x100>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    c7ce:	f240 11e5 	movw	r1, #485	; 0x1e5
    c7d2:	4828      	ldr	r0, [pc, #160]	; (c874 <HAL_I2C_Init+0x1d8>)
    c7d4:	f00c fe1e 	bl	19414 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    c7d8:	69a3      	ldr	r3, [r4, #24]
    c7da:	2b07      	cmp	r3, #7
    c7dc:	d98a      	bls.n	c6f4 <HAL_I2C_Init+0x58>
    c7de:	e027      	b.n	c830 <HAL_I2C_Init+0x194>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    c7e0:	f44f 71f2 	mov.w	r1, #484	; 0x1e4
    c7e4:	4823      	ldr	r0, [pc, #140]	; (c874 <HAL_I2C_Init+0x1d8>)
    c7e6:	f00c fe15 	bl	19414 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    c7ea:	6963      	ldr	r3, [r4, #20]
    c7ec:	2bff      	cmp	r3, #255	; 0xff
    c7ee:	f67f af7d 	bls.w	c6ec <HAL_I2C_Init+0x50>
    c7f2:	e7ec      	b.n	c7ce <HAL_I2C_Init+0x132>
    hi2c->Lock = HAL_UNLOCKED;
    c7f4:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
    c7f8:	4620      	mov	r0, r4
    c7fa:	f00c fbaf 	bl	18f5c <HAL_I2C_MspInit>
    c7fe:	e788      	b.n	c712 <HAL_I2C_Init+0x76>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    c800:	f44f 71f4 	mov.w	r1, #488	; 0x1e8
    c804:	481b      	ldr	r0, [pc, #108]	; (c874 <HAL_I2C_Init+0x1d8>)
    c806:	f00c fe05 	bl	19414 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_RESET)
    c80a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    c80e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    c812:	2b00      	cmp	r3, #0
    c814:	f47f af7d 	bne.w	c712 <HAL_I2C_Init+0x76>
    c818:	e7ec      	b.n	c7f4 <HAL_I2C_Init+0x158>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    c81a:	f240 11e7 	movw	r1, #487	; 0x1e7
    c81e:	4815      	ldr	r0, [pc, #84]	; (c874 <HAL_I2C_Init+0x1d8>)
    c820:	f00c fdf8 	bl	19414 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    c824:	6a23      	ldr	r3, [r4, #32]
    c826:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
    c82a:	f43f af6c 	beq.w	c706 <HAL_I2C_Init+0x6a>
    c82e:	e7e7      	b.n	c800 <HAL_I2C_Init+0x164>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    c830:	f44f 71f3 	mov.w	r1, #486	; 0x1e6
    c834:	480f      	ldr	r0, [pc, #60]	; (c874 <HAL_I2C_Init+0x1d8>)
    c836:	f00c fded 	bl	19414 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    c83a:	69e3      	ldr	r3, [r4, #28]
    c83c:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
    c840:	f43f af5d 	beq.w	c6fe <HAL_I2C_Init+0x62>
    c844:	e7e9      	b.n	c81a <HAL_I2C_Init+0x17e>
    return HAL_ERROR;
    c846:	2001      	movs	r0, #1
}
    c848:	4770      	bx	lr
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c84a:	f240 11e1 	movw	r1, #481	; 0x1e1
    c84e:	4809      	ldr	r0, [pc, #36]	; (c874 <HAL_I2C_Init+0x1d8>)
    c850:	f00c fde0 	bl	19414 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    c854:	68a3      	ldr	r3, [r4, #8]
    c856:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    c85a:	f4ff af3c 	bcc.w	c6d6 <HAL_I2C_Init+0x3a>
    c85e:	e7ac      	b.n	c7ba <HAL_I2C_Init+0x11e>
    c860:	40005c00 	.word	0x40005c00
    c864:	40005400 	.word	0x40005400
    c868:	40005800 	.word	0x40005800
    c86c:	58001c00 	.word	0x58001c00
    c870:	02008000 	.word	0x02008000
    c874:	0002fd80 	.word	0x0002fd80

0000c878 <HAL_I2C_Master_Transmit>:
{
    c878:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
    c87c:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
{
    c880:	9e08      	ldr	r6, [sp, #32]
  if (hi2c->State == HAL_I2C_STATE_READY)
    c882:	2c20      	cmp	r4, #32
    c884:	f040 80a1 	bne.w	c9ca <HAL_I2C_Master_Transmit+0x152>
    __HAL_LOCK(hi2c);
    c888:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
    c88c:	2c01      	cmp	r4, #1
    c88e:	f000 809c 	beq.w	c9ca <HAL_I2C_Master_Transmit+0x152>
    c892:	4698      	mov	r8, r3
    c894:	2301      	movs	r3, #1
    c896:	4691      	mov	r9, r2
    c898:	460f      	mov	r7, r1
    c89a:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
    c89e:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
    c8a0:	f7fb fda8 	bl	83f4 <HAL_GetTick>
    c8a4:	4605      	mov	r5, r0
    c8a6:	e005      	b.n	c8b4 <HAL_I2C_Master_Transmit+0x3c>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c8a8:	f7fb fda4 	bl	83f4 <HAL_GetTick>
    c8ac:	1b40      	subs	r0, r0, r5
    c8ae:	2819      	cmp	r0, #25
    c8b0:	f200 80a6 	bhi.w	ca00 <HAL_I2C_Master_Transmit+0x188>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    c8b4:	6823      	ldr	r3, [r4, #0]
    c8b6:	6998      	ldr	r0, [r3, #24]
    c8b8:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
    c8bc:	d1f4      	bne.n	c8a8 <HAL_I2C_Master_Transmit+0x30>
    c8be:	4a78      	ldr	r2, [pc, #480]	; (caa0 <HAL_I2C_Master_Transmit+0x228>)
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
    c8c0:	f04f 0c21 	mov.w	ip, #33	; 0x21
    c8c4:	4977      	ldr	r1, [pc, #476]	; (caa4 <HAL_I2C_Master_Transmit+0x22c>)
    c8c6:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
    c8ca:	4293      	cmp	r3, r2
    c8cc:	bf18      	it	ne
    c8ce:	428b      	cmpne	r3, r1
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
    c8d0:	f04f 0110 	mov.w	r1, #16
    c8d4:	f8df c1dc 	ldr.w	ip, [pc, #476]	; cab4 <HAL_I2C_Master_Transmit+0x23c>
    c8d8:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    c8dc:	bf14      	ite	ne
    c8de:	2201      	movne	r2, #1
    c8e0:	2200      	moveq	r2, #0
    c8e2:	4971      	ldr	r1, [pc, #452]	; (caa8 <HAL_I2C_Master_Transmit+0x230>)
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    c8e4:	6460      	str	r0, [r4, #68]	; 0x44
    c8e6:	428b      	cmp	r3, r1
    c8e8:	bf0c      	ite	eq
    c8ea:	2200      	moveq	r2, #0
    c8ec:	f002 0201 	andne.w	r2, r2, #1
    hi2c->XferCount = Size;
    c8f0:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    c8f4:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    c8f6:	4563      	cmp	r3, ip
    c8f8:	bf0c      	ite	eq
    c8fa:	2200      	moveq	r2, #0
    c8fc:	f002 0201 	andne.w	r2, r2, #1
    hi2c->pBuffPtr  = pData;
    c900:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    c904:	29ff      	cmp	r1, #255	; 0xff
    hi2c->XferISR   = NULL;
    c906:	6360      	str	r0, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    c908:	d862      	bhi.n	c9d0 <HAL_I2C_Master_Transmit+0x158>
      hi2c->XferSize = hi2c->XferCount;
    c90a:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    c90c:	b289      	uxth	r1, r1
    c90e:	8521      	strh	r1, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
    c910:	fa5f f881 	uxtb.w	r8, r1
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c914:	2a00      	cmp	r2, #0
    c916:	f040 80b5 	bne.w	ca84 <HAL_I2C_Master_Transmit+0x20c>
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    c91a:	f3c7 0709 	ubfx	r7, r7, #0, #10
    c91e:	4a63      	ldr	r2, [pc, #396]	; (caac <HAL_I2C_Master_Transmit+0x234>)
    c920:	6859      	ldr	r1, [r3, #4]
    c922:	433a      	orrs	r2, r7
    c924:	4862      	ldr	r0, [pc, #392]	; (cab0 <HAL_I2C_Master_Transmit+0x238>)
    c926:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
    c92a:	4001      	ands	r1, r0
    c92c:	430a      	orrs	r2, r1
    c92e:	605a      	str	r2, [r3, #4]
    c930:	f8df 8194 	ldr.w	r8, [pc, #404]	; cac8 <HAL_I2C_Master_Transmit+0x250>
    c934:	f8df 916c 	ldr.w	r9, [pc, #364]	; caa4 <HAL_I2C_Master_Transmit+0x22c>
    c938:	ea47 0808 	orr.w	r8, r7, r8
    while (hi2c->XferCount > 0U)
    c93c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    c93e:	462a      	mov	r2, r5
    c940:	4631      	mov	r1, r6
    c942:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
    c944:	b29b      	uxth	r3, r3
    c946:	2b00      	cmp	r3, #0
    c948:	d07b      	beq.n	ca42 <HAL_I2C_Master_Transmit+0x1ca>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    c94a:	f7ff fded 	bl	c528 <I2C_WaitOnTXISFlagUntilTimeout>
    c94e:	2800      	cmp	r0, #0
    c950:	d174      	bne.n	ca3c <HAL_I2C_Master_Transmit+0x1c4>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
    c952:	6a62      	ldr	r2, [r4, #36]	; 0x24
    c954:	6823      	ldr	r3, [r4, #0]
    c956:	7812      	ldrb	r2, [r2, #0]
    c958:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
    c95a:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    c95c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
    c95e:	3901      	subs	r1, #1
      hi2c->pBuffPtr++;
    c960:	6a62      	ldr	r2, [r4, #36]	; 0x24
      hi2c->XferSize--;
    c962:	3b01      	subs	r3, #1
      hi2c->XferCount--;
    c964:	b289      	uxth	r1, r1
      hi2c->pBuffPtr++;
    c966:	3201      	adds	r2, #1
      hi2c->XferSize--;
    c968:	b29b      	uxth	r3, r3
      hi2c->XferCount--;
    c96a:	8561      	strh	r1, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    c96c:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    c96e:	8523      	strh	r3, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    c970:	b289      	uxth	r1, r1
      hi2c->pBuffPtr++;
    c972:	6262      	str	r2, [r4, #36]	; 0x24
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    c974:	2b00      	cmp	r3, #0
    c976:	d1e1      	bne.n	c93c <HAL_I2C_Master_Transmit+0xc4>
    c978:	2900      	cmp	r1, #0
    c97a:	d0df      	beq.n	c93c <HAL_I2C_Master_Transmit+0xc4>
    c97c:	1c70      	adds	r0, r6, #1
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    c97e:	6822      	ldr	r2, [r4, #0]
    c980:	d134      	bne.n	c9ec <HAL_I2C_Master_Transmit+0x174>
    c982:	6993      	ldr	r3, [r2, #24]
    c984:	0619      	lsls	r1, r3, #24
    c986:	d5fc      	bpl.n	c982 <HAL_I2C_Master_Transmit+0x10a>
    c988:	4b4a      	ldr	r3, [pc, #296]	; (cab4 <HAL_I2C_Master_Transmit+0x23c>)
    c98a:	4947      	ldr	r1, [pc, #284]	; (caa8 <HAL_I2C_Master_Transmit+0x230>)
    c98c:	454a      	cmp	r2, r9
    c98e:	bf18      	it	ne
    c990:	429a      	cmpne	r2, r3
    c992:	4843      	ldr	r0, [pc, #268]	; (caa0 <HAL_I2C_Master_Transmit+0x228>)
    c994:	bf14      	ite	ne
    c996:	2301      	movne	r3, #1
    c998:	2300      	moveq	r3, #0
    c99a:	428a      	cmp	r2, r1
    c99c:	bf0c      	ite	eq
    c99e:	2300      	moveq	r3, #0
    c9a0:	f003 0301 	andne.w	r3, r3, #1
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
    c9a4:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    c9a6:	4282      	cmp	r2, r0
    c9a8:	bf0c      	ite	eq
    c9aa:	2300      	moveq	r3, #0
    c9ac:	f003 0301 	andne.w	r3, r3, #1
    c9b0:	29ff      	cmp	r1, #255	; 0xff
    c9b2:	d933      	bls.n	ca1c <HAL_I2C_Master_Transmit+0x1a4>
          hi2c->XferSize = MAX_NBYTE_SIZE;
    c9b4:	21ff      	movs	r1, #255	; 0xff
    c9b6:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c9b8:	2b00      	cmp	r3, #0
    c9ba:	d155      	bne.n	ca68 <HAL_I2C_Master_Transmit+0x1f0>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    c9bc:	6853      	ldr	r3, [r2, #4]
    c9be:	493e      	ldr	r1, [pc, #248]	; (cab8 <HAL_I2C_Master_Transmit+0x240>)
    c9c0:	400b      	ands	r3, r1
    c9c2:	ea43 0308 	orr.w	r3, r3, r8
    c9c6:	6053      	str	r3, [r2, #4]
    c9c8:	e7b8      	b.n	c93c <HAL_I2C_Master_Transmit+0xc4>
    return HAL_BUSY;
    c9ca:	2002      	movs	r0, #2
}
    c9cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hi2c->XferSize = MAX_NBYTE_SIZE;
    c9d0:	21ff      	movs	r1, #255	; 0xff
    c9d2:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c9d4:	2a00      	cmp	r2, #0
    c9d6:	d15c      	bne.n	ca92 <HAL_I2C_Master_Transmit+0x21a>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    c9d8:	685a      	ldr	r2, [r3, #4]
    c9da:	f3c7 0709 	ubfx	r7, r7, #0, #10
    c9de:	4937      	ldr	r1, [pc, #220]	; (cabc <HAL_I2C_Master_Transmit+0x244>)
    c9e0:	4833      	ldr	r0, [pc, #204]	; (cab0 <HAL_I2C_Master_Transmit+0x238>)
    c9e2:	4339      	orrs	r1, r7
    c9e4:	4002      	ands	r2, r0
    c9e6:	430a      	orrs	r2, r1
    c9e8:	605a      	str	r2, [r3, #4]
    c9ea:	e7a1      	b.n	c930 <HAL_I2C_Master_Transmit+0xb8>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    c9ec:	6993      	ldr	r3, [r2, #24]
    c9ee:	061b      	lsls	r3, r3, #24
    c9f0:	d4ca      	bmi.n	c988 <HAL_I2C_Master_Transmit+0x110>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c9f2:	f7fb fcff 	bl	83f4 <HAL_GetTick>
    c9f6:	1b40      	subs	r0, r0, r5
    c9f8:	4286      	cmp	r6, r0
    c9fa:	d301      	bcc.n	ca00 <HAL_I2C_Master_Transmit+0x188>
    c9fc:	2e00      	cmp	r6, #0
    c9fe:	d1bd      	bne.n	c97c <HAL_I2C_Master_Transmit+0x104>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    ca00:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    ca02:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
    ca04:	2200      	movs	r2, #0
          return HAL_ERROR;
    ca06:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    ca08:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
    ca0a:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    ca0e:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    ca10:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
    ca14:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    ca18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          hi2c->XferSize = hi2c->XferCount;
    ca1c:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    ca1e:	b289      	uxth	r1, r1
    ca20:	8521      	strh	r1, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
    ca22:	fa5f fa81 	uxtb.w	sl, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ca26:	bb33      	cbnz	r3, ca76 <HAL_I2C_Master_Transmit+0x1fe>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    ca28:	6851      	ldr	r1, [r2, #4]
    ca2a:	ea47 430a 	orr.w	r3, r7, sl, lsl #16
    ca2e:	4822      	ldr	r0, [pc, #136]	; (cab8 <HAL_I2C_Master_Transmit+0x240>)
    ca30:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    ca34:	4001      	ands	r1, r0
    ca36:	430b      	orrs	r3, r1
    ca38:	6053      	str	r3, [r2, #4]
    ca3a:	e77f      	b.n	c93c <HAL_I2C_Master_Transmit+0xc4>
        return HAL_ERROR;
    ca3c:	2001      	movs	r0, #1
}
    ca3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    ca42:	f7ff fdd1 	bl	c5e8 <I2C_WaitOnSTOPFlagUntilTimeout>
    ca46:	2800      	cmp	r0, #0
    ca48:	d1f8      	bne.n	ca3c <HAL_I2C_Master_Transmit+0x1c4>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    ca4a:	6823      	ldr	r3, [r4, #0]
    ca4c:	2220      	movs	r2, #32
    I2C_RESET_CR2(hi2c);
    ca4e:	4d1c      	ldr	r5, [pc, #112]	; (cac0 <HAL_I2C_Master_Transmit+0x248>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    ca50:	61da      	str	r2, [r3, #28]
    I2C_RESET_CR2(hi2c);
    ca52:	6821      	ldr	r1, [r4, #0]
    ca54:	684b      	ldr	r3, [r1, #4]
    ca56:	402b      	ands	r3, r5
    ca58:	604b      	str	r3, [r1, #4]
    hi2c->State = HAL_I2C_STATE_READY;
    ca5a:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    ca5e:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
    ca62:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
    ca66:	e7b1      	b.n	c9cc <HAL_I2C_Master_Transmit+0x154>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ca68:	f641 1131 	movw	r1, #6449	; 0x1931
    ca6c:	4815      	ldr	r0, [pc, #84]	; (cac4 <HAL_I2C_Master_Transmit+0x24c>)
    ca6e:	f00c fcd1 	bl	19414 <assert_failed>
    ca72:	6822      	ldr	r2, [r4, #0]
    ca74:	e7a2      	b.n	c9bc <HAL_I2C_Master_Transmit+0x144>
    ca76:	f641 1131 	movw	r1, #6449	; 0x1931
    ca7a:	4812      	ldr	r0, [pc, #72]	; (cac4 <HAL_I2C_Master_Transmit+0x24c>)
    ca7c:	f00c fcca 	bl	19414 <assert_failed>
    ca80:	6822      	ldr	r2, [r4, #0]
    ca82:	e7d1      	b.n	ca28 <HAL_I2C_Master_Transmit+0x1b0>
    ca84:	f641 1131 	movw	r1, #6449	; 0x1931
    ca88:	480e      	ldr	r0, [pc, #56]	; (cac4 <HAL_I2C_Master_Transmit+0x24c>)
    ca8a:	f00c fcc3 	bl	19414 <assert_failed>
    ca8e:	6823      	ldr	r3, [r4, #0]
    ca90:	e743      	b.n	c91a <HAL_I2C_Master_Transmit+0xa2>
    ca92:	f641 1131 	movw	r1, #6449	; 0x1931
    ca96:	480b      	ldr	r0, [pc, #44]	; (cac4 <HAL_I2C_Master_Transmit+0x24c>)
    ca98:	f00c fcbc 	bl	19414 <assert_failed>
    ca9c:	6823      	ldr	r3, [r4, #0]
    ca9e:	e79b      	b.n	c9d8 <HAL_I2C_Master_Transmit+0x160>
    caa0:	40005c00 	.word	0x40005c00
    caa4:	40005400 	.word	0x40005400
    caa8:	40005800 	.word	0x40005800
    caac:	82002000 	.word	0x82002000
    cab0:	fc009800 	.word	0xfc009800
    cab4:	58001c00 	.word	0x58001c00
    cab8:	fc009c00 	.word	0xfc009c00
    cabc:	81ff2000 	.word	0x81ff2000
    cac0:	fe00e800 	.word	0xfe00e800
    cac4:	0002fd80 	.word	0x0002fd80
    cac8:	01ff0000 	.word	0x01ff0000

0000cacc <HAL_I2C_Master_Transmit_DMA>:
{
    cacc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
    cad0:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
    cad4:	2c20      	cmp	r4, #32
    cad6:	d148      	bne.n	cb6a <HAL_I2C_Master_Transmit_DMA+0x9e>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
    cad8:	6807      	ldr	r7, [r0, #0]
    cada:	69bd      	ldr	r5, [r7, #24]
    cadc:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
    cae0:	d143      	bne.n	cb6a <HAL_I2C_Master_Transmit_DMA+0x9e>
    __HAL_LOCK(hi2c);
    cae2:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
    cae6:	2c01      	cmp	r4, #1
    cae8:	d03f      	beq.n	cb6a <HAL_I2C_Master_Transmit_DMA+0x9e>
    caea:	4604      	mov	r4, r0
    caec:	460e      	mov	r6, r1
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
    caee:	f04f 0c21 	mov.w	ip, #33	; 0x21
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
    caf2:	2110      	movs	r1, #16
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    caf4:	4868      	ldr	r0, [pc, #416]	; (cc98 <HAL_I2C_Master_Transmit_DMA+0x1cc>)
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
    caf6:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
    cafa:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    __HAL_LOCK(hi2c);
    cafe:	2101      	movs	r1, #1
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    cb00:	6465      	str	r5, [r4, #68]	; 0x44
    hi2c->XferCount   = Size;
    cb02:	8563      	strh	r3, [r4, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    cb04:	62e0      	str	r0, [r4, #44]	; 0x2c
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    cb06:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->XferISR     = I2C_Master_ISR_DMA;
    cb08:	f8df 81c0 	ldr.w	r8, [pc, #448]	; cccc <HAL_I2C_Master_Transmit_DMA+0x200>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    cb0c:	2bff      	cmp	r3, #255	; 0xff
    hi2c->pBuffPtr    = pData;
    cb0e:	6262      	str	r2, [r4, #36]	; 0x24
    __HAL_LOCK(hi2c);
    cb10:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->XferISR     = I2C_Master_ISR_DMA;
    cb14:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    cb18:	d92b      	bls.n	cb72 <HAL_I2C_Master_Transmit_DMA+0xa6>
    cb1a:	23ff      	movs	r3, #255	; 0xff
      xfermode = I2C_RELOAD_MODE;
    cb1c:	f04f 7980 	mov.w	r9, #16777216	; 0x1000000
    cb20:	8523      	strh	r3, [r4, #40]	; 0x28
      if (hi2c->hdmatx != NULL)
    cb22:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cb24:	2b00      	cmp	r3, #0
    cb26:	d058      	beq.n	cbda <HAL_I2C_Master_Transmit_DMA+0x10e>
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
    cb28:	4d5c      	ldr	r5, [pc, #368]	; (cc9c <HAL_I2C_Master_Transmit_DMA+0x1d0>)
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
    cb2a:	2700      	movs	r7, #0
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
    cb2c:	485c      	ldr	r0, [pc, #368]	; (cca0 <HAL_I2C_Master_Transmit_DMA+0x1d4>)
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
    cb2e:	4611      	mov	r1, r2
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
    cb30:	63dd      	str	r5, [r3, #60]	; 0x3c
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
    cb32:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cb34:	64d8      	str	r0, [r3, #76]	; 0x4c
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
    cb36:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cb38:	641f      	str	r7, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
    cb3a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cb3c:	651f      	str	r7, [r3, #80]	; 0x50
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
    cb3e:	6822      	ldr	r2, [r4, #0]
    cb40:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    cb42:	3228      	adds	r2, #40	; 0x28
    cb44:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    cb46:	f7fd ffc9 	bl	aadc <HAL_DMA_Start_IT>
      if (dmaxferstatus == HAL_OK)
    cb4a:	4605      	mov	r5, r0
    cb4c:	2800      	cmp	r0, #0
    cb4e:	d05b      	beq.n	cc08 <HAL_I2C_Master_Transmit_DMA+0x13c>
        hi2c->State     = HAL_I2C_STATE_READY;
    cb50:	2320      	movs	r3, #32
        __HAL_UNLOCK(hi2c);
    cb52:	f884 7040 	strb.w	r7, [r4, #64]	; 0x40
        return HAL_ERROR;
    cb56:	2501      	movs	r5, #1
        hi2c->State     = HAL_I2C_STATE_READY;
    cb58:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
    cb5c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
    cb60:	6c63      	ldr	r3, [r4, #68]	; 0x44
    cb62:	f043 0310 	orr.w	r3, r3, #16
    cb66:	6463      	str	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
    cb68:	e000      	b.n	cb6c <HAL_I2C_Master_Transmit_DMA+0xa0>
    return HAL_BUSY;
    cb6a:	2502      	movs	r5, #2
}
    cb6c:	4628      	mov	r0, r5
    cb6e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      hi2c->XferSize = hi2c->XferCount;
    cb72:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    cb74:	b29b      	uxth	r3, r3
    cb76:	8523      	strh	r3, [r4, #40]	; 0x28
    if (hi2c->XferSize > 0U)
    cb78:	2b00      	cmp	r3, #0
    cb7a:	d13b      	bne.n	cbf4 <HAL_I2C_Master_Transmit_DMA+0x128>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cb7c:	4b49      	ldr	r3, [pc, #292]	; (cca4 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
    cb7e:	4a4a      	ldr	r2, [pc, #296]	; (cca8 <HAL_I2C_Master_Transmit_DMA+0x1dc>)
    cb80:	494a      	ldr	r1, [pc, #296]	; (ccac <HAL_I2C_Master_Transmit_DMA+0x1e0>)
    cb82:	429f      	cmp	r7, r3
    cb84:	bf18      	it	ne
    cb86:	4297      	cmpne	r7, r2
      hi2c->XferISR = I2C_Master_ISR_IT;
    cb88:	4a49      	ldr	r2, [pc, #292]	; (ccb0 <HAL_I2C_Master_Transmit_DMA+0x1e4>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cb8a:	bf14      	ite	ne
    cb8c:	2301      	movne	r3, #1
    cb8e:	2300      	moveq	r3, #0
      hi2c->XferISR = I2C_Master_ISR_IT;
    cb90:	6362      	str	r2, [r4, #52]	; 0x34
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cb92:	428f      	cmp	r7, r1
    cb94:	bf0c      	ite	eq
    cb96:	2300      	moveq	r3, #0
    cb98:	f003 0301 	andne.w	r3, r3, #1
    cb9c:	b113      	cbz	r3, cba4 <HAL_I2C_Master_Transmit_DMA+0xd8>
    cb9e:	4b45      	ldr	r3, [pc, #276]	; (ccb4 <HAL_I2C_Master_Transmit_DMA+0x1e8>)
    cba0:	429f      	cmp	r7, r3
    cba2:	d12a      	bne.n	cbfa <HAL_I2C_Master_Transmit_DMA+0x12e>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    cba4:	f3c6 0109 	ubfx	r1, r6, #0, #10
    cba8:	4b43      	ldr	r3, [pc, #268]	; (ccb8 <HAL_I2C_Master_Transmit_DMA+0x1ec>)
    cbaa:	687a      	ldr	r2, [r7, #4]
      __HAL_UNLOCK(hi2c);
    cbac:	2000      	movs	r0, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    cbae:	430b      	orrs	r3, r1
    cbb0:	4942      	ldr	r1, [pc, #264]	; (ccbc <HAL_I2C_Master_Transmit_DMA+0x1f0>)
    cbb2:	400a      	ands	r2, r1
    cbb4:	4313      	orrs	r3, r2
    cbb6:	607b      	str	r3, [r7, #4]
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
  uint32_t tmpisr = 0U;

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cbb8:	6b63      	ldr	r3, [r4, #52]	; 0x34
      __HAL_UNLOCK(hi2c);
    cbba:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cbbe:	4543      	cmp	r3, r8
    cbc0:	d004      	beq.n	cbcc <HAL_I2C_Master_Transmit_DMA+0x100>
    cbc2:	4a3f      	ldr	r2, [pc, #252]	; (ccc0 <HAL_I2C_Master_Transmit_DMA+0x1f4>)
    cbc4:	4293      	cmp	r3, r2
    cbc6:	d001      	beq.n	cbcc <HAL_I2C_Master_Transmit_DMA+0x100>
    cbc8:	21f2      	movs	r1, #242	; 0xf2
    cbca:	e000      	b.n	cbce <HAL_I2C_Master_Transmit_DMA+0x102>
    cbcc:	2100      	movs	r1, #0
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    cbce:	6822      	ldr	r2, [r4, #0]
    return HAL_OK;
    cbd0:	2500      	movs	r5, #0
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    cbd2:	6813      	ldr	r3, [r2, #0]
    cbd4:	430b      	orrs	r3, r1
    cbd6:	6013      	str	r3, [r2, #0]
    cbd8:	e7c8      	b.n	cb6c <HAL_I2C_Master_Transmit_DMA+0xa0>
        hi2c->State     = HAL_I2C_STATE_READY;
    cbda:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
    cbdc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        return HAL_ERROR;
    cbe0:	2501      	movs	r5, #1
        hi2c->State     = HAL_I2C_STATE_READY;
    cbe2:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
    cbe6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
    cbea:	6c63      	ldr	r3, [r4, #68]	; 0x44
    cbec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    cbf0:	6463      	str	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
    cbf2:	e7bb      	b.n	cb6c <HAL_I2C_Master_Transmit_DMA+0xa0>
      xfermode = I2C_AUTOEND_MODE;
    cbf4:	f04f 7900 	mov.w	r9, #33554432	; 0x2000000
    cbf8:	e793      	b.n	cb22 <HAL_I2C_Master_Transmit_DMA+0x56>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cbfa:	f641 1131 	movw	r1, #6449	; 0x1931
    cbfe:	4831      	ldr	r0, [pc, #196]	; (ccc4 <HAL_I2C_Master_Transmit_DMA+0x1f8>)
    cc00:	f00c fc08 	bl	19414 <assert_failed>
    cc04:	6827      	ldr	r7, [r4, #0]
    cc06:	e7cd      	b.n	cba4 <HAL_I2C_Master_Transmit_DMA+0xd8>
    cc08:	4b26      	ldr	r3, [pc, #152]	; (cca4 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
    cc0a:	6822      	ldr	r2, [r4, #0]
    cc0c:	4826      	ldr	r0, [pc, #152]	; (cca8 <HAL_I2C_Master_Transmit_DMA+0x1dc>)
    cc0e:	4927      	ldr	r1, [pc, #156]	; (ccac <HAL_I2C_Master_Transmit_DMA+0x1e0>)
    cc10:	429a      	cmp	r2, r3
    cc12:	bf18      	it	ne
    cc14:	4282      	cmpne	r2, r0
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
    cc16:	f894 7028 	ldrb.w	r7, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cc1a:	bf14      	ite	ne
    cc1c:	2301      	movne	r3, #1
    cc1e:	2300      	moveq	r3, #0
    cc20:	428a      	cmp	r2, r1
    cc22:	bf0c      	ite	eq
    cc24:	2300      	moveq	r3, #0
    cc26:	f003 0301 	andne.w	r3, r3, #1
    cc2a:	b113      	cbz	r3, cc32 <HAL_I2C_Master_Transmit_DMA+0x166>
    cc2c:	4b21      	ldr	r3, [pc, #132]	; (ccb4 <HAL_I2C_Master_Transmit_DMA+0x1e8>)
    cc2e:	429a      	cmp	r2, r3
    cc30:	d12a      	bne.n	cc88 <HAL_I2C_Master_Transmit_DMA+0x1bc>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    cc32:	f3c6 0109 	ubfx	r1, r6, #0, #10
    cc36:	4b24      	ldr	r3, [pc, #144]	; (ccc8 <HAL_I2C_Master_Transmit_DMA+0x1fc>)
    cc38:	6856      	ldr	r6, [r2, #4]
        __HAL_UNLOCK(hi2c);
    cc3a:	2000      	movs	r0, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    cc3c:	430b      	orrs	r3, r1
    cc3e:	491f      	ldr	r1, [pc, #124]	; (ccbc <HAL_I2C_Master_Transmit_DMA+0x1f0>)
    cc40:	400e      	ands	r6, r1
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cc42:	491f      	ldr	r1, [pc, #124]	; (ccc0 <HAL_I2C_Master_Transmit_DMA+0x1f4>)
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    cc44:	4333      	orrs	r3, r6
    cc46:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
    cc4a:	ea43 0309 	orr.w	r3, r3, r9
    cc4e:	6053      	str	r3, [r2, #4]
        hi2c->XferCount -= hi2c->XferSize;
    cc50:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
    cc52:	8d26      	ldrh	r6, [r4, #40]	; 0x28
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cc54:	6b63      	ldr	r3, [r4, #52]	; 0x34
        hi2c->XferCount -= hi2c->XferSize;
    cc56:	1b92      	subs	r2, r2, r6
        __HAL_UNLOCK(hi2c);
    cc58:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cc5c:	428b      	cmp	r3, r1
        hi2c->XferCount -= hi2c->XferSize;
    cc5e:	b292      	uxth	r2, r2
    cc60:	8562      	strh	r2, [r4, #42]	; 0x2a
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cc62:	d00f      	beq.n	cc84 <HAL_I2C_Master_Transmit_DMA+0x1b8>
    cc64:	eba3 0308 	sub.w	r3, r3, r8
    cc68:	fab3 f383 	clz	r3, r3
    cc6c:	095b      	lsrs	r3, r3, #5
    cc6e:	b94b      	cbnz	r3, cc84 <HAL_I2C_Master_Transmit_DMA+0x1b8>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    cc70:	6821      	ldr	r1, [r4, #0]
    cc72:	680a      	ldr	r2, [r1, #0]
    cc74:	4313      	orrs	r3, r2
    cc76:	600b      	str	r3, [r1, #0]
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
    cc78:	6822      	ldr	r2, [r4, #0]
    cc7a:	6813      	ldr	r3, [r2, #0]
    cc7c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    cc80:	6013      	str	r3, [r2, #0]
    cc82:	e773      	b.n	cb6c <HAL_I2C_Master_Transmit_DMA+0xa0>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cc84:	2390      	movs	r3, #144	; 0x90
    cc86:	e7f3      	b.n	cc70 <HAL_I2C_Master_Transmit_DMA+0x1a4>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cc88:	f641 1131 	movw	r1, #6449	; 0x1931
    cc8c:	480d      	ldr	r0, [pc, #52]	; (ccc4 <HAL_I2C_Master_Transmit_DMA+0x1f8>)
    cc8e:	f00c fbc1 	bl	19414 <assert_failed>
    cc92:	6822      	ldr	r2, [r4, #0]
    cc94:	e7cd      	b.n	cc32 <HAL_I2C_Master_Transmit_DMA+0x166>
    cc96:	bf00      	nop
    cc98:	ffff0000 	.word	0xffff0000
    cc9c:	0000d4c1 	.word	0x0000d4c1
    cca0:	0000dd45 	.word	0x0000dd45
    cca4:	40005400 	.word	0x40005400
    cca8:	40005800 	.word	0x40005800
    ccac:	40005c00 	.word	0x40005c00
    ccb0:	0000d7cd 	.word	0x0000d7cd
    ccb4:	58001c00 	.word	0x58001c00
    ccb8:	82002000 	.word	0x82002000
    ccbc:	fc009800 	.word	0xfc009800
    ccc0:	0000d2f5 	.word	0x0000d2f5
    ccc4:	0002fd80 	.word	0x0002fd80
    ccc8:	80002000 	.word	0x80002000
    cccc:	0000daa1 	.word	0x0000daa1

0000ccd0 <HAL_I2C_MasterTxCpltCallback>:
    ccd0:	4770      	bx	lr
    ccd2:	bf00      	nop

0000ccd4 <HAL_I2C_MasterRxCpltCallback>:
    ccd4:	4770      	bx	lr
    ccd6:	bf00      	nop

0000ccd8 <HAL_I2C_SlaveTxCpltCallback>:
    ccd8:	4770      	bx	lr
    ccda:	bf00      	nop

0000ccdc <HAL_I2C_SlaveRxCpltCallback>:
    ccdc:	4770      	bx	lr
    ccde:	bf00      	nop

0000cce0 <I2C_ITSlaveSeqCplt>:
{
    cce0:	b538      	push	{r3, r4, r5, lr}
    cce2:	4603      	mov	r3, r0
  hi2c->Mode = HAL_I2C_MODE_NONE;
    cce4:	2000      	movs	r0, #0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
    cce6:	681a      	ldr	r2, [r3, #0]
    cce8:	6811      	ldr	r1, [r2, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
    ccea:	f883 0042 	strb.w	r0, [r3, #66]	; 0x42
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
    ccee:	0448      	lsls	r0, r1, #17
    ccf0:	d50c      	bpl.n	cd0c <I2C_ITSlaveSeqCplt+0x2c>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    ccf2:	6811      	ldr	r1, [r2, #0]
    ccf4:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
    ccf8:	6011      	str	r1, [r2, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
    ccfa:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    ccfe:	2a29      	cmp	r2, #41	; 0x29
    cd00:	d00e      	beq.n	cd20 <I2C_ITSlaveSeqCplt+0x40>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
    cd02:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    cd06:	2a2a      	cmp	r2, #42	; 0x2a
    cd08:	d024      	beq.n	cd54 <I2C_ITSlaveSeqCplt+0x74>
}
    cd0a:	bd38      	pop	{r3, r4, r5, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
    cd0c:	0409      	lsls	r1, r1, #16
    cd0e:	d5f4      	bpl.n	ccfa <I2C_ITSlaveSeqCplt+0x1a>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    cd10:	6811      	ldr	r1, [r2, #0]
    cd12:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
    cd16:	6011      	str	r1, [r2, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
    cd18:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    cd1c:	2a29      	cmp	r2, #41	; 0x29
    cd1e:	d1f0      	bne.n	cd02 <I2C_ITSlaveSeqCplt+0x22>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    cd20:	2128      	movs	r1, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
    cd22:	2221      	movs	r2, #33	; 0x21
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd24:	681c      	ldr	r4, [r3, #0]
    __HAL_UNLOCK(hi2c);
    cd26:	2500      	movs	r5, #0
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    cd28:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    HAL_I2C_SlaveTxCpltCallback(hi2c);
    cd2c:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
    cd2e:	631a      	str	r2, [r3, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cd30:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd34:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cd36:	f001 0128 	and.w	r1, r1, #40	; 0x28
    cd3a:	2928      	cmp	r1, #40	; 0x28
    cd3c:	bf14      	ite	ne
    cd3e:	f06f 01f2 	mvnne.w	r1, #242	; 0xf2
    cd42:	f06f 0142 	mvneq.w	r1, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd46:	400a      	ands	r2, r1
    cd48:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
    cd4a:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
    cd4e:	f7ff ffc3 	bl	ccd8 <HAL_I2C_SlaveTxCpltCallback>
}
    cd52:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    cd54:	2128      	movs	r1, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    cd56:	2222      	movs	r2, #34	; 0x22
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd58:	681c      	ldr	r4, [r3, #0]
    __HAL_UNLOCK(hi2c);
    cd5a:	2500      	movs	r5, #0
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    cd5c:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    cd60:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    cd62:	631a      	str	r2, [r3, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cd64:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd68:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cd6a:	f001 0128 	and.w	r1, r1, #40	; 0x28
    cd6e:	2928      	cmp	r1, #40	; 0x28
    cd70:	bf14      	ite	ne
    cd72:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
    cd76:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd7a:	400a      	ands	r2, r1
    cd7c:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
    cd7e:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    cd82:	f7ff ffab 	bl	ccdc <HAL_I2C_SlaveRxCpltCallback>
}
    cd86:	bd38      	pop	{r3, r4, r5, pc}

0000cd88 <HAL_I2C_AddrCallback>:
}
    cd88:	4770      	bx	lr
    cd8a:	bf00      	nop

0000cd8c <I2C_ITAddrCplt.isra.9.part.10>:
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
    cd8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    transferdirection = I2C_GET_DIR(hi2c);
    cd8e:	6804      	ldr	r4, [r0, #0]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    cd90:	68c3      	ldr	r3, [r0, #12]
    transferdirection = I2C_GET_DIR(hi2c);
    cd92:	69a1      	ldr	r1, [r4, #24]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
    cd94:	69a2      	ldr	r2, [r4, #24]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    cd96:	2b02      	cmp	r3, #2
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
    cd98:	68a6      	ldr	r6, [r4, #8]
    transferdirection = I2C_GET_DIR(hi2c);
    cd9a:	f3c1 4100 	ubfx	r1, r1, #16, #1
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
    cd9e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
    cda2:	68e7      	ldr	r7, [r4, #12]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
    cda4:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    cda8:	d10d      	bne.n	cdc6 <I2C_ITAddrCplt.isra.9.part.10+0x3a>
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
    cdaa:	f3c6 0609 	ubfx	r6, r6, #0, #10
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
    cdae:	ea82 13d6 	eor.w	r3, r2, r6, lsr #7
    cdb2:	f013 0306 	ands.w	r3, r3, #6
    cdb6:	d110      	bne.n	cdda <I2C_ITAddrCplt.isra.9.part.10+0x4e>
        hi2c->AddrEventCount++;
    cdb8:	6c82      	ldr	r2, [r0, #72]	; 0x48
    cdba:	3201      	adds	r2, #1
    cdbc:	6482      	str	r2, [r0, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
    cdbe:	6c82      	ldr	r2, [r0, #72]	; 0x48
    cdc0:	2a02      	cmp	r2, #2
    cdc2:	d016      	beq.n	cdf2 <I2C_ITAddrCplt.isra.9.part.10+0x66>
}
    cdc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cdc6:	6823      	ldr	r3, [r4, #0]
      __HAL_UNLOCK(hi2c);
    cdc8:	2600      	movs	r6, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cdca:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
    cdce:	6023      	str	r3, [r4, #0]
      __HAL_UNLOCK(hi2c);
    cdd0:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    cdd4:	f7ff ffd8 	bl	cd88 <HAL_I2C_AddrCallback>
}
    cdd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cdda:	6823      	ldr	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
    cddc:	2600      	movs	r6, #0
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    cdde:	f007 02fe 	and.w	r2, r7, #254	; 0xfe
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cde2:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
    cde6:	6023      	str	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
    cde8:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    cdec:	f7ff ffcc 	bl	cd88 <HAL_I2C_AddrCallback>
}
    cdf0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    cdf2:	2708      	movs	r7, #8
          hi2c->AddrEventCount = 0U;
    cdf4:	6483      	str	r3, [r0, #72]	; 0x48
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    cdf6:	4632      	mov	r2, r6
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    cdf8:	61e7      	str	r7, [r4, #28]
          __HAL_UNLOCK(hi2c);
    cdfa:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    cdfe:	f7ff ffc3 	bl	cd88 <HAL_I2C_AddrCallback>
}
    ce02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000ce04 <HAL_I2C_ListenCpltCallback>:
    ce04:	4770      	bx	lr
    ce06:	bf00      	nop

0000ce08 <HAL_I2C_MemTxCpltCallback>:
    ce08:	4770      	bx	lr
    ce0a:	bf00      	nop

0000ce0c <HAL_I2C_MemRxCpltCallback>:
    ce0c:	4770      	bx	lr
    ce0e:	bf00      	nop

0000ce10 <HAL_I2C_ErrorCallback>:
    ce10:	4770      	bx	lr
    ce12:	bf00      	nop

0000ce14 <HAL_I2C_AbortCpltCallback>:
    ce14:	4770      	bx	lr
    ce16:	bf00      	nop

0000ce18 <I2C_DMAAbort>:
{
    ce18:	b508      	push	{r3, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
    ce1a:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if (hi2c->hdmatx != NULL)
    ce1c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    ce1e:	b10a      	cbz	r2, ce24 <I2C_DMAAbort+0xc>
    hi2c->hdmatx->XferAbortCallback = NULL;
    ce20:	2100      	movs	r1, #0
    ce22:	6511      	str	r1, [r2, #80]	; 0x50
  if (hi2c->hdmarx != NULL)
    ce24:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    ce26:	b10a      	cbz	r2, ce2c <I2C_DMAAbort+0x14>
    hi2c->hdmarx->XferAbortCallback = NULL;
    ce28:	2100      	movs	r1, #0
    ce2a:	6511      	str	r1, [r2, #80]	; 0x50
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    ce2c:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    ce30:	2a60      	cmp	r2, #96	; 0x60
    ce32:	d007      	beq.n	ce44 <I2C_DMAAbort+0x2c>
    hi2c->PreviousState = I2C_STATE_NONE;
    ce34:	2200      	movs	r2, #0
    HAL_I2C_ErrorCallback(hi2c);
    ce36:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_NONE;
    ce38:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    ce3a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    ce3e:	f7ff ffe7 	bl	ce10 <HAL_I2C_ErrorCallback>
}
    ce42:	bd08      	pop	{r3, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
    ce44:	2200      	movs	r2, #0
    hi2c->State = HAL_I2C_STATE_READY;
    ce46:	2120      	movs	r1, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    ce48:	4618      	mov	r0, r3
    hi2c->State = HAL_I2C_STATE_READY;
    ce4a:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    ce4e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    ce52:	631a      	str	r2, [r3, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    ce54:	f7ff ffde 	bl	ce14 <HAL_I2C_AbortCpltCallback>
}
    ce58:	bd08      	pop	{r3, pc}
    ce5a:	bf00      	nop

0000ce5c <I2C_ITError>:
{
    ce5c:	b570      	push	{r4, r5, r6, lr}
    ce5e:	4604      	mov	r4, r0
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    ce60:	2200      	movs	r2, #0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    ce62:	484c      	ldr	r0, [pc, #304]	; (cf94 <I2C_ITError+0x138>)
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    ce64:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    ce68:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    ce6c:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    ce6e:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->XferCount     = 0U;
    ce70:	8562      	strh	r2, [r4, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
    ce72:	6c62      	ldr	r2, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    ce74:	2b02      	cmp	r3, #2
    ce76:	6820      	ldr	r0, [r4, #0]
  hi2c->ErrorCode |= ErrorCode;
    ce78:	ea41 0102 	orr.w	r1, r1, r2
    ce7c:	6461      	str	r1, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    ce7e:	d830      	bhi.n	cee2 <I2C_ITError+0x86>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce80:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    ce84:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce86:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce8a:	4032      	ands	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    ce8c:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce8e:	4031      	ands	r1, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    ce90:	4d41      	ldr	r5, [pc, #260]	; (cf98 <I2C_ITError+0x13c>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce92:	42b2      	cmp	r2, r6
    ce94:	bf14      	ite	ne
    ce96:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
    ce9a:	f06f 0246 	mvneq.w	r2, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce9e:	42b1      	cmp	r1, r6
    cea0:	bf18      	it	ne
    cea2:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cea6:	4013      	ands	r3, r2
    cea8:	6003      	str	r3, [r0, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    ceaa:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    ceae:	6365      	str	r5, [r4, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    ceb0:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
    ceb2:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    ceb4:	b118      	cbz	r0, cebe <I2C_ITError+0x62>
    ceb6:	2b11      	cmp	r3, #17
    ceb8:	d025      	beq.n	cf06 <I2C_ITError+0xaa>
    ceba:	2b21      	cmp	r3, #33	; 0x21
    cebc:	d023      	beq.n	cf06 <I2C_ITError+0xaa>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
    cebe:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    cec0:	b118      	cbz	r0, ceca <I2C_ITError+0x6e>
    cec2:	2b12      	cmp	r3, #18
    cec4:	d037      	beq.n	cf36 <I2C_ITError+0xda>
    cec6:	2b22      	cmp	r3, #34	; 0x22
    cec8:	d035      	beq.n	cf36 <I2C_ITError+0xda>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    ceca:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    cece:	2b60      	cmp	r3, #96	; 0x60
    ced0:	d054      	beq.n	cf7c <I2C_ITError+0x120>
    hi2c->PreviousState = I2C_STATE_NONE;
    ced2:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
    ced4:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
    ced6:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    ced8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    cedc:	f7ff ff98 	bl	ce10 <HAL_I2C_ErrorCallback>
}
    cee0:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cee2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cee6:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    ceea:	6803      	ldr	r3, [r0, #0]
    ceec:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    cef0:	6003      	str	r3, [r0, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
    cef2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    cef6:	2b60      	cmp	r3, #96	; 0x60
    cef8:	d002      	beq.n	cf00 <I2C_ITError+0xa4>
      hi2c->State         = HAL_I2C_STATE_READY;
    cefa:	2320      	movs	r3, #32
    cefc:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    cf00:	2300      	movs	r3, #0
    cf02:	6363      	str	r3, [r4, #52]	; 0x34
    cf04:	e7d4      	b.n	ceb0 <I2C_ITError+0x54>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
    cf06:	6823      	ldr	r3, [r4, #0]
    cf08:	681a      	ldr	r2, [r3, #0]
    cf0a:	0451      	lsls	r1, r2, #17
    cf0c:	d430      	bmi.n	cf70 <I2C_ITError+0x114>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
    cf0e:	f7fe f9f9 	bl	b304 <HAL_DMA_GetState>
    cf12:	2801      	cmp	r0, #1
    cf14:	d0d9      	beq.n	ceca <I2C_ITError+0x6e>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    cf16:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
    cf18:	2300      	movs	r3, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    cf1a:	4920      	ldr	r1, [pc, #128]	; (cf9c <I2C_ITError+0x140>)
    cf1c:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    cf1e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
    cf22:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    cf24:	f7fe f8b4 	bl	b090 <HAL_DMA_Abort_IT>
    cf28:	2800      	cmp	r0, #0
    cf2a:	d0d9      	beq.n	cee0 <I2C_ITError+0x84>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    cf2c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
    cf2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    cf32:	6d03      	ldr	r3, [r0, #80]	; 0x50
    cf34:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
    cf36:	6823      	ldr	r3, [r4, #0]
    cf38:	681a      	ldr	r2, [r3, #0]
    cf3a:	0412      	lsls	r2, r2, #16
    cf3c:	d504      	bpl.n	cf48 <I2C_ITError+0xec>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    cf3e:	681a      	ldr	r2, [r3, #0]
    cf40:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    cf44:	601a      	str	r2, [r3, #0]
    cf46:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
    cf48:	f7fe f9dc 	bl	b304 <HAL_DMA_GetState>
    cf4c:	2801      	cmp	r0, #1
    cf4e:	d0bc      	beq.n	ceca <I2C_ITError+0x6e>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    cf50:	6be2      	ldr	r2, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
    cf52:	2300      	movs	r3, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    cf54:	4911      	ldr	r1, [pc, #68]	; (cf9c <I2C_ITError+0x140>)
    cf56:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    cf58:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
    cf5c:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    cf5e:	f7fe f897 	bl	b090 <HAL_DMA_Abort_IT>
    cf62:	2800      	cmp	r0, #0
    cf64:	d0bc      	beq.n	cee0 <I2C_ITError+0x84>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    cf66:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
    cf68:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    cf6c:	6d03      	ldr	r3, [r0, #80]	; 0x50
    cf6e:	4718      	bx	r3
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    cf70:	681a      	ldr	r2, [r3, #0]
    cf72:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    cf76:	601a      	str	r2, [r3, #0]
    cf78:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    cf7a:	e7c8      	b.n	cf0e <I2C_ITError+0xb2>
    hi2c->PreviousState = I2C_STATE_NONE;
    cf7c:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
    cf7e:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    cf80:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
    cf82:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    cf86:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    cf8a:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    cf8c:	f7ff ff42 	bl	ce14 <HAL_I2C_AbortCpltCallback>
}
    cf90:	bd70      	pop	{r4, r5, r6, pc}
    cf92:	bf00      	nop
    cf94:	ffff0000 	.word	0xffff0000
    cf98:	0000d14d 	.word	0x0000d14d
    cf9c:	0000ce19 	.word	0x0000ce19

0000cfa0 <I2C_ITSlaveCplt>:
{
    cfa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    cfa2:	4604      	mov	r4, r0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
    cfa4:	6802      	ldr	r2, [r0, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    cfa6:	2620      	movs	r6, #32
{
    cfa8:	460d      	mov	r5, r1
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
    cfaa:	6810      	ldr	r0, [r2, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    cfac:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    cfb0:	61d6      	str	r6, [r2, #28]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
    cfb2:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cfb6:	6821      	ldr	r1, [r4, #0]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
    cfb8:	2b21      	cmp	r3, #33	; 0x21
    cfba:	d165      	bne.n	d088 <I2C_ITSlaveCplt+0xe8>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cfbc:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cfc0:	680a      	ldr	r2, [r1, #0]
    cfc2:	f022 02fa 	bic.w	r2, r2, #250	; 0xfa
    cfc6:	600a      	str	r2, [r1, #0]
    cfc8:	6821      	ldr	r1, [r4, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
    cfca:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    cfcc:	684a      	ldr	r2, [r1, #4]
  I2C_RESET_CR2(hi2c);
    cfce:	4e5d      	ldr	r6, [pc, #372]	; (d144 <I2C_ITSlaveCplt+0x1a4>)
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    cfd0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    cfd4:	604a      	str	r2, [r1, #4]
  I2C_RESET_CR2(hi2c);
    cfd6:	6822      	ldr	r2, [r4, #0]
    cfd8:	6853      	ldr	r3, [r2, #4]
    cfda:	4033      	ands	r3, r6
    cfdc:	6053      	str	r3, [r2, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    cfde:	6823      	ldr	r3, [r4, #0]
    cfe0:	699a      	ldr	r2, [r3, #24]
    cfe2:	0792      	lsls	r2, r2, #30
    cfe4:	d502      	bpl.n	cfec <I2C_ITSlaveCplt+0x4c>
    hi2c->Instance->TXDR = 0x00U;
    cfe6:	2200      	movs	r2, #0
    cfe8:	629a      	str	r2, [r3, #40]	; 0x28
    cfea:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    cfec:	699a      	ldr	r2, [r3, #24]
    cfee:	07d7      	lsls	r7, r2, #31
    cff0:	d403      	bmi.n	cffa <I2C_ITSlaveCplt+0x5a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    cff2:	699a      	ldr	r2, [r3, #24]
    cff4:	f042 0201 	orr.w	r2, r2, #1
    cff8:	619a      	str	r2, [r3, #24]
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
    cffa:	0446      	lsls	r6, r0, #17
    cffc:	d539      	bpl.n	d072 <I2C_ITSlaveCplt+0xd2>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    cffe:	6822      	ldr	r2, [r4, #0]
    d000:	6813      	ldr	r3, [r2, #0]
    d002:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    d006:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmatx != NULL)
    d008:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d00a:	b11b      	cbz	r3, d014 <I2C_ITSlaveCplt+0x74>
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
    d00c:	681a      	ldr	r2, [r3, #0]
    d00e:	6853      	ldr	r3, [r2, #4]
    d010:	b29b      	uxth	r3, r3
    d012:	8563      	strh	r3, [r4, #42]	; 0x2a
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
    d014:	0769      	lsls	r1, r5, #29
    d016:	d50b      	bpl.n	d030 <I2C_ITSlaveCplt+0x90>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d018:	6822      	ldr	r2, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
    d01a:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d01e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d020:	6a52      	ldr	r2, [r2, #36]	; 0x24
    d022:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    d024:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d026:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    d028:	3301      	adds	r3, #1
    d02a:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d02c:	2a00      	cmp	r2, #0
    d02e:	d144      	bne.n	d0ba <I2C_ITSlaveCplt+0x11a>
  if (hi2c->XferCount != 0U)
    d030:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d032:	b29b      	uxth	r3, r3
    d034:	b11b      	cbz	r3, d03e <I2C_ITSlaveCplt+0x9e>
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d036:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d038:	f043 0304 	orr.w	r3, r3, #4
    d03c:	6463      	str	r3, [r4, #68]	; 0x44
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d03e:	2700      	movs	r7, #0
    d040:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
    d044:	6c66      	ldr	r6, [r4, #68]	; 0x44
  hi2c->XferISR = NULL;
    d046:	6367      	str	r7, [r4, #52]	; 0x34
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
    d048:	2e00      	cmp	r6, #0
    d04a:	d13d      	bne.n	d0c8 <I2C_ITSlaveCplt+0x128>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    d04c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d04e:	4d3e      	ldr	r5, [pc, #248]	; (d148 <I2C_ITSlaveCplt+0x1a8>)
    d050:	42ab      	cmp	r3, r5
    d052:	d124      	bne.n	d09e <I2C_ITSlaveCplt+0xfe>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    d054:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    d058:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
    d05a:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    d05e:	2b22      	cmp	r3, #34	; 0x22
    hi2c->State = HAL_I2C_STATE_READY;
    d060:	f04f 0320 	mov.w	r3, #32
    d064:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
    d068:	6326      	str	r6, [r4, #48]	; 0x30
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    d06a:	d066      	beq.n	d13a <I2C_ITSlaveCplt+0x19a>
    HAL_I2C_SlaveTxCpltCallback(hi2c);
    d06c:	f7ff fe34 	bl	ccd8 <HAL_I2C_SlaveTxCpltCallback>
}
    d070:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
    d072:	0400      	lsls	r0, r0, #16
    d074:	d5ce      	bpl.n	d014 <I2C_ITSlaveCplt+0x74>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    d076:	6822      	ldr	r2, [r4, #0]
    d078:	6813      	ldr	r3, [r2, #0]
    d07a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    d07e:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmarx != NULL)
    d080:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    d082:	2b00      	cmp	r3, #0
    d084:	d1c2      	bne.n	d00c <I2C_ITSlaveCplt+0x6c>
    d086:	e7c5      	b.n	d014 <I2C_ITSlaveCplt+0x74>
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
    d088:	2b22      	cmp	r3, #34	; 0x22
    d08a:	d19f      	bne.n	cfcc <I2C_ITSlaveCplt+0x2c>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d08c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d090:	680a      	ldr	r2, [r1, #0]
    d092:	f022 02fc 	bic.w	r2, r2, #252	; 0xfc
    d096:	600a      	str	r2, [r1, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    d098:	6323      	str	r3, [r4, #48]	; 0x30
    d09a:	6821      	ldr	r1, [r4, #0]
    d09c:	e796      	b.n	cfcc <I2C_ITSlaveCplt+0x2c>
    I2C_ITSlaveSeqCplt(hi2c);
    d09e:	4620      	mov	r0, r4
    d0a0:	f7ff fe1e 	bl	cce0 <I2C_ITSlaveSeqCplt>
    hi2c->State = HAL_I2C_STATE_READY;
    d0a4:	2320      	movs	r3, #32
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d0a6:	62e5      	str	r5, [r4, #44]	; 0x2c
    HAL_I2C_ListenCpltCallback(hi2c);
    d0a8:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
    d0aa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    d0ae:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    d0b2:	6326      	str	r6, [r4, #48]	; 0x30
    HAL_I2C_ListenCpltCallback(hi2c);
    d0b4:	f7ff fea6 	bl	ce04 <HAL_I2C_ListenCpltCallback>
}
    d0b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hi2c->XferCount--;
    d0ba:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d0bc:	3a01      	subs	r2, #1
      hi2c->XferCount--;
    d0be:	3b01      	subs	r3, #1
      hi2c->XferSize--;
    d0c0:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d0c2:	b29b      	uxth	r3, r3
    d0c4:	8563      	strh	r3, [r4, #42]	; 0x2a
    d0c6:	e7b3      	b.n	d030 <I2C_ITSlaveCplt+0x90>
    I2C_ITError(hi2c, hi2c->ErrorCode);
    d0c8:	6c61      	ldr	r1, [r4, #68]	; 0x44
    d0ca:	4620      	mov	r0, r4
    d0cc:	f7ff fec6 	bl	ce5c <I2C_ITError>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
    d0d0:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d0d4:	2b28      	cmp	r3, #40	; 0x28
    d0d6:	d1cb      	bne.n	d070 <I2C_ITSlaveCplt+0xd0>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d0d8:	4b1b      	ldr	r3, [pc, #108]	; (d148 <I2C_ITSlaveCplt+0x1a8>)
  hi2c->State = HAL_I2C_STATE_READY;
    d0da:	2220      	movs	r2, #32
  hi2c->XferISR = NULL;
    d0dc:	6367      	str	r7, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d0de:	62e3      	str	r3, [r4, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
    d0e0:	6327      	str	r7, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
    d0e2:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d0e6:	076a      	lsls	r2, r5, #29
    d0e8:	6823      	ldr	r3, [r4, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d0ea:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d0ee:	d512      	bpl.n	d116 <I2C_ITSlaveCplt+0x176>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d0f0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    d0f2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d0f4:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    d0f6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d0f8:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    d0fa:	3301      	adds	r3, #1
    d0fc:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d0fe:	b1fa      	cbz	r2, d140 <I2C_ITSlaveCplt+0x1a0>
      hi2c->XferCount--;
    d100:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d102:	3a01      	subs	r2, #1
    d104:	6823      	ldr	r3, [r4, #0]
      hi2c->XferCount--;
    d106:	3901      	subs	r1, #1
      hi2c->XferSize--;
    d108:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d10a:	b28a      	uxth	r2, r1
    d10c:	8562      	strh	r2, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d10e:	6c62      	ldr	r2, [r4, #68]	; 0x44
    d110:	f042 0204 	orr.w	r2, r2, #4
    d114:	6462      	str	r2, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d116:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d11a:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d11c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
    d120:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d122:	681a      	ldr	r2, [r3, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
    d124:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d126:	f022 02fe 	bic.w	r2, r2, #254	; 0xfe
    d12a:	601a      	str	r2, [r3, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d12c:	6823      	ldr	r3, [r4, #0]
    d12e:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
    d130:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
    d134:	f7ff fe66 	bl	ce04 <HAL_I2C_ListenCpltCallback>
}
    d138:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    d13a:	f7ff fdcf 	bl	ccdc <HAL_I2C_SlaveRxCpltCallback>
}
    d13e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d140:	6823      	ldr	r3, [r4, #0]
    d142:	e7e8      	b.n	d116 <I2C_ITSlaveCplt+0x176>
    d144:	fe00e800 	.word	0xfe00e800
    d148:	ffff0000 	.word	0xffff0000

0000d14c <I2C_Slave_ISR_IT>:
{
    d14c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
    d14e:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
    d152:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
    d154:	2b01      	cmp	r3, #1
    d156:	d07f      	beq.n	d258 <I2C_Slave_ISR_IT+0x10c>
    d158:	4616      	mov	r6, r2
    d15a:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    d15c:	068a      	lsls	r2, r1, #26
    d15e:	4604      	mov	r4, r0
    d160:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
    d162:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    d166:	d501      	bpl.n	d16c <I2C_Slave_ISR_IT+0x20>
    d168:	06b3      	lsls	r3, r6, #26
    d16a:	d462      	bmi.n	d232 <I2C_Slave_ISR_IT+0xe6>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d16c:	06ea      	lsls	r2, r5, #27
    d16e:	d51b      	bpl.n	d1a8 <I2C_Slave_ISR_IT+0x5c>
    d170:	06f3      	lsls	r3, r6, #27
    d172:	d519      	bpl.n	d1a8 <I2C_Slave_ISR_IT+0x5c>
    if (hi2c->XferCount == 0U)
    d174:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d176:	6822      	ldr	r2, [r4, #0]
    d178:	b29b      	uxth	r3, r3
    d17a:	2b00      	cmp	r3, #0
    d17c:	d15e      	bne.n	d23c <I2C_Slave_ISR_IT+0xf0>
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
    d17e:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    d182:	2928      	cmp	r1, #40	; 0x28
    d184:	d102      	bne.n	d18c <I2C_Slave_ISR_IT+0x40>
    d186:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    d18a:	d07a      	beq.n	d282 <I2C_Slave_ISR_IT+0x136>
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    d18c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d190:	2b29      	cmp	r3, #41	; 0x29
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d192:	f04f 0310 	mov.w	r3, #16
    d196:	61d3      	str	r3, [r2, #28]
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    d198:	d102      	bne.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d19a:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
    d19e:	d161      	bne.n	d264 <I2C_Slave_ISR_IT+0x118>
  __HAL_UNLOCK(hi2c);
    d1a0:	2000      	movs	r0, #0
    d1a2:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    d1a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    d1a8:	076a      	lsls	r2, r5, #29
    d1aa:	d40e      	bmi.n	d1ca <I2C_Slave_ISR_IT+0x7e>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
    d1ac:	0728      	lsls	r0, r5, #28
    d1ae:	d52a      	bpl.n	d206 <I2C_Slave_ISR_IT+0xba>
    d1b0:	0731      	lsls	r1, r6, #28
    d1b2:	d528      	bpl.n	d206 <I2C_Slave_ISR_IT+0xba>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
    d1b4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d1b8:	f003 0328 	and.w	r3, r3, #40	; 0x28
    d1bc:	2b28      	cmp	r3, #40	; 0x28
    d1be:	f000 8090 	beq.w	d2e2 <I2C_Slave_ISR_IT+0x196>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    d1c2:	6823      	ldr	r3, [r4, #0]
    d1c4:	2208      	movs	r2, #8
    d1c6:	61da      	str	r2, [r3, #28]
    d1c8:	e7ea      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    d1ca:	0773      	lsls	r3, r6, #29
    d1cc:	d5ee      	bpl.n	d1ac <I2C_Slave_ISR_IT+0x60>
    if (hi2c->XferCount > 0U)
    d1ce:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d1d0:	b29b      	uxth	r3, r3
    d1d2:	b16b      	cbz	r3, d1f0 <I2C_Slave_ISR_IT+0xa4>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d1d4:	6822      	ldr	r2, [r4, #0]
    d1d6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d1d8:	6a52      	ldr	r2, [r2, #36]	; 0x24
    d1da:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
    d1dc:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
    d1de:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
    d1e0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d1e2:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
    d1e4:	3101      	adds	r1, #1
      hi2c->XferCount--;
    d1e6:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
    d1e8:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
    d1ea:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
    d1ec:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d1ee:	8522      	strh	r2, [r4, #40]	; 0x28
    if ((hi2c->XferCount == 0U) && \
    d1f0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d1f2:	b29b      	uxth	r3, r3
    d1f4:	2b00      	cmp	r3, #0
    d1f6:	d1d3      	bne.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d1f8:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
    d1fc:	d0d0      	beq.n	d1a0 <I2C_Slave_ISR_IT+0x54>
        I2C_ITSlaveSeqCplt(hi2c);
    d1fe:	4620      	mov	r0, r4
    d200:	f7ff fd6e 	bl	cce0 <I2C_ITSlaveSeqCplt>
    d204:	e7cc      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
    d206:	07aa      	lsls	r2, r5, #30
    d208:	d5ca      	bpl.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d20a:	07b3      	lsls	r3, r6, #30
    d20c:	d5c8      	bpl.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    if (hi2c->XferCount > 0U)
    d20e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d210:	b29b      	uxth	r3, r3
    d212:	b31b      	cbz	r3, d25c <I2C_Slave_ISR_IT+0x110>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
    d214:	6a62      	ldr	r2, [r4, #36]	; 0x24
    d216:	6823      	ldr	r3, [r4, #0]
    d218:	7812      	ldrb	r2, [r2, #0]
    d21a:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
    d21c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
    d21e:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
    d220:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d222:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
    d224:	3101      	adds	r1, #1
      hi2c->XferCount--;
    d226:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
    d228:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
    d22a:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
    d22c:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d22e:	8522      	strh	r2, [r4, #40]	; 0x28
    d230:	e7b6      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
    d232:	f7ff feb5 	bl	cfa0 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d236:	06ea      	lsls	r2, r5, #27
    d238:	d5b6      	bpl.n	d1a8 <I2C_Slave_ISR_IT+0x5c>
    d23a:	e799      	b.n	d170 <I2C_Slave_ISR_IT+0x24>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d23c:	2310      	movs	r3, #16
    d23e:	61d3      	str	r3, [r2, #28]
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d240:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d242:	f043 0304 	orr.w	r3, r3, #4
    d246:	6463      	str	r3, [r4, #68]	; 0x44
      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
    d248:	f037 7380 	bics.w	r3, r7, #16777216	; 0x1000000
    d24c:	d1a8      	bne.n	d1a0 <I2C_Slave_ISR_IT+0x54>
        I2C_ITError(hi2c, hi2c->ErrorCode);
    d24e:	6c61      	ldr	r1, [r4, #68]	; 0x44
    d250:	4620      	mov	r0, r4
    d252:	f7ff fe03 	bl	ce5c <I2C_ITError>
    d256:	e7a3      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
  __HAL_LOCK(hi2c);
    d258:	2002      	movs	r0, #2
}
    d25a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
    d25c:	f037 7380 	bics.w	r3, r7, #16777216	; 0x1000000
    d260:	d19e      	bne.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d262:	e7cc      	b.n	d1fe <I2C_Slave_ISR_IT+0xb2>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d264:	6823      	ldr	r3, [r4, #0]
    d266:	699a      	ldr	r2, [r3, #24]
    d268:	0790      	lsls	r0, r2, #30
    d26a:	d502      	bpl.n	d272 <I2C_Slave_ISR_IT+0x126>
    hi2c->Instance->TXDR = 0x00U;
    d26c:	2200      	movs	r2, #0
    d26e:	629a      	str	r2, [r3, #40]	; 0x28
    d270:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    d272:	699a      	ldr	r2, [r3, #24]
    d274:	07d1      	lsls	r1, r2, #31
    d276:	d4c2      	bmi.n	d1fe <I2C_Slave_ISR_IT+0xb2>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    d278:	699a      	ldr	r2, [r3, #24]
    d27a:	f042 0201 	orr.w	r2, r2, #1
    d27e:	619a      	str	r2, [r3, #24]
    d280:	e7bd      	b.n	d1fe <I2C_Slave_ISR_IT+0xb2>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d282:	481b      	ldr	r0, [pc, #108]	; (d2f0 <I2C_Slave_ISR_IT+0x1a4>)
  hi2c->State = HAL_I2C_STATE_READY;
    d284:	2120      	movs	r1, #32
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d286:	076d      	lsls	r5, r5, #29
  hi2c->XferISR = NULL;
    d288:	6363      	str	r3, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d28a:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
    d28c:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
    d28e:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d292:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d296:	d512      	bpl.n	d2be <I2C_Slave_ISR_IT+0x172>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d298:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d29a:	6a52      	ldr	r2, [r2, #36]	; 0x24
    d29c:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    d29e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d2a0:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    d2a2:	3301      	adds	r3, #1
    d2a4:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d2a6:	b301      	cbz	r1, d2ea <I2C_Slave_ISR_IT+0x19e>
      hi2c->XferCount--;
    d2a8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d2aa:	3901      	subs	r1, #1
    d2ac:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount--;
    d2ae:	3b01      	subs	r3, #1
      hi2c->XferSize--;
    d2b0:	8521      	strh	r1, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d2b2:	b29b      	uxth	r3, r3
    d2b4:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d2b6:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d2b8:	f043 0304 	orr.w	r3, r3, #4
    d2bc:	6463      	str	r3, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d2be:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d2c2:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d2c4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
    d2c8:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d2ca:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
    d2cc:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d2ce:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    d2d2:	6013      	str	r3, [r2, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d2d4:	6823      	ldr	r3, [r4, #0]
    d2d6:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
    d2d8:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
    d2dc:	f7ff fd92 	bl	ce04 <HAL_I2C_ListenCpltCallback>
    d2e0:	e75e      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d2e2:	4620      	mov	r0, r4
    d2e4:	f7ff fd52 	bl	cd8c <I2C_ITAddrCplt.isra.9.part.10>
    d2e8:	e75a      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d2ea:	6822      	ldr	r2, [r4, #0]
    d2ec:	e7e7      	b.n	d2be <I2C_Slave_ISR_IT+0x172>
    d2ee:	bf00      	nop
    d2f0:	ffff0000 	.word	0xffff0000

0000d2f4 <I2C_Slave_ISR_DMA>:
{
    d2f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
    d2f6:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
    d2fa:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
    d2fc:	2b01      	cmp	r3, #1
    d2fe:	f000 80b0 	beq.w	d462 <I2C_Slave_ISR_DMA+0x16e>
    d302:	4615      	mov	r5, r2
    d304:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    d306:	068a      	lsls	r2, r1, #26
    d308:	4604      	mov	r4, r0
    d30a:	460e      	mov	r6, r1
  __HAL_LOCK(hi2c);
    d30c:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    d310:	d502      	bpl.n	d318 <I2C_Slave_ISR_DMA+0x24>
    d312:	06ab      	lsls	r3, r5, #26
    d314:	f100 8081 	bmi.w	d41a <I2C_Slave_ISR_DMA+0x126>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d318:	06f1      	lsls	r1, r6, #27
    d31a:	d56d      	bpl.n	d3f8 <I2C_Slave_ISR_DMA+0x104>
    d31c:	06ea      	lsls	r2, r5, #27
    d31e:	d56b      	bpl.n	d3f8 <I2C_Slave_ISR_DMA+0x104>
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
    d320:	0bab      	lsrs	r3, r5, #14
    d322:	6822      	ldr	r2, [r4, #0]
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
    d324:	0bed      	lsrs	r5, r5, #15
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
    d326:	f003 0001 	and.w	r0, r3, #1
    d32a:	432b      	orrs	r3, r5
    d32c:	07db      	lsls	r3, r3, #31
    d32e:	d579      	bpl.n	d424 <I2C_Slave_ISR_DMA+0x130>
    d330:	e9d4 130e 	ldrd	r1, r3, [r4, #56]	; 0x38
      if (hi2c->hdmarx != NULL)
    d334:	b1bb      	cbz	r3, d366 <I2C_Slave_ISR_DMA+0x72>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
    d336:	07ed      	lsls	r5, r5, #31
    d338:	d515      	bpl.n	d366 <I2C_Slave_ISR_DMA+0x72>
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
    d33a:	f8df e180 	ldr.w	lr, [pc, #384]	; d4bc <I2C_Slave_ISR_DMA+0x1c8>
    d33e:	681d      	ldr	r5, [r3, #0]
    d340:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    d344:	686b      	ldr	r3, [r5, #4]
    d346:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    d34a:	fab3 f383 	clz	r3, r3
    d34e:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    d352:	095b      	lsrs	r3, r3, #5
    d354:	f50e 7e5c 	add.w	lr, lr, #880	; 0x370
    d358:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    d35c:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    d360:	2b00      	cmp	r3, #0
    d362:	f040 809a 	bne.w	d49a <I2C_Slave_ISR_DMA+0x1a6>
      if (hi2c->hdmatx != NULL)
    d366:	2900      	cmp	r1, #0
    d368:	d07f      	beq.n	d46a <I2C_Slave_ISR_DMA+0x176>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
    d36a:	2800      	cmp	r0, #0
    d36c:	d07d      	beq.n	d46a <I2C_Slave_ISR_DMA+0x176>
    d36e:	2000      	movs	r0, #0
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
    d370:	6809      	ldr	r1, [r1, #0]
    d372:	684b      	ldr	r3, [r1, #4]
    d374:	fab3 f383 	clz	r3, r3
    d378:	095b      	lsrs	r3, r3, #5
    d37a:	2b00      	cmp	r3, #0
    d37c:	d073      	beq.n	d466 <I2C_Slave_ISR_DMA+0x172>
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
    d37e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d382:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    d386:	b2db      	uxtb	r3, r3
    d388:	d14f      	bne.n	d42a <I2C_Slave_ISR_DMA+0x136>
    d38a:	2b28      	cmp	r3, #40	; 0x28
    d38c:	d14d      	bne.n	d42a <I2C_Slave_ISR_DMA+0x136>
  hi2c->PreviousState = I2C_STATE_NONE;
    d38e:	2300      	movs	r3, #0
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d390:	4849      	ldr	r0, [pc, #292]	; (d4b8 <I2C_Slave_ISR_DMA+0x1c4>)
  hi2c->State = HAL_I2C_STATE_READY;
    d392:	2120      	movs	r1, #32
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d394:	0775      	lsls	r5, r6, #29
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d396:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->XferISR = NULL;
    d398:	6363      	str	r3, [r4, #52]	; 0x34
  hi2c->PreviousState = I2C_STATE_NONE;
    d39a:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
    d39c:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d3a0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d3a4:	d513      	bpl.n	d3ce <I2C_Slave_ISR_DMA+0xda>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d3a6:	6a52      	ldr	r2, [r2, #36]	; 0x24
    d3a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d3aa:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    d3ac:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d3ae:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    d3b0:	3301      	adds	r3, #1
    d3b2:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d3b4:	2a00      	cmp	r2, #0
    d3b6:	d07c      	beq.n	d4b2 <I2C_Slave_ISR_DMA+0x1be>
      hi2c->XferCount--;
    d3b8:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d3ba:	1e53      	subs	r3, r2, #1
    d3bc:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount--;
    d3be:	3901      	subs	r1, #1
      hi2c->XferSize--;
    d3c0:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d3c2:	b28b      	uxth	r3, r1
    d3c4:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d3c6:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d3c8:	f043 0304 	orr.w	r3, r3, #4
    d3cc:	6463      	str	r3, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d3ce:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d3d2:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d3d4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
    d3d8:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d3da:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
    d3dc:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d3de:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    d3e2:	6013      	str	r3, [r2, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d3e4:	6823      	ldr	r3, [r4, #0]
    d3e6:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
    d3e8:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
    d3ec:	f7ff fd0a 	bl	ce04 <HAL_I2C_ListenCpltCallback>
  __HAL_UNLOCK(hi2c);
    d3f0:	2000      	movs	r0, #0
    d3f2:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    d3f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
    d3f8:	0732      	lsls	r2, r6, #28
    d3fa:	d5f9      	bpl.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
    d3fc:	072b      	lsls	r3, r5, #28
    d3fe:	d5f7      	bpl.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
    d400:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d404:	f003 0328 	and.w	r3, r3, #40	; 0x28
    d408:	2b28      	cmp	r3, #40	; 0x28
    d40a:	d04e      	beq.n	d4aa <I2C_Slave_ISR_DMA+0x1b6>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    d40c:	6823      	ldr	r3, [r4, #0]
    d40e:	2208      	movs	r2, #8
  __HAL_UNLOCK(hi2c);
    d410:	2000      	movs	r0, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    d412:	61da      	str	r2, [r3, #28]
  __HAL_UNLOCK(hi2c);
    d414:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    d418:	e7ed      	b.n	d3f6 <I2C_Slave_ISR_DMA+0x102>
    I2C_ITSlaveCplt(hi2c, ITFlags);
    d41a:	f7ff fdc1 	bl	cfa0 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d41e:	06f1      	lsls	r1, r6, #27
    d420:	d5ea      	bpl.n	d3f8 <I2C_Slave_ISR_DMA+0x104>
    d422:	e77b      	b.n	d31c <I2C_Slave_ISR_DMA+0x28>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d424:	2310      	movs	r3, #16
    d426:	61d3      	str	r3, [r2, #28]
    d428:	e7e2      	b.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    d42a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d42e:	2b29      	cmp	r3, #41	; 0x29
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d430:	f04f 0310 	mov.w	r3, #16
    d434:	61d3      	str	r3, [r2, #28]
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    d436:	d1db      	bne.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
    d438:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
    d43c:	d0d8      	beq.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d43e:	6823      	ldr	r3, [r4, #0]
    d440:	699a      	ldr	r2, [r3, #24]
    d442:	0790      	lsls	r0, r2, #30
    d444:	d502      	bpl.n	d44c <I2C_Slave_ISR_DMA+0x158>
    hi2c->Instance->TXDR = 0x00U;
    d446:	2200      	movs	r2, #0
    d448:	629a      	str	r2, [r3, #40]	; 0x28
    d44a:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    d44c:	699a      	ldr	r2, [r3, #24]
    d44e:	07d1      	lsls	r1, r2, #31
    d450:	d403      	bmi.n	d45a <I2C_Slave_ISR_DMA+0x166>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    d452:	699a      	ldr	r2, [r3, #24]
    d454:	f042 0201 	orr.w	r2, r2, #1
    d458:	619a      	str	r2, [r3, #24]
          I2C_ITSlaveSeqCplt(hi2c);
    d45a:	4620      	mov	r0, r4
    d45c:	f7ff fc40 	bl	cce0 <I2C_ITSlaveSeqCplt>
    d460:	e7c6      	b.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
  __HAL_LOCK(hi2c);
    d462:	2002      	movs	r0, #2
}
    d464:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (treatdmanack == 1U)
    d466:	2800      	cmp	r0, #0
    d468:	d189      	bne.n	d37e <I2C_Slave_ISR_DMA+0x8a>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d46a:	2310      	movs	r3, #16
    d46c:	61d3      	str	r3, [r2, #28]
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
    d46e:	f037 7280 	bics.w	r2, r7, #16777216	; 0x1000000
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d472:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d474:	f043 0304 	orr.w	r3, r3, #4
    d478:	6463      	str	r3, [r4, #68]	; 0x44
        tmpstate = hi2c->State;
    d47a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d47e:	b2db      	uxtb	r3, r3
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
    d480:	d1b6      	bne.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
    d482:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    d486:	2b21      	cmp	r3, #33	; 0x21
    d488:	d001      	beq.n	d48e <I2C_Slave_ISR_DMA+0x19a>
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
    d48a:	2b22      	cmp	r3, #34	; 0x22
    d48c:	d100      	bne.n	d490 <I2C_Slave_ISR_DMA+0x19c>
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    d48e:	6323      	str	r3, [r4, #48]	; 0x30
          I2C_ITError(hi2c, hi2c->ErrorCode);
    d490:	6c61      	ldr	r1, [r4, #68]	; 0x44
    d492:	4620      	mov	r0, r4
    d494:	f7ff fce2 	bl	ce5c <I2C_ITError>
    d498:	e7aa      	b.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
      if (hi2c->hdmatx != NULL)
    d49a:	2900      	cmp	r1, #0
    d49c:	f43f af6f 	beq.w	d37e <I2C_Slave_ISR_DMA+0x8a>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
    d4a0:	2800      	cmp	r0, #0
    d4a2:	f43f af6c 	beq.w	d37e <I2C_Slave_ISR_DMA+0x8a>
            treatdmanack = 1U;
    d4a6:	2001      	movs	r0, #1
    d4a8:	e762      	b.n	d370 <I2C_Slave_ISR_DMA+0x7c>
    d4aa:	4620      	mov	r0, r4
    d4ac:	f7ff fc6e 	bl	cd8c <I2C_ITAddrCplt.isra.9.part.10>
    d4b0:	e79e      	b.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
    d4b2:	6822      	ldr	r2, [r4, #0]
    d4b4:	e78b      	b.n	d3ce <I2C_Slave_ISR_DMA+0xda>
    d4b6:	bf00      	nop
    d4b8:	ffff0000 	.word	0xffff0000
    d4bc:	40020028 	.word	0x40020028

0000d4c0 <I2C_DMAMasterTransmitCplt>:
{
    d4c0:	b510      	push	{r4, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
    d4c2:	6b84      	ldr	r4, [r0, #56]	; 0x38
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    d4c4:	6822      	ldr	r2, [r4, #0]
    d4c6:	6813      	ldr	r3, [r2, #0]
    d4c8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    d4cc:	6013      	str	r3, [r2, #0]
  if (hi2c->XferCount == 0U)
    d4ce:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d4d0:	b29b      	uxth	r3, r3
    d4d2:	b963      	cbnz	r3, d4ee <I2C_DMAMasterTransmitCplt+0x2e>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d4d4:	6b63      	ldr	r3, [r4, #52]	; 0x34
    d4d6:	4a1e      	ldr	r2, [pc, #120]	; (d550 <I2C_DMAMasterTransmitCplt+0x90>)
    d4d8:	4293      	cmp	r3, r2
    d4da:	d02b      	beq.n	d534 <I2C_DMAMasterTransmitCplt+0x74>
    d4dc:	4a1d      	ldr	r2, [pc, #116]	; (d554 <I2C_DMAMasterTransmitCplt+0x94>)
    d4de:	4293      	cmp	r3, r2
    d4e0:	d028      	beq.n	d534 <I2C_DMAMasterTransmitCplt+0x74>
      tmpisr |= I2C_IT_STOPI;
    d4e2:	2120      	movs	r1, #32
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d4e4:	6822      	ldr	r2, [r4, #0]
    d4e6:	6813      	ldr	r3, [r2, #0]
    d4e8:	430b      	orrs	r3, r1
    d4ea:	6013      	str	r3, [r2, #0]
}
    d4ec:	bd10      	pop	{r4, pc}
    hi2c->pBuffPtr += hi2c->XferSize;
    d4ee:	6a61      	ldr	r1, [r4, #36]	; 0x24
    d4f0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d4f2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr += hi2c->XferSize;
    d4f4:	4411      	add	r1, r2
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d4f6:	2bff      	cmp	r3, #255	; 0xff
    hi2c->pBuffPtr += hi2c->XferSize;
    d4f8:	6261      	str	r1, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d4fa:	d818      	bhi.n	d52e <I2C_DMAMasterTransmitCplt+0x6e>
      hi2c->XferSize = hi2c->XferCount;
    d4fc:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
    d4fe:	b280      	uxth	r0, r0
    d500:	4603      	mov	r3, r0
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
    d502:	6822      	ldr	r2, [r4, #0]
    d504:	8520      	strh	r0, [r4, #40]	; 0x28
    d506:	3228      	adds	r2, #40	; 0x28
    d508:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    d50a:	f7fd fae7 	bl	aadc <HAL_DMA_Start_IT>
    d50e:	b9c8      	cbnz	r0, d544 <I2C_DMAMasterTransmitCplt+0x84>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d510:	6b63      	ldr	r3, [r4, #52]	; 0x34
    d512:	4a10      	ldr	r2, [pc, #64]	; (d554 <I2C_DMAMasterTransmitCplt+0x94>)
    d514:	4293      	cmp	r3, r2
    d516:	d00f      	beq.n	d538 <I2C_DMAMasterTransmitCplt+0x78>
    d518:	4a0d      	ldr	r2, [pc, #52]	; (d550 <I2C_DMAMasterTransmitCplt+0x90>)
    d51a:	1a9b      	subs	r3, r3, r2
    d51c:	fab3 f383 	clz	r3, r3
    d520:	095b      	lsrs	r3, r3, #5
    d522:	b94b      	cbnz	r3, d538 <I2C_DMAMasterTransmitCplt+0x78>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d524:	6821      	ldr	r1, [r4, #0]
    d526:	680a      	ldr	r2, [r1, #0]
    d528:	4313      	orrs	r3, r2
    d52a:	600b      	str	r3, [r1, #0]
}
    d52c:	bd10      	pop	{r4, pc}
    d52e:	23ff      	movs	r3, #255	; 0xff
      hi2c->XferSize = MAX_NBYTE_SIZE;
    d530:	4618      	mov	r0, r3
    d532:	e7e6      	b.n	d502 <I2C_DMAMasterTransmitCplt+0x42>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d534:	2160      	movs	r1, #96	; 0x60
    d536:	e7d5      	b.n	d4e4 <I2C_DMAMasterTransmitCplt+0x24>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d538:	6821      	ldr	r1, [r4, #0]
      tmpisr |= I2C_IT_TCI;
    d53a:	2340      	movs	r3, #64	; 0x40
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d53c:	680a      	ldr	r2, [r1, #0]
    d53e:	4313      	orrs	r3, r2
    d540:	600b      	str	r3, [r1, #0]
    d542:	e7f3      	b.n	d52c <I2C_DMAMasterTransmitCplt+0x6c>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
    d544:	4620      	mov	r0, r4
    d546:	2110      	movs	r1, #16
}
    d548:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
    d54c:	f7ff bc86 	b.w	ce5c <I2C_ITError>
    d550:	0000d2f5 	.word	0x0000d2f5
    d554:	0000daa1 	.word	0x0000daa1

0000d558 <I2C_ITMasterCplt>:
{
    d558:	b570      	push	{r4, r5, r6, lr}
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    d55a:	2220      	movs	r2, #32
    d55c:	6803      	ldr	r3, [r0, #0]
{
    d55e:	4604      	mov	r4, r0
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    d560:	61da      	str	r2, [r3, #28]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    d562:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    d566:	2b21      	cmp	r3, #33	; 0x21
    d568:	f000 80a8 	beq.w	d6bc <I2C_ITMasterCplt+0x164>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    d56c:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    d570:	2b22      	cmp	r3, #34	; 0x22
    d572:	f000 808d 	beq.w	d690 <I2C_ITMasterCplt+0x138>
  I2C_RESET_CR2(hi2c);
    d576:	6822      	ldr	r2, [r4, #0]
  hi2c->XferISR       = NULL;
    d578:	2500      	movs	r5, #0
  I2C_RESET_CR2(hi2c);
    d57a:	4890      	ldr	r0, [pc, #576]	; (d7bc <I2C_ITMasterCplt+0x264>)
    d57c:	6853      	ldr	r3, [r2, #4]
    d57e:	4003      	ands	r3, r0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    d580:	488f      	ldr	r0, [pc, #572]	; (d7c0 <I2C_ITMasterCplt+0x268>)
  I2C_RESET_CR2(hi2c);
    d582:	6053      	str	r3, [r2, #4]
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
    d584:	06cb      	lsls	r3, r1, #27
  hi2c->XferISR       = NULL;
    d586:	6365      	str	r5, [r4, #52]	; 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    d588:	62e0      	str	r0, [r4, #44]	; 0x2c
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
    d58a:	d506      	bpl.n	d59a <I2C_ITMasterCplt+0x42>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d58c:	6823      	ldr	r3, [r4, #0]
    d58e:	2210      	movs	r2, #16
    d590:	61da      	str	r2, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d592:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d594:	f043 0304 	orr.w	r3, r3, #4
    d598:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
    d59a:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    d59e:	6823      	ldr	r3, [r4, #0]
    d5a0:	2a60      	cmp	r2, #96	; 0x60
    d5a2:	f000 8086 	beq.w	d6b2 <I2C_ITMasterCplt+0x15a>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d5a6:	699a      	ldr	r2, [r3, #24]
    d5a8:	0795      	lsls	r5, r2, #30
    d5aa:	d502      	bpl.n	d5b2 <I2C_ITMasterCplt+0x5a>
    hi2c->Instance->TXDR = 0x00U;
    d5ac:	2200      	movs	r2, #0
    d5ae:	629a      	str	r2, [r3, #40]	; 0x28
    d5b0:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    d5b2:	699a      	ldr	r2, [r3, #24]
    d5b4:	07d0      	lsls	r0, r2, #31
    d5b6:	d403      	bmi.n	d5c0 <I2C_ITMasterCplt+0x68>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    d5b8:	699a      	ldr	r2, [r3, #24]
    d5ba:	f042 0201 	orr.w	r2, r2, #1
    d5be:	619a      	str	r2, [r3, #24]
  tmperror = hi2c->ErrorCode;
    d5c0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
    d5c2:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    d5c6:	2a60      	cmp	r2, #96	; 0x60
    d5c8:	d00d      	beq.n	d5e6 <I2C_ITMasterCplt+0x8e>
    d5ca:	3300      	adds	r3, #0
    d5cc:	bf18      	it	ne
    d5ce:	2301      	movne	r3, #1
    d5d0:	b94b      	cbnz	r3, d5e6 <I2C_ITMasterCplt+0x8e>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    d5d2:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    d5d6:	2a21      	cmp	r2, #33	; 0x21
    d5d8:	f000 80ce 	beq.w	d778 <I2C_ITMasterCplt+0x220>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    d5dc:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    d5e0:	2a22      	cmp	r2, #34	; 0x22
    d5e2:	d07c      	beq.n	d6de <I2C_ITMasterCplt+0x186>
}
    d5e4:	bd70      	pop	{r4, r5, r6, pc}
    I2C_ITError(hi2c, hi2c->ErrorCode);
    d5e6:	6c62      	ldr	r2, [r4, #68]	; 0x44
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    d5e8:	2100      	movs	r1, #0
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    d5ea:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    d5ee:	4874      	ldr	r0, [pc, #464]	; (d7c0 <I2C_ITMasterCplt+0x268>)
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    d5f0:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    d5f4:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    d5f6:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->XferCount     = 0U;
    d5f8:	8561      	strh	r1, [r4, #42]	; 0x2a
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    d5fa:	2b02      	cmp	r3, #2
  hi2c->ErrorCode |= ErrorCode;
    d5fc:	6c60      	ldr	r0, [r4, #68]	; 0x44
    d5fe:	6821      	ldr	r1, [r4, #0]
    d600:	ea42 0200 	orr.w	r2, r2, r0
    d604:	6462      	str	r2, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    d606:	d831      	bhi.n	d66c <I2C_ITMasterCplt+0x114>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d608:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    d60c:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d60e:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d612:	4032      	ands	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d614:	680b      	ldr	r3, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d616:	4030      	ands	r0, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    d618:	4d6a      	ldr	r5, [pc, #424]	; (d7c4 <I2C_ITMasterCplt+0x26c>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d61a:	42b2      	cmp	r2, r6
    d61c:	bf14      	ite	ne
    d61e:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
    d622:	f06f 0246 	mvneq.w	r2, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d626:	42b0      	cmp	r0, r6
    d628:	bf18      	it	ne
    d62a:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d62e:	4013      	ands	r3, r2
    d630:	600b      	str	r3, [r1, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    d632:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    d636:	6365      	str	r5, [r4, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    d638:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
    d63a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    d63c:	b118      	cbz	r0, d646 <I2C_ITMasterCplt+0xee>
    d63e:	2b11      	cmp	r3, #17
    d640:	d05d      	beq.n	d6fe <I2C_ITMasterCplt+0x1a6>
    d642:	2b21      	cmp	r3, #33	; 0x21
    d644:	d05b      	beq.n	d6fe <I2C_ITMasterCplt+0x1a6>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
    d646:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    d648:	b118      	cbz	r0, d652 <I2C_ITMasterCplt+0xfa>
    d64a:	2b12      	cmp	r3, #18
    d64c:	d075      	beq.n	d73a <I2C_ITMasterCplt+0x1e2>
    d64e:	2b22      	cmp	r3, #34	; 0x22
    d650:	d073      	beq.n	d73a <I2C_ITMasterCplt+0x1e2>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    d652:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d656:	2b60      	cmp	r3, #96	; 0x60
    d658:	f000 809e 	beq.w	d798 <I2C_ITMasterCplt+0x240>
    hi2c->PreviousState = I2C_STATE_NONE;
    d65c:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
    d65e:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
    d660:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    d662:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    d666:	f7ff fbd3 	bl	ce10 <HAL_I2C_ErrorCallback>
}
    d66a:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d66c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d670:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d674:	680b      	ldr	r3, [r1, #0]
    d676:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    d67a:	600b      	str	r3, [r1, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
    d67c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d680:	2b60      	cmp	r3, #96	; 0x60
    d682:	d002      	beq.n	d68a <I2C_ITMasterCplt+0x132>
      hi2c->State         = HAL_I2C_STATE_READY;
    d684:	2320      	movs	r3, #32
    d686:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    d68a:	2300      	movs	r3, #0
    d68c:	6363      	str	r3, [r4, #52]	; 0x34
    d68e:	e7d3      	b.n	d638 <I2C_ITMasterCplt+0xe0>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d690:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d694:	2512      	movs	r5, #18
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d696:	6800      	ldr	r0, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d698:	f002 0228 	and.w	r2, r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d69c:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d69e:	2a28      	cmp	r2, #40	; 0x28
    d6a0:	bf14      	ite	ne
    d6a2:	f06f 02f4 	mvnne.w	r2, #244	; 0xf4
    d6a6:	f06f 0244 	mvneq.w	r2, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d6aa:	4013      	ands	r3, r2
    d6ac:	6003      	str	r3, [r0, #0]
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d6ae:	6325      	str	r5, [r4, #48]	; 0x30
    d6b0:	e761      	b.n	d576 <I2C_ITMasterCplt+0x1e>
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
    d6b2:	074e      	lsls	r6, r1, #29
    d6b4:	f57f af77 	bpl.w	d5a6 <I2C_ITMasterCplt+0x4e>
    tmp = (uint8_t)hi2c->Instance->RXDR;
    d6b8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    d6ba:	e774      	b.n	d5a6 <I2C_ITMasterCplt+0x4e>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d6bc:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    d6c0:	2511      	movs	r5, #17
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d6c2:	6800      	ldr	r0, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d6c4:	f002 0228 	and.w	r2, r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d6c8:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d6ca:	2a28      	cmp	r2, #40	; 0x28
    d6cc:	bf14      	ite	ne
    d6ce:	f06f 02f2 	mvnne.w	r2, #242	; 0xf2
    d6d2:	f06f 0242 	mvneq.w	r2, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d6d6:	4013      	ands	r3, r2
    d6d8:	6003      	str	r3, [r0, #0]
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    d6da:	6325      	str	r5, [r4, #48]	; 0x30
    d6dc:	e74b      	b.n	d576 <I2C_ITMasterCplt+0x1e>
    hi2c->State = HAL_I2C_STATE_READY;
    d6de:	2220      	movs	r2, #32
      HAL_I2C_MemRxCpltCallback(hi2c);
    d6e0:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
    d6e2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
    d6e6:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
    d6ea:	6323      	str	r3, [r4, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    d6ec:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
    d6f0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    d6f4:	2a40      	cmp	r2, #64	; 0x40
    d6f6:	d05d      	beq.n	d7b4 <I2C_ITMasterCplt+0x25c>
      HAL_I2C_MasterRxCpltCallback(hi2c);
    d6f8:	f7ff faec 	bl	ccd4 <HAL_I2C_MasterRxCpltCallback>
}
    d6fc:	bd70      	pop	{r4, r5, r6, pc}
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
    d6fe:	6823      	ldr	r3, [r4, #0]
    d700:	681a      	ldr	r2, [r3, #0]
    d702:	0451      	lsls	r1, r2, #17
    d704:	d504      	bpl.n	d710 <I2C_ITMasterCplt+0x1b8>
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    d706:	681a      	ldr	r2, [r3, #0]
    d708:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    d70c:	601a      	str	r2, [r3, #0]
    d70e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
    d710:	f7fd fdf8 	bl	b304 <HAL_DMA_GetState>
    d714:	2801      	cmp	r0, #1
    d716:	d09c      	beq.n	d652 <I2C_ITMasterCplt+0xfa>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    d718:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
    d71a:	2300      	movs	r3, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    d71c:	492a      	ldr	r1, [pc, #168]	; (d7c8 <I2C_ITMasterCplt+0x270>)
    d71e:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    d720:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
    d724:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    d726:	f7fd fcb3 	bl	b090 <HAL_DMA_Abort_IT>
    d72a:	2800      	cmp	r0, #0
    d72c:	f43f af5a 	beq.w	d5e4 <I2C_ITMasterCplt+0x8c>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    d730:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
    d732:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    d736:	6d03      	ldr	r3, [r0, #80]	; 0x50
    d738:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
    d73a:	6823      	ldr	r3, [r4, #0]
    d73c:	681a      	ldr	r2, [r3, #0]
    d73e:	0412      	lsls	r2, r2, #16
    d740:	d504      	bpl.n	d74c <I2C_ITMasterCplt+0x1f4>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    d742:	681a      	ldr	r2, [r3, #0]
    d744:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    d748:	601a      	str	r2, [r3, #0]
    d74a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
    d74c:	f7fd fdda 	bl	b304 <HAL_DMA_GetState>
    d750:	2801      	cmp	r0, #1
    d752:	f43f af7e 	beq.w	d652 <I2C_ITMasterCplt+0xfa>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    d756:	6be2      	ldr	r2, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
    d758:	2300      	movs	r3, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    d75a:	491b      	ldr	r1, [pc, #108]	; (d7c8 <I2C_ITMasterCplt+0x270>)
    d75c:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    d75e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
    d762:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    d764:	f7fd fc94 	bl	b090 <HAL_DMA_Abort_IT>
    d768:	2800      	cmp	r0, #0
    d76a:	f43f af3b 	beq.w	d5e4 <I2C_ITMasterCplt+0x8c>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    d76e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
    d770:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    d774:	6d03      	ldr	r3, [r0, #80]	; 0x50
    d776:	4718      	bx	r3
    hi2c->State = HAL_I2C_STATE_READY;
    d778:	2220      	movs	r2, #32
      HAL_I2C_MemTxCpltCallback(hi2c);
    d77a:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
    d77c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
    d780:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
    d784:	6323      	str	r3, [r4, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    d786:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
    d78a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    d78e:	2a40      	cmp	r2, #64	; 0x40
    d790:	d00d      	beq.n	d7ae <I2C_ITMasterCplt+0x256>
      HAL_I2C_MasterTxCpltCallback(hi2c);
    d792:	f7ff fa9d 	bl	ccd0 <HAL_I2C_MasterTxCpltCallback>
}
    d796:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
    d798:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
    d79a:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    d79c:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
    d79e:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    d7a2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    d7a6:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    d7a8:	f7ff fb34 	bl	ce14 <HAL_I2C_AbortCpltCallback>
}
    d7ac:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MemTxCpltCallback(hi2c);
    d7ae:	f7ff fb2b 	bl	ce08 <HAL_I2C_MemTxCpltCallback>
}
    d7b2:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MemRxCpltCallback(hi2c);
    d7b4:	f7ff fb2a 	bl	ce0c <HAL_I2C_MemRxCpltCallback>
}
    d7b8:	bd70      	pop	{r4, r5, r6, pc}
    d7ba:	bf00      	nop
    d7bc:	fe00e800 	.word	0xfe00e800
    d7c0:	ffff0000 	.word	0xffff0000
    d7c4:	0000d14d 	.word	0x0000d14d
    d7c8:	0000ce19 	.word	0x0000ce19

0000d7cc <I2C_Master_ISR_IT>:
  __HAL_LOCK(hi2c);
    d7cc:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    d7d0:	2b01      	cmp	r3, #1
    d7d2:	f000 80d8 	beq.w	d986 <I2C_Master_ISR_IT+0x1ba>
    d7d6:	2301      	movs	r3, #1
{
    d7d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d7dc:	06cf      	lsls	r7, r1, #27
{
    d7de:	b082      	sub	sp, #8
    d7e0:	4604      	mov	r4, r0
    d7e2:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
    d7e4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d7e8:	d51e      	bpl.n	d828 <I2C_Master_ISR_IT+0x5c>
    d7ea:	06d6      	lsls	r6, r2, #27
    d7ec:	d51c      	bpl.n	d828 <I2C_Master_ISR_IT+0x5c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d7ee:	6803      	ldr	r3, [r0, #0]
    d7f0:	2110      	movs	r1, #16
    d7f2:	61d9      	str	r1, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d7f4:	6c41      	ldr	r1, [r0, #68]	; 0x44
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d7f6:	6803      	ldr	r3, [r0, #0]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d7f8:	f041 0104 	orr.w	r1, r1, #4
    d7fc:	6441      	str	r1, [r0, #68]	; 0x44
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d7fe:	6999      	ldr	r1, [r3, #24]
    d800:	0788      	lsls	r0, r1, #30
    d802:	d502      	bpl.n	d80a <I2C_Master_ISR_IT+0x3e>
    hi2c->Instance->TXDR = 0x00U;
    d804:	2100      	movs	r1, #0
    d806:	6299      	str	r1, [r3, #40]	; 0x28
    d808:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    d80a:	6999      	ldr	r1, [r3, #24]
    d80c:	07c9      	lsls	r1, r1, #31
    d80e:	f140 8087 	bpl.w	d920 <I2C_Master_ISR_IT+0x154>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    d812:	06a9      	lsls	r1, r5, #26
    d814:	d502      	bpl.n	d81c <I2C_Master_ISR_IT+0x50>
    d816:	0693      	lsls	r3, r2, #26
    d818:	f100 80b7 	bmi.w	d98a <I2C_Master_ISR_IT+0x1be>
  __HAL_UNLOCK(hi2c);
    d81c:	2000      	movs	r0, #0
    d81e:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    d822:	b002      	add	sp, #8
    d824:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    d828:	076f      	lsls	r7, r5, #29
    d82a:	d408      	bmi.n	d83e <I2C_Master_ISR_IT+0x72>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
    d82c:	07a8      	lsls	r0, r5, #30
    d82e:	d519      	bpl.n	d864 <I2C_Master_ISR_IT+0x98>
    d830:	0791      	lsls	r1, r2, #30
    d832:	d517      	bpl.n	d864 <I2C_Master_ISR_IT+0x98>
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
    d834:	6a61      	ldr	r1, [r4, #36]	; 0x24
    d836:	6823      	ldr	r3, [r4, #0]
    d838:	7809      	ldrb	r1, [r1, #0]
    d83a:	6299      	str	r1, [r3, #40]	; 0x28
    d83c:	e007      	b.n	d84e <I2C_Master_ISR_IT+0x82>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    d83e:	0756      	lsls	r6, r2, #29
    d840:	d5f4      	bpl.n	d82c <I2C_Master_ISR_IT+0x60>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d842:	6821      	ldr	r1, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
    d844:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d848:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d84a:	6a49      	ldr	r1, [r1, #36]	; 0x24
    d84c:	7019      	strb	r1, [r3, #0]
    hi2c->XferCount--;
    d84e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr++;
    d850:	6a60      	ldr	r0, [r4, #36]	; 0x24
    hi2c->XferSize--;
    d852:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    hi2c->XferCount--;
    d854:	3b01      	subs	r3, #1
    hi2c->pBuffPtr++;
    d856:	3001      	adds	r0, #1
    hi2c->XferCount--;
    d858:	b29b      	uxth	r3, r3
    hi2c->XferSize--;
    d85a:	3901      	subs	r1, #1
    hi2c->pBuffPtr++;
    d85c:	6260      	str	r0, [r4, #36]	; 0x24
    hi2c->XferCount--;
    d85e:	8563      	strh	r3, [r4, #42]	; 0x2a
    hi2c->XferSize--;
    d860:	8521      	strh	r1, [r4, #40]	; 0x28
    hi2c->XferCount--;
    d862:	e7d6      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    d864:	062b      	lsls	r3, r5, #24
    d866:	d416      	bmi.n	d896 <I2C_Master_ISR_IT+0xca>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    d868:	066e      	lsls	r6, r5, #25
    d86a:	d5d2      	bpl.n	d812 <I2C_Master_ISR_IT+0x46>
    d86c:	0650      	lsls	r0, r2, #25
    d86e:	d5d0      	bpl.n	d812 <I2C_Master_ISR_IT+0x46>
    if (hi2c->XferCount == 0U)
    d870:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d872:	b29b      	uxth	r3, r3
    d874:	2b00      	cmp	r3, #0
    d876:	d17f      	bne.n	d978 <I2C_Master_ISR_IT+0x1ac>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    d878:	6821      	ldr	r1, [r4, #0]
    d87a:	684b      	ldr	r3, [r1, #4]
    d87c:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    d880:	d1c7      	bne.n	d812 <I2C_Master_ISR_IT+0x46>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
    d882:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    d884:	f510 3f80 	cmn.w	r0, #65536	; 0x10000
    d888:	f040 80a2 	bne.w	d9d0 <I2C_Master_ISR_IT+0x204>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
    d88c:	684b      	ldr	r3, [r1, #4]
    d88e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    d892:	604b      	str	r3, [r1, #4]
    d894:	e7bd      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    d896:	0657      	lsls	r7, r2, #25
    d898:	d5bb      	bpl.n	d812 <I2C_Master_ISR_IT+0x46>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    d89a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d89c:	6821      	ldr	r1, [r4, #0]
    d89e:	b29b      	uxth	r3, r3
    d8a0:	2b00      	cmp	r3, #0
    d8a2:	d042      	beq.n	d92a <I2C_Master_ISR_IT+0x15e>
    d8a4:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    d8a6:	2b00      	cmp	r3, #0
    d8a8:	d13f      	bne.n	d92a <I2C_Master_ISR_IT+0x15e>
    d8aa:	4b76      	ldr	r3, [pc, #472]	; (da84 <I2C_Master_ISR_IT+0x2b8>)
    d8ac:	4e76      	ldr	r6, [pc, #472]	; (da88 <I2C_Master_ISR_IT+0x2bc>)
    d8ae:	4877      	ldr	r0, [pc, #476]	; (da8c <I2C_Master_ISR_IT+0x2c0>)
    d8b0:	4299      	cmp	r1, r3
    d8b2:	bf18      	it	ne
    d8b4:	42b1      	cmpne	r1, r6
    d8b6:	4f76      	ldr	r7, [pc, #472]	; (da90 <I2C_Master_ISR_IT+0x2c4>)
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    d8b8:	684e      	ldr	r6, [r1, #4]
    d8ba:	bf14      	ite	ne
    d8bc:	2301      	movne	r3, #1
    d8be:	2300      	moveq	r3, #0
    d8c0:	f3c6 0609 	ubfx	r6, r6, #0, #10
    d8c4:	4281      	cmp	r1, r0
    d8c6:	bf0c      	ite	eq
    d8c8:	2300      	moveq	r3, #0
    d8ca:	f003 0301 	andne.w	r3, r3, #1
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d8ce:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
    d8d0:	42b9      	cmp	r1, r7
    d8d2:	bf0c      	ite	eq
    d8d4:	2300      	moveq	r3, #0
    d8d6:	f003 0301 	andne.w	r3, r3, #1
    d8da:	28ff      	cmp	r0, #255	; 0xff
    d8dc:	f200 8099 	bhi.w	da12 <I2C_Master_ISR_IT+0x246>
        hi2c->XferSize = hi2c->XferCount;
    d8e0:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    d8e2:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
        hi2c->XferSize = hi2c->XferCount;
    d8e4:	b280      	uxth	r0, r0
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    d8e6:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
        hi2c->XferSize = hi2c->XferCount;
    d8ea:	8520      	strh	r0, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
    d8ec:	b2c7      	uxtb	r7, r0
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    d8ee:	f000 809b 	beq.w	da28 <I2C_Master_ISR_IT+0x25c>
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
    d8f2:	f8d4 802c 	ldr.w	r8, [r4, #44]	; 0x2c
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d8f6:	2b00      	cmp	r3, #0
    d8f8:	f040 80a1 	bne.w	da3e <I2C_Master_ISR_IT+0x272>
  assert_param(IS_TRANSFER_MODE(Mode));
    d8fc:	f038 7380 	bics.w	r3, r8, #16777216	; 0x1000000
    d900:	d003      	beq.n	d90a <I2C_Master_ISR_IT+0x13e>
    d902:	f1b8 7f00 	cmp.w	r8, #33554432	; 0x2000000
    d906:	f040 80a2 	bne.w	da4e <I2C_Master_ISR_IT+0x282>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d90a:	6823      	ldr	r3, [r4, #0]
    d90c:	4961      	ldr	r1, [pc, #388]	; (da94 <I2C_Master_ISR_IT+0x2c8>)
    d90e:	6858      	ldr	r0, [r3, #4]
    d910:	4008      	ands	r0, r1
    d912:	ea40 0008 	orr.w	r0, r0, r8
    d916:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
    d91a:	4306      	orrs	r6, r0
    d91c:	605e      	str	r6, [r3, #4]
    d91e:	e778      	b.n	d812 <I2C_Master_ISR_IT+0x46>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    d920:	6999      	ldr	r1, [r3, #24]
    d922:	f041 0101 	orr.w	r1, r1, #1
    d926:	6199      	str	r1, [r3, #24]
    d928:	e773      	b.n	d812 <I2C_Master_ISR_IT+0x46>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    d92a:	684b      	ldr	r3, [r1, #4]
    d92c:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    d930:	d122      	bne.n	d978 <I2C_Master_ISR_IT+0x1ac>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d932:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    d936:	2720      	movs	r7, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    d938:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
    d93c:	9201      	str	r2, [sp, #4]
    d93e:	2821      	cmp	r0, #33	; 0x21
    d940:	d02d      	beq.n	d99e <I2C_Master_ISR_IT+0x1d2>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d942:	2612      	movs	r6, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    d944:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    d948:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    d94a:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d94c:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d94e:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d952:	f8d1 c000 	ldr.w	ip, [r1]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d956:	f007 0728 	and.w	r7, r7, #40	; 0x28
    d95a:	2f28      	cmp	r7, #40	; 0x28
    d95c:	bf14      	ite	ne
    d95e:	f06f 06f4 	mvnne.w	r6, #244	; 0xf4
    d962:	f06f 0644 	mvneq.w	r6, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d966:	ea06 060c 	and.w	r6, r6, ip
    d96a:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
    d96c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    d970:	f7ff f9b0 	bl	ccd4 <HAL_I2C_MasterRxCpltCallback>
    d974:	9a01      	ldr	r2, [sp, #4]
    d976:	e74c      	b.n	d812 <I2C_Master_ISR_IT+0x46>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
    d978:	2140      	movs	r1, #64	; 0x40
    d97a:	4620      	mov	r0, r4
    d97c:	9201      	str	r2, [sp, #4]
    d97e:	f7ff fa6d 	bl	ce5c <I2C_ITError>
    d982:	9a01      	ldr	r2, [sp, #4]
    d984:	e745      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  __HAL_LOCK(hi2c);
    d986:	2002      	movs	r0, #2
}
    d988:	4770      	bx	lr
    I2C_ITMasterCplt(hi2c, tmpITFlags);
    d98a:	4620      	mov	r0, r4
    d98c:	4629      	mov	r1, r5
    d98e:	f7ff fde3 	bl	d558 <I2C_ITMasterCplt>
  __HAL_UNLOCK(hi2c);
    d992:	2000      	movs	r0, #0
    d994:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    d998:	b002      	add	sp, #8
    d99a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    d99e:	2611      	movs	r6, #17
    hi2c->State         = HAL_I2C_STATE_READY;
    d9a0:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    d9a4:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterTxCpltCallback(hi2c);
    d9a6:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    d9a8:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d9aa:	f894 6041 	ldrb.w	r6, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d9ae:	680f      	ldr	r7, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d9b0:	f006 0628 	and.w	r6, r6, #40	; 0x28
    d9b4:	2e28      	cmp	r6, #40	; 0x28
    d9b6:	bf14      	ite	ne
    d9b8:	f06f 06f2 	mvnne.w	r6, #242	; 0xf2
    d9bc:	f06f 0642 	mvneq.w	r6, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d9c0:	403e      	ands	r6, r7
    d9c2:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
    d9c4:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
    d9c8:	f7ff f982 	bl	ccd0 <HAL_I2C_MasterTxCpltCallback>
    d9cc:	9a01      	ldr	r2, [sp, #4]
    d9ce:	e720      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d9d0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    d9d4:	2720      	movs	r7, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    d9d6:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
    d9da:	9201      	str	r2, [sp, #4]
    d9dc:	2821      	cmp	r0, #33	; 0x21
    d9de:	d0de      	beq.n	d99e <I2C_Master_ISR_IT+0x1d2>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d9e0:	2612      	movs	r6, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    d9e2:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    d9e6:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    d9e8:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d9ea:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d9ec:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d9f0:	680e      	ldr	r6, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d9f2:	f007 0728 	and.w	r7, r7, #40	; 0x28
    d9f6:	2f28      	cmp	r7, #40	; 0x28
    d9f8:	bf14      	ite	ne
    d9fa:	f06f 07f4 	mvnne.w	r7, #244	; 0xf4
    d9fe:	f06f 0744 	mvneq.w	r7, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    da02:	403e      	ands	r6, r7
    da04:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
    da06:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    da0a:	f7ff f963 	bl	ccd4 <HAL_I2C_MasterRxCpltCallback>
    da0e:	9a01      	ldr	r2, [sp, #4]
    da10:	e6ff      	b.n	d812 <I2C_Master_ISR_IT+0x46>
        hi2c->XferSize = MAX_NBYTE_SIZE;
    da12:	20ff      	movs	r0, #255	; 0xff
    da14:	8520      	strh	r0, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    da16:	bb13      	cbnz	r3, da5e <I2C_Master_ISR_IT+0x292>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    da18:	684b      	ldr	r3, [r1, #4]
    da1a:	4f1e      	ldr	r7, [pc, #120]	; (da94 <I2C_Master_ISR_IT+0x2c8>)
    da1c:	481e      	ldr	r0, [pc, #120]	; (da98 <I2C_Master_ISR_IT+0x2cc>)
    da1e:	403b      	ands	r3, r7
    da20:	4330      	orrs	r0, r6
    da22:	4303      	orrs	r3, r0
    da24:	604b      	str	r3, [r1, #4]
    da26:	e6f4      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    da28:	bb13      	cbnz	r3, da70 <I2C_Master_ISR_IT+0x2a4>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    da2a:	ea46 4307 	orr.w	r3, r6, r7, lsl #16
    da2e:	6848      	ldr	r0, [r1, #4]
    da30:	4e18      	ldr	r6, [pc, #96]	; (da94 <I2C_Master_ISR_IT+0x2c8>)
    da32:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    da36:	4030      	ands	r0, r6
    da38:	4303      	orrs	r3, r0
    da3a:	604b      	str	r3, [r1, #4]
    da3c:	e6e9      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    da3e:	f641 1131 	movw	r1, #6449	; 0x1931
    da42:	4816      	ldr	r0, [pc, #88]	; (da9c <I2C_Master_ISR_IT+0x2d0>)
    da44:	9201      	str	r2, [sp, #4]
    da46:	f00b fce5 	bl	19414 <assert_failed>
    da4a:	9a01      	ldr	r2, [sp, #4]
    da4c:	e756      	b.n	d8fc <I2C_Master_ISR_IT+0x130>
  assert_param(IS_TRANSFER_MODE(Mode));
    da4e:	f641 1132 	movw	r1, #6450	; 0x1932
    da52:	4812      	ldr	r0, [pc, #72]	; (da9c <I2C_Master_ISR_IT+0x2d0>)
    da54:	9201      	str	r2, [sp, #4]
    da56:	f00b fcdd 	bl	19414 <assert_failed>
    da5a:	9a01      	ldr	r2, [sp, #4]
    da5c:	e755      	b.n	d90a <I2C_Master_ISR_IT+0x13e>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    da5e:	f641 1131 	movw	r1, #6449	; 0x1931
    da62:	480e      	ldr	r0, [pc, #56]	; (da9c <I2C_Master_ISR_IT+0x2d0>)
    da64:	9201      	str	r2, [sp, #4]
    da66:	f00b fcd5 	bl	19414 <assert_failed>
    da6a:	6821      	ldr	r1, [r4, #0]
    da6c:	9a01      	ldr	r2, [sp, #4]
    da6e:	e7d3      	b.n	da18 <I2C_Master_ISR_IT+0x24c>
    da70:	f641 1131 	movw	r1, #6449	; 0x1931
    da74:	4809      	ldr	r0, [pc, #36]	; (da9c <I2C_Master_ISR_IT+0x2d0>)
    da76:	9201      	str	r2, [sp, #4]
    da78:	f00b fccc 	bl	19414 <assert_failed>
    da7c:	6821      	ldr	r1, [r4, #0]
    da7e:	9a01      	ldr	r2, [sp, #4]
    da80:	e7d3      	b.n	da2a <I2C_Master_ISR_IT+0x25e>
    da82:	bf00      	nop
    da84:	40005400 	.word	0x40005400
    da88:	40005800 	.word	0x40005800
    da8c:	40005c00 	.word	0x40005c00
    da90:	58001c00 	.word	0x58001c00
    da94:	fc009c00 	.word	0xfc009c00
    da98:	01ff0000 	.word	0x01ff0000
    da9c:	0002fd80 	.word	0x0002fd80

0000daa0 <I2C_Master_ISR_DMA>:
  __HAL_LOCK(hi2c);
    daa0:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    daa4:	2b01      	cmp	r3, #1
    daa6:	f000 80a8 	beq.w	dbfa <I2C_Master_ISR_DMA+0x15a>
    daaa:	2301      	movs	r3, #1
{
    daac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    dab0:	06cd      	lsls	r5, r1, #27
    dab2:	4604      	mov	r4, r0
  __HAL_LOCK(hi2c);
    dab4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    dab8:	d529      	bpl.n	db0e <I2C_Master_ISR_DMA+0x6e>
    daba:	06d0      	lsls	r0, r2, #27
    dabc:	d527      	bpl.n	db0e <I2C_Master_ISR_DMA+0x6e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    dabe:	6823      	ldr	r3, [r4, #0]
    dac0:	2210      	movs	r2, #16
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    dac2:	4998      	ldr	r1, [pc, #608]	; (dd24 <I2C_Master_ISR_DMA+0x284>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    dac4:	61da      	str	r2, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    dac6:	6c63      	ldr	r3, [r4, #68]	; 0x44
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    dac8:	6b62      	ldr	r2, [r4, #52]	; 0x34
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    daca:	f043 0304 	orr.w	r3, r3, #4
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    dace:	428a      	cmp	r2, r1
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    dad0:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    dad2:	f000 8090 	beq.w	dbf6 <I2C_Master_ISR_DMA+0x156>
    dad6:	4b94      	ldr	r3, [pc, #592]	; (dd28 <I2C_Master_ISR_DMA+0x288>)
    dad8:	429a      	cmp	r2, r3
    dada:	f000 808c 	beq.w	dbf6 <I2C_Master_ISR_DMA+0x156>
      tmpisr |= I2C_IT_STOPI;
    dade:	2120      	movs	r1, #32
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    dae0:	6822      	ldr	r2, [r4, #0]
    dae2:	6813      	ldr	r3, [r2, #0]
    dae4:	430b      	orrs	r3, r1
    dae6:	6013      	str	r3, [r2, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    dae8:	6823      	ldr	r3, [r4, #0]
    daea:	699a      	ldr	r2, [r3, #24]
    daec:	0791      	lsls	r1, r2, #30
    daee:	d502      	bpl.n	daf6 <I2C_Master_ISR_DMA+0x56>
    hi2c->Instance->TXDR = 0x00U;
    daf0:	2200      	movs	r2, #0
    daf2:	629a      	str	r2, [r3, #40]	; 0x28
    daf4:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    daf6:	699a      	ldr	r2, [r3, #24]
    daf8:	07d2      	lsls	r2, r2, #31
    dafa:	d403      	bmi.n	db04 <I2C_Master_ISR_DMA+0x64>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    dafc:	699a      	ldr	r2, [r3, #24]
    dafe:	f042 0201 	orr.w	r2, r2, #1
    db02:	619a      	str	r2, [r3, #24]
  __HAL_UNLOCK(hi2c);
    db04:	2000      	movs	r0, #0
    db06:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    db0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    db0e:	060f      	lsls	r7, r1, #24
    db10:	d553      	bpl.n	dbba <I2C_Master_ISR_DMA+0x11a>
    db12:	0656      	lsls	r6, r2, #25
    db14:	d567      	bpl.n	dbe6 <I2C_Master_ISR_DMA+0x146>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
    db16:	6822      	ldr	r2, [r4, #0]
    db18:	6813      	ldr	r3, [r2, #0]
    db1a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    db1e:	6013      	str	r3, [r2, #0]
    if (hi2c->XferCount != 0U)
    db20:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    db22:	6822      	ldr	r2, [r4, #0]
    if (hi2c->XferCount != 0U)
    db24:	b29b      	uxth	r3, r3
    db26:	2b00      	cmp	r3, #0
    db28:	d069      	beq.n	dbfe <I2C_Master_ISR_DMA+0x15e>
    db2a:	4980      	ldr	r1, [pc, #512]	; (dd2c <I2C_Master_ISR_DMA+0x28c>)
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    db2c:	4610      	mov	r0, r2
    db2e:	4e80      	ldr	r6, [pc, #512]	; (dd30 <I2C_Master_ISR_DMA+0x290>)
    db30:	6855      	ldr	r5, [r2, #4]
    db32:	42b2      	cmp	r2, r6
    db34:	bf18      	it	ne
    db36:	428a      	cmpne	r2, r1
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
    db38:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    db3a:	f3c5 0609 	ubfx	r6, r5, #0, #10
    db3e:	bf14      	ite	ne
    db40:	2101      	movne	r1, #1
    db42:	2100      	moveq	r1, #0
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
    db44:	2bff      	cmp	r3, #255	; 0xff
    db46:	f200 8082 	bhi.w	dc4e <I2C_Master_ISR_DMA+0x1ae>
        hi2c->XferSize = hi2c->XferCount;
    db4a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    db4c:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
        hi2c->XferSize = hi2c->XferCount;
    db4e:	b29b      	uxth	r3, r3
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    db50:	f515 3f80 	cmn.w	r5, #65536	; 0x10000
        hi2c->XferSize = hi2c->XferCount;
    db54:	8523      	strh	r3, [r4, #40]	; 0x28
    db56:	b2db      	uxtb	r3, r3
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    db58:	f000 80c6 	beq.w	dce8 <I2C_Master_ISR_DMA+0x248>
          xfermode = hi2c->XferOptions;
    db5c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    db5e:	041d      	lsls	r5, r3, #16
    db60:	f027 7880 	bic.w	r8, r7, #16777216	; 0x1000000
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    db64:	2900      	cmp	r1, #0
    db66:	f040 80ca 	bne.w	dcfe <I2C_Master_ISR_DMA+0x25e>
    db6a:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    db6e:	bf18      	it	ne
    db70:	f1b8 0f00 	cmpne.w	r8, #0
    db74:	bf14      	ite	ne
    db76:	f04f 0801 	movne.w	r8, #1
    db7a:	f04f 0800 	moveq.w	r8, #0
  assert_param(IS_TRANSFER_MODE(Mode));
    db7e:	f1b8 0f00 	cmp.w	r8, #0
    db82:	f040 80b5 	bne.w	dcf0 <I2C_Master_ISR_DMA+0x250>
    db86:	6822      	ldr	r2, [r4, #0]
    db88:	4610      	mov	r0, r2
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    db8a:	6843      	ldr	r3, [r0, #4]
    db8c:	433d      	orrs	r5, r7
    db8e:	4a69      	ldr	r2, [pc, #420]	; (dd34 <I2C_Master_ISR_DMA+0x294>)
    db90:	4335      	orrs	r5, r6
    db92:	4013      	ands	r3, r2
    db94:	431d      	orrs	r5, r3
    db96:	6045      	str	r5, [r0, #4]
      hi2c->XferCount -= hi2c->XferSize;
    db98:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    db9a:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    db9c:	1a9b      	subs	r3, r3, r2
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
    db9e:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount -= hi2c->XferSize;
    dba0:	b29b      	uxth	r3, r3
    dba2:	8563      	strh	r3, [r4, #42]	; 0x2a
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    dba4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    dba8:	2b22      	cmp	r3, #34	; 0x22
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
    dbaa:	6813      	ldr	r3, [r2, #0]
    dbac:	bf0c      	ite	eq
    dbae:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
    dbb2:	f443 4380 	orrne.w	r3, r3, #16384	; 0x4000
    dbb6:	6013      	str	r3, [r2, #0]
    dbb8:	e7a4      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    dbba:	064d      	lsls	r5, r1, #25
    dbbc:	d513      	bpl.n	dbe6 <I2C_Master_ISR_DMA+0x146>
    dbbe:	0650      	lsls	r0, r2, #25
    dbc0:	d511      	bpl.n	dbe6 <I2C_Master_ISR_DMA+0x146>
    if (hi2c->XferCount == 0U)
    dbc2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    dbc4:	b29b      	uxth	r3, r3
    dbc6:	2b00      	cmp	r3, #0
    dbc8:	d13c      	bne.n	dc44 <I2C_Master_ISR_DMA+0x1a4>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    dbca:	6822      	ldr	r2, [r4, #0]
    dbcc:	6853      	ldr	r3, [r2, #4]
    dbce:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    dbd2:	d197      	bne.n	db04 <I2C_Master_ISR_DMA+0x64>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
    dbd4:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    dbd6:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
    dbda:	d166      	bne.n	dcaa <I2C_Master_ISR_DMA+0x20a>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
    dbdc:	6853      	ldr	r3, [r2, #4]
    dbde:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    dbe2:	6053      	str	r3, [r2, #4]
    dbe4:	e78e      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    dbe6:	068b      	lsls	r3, r1, #26
    dbe8:	d58c      	bpl.n	db04 <I2C_Master_ISR_DMA+0x64>
    dbea:	0692      	lsls	r2, r2, #26
    dbec:	d58a      	bpl.n	db04 <I2C_Master_ISR_DMA+0x64>
    I2C_ITMasterCplt(hi2c, ITFlags);
    dbee:	4620      	mov	r0, r4
    dbf0:	f7ff fcb2 	bl	d558 <I2C_ITMasterCplt>
    dbf4:	e786      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    dbf6:	2160      	movs	r1, #96	; 0x60
    dbf8:	e772      	b.n	dae0 <I2C_Master_ISR_DMA+0x40>
  __HAL_LOCK(hi2c);
    dbfa:	2002      	movs	r0, #2
}
    dbfc:	4770      	bx	lr
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    dbfe:	6853      	ldr	r3, [r2, #4]
    dc00:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    dc04:	d11e      	bne.n	dc44 <I2C_Master_ISR_DMA+0x1a4>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    dc06:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    dc0a:	2520      	movs	r5, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    dc0c:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    dc10:	2921      	cmp	r1, #33	; 0x21
    dc12:	d032      	beq.n	dc7a <I2C_Master_ISR_DMA+0x1da>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    dc14:	2112      	movs	r1, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    dc16:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    dc1a:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    dc1c:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    dc1e:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dc20:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dc24:	6816      	ldr	r6, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dc26:	f005 0528 	and.w	r5, r5, #40	; 0x28
    dc2a:	2d28      	cmp	r5, #40	; 0x28
    dc2c:	bf14      	ite	ne
    dc2e:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
    dc32:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dc36:	4031      	ands	r1, r6
    dc38:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
    dc3a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    dc3e:	f7ff f849 	bl	ccd4 <HAL_I2C_MasterRxCpltCallback>
    dc42:	e75f      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
    dc44:	2140      	movs	r1, #64	; 0x40
    dc46:	4620      	mov	r0, r4
    dc48:	f7ff f908 	bl	ce5c <I2C_ITError>
    dc4c:	e75a      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
        hi2c->XferSize = MAX_NBYTE_SIZE;
    dc4e:	23ff      	movs	r3, #255	; 0xff
    dc50:	f44f 057f 	mov.w	r5, #16711680	; 0xff0000
        xfermode = I2C_RELOAD_MODE;
    dc54:	f04f 7780 	mov.w	r7, #16777216	; 0x1000000
        hi2c->XferSize = MAX_NBYTE_SIZE;
    dc58:	8523      	strh	r3, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    dc5a:	2900      	cmp	r1, #0
    dc5c:	d095      	beq.n	db8a <I2C_Master_ISR_DMA+0xea>
    dc5e:	4b36      	ldr	r3, [pc, #216]	; (dd38 <I2C_Master_ISR_DMA+0x298>)
    dc60:	429a      	cmp	r2, r3
    dc62:	d091      	beq.n	db88 <I2C_Master_ISR_DMA+0xe8>
    dc64:	4b35      	ldr	r3, [pc, #212]	; (dd3c <I2C_Master_ISR_DMA+0x29c>)
    dc66:	429a      	cmp	r2, r3
    dc68:	d08e      	beq.n	db88 <I2C_Master_ISR_DMA+0xe8>
    dc6a:	f04f 0800 	mov.w	r8, #0
    dc6e:	f641 1131 	movw	r1, #6449	; 0x1931
    dc72:	4833      	ldr	r0, [pc, #204]	; (dd40 <I2C_Master_ISR_DMA+0x2a0>)
    dc74:	f00b fbce 	bl	19414 <assert_failed>
    dc78:	e781      	b.n	db7e <I2C_Master_ISR_DMA+0xde>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    dc7a:	2111      	movs	r1, #17
    hi2c->State         = HAL_I2C_STATE_READY;
    dc7c:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    dc80:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterTxCpltCallback(hi2c);
    dc82:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    dc84:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dc86:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dc8a:	6815      	ldr	r5, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dc8c:	f001 0128 	and.w	r1, r1, #40	; 0x28
    dc90:	2928      	cmp	r1, #40	; 0x28
    dc92:	bf14      	ite	ne
    dc94:	f06f 01f2 	mvnne.w	r1, #242	; 0xf2
    dc98:	f06f 0142 	mvneq.w	r1, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dc9c:	4029      	ands	r1, r5
    dc9e:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
    dca0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
    dca4:	f7ff f814 	bl	ccd0 <HAL_I2C_MasterTxCpltCallback>
    dca8:	e72c      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    dcaa:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    dcae:	2520      	movs	r5, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    dcb0:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    dcb4:	2921      	cmp	r1, #33	; 0x21
    dcb6:	d0e0      	beq.n	dc7a <I2C_Master_ISR_DMA+0x1da>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    dcb8:	2112      	movs	r1, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    dcba:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    dcbe:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    dcc0:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    dcc2:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dcc4:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dcc8:	6815      	ldr	r5, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dcca:	f001 0128 	and.w	r1, r1, #40	; 0x28
    dcce:	2928      	cmp	r1, #40	; 0x28
    dcd0:	bf14      	ite	ne
    dcd2:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
    dcd6:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dcda:	4029      	ands	r1, r5
    dcdc:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
    dcde:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    dce2:	f7fe fff7 	bl	ccd4 <HAL_I2C_MasterRxCpltCallback>
    dce6:	e70d      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
          xfermode = I2C_AUTOEND_MODE;
    dce8:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
    dcec:	041d      	lsls	r5, r3, #16
    dcee:	e7b4      	b.n	dc5a <I2C_Master_ISR_DMA+0x1ba>
  assert_param(IS_TRANSFER_MODE(Mode));
    dcf0:	4813      	ldr	r0, [pc, #76]	; (dd40 <I2C_Master_ISR_DMA+0x2a0>)
    dcf2:	f641 1132 	movw	r1, #6450	; 0x1932
    dcf6:	f00b fb8d 	bl	19414 <assert_failed>
    dcfa:	6820      	ldr	r0, [r4, #0]
    dcfc:	e745      	b.n	db8a <I2C_Master_ISR_DMA+0xea>
    dcfe:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    dd02:	bf18      	it	ne
    dd04:	f1b8 0f00 	cmpne.w	r8, #0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    dd08:	4b0b      	ldr	r3, [pc, #44]	; (dd38 <I2C_Master_ISR_DMA+0x298>)
    dd0a:	bf14      	ite	ne
    dd0c:	f04f 0801 	movne.w	r8, #1
    dd10:	f04f 0800 	moveq.w	r8, #0
    dd14:	429a      	cmp	r2, r3
    dd16:	f43f af32 	beq.w	db7e <I2C_Master_ISR_DMA+0xde>
    dd1a:	4b08      	ldr	r3, [pc, #32]	; (dd3c <I2C_Master_ISR_DMA+0x29c>)
    dd1c:	429a      	cmp	r2, r3
    dd1e:	d1a6      	bne.n	dc6e <I2C_Master_ISR_DMA+0x1ce>
    dd20:	e72d      	b.n	db7e <I2C_Master_ISR_DMA+0xde>
    dd22:	bf00      	nop
    dd24:	0000d2f5 	.word	0x0000d2f5
    dd28:	0000daa1 	.word	0x0000daa1
    dd2c:	40005800 	.word	0x40005800
    dd30:	40005400 	.word	0x40005400
    dd34:	fc009c00 	.word	0xfc009c00
    dd38:	58001c00 	.word	0x58001c00
    dd3c:	40005c00 	.word	0x40005c00
    dd40:	0002fd80 	.word	0x0002fd80

0000dd44 <I2C_DMAError>:
{
    dd44:	b570      	push	{r4, r5, r6, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
    dd46:	6b85      	ldr	r5, [r0, #56]	; 0x38
  if (hi2c->hdmatx != NULL)
    dd48:	6bac      	ldr	r4, [r5, #56]	; 0x38
    dd4a:	b124      	cbz	r4, dd56 <I2C_DMAError+0x12>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
    dd4c:	6822      	ldr	r2, [r4, #0]
    dd4e:	6854      	ldr	r4, [r2, #4]
    dd50:	fab4 f484 	clz	r4, r4
    dd54:	0964      	lsrs	r4, r4, #5
  if (hi2c->hdmarx != NULL)
    dd56:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    dd58:	2b00      	cmp	r3, #0
    dd5a:	d049      	beq.n	ddf0 <I2C_DMAError+0xac>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
    dd5c:	681a      	ldr	r2, [r3, #0]
    dd5e:	6853      	ldr	r3, [r2, #4]
    dd60:	fab3 f383 	clz	r3, r3
    dd64:	095b      	lsrs	r3, r3, #5
    dd66:	2b00      	cmp	r3, #0
    dd68:	d042      	beq.n	ddf0 <I2C_DMAError+0xac>
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
    dd6a:	f7fd facf 	bl	b30c <HAL_DMA_GetError>
    dd6e:	2802      	cmp	r0, #2
    dd70:	d03d      	beq.n	ddee <I2C_DMAError+0xaa>
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
    dd72:	6829      	ldr	r1, [r5, #0]
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    dd74:	2200      	movs	r2, #0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    dd76:	4852      	ldr	r0, [pc, #328]	; (dec0 <I2C_DMAError+0x17c>)
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
    dd78:	684b      	ldr	r3, [r1, #4]
    dd7a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    dd7e:	604b      	str	r3, [r1, #4]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    dd80:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    dd84:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    dd88:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    dd8a:	62e8      	str	r0, [r5, #44]	; 0x2c
  hi2c->XferCount     = 0U;
    dd8c:	856a      	strh	r2, [r5, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
    dd8e:	6c6a      	ldr	r2, [r5, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    dd90:	2b02      	cmp	r3, #2
  hi2c->ErrorCode |= ErrorCode;
    dd92:	f042 0210 	orr.w	r2, r2, #16
    dd96:	646a      	str	r2, [r5, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    dd98:	d931      	bls.n	ddfe <I2C_DMAError+0xba>
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dd9a:	682a      	ldr	r2, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dd9c:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dda0:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dda4:	6813      	ldr	r3, [r2, #0]
    dda6:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    ddaa:	6013      	str	r3, [r2, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
    ddac:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    ddb0:	2b60      	cmp	r3, #96	; 0x60
    ddb2:	d002      	beq.n	ddba <I2C_DMAError+0x76>
      hi2c->State         = HAL_I2C_STATE_READY;
    ddb4:	2320      	movs	r3, #32
    ddb6:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
    hi2c->XferISR       = NULL;
    ddba:	2300      	movs	r3, #0
    ddbc:	636b      	str	r3, [r5, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    ddbe:	6ba8      	ldr	r0, [r5, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
    ddc0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    ddc2:	b118      	cbz	r0, ddcc <I2C_DMAError+0x88>
    ddc4:	2b11      	cmp	r3, #17
    ddc6:	d034      	beq.n	de32 <I2C_DMAError+0xee>
    ddc8:	2b21      	cmp	r3, #33	; 0x21
    ddca:	d032      	beq.n	de32 <I2C_DMAError+0xee>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
    ddcc:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    ddce:	b118      	cbz	r0, ddd8 <I2C_DMAError+0x94>
    ddd0:	2b12      	cmp	r3, #18
    ddd2:	d046      	beq.n	de62 <I2C_DMAError+0x11e>
    ddd4:	2b22      	cmp	r3, #34	; 0x22
    ddd6:	d044      	beq.n	de62 <I2C_DMAError+0x11e>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    ddd8:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    dddc:	2b60      	cmp	r3, #96	; 0x60
    ddde:	d063      	beq.n	dea8 <I2C_DMAError+0x164>
    hi2c->PreviousState = I2C_STATE_NONE;
    dde0:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
    dde2:	4628      	mov	r0, r5
    hi2c->PreviousState = I2C_STATE_NONE;
    dde4:	632b      	str	r3, [r5, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    dde6:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    ddea:	f7ff f811 	bl	ce10 <HAL_I2C_ErrorCallback>
}
    ddee:	bd70      	pop	{r4, r5, r6, pc}
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
    ddf0:	f7fd fa8c 	bl	b30c <HAL_DMA_GetError>
    ddf4:	2802      	cmp	r0, #2
    ddf6:	d0fa      	beq.n	ddee <I2C_DMAError+0xaa>
    ddf8:	07e0      	lsls	r0, r4, #31
    ddfa:	d4ba      	bmi.n	dd72 <I2C_DMAError+0x2e>
}
    ddfc:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ddfe:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    de02:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de04:	f895 1041 	ldrb.w	r1, [r5, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de08:	4033      	ands	r3, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    de0a:	6828      	ldr	r0, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de0c:	4031      	ands	r1, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    de0e:	4c2d      	ldr	r4, [pc, #180]	; (dec4 <I2C_DMAError+0x180>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de10:	42b3      	cmp	r3, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    de12:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de14:	bf14      	ite	ne
    de16:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
    de1a:	f06f 0246 	mvneq.w	r2, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de1e:	42b1      	cmp	r1, r6
    de20:	bf18      	it	ne
    de22:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    de26:	4013      	ands	r3, r2
    de28:	6003      	str	r3, [r0, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    de2a:	f885 6041 	strb.w	r6, [r5, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    de2e:	636c      	str	r4, [r5, #52]	; 0x34
    de30:	e7c5      	b.n	ddbe <I2C_DMAError+0x7a>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
    de32:	682b      	ldr	r3, [r5, #0]
    de34:	681a      	ldr	r2, [r3, #0]
    de36:	0451      	lsls	r1, r2, #17
    de38:	d430      	bmi.n	de9c <I2C_DMAError+0x158>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
    de3a:	f7fd fa63 	bl	b304 <HAL_DMA_GetState>
    de3e:	2801      	cmp	r0, #1
    de40:	d0ca      	beq.n	ddd8 <I2C_DMAError+0x94>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    de42:	6baa      	ldr	r2, [r5, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
    de44:	2300      	movs	r3, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    de46:	4920      	ldr	r1, [pc, #128]	; (dec8 <I2C_DMAError+0x184>)
    de48:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    de4a:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
    de4e:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    de50:	f7fd f91e 	bl	b090 <HAL_DMA_Abort_IT>
    de54:	2800      	cmp	r0, #0
    de56:	d0ca      	beq.n	ddee <I2C_DMAError+0xaa>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    de58:	6ba8      	ldr	r0, [r5, #56]	; 0x38
}
    de5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    de5e:	6d03      	ldr	r3, [r0, #80]	; 0x50
    de60:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
    de62:	682b      	ldr	r3, [r5, #0]
    de64:	681a      	ldr	r2, [r3, #0]
    de66:	0412      	lsls	r2, r2, #16
    de68:	d504      	bpl.n	de74 <I2C_DMAError+0x130>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    de6a:	681a      	ldr	r2, [r3, #0]
    de6c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    de70:	601a      	str	r2, [r3, #0]
    de72:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
    de74:	f7fd fa46 	bl	b304 <HAL_DMA_GetState>
    de78:	2801      	cmp	r0, #1
    de7a:	d0ad      	beq.n	ddd8 <I2C_DMAError+0x94>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    de7c:	6bea      	ldr	r2, [r5, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
    de7e:	2300      	movs	r3, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    de80:	4911      	ldr	r1, [pc, #68]	; (dec8 <I2C_DMAError+0x184>)
    de82:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    de84:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
    de88:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    de8a:	f7fd f901 	bl	b090 <HAL_DMA_Abort_IT>
    de8e:	2800      	cmp	r0, #0
    de90:	d0ad      	beq.n	ddee <I2C_DMAError+0xaa>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    de92:	6be8      	ldr	r0, [r5, #60]	; 0x3c
}
    de94:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    de98:	6d03      	ldr	r3, [r0, #80]	; 0x50
    de9a:	4718      	bx	r3
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    de9c:	681a      	ldr	r2, [r3, #0]
    de9e:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    dea2:	601a      	str	r2, [r3, #0]
    dea4:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    dea6:	e7c8      	b.n	de3a <I2C_DMAError+0xf6>
    hi2c->PreviousState = I2C_STATE_NONE;
    dea8:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
    deaa:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    deac:	4628      	mov	r0, r5
    hi2c->State = HAL_I2C_STATE_READY;
    deae:	f885 2041 	strb.w	r2, [r5, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    deb2:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    deb6:	632b      	str	r3, [r5, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    deb8:	f7fe ffac 	bl	ce14 <HAL_I2C_AbortCpltCallback>
}
    debc:	bd70      	pop	{r4, r5, r6, pc}
    debe:	bf00      	nop
    dec0:	ffff0000 	.word	0xffff0000
    dec4:	0000d14d 	.word	0x0000d14d
    dec8:	0000ce19 	.word	0x0000ce19

0000decc <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
    decc:	b570      	push	{r4, r5, r6, lr}
    dece:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ded0:	4b25      	ldr	r3, [pc, #148]	; (df68 <HAL_I2CEx_ConfigAnalogFilter+0x9c>)
    ded2:	4826      	ldr	r0, [pc, #152]	; (df6c <HAL_I2CEx_ConfigAnalogFilter+0xa0>)
{
    ded4:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ded6:	6822      	ldr	r2, [r4, #0]
    ded8:	4925      	ldr	r1, [pc, #148]	; (df70 <HAL_I2CEx_ConfigAnalogFilter+0xa4>)
    deda:	429a      	cmp	r2, r3
    dedc:	bf18      	it	ne
    dede:	4282      	cmpne	r2, r0
    dee0:	bf14      	ite	ne
    dee2:	2301      	movne	r3, #1
    dee4:	2300      	moveq	r3, #0
    dee6:	428a      	cmp	r2, r1
    dee8:	bf0c      	ite	eq
    deea:	2300      	moveq	r3, #0
    deec:	f003 0301 	andne.w	r3, r3, #1
    def0:	b113      	cbz	r3, def8 <HAL_I2CEx_ConfigAnalogFilter+0x2c>
    def2:	4b20      	ldr	r3, [pc, #128]	; (df74 <HAL_I2CEx_ConfigAnalogFilter+0xa8>)
    def4:	429a      	cmp	r2, r3
    def6:	d132      	bne.n	df5e <HAL_I2CEx_ConfigAnalogFilter+0x92>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
    def8:	f435 5380 	bics.w	r3, r5, #4096	; 0x1000
    defc:	d12a      	bne.n	df54 <HAL_I2CEx_ConfigAnalogFilter+0x88>

  if (hi2c->State == HAL_I2C_STATE_READY)
    defe:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    df02:	b2db      	uxtb	r3, r3
    df04:	2b20      	cmp	r3, #32
    df06:	d123      	bne.n	df50 <HAL_I2CEx_ConfigAnalogFilter+0x84>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
    df08:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
    df0c:	2a01      	cmp	r2, #1
    df0e:	d01f      	beq.n	df50 <HAL_I2CEx_ConfigAnalogFilter+0x84>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
    df10:	6826      	ldr	r6, [r4, #0]
    __HAL_LOCK(hi2c);
    df12:	2101      	movs	r1, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
    df14:	2224      	movs	r2, #36	; 0x24
    __HAL_LOCK(hi2c);
    df16:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    df1a:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
    df1c:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
    df20:	6832      	ldr	r2, [r6, #0]

    return HAL_OK;
    df22:	4608      	mov	r0, r1
    __HAL_I2C_DISABLE(hi2c);
    df24:	f022 0201 	bic.w	r2, r2, #1
    df28:	6032      	str	r2, [r6, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
    df2a:	6826      	ldr	r6, [r4, #0]
    df2c:	6832      	ldr	r2, [r6, #0]
    df2e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    df32:	6032      	str	r2, [r6, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
    df34:	6826      	ldr	r6, [r4, #0]
    df36:	6832      	ldr	r2, [r6, #0]
    df38:	4315      	orrs	r5, r2
    df3a:	6035      	str	r5, [r6, #0]
    __HAL_I2C_ENABLE(hi2c);
    df3c:	6825      	ldr	r5, [r4, #0]
    df3e:	682a      	ldr	r2, [r5, #0]
    df40:	f042 0201 	orr.w	r2, r2, #1
    df44:	602a      	str	r2, [r5, #0]
    hi2c->State = HAL_I2C_STATE_READY;
    df46:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    df4a:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
    df4e:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
    df50:	2002      	movs	r0, #2
}
    df52:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
    df54:	2165      	movs	r1, #101	; 0x65
    df56:	4808      	ldr	r0, [pc, #32]	; (df78 <HAL_I2CEx_ConfigAnalogFilter+0xac>)
    df58:	f00b fa5c 	bl	19414 <assert_failed>
    df5c:	e7cf      	b.n	defe <HAL_I2CEx_ConfigAnalogFilter+0x32>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    df5e:	2164      	movs	r1, #100	; 0x64
    df60:	4805      	ldr	r0, [pc, #20]	; (df78 <HAL_I2CEx_ConfigAnalogFilter+0xac>)
    df62:	f00b fa57 	bl	19414 <assert_failed>
    df66:	e7c7      	b.n	def8 <HAL_I2CEx_ConfigAnalogFilter+0x2c>
    df68:	40005400 	.word	0x40005400
    df6c:	40005800 	.word	0x40005800
    df70:	40005c00 	.word	0x40005c00
    df74:	58001c00 	.word	0x58001c00
    df78:	0002fdb8 	.word	0x0002fdb8

0000df7c <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
    df7c:	b570      	push	{r4, r5, r6, lr}
    df7e:	4604      	mov	r4, r0
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    df80:	4b24      	ldr	r3, [pc, #144]	; (e014 <HAL_I2CEx_ConfigDigitalFilter+0x98>)
    df82:	4825      	ldr	r0, [pc, #148]	; (e018 <HAL_I2CEx_ConfigDigitalFilter+0x9c>)
{
    df84:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    df86:	6822      	ldr	r2, [r4, #0]
    df88:	4924      	ldr	r1, [pc, #144]	; (e01c <HAL_I2CEx_ConfigDigitalFilter+0xa0>)
    df8a:	429a      	cmp	r2, r3
    df8c:	bf18      	it	ne
    df8e:	4282      	cmpne	r2, r0
    df90:	bf14      	ite	ne
    df92:	2301      	movne	r3, #1
    df94:	2300      	moveq	r3, #0
    df96:	428a      	cmp	r2, r1
    df98:	bf0c      	ite	eq
    df9a:	2300      	moveq	r3, #0
    df9c:	f003 0301 	andne.w	r3, r3, #1
    dfa0:	b113      	cbz	r3, dfa8 <HAL_I2CEx_ConfigDigitalFilter+0x2c>
    dfa2:	4b1f      	ldr	r3, [pc, #124]	; (e020 <HAL_I2CEx_ConfigDigitalFilter+0xa4>)
    dfa4:	429a      	cmp	r2, r3
    dfa6:	d12f      	bne.n	e008 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
    dfa8:	2d0f      	cmp	r5, #15
    dfaa:	d828      	bhi.n	dffe <HAL_I2CEx_ConfigDigitalFilter+0x82>

  if (hi2c->State == HAL_I2C_STATE_READY)
    dfac:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    dfb0:	b2db      	uxtb	r3, r3
    dfb2:	2b20      	cmp	r3, #32
    dfb4:	d121      	bne.n	dffa <HAL_I2CEx_ConfigDigitalFilter+0x7e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
    dfb6:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
    dfba:	2a01      	cmp	r2, #1
    dfbc:	d01d      	beq.n	dffa <HAL_I2CEx_ConfigDigitalFilter+0x7e>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
    dfbe:	6821      	ldr	r1, [r4, #0]
    __HAL_LOCK(hi2c);
    dfc0:	2001      	movs	r0, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
    dfc2:	2224      	movs	r2, #36	; 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    dfc4:	2600      	movs	r6, #0
    __HAL_LOCK(hi2c);
    dfc6:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_BUSY;
    dfca:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41

    return HAL_OK;
    dfce:	4630      	mov	r0, r6
    __HAL_I2C_DISABLE(hi2c);
    dfd0:	680a      	ldr	r2, [r1, #0]
    dfd2:	f022 0201 	bic.w	r2, r2, #1
    dfd6:	600a      	str	r2, [r1, #0]
    tmpreg = hi2c->Instance->CR1;
    dfd8:	6822      	ldr	r2, [r4, #0]
    dfda:	6811      	ldr	r1, [r2, #0]
    tmpreg &= ~(I2C_CR1_DNF);
    dfdc:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00
    tmpreg |= DigitalFilter << 8U;
    dfe0:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
    hi2c->Instance->CR1 = tmpreg;
    dfe4:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
    dfe6:	6821      	ldr	r1, [r4, #0]
    dfe8:	680a      	ldr	r2, [r1, #0]
    dfea:	f042 0201 	orr.w	r2, r2, #1
    dfee:	600a      	str	r2, [r1, #0]
    hi2c->State = HAL_I2C_STATE_READY;
    dff0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    dff4:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
    dff8:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
    dffa:	2002      	movs	r0, #2
}
    dffc:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
    dffe:	2193      	movs	r1, #147	; 0x93
    e000:	4808      	ldr	r0, [pc, #32]	; (e024 <HAL_I2CEx_ConfigDigitalFilter+0xa8>)
    e002:	f00b fa07 	bl	19414 <assert_failed>
    e006:	e7d1      	b.n	dfac <HAL_I2CEx_ConfigDigitalFilter+0x30>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    e008:	2192      	movs	r1, #146	; 0x92
    e00a:	4806      	ldr	r0, [pc, #24]	; (e024 <HAL_I2CEx_ConfigDigitalFilter+0xa8>)
    e00c:	f00b fa02 	bl	19414 <assert_failed>
    e010:	e7ca      	b.n	dfa8 <HAL_I2CEx_ConfigDigitalFilter+0x2c>
    e012:	bf00      	nop
    e014:	40005400 	.word	0x40005400
    e018:	40005800 	.word	0x40005800
    e01c:	40005c00 	.word	0x40005c00
    e020:	58001c00 	.word	0x58001c00
    e024:	0002fdb8 	.word	0x0002fdb8

0000e028 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
    e028:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));
    e02a:	1e43      	subs	r3, r0, #1
{
    e02c:	4604      	mov	r4, r0
  assert_param (IS_PWR_SUPPLY (SupplySource));
    e02e:	2b01      	cmp	r3, #1
    e030:	d904      	bls.n	e03c <HAL_PWREx_ConfigSupply+0x14>
    e032:	f44f 719d 	mov.w	r1, #314	; 0x13a
    e036:	4812      	ldr	r0, [pc, #72]	; (e080 <HAL_PWREx_ConfigSupply+0x58>)
    e038:	f00b f9ec 	bl	19414 <assert_failed>

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
    e03c:	4b11      	ldr	r3, [pc, #68]	; (e084 <HAL_PWREx_ConfigSupply+0x5c>)
    e03e:	68da      	ldr	r2, [r3, #12]
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
    e040:	68d8      	ldr	r0, [r3, #12]
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
    e042:	0752      	lsls	r2, r2, #29
    e044:	d405      	bmi.n	e052 <HAL_PWREx_ConfigSupply+0x2a>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
    e046:	f000 0007 	and.w	r0, r0, #7
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
    e04a:	1b00      	subs	r0, r0, r4
    e04c:	bf18      	it	ne
    e04e:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
    e050:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
    e052:	f020 0007 	bic.w	r0, r0, #7
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
    e056:	461d      	mov	r5, r3
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
    e058:	4320      	orrs	r0, r4
    e05a:	60d8      	str	r0, [r3, #12]
  tickstart = HAL_GetTick ();
    e05c:	f7fa f9ca 	bl	83f4 <HAL_GetTick>
    e060:	4604      	mov	r4, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
    e062:	e005      	b.n	e070 <HAL_PWREx_ConfigSupply+0x48>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
    e064:	f7fa f9c6 	bl	83f4 <HAL_GetTick>
    e068:	1b00      	subs	r0, r0, r4
    e06a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
    e06e:	d804      	bhi.n	e07a <HAL_PWREx_ConfigSupply+0x52>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
    e070:	686b      	ldr	r3, [r5, #4]
    e072:	049b      	lsls	r3, r3, #18
    e074:	d5f6      	bpl.n	e064 <HAL_PWREx_ConfigSupply+0x3c>
  return HAL_OK;
    e076:	2000      	movs	r0, #0
}
    e078:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_ERROR;
    e07a:	2001      	movs	r0, #1
}
    e07c:	bd38      	pop	{r3, r4, r5, pc}
    e07e:	bf00      	nop
    e080:	0002fdf4 	.word	0x0002fdf4
    e084:	58024800 	.word	0x58024800

0000e088 <HAL_PWREx_EnableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
    e088:	4a02      	ldr	r2, [pc, #8]	; (e094 <HAL_PWREx_EnableUSBVoltageDetector+0xc>)
    e08a:	68d3      	ldr	r3, [r2, #12]
    e08c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    e090:	60d3      	str	r3, [r2, #12]
}
    e092:	4770      	bx	lr
    e094:	58024800 	.word	0x58024800

0000e098 <HAL_PWREx_DisableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
    e098:	4a02      	ldr	r2, [pc, #8]	; (e0a4 <HAL_PWREx_DisableUSBVoltageDetector+0xc>)
    e09a:	68d3      	ldr	r3, [r2, #12]
    e09c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    e0a0:	60d3      	str	r3, [r2, #12]
}
    e0a2:	4770      	bx	lr
    e0a4:	58024800 	.word	0x58024800

0000e0a8 <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
    e0a8:	2800      	cmp	r0, #0
    e0aa:	f000 823c 	beq.w	e526 <HAL_RCC_OscConfig+0x47e>
{
    e0ae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    e0b0:	6803      	ldr	r3, [r0, #0]
    e0b2:	4604      	mov	r4, r0
    e0b4:	2b00      	cmp	r3, #0
    e0b6:	f000 80a6 	beq.w	e206 <HAL_RCC_OscConfig+0x15e>
    e0ba:	0698      	lsls	r0, r3, #26
    e0bc:	f000 821e 	beq.w	e4fc <HAL_RCC_OscConfig+0x454>
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
    e0c0:	07d9      	lsls	r1, r3, #31
    e0c2:	d536      	bpl.n	e132 <HAL_RCC_OscConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    e0c4:	6863      	ldr	r3, [r4, #4]
    e0c6:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
    e0ca:	d003      	beq.n	e0d4 <HAL_RCC_OscConfig+0x2c>
    e0cc:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
    e0d0:	f040 81e8 	bne.w	e4a4 <HAL_RCC_OscConfig+0x3fc>

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    e0d4:	4aa7      	ldr	r2, [pc, #668]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e0d6:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
    e0d8:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    e0da:	f003 0338 	and.w	r3, r3, #56	; 0x38
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
    e0de:	2b10      	cmp	r3, #16
    e0e0:	f000 81f2 	beq.w	e4c8 <HAL_RCC_OscConfig+0x420>
    e0e4:	2b18      	cmp	r3, #24
    e0e6:	f000 81ea 	beq.w	e4be <HAL_RCC_OscConfig+0x416>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    e0ea:	6863      	ldr	r3, [r4, #4]
    e0ec:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    e0f0:	f000 81f5 	beq.w	e4de <HAL_RCC_OscConfig+0x436>
    e0f4:	2b00      	cmp	r3, #0
    e0f6:	f040 8267 	bne.w	e5c8 <HAL_RCC_OscConfig+0x520>
    e0fa:	4b9e      	ldr	r3, [pc, #632]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e0fc:	681a      	ldr	r2, [r3, #0]
    e0fe:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    e102:	601a      	str	r2, [r3, #0]
    e104:	681a      	ldr	r2, [r3, #0]
    e106:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
    e10a:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
    e10c:	6863      	ldr	r3, [r4, #4]
    e10e:	2b00      	cmp	r3, #0
    e110:	f000 81fb 	beq.w	e50a <HAL_RCC_OscConfig+0x462>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
    e114:	f7fa f96e 	bl	83f4 <HAL_GetTick>

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    e118:	4d96      	ldr	r5, [pc, #600]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
        tickstart = HAL_GetTick();
    e11a:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    e11c:	e005      	b.n	e12a <HAL_RCC_OscConfig+0x82>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    e11e:	f7fa f969 	bl	83f4 <HAL_GetTick>
    e122:	1b80      	subs	r0, r0, r6
    e124:	2864      	cmp	r0, #100	; 0x64
    e126:	f200 81e7 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    e12a:	682b      	ldr	r3, [r5, #0]
    e12c:	039b      	lsls	r3, r3, #14
    e12e:	d5f6      	bpl.n	e11e <HAL_RCC_OscConfig+0x76>
    e130:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
    e132:	0798      	lsls	r0, r3, #30
    e134:	d52b      	bpl.n	e18e <HAL_RCC_OscConfig+0xe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    e136:	68e2      	ldr	r2, [r4, #12]
    e138:	2a19      	cmp	r2, #25
    e13a:	f200 8288 	bhi.w	e64e <HAL_RCC_OscConfig+0x5a6>
    e13e:	4b8e      	ldr	r3, [pc, #568]	; (e378 <HAL_RCC_OscConfig+0x2d0>)
    e140:	40d3      	lsrs	r3, r2
    e142:	07d9      	lsls	r1, r3, #31
    e144:	f140 8283 	bpl.w	e64e <HAL_RCC_OscConfig+0x5a6>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    e148:	6923      	ldr	r3, [r4, #16]
    e14a:	2b7f      	cmp	r3, #127	; 0x7f
    e14c:	f200 81a4 	bhi.w	e498 <HAL_RCC_OscConfig+0x3f0>

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    e150:	4a88      	ldr	r2, [pc, #544]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e152:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
    e154:	6a92      	ldr	r2, [r2, #40]	; 0x28
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
    e156:	f013 0338 	ands.w	r3, r3, #56	; 0x38
    e15a:	f040 8173 	bne.w	e444 <HAL_RCC_OscConfig+0x39c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
    e15e:	4b85      	ldr	r3, [pc, #532]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e160:	681b      	ldr	r3, [r3, #0]
    e162:	075b      	lsls	r3, r3, #29
    e164:	d503      	bpl.n	e16e <HAL_RCC_OscConfig+0xc6>
    e166:	68e3      	ldr	r3, [r4, #12]
    e168:	2b00      	cmp	r3, #0
    e16a:	f000 81b6 	beq.w	e4da <HAL_RCC_OscConfig+0x432>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    e16e:	f7fa f959 	bl	8424 <HAL_GetREVID>
    e172:	f241 0303 	movw	r3, #4099	; 0x1003
    e176:	4a7f      	ldr	r2, [pc, #508]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e178:	4298      	cmp	r0, r3
    e17a:	6921      	ldr	r1, [r4, #16]
    e17c:	6853      	ldr	r3, [r2, #4]
    e17e:	f200 825b 	bhi.w	e638 <HAL_RCC_OscConfig+0x590>
    e182:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
    e186:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
    e18a:	6053      	str	r3, [r2, #4]
    e18c:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
    e18e:	06d9      	lsls	r1, r3, #27
    e190:	d539      	bpl.n	e206 <HAL_RCC_OscConfig+0x15e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    e192:	69e3      	ldr	r3, [r4, #28]
    e194:	f033 0380 	bics.w	r3, r3, #128	; 0x80
    e198:	f040 81fd 	bne.w	e596 <HAL_RCC_OscConfig+0x4ee>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
    e19c:	6a23      	ldr	r3, [r4, #32]
    e19e:	2b3f      	cmp	r3, #63	; 0x3f
    e1a0:	f200 81f3 	bhi.w	e58a <HAL_RCC_OscConfig+0x4e2>

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    e1a4:	4a73      	ldr	r2, [pc, #460]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e1a6:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
    e1a8:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    e1aa:	f003 0338 	and.w	r3, r3, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
    e1ae:	2b08      	cmp	r3, #8
    e1b0:	f000 81c0 	beq.w	e534 <HAL_RCC_OscConfig+0x48c>
    e1b4:	2b18      	cmp	r3, #24
    e1b6:	f000 81b8 	beq.w	e52a <HAL_RCC_OscConfig+0x482>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
    e1ba:	69e3      	ldr	r3, [r4, #28]
    e1bc:	2b00      	cmp	r3, #0
    e1be:	f000 8211 	beq.w	e5e4 <HAL_RCC_OscConfig+0x53c>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
    e1c2:	4b6c      	ldr	r3, [pc, #432]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e1c4:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    e1c6:	461d      	mov	r5, r3
        __HAL_RCC_CSI_ENABLE();
    e1c8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    e1cc:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    e1ce:	f7fa f911 	bl	83f4 <HAL_GetTick>
    e1d2:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    e1d4:	e005      	b.n	e1e2 <HAL_RCC_OscConfig+0x13a>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
    e1d6:	f7fa f90d 	bl	83f4 <HAL_GetTick>
    e1da:	1b80      	subs	r0, r0, r6
    e1dc:	2802      	cmp	r0, #2
    e1de:	f200 818b 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    e1e2:	682b      	ldr	r3, [r5, #0]
    e1e4:	05db      	lsls	r3, r3, #23
    e1e6:	d5f6      	bpl.n	e1d6 <HAL_RCC_OscConfig+0x12e>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    e1e8:	f7fa f91c 	bl	8424 <HAL_GetREVID>
    e1ec:	f241 0303 	movw	r3, #4099	; 0x1003
    e1f0:	4298      	cmp	r0, r3
    e1f2:	f200 82b5 	bhi.w	e760 <HAL_RCC_OscConfig+0x6b8>
    e1f6:	686b      	ldr	r3, [r5, #4]
    e1f8:	6a22      	ldr	r2, [r4, #32]
    e1fa:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
    e1fe:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
    e202:	606b      	str	r3, [r5, #4]
    e204:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
    e206:	071d      	lsls	r5, r3, #28
    e208:	d51a      	bpl.n	e240 <HAL_RCC_OscConfig+0x198>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    e20a:	6963      	ldr	r3, [r4, #20]
    e20c:	2b01      	cmp	r3, #1
    e20e:	f200 814f 	bhi.w	e4b0 <HAL_RCC_OscConfig+0x408>

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
    e212:	2b00      	cmp	r3, #0
    e214:	f000 81a6 	beq.w	e564 <HAL_RCC_OscConfig+0x4bc>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
    e218:	4b56      	ldr	r3, [pc, #344]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e21a:	6f5a      	ldr	r2, [r3, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
    e21c:	461d      	mov	r5, r3
      __HAL_RCC_LSI_ENABLE();
    e21e:	f042 0201 	orr.w	r2, r2, #1
    e222:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
    e224:	f7fa f8e6 	bl	83f4 <HAL_GetTick>
    e228:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
    e22a:	e005      	b.n	e238 <HAL_RCC_OscConfig+0x190>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
    e22c:	f7fa f8e2 	bl	83f4 <HAL_GetTick>
    e230:	1b80      	subs	r0, r0, r6
    e232:	2802      	cmp	r0, #2
    e234:	f200 8160 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
    e238:	6f6b      	ldr	r3, [r5, #116]	; 0x74
    e23a:	0798      	lsls	r0, r3, #30
    e23c:	d5f6      	bpl.n	e22c <HAL_RCC_OscConfig+0x184>
    e23e:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
    e240:	069a      	lsls	r2, r3, #26
    e242:	d51a      	bpl.n	e27a <HAL_RCC_OscConfig+0x1d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
    e244:	69a3      	ldr	r3, [r4, #24]
    e246:	2b01      	cmp	r3, #1
    e248:	f200 814f 	bhi.w	e4ea <HAL_RCC_OscConfig+0x442>

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
    e24c:	2b00      	cmp	r3, #0
    e24e:	f000 81a8 	beq.w	e5a2 <HAL_RCC_OscConfig+0x4fa>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
    e252:	4b48      	ldr	r3, [pc, #288]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e254:	681a      	ldr	r2, [r3, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
    e256:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_ENABLE();
    e258:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    e25c:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
    e25e:	f7fa f8c9 	bl	83f4 <HAL_GetTick>
    e262:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
    e264:	e005      	b.n	e272 <HAL_RCC_OscConfig+0x1ca>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
    e266:	f7fa f8c5 	bl	83f4 <HAL_GetTick>
    e26a:	1b80      	subs	r0, r0, r6
    e26c:	2802      	cmp	r0, #2
    e26e:	f200 8143 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
    e272:	682b      	ldr	r3, [r5, #0]
    e274:	049f      	lsls	r7, r3, #18
    e276:	d5f6      	bpl.n	e266 <HAL_RCC_OscConfig+0x1be>
    e278:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
    e27a:	0759      	lsls	r1, r3, #29
    e27c:	d53c      	bpl.n	e2f8 <HAL_RCC_OscConfig+0x250>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    e27e:	68a3      	ldr	r3, [r4, #8]
    e280:	2b01      	cmp	r3, #1
    e282:	d902      	bls.n	e28a <HAL_RCC_OscConfig+0x1e2>
    e284:	2b05      	cmp	r3, #5
    e286:	f040 81f8 	bne.w	e67a <HAL_RCC_OscConfig+0x5d2>

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
    e28a:	4b3c      	ldr	r3, [pc, #240]	; (e37c <HAL_RCC_OscConfig+0x2d4>)
    e28c:	681a      	ldr	r2, [r3, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    e28e:	461d      	mov	r5, r3
    PWR->CR1 |= PWR_CR1_DBP;
    e290:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    e294:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    e296:	f7fa f8ad 	bl	83f4 <HAL_GetTick>
    e29a:	4606      	mov	r6, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    e29c:	e005      	b.n	e2aa <HAL_RCC_OscConfig+0x202>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
    e29e:	f7fa f8a9 	bl	83f4 <HAL_GetTick>
    e2a2:	1b80      	subs	r0, r0, r6
    e2a4:	2864      	cmp	r0, #100	; 0x64
    e2a6:	f200 8127 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    e2aa:	682b      	ldr	r3, [r5, #0]
    e2ac:	05da      	lsls	r2, r3, #23
    e2ae:	d5f6      	bpl.n	e29e <HAL_RCC_OscConfig+0x1f6>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    e2b0:	68a3      	ldr	r3, [r4, #8]
    e2b2:	2b01      	cmp	r3, #1
    e2b4:	f000 821d 	beq.w	e6f2 <HAL_RCC_OscConfig+0x64a>
    e2b8:	2b00      	cmp	r3, #0
    e2ba:	f040 8244 	bne.w	e746 <HAL_RCC_OscConfig+0x69e>
    e2be:	4b2d      	ldr	r3, [pc, #180]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e2c0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    e2c2:	f022 0201 	bic.w	r2, r2, #1
    e2c6:	671a      	str	r2, [r3, #112]	; 0x70
    e2c8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    e2ca:	f022 0204 	bic.w	r2, r2, #4
    e2ce:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    e2d0:	68a3      	ldr	r3, [r4, #8]
    e2d2:	2b00      	cmp	r3, #0
    e2d4:	f000 8213 	beq.w	e6fe <HAL_RCC_OscConfig+0x656>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
    e2d8:	f7fa f88c 	bl	83f4 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    e2dc:	4d25      	ldr	r5, [pc, #148]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
      tickstart = HAL_GetTick();
    e2de:	4607      	mov	r7, r0
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    e2e0:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    e2e4:	e005      	b.n	e2f2 <HAL_RCC_OscConfig+0x24a>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    e2e6:	f7fa f885 	bl	83f4 <HAL_GetTick>
    e2ea:	1bc0      	subs	r0, r0, r7
    e2ec:	42b0      	cmp	r0, r6
    e2ee:	f200 8103 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    e2f2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    e2f4:	079b      	lsls	r3, r3, #30
    e2f6:	d5f6      	bpl.n	e2e6 <HAL_RCC_OscConfig+0x23e>
      }
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    e2f8:	6a60      	ldr	r0, [r4, #36]	; 0x24
    e2fa:	2802      	cmp	r0, #2
    e2fc:	f200 81b6 	bhi.w	e66c <HAL_RCC_OscConfig+0x5c4>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
    e300:	2800      	cmp	r0, #0
    e302:	f000 809d 	beq.w	e440 <HAL_RCC_OscConfig+0x398>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
    e306:	4a1b      	ldr	r2, [pc, #108]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e308:	6913      	ldr	r3, [r2, #16]
    e30a:	f003 0338 	and.w	r3, r3, #56	; 0x38
    e30e:	2b18      	cmp	r3, #24
    e310:	f000 81c1 	beq.w	e696 <HAL_RCC_OscConfig+0x5ee>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
    e314:	2802      	cmp	r0, #2
    e316:	f040 8203 	bne.w	e720 <HAL_RCC_OscConfig+0x678>
      {
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    e31a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e31c:	2b03      	cmp	r3, #3
    e31e:	f200 8253 	bhi.w	e7c8 <HAL_RCC_OscConfig+0x720>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
    e322:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    e324:	3b01      	subs	r3, #1
    e326:	2b3e      	cmp	r3, #62	; 0x3e
    e328:	f200 8230 	bhi.w	e78c <HAL_RCC_OscConfig+0x6e4>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
    e32c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    e32e:	3b04      	subs	r3, #4
    e330:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    e334:	f200 8224 	bhi.w	e780 <HAL_RCC_OscConfig+0x6d8>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
    e338:	6b63      	ldr	r3, [r4, #52]	; 0x34
    e33a:	3b01      	subs	r3, #1
    e33c:	2b7f      	cmp	r3, #127	; 0x7f
    e33e:	f200 823d 	bhi.w	e7bc <HAL_RCC_OscConfig+0x714>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
    e342:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    e344:	3b01      	subs	r3, #1
    e346:	2b7f      	cmp	r3, #127	; 0x7f
    e348:	f200 8232 	bhi.w	e7b0 <HAL_RCC_OscConfig+0x708>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
    e34c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    e34e:	3b01      	subs	r3, #1
    e350:	2b7f      	cmp	r3, #127	; 0x7f
    e352:	f200 8227 	bhi.w	e7a4 <HAL_RCC_OscConfig+0x6fc>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
    e356:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    e358:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    e35c:	f080 821c 	bcs.w	e798 <HAL_RCC_OscConfig+0x6f0>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
    e360:	4b04      	ldr	r3, [pc, #16]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e362:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e364:	461d      	mov	r5, r3
        __HAL_RCC_PLL_DISABLE();
    e366:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
    e36a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    e36c:	f7fa f842 	bl	83f4 <HAL_GetTick>
    e370:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e372:	e00b      	b.n	e38c <HAL_RCC_OscConfig+0x2e4>
    e374:	58024400 	.word	0x58024400
    e378:	02020203 	.word	0x02020203
    e37c:	58024800 	.word	0x58024800
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    e380:	f7fa f838 	bl	83f4 <HAL_GetTick>
    e384:	1b80      	subs	r0, r0, r6
    e386:	2802      	cmp	r0, #2
    e388:	f200 80b6 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e38c:	682b      	ldr	r3, [r5, #0]
    e38e:	0199      	lsls	r1, r3, #6
    e390:	d4f6      	bmi.n	e380 <HAL_RCC_OscConfig+0x2d8>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    e392:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    e394:	4bb1      	ldr	r3, [pc, #708]	; (e65c <HAL_RCC_OscConfig+0x5b4>)
    e396:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    e398:	4013      	ands	r3, r2
    e39a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
    e39c:	49b0      	ldr	r1, [pc, #704]	; (e660 <HAL_RCC_OscConfig+0x5b8>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    e39e:	4303      	orrs	r3, r0

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    e3a0:	4eb0      	ldr	r6, [pc, #704]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    e3a2:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
    e3a6:	62ab      	str	r3, [r5, #40]	; 0x28
    e3a8:	6b27      	ldr	r7, [r4, #48]	; 0x30
    e3aa:	e9d4 320d 	ldrd	r3, r2, [r4, #52]	; 0x34
    e3ae:	3f01      	subs	r7, #1
    e3b0:	1e50      	subs	r0, r2, #1
    e3b2:	3b01      	subs	r3, #1
    e3b4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    e3b6:	f3c7 0708 	ubfx	r7, r7, #0, #9
    e3ba:	025b      	lsls	r3, r3, #9
    e3bc:	0400      	lsls	r0, r0, #16
    e3be:	3a01      	subs	r2, #1
    e3c0:	b29b      	uxth	r3, r3
    e3c2:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
    e3c6:	0612      	lsls	r2, r2, #24
    e3c8:	4303      	orrs	r3, r0
    e3ca:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
    e3ce:	433b      	orrs	r3, r7
    e3d0:	4313      	orrs	r3, r2
    e3d2:	632b      	str	r3, [r5, #48]	; 0x30
         __HAL_RCC_PLLFRACN_DISABLE();
    e3d4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e3d6:	f023 0301 	bic.w	r3, r3, #1
    e3da:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
    e3dc:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    e3de:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    e3e0:	4011      	ands	r1, r2
    e3e2:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
    e3e6:	6369      	str	r1, [r5, #52]	; 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
    e3e8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e3ea:	6c22      	ldr	r2, [r4, #64]	; 0x40
    e3ec:	f023 030c 	bic.w	r3, r3, #12
    e3f0:	4313      	orrs	r3, r2
    e3f2:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
    e3f4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e3f6:	6c62      	ldr	r2, [r4, #68]	; 0x44
    e3f8:	f023 0302 	bic.w	r3, r3, #2
    e3fc:	4313      	orrs	r3, r2
    e3fe:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
    e400:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e402:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    e406:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    e408:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e40a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    e40e:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
    e410:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e412:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    e416:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_ENABLE();
    e418:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e41a:	f043 0301 	orr.w	r3, r3, #1
    e41e:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_ENABLE();
    e420:	682b      	ldr	r3, [r5, #0]
    e422:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    e426:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
    e428:	f7f9 ffe4 	bl	83f4 <HAL_GetTick>
    e42c:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    e42e:	e004      	b.n	e43a <HAL_RCC_OscConfig+0x392>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    e430:	f7f9 ffe0 	bl	83f4 <HAL_GetTick>
    e434:	1b00      	subs	r0, r0, r4
    e436:	2802      	cmp	r0, #2
    e438:	d85e      	bhi.n	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    e43a:	6833      	ldr	r3, [r6, #0]
    e43c:	019a      	lsls	r2, r3, #6
    e43e:	d5f7      	bpl.n	e430 <HAL_RCC_OscConfig+0x388>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
    e440:	2000      	movs	r0, #0
}
    e442:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
    e444:	2b18      	cmp	r3, #24
    e446:	f000 80fe 	beq.w	e646 <HAL_RCC_OscConfig+0x59e>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
    e44a:	68e2      	ldr	r2, [r4, #12]
    e44c:	2a00      	cmp	r2, #0
    e44e:	f000 80de 	beq.w	e60e <HAL_RCC_OscConfig+0x566>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
    e452:	4984      	ldr	r1, [pc, #528]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e454:	680b      	ldr	r3, [r1, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    e456:	460d      	mov	r5, r1
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
    e458:	f023 0319 	bic.w	r3, r3, #25
    e45c:	4313      	orrs	r3, r2
    e45e:	600b      	str	r3, [r1, #0]
        tickstart = HAL_GetTick();
    e460:	f7f9 ffc8 	bl	83f4 <HAL_GetTick>
    e464:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    e466:	e004      	b.n	e472 <HAL_RCC_OscConfig+0x3ca>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    e468:	f7f9 ffc4 	bl	83f4 <HAL_GetTick>
    e46c:	1b80      	subs	r0, r0, r6
    e46e:	2802      	cmp	r0, #2
    e470:	d842      	bhi.n	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    e472:	682b      	ldr	r3, [r5, #0]
    e474:	075f      	lsls	r7, r3, #29
    e476:	d5f7      	bpl.n	e468 <HAL_RCC_OscConfig+0x3c0>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    e478:	f7f9 ffd4 	bl	8424 <HAL_GetREVID>
    e47c:	f241 0303 	movw	r3, #4099	; 0x1003
    e480:	6922      	ldr	r2, [r4, #16]
    e482:	4298      	cmp	r0, r3
    e484:	686b      	ldr	r3, [r5, #4]
    e486:	f200 8174 	bhi.w	e772 <HAL_RCC_OscConfig+0x6ca>
    e48a:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
    e48e:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
    e492:	606b      	str	r3, [r5, #4]
    e494:	6823      	ldr	r3, [r4, #0]
    e496:	e67a      	b.n	e18e <HAL_RCC_OscConfig+0xe6>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    e498:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
    e49c:	4872      	ldr	r0, [pc, #456]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e49e:	f00a ffb9 	bl	19414 <assert_failed>
    e4a2:	e655      	b.n	e150 <HAL_RCC_OscConfig+0xa8>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    e4a4:	f240 11a3 	movw	r1, #419	; 0x1a3
    e4a8:	486f      	ldr	r0, [pc, #444]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e4aa:	f00a ffb3 	bl	19414 <assert_failed>
    e4ae:	e611      	b.n	e0d4 <HAL_RCC_OscConfig+0x2c>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    e4b0:	f44f 7117 	mov.w	r1, #604	; 0x25c
    e4b4:	486c      	ldr	r0, [pc, #432]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e4b6:	f00a ffad 	bl	19414 <assert_failed>
    e4ba:	6963      	ldr	r3, [r4, #20]
    e4bc:	e6a9      	b.n	e212 <HAL_RCC_OscConfig+0x16a>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
    e4be:	f002 0203 	and.w	r2, r2, #3
    e4c2:	2a02      	cmp	r2, #2
    e4c4:	f47f ae11 	bne.w	e0ea <HAL_RCC_OscConfig+0x42>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
    e4c8:	4b66      	ldr	r3, [pc, #408]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e4ca:	681b      	ldr	r3, [r3, #0]
    e4cc:	039a      	lsls	r2, r3, #14
    e4ce:	f57f ae2f 	bpl.w	e130 <HAL_RCC_OscConfig+0x88>
    e4d2:	6863      	ldr	r3, [r4, #4]
    e4d4:	2b00      	cmp	r3, #0
    e4d6:	f47f ae2b 	bne.w	e130 <HAL_RCC_OscConfig+0x88>
        return HAL_ERROR;
    e4da:	2001      	movs	r0, #1
}
    e4dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    e4de:	4a61      	ldr	r2, [pc, #388]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e4e0:	6813      	ldr	r3, [r2, #0]
    e4e2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    e4e6:	6013      	str	r3, [r2, #0]
    e4e8:	e610      	b.n	e10c <HAL_RCC_OscConfig+0x64>
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
    e4ea:	f240 2187 	movw	r1, #647	; 0x287
    e4ee:	485e      	ldr	r0, [pc, #376]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e4f0:	f00a ff90 	bl	19414 <assert_failed>
    e4f4:	69a3      	ldr	r3, [r4, #24]
    e4f6:	e6a9      	b.n	e24c <HAL_RCC_OscConfig+0x1a4>
            return HAL_TIMEOUT;
    e4f8:	2003      	movs	r0, #3
}
    e4fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    e4fc:	f44f 71cf 	mov.w	r1, #414	; 0x19e
    e500:	4859      	ldr	r0, [pc, #356]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e502:	f00a ff87 	bl	19414 <assert_failed>
    e506:	6823      	ldr	r3, [r4, #0]
    e508:	e5da      	b.n	e0c0 <HAL_RCC_OscConfig+0x18>
        tickstart = HAL_GetTick();
    e50a:	f7f9 ff73 	bl	83f4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
    e50e:	4d55      	ldr	r5, [pc, #340]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
        tickstart = HAL_GetTick();
    e510:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
    e512:	e004      	b.n	e51e <HAL_RCC_OscConfig+0x476>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    e514:	f7f9 ff6e 	bl	83f4 <HAL_GetTick>
    e518:	1b80      	subs	r0, r0, r6
    e51a:	2864      	cmp	r0, #100	; 0x64
    e51c:	d8ec      	bhi.n	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
    e51e:	682b      	ldr	r3, [r5, #0]
    e520:	039f      	lsls	r7, r3, #14
    e522:	d4f7      	bmi.n	e514 <HAL_RCC_OscConfig+0x46c>
    e524:	e604      	b.n	e130 <HAL_RCC_OscConfig+0x88>
    return HAL_ERROR;
    e526:	2001      	movs	r0, #1
}
    e528:	4770      	bx	lr
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
    e52a:	f002 0203 	and.w	r2, r2, #3
    e52e:	2a01      	cmp	r2, #1
    e530:	f47f ae43 	bne.w	e1ba <HAL_RCC_OscConfig+0x112>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
    e534:	4b4b      	ldr	r3, [pc, #300]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e536:	681b      	ldr	r3, [r3, #0]
    e538:	05da      	lsls	r2, r3, #23
    e53a:	d502      	bpl.n	e542 <HAL_RCC_OscConfig+0x49a>
    e53c:	69e3      	ldr	r3, [r4, #28]
    e53e:	2b80      	cmp	r3, #128	; 0x80
    e540:	d1cb      	bne.n	e4da <HAL_RCC_OscConfig+0x432>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    e542:	f7f9 ff6f 	bl	8424 <HAL_GetREVID>
    e546:	f241 0303 	movw	r3, #4099	; 0x1003
    e54a:	4a46      	ldr	r2, [pc, #280]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e54c:	4298      	cmp	r0, r3
    e54e:	6a21      	ldr	r1, [r4, #32]
    e550:	f200 8099 	bhi.w	e686 <HAL_RCC_OscConfig+0x5de>
    e554:	6853      	ldr	r3, [r2, #4]
    e556:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
    e55a:	ea43 6381 	orr.w	r3, r3, r1, lsl #26
    e55e:	6053      	str	r3, [r2, #4]
    e560:	6823      	ldr	r3, [r4, #0]
    e562:	e650      	b.n	e206 <HAL_RCC_OscConfig+0x15e>
      __HAL_RCC_LSI_DISABLE();
    e564:	4b3f      	ldr	r3, [pc, #252]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e566:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
    e568:	461d      	mov	r5, r3
      __HAL_RCC_LSI_DISABLE();
    e56a:	f022 0201 	bic.w	r2, r2, #1
    e56e:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
    e570:	f7f9 ff40 	bl	83f4 <HAL_GetTick>
    e574:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
    e576:	e004      	b.n	e582 <HAL_RCC_OscConfig+0x4da>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
    e578:	f7f9 ff3c 	bl	83f4 <HAL_GetTick>
    e57c:	1b80      	subs	r0, r0, r6
    e57e:	2802      	cmp	r0, #2
    e580:	d8ba      	bhi.n	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
    e582:	6f6b      	ldr	r3, [r5, #116]	; 0x74
    e584:	0799      	lsls	r1, r3, #30
    e586:	d4f7      	bmi.n	e578 <HAL_RCC_OscConfig+0x4d0>
    e588:	e659      	b.n	e23e <HAL_RCC_OscConfig+0x196>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
    e58a:	f240 211b 	movw	r1, #539	; 0x21b
    e58e:	4836      	ldr	r0, [pc, #216]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e590:	f00a ff40 	bl	19414 <assert_failed>
    e594:	e606      	b.n	e1a4 <HAL_RCC_OscConfig+0xfc>
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    e596:	f240 211a 	movw	r1, #538	; 0x21a
    e59a:	4833      	ldr	r0, [pc, #204]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e59c:	f00a ff3a 	bl	19414 <assert_failed>
    e5a0:	e5fc      	b.n	e19c <HAL_RCC_OscConfig+0xf4>
      __HAL_RCC_HSI48_DISABLE();
    e5a2:	4b30      	ldr	r3, [pc, #192]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e5a4:	681a      	ldr	r2, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
    e5a6:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_DISABLE();
    e5a8:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    e5ac:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
    e5ae:	f7f9 ff21 	bl	83f4 <HAL_GetTick>
    e5b2:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
    e5b4:	e004      	b.n	e5c0 <HAL_RCC_OscConfig+0x518>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
    e5b6:	f7f9 ff1d 	bl	83f4 <HAL_GetTick>
    e5ba:	1b80      	subs	r0, r0, r6
    e5bc:	2802      	cmp	r0, #2
    e5be:	d89b      	bhi.n	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
    e5c0:	682b      	ldr	r3, [r5, #0]
    e5c2:	0498      	lsls	r0, r3, #18
    e5c4:	d4f7      	bmi.n	e5b6 <HAL_RCC_OscConfig+0x50e>
    e5c6:	e657      	b.n	e278 <HAL_RCC_OscConfig+0x1d0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    e5c8:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
    e5cc:	4b25      	ldr	r3, [pc, #148]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e5ce:	681a      	ldr	r2, [r3, #0]
    e5d0:	f47f ad95 	bne.w	e0fe <HAL_RCC_OscConfig+0x56>
    e5d4:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
    e5d8:	601a      	str	r2, [r3, #0]
    e5da:	681a      	ldr	r2, [r3, #0]
    e5dc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    e5e0:	601a      	str	r2, [r3, #0]
    e5e2:	e593      	b.n	e10c <HAL_RCC_OscConfig+0x64>
        __HAL_RCC_CSI_DISABLE();
    e5e4:	4b1f      	ldr	r3, [pc, #124]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e5e6:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
    e5e8:	461d      	mov	r5, r3
        __HAL_RCC_CSI_DISABLE();
    e5ea:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    e5ee:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    e5f0:	f7f9 ff00 	bl	83f4 <HAL_GetTick>
    e5f4:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
    e5f6:	e005      	b.n	e604 <HAL_RCC_OscConfig+0x55c>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
    e5f8:	f7f9 fefc 	bl	83f4 <HAL_GetTick>
    e5fc:	1b80      	subs	r0, r0, r6
    e5fe:	2802      	cmp	r0, #2
    e600:	f63f af7a 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
    e604:	682b      	ldr	r3, [r5, #0]
    e606:	05df      	lsls	r7, r3, #23
    e608:	d4f6      	bmi.n	e5f8 <HAL_RCC_OscConfig+0x550>
    e60a:	6823      	ldr	r3, [r4, #0]
    e60c:	e5fb      	b.n	e206 <HAL_RCC_OscConfig+0x15e>
        __HAL_RCC_HSI_DISABLE();
    e60e:	4b15      	ldr	r3, [pc, #84]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e610:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    e612:	461d      	mov	r5, r3
        __HAL_RCC_HSI_DISABLE();
    e614:	f022 0201 	bic.w	r2, r2, #1
    e618:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    e61a:	f7f9 feeb 	bl	83f4 <HAL_GetTick>
    e61e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    e620:	e005      	b.n	e62e <HAL_RCC_OscConfig+0x586>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    e622:	f7f9 fee7 	bl	83f4 <HAL_GetTick>
    e626:	1b80      	subs	r0, r0, r6
    e628:	2802      	cmp	r0, #2
    e62a:	f63f af65 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    e62e:	682b      	ldr	r3, [r5, #0]
    e630:	0758      	lsls	r0, r3, #29
    e632:	d4f6      	bmi.n	e622 <HAL_RCC_OscConfig+0x57a>
    e634:	6823      	ldr	r3, [r4, #0]
    e636:	e5aa      	b.n	e18e <HAL_RCC_OscConfig+0xe6>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    e638:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
    e63c:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    e640:	6053      	str	r3, [r2, #4]
    e642:	6823      	ldr	r3, [r4, #0]
    e644:	e5a3      	b.n	e18e <HAL_RCC_OscConfig+0xe6>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
    e646:	0792      	lsls	r2, r2, #30
    e648:	f47f aeff 	bne.w	e44a <HAL_RCC_OscConfig+0x3a2>
    e64c:	e587      	b.n	e15e <HAL_RCC_OscConfig+0xb6>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    e64e:	f240 11d7 	movw	r1, #471	; 0x1d7
    e652:	4805      	ldr	r0, [pc, #20]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e654:	f00a fede 	bl	19414 <assert_failed>
    e658:	e576      	b.n	e148 <HAL_RCC_OscConfig+0xa0>
    e65a:	bf00      	nop
    e65c:	fffffc0c 	.word	0xfffffc0c
    e660:	ffff0007 	.word	0xffff0007
    e664:	58024400 	.word	0x58024400
    e668:	0002fe30 	.word	0x0002fe30
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    e66c:	4859      	ldr	r0, [pc, #356]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e66e:	f240 21e3 	movw	r1, #739	; 0x2e3
    e672:	f00a fecf 	bl	19414 <assert_failed>
    e676:	6a60      	ldr	r0, [r4, #36]	; 0x24
    e678:	e642      	b.n	e300 <HAL_RCC_OscConfig+0x258>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    e67a:	f240 21b1 	movw	r1, #689	; 0x2b1
    e67e:	4855      	ldr	r0, [pc, #340]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e680:	f00a fec8 	bl	19414 <assert_failed>
    e684:	e601      	b.n	e28a <HAL_RCC_OscConfig+0x1e2>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    e686:	68d3      	ldr	r3, [r2, #12]
    e688:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
    e68c:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    e690:	60d3      	str	r3, [r2, #12]
    e692:	6823      	ldr	r3, [r4, #0]
    e694:	e5b7      	b.n	e206 <HAL_RCC_OscConfig+0x15e>
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    e696:	2801      	cmp	r0, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
    e698:	6a91      	ldr	r1, [r2, #40]	; 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
    e69a:	6b15      	ldr	r5, [r2, #48]	; 0x30
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    e69c:	f43f aed1 	beq.w	e442 <HAL_RCC_OscConfig+0x39a>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
    e6a0:	f001 0303 	and.w	r3, r1, #3
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    e6a4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    e6a6:	4293      	cmp	r3, r2
    e6a8:	f47f af17 	bne.w	e4da <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
    e6ac:	f3c1 1105 	ubfx	r1, r1, #4, #6
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
    e6b0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    e6b2:	4299      	cmp	r1, r3
    e6b4:	f47f af11 	bne.w	e4da <HAL_RCC_OscConfig+0x432>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
    e6b8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    e6ba:	f3c5 0208 	ubfx	r2, r5, #0, #9
    e6be:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
    e6c0:	429a      	cmp	r2, r3
    e6c2:	f47f af0a 	bne.w	e4da <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
    e6c6:	6b63      	ldr	r3, [r4, #52]	; 0x34
    e6c8:	f3c5 2246 	ubfx	r2, r5, #9, #7
    e6cc:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
    e6ce:	429a      	cmp	r2, r3
    e6d0:	f47f af03 	bne.w	e4da <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
    e6d4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    e6d6:	f3c5 4206 	ubfx	r2, r5, #16, #7
    e6da:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
    e6dc:	429a      	cmp	r2, r3
    e6de:	f47f aefc 	bne.w	e4da <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
    e6e2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    e6e4:	f3c5 6506 	ubfx	r5, r5, #24, #7
    e6e8:	3801      	subs	r0, #1
    return HAL_ERROR;
    e6ea:	1a28      	subs	r0, r5, r0
    e6ec:	bf18      	it	ne
    e6ee:	2001      	movne	r0, #1
    e6f0:	e6a7      	b.n	e442 <HAL_RCC_OscConfig+0x39a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    e6f2:	4a39      	ldr	r2, [pc, #228]	; (e7d8 <HAL_RCC_OscConfig+0x730>)
    e6f4:	6f13      	ldr	r3, [r2, #112]	; 0x70
    e6f6:	f043 0301 	orr.w	r3, r3, #1
    e6fa:	6713      	str	r3, [r2, #112]	; 0x70
    e6fc:	e5e8      	b.n	e2d0 <HAL_RCC_OscConfig+0x228>
      tickstart = HAL_GetTick();
    e6fe:	f7f9 fe79 	bl	83f4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
    e702:	4d35      	ldr	r5, [pc, #212]	; (e7d8 <HAL_RCC_OscConfig+0x730>)
      tickstart = HAL_GetTick();
    e704:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    e706:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
    e70a:	e005      	b.n	e718 <HAL_RCC_OscConfig+0x670>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    e70c:	f7f9 fe72 	bl	83f4 <HAL_GetTick>
    e710:	1bc0      	subs	r0, r0, r7
    e712:	42b0      	cmp	r0, r6
    e714:	f63f aef0 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
    e718:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    e71a:	0798      	lsls	r0, r3, #30
    e71c:	d4f6      	bmi.n	e70c <HAL_RCC_OscConfig+0x664>
    e71e:	e5eb      	b.n	e2f8 <HAL_RCC_OscConfig+0x250>
        __HAL_RCC_PLL_DISABLE();
    e720:	6813      	ldr	r3, [r2, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e722:	4614      	mov	r4, r2
        __HAL_RCC_PLL_DISABLE();
    e724:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    e728:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
    e72a:	f7f9 fe63 	bl	83f4 <HAL_GetTick>
    e72e:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e730:	e005      	b.n	e73e <HAL_RCC_OscConfig+0x696>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    e732:	f7f9 fe5f 	bl	83f4 <HAL_GetTick>
    e736:	1b40      	subs	r0, r0, r5
    e738:	2802      	cmp	r0, #2
    e73a:	f63f aedd 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e73e:	6823      	ldr	r3, [r4, #0]
    e740:	019b      	lsls	r3, r3, #6
    e742:	d4f6      	bmi.n	e732 <HAL_RCC_OscConfig+0x68a>
    e744:	e67c      	b.n	e440 <HAL_RCC_OscConfig+0x398>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    e746:	2b05      	cmp	r3, #5
    e748:	4b23      	ldr	r3, [pc, #140]	; (e7d8 <HAL_RCC_OscConfig+0x730>)
    e74a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    e74c:	f47f adb9 	bne.w	e2c2 <HAL_RCC_OscConfig+0x21a>
    e750:	f042 0204 	orr.w	r2, r2, #4
    e754:	671a      	str	r2, [r3, #112]	; 0x70
    e756:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    e758:	f042 0201 	orr.w	r2, r2, #1
    e75c:	671a      	str	r2, [r3, #112]	; 0x70
    e75e:	e5b7      	b.n	e2d0 <HAL_RCC_OscConfig+0x228>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    e760:	68eb      	ldr	r3, [r5, #12]
    e762:	6a22      	ldr	r2, [r4, #32]
    e764:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
    e768:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    e76c:	60eb      	str	r3, [r5, #12]
    e76e:	6823      	ldr	r3, [r4, #0]
    e770:	e549      	b.n	e206 <HAL_RCC_OscConfig+0x15e>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    e772:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
    e776:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    e77a:	606b      	str	r3, [r5, #4]
    e77c:	6823      	ldr	r3, [r4, #0]
    e77e:	e506      	b.n	e18e <HAL_RCC_OscConfig+0xe6>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
    e780:	f240 21ee 	movw	r1, #750	; 0x2ee
    e784:	4813      	ldr	r0, [pc, #76]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e786:	f00a fe45 	bl	19414 <assert_failed>
    e78a:	e5d5      	b.n	e338 <HAL_RCC_OscConfig+0x290>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
    e78c:	f240 21ed 	movw	r1, #749	; 0x2ed
    e790:	4810      	ldr	r0, [pc, #64]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e792:	f00a fe3f 	bl	19414 <assert_failed>
    e796:	e5c9      	b.n	e32c <HAL_RCC_OscConfig+0x284>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
    e798:	f240 21f2 	movw	r1, #754	; 0x2f2
    e79c:	480d      	ldr	r0, [pc, #52]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e79e:	f00a fe39 	bl	19414 <assert_failed>
    e7a2:	e5dd      	b.n	e360 <HAL_RCC_OscConfig+0x2b8>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
    e7a4:	f240 21f1 	movw	r1, #753	; 0x2f1
    e7a8:	480a      	ldr	r0, [pc, #40]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e7aa:	f00a fe33 	bl	19414 <assert_failed>
    e7ae:	e5d2      	b.n	e356 <HAL_RCC_OscConfig+0x2ae>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
    e7b0:	f44f 713c 	mov.w	r1, #752	; 0x2f0
    e7b4:	4807      	ldr	r0, [pc, #28]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e7b6:	f00a fe2d 	bl	19414 <assert_failed>
    e7ba:	e5c7      	b.n	e34c <HAL_RCC_OscConfig+0x2a4>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
    e7bc:	f240 21ef 	movw	r1, #751	; 0x2ef
    e7c0:	4804      	ldr	r0, [pc, #16]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e7c2:	f00a fe27 	bl	19414 <assert_failed>
    e7c6:	e5bc      	b.n	e342 <HAL_RCC_OscConfig+0x29a>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    e7c8:	f44f 713b 	mov.w	r1, #748	; 0x2ec
    e7cc:	4801      	ldr	r0, [pc, #4]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e7ce:	f00a fe21 	bl	19414 <assert_failed>
    e7d2:	e5a6      	b.n	e322 <HAL_RCC_OscConfig+0x27a>
    e7d4:	0002fe30 	.word	0x0002fe30
    e7d8:	58024400 	.word	0x58024400

0000e7dc <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
    e7dc:	4a3e      	ldr	r2, [pc, #248]	; (e8d8 <HAL_RCC_GetSysClockFreq+0xfc>)
    e7de:	6913      	ldr	r3, [r2, #16]
    e7e0:	f003 0338 	and.w	r3, r3, #56	; 0x38
    e7e4:	2b10      	cmp	r3, #16
    e7e6:	d04f      	beq.n	e888 <HAL_RCC_GetSysClockFreq+0xac>
    e7e8:	2b18      	cmp	r3, #24
    e7ea:	d00b      	beq.n	e804 <HAL_RCC_GetSysClockFreq+0x28>
    e7ec:	b10b      	cbz	r3, e7f2 <HAL_RCC_GetSysClockFreq+0x16>
      }

    break;

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
    e7ee:	483b      	ldr	r0, [pc, #236]	; (e8dc <HAL_RCC_GetSysClockFreq+0x100>)
    e7f0:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    e7f2:	6813      	ldr	r3, [r2, #0]
    e7f4:	0699      	lsls	r1, r3, #26
    e7f6:	d549      	bpl.n	e88c <HAL_RCC_GetSysClockFreq+0xb0>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    e7f8:	6813      	ldr	r3, [r2, #0]
    e7fa:	4839      	ldr	r0, [pc, #228]	; (e8e0 <HAL_RCC_GetSysClockFreq+0x104>)
    e7fc:	f3c3 03c1 	ubfx	r3, r3, #3, #2
    e800:	40d8      	lsrs	r0, r3
    e802:	4770      	bx	lr
{
    e804:	b410      	push	{r4}
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    e806:	6a91      	ldr	r1, [r2, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    e808:	6a90      	ldr	r0, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    e80a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    e80c:	f3c0 1005 	ubfx	r0, r0, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    e810:	6b54      	ldr	r4, [r2, #52]	; 0x34

    if (pllm != 0U)
    e812:	b3b0      	cbz	r0, e882 <HAL_RCC_GetSysClockFreq+0xa6>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    e814:	f3c4 04cc 	ubfx	r4, r4, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    e818:	f003 0301 	and.w	r3, r3, #1
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    e81c:	f001 0103 	and.w	r1, r1, #3
    e820:	ee07 0a90 	vmov	s15, r0
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    e824:	fb03 f304 	mul.w	r3, r3, r4
    {
      switch (pllsource)
    e828:	2901      	cmp	r1, #1
    e82a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    e82e:	ee07 3a10 	vmov	s14, r3
    e832:	eeba 7ae9 	vcvt.f32.s32	s14, s14, #13
      switch (pllsource)
    e836:	d002      	beq.n	e83e <HAL_RCC_GetSysClockFreq+0x62>
    e838:	d32d      	bcc.n	e896 <HAL_RCC_GetSysClockFreq+0xba>
    e83a:	2902      	cmp	r1, #2
    e83c:	d028      	beq.n	e890 <HAL_RCC_GetSysClockFreq+0xb4>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e83e:	eddf 5a29 	vldr	s11, [pc, #164]	; e8e4 <HAL_RCC_GetSysClockFreq+0x108>
    e842:	eec5 6aa7 	vdiv.f32	s13, s11, s15
    e846:	6b13      	ldr	r3, [r2, #48]	; 0x30
    e848:	f3c3 0308 	ubfx	r3, r3, #0, #9
    e84c:	ee07 3a90 	vmov	s15, r3
    e850:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    e854:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    e858:	ee77 7a86 	vadd.f32	s15, s15, s12
    e85c:	ee37 7a87 	vadd.f32	s14, s15, s14
    e860:	ee27 7a26 	vmul.f32	s14, s14, s13
        break;
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
    e864:	4b1c      	ldr	r3, [pc, #112]	; (e8d8 <HAL_RCC_GetSysClockFreq+0xfc>)
    e866:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    e868:	f3c3 2346 	ubfx	r3, r3, #9, #7
    e86c:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
    e86e:	ee07 3a90 	vmov	s15, r3
    e872:	eef8 6ae7 	vcvt.f32.s32	s13, s15
    e876:	eec7 7a26 	vdiv.f32	s15, s14, s13
    e87a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    e87e:	ee17 0a90 	vmov	r0, s15
    sysclockfreq = CSI_VALUE;
    break;
  }

  return sysclockfreq;
}
    e882:	f85d 4b04 	ldr.w	r4, [sp], #4
    e886:	4770      	bx	lr
    sysclockfreq = HSE_VALUE;
    e888:	4817      	ldr	r0, [pc, #92]	; (e8e8 <HAL_RCC_GetSysClockFreq+0x10c>)
    e88a:	4770      	bx	lr
        sysclockfreq = (uint32_t) HSI_VALUE;
    e88c:	4814      	ldr	r0, [pc, #80]	; (e8e0 <HAL_RCC_GetSysClockFreq+0x104>)
}
    e88e:	4770      	bx	lr
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e890:	eddf 5a16 	vldr	s11, [pc, #88]	; e8ec <HAL_RCC_GetSysClockFreq+0x110>
    e894:	e7d5      	b.n	e842 <HAL_RCC_GetSysClockFreq+0x66>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    e896:	6813      	ldr	r3, [r2, #0]
    e898:	069b      	lsls	r3, r3, #26
    e89a:	d51a      	bpl.n	e8d2 <HAL_RCC_GetSysClockFreq+0xf6>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    e89c:	6810      	ldr	r0, [r2, #0]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e89e:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    e8a2:	490f      	ldr	r1, [pc, #60]	; (e8e0 <HAL_RCC_GetSysClockFreq+0x104>)
    e8a4:	f3c0 00c1 	ubfx	r0, r0, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e8a8:	6b13      	ldr	r3, [r2, #48]	; 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    e8aa:	40c1      	lsrs	r1, r0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e8ac:	f3c3 0308 	ubfx	r3, r3, #0, #9
    e8b0:	ee06 1a90 	vmov	s13, r1
    e8b4:	eef8 5ae6 	vcvt.f32.s32	s11, s13
    e8b8:	ee06 3a90 	vmov	s13, r3
    e8bc:	eeb8 6ae6 	vcvt.f32.s32	s12, s13
    e8c0:	eec5 6aa7 	vdiv.f32	s13, s11, s15
    e8c4:	ee76 7a05 	vadd.f32	s15, s12, s10
    e8c8:	ee37 7a87 	vadd.f32	s14, s15, s14
    e8cc:	ee26 7a87 	vmul.f32	s14, s13, s14
    e8d0:	e7c8      	b.n	e864 <HAL_RCC_GetSysClockFreq+0x88>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e8d2:	eddf 5a07 	vldr	s11, [pc, #28]	; e8f0 <HAL_RCC_GetSysClockFreq+0x114>
    e8d6:	e7b4      	b.n	e842 <HAL_RCC_GetSysClockFreq+0x66>
    e8d8:	58024400 	.word	0x58024400
    e8dc:	003d0900 	.word	0x003d0900
    e8e0:	03d09000 	.word	0x03d09000
    e8e4:	4a742400 	.word	0x4a742400
    e8e8:	017d7840 	.word	0x017d7840
    e8ec:	4bbebc20 	.word	0x4bbebc20
    e8f0:	4c742400 	.word	0x4c742400

0000e8f4 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
    e8f4:	2800      	cmp	r0, #0
    e8f6:	f000 81bd 	beq.w	ec74 <HAL_RCC_ClockConfig+0x380>
{
    e8fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    e8fe:	6803      	ldr	r3, [r0, #0]
    e900:	4604      	mov	r4, r0
    e902:	460d      	mov	r5, r1
    e904:	3b01      	subs	r3, #1
    e906:	2b3e      	cmp	r3, #62	; 0x3e
    e908:	f200 81a1 	bhi.w	ec4e <HAL_RCC_ClockConfig+0x35a>
  assert_param(IS_FLASH_LATENCY(FLatency));
    e90c:	2d0f      	cmp	r5, #15
    e90e:	f200 818e 	bhi.w	ec2e <HAL_RCC_ClockConfig+0x33a>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
    e912:	4a5e      	ldr	r2, [pc, #376]	; (ea8c <HAL_RCC_ClockConfig+0x198>)
    e914:	6813      	ldr	r3, [r2, #0]
    e916:	f003 030f 	and.w	r3, r3, #15
    e91a:	42ab      	cmp	r3, r5
    e91c:	f0c0 81ac 	bcc.w	ec78 <HAL_RCC_ClockConfig+0x384>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
    e920:	6823      	ldr	r3, [r4, #0]
    e922:	075e      	lsls	r6, r3, #29
    e924:	d512      	bpl.n	e94c <HAL_RCC_ClockConfig+0x58>
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
    e926:	4a5a      	ldr	r2, [pc, #360]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e928:	6921      	ldr	r1, [r4, #16]
    e92a:	6992      	ldr	r2, [r2, #24]
    e92c:	f002 0270 	and.w	r2, r2, #112	; 0x70
    e930:	4291      	cmp	r1, r2
    e932:	d90b      	bls.n	e94c <HAL_RCC_ClockConfig+0x58>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    e934:	f021 0330 	bic.w	r3, r1, #48	; 0x30
    e938:	2b40      	cmp	r3, #64	; 0x40
    e93a:	f040 81c0 	bne.w	ecbe <HAL_RCC_ClockConfig+0x3ca>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
    e93e:	4a54      	ldr	r2, [pc, #336]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e940:	6993      	ldr	r3, [r2, #24]
    e942:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    e946:	4319      	orrs	r1, r3
    e948:	6191      	str	r1, [r2, #24]
    e94a:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
    e94c:	0718      	lsls	r0, r3, #28
    e94e:	d512      	bpl.n	e976 <HAL_RCC_ClockConfig+0x82>
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
    e950:	4a4f      	ldr	r2, [pc, #316]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e952:	6961      	ldr	r1, [r4, #20]
    e954:	69d2      	ldr	r2, [r2, #28]
    e956:	f002 0270 	and.w	r2, r2, #112	; 0x70
    e95a:	4291      	cmp	r1, r2
    e95c:	d90b      	bls.n	e976 <HAL_RCC_ClockConfig+0x82>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    e95e:	f021 0330 	bic.w	r3, r1, #48	; 0x30
    e962:	2b40      	cmp	r3, #64	; 0x40
    e964:	f040 81b2 	bne.w	eccc <HAL_RCC_ClockConfig+0x3d8>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    e968:	4a49      	ldr	r2, [pc, #292]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e96a:	69d3      	ldr	r3, [r2, #28]
    e96c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    e970:	4319      	orrs	r1, r3
    e972:	61d1      	str	r1, [r2, #28]
    e974:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
    e976:	06d9      	lsls	r1, r3, #27
    e978:	d513      	bpl.n	e9a2 <HAL_RCC_ClockConfig+0xae>
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
    e97a:	4a45      	ldr	r2, [pc, #276]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e97c:	69a1      	ldr	r1, [r4, #24]
    e97e:	69d2      	ldr	r2, [r2, #28]
    e980:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    e984:	4291      	cmp	r1, r2
    e986:	d90c      	bls.n	e9a2 <HAL_RCC_ClockConfig+0xae>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    e988:	f421 7340 	bic.w	r3, r1, #768	; 0x300
    e98c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    e990:	f040 81a3 	bne.w	ecda <HAL_RCC_ClockConfig+0x3e6>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
    e994:	4a3e      	ldr	r2, [pc, #248]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e996:	69d3      	ldr	r3, [r2, #28]
    e998:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    e99c:	4319      	orrs	r1, r3
    e99e:	61d1      	str	r1, [r2, #28]
    e9a0:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
    e9a2:	069a      	lsls	r2, r3, #26
    e9a4:	d512      	bpl.n	e9cc <HAL_RCC_ClockConfig+0xd8>
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
    e9a6:	4a3a      	ldr	r2, [pc, #232]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e9a8:	69e1      	ldr	r1, [r4, #28]
    e9aa:	6a12      	ldr	r2, [r2, #32]
    e9ac:	f002 0270 	and.w	r2, r2, #112	; 0x70
    e9b0:	4291      	cmp	r1, r2
    e9b2:	d90b      	bls.n	e9cc <HAL_RCC_ClockConfig+0xd8>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
    e9b4:	f021 0330 	bic.w	r3, r1, #48	; 0x30
    e9b8:	2b40      	cmp	r3, #64	; 0x40
    e9ba:	f040 8179 	bne.w	ecb0 <HAL_RCC_ClockConfig+0x3bc>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
    e9be:	4a34      	ldr	r2, [pc, #208]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e9c0:	6a13      	ldr	r3, [r2, #32]
    e9c2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    e9c6:	4319      	orrs	r1, r3
    e9c8:	6211      	str	r1, [r2, #32]
    e9ca:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
    e9cc:	079f      	lsls	r7, r3, #30
    e9ce:	d512      	bpl.n	e9f6 <HAL_RCC_ClockConfig+0x102>
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
    e9d0:	4a2f      	ldr	r2, [pc, #188]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e9d2:	68e1      	ldr	r1, [r4, #12]
    e9d4:	6992      	ldr	r2, [r2, #24]
    e9d6:	f002 020f 	and.w	r2, r2, #15
    e9da:	4291      	cmp	r1, r2
    e9dc:	d90b      	bls.n	e9f6 <HAL_RCC_ClockConfig+0x102>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    e9de:	f1a1 0308 	sub.w	r3, r1, #8
    e9e2:	2b07      	cmp	r3, #7
    e9e4:	f200 8180 	bhi.w	ece8 <HAL_RCC_ClockConfig+0x3f4>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
    e9e8:	4a29      	ldr	r2, [pc, #164]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e9ea:	6993      	ldr	r3, [r2, #24]
    e9ec:	f023 030f 	bic.w	r3, r3, #15
    e9f0:	4319      	orrs	r1, r3
    e9f2:	6191      	str	r1, [r2, #24]
    e9f4:	6823      	ldr	r3, [r4, #0]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    e9f6:	07de      	lsls	r6, r3, #31
    e9f8:	d55a      	bpl.n	eab0 <HAL_RCC_ClockConfig+0x1bc>
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
    e9fa:	68a2      	ldr	r2, [r4, #8]
    e9fc:	f432 6300 	bics.w	r3, r2, #2048	; 0x800
    ea00:	f422 7000 	bic.w	r0, r2, #512	; 0x200
    ea04:	f422 6180 	bic.w	r1, r2, #1024	; 0x400
    ea08:	bf14      	ite	ne
    ea0a:	2301      	movne	r3, #1
    ea0c:	2300      	moveq	r3, #0
    ea0e:	f5b0 6f10 	cmp.w	r0, #2304	; 0x900
    ea12:	bf0c      	ite	eq
    ea14:	2300      	moveq	r3, #0
    ea16:	f003 0301 	andne.w	r3, r3, #1
    ea1a:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
    ea1e:	bf0c      	ite	eq
    ea20:	2300      	moveq	r3, #0
    ea22:	f003 0301 	andne.w	r3, r3, #1
    ea26:	f5b1 6f20 	cmp.w	r1, #2560	; 0xa00
    ea2a:	bf0c      	ite	eq
    ea2c:	2300      	moveq	r3, #0
    ea2e:	f003 0301 	andne.w	r3, r3, #1
    ea32:	b12b      	cbz	r3, ea40 <HAL_RCC_ClockConfig+0x14c>
    ea34:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    ea38:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
    ea3c:	f040 812e 	bne.w	ec9c <HAL_RCC_ClockConfig+0x3a8>
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    ea40:	6863      	ldr	r3, [r4, #4]
    ea42:	2b03      	cmp	r3, #3
    ea44:	f200 8110 	bhi.w	ec68 <HAL_RCC_ClockConfig+0x374>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
    ea48:	4a11      	ldr	r2, [pc, #68]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    ea4a:	68a1      	ldr	r1, [r4, #8]
    ea4c:	6993      	ldr	r3, [r2, #24]
    ea4e:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
    ea52:	430b      	orrs	r3, r1
    ea54:	6193      	str	r3, [r2, #24]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    ea56:	6863      	ldr	r3, [r4, #4]
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    ea58:	6812      	ldr	r2, [r2, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    ea5a:	2b02      	cmp	r3, #2
    ea5c:	f000 8100 	beq.w	ec60 <HAL_RCC_ClockConfig+0x36c>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    ea60:	2b03      	cmp	r3, #3
    ea62:	f000 8117 	beq.w	ec94 <HAL_RCC_ClockConfig+0x3a0>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
    ea66:	2b01      	cmp	r3, #1
    ea68:	f000 811e 	beq.w	eca8 <HAL_RCC_ClockConfig+0x3b4>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    ea6c:	0757      	lsls	r7, r2, #29
    ea6e:	f140 80eb 	bpl.w	ec48 <HAL_RCC_ClockConfig+0x354>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    ea72:	4907      	ldr	r1, [pc, #28]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    ea74:	f241 3888 	movw	r8, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    ea78:	690a      	ldr	r2, [r1, #16]
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    ea7a:	460e      	mov	r6, r1
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    ea7c:	f022 0207 	bic.w	r2, r2, #7
    ea80:	4313      	orrs	r3, r2
    ea82:	610b      	str	r3, [r1, #16]
      tickstart = HAL_GetTick();
    ea84:	f7f9 fcb6 	bl	83f4 <HAL_GetTick>
    ea88:	4607      	mov	r7, r0
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    ea8a:	e009      	b.n	eaa0 <HAL_RCC_ClockConfig+0x1ac>
    ea8c:	52002000 	.word	0x52002000
    ea90:	58024400 	.word	0x58024400
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    ea94:	f7f9 fcae 	bl	83f4 <HAL_GetTick>
    ea98:	1bc0      	subs	r0, r0, r7
    ea9a:	4540      	cmp	r0, r8
    ea9c:	f200 80f8 	bhi.w	ec90 <HAL_RCC_ClockConfig+0x39c>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    eaa0:	6933      	ldr	r3, [r6, #16]
    eaa2:	6862      	ldr	r2, [r4, #4]
    eaa4:	f003 0338 	and.w	r3, r3, #56	; 0x38
    eaa8:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
    eaac:	d1f2      	bne.n	ea94 <HAL_RCC_ClockConfig+0x1a0>
    eaae:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
    eab0:	079e      	lsls	r6, r3, #30
    eab2:	d517      	bpl.n	eae4 <HAL_RCC_ClockConfig+0x1f0>
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
    eab4:	4b90      	ldr	r3, [pc, #576]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eab6:	68e2      	ldr	r2, [r4, #12]
    eab8:	699b      	ldr	r3, [r3, #24]
    eaba:	f003 030f 	and.w	r3, r3, #15
    eabe:	429a      	cmp	r2, r3
    eac0:	d210      	bcs.n	eae4 <HAL_RCC_ClockConfig+0x1f0>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    eac2:	f1a2 0308 	sub.w	r3, r2, #8
    eac6:	2b06      	cmp	r3, #6
    eac8:	d906      	bls.n	ead8 <HAL_RCC_ClockConfig+0x1e4>
    eaca:	b12a      	cbz	r2, ead8 <HAL_RCC_ClockConfig+0x1e4>
    eacc:	f240 4136 	movw	r1, #1078	; 0x436
    ead0:	488a      	ldr	r0, [pc, #552]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ead2:	f00a fc9f 	bl	19414 <assert_failed>
    ead6:	68e2      	ldr	r2, [r4, #12]
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
    ead8:	4987      	ldr	r1, [pc, #540]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eada:	698b      	ldr	r3, [r1, #24]
    eadc:	f023 030f 	bic.w	r3, r3, #15
    eae0:	431a      	orrs	r2, r3
    eae2:	618a      	str	r2, [r1, #24]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
    eae4:	4a86      	ldr	r2, [pc, #536]	; (ed00 <HAL_RCC_ClockConfig+0x40c>)
    eae6:	6813      	ldr	r3, [r2, #0]
    eae8:	f003 030f 	and.w	r3, r3, #15
    eaec:	42ab      	cmp	r3, r5
    eaee:	d90a      	bls.n	eb06 <HAL_RCC_ClockConfig+0x212>
    __HAL_FLASH_SET_LATENCY(FLatency);
    eaf0:	6813      	ldr	r3, [r2, #0]
    eaf2:	f023 030f 	bic.w	r3, r3, #15
    eaf6:	432b      	orrs	r3, r5
    eaf8:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
    eafa:	6813      	ldr	r3, [r2, #0]
    eafc:	f003 030f 	and.w	r3, r3, #15
    eb00:	42ab      	cmp	r3, r5
    eb02:	f040 80a1 	bne.w	ec48 <HAL_RCC_ClockConfig+0x354>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
    eb06:	6823      	ldr	r3, [r4, #0]
    eb08:	0758      	lsls	r0, r3, #29
    eb0a:	d51a      	bpl.n	eb42 <HAL_RCC_ClockConfig+0x24e>
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
    eb0c:	4a7a      	ldr	r2, [pc, #488]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eb0e:	6921      	ldr	r1, [r4, #16]
    eb10:	6992      	ldr	r2, [r2, #24]
    eb12:	f002 0270 	and.w	r2, r2, #112	; 0x70
    eb16:	4291      	cmp	r1, r2
    eb18:	d213      	bcs.n	eb42 <HAL_RCC_ClockConfig+0x24e>
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    eb1a:	2950      	cmp	r1, #80	; 0x50
    eb1c:	bf18      	it	ne
    eb1e:	2960      	cmpne	r1, #96	; 0x60
    eb20:	d008      	beq.n	eb34 <HAL_RCC_ClockConfig+0x240>
    eb22:	f031 0340 	bics.w	r3, r1, #64	; 0x40
    eb26:	d005      	beq.n	eb34 <HAL_RCC_ClockConfig+0x240>
    eb28:	f240 4157 	movw	r1, #1111	; 0x457
    eb2c:	4873      	ldr	r0, [pc, #460]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    eb2e:	f00a fc71 	bl	19414 <assert_failed>
    eb32:	6921      	ldr	r1, [r4, #16]
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
    eb34:	4a70      	ldr	r2, [pc, #448]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eb36:	6993      	ldr	r3, [r2, #24]
    eb38:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    eb3c:	4319      	orrs	r1, r3
    eb3e:	6191      	str	r1, [r2, #24]
    eb40:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
    eb42:	0719      	lsls	r1, r3, #28
    eb44:	d51a      	bpl.n	eb7c <HAL_RCC_ClockConfig+0x288>
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
    eb46:	4a6c      	ldr	r2, [pc, #432]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eb48:	6961      	ldr	r1, [r4, #20]
    eb4a:	69d2      	ldr	r2, [r2, #28]
    eb4c:	f002 0270 	and.w	r2, r2, #112	; 0x70
    eb50:	4291      	cmp	r1, r2
    eb52:	d213      	bcs.n	eb7c <HAL_RCC_ClockConfig+0x288>
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    eb54:	2950      	cmp	r1, #80	; 0x50
    eb56:	bf18      	it	ne
    eb58:	2960      	cmpne	r1, #96	; 0x60
    eb5a:	d008      	beq.n	eb6e <HAL_RCC_ClockConfig+0x27a>
    eb5c:	f031 0340 	bics.w	r3, r1, #64	; 0x40
    eb60:	d005      	beq.n	eb6e <HAL_RCC_ClockConfig+0x27a>
    eb62:	f240 4169 	movw	r1, #1129	; 0x469
    eb66:	4865      	ldr	r0, [pc, #404]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    eb68:	f00a fc54 	bl	19414 <assert_failed>
    eb6c:	6961      	ldr	r1, [r4, #20]
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    eb6e:	4a62      	ldr	r2, [pc, #392]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eb70:	69d3      	ldr	r3, [r2, #28]
    eb72:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    eb76:	4319      	orrs	r1, r3
    eb78:	61d1      	str	r1, [r2, #28]
    eb7a:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
    eb7c:	06da      	lsls	r2, r3, #27
    eb7e:	d51c      	bpl.n	ebba <HAL_RCC_ClockConfig+0x2c6>
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
    eb80:	4a5d      	ldr	r2, [pc, #372]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eb82:	69a1      	ldr	r1, [r4, #24]
    eb84:	69d2      	ldr	r2, [r2, #28]
    eb86:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    eb8a:	4291      	cmp	r1, r2
    eb8c:	d215      	bcs.n	ebba <HAL_RCC_ClockConfig+0x2c6>
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    eb8e:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
    eb92:	bf18      	it	ne
    eb94:	f5b1 6fa0 	cmpne.w	r1, #1280	; 0x500
    eb98:	d008      	beq.n	ebac <HAL_RCC_ClockConfig+0x2b8>
    eb9a:	f431 6380 	bics.w	r3, r1, #1024	; 0x400
    eb9e:	d005      	beq.n	ebac <HAL_RCC_ClockConfig+0x2b8>
    eba0:	f240 417b 	movw	r1, #1147	; 0x47b
    eba4:	4855      	ldr	r0, [pc, #340]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    eba6:	f00a fc35 	bl	19414 <assert_failed>
    ebaa:	69a1      	ldr	r1, [r4, #24]
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
    ebac:	4a52      	ldr	r2, [pc, #328]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    ebae:	69d3      	ldr	r3, [r2, #28]
    ebb0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    ebb4:	4319      	orrs	r1, r3
    ebb6:	61d1      	str	r1, [r2, #28]
    ebb8:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
    ebba:	069b      	lsls	r3, r3, #26
    ebbc:	d519      	bpl.n	ebf2 <HAL_RCC_ClockConfig+0x2fe>
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
    ebbe:	4b4e      	ldr	r3, [pc, #312]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    ebc0:	69e2      	ldr	r2, [r4, #28]
    ebc2:	6a1b      	ldr	r3, [r3, #32]
    ebc4:	f003 0370 	and.w	r3, r3, #112	; 0x70
    ebc8:	429a      	cmp	r2, r3
    ebca:	d212      	bcs.n	ebf2 <HAL_RCC_ClockConfig+0x2fe>
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
    ebcc:	2a50      	cmp	r2, #80	; 0x50
    ebce:	bf18      	it	ne
    ebd0:	2a60      	cmpne	r2, #96	; 0x60
    ebd2:	d008      	beq.n	ebe6 <HAL_RCC_ClockConfig+0x2f2>
    ebd4:	f032 0340 	bics.w	r3, r2, #64	; 0x40
    ebd8:	d005      	beq.n	ebe6 <HAL_RCC_ClockConfig+0x2f2>
    ebda:	f240 418d 	movw	r1, #1165	; 0x48d
    ebde:	4847      	ldr	r0, [pc, #284]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ebe0:	f00a fc18 	bl	19414 <assert_failed>
    ebe4:	69e2      	ldr	r2, [r4, #28]
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
    ebe6:	4944      	ldr	r1, [pc, #272]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    ebe8:	6a0b      	ldr	r3, [r1, #32]
    ebea:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    ebee:	431a      	orrs	r2, r3
    ebf0:	620a      	str	r2, [r1, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    ebf2:	f7ff fdf3 	bl	e7dc <HAL_RCC_GetSysClockFreq>
    ebf6:	4a40      	ldr	r2, [pc, #256]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    ebf8:	4942      	ldr	r1, [pc, #264]	; (ed04 <HAL_RCC_ClockConfig+0x410>)
    ebfa:	6993      	ldr	r3, [r2, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ebfc:	6992      	ldr	r2, [r2, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    ebfe:	f3c3 2303 	ubfx	r3, r3, #8, #4
  halstatus = HAL_InitTick (uwTickPrio);
    ec02:	4d41      	ldr	r5, [pc, #260]	; (ed08 <HAL_RCC_ClockConfig+0x414>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ec04:	f002 020f 	and.w	r2, r2, #15
    ec08:	4c40      	ldr	r4, [pc, #256]	; (ed0c <HAL_RCC_ClockConfig+0x418>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    ec0a:	5ccb      	ldrb	r3, [r1, r3]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ec0c:	5c8a      	ldrb	r2, [r1, r2]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    ec0e:	f003 031f 	and.w	r3, r3, #31
  SystemCoreClock = common_system_clock;
    ec12:	493f      	ldr	r1, [pc, #252]	; (ed10 <HAL_RCC_ClockConfig+0x41c>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ec14:	f002 021f 	and.w	r2, r2, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    ec18:	fa20 f303 	lsr.w	r3, r0, r3
  halstatus = HAL_InitTick (uwTickPrio);
    ec1c:	6828      	ldr	r0, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ec1e:	fa23 f202 	lsr.w	r2, r3, r2
  SystemCoreClock = common_system_clock;
    ec22:	600b      	str	r3, [r1, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ec24:	6022      	str	r2, [r4, #0]
}
    ec26:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick (uwTickPrio);
    ec2a:	f7f9 bb8b 	b.w	8344 <HAL_InitTick>
  assert_param(IS_FLASH_LATENCY(FLatency));
    ec2e:	f44f 7160 	mov.w	r1, #896	; 0x380
    ec32:	4832      	ldr	r0, [pc, #200]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ec34:	f00a fbee 	bl	19414 <assert_failed>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
    ec38:	4b31      	ldr	r3, [pc, #196]	; (ed00 <HAL_RCC_ClockConfig+0x40c>)
    ec3a:	681a      	ldr	r2, [r3, #0]
    __HAL_FLASH_SET_LATENCY(FLatency);
    ec3c:	6819      	ldr	r1, [r3, #0]
    ec3e:	f021 010f 	bic.w	r1, r1, #15
    ec42:	430d      	orrs	r5, r1
    ec44:	601d      	str	r5, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
    ec46:	681b      	ldr	r3, [r3, #0]
    return HAL_ERROR;
    ec48:	2001      	movs	r0, #1
}
    ec4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    ec4e:	f240 317f 	movw	r1, #895	; 0x37f
    ec52:	482a      	ldr	r0, [pc, #168]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ec54:	f00a fbde 	bl	19414 <assert_failed>
  assert_param(IS_FLASH_LATENCY(FLatency));
    ec58:	2d0f      	cmp	r5, #15
    ec5a:	f67f ae5a 	bls.w	e912 <HAL_RCC_ClockConfig+0x1e>
    ec5e:	e7e6      	b.n	ec2e <HAL_RCC_ClockConfig+0x33a>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    ec60:	0390      	lsls	r0, r2, #14
    ec62:	f53f af06 	bmi.w	ea72 <HAL_RCC_ClockConfig+0x17e>
    ec66:	e7ef      	b.n	ec48 <HAL_RCC_ClockConfig+0x354>
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    ec68:	f240 31f5 	movw	r1, #1013	; 0x3f5
    ec6c:	4823      	ldr	r0, [pc, #140]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ec6e:	f00a fbd1 	bl	19414 <assert_failed>
    ec72:	e6e9      	b.n	ea48 <HAL_RCC_ClockConfig+0x154>
    return HAL_ERROR;
    ec74:	2001      	movs	r0, #1
}
    ec76:	4770      	bx	lr
    __HAL_FLASH_SET_LATENCY(FLatency);
    ec78:	6813      	ldr	r3, [r2, #0]
    ec7a:	f023 030f 	bic.w	r3, r3, #15
    ec7e:	432b      	orrs	r3, r5
    ec80:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
    ec82:	6813      	ldr	r3, [r2, #0]
    ec84:	f003 030f 	and.w	r3, r3, #15
    ec88:	42ab      	cmp	r3, r5
    ec8a:	f43f ae49 	beq.w	e920 <HAL_RCC_ClockConfig+0x2c>
    ec8e:	e7db      	b.n	ec48 <HAL_RCC_ClockConfig+0x354>
            return HAL_TIMEOUT;
    ec90:	2003      	movs	r0, #3
    ec92:	e7da      	b.n	ec4a <HAL_RCC_ClockConfig+0x356>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    ec94:	0191      	lsls	r1, r2, #6
    ec96:	f53f aeec 	bmi.w	ea72 <HAL_RCC_ClockConfig+0x17e>
    ec9a:	e7d5      	b.n	ec48 <HAL_RCC_ClockConfig+0x354>
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
    ec9c:	f44f 717d 	mov.w	r1, #1012	; 0x3f4
    eca0:	4816      	ldr	r0, [pc, #88]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    eca2:	f00a fbb7 	bl	19414 <assert_failed>
    eca6:	e6cb      	b.n	ea40 <HAL_RCC_ClockConfig+0x14c>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    eca8:	05d2      	lsls	r2, r2, #23
    ecaa:	f53f aee2 	bmi.w	ea72 <HAL_RCC_ClockConfig+0x17e>
    ecae:	e7cb      	b.n	ec48 <HAL_RCC_ClockConfig+0x354>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
    ecb0:	f240 31d1 	movw	r1, #977	; 0x3d1
    ecb4:	4811      	ldr	r0, [pc, #68]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ecb6:	f00a fbad 	bl	19414 <assert_failed>
    ecba:	69e1      	ldr	r1, [r4, #28]
    ecbc:	e67f      	b.n	e9be <HAL_RCC_ClockConfig+0xca>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    ecbe:	f44f 7167 	mov.w	r1, #924	; 0x39c
    ecc2:	480e      	ldr	r0, [pc, #56]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ecc4:	f00a fba6 	bl	19414 <assert_failed>
    ecc8:	6921      	ldr	r1, [r4, #16]
    ecca:	e638      	b.n	e93e <HAL_RCC_ClockConfig+0x4a>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    eccc:	f240 31ae 	movw	r1, #942	; 0x3ae
    ecd0:	480a      	ldr	r0, [pc, #40]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ecd2:	f00a fb9f 	bl	19414 <assert_failed>
    ecd6:	6961      	ldr	r1, [r4, #20]
    ecd8:	e646      	b.n	e968 <HAL_RCC_ClockConfig+0x74>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    ecda:	f240 31bf 	movw	r1, #959	; 0x3bf
    ecde:	4807      	ldr	r0, [pc, #28]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ece0:	f00a fb98 	bl	19414 <assert_failed>
    ece4:	69a1      	ldr	r1, [r4, #24]
    ece6:	e655      	b.n	e994 <HAL_RCC_ClockConfig+0xa0>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    ece8:	f44f 7179 	mov.w	r1, #996	; 0x3e4
    ecec:	4803      	ldr	r0, [pc, #12]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ecee:	f00a fb91 	bl	19414 <assert_failed>
    ecf2:	68e1      	ldr	r1, [r4, #12]
    ecf4:	e678      	b.n	e9e8 <HAL_RCC_ClockConfig+0xf4>
    ecf6:	bf00      	nop
    ecf8:	58024400 	.word	0x58024400
    ecfc:	0002fe30 	.word	0x0002fe30
    ed00:	52002000 	.word	0x52002000
    ed04:	00030cdc 	.word	0x00030cdc
    ed08:	00062560 	.word	0x00062560
    ed0c:	00062810 	.word	0x00062810
    ed10:	0006280c 	.word	0x0006280c

0000ed14 <HAL_RCC_GetHCLKFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
    ed14:	4a49      	ldr	r2, [pc, #292]	; (ee3c <HAL_RCC_GetHCLKFreq+0x128>)
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
    ed16:	b430      	push	{r4, r5}
  switch (RCC->CFGR & RCC_CFGR_SWS)
    ed18:	6913      	ldr	r3, [r2, #16]
    ed1a:	f003 0338 	and.w	r3, r3, #56	; 0x38
    ed1e:	2b10      	cmp	r3, #16
    ed20:	d064      	beq.n	edec <HAL_RCC_GetHCLKFreq+0xd8>
    ed22:	2b18      	cmp	r3, #24
    ed24:	d022      	beq.n	ed6c <HAL_RCC_GetHCLKFreq+0x58>
    ed26:	b1bb      	cbz	r3, ed58 <HAL_RCC_GetHCLKFreq+0x44>
    sysclockfreq = CSI_VALUE;
    ed28:	4b45      	ldr	r3, [pc, #276]	; (ee40 <HAL_RCC_GetHCLKFreq+0x12c>)
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    ed2a:	4944      	ldr	r1, [pc, #272]	; (ee3c <HAL_RCC_GetHCLKFreq+0x128>)
    ed2c:	4845      	ldr	r0, [pc, #276]	; (ee44 <HAL_RCC_GetHCLKFreq+0x130>)
    ed2e:	698a      	ldr	r2, [r1, #24]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed30:	6989      	ldr	r1, [r1, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    ed32:	f3c2 2203 	ubfx	r2, r2, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed36:	4c44      	ldr	r4, [pc, #272]	; (ee48 <HAL_RCC_GetHCLKFreq+0x134>)
    ed38:	f001 010f 	and.w	r1, r1, #15
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
    ed3c:	4d43      	ldr	r5, [pc, #268]	; (ee4c <HAL_RCC_GetHCLKFreq+0x138>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    ed3e:	5c82      	ldrb	r2, [r0, r2]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed40:	5c40      	ldrb	r0, [r0, r1]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    ed42:	f002 021f 	and.w	r2, r2, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed46:	f000 001f 	and.w	r0, r0, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    ed4a:	40d3      	lsrs	r3, r2
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed4c:	fa23 f000 	lsr.w	r0, r3, r0
  SystemCoreClock = common_system_clock;
    ed50:	602b      	str	r3, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed52:	6020      	str	r0, [r4, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
    ed54:	bc30      	pop	{r4, r5}
    ed56:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    ed58:	6813      	ldr	r3, [r2, #0]
    ed5a:	0699      	lsls	r1, r3, #26
    ed5c:	d548      	bpl.n	edf0 <HAL_RCC_GetHCLKFreq+0xdc>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ed5e:	6813      	ldr	r3, [r2, #0]
    ed60:	4a3b      	ldr	r2, [pc, #236]	; (ee50 <HAL_RCC_GetHCLKFreq+0x13c>)
    ed62:	f3c3 03c1 	ubfx	r3, r3, #3, #2
    ed66:	fa22 f303 	lsr.w	r3, r2, r3
    ed6a:	e7de      	b.n	ed2a <HAL_RCC_GetHCLKFreq+0x16>
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    ed6c:	6a90      	ldr	r0, [r2, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    ed6e:	6a93      	ldr	r3, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    ed70:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    ed72:	f3c3 1305 	ubfx	r3, r3, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    ed76:	6b54      	ldr	r4, [r2, #52]	; 0x34
    if (pllm != 0U)
    ed78:	2b00      	cmp	r3, #0
    ed7a:	d0d6      	beq.n	ed2a <HAL_RCC_GetHCLKFreq+0x16>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    ed7c:	f3c4 04cc 	ubfx	r4, r4, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    ed80:	f001 0101 	and.w	r1, r1, #1
    ed84:	ee07 3a90 	vmov	s15, r3
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    ed88:	f000 0003 	and.w	r0, r0, #3
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    ed8c:	fb01 f304 	mul.w	r3, r1, r4
    ed90:	eef8 6ae7 	vcvt.f32.s32	s13, s15
      switch (pllsource)
    ed94:	2801      	cmp	r0, #1
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    ed96:	ee07 3a90 	vmov	s15, r3
    ed9a:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
      switch (pllsource)
    ed9e:	d002      	beq.n	eda6 <HAL_RCC_GetHCLKFreq+0x92>
    eda0:	d32b      	bcc.n	edfa <HAL_RCC_GetHCLKFreq+0xe6>
    eda2:	2802      	cmp	r0, #2
    eda4:	d026      	beq.n	edf4 <HAL_RCC_GetHCLKFreq+0xe0>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    eda6:	ed9f 7a2b 	vldr	s14, [pc, #172]	; ee54 <HAL_RCC_GetHCLKFreq+0x140>
    edaa:	ee87 6a26 	vdiv.f32	s12, s14, s13
    edae:	6b13      	ldr	r3, [r2, #48]	; 0x30
    edb0:	f3c3 0308 	ubfx	r3, r3, #0, #9
    edb4:	ee07 3a10 	vmov	s14, r3
    edb8:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    edbc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    edc0:	ee37 7a25 	vadd.f32	s14, s14, s11
    edc4:	ee77 7a27 	vadd.f32	s15, s14, s15
    edc8:	ee67 7a86 	vmul.f32	s15, s15, s12
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
    edcc:	4b1b      	ldr	r3, [pc, #108]	; (ee3c <HAL_RCC_GetHCLKFreq+0x128>)
    edce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    edd0:	f3c3 2346 	ubfx	r3, r3, #9, #7
    edd4:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
    edd6:	ee07 3a10 	vmov	s14, r3
    edda:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    edde:	eec7 6a87 	vdiv.f32	s13, s15, s14
    ede2:	eefc 7ae6 	vcvt.u32.f32	s15, s13
    ede6:	ee17 3a90 	vmov	r3, s15
    edea:	e79e      	b.n	ed2a <HAL_RCC_GetHCLKFreq+0x16>
    sysclockfreq = HSE_VALUE;
    edec:	4b1a      	ldr	r3, [pc, #104]	; (ee58 <HAL_RCC_GetHCLKFreq+0x144>)
    edee:	e79c      	b.n	ed2a <HAL_RCC_GetHCLKFreq+0x16>
        sysclockfreq = (uint32_t) HSI_VALUE;
    edf0:	4b17      	ldr	r3, [pc, #92]	; (ee50 <HAL_RCC_GetHCLKFreq+0x13c>)
    edf2:	e79a      	b.n	ed2a <HAL_RCC_GetHCLKFreq+0x16>
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    edf4:	ed9f 7a19 	vldr	s14, [pc, #100]	; ee5c <HAL_RCC_GetHCLKFreq+0x148>
    edf8:	e7d7      	b.n	edaa <HAL_RCC_GetHCLKFreq+0x96>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    edfa:	6813      	ldr	r3, [r2, #0]
    edfc:	069b      	lsls	r3, r3, #26
    edfe:	d51a      	bpl.n	ee36 <HAL_RCC_GetHCLKFreq+0x122>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ee00:	6810      	ldr	r0, [r2, #0]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    ee02:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ee06:	4912      	ldr	r1, [pc, #72]	; (ee50 <HAL_RCC_GetHCLKFreq+0x13c>)
    ee08:	f3c0 00c1 	ubfx	r0, r0, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    ee0c:	6b13      	ldr	r3, [r2, #48]	; 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ee0e:	40c1      	lsrs	r1, r0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    ee10:	f3c3 0308 	ubfx	r3, r3, #0, #9
    ee14:	ee07 1a10 	vmov	s14, r1
    ee18:	eef8 5ac7 	vcvt.f32.s32	s11, s14
    ee1c:	ee07 3a10 	vmov	s14, r3
    ee20:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
    ee24:	ee85 7aa6 	vdiv.f32	s14, s11, s13
    ee28:	ee76 6a05 	vadd.f32	s13, s12, s10
    ee2c:	ee76 7aa7 	vadd.f32	s15, s13, s15
    ee30:	ee67 7a27 	vmul.f32	s15, s14, s15
    ee34:	e7ca      	b.n	edcc <HAL_RCC_GetHCLKFreq+0xb8>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    ee36:	ed9f 7a0a 	vldr	s14, [pc, #40]	; ee60 <HAL_RCC_GetHCLKFreq+0x14c>
    ee3a:	e7b6      	b.n	edaa <HAL_RCC_GetHCLKFreq+0x96>
    ee3c:	58024400 	.word	0x58024400
    ee40:	003d0900 	.word	0x003d0900
    ee44:	00030cdc 	.word	0x00030cdc
    ee48:	00062810 	.word	0x00062810
    ee4c:	0006280c 	.word	0x0006280c
    ee50:	03d09000 	.word	0x03d09000
    ee54:	4a742400 	.word	0x4a742400
    ee58:	017d7840 	.word	0x017d7840
    ee5c:	4bbebc20 	.word	0x4bbebc20
    ee60:	4c742400 	.word	0x4c742400

0000ee64 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
    ee64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
    ee66:	6803      	ldr	r3, [r0, #0]
{
    ee68:	4604      	mov	r4, r0
    ee6a:	460e      	mov	r6, r1
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
    ee6c:	3b01      	subs	r3, #1
    ee6e:	2b3e      	cmp	r3, #62	; 0x3e
    ee70:	f200 809a 	bhi.w	efa8 <RCCEx_PLL2_Config+0x144>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
    ee74:	6863      	ldr	r3, [r4, #4]
    ee76:	3b04      	subs	r3, #4
    ee78:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    ee7c:	f200 809f 	bhi.w	efbe <RCCEx_PLL2_Config+0x15a>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
    ee80:	68a3      	ldr	r3, [r4, #8]
    ee82:	3b01      	subs	r3, #1
    ee84:	2b7f      	cmp	r3, #127	; 0x7f
    ee86:	f200 80a4 	bhi.w	efd2 <RCCEx_PLL2_Config+0x16e>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
    ee8a:	6923      	ldr	r3, [r4, #16]
    ee8c:	3b01      	subs	r3, #1
    ee8e:	2b7f      	cmp	r3, #127	; 0x7f
    ee90:	f200 80a9 	bhi.w	efe6 <RCCEx_PLL2_Config+0x182>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
    ee94:	68e3      	ldr	r3, [r4, #12]
    ee96:	3b01      	subs	r3, #1
    ee98:	2b7f      	cmp	r3, #127	; 0x7f
    ee9a:	f200 80ae 	bhi.w	effa <RCCEx_PLL2_Config+0x196>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
    ee9e:	6963      	ldr	r3, [r4, #20]
    eea0:	f033 03c0 	bics.w	r3, r3, #192	; 0xc0
    eea4:	f040 80b3 	bne.w	f00e <RCCEx_PLL2_Config+0x1aa>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
    eea8:	69a3      	ldr	r3, [r4, #24]
    eeaa:	f033 0320 	bics.w	r3, r3, #32
    eeae:	f040 80b8 	bne.w	f022 <RCCEx_PLL2_Config+0x1be>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
    eeb2:	69e3      	ldr	r3, [r4, #28]
    eeb4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    eeb8:	d270      	bcs.n	ef9c <RCCEx_PLL2_Config+0x138>

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
    eeba:	4a5f      	ldr	r2, [pc, #380]	; (f038 <RCCEx_PLL2_Config+0x1d4>)
    eebc:	6a93      	ldr	r3, [r2, #40]	; 0x28
    eebe:	f003 0303 	and.w	r3, r3, #3
    eec2:	2b03      	cmp	r3, #3
    eec4:	d066      	beq.n	ef94 <RCCEx_PLL2_Config+0x130>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
    eec6:	6813      	ldr	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
    eec8:	4615      	mov	r5, r2
    __HAL_RCC_PLL2_DISABLE();
    eeca:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
    eece:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
    eed0:	f7f9 fa90 	bl	83f4 <HAL_GetTick>
    eed4:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
    eed6:	e004      	b.n	eee2 <RCCEx_PLL2_Config+0x7e>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
    eed8:	f7f9 fa8c 	bl	83f4 <HAL_GetTick>
    eedc:	1bc0      	subs	r0, r0, r7
    eede:	2802      	cmp	r0, #2
    eee0:	d85a      	bhi.n	ef98 <RCCEx_PLL2_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
    eee2:	682b      	ldr	r3, [r5, #0]
    eee4:	011a      	lsls	r2, r3, #4
    eee6:	d4f7      	bmi.n	eed8 <RCCEx_PLL2_Config+0x74>
        return HAL_TIMEOUT;
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
    eee8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    eeea:	6822      	ldr	r2, [r4, #0]
    eeec:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
    eef0:	4952      	ldr	r1, [pc, #328]	; (f03c <RCCEx_PLL2_Config+0x1d8>)
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
    eef2:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
    eef6:	62ab      	str	r3, [r5, #40]	; 0x28
    eef8:	6867      	ldr	r7, [r4, #4]
    eefa:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    eefe:	3f01      	subs	r7, #1
    ef00:	1e50      	subs	r0, r2, #1
    ef02:	3b01      	subs	r3, #1
    ef04:	6922      	ldr	r2, [r4, #16]
    ef06:	f3c7 0708 	ubfx	r7, r7, #0, #9
    ef0a:	025b      	lsls	r3, r3, #9
    ef0c:	0400      	lsls	r0, r0, #16
    ef0e:	3a01      	subs	r2, #1
    ef10:	b29b      	uxth	r3, r3
    ef12:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
    ef16:	0612      	lsls	r2, r2, #24
    ef18:	4303      	orrs	r3, r0
    ef1a:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
    ef1e:	433b      	orrs	r3, r7
    ef20:	4313      	orrs	r3, r2
    ef22:	63ab      	str	r3, [r5, #56]	; 0x38
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
    ef24:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ef26:	6962      	ldr	r2, [r4, #20]
    ef28:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    ef2c:	4313      	orrs	r3, r2
    ef2e:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
    ef30:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ef32:	69a2      	ldr	r2, [r4, #24]
    ef34:	f023 0320 	bic.w	r3, r3, #32
    ef38:	4313      	orrs	r3, r2
    ef3a:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_DISABLE();
    ef3c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ef3e:	f023 0310 	bic.w	r3, r3, #16
    ef42:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
    ef44:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    ef46:	69e3      	ldr	r3, [r4, #28]
    ef48:	4011      	ands	r1, r2
    ef4a:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
    ef4e:	63e9      	str	r1, [r5, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
    ef50:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ef52:	f043 0310 	orr.w	r3, r3, #16
    ef56:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
    ef58:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
    ef5a:	2e00      	cmp	r6, #0
    ef5c:	d067      	beq.n	f02e <RCCEx_PLL2_Config+0x1ca>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
    ef5e:	2e01      	cmp	r6, #1
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
    ef60:	bf0c      	ite	eq
    ef62:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
    ef66:	f443 1300 	orrne.w	r3, r3, #2097152	; 0x200000
    ef6a:	62eb      	str	r3, [r5, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
    ef6c:	4b32      	ldr	r3, [pc, #200]	; (f038 <RCCEx_PLL2_Config+0x1d4>)
    ef6e:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
    ef70:	461c      	mov	r4, r3
    __HAL_RCC_PLL2_ENABLE();
    ef72:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
    ef76:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    ef78:	f7f9 fa3c 	bl	83f4 <HAL_GetTick>
    ef7c:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
    ef7e:	e004      	b.n	ef8a <RCCEx_PLL2_Config+0x126>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
    ef80:	f7f9 fa38 	bl	83f4 <HAL_GetTick>
    ef84:	1b40      	subs	r0, r0, r5
    ef86:	2802      	cmp	r0, #2
    ef88:	d806      	bhi.n	ef98 <RCCEx_PLL2_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
    ef8a:	6823      	ldr	r3, [r4, #0]
    ef8c:	011b      	lsls	r3, r3, #4
    ef8e:	d5f7      	bpl.n	ef80 <RCCEx_PLL2_Config+0x11c>
    }

  }


  return status;
    ef90:	2000      	movs	r0, #0
}
    ef92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
    ef94:	2001      	movs	r0, #1
}
    ef96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
    ef98:	2003      	movs	r0, #3
}
    ef9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
    ef9c:	f640 4186 	movw	r1, #3206	; 0xc86
    efa0:	4827      	ldr	r0, [pc, #156]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    efa2:	f00a fa37 	bl	19414 <assert_failed>
    efa6:	e788      	b.n	eeba <RCCEx_PLL2_Config+0x56>
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
    efa8:	f640 417f 	movw	r1, #3199	; 0xc7f
    efac:	4824      	ldr	r0, [pc, #144]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    efae:	f00a fa31 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
    efb2:	6863      	ldr	r3, [r4, #4]
    efb4:	3b04      	subs	r3, #4
    efb6:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    efba:	f67f af61 	bls.w	ee80 <RCCEx_PLL2_Config+0x1c>
    efbe:	f44f 6148 	mov.w	r1, #3200	; 0xc80
    efc2:	481f      	ldr	r0, [pc, #124]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    efc4:	f00a fa26 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
    efc8:	68a3      	ldr	r3, [r4, #8]
    efca:	3b01      	subs	r3, #1
    efcc:	2b7f      	cmp	r3, #127	; 0x7f
    efce:	f67f af5c 	bls.w	ee8a <RCCEx_PLL2_Config+0x26>
    efd2:	f640 4181 	movw	r1, #3201	; 0xc81
    efd6:	481a      	ldr	r0, [pc, #104]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    efd8:	f00a fa1c 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
    efdc:	6923      	ldr	r3, [r4, #16]
    efde:	3b01      	subs	r3, #1
    efe0:	2b7f      	cmp	r3, #127	; 0x7f
    efe2:	f67f af57 	bls.w	ee94 <RCCEx_PLL2_Config+0x30>
    efe6:	f640 4182 	movw	r1, #3202	; 0xc82
    efea:	4815      	ldr	r0, [pc, #84]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    efec:	f00a fa12 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
    eff0:	68e3      	ldr	r3, [r4, #12]
    eff2:	3b01      	subs	r3, #1
    eff4:	2b7f      	cmp	r3, #127	; 0x7f
    eff6:	f67f af52 	bls.w	ee9e <RCCEx_PLL2_Config+0x3a>
    effa:	f640 4183 	movw	r1, #3203	; 0xc83
    effe:	4810      	ldr	r0, [pc, #64]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    f000:	f00a fa08 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
    f004:	6963      	ldr	r3, [r4, #20]
    f006:	f033 03c0 	bics.w	r3, r3, #192	; 0xc0
    f00a:	f43f af4d 	beq.w	eea8 <RCCEx_PLL2_Config+0x44>
    f00e:	f640 4184 	movw	r1, #3204	; 0xc84
    f012:	480b      	ldr	r0, [pc, #44]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    f014:	f00a f9fe 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
    f018:	69a3      	ldr	r3, [r4, #24]
    f01a:	f033 0320 	bics.w	r3, r3, #32
    f01e:	f43f af48 	beq.w	eeb2 <RCCEx_PLL2_Config+0x4e>
    f022:	f640 4185 	movw	r1, #3205	; 0xc85
    f026:	4806      	ldr	r0, [pc, #24]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    f028:	f00a f9f4 	bl	19414 <assert_failed>
    f02c:	e741      	b.n	eeb2 <RCCEx_PLL2_Config+0x4e>
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
    f02e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    f032:	62eb      	str	r3, [r5, #44]	; 0x2c
    f034:	e79a      	b.n	ef6c <RCCEx_PLL2_Config+0x108>
    f036:	bf00      	nop
    f038:	58024400 	.word	0x58024400
    f03c:	ffff0007 	.word	0xffff0007
    f040:	0002fe68 	.word	0x0002fe68

0000f044 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
    f044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
    f046:	6803      	ldr	r3, [r0, #0]
{
    f048:	4604      	mov	r4, r0
    f04a:	460e      	mov	r6, r1
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
    f04c:	3b01      	subs	r3, #1
    f04e:	2b3e      	cmp	r3, #62	; 0x3e
    f050:	f200 809a 	bhi.w	f188 <RCCEx_PLL3_Config+0x144>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
    f054:	6863      	ldr	r3, [r4, #4]
    f056:	3b04      	subs	r3, #4
    f058:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    f05c:	f200 809f 	bhi.w	f19e <RCCEx_PLL3_Config+0x15a>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
    f060:	68a3      	ldr	r3, [r4, #8]
    f062:	3b01      	subs	r3, #1
    f064:	2b7f      	cmp	r3, #127	; 0x7f
    f066:	f200 80a4 	bhi.w	f1b2 <RCCEx_PLL3_Config+0x16e>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
    f06a:	6923      	ldr	r3, [r4, #16]
    f06c:	3b01      	subs	r3, #1
    f06e:	2b7f      	cmp	r3, #127	; 0x7f
    f070:	f200 80a9 	bhi.w	f1c6 <RCCEx_PLL3_Config+0x182>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
    f074:	68e3      	ldr	r3, [r4, #12]
    f076:	3b01      	subs	r3, #1
    f078:	2b7f      	cmp	r3, #127	; 0x7f
    f07a:	f200 80ae 	bhi.w	f1da <RCCEx_PLL3_Config+0x196>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
    f07e:	6963      	ldr	r3, [r4, #20]
    f080:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    f084:	f040 80b3 	bne.w	f1ee <RCCEx_PLL3_Config+0x1aa>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
    f088:	69a3      	ldr	r3, [r4, #24]
    f08a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    f08e:	f040 80b8 	bne.w	f202 <RCCEx_PLL3_Config+0x1be>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
    f092:	69e3      	ldr	r3, [r4, #28]
    f094:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    f098:	d270      	bcs.n	f17c <RCCEx_PLL3_Config+0x138>

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
    f09a:	4a5f      	ldr	r2, [pc, #380]	; (f218 <RCCEx_PLL3_Config+0x1d4>)
    f09c:	6a93      	ldr	r3, [r2, #40]	; 0x28
    f09e:	f003 0303 	and.w	r3, r3, #3
    f0a2:	2b03      	cmp	r3, #3
    f0a4:	d066      	beq.n	f174 <RCCEx_PLL3_Config+0x130>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
    f0a6:	6813      	ldr	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
    f0a8:	4615      	mov	r5, r2
    __HAL_RCC_PLL3_DISABLE();
    f0aa:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    f0ae:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
    f0b0:	f7f9 f9a0 	bl	83f4 <HAL_GetTick>
    f0b4:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
    f0b6:	e004      	b.n	f0c2 <RCCEx_PLL3_Config+0x7e>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
    f0b8:	f7f9 f99c 	bl	83f4 <HAL_GetTick>
    f0bc:	1bc0      	subs	r0, r0, r7
    f0be:	2802      	cmp	r0, #2
    f0c0:	d85a      	bhi.n	f178 <RCCEx_PLL3_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
    f0c2:	682b      	ldr	r3, [r5, #0]
    f0c4:	009a      	lsls	r2, r3, #2
    f0c6:	d4f7      	bmi.n	f0b8 <RCCEx_PLL3_Config+0x74>
        return HAL_TIMEOUT;
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
    f0c8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    f0ca:	6822      	ldr	r2, [r4, #0]
    f0cc:	f023 737c 	bic.w	r3, r3, #66060288	; 0x3f00000

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
    f0d0:	4952      	ldr	r1, [pc, #328]	; (f21c <RCCEx_PLL3_Config+0x1d8>)
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
    f0d2:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    f0d6:	62ab      	str	r3, [r5, #40]	; 0x28
    f0d8:	6867      	ldr	r7, [r4, #4]
    f0da:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    f0de:	3f01      	subs	r7, #1
    f0e0:	1e50      	subs	r0, r2, #1
    f0e2:	3b01      	subs	r3, #1
    f0e4:	6922      	ldr	r2, [r4, #16]
    f0e6:	f3c7 0708 	ubfx	r7, r7, #0, #9
    f0ea:	025b      	lsls	r3, r3, #9
    f0ec:	0400      	lsls	r0, r0, #16
    f0ee:	3a01      	subs	r2, #1
    f0f0:	b29b      	uxth	r3, r3
    f0f2:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
    f0f6:	0612      	lsls	r2, r2, #24
    f0f8:	4303      	orrs	r3, r0
    f0fa:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
    f0fe:	433b      	orrs	r3, r7
    f100:	4313      	orrs	r3, r2
    f102:	642b      	str	r3, [r5, #64]	; 0x40
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
    f104:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f106:	6962      	ldr	r2, [r4, #20]
    f108:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
    f10c:	4313      	orrs	r3, r2
    f10e:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
    f110:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f112:	69a2      	ldr	r2, [r4, #24]
    f114:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    f118:	4313      	orrs	r3, r2
    f11a:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_DISABLE();
    f11c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f11e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    f122:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
    f124:	6c6a      	ldr	r2, [r5, #68]	; 0x44
    f126:	69e3      	ldr	r3, [r4, #28]
    f128:	4011      	ands	r1, r2
    f12a:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
    f12e:	6469      	str	r1, [r5, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
    f130:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f132:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    f136:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
    f138:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
    f13a:	2e00      	cmp	r6, #0
    f13c:	d067      	beq.n	f20e <RCCEx_PLL3_Config+0x1ca>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
    f13e:	2e01      	cmp	r6, #1
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
    f140:	bf0c      	ite	eq
    f142:	f443 0300 	orreq.w	r3, r3, #8388608	; 0x800000
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
    f146:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
    f14a:	62eb      	str	r3, [r5, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
    f14c:	4b32      	ldr	r3, [pc, #200]	; (f218 <RCCEx_PLL3_Config+0x1d4>)
    f14e:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
    f150:	461c      	mov	r4, r3
    __HAL_RCC_PLL3_ENABLE();
    f152:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    f156:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    f158:	f7f9 f94c 	bl	83f4 <HAL_GetTick>
    f15c:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
    f15e:	e004      	b.n	f16a <RCCEx_PLL3_Config+0x126>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
    f160:	f7f9 f948 	bl	83f4 <HAL_GetTick>
    f164:	1b40      	subs	r0, r0, r5
    f166:	2802      	cmp	r0, #2
    f168:	d806      	bhi.n	f178 <RCCEx_PLL3_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
    f16a:	6823      	ldr	r3, [r4, #0]
    f16c:	009b      	lsls	r3, r3, #2
    f16e:	d5f7      	bpl.n	f160 <RCCEx_PLL3_Config+0x11c>
    }

  }


  return status;
    f170:	2000      	movs	r0, #0
}
    f172:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
    f174:	2001      	movs	r0, #1
}
    f176:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
    f178:	2003      	movs	r0, #3
}
    f17a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
    f17c:	f640 41ee 	movw	r1, #3310	; 0xcee
    f180:	4827      	ldr	r0, [pc, #156]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f182:	f00a f947 	bl	19414 <assert_failed>
    f186:	e788      	b.n	f09a <RCCEx_PLL3_Config+0x56>
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
    f188:	f640 41e7 	movw	r1, #3303	; 0xce7
    f18c:	4824      	ldr	r0, [pc, #144]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f18e:	f00a f941 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
    f192:	6863      	ldr	r3, [r4, #4]
    f194:	3b04      	subs	r3, #4
    f196:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    f19a:	f67f af61 	bls.w	f060 <RCCEx_PLL3_Config+0x1c>
    f19e:	f640 41e8 	movw	r1, #3304	; 0xce8
    f1a2:	481f      	ldr	r0, [pc, #124]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f1a4:	f00a f936 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
    f1a8:	68a3      	ldr	r3, [r4, #8]
    f1aa:	3b01      	subs	r3, #1
    f1ac:	2b7f      	cmp	r3, #127	; 0x7f
    f1ae:	f67f af5c 	bls.w	f06a <RCCEx_PLL3_Config+0x26>
    f1b2:	f640 41e9 	movw	r1, #3305	; 0xce9
    f1b6:	481a      	ldr	r0, [pc, #104]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f1b8:	f00a f92c 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
    f1bc:	6923      	ldr	r3, [r4, #16]
    f1be:	3b01      	subs	r3, #1
    f1c0:	2b7f      	cmp	r3, #127	; 0x7f
    f1c2:	f67f af57 	bls.w	f074 <RCCEx_PLL3_Config+0x30>
    f1c6:	f640 41ea 	movw	r1, #3306	; 0xcea
    f1ca:	4815      	ldr	r0, [pc, #84]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f1cc:	f00a f922 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
    f1d0:	68e3      	ldr	r3, [r4, #12]
    f1d2:	3b01      	subs	r3, #1
    f1d4:	2b7f      	cmp	r3, #127	; 0x7f
    f1d6:	f67f af52 	bls.w	f07e <RCCEx_PLL3_Config+0x3a>
    f1da:	f640 41eb 	movw	r1, #3307	; 0xceb
    f1de:	4810      	ldr	r0, [pc, #64]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f1e0:	f00a f918 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
    f1e4:	6963      	ldr	r3, [r4, #20]
    f1e6:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    f1ea:	f43f af4d 	beq.w	f088 <RCCEx_PLL3_Config+0x44>
    f1ee:	f640 41ec 	movw	r1, #3308	; 0xcec
    f1f2:	480b      	ldr	r0, [pc, #44]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f1f4:	f00a f90e 	bl	19414 <assert_failed>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
    f1f8:	69a3      	ldr	r3, [r4, #24]
    f1fa:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    f1fe:	f43f af48 	beq.w	f092 <RCCEx_PLL3_Config+0x4e>
    f202:	f640 41ed 	movw	r1, #3309	; 0xced
    f206:	4806      	ldr	r0, [pc, #24]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f208:	f00a f904 	bl	19414 <assert_failed>
    f20c:	e741      	b.n	f092 <RCCEx_PLL3_Config+0x4e>
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
    f20e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    f212:	62eb      	str	r3, [r5, #44]	; 0x2c
    f214:	e79a      	b.n	f14c <RCCEx_PLL3_Config+0x108>
    f216:	bf00      	nop
    f218:	58024400 	.word	0x58024400
    f21c:	ffff0007 	.word	0xffff0007
    f220:	0002fe68 	.word	0x0002fe68

0000f224 <HAL_RCCEx_PeriphCLKConfig>:
{
    f224:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
    f228:	6803      	ldr	r3, [r0, #0]
{
    f22a:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
    f22c:	f013 6600 	ands.w	r6, r3, #134217728	; 0x8000000
    f230:	d016      	beq.n	f260 <HAL_RCCEx_PeriphCLKConfig+0x3c>
    switch(PeriphClkInit->SpdifrxClockSelection)
    f232:	6e42      	ldr	r2, [r0, #100]	; 0x64
    f234:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
    f238:	f000 8527 	beq.w	fc8a <HAL_RCCEx_PeriphCLKConfig+0xa66>
    f23c:	f240 861b 	bls.w	fe76 <HAL_RCCEx_PeriphCLKConfig+0xc52>
    f240:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    f244:	f000 855b 	beq.w	fcfe <HAL_RCCEx_PeriphCLKConfig+0xada>
    f248:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
    f24c:	f040 8639 	bne.w	fec2 <HAL_RCCEx_PeriphCLKConfig+0xc9e>
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
    f250:	49b7      	ldr	r1, [pc, #732]	; (f530 <HAL_RCCEx_PeriphCLKConfig+0x30c>)
    f252:	2600      	movs	r6, #0
    f254:	6d0b      	ldr	r3, [r1, #80]	; 0x50
    f256:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
    f25a:	431a      	orrs	r2, r3
    f25c:	650a      	str	r2, [r1, #80]	; 0x50
    f25e:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
    f260:	05dd      	lsls	r5, r3, #23
    f262:	d50a      	bpl.n	f27a <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch(PeriphClkInit->Sai1ClockSelection)
    f264:	6d62      	ldr	r2, [r4, #84]	; 0x54
    f266:	2a04      	cmp	r2, #4
    f268:	d806      	bhi.n	f278 <HAL_RCCEx_PeriphCLKConfig+0x54>
    f26a:	e8df f012 	tbh	[pc, r2, lsl #1]
    f26e:	04ac      	.short	0x04ac
    f270:	04c404be 	.word	0x04c404be
    f274:	04880488 	.word	0x04880488
      ret = HAL_ERROR;
    f278:	2601      	movs	r6, #1
    f27a:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
    f27c:	0598      	lsls	r0, r3, #22
    f27e:	d515      	bpl.n	f2ac <HAL_RCCEx_PeriphCLKConfig+0x88>
    switch(PeriphClkInit->Sai23ClockSelection)
    f280:	6da2      	ldr	r2, [r4, #88]	; 0x58
    f282:	2a80      	cmp	r2, #128	; 0x80
    f284:	f000 850c 	beq.w	fca0 <HAL_RCCEx_PeriphCLKConfig+0xa7c>
    f288:	f200 85ea 	bhi.w	fe60 <HAL_RCCEx_PeriphCLKConfig+0xc3c>
    f28c:	2a00      	cmp	r2, #0
    f28e:	f000 853c 	beq.w	fd0a <HAL_RCCEx_PeriphCLKConfig+0xae6>
    f292:	2a40      	cmp	r2, #64	; 0x40
    f294:	f040 85eb 	bne.w	fe6e <HAL_RCCEx_PeriphCLKConfig+0xc4a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f298:	2100      	movs	r1, #0
    f29a:	1d20      	adds	r0, r4, #4
    f29c:	f7ff fde2 	bl	ee64 <RCCEx_PLL2_Config>
    f2a0:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f2a2:	2d00      	cmp	r5, #0
    f2a4:	f000 8505 	beq.w	fcb2 <HAL_RCCEx_PeriphCLKConfig+0xa8e>
    f2a8:	6823      	ldr	r3, [r4, #0]
    f2aa:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
    f2ac:	0559      	lsls	r1, r3, #21
    f2ae:	d518      	bpl.n	f2e2 <HAL_RCCEx_PeriphCLKConfig+0xbe>
    switch(PeriphClkInit->Sai4AClockSelection)
    f2b0:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
    f2b4:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
    f2b8:	f000 8505 	beq.w	fcc6 <HAL_RCCEx_PeriphCLKConfig+0xaa2>
    f2bc:	f200 85c4 	bhi.w	fe48 <HAL_RCCEx_PeriphCLKConfig+0xc24>
    f2c0:	2a00      	cmp	r2, #0
    f2c2:	f000 8530 	beq.w	fd26 <HAL_RCCEx_PeriphCLKConfig+0xb02>
    f2c6:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    f2ca:	f040 85c5 	bne.w	fe58 <HAL_RCCEx_PeriphCLKConfig+0xc34>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f2ce:	2100      	movs	r1, #0
    f2d0:	1d20      	adds	r0, r4, #4
    f2d2:	f7ff fdc7 	bl	ee64 <RCCEx_PLL2_Config>
    f2d6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f2d8:	2d00      	cmp	r5, #0
    f2da:	f000 84fd 	beq.w	fcd8 <HAL_RCCEx_PeriphCLKConfig+0xab4>
    f2de:	6823      	ldr	r3, [r4, #0]
    f2e0:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
    f2e2:	051a      	lsls	r2, r3, #20
    f2e4:	d518      	bpl.n	f318 <HAL_RCCEx_PeriphCLKConfig+0xf4>
    switch(PeriphClkInit->Sai4BClockSelection)
    f2e6:	f8d4 20a8 	ldr.w	r2, [r4, #168]	; 0xa8
    f2ea:	f1b2 7f00 	cmp.w	r2, #33554432	; 0x2000000
    f2ee:	f000 84fe 	beq.w	fcee <HAL_RCCEx_PeriphCLKConfig+0xaca>
    f2f2:	f200 85d5 	bhi.w	fea0 <HAL_RCCEx_PeriphCLKConfig+0xc7c>
    f2f6:	2a00      	cmp	r2, #0
    f2f8:	f000 84b4 	beq.w	fc64 <HAL_RCCEx_PeriphCLKConfig+0xa40>
    f2fc:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
    f300:	f040 85d6 	bne.w	feb0 <HAL_RCCEx_PeriphCLKConfig+0xc8c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f304:	2100      	movs	r1, #0
    f306:	1d20      	adds	r0, r4, #4
    f308:	f7ff fdac 	bl	ee64 <RCCEx_PLL2_Config>
    f30c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f30e:	2d00      	cmp	r5, #0
    f310:	f000 84b0 	beq.w	fc74 <HAL_RCCEx_PeriphCLKConfig+0xa50>
    f314:	6823      	ldr	r3, [r4, #0]
    f316:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
    f318:	019f      	lsls	r7, r3, #6
    f31a:	d50d      	bpl.n	f338 <HAL_RCCEx_PeriphCLKConfig+0x114>
    switch(PeriphClkInit->QspiClockSelection)
    f31c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    f31e:	2a10      	cmp	r2, #16
    f320:	f000 83f6 	beq.w	fb10 <HAL_RCCEx_PeriphCLKConfig+0x8ec>
    f324:	f240 85c8 	bls.w	feb8 <HAL_RCCEx_PeriphCLKConfig+0xc94>
    f328:	2a20      	cmp	r2, #32
    f32a:	f000 83fa 	beq.w	fb22 <HAL_RCCEx_PeriphCLKConfig+0x8fe>
    f32e:	2a30      	cmp	r2, #48	; 0x30
    f330:	f000 83f3 	beq.w	fb1a <HAL_RCCEx_PeriphCLKConfig+0x8f6>
      ret = HAL_ERROR;
    f334:	2601      	movs	r6, #1
    f336:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
    f338:	04d8      	lsls	r0, r3, #19
    f33a:	d517      	bpl.n	f36c <HAL_RCCEx_PeriphCLKConfig+0x148>
    switch(PeriphClkInit->Spi123ClockSelection)
    f33c:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    f33e:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    f342:	f000 8477 	beq.w	fc34 <HAL_RCCEx_PeriphCLKConfig+0xa10>
    f346:	f200 859f 	bhi.w	fe88 <HAL_RCCEx_PeriphCLKConfig+0xc64>
    f34a:	2a00      	cmp	r2, #0
    f34c:	f000 84e4 	beq.w	fd18 <HAL_RCCEx_PeriphCLKConfig+0xaf4>
    f350:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    f354:	f040 85a0 	bne.w	fe98 <HAL_RCCEx_PeriphCLKConfig+0xc74>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f358:	2100      	movs	r1, #0
    f35a:	1d20      	adds	r0, r4, #4
    f35c:	f7ff fd82 	bl	ee64 <RCCEx_PLL2_Config>
    f360:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f362:	2d00      	cmp	r5, #0
    f364:	f000 846f 	beq.w	fc46 <HAL_RCCEx_PeriphCLKConfig+0xa22>
    f368:	6823      	ldr	r3, [r4, #0]
    f36a:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
    f36c:	0499      	lsls	r1, r3, #18
    f36e:	d51b      	bpl.n	f3a8 <HAL_RCCEx_PeriphCLKConfig+0x184>
    switch(PeriphClkInit->Spi45ClockSelection)
    f370:	6e22      	ldr	r2, [r4, #96]	; 0x60
    f372:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
    f376:	f000 83e5 	beq.w	fb44 <HAL_RCCEx_PeriphCLKConfig+0x920>
    f37a:	f200 8527 	bhi.w	fdcc <HAL_RCCEx_PeriphCLKConfig+0xba8>
    f37e:	b142      	cbz	r2, f392 <HAL_RCCEx_PeriphCLKConfig+0x16e>
    f380:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    f384:	f040 852e 	bne.w	fde4 <HAL_RCCEx_PeriphCLKConfig+0xbc0>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    f388:	2101      	movs	r1, #1
    f38a:	1d20      	adds	r0, r4, #4
    f38c:	f7ff fd6a 	bl	ee64 <RCCEx_PLL2_Config>
    f390:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f392:	2d00      	cmp	r5, #0
    f394:	f040 833b 	bne.w	fa0e <HAL_RCCEx_PeriphCLKConfig+0x7ea>
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
    f398:	4a65      	ldr	r2, [pc, #404]	; (f530 <HAL_RCCEx_PeriphCLKConfig+0x30c>)
    f39a:	6e21      	ldr	r1, [r4, #96]	; 0x60
    f39c:	6d13      	ldr	r3, [r2, #80]	; 0x50
    f39e:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
    f3a2:	430b      	orrs	r3, r1
    f3a4:	6513      	str	r3, [r2, #80]	; 0x50
    f3a6:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
    f3a8:	045a      	lsls	r2, r3, #17
    f3aa:	d51d      	bpl.n	f3e8 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    switch(PeriphClkInit->Spi6ClockSelection)
    f3ac:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
    f3b0:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    f3b4:	f000 83d0 	beq.w	fb58 <HAL_RCCEx_PeriphCLKConfig+0x934>
    f3b8:	f200 8527 	bhi.w	fe0a <HAL_RCCEx_PeriphCLKConfig+0xbe6>
    f3bc:	b142      	cbz	r2, f3d0 <HAL_RCCEx_PeriphCLKConfig+0x1ac>
    f3be:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    f3c2:	f040 852e 	bne.w	fe22 <HAL_RCCEx_PeriphCLKConfig+0xbfe>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    f3c6:	2101      	movs	r1, #1
    f3c8:	1d20      	adds	r0, r4, #4
    f3ca:	f7ff fd4b 	bl	ee64 <RCCEx_PLL2_Config>
    f3ce:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f3d0:	2d00      	cmp	r5, #0
    f3d2:	f040 8319 	bne.w	fa08 <HAL_RCCEx_PeriphCLKConfig+0x7e4>
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
    f3d6:	4a56      	ldr	r2, [pc, #344]	; (f530 <HAL_RCCEx_PeriphCLKConfig+0x30c>)
    f3d8:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
    f3dc:	6d93      	ldr	r3, [r2, #88]	; 0x58
    f3de:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
    f3e2:	430b      	orrs	r3, r1
    f3e4:	6593      	str	r3, [r2, #88]	; 0x58
    f3e6:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
    f3e8:	041f      	lsls	r7, r3, #16
    f3ea:	d50d      	bpl.n	f408 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
    switch(PeriphClkInit->FdcanClockSelection)
    f3ec:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    f3ee:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    f3f2:	f000 83bb 	beq.w	fb6c <HAL_RCCEx_PeriphCLKConfig+0x948>
    f3f6:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    f3fa:	f000 8298 	beq.w	f92e <HAL_RCCEx_PeriphCLKConfig+0x70a>
    f3fe:	2a00      	cmp	r2, #0
    f400:	f000 829a 	beq.w	f938 <HAL_RCCEx_PeriphCLKConfig+0x714>
      ret = HAL_ERROR;
    f404:	2601      	movs	r6, #1
    f406:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
    f408:	01d8      	lsls	r0, r3, #7
    f40a:	d50a      	bpl.n	f422 <HAL_RCCEx_PeriphCLKConfig+0x1fe>
    switch(PeriphClkInit->FmcClockSelection)
    f40c:	6c62      	ldr	r2, [r4, #68]	; 0x44
    f40e:	2a03      	cmp	r2, #3
    f410:	d805      	bhi.n	f41e <HAL_RCCEx_PeriphCLKConfig+0x1fa>
    f412:	e8df f012 	tbh	[pc, r2, lsl #1]
    f416:	0270      	.short	0x0270
    f418:	026b033c 	.word	0x026b033c
    f41c:	0270      	.short	0x0270
      ret = HAL_ERROR;
    f41e:	2601      	movs	r6, #1
    f420:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
    f422:	0259      	lsls	r1, r3, #9
    f424:	f140 80c9 	bpl.w	f5ba <HAL_RCCEx_PeriphCLKConfig+0x396>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    f428:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
    f42c:	4f41      	ldr	r7, [pc, #260]	; (f534 <HAL_RCCEx_PeriphCLKConfig+0x310>)
    f42e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    f432:	bf18      	it	ne
    f434:	f5b2 7f00 	cmpne.w	r2, #512	; 0x200
    f438:	f422 4ca0 	bic.w	ip, r2, #20480	; 0x5000
    f43c:	f422 4010 	bic.w	r0, r2, #36864	; 0x9000
    f440:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
    f444:	bf14      	ite	ne
    f446:	2301      	movne	r3, #1
    f448:	2300      	moveq	r3, #0
    f44a:	f422 3e88 	bic.w	lr, r2, #69632	; 0x11000
    f44e:	f5bc 5f0c 	cmp.w	ip, #8960	; 0x2300
    f452:	bf0c      	ite	eq
    f454:	2300      	moveq	r3, #0
    f456:	f003 0301 	andne.w	r3, r3, #1
    f45a:	f8df c0e4 	ldr.w	ip, [pc, #228]	; f540 <HAL_RCCEx_PeriphCLKConfig+0x31c>
    f45e:	f5b0 4f86 	cmp.w	r0, #17152	; 0x4300
    f462:	bf0c      	ite	eq
    f464:	2300      	moveq	r3, #0
    f466:	f003 0301 	andne.w	r3, r3, #1
    f46a:	4833      	ldr	r0, [pc, #204]	; (f538 <HAL_RCCEx_PeriphCLKConfig+0x314>)
    f46c:	f5b1 4f03 	cmp.w	r1, #33536	; 0x8300
    f470:	bf0c      	ite	eq
    f472:	2300      	moveq	r3, #0
    f474:	f003 0301 	andne.w	r3, r3, #1
    f478:	f5be 4f63 	cmp.w	lr, #58112	; 0xe300
    f47c:	bf0c      	ite	eq
    f47e:	2300      	moveq	r3, #0
    f480:	f003 0301 	andne.w	r3, r3, #1
    f484:	f422 3e04 	bic.w	lr, r2, #135168	; 0x21000
    f488:	42b9      	cmp	r1, r7
    f48a:	bf0c      	ite	eq
    f48c:	2300      	moveq	r3, #0
    f48e:	f003 0301 	andne.w	r3, r3, #1
    f492:	f507 4740 	add.w	r7, r7, #49152	; 0xc000
    f496:	4281      	cmp	r1, r0
    f498:	bf0c      	ite	eq
    f49a:	2300      	moveq	r3, #0
    f49c:	f003 0301 	andne.w	r3, r3, #1
    f4a0:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
    f4a4:	4561      	cmp	r1, ip
    f4a6:	bf0c      	ite	eq
    f4a8:	2300      	moveq	r3, #0
    f4aa:	f003 0301 	andne.w	r3, r3, #1
    f4ae:	f50c 4c40 	add.w	ip, ip, #49152	; 0xc000
    f4b2:	45be      	cmp	lr, r7
    f4b4:	bf0c      	ite	eq
    f4b6:	2300      	moveq	r3, #0
    f4b8:	f003 0301 	andne.w	r3, r3, #1
    f4bc:	f507 4740 	add.w	r7, r7, #49152	; 0xc000
    f4c0:	4281      	cmp	r1, r0
    f4c2:	bf0c      	ite	eq
    f4c4:	2300      	moveq	r3, #0
    f4c6:	f003 0301 	andne.w	r3, r3, #1
    f4ca:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
    f4ce:	4561      	cmp	r1, ip
    f4d0:	bf0c      	ite	eq
    f4d2:	2300      	moveq	r3, #0
    f4d4:	f003 0301 	andne.w	r3, r3, #1
    f4d8:	f50c 4c40 	add.w	ip, ip, #49152	; 0xc000
    f4dc:	42b9      	cmp	r1, r7
    f4de:	bf0c      	ite	eq
    f4e0:	2300      	moveq	r3, #0
    f4e2:	f003 0301 	andne.w	r3, r3, #1
    f4e6:	f507 4740 	add.w	r7, r7, #49152	; 0xc000
    f4ea:	4281      	cmp	r1, r0
    f4ec:	bf0c      	ite	eq
    f4ee:	2300      	moveq	r3, #0
    f4f0:	f003 0301 	andne.w	r3, r3, #1
    f4f4:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
    f4f8:	4561      	cmp	r1, ip
    f4fa:	bf0c      	ite	eq
    f4fc:	2300      	moveq	r3, #0
    f4fe:	f003 0301 	andne.w	r3, r3, #1
    f502:	42b9      	cmp	r1, r7
    f504:	bf0c      	ite	eq
    f506:	2300      	moveq	r3, #0
    f508:	f003 0301 	andne.w	r3, r3, #1
    f50c:	4281      	cmp	r1, r0
    f50e:	bf0c      	ite	eq
    f510:	2300      	moveq	r3, #0
    f512:	f003 0301 	andne.w	r3, r3, #1
    f516:	2b00      	cmp	r3, #0
    f518:	f040 81b7 	bne.w	f88a <HAL_RCCEx_PeriphCLKConfig+0x666>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
    f51c:	4b07      	ldr	r3, [pc, #28]	; (f53c <HAL_RCCEx_PeriphCLKConfig+0x318>)
    f51e:	681a      	ldr	r2, [r3, #0]
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    f520:	461f      	mov	r7, r3
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
    f522:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    f526:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    f528:	f7f8 ff64 	bl	83f4 <HAL_GetTick>
    f52c:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    f52e:	e010      	b.n	f552 <HAL_RCCEx_PeriphCLKConfig+0x32e>
    f530:	58024400 	.word	0x58024400
    f534:	00010300 	.word	0x00010300
    f538:	00014300 	.word	0x00014300
    f53c:	58024800 	.word	0x58024800
    f540:	00018300 	.word	0x00018300
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
    f544:	f7f8 ff56 	bl	83f4 <HAL_GetTick>
    f548:	eba0 0008 	sub.w	r0, r0, r8
    f54c:	2864      	cmp	r0, #100	; 0x64
    f54e:	f200 8245 	bhi.w	f9dc <HAL_RCCEx_PeriphCLKConfig+0x7b8>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    f552:	683b      	ldr	r3, [r7, #0]
    f554:	05da      	lsls	r2, r3, #23
    f556:	d5f5      	bpl.n	f544 <HAL_RCCEx_PeriphCLKConfig+0x320>
    if(ret == HAL_OK)
    f558:	2d00      	cmp	r5, #0
    f55a:	f040 84c0 	bne.w	fede <HAL_RCCEx_PeriphCLKConfig+0xcba>
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
    f55e:	4b3e      	ldr	r3, [pc, #248]	; (f658 <HAL_RCCEx_PeriphCLKConfig+0x434>)
    f560:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
    f564:	6f19      	ldr	r1, [r3, #112]	; 0x70
    f566:	4051      	eors	r1, r2
    f568:	f411 7f40 	tst.w	r1, #768	; 0x300
    f56c:	d00d      	beq.n	f58a <HAL_RCCEx_PeriphCLKConfig+0x366>
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
    f56e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_FORCE();
    f570:	6f19      	ldr	r1, [r3, #112]	; 0x70
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
    f572:	f422 7240 	bic.w	r2, r2, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
    f576:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
    f57a:	6719      	str	r1, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
    f57c:	6f19      	ldr	r1, [r3, #112]	; 0x70
    f57e:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    f582:	6719      	str	r1, [r3, #112]	; 0x70
        RCC->BDCR = tmpreg;
    f584:	671a      	str	r2, [r3, #112]	; 0x70
    f586:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
    f58a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    f58e:	f000 83f9 	beq.w	fd84 <HAL_RCCEx_PeriphCLKConfig+0xb60>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
    f592:	f402 7340 	and.w	r3, r2, #768	; 0x300
    f596:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    f59a:	f000 8495 	beq.w	fec8 <HAL_RCCEx_PeriphCLKConfig+0xca4>
    f59e:	4a2e      	ldr	r2, [pc, #184]	; (f658 <HAL_RCCEx_PeriphCLKConfig+0x434>)
    f5a0:	6913      	ldr	r3, [r2, #16]
    f5a2:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
    f5a6:	6113      	str	r3, [r2, #16]
    f5a8:	4a2b      	ldr	r2, [pc, #172]	; (f658 <HAL_RCCEx_PeriphCLKConfig+0x434>)
    f5aa:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
    f5ae:	6f11      	ldr	r1, [r2, #112]	; 0x70
    f5b0:	f3c3 030b 	ubfx	r3, r3, #0, #12
    f5b4:	430b      	orrs	r3, r1
    f5b6:	6713      	str	r3, [r2, #112]	; 0x70
    f5b8:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
    f5ba:	07df      	lsls	r7, r3, #31
    f5bc:	d52f      	bpl.n	f61e <HAL_RCCEx_PeriphCLKConfig+0x3fa>
    switch(PeriphClkInit->Usart16ClockSelection)
    f5be:	6fa2      	ldr	r2, [r4, #120]	; 0x78
    f5c0:	2a28      	cmp	r2, #40	; 0x28
    f5c2:	d82a      	bhi.n	f61a <HAL_RCCEx_PeriphCLKConfig+0x3f6>
    f5c4:	e8df f012 	tbh	[pc, r2, lsl #1]
    f5c8:	002901a8 	.word	0x002901a8
    f5cc:	00290029 	.word	0x00290029
    f5d0:	00290029 	.word	0x00290029
    f5d4:	00290029 	.word	0x00290029
    f5d8:	0029028a 	.word	0x0029028a
    f5dc:	00290029 	.word	0x00290029
    f5e0:	00290029 	.word	0x00290029
    f5e4:	00290029 	.word	0x00290029
    f5e8:	002901a2 	.word	0x002901a2
    f5ec:	00290029 	.word	0x00290029
    f5f0:	00290029 	.word	0x00290029
    f5f4:	00290029 	.word	0x00290029
    f5f8:	002901a8 	.word	0x002901a8
    f5fc:	00290029 	.word	0x00290029
    f600:	00290029 	.word	0x00290029
    f604:	00290029 	.word	0x00290029
    f608:	002901a8 	.word	0x002901a8
    f60c:	00290029 	.word	0x00290029
    f610:	00290029 	.word	0x00290029
    f614:	00290029 	.word	0x00290029
    f618:	01a8      	.short	0x01a8
      ret = HAL_ERROR;
    f61a:	2601      	movs	r6, #1
    f61c:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
    f61e:	0798      	lsls	r0, r3, #30
    f620:	d50c      	bpl.n	f63c <HAL_RCCEx_PeriphCLKConfig+0x418>
    switch(PeriphClkInit->Usart234578ClockSelection)
    f622:	6f62      	ldr	r2, [r4, #116]	; 0x74
    f624:	2a05      	cmp	r2, #5
    f626:	d807      	bhi.n	f638 <HAL_RCCEx_PeriphCLKConfig+0x414>
    f628:	e8df f012 	tbh	[pc, r2, lsl #1]
    f62c:	021f0154 	.word	0x021f0154
    f630:	0154014e 	.word	0x0154014e
    f634:	01540154 	.word	0x01540154
      ret = HAL_ERROR;
    f638:	2601      	movs	r6, #1
    f63a:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
    f63c:	0759      	lsls	r1, r3, #29
    f63e:	d50f      	bpl.n	f660 <HAL_RCCEx_PeriphCLKConfig+0x43c>
    switch(PeriphClkInit->Lpuart1ClockSelection)
    f640:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
    f644:	2a05      	cmp	r2, #5
    f646:	d809      	bhi.n	f65c <HAL_RCCEx_PeriphCLKConfig+0x438>
    f648:	e8df f012 	tbh	[pc, r2, lsl #1]
    f64c:	02180131 	.word	0x02180131
    f650:	0131012b 	.word	0x0131012b
    f654:	01310131 	.word	0x01310131
    f658:	58024400 	.word	0x58024400
      ret = HAL_ERROR;
    f65c:	2601      	movs	r6, #1
    f65e:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
    f660:	069a      	lsls	r2, r3, #26
    f662:	d51d      	bpl.n	f6a0 <HAL_RCCEx_PeriphCLKConfig+0x47c>
    switch(PeriphClkInit->Lptim1ClockSelection)
    f664:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
    f668:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    f66c:	f000 82a1 	beq.w	fbb2 <HAL_RCCEx_PeriphCLKConfig+0x98e>
    f670:	f200 83bc 	bhi.w	fdec <HAL_RCCEx_PeriphCLKConfig+0xbc8>
    f674:	b142      	cbz	r2, f688 <HAL_RCCEx_PeriphCLKConfig+0x464>
    f676:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    f67a:	f040 83c3 	bne.w	fe04 <HAL_RCCEx_PeriphCLKConfig+0xbe0>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f67e:	2100      	movs	r1, #0
    f680:	1d20      	adds	r0, r4, #4
    f682:	f7ff fbef 	bl	ee64 <RCCEx_PLL2_Config>
    f686:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f688:	2d00      	cmp	r5, #0
    f68a:	f040 81c9 	bne.w	fa20 <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
    f68e:	4ab9      	ldr	r2, [pc, #740]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f690:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
    f694:	6d53      	ldr	r3, [r2, #84]	; 0x54
    f696:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
    f69a:	430b      	orrs	r3, r1
    f69c:	6553      	str	r3, [r2, #84]	; 0x54
    f69e:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
    f6a0:	065f      	lsls	r7, r3, #25
    f6a2:	d51d      	bpl.n	f6e0 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
    switch(PeriphClkInit->Lptim2ClockSelection)
    f6a4:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
    f6a8:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
    f6ac:	f000 8277 	beq.w	fb9e <HAL_RCCEx_PeriphCLKConfig+0x97a>
    f6b0:	f200 83bb 	bhi.w	fe2a <HAL_RCCEx_PeriphCLKConfig+0xc06>
    f6b4:	b142      	cbz	r2, f6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
    f6b6:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    f6ba:	f040 83c2 	bne.w	fe42 <HAL_RCCEx_PeriphCLKConfig+0xc1e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f6be:	2100      	movs	r1, #0
    f6c0:	1d20      	adds	r0, r4, #4
    f6c2:	f7ff fbcf 	bl	ee64 <RCCEx_PLL2_Config>
    f6c6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f6c8:	2d00      	cmp	r5, #0
    f6ca:	f040 81a6 	bne.w	fa1a <HAL_RCCEx_PeriphCLKConfig+0x7f6>
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
    f6ce:	4aa9      	ldr	r2, [pc, #676]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f6d0:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
    f6d4:	6d93      	ldr	r3, [r2, #88]	; 0x58
    f6d6:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
    f6da:	430b      	orrs	r3, r1
    f6dc:	6593      	str	r3, [r2, #88]	; 0x58
    f6de:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
    f6e0:	0618      	lsls	r0, r3, #24
    f6e2:	d51d      	bpl.n	f720 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
    switch(PeriphClkInit->Lptim345ClockSelection)
    f6e4:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    f6e8:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
    f6ec:	f000 824d 	beq.w	fb8a <HAL_RCCEx_PeriphCLKConfig+0x966>
    f6f0:	f200 835d 	bhi.w	fdae <HAL_RCCEx_PeriphCLKConfig+0xb8a>
    f6f4:	b142      	cbz	r2, f708 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    f6f6:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    f6fa:	f040 8364 	bne.w	fdc6 <HAL_RCCEx_PeriphCLKConfig+0xba2>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f6fe:	2100      	movs	r1, #0
    f700:	1d20      	adds	r0, r4, #4
    f702:	f7ff fbaf 	bl	ee64 <RCCEx_PLL2_Config>
    f706:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f708:	2d00      	cmp	r5, #0
    f70a:	f040 8183 	bne.w	fa14 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
    f70e:	4a99      	ldr	r2, [pc, #612]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f710:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
    f714:	6d93      	ldr	r3, [r2, #88]	; 0x58
    f716:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
    f71a:	430b      	orrs	r3, r1
    f71c:	6593      	str	r3, [r2, #88]	; 0x58
    f71e:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
    f720:	0719      	lsls	r1, r3, #28
    f722:	d510      	bpl.n	f746 <HAL_RCCEx_PeriphCLKConfig+0x522>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
    f724:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
    f728:	f432 5340 	bics.w	r3, r2, #12288	; 0x3000
    f72c:	f040 831a 	bne.w	fd64 <HAL_RCCEx_PeriphCLKConfig+0xb40>
    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
    f730:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    f734:	f000 8266 	beq.w	fc04 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
    f738:	498e      	ldr	r1, [pc, #568]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f73a:	6d4b      	ldr	r3, [r1, #84]	; 0x54
    f73c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
    f740:	4313      	orrs	r3, r2
    f742:	654b      	str	r3, [r1, #84]	; 0x54
    f744:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
    f746:	06da      	lsls	r2, r3, #27
    f748:	d516      	bpl.n	f778 <HAL_RCCEx_PeriphCLKConfig+0x554>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
    f74a:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    f74e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    f752:	bf18      	it	ne
    f754:	f5b2 5f40 	cmpne.w	r2, #12288	; 0x3000
    f758:	d003      	beq.n	f762 <HAL_RCCEx_PeriphCLKConfig+0x53e>
    f75a:	f432 7380 	bics.w	r3, r2, #256	; 0x100
    f75e:	f040 8309 	bne.w	fd74 <HAL_RCCEx_PeriphCLKConfig+0xb50>
    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
    f762:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    f766:	f000 8259 	beq.w	fc1c <HAL_RCCEx_PeriphCLKConfig+0x9f8>
      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
    f76a:	4982      	ldr	r1, [pc, #520]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f76c:	6d8b      	ldr	r3, [r1, #88]	; 0x58
    f76e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    f772:	4313      	orrs	r3, r2
    f774:	658b      	str	r3, [r1, #88]	; 0x58
    f776:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
    f778:	031f      	lsls	r7, r3, #12
    f77a:	d50e      	bpl.n	f79a <HAL_RCCEx_PeriphCLKConfig+0x576>
    switch(PeriphClkInit->AdcClockSelection)
    f77c:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
    f780:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    f784:	f000 80e3 	beq.w	f94e <HAL_RCCEx_PeriphCLKConfig+0x72a>
    f788:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
    f78c:	f000 80e5 	beq.w	f95a <HAL_RCCEx_PeriphCLKConfig+0x736>
    f790:	2900      	cmp	r1, #0
    f792:	f000 82d6 	beq.w	fd42 <HAL_RCCEx_PeriphCLKConfig+0xb1e>
      ret = HAL_ERROR;
    f796:	2601      	movs	r6, #1
    f798:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
    f79a:	0358      	lsls	r0, r3, #13
    f79c:	d50f      	bpl.n	f7be <HAL_RCCEx_PeriphCLKConfig+0x59a>
    switch(PeriphClkInit->UsbClockSelection)
    f79e:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
    f7a2:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    f7a6:	f000 80eb 	beq.w	f980 <HAL_RCCEx_PeriphCLKConfig+0x75c>
    f7aa:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
    f7ae:	f000 80ed 	beq.w	f98c <HAL_RCCEx_PeriphCLKConfig+0x768>
    f7b2:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
    f7b6:	f000 82cc 	beq.w	fd52 <HAL_RCCEx_PeriphCLKConfig+0xb2e>
      ret = HAL_ERROR;
    f7ba:	2601      	movs	r6, #1
    f7bc:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
    f7be:	03d9      	lsls	r1, r3, #15
    f7c0:	d515      	bpl.n	f7ee <HAL_RCCEx_PeriphCLKConfig+0x5ca>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
    f7c2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    f7c4:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
    f7c8:	f040 8171 	bne.w	faae <HAL_RCCEx_PeriphCLKConfig+0x88a>
    switch(PeriphClkInit->SdmmcClockSelection)
    f7cc:	2b00      	cmp	r3, #0
    f7ce:	f000 813b 	beq.w	fa48 <HAL_RCCEx_PeriphCLKConfig+0x824>
    f7d2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    f7d6:	f040 8129 	bne.w	fa2c <HAL_RCCEx_PeriphCLKConfig+0x808>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
    f7da:	2102      	movs	r1, #2
    f7dc:	1d20      	adds	r0, r4, #4
    f7de:	f7ff fb41 	bl	ee64 <RCCEx_PLL2_Config>
    f7e2:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f7e4:	2d00      	cmp	r5, #0
    f7e6:	f000 8137 	beq.w	fa58 <HAL_RCCEx_PeriphCLKConfig+0x834>
    f7ea:	6823      	ldr	r3, [r4, #0]
    f7ec:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
    f7ee:	009a      	lsls	r2, r3, #2
    f7f0:	f100 80e9 	bmi.w	f9c6 <HAL_RCCEx_PeriphCLKConfig+0x7a2>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
    f7f4:	039f      	lsls	r7, r3, #14
    f7f6:	d437      	bmi.n	f868 <HAL_RCCEx_PeriphCLKConfig+0x644>
    f7f8:	3600      	adds	r6, #0
    f7fa:	bf18      	it	ne
    f7fc:	2601      	movne	r6, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
    f7fe:	02d8      	lsls	r0, r3, #11
    f800:	d50b      	bpl.n	f81a <HAL_RCCEx_PeriphCLKConfig+0x5f6>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
    f802:	6f22      	ldr	r2, [r4, #112]	; 0x70
    f804:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
    f808:	f040 814a 	bne.w	faa0 <HAL_RCCEx_PeriphCLKConfig+0x87c>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
    f80c:	4959      	ldr	r1, [pc, #356]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f80e:	6d0b      	ldr	r3, [r1, #80]	; 0x50
    f810:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    f814:	4313      	orrs	r3, r2
    f816:	650b      	str	r3, [r1, #80]	; 0x50
    f818:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
    f81a:	0299      	lsls	r1, r3, #10
    f81c:	d50b      	bpl.n	f836 <HAL_RCCEx_PeriphCLKConfig+0x612>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
    f81e:	6ea2      	ldr	r2, [r4, #104]	; 0x68
    f820:	f032 7380 	bics.w	r3, r2, #16777216	; 0x1000000
    f824:	f040 814d 	bne.w	fac2 <HAL_RCCEx_PeriphCLKConfig+0x89e>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
    f828:	4952      	ldr	r1, [pc, #328]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f82a:	6d0b      	ldr	r3, [r1, #80]	; 0x50
    f82c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    f830:	4313      	orrs	r3, r2
    f832:	650b      	str	r3, [r1, #80]	; 0x50
    f834:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
    f836:	005a      	lsls	r2, r3, #1
    f838:	d510      	bpl.n	f85c <HAL_RCCEx_PeriphCLKConfig+0x638>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
    f83a:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
    f83e:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
    f842:	f040 8145 	bne.w	fad0 <HAL_RCCEx_PeriphCLKConfig+0x8ac>
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
    f846:	4b4b      	ldr	r3, [pc, #300]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f848:	691a      	ldr	r2, [r3, #16]
    f84a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    f84e:	611a      	str	r2, [r3, #16]
    f850:	691a      	ldr	r2, [r3, #16]
    f852:	f8d4 10b8 	ldr.w	r1, [r4, #184]	; 0xb8
    f856:	430a      	orrs	r2, r1
    f858:	611a      	str	r2, [r3, #16]
    f85a:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
    f85c:	2b00      	cmp	r3, #0
    f85e:	f2c0 80a1 	blt.w	f9a4 <HAL_RCCEx_PeriphCLKConfig+0x780>
}
    f862:	4630      	mov	r0, r6
    f864:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    switch(PeriphClkInit->RngClockSelection)
    f868:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    f86a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    f86e:	f000 80e1 	beq.w	fa34 <HAL_RCCEx_PeriphCLKConfig+0x810>
    f872:	f240 813c 	bls.w	faee <HAL_RCCEx_PeriphCLKConfig+0x8ca>
    f876:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    f87a:	f000 80e0 	beq.w	fa3e <HAL_RCCEx_PeriphCLKConfig+0x81a>
    f87e:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
    f882:	f000 80dc 	beq.w	fa3e <HAL_RCCEx_PeriphCLKConfig+0x81a>
    f886:	2601      	movs	r6, #1
    f888:	e7b9      	b.n	f7fe <HAL_RCCEx_PeriphCLKConfig+0x5da>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    f88a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    f88e:	4b3a      	ldr	r3, [pc, #232]	; (f978 <HAL_RCCEx_PeriphCLKConfig+0x754>)
    f890:	429a      	cmp	r2, r3
    f892:	f43f ae43 	beq.w	f51c <HAL_RCCEx_PeriphCLKConfig+0x2f8>
    f896:	f44f 715a 	mov.w	r1, #872	; 0x368
    f89a:	4838      	ldr	r0, [pc, #224]	; (f97c <HAL_RCCEx_PeriphCLKConfig+0x758>)
    f89c:	f009 fdba 	bl	19414 <assert_failed>
    f8a0:	e63c      	b.n	f51c <HAL_RCCEx_PeriphCLKConfig+0x2f8>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    f8a2:	2101      	movs	r1, #1
    f8a4:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f8a8:	f7ff fbcc 	bl	f044 <RCCEx_PLL3_Config>
    f8ac:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f8ae:	2d00      	cmp	r5, #0
    f8b0:	f040 809e 	bne.w	f9f0 <HAL_RCCEx_PeriphCLKConfig+0x7cc>
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
    f8b4:	4a2f      	ldr	r2, [pc, #188]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f8b6:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
    f8ba:	6d93      	ldr	r3, [r2, #88]	; 0x58
    f8bc:	f023 0307 	bic.w	r3, r3, #7
    f8c0:	430b      	orrs	r3, r1
    f8c2:	6593      	str	r3, [r2, #88]	; 0x58
    f8c4:	6823      	ldr	r3, [r4, #0]
    f8c6:	e6cb      	b.n	f660 <HAL_RCCEx_PeriphCLKConfig+0x43c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    f8c8:	2101      	movs	r1, #1
    f8ca:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f8ce:	f7ff fbb9 	bl	f044 <RCCEx_PLL3_Config>
    f8d2:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f8d4:	2d00      	cmp	r5, #0
    f8d6:	f040 808e 	bne.w	f9f6 <HAL_RCCEx_PeriphCLKConfig+0x7d2>
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
    f8da:	4a26      	ldr	r2, [pc, #152]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f8dc:	6f61      	ldr	r1, [r4, #116]	; 0x74
    f8de:	6d53      	ldr	r3, [r2, #84]	; 0x54
    f8e0:	f023 0307 	bic.w	r3, r3, #7
    f8e4:	430b      	orrs	r3, r1
    f8e6:	6553      	str	r3, [r2, #84]	; 0x54
    f8e8:	6823      	ldr	r3, [r4, #0]
    f8ea:	e6a7      	b.n	f63c <HAL_RCCEx_PeriphCLKConfig+0x418>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
    f8ec:	2102      	movs	r1, #2
    f8ee:	1d20      	adds	r0, r4, #4
    f8f0:	f7ff fab8 	bl	ee64 <RCCEx_PLL2_Config>
    f8f4:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f8f6:	2d00      	cmp	r5, #0
    f8f8:	d177      	bne.n	f9ea <HAL_RCCEx_PeriphCLKConfig+0x7c6>
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
    f8fa:	4a1e      	ldr	r2, [pc, #120]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f8fc:	6c61      	ldr	r1, [r4, #68]	; 0x44
    f8fe:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
    f900:	f023 0303 	bic.w	r3, r3, #3
    f904:	430b      	orrs	r3, r1
    f906:	64d3      	str	r3, [r2, #76]	; 0x4c
    f908:	6823      	ldr	r3, [r4, #0]
    f90a:	e58a      	b.n	f422 <HAL_RCCEx_PeriphCLKConfig+0x1fe>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    f90c:	2101      	movs	r1, #1
    f90e:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f912:	f7ff fb97 	bl	f044 <RCCEx_PLL3_Config>
    f916:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f918:	2d00      	cmp	r5, #0
    f91a:	d163      	bne.n	f9e4 <HAL_RCCEx_PeriphCLKConfig+0x7c0>
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
    f91c:	4a15      	ldr	r2, [pc, #84]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f91e:	6fa1      	ldr	r1, [r4, #120]	; 0x78
    f920:	6d53      	ldr	r3, [r2, #84]	; 0x54
    f922:	f023 0338 	bic.w	r3, r3, #56	; 0x38
    f926:	430b      	orrs	r3, r1
    f928:	6553      	str	r3, [r2, #84]	; 0x54
    f92a:	6823      	ldr	r3, [r4, #0]
    f92c:	e677      	b.n	f61e <HAL_RCCEx_PeriphCLKConfig+0x3fa>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    f92e:	2101      	movs	r1, #1
    f930:	1d20      	adds	r0, r4, #4
    f932:	f7ff fa97 	bl	ee64 <RCCEx_PLL2_Config>
    f936:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f938:	2d00      	cmp	r5, #0
    f93a:	d174      	bne.n	fa26 <HAL_RCCEx_PeriphCLKConfig+0x802>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
    f93c:	4a0d      	ldr	r2, [pc, #52]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f93e:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
    f940:	6d13      	ldr	r3, [r2, #80]	; 0x50
    f942:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
    f946:	430b      	orrs	r3, r1
    f948:	6513      	str	r3, [r2, #80]	; 0x50
    f94a:	6823      	ldr	r3, [r4, #0]
    f94c:	e55c      	b.n	f408 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
    f94e:	2102      	movs	r1, #2
    f950:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f954:	f7ff fb76 	bl	f044 <RCCEx_PLL3_Config>
    f958:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f95a:	2d00      	cmp	r5, #0
    f95c:	d151      	bne.n	fa02 <HAL_RCCEx_PeriphCLKConfig+0x7de>
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
    f95e:	4a05      	ldr	r2, [pc, #20]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f960:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
    f964:	6d93      	ldr	r3, [r2, #88]	; 0x58
    f966:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    f96a:	430b      	orrs	r3, r1
    f96c:	6593      	str	r3, [r2, #88]	; 0x58
    f96e:	6823      	ldr	r3, [r4, #0]
    f970:	e713      	b.n	f79a <HAL_RCCEx_PeriphCLKConfig+0x576>
    f972:	bf00      	nop
    f974:	58024400 	.word	0x58024400
    f978:	0003e300 	.word	0x0003e300
    f97c:	0002fe68 	.word	0x0002fe68
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    f980:	2101      	movs	r1, #1
    f982:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f986:	f7ff fb5d 	bl	f044 <RCCEx_PLL3_Config>
    f98a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f98c:	2d00      	cmp	r5, #0
    f98e:	d135      	bne.n	f9fc <HAL_RCCEx_PeriphCLKConfig+0x7d8>
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
    f990:	4ab2      	ldr	r2, [pc, #712]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    f992:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
    f996:	6d53      	ldr	r3, [r2, #84]	; 0x54
    f998:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
    f99c:	430b      	orrs	r3, r1
    f99e:	6553      	str	r3, [r2, #84]	; 0x54
    f9a0:	6823      	ldr	r3, [r4, #0]
    f9a2:	e70c      	b.n	f7be <HAL_RCCEx_PeriphCLKConfig+0x59a>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
    f9a4:	6d22      	ldr	r2, [r4, #80]	; 0x50
    f9a6:	f032 5380 	bics.w	r3, r2, #268435456	; 0x10000000
    f9aa:	d003      	beq.n	f9b4 <HAL_RCCEx_PeriphCLKConfig+0x790>
    f9ac:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    f9b0:	f040 81c0 	bne.w	fd34 <HAL_RCCEx_PeriphCLKConfig+0xb10>
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
    f9b4:	49a9      	ldr	r1, [pc, #676]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
}
    f9b6:	4630      	mov	r0, r6
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
    f9b8:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
    f9ba:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
    f9be:	4313      	orrs	r3, r2
    f9c0:	64cb      	str	r3, [r1, #76]	; 0x4c
}
    f9c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
    f9c6:	2102      	movs	r1, #2
    f9c8:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f9cc:	f7ff fb3a 	bl	f044 <RCCEx_PLL3_Config>
    f9d0:	6823      	ldr	r3, [r4, #0]
    f9d2:	2800      	cmp	r0, #0
    f9d4:	f43f af0e 	beq.w	f7f4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>
      status=HAL_ERROR;
    f9d8:	2601      	movs	r6, #1
    f9da:	e70b      	b.n	f7f4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>
            ret = HAL_TIMEOUT;
    f9dc:	2603      	movs	r6, #3
    f9de:	6823      	ldr	r3, [r4, #0]
    f9e0:	4635      	mov	r5, r6
    f9e2:	e5ea      	b.n	f5ba <HAL_RCCEx_PeriphCLKConfig+0x396>
    f9e4:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    f9e6:	462e      	mov	r6, r5
    f9e8:	e619      	b.n	f61e <HAL_RCCEx_PeriphCLKConfig+0x3fa>
    f9ea:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    f9ec:	462e      	mov	r6, r5
    f9ee:	e518      	b.n	f422 <HAL_RCCEx_PeriphCLKConfig+0x1fe>
    f9f0:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    f9f2:	462e      	mov	r6, r5
    f9f4:	e634      	b.n	f660 <HAL_RCCEx_PeriphCLKConfig+0x43c>
    f9f6:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    f9f8:	462e      	mov	r6, r5
    f9fa:	e61f      	b.n	f63c <HAL_RCCEx_PeriphCLKConfig+0x418>
    f9fc:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    f9fe:	462e      	mov	r6, r5
    fa00:	e6dd      	b.n	f7be <HAL_RCCEx_PeriphCLKConfig+0x59a>
    fa02:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa04:	462e      	mov	r6, r5
    fa06:	e6c8      	b.n	f79a <HAL_RCCEx_PeriphCLKConfig+0x576>
    fa08:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa0a:	462e      	mov	r6, r5
    fa0c:	e4ec      	b.n	f3e8 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    fa0e:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa10:	462e      	mov	r6, r5
    fa12:	e4c9      	b.n	f3a8 <HAL_RCCEx_PeriphCLKConfig+0x184>
    fa14:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa16:	462e      	mov	r6, r5
    fa18:	e682      	b.n	f720 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
    fa1a:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa1c:	462e      	mov	r6, r5
    fa1e:	e65f      	b.n	f6e0 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
    fa20:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa22:	462e      	mov	r6, r5
    fa24:	e63c      	b.n	f6a0 <HAL_RCCEx_PeriphCLKConfig+0x47c>
    fa26:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa28:	462e      	mov	r6, r5
    fa2a:	e4ed      	b.n	f408 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
      ret = HAL_ERROR;
    fa2c:	2601      	movs	r6, #1
    fa2e:	6823      	ldr	r3, [r4, #0]
    fa30:	4635      	mov	r5, r6
    fa32:	e6dc      	b.n	f7ee <HAL_RCCEx_PeriphCLKConfig+0x5ca>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fa34:	4a89      	ldr	r2, [pc, #548]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fa36:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fa38:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fa3c:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fa3e:	2d00      	cmp	r5, #0
    fa40:	d05a      	beq.n	faf8 <HAL_RCCEx_PeriphCLKConfig+0x8d4>
    fa42:	6823      	ldr	r3, [r4, #0]
    fa44:	2601      	movs	r6, #1
    fa46:	e6da      	b.n	f7fe <HAL_RCCEx_PeriphCLKConfig+0x5da>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fa48:	4a84      	ldr	r2, [pc, #528]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fa4a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fa4c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fa50:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fa52:	2d00      	cmp	r5, #0
    fa54:	f47f aec9 	bne.w	f7ea <HAL_RCCEx_PeriphCLKConfig+0x5c6>
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
    fa58:	4a80      	ldr	r2, [pc, #512]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fa5a:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
    fa5c:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
    fa5e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    fa62:	430b      	orrs	r3, r1
    fa64:	64d3      	str	r3, [r2, #76]	; 0x4c
    fa66:	6823      	ldr	r3, [r4, #0]
    fa68:	e6c1      	b.n	f7ee <HAL_RCCEx_PeriphCLKConfig+0x5ca>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    fa6a:	2101      	movs	r1, #1
    fa6c:	1d20      	adds	r0, r4, #4
    fa6e:	f7ff f9f9 	bl	ee64 <RCCEx_PLL2_Config>
    fa72:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fa74:	2d00      	cmp	r5, #0
    fa76:	f43f af30 	beq.w	f8da <HAL_RCCEx_PeriphCLKConfig+0x6b6>
    fa7a:	e7bc      	b.n	f9f6 <HAL_RCCEx_PeriphCLKConfig+0x7d2>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    fa7c:	2101      	movs	r1, #1
    fa7e:	1d20      	adds	r0, r4, #4
    fa80:	f7ff f9f0 	bl	ee64 <RCCEx_PLL2_Config>
    fa84:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fa86:	2d00      	cmp	r5, #0
    fa88:	f43f af14 	beq.w	f8b4 <HAL_RCCEx_PeriphCLKConfig+0x690>
    fa8c:	e7b0      	b.n	f9f0 <HAL_RCCEx_PeriphCLKConfig+0x7cc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fa8e:	4a73      	ldr	r2, [pc, #460]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fa90:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fa92:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fa96:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fa98:	2d00      	cmp	r5, #0
    fa9a:	f43f af2e 	beq.w	f8fa <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    fa9e:	e7a4      	b.n	f9ea <HAL_RCCEx_PeriphCLKConfig+0x7c6>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
    faa0:	f240 51bd 	movw	r1, #1469	; 0x5bd
    faa4:	486e      	ldr	r0, [pc, #440]	; (fc60 <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
    faa6:	f009 fcb5 	bl	19414 <assert_failed>
    faaa:	6f22      	ldr	r2, [r4, #112]	; 0x70
    faac:	e6ae      	b.n	f80c <HAL_RCCEx_PeriphCLKConfig+0x5e8>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
    faae:	f240 515e 	movw	r1, #1374	; 0x55e
    fab2:	486b      	ldr	r0, [pc, #428]	; (fc60 <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
    fab4:	f009 fcae 	bl	19414 <assert_failed>
    fab8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    switch(PeriphClkInit->SdmmcClockSelection)
    faba:	2b00      	cmp	r3, #0
    fabc:	f47f ae89 	bne.w	f7d2 <HAL_RCCEx_PeriphCLKConfig+0x5ae>
    fac0:	e7c2      	b.n	fa48 <HAL_RCCEx_PeriphCLKConfig+0x824>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
    fac2:	f240 51d1 	movw	r1, #1489	; 0x5d1
    fac6:	4866      	ldr	r0, [pc, #408]	; (fc60 <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
    fac8:	f009 fca4 	bl	19414 <assert_failed>
    facc:	6ea2      	ldr	r2, [r4, #104]	; 0x68
    face:	e6ab      	b.n	f828 <HAL_RCCEx_PeriphCLKConfig+0x604>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
    fad0:	f240 51e7 	movw	r1, #1511	; 0x5e7
    fad4:	4862      	ldr	r0, [pc, #392]	; (fc60 <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
    fad6:	f009 fc9d 	bl	19414 <assert_failed>
    fada:	e6b4      	b.n	f846 <HAL_RCCEx_PeriphCLKConfig+0x622>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    fadc:	2101      	movs	r1, #1
    fade:	1d20      	adds	r0, r4, #4
    fae0:	f7ff f9c0 	bl	ee64 <RCCEx_PLL2_Config>
    fae4:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fae6:	2d00      	cmp	r5, #0
    fae8:	f43f af18 	beq.w	f91c <HAL_RCCEx_PeriphCLKConfig+0x6f8>
    faec:	e77a      	b.n	f9e4 <HAL_RCCEx_PeriphCLKConfig+0x7c0>
    switch(PeriphClkInit->RngClockSelection)
    faee:	2a00      	cmp	r2, #0
    faf0:	f47f aec9 	bne.w	f886 <HAL_RCCEx_PeriphCLKConfig+0x662>
    if(ret == HAL_OK)
    faf4:	2d00      	cmp	r5, #0
    faf6:	d1a4      	bne.n	fa42 <HAL_RCCEx_PeriphCLKConfig+0x81e>
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
    faf8:	4a58      	ldr	r2, [pc, #352]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fafa:	3600      	adds	r6, #0
    fafc:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
    fafe:	6d53      	ldr	r3, [r2, #84]	; 0x54
    fb00:	bf18      	it	ne
    fb02:	2601      	movne	r6, #1
    fb04:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    fb08:	430b      	orrs	r3, r1
    fb0a:	6553      	str	r3, [r2, #84]	; 0x54
    fb0c:	6823      	ldr	r3, [r4, #0]
    fb0e:	e676      	b.n	f7fe <HAL_RCCEx_PeriphCLKConfig+0x5da>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fb10:	4a52      	ldr	r2, [pc, #328]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fb12:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fb14:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fb18:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fb1a:	b14d      	cbz	r5, fb30 <HAL_RCCEx_PeriphCLKConfig+0x90c>
    fb1c:	6823      	ldr	r3, [r4, #0]
    fb1e:	462e      	mov	r6, r5
    fb20:	e40a      	b.n	f338 <HAL_RCCEx_PeriphCLKConfig+0x114>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
    fb22:	2102      	movs	r1, #2
    fb24:	1d20      	adds	r0, r4, #4
    fb26:	f7ff f99d 	bl	ee64 <RCCEx_PLL2_Config>
    fb2a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fb2c:	2d00      	cmp	r5, #0
    fb2e:	d1f5      	bne.n	fb1c <HAL_RCCEx_PeriphCLKConfig+0x8f8>
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
    fb30:	4a4a      	ldr	r2, [pc, #296]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fb32:	6ca1      	ldr	r1, [r4, #72]	; 0x48
    fb34:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
    fb36:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    fb3a:	430b      	orrs	r3, r1
    fb3c:	64d3      	str	r3, [r2, #76]	; 0x4c
    fb3e:	6823      	ldr	r3, [r4, #0]
    fb40:	f7ff bbfa 	b.w	f338 <HAL_RCCEx_PeriphCLKConfig+0x114>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    fb44:	2101      	movs	r1, #1
    fb46:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fb4a:	f7ff fa7b 	bl	f044 <RCCEx_PLL3_Config>
    fb4e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fb50:	2d00      	cmp	r5, #0
    fb52:	f43f ac21 	beq.w	f398 <HAL_RCCEx_PeriphCLKConfig+0x174>
    fb56:	e75a      	b.n	fa0e <HAL_RCCEx_PeriphCLKConfig+0x7ea>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    fb58:	2101      	movs	r1, #1
    fb5a:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fb5e:	f7ff fa71 	bl	f044 <RCCEx_PLL3_Config>
    fb62:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fb64:	2d00      	cmp	r5, #0
    fb66:	f43f ac36 	beq.w	f3d6 <HAL_RCCEx_PeriphCLKConfig+0x1b2>
    fb6a:	e74d      	b.n	fa08 <HAL_RCCEx_PeriphCLKConfig+0x7e4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fb6c:	4a3b      	ldr	r2, [pc, #236]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fb6e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fb70:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fb74:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fb76:	2d00      	cmp	r5, #0
    fb78:	f43f aee0 	beq.w	f93c <HAL_RCCEx_PeriphCLKConfig+0x718>
    fb7c:	e753      	b.n	fa26 <HAL_RCCEx_PeriphCLKConfig+0x802>
    switch(PeriphClkInit->Sai1ClockSelection)
    fb7e:	4635      	mov	r5, r6
    if(ret == HAL_OK)
    fb80:	b34d      	cbz	r5, fbd6 <HAL_RCCEx_PeriphCLKConfig+0x9b2>
    fb82:	6823      	ldr	r3, [r4, #0]
    fb84:	462e      	mov	r6, r5
    fb86:	f7ff bb79 	b.w	f27c <HAL_RCCEx_PeriphCLKConfig+0x58>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
    fb8a:	2102      	movs	r1, #2
    fb8c:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fb90:	f7ff fa58 	bl	f044 <RCCEx_PLL3_Config>
    fb94:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fb96:	2d00      	cmp	r5, #0
    fb98:	f43f adb9 	beq.w	f70e <HAL_RCCEx_PeriphCLKConfig+0x4ea>
    fb9c:	e73a      	b.n	fa14 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
    fb9e:	2102      	movs	r1, #2
    fba0:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fba4:	f7ff fa4e 	bl	f044 <RCCEx_PLL3_Config>
    fba8:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fbaa:	2d00      	cmp	r5, #0
    fbac:	f43f ad8f 	beq.w	f6ce <HAL_RCCEx_PeriphCLKConfig+0x4aa>
    fbb0:	e733      	b.n	fa1a <HAL_RCCEx_PeriphCLKConfig+0x7f6>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
    fbb2:	2102      	movs	r1, #2
    fbb4:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fbb8:	f7ff fa44 	bl	f044 <RCCEx_PLL3_Config>
    fbbc:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fbbe:	2d00      	cmp	r5, #0
    fbc0:	f43f ad65 	beq.w	f68e <HAL_RCCEx_PeriphCLKConfig+0x46a>
    fbc4:	e72c      	b.n	fa20 <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fbc6:	4a25      	ldr	r2, [pc, #148]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
      break;
    fbc8:	4635      	mov	r5, r6
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fbca:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fbcc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fbd0:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fbd2:	2d00      	cmp	r5, #0
    fbd4:	d1d5      	bne.n	fb82 <HAL_RCCEx_PeriphCLKConfig+0x95e>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
    fbd6:	4a21      	ldr	r2, [pc, #132]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fbd8:	6d61      	ldr	r1, [r4, #84]	; 0x54
    fbda:	6d13      	ldr	r3, [r2, #80]	; 0x50
    fbdc:	f023 0307 	bic.w	r3, r3, #7
    fbe0:	430b      	orrs	r3, r1
    fbe2:	6513      	str	r3, [r2, #80]	; 0x50
    fbe4:	6823      	ldr	r3, [r4, #0]
    fbe6:	f7ff bb49 	b.w	f27c <HAL_RCCEx_PeriphCLKConfig+0x58>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    fbea:	2100      	movs	r1, #0
    fbec:	1d20      	adds	r0, r4, #4
    fbee:	f7ff f939 	bl	ee64 <RCCEx_PLL2_Config>
    fbf2:	4605      	mov	r5, r0
      break;
    fbf4:	e7c4      	b.n	fb80 <HAL_RCCEx_PeriphCLKConfig+0x95c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
    fbf6:	2100      	movs	r1, #0
    fbf8:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fbfc:	f7ff fa22 	bl	f044 <RCCEx_PLL3_Config>
    fc00:	4605      	mov	r5, r0
      break;
    fc02:	e7bd      	b.n	fb80 <HAL_RCCEx_PeriphCLKConfig+0x95c>
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
    fc04:	2102      	movs	r1, #2
    fc06:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fc0a:	f7ff fa1b 	bl	f044 <RCCEx_PLL3_Config>
    fc0e:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
    fc12:	2800      	cmp	r0, #0
    fc14:	f43f ad90 	beq.w	f738 <HAL_RCCEx_PeriphCLKConfig+0x514>
          status = HAL_ERROR;
    fc18:	2601      	movs	r6, #1
    fc1a:	e58d      	b.n	f738 <HAL_RCCEx_PeriphCLKConfig+0x514>
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
    fc1c:	2102      	movs	r1, #2
    fc1e:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fc22:	f7ff fa0f 	bl	f044 <RCCEx_PLL3_Config>
    fc26:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    fc2a:	2800      	cmp	r0, #0
    fc2c:	f43f ad9d 	beq.w	f76a <HAL_RCCEx_PeriphCLKConfig+0x546>
        status = HAL_ERROR;
    fc30:	2601      	movs	r6, #1
    fc32:	e59a      	b.n	f76a <HAL_RCCEx_PeriphCLKConfig+0x546>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
    fc34:	2100      	movs	r1, #0
    fc36:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fc3a:	f7ff fa03 	bl	f044 <RCCEx_PLL3_Config>
    fc3e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fc40:	2d00      	cmp	r5, #0
    fc42:	f47f ab91 	bne.w	f368 <HAL_RCCEx_PeriphCLKConfig+0x144>
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
    fc46:	4a05      	ldr	r2, [pc, #20]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fc48:	6de1      	ldr	r1, [r4, #92]	; 0x5c
    fc4a:	6d13      	ldr	r3, [r2, #80]	; 0x50
    fc4c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
    fc50:	430b      	orrs	r3, r1
    fc52:	6513      	str	r3, [r2, #80]	; 0x50
    fc54:	6823      	ldr	r3, [r4, #0]
    fc56:	f7ff bb89 	b.w	f36c <HAL_RCCEx_PeriphCLKConfig+0x148>
    fc5a:	bf00      	nop
    fc5c:	58024400 	.word	0x58024400
    fc60:	0002fe68 	.word	0x0002fe68
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fc64:	4aa0      	ldr	r2, [pc, #640]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fc66:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fc68:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fc6c:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fc6e:	2d00      	cmp	r5, #0
    fc70:	f47f ab50 	bne.w	f314 <HAL_RCCEx_PeriphCLKConfig+0xf0>
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
    fc74:	4a9c      	ldr	r2, [pc, #624]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fc76:	f8d4 10a8 	ldr.w	r1, [r4, #168]	; 0xa8
    fc7a:	6d93      	ldr	r3, [r2, #88]	; 0x58
    fc7c:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    fc80:	430b      	orrs	r3, r1
    fc82:	6593      	str	r3, [r2, #88]	; 0x58
    fc84:	6823      	ldr	r3, [r4, #0]
    fc86:	f7ff bb47 	b.w	f318 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
    fc8a:	2102      	movs	r1, #2
    fc8c:	3004      	adds	r0, #4
    fc8e:	f7ff f8e9 	bl	ee64 <RCCEx_PLL2_Config>
    fc92:	4606      	mov	r6, r0
    if(ret == HAL_OK)
    fc94:	2e00      	cmp	r6, #0
    fc96:	f47f aae2 	bne.w	f25e <HAL_RCCEx_PeriphCLKConfig+0x3a>
    fc9a:	6e62      	ldr	r2, [r4, #100]	; 0x64
    fc9c:	f7ff bad8 	b.w	f250 <HAL_RCCEx_PeriphCLKConfig+0x2c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
    fca0:	2100      	movs	r1, #0
    fca2:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fca6:	f7ff f9cd 	bl	f044 <RCCEx_PLL3_Config>
    fcaa:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fcac:	2d00      	cmp	r5, #0
    fcae:	f47f aafb 	bne.w	f2a8 <HAL_RCCEx_PeriphCLKConfig+0x84>
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
    fcb2:	4a8d      	ldr	r2, [pc, #564]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fcb4:	6da1      	ldr	r1, [r4, #88]	; 0x58
    fcb6:	6d13      	ldr	r3, [r2, #80]	; 0x50
    fcb8:	f423 73e0 	bic.w	r3, r3, #448	; 0x1c0
    fcbc:	430b      	orrs	r3, r1
    fcbe:	6513      	str	r3, [r2, #80]	; 0x50
    fcc0:	6823      	ldr	r3, [r4, #0]
    fcc2:	f7ff baf3 	b.w	f2ac <HAL_RCCEx_PeriphCLKConfig+0x88>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
    fcc6:	2100      	movs	r1, #0
    fcc8:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fccc:	f7ff f9ba 	bl	f044 <RCCEx_PLL3_Config>
    fcd0:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fcd2:	2d00      	cmp	r5, #0
    fcd4:	f47f ab03 	bne.w	f2de <HAL_RCCEx_PeriphCLKConfig+0xba>
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
    fcd8:	4a83      	ldr	r2, [pc, #524]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fcda:	f8d4 10a4 	ldr.w	r1, [r4, #164]	; 0xa4
    fcde:	6d93      	ldr	r3, [r2, #88]	; 0x58
    fce0:	f423 0360 	bic.w	r3, r3, #14680064	; 0xe00000
    fce4:	430b      	orrs	r3, r1
    fce6:	6593      	str	r3, [r2, #88]	; 0x58
    fce8:	6823      	ldr	r3, [r4, #0]
    fcea:	f7ff bafa 	b.w	f2e2 <HAL_RCCEx_PeriphCLKConfig+0xbe>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
    fcee:	2100      	movs	r1, #0
    fcf0:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fcf4:	f7ff f9a6 	bl	f044 <RCCEx_PLL3_Config>
    fcf8:	4605      	mov	r5, r0
      break;
    fcfa:	f7ff bb08 	b.w	f30e <HAL_RCCEx_PeriphCLKConfig+0xea>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
    fcfe:	2102      	movs	r1, #2
    fd00:	3024      	adds	r0, #36	; 0x24
    fd02:	f7ff f99f 	bl	f044 <RCCEx_PLL3_Config>
    fd06:	4606      	mov	r6, r0
      break;
    fd08:	e7c4      	b.n	fc94 <HAL_RCCEx_PeriphCLKConfig+0xa70>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fd0a:	4a77      	ldr	r2, [pc, #476]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fd0c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fd0e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fd12:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
    fd14:	f7ff bac5 	b.w	f2a2 <HAL_RCCEx_PeriphCLKConfig+0x7e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fd18:	4a73      	ldr	r2, [pc, #460]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fd1a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fd1c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fd20:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
    fd22:	f7ff bb1e 	b.w	f362 <HAL_RCCEx_PeriphCLKConfig+0x13e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fd26:	4a70      	ldr	r2, [pc, #448]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fd28:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fd2a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fd2e:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
    fd30:	f7ff bad2 	b.w	f2d8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
    fd34:	f240 51f1 	movw	r1, #1521	; 0x5f1
    fd38:	486c      	ldr	r0, [pc, #432]	; (feec <HAL_RCCEx_PeriphCLKConfig+0xcc8>)
    fd3a:	f009 fb6b 	bl	19414 <assert_failed>
    fd3e:	6d22      	ldr	r2, [r4, #80]	; 0x50
    fd40:	e638      	b.n	f9b4 <HAL_RCCEx_PeriphCLKConfig+0x790>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    fd42:	1d20      	adds	r0, r4, #4
    fd44:	f7ff f88e 	bl	ee64 <RCCEx_PLL2_Config>
    fd48:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fd4a:	2d00      	cmp	r5, #0
    fd4c:	f43f ae07 	beq.w	f95e <HAL_RCCEx_PeriphCLKConfig+0x73a>
    fd50:	e657      	b.n	fa02 <HAL_RCCEx_PeriphCLKConfig+0x7de>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fd52:	4a65      	ldr	r2, [pc, #404]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fd54:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fd56:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fd5a:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fd5c:	2d00      	cmp	r5, #0
    fd5e:	f43f ae17 	beq.w	f990 <HAL_RCCEx_PeriphCLKConfig+0x76c>
    fd62:	e64b      	b.n	f9fc <HAL_RCCEx_PeriphCLKConfig+0x7d8>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
    fd64:	f240 41e6 	movw	r1, #1254	; 0x4e6
    fd68:	4860      	ldr	r0, [pc, #384]	; (feec <HAL_RCCEx_PeriphCLKConfig+0xcc8>)
    fd6a:	f009 fb53 	bl	19414 <assert_failed>
    fd6e:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
    fd72:	e4dd      	b.n	f730 <HAL_RCCEx_PeriphCLKConfig+0x50c>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
    fd74:	f44f 619f 	mov.w	r1, #1272	; 0x4f8
    fd78:	485c      	ldr	r0, [pc, #368]	; (feec <HAL_RCCEx_PeriphCLKConfig+0xcc8>)
    fd7a:	f009 fb4b 	bl	19414 <assert_failed>
    fd7e:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    fd82:	e4ee      	b.n	f762 <HAL_RCCEx_PeriphCLKConfig+0x53e>
        tickstart = HAL_GetTick();
    fd84:	f7f8 fb36 	bl	83f4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    fd88:	4f57      	ldr	r7, [pc, #348]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
        tickstart = HAL_GetTick();
    fd8a:	4681      	mov	r9, r0
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
    fd8c:	f241 3888 	movw	r8, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    fd90:	e006      	b.n	fda0 <HAL_RCCEx_PeriphCLKConfig+0xb7c>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
    fd92:	f7f8 fb2f 	bl	83f4 <HAL_GetTick>
    fd96:	eba0 0009 	sub.w	r0, r0, r9
    fd9a:	4540      	cmp	r0, r8
    fd9c:	f63f ae1e 	bhi.w	f9dc <HAL_RCCEx_PeriphCLKConfig+0x7b8>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    fda0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    fda2:	079b      	lsls	r3, r3, #30
    fda4:	d5f5      	bpl.n	fd92 <HAL_RCCEx_PeriphCLKConfig+0xb6e>
    fda6:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
    fdaa:	f7ff bbf2 	b.w	f592 <HAL_RCCEx_PeriphCLKConfig+0x36e>
    switch(PeriphClkInit->Lptim345ClockSelection)
    fdae:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    fdb2:	f43f aca9 	beq.w	f708 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    fdb6:	f5b2 4f20 	cmp.w	r2, #40960	; 0xa000
    fdba:	f43f aca5 	beq.w	f708 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    fdbe:	f5b2 4fc0 	cmp.w	r2, #24576	; 0x6000
    fdc2:	f43f aca1 	beq.w	f708 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
      ret = HAL_ERROR;
    fdc6:	2601      	movs	r6, #1
    fdc8:	4635      	mov	r5, r6
    fdca:	e4a9      	b.n	f720 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
    switch(PeriphClkInit->Spi45ClockSelection)
    fdcc:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
    fdd0:	f43f aadf 	beq.w	f392 <HAL_RCCEx_PeriphCLKConfig+0x16e>
    fdd4:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
    fdd8:	f43f aadb 	beq.w	f392 <HAL_RCCEx_PeriphCLKConfig+0x16e>
    fddc:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
    fde0:	f43f aad7 	beq.w	f392 <HAL_RCCEx_PeriphCLKConfig+0x16e>
      ret = HAL_ERROR;
    fde4:	2601      	movs	r6, #1
    fde6:	4635      	mov	r5, r6
    fde8:	f7ff bade 	b.w	f3a8 <HAL_RCCEx_PeriphCLKConfig+0x184>
    switch(PeriphClkInit->Lptim1ClockSelection)
    fdec:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
    fdf0:	f43f ac4a 	beq.w	f688 <HAL_RCCEx_PeriphCLKConfig+0x464>
    fdf4:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
    fdf8:	f43f ac46 	beq.w	f688 <HAL_RCCEx_PeriphCLKConfig+0x464>
    fdfc:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
    fe00:	f43f ac42 	beq.w	f688 <HAL_RCCEx_PeriphCLKConfig+0x464>
      ret = HAL_ERROR;
    fe04:	2601      	movs	r6, #1
    fe06:	4635      	mov	r5, r6
    fe08:	e44a      	b.n	f6a0 <HAL_RCCEx_PeriphCLKConfig+0x47c>
    switch(PeriphClkInit->Spi6ClockSelection)
    fe0a:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
    fe0e:	f43f aadf 	beq.w	f3d0 <HAL_RCCEx_PeriphCLKConfig+0x1ac>
    fe12:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
    fe16:	f43f aadb 	beq.w	f3d0 <HAL_RCCEx_PeriphCLKConfig+0x1ac>
    fe1a:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
    fe1e:	f43f aad7 	beq.w	f3d0 <HAL_RCCEx_PeriphCLKConfig+0x1ac>
      ret = HAL_ERROR;
    fe22:	2601      	movs	r6, #1
    fe24:	4635      	mov	r5, r6
    fe26:	f7ff badf 	b.w	f3e8 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    switch(PeriphClkInit->Lptim2ClockSelection)
    fe2a:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    fe2e:	f43f ac4b 	beq.w	f6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
    fe32:	f5b2 5fa0 	cmp.w	r2, #5120	; 0x1400
    fe36:	f43f ac47 	beq.w	f6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
    fe3a:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
    fe3e:	f43f ac43 	beq.w	f6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
      ret = HAL_ERROR;
    fe42:	2601      	movs	r6, #1
    fe44:	4635      	mov	r5, r6
    fe46:	e44b      	b.n	f6e0 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
    switch(PeriphClkInit->Sai4AClockSelection)
    fe48:	f5b2 0fc0 	cmp.w	r2, #6291456	; 0x600000
    fe4c:	f43f aa44 	beq.w	f2d8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
    fe50:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    fe54:	f43f aa40 	beq.w	f2d8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      ret = HAL_ERROR;
    fe58:	2601      	movs	r6, #1
    fe5a:	4635      	mov	r5, r6
    fe5c:	f7ff ba41 	b.w	f2e2 <HAL_RCCEx_PeriphCLKConfig+0xbe>
    switch(PeriphClkInit->Sai23ClockSelection)
    fe60:	2ac0      	cmp	r2, #192	; 0xc0
    fe62:	f43f aa1e 	beq.w	f2a2 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    fe66:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    fe6a:	f43f aa1a 	beq.w	f2a2 <HAL_RCCEx_PeriphCLKConfig+0x7e>
      ret = HAL_ERROR;
    fe6e:	2601      	movs	r6, #1
    fe70:	4635      	mov	r5, r6
    fe72:	f7ff ba1b 	b.w	f2ac <HAL_RCCEx_PeriphCLKConfig+0x88>
    switch(PeriphClkInit->SpdifrxClockSelection)
    fe76:	bb22      	cbnz	r2, fec2 <HAL_RCCEx_PeriphCLKConfig+0xc9e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fe78:	4a1b      	ldr	r2, [pc, #108]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fe7a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fe7c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fe80:	62d3      	str	r3, [r2, #44]	; 0x2c
    fe82:	6e42      	ldr	r2, [r0, #100]	; 0x64
    fe84:	f7ff b9e4 	b.w	f250 <HAL_RCCEx_PeriphCLKConfig+0x2c>
    switch(PeriphClkInit->Spi123ClockSelection)
    fe88:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
    fe8c:	f43f aa69 	beq.w	f362 <HAL_RCCEx_PeriphCLKConfig+0x13e>
    fe90:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
    fe94:	f43f aa65 	beq.w	f362 <HAL_RCCEx_PeriphCLKConfig+0x13e>
      ret = HAL_ERROR;
    fe98:	2601      	movs	r6, #1
    fe9a:	4635      	mov	r5, r6
    fe9c:	f7ff ba66 	b.w	f36c <HAL_RCCEx_PeriphCLKConfig+0x148>
    switch(PeriphClkInit->Sai4BClockSelection)
    fea0:	f1b2 7f40 	cmp.w	r2, #50331648	; 0x3000000
    fea4:	f43f aa33 	beq.w	f30e <HAL_RCCEx_PeriphCLKConfig+0xea>
    fea8:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
    feac:	f43f aa2f 	beq.w	f30e <HAL_RCCEx_PeriphCLKConfig+0xea>
      ret = HAL_ERROR;
    feb0:	2601      	movs	r6, #1
    feb2:	4635      	mov	r5, r6
    feb4:	f7ff ba30 	b.w	f318 <HAL_RCCEx_PeriphCLKConfig+0xf4>
    switch(PeriphClkInit->QspiClockSelection)
    feb8:	2a00      	cmp	r2, #0
    feba:	f43f ae2e 	beq.w	fb1a <HAL_RCCEx_PeriphCLKConfig+0x8f6>
    febe:	f7ff ba39 	b.w	f334 <HAL_RCCEx_PeriphCLKConfig+0x110>
      ret = HAL_ERROR;
    fec2:	2601      	movs	r6, #1
    fec4:	f7ff b9cc 	b.w	f260 <HAL_RCCEx_PeriphCLKConfig+0x3c>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
    fec8:	4807      	ldr	r0, [pc, #28]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    feca:	4b09      	ldr	r3, [pc, #36]	; (fef0 <HAL_RCCEx_PeriphCLKConfig+0xccc>)
    fecc:	6901      	ldr	r1, [r0, #16]
    fece:	ea03 1312 	and.w	r3, r3, r2, lsr #4
    fed2:	f421 527c 	bic.w	r2, r1, #16128	; 0x3f00
    fed6:	4313      	orrs	r3, r2
    fed8:	6103      	str	r3, [r0, #16]
    feda:	f7ff bb65 	b.w	f5a8 <HAL_RCCEx_PeriphCLKConfig+0x384>
    fede:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fee0:	462e      	mov	r6, r5
    fee2:	f7ff bb6a 	b.w	f5ba <HAL_RCCEx_PeriphCLKConfig+0x396>
    fee6:	bf00      	nop
    fee8:	58024400 	.word	0x58024400
    feec:	0002fe68 	.word	0x0002fe68
    fef0:	00ffffcf 	.word	0x00ffffcf

0000fef4 <HAL_RCCEx_GetPLL2ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    fef4:	4a46      	ldr	r2, [pc, #280]	; (10010 <HAL_RCCEx_GetPLL2ClockFreq+0x11c>)
{
    fef6:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    fef8:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
    fefa:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
    fefc:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
    fefe:	f3c3 3305 	ubfx	r3, r3, #12, #6
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
    ff02:	6bd5      	ldr	r5, [r2, #60]	; 0x3c
  if (pll2m != 0U)
    ff04:	2b00      	cmp	r3, #0
    ff06:	d059      	beq.n	ffbc <HAL_RCCEx_GetPLL2ClockFreq+0xc8>
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
    ff08:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
    ff0c:	f3c1 1100 	ubfx	r1, r1, #4, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    ff10:	f004 0403 	and.w	r4, r4, #3
    ff14:	ee07 3a90 	vmov	s15, r3
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
    ff18:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
    ff1c:	2c01      	cmp	r4, #1
    ff1e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    ff22:	ee06 1a90 	vmov	s13, r1
    ff26:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
    ff2a:	d002      	beq.n	ff32 <HAL_RCCEx_GetPLL2ClockFreq+0x3e>
    ff2c:	d34e      	bcc.n	ffcc <HAL_RCCEx_GetPLL2ClockFreq+0xd8>
    ff2e:	2c02      	cmp	r4, #2
    ff30:	d049      	beq.n	ffc6 <HAL_RCCEx_GetPLL2ClockFreq+0xd2>
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
    ff32:	ed9f 7a38 	vldr	s14, [pc, #224]	; 10014 <HAL_RCCEx_GetPLL2ClockFreq+0x120>
    ff36:	ee87 6a27 	vdiv.f32	s12, s14, s15
    ff3a:	6b93      	ldr	r3, [r2, #56]	; 0x38
    ff3c:	f3c3 0308 	ubfx	r3, r3, #0, #9
    ff40:	ee07 3a10 	vmov	s14, r3
    ff44:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    ff48:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    ff4c:	ee37 7a25 	vadd.f32	s14, s14, s11
    ff50:	ee77 7a26 	vadd.f32	s15, s14, s13
    ff54:	ee67 7a86 	vmul.f32	s15, s15, s12
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
    ff58:	4a2d      	ldr	r2, [pc, #180]	; (10010 <HAL_RCCEx_GetPLL2ClockFreq+0x11c>)
    ff5a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    ff5e:	6b93      	ldr	r3, [r2, #56]	; 0x38
    ff60:	f3c3 2346 	ubfx	r3, r3, #9, #7
    ff64:	ee06 3a90 	vmov	s13, r3
    ff68:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
    ff6c:	bc30      	pop	{r4, r5}
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
    ff6e:	ee76 6a86 	vadd.f32	s13, s13, s12
    ff72:	ee87 7aa6 	vdiv.f32	s14, s15, s13
    ff76:	eebc 7ac7 	vcvt.u32.f32	s14, s14
    ff7a:	ed80 7a00 	vstr	s14, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
    ff7e:	6b93      	ldr	r3, [r2, #56]	; 0x38
    ff80:	f3c3 4306 	ubfx	r3, r3, #16, #7
    ff84:	ee06 3a90 	vmov	s13, r3
    ff88:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    ff8c:	ee76 6a86 	vadd.f32	s13, s13, s12
    ff90:	ee87 7aa6 	vdiv.f32	s14, s15, s13
    ff94:	eebc 7ac7 	vcvt.u32.f32	s14, s14
    ff98:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
    ff9c:	6b93      	ldr	r3, [r2, #56]	; 0x38
    ff9e:	f3c3 6306 	ubfx	r3, r3, #24, #7
    ffa2:	ee07 3a10 	vmov	s14, r3
    ffa6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    ffaa:	ee37 7a06 	vadd.f32	s14, s14, s12
    ffae:	eec7 6a87 	vdiv.f32	s13, s15, s14
    ffb2:	eefc 6ae6 	vcvt.u32.f32	s13, s13
    ffb6:	edc0 6a02 	vstr	s13, [r0, #8]
}
    ffba:	4770      	bx	lr
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    ffbc:	e9c0 3300 	strd	r3, r3, [r0]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
    ffc0:	6083      	str	r3, [r0, #8]
}
    ffc2:	bc30      	pop	{r4, r5}
    ffc4:	4770      	bx	lr
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
    ffc6:	ed9f 7a14 	vldr	s14, [pc, #80]	; 10018 <HAL_RCCEx_GetPLL2ClockFreq+0x124>
    ffca:	e7b4      	b.n	ff36 <HAL_RCCEx_GetPLL2ClockFreq+0x42>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    ffcc:	6813      	ldr	r3, [r2, #0]
    ffce:	069b      	lsls	r3, r3, #26
    ffd0:	d51a      	bpl.n	10008 <HAL_RCCEx_GetPLL2ClockFreq+0x114>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ffd2:	6814      	ldr	r4, [r2, #0]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
    ffd4:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ffd8:	4910      	ldr	r1, [pc, #64]	; (1001c <HAL_RCCEx_GetPLL2ClockFreq+0x128>)
    ffda:	f3c4 04c1 	ubfx	r4, r4, #3, #2
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
    ffde:	6b93      	ldr	r3, [r2, #56]	; 0x38
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ffe0:	40e1      	lsrs	r1, r4
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
    ffe2:	f3c3 0308 	ubfx	r3, r3, #0, #9
    ffe6:	ee07 1a10 	vmov	s14, r1
    ffea:	eef8 5ac7 	vcvt.f32.s32	s11, s14
    ffee:	ee07 3a10 	vmov	s14, r3
    fff2:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
    fff6:	ee85 7aa7 	vdiv.f32	s14, s11, s15
    fffa:	ee76 7a05 	vadd.f32	s15, s12, s10
    fffe:	ee77 7aa6 	vadd.f32	s15, s15, s13
   10002:	ee67 7a27 	vmul.f32	s15, s14, s15
   10006:	e7a7      	b.n	ff58 <HAL_RCCEx_GetPLL2ClockFreq+0x64>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
   10008:	ed9f 7a05 	vldr	s14, [pc, #20]	; 10020 <HAL_RCCEx_GetPLL2ClockFreq+0x12c>
   1000c:	e793      	b.n	ff36 <HAL_RCCEx_GetPLL2ClockFreq+0x42>
   1000e:	bf00      	nop
   10010:	58024400 	.word	0x58024400
   10014:	4a742400 	.word	0x4a742400
   10018:	4bbebc20 	.word	0x4bbebc20
   1001c:	03d09000 	.word	0x03d09000
   10020:	4c742400 	.word	0x4c742400

00010024 <HAL_RCCEx_GetPLL3ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10024:	4a46      	ldr	r2, [pc, #280]	; (10140 <HAL_RCCEx_GetPLL3ClockFreq+0x11c>)
{
   10026:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10028:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
   1002a:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
   1002c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
   1002e:	f3c3 5305 	ubfx	r3, r3, #20, #6
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
   10032:	6c55      	ldr	r5, [r2, #68]	; 0x44
  if (pll3m != 0U)
   10034:	2b00      	cmp	r3, #0
   10036:	d059      	beq.n	100ec <HAL_RCCEx_GetPLL3ClockFreq+0xc8>
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
   10038:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
   1003c:	f3c1 2100 	ubfx	r1, r1, #8, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10040:	f004 0403 	and.w	r4, r4, #3
   10044:	ee07 3a90 	vmov	s15, r3
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
   10048:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
   1004c:	2c01      	cmp	r4, #1
   1004e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   10052:	ee06 1a90 	vmov	s13, r1
   10056:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
   1005a:	d002      	beq.n	10062 <HAL_RCCEx_GetPLL3ClockFreq+0x3e>
   1005c:	d34e      	bcc.n	100fc <HAL_RCCEx_GetPLL3ClockFreq+0xd8>
   1005e:	2c02      	cmp	r4, #2
   10060:	d049      	beq.n	100f6 <HAL_RCCEx_GetPLL3ClockFreq+0xd2>
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   10062:	ed9f 7a38 	vldr	s14, [pc, #224]	; 10144 <HAL_RCCEx_GetPLL3ClockFreq+0x120>
   10066:	ee87 6a27 	vdiv.f32	s12, s14, s15
   1006a:	6c13      	ldr	r3, [r2, #64]	; 0x40
   1006c:	f3c3 0308 	ubfx	r3, r3, #0, #9
   10070:	ee07 3a10 	vmov	s14, r3
   10074:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   10078:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   1007c:	ee37 7a25 	vadd.f32	s14, s14, s11
   10080:	ee77 7a26 	vadd.f32	s15, s14, s13
   10084:	ee67 7a86 	vmul.f32	s15, s15, s12
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
   10088:	4a2d      	ldr	r2, [pc, #180]	; (10140 <HAL_RCCEx_GetPLL3ClockFreq+0x11c>)
   1008a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   1008e:	6c13      	ldr	r3, [r2, #64]	; 0x40
   10090:	f3c3 2346 	ubfx	r3, r3, #9, #7
   10094:	ee06 3a90 	vmov	s13, r3
   10098:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
   1009c:	bc30      	pop	{r4, r5}
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
   1009e:	ee76 6a86 	vadd.f32	s13, s13, s12
   100a2:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   100a6:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   100aa:	ed80 7a00 	vstr	s14, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
   100ae:	6c13      	ldr	r3, [r2, #64]	; 0x40
   100b0:	f3c3 4306 	ubfx	r3, r3, #16, #7
   100b4:	ee06 3a90 	vmov	s13, r3
   100b8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   100bc:	ee76 6a86 	vadd.f32	s13, s13, s12
   100c0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   100c4:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   100c8:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
   100cc:	6c13      	ldr	r3, [r2, #64]	; 0x40
   100ce:	f3c3 6306 	ubfx	r3, r3, #24, #7
   100d2:	ee07 3a10 	vmov	s14, r3
   100d6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   100da:	ee37 7a06 	vadd.f32	s14, s14, s12
   100de:	eec7 6a87 	vdiv.f32	s13, s15, s14
   100e2:	eefc 6ae6 	vcvt.u32.f32	s13, s13
   100e6:	edc0 6a02 	vstr	s13, [r0, #8]
}
   100ea:	4770      	bx	lr
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
   100ec:	e9c0 3300 	strd	r3, r3, [r0]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
   100f0:	6083      	str	r3, [r0, #8]
}
   100f2:	bc30      	pop	{r4, r5}
   100f4:	4770      	bx	lr
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   100f6:	ed9f 7a14 	vldr	s14, [pc, #80]	; 10148 <HAL_RCCEx_GetPLL3ClockFreq+0x124>
   100fa:	e7b4      	b.n	10066 <HAL_RCCEx_GetPLL3ClockFreq+0x42>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   100fc:	6813      	ldr	r3, [r2, #0]
   100fe:	069b      	lsls	r3, r3, #26
   10100:	d51a      	bpl.n	10138 <HAL_RCCEx_GetPLL3ClockFreq+0x114>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10102:	6814      	ldr	r4, [r2, #0]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   10104:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10108:	4910      	ldr	r1, [pc, #64]	; (1014c <HAL_RCCEx_GetPLL3ClockFreq+0x128>)
   1010a:	f3c4 04c1 	ubfx	r4, r4, #3, #2
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   1010e:	6c13      	ldr	r3, [r2, #64]	; 0x40
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10110:	40e1      	lsrs	r1, r4
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   10112:	f3c3 0308 	ubfx	r3, r3, #0, #9
   10116:	ee07 1a10 	vmov	s14, r1
   1011a:	eef8 5ac7 	vcvt.f32.s32	s11, s14
   1011e:	ee07 3a10 	vmov	s14, r3
   10122:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
   10126:	ee85 7aa7 	vdiv.f32	s14, s11, s15
   1012a:	ee76 7a05 	vadd.f32	s15, s12, s10
   1012e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   10132:	ee67 7a27 	vmul.f32	s15, s14, s15
   10136:	e7a7      	b.n	10088 <HAL_RCCEx_GetPLL3ClockFreq+0x64>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   10138:	ed9f 7a05 	vldr	s14, [pc, #20]	; 10150 <HAL_RCCEx_GetPLL3ClockFreq+0x12c>
   1013c:	e793      	b.n	10066 <HAL_RCCEx_GetPLL3ClockFreq+0x42>
   1013e:	bf00      	nop
   10140:	58024400 	.word	0x58024400
   10144:	4a742400 	.word	0x4a742400
   10148:	4bbebc20 	.word	0x4bbebc20
   1014c:	03d09000 	.word	0x03d09000
   10150:	4c742400 	.word	0x4c742400

00010154 <HAL_RCCEx_GetPLL1ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10154:	4a46      	ldr	r2, [pc, #280]	; (10270 <HAL_RCCEx_GetPLL1ClockFreq+0x11c>)
{
   10156:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10158:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
   1015a:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
   1015c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
   1015e:	f3c3 1305 	ubfx	r3, r3, #4, #6
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
   10162:	6b55      	ldr	r5, [r2, #52]	; 0x34
  if (pll1m != 0U)
   10164:	2b00      	cmp	r3, #0
   10166:	d059      	beq.n	1021c <HAL_RCCEx_GetPLL1ClockFreq+0xc8>
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
   10168:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
   1016c:	f001 0101 	and.w	r1, r1, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10170:	f004 0403 	and.w	r4, r4, #3
   10174:	ee07 3a90 	vmov	s15, r3
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
   10178:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
   1017c:	2c01      	cmp	r4, #1
   1017e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   10182:	ee06 1a90 	vmov	s13, r1
   10186:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
   1018a:	d002      	beq.n	10192 <HAL_RCCEx_GetPLL1ClockFreq+0x3e>
   1018c:	d34e      	bcc.n	1022c <HAL_RCCEx_GetPLL1ClockFreq+0xd8>
   1018e:	2c02      	cmp	r4, #2
   10190:	d049      	beq.n	10226 <HAL_RCCEx_GetPLL1ClockFreq+0xd2>
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   10192:	ed9f 7a38 	vldr	s14, [pc, #224]	; 10274 <HAL_RCCEx_GetPLL1ClockFreq+0x120>
   10196:	ee87 6a27 	vdiv.f32	s12, s14, s15
   1019a:	6b13      	ldr	r3, [r2, #48]	; 0x30
   1019c:	f3c3 0308 	ubfx	r3, r3, #0, #9
   101a0:	ee07 3a10 	vmov	s14, r3
   101a4:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   101a8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   101ac:	ee37 7a25 	vadd.f32	s14, s14, s11
   101b0:	ee77 7a26 	vadd.f32	s15, s14, s13
   101b4:	ee67 7a86 	vmul.f32	s15, s15, s12
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
   101b8:	4a2d      	ldr	r2, [pc, #180]	; (10270 <HAL_RCCEx_GetPLL1ClockFreq+0x11c>)
   101ba:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   101be:	6b13      	ldr	r3, [r2, #48]	; 0x30
   101c0:	f3c3 2346 	ubfx	r3, r3, #9, #7
   101c4:	ee06 3a90 	vmov	s13, r3
   101c8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
   101cc:	bc30      	pop	{r4, r5}
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
   101ce:	ee76 6a86 	vadd.f32	s13, s13, s12
   101d2:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   101d6:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   101da:	ed80 7a00 	vstr	s14, [r0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
   101de:	6b13      	ldr	r3, [r2, #48]	; 0x30
   101e0:	f3c3 4306 	ubfx	r3, r3, #16, #7
   101e4:	ee06 3a90 	vmov	s13, r3
   101e8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   101ec:	ee76 6a86 	vadd.f32	s13, s13, s12
   101f0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   101f4:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   101f8:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
   101fc:	6b13      	ldr	r3, [r2, #48]	; 0x30
   101fe:	f3c3 6306 	ubfx	r3, r3, #24, #7
   10202:	ee07 3a10 	vmov	s14, r3
   10206:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   1020a:	ee37 7a06 	vadd.f32	s14, s14, s12
   1020e:	eec7 6a87 	vdiv.f32	s13, s15, s14
   10212:	eefc 6ae6 	vcvt.u32.f32	s13, s13
   10216:	edc0 6a02 	vstr	s13, [r0, #8]
}
   1021a:	4770      	bx	lr
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
   1021c:	e9c0 3300 	strd	r3, r3, [r0]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
   10220:	6083      	str	r3, [r0, #8]
}
   10222:	bc30      	pop	{r4, r5}
   10224:	4770      	bx	lr
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   10226:	ed9f 7a14 	vldr	s14, [pc, #80]	; 10278 <HAL_RCCEx_GetPLL1ClockFreq+0x124>
   1022a:	e7b4      	b.n	10196 <HAL_RCCEx_GetPLL1ClockFreq+0x42>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   1022c:	6813      	ldr	r3, [r2, #0]
   1022e:	069b      	lsls	r3, r3, #26
   10230:	d51a      	bpl.n	10268 <HAL_RCCEx_GetPLL1ClockFreq+0x114>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10232:	6814      	ldr	r4, [r2, #0]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   10234:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10238:	4910      	ldr	r1, [pc, #64]	; (1027c <HAL_RCCEx_GetPLL1ClockFreq+0x128>)
   1023a:	f3c4 04c1 	ubfx	r4, r4, #3, #2
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   1023e:	6b13      	ldr	r3, [r2, #48]	; 0x30
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10240:	40e1      	lsrs	r1, r4
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   10242:	f3c3 0308 	ubfx	r3, r3, #0, #9
   10246:	ee07 1a10 	vmov	s14, r1
   1024a:	eef8 5ac7 	vcvt.f32.s32	s11, s14
   1024e:	ee07 3a10 	vmov	s14, r3
   10252:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
   10256:	ee85 7aa7 	vdiv.f32	s14, s11, s15
   1025a:	ee76 7a05 	vadd.f32	s15, s12, s10
   1025e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   10262:	ee67 7a27 	vmul.f32	s15, s14, s15
   10266:	e7a7      	b.n	101b8 <HAL_RCCEx_GetPLL1ClockFreq+0x64>
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   10268:	ed9f 7a05 	vldr	s14, [pc, #20]	; 10280 <HAL_RCCEx_GetPLL1ClockFreq+0x12c>
   1026c:	e793      	b.n	10196 <HAL_RCCEx_GetPLL1ClockFreq+0x42>
   1026e:	bf00      	nop
   10270:	58024400 	.word	0x58024400
   10274:	4a742400 	.word	0x4a742400
   10278:	4bbebc20 	.word	0x4bbebc20
   1027c:	03d09000 	.word	0x03d09000
   10280:	4c742400 	.word	0x4c742400

00010284 <HAL_RCCEx_GetPeriphCLKFreq>:
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
   10284:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
{
   10288:	b500      	push	{lr}
   1028a:	b085      	sub	sp, #20
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
   1028c:	d02d      	beq.n	102ea <HAL_RCCEx_GetPeriphCLKFreq+0x66>
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
   1028e:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
   10292:	d018      	beq.n	102c6 <HAL_RCCEx_GetPeriphCLKFreq+0x42>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
   10294:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
   10298:	d04e      	beq.n	10338 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
   1029a:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
   1029e:	d037      	beq.n	10310 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
   102a0:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   102a4:	f000 808b 	beq.w	103be <HAL_RCCEx_GetPeriphCLKFreq+0x13a>
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
   102a8:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
   102ac:	f000 80ac 	beq.w	10408 <HAL_RCCEx_GetPeriphCLKFreq+0x184>
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
   102b0:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
   102b4:	f000 80b6 	beq.w	10424 <HAL_RCCEx_GetPeriphCLKFreq+0x1a0>
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
   102b8:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
   102bc:	d062      	beq.n	10384 <HAL_RCCEx_GetPeriphCLKFreq+0x100>
          frequency = 0;
   102be:	2000      	movs	r0, #0
}
   102c0:	b005      	add	sp, #20
   102c2:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
   102c6:	4a70      	ldr	r2, [pc, #448]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   102c8:	6d13      	ldr	r3, [r2, #80]	; 0x50
   102ca:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
      switch (saiclocksource)
   102ce:	2b80      	cmp	r3, #128	; 0x80
   102d0:	d043      	beq.n	1035a <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
   102d2:	d86a      	bhi.n	103aa <HAL_RCCEx_GetPeriphCLKFreq+0x126>
   102d4:	2b00      	cmp	r3, #0
   102d6:	d039      	beq.n	1034c <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
   102d8:	2b40      	cmp	r3, #64	; 0x40
   102da:	d1f0      	bne.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   102dc:	a801      	add	r0, sp, #4
   102de:	f7ff fe09 	bl	fef4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
   102e2:	9801      	ldr	r0, [sp, #4]
}
   102e4:	b005      	add	sp, #20
   102e6:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
   102ea:	4b67      	ldr	r3, [pc, #412]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   102ec:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   102ee:	f003 0307 	and.w	r3, r3, #7
      switch (saiclocksource)
   102f2:	2b04      	cmp	r3, #4
   102f4:	d8e3      	bhi.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
   102f6:	a201      	add	r2, pc, #4	; (adr r2, 102fc <HAL_RCCEx_GetPeriphCLKFreq+0x78>)
   102f8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   102fc:	0001034d 	.word	0x0001034d
   10300:	000102dd 	.word	0x000102dd
   10304:	0001035b 	.word	0x0001035b
   10308:	00010331 	.word	0x00010331
   1030c:	00010369 	.word	0x00010369
      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
   10310:	4a5d      	ldr	r2, [pc, #372]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   10312:	6d93      	ldr	r3, [r2, #88]	; 0x58
   10314:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
      switch (saiclocksource)
   10318:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
   1031c:	d01d      	beq.n	1035a <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
   1031e:	d85c      	bhi.n	103da <HAL_RCCEx_GetPeriphCLKFreq+0x156>
   10320:	b1a3      	cbz	r3, 1034c <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
   10322:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   10326:	d0d9      	beq.n	102dc <HAL_RCCEx_GetPeriphCLKFreq+0x58>
   10328:	e7c9      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
   1032a:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
   1032e:	d15b      	bne.n	103e8 <HAL_RCCEx_GetPeriphCLKFreq+0x164>
          frequency = EXTERNAL_CLOCK_VALUE;
   10330:	4856      	ldr	r0, [pc, #344]	; (1048c <HAL_RCCEx_GetPeriphCLKFreq+0x208>)
}
   10332:	b005      	add	sp, #20
   10334:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
   10338:	4a53      	ldr	r2, [pc, #332]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   1033a:	6d93      	ldr	r3, [r2, #88]	; 0x58
   1033c:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
      switch (saiclocksource)
   10340:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   10344:	d009      	beq.n	1035a <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
   10346:	d8f0      	bhi.n	1032a <HAL_RCCEx_GetPeriphCLKFreq+0xa6>
   10348:	2b00      	cmp	r3, #0
   1034a:	d151      	bne.n	103f0 <HAL_RCCEx_GetPeriphCLKFreq+0x16c>
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   1034c:	a801      	add	r0, sp, #4
   1034e:	f7ff ff01 	bl	10154 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
   10352:	9802      	ldr	r0, [sp, #8]
}
   10354:	b005      	add	sp, #20
   10356:	f85d fb04 	ldr.w	pc, [sp], #4
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   1035a:	a801      	add	r0, sp, #4
   1035c:	f7ff fe62 	bl	10024 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
   10360:	9801      	ldr	r0, [sp, #4]
}
   10362:	b005      	add	sp, #20
   10364:	f85d fb04 	ldr.w	pc, [sp], #4
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
   10368:	4b47      	ldr	r3, [pc, #284]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   1036a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
   1036c:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
   10370:	d019      	beq.n	103a6 <HAL_RCCEx_GetPeriphCLKFreq+0x122>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
   10372:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   10376:	d062      	beq.n	1043e <HAL_RCCEx_GetPeriphCLKFreq+0x1ba>
            frequency = HSE_VALUE;
   10378:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   1037c:	4844      	ldr	r0, [pc, #272]	; (10490 <HAL_RCCEx_GetPeriphCLKFreq+0x20c>)
   1037e:	bf18      	it	ne
   10380:	2000      	movne	r0, #0
   10382:	e79d      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
   10384:	4b40      	ldr	r3, [pc, #256]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   10386:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   10388:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
      switch (srcclk)
   1038c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   10390:	d068      	beq.n	10464 <HAL_RCCEx_GetPeriphCLKFreq+0x1e0>
   10392:	d95b      	bls.n	1044c <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>
   10394:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
   10398:	d051      	beq.n	1043e <HAL_RCCEx_GetPeriphCLKFreq+0x1ba>
   1039a:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
   1039e:	d05f      	beq.n	10460 <HAL_RCCEx_GetPeriphCLKFreq+0x1dc>
   103a0:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
   103a4:	d18b      	bne.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
            frequency = HSI_VALUE;
   103a6:	483b      	ldr	r0, [pc, #236]	; (10494 <HAL_RCCEx_GetPeriphCLKFreq+0x210>)
   103a8:	e78a      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      switch (saiclocksource)
   103aa:	2bc0      	cmp	r3, #192	; 0xc0
   103ac:	d0c0      	beq.n	10330 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
   103ae:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   103b2:	d184      	bne.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
   103b4:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
   103b6:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
   103ba:	d1da      	bne.n	10372 <HAL_RCCEx_GetPeriphCLKFreq+0xee>
   103bc:	e7f3      	b.n	103a6 <HAL_RCCEx_GetPeriphCLKFreq+0x122>
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
   103be:	4a32      	ldr	r2, [pc, #200]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   103c0:	6d13      	ldr	r3, [r2, #80]	; 0x50
   103c2:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
      switch (srcclk)
   103c6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   103ca:	d0c6      	beq.n	1035a <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
   103cc:	d815      	bhi.n	103fa <HAL_RCCEx_GetPeriphCLKFreq+0x176>
   103ce:	2b00      	cmp	r3, #0
   103d0:	d0bc      	beq.n	1034c <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
   103d2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   103d6:	d081      	beq.n	102dc <HAL_RCCEx_GetPeriphCLKFreq+0x58>
   103d8:	e771      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
   103da:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
   103de:	d0a7      	beq.n	10330 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
   103e0:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
   103e4:	d0e6      	beq.n	103b4 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
   103e6:	e76a      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
   103e8:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   103ec:	d0e2      	beq.n	103b4 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
   103ee:	e766      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
   103f0:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
   103f4:	f43f af72 	beq.w	102dc <HAL_RCCEx_GetPeriphCLKFreq+0x58>
   103f8:	e761      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (srcclk)
   103fa:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
   103fe:	d097      	beq.n	10330 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
   10400:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   10404:	d0d6      	beq.n	103b4 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
   10406:	e75a      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
   10408:	4a1f      	ldr	r2, [pc, #124]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   1040a:	6d93      	ldr	r3, [r2, #88]	; 0x58
   1040c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
      switch (srcclk)
   10410:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   10414:	d015      	beq.n	10442 <HAL_RCCEx_GetPeriphCLKFreq+0x1be>
   10416:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   1041a:	d0cb      	beq.n	103b4 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
   1041c:	2b00      	cmp	r3, #0
   1041e:	f47f af4e 	bne.w	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
   10422:	e75b      	b.n	102dc <HAL_RCCEx_GetPeriphCLKFreq+0x58>
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
   10424:	4b18      	ldr	r3, [pc, #96]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   10426:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
      switch (srcclk)
   10428:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
   1042c:	d08e      	beq.n	1034c <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
   1042e:	2b00      	cmp	r3, #0
   10430:	f43f af45 	beq.w	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   10434:	a801      	add	r0, sp, #4
   10436:	f7ff fd5d 	bl	fef4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
   1043a:	9803      	ldr	r0, [sp, #12]
          break;
   1043c:	e740      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
            frequency = CSI_VALUE;
   1043e:	4816      	ldr	r0, [pc, #88]	; (10498 <HAL_RCCEx_GetPeriphCLKFreq+0x214>)
   10440:	e73e      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   10442:	a801      	add	r0, sp, #4
   10444:	f7ff fdee 	bl	10024 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
   10448:	9803      	ldr	r0, [sp, #12]
          break;
   1044a:	e739      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      switch (srcclk)
   1044c:	b17b      	cbz	r3, 1046e <HAL_RCCEx_GetPeriphCLKFreq+0x1ea>
   1044e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   10452:	f47f af34 	bne.w	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   10456:	a801      	add	r0, sp, #4
   10458:	f7ff fd4c 	bl	fef4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
   1045c:	9802      	ldr	r0, [sp, #8]
          break;
   1045e:	e72f      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          frequency = HSE_VALUE;
   10460:	480b      	ldr	r0, [pc, #44]	; (10490 <HAL_RCCEx_GetPeriphCLKFreq+0x20c>)
          break;
   10462:	e72d      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   10464:	a801      	add	r0, sp, #4
   10466:	f7ff fddd 	bl	10024 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
   1046a:	9802      	ldr	r0, [sp, #8]
          break;
   1046c:	e728      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
   1046e:	f7fe fc51 	bl	ed14 <HAL_RCC_GetHCLKFreq>
   10472:	4b05      	ldr	r3, [pc, #20]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   10474:	4a09      	ldr	r2, [pc, #36]	; (1049c <HAL_RCCEx_GetPeriphCLKFreq+0x218>)
   10476:	6a1b      	ldr	r3, [r3, #32]
   10478:	f3c3 1302 	ubfx	r3, r3, #4, #3
   1047c:	5cd3      	ldrb	r3, [r2, r3]
   1047e:	f003 031f 	and.w	r3, r3, #31
   10482:	40d8      	lsrs	r0, r3
          break;
   10484:	e71c      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
   10486:	bf00      	nop
   10488:	58024400 	.word	0x58024400
   1048c:	00bb8000 	.word	0x00bb8000
   10490:	017d7840 	.word	0x017d7840
   10494:	03d09000 	.word	0x03d09000
   10498:	003d0900 	.word	0x003d0900
   1049c:	00030cdc 	.word	0x00030cdc

000104a0 <HAL_RNG_Init>:
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
  uint32_t tickstart;
  /* Check the RNG handle allocation */
  if (hrng == NULL)
   104a0:	2800      	cmp	r0, #0
   104a2:	d049      	beq.n	10538 <HAL_RNG_Init+0x98>
{
   104a4:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }
  /* Check the parameters */
  assert_param(IS_RNG_ALL_INSTANCE(hrng->Instance));
   104a6:	4b28      	ldr	r3, [pc, #160]	; (10548 <HAL_RNG_Init+0xa8>)
   104a8:	4604      	mov	r4, r0
   104aa:	6802      	ldr	r2, [r0, #0]
   104ac:	429a      	cmp	r2, r3
   104ae:	d003      	beq.n	104b8 <HAL_RNG_Init+0x18>
   104b0:	21b1      	movs	r1, #177	; 0xb1
   104b2:	4826      	ldr	r0, [pc, #152]	; (1054c <HAL_RNG_Init+0xac>)
   104b4:	f008 ffae 	bl	19414 <assert_failed>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
   104b8:	6863      	ldr	r3, [r4, #4]
   104ba:	f033 0320 	bics.w	r3, r3, #32
   104be:	d131      	bne.n	10524 <HAL_RNG_Init+0x84>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
   104c0:	7a63      	ldrb	r3, [r4, #9]
   104c2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   104c6:	b343      	cbz	r3, 1051a <HAL_RNG_Init+0x7a>
    HAL_RNG_MspInit(hrng);
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
   104c8:	2302      	movs	r3, #2
      return HAL_ERROR;
    }
  }
#else
  /* Clock Error Detection Configuration */
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
   104ca:	e9d4 2100 	ldrd	r2, r1, [r4]
  hrng->State = HAL_RNG_STATE_BUSY;
   104ce:	7263      	strb	r3, [r4, #9]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
   104d0:	6813      	ldr	r3, [r2, #0]
   104d2:	f023 0320 	bic.w	r3, r3, #32
   104d6:	430b      	orrs	r3, r1
   104d8:	6013      	str	r3, [r2, #0]
#endif /* end of RNG_CR_CONDRST */

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
   104da:	6822      	ldr	r2, [r4, #0]
   104dc:	6813      	ldr	r3, [r2, #0]
   104de:	f043 0304 	orr.w	r3, r3, #4
   104e2:	6013      	str	r3, [r2, #0]

  /* verify that no seed error */
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
   104e4:	6823      	ldr	r3, [r4, #0]
   104e6:	685b      	ldr	r3, [r3, #4]
   104e8:	065b      	lsls	r3, r3, #25
   104ea:	d503      	bpl.n	104f4 <HAL_RNG_Init+0x54>
  {
    hrng->State = HAL_RNG_STATE_ERROR;
   104ec:	2304      	movs	r3, #4
    return HAL_ERROR;
   104ee:	2001      	movs	r0, #1
    hrng->State = HAL_RNG_STATE_ERROR;
   104f0:	7263      	strb	r3, [r4, #9]
  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
   104f2:	bd38      	pop	{r3, r4, r5, pc}
  tickstart = HAL_GetTick();
   104f4:	f7f7 ff7e 	bl	83f4 <HAL_GetTick>
   104f8:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
   104fa:	e004      	b.n	10506 <HAL_RNG_Init+0x66>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
   104fc:	f7f7 ff7a 	bl	83f4 <HAL_GetTick>
   10500:	1b40      	subs	r0, r0, r5
   10502:	2802      	cmp	r0, #2
   10504:	d81a      	bhi.n	1053c <HAL_RNG_Init+0x9c>
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
   10506:	6823      	ldr	r3, [r4, #0]
   10508:	685b      	ldr	r3, [r3, #4]
   1050a:	f013 0304 	ands.w	r3, r3, #4
   1050e:	d1f5      	bne.n	104fc <HAL_RNG_Init+0x5c>
  hrng->State = HAL_RNG_STATE_READY;
   10510:	2201      	movs	r2, #1
  return HAL_OK;
   10512:	4618      	mov	r0, r3
  hrng->State = HAL_RNG_STATE_READY;
   10514:	7262      	strb	r2, [r4, #9]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
   10516:	60e3      	str	r3, [r4, #12]
}
   10518:	bd38      	pop	{r3, r4, r5, pc}
    hrng->Lock = HAL_UNLOCKED;
   1051a:	7222      	strb	r2, [r4, #8]
    HAL_RNG_MspInit(hrng);
   1051c:	4620      	mov	r0, r4
   1051e:	f009 fc8b 	bl	19e38 <HAL_RNG_MspInit>
   10522:	e7d1      	b.n	104c8 <HAL_RNG_Init+0x28>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
   10524:	21b2      	movs	r1, #178	; 0xb2
   10526:	4809      	ldr	r0, [pc, #36]	; (1054c <HAL_RNG_Init+0xac>)
   10528:	f008 ff74 	bl	19414 <assert_failed>
  if (hrng->State == HAL_RNG_STATE_RESET)
   1052c:	7a63      	ldrb	r3, [r4, #9]
   1052e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   10532:	2b00      	cmp	r3, #0
   10534:	d1c8      	bne.n	104c8 <HAL_RNG_Init+0x28>
   10536:	e7f0      	b.n	1051a <HAL_RNG_Init+0x7a>
    return HAL_ERROR;
   10538:	2001      	movs	r0, #1
}
   1053a:	4770      	bx	lr
      hrng->State = HAL_RNG_STATE_ERROR;
   1053c:	2204      	movs	r2, #4
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   1053e:	2302      	movs	r3, #2
      return HAL_ERROR;
   10540:	2001      	movs	r0, #1
      hrng->State = HAL_RNG_STATE_ERROR;
   10542:	7262      	strb	r2, [r4, #9]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   10544:	60e3      	str	r3, [r4, #12]
}
   10546:	bd38      	pop	{r3, r4, r5, pc}
   10548:	48021800 	.word	0x48021800
   1054c:	0002fea4 	.word	0x0002fea4

00010550 <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
   10550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
   10552:	7a03      	ldrb	r3, [r0, #8]
   10554:	2b01      	cmp	r3, #1
   10556:	d00b      	beq.n	10570 <HAL_RNG_GenerateRandomNumber+0x20>
   10558:	4604      	mov	r4, r0
   1055a:	2001      	movs	r0, #1
   1055c:	460e      	mov	r6, r1

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
   1055e:	7a63      	ldrb	r3, [r4, #9]
  __HAL_LOCK(hrng);
   10560:	7220      	strb	r0, [r4, #8]
  if (hrng->State == HAL_RNG_STATE_READY)
   10562:	4283      	cmp	r3, r0
   10564:	d006      	beq.n	10574 <HAL_RNG_GenerateRandomNumber+0x24>

    hrng->State = HAL_RNG_STATE_READY;
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
   10566:	2304      	movs	r3, #4
   10568:	60e3      	str	r3, [r4, #12]
    status = HAL_ERROR;
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
   1056a:	2300      	movs	r3, #0
   1056c:	7223      	strb	r3, [r4, #8]

  return status;
}
   1056e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hrng);
   10570:	2002      	movs	r0, #2
}
   10572:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->State = HAL_RNG_STATE_BUSY;
   10574:	2302      	movs	r3, #2
   10576:	7263      	strb	r3, [r4, #9]
    tickstart = HAL_GetTick();
   10578:	f7f7 ff3c 	bl	83f4 <HAL_GetTick>
   1057c:	4607      	mov	r7, r0
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
   1057e:	e004      	b.n	1058a <HAL_RNG_GenerateRandomNumber+0x3a>
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
   10580:	f7f7 ff38 	bl	83f4 <HAL_GetTick>
   10584:	1bc0      	subs	r0, r0, r7
   10586:	2802      	cmp	r0, #2
   10588:	d80b      	bhi.n	105a2 <HAL_RNG_GenerateRandomNumber+0x52>
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
   1058a:	6822      	ldr	r2, [r4, #0]
   1058c:	6855      	ldr	r5, [r2, #4]
   1058e:	f015 0501 	ands.w	r5, r5, #1
   10592:	d0f5      	beq.n	10580 <HAL_RNG_GenerateRandomNumber+0x30>
    hrng->RandomNumber = hrng->Instance->DR;
   10594:	6893      	ldr	r3, [r2, #8]
    hrng->State = HAL_RNG_STATE_READY;
   10596:	2201      	movs	r2, #1
  HAL_StatusTypeDef status = HAL_OK;
   10598:	2000      	movs	r0, #0
    hrng->RandomNumber = hrng->Instance->DR;
   1059a:	6123      	str	r3, [r4, #16]
    *random32bit = hrng->RandomNumber;
   1059c:	6033      	str	r3, [r6, #0]
    hrng->State = HAL_RNG_STATE_READY;
   1059e:	7262      	strb	r2, [r4, #9]
   105a0:	e7e3      	b.n	1056a <HAL_RNG_GenerateRandomNumber+0x1a>
        hrng->State = HAL_RNG_STATE_READY;
   105a2:	2001      	movs	r0, #1
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   105a4:	2302      	movs	r3, #2
        __HAL_UNLOCK(hrng);
   105a6:	7225      	strb	r5, [r4, #8]
        hrng->State = HAL_RNG_STATE_READY;
   105a8:	7260      	strb	r0, [r4, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   105aa:	60e3      	str	r3, [r4, #12]
}
   105ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   105ae:	bf00      	nop

000105b0 <HAL_SAI_InitProtocol>:
HAL_StatusTypeDef HAL_SAI_InitProtocol(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
  HAL_StatusTypeDef status;

  /* Check the parameters */
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   105b0:	2904      	cmp	r1, #4
{
   105b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   105b4:	460d      	mov	r5, r1
   105b6:	4604      	mov	r4, r0
   105b8:	4617      	mov	r7, r2
   105ba:	461e      	mov	r6, r3
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   105bc:	d87c      	bhi.n	106b8 <HAL_SAI_InitProtocol+0x108>
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
   105be:	2f03      	cmp	r7, #3
   105c0:	d874      	bhi.n	106ac <HAL_SAI_InitProtocol+0xfc>

  switch (protocol)
   105c2:	2d04      	cmp	r5, #4
   105c4:	d828      	bhi.n	10618 <HAL_SAI_InitProtocol+0x68>
   105c6:	e8df f005 	tbb	[pc, r5]
   105ca:	4c4c      	.short	0x4c4c
   105cc:	294c      	.short	0x294c
   105ce:	29          	.byte	0x29
   105cf:	00          	.byte	0x00

  /* Check the SAI PDM parameters */
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
  if (hsai->Init.PdmInit.Activation == ENABLE)
  {
    assert_param(IS_SAI_PDM_MIC_PAIRS_NUMBER(hsai->Init.PdmInit.MicPairsNbr));
   105d0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   105d2:	3b01      	subs	r3, #1
   105d4:	2b02      	cmp	r3, #2
   105d6:	d904      	bls.n	105e2 <HAL_SAI_InitProtocol+0x32>
   105d8:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
   105dc:	4839      	ldr	r0, [pc, #228]	; (106c4 <HAL_SAI_InitProtocol+0x114>)
   105de:	f008 ff19 	bl	19414 <assert_failed>
    assert_param(IS_SAI_PDM_CLOCK_ENABLE(hsai->Init.PdmInit.ClockEnable));
   105e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
   105e4:	b113      	cbz	r3, 105ec <HAL_SAI_InitProtocol+0x3c>
   105e6:	f433 7340 	bics.w	r3, r3, #768	; 0x300
   105ea:	d004      	beq.n	105f6 <HAL_SAI_InitProtocol+0x46>
   105ec:	f240 11af 	movw	r1, #431	; 0x1af
   105f0:	4834      	ldr	r0, [pc, #208]	; (106c4 <HAL_SAI_InitProtocol+0x114>)
   105f2:	f008 ff0f 	bl	19414 <assert_failed>
    /* Check that SAI sub-block is SAI1 or SAI4 sub-block A, in master RX mode with free protocol */
#if defined(SAI4)
    if (((hsai->Instance != SAI1_Block_A) && (hsai->Instance != SAI4_Block_A)) ||
   105f6:	6823      	ldr	r3, [r4, #0]
   105f8:	4a33      	ldr	r2, [pc, #204]	; (106c8 <HAL_SAI_InitProtocol+0x118>)
   105fa:	4293      	cmp	r3, r2
   105fc:	d005      	beq.n	1060a <HAL_SAI_InitProtocol+0x5a>
   105fe:	f102 52c0 	add.w	r2, r2, #402653184	; 0x18000000
   10602:	f5a2 3282 	sub.w	r2, r2, #66560	; 0x10400
   10606:	4293      	cmp	r3, r2
   10608:	d106      	bne.n	10618 <HAL_SAI_InitProtocol+0x68>
   1060a:	6862      	ldr	r2, [r4, #4]
   1060c:	2a01      	cmp	r2, #1
   1060e:	d103      	bne.n	10618 <HAL_SAI_InitProtocol+0x68>
         (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
   10610:	6c62      	ldr	r2, [r4, #68]	; 0x44
   10612:	2a00      	cmp	r2, #0
   10614:	f000 816d 	beq.w	108f2 <HAL_SAI_InitProtocol+0x342>
  hsai->SlotInit.SlotNumber      = nbslot;

  /* in IS2 the number of slot must be even */
  if ((nbslot & 0x1U) != 0U)
  {
    return HAL_ERROR;
   10618:	2001      	movs	r0, #1
}
   1061a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  HAL_StatusTypeDef status = HAL_OK;

  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
  /* Compute ClockStrobing according AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1061c:	6862      	ldr	r2, [r4, #4]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   1061e:	2300      	movs	r3, #0
  {
    /* Receive */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_FALLINGEDGE;
  }
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
  hsai->FrameInit.FSPolarity     = SAI_FS_ACTIVE_HIGH;
   10620:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
   10624:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10628:	f032 0202 	bics.w	r2, r2, #2
  hsai->SlotInit.FirstBitOffset  = 0;
  hsai->SlotInit.SlotNumber      = nbslot;
   1062c:	6726      	str	r6, [r4, #112]	; 0x70
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   1062e:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10630:	bf0c      	ite	eq
   10632:	2201      	moveq	r2, #1
   10634:	461a      	movne	r2, r3
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;

  if (protocol == SAI_PCM_SHORT)
  {
      hsai->FrameInit.ActiveFrameLength = 1;
   10636:	2d04      	cmp	r5, #4
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
   10638:	64e3      	str	r3, [r4, #76]	; 0x4c
   1063a:	6522      	str	r2, [r4, #80]	; 0x50
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1063c:	f64f 72ff 	movw	r2, #65535	; 0xffff
      hsai->FrameInit.ActiveFrameLength = 1;
   10640:	bf14      	ite	ne
   10642:	250d      	movne	r5, #13
   10644:	2501      	moveq	r5, #1
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
   10646:	65e3      	str	r3, [r4, #92]	; 0x5c
   10648:	65a5      	str	r5, [r4, #88]	; 0x58
  hsai->SlotInit.FirstBitOffset  = 0;
   1064a:	66a3      	str	r3, [r4, #104]	; 0x68
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1064c:	6762      	str	r2, [r4, #116]	; 0x74
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
   1064e:	e9c4 0118 	strd	r0, r1, [r4, #96]	; 0x60
  {
    /* SAI_PCM_LONG */
      hsai->FrameInit.ActiveFrameLength = 13;
  }

  switch (datasize)
   10652:	2f03      	cmp	r7, #3
   10654:	d8e0      	bhi.n	10618 <HAL_SAI_InitProtocol+0x68>
   10656:	e8df f017 	tbh	[pc, r7, lsl #1]
   1065a:	0173      	.short	0x0173
   1065c:	017a016d 	.word	0x017a016d
   10660:	0039      	.short	0x0039
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10662:	6862      	ldr	r2, [r4, #4]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   10664:	2300      	movs	r3, #0
  hsai->SlotInit.SlotNumber      = nbslot;
   10666:	6726      	str	r6, [r4, #112]	; 0x70
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10668:	f032 0202 	bics.w	r2, r2, #2
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   1066c:	6463      	str	r3, [r4, #68]	; 0x44
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
   1066e:	64e3      	str	r3, [r4, #76]	; 0x4c
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
   10670:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10674:	bf08      	it	eq
   10676:	4619      	moveq	r1, r3
  hsai->SlotInit.FirstBitOffset  = 0;
   10678:	66a3      	str	r3, [r4, #104]	; 0x68
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1067a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1067e:	bf18      	it	ne
   10680:	2101      	movne	r1, #1
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
   10682:	65e2      	str	r2, [r4, #92]	; 0x5c
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   10684:	6763      	str	r3, [r4, #116]	; 0x74
  if ((nbslot & 0x1U) != 0U)
   10686:	f016 0301 	ands.w	r3, r6, #1
   1068a:	6521      	str	r1, [r4, #80]	; 0x50
   1068c:	d1c4      	bne.n	10618 <HAL_SAI_InitProtocol+0x68>
  if (protocol == SAI_I2S_STANDARD)
   1068e:	2d00      	cmp	r5, #0
   10690:	f000 8164 	beq.w	1095c <HAL_SAI_InitProtocol+0x3ac>
   10694:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   10698:	e9c4 2318 	strd	r2, r3, [r4, #96]	; 0x60
  switch (datasize)
   1069c:	2f03      	cmp	r7, #3
   1069e:	d8bb      	bhi.n	10618 <HAL_SAI_InitProtocol+0x68>
   106a0:	e8df f017 	tbh	[pc, r7, lsl #1]
   106a4:	02490259 	.word	0x02490259
   106a8:	022e0238 	.word	0x022e0238
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
   106ac:	f44f 71a9 	mov.w	r1, #338	; 0x152
   106b0:	4804      	ldr	r0, [pc, #16]	; (106c4 <HAL_SAI_InitProtocol+0x114>)
   106b2:	f008 feaf 	bl	19414 <assert_failed>
   106b6:	e784      	b.n	105c2 <HAL_SAI_InitProtocol+0x12>
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   106b8:	f240 1151 	movw	r1, #337	; 0x151
   106bc:	4801      	ldr	r0, [pc, #4]	; (106c4 <HAL_SAI_InitProtocol+0x114>)
   106be:	f008 fea9 	bl	19414 <assert_failed>
   106c2:	e77c      	b.n	105be <HAL_SAI_InitProtocol+0xe>
   106c4:	0002fedc 	.word	0x0002fedc
   106c8:	40015804 	.word	0x40015804
      hsai->FrameInit.FrameLength = 32U * nbslot;
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
      break;
    case SAI_PROTOCOL_DATASIZE_32BIT:
      hsai->Init.DataSize = SAI_DATASIZE_32;
      hsai->FrameInit.FrameLength = 32U * nbslot;
   106cc:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_32;
   106ce:	21e0      	movs	r1, #224	; 0xe0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   106d0:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
   106d2:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_32;
   106d4:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   106d6:	66e2      	str	r2, [r4, #108]	; 0x6c
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
   106d8:	6822      	ldr	r2, [r4, #0]
   106da:	4ba7      	ldr	r3, [pc, #668]	; (10978 <HAL_SAI_InitProtocol+0x3c8>)
   106dc:	49a7      	ldr	r1, [pc, #668]	; (1097c <HAL_SAI_InitProtocol+0x3cc>)
   106de:	48a8      	ldr	r0, [pc, #672]	; (10980 <HAL_SAI_InitProtocol+0x3d0>)
   106e0:	429a      	cmp	r2, r3
   106e2:	bf18      	it	ne
   106e4:	428a      	cmpne	r2, r1
   106e6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
   106ea:	4da6      	ldr	r5, [pc, #664]	; (10984 <HAL_SAI_InitProtocol+0x3d4>)
   106ec:	bf14      	ite	ne
   106ee:	2301      	movne	r3, #1
   106f0:	2300      	moveq	r3, #0
   106f2:	4282      	cmp	r2, r0
   106f4:	bf0c      	ite	eq
   106f6:	2300      	moveq	r3, #0
   106f8:	f003 0301 	andne.w	r3, r3, #1
   106fc:	f500 6084 	add.w	r0, r0, #1056	; 0x420
   10700:	428a      	cmp	r2, r1
   10702:	bf0c      	ite	eq
   10704:	2300      	moveq	r3, #0
   10706:	f003 0301 	andne.w	r3, r3, #1
   1070a:	499f      	ldr	r1, [pc, #636]	; (10988 <HAL_SAI_InitProtocol+0x3d8>)
   1070c:	42aa      	cmp	r2, r5
   1070e:	bf0c      	ite	eq
   10710:	2300      	moveq	r3, #0
   10712:	f003 0301 	andne.w	r3, r3, #1
   10716:	4282      	cmp	r2, r0
   10718:	bf0c      	ite	eq
   1071a:	2300      	moveq	r3, #0
   1071c:	f003 0301 	andne.w	r3, r3, #1
   10720:	428a      	cmp	r2, r1
   10722:	bf0c      	ite	eq
   10724:	2300      	moveq	r3, #0
   10726:	f003 0301 	andne.w	r3, r3, #1
   1072a:	b11b      	cbz	r3, 10734 <HAL_SAI_InitProtocol+0x184>
   1072c:	4b97      	ldr	r3, [pc, #604]	; (1098c <HAL_SAI_InitProtocol+0x3dc>)
   1072e:	429a      	cmp	r2, r3
   10730:	f040 835d 	bne.w	10dee <HAL_SAI_InitProtocol+0x83e>
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
   10734:	6a22      	ldr	r2, [r4, #32]
   10736:	f64b 3680 	movw	r6, #48000	; 0xbb80
   1073a:	4b95      	ldr	r3, [pc, #596]	; (10990 <HAL_SAI_InitProtocol+0x3e0>)
   1073c:	f64a 4544 	movw	r5, #44100	; 0xac44
   10740:	4994      	ldr	r1, [pc, #592]	; (10994 <HAL_SAI_InitProtocol+0x3e4>)
   10742:	f245 6022 	movw	r0, #22050	; 0x5622
   10746:	429a      	cmp	r2, r3
   10748:	bf18      	it	ne
   1074a:	428a      	cmpne	r2, r1
   1074c:	f642 3111 	movw	r1, #11025	; 0x2b11
   10750:	bf14      	ite	ne
   10752:	2301      	movne	r3, #1
   10754:	2300      	moveq	r3, #0
   10756:	42b2      	cmp	r2, r6
   10758:	bf0c      	ite	eq
   1075a:	2300      	moveq	r3, #0
   1075c:	f003 0301 	andne.w	r3, r3, #1
   10760:	42aa      	cmp	r2, r5
   10762:	bf0c      	ite	eq
   10764:	2300      	moveq	r3, #0
   10766:	f003 0301 	andne.w	r3, r3, #1
   1076a:	f5b2 4ffa 	cmp.w	r2, #32000	; 0x7d00
   1076e:	bf0c      	ite	eq
   10770:	2300      	moveq	r3, #0
   10772:	f003 0301 	andne.w	r3, r3, #1
   10776:	4282      	cmp	r2, r0
   10778:	bf0c      	ite	eq
   1077a:	2300      	moveq	r3, #0
   1077c:	f003 0301 	andne.w	r3, r3, #1
   10780:	f5b2 5f7a 	cmp.w	r2, #16000	; 0x3e80
   10784:	bf0c      	ite	eq
   10786:	2300      	moveq	r3, #0
   10788:	f003 0301 	andne.w	r3, r3, #1
   1078c:	428a      	cmp	r2, r1
   1078e:	bf0c      	ite	eq
   10790:	2300      	moveq	r3, #0
   10792:	f003 0301 	andne.w	r3, r3, #1
   10796:	f5b2 5ffa 	cmp.w	r2, #8000	; 0x1f40
   1079a:	bf0c      	ite	eq
   1079c:	2300      	moveq	r3, #0
   1079e:	f003 0301 	andne.w	r3, r3, #1
   107a2:	b113      	cbz	r3, 107aa <HAL_SAI_InitProtocol+0x1fa>
   107a4:	2a00      	cmp	r2, #0
   107a6:	f040 8333 	bne.w	10e10 <HAL_SAI_InitProtocol+0x860>
  assert_param(IS_SAI_BLOCK_PROTOCOL(hsai->Init.Protocol));
   107aa:	6c63      	ldr	r3, [r4, #68]	; 0x44
   107ac:	f033 0204 	bics.w	r2, r3, #4
   107b0:	d006      	beq.n	107c0 <HAL_SAI_InitProtocol+0x210>
   107b2:	2b08      	cmp	r3, #8
   107b4:	d004      	beq.n	107c0 <HAL_SAI_InitProtocol+0x210>
   107b6:	f240 1185 	movw	r1, #389	; 0x185
   107ba:	4877      	ldr	r0, [pc, #476]	; (10998 <HAL_SAI_InitProtocol+0x3e8>)
   107bc:	f008 fe2a 	bl	19414 <assert_failed>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
   107c0:	6863      	ldr	r3, [r4, #4]
   107c2:	2b03      	cmp	r3, #3
   107c4:	f200 8166 	bhi.w	10a94 <HAL_SAI_InitProtocol+0x4e4>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
   107c8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   107ca:	f023 0220 	bic.w	r2, r3, #32
   107ce:	2a80      	cmp	r2, #128	; 0x80
   107d0:	d004      	beq.n	107dc <HAL_SAI_InitProtocol+0x22c>
   107d2:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
   107d6:	2b40      	cmp	r3, #64	; 0x40
   107d8:	f040 82e7 	bne.w	10daa <HAL_SAI_InitProtocol+0x7fa>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
   107dc:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   107de:	f433 7380 	bics.w	r3, r3, #256	; 0x100
   107e2:	f040 8151 	bne.w	10a88 <HAL_SAI_InitProtocol+0x4d8>
  assert_param(IS_SAI_BLOCK_CLOCK_STROBING(hsai->Init.ClockStrobing));
   107e6:	6d23      	ldr	r3, [r4, #80]	; 0x50
   107e8:	2b01      	cmp	r3, #1
   107ea:	d904      	bls.n	107f6 <HAL_SAI_InitProtocol+0x246>
   107ec:	f240 1189 	movw	r1, #393	; 0x189
   107f0:	4869      	ldr	r0, [pc, #420]	; (10998 <HAL_SAI_InitProtocol+0x3e8>)
   107f2:	f008 fe0f 	bl	19414 <assert_failed>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
   107f6:	68a3      	ldr	r3, [r4, #8]
   107f8:	2b05      	cmp	r3, #5
   107fa:	f200 813f 	bhi.w	10a7c <HAL_SAI_InitProtocol+0x4cc>
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
   107fe:	f7f7 fe11 	bl	8424 <HAL_GetREVID>
   10802:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
   10806:	d304      	bcc.n	10812 <HAL_SAI_InitProtocol+0x262>
    assert_param(IS_SAI_BLOCK_MCK_OUTPUT(hsai->Init.MckOutput));
   10808:	6923      	ldr	r3, [r4, #16]
   1080a:	f033 6300 	bics.w	r3, r3, #134217728	; 0x8000000
   1080e:	f040 8294 	bne.w	10d3a <HAL_SAI_InitProtocol+0x78a>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
   10812:	6963      	ldr	r3, [r4, #20]
   10814:	f433 5300 	bics.w	r3, r3, #8192	; 0x2000
   10818:	f040 812a 	bne.w	10a70 <HAL_SAI_InitProtocol+0x4c0>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
   1081c:	69a3      	ldr	r3, [r4, #24]
   1081e:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
   10822:	f040 8167 	bne.w	10af4 <HAL_SAI_InitProtocol+0x544>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
   10826:	69e3      	ldr	r3, [r4, #28]
   10828:	2b04      	cmp	r3, #4
   1082a:	f200 815d 	bhi.w	10ae8 <HAL_SAI_InitProtocol+0x538>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
   1082e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   10830:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   10834:	f040 8152 	bne.w	10adc <HAL_SAI_InitProtocol+0x52c>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
   10838:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1083a:	f423 4180 	bic.w	r1, r3, #16384	; 0x4000
   1083e:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
   10842:	f5b1 4f20 	cmp.w	r1, #40960	; 0xa000
   10846:	bf18      	it	ne
   10848:	2a00      	cmpne	r2, #0
   1084a:	d003      	beq.n	10854 <HAL_SAI_InitProtocol+0x2a4>
   1084c:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
   10850:	f040 82a3 	bne.w	10d9a <HAL_SAI_InitProtocol+0x7ea>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
   10854:	6b63      	ldr	r3, [r4, #52]	; 0x34
   10856:	f033 0310 	bics.w	r3, r3, #16
   1085a:	f040 8139 	bne.w	10ad0 <HAL_SAI_InitProtocol+0x520>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
   1085e:	68e3      	ldr	r3, [r4, #12]
   10860:	2b02      	cmp	r3, #2
   10862:	f200 812f 	bhi.w	10ac4 <HAL_SAI_InitProtocol+0x514>
  assert_param(IS_SAI_BLOCK_MCK_OVERSAMPLING(hsai->Init.MckOverSampling));
   10866:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   10868:	f033 6380 	bics.w	r3, r3, #67108864	; 0x4000000
   1086c:	f040 8124 	bne.w	10ab8 <HAL_SAI_InitProtocol+0x508>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
   10870:	6d63      	ldr	r3, [r4, #84]	; 0x54
   10872:	3b08      	subs	r3, #8
   10874:	2bf8      	cmp	r3, #248	; 0xf8
   10876:	f200 8119 	bhi.w	10aac <HAL_SAI_InitProtocol+0x4fc>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
   1087a:	6da3      	ldr	r3, [r4, #88]	; 0x58
   1087c:	3b01      	subs	r3, #1
   1087e:	2b7f      	cmp	r3, #127	; 0x7f
   10880:	f200 810e 	bhi.w	10aa0 <HAL_SAI_InitProtocol+0x4f0>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
   10884:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   10886:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
   1088a:	f040 80eb 	bne.w	10a64 <HAL_SAI_InitProtocol+0x4b4>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
   1088e:	6e23      	ldr	r3, [r4, #96]	; 0x60
   10890:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
   10894:	f040 80e0 	bne.w	10a58 <HAL_SAI_InitProtocol+0x4a8>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
   10898:	6e63      	ldr	r3, [r4, #100]	; 0x64
   1089a:	f433 2380 	bics.w	r3, r3, #262144	; 0x40000
   1089e:	f040 80d5 	bne.w	10a4c <HAL_SAI_InitProtocol+0x49c>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
   108a2:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   108a4:	2b18      	cmp	r3, #24
   108a6:	f200 80cb 	bhi.w	10a40 <HAL_SAI_InitProtocol+0x490>
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
   108aa:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   108ac:	f033 0240 	bics.w	r2, r3, #64	; 0x40
   108b0:	d006      	beq.n	108c0 <HAL_SAI_InitProtocol+0x310>
   108b2:	2b80      	cmp	r3, #128	; 0x80
   108b4:	d004      	beq.n	108c0 <HAL_SAI_InitProtocol+0x310>
   108b6:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
   108ba:	4837      	ldr	r0, [pc, #220]	; (10998 <HAL_SAI_InitProtocol+0x3e8>)
   108bc:	f008 fdaa 	bl	19414 <assert_failed>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
   108c0:	6f23      	ldr	r3, [r4, #112]	; 0x70
   108c2:	3b01      	subs	r3, #1
   108c4:	2b0f      	cmp	r3, #15
   108c6:	f200 80b5 	bhi.w	10a34 <HAL_SAI_InitProtocol+0x484>
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
   108ca:	6f63      	ldr	r3, [r4, #116]	; 0x74
   108cc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   108d0:	f080 80aa 	bcs.w	10a28 <HAL_SAI_InitProtocol+0x478>
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
   108d4:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   108d8:	2b01      	cmp	r3, #1
   108da:	d906      	bls.n	108ea <HAL_SAI_InitProtocol+0x33a>
   108dc:	f240 11ab 	movw	r1, #427	; 0x1ab
   108e0:	482d      	ldr	r0, [pc, #180]	; (10998 <HAL_SAI_InitProtocol+0x3e8>)
   108e2:	f008 fd97 	bl	19414 <assert_failed>
   108e6:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
  if (hsai->Init.PdmInit.Activation == ENABLE)
   108ea:	2b01      	cmp	r3, #1
   108ec:	f43f ae70 	beq.w	105d0 <HAL_SAI_InitProtocol+0x20>
   108f0:	6823      	ldr	r3, [r4, #0]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
   108f2:	4a21      	ldr	r2, [pc, #132]	; (10978 <HAL_SAI_InitProtocol+0x3c8>)
   108f4:	4293      	cmp	r3, r2
   108f6:	d053      	beq.n	109a0 <HAL_SAI_InitProtocol+0x3f0>
   108f8:	3220      	adds	r2, #32
   108fa:	4293      	cmp	r3, r2
   108fc:	d050      	beq.n	109a0 <HAL_SAI_InitProtocol+0x3f0>
  else if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
   108fe:	f502 7278 	add.w	r2, r2, #992	; 0x3e0
   10902:	4293      	cmp	r3, r2
   10904:	f000 8136 	beq.w	10b74 <HAL_SAI_InitProtocol+0x5c4>
   10908:	3220      	adds	r2, #32
   1090a:	4293      	cmp	r3, r2
   1090c:	f000 8132 	beq.w	10b74 <HAL_SAI_InitProtocol+0x5c4>
  else if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
   10910:	f502 7278 	add.w	r2, r2, #992	; 0x3e0
   10914:	4293      	cmp	r3, r2
   10916:	f000 8246 	beq.w	10da6 <HAL_SAI_InitProtocol+0x7f6>
   1091a:	3220      	adds	r2, #32
   1091c:	4293      	cmp	r3, r2
   1091e:	f000 8242 	beq.w	10da6 <HAL_SAI_InitProtocol+0x7f6>
  else if ((hsai->Instance == SAI4_Block_A) || (hsai->Instance == SAI4_Block_B))
   10922:	4a19      	ldr	r2, [pc, #100]	; (10988 <HAL_SAI_InitProtocol+0x3d8>)
   10924:	4293      	cmp	r3, r2
   10926:	d003      	beq.n	10930 <HAL_SAI_InitProtocol+0x380>
   10928:	3220      	adds	r2, #32
   1092a:	4293      	cmp	r3, r2
   1092c:	f47f ae74 	bne.w	10618 <HAL_SAI_InitProtocol+0x68>
    SaiBaseAddress = SAI4;
   10930:	4d1a      	ldr	r5, [pc, #104]	; (1099c <HAL_SAI_InitProtocol+0x3ec>)
   10932:	e036      	b.n	109a2 <HAL_SAI_InitProtocol+0x3f2>
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10934:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
   10936:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10938:	64a2      	str	r2, [r4, #72]	; 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
   1093a:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1093c:	66e2      	str	r2, [r4, #108]	; 0x6c
   1093e:	e6cb      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 16U * nbslot;
   10940:	0136      	lsls	r6, r6, #4
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10942:	2180      	movs	r1, #128	; 0x80
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   10944:	2240      	movs	r2, #64	; 0x40
      hsai->FrameInit.FrameLength = 16U * nbslot;
   10946:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10948:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   1094a:	66e2      	str	r2, [r4, #108]	; 0x6c
   1094c:	e6c4      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 32U * nbslot;
   1094e:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_24;
   10950:	21c0      	movs	r1, #192	; 0xc0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10952:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
   10954:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_24;
   10956:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10958:	66e2      	str	r2, [r4, #108]	; 0x6c
   1095a:	e6bd      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
   1095c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   10960:	e9c4 5318 	strd	r5, r3, [r4, #96]	; 0x60
  switch (datasize)
   10964:	2f03      	cmp	r7, #3
   10966:	f63f ae57 	bhi.w	10618 <HAL_SAI_InitProtocol+0x68>
   1096a:	e8df f017 	tbh	[pc, r7, lsl #1]
   1096e:	00f4      	.short	0x00f4
   10970:	00d300e4 	.word	0x00d300e4
   10974:	00c9      	.short	0x00c9
   10976:	bf00      	nop
   10978:	40015804 	.word	0x40015804
   1097c:	40015824 	.word	0x40015824
   10980:	40015c04 	.word	0x40015c04
   10984:	40016004 	.word	0x40016004
   10988:	58005404 	.word	0x58005404
   1098c:	58005424 	.word	0x58005424
   10990:	0002ee00 	.word	0x0002ee00
   10994:	00017700 	.word	0x00017700
   10998:	0002fedc 	.word	0x0002fedc
   1099c:	58005400 	.word	0x58005400
    SaiBaseAddress = SAI1;
   109a0:	4d75      	ldr	r5, [pc, #468]	; (10b78 <HAL_SAI_InitProtocol+0x5c8>)
  if (hsai->State == HAL_SAI_STATE_RESET)
   109a2:	f894 2091 	ldrb.w	r2, [r4, #145]	; 0x91
   109a6:	f002 01ff 	and.w	r1, r2, #255	; 0xff
   109aa:	2a00      	cmp	r2, #0
   109ac:	f000 81be 	beq.w	10d2c <HAL_SAI_InitProtocol+0x77c>
  *              the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   109b0:	4a72      	ldr	r2, [pc, #456]	; (10b7c <HAL_SAI_InitProtocol+0x5cc>)
   109b2:	4873      	ldr	r0, [pc, #460]	; (10b80 <HAL_SAI_InitProtocol+0x5d0>)
   109b4:	6812      	ldr	r2, [r2, #0]
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
   109b6:	6819      	ldr	r1, [r3, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   109b8:	fba0 0202 	umull	r0, r2, r0, r2
  __HAL_SAI_DISABLE(hsai);
   109bc:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   109c0:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
   109c2:	6019      	str	r1, [r3, #0]

  do
  {
    /* Check for the Timeout */
    if (count == 0U)
   109c4:	0093      	lsls	r3, r2, #2
   109c6:	b33a      	cbz	r2, 10a18 <HAL_SAI_InitProtocol+0x468>
      status = HAL_TIMEOUT;
      break;
    }
    count--;
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   109c8:	6821      	ldr	r1, [r4, #0]
    count--;
   109ca:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   109cc:	680a      	ldr	r2, [r1, #0]
   109ce:	03d7      	lsls	r7, r2, #15
   109d0:	d504      	bpl.n	109dc <HAL_SAI_InitProtocol+0x42c>
    if (count == 0U)
   109d2:	b30b      	cbz	r3, 10a18 <HAL_SAI_InitProtocol+0x468>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   109d4:	680a      	ldr	r2, [r1, #0]
    count--;
   109d6:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   109d8:	03d2      	lsls	r2, r2, #15
   109da:	d4fa      	bmi.n	109d2 <HAL_SAI_InitProtocol+0x422>
  switch (hsai->Init.SynchroExt)
   109dc:	68e3      	ldr	r3, [r4, #12]
  hsai->State = HAL_SAI_STATE_BUSY;
   109de:	2202      	movs	r2, #2
  switch (hsai->Init.SynchroExt)
   109e0:	2b01      	cmp	r3, #1
  hsai->State = HAL_SAI_STATE_BUSY;
   109e2:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
  switch (hsai->Init.SynchroExt)
   109e6:	f000 80c0 	beq.w	10b6a <HAL_SAI_InitProtocol+0x5ba>
   109ea:	4293      	cmp	r3, r2
   109ec:	bf15      	itete	ne
   109ee:	4610      	movne	r0, r2
   109f0:	2123      	moveq	r1, #35	; 0x23
   109f2:	2103      	movne	r1, #3
   109f4:	2022      	moveq	r0, #34	; 0x22
   109f6:	bf0b      	itete	eq
   109f8:	2621      	moveq	r6, #33	; 0x21
   109fa:	2601      	movne	r6, #1
   109fc:	2220      	moveq	r2, #32
   109fe:	2200      	movne	r2, #0
  switch (hsai->Init.Synchro)
   10a00:	68a3      	ldr	r3, [r4, #8]
   10a02:	3b01      	subs	r3, #1
   10a04:	2b04      	cmp	r3, #4
   10a06:	f200 818b 	bhi.w	10d20 <HAL_SAI_InitProtocol+0x770>
   10a0a:	e8df f013 	tbh	[pc, r3, lsl #1]
   10a0e:	0186      	.short	0x0186
   10a10:	018b00c0 	.word	0x018b00c0
   10a14:	01da00bf 	.word	0x01da00bf
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   10a18:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    return HAL_ERROR;
   10a1c:	2001      	movs	r0, #1
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   10a1e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   10a22:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
}
   10a26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
   10a28:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
   10a2c:	4855      	ldr	r0, [pc, #340]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a2e:	f008 fcf1 	bl	19414 <assert_failed>
   10a32:	e74f      	b.n	108d4 <HAL_SAI_InitProtocol+0x324>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
   10a34:	f240 11a7 	movw	r1, #423	; 0x1a7
   10a38:	4852      	ldr	r0, [pc, #328]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a3a:	f008 fceb 	bl	19414 <assert_failed>
   10a3e:	e744      	b.n	108ca <HAL_SAI_InitProtocol+0x31a>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
   10a40:	f240 11a5 	movw	r1, #421	; 0x1a5
   10a44:	484f      	ldr	r0, [pc, #316]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a46:	f008 fce5 	bl	19414 <assert_failed>
   10a4a:	e72e      	b.n	108aa <HAL_SAI_InitProtocol+0x2fa>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
   10a4c:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
   10a50:	484c      	ldr	r0, [pc, #304]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a52:	f008 fcdf 	bl	19414 <assert_failed>
   10a56:	e724      	b.n	108a2 <HAL_SAI_InitProtocol+0x2f2>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
   10a58:	f240 11a1 	movw	r1, #417	; 0x1a1
   10a5c:	4849      	ldr	r0, [pc, #292]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a5e:	f008 fcd9 	bl	19414 <assert_failed>
   10a62:	e719      	b.n	10898 <HAL_SAI_InitProtocol+0x2e8>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
   10a64:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
   10a68:	4846      	ldr	r0, [pc, #280]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a6a:	f008 fcd3 	bl	19414 <assert_failed>
   10a6e:	e70e      	b.n	1088e <HAL_SAI_InitProtocol+0x2de>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
   10a70:	f44f 71ca 	mov.w	r1, #404	; 0x194
   10a74:	4843      	ldr	r0, [pc, #268]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a76:	f008 fccd 	bl	19414 <assert_failed>
   10a7a:	e6cf      	b.n	1081c <HAL_SAI_InitProtocol+0x26c>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
   10a7c:	f44f 71c5 	mov.w	r1, #394	; 0x18a
   10a80:	4840      	ldr	r0, [pc, #256]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a82:	f008 fcc7 	bl	19414 <assert_failed>
   10a86:	e6ba      	b.n	107fe <HAL_SAI_InitProtocol+0x24e>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
   10a88:	f44f 71c4 	mov.w	r1, #392	; 0x188
   10a8c:	483d      	ldr	r0, [pc, #244]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a8e:	f008 fcc1 	bl	19414 <assert_failed>
   10a92:	e6a8      	b.n	107e6 <HAL_SAI_InitProtocol+0x236>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
   10a94:	f44f 71c3 	mov.w	r1, #390	; 0x186
   10a98:	483a      	ldr	r0, [pc, #232]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a9a:	f008 fcbb 	bl	19414 <assert_failed>
   10a9e:	e693      	b.n	107c8 <HAL_SAI_InitProtocol+0x218>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
   10aa0:	f240 119f 	movw	r1, #415	; 0x19f
   10aa4:	4837      	ldr	r0, [pc, #220]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10aa6:	f008 fcb5 	bl	19414 <assert_failed>
   10aaa:	e6eb      	b.n	10884 <HAL_SAI_InitProtocol+0x2d4>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
   10aac:	f44f 71cf 	mov.w	r1, #414	; 0x19e
   10ab0:	4834      	ldr	r0, [pc, #208]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10ab2:	f008 fcaf 	bl	19414 <assert_failed>
   10ab6:	e6e0      	b.n	1087a <HAL_SAI_InitProtocol+0x2ca>
  assert_param(IS_SAI_BLOCK_MCK_OVERSAMPLING(hsai->Init.MckOverSampling));
   10ab8:	f240 119b 	movw	r1, #411	; 0x19b
   10abc:	4831      	ldr	r0, [pc, #196]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10abe:	f008 fca9 	bl	19414 <assert_failed>
   10ac2:	e6d5      	b.n	10870 <HAL_SAI_InitProtocol+0x2c0>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
   10ac4:	f44f 71cd 	mov.w	r1, #410	; 0x19a
   10ac8:	482e      	ldr	r0, [pc, #184]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10aca:	f008 fca3 	bl	19414 <assert_failed>
   10ace:	e6ca      	b.n	10866 <HAL_SAI_InitProtocol+0x2b6>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
   10ad0:	f240 1199 	movw	r1, #409	; 0x199
   10ad4:	482b      	ldr	r0, [pc, #172]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10ad6:	f008 fc9d 	bl	19414 <assert_failed>
   10ada:	e6c0      	b.n	1085e <HAL_SAI_InitProtocol+0x2ae>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
   10adc:	f240 1197 	movw	r1, #407	; 0x197
   10ae0:	4828      	ldr	r0, [pc, #160]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10ae2:	f008 fc97 	bl	19414 <assert_failed>
   10ae6:	e6a7      	b.n	10838 <HAL_SAI_InitProtocol+0x288>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
   10ae8:	f44f 71cb 	mov.w	r1, #406	; 0x196
   10aec:	4825      	ldr	r0, [pc, #148]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10aee:	f008 fc91 	bl	19414 <assert_failed>
   10af2:	e69c      	b.n	1082e <HAL_SAI_InitProtocol+0x27e>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
   10af4:	f240 1195 	movw	r1, #405	; 0x195
   10af8:	4822      	ldr	r0, [pc, #136]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10afa:	f008 fc8b 	bl	19414 <assert_failed>
   10afe:	e692      	b.n	10826 <HAL_SAI_InitProtocol+0x276>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b00:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_32;
   10b02:	21e0      	movs	r1, #224	; 0xe0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10b04:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b06:	01b3      	lsls	r3, r6, #6
      hsai->Init.DataSize = SAI_DATASIZE_32;
   10b08:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b0a:	0176      	lsls	r6, r6, #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10b0c:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b0e:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
   10b12:	e5e1      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b14:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_24;
   10b16:	21c0      	movs	r1, #192	; 0xc0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10b18:	2280      	movs	r2, #128	; 0x80
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   10b1a:	2d02      	cmp	r5, #2
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b1c:	ea4f 1386 	mov.w	r3, r6, lsl #6
      hsai->Init.DataSize = SAI_DATASIZE_24;
   10b20:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b22:	ea4f 1646 	mov.w	r6, r6, lsl #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10b26:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b28:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   10b2c:	f47f add4 	bne.w	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->SlotInit.FirstBitOffset = 8;
   10b30:	2308      	movs	r3, #8
   10b32:	66a3      	str	r3, [r4, #104]	; 0x68
   10b34:	e5d0      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b36:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10b38:	2380      	movs	r3, #128	; 0x80
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   10b3a:	2d02      	cmp	r5, #2
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b3c:	ea4f 1286 	mov.w	r2, r6, lsl #6
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10b40:	64a3      	str	r3, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b42:	ea4f 1646 	mov.w	r6, r6, lsl #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10b46:	66e3      	str	r3, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b48:	e9c4 2615 	strd	r2, r6, [r4, #84]	; 0x54
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   10b4c:	f47f adc4 	bne.w	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->SlotInit.FirstBitOffset = 16;
   10b50:	2310      	movs	r3, #16
   10b52:	66a3      	str	r3, [r4, #104]	; 0x68
   10b54:	e5c0      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
   10b56:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10b58:	2180      	movs	r1, #128	; 0x80
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   10b5a:	2240      	movs	r2, #64	; 0x40
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
   10b5c:	0173      	lsls	r3, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10b5e:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
   10b60:	0136      	lsls	r6, r6, #4
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   10b62:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
   10b64:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
   10b68:	e5b6      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
  switch (hsai->Init.SynchroExt)
   10b6a:	2113      	movs	r1, #19
   10b6c:	2012      	movs	r0, #18
   10b6e:	2611      	movs	r6, #17
      tmpregisterGCR = SAI_GCR_SYNCOUT_0;
   10b70:	2210      	movs	r2, #16
   10b72:	e745      	b.n	10a00 <HAL_SAI_InitProtocol+0x450>
    SaiBaseAddress = SAI2;
   10b74:	4d04      	ldr	r5, [pc, #16]	; (10b88 <HAL_SAI_InitProtocol+0x5d8>)
   10b76:	e714      	b.n	109a2 <HAL_SAI_InitProtocol+0x3f2>
   10b78:	40015800 	.word	0x40015800
   10b7c:	0006280c 	.word	0x0006280c
   10b80:	95cbec1b 	.word	0x95cbec1b
   10b84:	0002fedc 	.word	0x0002fedc
   10b88:	40015c00 	.word	0x40015c00
      tmpregisterGCR |= SAI_GCR_SYNCIN_1;
   10b8c:	4602      	mov	r2, r0
      syncen_bits = SAI_xCR1_SYNCEN_1;
   10b8e:	f44f 6600 	mov.w	r6, #2048	; 0x800
  SaiBaseAddress->GCR = tmpregisterGCR;
   10b92:	602a      	str	r2, [r5, #0]
  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
   10b94:	6a23      	ldr	r3, [r4, #32]
   10b96:	2b00      	cmp	r3, #0
   10b98:	d045      	beq.n	10c26 <HAL_SAI_InitProtocol+0x676>
    if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
   10b9a:	6823      	ldr	r3, [r4, #0]
   10b9c:	4a9f      	ldr	r2, [pc, #636]	; (10e1c <HAL_SAI_InitProtocol+0x86c>)
   10b9e:	4293      	cmp	r3, r2
   10ba0:	f000 811f 	beq.w	10de2 <HAL_SAI_InitProtocol+0x832>
   10ba4:	489e      	ldr	r0, [pc, #632]	; (10e20 <HAL_SAI_InitProtocol+0x870>)
   10ba6:	1a18      	subs	r0, r3, r0
   10ba8:	fab0 f080 	clz	r0, r0
   10bac:	0940      	lsrs	r0, r0, #5
   10bae:	2800      	cmp	r0, #0
   10bb0:	f040 8117 	bne.w	10de2 <HAL_SAI_InitProtocol+0x832>
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
   10bb4:	4a9b      	ldr	r2, [pc, #620]	; (10e24 <HAL_SAI_InitProtocol+0x874>)
   10bb6:	4293      	cmp	r3, r2
   10bb8:	f000 810d 	beq.w	10dd6 <HAL_SAI_InitProtocol+0x826>
   10bbc:	3220      	adds	r2, #32
   10bbe:	4293      	cmp	r3, r2
   10bc0:	f000 8109 	beq.w	10dd6 <HAL_SAI_InitProtocol+0x826>
    if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
   10bc4:	4a98      	ldr	r2, [pc, #608]	; (10e28 <HAL_SAI_InitProtocol+0x878>)
   10bc6:	4293      	cmp	r3, r2
   10bc8:	f000 80ff 	beq.w	10dca <HAL_SAI_InitProtocol+0x81a>
   10bcc:	3220      	adds	r2, #32
   10bce:	4293      	cmp	r3, r2
   10bd0:	f000 80fb 	beq.w	10dca <HAL_SAI_InitProtocol+0x81a>
    if (hsai->Instance == SAI4_Block_A)
   10bd4:	4a95      	ldr	r2, [pc, #596]	; (10e2c <HAL_SAI_InitProtocol+0x87c>)
   10bd6:	4293      	cmp	r3, r2
   10bd8:	f000 8114 	beq.w	10e04 <HAL_SAI_InitProtocol+0x854>
    if (hsai->Instance == SAI4_Block_B)
   10bdc:	4a94      	ldr	r2, [pc, #592]	; (10e30 <HAL_SAI_InitProtocol+0x880>)
   10bde:	4293      	cmp	r3, r2
   10be0:	f000 810b 	beq.w	10dfa <HAL_SAI_InitProtocol+0x84a>
    if (hsai->Init.NoDivider == SAI_MASTERDIVIDER_DISABLE)
   10be4:	69a2      	ldr	r2, [r4, #24]
   10be6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   10bea:	6a23      	ldr	r3, [r4, #32]
   10bec:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
   10bf0:	ea4f 0040 	mov.w	r0, r0, lsl #1
   10bf4:	f000 80df 	beq.w	10db6 <HAL_SAI_InitProtocol+0x806>
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
   10bf8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
   10bfa:	021b      	lsls	r3, r3, #8
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
   10bfc:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
   10c00:	bf14      	ite	ne
   10c02:	2201      	movne	r2, #1
   10c04:	2202      	moveq	r2, #2
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
   10c06:	fb02 f303 	mul.w	r3, r2, r3
   10c0a:	fbb0 f3f3 	udiv	r3, r0, r3
    hsai->Init.Mckdiv = tmpval / 10U;
   10c0e:	4a89      	ldr	r2, [pc, #548]	; (10e34 <HAL_SAI_InitProtocol+0x884>)
   10c10:	fba2 1203 	umull	r1, r2, r2, r3
   10c14:	08d2      	lsrs	r2, r2, #3
    if ((tmpval % 10U) > 8U)
   10c16:	eb02 0182 	add.w	r1, r2, r2, lsl #2
   10c1a:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
   10c1e:	2b09      	cmp	r3, #9
      hsai->Init.Mckdiv += 1U;
   10c20:	bf08      	it	eq
   10c22:	3201      	addeq	r2, #1
   10c24:	6262      	str	r2, [r4, #36]	; 0x24
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10c26:	6863      	ldr	r3, [r4, #4]
   10c28:	6d22      	ldr	r2, [r4, #80]	; 0x50
   10c2a:	f033 0702 	bics.w	r7, r3, #2
   10c2e:	f040 80ae 	bne.w	10d8e <HAL_SAI_InitProtocol+0x7de>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
   10c32:	2a01      	cmp	r2, #1
   10c34:	bf18      	it	ne
   10c36:	f44f 7700 	movne.w	r7, #512	; 0x200
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
   10c3a:	f7f7 fbf3 	bl	8424 <HAL_GetREVID>
   10c3e:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
   10c42:	6822      	ldr	r2, [r4, #0]
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
   10c44:	f0c0 8092 	bcc.w	10d6c <HAL_SAI_InitProtocol+0x7bc>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
   10c48:	6811      	ldr	r1, [r2, #0]
   10c4a:	4b7b      	ldr	r3, [pc, #492]	; (10e38 <HAL_SAI_InitProtocol+0x888>)
   10c4c:	400b      	ands	r3, r1
   10c4e:	6013      	str	r3, [r2, #0]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   10c50:	6863      	ldr	r3, [r4, #4]
   10c52:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
   10c54:	e9d4 1211 	ldrd	r1, r2, [r4, #68]	; 0x44
   10c58:	430b      	orrs	r3, r1
   10c5a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   10c5c:	4313      	orrs	r3, r2
   10c5e:	6962      	ldr	r2, [r4, #20]
   10c60:	4303      	orrs	r3, r0
   10c62:	69a0      	ldr	r0, [r4, #24]
   10c64:	430b      	orrs	r3, r1
   10c66:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   10c68:	4313      	orrs	r3, r2
   10c6a:	6922      	ldr	r2, [r4, #16]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   10c6c:	4303      	orrs	r3, r0
   10c6e:	6820      	ldr	r0, [r4, #0]
   10c70:	430b      	orrs	r3, r1
   10c72:	6801      	ldr	r1, [r0, #0]
   10c74:	4313      	orrs	r3, r2
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
   10c76:	6a62      	ldr	r2, [r4, #36]	; 0x24
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   10c78:	430b      	orrs	r3, r1
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
   10c7a:	f24f 0120 	movw	r1, #61472	; 0xf020
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   10c7e:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
   10c82:	4333      	orrs	r3, r6
   10c84:	433b      	orrs	r3, r7
   10c86:	6003      	str	r3, [r0, #0]
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   10c88:	6826      	ldr	r6, [r4, #0]
   10c8a:	4b6c      	ldr	r3, [pc, #432]	; (10e3c <HAL_SAI_InitProtocol+0x88c>)
   10c8c:	6872      	ldr	r2, [r6, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
   10c8e:	486c      	ldr	r0, [pc, #432]	; (10e40 <HAL_SAI_InitProtocol+0x890>)
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   10c90:	4013      	ands	r3, r2
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
   10c92:	4a62      	ldr	r2, [pc, #392]	; (10e1c <HAL_SAI_InitProtocol+0x86c>)
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   10c94:	6073      	str	r3, [r6, #4]
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
   10c96:	69e3      	ldr	r3, [r4, #28]
   10c98:	e9d4 760c 	ldrd	r7, r6, [r4, #48]	; 0x30
   10c9c:	433b      	orrs	r3, r7
   10c9e:	6827      	ldr	r7, [r4, #0]
   10ca0:	4333      	orrs	r3, r6
   10ca2:	687e      	ldr	r6, [r7, #4]
   10ca4:	4333      	orrs	r3, r6
   10ca6:	607b      	str	r3, [r7, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
   10ca8:	6823      	ldr	r3, [r4, #0]
   10caa:	689e      	ldr	r6, [r3, #8]
   10cac:	4030      	ands	r0, r6
   10cae:	6098      	str	r0, [r3, #8]
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
   10cb0:	6e63      	ldr	r3, [r4, #100]	; 0x64
   10cb2:	6827      	ldr	r7, [r4, #0]
   10cb4:	e9d4 6017 	ldrd	r6, r0, [r4, #92]	; 0x5c
   10cb8:	4333      	orrs	r3, r6
   10cba:	6d66      	ldr	r6, [r4, #84]	; 0x54
   10cbc:	4303      	orrs	r3, r0
   10cbe:	68b8      	ldr	r0, [r7, #8]
   10cc0:	3e01      	subs	r6, #1
   10cc2:	4303      	orrs	r3, r0
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
   10cc4:	6da0      	ldr	r0, [r4, #88]	; 0x58
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
   10cc6:	4333      	orrs	r3, r6
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
   10cc8:	3801      	subs	r0, #1
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
   10cca:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   10cce:	60bb      	str	r3, [r7, #8]
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
   10cd0:	6820      	ldr	r0, [r4, #0]
   10cd2:	68c3      	ldr	r3, [r0, #12]
   10cd4:	400b      	ands	r3, r1
   10cd6:	60c3      	str	r3, [r0, #12]
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   10cd8:	6820      	ldr	r0, [r4, #0]
   10cda:	e9d4 361a 	ldrd	r3, r6, [r4, #104]	; 0x68
   10cde:	68c1      	ldr	r1, [r0, #12]
   10ce0:	4333      	orrs	r3, r6
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
   10ce2:	6f66      	ldr	r6, [r4, #116]	; 0x74
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   10ce4:	430b      	orrs	r3, r1
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
   10ce6:	6f21      	ldr	r1, [r4, #112]	; 0x70
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   10ce8:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
   10cec:	3901      	subs	r1, #1
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   10cee:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   10cf2:	60c3      	str	r3, [r0, #12]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
   10cf4:	6823      	ldr	r3, [r4, #0]
   10cf6:	4293      	cmp	r3, r2
   10cf8:	d025      	beq.n	10d46 <HAL_SAI_InitProtocol+0x796>
   10cfa:	f102 52c0 	add.w	r2, r2, #402653184	; 0x18000000
   10cfe:	f5a2 3282 	sub.w	r2, r2, #66560	; 0x10400
   10d02:	4293      	cmp	r3, r2
   10d04:	d01f      	beq.n	10d46 <HAL_SAI_InitProtocol+0x796>
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   10d06:	2300      	movs	r3, #0
  hsai->State = HAL_SAI_STATE_READY;
   10d08:	2201      	movs	r2, #1
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   10d0a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
  return HAL_OK;
   10d0e:	4618      	mov	r0, r3
  __HAL_UNLOCK(hsai);
   10d10:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
  hsai->State = HAL_SAI_STATE_READY;
   10d14:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
}
   10d18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      syncen_bits = SAI_xCR1_SYNCEN_0;
   10d1a:	f44f 6680 	mov.w	r6, #1024	; 0x400
   10d1e:	e738      	b.n	10b92 <HAL_SAI_InitProtocol+0x5e2>
      syncen_bits = 0;
   10d20:	2600      	movs	r6, #0
   10d22:	e736      	b.n	10b92 <HAL_SAI_InitProtocol+0x5e2>
      tmpregisterGCR |= SAI_GCR_SYNCIN_0;
   10d24:	4632      	mov	r2, r6
      syncen_bits = SAI_xCR1_SYNCEN_1;
   10d26:	f44f 6600 	mov.w	r6, #2048	; 0x800
   10d2a:	e732      	b.n	10b92 <HAL_SAI_InitProtocol+0x5e2>
    hsai->Lock = HAL_UNLOCKED;
   10d2c:	f884 1090 	strb.w	r1, [r4, #144]	; 0x90
    HAL_SAI_MspInit(hsai);
   10d30:	4620      	mov	r0, r4
   10d32:	f009 f8d9 	bl	19ee8 <HAL_SAI_MspInit>
   10d36:	6823      	ldr	r3, [r4, #0]
   10d38:	e63a      	b.n	109b0 <HAL_SAI_InitProtocol+0x400>
    assert_param(IS_SAI_BLOCK_MCK_OUTPUT(hsai->Init.MckOutput));
   10d3a:	f240 118f 	movw	r1, #399	; 0x18f
   10d3e:	4841      	ldr	r0, [pc, #260]	; (10e44 <HAL_SAI_InitProtocol+0x894>)
   10d40:	f008 fb68 	bl	19414 <assert_failed>
   10d44:	e565      	b.n	10812 <HAL_SAI_InitProtocol+0x262>
    SaiBaseAddress->PDMCR &= ~(SAI_PDMCR_PDMEN);
   10d46:	6c6b      	ldr	r3, [r5, #68]	; 0x44
   10d48:	f023 0301 	bic.w	r3, r3, #1
   10d4c:	646b      	str	r3, [r5, #68]	; 0x44
    if (hsai->Init.PdmInit.Activation == ENABLE)
   10d4e:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   10d52:	2b01      	cmp	r3, #1
   10d54:	d1d7      	bne.n	10d06 <HAL_SAI_InitProtocol+0x756>
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
   10d56:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
                               ((hsai->Init.PdmInit.MicPairsNbr - 1U) << SAI_PDMCR_MICNBR_Pos));
   10d5a:	3a01      	subs	r2, #1
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
   10d5c:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
   10d60:	646b      	str	r3, [r5, #68]	; 0x44
      SaiBaseAddress->PDMCR |= SAI_PDMCR_PDMEN;
   10d62:	6c6b      	ldr	r3, [r5, #68]	; 0x44
   10d64:	f043 0301 	orr.w	r3, r3, #1
   10d68:	646b      	str	r3, [r5, #68]	; 0x44
   10d6a:	e7cc      	b.n	10d06 <HAL_SAI_InitProtocol+0x756>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
   10d6c:	6811      	ldr	r1, [r2, #0]
   10d6e:	4b36      	ldr	r3, [pc, #216]	; (10e48 <HAL_SAI_InitProtocol+0x898>)
   10d70:	400b      	ands	r3, r1
   10d72:	6013      	str	r3, [r2, #0]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   10d74:	6863      	ldr	r3, [r4, #4]
   10d76:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
   10d78:	e9d4 2011 	ldrd	r2, r0, [r4, #68]	; 0x44
   10d7c:	4313      	orrs	r3, r2
   10d7e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   10d80:	4303      	orrs	r3, r0
   10d82:	6960      	ldr	r0, [r4, #20]
   10d84:	430b      	orrs	r3, r1
   10d86:	69a1      	ldr	r1, [r4, #24]
   10d88:	4313      	orrs	r3, r2
   10d8a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   10d8c:	e76e      	b.n	10c6c <HAL_SAI_InitProtocol+0x6bc>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
   10d8e:	2a01      	cmp	r2, #1
   10d90:	bf14      	ite	ne
   10d92:	2700      	movne	r7, #0
   10d94:	f44f 7700 	moveq.w	r7, #512	; 0x200
   10d98:	e74f      	b.n	10c3a <HAL_SAI_InitProtocol+0x68a>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
   10d9a:	f44f 71cc 	mov.w	r1, #408	; 0x198
   10d9e:	4829      	ldr	r0, [pc, #164]	; (10e44 <HAL_SAI_InitProtocol+0x894>)
   10da0:	f008 fb38 	bl	19414 <assert_failed>
   10da4:	e556      	b.n	10854 <HAL_SAI_InitProtocol+0x2a4>
    SaiBaseAddress = SAI3;
   10da6:	4d29      	ldr	r5, [pc, #164]	; (10e4c <HAL_SAI_InitProtocol+0x89c>)
   10da8:	e5fb      	b.n	109a2 <HAL_SAI_InitProtocol+0x3f2>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
   10daa:	f240 1187 	movw	r1, #391	; 0x187
   10dae:	4825      	ldr	r0, [pc, #148]	; (10e44 <HAL_SAI_InitProtocol+0x894>)
   10db0:	f008 fb30 	bl	19414 <assert_failed>
   10db4:	e512      	b.n	107dc <HAL_SAI_InitProtocol+0x22c>
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * hsai->FrameInit.FrameLength);
   10db6:	6d62      	ldr	r2, [r4, #84]	; 0x54
   10db8:	fb02 f303 	mul.w	r3, r2, r3
   10dbc:	fbb0 f3f3 	udiv	r3, r0, r3
   10dc0:	e725      	b.n	10c0e <HAL_SAI_InitProtocol+0x65e>
      tmpregisterGCR |= (SAI_GCR_SYNCIN_1 | SAI_GCR_SYNCIN_0);
   10dc2:	460a      	mov	r2, r1
      syncen_bits = SAI_xCR1_SYNCEN_1;
   10dc4:	f44f 6600 	mov.w	r6, #2048	; 0x800
   10dc8:	e6e3      	b.n	10b92 <HAL_SAI_InitProtocol+0x5e2>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI3);
   10dca:	f44f 7000 	mov.w	r0, #512	; 0x200
   10dce:	f7ff fa59 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   10dd2:	6823      	ldr	r3, [r4, #0]
   10dd4:	e6fe      	b.n	10bd4 <HAL_SAI_InitProtocol+0x624>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
   10dd6:	f44f 7000 	mov.w	r0, #512	; 0x200
   10dda:	f7ff fa53 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   10dde:	6823      	ldr	r3, [r4, #0]
   10de0:	e6f0      	b.n	10bc4 <HAL_SAI_InitProtocol+0x614>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
   10de2:	f44f 7080 	mov.w	r0, #256	; 0x100
   10de6:	f7ff fa4d 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   10dea:	6823      	ldr	r3, [r4, #0]
   10dec:	e6e2      	b.n	10bb4 <HAL_SAI_InitProtocol+0x604>
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
   10dee:	f240 1181 	movw	r1, #385	; 0x181
   10df2:	4814      	ldr	r0, [pc, #80]	; (10e44 <HAL_SAI_InitProtocol+0x894>)
   10df4:	f008 fb0e 	bl	19414 <assert_failed>
   10df8:	e49c      	b.n	10734 <HAL_SAI_InitProtocol+0x184>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4B);
   10dfa:	f44f 6000 	mov.w	r0, #2048	; 0x800
   10dfe:	f7ff fa41 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   10e02:	e6ef      	b.n	10be4 <HAL_SAI_InitProtocol+0x634>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4A);
   10e04:	f44f 6080 	mov.w	r0, #1024	; 0x400
   10e08:	f7ff fa3c 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   10e0c:	6823      	ldr	r3, [r4, #0]
   10e0e:	e6e5      	b.n	10bdc <HAL_SAI_InitProtocol+0x62c>
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
   10e10:	f44f 71c2 	mov.w	r1, #388	; 0x184
   10e14:	480b      	ldr	r0, [pc, #44]	; (10e44 <HAL_SAI_InitProtocol+0x894>)
   10e16:	f008 fafd 	bl	19414 <assert_failed>
   10e1a:	e4c6      	b.n	107aa <HAL_SAI_InitProtocol+0x1fa>
   10e1c:	40015804 	.word	0x40015804
   10e20:	40015824 	.word	0x40015824
   10e24:	40015c04 	.word	0x40015c04
   10e28:	40016004 	.word	0x40016004
   10e2c:	58005404 	.word	0x58005404
   10e30:	58005424 	.word	0x58005424
   10e34:	cccccccd 	.word	0xcccccccd
   10e38:	f005c010 	.word	0xf005c010
   10e3c:	ffff1ff0 	.word	0xffff1ff0
   10e40:	fff88000 	.word	0xfff88000
   10e44:	0002fedc 	.word	0x0002fedc
   10e48:	f805c010 	.word	0xf805c010
   10e4c:	40016000 	.word	0x40016000

00010e50 <HAL_SAI_Transmit_DMA>:
{
   10e50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10e54:	460f      	mov	r7, r1
   10e56:	4604      	mov	r4, r0
   10e58:	4690      	mov	r8, r2
  uint32_t tickstart = HAL_GetTick();
   10e5a:	f7f7 facb 	bl	83f4 <HAL_GetTick>
  if ((pData == NULL) || (Size == 0U))
   10e5e:	2f00      	cmp	r7, #0
   10e60:	d064      	beq.n	10f2c <HAL_SAI_Transmit_DMA+0xdc>
   10e62:	fab8 f588 	clz	r5, r8
   10e66:	096d      	lsrs	r5, r5, #5
   10e68:	2d00      	cmp	r5, #0
   10e6a:	d15f      	bne.n	10f2c <HAL_SAI_Transmit_DMA+0xdc>
  if (hsai->State == HAL_SAI_STATE_READY)
   10e6c:	f894 6091 	ldrb.w	r6, [r4, #145]	; 0x91
   10e70:	b2f6      	uxtb	r6, r6
   10e72:	2e01      	cmp	r6, #1
   10e74:	d156      	bne.n	10f24 <HAL_SAI_Transmit_DMA+0xd4>
    __HAL_LOCK(hsai);
   10e76:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
   10e7a:	2b01      	cmp	r3, #1
   10e7c:	d052      	beq.n	10f24 <HAL_SAI_Transmit_DMA+0xd4>
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   10e7e:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    hsai->State = HAL_SAI_STATE_BUSY_TX;
   10e82:	2112      	movs	r1, #18
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   10e84:	4a37      	ldr	r2, [pc, #220]	; (10f64 <HAL_SAI_Transmit_DMA+0x114>)
   10e86:	4681      	mov	r9, r0
    hsai->pBuffPtr = pData;
   10e88:	67a7      	str	r7, [r4, #120]	; 0x78
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   10e8a:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    hsai->XferSize = Size;
   10e8e:	f8a4 807c 	strh.w	r8, [r4, #124]	; 0x7c
    hsai->State = HAL_SAI_STATE_BUSY_TX;
   10e92:	f884 1091 	strb.w	r1, [r4, #145]	; 0x91
    __HAL_LOCK(hsai);
   10e96:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
    hsai->XferCount = Size;
   10e9a:	f8a4 807e 	strh.w	r8, [r4, #126]	; 0x7e
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   10e9e:	4932      	ldr	r1, [pc, #200]	; (10f68 <HAL_SAI_Transmit_DMA+0x118>)
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   10ea0:	641a      	str	r2, [r3, #64]	; 0x40
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   10ea2:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
   10ea6:	4a31      	ldr	r2, [pc, #196]	; (10f6c <HAL_SAI_Transmit_DMA+0x11c>)
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   10ea8:	63d9      	str	r1, [r3, #60]	; 0x3c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
   10eaa:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   10eae:	64da      	str	r2, [r3, #76]	; 0x4c
    hsai->hdmatx->XferAbortCallback = NULL;
   10eb0:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   10eb4:	651d      	str	r5, [r3, #80]	; 0x50
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
   10eb6:	6822      	ldr	r2, [r4, #0]
   10eb8:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
   10ebc:	321c      	adds	r2, #28
   10ebe:	6fa1      	ldr	r1, [r4, #120]	; 0x78
   10ec0:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
   10ec4:	f7f9 fe0a 	bl	aadc <HAL_DMA_Start_IT>
   10ec8:	4607      	mov	r7, r0
   10eca:	2800      	cmp	r0, #0
   10ecc:	d132      	bne.n	10f34 <HAL_SAI_Transmit_DMA+0xe4>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   10ece:	6c62      	ldr	r2, [r4, #68]	; 0x44
   10ed0:	6863      	ldr	r3, [r4, #4]
   10ed2:	2a08      	cmp	r2, #8
   10ed4:	d03c      	beq.n	10f50 <HAL_SAI_Transmit_DMA+0x100>
   10ed6:	2005      	movs	r0, #5
   10ed8:	2261      	movs	r2, #97	; 0x61
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   10eda:	6821      	ldr	r1, [r4, #0]
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10edc:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_WCKCFG;
   10ede:	2b01      	cmp	r3, #1
   10ee0:	bf88      	it	hi
   10ee2:	4602      	movhi	r2, r0
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   10ee4:	690b      	ldr	r3, [r1, #16]
   10ee6:	4313      	orrs	r3, r2
   10ee8:	610b      	str	r3, [r1, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   10eea:	6822      	ldr	r2, [r4, #0]
   10eec:	6813      	ldr	r3, [r2, #0]
   10eee:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   10ef2:	6013      	str	r3, [r2, #0]
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
   10ef4:	e006      	b.n	10f04 <HAL_SAI_Transmit_DMA+0xb4>
      if ((HAL_GetTick() - tickstart) > SAI_LONG_TIMEOUT)
   10ef6:	f7f7 fa7d 	bl	83f4 <HAL_GetTick>
   10efa:	eba0 0009 	sub.w	r0, r0, r9
   10efe:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
   10f02:	d81b      	bhi.n	10f3c <HAL_SAI_Transmit_DMA+0xec>
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
   10f04:	6822      	ldr	r2, [r4, #0]
   10f06:	6955      	ldr	r5, [r2, #20]
   10f08:	f415 25e0 	ands.w	r5, r5, #458752	; 0x70000
   10f0c:	d0f3      	beq.n	10ef6 <HAL_SAI_Transmit_DMA+0xa6>
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
   10f0e:	6813      	ldr	r3, [r2, #0]
   10f10:	03db      	lsls	r3, r3, #15
   10f12:	d403      	bmi.n	10f1c <HAL_SAI_Transmit_DMA+0xcc>
      __HAL_SAI_ENABLE(hsai);
   10f14:	6813      	ldr	r3, [r2, #0]
   10f16:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   10f1a:	6013      	str	r3, [r2, #0]
    __HAL_UNLOCK(hsai);
   10f1c:	2300      	movs	r3, #0
   10f1e:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
    return HAL_OK;
   10f22:	e000      	b.n	10f26 <HAL_SAI_Transmit_DMA+0xd6>
    return HAL_BUSY;
   10f24:	2702      	movs	r7, #2
}
   10f26:	4638      	mov	r0, r7
   10f28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return  HAL_ERROR;
   10f2c:	2701      	movs	r7, #1
}
   10f2e:	4638      	mov	r0, r7
   10f30:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      __HAL_UNLOCK(hsai);
   10f34:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
      return  HAL_ERROR;
   10f38:	4637      	mov	r7, r6
   10f3a:	e7f4      	b.n	10f26 <HAL_SAI_Transmit_DMA+0xd6>
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   10f3c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
        return HAL_TIMEOUT;
   10f40:	2703      	movs	r7, #3
        __HAL_UNLOCK(hsai);
   10f42:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   10f46:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   10f4a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
        return HAL_TIMEOUT;
   10f4e:	e7ea      	b.n	10f26 <HAL_SAI_Transmit_DMA+0xd6>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   10f50:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   10f54:	2a01      	cmp	r2, #1
   10f56:	bf0b      	itete	eq
   10f58:	2015      	moveq	r0, #21
   10f5a:	2005      	movne	r0, #5
   10f5c:	2271      	moveq	r2, #113	; 0x71
   10f5e:	2261      	movne	r2, #97	; 0x61
   10f60:	e7bb      	b.n	10eda <HAL_SAI_Transmit_DMA+0x8a>
   10f62:	bf00      	nop
   10f64:	000110b5 	.word	0x000110b5
   10f68:	00011051 	.word	0x00011051
   10f6c:	00011131 	.word	0x00011131

00010f70 <HAL_SAI_Receive_DMA>:
  if ((pData == NULL) || (Size == 0U))
   10f70:	2900      	cmp	r1, #0
   10f72:	d057      	beq.n	11024 <HAL_SAI_Receive_DMA+0xb4>
{
   10f74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((pData == NULL) || (Size == 0U))
   10f76:	fab2 f582 	clz	r5, r2
   10f7a:	096d      	lsrs	r5, r5, #5
   10f7c:	2d00      	cmp	r5, #0
   10f7e:	d14f      	bne.n	11020 <HAL_SAI_Receive_DMA+0xb0>
  if (hsai->State == HAL_SAI_STATE_READY)
   10f80:	f890 6091 	ldrb.w	r6, [r0, #145]	; 0x91
   10f84:	b2f6      	uxtb	r6, r6
   10f86:	2e01      	cmp	r6, #1
   10f88:	d148      	bne.n	1101c <HAL_SAI_Receive_DMA+0xac>
    __HAL_LOCK(hsai);
   10f8a:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
   10f8e:	2b01      	cmp	r3, #1
   10f90:	d044      	beq.n	1101c <HAL_SAI_Receive_DMA+0xac>
   10f92:	4604      	mov	r4, r0
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   10f94:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
    hsai->State = HAL_SAI_STATE_BUSY_RX;
   10f98:	2722      	movs	r7, #34	; 0x22
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   10f9a:	482a      	ldr	r0, [pc, #168]	; (11044 <HAL_SAI_Receive_DMA+0xd4>)
    hsai->pBuffPtr = pData;
   10f9c:	67a1      	str	r1, [r4, #120]	; 0x78
    hsai->XferSize = Size;
   10f9e:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   10fa2:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    hsai->XferCount = Size;
   10fa6:	f8a4 207e 	strh.w	r2, [r4, #126]	; 0x7e
    __HAL_LOCK(hsai);
   10faa:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
    hsai->State = HAL_SAI_STATE_BUSY_RX;
   10fae:	f884 7091 	strb.w	r7, [r4, #145]	; 0x91
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   10fb2:	4925      	ldr	r1, [pc, #148]	; (11048 <HAL_SAI_Receive_DMA+0xd8>)
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   10fb4:	6418      	str	r0, [r3, #64]	; 0x40
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   10fb6:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
   10fba:	4a24      	ldr	r2, [pc, #144]	; (1104c <HAL_SAI_Receive_DMA+0xdc>)
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   10fbc:	63d9      	str	r1, [r3, #60]	; 0x3c
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
   10fbe:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   10fc2:	64da      	str	r2, [r3, #76]	; 0x4c
    hsai->hdmarx->XferAbortCallback = NULL;
   10fc4:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   10fc8:	651d      	str	r5, [r3, #80]	; 0x50
    if (HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
   10fca:	6821      	ldr	r1, [r4, #0]
   10fcc:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
   10fd0:	311c      	adds	r1, #28
   10fd2:	6fa2      	ldr	r2, [r4, #120]	; 0x78
   10fd4:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
   10fd8:	f7f9 fd80 	bl	aadc <HAL_DMA_Start_IT>
   10fdc:	bb20      	cbnz	r0, 11028 <HAL_SAI_Receive_DMA+0xb8>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   10fde:	6c62      	ldr	r2, [r4, #68]	; 0x44
   10fe0:	6863      	ldr	r3, [r4, #4]
   10fe2:	2a08      	cmp	r2, #8
   10fe4:	d024      	beq.n	11030 <HAL_SAI_Receive_DMA+0xc0>
   10fe6:	2505      	movs	r5, #5
   10fe8:	2261      	movs	r2, #97	; 0x61
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   10fea:	6821      	ldr	r1, [r4, #0]
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10fec:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_WCKCFG;
   10fee:	2b01      	cmp	r3, #1
   10ff0:	bf88      	it	hi
   10ff2:	462a      	movhi	r2, r5
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   10ff4:	690b      	ldr	r3, [r1, #16]
   10ff6:	4313      	orrs	r3, r2
   10ff8:	610b      	str	r3, [r1, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   10ffa:	6822      	ldr	r2, [r4, #0]
   10ffc:	6813      	ldr	r3, [r2, #0]
   10ffe:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11002:	6013      	str	r3, [r2, #0]
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
   11004:	6823      	ldr	r3, [r4, #0]
   11006:	681a      	ldr	r2, [r3, #0]
   11008:	03d2      	lsls	r2, r2, #15
   1100a:	d403      	bmi.n	11014 <HAL_SAI_Receive_DMA+0xa4>
      __HAL_SAI_ENABLE(hsai);
   1100c:	681a      	ldr	r2, [r3, #0]
   1100e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   11012:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(hsai);
   11014:	2300      	movs	r3, #0
   11016:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
}
   1101a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
   1101c:	2002      	movs	r0, #2
}
   1101e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
   11020:	2001      	movs	r0, #1
}
   11022:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
   11024:	2001      	movs	r0, #1
}
   11026:	4770      	bx	lr
      __HAL_UNLOCK(hsai);
   11028:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
      return  HAL_ERROR;
   1102c:	4630      	mov	r0, r6
}
   1102e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   11030:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   11034:	2a01      	cmp	r2, #1
   11036:	bf0b      	itete	eq
   11038:	2515      	moveq	r5, #21
   1103a:	2505      	movne	r5, #5
   1103c:	2271      	moveq	r2, #113	; 0x71
   1103e:	2261      	movne	r2, #97	; 0x61
   11040:	e7d3      	b.n	10fea <HAL_SAI_Receive_DMA+0x7a>
   11042:	bf00      	nop
   11044:	00011125 	.word	0x00011125
   11048:	000110c1 	.word	0x000110c1
   1104c:	00011131 	.word	0x00011131

00011050 <SAI_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
   11050:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
   11052:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   11054:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
   11056:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   1105a:	d01a      	beq.n	11092 <SAI_DMATxCplt+0x42>
  {
    hsai->XferCount = 0;
   1105c:	2300      	movs	r3, #0

    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   1105e:	6802      	ldr	r2, [r0, #0]
    hsai->XferCount = 0;
   11060:	f8a0 307e 	strh.w	r3, [r0, #126]	; 0x7e
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   11064:	6813      	ldr	r3, [r2, #0]
   11066:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   1106a:	6013      	str	r3, [r2, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   1106c:	6c43      	ldr	r3, [r0, #68]	; 0x44
   1106e:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   11070:	6843      	ldr	r3, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   11072:	d011      	beq.n	11098 <SAI_DMATxCplt+0x48>
   11074:	f06f 0261 	mvn.w	r2, #97	; 0x61
   11078:	f06f 0505 	mvn.w	r5, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1107c:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   1107e:	6801      	ldr	r1, [r0, #0]

    hsai->State = HAL_SAI_STATE_READY;
   11080:	2401      	movs	r4, #1
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   11082:	42a3      	cmp	r3, r4
   11084:	bf88      	it	hi
   11086:	462a      	movhi	r2, r5
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   11088:	690b      	ldr	r3, [r1, #16]
   1108a:	4013      	ands	r3, r2
   1108c:	610b      	str	r3, [r1, #16]
    hsai->State = HAL_SAI_STATE_READY;
   1108e:	f880 4091 	strb.w	r4, [r0, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxCpltCallback(hsai);
#else
  HAL_SAI_TxCpltCallback(hsai);
   11092:	f006 f927 	bl	172e4 <HAL_SAI_TxCpltCallback>
#endif
}
   11096:	bd38      	pop	{r3, r4, r5, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   11098:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   1109c:	2a01      	cmp	r2, #1
   1109e:	bf0b      	itete	eq
   110a0:	f06f 0271 	mvneq.w	r2, #113	; 0x71
   110a4:	f06f 0261 	mvnne.w	r2, #97	; 0x61
   110a8:	f06f 0515 	mvneq.w	r5, #21
   110ac:	f06f 0505 	mvnne.w	r5, #5
   110b0:	e7e4      	b.n	1107c <SAI_DMATxCplt+0x2c>
   110b2:	bf00      	nop

000110b4 <SAI_DMATxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
   110b4:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxHalfCpltCallback(hsai);
#else
  HAL_SAI_TxHalfCpltCallback(hsai);
   110b6:	6b80      	ldr	r0, [r0, #56]	; 0x38
   110b8:	f006 f916 	bl	172e8 <HAL_SAI_TxHalfCpltCallback>
#endif
}
   110bc:	bd08      	pop	{r3, pc}
   110be:	bf00      	nop

000110c0 <SAI_DMARxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)
{
   110c0:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
   110c2:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   110c4:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
   110c6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   110ca:	d01a      	beq.n	11102 <SAI_DMARxCplt+0x42>
  {
    /* Disable Rx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   110cc:	6802      	ldr	r2, [r0, #0]
    hsai->XferCount = 0;
   110ce:	2100      	movs	r1, #0
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   110d0:	6813      	ldr	r3, [r2, #0]
   110d2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   110d6:	6013      	str	r3, [r2, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   110d8:	6c43      	ldr	r3, [r0, #68]	; 0x44
    hsai->XferCount = 0;
   110da:	f8a0 107e 	strh.w	r1, [r0, #126]	; 0x7e
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   110de:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   110e0:	6843      	ldr	r3, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   110e2:	d011      	beq.n	11108 <SAI_DMARxCplt+0x48>
   110e4:	f06f 0261 	mvn.w	r2, #97	; 0x61
   110e8:	f06f 0505 	mvn.w	r5, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   110ec:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   110ee:	6801      	ldr	r1, [r0, #0]

    hsai->State = HAL_SAI_STATE_READY;
   110f0:	2401      	movs	r4, #1
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   110f2:	42a3      	cmp	r3, r4
   110f4:	bf88      	it	hi
   110f6:	462a      	movhi	r2, r5
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   110f8:	690b      	ldr	r3, [r1, #16]
   110fa:	4013      	ands	r3, r2
   110fc:	610b      	str	r3, [r1, #16]
    hsai->State = HAL_SAI_STATE_READY;
   110fe:	f880 4091 	strb.w	r4, [r0, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxCpltCallback(hsai);
#else
  HAL_SAI_RxCpltCallback(hsai);
   11102:	f006 f8f3 	bl	172ec <HAL_SAI_RxCpltCallback>
#endif
}
   11106:	bd38      	pop	{r3, r4, r5, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   11108:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   1110c:	2a01      	cmp	r2, #1
   1110e:	bf0b      	itete	eq
   11110:	f06f 0271 	mvneq.w	r2, #113	; 0x71
   11114:	f06f 0261 	mvnne.w	r2, #97	; 0x61
   11118:	f06f 0515 	mvneq.w	r5, #21
   1111c:	f06f 0505 	mvnne.w	r5, #5
   11120:	e7e4      	b.n	110ec <SAI_DMARxCplt+0x2c>
   11122:	bf00      	nop

00011124 <SAI_DMARxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
   11124:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxHalfCpltCallback(hsai);
#else
  HAL_SAI_RxHalfCpltCallback(hsai);
   11126:	6b80      	ldr	r0, [r0, #56]	; 0x38
   11128:	f006 f8e4 	bl	172f4 <HAL_SAI_RxHalfCpltCallback>
#endif
}
   1112c:	bd08      	pop	{r3, pc}
   1112e:	bf00      	nop

00011130 <SAI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
   11130:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   11132:	6b84      	ldr	r4, [r0, #56]	; 0x38

  /* Ignore DMA FIFO error */
  if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
   11134:	f7fa f8ea 	bl	b30c <HAL_DMA_GetError>
   11138:	2802      	cmp	r0, #2
   1113a:	d02a      	beq.n	11192 <SAI_DMAError+0x62>
  {
    /* Set SAI error code */
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
   1113c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94

    /* Disable the SAI DMA request */
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   11140:	6821      	ldr	r1, [r4, #0]
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
   11142:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   11146:	4a17      	ldr	r2, [pc, #92]	; (111a4 <SAI_DMAError+0x74>)
   11148:	4d17      	ldr	r5, [pc, #92]	; (111a8 <SAI_DMAError+0x78>)
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
   1114a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   1114e:	680b      	ldr	r3, [r1, #0]
   11150:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   11154:	600b      	str	r3, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   11156:	6812      	ldr	r2, [r2, #0]
  __HAL_SAI_DISABLE(hsai);
   11158:	6820      	ldr	r0, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   1115a:	fba5 3202 	umull	r3, r2, r5, r2
  __HAL_SAI_DISABLE(hsai);
   1115e:	6801      	ldr	r1, [r0, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   11160:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
   11162:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    if (count == 0U)
   11166:	0093      	lsls	r3, r2, #2
  __HAL_SAI_DISABLE(hsai);
   11168:	6001      	str	r1, [r0, #0]
    if (count == 0U)
   1116a:	b19a      	cbz	r2, 11194 <SAI_DMAError+0x64>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   1116c:	6821      	ldr	r1, [r4, #0]
    count--;
   1116e:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   11170:	680a      	ldr	r2, [r1, #0]
   11172:	03d0      	lsls	r0, r2, #15
   11174:	d504      	bpl.n	11180 <SAI_DMAError+0x50>
    if (count == 0U)
   11176:	b16b      	cbz	r3, 11194 <SAI_DMAError+0x64>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   11178:	680a      	ldr	r2, [r1, #0]
    count--;
   1117a:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   1117c:	03d2      	lsls	r2, r2, #15
   1117e:	d4fa      	bmi.n	11176 <SAI_DMAError+0x46>
    /* Disable SAI peripheral */
    /* No need to check return value because state will be updated and HAL_SAI_ErrorCallback will be called later */
    (void) SAI_Disable(hsai);

    /* Set the SAI state ready to be able to start again the process */
    hsai->State = HAL_SAI_STATE_READY;
   11180:	2201      	movs	r2, #1

    /* Initialize XferCount */
    hsai->XferCount = 0U;
   11182:	2300      	movs	r3, #0

    /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
    hsai->ErrorCallback(hsai);
#else
    HAL_SAI_ErrorCallback(hsai);
   11184:	4620      	mov	r0, r4
    hsai->State = HAL_SAI_STATE_READY;
   11186:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
    hsai->XferCount = 0U;
   1118a:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    HAL_SAI_ErrorCallback(hsai);
   1118e:	f006 f8a5 	bl	172dc <HAL_SAI_ErrorCallback>
#endif
  }
}
   11192:	bd38      	pop	{r3, r4, r5, pc}
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   11194:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
   11198:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1119c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
   111a0:	e7ee      	b.n	11180 <SAI_DMAError+0x50>
   111a2:	bf00      	nop
   111a4:	0006280c 	.word	0x0006280c
   111a8:	95cbec1b 	.word	0x95cbec1b

000111ac <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
   111ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   111b0:	4605      	mov	r5, r0
   111b2:	b087      	sub	sp, #28
   111b4:	460f      	mov	r7, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
   111b6:	f7f7 f91d 	bl	83f4 <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0UL, 0UL};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
   111ba:	2108      	movs	r1, #8
  uint32_t tickstart = HAL_GetTick();
   111bc:	4606      	mov	r6, r0
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
   111be:	6828      	ldr	r0, [r5, #0]
   111c0:	f002 fd82 	bl	13cc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   111c4:	4604      	mov	r4, r0
   111c6:	b118      	cbz	r0, 111d0 <SD_FindSCR+0x24>
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
   111c8:	4620      	mov	r0, r4
   111ca:	b007      	add	sp, #28
   111cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
   111d0:	6ca9      	ldr	r1, [r5, #72]	; 0x48
   111d2:	6828      	ldr	r0, [r5, #0]
   111d4:	0409      	lsls	r1, r1, #16
   111d6:	f002 ffe1 	bl	1419c <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
   111da:	4604      	mov	r4, r0
   111dc:	2800      	cmp	r0, #0
   111de:	d1f3      	bne.n	111c8 <SD_FindSCR+0x1c>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   111e0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 8U;
   111e4:	2308      	movs	r3, #8
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
   111e6:	2130      	movs	r1, #48	; 0x30
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   111e8:	9004      	str	r0, [sp, #16]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   111ea:	9200      	str	r2, [sp, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   111ec:	2202      	movs	r2, #2
  config.DataLength    = 8U;
   111ee:	9301      	str	r3, [sp, #4]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   111f0:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
   111f2:	9102      	str	r1, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   111f4:	4669      	mov	r1, sp
   111f6:	6828      	ldr	r0, [r5, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   111f8:	9203      	str	r2, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   111fa:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   111fc:	f002 fd06 	bl	13c0c <SDMMC_ConfigData>
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
   11200:	6828      	ldr	r0, [r5, #0]
   11202:	f003 f887 	bl	14314 <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
   11206:	4604      	mov	r4, r0
   11208:	2800      	cmp	r0, #0
   1120a:	d1dd      	bne.n	111c8 <SD_FindSCR+0x1c>
  uint32_t index = 0U;
   1120c:	4681      	mov	r9, r0
  uint32_t tempscr[2U] = {0UL, 0UL};
   1120e:	4683      	mov	fp, r0
   11210:	4682      	mov	sl, r0
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
   11212:	f240 582a 	movw	r8, #1322	; 0x52a
   11216:	e004      	b.n	11222 <SD_FindSCR+0x76>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   11218:	f7f7 f8ec 	bl	83f4 <HAL_GetTick>
   1121c:	1b80      	subs	r0, r0, r6
   1121e:	3001      	adds	r0, #1
   11220:	d025      	beq.n	1126e <SD_FindSCR+0xc2>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
   11222:	6828      	ldr	r0, [r5, #0]
   11224:	6b43      	ldr	r3, [r0, #52]	; 0x34
   11226:	ea13 0f08 	tst.w	r3, r8
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
   1122a:	6b43      	ldr	r3, [r0, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
   1122c:	d10e      	bne.n	1124c <SD_FindSCR+0xa0>
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
   1122e:	031b      	lsls	r3, r3, #12
   11230:	d4f2      	bmi.n	11218 <SD_FindSCR+0x6c>
   11232:	f1b9 0f00 	cmp.w	r9, #0
   11236:	d1ef      	bne.n	11218 <SD_FindSCR+0x6c>
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
   11238:	f002 fcc2 	bl	13bc0 <SDMMC_ReadFIFO>
   1123c:	4682      	mov	sl, r0
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
   1123e:	6828      	ldr	r0, [r5, #0]
      index++;
   11240:	f04f 0901 	mov.w	r9, #1
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
   11244:	f002 fcbc 	bl	13bc0 <SDMMC_ReadFIFO>
   11248:	4683      	mov	fp, r0
   1124a:	e7e5      	b.n	11218 <SD_FindSCR+0x6c>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   1124c:	0719      	lsls	r1, r3, #28
   1124e:	d411      	bmi.n	11274 <SD_FindSCR+0xc8>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   11250:	6b43      	ldr	r3, [r0, #52]	; 0x34
   11252:	079a      	lsls	r2, r3, #30
   11254:	d411      	bmi.n	1127a <SD_FindSCR+0xce>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
   11256:	6b43      	ldr	r3, [r0, #52]	; 0x34
   11258:	069b      	lsls	r3, r3, #26
   1125a:	d411      	bmi.n	11280 <SD_FindSCR+0xd4>
   1125c:	fa9b f28b 	rev.w	r2, fp
   11260:	fa9a f38a 	rev.w	r3, sl
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   11264:	4908      	ldr	r1, [pc, #32]	; (11288 <SD_FindSCR+0xdc>)
   11266:	6381      	str	r1, [r0, #56]	; 0x38
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
   11268:	e9c7 2300 	strd	r2, r3, [r7]
  return HAL_SD_ERROR_NONE;
   1126c:	e7ac      	b.n	111c8 <SD_FindSCR+0x1c>
      return HAL_SD_ERROR_TIMEOUT;
   1126e:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
   11272:	e7a9      	b.n	111c8 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
   11274:	2408      	movs	r4, #8
   11276:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_TIMEOUT;
   11278:	e7a6      	b.n	111c8 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
   1127a:	2402      	movs	r4, #2
   1127c:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_CRC_FAIL;
   1127e:	e7a3      	b.n	111c8 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
   11280:	2420      	movs	r4, #32
   11282:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
   11284:	e7a0      	b.n	111c8 <SD_FindSCR+0x1c>
   11286:	bf00      	nop
   11288:	18000f3a 	.word	0x18000f3a

0001128c <HAL_SD_ReadBlocks>:
{
   1128c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11290:	460d      	mov	r5, r1
   11292:	b086      	sub	sp, #24
   11294:	4604      	mov	r4, r0
   11296:	4690      	mov	r8, r2
   11298:	461e      	mov	r6, r3
  uint32_t tickstart = HAL_GetTick();
   1129a:	f7f7 f8ab 	bl	83f4 <HAL_GetTick>
  if(NULL == pData)
   1129e:	2d00      	cmp	r5, #0
   112a0:	d070      	beq.n	11384 <HAL_SD_ReadBlocks+0xf8>
   112a2:	4607      	mov	r7, r0
  if(hsd->State == HAL_SD_STATE_READY)
   112a4:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
   112a8:	b2c0      	uxtb	r0, r0
   112aa:	2801      	cmp	r0, #1
   112ac:	d007      	beq.n	112be <HAL_SD_ReadBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   112ae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   112b0:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   112b2:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   112b6:	63a3      	str	r3, [r4, #56]	; 0x38
}
   112b8:	b006      	add	sp, #24
   112ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   112be:	eb08 0306 	add.w	r3, r8, r6
   112c2:	6d62      	ldr	r2, [r4, #84]	; 0x54
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   112c4:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   112c6:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   112c8:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   112ca:	d863      	bhi.n	11394 <HAL_SD_ReadBlocks+0x108>
    hsd->Instance->DCTRL = 0U;
   112cc:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
   112ce:	2203      	movs	r2, #3
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   112d0:	f04f 0902 	mov.w	r9, #2
    hsd->State = HAL_SD_STATE_BUSY;
   112d4:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   112d8:	2290      	movs	r2, #144	; 0x90
    hsd->Instance->DCTRL = 0U;
   112da:	62d9      	str	r1, [r3, #44]	; 0x2c
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
   112dc:	0271      	lsls	r1, r6, #9
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   112de:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
   112e0:	9101      	str	r1, [sp, #4]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   112e2:	4669      	mov	r1, sp
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   112e4:	2b01      	cmp	r3, #1
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   112e6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   112ea:	6820      	ldr	r0, [r4, #0]
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   112ec:	9300      	str	r3, [sp, #0]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   112ee:	f04f 0300 	mov.w	r3, #0
      add *= 512U;
   112f2:	bf18      	it	ne
   112f4:	ea4f 2848 	movne.w	r8, r8, lsl #9
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   112f8:	9202      	str	r2, [sp, #8]
    config.DPSM          = SDMMC_DPSM_DISABLE;
   112fa:	9305      	str	r3, [sp, #20]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   112fc:	e9cd 9303 	strd	r9, r3, [sp, #12]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   11300:	f002 fc84 	bl	13c0c <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   11304:	6822      	ldr	r2, [r4, #0]
    if(NumberOfBlocks > 1U)
   11306:	2e01      	cmp	r6, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   11308:	68d3      	ldr	r3, [r2, #12]
   1130a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1130e:	60d3      	str	r3, [r2, #12]
    if(NumberOfBlocks > 1U)
   11310:	d953      	bls.n	113ba <HAL_SD_ReadBlocks+0x12e>
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
   11312:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
   11316:	4641      	mov	r1, r8
   11318:	6820      	ldr	r0, [r4, #0]
   1131a:	f002 fd5d 	bl	13dd8 <SDMMC_CmdReadMultiBlock>
   1131e:	4603      	mov	r3, r0
   11320:	6820      	ldr	r0, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
   11322:	2b00      	cmp	r3, #0
   11324:	d13d      	bne.n	113a2 <HAL_SD_ReadBlocks+0x116>
    dataremaining = config.DataLength;
   11326:	f8dd 9004 	ldr.w	r9, [sp, #4]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   1132a:	e006      	b.n	1133a <HAL_SD_ReadBlocks+0xae>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
   1132c:	f7f7 f862 	bl	83f4 <HAL_GetTick>
   11330:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   11332:	1bc0      	subs	r0, r0, r7
   11334:	4298      	cmp	r0, r3
   11336:	d274      	bcs.n	11422 <HAL_SD_ReadBlocks+0x196>
   11338:	6820      	ldr	r0, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   1133a:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1133c:	f413 7f95 	tst.w	r3, #298	; 0x12a
   11340:	d143      	bne.n	113ca <HAL_SD_ReadBlocks+0x13e>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining >= 32U))
   11342:	6b43      	ldr	r3, [r0, #52]	; 0x34
   11344:	0419      	lsls	r1, r3, #16
   11346:	d5f1      	bpl.n	1132c <HAL_SD_ReadBlocks+0xa0>
   11348:	f1b9 0f1f 	cmp.w	r9, #31
   1134c:	d9ee      	bls.n	1132c <HAL_SD_ReadBlocks+0xa0>
   1134e:	f105 0a04 	add.w	sl, r5, #4
   11352:	f105 0824 	add.w	r8, r5, #36	; 0x24
   11356:	e000      	b.n	1135a <HAL_SD_ReadBlocks+0xce>
   11358:	6820      	ldr	r0, [r4, #0]
          data = SDMMC_ReadFIFO(hsd->Instance);
   1135a:	f002 fc31 	bl	13bc0 <SDMMC_ReadFIFO>
          *tempbuff = (uint8_t)(data & 0xFFU);
   1135e:	f80a 0c04 	strb.w	r0, [sl, #-4]
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
   11362:	0a02      	lsrs	r2, r0, #8
   11364:	f10a 0a04 	add.w	sl, sl, #4
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
   11368:	0c03      	lsrs	r3, r0, #16
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
   1136a:	0e00      	lsrs	r0, r0, #24
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
   1136c:	f80a 2c07 	strb.w	r2, [sl, #-7]
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
   11370:	f80a 3c06 	strb.w	r3, [sl, #-6]
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
   11374:	f80a 0c05 	strb.w	r0, [sl, #-5]
        for(count = 0U; count < 8U; count++)
   11378:	45c2      	cmp	sl, r8
   1137a:	d1ed      	bne.n	11358 <HAL_SD_ReadBlocks+0xcc>
   1137c:	3520      	adds	r5, #32
        dataremaining -= 32U;
   1137e:	f1a9 0920 	sub.w	r9, r9, #32
   11382:	e7d3      	b.n	1132c <HAL_SD_ReadBlocks+0xa0>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   11384:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   11386:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   11388:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   1138c:	63a3      	str	r3, [r4, #56]	; 0x38
}
   1138e:	b006      	add	sp, #24
   11390:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
   11394:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11396:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   1139a:	63a3      	str	r3, [r4, #56]	; 0x38
}
   1139c:	b006      	add	sp, #24
   1139e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   113a2:	4a39      	ldr	r2, [pc, #228]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
   113a4:	2101      	movs	r1, #1
      hsd->Context = SD_CONTEXT_NONE;
   113a6:	2500      	movs	r5, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   113a8:	6382      	str	r2, [r0, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
   113aa:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          return HAL_ERROR;
   113ac:	4608      	mov	r0, r1
          hsd->ErrorCode |= errorstate;
   113ae:	4313      	orrs	r3, r2
   113b0:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
   113b2:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
   113b6:	6325      	str	r5, [r4, #48]	; 0x30
          return HAL_ERROR;
   113b8:	e77e      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
   113ba:	2301      	movs	r3, #1
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
   113bc:	4641      	mov	r1, r8
   113be:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
   113c0:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
   113c2:	f002 fcc5 	bl	13d50 <SDMMC_CmdReadSingleBlock>
   113c6:	4603      	mov	r3, r0
   113c8:	e7aa      	b.n	11320 <HAL_SD_ReadBlocks+0x94>
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
   113ca:	68c3      	ldr	r3, [r0, #12]
   113cc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   113d0:	60c3      	str	r3, [r0, #12]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
   113d2:	6823      	ldr	r3, [r4, #0]
   113d4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   113d6:	05d2      	lsls	r2, r2, #23
   113d8:	d50b      	bpl.n	113f2 <HAL_SD_ReadBlocks+0x166>
   113da:	2e01      	cmp	r6, #1
   113dc:	d909      	bls.n	113f2 <HAL_SD_ReadBlocks+0x166>
      if(hsd->SdCard.CardType != CARD_SECURED)
   113de:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   113e0:	2a03      	cmp	r2, #3
   113e2:	d006      	beq.n	113f2 <HAL_SD_ReadBlocks+0x166>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
   113e4:	4618      	mov	r0, r3
   113e6:	f002 fdc3 	bl	13f70 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
   113ea:	4603      	mov	r3, r0
   113ec:	2800      	cmp	r0, #0
   113ee:	d145      	bne.n	1147c <HAL_SD_ReadBlocks+0x1f0>
   113f0:	6823      	ldr	r3, [r4, #0]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   113f2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   113f4:	f012 0208 	ands.w	r2, r2, #8
   113f8:	d121      	bne.n	1143e <HAL_SD_ReadBlocks+0x1b2>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   113fa:	6b59      	ldr	r1, [r3, #52]	; 0x34
   113fc:	f011 0102 	ands.w	r1, r1, #2
   11400:	d12a      	bne.n	11458 <HAL_SD_ReadBlocks+0x1cc>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
   11402:	6b58      	ldr	r0, [r3, #52]	; 0x34
   11404:	f010 0020 	ands.w	r0, r0, #32
   11408:	d032      	beq.n	11470 <HAL_SD_ReadBlocks+0x1e4>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1140a:	481f      	ldr	r0, [pc, #124]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
   1140c:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1140e:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   11410:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
   11412:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11414:	f043 0320 	orr.w	r3, r3, #32
   11418:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   1141a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   1141e:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
   11420:	e74a      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11422:	6823      	ldr	r3, [r4, #0]
        hsd->State= HAL_SD_STATE_READY;
   11424:	2101      	movs	r1, #1
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11426:	4d18      	ldr	r5, [pc, #96]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
        hsd->Context = SD_CONTEXT_NONE;
   11428:	2200      	movs	r2, #0
        return HAL_TIMEOUT;
   1142a:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1142c:	639d      	str	r5, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
   1142e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11430:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   11434:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
   11436:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
   1143a:	6322      	str	r2, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
   1143c:	e73c      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1143e:	4812      	ldr	r0, [pc, #72]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
   11440:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
   11442:	2100      	movs	r1, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11444:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   11446:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
   11448:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1144a:	f043 0308 	orr.w	r3, r3, #8
   1144e:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   11450:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   11454:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
   11456:	e72f      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11458:	480b      	ldr	r0, [pc, #44]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
   1145a:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1145c:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   1145e:	4608      	mov	r0, r1
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
   11460:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11462:	f043 0302 	orr.w	r3, r3, #2
   11466:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   11468:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   1146c:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
   1146e:	e723      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   11470:	4906      	ldr	r1, [pc, #24]	; (1148c <HAL_SD_ReadBlocks+0x200>)
    hsd->State = HAL_SD_STATE_READY;
   11472:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   11474:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   11476:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_OK;
   1147a:	e71d      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1147c:	6822      	ldr	r2, [r4, #0]
          hsd->State = HAL_SD_STATE_READY;
   1147e:	2101      	movs	r1, #1
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11480:	4801      	ldr	r0, [pc, #4]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
          hsd->Context = SD_CONTEXT_NONE;
   11482:	2500      	movs	r5, #0
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11484:	6390      	str	r0, [r2, #56]	; 0x38
   11486:	e790      	b.n	113aa <HAL_SD_ReadBlocks+0x11e>
   11488:	1fe00fff 	.word	0x1fe00fff
   1148c:	18000f3a 	.word	0x18000f3a

00011490 <HAL_SD_WriteBlocks>:
{
   11490:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11494:	460d      	mov	r5, r1
   11496:	b089      	sub	sp, #36	; 0x24
   11498:	4604      	mov	r4, r0
   1149a:	4616      	mov	r6, r2
   1149c:	461f      	mov	r7, r3
  uint32_t tickstart = HAL_GetTick();
   1149e:	f7f6 ffa9 	bl	83f4 <HAL_GetTick>
  if(NULL == pData)
   114a2:	2d00      	cmp	r5, #0
   114a4:	d05d      	beq.n	11562 <HAL_SD_WriteBlocks+0xd2>
   114a6:	4680      	mov	r8, r0
  if(hsd->State == HAL_SD_STATE_READY)
   114a8:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
   114ac:	b2c0      	uxtb	r0, r0
   114ae:	2801      	cmp	r0, #1
   114b0:	d007      	beq.n	114c2 <HAL_SD_WriteBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   114b2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   114b4:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   114b6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   114ba:	63a3      	str	r3, [r4, #56]	; 0x38
}
   114bc:	b009      	add	sp, #36	; 0x24
   114be:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   114c2:	19f3      	adds	r3, r6, r7
   114c4:	6d62      	ldr	r2, [r4, #84]	; 0x54
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   114c6:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   114c8:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   114ca:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   114cc:	d851      	bhi.n	11572 <HAL_SD_WriteBlocks+0xe2>
    hsd->Instance->DCTRL = 0U;
   114ce:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
   114d0:	2203      	movs	r2, #3
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
   114d2:	0278      	lsls	r0, r7, #9
    hsd->State = HAL_SD_STATE_BUSY;
   114d4:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   114d8:	2290      	movs	r2, #144	; 0x90
    hsd->Instance->DCTRL = 0U;
   114da:	62d9      	str	r1, [r3, #44]	; 0x2c
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   114dc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   114e0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   114e2:	9102      	str	r1, [sp, #8]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   114e4:	a902      	add	r1, sp, #8
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   114e6:	2b01      	cmp	r3, #1
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
   114e8:	f04f 0300 	mov.w	r3, #0
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   114ec:	e9cd 0203 	strd	r0, r2, [sp, #12]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   114f0:	6820      	ldr	r0, [r4, #0]
      add *= 512U;
   114f2:	bf18      	it	ne
   114f4:	0276      	lslne	r6, r6, #9
    config.DPSM          = SDMMC_DPSM_DISABLE;
   114f6:	9307      	str	r3, [sp, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   114f8:	e9cd 3305 	strd	r3, r3, [sp, #20]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   114fc:	f002 fb86 	bl	13c0c <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   11500:	6822      	ldr	r2, [r4, #0]
    if(NumberOfBlocks > 1U)
   11502:	2f01      	cmp	r7, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   11504:	68d3      	ldr	r3, [r2, #12]
   11506:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1150a:	60d3      	str	r3, [r2, #12]
    if(NumberOfBlocks > 1U)
   1150c:	d944      	bls.n	11598 <HAL_SD_WriteBlocks+0x108>
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
   1150e:	2320      	movs	r3, #32
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
   11510:	4631      	mov	r1, r6
   11512:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
   11514:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
   11516:	f002 fce7 	bl	13ee8 <SDMMC_CmdWriteMultiBlock>
   1151a:	4603      	mov	r3, r0
   1151c:	6820      	ldr	r0, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
   1151e:	bb7b      	cbnz	r3, 11580 <HAL_SD_WriteBlocks+0xf0>
    dataremaining = config.DataLength;
   11520:	9e03      	ldr	r6, [sp, #12]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   11522:	e007      	b.n	11534 <HAL_SD_WriteBlocks+0xa4>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
   11524:	f7f6 ff66 	bl	83f4 <HAL_GetTick>
   11528:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1152a:	eba0 0008 	sub.w	r0, r0, r8
   1152e:	4298      	cmp	r0, r3
   11530:	d266      	bcs.n	11600 <HAL_SD_WriteBlocks+0x170>
   11532:	6820      	ldr	r0, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   11534:	6b43      	ldr	r3, [r0, #52]	; 0x34
   11536:	f413 7f8d 	tst.w	r3, #282	; 0x11a
   1153a:	d135      	bne.n	115a8 <HAL_SD_WriteBlocks+0x118>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining >= 32U))
   1153c:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1153e:	0459      	lsls	r1, r3, #17
   11540:	d5f0      	bpl.n	11524 <HAL_SD_WriteBlocks+0x94>
   11542:	2e1f      	cmp	r6, #31
   11544:	d9ee      	bls.n	11524 <HAL_SD_WriteBlocks+0x94>
   11546:	f105 0920 	add.w	r9, r5, #32
   1154a:	e000      	b.n	1154e <HAL_SD_WriteBlocks+0xbe>
   1154c:	6820      	ldr	r0, [r4, #0]
          data |= ((uint32_t)(*tempbuff) << 24U);
   1154e:	f855 3b04 	ldr.w	r3, [r5], #4
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
   11552:	a901      	add	r1, sp, #4
          data |= ((uint32_t)(*tempbuff) << 24U);
   11554:	9301      	str	r3, [sp, #4]
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
   11556:	f002 fb37 	bl	13bc8 <SDMMC_WriteFIFO>
        for(count = 0U; count < 8U; count++)
   1155a:	454d      	cmp	r5, r9
   1155c:	d1f6      	bne.n	1154c <HAL_SD_WriteBlocks+0xbc>
        dataremaining -= 32U;
   1155e:	3e20      	subs	r6, #32
   11560:	e7e0      	b.n	11524 <HAL_SD_WriteBlocks+0x94>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   11562:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   11564:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   11566:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   1156a:	63a3      	str	r3, [r4, #56]	; 0x38
}
   1156c:	b009      	add	sp, #36	; 0x24
   1156e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
   11572:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11574:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   11578:	63a3      	str	r3, [r4, #56]	; 0x38
}
   1157a:	b009      	add	sp, #36	; 0x24
   1157c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11580:	4a38      	ldr	r2, [pc, #224]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
   11582:	2101      	movs	r1, #1
      hsd->Context = SD_CONTEXT_NONE;
   11584:	2500      	movs	r5, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11586:	6382      	str	r2, [r0, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
   11588:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          return HAL_ERROR;
   1158a:	4608      	mov	r0, r1
          hsd->ErrorCode |= errorstate;
   1158c:	4313      	orrs	r3, r2
   1158e:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
   11590:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
   11594:	6325      	str	r5, [r4, #48]	; 0x30
          return HAL_ERROR;
   11596:	e791      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
   11598:	2310      	movs	r3, #16
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
   1159a:	4631      	mov	r1, r6
   1159c:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
   1159e:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
   115a0:	f002 fc5e 	bl	13e60 <SDMMC_CmdWriteSingleBlock>
   115a4:	4603      	mov	r3, r0
   115a6:	e7b9      	b.n	1151c <HAL_SD_WriteBlocks+0x8c>
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
   115a8:	68c3      	ldr	r3, [r0, #12]
   115aa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   115ae:	60c3      	str	r3, [r0, #12]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
   115b0:	6823      	ldr	r3, [r4, #0]
   115b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   115b4:	05d2      	lsls	r2, r2, #23
   115b6:	d50b      	bpl.n	115d0 <HAL_SD_WriteBlocks+0x140>
   115b8:	2f01      	cmp	r7, #1
   115ba:	d909      	bls.n	115d0 <HAL_SD_WriteBlocks+0x140>
      if(hsd->SdCard.CardType != CARD_SECURED)
   115bc:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   115be:	2a03      	cmp	r2, #3
   115c0:	d006      	beq.n	115d0 <HAL_SD_WriteBlocks+0x140>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
   115c2:	4618      	mov	r0, r3
   115c4:	f002 fcd4 	bl	13f70 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
   115c8:	4603      	mov	r3, r0
   115ca:	2800      	cmp	r0, #0
   115cc:	d143      	bne.n	11656 <HAL_SD_WriteBlocks+0x1c6>
   115ce:	6823      	ldr	r3, [r4, #0]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   115d0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   115d2:	f012 0208 	ands.w	r2, r2, #8
   115d6:	d11f      	bne.n	11618 <HAL_SD_WriteBlocks+0x188>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   115d8:	6b59      	ldr	r1, [r3, #52]	; 0x34
   115da:	f011 0102 	ands.w	r1, r1, #2
   115de:	d128      	bne.n	11632 <HAL_SD_WriteBlocks+0x1a2>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
   115e0:	6b58      	ldr	r0, [r3, #52]	; 0x34
   115e2:	f010 0010 	ands.w	r0, r0, #16
   115e6:	d030      	beq.n	1164a <HAL_SD_WriteBlocks+0x1ba>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   115e8:	481e      	ldr	r0, [pc, #120]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
   115ea:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   115ec:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   115ee:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
   115f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   115f2:	f043 0310 	orr.w	r3, r3, #16
   115f6:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   115f8:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   115fc:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
   115fe:	e75d      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11600:	6821      	ldr	r1, [r4, #0]
        hsd->State = HAL_SD_STATE_READY;
   11602:	2201      	movs	r2, #1
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11604:	4d17      	ldr	r5, [pc, #92]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
        hsd->Context = SD_CONTEXT_NONE;
   11606:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
   11608:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1160a:	638d      	str	r5, [r1, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
   1160c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   1160e:	63a1      	str	r1, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
   11610:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
   11614:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
   11616:	e751      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11618:	4812      	ldr	r0, [pc, #72]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
   1161a:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
   1161c:	2100      	movs	r1, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1161e:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   11620:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
   11622:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11624:	f043 0308 	orr.w	r3, r3, #8
   11628:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   1162a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   1162e:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
   11630:	e744      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11632:	480c      	ldr	r0, [pc, #48]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
   11634:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11636:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   11638:	4608      	mov	r0, r1
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
   1163a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1163c:	f043 0302 	orr.w	r3, r3, #2
   11640:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   11642:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   11646:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
   11648:	e738      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   1164a:	4907      	ldr	r1, [pc, #28]	; (11668 <HAL_SD_WriteBlocks+0x1d8>)
    hsd->State = HAL_SD_STATE_READY;
   1164c:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   1164e:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   11650:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_OK;
   11654:	e732      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11656:	6822      	ldr	r2, [r4, #0]
          hsd->State = HAL_SD_STATE_READY;
   11658:	2101      	movs	r1, #1
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1165a:	4802      	ldr	r0, [pc, #8]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
          hsd->Context = SD_CONTEXT_NONE;
   1165c:	2500      	movs	r5, #0
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1165e:	6390      	str	r0, [r2, #56]	; 0x38
   11660:	e792      	b.n	11588 <HAL_SD_WriteBlocks+0xf8>
   11662:	bf00      	nop
   11664:	1fe00fff 	.word	0x1fe00fff
   11668:	18000f3a 	.word	0x18000f3a

0001166c <HAL_SD_DriveTransceiver_1_8V_Callback>:
}
   1166c:	4770      	bx	lr
   1166e:	bf00      	nop

00011670 <HAL_SD_GetCardCSD>:
{
   11670:	4603      	mov	r3, r0
  pCSD->Reserved2 = 0U; /*!< Reserved */
   11672:	2000      	movs	r0, #0
{
   11674:	b430      	push	{r4, r5}
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
   11676:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   11678:	0f92      	lsrs	r2, r2, #30
   1167a:	700a      	strb	r2, [r1, #0]
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
   1167c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   1167e:	f3c2 6283 	ubfx	r2, r2, #26, #4
   11682:	704a      	strb	r2, [r1, #1]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
   11684:	f893 2063 	ldrb.w	r2, [r3, #99]	; 0x63
   11688:	f002 0203 	and.w	r2, r2, #3
   1168c:	708a      	strb	r2, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
   1168e:	f893 2062 	ldrb.w	r2, [r3, #98]	; 0x62
   11692:	70ca      	strb	r2, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
   11694:	f893 2061 	ldrb.w	r2, [r3, #97]	; 0x61
   11698:	710a      	strb	r2, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
   1169a:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
   1169e:	714a      	strb	r2, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
   116a0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   116a2:	0d12      	lsrs	r2, r2, #20
   116a4:	80ca      	strh	r2, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
   116a6:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
   116aa:	f002 020f 	and.w	r2, r2, #15
   116ae:	720a      	strb	r2, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
   116b0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   116b2:	f3c2 32c0 	ubfx	r2, r2, #15, #1
   116b6:	724a      	strb	r2, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
   116b8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   116ba:	f3c2 3280 	ubfx	r2, r2, #14, #1
   116be:	728a      	strb	r2, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
   116c0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   116c2:	f3c2 3240 	ubfx	r2, r2, #13, #1
   116c6:	72ca      	strb	r2, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
   116c8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   116ca:	f3c2 3200 	ubfx	r2, r2, #12, #1
   116ce:	730a      	strb	r2, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
   116d0:	7348      	strb	r0, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
   116d2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   116d4:	2a00      	cmp	r2, #0
   116d6:	f040 8086 	bne.w	117e6 <HAL_SD_GetCardCSD+0x176>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
   116da:	6e5d      	ldr	r5, [r3, #100]	; 0x64
   116dc:	f640 72fc 	movw	r2, #4092	; 0xffc
   116e0:	6e98      	ldr	r0, [r3, #104]	; 0x68
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   116e2:	2401      	movs	r4, #1
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
   116e4:	ea02 0285 	and.w	r2, r2, r5, lsl #2
    hsd->SdCard.LogBlockSize = 512U;
   116e8:	f44f 7500 	mov.w	r5, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
   116ec:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
   116f0:	610a      	str	r2, [r1, #16]
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
   116f2:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   116f4:	f3c2 62c2 	ubfx	r2, r2, #27, #3
   116f8:	750a      	strb	r2, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
   116fa:	f893 206b 	ldrb.w	r2, [r3, #107]	; 0x6b
   116fe:	f002 0207 	and.w	r2, r2, #7
   11702:	754a      	strb	r2, [r1, #21]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
   11704:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   11706:	f3c2 5242 	ubfx	r2, r2, #21, #3
   1170a:	758a      	strb	r2, [r1, #22]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
   1170c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   1170e:	f3c2 4282 	ubfx	r2, r2, #18, #3
   11712:	75ca      	strb	r2, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
   11714:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   11716:	f3c2 32c2 	ubfx	r2, r2, #15, #3
   1171a:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
   1171c:	690a      	ldr	r2, [r1, #16]
   1171e:	4422      	add	r2, r4
   11720:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
   11722:	7e08      	ldrb	r0, [r1, #24]
   11724:	f000 0007 	and.w	r0, r0, #7
   11728:	3002      	adds	r0, #2
   1172a:	4082      	lsls	r2, r0
   1172c:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   1172e:	7a08      	ldrb	r0, [r1, #8]
    hsd->SdCard.LogBlockSize = 512U;
   11730:	659d      	str	r5, [r3, #88]	; 0x58
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   11732:	f000 000f 	and.w	r0, r0, #15
   11736:	fa04 f000 	lsl.w	r0, r4, r0
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
   1173a:	0a44      	lsrs	r4, r0, #9
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   1173c:	6518      	str	r0, [r3, #80]	; 0x50
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
   1173e:	fb02 f204 	mul.w	r2, r2, r4
   11742:	655a      	str	r2, [r3, #84]	; 0x54
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
   11744:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  pCSD->Reserved3 = 0;
   11746:	2500      	movs	r5, #0
  pCSD->Reserved4 = 1;
   11748:	2401      	movs	r4, #1
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
   1174a:	f3c2 3280 	ubfx	r2, r2, #14, #1
  return HAL_OK;
   1174e:	4628      	mov	r0, r5
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
   11750:	764a      	strb	r2, [r1, #25]
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
   11752:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   11754:	f3c2 12c6 	ubfx	r2, r2, #7, #7
   11758:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
   1175a:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   1175c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   11760:	76ca      	strb	r2, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
   11762:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   11764:	0fd2      	lsrs	r2, r2, #31
   11766:	770a      	strb	r2, [r1, #28]
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
   11768:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   1176a:	f3c2 7241 	ubfx	r2, r2, #29, #2
   1176e:	774a      	strb	r2, [r1, #29]
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
   11770:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   11772:	f3c2 6282 	ubfx	r2, r2, #26, #3
   11776:	778a      	strb	r2, [r1, #30]
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
   11778:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   1177a:	f3c2 5283 	ubfx	r2, r2, #22, #4
   1177e:	77ca      	strb	r2, [r1, #31]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
   11780:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   11782:	f3c2 5240 	ubfx	r2, r2, #21, #1
   11786:	f881 2020 	strb.w	r2, [r1, #32]
  pCSD->Reserved3 = 0;
   1178a:	f881 5021 	strb.w	r5, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
   1178e:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
   11792:	4022      	ands	r2, r4
   11794:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
   11798:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   1179a:	f3c2 32c0 	ubfx	r2, r2, #15, #1
   1179e:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
   117a2:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   117a4:	f3c2 3280 	ubfx	r2, r2, #14, #1
   117a8:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
   117ac:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   117ae:	f3c2 3240 	ubfx	r2, r2, #13, #1
   117b2:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
   117b6:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   117b8:	f3c2 3200 	ubfx	r2, r2, #12, #1
   117bc:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
   117c0:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   117c2:	f3c2 2281 	ubfx	r2, r2, #10, #2
   117c6:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
   117ca:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   117cc:	f3c2 2201 	ubfx	r2, r2, #8, #2
   117d0:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
   117d4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   117d6:	f3c3 0346 	ubfx	r3, r3, #1, #7
   117da:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
   117de:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
}
   117e2:	bc30      	pop	{r4, r5}
   117e4:	4770      	bx	lr
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
   117e6:	2a01      	cmp	r2, #1
   117e8:	d00c      	beq.n	11804 <HAL_SD_GetCardCSD+0x194>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   117ea:	681a      	ldr	r2, [r3, #0]
    hsd->State = HAL_SD_STATE_READY;
   117ec:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   117ee:	4c0e      	ldr	r4, [pc, #56]	; (11828 <HAL_SD_GetCardCSD+0x1b8>)
    return HAL_ERROR;
   117f0:	4608      	mov	r0, r1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   117f2:	6394      	str	r4, [r2, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   117f4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   117f6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   117fa:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   117fc:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
}
   11800:	bc30      	pop	{r4, r5}
   11802:	4770      	bx	lr
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
   11804:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    hsd->SdCard.BlockSize = 512U;
   11806:	f44f 7000 	mov.w	r0, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
   1180a:	f8b3 406a 	ldrh.w	r4, [r3, #106]	; 0x6a
   1180e:	0412      	lsls	r2, r2, #16
   11810:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
   11814:	4322      	orrs	r2, r4
   11816:	610a      	str	r2, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
   11818:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockSize = 512U;
   1181a:	6518      	str	r0, [r3, #80]	; 0x50
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
   1181c:	3201      	adds	r2, #1
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
   1181e:	6598      	str	r0, [r3, #88]	; 0x58
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
   11820:	0292      	lsls	r2, r2, #10
   11822:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
   11824:	655a      	str	r2, [r3, #84]	; 0x54
   11826:	e78d      	b.n	11744 <HAL_SD_GetCardCSD+0xd4>
   11828:	1fe00fff 	.word	0x1fe00fff

0001182c <HAL_SD_InitCard>:
{
   1182c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   11830:	6982      	ldr	r2, [r0, #24]
{
   11832:	b098      	sub	sp, #96	; 0x60
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
   11834:	2300      	movs	r3, #0
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
   11836:	21fa      	movs	r1, #250	; 0xfa
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   11838:	2a02      	cmp	r2, #2
{
   1183a:	4604      	mov	r4, r0
   1183c:	6805      	ldr	r5, [r0, #0]
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
   1183e:	910b      	str	r1, [sp, #44]	; 0x2c
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
   11840:	e9cd 3307 	strd	r3, r3, [sp, #28]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
   11844:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   11848:	d104      	bne.n	11854 <HAL_SD_InitCard+0x28>
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
   1184a:	682b      	ldr	r3, [r5, #0]
   1184c:	f043 0310 	orr.w	r3, r3, #16
   11850:	602b      	str	r3, [r5, #0]
   11852:	6805      	ldr	r5, [r0, #0]
  (void)SDMMC_Init(hsd->Instance, Init);
   11854:	aa0a      	add	r2, sp, #40	; 0x28
   11856:	ab07      	add	r3, sp, #28
   11858:	ca07      	ldmia	r2, {r0, r1, r2}
   1185a:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
   1185e:	4628      	mov	r0, r5
   11860:	cb0e      	ldmia	r3, {r1, r2, r3}
   11862:	f002 f94d 	bl	13b00 <SDMMC_Init>
  (void)SDMMC_PowerState_ON(hsd->Instance);
   11866:	6820      	ldr	r0, [r4, #0]
   11868:	f002 f9b4 	bl	13bd4 <SDMMC_PowerState_ON>
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC)/(2U*SDMMC_INIT_CLK_DIV);
   1186c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   11870:	f7fe fd08 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   11874:	4ba3      	ldr	r3, [pc, #652]	; (11b04 <HAL_SD_InitCard+0x2d8>)
   11876:	fba3 3000 	umull	r3, r0, r3, r0
  if(sdmmc_clk != 0U)
   1187a:	0940      	lsrs	r0, r0, #5
   1187c:	d019      	beq.n	118b2 <HAL_SD_InitCard+0x86>
    HAL_Delay(1U+ (74U*1000U/(sdmmc_clk)));
   1187e:	4ba2      	ldr	r3, [pc, #648]	; (11b08 <HAL_SD_InitCard+0x2dc>)
   11880:	fbb3 f0f0 	udiv	r0, r3, r0
   11884:	3001      	adds	r0, #1
   11886:	f7f6 fdbb 	bl	8400 <HAL_Delay>
  __IO uint32_t count = 0U;
   1188a:	2300      	movs	r3, #0
   1188c:	9306      	str	r3, [sp, #24]
  uint32_t tickstart = HAL_GetTick();
   1188e:	f7f6 fdb1 	bl	83f4 <HAL_GetTick>
   11892:	4680      	mov	r8, r0
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
   11894:	6820      	ldr	r0, [r4, #0]
   11896:	f002 fc13 	bl	140c0 <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
   1189a:	4605      	mov	r5, r0
   1189c:	b168      	cbz	r0, 118ba <HAL_SD_InitCard+0x8e>
    hsd->State = HAL_SD_STATE_READY;
   1189e:	2601      	movs	r6, #1
   118a0:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
   118a4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   118a6:	431d      	orrs	r5, r3
   118a8:	63a5      	str	r5, [r4, #56]	; 0x38
}
   118aa:	4630      	mov	r0, r6
   118ac:	b018      	add	sp, #96	; 0x60
   118ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    HAL_Delay(2U);
   118b2:	2002      	movs	r0, #2
   118b4:	f7f6 fda4 	bl	8400 <HAL_Delay>
   118b8:	e7e7      	b.n	1188a <HAL_SD_InitCard+0x5e>
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
   118ba:	6820      	ldr	r0, [r4, #0]
   118bc:	f002 fc2e 	bl	1411c <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
   118c0:	2800      	cmp	r0, #0
   118c2:	d179      	bne.n	119b8 <HAL_SD_InitCard+0x18c>
    hsd->SdCard.CardVersion = CARD_V2_X;
   118c4:	2301      	movs	r3, #1
   118c6:	6423      	str	r3, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
   118c8:	2100      	movs	r1, #0
   118ca:	6820      	ldr	r0, [r4, #0]
   118cc:	f002 fc66 	bl	1419c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   118d0:	bb08      	cbnz	r0, 11916 <HAL_SD_InitCard+0xea>
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
   118d2:	9b06      	ldr	r3, [sp, #24]
   118d4:	f64f 76fe 	movw	r6, #65534	; 0xfffe
   118d8:	42b3      	cmp	r3, r6
   118da:	f200 8109 	bhi.w	11af0 <HAL_SD_InitCard+0x2c4>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
   118de:	4f8b      	ldr	r7, [pc, #556]	; (11b0c <HAL_SD_InitCard+0x2e0>)
   118e0:	e00c      	b.n	118fc <HAL_SD_InitCard+0xd0>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   118e2:	4601      	mov	r1, r0
   118e4:	6820      	ldr	r0, [r4, #0]
   118e6:	f002 f981 	bl	13bec <SDMMC_GetResponse>
    count++;
   118ea:	9b06      	ldr	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
   118ec:	1e02      	subs	r2, r0, #0
    count++;
   118ee:	f103 0301 	add.w	r3, r3, #1
   118f2:	9306      	str	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
   118f4:	9b06      	ldr	r3, [sp, #24]
   118f6:	db11      	blt.n	1191c <HAL_SD_InitCard+0xf0>
   118f8:	42b3      	cmp	r3, r6
   118fa:	d80f      	bhi.n	1191c <HAL_SD_InitCard+0xf0>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
   118fc:	2100      	movs	r1, #0
   118fe:	6820      	ldr	r0, [r4, #0]
   11900:	f002 fc4c 	bl	1419c <SDMMC_CmdAppCommand>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
   11904:	4639      	mov	r1, r7
    if(errorstate != HAL_SD_ERROR_NONE)
   11906:	4605      	mov	r5, r0
   11908:	2800      	cmp	r0, #0
   1190a:	d1c8      	bne.n	1189e <HAL_SD_InitCard+0x72>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
   1190c:	6820      	ldr	r0, [r4, #0]
   1190e:	f002 fc89 	bl	14224 <SDMMC_CmdAppOperCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   11912:	2800      	cmp	r0, #0
   11914:	d0e5      	beq.n	118e2 <HAL_SD_InitCard+0xb6>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   11916:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   1191a:	e7c0      	b.n	1189e <HAL_SD_InitCard+0x72>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
   1191c:	9906      	ldr	r1, [sp, #24]
   1191e:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   11922:	4299      	cmp	r1, r3
   11924:	f200 809d 	bhi.w	11a62 <HAL_SD_InitCard+0x236>
  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
   11928:	0057      	lsls	r7, r2, #1
   1192a:	6820      	ldr	r0, [r4, #0]
   1192c:	d504      	bpl.n	11938 <HAL_SD_InitCard+0x10c>
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   1192e:	69a3      	ldr	r3, [r4, #24]
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
   11930:	2101      	movs	r1, #1
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   11932:	2b02      	cmp	r3, #2
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
   11934:	63e1      	str	r1, [r4, #60]	; 0x3c
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   11936:	d051      	beq.n	119dc <HAL_SD_InitCard+0x1b0>
  uint16_t sd_rca = 1U;
   11938:	2301      	movs	r3, #1
   1193a:	f8ad 3016 	strh.w	r3, [sp, #22]
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
   1193e:	f002 f951 	bl	13be4 <SDMMC_GetPowerState>
   11942:	2800      	cmp	r0, #0
   11944:	d044      	beq.n	119d0 <HAL_SD_InitCard+0x1a4>
  if(hsd->SdCard.CardType != CARD_SECURED)
   11946:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   11948:	6823      	ldr	r3, [r4, #0]
   1194a:	2a03      	cmp	r2, #3
   1194c:	d125      	bne.n	1199a <HAL_SD_InitCard+0x16e>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
   1194e:	4618      	mov	r0, r3
   11950:	2104      	movs	r1, #4
   11952:	f002 f94b 	bl	13bec <SDMMC_GetResponse>
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
   11956:	a90d      	add	r1, sp, #52	; 0x34
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
   11958:	0d03      	lsrs	r3, r0, #20
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
   1195a:	4620      	mov	r0, r4
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
   1195c:	6463      	str	r3, [r4, #68]	; 0x44
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
   1195e:	f7ff fe87 	bl	11670 <HAL_SD_GetCardCSD>
   11962:	4606      	mov	r6, r0
   11964:	2800      	cmp	r0, #0
   11966:	d136      	bne.n	119d6 <HAL_SD_InitCard+0x1aa>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
   11968:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   1196a:	4603      	mov	r3, r0
   1196c:	6820      	ldr	r0, [r4, #0]
   1196e:	0412      	lsls	r2, r2, #16
   11970:	f002 fb62 	bl	14038 <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
   11974:	b9b0      	cbnz	r0, 119a4 <HAL_SD_InitCard+0x178>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
   11976:	f44f 7100 	mov.w	r1, #512	; 0x200
   1197a:	6820      	ldr	r0, [r4, #0]
   1197c:	f002 f9a4 	bl	13cc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   11980:	2800      	cmp	r0, #0
   11982:	d092      	beq.n	118aa <HAL_SD_InitCard+0x7e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11984:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_READY;
   11986:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11988:	4961      	ldr	r1, [pc, #388]	; (11b10 <HAL_SD_InitCard+0x2e4>)
    return HAL_ERROR;
   1198a:	4616      	mov	r6, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1198c:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
   1198e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11990:	4318      	orrs	r0, r3
   11992:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   11994:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_ERROR;
   11998:	e787      	b.n	118aa <HAL_SD_InitCard+0x7e>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
   1199a:	4618      	mov	r0, r3
   1199c:	f002 fcfe 	bl	1439c <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
   119a0:	2800      	cmp	r0, #0
   119a2:	d061      	beq.n	11a68 <HAL_SD_InitCard+0x23c>
    hsd->State = HAL_SD_STATE_READY;
   119a4:	2601      	movs	r6, #1
   119a6:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
   119aa:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   119ac:	4308      	orrs	r0, r1
   119ae:	63a0      	str	r0, [r4, #56]	; 0x38
}
   119b0:	4630      	mov	r0, r6
   119b2:	b018      	add	sp, #96	; 0x60
   119b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hsd->SdCard.CardVersion = CARD_V1_X;
   119b8:	6425      	str	r5, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
   119ba:	6820      	ldr	r0, [r4, #0]
   119bc:	f002 fb80 	bl	140c0 <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
   119c0:	4605      	mov	r5, r0
   119c2:	2800      	cmp	r0, #0
   119c4:	f47f af6b 	bne.w	1189e <HAL_SD_InitCard+0x72>
  if( hsd->SdCard.CardVersion == CARD_V2_X)
   119c8:	6c23      	ldr	r3, [r4, #64]	; 0x40
   119ca:	2b01      	cmp	r3, #1
   119cc:	d181      	bne.n	118d2 <HAL_SD_InitCard+0xa6>
   119ce:	e77b      	b.n	118c8 <HAL_SD_InitCard+0x9c>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
   119d0:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
   119d4:	e7e6      	b.n	119a4 <HAL_SD_InitCard+0x178>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   119d6:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
   119da:	e7e3      	b.n	119a4 <HAL_SD_InitCard+0x178>
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
   119dc:	01d6      	lsls	r6, r2, #7
   119de:	d5ab      	bpl.n	11938 <HAL_SD_InitCard+0x10c>
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
   119e0:	f44f 7300 	mov.w	r3, #512	; 0x200
   119e4:	65e3      	str	r3, [r4, #92]	; 0x5c
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
   119e6:	6803      	ldr	r3, [r0, #0]
   119e8:	f043 0308 	orr.w	r3, r3, #8
   119ec:	6003      	str	r3, [r0, #0]
        errorstate = SDMMC_CmdVoltageSwitch(hsd->Instance);
   119ee:	6820      	ldr	r0, [r4, #0]
   119f0:	f002 fe24 	bl	1463c <SDMMC_CmdVoltageSwitch>
        if(errorstate != HAL_SD_ERROR_NONE)
   119f4:	4605      	mov	r5, r0
   119f6:	b130      	cbz	r0, 11a06 <HAL_SD_InitCard+0x1da>
   119f8:	e751      	b.n	1189e <HAL_SD_InitCard+0x72>
          if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   119fa:	f7f6 fcfb 	bl	83f4 <HAL_GetTick>
   119fe:	eba0 0008 	sub.w	r0, r0, r8
   11a02:	3001      	adds	r0, #1
   11a04:	d079      	beq.n	11afa <HAL_SD_InitCard+0x2ce>
        while(( hsd->Instance->STA & SDMMC_FLAG_CKSTOP) != SDMMC_FLAG_CKSTOP)
   11a06:	6823      	ldr	r3, [r4, #0]
   11a08:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11a0a:	0155      	lsls	r5, r2, #5
   11a0c:	d5f5      	bpl.n	119fa <HAL_SD_InitCard+0x1ce>
        hsd->Instance->ICR = SDMMC_FLAG_CKSTOP;
   11a0e:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
   11a12:	639a      	str	r2, [r3, #56]	; 0x38
        if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) != SDMMC_FLAG_BUSYD0)
   11a14:	6823      	ldr	r3, [r4, #0]
   11a16:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   11a18:	02d8      	lsls	r0, r3, #11
   11a1a:	f57f af7c 	bpl.w	11916 <HAL_SD_InitCard+0xea>
          HAL_SD_DriveTransceiver_1_8V_Callback(SET);
   11a1e:	2001      	movs	r0, #1
   11a20:	f7ff fe24 	bl	1166c <HAL_SD_DriveTransceiver_1_8V_Callback>
          hsd->Instance->POWER |= SDMMC_POWER_VSWITCH;
   11a24:	6822      	ldr	r2, [r4, #0]
   11a26:	6813      	ldr	r3, [r2, #0]
   11a28:	f043 0304 	orr.w	r3, r3, #4
   11a2c:	6013      	str	r3, [r2, #0]
   11a2e:	e005      	b.n	11a3c <HAL_SD_InitCard+0x210>
            if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   11a30:	f7f6 fce0 	bl	83f4 <HAL_GetTick>
   11a34:	eba0 0008 	sub.w	r0, r0, r8
   11a38:	3001      	adds	r0, #1
   11a3a:	d05e      	beq.n	11afa <HAL_SD_InitCard+0x2ce>
          while(( hsd->Instance->STA & SDMMC_FLAG_VSWEND) != SDMMC_FLAG_VSWEND)
   11a3c:	6823      	ldr	r3, [r4, #0]
   11a3e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11a40:	0191      	lsls	r1, r2, #6
   11a42:	d5f5      	bpl.n	11a30 <HAL_SD_InitCard+0x204>
          hsd->Instance->ICR = SDMMC_FLAG_VSWEND;
   11a44:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
   11a48:	639a      	str	r2, [r3, #56]	; 0x38
          if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) == SDMMC_FLAG_BUSYD0)
   11a4a:	6823      	ldr	r3, [r4, #0]
   11a4c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11a4e:	02d2      	lsls	r2, r2, #11
   11a50:	d407      	bmi.n	11a62 <HAL_SD_InitCard+0x236>
          hsd->Instance->POWER = 0x13U;
   11a52:	2113      	movs	r1, #19
          hsd->Instance->ICR = 0xFFFFFFFFU;
   11a54:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
          hsd->Instance->POWER = 0x13U;
   11a58:	6019      	str	r1, [r3, #0]
          hsd->Instance->ICR = 0xFFFFFFFFU;
   11a5a:	6823      	ldr	r3, [r4, #0]
   11a5c:	639a      	str	r2, [r3, #56]	; 0x38
   11a5e:	6820      	ldr	r0, [r4, #0]
   11a60:	e76a      	b.n	11938 <HAL_SD_InitCard+0x10c>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
   11a62:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
   11a66:	e71a      	b.n	1189e <HAL_SD_InitCard+0x72>
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11a68:	4601      	mov	r1, r0
   11a6a:	6820      	ldr	r0, [r4, #0]
   11a6c:	f002 f8be 	bl	13bec <SDMMC_GetResponse>
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11a70:	2104      	movs	r1, #4
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11a72:	6720      	str	r0, [r4, #112]	; 0x70
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11a74:	6820      	ldr	r0, [r4, #0]
   11a76:	f002 f8b9 	bl	13bec <SDMMC_GetResponse>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11a7a:	2108      	movs	r1, #8
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11a7c:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11a7e:	6820      	ldr	r0, [r4, #0]
   11a80:	f002 f8b4 	bl	13bec <SDMMC_GetResponse>
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   11a84:	210c      	movs	r1, #12
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11a86:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   11a88:	6820      	ldr	r0, [r4, #0]
   11a8a:	f002 f8af 	bl	13bec <SDMMC_GetResponse>
  if(hsd->SdCard.CardType != CARD_SECURED)
   11a8e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   11a90:	67e0      	str	r0, [r4, #124]	; 0x7c
  if(hsd->SdCard.CardType != CARD_SECURED)
   11a92:	2b03      	cmp	r3, #3
   11a94:	d034      	beq.n	11b00 <HAL_SD_InitCard+0x2d4>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
   11a96:	f10d 0116 	add.w	r1, sp, #22
   11a9a:	6820      	ldr	r0, [r4, #0]
   11a9c:	f002 fcf2 	bl	14484 <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
   11aa0:	2800      	cmp	r0, #0
   11aa2:	f47f af7f 	bne.w	119a4 <HAL_SD_InitCard+0x178>
  if(hsd->SdCard.CardType != CARD_SECURED)
   11aa6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   11aa8:	6823      	ldr	r3, [r4, #0]
   11aaa:	2a03      	cmp	r2, #3
   11aac:	f43f af4f 	beq.w	1194e <HAL_SD_InitCard+0x122>
    hsd->SdCard.RelCardAdd = sd_rca;
   11ab0:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11ab4:	4618      	mov	r0, r3
    hsd->SdCard.RelCardAdd = sd_rca;
   11ab6:	64a1      	str	r1, [r4, #72]	; 0x48
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11ab8:	0409      	lsls	r1, r1, #16
   11aba:	f002 fca9 	bl	14410 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
   11abe:	2800      	cmp	r0, #0
   11ac0:	f47f af70 	bne.w	119a4 <HAL_SD_InitCard+0x178>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11ac4:	4601      	mov	r1, r0
   11ac6:	6820      	ldr	r0, [r4, #0]
   11ac8:	f002 f890 	bl	13bec <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11acc:	2104      	movs	r1, #4
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11ace:	6620      	str	r0, [r4, #96]	; 0x60
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11ad0:	6820      	ldr	r0, [r4, #0]
   11ad2:	f002 f88b 	bl	13bec <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11ad6:	2108      	movs	r1, #8
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11ad8:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11ada:	6820      	ldr	r0, [r4, #0]
   11adc:	f002 f886 	bl	13bec <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   11ae0:	210c      	movs	r1, #12
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11ae2:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   11ae4:	6820      	ldr	r0, [r4, #0]
   11ae6:	f002 f881 	bl	13bec <SDMMC_GetResponse>
   11aea:	6823      	ldr	r3, [r4, #0]
   11aec:	66e0      	str	r0, [r4, #108]	; 0x6c
   11aee:	e72e      	b.n	1194e <HAL_SD_InitCard+0x122>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
   11af0:	9b06      	ldr	r3, [sp, #24]
   11af2:	42b3      	cmp	r3, r6
   11af4:	d8b5      	bhi.n	11a62 <HAL_SD_InitCard+0x236>
   11af6:	6820      	ldr	r0, [r4, #0]
   11af8:	e71e      	b.n	11938 <HAL_SD_InitCard+0x10c>
            return HAL_SD_ERROR_TIMEOUT;
   11afa:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
   11afe:	e6ce      	b.n	1189e <HAL_SD_InitCard+0x72>
   11b00:	6823      	ldr	r3, [r4, #0]
   11b02:	e724      	b.n	1194e <HAL_SD_InitCard+0x122>
   11b04:	10624dd3 	.word	0x10624dd3
   11b08:	00012110 	.word	0x00012110
   11b0c:	c1100000 	.word	0xc1100000
   11b10:	1fe00fff 	.word	0x1fe00fff

00011b14 <HAL_SD_GetCardStatus>:
{
   11b14:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11b18:	4604      	mov	r4, r0
   11b1a:	b097      	sub	sp, #92	; 0x5c
   11b1c:	460d      	mov	r5, r1
  uint32_t tickstart = HAL_GetTick();
   11b1e:	f7f6 fc69 	bl	83f4 <HAL_GetTick>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11b22:	2100      	movs	r1, #0
  uint32_t tickstart = HAL_GetTick();
   11b24:	4680      	mov	r8, r0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11b26:	6820      	ldr	r0, [r4, #0]
   11b28:	f002 f860 	bl	13bec <SDMMC_GetResponse>
   11b2c:	0187      	lsls	r7, r0, #6
   11b2e:	d422      	bmi.n	11b76 <HAL_SD_GetCardStatus+0x62>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
   11b30:	2140      	movs	r1, #64	; 0x40
   11b32:	6820      	ldr	r0, [r4, #0]
   11b34:	f002 f8c8 	bl	13cc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   11b38:	b308      	cbz	r0, 11b7e <HAL_SD_GetCardStatus+0x6a>
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
   11b3a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11b3c:	63a3      	str	r3, [r4, #56]	; 0x38
   11b3e:	6823      	ldr	r3, [r4, #0]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11b40:	495b      	ldr	r1, [pc, #364]	; (11cb0 <HAL_SD_GetCardStatus+0x19c>)
    hsd->State = HAL_SD_STATE_READY;
   11b42:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11b44:	6399      	str	r1, [r3, #56]	; 0x38
    status = HAL_ERROR;
   11b46:	4616      	mov	r6, r2
    hsd->ErrorCode |= errorstate;
   11b48:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11b4a:	4318      	orrs	r0, r3
   11b4c:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   11b4e:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
   11b52:	f44f 7100 	mov.w	r1, #512	; 0x200
   11b56:	6820      	ldr	r0, [r4, #0]
   11b58:	f002 f8b6 	bl	13cc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   11b5c:	b138      	cbz	r0, 11b6e <HAL_SD_GetCardStatus+0x5a>
    hsd->State = HAL_SD_STATE_READY;
   11b5e:	2301      	movs	r3, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11b60:	6822      	ldr	r2, [r4, #0]
   11b62:	4953      	ldr	r1, [pc, #332]	; (11cb0 <HAL_SD_GetCardStatus+0x19c>)
    status = HAL_ERROR;
   11b64:	461e      	mov	r6, r3
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11b66:	6391      	str	r1, [r2, #56]	; 0x38
    hsd->ErrorCode = errorstate;
   11b68:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   11b6a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
   11b6e:	4630      	mov	r0, r6
   11b70:	b017      	add	sp, #92	; 0x5c
   11b72:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11b76:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
   11b78:	f44f 6000 	mov.w	r0, #2048	; 0x800
   11b7c:	e7e0      	b.n	11b40 <HAL_SD_GetCardStatus+0x2c>
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11b7e:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   11b80:	6820      	ldr	r0, [r4, #0]
   11b82:	0409      	lsls	r1, r1, #16
   11b84:	f002 fb0a 	bl	1419c <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
   11b88:	2800      	cmp	r0, #0
   11b8a:	d1d6      	bne.n	11b3a <HAL_SD_GetCardStatus+0x26>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   11b8c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 64U;
   11b90:	2340      	movs	r3, #64	; 0x40
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
   11b92:	2160      	movs	r1, #96	; 0x60
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   11b94:	9004      	str	r0, [sp, #16]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   11b96:	9200      	str	r2, [sp, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   11b98:	2202      	movs	r2, #2
  config.DataLength    = 64U;
   11b9a:	9301      	str	r3, [sp, #4]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   11b9c:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
   11b9e:	9102      	str	r1, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   11ba0:	4669      	mov	r1, sp
   11ba2:	6820      	ldr	r0, [r4, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   11ba4:	9203      	str	r2, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   11ba6:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   11ba8:	f002 f830 	bl	13c0c <SDMMC_ConfigData>
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
   11bac:	6820      	ldr	r0, [r4, #0]
   11bae:	f002 fd01 	bl	145b4 <SDMMC_CmdStatusRegister>
  if(errorstate != HAL_SD_ERROR_NONE)
   11bb2:	2800      	cmp	r0, #0
   11bb4:	d1c1      	bne.n	11b3a <HAL_SD_GetCardStatus+0x26>
  uint32_t *pData = pSDstatus;
   11bb6:	af06      	add	r7, sp, #24
   11bb8:	e005      	b.n	11bc6 <HAL_SD_GetCardStatus+0xb2>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   11bba:	f7f6 fc1b 	bl	83f4 <HAL_GetTick>
   11bbe:	eba0 0008 	sub.w	r0, r0, r8
   11bc2:	3001      	adds	r0, #1
   11bc4:	d013      	beq.n	11bee <HAL_SD_GetCardStatus+0xda>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   11bc6:	6823      	ldr	r3, [r4, #0]
   11bc8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11bca:	f412 7f95 	tst.w	r2, #298	; 0x12a
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
   11bce:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   11bd0:	d110      	bne.n	11bf4 <HAL_SD_GetCardStatus+0xe0>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
   11bd2:	0416      	lsls	r6, r2, #16
   11bd4:	d5f1      	bpl.n	11bba <HAL_SD_GetCardStatus+0xa6>
   11bd6:	f107 0620 	add.w	r6, r7, #32
   11bda:	e000      	b.n	11bde <HAL_SD_GetCardStatus+0xca>
   11bdc:	6823      	ldr	r3, [r4, #0]
        *pData = SDMMC_ReadFIFO(hsd->Instance);
   11bde:	4618      	mov	r0, r3
   11be0:	f001 ffee 	bl	13bc0 <SDMMC_ReadFIFO>
   11be4:	f847 0b04 	str.w	r0, [r7], #4
      for(count = 0U; count < 8U; count++)
   11be8:	42b7      	cmp	r7, r6
   11bea:	d1f7      	bne.n	11bdc <HAL_SD_GetCardStatus+0xc8>
   11bec:	e7e5      	b.n	11bba <HAL_SD_GetCardStatus+0xa6>
      return HAL_SD_ERROR_TIMEOUT;
   11bee:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
   11bf2:	e7a4      	b.n	11b3e <HAL_SD_GetCardStatus+0x2a>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   11bf4:	0710      	lsls	r0, r2, #28
   11bf6:	d455      	bmi.n	11ca4 <HAL_SD_GetCardStatus+0x190>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   11bf8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11bfa:	0791      	lsls	r1, r2, #30
   11bfc:	d454      	bmi.n	11ca8 <HAL_SD_GetCardStatus+0x194>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
   11bfe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11c00:	0692      	lsls	r2, r2, #26
   11c02:	d50b      	bpl.n	11c1c <HAL_SD_GetCardStatus+0x108>
   11c04:	e052      	b.n	11cac <HAL_SD_GetCardStatus+0x198>
    *pData = SDMMC_ReadFIFO(hsd->Instance);
   11c06:	f001 ffdb 	bl	13bc0 <SDMMC_ReadFIFO>
   11c0a:	f847 0b04 	str.w	r0, [r7], #4
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   11c0e:	f7f6 fbf1 	bl	83f4 <HAL_GetTick>
   11c12:	eba0 0008 	sub.w	r0, r0, r8
   11c16:	3001      	adds	r0, #1
   11c18:	d0e9      	beq.n	11bee <HAL_SD_GetCardStatus+0xda>
   11c1a:	6823      	ldr	r3, [r4, #0]
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
   11c1c:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    *pData = SDMMC_ReadFIFO(hsd->Instance);
   11c1e:	4618      	mov	r0, r3
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
   11c20:	f416 5680 	ands.w	r6, r6, #4096	; 0x1000
   11c24:	d1ef      	bne.n	11c06 <HAL_SD_GetCardStatus+0xf2>
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
   11c26:	9f06      	ldr	r7, [sp, #24]
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
   11c28:	9808      	ldr	r0, [sp, #32]
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   11c2a:	0a39      	lsrs	r1, r7, #8
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
   11c2c:	f3c7 1e81 	ubfx	lr, r7, #6, #2
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c30:	ea4f 4810 	mov.w	r8, r0, lsr #16
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
   11c34:	f3c7 1c40 	ubfx	ip, r7, #5, #1
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   11c38:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c3c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   11c3e:	ea41 6117 	orr.w	r1, r1, r7, lsr #24
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c42:	f028 07ff 	bic.w	r7, r8, #255	; 0xff
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   11c46:	f8df 806c 	ldr.w	r8, [pc, #108]	; 11cb4 <HAL_SD_GetCardStatus+0x1a0>
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c4a:	fa5f f982 	uxtb.w	r9, r2
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   11c4e:	b289      	uxth	r1, r1
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   11c50:	f8c3 8038 	str.w	r8, [r3, #56]	; 0x38
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
   11c54:	fa5f f880 	uxtb.w	r8, r0
   11c58:	9b07      	ldr	r3, [sp, #28]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c5a:	ea47 0709 	orr.w	r7, r7, r9
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
   11c5e:	f885 e000 	strb.w	lr, [r5]
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
   11c62:	f885 c001 	strb.w	ip, [r5, #1]
   11c66:	fa93 fe83 	rev.w	lr, r3
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   11c6a:	8069      	strh	r1, [r5, #2]
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
   11c6c:	f3c0 5303 	ubfx	r3, r0, #20, #4
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
   11c70:	f3c0 2107 	ubfx	r1, r0, #8, #8
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
   11c74:	f8c5 e004 	str.w	lr, [r5, #4]
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
   11c78:	f3c2 2c85 	ubfx	ip, r2, #10, #6
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
   11c7c:	f885 8008 	strb.w	r8, [r5, #8]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
   11c80:	f3c2 2001 	ubfx	r0, r2, #8, #2
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
   11c84:	7269      	strb	r1, [r5, #9]
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
   11c86:	72ab      	strb	r3, [r5, #10]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
   11c88:	f3c2 1103 	ubfx	r1, r2, #4, #4
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
   11c8c:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
   11c90:	f002 020f 	and.w	r2, r2, #15
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c94:	81af      	strh	r7, [r5, #12]
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
   11c96:	f885 c00e 	strb.w	ip, [r5, #14]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
   11c9a:	73e8      	strb	r0, [r5, #15]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
   11c9c:	7429      	strb	r1, [r5, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
   11c9e:	746a      	strb	r2, [r5, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
   11ca0:	74ab      	strb	r3, [r5, #18]
   11ca2:	e756      	b.n	11b52 <HAL_SD_GetCardStatus+0x3e>
    return HAL_SD_ERROR_DATA_TIMEOUT;
   11ca4:	2008      	movs	r0, #8
   11ca6:	e74b      	b.n	11b40 <HAL_SD_GetCardStatus+0x2c>
    return HAL_SD_ERROR_DATA_CRC_FAIL;
   11ca8:	2002      	movs	r0, #2
   11caa:	e749      	b.n	11b40 <HAL_SD_GetCardStatus+0x2c>
    return HAL_SD_ERROR_RX_OVERRUN;
   11cac:	2020      	movs	r0, #32
   11cae:	e747      	b.n	11b40 <HAL_SD_GetCardStatus+0x2c>
   11cb0:	1fe00fff 	.word	0x1fe00fff
   11cb4:	18000f3a 	.word	0x18000f3a

00011cb8 <HAL_SD_GetCardInfo>:
{
   11cb8:	4603      	mov	r3, r0
}
   11cba:	2000      	movs	r0, #0
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
   11cbc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   11cbe:	600a      	str	r2, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
   11cc0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   11cc2:	604a      	str	r2, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
   11cc4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   11cc6:	608a      	str	r2, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
   11cc8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   11cca:	60ca      	str	r2, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
   11ccc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   11cce:	610a      	str	r2, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
   11cd0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   11cd2:	614a      	str	r2, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
   11cd4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   11cd6:	618a      	str	r2, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
   11cd8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   11cda:	61cb      	str	r3, [r1, #28]
}
   11cdc:	4770      	bx	lr
   11cde:	bf00      	nop

00011ce0 <HAL_SD_ConfigWideBusOperation>:
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
   11ce0:	f431 4380 	bics.w	r3, r1, #16384	; 0x4000
{
   11ce4:	b570      	push	{r4, r5, r6, lr}
   11ce6:	460d      	mov	r5, r1
   11ce8:	b08a      	sub	sp, #40	; 0x28
   11cea:	4604      	mov	r4, r0
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
   11cec:	d002      	beq.n	11cf4 <HAL_SD_ConfigWideBusOperation+0x14>
   11cee:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
   11cf2:	d152      	bne.n	11d9a <HAL_SD_ConfigWideBusOperation+0xba>
  hsd->State = HAL_SD_STATE_BUSY;
   11cf4:	2103      	movs	r1, #3
  if(hsd->SdCard.CardType != CARD_SECURED)
   11cf6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   11cf8:	6823      	ldr	r3, [r4, #0]
   11cfa:	428a      	cmp	r2, r1
  hsd->State = HAL_SD_STATE_BUSY;
   11cfc:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  if(hsd->SdCard.CardType != CARD_SECURED)
   11d00:	d025      	beq.n	11d4e <HAL_SD_ConfigWideBusOperation+0x6e>
    if(WideMode == SDMMC_BUS_WIDE_8B)
   11d02:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   11d06:	d022      	beq.n	11d4e <HAL_SD_ConfigWideBusOperation+0x6e>
    else if(WideMode == SDMMC_BUS_WIDE_4B)
   11d08:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
   11d0c:	d06b      	beq.n	11de6 <HAL_SD_ConfigWideBusOperation+0x106>
    else if(WideMode == SDMMC_BUS_WIDE_1B)
   11d0e:	2d00      	cmp	r5, #0
   11d10:	d049      	beq.n	11da6 <HAL_SD_ConfigWideBusOperation+0xc6>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   11d12:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   11d14:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
   11d18:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
   11d1a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   11d1c:	b9f2      	cbnz	r2, 11d5c <HAL_SD_ConfigWideBusOperation+0x7c>
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
   11d1e:	6962      	ldr	r2, [r4, #20]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
   11d20:	6921      	ldr	r1, [r4, #16]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
   11d22:	2a03      	cmp	r2, #3
    Init.BusWide             = WideMode;
   11d24:	9506      	str	r5, [sp, #24]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
   11d26:	9107      	str	r1, [sp, #28]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
   11d28:	e9d4 6001 	ldrd	r6, r0, [r4, #4]
   11d2c:	e9cd 6004 	strd	r6, r0, [sp, #16]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
   11d30:	d92a      	bls.n	11d88 <HAL_SD_ConfigWideBusOperation+0xa8>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
   11d32:	9208      	str	r2, [sp, #32]
    (void)SDMMC_Init(hsd->Instance, Init);
   11d34:	aa0a      	add	r2, sp, #40	; 0x28
   11d36:	ae04      	add	r6, sp, #16
  HAL_StatusTypeDef status = HAL_OK;
   11d38:	2500      	movs	r5, #0
    (void)SDMMC_Init(hsd->Instance, Init);
   11d3a:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   11d3e:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
   11d42:	4618      	mov	r0, r3
   11d44:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
   11d48:	f001 feda 	bl	13b00 <SDMMC_Init>
   11d4c:	e009      	b.n	11d62 <HAL_SD_ConfigWideBusOperation+0x82>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   11d4e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   11d50:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   11d54:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
   11d56:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   11d58:	2a00      	cmp	r2, #0
   11d5a:	d0e0      	beq.n	11d1e <HAL_SD_ConfigWideBusOperation+0x3e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11d5c:	4a36      	ldr	r2, [pc, #216]	; (11e38 <HAL_SD_ConfigWideBusOperation+0x158>)
    status = HAL_ERROR;
   11d5e:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11d60:	639a      	str	r2, [r3, #56]	; 0x38
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
   11d62:	f44f 7100 	mov.w	r1, #512	; 0x200
   11d66:	6820      	ldr	r0, [r4, #0]
   11d68:	f001 ffae 	bl	13cc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   11d6c:	b130      	cbz	r0, 11d7c <HAL_SD_ConfigWideBusOperation+0x9c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11d6e:	6823      	ldr	r3, [r4, #0]
    status = HAL_ERROR;
   11d70:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11d72:	4a31      	ldr	r2, [pc, #196]	; (11e38 <HAL_SD_ConfigWideBusOperation+0x158>)
   11d74:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
   11d76:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11d78:	4318      	orrs	r0, r3
   11d7a:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_READY;
   11d7c:	2301      	movs	r3, #1
}
   11d7e:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
   11d80:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
   11d84:	b00a      	add	sp, #40	; 0x28
   11d86:	bd70      	pop	{r4, r5, r6, pc}
    else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
   11d88:	6de1      	ldr	r1, [r4, #92]	; 0x5c
   11d8a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   11d8e:	d0d0      	beq.n	11d32 <HAL_SD_ConfigWideBusOperation+0x52>
    else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
   11d90:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   11d94:	d034      	beq.n	11e00 <HAL_SD_ConfigWideBusOperation+0x120>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
   11d96:	2204      	movs	r2, #4
   11d98:	e7cb      	b.n	11d32 <HAL_SD_ConfigWideBusOperation+0x52>
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
   11d9a:	f640 1149 	movw	r1, #2377	; 0x949
   11d9e:	4827      	ldr	r0, [pc, #156]	; (11e3c <HAL_SD_ConfigWideBusOperation+0x15c>)
   11da0:	f007 fb38 	bl	19414 <assert_failed>
   11da4:	e7a6      	b.n	11cf4 <HAL_SD_ConfigWideBusOperation+0x14>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11da6:	4629      	mov	r1, r5
   11da8:	4618      	mov	r0, r3
  uint32_t scr[2U] = {0UL, 0UL};
   11daa:	e9cd 5504 	strd	r5, r5, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11dae:	f001 ff1d 	bl	13bec <SDMMC_GetResponse>
   11db2:	0181      	lsls	r1, r0, #6
   11db4:	d420      	bmi.n	11df8 <HAL_SD_ConfigWideBusOperation+0x118>
  errorstate = SD_FindSCR(hsd, scr);
   11db6:	a904      	add	r1, sp, #16
   11db8:	4620      	mov	r0, r4
   11dba:	f7ff f9f7 	bl	111ac <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
   11dbe:	b968      	cbnz	r0, 11ddc <HAL_SD_ConfigWideBusOperation+0xfc>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
   11dc0:	9a05      	ldr	r2, [sp, #20]
   11dc2:	6823      	ldr	r3, [r4, #0]
   11dc4:	03d2      	lsls	r2, r2, #15
   11dc6:	d534      	bpl.n	11e32 <HAL_SD_ConfigWideBusOperation+0x152>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11dc8:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   11dca:	4618      	mov	r0, r3
   11dcc:	0409      	lsls	r1, r1, #16
   11dce:	f002 f9e5 	bl	1419c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   11dd2:	b918      	cbnz	r0, 11ddc <HAL_SD_ConfigWideBusOperation+0xfc>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
   11dd4:	4629      	mov	r1, r5
   11dd6:	6820      	ldr	r0, [r4, #0]
   11dd8:	f002 fa58 	bl	1428c <SDMMC_CmdBusWidth>
   11ddc:	6823      	ldr	r3, [r4, #0]
      hsd->ErrorCode |= errorstate;
   11dde:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   11de0:	4310      	orrs	r0, r2
   11de2:	63a0      	str	r0, [r4, #56]	; 0x38
   11de4:	e7b7      	b.n	11d56 <HAL_SD_ConfigWideBusOperation+0x76>
  uint32_t scr[2U] = {0UL, 0UL};
   11de6:	2200      	movs	r2, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11de8:	4618      	mov	r0, r3
   11dea:	4611      	mov	r1, r2
  uint32_t scr[2U] = {0UL, 0UL};
   11dec:	e9cd 2204 	strd	r2, r2, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11df0:	f001 fefc 	bl	13bec <SDMMC_GetResponse>
   11df4:	0186      	lsls	r6, r0, #6
   11df6:	d506      	bpl.n	11e06 <HAL_SD_ConfigWideBusOperation+0x126>
   11df8:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
   11dfa:	f44f 6000 	mov.w	r0, #2048	; 0x800
   11dfe:	e7ee      	b.n	11dde <HAL_SD_ConfigWideBusOperation+0xfe>
      Init.ClockDiv = SDMMC_HSpeed_CLK_DIV;
   11e00:	2202      	movs	r2, #2
   11e02:	9208      	str	r2, [sp, #32]
   11e04:	e796      	b.n	11d34 <HAL_SD_ConfigWideBusOperation+0x54>
  errorstate = SD_FindSCR(hsd, scr);
   11e06:	a904      	add	r1, sp, #16
   11e08:	4620      	mov	r0, r4
   11e0a:	f7ff f9cf 	bl	111ac <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
   11e0e:	2800      	cmp	r0, #0
   11e10:	d1e4      	bne.n	11ddc <HAL_SD_ConfigWideBusOperation+0xfc>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
   11e12:	9a05      	ldr	r2, [sp, #20]
   11e14:	6823      	ldr	r3, [r4, #0]
   11e16:	0350      	lsls	r0, r2, #13
   11e18:	d50b      	bpl.n	11e32 <HAL_SD_ConfigWideBusOperation+0x152>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11e1a:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   11e1c:	4618      	mov	r0, r3
   11e1e:	0409      	lsls	r1, r1, #16
   11e20:	f002 f9bc 	bl	1419c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   11e24:	2800      	cmp	r0, #0
   11e26:	d1d9      	bne.n	11ddc <HAL_SD_ConfigWideBusOperation+0xfc>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
   11e28:	2102      	movs	r1, #2
   11e2a:	6820      	ldr	r0, [r4, #0]
   11e2c:	f002 fa2e 	bl	1428c <SDMMC_CmdBusWidth>
   11e30:	e7d4      	b.n	11ddc <HAL_SD_ConfigWideBusOperation+0xfc>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
   11e32:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
   11e36:	e7d2      	b.n	11dde <HAL_SD_ConfigWideBusOperation+0xfe>
   11e38:	1fe00fff 	.word	0x1fe00fff
   11e3c:	0002ff14 	.word	0x0002ff14

00011e40 <HAL_SD_Init>:
{
   11e40:	b5f0      	push	{r4, r5, r6, r7, lr}
   11e42:	b087      	sub	sp, #28
  if(hsd == NULL)
   11e44:	2800      	cmp	r0, #0
   11e46:	d038      	beq.n	11eba <HAL_SD_Init+0x7a>
  assert_param(IS_SDMMC_ALL_INSTANCE(hsd->Instance));
   11e48:	6803      	ldr	r3, [r0, #0]
   11e4a:	4604      	mov	r4, r0
   11e4c:	4a5c      	ldr	r2, [pc, #368]	; (11fc0 <HAL_SD_Init+0x180>)
   11e4e:	4293      	cmp	r3, r2
   11e50:	d007      	beq.n	11e62 <HAL_SD_Init+0x22>
   11e52:	4a5c      	ldr	r2, [pc, #368]	; (11fc4 <HAL_SD_Init+0x184>)
   11e54:	4293      	cmp	r3, r2
   11e56:	d004      	beq.n	11e62 <HAL_SD_Init+0x22>
   11e58:	f240 115b 	movw	r1, #347	; 0x15b
   11e5c:	485a      	ldr	r0, [pc, #360]	; (11fc8 <HAL_SD_Init+0x188>)
   11e5e:	f007 fad9 	bl	19414 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_EDGE(hsd->Init.ClockEdge));
   11e62:	6863      	ldr	r3, [r4, #4]
   11e64:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
   11e68:	d17a      	bne.n	11f60 <HAL_SD_Init+0x120>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
   11e6a:	68a3      	ldr	r3, [r4, #8]
   11e6c:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   11e70:	d16c      	bne.n	11f4c <HAL_SD_Init+0x10c>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
   11e72:	68e3      	ldr	r3, [r4, #12]
   11e74:	f433 4280 	bics.w	r2, r3, #16384	; 0x4000
   11e78:	d003      	beq.n	11e82 <HAL_SD_Init+0x42>
   11e7a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   11e7e:	f040 8084 	bne.w	11f8a <HAL_SD_Init+0x14a>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
   11e82:	6923      	ldr	r3, [r4, #16]
   11e84:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
   11e88:	d175      	bne.n	11f76 <HAL_SD_Init+0x136>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
   11e8a:	6963      	ldr	r3, [r4, #20]
   11e8c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   11e90:	d250      	bcs.n	11f34 <HAL_SD_Init+0xf4>
  if(hsd->State == HAL_SD_STATE_RESET)
   11e92:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
   11e96:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   11e9a:	b93b      	cbnz	r3, 11eac <HAL_SD_Init+0x6c>
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_UNKNOWN)
   11e9c:	69a3      	ldr	r3, [r4, #24]
    hsd->Lock = HAL_UNLOCKED;
   11e9e:	7722      	strb	r2, [r4, #28]
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_UNKNOWN)
   11ea0:	b90b      	cbnz	r3, 11ea6 <HAL_SD_Init+0x66>
      hsd->Init.TranceiverPresent = SDMMC_TRANSCEIVER_PRESENT;
   11ea2:	2302      	movs	r3, #2
   11ea4:	61a3      	str	r3, [r4, #24]
    HAL_SD_MspInit(hsd);
   11ea6:	4620      	mov	r0, r4
   11ea8:	f008 f97e 	bl	1a1a8 <HAL_SD_MspInit>
  hsd->State = HAL_SD_STATE_BUSY;
   11eac:	2303      	movs	r3, #3
  if (HAL_SD_InitCard(hsd) != HAL_OK)
   11eae:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_BUSY;
   11eb0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
   11eb4:	f7ff fcba 	bl	1182c <HAL_SD_InitCard>
   11eb8:	b118      	cbz	r0, 11ec2 <HAL_SD_Init+0x82>
    return HAL_ERROR;
   11eba:	2501      	movs	r5, #1
}
   11ebc:	4628      	mov	r0, r5
   11ebe:	b007      	add	sp, #28
   11ec0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
   11ec2:	a901      	add	r1, sp, #4
   11ec4:	4620      	mov	r0, r4
   11ec6:	f7ff fe25 	bl	11b14 <HAL_SD_GetCardStatus>
   11eca:	2800      	cmp	r0, #0
   11ecc:	d1f5      	bne.n	11eba <HAL_SD_Init+0x7a>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   11ece:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  speedgrade = CardStatus.UhsSpeedGrade;
   11ed0:	f89d 2014 	ldrb.w	r2, [sp, #20]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   11ed4:	2901      	cmp	r1, #1
  unitsize = CardStatus.UhsAllocationUnitSize;
   11ed6:	f89d 3015 	ldrb.w	r3, [sp, #21]
  speedgrade = CardStatus.UhsSpeedGrade;
   11eda:	b2d2      	uxtb	r2, r2
  unitsize = CardStatus.UhsAllocationUnitSize;
   11edc:	b2db      	uxtb	r3, r3
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   11ede:	d05f      	beq.n	11fa0 <HAL_SD_Init+0x160>
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
   11ee0:	65e0      	str	r0, [r4, #92]	; 0x5c
  if(HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
   11ee2:	68e1      	ldr	r1, [r4, #12]
   11ee4:	4620      	mov	r0, r4
   11ee6:	f7ff fefb 	bl	11ce0 <HAL_SD_ConfigWideBusOperation>
   11eea:	4605      	mov	r5, r0
   11eec:	2800      	cmp	r0, #0
   11eee:	d1e4      	bne.n	11eba <HAL_SD_Init+0x7a>
  tickstart = HAL_GetTick();
   11ef0:	f7f6 fa80 	bl	83f4 <HAL_GetTick>
   11ef4:	4607      	mov	r7, r0
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
   11ef6:	e007      	b.n	11f08 <HAL_SD_Init+0xc8>
    hsd->ErrorCode |= errorstate;
   11ef8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11efa:	431e      	orrs	r6, r3
   11efc:	63a6      	str	r6, [r4, #56]	; 0x38
    if((HAL_GetTick()-tickstart) >=  SDMMC_DATATIMEOUT)
   11efe:	f7f6 fa79 	bl	83f4 <HAL_GetTick>
   11f02:	1bc0      	subs	r0, r0, r7
   11f04:	3001      	adds	r0, #1
   11f06:	d053      	beq.n	11fb0 <HAL_SD_Init+0x170>
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11f08:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   11f0a:	6820      	ldr	r0, [r4, #0]
   11f0c:	0409      	lsls	r1, r1, #16
   11f0e:	f002 fb0d 	bl	1452c <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
   11f12:	4606      	mov	r6, r0
   11f14:	2800      	cmp	r0, #0
   11f16:	d1ef      	bne.n	11ef8 <HAL_SD_Init+0xb8>
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11f18:	4601      	mov	r1, r0
   11f1a:	6820      	ldr	r0, [r4, #0]
   11f1c:	f001 fe66 	bl	13bec <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
   11f20:	f3c0 2043 	ubfx	r0, r0, #9, #4
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
   11f24:	2804      	cmp	r0, #4
   11f26:	d1ea      	bne.n	11efe <HAL_SD_Init+0xbe>
  hsd->State = HAL_SD_STATE_READY;
   11f28:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
   11f2a:	63a6      	str	r6, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
   11f2c:	6326      	str	r6, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
   11f2e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
   11f32:	e7c3      	b.n	11ebc <HAL_SD_Init+0x7c>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
   11f34:	f44f 71b0 	mov.w	r1, #352	; 0x160
   11f38:	4823      	ldr	r0, [pc, #140]	; (11fc8 <HAL_SD_Init+0x188>)
   11f3a:	f007 fa6b 	bl	19414 <assert_failed>
  if(hsd->State == HAL_SD_STATE_RESET)
   11f3e:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
   11f42:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   11f46:	2b00      	cmp	r3, #0
   11f48:	d1b0      	bne.n	11eac <HAL_SD_Init+0x6c>
   11f4a:	e7a7      	b.n	11e9c <HAL_SD_Init+0x5c>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
   11f4c:	f240 115d 	movw	r1, #349	; 0x15d
   11f50:	481d      	ldr	r0, [pc, #116]	; (11fc8 <HAL_SD_Init+0x188>)
   11f52:	f007 fa5f 	bl	19414 <assert_failed>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
   11f56:	68e3      	ldr	r3, [r4, #12]
   11f58:	f433 4280 	bics.w	r2, r3, #16384	; 0x4000
   11f5c:	d18d      	bne.n	11e7a <HAL_SD_Init+0x3a>
   11f5e:	e790      	b.n	11e82 <HAL_SD_Init+0x42>
  assert_param(IS_SDMMC_CLOCK_EDGE(hsd->Init.ClockEdge));
   11f60:	f44f 71ae 	mov.w	r1, #348	; 0x15c
   11f64:	4818      	ldr	r0, [pc, #96]	; (11fc8 <HAL_SD_Init+0x188>)
   11f66:	f007 fa55 	bl	19414 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
   11f6a:	68a3      	ldr	r3, [r4, #8]
   11f6c:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   11f70:	f43f af7f 	beq.w	11e72 <HAL_SD_Init+0x32>
   11f74:	e7ea      	b.n	11f4c <HAL_SD_Init+0x10c>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
   11f76:	f240 115f 	movw	r1, #351	; 0x15f
   11f7a:	4813      	ldr	r0, [pc, #76]	; (11fc8 <HAL_SD_Init+0x188>)
   11f7c:	f007 fa4a 	bl	19414 <assert_failed>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
   11f80:	6963      	ldr	r3, [r4, #20]
   11f82:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   11f86:	d384      	bcc.n	11e92 <HAL_SD_Init+0x52>
   11f88:	e7d4      	b.n	11f34 <HAL_SD_Init+0xf4>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
   11f8a:	f44f 71af 	mov.w	r1, #350	; 0x15e
   11f8e:	480e      	ldr	r0, [pc, #56]	; (11fc8 <HAL_SD_Init+0x188>)
   11f90:	f007 fa40 	bl	19414 <assert_failed>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
   11f94:	6923      	ldr	r3, [r4, #16]
   11f96:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
   11f9a:	f43f af76 	beq.w	11e8a <HAL_SD_Init+0x4a>
   11f9e:	e7ea      	b.n	11f76 <HAL_SD_Init+0x136>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   11fa0:	4313      	orrs	r3, r2
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
   11fa2:	bf14      	ite	ne
   11fa4:	f44f 7300 	movne.w	r3, #512	; 0x200
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
   11fa8:	f44f 7380 	moveq.w	r3, #256	; 0x100
   11fac:	65e3      	str	r3, [r4, #92]	; 0x5c
   11fae:	e798      	b.n	11ee2 <HAL_SD_Init+0xa2>
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
   11fb0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
      hsd->State= HAL_SD_STATE_READY;
   11fb4:	2301      	movs	r3, #1
      return HAL_TIMEOUT;
   11fb6:	2503      	movs	r5, #3
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
   11fb8:	63a2      	str	r2, [r4, #56]	; 0x38
      hsd->State= HAL_SD_STATE_READY;
   11fba:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return HAL_TIMEOUT;
   11fbe:	e77d      	b.n	11ebc <HAL_SD_Init+0x7c>
   11fc0:	52007000 	.word	0x52007000
   11fc4:	48022400 	.word	0x48022400
   11fc8:	0002ff14 	.word	0x0002ff14

00011fcc <HAL_SD_GetCardState>:
{
   11fcc:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11fce:	6c81      	ldr	r1, [r0, #72]	; 0x48
{
   11fd0:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11fd2:	6800      	ldr	r0, [r0, #0]
   11fd4:	0409      	lsls	r1, r1, #16
   11fd6:	f002 faa9 	bl	1452c <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
   11fda:	4601      	mov	r1, r0
   11fdc:	b120      	cbz	r0, 11fe8 <HAL_SD_GetCardState+0x1c>
    hsd->ErrorCode |= errorstate;
   11fde:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11fe0:	2000      	movs	r0, #0
   11fe2:	4319      	orrs	r1, r3
   11fe4:	63a1      	str	r1, [r4, #56]	; 0x38
}
   11fe6:	bd10      	pop	{r4, pc}
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11fe8:	6820      	ldr	r0, [r4, #0]
   11fea:	f001 fdff 	bl	13bec <SDMMC_GetResponse>
   11fee:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
   11ff2:	bd10      	pop	{r4, pc}

00011ff4 <HAL_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{
  /* Check the SDRAM handle parameter */
  if (hsdram == NULL)
   11ff4:	b310      	cbz	r0, 1203c <HAL_SDRAM_Init+0x48>
{
   11ff6:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }

  if (hsdram->State == HAL_SDRAM_STATE_RESET)
   11ff8:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   11ffc:	4604      	mov	r4, r0
   11ffe:	460d      	mov	r5, r1
   12000:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   12004:	b1ab      	cbz	r3, 12032 <HAL_SDRAM_Init+0x3e>
    HAL_SDRAM_MspInit(hsdram);
#endif
  }

  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
   12006:	2302      	movs	r3, #2

  /* Initialize SDRAM control Interface */
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
   12008:	1d21      	adds	r1, r4, #4
   1200a:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
   1200c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
   12010:	f001 fb3a 	bl	13688 <FMC_SDRAM_Init>

  /* Initialize SDRAM timing Interface */
  (void)FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
   12014:	4629      	mov	r1, r5
   12016:	e9d4 0200 	ldrd	r0, r2, [r4]
   1201a:	f001 fbf9 	bl	13810 <FMC_SDRAM_Timing_Init>

  /* Enable FMC Peripheral */
  __FMC_ENABLE();
   1201e:	4a08      	ldr	r2, [pc, #32]	; (12040 <HAL_SDRAM_Init+0x4c>)
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
   12020:	2101      	movs	r1, #1

  return HAL_OK;
   12022:	2000      	movs	r0, #0
  __FMC_ENABLE();
   12024:	6813      	ldr	r3, [r2, #0]
   12026:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1202a:	6013      	str	r3, [r2, #0]
  hsdram->State = HAL_SDRAM_STATE_READY;
   1202c:	f884 102c 	strb.w	r1, [r4, #44]	; 0x2c
}
   12030:	bd38      	pop	{r3, r4, r5, pc}
    hsdram->Lock = HAL_UNLOCKED;
   12032:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    HAL_SDRAM_MspInit(hsdram);
   12036:	f005 fe6b 	bl	17d10 <HAL_SDRAM_MspInit>
   1203a:	e7e4      	b.n	12006 <HAL_SDRAM_Init+0x12>
    return HAL_ERROR;
   1203c:	2001      	movs	r0, #1
}
   1203e:	4770      	bx	lr
   12040:	52004000 	.word	0x52004000

00012044 <HAL_SDRAM_SendCommand>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  HAL_SDRAM_StateTypeDef state = hsdram->State;
   12044:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   12048:	b2db      	uxtb	r3, r3
  
  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
   1204a:	2b02      	cmp	r3, #2
   1204c:	d015      	beq.n	1207a <HAL_SDRAM_SendCommand+0x36>
{
   1204e:	b570      	push	{r4, r5, r6, lr}
  {
    return HAL_BUSY;
  }
  else if((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_PRECHARGED))
   12050:	f003 04fb 	and.w	r4, r3, #251	; 0xfb
   12054:	2c01      	cmp	r4, #1
   12056:	d001      	beq.n	1205c <HAL_SDRAM_SendCommand+0x18>
      hsdram->State = HAL_SDRAM_STATE_READY;
    }
  }
  else
  {
    return HAL_ERROR;
   12058:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
   1205a:	bd70      	pop	{r4, r5, r6, pc}
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   1205c:	2302      	movs	r3, #2
   1205e:	4605      	mov	r5, r0
   12060:	460e      	mov	r6, r1
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
   12062:	6800      	ldr	r0, [r0, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   12064:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
   12068:	f001 fc7a 	bl	13960 <FMC_SDRAM_SendCommand>
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
   1206c:	6833      	ldr	r3, [r6, #0]
   1206e:	2b02      	cmp	r3, #2
   12070:	d005      	beq.n	1207e <HAL_SDRAM_SendCommand+0x3a>
      hsdram->State = HAL_SDRAM_STATE_READY;
   12072:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
  return HAL_OK;
   12076:	2000      	movs	r0, #0
}
   12078:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
   1207a:	4618      	mov	r0, r3
}
   1207c:	4770      	bx	lr
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
   1207e:	2305      	movs	r3, #5
  return HAL_OK;
   12080:	2000      	movs	r0, #0
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
   12082:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
}
   12086:	bd70      	pop	{r4, r5, r6, pc}

00012088 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
   12088:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
   1208a:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   1208e:	b2db      	uxtb	r3, r3
   12090:	2b02      	cmp	r3, #2
   12092:	d006      	beq.n	120a2 <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
   12094:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
   12098:	b2ed      	uxtb	r5, r5
   1209a:	2d01      	cmp	r5, #1
   1209c:	d003      	beq.n	120a6 <HAL_SDRAM_ProgramRefreshRate+0x1e>
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_READY;
  }
  else
  {
    return HAL_ERROR;
   1209e:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
   120a0:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_BUSY;
   120a2:	4618      	mov	r0, r3
}
   120a4:	bd38      	pop	{r3, r4, r5, pc}
   120a6:	4604      	mov	r4, r0
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   120a8:	2302      	movs	r3, #2
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
   120aa:	6800      	ldr	r0, [r0, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   120ac:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
   120b0:	f001 fca0 	bl	139f4 <FMC_SDRAM_ProgramRefreshRate>
    hsdram->State = HAL_SDRAM_STATE_READY;
   120b4:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
  return HAL_OK;
   120b8:	2000      	movs	r0, #0
}
   120ba:	bd38      	pop	{r3, r4, r5, pc}

000120bc <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
   120bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
   120c0:	6a02      	ldr	r2, [r0, #32]
{
   120c2:	460f      	mov	r7, r1
   120c4:	4604      	mov	r4, r0
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
   120c6:	4b3b      	ldr	r3, [pc, #236]	; (121b4 <TIM_OC1_SetConfig+0xf8>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
   120c8:	f022 0201 	bic.w	r2, r2, #1
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   120cc:	493a      	ldr	r1, [pc, #232]	; (121b8 <TIM_OC1_SetConfig+0xfc>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
   120ce:	6202      	str	r2, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   120d0:	428c      	cmp	r4, r1
  tmpccer = TIMx->CCER;
   120d2:	6a05      	ldr	r5, [r0, #32]
  tmpcr2 =  TIMx->CR2;
   120d4:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
   120d8:	6980      	ldr	r0, [r0, #24]
  tmpccer &= ~TIM_CCER_CC1P;
   120da:	f025 0502 	bic.w	r5, r5, #2
  tmpccer |= OC_Config->OCPolarity;
   120de:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
   120e0:	ea03 0300 	and.w	r3, r3, r0
  tmpccmrx |= OC_Config->OCMode;
   120e4:	683e      	ldr	r6, [r7, #0]
  tmpccer |= OC_Config->OCPolarity;
   120e6:	ea45 0502 	orr.w	r5, r5, r2
  tmpccmrx |= OC_Config->OCMode;
   120ea:	ea46 0603 	orr.w	r6, r6, r3
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   120ee:	d03a      	beq.n	12166 <TIM_OC1_SetConfig+0xaa>
   120f0:	4b32      	ldr	r3, [pc, #200]	; (121bc <TIM_OC1_SetConfig+0x100>)
   120f2:	429c      	cmp	r4, r3
   120f4:	d037      	beq.n	12166 <TIM_OC1_SetConfig+0xaa>
   120f6:	4a32      	ldr	r2, [pc, #200]	; (121c0 <TIM_OC1_SetConfig+0x104>)
   120f8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   120fc:	429c      	cmp	r4, r3
   120fe:	bf18      	it	ne
   12100:	4294      	cmpne	r4, r2
   12102:	d003      	beq.n	1210c <TIM_OC1_SetConfig+0x50>
   12104:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12108:	429c      	cmp	r4, r3
   1210a:	d144      	bne.n	12196 <TIM_OC1_SetConfig+0xda>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   1210c:	68fb      	ldr	r3, [r7, #12]
   1210e:	f025 0508 	bic.w	r5, r5, #8
   12112:	f033 0208 	bics.w	r2, r3, #8
   12116:	d02c      	beq.n	12172 <TIM_OC1_SetConfig+0xb6>
   12118:	f641 0106 	movw	r1, #6150	; 0x1806
   1211c:	4829      	ldr	r0, [pc, #164]	; (121c4 <TIM_OC1_SetConfig+0x108>)
   1211e:	f007 f979 	bl	19414 <assert_failed>

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
   12122:	68fb      	ldr	r3, [r7, #12]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
   12124:	4a26      	ldr	r2, [pc, #152]	; (121c0 <TIM_OC1_SetConfig+0x104>)
    tmpccer |= OC_Config->OCNPolarity;
   12126:	431d      	orrs	r5, r3
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   12128:	4b27      	ldr	r3, [pc, #156]	; (121c8 <TIM_OC1_SetConfig+0x10c>)
   1212a:	429c      	cmp	r4, r3
   1212c:	bf18      	it	ne
   1212e:	4294      	cmpne	r4, r2
    tmpccer &= ~TIM_CCER_CC1NE;
   12130:	f025 0504 	bic.w	r5, r5, #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   12134:	d020      	beq.n	12178 <TIM_OC1_SetConfig+0xbc>
   12136:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   1213a:	429c      	cmp	r4, r3
   1213c:	d12b      	bne.n	12196 <TIM_OC1_SetConfig+0xda>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   1213e:	69bb      	ldr	r3, [r7, #24]
   12140:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   12144:	d01c      	beq.n	12180 <TIM_OC1_SetConfig+0xc4>
   12146:	f641 0113 	movw	r1, #6163	; 0x1813
   1214a:	481e      	ldr	r0, [pc, #120]	; (121c4 <TIM_OC1_SetConfig+0x108>)
   1214c:	f007 f962 	bl	19414 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   12150:	697b      	ldr	r3, [r7, #20]
   12152:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   12156:	d017      	beq.n	12188 <TIM_OC1_SetConfig+0xcc>
   12158:	f641 0114 	movw	r1, #6164	; 0x1814
   1215c:	4819      	ldr	r0, [pc, #100]	; (121c4 <TIM_OC1_SetConfig+0x108>)
   1215e:	f007 f959 	bl	19414 <assert_failed>
   12162:	697b      	ldr	r3, [r7, #20]
   12164:	e010      	b.n	12188 <TIM_OC1_SetConfig+0xcc>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   12166:	68fb      	ldr	r3, [r7, #12]
   12168:	f025 0508 	bic.w	r5, r5, #8
   1216c:	f033 0208 	bics.w	r2, r3, #8
   12170:	d119      	bne.n	121a6 <TIM_OC1_SetConfig+0xea>
    tmpccer |= OC_Config->OCNPolarity;
   12172:	431d      	orrs	r5, r3
    tmpccer &= ~TIM_CCER_CC1NE;
   12174:	f025 0504 	bic.w	r5, r5, #4
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   12178:	69bb      	ldr	r3, [r7, #24]
   1217a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   1217e:	d1e2      	bne.n	12146 <TIM_OC1_SetConfig+0x8a>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   12180:	697b      	ldr	r3, [r7, #20]
   12182:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   12186:	d1e7      	bne.n	12158 <TIM_OC1_SetConfig+0x9c>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
   12188:	f428 7840 	bic.w	r8, r8, #768	; 0x300
   1218c:	69ba      	ldr	r2, [r7, #24]
   1218e:	ea48 0802 	orr.w	r8, r8, r2
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
   12192:	ea48 0803 	orr.w	r8, r8, r3
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
   12196:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
   1219a:	61a6      	str	r6, [r4, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
   1219c:	687b      	ldr	r3, [r7, #4]
   1219e:	6363      	str	r3, [r4, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
   121a0:	6225      	str	r5, [r4, #32]
}
   121a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   121a6:	f641 0106 	movw	r1, #6150	; 0x1806
   121aa:	4806      	ldr	r0, [pc, #24]	; (121c4 <TIM_OC1_SetConfig+0x108>)
   121ac:	f007 f932 	bl	19414 <assert_failed>
    tmpccer |= OC_Config->OCNPolarity;
   121b0:	68fb      	ldr	r3, [r7, #12]
   121b2:	e7de      	b.n	12172 <TIM_OC1_SetConfig+0xb6>
   121b4:	fffeff8c 	.word	0xfffeff8c
   121b8:	40010000 	.word	0x40010000
   121bc:	40010400 	.word	0x40010400
   121c0:	40014000 	.word	0x40014000
   121c4:	0002ff4c 	.word	0x0002ff4c
   121c8:	40014400 	.word	0x40014400

000121cc <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
   121cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
   121d0:	6a03      	ldr	r3, [r0, #32]
{
   121d2:	460f      	mov	r7, r1
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   121d4:	4931      	ldr	r1, [pc, #196]	; (1229c <TIM_OC3_SetConfig+0xd0>)
{
   121d6:	4604      	mov	r4, r0
  TIMx->CCER &= ~TIM_CCER_CC3E;
   121d8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   121dc:	4288      	cmp	r0, r1
  TIMx->CCER &= ~TIM_CCER_CC3E;
   121de:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
   121e0:	6a05      	ldr	r5, [r0, #32]
  tmpcr2 =  TIMx->CR2;
   121e2:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
   121e6:	69c6      	ldr	r6, [r0, #28]
  tmpccer &= ~TIM_CCER_CC3P;
   121e8:	f425 7500 	bic.w	r5, r5, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
   121ec:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
   121ee:	f026 0673 	bic.w	r6, r6, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
   121f2:	683b      	ldr	r3, [r7, #0]
  tmpccer |= (OC_Config->OCPolarity << 8U);
   121f4:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
  tmpccmrx |= OC_Config->OCMode;
   121f8:	ea46 0603 	orr.w	r6, r6, r3
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   121fc:	d023      	beq.n	12246 <TIM_OC3_SetConfig+0x7a>
   121fe:	4b28      	ldr	r3, [pc, #160]	; (122a0 <TIM_OC3_SetConfig+0xd4>)
   12200:	4298      	cmp	r0, r3
   12202:	d020      	beq.n	12246 <TIM_OC3_SetConfig+0x7a>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
   12204:	4a27      	ldr	r2, [pc, #156]	; (122a4 <TIM_OC3_SetConfig+0xd8>)
   12206:	4b28      	ldr	r3, [pc, #160]	; (122a8 <TIM_OC3_SetConfig+0xdc>)
   12208:	4298      	cmp	r0, r3
   1220a:	bf18      	it	ne
   1220c:	4290      	cmpne	r0, r2
   1220e:	d003      	beq.n	12218 <TIM_OC3_SetConfig+0x4c>
   12210:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12214:	4298      	cmp	r0, r3
   12216:	d10e      	bne.n	12236 <TIM_OC3_SetConfig+0x6a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   12218:	69bb      	ldr	r3, [r7, #24]
   1221a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   1221e:	d120      	bne.n	12262 <TIM_OC3_SetConfig+0x96>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   12220:	697b      	ldr	r3, [r7, #20]
   12222:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   12226:	d125      	bne.n	12274 <TIM_OC3_SetConfig+0xa8>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
   12228:	f428 5840 	bic.w	r8, r8, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   1222c:	69ba      	ldr	r2, [r7, #24]
   1222e:	ea48 1802 	orr.w	r8, r8, r2, lsl #4
   12232:	ea48 1803 	orr.w	r8, r8, r3, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
   12236:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
   1223a:	61e6      	str	r6, [r4, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
   1223c:	687b      	ldr	r3, [r7, #4]
   1223e:	63e3      	str	r3, [r4, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
   12240:	6225      	str	r5, [r4, #32]
}
   12242:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   12246:	68fb      	ldr	r3, [r7, #12]
   12248:	f033 0208 	bics.w	r2, r3, #8
   1224c:	d119      	bne.n	12282 <TIM_OC3_SetConfig+0xb6>
    tmpccer &= ~TIM_CCER_CC3NP;
   1224e:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
   12252:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
   12256:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   1225a:	69bb      	ldr	r3, [r7, #24]
   1225c:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   12260:	d0de      	beq.n	12220 <TIM_OC3_SetConfig+0x54>
   12262:	f641 01a9 	movw	r1, #6313	; 0x18a9
   12266:	4811      	ldr	r0, [pc, #68]	; (122ac <TIM_OC3_SetConfig+0xe0>)
   12268:	f007 f8d4 	bl	19414 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   1226c:	697b      	ldr	r3, [r7, #20]
   1226e:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   12272:	d0d9      	beq.n	12228 <TIM_OC3_SetConfig+0x5c>
   12274:	f641 01aa 	movw	r1, #6314	; 0x18aa
   12278:	480c      	ldr	r0, [pc, #48]	; (122ac <TIM_OC3_SetConfig+0xe0>)
   1227a:	f007 f8cb 	bl	19414 <assert_failed>
   1227e:	697b      	ldr	r3, [r7, #20]
   12280:	e7d2      	b.n	12228 <TIM_OC3_SetConfig+0x5c>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   12282:	f641 019c 	movw	r1, #6300	; 0x189c
   12286:	4809      	ldr	r0, [pc, #36]	; (122ac <TIM_OC3_SetConfig+0xe0>)
   12288:	f007 f8c4 	bl	19414 <assert_failed>
    tmpccer &= ~TIM_CCER_CC3NP;
   1228c:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
   12290:	68fb      	ldr	r3, [r7, #12]
    tmpccer |= (OC_Config->OCNPolarity << 8U);
   12292:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
   12296:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
   1229a:	e7de      	b.n	1225a <TIM_OC3_SetConfig+0x8e>
   1229c:	40010000 	.word	0x40010000
   122a0:	40010400 	.word	0x40010400
   122a4:	40014000 	.word	0x40014000
   122a8:	40014400 	.word	0x40014400
   122ac:	0002ff4c 	.word	0x0002ff4c

000122b0 <HAL_TIM_Base_Init>:
  if (htim == NULL)
   122b0:	2800      	cmp	r0, #0
   122b2:	f000 80dd 	beq.w	12470 <HAL_TIM_Base_Init+0x1c0>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   122b6:	4b80      	ldr	r3, [pc, #512]	; (124b8 <HAL_TIM_Base_Init+0x208>)
   122b8:	4980      	ldr	r1, [pc, #512]	; (124bc <HAL_TIM_Base_Init+0x20c>)
{
   122ba:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   122bc:	6802      	ldr	r2, [r0, #0]
   122be:	4604      	mov	r4, r0
   122c0:	487f      	ldr	r0, [pc, #508]	; (124c0 <HAL_TIM_Base_Init+0x210>)
   122c2:	429a      	cmp	r2, r3
   122c4:	bf18      	it	ne
   122c6:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   122ca:	4d7e      	ldr	r5, [pc, #504]	; (124c4 <HAL_TIM_Base_Init+0x214>)
   122cc:	bf14      	ite	ne
   122ce:	2301      	movne	r3, #1
   122d0:	2300      	moveq	r3, #0
   122d2:	4282      	cmp	r2, r0
   122d4:	bf0c      	ite	eq
   122d6:	2300      	moveq	r3, #0
   122d8:	f003 0301 	andne.w	r3, r3, #1
   122dc:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
   122e0:	428a      	cmp	r2, r1
   122e2:	bf0c      	ite	eq
   122e4:	2300      	moveq	r3, #0
   122e6:	f003 0301 	andne.w	r3, r3, #1
   122ea:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
   122ee:	42aa      	cmp	r2, r5
   122f0:	bf0c      	ite	eq
   122f2:	2300      	moveq	r3, #0
   122f4:	f003 0301 	andne.w	r3, r3, #1
   122f8:	f505 4578 	add.w	r5, r5, #63488	; 0xf800
   122fc:	4282      	cmp	r2, r0
   122fe:	bf0c      	ite	eq
   12300:	2300      	moveq	r3, #0
   12302:	f003 0301 	andne.w	r3, r3, #1
   12306:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   1230a:	428a      	cmp	r2, r1
   1230c:	bf0c      	ite	eq
   1230e:	2300      	moveq	r3, #0
   12310:	f003 0301 	andne.w	r3, r3, #1
   12314:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   12318:	42aa      	cmp	r2, r5
   1231a:	bf0c      	ite	eq
   1231c:	2300      	moveq	r3, #0
   1231e:	f003 0301 	andne.w	r3, r3, #1
   12322:	f5a5 4564 	sub.w	r5, r5, #58368	; 0xe400
   12326:	4282      	cmp	r2, r0
   12328:	bf0c      	ite	eq
   1232a:	2300      	moveq	r3, #0
   1232c:	f003 0301 	andne.w	r3, r3, #1
   12330:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
   12334:	428a      	cmp	r2, r1
   12336:	bf0c      	ite	eq
   12338:	2300      	moveq	r3, #0
   1233a:	f003 0301 	andne.w	r3, r3, #1
   1233e:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
   12342:	42aa      	cmp	r2, r5
   12344:	bf0c      	ite	eq
   12346:	2300      	moveq	r3, #0
   12348:	f003 0301 	andne.w	r3, r3, #1
   1234c:	4282      	cmp	r2, r0
   1234e:	bf0c      	ite	eq
   12350:	2300      	moveq	r3, #0
   12352:	f003 0301 	andne.w	r3, r3, #1
   12356:	428a      	cmp	r2, r1
   12358:	bf0c      	ite	eq
   1235a:	2300      	moveq	r3, #0
   1235c:	f003 0301 	andne.w	r3, r3, #1
   12360:	b11b      	cbz	r3, 1236a <HAL_TIM_Base_Init+0xba>
   12362:	4b59      	ldr	r3, [pc, #356]	; (124c8 <HAL_TIM_Base_Init+0x218>)
   12364:	429a      	cmp	r2, r3
   12366:	f040 80a0 	bne.w	124aa <HAL_TIM_Base_Init+0x1fa>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1236a:	68a3      	ldr	r3, [r4, #8]
   1236c:	f023 0140 	bic.w	r1, r3, #64	; 0x40
   12370:	f023 0210 	bic.w	r2, r3, #16
   12374:	2920      	cmp	r1, #32
   12376:	bf18      	it	ne
   12378:	2a00      	cmpne	r2, #0
   1237a:	d002      	beq.n	12382 <HAL_TIM_Base_Init+0xd2>
   1237c:	2b40      	cmp	r3, #64	; 0x40
   1237e:	f040 8083 	bne.w	12488 <HAL_TIM_Base_Init+0x1d8>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   12382:	6923      	ldr	r3, [r4, #16]
   12384:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   12388:	d002      	beq.n	12390 <HAL_TIM_Base_Init+0xe0>
   1238a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1238e:	d171      	bne.n	12474 <HAL_TIM_Base_Init+0x1c4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   12390:	69a3      	ldr	r3, [r4, #24]
   12392:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   12396:	d15f      	bne.n	12458 <HAL_TIM_Base_Init+0x1a8>
  if (htim->State == HAL_TIM_STATE_RESET)
   12398:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   1239c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   123a0:	2b00      	cmp	r3, #0
   123a2:	d053      	beq.n	1244c <HAL_TIM_Base_Init+0x19c>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
   123a4:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
   123a6:	2302      	movs	r3, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   123a8:	4943      	ldr	r1, [pc, #268]	; (124b8 <HAL_TIM_Base_Init+0x208>)
   123aa:	4d48      	ldr	r5, [pc, #288]	; (124cc <HAL_TIM_Base_Init+0x21c>)
   123ac:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   123b0:	eba2 0101 	sub.w	r1, r2, r1
  htim->State = HAL_TIM_STATE_BUSY;
   123b4:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
   123b8:	eba2 0505 	sub.w	r5, r2, r5
  tmpcr1 = TIMx->CR1;
   123bc:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   123be:	fab1 f181 	clz	r1, r1
   123c2:	fab5 f585 	clz	r5, r5
   123c6:	ea4f 1151 	mov.w	r1, r1, lsr #5
   123ca:	ea4f 1555 	mov.w	r5, r5, lsr #5
   123ce:	d018      	beq.n	12402 <HAL_TIM_Base_Init+0x152>
   123d0:	b9b9      	cbnz	r1, 12402 <HAL_TIM_Base_Init+0x152>
   123d2:	483b      	ldr	r0, [pc, #236]	; (124c0 <HAL_TIM_Base_Init+0x210>)
   123d4:	4282      	cmp	r2, r0
   123d6:	d014      	beq.n	12402 <HAL_TIM_Base_Init+0x152>
   123d8:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   123dc:	4282      	cmp	r2, r0
   123de:	d010      	beq.n	12402 <HAL_TIM_Base_Init+0x152>
   123e0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   123e4:	4282      	cmp	r2, r0
   123e6:	d055      	beq.n	12494 <HAL_TIM_Base_Init+0x1e4>
   123e8:	2d00      	cmp	r5, #0
   123ea:	d153      	bne.n	12494 <HAL_TIM_Base_Init+0x1e4>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   123ec:	4e38      	ldr	r6, [pc, #224]	; (124d0 <HAL_TIM_Base_Init+0x220>)
   123ee:	4839      	ldr	r0, [pc, #228]	; (124d4 <HAL_TIM_Base_Init+0x224>)
   123f0:	4282      	cmp	r2, r0
   123f2:	bf18      	it	ne
   123f4:	42b2      	cmpne	r2, r6
   123f6:	d008      	beq.n	1240a <HAL_TIM_Base_Init+0x15a>
   123f8:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   123fc:	4282      	cmp	r2, r0
   123fe:	d108      	bne.n	12412 <HAL_TIM_Base_Init+0x162>
   12400:	e003      	b.n	1240a <HAL_TIM_Base_Init+0x15a>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   12402:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   12406:	68a0      	ldr	r0, [r4, #8]
   12408:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
   1240a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
   1240e:	6920      	ldr	r0, [r4, #16]
   12410:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   12412:	69a0      	ldr	r0, [r4, #24]
   12414:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   12418:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
   1241a:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
   1241c:	68e3      	ldr	r3, [r4, #12]
   1241e:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
   12420:	6863      	ldr	r3, [r4, #4]
   12422:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   12424:	b951      	cbnz	r1, 1243c <HAL_TIM_Base_Init+0x18c>
   12426:	b94d      	cbnz	r5, 1243c <HAL_TIM_Base_Init+0x18c>
   12428:	4929      	ldr	r1, [pc, #164]	; (124d0 <HAL_TIM_Base_Init+0x220>)
   1242a:	4b2a      	ldr	r3, [pc, #168]	; (124d4 <HAL_TIM_Base_Init+0x224>)
   1242c:	429a      	cmp	r2, r3
   1242e:	bf18      	it	ne
   12430:	428a      	cmpne	r2, r1
   12432:	d003      	beq.n	1243c <HAL_TIM_Base_Init+0x18c>
   12434:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12438:	429a      	cmp	r2, r3
   1243a:	d101      	bne.n	12440 <HAL_TIM_Base_Init+0x190>
    TIMx->RCR = Structure->RepetitionCounter;
   1243c:	6963      	ldr	r3, [r4, #20]
   1243e:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
   12440:	2301      	movs	r3, #1
  return HAL_OK;
   12442:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
   12444:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
   12446:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
   1244a:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
   1244c:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
   12450:	4620      	mov	r0, r4
   12452:	f00f fbf7 	bl	21c44 <HAL_TIM_Base_MspInit>
   12456:	e7a5      	b.n	123a4 <HAL_TIM_Base_Init+0xf4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   12458:	f44f 718c 	mov.w	r1, #280	; 0x118
   1245c:	481e      	ldr	r0, [pc, #120]	; (124d8 <HAL_TIM_Base_Init+0x228>)
   1245e:	f006 ffd9 	bl	19414 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
   12462:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   12466:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   1246a:	2b00      	cmp	r3, #0
   1246c:	d19a      	bne.n	123a4 <HAL_TIM_Base_Init+0xf4>
   1246e:	e7ed      	b.n	1244c <HAL_TIM_Base_Init+0x19c>
    return HAL_ERROR;
   12470:	2001      	movs	r0, #1
}
   12472:	4770      	bx	lr
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   12474:	f240 1117 	movw	r1, #279	; 0x117
   12478:	4817      	ldr	r0, [pc, #92]	; (124d8 <HAL_TIM_Base_Init+0x228>)
   1247a:	f006 ffcb 	bl	19414 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1247e:	69a3      	ldr	r3, [r4, #24]
   12480:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   12484:	d088      	beq.n	12398 <HAL_TIM_Base_Init+0xe8>
   12486:	e7e7      	b.n	12458 <HAL_TIM_Base_Init+0x1a8>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   12488:	f44f 718b 	mov.w	r1, #278	; 0x116
   1248c:	4812      	ldr	r0, [pc, #72]	; (124d8 <HAL_TIM_Base_Init+0x228>)
   1248e:	f006 ffc1 	bl	19414 <assert_failed>
   12492:	e776      	b.n	12382 <HAL_TIM_Base_Init+0xd2>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   12494:	480b      	ldr	r0, [pc, #44]	; (124c4 <HAL_TIM_Base_Init+0x214>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   12496:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   1249a:	68a6      	ldr	r6, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   1249c:	4282      	cmp	r2, r0
    tmpcr1 |= Structure->CounterMode;
   1249e:	ea43 0306 	orr.w	r3, r3, r6
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   124a2:	d0b2      	beq.n	1240a <HAL_TIM_Base_Init+0x15a>
   124a4:	2d00      	cmp	r5, #0
   124a6:	d1b0      	bne.n	1240a <HAL_TIM_Base_Init+0x15a>
   124a8:	e7a0      	b.n	123ec <HAL_TIM_Base_Init+0x13c>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   124aa:	f240 1115 	movw	r1, #277	; 0x115
   124ae:	480a      	ldr	r0, [pc, #40]	; (124d8 <HAL_TIM_Base_Init+0x228>)
   124b0:	f006 ffb0 	bl	19414 <assert_failed>
   124b4:	e759      	b.n	1236a <HAL_TIM_Base_Init+0xba>
   124b6:	bf00      	nop
   124b8:	40010000 	.word	0x40010000
   124bc:	40000800 	.word	0x40000800
   124c0:	40000400 	.word	0x40000400
   124c4:	40000c00 	.word	0x40000c00
   124c8:	40014800 	.word	0x40014800
   124cc:	40010400 	.word	0x40010400
   124d0:	40014000 	.word	0x40014000
   124d4:	40014400 	.word	0x40014400
   124d8:	0002ff4c 	.word	0x0002ff4c

000124dc <HAL_TIM_PWM_Init>:
  if (htim == NULL)
   124dc:	2800      	cmp	r0, #0
   124de:	f000 80dd 	beq.w	1269c <HAL_TIM_PWM_Init+0x1c0>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   124e2:	4b80      	ldr	r3, [pc, #512]	; (126e4 <HAL_TIM_PWM_Init+0x208>)
   124e4:	4980      	ldr	r1, [pc, #512]	; (126e8 <HAL_TIM_PWM_Init+0x20c>)
{
   124e6:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   124e8:	6802      	ldr	r2, [r0, #0]
   124ea:	4604      	mov	r4, r0
   124ec:	487f      	ldr	r0, [pc, #508]	; (126ec <HAL_TIM_PWM_Init+0x210>)
   124ee:	429a      	cmp	r2, r3
   124f0:	bf18      	it	ne
   124f2:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   124f6:	4d7e      	ldr	r5, [pc, #504]	; (126f0 <HAL_TIM_PWM_Init+0x214>)
   124f8:	bf14      	ite	ne
   124fa:	2301      	movne	r3, #1
   124fc:	2300      	moveq	r3, #0
   124fe:	4282      	cmp	r2, r0
   12500:	bf0c      	ite	eq
   12502:	2300      	moveq	r3, #0
   12504:	f003 0301 	andne.w	r3, r3, #1
   12508:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
   1250c:	428a      	cmp	r2, r1
   1250e:	bf0c      	ite	eq
   12510:	2300      	moveq	r3, #0
   12512:	f003 0301 	andne.w	r3, r3, #1
   12516:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
   1251a:	42aa      	cmp	r2, r5
   1251c:	bf0c      	ite	eq
   1251e:	2300      	moveq	r3, #0
   12520:	f003 0301 	andne.w	r3, r3, #1
   12524:	f505 4578 	add.w	r5, r5, #63488	; 0xf800
   12528:	4282      	cmp	r2, r0
   1252a:	bf0c      	ite	eq
   1252c:	2300      	moveq	r3, #0
   1252e:	f003 0301 	andne.w	r3, r3, #1
   12532:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   12536:	428a      	cmp	r2, r1
   12538:	bf0c      	ite	eq
   1253a:	2300      	moveq	r3, #0
   1253c:	f003 0301 	andne.w	r3, r3, #1
   12540:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   12544:	42aa      	cmp	r2, r5
   12546:	bf0c      	ite	eq
   12548:	2300      	moveq	r3, #0
   1254a:	f003 0301 	andne.w	r3, r3, #1
   1254e:	f5a5 4564 	sub.w	r5, r5, #58368	; 0xe400
   12552:	4282      	cmp	r2, r0
   12554:	bf0c      	ite	eq
   12556:	2300      	moveq	r3, #0
   12558:	f003 0301 	andne.w	r3, r3, #1
   1255c:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
   12560:	428a      	cmp	r2, r1
   12562:	bf0c      	ite	eq
   12564:	2300      	moveq	r3, #0
   12566:	f003 0301 	andne.w	r3, r3, #1
   1256a:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
   1256e:	42aa      	cmp	r2, r5
   12570:	bf0c      	ite	eq
   12572:	2300      	moveq	r3, #0
   12574:	f003 0301 	andne.w	r3, r3, #1
   12578:	4282      	cmp	r2, r0
   1257a:	bf0c      	ite	eq
   1257c:	2300      	moveq	r3, #0
   1257e:	f003 0301 	andne.w	r3, r3, #1
   12582:	428a      	cmp	r2, r1
   12584:	bf0c      	ite	eq
   12586:	2300      	moveq	r3, #0
   12588:	f003 0301 	andne.w	r3, r3, #1
   1258c:	b11b      	cbz	r3, 12596 <HAL_TIM_PWM_Init+0xba>
   1258e:	4b59      	ldr	r3, [pc, #356]	; (126f4 <HAL_TIM_PWM_Init+0x218>)
   12590:	429a      	cmp	r2, r3
   12592:	f040 80a0 	bne.w	126d6 <HAL_TIM_PWM_Init+0x1fa>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   12596:	68a3      	ldr	r3, [r4, #8]
   12598:	f023 0140 	bic.w	r1, r3, #64	; 0x40
   1259c:	f023 0210 	bic.w	r2, r3, #16
   125a0:	2920      	cmp	r1, #32
   125a2:	bf18      	it	ne
   125a4:	2a00      	cmpne	r2, #0
   125a6:	d002      	beq.n	125ae <HAL_TIM_PWM_Init+0xd2>
   125a8:	2b40      	cmp	r3, #64	; 0x40
   125aa:	f040 8083 	bne.w	126b4 <HAL_TIM_PWM_Init+0x1d8>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   125ae:	6923      	ldr	r3, [r4, #16]
   125b0:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   125b4:	d002      	beq.n	125bc <HAL_TIM_PWM_Init+0xe0>
   125b6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   125ba:	d171      	bne.n	126a0 <HAL_TIM_PWM_Init+0x1c4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   125bc:	69a3      	ldr	r3, [r4, #24]
   125be:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   125c2:	d15f      	bne.n	12684 <HAL_TIM_PWM_Init+0x1a8>
  if (htim->State == HAL_TIM_STATE_RESET)
   125c4:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   125c8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   125cc:	2b00      	cmp	r3, #0
   125ce:	d053      	beq.n	12678 <HAL_TIM_PWM_Init+0x19c>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
   125d0:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
   125d2:	2302      	movs	r3, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   125d4:	4943      	ldr	r1, [pc, #268]	; (126e4 <HAL_TIM_PWM_Init+0x208>)
   125d6:	4d48      	ldr	r5, [pc, #288]	; (126f8 <HAL_TIM_PWM_Init+0x21c>)
   125d8:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   125dc:	eba2 0101 	sub.w	r1, r2, r1
  htim->State = HAL_TIM_STATE_BUSY;
   125e0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
   125e4:	eba2 0505 	sub.w	r5, r2, r5
  tmpcr1 = TIMx->CR1;
   125e8:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   125ea:	fab1 f181 	clz	r1, r1
   125ee:	fab5 f585 	clz	r5, r5
   125f2:	ea4f 1151 	mov.w	r1, r1, lsr #5
   125f6:	ea4f 1555 	mov.w	r5, r5, lsr #5
   125fa:	d018      	beq.n	1262e <HAL_TIM_PWM_Init+0x152>
   125fc:	b9b9      	cbnz	r1, 1262e <HAL_TIM_PWM_Init+0x152>
   125fe:	483b      	ldr	r0, [pc, #236]	; (126ec <HAL_TIM_PWM_Init+0x210>)
   12600:	4282      	cmp	r2, r0
   12602:	d014      	beq.n	1262e <HAL_TIM_PWM_Init+0x152>
   12604:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   12608:	4282      	cmp	r2, r0
   1260a:	d010      	beq.n	1262e <HAL_TIM_PWM_Init+0x152>
   1260c:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   12610:	4282      	cmp	r2, r0
   12612:	d055      	beq.n	126c0 <HAL_TIM_PWM_Init+0x1e4>
   12614:	2d00      	cmp	r5, #0
   12616:	d153      	bne.n	126c0 <HAL_TIM_PWM_Init+0x1e4>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   12618:	4e38      	ldr	r6, [pc, #224]	; (126fc <HAL_TIM_PWM_Init+0x220>)
   1261a:	4839      	ldr	r0, [pc, #228]	; (12700 <HAL_TIM_PWM_Init+0x224>)
   1261c:	4282      	cmp	r2, r0
   1261e:	bf18      	it	ne
   12620:	42b2      	cmpne	r2, r6
   12622:	d008      	beq.n	12636 <HAL_TIM_PWM_Init+0x15a>
   12624:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   12628:	4282      	cmp	r2, r0
   1262a:	d108      	bne.n	1263e <HAL_TIM_PWM_Init+0x162>
   1262c:	e003      	b.n	12636 <HAL_TIM_PWM_Init+0x15a>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   1262e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   12632:	68a0      	ldr	r0, [r4, #8]
   12634:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
   12636:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
   1263a:	6920      	ldr	r0, [r4, #16]
   1263c:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   1263e:	69a0      	ldr	r0, [r4, #24]
   12640:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   12644:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
   12646:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
   12648:	68e3      	ldr	r3, [r4, #12]
   1264a:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
   1264c:	6863      	ldr	r3, [r4, #4]
   1264e:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   12650:	b951      	cbnz	r1, 12668 <HAL_TIM_PWM_Init+0x18c>
   12652:	b94d      	cbnz	r5, 12668 <HAL_TIM_PWM_Init+0x18c>
   12654:	4929      	ldr	r1, [pc, #164]	; (126fc <HAL_TIM_PWM_Init+0x220>)
   12656:	4b2a      	ldr	r3, [pc, #168]	; (12700 <HAL_TIM_PWM_Init+0x224>)
   12658:	429a      	cmp	r2, r3
   1265a:	bf18      	it	ne
   1265c:	428a      	cmpne	r2, r1
   1265e:	d003      	beq.n	12668 <HAL_TIM_PWM_Init+0x18c>
   12660:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12664:	429a      	cmp	r2, r3
   12666:	d101      	bne.n	1266c <HAL_TIM_PWM_Init+0x190>
    TIMx->RCR = Structure->RepetitionCounter;
   12668:	6963      	ldr	r3, [r4, #20]
   1266a:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
   1266c:	2301      	movs	r3, #1
  return HAL_OK;
   1266e:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
   12670:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
   12672:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
   12676:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
   12678:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
   1267c:	4620      	mov	r0, r4
   1267e:	f00f fac7 	bl	21c10 <HAL_TIM_PWM_MspInit>
   12682:	e7a5      	b.n	125d0 <HAL_TIM_PWM_Init+0xf4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   12684:	f240 41a5 	movw	r1, #1189	; 0x4a5
   12688:	481e      	ldr	r0, [pc, #120]	; (12704 <HAL_TIM_PWM_Init+0x228>)
   1268a:	f006 fec3 	bl	19414 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
   1268e:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   12692:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   12696:	2b00      	cmp	r3, #0
   12698:	d19a      	bne.n	125d0 <HAL_TIM_PWM_Init+0xf4>
   1269a:	e7ed      	b.n	12678 <HAL_TIM_PWM_Init+0x19c>
    return HAL_ERROR;
   1269c:	2001      	movs	r0, #1
}
   1269e:	4770      	bx	lr
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   126a0:	f240 41a4 	movw	r1, #1188	; 0x4a4
   126a4:	4817      	ldr	r0, [pc, #92]	; (12704 <HAL_TIM_PWM_Init+0x228>)
   126a6:	f006 feb5 	bl	19414 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   126aa:	69a3      	ldr	r3, [r4, #24]
   126ac:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   126b0:	d088      	beq.n	125c4 <HAL_TIM_PWM_Init+0xe8>
   126b2:	e7e7      	b.n	12684 <HAL_TIM_PWM_Init+0x1a8>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   126b4:	f240 41a3 	movw	r1, #1187	; 0x4a3
   126b8:	4812      	ldr	r0, [pc, #72]	; (12704 <HAL_TIM_PWM_Init+0x228>)
   126ba:	f006 feab 	bl	19414 <assert_failed>
   126be:	e776      	b.n	125ae <HAL_TIM_PWM_Init+0xd2>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   126c0:	480b      	ldr	r0, [pc, #44]	; (126f0 <HAL_TIM_PWM_Init+0x214>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   126c2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   126c6:	68a6      	ldr	r6, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   126c8:	4282      	cmp	r2, r0
    tmpcr1 |= Structure->CounterMode;
   126ca:	ea43 0306 	orr.w	r3, r3, r6
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   126ce:	d0b2      	beq.n	12636 <HAL_TIM_PWM_Init+0x15a>
   126d0:	2d00      	cmp	r5, #0
   126d2:	d1b0      	bne.n	12636 <HAL_TIM_PWM_Init+0x15a>
   126d4:	e7a0      	b.n	12618 <HAL_TIM_PWM_Init+0x13c>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   126d6:	f240 41a2 	movw	r1, #1186	; 0x4a2
   126da:	480a      	ldr	r0, [pc, #40]	; (12704 <HAL_TIM_PWM_Init+0x228>)
   126dc:	f006 fe9a 	bl	19414 <assert_failed>
   126e0:	e759      	b.n	12596 <HAL_TIM_PWM_Init+0xba>
   126e2:	bf00      	nop
   126e4:	40010000 	.word	0x40010000
   126e8:	40000800 	.word	0x40000800
   126ec:	40000400 	.word	0x40000400
   126f0:	40000c00 	.word	0x40000c00
   126f4:	40014800 	.word	0x40014800
   126f8:	40010400 	.word	0x40010400
   126fc:	40014000 	.word	0x40014000
   12700:	40014400 	.word	0x40014400
   12704:	0002ff4c 	.word	0x0002ff4c

00012708 <HAL_TIM_PWM_Start>:
{
   12708:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1270a:	4b66      	ldr	r3, [pc, #408]	; (128a4 <HAL_TIM_PWM_Start+0x19c>)
{
   1270c:	4606      	mov	r6, r0
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1270e:	6804      	ldr	r4, [r0, #0]
{
   12710:	460d      	mov	r5, r1
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   12712:	429c      	cmp	r4, r3
   12714:	f000 8093 	beq.w	1283e <HAL_TIM_PWM_Start+0x136>
   12718:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
   1271c:	f000 8089 	beq.w	12832 <HAL_TIM_PWM_Start+0x12a>
   12720:	4b61      	ldr	r3, [pc, #388]	; (128a8 <HAL_TIM_PWM_Start+0x1a0>)
   12722:	429c      	cmp	r4, r3
   12724:	f000 8085 	beq.w	12832 <HAL_TIM_PWM_Start+0x12a>
   12728:	4b60      	ldr	r3, [pc, #384]	; (128ac <HAL_TIM_PWM_Start+0x1a4>)
   1272a:	429c      	cmp	r4, r3
   1272c:	f000 8081 	beq.w	12832 <HAL_TIM_PWM_Start+0x12a>
   12730:	4b5f      	ldr	r3, [pc, #380]	; (128b0 <HAL_TIM_PWM_Start+0x1a8>)
   12732:	429c      	cmp	r4, r3
   12734:	d07d      	beq.n	12832 <HAL_TIM_PWM_Start+0x12a>
   12736:	4b5f      	ldr	r3, [pc, #380]	; (128b4 <HAL_TIM_PWM_Start+0x1ac>)
   12738:	429c      	cmp	r4, r3
   1273a:	f000 8092 	beq.w	12862 <HAL_TIM_PWM_Start+0x15a>
   1273e:	4b5e      	ldr	r3, [pc, #376]	; (128b8 <HAL_TIM_PWM_Start+0x1b0>)
   12740:	429c      	cmp	r4, r3
   12742:	f000 8096 	beq.w	12872 <HAL_TIM_PWM_Start+0x16a>
   12746:	4b5d      	ldr	r3, [pc, #372]	; (128bc <HAL_TIM_PWM_Start+0x1b4>)
   12748:	429c      	cmp	r4, r3
   1274a:	f040 8097 	bne.w	1287c <HAL_TIM_PWM_Start+0x174>
   1274e:	b1d5      	cbz	r5, 12786 <HAL_TIM_PWM_Start+0x7e>
   12750:	f240 511c 	movw	r1, #1308	; 0x51c
   12754:	485a      	ldr	r0, [pc, #360]	; (128c0 <HAL_TIM_PWM_Start+0x1b8>)
   12756:	f006 fe5d 	bl	19414 <assert_failed>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1275a:	6834      	ldr	r4, [r6, #0]
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   1275c:	4b51      	ldr	r3, [pc, #324]	; (128a4 <HAL_TIM_PWM_Start+0x19c>)
   1275e:	429c      	cmp	r4, r3
   12760:	d02d      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12762:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
   12766:	d02a      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12768:	f5a3 437c 	sub.w	r3, r3, #64512	; 0xfc00
   1276c:	429c      	cmp	r4, r3
   1276e:	d026      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12770:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12774:	429c      	cmp	r4, r3
   12776:	d022      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12778:	4b4d      	ldr	r3, [pc, #308]	; (128b0 <HAL_TIM_PWM_Start+0x1a8>)
   1277a:	429c      	cmp	r4, r3
   1277c:	d01f      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   1277e:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
   12782:	429c      	cmp	r4, r3
   12784:	d01b      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12786:	4b4c      	ldr	r3, [pc, #304]	; (128b8 <HAL_TIM_PWM_Start+0x1b0>)
   12788:	429c      	cmp	r4, r3
   1278a:	d018      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   1278c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12790:	429c      	cmp	r4, r3
   12792:	d014      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12794:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12798:	429c      	cmp	r4, r3
   1279a:	d010      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   1279c:	f503 3390 	add.w	r3, r3, #73728	; 0x12000
   127a0:	429c      	cmp	r4, r3
   127a2:	d00c      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   127a4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   127a8:	429c      	cmp	r4, r3
   127aa:	d008      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   127ac:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   127b0:	429c      	cmp	r4, r3
   127b2:	d004      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   127b4:	f641 3154 	movw	r1, #6996	; 0x1b54
   127b8:	4841      	ldr	r0, [pc, #260]	; (128c0 <HAL_TIM_PWM_Start+0x1b8>)
   127ba:	f006 fe2b 	bl	19414 <assert_failed>
  assert_param(IS_TIM_CHANNELS(Channel));
   127be:	2d14      	cmp	r5, #20
   127c0:	d943      	bls.n	1284a <HAL_TIM_PWM_Start+0x142>
   127c2:	2d3c      	cmp	r5, #60	; 0x3c
   127c4:	d147      	bne.n	12856 <HAL_TIM_PWM_Start+0x14e>

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   127c6:	2301      	movs	r3, #1
   127c8:	f005 051f 	and.w	r5, r5, #31

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
   127cc:	6a21      	ldr	r1, [r4, #32]
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   127ce:	fa03 f505 	lsl.w	r5, r3, r5
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   127d2:	4a34      	ldr	r2, [pc, #208]	; (128a4 <HAL_TIM_PWM_Start+0x19c>)
   127d4:	4f37      	ldr	r7, [pc, #220]	; (128b4 <HAL_TIM_PWM_Start+0x1ac>)
  TIMx->CCER &= ~tmp;
   127d6:	ea21 0105 	bic.w	r1, r1, r5
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   127da:	483a      	ldr	r0, [pc, #232]	; (128c4 <HAL_TIM_PWM_Start+0x1bc>)
  TIMx->CCER &= ~tmp;
   127dc:	6221      	str	r1, [r4, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   127de:	6a23      	ldr	r3, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   127e0:	4939      	ldr	r1, [pc, #228]	; (128c8 <HAL_TIM_PWM_Start+0x1c0>)
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   127e2:	431d      	orrs	r5, r3
   127e4:	6225      	str	r5, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   127e6:	6833      	ldr	r3, [r6, #0]
   127e8:	42bb      	cmp	r3, r7
   127ea:	bf18      	it	ne
   127ec:	4293      	cmpne	r3, r2
   127ee:	bf0c      	ite	eq
   127f0:	2201      	moveq	r2, #1
   127f2:	2200      	movne	r2, #0
   127f4:	4283      	cmp	r3, r0
   127f6:	bf08      	it	eq
   127f8:	f042 0201 	orreq.w	r2, r2, #1
   127fc:	428b      	cmp	r3, r1
   127fe:	bf08      	it	eq
   12800:	f042 0201 	orreq.w	r2, r2, #1
   12804:	b912      	cbnz	r2, 1280c <HAL_TIM_PWM_Start+0x104>
   12806:	4a31      	ldr	r2, [pc, #196]	; (128cc <HAL_TIM_PWM_Start+0x1c4>)
   12808:	4293      	cmp	r3, r2
   1280a:	d104      	bne.n	12816 <HAL_TIM_PWM_Start+0x10e>
    __HAL_TIM_MOE_ENABLE(htim);
   1280c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   1280e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
   12812:	645a      	str	r2, [r3, #68]	; 0x44
   12814:	6833      	ldr	r3, [r6, #0]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   12816:	6899      	ldr	r1, [r3, #8]
   12818:	4a2d      	ldr	r2, [pc, #180]	; (128d0 <HAL_TIM_PWM_Start+0x1c8>)
   1281a:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1281c:	2a06      	cmp	r2, #6
   1281e:	d006      	beq.n	1282e <HAL_TIM_PWM_Start+0x126>
   12820:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
   12824:	d003      	beq.n	1282e <HAL_TIM_PWM_Start+0x126>
    __HAL_TIM_ENABLE(htim);
   12826:	681a      	ldr	r2, [r3, #0]
   12828:	f042 0201 	orr.w	r2, r2, #1
   1282c:	601a      	str	r2, [r3, #0]
}
   1282e:	2000      	movs	r0, #0
   12830:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   12832:	f035 030c 	bics.w	r3, r5, #12
   12836:	d18b      	bne.n	12750 <HAL_TIM_PWM_Start+0x48>
  assert_param(IS_TIM_CHANNELS(Channel));
   12838:	2d14      	cmp	r5, #20
   1283a:	d8c2      	bhi.n	127c2 <HAL_TIM_PWM_Start+0xba>
   1283c:	e005      	b.n	1284a <HAL_TIM_PWM_Start+0x142>
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1283e:	2914      	cmp	r1, #20
   12840:	d886      	bhi.n	12750 <HAL_TIM_PWM_Start+0x48>
   12842:	4b24      	ldr	r3, [pc, #144]	; (128d4 <HAL_TIM_PWM_Start+0x1cc>)
   12844:	40cb      	lsrs	r3, r1
   12846:	07d9      	lsls	r1, r3, #31
   12848:	d582      	bpl.n	12750 <HAL_TIM_PWM_Start+0x48>
  assert_param(IS_TIM_CHANNELS(Channel));
   1284a:	4b22      	ldr	r3, [pc, #136]	; (128d4 <HAL_TIM_PWM_Start+0x1cc>)
   1284c:	40eb      	lsrs	r3, r5
   1284e:	07db      	lsls	r3, r3, #31
   12850:	d4b9      	bmi.n	127c6 <HAL_TIM_PWM_Start+0xbe>
   12852:	2d3c      	cmp	r5, #60	; 0x3c
   12854:	d0b7      	beq.n	127c6 <HAL_TIM_PWM_Start+0xbe>
   12856:	f641 3155 	movw	r1, #6997	; 0x1b55
   1285a:	4819      	ldr	r0, [pc, #100]	; (128c0 <HAL_TIM_PWM_Start+0x1b8>)
   1285c:	f006 fdda 	bl	19414 <assert_failed>
   12860:	e7b1      	b.n	127c6 <HAL_TIM_PWM_Start+0xbe>
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   12862:	2914      	cmp	r1, #20
   12864:	f63f af74 	bhi.w	12750 <HAL_TIM_PWM_Start+0x48>
   12868:	4b1a      	ldr	r3, [pc, #104]	; (128d4 <HAL_TIM_PWM_Start+0x1cc>)
   1286a:	40cb      	lsrs	r3, r1
   1286c:	07da      	lsls	r2, r3, #31
   1286e:	d4a6      	bmi.n	127be <HAL_TIM_PWM_Start+0xb6>
   12870:	e76e      	b.n	12750 <HAL_TIM_PWM_Start+0x48>
   12872:	f035 0304 	bics.w	r3, r5, #4
   12876:	f47f af6b 	bne.w	12750 <HAL_TIM_PWM_Start+0x48>
   1287a:	e784      	b.n	12786 <HAL_TIM_PWM_Start+0x7e>
   1287c:	4b16      	ldr	r3, [pc, #88]	; (128d8 <HAL_TIM_PWM_Start+0x1d0>)
   1287e:	429c      	cmp	r4, r3
   12880:	f43f af65 	beq.w	1274e <HAL_TIM_PWM_Start+0x46>
   12884:	4b0f      	ldr	r3, [pc, #60]	; (128c4 <HAL_TIM_PWM_Start+0x1bc>)
   12886:	429c      	cmp	r4, r3
   12888:	d0f3      	beq.n	12872 <HAL_TIM_PWM_Start+0x16a>
   1288a:	4b0f      	ldr	r3, [pc, #60]	; (128c8 <HAL_TIM_PWM_Start+0x1c0>)
   1288c:	429c      	cmp	r4, r3
   1288e:	f43f af5e 	beq.w	1274e <HAL_TIM_PWM_Start+0x46>
   12892:	4b0e      	ldr	r3, [pc, #56]	; (128cc <HAL_TIM_PWM_Start+0x1c4>)
   12894:	429c      	cmp	r4, r3
   12896:	f47f af5b 	bne.w	12750 <HAL_TIM_PWM_Start+0x48>
   1289a:	2900      	cmp	r1, #0
   1289c:	f47f af58 	bne.w	12750 <HAL_TIM_PWM_Start+0x48>
   128a0:	461c      	mov	r4, r3
   128a2:	e769      	b.n	12778 <HAL_TIM_PWM_Start+0x70>
   128a4:	40010000 	.word	0x40010000
   128a8:	40000400 	.word	0x40000400
   128ac:	40000800 	.word	0x40000800
   128b0:	40000c00 	.word	0x40000c00
   128b4:	40010400 	.word	0x40010400
   128b8:	40001800 	.word	0x40001800
   128bc:	40001c00 	.word	0x40001c00
   128c0:	0002ff4c 	.word	0x0002ff4c
   128c4:	40014000 	.word	0x40014000
   128c8:	40014400 	.word	0x40014400
   128cc:	40014800 	.word	0x40014800
   128d0:	00010007 	.word	0x00010007
   128d4:	00111111 	.word	0x00111111
   128d8:	40002000 	.word	0x40002000

000128dc <HAL_TIM_ConfigClockSource>:
{
   128dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
   128de:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
   128e2:	2b01      	cmp	r3, #1
   128e4:	f000 8186 	beq.w	12bf4 <HAL_TIM_ConfigClockSource+0x318>
   128e8:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
   128ea:	2302      	movs	r3, #2
   128ec:	460d      	mov	r5, r1
   128ee:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
   128f0:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
   128f4:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   128f8:	680b      	ldr	r3, [r1, #0]
   128fa:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   128fe:	bf18      	it	ne
   12900:	f5b3 5f00 	cmpne.w	r3, #8192	; 0x2000
   12904:	bf14      	ite	ne
   12906:	2201      	movne	r2, #1
   12908:	2200      	moveq	r2, #0
   1290a:	f033 0330 	bics.w	r3, r3, #48	; 0x30
   1290e:	bf08      	it	eq
   12910:	2200      	moveq	r2, #0
   12912:	b112      	cbz	r2, 1291a <HAL_TIM_ConfigClockSource+0x3e>
   12914:	2b40      	cmp	r3, #64	; 0x40
   12916:	f040 8262 	bne.w	12dde <HAL_TIM_ConfigClockSource+0x502>
  tmpsmcr = htim->Instance->SMCR;
   1291a:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   1291c:	4bb6      	ldr	r3, [pc, #728]	; (12bf8 <HAL_TIM_ConfigClockSource+0x31c>)
  tmpsmcr = htim->Instance->SMCR;
   1291e:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   12920:	400b      	ands	r3, r1
  htim->Instance->SMCR = tmpsmcr;
   12922:	6093      	str	r3, [r2, #8]
  switch (sClockSourceConfig->ClockSource)
   12924:	682b      	ldr	r3, [r5, #0]
   12926:	2b70      	cmp	r3, #112	; 0x70
   12928:	f000 8178 	beq.w	12c1c <HAL_TIM_ConfigClockSource+0x340>
   1292c:	d85c      	bhi.n	129e8 <HAL_TIM_ConfigClockSource+0x10c>
   1292e:	2b30      	cmp	r3, #48	; 0x30
   12930:	f000 820f 	beq.w	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12934:	f240 8206 	bls.w	12d44 <HAL_TIM_ConfigClockSource+0x468>
   12938:	2b50      	cmp	r3, #80	; 0x50
   1293a:	f000 81b4 	beq.w	12ca6 <HAL_TIM_ConfigClockSource+0x3ca>
   1293e:	2b60      	cmp	r3, #96	; 0x60
   12940:	f000 80c3 	beq.w	12aca <HAL_TIM_ConfigClockSource+0x1ee>
   12944:	2b40      	cmp	r3, #64	; 0x40
   12946:	f040 80b8 	bne.w	12aba <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   1294a:	6822      	ldr	r2, [r4, #0]
   1294c:	4bab      	ldr	r3, [pc, #684]	; (12bfc <HAL_TIM_ConfigClockSource+0x320>)
   1294e:	48ac      	ldr	r0, [pc, #688]	; (12c00 <HAL_TIM_ConfigClockSource+0x324>)
   12950:	429a      	cmp	r2, r3
   12952:	bf18      	it	ne
   12954:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12958:	49aa      	ldr	r1, [pc, #680]	; (12c04 <HAL_TIM_ConfigClockSource+0x328>)
   1295a:	bf14      	ite	ne
   1295c:	2301      	movne	r3, #1
   1295e:	2300      	moveq	r3, #0
   12960:	4282      	cmp	r2, r0
   12962:	bf0c      	ite	eq
   12964:	2300      	moveq	r3, #0
   12966:	f003 0301 	andne.w	r3, r3, #1
   1296a:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   1296e:	428a      	cmp	r2, r1
   12970:	bf0c      	ite	eq
   12972:	2300      	moveq	r3, #0
   12974:	f003 0301 	andne.w	r3, r3, #1
   12978:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
   1297c:	4282      	cmp	r2, r0
   1297e:	bf0c      	ite	eq
   12980:	2300      	moveq	r3, #0
   12982:	f003 0301 	andne.w	r3, r3, #1
   12986:	428a      	cmp	r2, r1
   12988:	bf0c      	ite	eq
   1298a:	2300      	moveq	r3, #0
   1298c:	f003 0301 	andne.w	r3, r3, #1
   12990:	b11b      	cbz	r3, 1299a <HAL_TIM_ConfigClockSource+0xbe>
   12992:	4b9d      	ldr	r3, [pc, #628]	; (12c08 <HAL_TIM_ConfigClockSource+0x32c>)
   12994:	429a      	cmp	r2, r3
   12996:	f040 825a 	bne.w	12e4e <HAL_TIM_ConfigClockSource+0x572>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   1299a:	686b      	ldr	r3, [r5, #4]
   1299c:	2b0a      	cmp	r3, #10
   1299e:	bf18      	it	ne
   129a0:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   129a4:	d003      	beq.n	129ae <HAL_TIM_ConfigClockSource+0xd2>
   129a6:	f033 0302 	bics.w	r3, r3, #2
   129aa:	f040 821e 	bne.w	12dea <HAL_TIM_ConfigClockSource+0x50e>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   129ae:	68ee      	ldr	r6, [r5, #12]
   129b0:	2e0f      	cmp	r6, #15
   129b2:	f200 826e 	bhi.w	12e92 <HAL_TIM_ConfigClockSource+0x5b6>
      TIM_TI1_ConfigInputStage(htim->Instance,
   129b6:	6823      	ldr	r3, [r4, #0]
   129b8:	6868      	ldr	r0, [r5, #4]
  tmpccer = TIMx->CCER;
   129ba:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
   129bc:	6a1d      	ldr	r5, [r3, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   129be:	f022 020a 	bic.w	r2, r2, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
   129c2:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
   129c6:	4310      	orrs	r0, r2
  tmpsmcr &= ~TIM_SMCR_TS;
   129c8:	4a90      	ldr	r2, [pc, #576]	; (12c0c <HAL_TIM_ConfigClockSource+0x330>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
   129ca:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
   129cc:	6999      	ldr	r1, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
   129ce:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
   129d2:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
  TIMx->CCMR1 = tmpccmr1;
   129d6:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
   129d8:	6218      	str	r0, [r3, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   129da:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = TIMx->SMCR;
   129dc:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
   129de:	400a      	ands	r2, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   129e0:	f042 0247 	orr.w	r2, r2, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
   129e4:	609a      	str	r2, [r3, #8]
   129e6:	e068      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
  switch (sClockSourceConfig->ClockSource)
   129e8:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
   129ec:	f000 81b1 	beq.w	12d52 <HAL_TIM_ConfigClockSource+0x476>
   129f0:	f200 81de 	bhi.w	12db0 <HAL_TIM_ConfigClockSource+0x4d4>
   129f4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   129f8:	f000 80b7 	beq.w	12b6a <HAL_TIM_ConfigClockSource+0x28e>
   129fc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   12a00:	f000 81a7 	beq.w	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12a04:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   12a08:	d157      	bne.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
   12a0a:	6822      	ldr	r2, [r4, #0]
   12a0c:	4b7b      	ldr	r3, [pc, #492]	; (12bfc <HAL_TIM_ConfigClockSource+0x320>)
   12a0e:	487c      	ldr	r0, [pc, #496]	; (12c00 <HAL_TIM_ConfigClockSource+0x324>)
   12a10:	429a      	cmp	r2, r3
   12a12:	bf18      	it	ne
   12a14:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12a18:	497a      	ldr	r1, [pc, #488]	; (12c04 <HAL_TIM_ConfigClockSource+0x328>)
   12a1a:	4d7d      	ldr	r5, [pc, #500]	; (12c10 <HAL_TIM_ConfigClockSource+0x334>)
   12a1c:	bf14      	ite	ne
   12a1e:	2301      	movne	r3, #1
   12a20:	2300      	moveq	r3, #0
   12a22:	4282      	cmp	r2, r0
   12a24:	bf0c      	ite	eq
   12a26:	2300      	moveq	r3, #0
   12a28:	f003 0301 	andne.w	r3, r3, #1
   12a2c:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
   12a30:	428a      	cmp	r2, r1
   12a32:	bf0c      	ite	eq
   12a34:	2300      	moveq	r3, #0
   12a36:	f003 0301 	andne.w	r3, r3, #1
   12a3a:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
   12a3e:	42aa      	cmp	r2, r5
   12a40:	bf0c      	ite	eq
   12a42:	2300      	moveq	r3, #0
   12a44:	f003 0301 	andne.w	r3, r3, #1
   12a48:	f505 4578 	add.w	r5, r5, #63488	; 0xf800
   12a4c:	4282      	cmp	r2, r0
   12a4e:	bf0c      	ite	eq
   12a50:	2300      	moveq	r3, #0
   12a52:	f003 0301 	andne.w	r3, r3, #1
   12a56:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   12a5a:	428a      	cmp	r2, r1
   12a5c:	bf0c      	ite	eq
   12a5e:	2300      	moveq	r3, #0
   12a60:	f003 0301 	andne.w	r3, r3, #1
   12a64:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   12a68:	42aa      	cmp	r2, r5
   12a6a:	bf0c      	ite	eq
   12a6c:	2300      	moveq	r3, #0
   12a6e:	f003 0301 	andne.w	r3, r3, #1
   12a72:	f5a5 4564 	sub.w	r5, r5, #58368	; 0xe400
   12a76:	4282      	cmp	r2, r0
   12a78:	bf0c      	ite	eq
   12a7a:	2300      	moveq	r3, #0
   12a7c:	f003 0301 	andne.w	r3, r3, #1
   12a80:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
   12a84:	428a      	cmp	r2, r1
   12a86:	bf0c      	ite	eq
   12a88:	2300      	moveq	r3, #0
   12a8a:	f003 0301 	andne.w	r3, r3, #1
   12a8e:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
   12a92:	42aa      	cmp	r2, r5
   12a94:	bf0c      	ite	eq
   12a96:	2300      	moveq	r3, #0
   12a98:	f003 0301 	andne.w	r3, r3, #1
   12a9c:	4282      	cmp	r2, r0
   12a9e:	bf0c      	ite	eq
   12aa0:	2300      	moveq	r3, #0
   12aa2:	f003 0301 	andne.w	r3, r3, #1
   12aa6:	428a      	cmp	r2, r1
   12aa8:	bf0c      	ite	eq
   12aaa:	2300      	moveq	r3, #0
   12aac:	f003 0301 	andne.w	r3, r3, #1
   12ab0:	b11b      	cbz	r3, 12aba <HAL_TIM_ConfigClockSource+0x1de>
   12ab2:	4b58      	ldr	r3, [pc, #352]	; (12c14 <HAL_TIM_ConfigClockSource+0x338>)
   12ab4:	429a      	cmp	r2, r3
   12ab6:	f040 81ff 	bne.w	12eb8 <HAL_TIM_ConfigClockSource+0x5dc>
  __HAL_UNLOCK(htim);
   12aba:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
   12abc:	2201      	movs	r2, #1
  return HAL_OK;
   12abe:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
   12ac0:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
   12ac4:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
   12ac8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   12aca:	6822      	ldr	r2, [r4, #0]
   12acc:	4b4b      	ldr	r3, [pc, #300]	; (12bfc <HAL_TIM_ConfigClockSource+0x320>)
   12ace:	484c      	ldr	r0, [pc, #304]	; (12c00 <HAL_TIM_ConfigClockSource+0x324>)
   12ad0:	429a      	cmp	r2, r3
   12ad2:	bf18      	it	ne
   12ad4:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12ad8:	494a      	ldr	r1, [pc, #296]	; (12c04 <HAL_TIM_ConfigClockSource+0x328>)
   12ada:	bf14      	ite	ne
   12adc:	2301      	movne	r3, #1
   12ade:	2300      	moveq	r3, #0
   12ae0:	4282      	cmp	r2, r0
   12ae2:	bf0c      	ite	eq
   12ae4:	2300      	moveq	r3, #0
   12ae6:	f003 0301 	andne.w	r3, r3, #1
   12aea:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   12aee:	428a      	cmp	r2, r1
   12af0:	bf0c      	ite	eq
   12af2:	2300      	moveq	r3, #0
   12af4:	f003 0301 	andne.w	r3, r3, #1
   12af8:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
   12afc:	4282      	cmp	r2, r0
   12afe:	bf0c      	ite	eq
   12b00:	2300      	moveq	r3, #0
   12b02:	f003 0301 	andne.w	r3, r3, #1
   12b06:	428a      	cmp	r2, r1
   12b08:	bf0c      	ite	eq
   12b0a:	2300      	moveq	r3, #0
   12b0c:	f003 0301 	andne.w	r3, r3, #1
   12b10:	b11b      	cbz	r3, 12b1a <HAL_TIM_ConfigClockSource+0x23e>
   12b12:	4b3d      	ldr	r3, [pc, #244]	; (12c08 <HAL_TIM_ConfigClockSource+0x32c>)
   12b14:	429a      	cmp	r2, r3
   12b16:	f040 8194 	bne.w	12e42 <HAL_TIM_ConfigClockSource+0x566>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12b1a:	686b      	ldr	r3, [r5, #4]
   12b1c:	2b0a      	cmp	r3, #10
   12b1e:	bf18      	it	ne
   12b20:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   12b24:	d003      	beq.n	12b2e <HAL_TIM_ConfigClockSource+0x252>
   12b26:	f033 0302 	bics.w	r3, r3, #2
   12b2a:	f040 8164 	bne.w	12df6 <HAL_TIM_ConfigClockSource+0x51a>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12b2e:	68ee      	ldr	r6, [r5, #12]
   12b30:	2e0f      	cmp	r6, #15
   12b32:	f200 81a7 	bhi.w	12e84 <HAL_TIM_ConfigClockSource+0x5a8>
      TIM_TI2_ConfigInputStage(htim->Instance,
   12b36:	6823      	ldr	r3, [r4, #0]
   12b38:	686f      	ldr	r7, [r5, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
   12b3a:	6a1d      	ldr	r5, [r3, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
   12b3c:	4a33      	ldr	r2, [pc, #204]	; (12c0c <HAL_TIM_ConfigClockSource+0x330>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
   12b3e:	f025 0510 	bic.w	r5, r5, #16
   12b42:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
   12b44:	6998      	ldr	r0, [r3, #24]
  tmpccer = TIMx->CCER;
   12b46:	6a19      	ldr	r1, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
   12b48:	f420 4070 	bic.w	r0, r0, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   12b4c:	f021 01a0 	bic.w	r1, r1, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
   12b50:	ea40 3006 	orr.w	r0, r0, r6, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
   12b54:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
   12b58:	6198      	str	r0, [r3, #24]
  TIMx->CCER = tmpccer;
   12b5a:	6219      	str	r1, [r3, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   12b5c:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = TIMx->SMCR;
   12b5e:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
   12b60:	400a      	ands	r2, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   12b62:	f042 0267 	orr.w	r2, r2, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
   12b66:	609a      	str	r2, [r3, #8]
   12b68:	e7a7      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   12b6a:	6822      	ldr	r2, [r4, #0]
   12b6c:	4b23      	ldr	r3, [pc, #140]	; (12bfc <HAL_TIM_ConfigClockSource+0x320>)
   12b6e:	4924      	ldr	r1, [pc, #144]	; (12c00 <HAL_TIM_ConfigClockSource+0x324>)
   12b70:	429a      	cmp	r2, r3
   12b72:	bf18      	it	ne
   12b74:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12b78:	4822      	ldr	r0, [pc, #136]	; (12c04 <HAL_TIM_ConfigClockSource+0x328>)
   12b7a:	bf14      	ite	ne
   12b7c:	2301      	movne	r3, #1
   12b7e:	2300      	moveq	r3, #0
   12b80:	428a      	cmp	r2, r1
   12b82:	bf0c      	ite	eq
   12b84:	2300      	moveq	r3, #0
   12b86:	f003 0301 	andne.w	r3, r3, #1
   12b8a:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   12b8e:	4282      	cmp	r2, r0
   12b90:	bf0c      	ite	eq
   12b92:	2300      	moveq	r3, #0
   12b94:	f003 0301 	andne.w	r3, r3, #1
   12b98:	428a      	cmp	r2, r1
   12b9a:	bf0c      	ite	eq
   12b9c:	2300      	moveq	r3, #0
   12b9e:	f003 0301 	andne.w	r3, r3, #1
   12ba2:	b11b      	cbz	r3, 12bac <HAL_TIM_ConfigClockSource+0x2d0>
   12ba4:	4b1c      	ldr	r3, [pc, #112]	; (12c18 <HAL_TIM_ConfigClockSource+0x33c>)
   12ba6:	429a      	cmp	r2, r3
   12ba8:	f040 810d 	bne.w	12dc6 <HAL_TIM_ConfigClockSource+0x4ea>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   12bac:	68ab      	ldr	r3, [r5, #8]
   12bae:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
   12bb2:	f040 8175 	bne.w	12ea0 <HAL_TIM_ConfigClockSource+0x5c4>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12bb6:	686b      	ldr	r3, [r5, #4]
   12bb8:	2b0a      	cmp	r3, #10
   12bba:	bf18      	it	ne
   12bbc:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   12bc0:	d003      	beq.n	12bca <HAL_TIM_ConfigClockSource+0x2ee>
   12bc2:	f033 0302 	bics.w	r3, r3, #2
   12bc6:	f040 8122 	bne.w	12e0e <HAL_TIM_ConfigClockSource+0x532>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12bca:	68e9      	ldr	r1, [r5, #12]
   12bcc:	290f      	cmp	r1, #15
   12bce:	f200 8144 	bhi.w	12e5a <HAL_TIM_ConfigClockSource+0x57e>
      TIM_ETR_SetConfig(htim->Instance,
   12bd2:	6820      	ldr	r0, [r4, #0]
   12bd4:	68ab      	ldr	r3, [r5, #8]
  tmpsmcr = TIMx->SMCR;
   12bd6:	6882      	ldr	r2, [r0, #8]
   12bd8:	686d      	ldr	r5, [r5, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   12bda:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
   12bde:	432b      	orrs	r3, r5
   12be0:	4313      	orrs	r3, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   12be2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  TIMx->SMCR = tmpsmcr;
   12be6:	6083      	str	r3, [r0, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
   12be8:	6822      	ldr	r2, [r4, #0]
   12bea:	6893      	ldr	r3, [r2, #8]
   12bec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   12bf0:	6093      	str	r3, [r2, #8]
      break;
   12bf2:	e762      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
  __HAL_LOCK(htim);
   12bf4:	2002      	movs	r0, #2
}
   12bf6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12bf8:	ffce0088 	.word	0xffce0088
   12bfc:	40010000 	.word	0x40010000
   12c00:	40000400 	.word	0x40000400
   12c04:	40000800 	.word	0x40000800
   12c08:	40014000 	.word	0x40014000
   12c0c:	ffcfff8f 	.word	0xffcfff8f
   12c10:	40000c00 	.word	0x40000c00
   12c14:	40014800 	.word	0x40014800
   12c18:	40010400 	.word	0x40010400
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   12c1c:	6822      	ldr	r2, [r4, #0]
   12c1e:	4ba9      	ldr	r3, [pc, #676]	; (12ec4 <HAL_TIM_ConfigClockSource+0x5e8>)
   12c20:	49a9      	ldr	r1, [pc, #676]	; (12ec8 <HAL_TIM_ConfigClockSource+0x5ec>)
   12c22:	429a      	cmp	r2, r3
   12c24:	bf18      	it	ne
   12c26:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12c2a:	48a8      	ldr	r0, [pc, #672]	; (12ecc <HAL_TIM_ConfigClockSource+0x5f0>)
   12c2c:	bf14      	ite	ne
   12c2e:	2301      	movne	r3, #1
   12c30:	2300      	moveq	r3, #0
   12c32:	428a      	cmp	r2, r1
   12c34:	bf0c      	ite	eq
   12c36:	2300      	moveq	r3, #0
   12c38:	f003 0301 	andne.w	r3, r3, #1
   12c3c:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   12c40:	4282      	cmp	r2, r0
   12c42:	bf0c      	ite	eq
   12c44:	2300      	moveq	r3, #0
   12c46:	f003 0301 	andne.w	r3, r3, #1
   12c4a:	428a      	cmp	r2, r1
   12c4c:	bf0c      	ite	eq
   12c4e:	2300      	moveq	r3, #0
   12c50:	f003 0301 	andne.w	r3, r3, #1
   12c54:	b11b      	cbz	r3, 12c5e <HAL_TIM_ConfigClockSource+0x382>
   12c56:	4b9e      	ldr	r3, [pc, #632]	; (12ed0 <HAL_TIM_ConfigClockSource+0x5f4>)
   12c58:	429a      	cmp	r2, r3
   12c5a:	f040 80ba 	bne.w	12dd2 <HAL_TIM_ConfigClockSource+0x4f6>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   12c5e:	68ab      	ldr	r3, [r5, #8]
   12c60:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
   12c64:	f040 8122 	bne.w	12eac <HAL_TIM_ConfigClockSource+0x5d0>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12c68:	686b      	ldr	r3, [r5, #4]
   12c6a:	2b0a      	cmp	r3, #10
   12c6c:	bf18      	it	ne
   12c6e:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   12c72:	d003      	beq.n	12c7c <HAL_TIM_ConfigClockSource+0x3a0>
   12c74:	f033 0302 	bics.w	r3, r3, #2
   12c78:	f040 80c3 	bne.w	12e02 <HAL_TIM_ConfigClockSource+0x526>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12c7c:	68e9      	ldr	r1, [r5, #12]
   12c7e:	290f      	cmp	r1, #15
   12c80:	f200 80f9 	bhi.w	12e76 <HAL_TIM_ConfigClockSource+0x59a>
      TIM_ETR_SetConfig(htim->Instance,
   12c84:	6820      	ldr	r0, [r4, #0]
   12c86:	68ab      	ldr	r3, [r5, #8]
  tmpsmcr = TIMx->SMCR;
   12c88:	6882      	ldr	r2, [r0, #8]
   12c8a:	686d      	ldr	r5, [r5, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   12c8c:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
   12c90:	432b      	orrs	r3, r5
   12c92:	4313      	orrs	r3, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   12c94:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  TIMx->SMCR = tmpsmcr;
   12c98:	6083      	str	r3, [r0, #8]
      tmpsmcr = htim->Instance->SMCR;
   12c9a:	6822      	ldr	r2, [r4, #0]
   12c9c:	6893      	ldr	r3, [r2, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   12c9e:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
   12ca2:	6093      	str	r3, [r2, #8]
      break;
   12ca4:	e709      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   12ca6:	6822      	ldr	r2, [r4, #0]
   12ca8:	4b86      	ldr	r3, [pc, #536]	; (12ec4 <HAL_TIM_ConfigClockSource+0x5e8>)
   12caa:	4887      	ldr	r0, [pc, #540]	; (12ec8 <HAL_TIM_ConfigClockSource+0x5ec>)
   12cac:	429a      	cmp	r2, r3
   12cae:	bf18      	it	ne
   12cb0:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12cb4:	4985      	ldr	r1, [pc, #532]	; (12ecc <HAL_TIM_ConfigClockSource+0x5f0>)
   12cb6:	bf14      	ite	ne
   12cb8:	2301      	movne	r3, #1
   12cba:	2300      	moveq	r3, #0
   12cbc:	4282      	cmp	r2, r0
   12cbe:	bf0c      	ite	eq
   12cc0:	2300      	moveq	r3, #0
   12cc2:	f003 0301 	andne.w	r3, r3, #1
   12cc6:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   12cca:	428a      	cmp	r2, r1
   12ccc:	bf0c      	ite	eq
   12cce:	2300      	moveq	r3, #0
   12cd0:	f003 0301 	andne.w	r3, r3, #1
   12cd4:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
   12cd8:	4282      	cmp	r2, r0
   12cda:	bf0c      	ite	eq
   12cdc:	2300      	moveq	r3, #0
   12cde:	f003 0301 	andne.w	r3, r3, #1
   12ce2:	428a      	cmp	r2, r1
   12ce4:	bf0c      	ite	eq
   12ce6:	2300      	moveq	r3, #0
   12ce8:	f003 0301 	andne.w	r3, r3, #1
   12cec:	b11b      	cbz	r3, 12cf6 <HAL_TIM_ConfigClockSource+0x41a>
   12cee:	4b79      	ldr	r3, [pc, #484]	; (12ed4 <HAL_TIM_ConfigClockSource+0x5f8>)
   12cf0:	429a      	cmp	r2, r3
   12cf2:	f040 8098 	bne.w	12e26 <HAL_TIM_ConfigClockSource+0x54a>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12cf6:	686b      	ldr	r3, [r5, #4]
   12cf8:	2b0a      	cmp	r3, #10
   12cfa:	bf18      	it	ne
   12cfc:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   12d00:	d003      	beq.n	12d0a <HAL_TIM_ConfigClockSource+0x42e>
   12d02:	f033 0302 	bics.w	r3, r3, #2
   12d06:	f040 8088 	bne.w	12e1a <HAL_TIM_ConfigClockSource+0x53e>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12d0a:	68ee      	ldr	r6, [r5, #12]
   12d0c:	2e0f      	cmp	r6, #15
   12d0e:	f200 80ab 	bhi.w	12e68 <HAL_TIM_ConfigClockSource+0x58c>
      TIM_TI1_ConfigInputStage(htim->Instance,
   12d12:	6823      	ldr	r3, [r4, #0]
   12d14:	6868      	ldr	r0, [r5, #4]
  tmpccer = TIMx->CCER;
   12d16:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
   12d18:	6a1d      	ldr	r5, [r3, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   12d1a:	f022 020a 	bic.w	r2, r2, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
   12d1e:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
   12d22:	4310      	orrs	r0, r2
  tmpsmcr &= ~TIM_SMCR_TS;
   12d24:	4a6c      	ldr	r2, [pc, #432]	; (12ed8 <HAL_TIM_ConfigClockSource+0x5fc>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
   12d26:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
   12d28:	6999      	ldr	r1, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
   12d2a:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
   12d2e:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
  TIMx->CCMR1 = tmpccmr1;
   12d32:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
   12d34:	6218      	str	r0, [r3, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   12d36:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = TIMx->SMCR;
   12d38:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
   12d3a:	400a      	ands	r2, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   12d3c:	f042 0257 	orr.w	r2, r2, #87	; 0x57
  TIMx->SMCR = tmpsmcr;
   12d40:	609a      	str	r2, [r3, #8]
   12d42:	e6ba      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
  switch (sClockSourceConfig->ClockSource)
   12d44:	2b10      	cmp	r3, #16
   12d46:	d004      	beq.n	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12d48:	2b20      	cmp	r3, #32
   12d4a:	d002      	beq.n	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12d4c:	2b00      	cmp	r3, #0
   12d4e:	f47f aeb4 	bne.w	12aba <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   12d52:	6821      	ldr	r1, [r4, #0]
   12d54:	4a5b      	ldr	r2, [pc, #364]	; (12ec4 <HAL_TIM_ConfigClockSource+0x5e8>)
   12d56:	4e5c      	ldr	r6, [pc, #368]	; (12ec8 <HAL_TIM_ConfigClockSource+0x5ec>)
   12d58:	4291      	cmp	r1, r2
   12d5a:	bf18      	it	ne
   12d5c:	f1b1 4f80 	cmpne.w	r1, #1073741824	; 0x40000000
   12d60:	485a      	ldr	r0, [pc, #360]	; (12ecc <HAL_TIM_ConfigClockSource+0x5f0>)
   12d62:	bf14      	ite	ne
   12d64:	2201      	movne	r2, #1
   12d66:	2200      	moveq	r2, #0
   12d68:	42b1      	cmp	r1, r6
   12d6a:	bf0c      	ite	eq
   12d6c:	2200      	moveq	r2, #0
   12d6e:	f002 0201 	andne.w	r2, r2, #1
   12d72:	f506 6600 	add.w	r6, r6, #2048	; 0x800
   12d76:	4281      	cmp	r1, r0
   12d78:	bf0c      	ite	eq
   12d7a:	2200      	moveq	r2, #0
   12d7c:	f002 0201 	andne.w	r2, r2, #1
   12d80:	f500 407c 	add.w	r0, r0, #64512	; 0xfc00
   12d84:	42b1      	cmp	r1, r6
   12d86:	bf0c      	ite	eq
   12d88:	2200      	moveq	r2, #0
   12d8a:	f002 0201 	andne.w	r2, r2, #1
   12d8e:	4281      	cmp	r1, r0
   12d90:	bf0c      	ite	eq
   12d92:	2200      	moveq	r2, #0
   12d94:	f002 0201 	andne.w	r2, r2, #1
   12d98:	b112      	cbz	r2, 12da0 <HAL_TIM_ConfigClockSource+0x4c4>
   12d9a:	4a4e      	ldr	r2, [pc, #312]	; (12ed4 <HAL_TIM_ConfigClockSource+0x5f8>)
   12d9c:	4291      	cmp	r1, r2
   12d9e:	d148      	bne.n	12e32 <HAL_TIM_ConfigClockSource+0x556>
  tmpsmcr = TIMx->SMCR;
   12da0:	6888      	ldr	r0, [r1, #8]
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   12da2:	f043 0307 	orr.w	r3, r3, #7
  tmpsmcr &= ~TIM_SMCR_TS;
   12da6:	4a4c      	ldr	r2, [pc, #304]	; (12ed8 <HAL_TIM_ConfigClockSource+0x5fc>)
   12da8:	4002      	ands	r2, r0
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   12daa:	4313      	orrs	r3, r2
  TIMx->SMCR = tmpsmcr;
   12dac:	608b      	str	r3, [r1, #8]
   12dae:	e684      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
  switch (sClockSourceConfig->ClockSource)
   12db0:	4a4a      	ldr	r2, [pc, #296]	; (12edc <HAL_TIM_ConfigClockSource+0x600>)
   12db2:	4293      	cmp	r3, r2
   12db4:	d0cd      	beq.n	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12db6:	3210      	adds	r2, #16
   12db8:	4293      	cmp	r3, r2
   12dba:	d0ca      	beq.n	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12dbc:	3a20      	subs	r2, #32
   12dbe:	4293      	cmp	r3, r2
   12dc0:	f47f ae7b 	bne.w	12aba <HAL_TIM_ConfigClockSource+0x1de>
   12dc4:	e7c5      	b.n	12d52 <HAL_TIM_ConfigClockSource+0x476>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   12dc6:	f241 21ab 	movw	r1, #4779	; 0x12ab
   12dca:	4845      	ldr	r0, [pc, #276]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12dcc:	f006 fb22 	bl	19414 <assert_failed>
   12dd0:	e6ec      	b.n	12bac <HAL_TIM_ConfigClockSource+0x2d0>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   12dd2:	f241 2193 	movw	r1, #4755	; 0x1293
   12dd6:	4842      	ldr	r0, [pc, #264]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12dd8:	f006 fb1c 	bl	19414 <assert_failed>
   12ddc:	e73f      	b.n	12c5e <HAL_TIM_ConfigClockSource+0x382>
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   12dde:	f44f 5194 	mov.w	r1, #4736	; 0x1280
   12de2:	483f      	ldr	r0, [pc, #252]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12de4:	f006 fb16 	bl	19414 <assert_failed>
   12de8:	e597      	b.n	1291a <HAL_TIM_ConfigClockSource+0x3e>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12dea:	f241 21e2 	movw	r1, #4834	; 0x12e2
   12dee:	483c      	ldr	r0, [pc, #240]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12df0:	f006 fb10 	bl	19414 <assert_failed>
   12df4:	e5db      	b.n	129ae <HAL_TIM_ConfigClockSource+0xd2>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12df6:	f241 21d2 	movw	r1, #4818	; 0x12d2
   12dfa:	4839      	ldr	r0, [pc, #228]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12dfc:	f006 fb0a 	bl	19414 <assert_failed>
   12e00:	e695      	b.n	12b2e <HAL_TIM_ConfigClockSource+0x252>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12e02:	f241 2197 	movw	r1, #4759	; 0x1297
   12e06:	4836      	ldr	r0, [pc, #216]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e08:	f006 fb04 	bl	19414 <assert_failed>
   12e0c:	e736      	b.n	12c7c <HAL_TIM_ConfigClockSource+0x3a0>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12e0e:	f241 21af 	movw	r1, #4783	; 0x12af
   12e12:	4833      	ldr	r0, [pc, #204]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e14:	f006 fafe 	bl	19414 <assert_failed>
   12e18:	e6d7      	b.n	12bca <HAL_TIM_ConfigClockSource+0x2ee>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12e1a:	f241 21c2 	movw	r1, #4802	; 0x12c2
   12e1e:	4830      	ldr	r0, [pc, #192]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e20:	f006 faf8 	bl	19414 <assert_failed>
   12e24:	e771      	b.n	12d0a <HAL_TIM_ConfigClockSource+0x42e>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   12e26:	f241 21bf 	movw	r1, #4799	; 0x12bf
   12e2a:	482d      	ldr	r0, [pc, #180]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e2c:	f006 faf2 	bl	19414 <assert_failed>
   12e30:	e761      	b.n	12cf6 <HAL_TIM_ConfigClockSource+0x41a>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   12e32:	f241 21f7 	movw	r1, #4855	; 0x12f7
   12e36:	482a      	ldr	r0, [pc, #168]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e38:	f006 faec 	bl	19414 <assert_failed>
   12e3c:	682b      	ldr	r3, [r5, #0]
   12e3e:	6821      	ldr	r1, [r4, #0]
   12e40:	e7ae      	b.n	12da0 <HAL_TIM_ConfigClockSource+0x4c4>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   12e42:	f241 21cf 	movw	r1, #4815	; 0x12cf
   12e46:	4826      	ldr	r0, [pc, #152]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e48:	f006 fae4 	bl	19414 <assert_failed>
   12e4c:	e665      	b.n	12b1a <HAL_TIM_ConfigClockSource+0x23e>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   12e4e:	f241 21df 	movw	r1, #4831	; 0x12df
   12e52:	4823      	ldr	r0, [pc, #140]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e54:	f006 fade 	bl	19414 <assert_failed>
   12e58:	e59f      	b.n	1299a <HAL_TIM_ConfigClockSource+0xbe>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12e5a:	f241 21b0 	movw	r1, #4784	; 0x12b0
   12e5e:	4820      	ldr	r0, [pc, #128]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e60:	f006 fad8 	bl	19414 <assert_failed>
   12e64:	68e9      	ldr	r1, [r5, #12]
   12e66:	e6b4      	b.n	12bd2 <HAL_TIM_ConfigClockSource+0x2f6>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12e68:	f241 21c3 	movw	r1, #4803	; 0x12c3
   12e6c:	481c      	ldr	r0, [pc, #112]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e6e:	f006 fad1 	bl	19414 <assert_failed>
   12e72:	68ee      	ldr	r6, [r5, #12]
   12e74:	e74d      	b.n	12d12 <HAL_TIM_ConfigClockSource+0x436>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12e76:	f241 2198 	movw	r1, #4760	; 0x1298
   12e7a:	4819      	ldr	r0, [pc, #100]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e7c:	f006 faca 	bl	19414 <assert_failed>
   12e80:	68e9      	ldr	r1, [r5, #12]
   12e82:	e6ff      	b.n	12c84 <HAL_TIM_ConfigClockSource+0x3a8>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12e84:	f241 21d3 	movw	r1, #4819	; 0x12d3
   12e88:	4815      	ldr	r0, [pc, #84]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e8a:	f006 fac3 	bl	19414 <assert_failed>
   12e8e:	68ee      	ldr	r6, [r5, #12]
   12e90:	e651      	b.n	12b36 <HAL_TIM_ConfigClockSource+0x25a>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12e92:	f241 21e3 	movw	r1, #4835	; 0x12e3
   12e96:	4812      	ldr	r0, [pc, #72]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e98:	f006 fabc 	bl	19414 <assert_failed>
   12e9c:	68ee      	ldr	r6, [r5, #12]
   12e9e:	e58a      	b.n	129b6 <HAL_TIM_ConfigClockSource+0xda>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   12ea0:	f241 21ae 	movw	r1, #4782	; 0x12ae
   12ea4:	480e      	ldr	r0, [pc, #56]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12ea6:	f006 fab5 	bl	19414 <assert_failed>
   12eaa:	e684      	b.n	12bb6 <HAL_TIM_ConfigClockSource+0x2da>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   12eac:	f241 2196 	movw	r1, #4758	; 0x1296
   12eb0:	480b      	ldr	r0, [pc, #44]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12eb2:	f006 faaf 	bl	19414 <assert_failed>
   12eb6:	e6d7      	b.n	12c68 <HAL_TIM_ConfigClockSource+0x38c>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
   12eb8:	f241 218c 	movw	r1, #4748	; 0x128c
   12ebc:	4808      	ldr	r0, [pc, #32]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12ebe:	f006 faa9 	bl	19414 <assert_failed>
   12ec2:	e5fa      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
   12ec4:	40010000 	.word	0x40010000
   12ec8:	40000400 	.word	0x40000400
   12ecc:	40000800 	.word	0x40000800
   12ed0:	40010400 	.word	0x40010400
   12ed4:	40014000 	.word	0x40014000
   12ed8:	ffcfff8f 	.word	0xffcfff8f
   12edc:	00100030 	.word	0x00100030
   12ee0:	0002ff4c 	.word	0x0002ff4c

00012ee4 <TIM_OC2_SetConfig>:
{
   12ee4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
   12ee8:	6a02      	ldr	r2, [r0, #32]
{
   12eea:	460e      	mov	r6, r1
   12eec:	4604      	mov	r4, r0
  tmpccmrx &= ~TIM_CCMR1_CC2S;
   12eee:	4b31      	ldr	r3, [pc, #196]	; (12fb4 <TIM_OC2_SetConfig+0xd0>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
   12ef0:	f022 0210 	bic.w	r2, r2, #16
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   12ef4:	4930      	ldr	r1, [pc, #192]	; (12fb8 <TIM_OC2_SetConfig+0xd4>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
   12ef6:	6202      	str	r2, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   12ef8:	428c      	cmp	r4, r1
  tmpccer = TIMx->CCER;
   12efa:	6a05      	ldr	r5, [r0, #32]
  tmpcr2 =  TIMx->CR2;
   12efc:	6847      	ldr	r7, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
   12efe:	6982      	ldr	r2, [r0, #24]
  tmpccer &= ~TIM_CCER_CC2P;
   12f00:	f025 0520 	bic.w	r5, r5, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
   12f04:	68b0      	ldr	r0, [r6, #8]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
   12f06:	ea03 0302 	and.w	r3, r3, r2
  tmpccmrx |= (OC_Config->OCMode << 8U);
   12f0a:	6832      	ldr	r2, [r6, #0]
  tmpccer |= (OC_Config->OCPolarity << 4U);
   12f0c:	ea45 1500 	orr.w	r5, r5, r0, lsl #4
  tmpccmrx |= (OC_Config->OCMode << 8U);
   12f10:	ea43 2802 	orr.w	r8, r3, r2, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   12f14:	d023      	beq.n	12f5e <TIM_OC2_SetConfig+0x7a>
   12f16:	4b29      	ldr	r3, [pc, #164]	; (12fbc <TIM_OC2_SetConfig+0xd8>)
   12f18:	429c      	cmp	r4, r3
   12f1a:	d020      	beq.n	12f5e <TIM_OC2_SetConfig+0x7a>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   12f1c:	4a28      	ldr	r2, [pc, #160]	; (12fc0 <TIM_OC2_SetConfig+0xdc>)
   12f1e:	4b29      	ldr	r3, [pc, #164]	; (12fc4 <TIM_OC2_SetConfig+0xe0>)
   12f20:	429c      	cmp	r4, r3
   12f22:	bf18      	it	ne
   12f24:	4294      	cmpne	r4, r2
   12f26:	d003      	beq.n	12f30 <TIM_OC2_SetConfig+0x4c>
   12f28:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12f2c:	429c      	cmp	r4, r3
   12f2e:	d10e      	bne.n	12f4e <TIM_OC2_SetConfig+0x6a>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   12f30:	69b3      	ldr	r3, [r6, #24]
   12f32:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   12f36:	d120      	bne.n	12f7a <TIM_OC2_SetConfig+0x96>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   12f38:	6971      	ldr	r1, [r6, #20]
   12f3a:	f431 7380 	bics.w	r3, r1, #256	; 0x100
   12f3e:	d125      	bne.n	12f8c <TIM_OC2_SetConfig+0xa8>
    tmpcr2 &= ~TIM_CR2_OIS2N;
   12f40:	f427 6240 	bic.w	r2, r7, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   12f44:	69b3      	ldr	r3, [r6, #24]
   12f46:	ea42 0283 	orr.w	r2, r2, r3, lsl #2
   12f4a:	ea42 0781 	orr.w	r7, r2, r1, lsl #2
  TIMx->CR2 = tmpcr2;
   12f4e:	6067      	str	r7, [r4, #4]
  TIMx->CCMR1 = tmpccmrx;
   12f50:	f8c4 8018 	str.w	r8, [r4, #24]
  TIMx->CCR2 = OC_Config->Pulse;
   12f54:	6873      	ldr	r3, [r6, #4]
   12f56:	63a3      	str	r3, [r4, #56]	; 0x38
  TIMx->CCER = tmpccer;
   12f58:	6225      	str	r5, [r4, #32]
}
   12f5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   12f5e:	68f3      	ldr	r3, [r6, #12]
   12f60:	f033 0208 	bics.w	r2, r3, #8
   12f64:	d119      	bne.n	12f9a <TIM_OC2_SetConfig+0xb6>
    tmpccer &= ~TIM_CCER_CC2NP;
   12f66:	f025 0580 	bic.w	r5, r5, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
   12f6a:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
   12f6e:	f025 0540 	bic.w	r5, r5, #64	; 0x40
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   12f72:	69b3      	ldr	r3, [r6, #24]
   12f74:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   12f78:	d0de      	beq.n	12f38 <TIM_OC2_SetConfig+0x54>
   12f7a:	f641 015f 	movw	r1, #6239	; 0x185f
   12f7e:	4812      	ldr	r0, [pc, #72]	; (12fc8 <TIM_OC2_SetConfig+0xe4>)
   12f80:	f006 fa48 	bl	19414 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   12f84:	6971      	ldr	r1, [r6, #20]
   12f86:	f431 7380 	bics.w	r3, r1, #256	; 0x100
   12f8a:	d0d9      	beq.n	12f40 <TIM_OC2_SetConfig+0x5c>
   12f8c:	f44f 51c3 	mov.w	r1, #6240	; 0x1860
   12f90:	480d      	ldr	r0, [pc, #52]	; (12fc8 <TIM_OC2_SetConfig+0xe4>)
   12f92:	f006 fa3f 	bl	19414 <assert_failed>
   12f96:	6971      	ldr	r1, [r6, #20]
   12f98:	e7d2      	b.n	12f40 <TIM_OC2_SetConfig+0x5c>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   12f9a:	f641 0151 	movw	r1, #6225	; 0x1851
   12f9e:	480a      	ldr	r0, [pc, #40]	; (12fc8 <TIM_OC2_SetConfig+0xe4>)
   12fa0:	f006 fa38 	bl	19414 <assert_failed>
    tmpccer &= ~TIM_CCER_CC2NP;
   12fa4:	f025 0580 	bic.w	r5, r5, #128	; 0x80
   12fa8:	68f3      	ldr	r3, [r6, #12]
    tmpccer |= (OC_Config->OCNPolarity << 4U);
   12faa:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
   12fae:	f025 0540 	bic.w	r5, r5, #64	; 0x40
   12fb2:	e7de      	b.n	12f72 <TIM_OC2_SetConfig+0x8e>
   12fb4:	feff8cff 	.word	0xfeff8cff
   12fb8:	40010000 	.word	0x40010000
   12fbc:	40010400 	.word	0x40010400
   12fc0:	40014000 	.word	0x40014000
   12fc4:	40014400 	.word	0x40014400
   12fc8:	0002ff4c 	.word	0x0002ff4c

00012fcc <HAL_TIM_PWM_ConfigChannel>:
  assert_param(IS_TIM_CHANNELS(Channel));
   12fcc:	2a14      	cmp	r2, #20
{
   12fce:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   12fd2:	4616      	mov	r6, r2
   12fd4:	4604      	mov	r4, r0
   12fd6:	460d      	mov	r5, r1
  assert_param(IS_TIM_CHANNELS(Channel));
   12fd8:	f240 80a2 	bls.w	13120 <HAL_TIM_PWM_ConfigChannel+0x154>
   12fdc:	2a3c      	cmp	r2, #60	; 0x3c
   12fde:	f040 80a4 	bne.w	1312a <HAL_TIM_PWM_ConfigChannel+0x15e>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   12fe2:	682b      	ldr	r3, [r5, #0]
   12fe4:	4a9b      	ldr	r2, [pc, #620]	; (13254 <HAL_TIM_PWM_ConfigChannel+0x288>)
   12fe6:	f023 0110 	bic.w	r1, r3, #16
   12fea:	4291      	cmp	r1, r2
   12fec:	d004      	beq.n	12ff8 <HAL_TIM_PWM_ConfigChannel+0x2c>
   12fee:	4a9a      	ldr	r2, [pc, #616]	; (13258 <HAL_TIM_PWM_ConfigChannel+0x28c>)
   12ff0:	401a      	ands	r2, r3
   12ff2:	2a60      	cmp	r2, #96	; 0x60
   12ff4:	f040 8235 	bne.w	13462 <HAL_TIM_PWM_ConfigChannel+0x496>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   12ff8:	68ab      	ldr	r3, [r5, #8]
   12ffa:	f033 0302 	bics.w	r3, r3, #2
   12ffe:	f040 809a 	bne.w	13136 <HAL_TIM_PWM_ConfigChannel+0x16a>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   13002:	692b      	ldr	r3, [r5, #16]
   13004:	f033 0304 	bics.w	r3, r3, #4
   13008:	f040 809f 	bne.w	1314a <HAL_TIM_PWM_ConfigChannel+0x17e>
  __HAL_LOCK(htim);
   1300c:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   13010:	2b01      	cmp	r3, #1
   13012:	f000 80a4 	beq.w	1315e <HAL_TIM_PWM_ConfigChannel+0x192>
   13016:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
   13018:	2302      	movs	r3, #2
  __HAL_LOCK(htim);
   1301a:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
   1301e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  switch (Channel)
   13022:	2e14      	cmp	r6, #20
   13024:	d873      	bhi.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
   13026:	e8df f016 	tbh	[pc, r6, lsl #1]
   1302a:	0015      	.short	0x0015
   1302c:	00720072 	.word	0x00720072
   13030:	009d0072 	.word	0x009d0072
   13034:	00720072 	.word	0x00720072
   13038:	00e00072 	.word	0x00e00072
   1303c:	00720072 	.word	0x00720072
   13040:	01290072 	.word	0x01290072
   13044:	00720072 	.word	0x00720072
   13048:	018e0072 	.word	0x018e0072
   1304c:	00720072 	.word	0x00720072
   13050:	01d50072 	.word	0x01d50072
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   13054:	6820      	ldr	r0, [r4, #0]
   13056:	4b81      	ldr	r3, [pc, #516]	; (1325c <HAL_TIM_PWM_ConfigChannel+0x290>)
   13058:	4a81      	ldr	r2, [pc, #516]	; (13260 <HAL_TIM_PWM_ConfigChannel+0x294>)
   1305a:	4298      	cmp	r0, r3
   1305c:	bf18      	it	ne
   1305e:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
   13062:	4980      	ldr	r1, [pc, #512]	; (13264 <HAL_TIM_PWM_ConfigChannel+0x298>)
   13064:	bf14      	ite	ne
   13066:	2301      	movne	r3, #1
   13068:	2300      	moveq	r3, #0
   1306a:	4290      	cmp	r0, r2
   1306c:	bf0c      	ite	eq
   1306e:	2300      	moveq	r3, #0
   13070:	f003 0301 	andne.w	r3, r3, #1
   13074:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   13078:	4288      	cmp	r0, r1
   1307a:	bf0c      	ite	eq
   1307c:	2300      	moveq	r3, #0
   1307e:	f003 0301 	andne.w	r3, r3, #1
   13082:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
   13086:	4290      	cmp	r0, r2
   13088:	bf0c      	ite	eq
   1308a:	2300      	moveq	r3, #0
   1308c:	f003 0301 	andne.w	r3, r3, #1
   13090:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
   13094:	4288      	cmp	r0, r1
   13096:	bf0c      	ite	eq
   13098:	2300      	moveq	r3, #0
   1309a:	f003 0301 	andne.w	r3, r3, #1
   1309e:	f5a1 4168 	sub.w	r1, r1, #59392	; 0xe800
   130a2:	4290      	cmp	r0, r2
   130a4:	bf0c      	ite	eq
   130a6:	2300      	moveq	r3, #0
   130a8:	f003 0301 	andne.w	r3, r3, #1
   130ac:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   130b0:	4288      	cmp	r0, r1
   130b2:	bf0c      	ite	eq
   130b4:	2300      	moveq	r3, #0
   130b6:	f003 0301 	andne.w	r3, r3, #1
   130ba:	f501 3192 	add.w	r1, r1, #74752	; 0x12400
   130be:	4290      	cmp	r0, r2
   130c0:	bf0c      	ite	eq
   130c2:	2300      	moveq	r3, #0
   130c4:	f003 0301 	andne.w	r3, r3, #1
   130c8:	f502 3292 	add.w	r2, r2, #74752	; 0x12400
   130cc:	4288      	cmp	r0, r1
   130ce:	bf0c      	ite	eq
   130d0:	2300      	moveq	r3, #0
   130d2:	f003 0301 	andne.w	r3, r3, #1
   130d6:	4290      	cmp	r0, r2
   130d8:	bf0c      	ite	eq
   130da:	2300      	moveq	r3, #0
   130dc:	f003 0301 	andne.w	r3, r3, #1
   130e0:	b11b      	cbz	r3, 130ea <HAL_TIM_PWM_ConfigChannel+0x11e>
   130e2:	4b61      	ldr	r3, [pc, #388]	; (13268 <HAL_TIM_PWM_ConfigChannel+0x29c>)
   130e4:	4298      	cmp	r0, r3
   130e6:	f040 81ec 	bne.w	134c2 <HAL_TIM_PWM_ConfigChannel+0x4f6>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
   130ea:	4629      	mov	r1, r5
   130ec:	f7fe ffe6 	bl	120bc <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   130f0:	6822      	ldr	r2, [r4, #0]
   130f2:	6993      	ldr	r3, [r2, #24]
   130f4:	f043 0308 	orr.w	r3, r3, #8
   130f8:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   130fa:	6822      	ldr	r2, [r4, #0]
   130fc:	6993      	ldr	r3, [r2, #24]
   130fe:	f023 0304 	bic.w	r3, r3, #4
   13102:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
   13104:	6822      	ldr	r2, [r4, #0]
   13106:	6929      	ldr	r1, [r5, #16]
   13108:	6993      	ldr	r3, [r2, #24]
   1310a:	430b      	orrs	r3, r1
   1310c:	6193      	str	r3, [r2, #24]
  __HAL_UNLOCK(htim);
   1310e:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
   13110:	2201      	movs	r2, #1
  return HAL_OK;
   13112:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
   13114:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
   13118:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
   1311c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_TIM_CHANNELS(Channel));
   13120:	4b52      	ldr	r3, [pc, #328]	; (1326c <HAL_TIM_PWM_ConfigChannel+0x2a0>)
   13122:	40d3      	lsrs	r3, r2
   13124:	07db      	lsls	r3, r3, #31
   13126:	f53f af5c 	bmi.w	12fe2 <HAL_TIM_PWM_ConfigChannel+0x16>
   1312a:	f640 611c 	movw	r1, #3612	; 0xe1c
   1312e:	4850      	ldr	r0, [pc, #320]	; (13270 <HAL_TIM_PWM_ConfigChannel+0x2a4>)
   13130:	f006 f970 	bl	19414 <assert_failed>
   13134:	e755      	b.n	12fe2 <HAL_TIM_PWM_ConfigChannel+0x16>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   13136:	f640 611e 	movw	r1, #3614	; 0xe1e
   1313a:	484d      	ldr	r0, [pc, #308]	; (13270 <HAL_TIM_PWM_ConfigChannel+0x2a4>)
   1313c:	f006 f96a 	bl	19414 <assert_failed>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   13140:	692b      	ldr	r3, [r5, #16]
   13142:	f033 0304 	bics.w	r3, r3, #4
   13146:	f43f af61 	beq.w	1300c <HAL_TIM_PWM_ConfigChannel+0x40>
   1314a:	f640 611f 	movw	r1, #3615	; 0xe1f
   1314e:	4848      	ldr	r0, [pc, #288]	; (13270 <HAL_TIM_PWM_ConfigChannel+0x2a4>)
   13150:	f006 f960 	bl	19414 <assert_failed>
  __HAL_LOCK(htim);
   13154:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   13158:	2b01      	cmp	r3, #1
   1315a:	f47f af5c 	bne.w	13016 <HAL_TIM_PWM_ConfigChannel+0x4a>
   1315e:	2002      	movs	r0, #2
}
   13160:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   13164:	6820      	ldr	r0, [r4, #0]
   13166:	4b3d      	ldr	r3, [pc, #244]	; (1325c <HAL_TIM_PWM_ConfigChannel+0x290>)
   13168:	4a3d      	ldr	r2, [pc, #244]	; (13260 <HAL_TIM_PWM_ConfigChannel+0x294>)
   1316a:	4298      	cmp	r0, r3
   1316c:	bf18      	it	ne
   1316e:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
   13172:	493c      	ldr	r1, [pc, #240]	; (13264 <HAL_TIM_PWM_ConfigChannel+0x298>)
   13174:	bf14      	ite	ne
   13176:	2301      	movne	r3, #1
   13178:	2300      	moveq	r3, #0
   1317a:	4290      	cmp	r0, r2
   1317c:	bf0c      	ite	eq
   1317e:	2300      	moveq	r3, #0
   13180:	f003 0301 	andne.w	r3, r3, #1
   13184:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   13188:	4288      	cmp	r0, r1
   1318a:	bf0c      	ite	eq
   1318c:	2300      	moveq	r3, #0
   1318e:	f003 0301 	andne.w	r3, r3, #1
   13192:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
   13196:	4290      	cmp	r0, r2
   13198:	bf0c      	ite	eq
   1319a:	2300      	moveq	r3, #0
   1319c:	f003 0301 	andne.w	r3, r3, #1
   131a0:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
   131a4:	4288      	cmp	r0, r1
   131a6:	bf0c      	ite	eq
   131a8:	2300      	moveq	r3, #0
   131aa:	f003 0301 	andne.w	r3, r3, #1
   131ae:	4290      	cmp	r0, r2
   131b0:	bf0c      	ite	eq
   131b2:	2300      	moveq	r3, #0
   131b4:	f003 0301 	andne.w	r3, r3, #1
   131b8:	b11b      	cbz	r3, 131c2 <HAL_TIM_PWM_ConfigChannel+0x1f6>
   131ba:	4b2e      	ldr	r3, [pc, #184]	; (13274 <HAL_TIM_PWM_ConfigChannel+0x2a8>)
   131bc:	4298      	cmp	r0, r3
   131be:	f040 8179 	bne.w	134b4 <HAL_TIM_PWM_ConfigChannel+0x4e8>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
   131c2:	4629      	mov	r1, r5
   131c4:	f7ff fe8e 	bl	12ee4 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   131c8:	6822      	ldr	r2, [r4, #0]
   131ca:	6993      	ldr	r3, [r2, #24]
   131cc:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   131d0:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   131d2:	6822      	ldr	r2, [r4, #0]
   131d4:	6993      	ldr	r3, [r2, #24]
   131d6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   131da:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   131dc:	6822      	ldr	r2, [r4, #0]
   131de:	6929      	ldr	r1, [r5, #16]
   131e0:	6993      	ldr	r3, [r2, #24]
   131e2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   131e6:	6193      	str	r3, [r2, #24]
      break;
   131e8:	e791      	b.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   131ea:	6820      	ldr	r0, [r4, #0]
   131ec:	4b1b      	ldr	r3, [pc, #108]	; (1325c <HAL_TIM_PWM_ConfigChannel+0x290>)
   131ee:	4a1c      	ldr	r2, [pc, #112]	; (13260 <HAL_TIM_PWM_ConfigChannel+0x294>)
   131f0:	4298      	cmp	r0, r3
   131f2:	bf18      	it	ne
   131f4:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
   131f8:	491a      	ldr	r1, [pc, #104]	; (13264 <HAL_TIM_PWM_ConfigChannel+0x298>)
   131fa:	bf14      	ite	ne
   131fc:	2301      	movne	r3, #1
   131fe:	2300      	moveq	r3, #0
   13200:	4290      	cmp	r0, r2
   13202:	bf0c      	ite	eq
   13204:	2300      	moveq	r3, #0
   13206:	f003 0301 	andne.w	r3, r3, #1
   1320a:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   1320e:	4288      	cmp	r0, r1
   13210:	bf0c      	ite	eq
   13212:	2300      	moveq	r3, #0
   13214:	f003 0301 	andne.w	r3, r3, #1
   13218:	4290      	cmp	r0, r2
   1321a:	bf0c      	ite	eq
   1321c:	2300      	moveq	r3, #0
   1321e:	f003 0301 	andne.w	r3, r3, #1
   13222:	b11b      	cbz	r3, 1322c <HAL_TIM_PWM_ConfigChannel+0x260>
   13224:	4b14      	ldr	r3, [pc, #80]	; (13278 <HAL_TIM_PWM_ConfigChannel+0x2ac>)
   13226:	4298      	cmp	r0, r3
   13228:	f040 813d 	bne.w	134a6 <HAL_TIM_PWM_ConfigChannel+0x4da>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
   1322c:	4629      	mov	r1, r5
   1322e:	f7fe ffcd 	bl	121cc <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   13232:	6822      	ldr	r2, [r4, #0]
   13234:	69d3      	ldr	r3, [r2, #28]
   13236:	f043 0308 	orr.w	r3, r3, #8
   1323a:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   1323c:	6822      	ldr	r2, [r4, #0]
   1323e:	69d3      	ldr	r3, [r2, #28]
   13240:	f023 0304 	bic.w	r3, r3, #4
   13244:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
   13246:	6822      	ldr	r2, [r4, #0]
   13248:	6929      	ldr	r1, [r5, #16]
   1324a:	69d3      	ldr	r3, [r2, #28]
   1324c:	430b      	orrs	r3, r1
   1324e:	61d3      	str	r3, [r2, #28]
      break;
   13250:	e75d      	b.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
   13252:	bf00      	nop
   13254:	00010040 	.word	0x00010040
   13258:	fffeffef 	.word	0xfffeffef
   1325c:	40010000 	.word	0x40010000
   13260:	40000400 	.word	0x40000400
   13264:	40000800 	.word	0x40000800
   13268:	40014800 	.word	0x40014800
   1326c:	00111111 	.word	0x00111111
   13270:	0002ff4c 	.word	0x0002ff4c
   13274:	40014000 	.word	0x40014000
   13278:	40010400 	.word	0x40010400
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   1327c:	6826      	ldr	r6, [r4, #0]
   1327e:	4b94      	ldr	r3, [pc, #592]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
   13280:	4a94      	ldr	r2, [pc, #592]	; (134d4 <HAL_TIM_PWM_ConfigChannel+0x508>)
   13282:	429e      	cmp	r6, r3
   13284:	bf18      	it	ne
   13286:	f1b6 4f80 	cmpne.w	r6, #1073741824	; 0x40000000
   1328a:	4993      	ldr	r1, [pc, #588]	; (134d8 <HAL_TIM_PWM_ConfigChannel+0x50c>)
   1328c:	bf14      	ite	ne
   1328e:	2301      	movne	r3, #1
   13290:	2300      	moveq	r3, #0
   13292:	4296      	cmp	r6, r2
   13294:	bf0c      	ite	eq
   13296:	2300      	moveq	r3, #0
   13298:	f003 0301 	andne.w	r3, r3, #1
   1329c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   132a0:	428e      	cmp	r6, r1
   132a2:	bf0c      	ite	eq
   132a4:	2300      	moveq	r3, #0
   132a6:	f003 0301 	andne.w	r3, r3, #1
   132aa:	4296      	cmp	r6, r2
   132ac:	bf0c      	ite	eq
   132ae:	2300      	moveq	r3, #0
   132b0:	f003 0301 	andne.w	r3, r3, #1
   132b4:	b11b      	cbz	r3, 132be <HAL_TIM_PWM_ConfigChannel+0x2f2>
   132b6:	4b89      	ldr	r3, [pc, #548]	; (134dc <HAL_TIM_PWM_ConfigChannel+0x510>)
   132b8:	429e      	cmp	r6, r3
   132ba:	f040 80ed 	bne.w	13498 <HAL_TIM_PWM_ConfigChannel+0x4cc>
  TIMx->CCER &= ~TIM_CCER_CC4E;
   132be:	6a33      	ldr	r3, [r6, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   132c0:	4983      	ldr	r1, [pc, #524]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
  TIMx->CCER &= ~TIM_CCER_CC4E;
   132c2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   132c6:	428e      	cmp	r6, r1
  TIMx->CCER &= ~TIM_CCER_CC4E;
   132c8:	6233      	str	r3, [r6, #32]
  tmpccer = TIMx->CCER;
   132ca:	6a33      	ldr	r3, [r6, #32]
  tmpcr2 =  TIMx->CR2;
   132cc:	f8d6 9004 	ldr.w	r9, [r6, #4]
  tmpccmrx = TIMx->CCMR2;
   132d0:	69f7      	ldr	r7, [r6, #28]
  tmpccer &= ~TIM_CCER_CC4P;
   132d2:	f423 5800 	bic.w	r8, r3, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
   132d6:	68aa      	ldr	r2, [r5, #8]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
   132d8:	f427 47e6 	bic.w	r7, r7, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
   132dc:	682b      	ldr	r3, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 12U);
   132de:	ea48 3802 	orr.w	r8, r8, r2, lsl #12
  tmpccmrx |= (OC_Config->OCMode << 8U);
   132e2:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   132e6:	d00d      	beq.n	13304 <HAL_TIM_PWM_ConfigChannel+0x338>
   132e8:	4b7c      	ldr	r3, [pc, #496]	; (134dc <HAL_TIM_PWM_ConfigChannel+0x510>)
   132ea:	429e      	cmp	r6, r3
   132ec:	d00a      	beq.n	13304 <HAL_TIM_PWM_ConfigChannel+0x338>
   132ee:	4a7c      	ldr	r2, [pc, #496]	; (134e0 <HAL_TIM_PWM_ConfigChannel+0x514>)
   132f0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   132f4:	429e      	cmp	r6, r3
   132f6:	bf18      	it	ne
   132f8:	4296      	cmpne	r6, r2
   132fa:	d003      	beq.n	13304 <HAL_TIM_PWM_ConfigChannel+0x338>
   132fc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   13300:	429e      	cmp	r6, r3
   13302:	d108      	bne.n	13316 <HAL_TIM_PWM_ConfigChannel+0x34a>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   13304:	696b      	ldr	r3, [r5, #20]
   13306:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   1330a:	f040 80be 	bne.w	1348a <HAL_TIM_PWM_ConfigChannel+0x4be>
    tmpcr2 &= ~TIM_CR2_OIS4;
   1330e:	f429 4980 	bic.w	r9, r9, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
   13312:	ea49 1983 	orr.w	r9, r9, r3, lsl #6
  TIMx->CR2 = tmpcr2;
   13316:	f8c6 9004 	str.w	r9, [r6, #4]
  TIMx->CCMR2 = tmpccmrx;
   1331a:	61f7      	str	r7, [r6, #28]
  TIMx->CCR4 = OC_Config->Pulse;
   1331c:	686b      	ldr	r3, [r5, #4]
   1331e:	6433      	str	r3, [r6, #64]	; 0x40
  TIMx->CCER = tmpccer;
   13320:	f8c6 8020 	str.w	r8, [r6, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   13324:	6822      	ldr	r2, [r4, #0]
   13326:	69d3      	ldr	r3, [r2, #28]
   13328:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   1332c:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   1332e:	6822      	ldr	r2, [r4, #0]
   13330:	69d3      	ldr	r3, [r2, #28]
   13332:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   13336:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
   13338:	6822      	ldr	r2, [r4, #0]
   1333a:	6929      	ldr	r1, [r5, #16]
   1333c:	69d3      	ldr	r3, [r2, #28]
   1333e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   13342:	61d3      	str	r3, [r2, #28]
      break;
   13344:	e6e3      	b.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   13346:	6823      	ldr	r3, [r4, #0]
   13348:	4a61      	ldr	r2, [pc, #388]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
   1334a:	4293      	cmp	r3, r2
   1334c:	d004      	beq.n	13358 <HAL_TIM_PWM_ConfigChannel+0x38c>
   1334e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   13352:	4293      	cmp	r3, r2
   13354:	f040 8092 	bne.w	1347c <HAL_TIM_PWM_ConfigChannel+0x4b0>
  TIMx->CCER &= ~TIM_CCER_CC5E;
   13358:	6a1a      	ldr	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   1335a:	4f5d      	ldr	r7, [pc, #372]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
  TIMx->CCER &= ~TIM_CCER_CC5E;
   1335c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   13360:	42bb      	cmp	r3, r7
  TIMx->CCER &= ~TIM_CCER_CC5E;
   13362:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
   13364:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
   13366:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
   1336a:	6d59      	ldr	r1, [r3, #84]	; 0x54
  tmpccer &= ~TIM_CCER_CC5P;
   1336c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
   13370:	68ae      	ldr	r6, [r5, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
   13372:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpccmrx |= OC_Config->OCMode;
   13376:	6828      	ldr	r0, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 16U);
   13378:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
  tmpccmrx |= OC_Config->OCMode;
   1337c:	ea41 0100 	orr.w	r1, r1, r0
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   13380:	d00d      	beq.n	1339e <HAL_TIM_PWM_ConfigChannel+0x3d2>
   13382:	4856      	ldr	r0, [pc, #344]	; (134dc <HAL_TIM_PWM_ConfigChannel+0x510>)
   13384:	4283      	cmp	r3, r0
   13386:	d00a      	beq.n	1339e <HAL_TIM_PWM_ConfigChannel+0x3d2>
   13388:	4e55      	ldr	r6, [pc, #340]	; (134e0 <HAL_TIM_PWM_ConfigChannel+0x514>)
   1338a:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
   1338e:	4283      	cmp	r3, r0
   13390:	bf18      	it	ne
   13392:	42b3      	cmpne	r3, r6
   13394:	d003      	beq.n	1339e <HAL_TIM_PWM_ConfigChannel+0x3d2>
   13396:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   1339a:	4283      	cmp	r3, r0
   1339c:	d104      	bne.n	133a8 <HAL_TIM_PWM_ConfigChannel+0x3dc>
    tmpcr2 &= ~TIM_CR2_OIS5;
   1339e:	f42c 3c80 	bic.w	ip, ip, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
   133a2:	6968      	ldr	r0, [r5, #20]
   133a4:	ea4c 2c00 	orr.w	ip, ip, r0, lsl #8
  TIMx->CR2 = tmpcr2;
   133a8:	f8c3 c004 	str.w	ip, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
   133ac:	6559      	str	r1, [r3, #84]	; 0x54
  TIMx->CCR5 = OC_Config->Pulse;
   133ae:	6869      	ldr	r1, [r5, #4]
   133b0:	6599      	str	r1, [r3, #88]	; 0x58
  TIMx->CCER = tmpccer;
   133b2:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
   133b4:	6822      	ldr	r2, [r4, #0]
   133b6:	6d53      	ldr	r3, [r2, #84]	; 0x54
   133b8:	f043 0308 	orr.w	r3, r3, #8
   133bc:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
   133be:	6822      	ldr	r2, [r4, #0]
   133c0:	6d53      	ldr	r3, [r2, #84]	; 0x54
   133c2:	f023 0304 	bic.w	r3, r3, #4
   133c6:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
   133c8:	6822      	ldr	r2, [r4, #0]
   133ca:	6929      	ldr	r1, [r5, #16]
   133cc:	6d53      	ldr	r3, [r2, #84]	; 0x54
   133ce:	430b      	orrs	r3, r1
   133d0:	6553      	str	r3, [r2, #84]	; 0x54
      break;
   133d2:	e69c      	b.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   133d4:	6823      	ldr	r3, [r4, #0]
   133d6:	4a3e      	ldr	r2, [pc, #248]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
   133d8:	4293      	cmp	r3, r2
   133da:	d003      	beq.n	133e4 <HAL_TIM_PWM_ConfigChannel+0x418>
   133dc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   133e0:	4293      	cmp	r3, r2
   133e2:	d144      	bne.n	1346e <HAL_TIM_PWM_ConfigChannel+0x4a2>
  TIMx->CCER &= ~TIM_CCER_CC6E;
   133e4:	6a1a      	ldr	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   133e6:	4f3a      	ldr	r7, [pc, #232]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
  TIMx->CCER &= ~TIM_CCER_CC6E;
   133e8:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   133ec:	42bb      	cmp	r3, r7
  TIMx->CCER &= ~TIM_CCER_CC6E;
   133ee:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
   133f0:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
   133f2:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
   133f6:	6d59      	ldr	r1, [r3, #84]	; 0x54
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
   133f8:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
   133fc:	68ae      	ldr	r6, [r5, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
   133fe:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
   13402:	6828      	ldr	r0, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 20U);
   13404:	ea42 5206 	orr.w	r2, r2, r6, lsl #20
  tmpccmrx |= (OC_Config->OCMode << 8U);
   13408:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   1340c:	d00d      	beq.n	1342a <HAL_TIM_PWM_ConfigChannel+0x45e>
   1340e:	4833      	ldr	r0, [pc, #204]	; (134dc <HAL_TIM_PWM_ConfigChannel+0x510>)
   13410:	4283      	cmp	r3, r0
   13412:	d00a      	beq.n	1342a <HAL_TIM_PWM_ConfigChannel+0x45e>
   13414:	4e32      	ldr	r6, [pc, #200]	; (134e0 <HAL_TIM_PWM_ConfigChannel+0x514>)
   13416:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
   1341a:	4283      	cmp	r3, r0
   1341c:	bf18      	it	ne
   1341e:	42b3      	cmpne	r3, r6
   13420:	d003      	beq.n	1342a <HAL_TIM_PWM_ConfigChannel+0x45e>
   13422:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   13426:	4283      	cmp	r3, r0
   13428:	d104      	bne.n	13434 <HAL_TIM_PWM_ConfigChannel+0x468>
    tmpcr2 &= ~TIM_CR2_OIS6;
   1342a:	f42c 3c00 	bic.w	ip, ip, #131072	; 0x20000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
   1342e:	6968      	ldr	r0, [r5, #20]
   13430:	ea4c 2c80 	orr.w	ip, ip, r0, lsl #10
  TIMx->CR2 = tmpcr2;
   13434:	f8c3 c004 	str.w	ip, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
   13438:	6559      	str	r1, [r3, #84]	; 0x54
  TIMx->CCR6 = OC_Config->Pulse;
   1343a:	6869      	ldr	r1, [r5, #4]
   1343c:	65d9      	str	r1, [r3, #92]	; 0x5c
  TIMx->CCER = tmpccer;
   1343e:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
   13440:	6822      	ldr	r2, [r4, #0]
   13442:	6d53      	ldr	r3, [r2, #84]	; 0x54
   13444:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   13448:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
   1344a:	6822      	ldr	r2, [r4, #0]
   1344c:	6d53      	ldr	r3, [r2, #84]	; 0x54
   1344e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   13452:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
   13454:	6822      	ldr	r2, [r4, #0]
   13456:	6929      	ldr	r1, [r5, #16]
   13458:	6d53      	ldr	r3, [r2, #84]	; 0x54
   1345a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   1345e:	6553      	str	r3, [r2, #84]	; 0x54
      break;
   13460:	e655      	b.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   13462:	f640 611d 	movw	r1, #3613	; 0xe1d
   13466:	481f      	ldr	r0, [pc, #124]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   13468:	f005 ffd4 	bl	19414 <assert_failed>
   1346c:	e5c4      	b.n	12ff8 <HAL_TIM_PWM_ConfigChannel+0x2c>
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   1346e:	f44f 6168 	mov.w	r1, #3712	; 0xe80
   13472:	481c      	ldr	r0, [pc, #112]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   13474:	f005 ffce 	bl	19414 <assert_failed>
   13478:	6823      	ldr	r3, [r4, #0]
   1347a:	e7b3      	b.n	133e4 <HAL_TIM_PWM_ConfigChannel+0x418>
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   1347c:	f640 616f 	movw	r1, #3695	; 0xe6f
   13480:	4818      	ldr	r0, [pc, #96]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   13482:	f005 ffc7 	bl	19414 <assert_failed>
   13486:	6823      	ldr	r3, [r4, #0]
   13488:	e766      	b.n	13358 <HAL_TIM_PWM_ConfigChannel+0x38c>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   1348a:	f641 01e8 	movw	r1, #6376	; 0x18e8
   1348e:	4815      	ldr	r0, [pc, #84]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   13490:	f005 ffc0 	bl	19414 <assert_failed>
   13494:	696b      	ldr	r3, [r5, #20]
   13496:	e73a      	b.n	1330e <HAL_TIM_PWM_ConfigChannel+0x342>
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   13498:	f640 615e 	movw	r1, #3678	; 0xe5e
   1349c:	4811      	ldr	r0, [pc, #68]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   1349e:	f005 ffb9 	bl	19414 <assert_failed>
   134a2:	6826      	ldr	r6, [r4, #0]
   134a4:	e70b      	b.n	132be <HAL_TIM_PWM_ConfigChannel+0x2f2>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   134a6:	480f      	ldr	r0, [pc, #60]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   134a8:	f640 614d 	movw	r1, #3661	; 0xe4d
   134ac:	f005 ffb2 	bl	19414 <assert_failed>
   134b0:	6820      	ldr	r0, [r4, #0]
   134b2:	e6bb      	b.n	1322c <HAL_TIM_PWM_ConfigChannel+0x260>
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   134b4:	480b      	ldr	r0, [pc, #44]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   134b6:	f640 613c 	movw	r1, #3644	; 0xe3c
   134ba:	f005 ffab 	bl	19414 <assert_failed>
   134be:	6820      	ldr	r0, [r4, #0]
   134c0:	e67f      	b.n	131c2 <HAL_TIM_PWM_ConfigChannel+0x1f6>
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   134c2:	4808      	ldr	r0, [pc, #32]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   134c4:	f640 612b 	movw	r1, #3627	; 0xe2b
   134c8:	f005 ffa4 	bl	19414 <assert_failed>
   134cc:	6820      	ldr	r0, [r4, #0]
   134ce:	e60c      	b.n	130ea <HAL_TIM_PWM_ConfigChannel+0x11e>
   134d0:	40010000 	.word	0x40010000
   134d4:	40000400 	.word	0x40000400
   134d8:	40000800 	.word	0x40000800
   134dc:	40010400 	.word	0x40010400
   134e0:	40014000 	.word	0x40014000
   134e4:	0002ff4c 	.word	0x0002ff4c

000134e8 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
   134e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmpcr2;
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   134ea:	4b60      	ldr	r3, [pc, #384]	; (1366c <HAL_TIMEx_MasterConfigSynchronization+0x184>)
{
   134ec:	4604      	mov	r4, r0
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   134ee:	6802      	ldr	r2, [r0, #0]
{
   134f0:	460d      	mov	r5, r1
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   134f2:	4e5f      	ldr	r6, [pc, #380]	; (13670 <HAL_TIMEx_MasterConfigSynchronization+0x188>)
   134f4:	429a      	cmp	r2, r3
   134f6:	bf18      	it	ne
   134f8:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   134fc:	485d      	ldr	r0, [pc, #372]	; (13674 <HAL_TIMEx_MasterConfigSynchronization+0x18c>)
   134fe:	495e      	ldr	r1, [pc, #376]	; (13678 <HAL_TIMEx_MasterConfigSynchronization+0x190>)
   13500:	bf14      	ite	ne
   13502:	2301      	movne	r3, #1
   13504:	2300      	moveq	r3, #0
   13506:	42b2      	cmp	r2, r6
   13508:	bf0c      	ite	eq
   1350a:	2300      	moveq	r3, #0
   1350c:	f003 0301 	andne.w	r3, r3, #1
   13510:	f506 6640 	add.w	r6, r6, #3072	; 0xc00
   13514:	4282      	cmp	r2, r0
   13516:	bf0c      	ite	eq
   13518:	2300      	moveq	r3, #0
   1351a:	f003 0301 	andne.w	r3, r3, #1
   1351e:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
   13522:	428a      	cmp	r2, r1
   13524:	bf0c      	ite	eq
   13526:	2300      	moveq	r3, #0
   13528:	f003 0301 	andne.w	r3, r3, #1
   1352c:	f501 4178 	add.w	r1, r1, #63488	; 0xf800
   13530:	42b2      	cmp	r2, r6
   13532:	bf0c      	ite	eq
   13534:	2300      	moveq	r3, #0
   13536:	f003 0301 	andne.w	r3, r3, #1
   1353a:	4282      	cmp	r2, r0
   1353c:	bf0c      	ite	eq
   1353e:	2300      	moveq	r3, #0
   13540:	f003 0301 	andne.w	r3, r3, #1
   13544:	428a      	cmp	r2, r1
   13546:	bf0c      	ite	eq
   13548:	2300      	moveq	r3, #0
   1354a:	f003 0301 	andne.w	r3, r3, #1
   1354e:	b113      	cbz	r3, 13556 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
   13550:	4b4a      	ldr	r3, [pc, #296]	; (1367c <HAL_TIMEx_MasterConfigSynchronization+0x194>)
   13552:	429a      	cmp	r2, r3
   13554:	d175      	bne.n	13642 <HAL_TIMEx_MasterConfigSynchronization+0x15a>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   13556:	682b      	ldr	r3, [r5, #0]
   13558:	f023 0330 	bic.w	r3, r3, #48	; 0x30
   1355c:	2b40      	cmp	r3, #64	; 0x40
   1355e:	d001      	beq.n	13564 <HAL_TIMEx_MasterConfigSynchronization+0x7c>
   13560:	2b00      	cmp	r3, #0
   13562:	d174      	bne.n	1364e <HAL_TIMEx_MasterConfigSynchronization+0x166>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   13564:	68ab      	ldr	r3, [r5, #8]
   13566:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   1356a:	d15f      	bne.n	1362c <HAL_TIMEx_MasterConfigSynchronization+0x144>

  /* Check input state */
  __HAL_LOCK(htim);
   1356c:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   13570:	2b01      	cmp	r3, #1
   13572:	d064      	beq.n	1363e <HAL_TIMEx_MasterConfigSynchronization+0x156>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
   13574:	6822      	ldr	r2, [r4, #0]
  __HAL_LOCK(htim);
   13576:	2001      	movs	r0, #1

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   13578:	4b3c      	ldr	r3, [pc, #240]	; (1366c <HAL_TIMEx_MasterConfigSynchronization+0x184>)
  htim->State = HAL_TIM_STATE_BUSY;
   1357a:	2102      	movs	r1, #2
  __HAL_LOCK(htim);
   1357c:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   13580:	429a      	cmp	r2, r3
  htim->State = HAL_TIM_STATE_BUSY;
   13582:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
  tmpcr2 = htim->Instance->CR2;
   13586:	6857      	ldr	r7, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
   13588:	6896      	ldr	r6, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   1358a:	d037      	beq.n	135fc <HAL_TIMEx_MasterConfigSynchronization+0x114>
   1358c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   13590:	429a      	cmp	r2, r3
   13592:	d033      	beq.n	135fc <HAL_TIMEx_MasterConfigSynchronization+0x114>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
   13594:	6829      	ldr	r1, [r5, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
   13596:	f027 0770 	bic.w	r7, r7, #112	; 0x70

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   1359a:	4b34      	ldr	r3, [pc, #208]	; (1366c <HAL_TIMEx_MasterConfigSynchronization+0x184>)
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
   1359c:	430f      	orrs	r7, r1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   1359e:	4934      	ldr	r1, [pc, #208]	; (13670 <HAL_TIMEx_MasterConfigSynchronization+0x188>)
   135a0:	4835      	ldr	r0, [pc, #212]	; (13678 <HAL_TIMEx_MasterConfigSynchronization+0x190>)
  htim->Instance->CR2 = tmpcr2;
   135a2:	6057      	str	r7, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   135a4:	6822      	ldr	r2, [r4, #0]
   135a6:	4f33      	ldr	r7, [pc, #204]	; (13674 <HAL_TIMEx_MasterConfigSynchronization+0x18c>)
   135a8:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   135ac:	bf18      	it	ne
   135ae:	429a      	cmpne	r2, r3
   135b0:	bf0c      	ite	eq
   135b2:	2301      	moveq	r3, #1
   135b4:	2300      	movne	r3, #0
   135b6:	428a      	cmp	r2, r1
   135b8:	bf08      	it	eq
   135ba:	f043 0301 	orreq.w	r3, r3, #1
   135be:	f501 3180 	add.w	r1, r1, #65536	; 0x10000
   135c2:	42ba      	cmp	r2, r7
   135c4:	bf08      	it	eq
   135c6:	f043 0301 	orreq.w	r3, r3, #1
   135ca:	4282      	cmp	r2, r0
   135cc:	bf08      	it	eq
   135ce:	f043 0301 	orreq.w	r3, r3, #1
   135d2:	428a      	cmp	r2, r1
   135d4:	bf08      	it	eq
   135d6:	f043 0301 	orreq.w	r3, r3, #1
   135da:	b913      	cbnz	r3, 135e2 <HAL_TIMEx_MasterConfigSynchronization+0xfa>
   135dc:	4b28      	ldr	r3, [pc, #160]	; (13680 <HAL_TIMEx_MasterConfigSynchronization+0x198>)
   135de:	429a      	cmp	r2, r3
   135e0:	d104      	bne.n	135ec <HAL_TIMEx_MasterConfigSynchronization+0x104>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
   135e2:	68ab      	ldr	r3, [r5, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
   135e4:	f026 0680 	bic.w	r6, r6, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
   135e8:	431e      	orrs	r6, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
   135ea:	6096      	str	r6, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
   135ec:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
   135ee:	2201      	movs	r2, #1

  return HAL_OK;
   135f0:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
   135f2:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
   135f6:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
   135fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
   135fc:	6868      	ldr	r0, [r5, #4]
   135fe:	f420 1340 	bic.w	r3, r0, #3145728	; 0x300000
   13602:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   13606:	bf18      	it	ne
   13608:	2b00      	cmpne	r3, #0
   1360a:	bf14      	ite	ne
   1360c:	2101      	movne	r1, #1
   1360e:	2100      	moveq	r1, #0
   13610:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   13614:	bf0c      	ite	eq
   13616:	2100      	moveq	r1, #0
   13618:	f001 0101 	andne.w	r1, r1, #1
   1361c:	b111      	cbz	r1, 13624 <HAL_TIMEx_MasterConfigSynchronization+0x13c>
   1361e:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   13622:	d11a      	bne.n	1365a <HAL_TIMEx_MasterConfigSynchronization+0x172>
    tmpcr2 &= ~TIM_CR2_MMS2;
   13624:	f427 0770 	bic.w	r7, r7, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
   13628:	4307      	orrs	r7, r0
   1362a:	e7b3      	b.n	13594 <HAL_TIMEx_MasterConfigSynchronization+0xac>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   1362c:	f240 6175 	movw	r1, #1653	; 0x675
   13630:	4814      	ldr	r0, [pc, #80]	; (13684 <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
   13632:	f005 feef 	bl	19414 <assert_failed>
  __HAL_LOCK(htim);
   13636:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   1363a:	2b01      	cmp	r3, #1
   1363c:	d19a      	bne.n	13574 <HAL_TIMEx_MasterConfigSynchronization+0x8c>
   1363e:	2002      	movs	r0, #2
}
   13640:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   13642:	f240 6173 	movw	r1, #1651	; 0x673
   13646:	480f      	ldr	r0, [pc, #60]	; (13684 <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
   13648:	f005 fee4 	bl	19414 <assert_failed>
   1364c:	e783      	b.n	13556 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   1364e:	f240 6174 	movw	r1, #1652	; 0x674
   13652:	480c      	ldr	r0, [pc, #48]	; (13684 <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
   13654:	f005 fede 	bl	19414 <assert_failed>
   13658:	e784      	b.n	13564 <HAL_TIMEx_MasterConfigSynchronization+0x7c>
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
   1365a:	480a      	ldr	r0, [pc, #40]	; (13684 <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
   1365c:	f240 6187 	movw	r1, #1671	; 0x687
   13660:	f005 fed8 	bl	19414 <assert_failed>
   13664:	6868      	ldr	r0, [r5, #4]
   13666:	6822      	ldr	r2, [r4, #0]
   13668:	e7dc      	b.n	13624 <HAL_TIMEx_MasterConfigSynchronization+0x13c>
   1366a:	bf00      	nop
   1366c:	40010000 	.word	0x40010000
   13670:	40000400 	.word	0x40000400
   13674:	40000800 	.word	0x40000800
   13678:	40000c00 	.word	0x40000c00
   1367c:	40014000 	.word	0x40014000
   13680:	40001800 	.word	0x40001800
   13684:	0002ff84 	.word	0x0002ff84

00013688 <FMC_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   13688:	4b5e      	ldr	r3, [pc, #376]	; (13804 <FMC_SDRAM_Init+0x17c>)
   1368a:	4298      	cmp	r0, r3
{
   1368c:	b570      	push	{r4, r5, r6, lr}
   1368e:	4605      	mov	r5, r0
   13690:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   13692:	d004      	beq.n	1369e <FMC_SDRAM_Init+0x16>
   13694:	f240 311a 	movw	r1, #794	; 0x31a
   13698:	485b      	ldr	r0, [pc, #364]	; (13808 <FMC_SDRAM_Init+0x180>)
   1369a:	f005 febb 	bl	19414 <assert_failed>
  assert_param(IS_FMC_SDRAM_BANK(Init->SDBank));
   1369e:	6823      	ldr	r3, [r4, #0]
   136a0:	2b01      	cmp	r3, #1
   136a2:	d904      	bls.n	136ae <FMC_SDRAM_Init+0x26>
   136a4:	f240 311b 	movw	r1, #795	; 0x31b
   136a8:	4857      	ldr	r0, [pc, #348]	; (13808 <FMC_SDRAM_Init+0x180>)
   136aa:	f005 feb3 	bl	19414 <assert_failed>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
   136ae:	6863      	ldr	r3, [r4, #4]
   136b0:	2b03      	cmp	r3, #3
   136b2:	f200 80a1 	bhi.w	137f8 <FMC_SDRAM_Init+0x170>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
   136b6:	68a3      	ldr	r3, [r4, #8]
   136b8:	f033 0204 	bics.w	r2, r3, #4
   136bc:	d002      	beq.n	136c4 <FMC_SDRAM_Init+0x3c>
   136be:	2b08      	cmp	r3, #8
   136c0:	f040 8094 	bne.w	137ec <FMC_SDRAM_Init+0x164>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
   136c4:	68e3      	ldr	r3, [r4, #12]
   136c6:	f033 0210 	bics.w	r2, r3, #16
   136ca:	d001      	beq.n	136d0 <FMC_SDRAM_Init+0x48>
   136cc:	2b20      	cmp	r3, #32
   136ce:	d17d      	bne.n	137cc <FMC_SDRAM_Init+0x144>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
   136d0:	6923      	ldr	r3, [r4, #16]
   136d2:	f033 0340 	bics.w	r3, r3, #64	; 0x40
   136d6:	f040 8083 	bne.w	137e0 <FMC_SDRAM_Init+0x158>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
   136da:	6963      	ldr	r3, [r4, #20]
   136dc:	f423 7280 	bic.w	r2, r3, #256	; 0x100
   136e0:	2a80      	cmp	r2, #128	; 0x80
   136e2:	d002      	beq.n	136ea <FMC_SDRAM_Init+0x62>
   136e4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   136e8:	d161      	bne.n	137ae <FMC_SDRAM_Init+0x126>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
   136ea:	69a3      	ldr	r3, [r4, #24]
   136ec:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   136f0:	d166      	bne.n	137c0 <FMC_SDRAM_Init+0x138>
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
   136f2:	69e3      	ldr	r3, [r4, #28]
   136f4:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
   136f8:	d002      	beq.n	13700 <FMC_SDRAM_Init+0x78>
   136fa:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
   136fe:	d147      	bne.n	13790 <FMC_SDRAM_Init+0x108>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
   13700:	6a23      	ldr	r3, [r4, #32]
   13702:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   13706:	d14c      	bne.n	137a2 <FMC_SDRAM_Init+0x11a>
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));
   13708:	6a62      	ldr	r2, [r4, #36]	; 0x24
   1370a:	f432 5300 	bics.w	r3, r2, #8192	; 0x2000
   1370e:	d002      	beq.n	13716 <FMC_SDRAM_Init+0x8e>
   13710:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
   13714:	d11c      	bne.n	13750 <FMC_SDRAM_Init+0xc8>

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank == FMC_SDRAM_BANK1)
   13716:	6821      	ldr	r1, [r4, #0]
   13718:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
   1371c:	b319      	cbz	r1, 13766 <FMC_SDRAM_Init+0xde>
                Init->ReadBurst          |
                Init->ReadPipeDelay));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   1371e:	6829      	ldr	r1, [r5, #0]
   13720:	4303      	orrs	r3, r0
               FMC_SDCRx_RPIPE,
               (Init->SDClockPeriod      |
                Init->ReadBurst          |
                Init->ReadPipeDelay));

    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
   13722:	483a      	ldr	r0, [pc, #232]	; (1380c <FMC_SDRAM_Init+0x184>)
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   13724:	f421 41f8 	bic.w	r1, r1, #31744	; 0x7c00
   13728:	430b      	orrs	r3, r1
   1372a:	4313      	orrs	r3, r2
   1372c:	602b      	str	r3, [r5, #0]
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
   1372e:	68e2      	ldr	r2, [r4, #12]
   13730:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
   13734:	430b      	orrs	r3, r1
   13736:	6921      	ldr	r1, [r4, #16]
   13738:	4313      	orrs	r3, r2
   1373a:	e9d4 6205 	ldrd	r6, r2, [r4, #20]
   1373e:	430b      	orrs	r3, r1
   13740:	6869      	ldr	r1, [r5, #4]
   13742:	4333      	orrs	r3, r6
   13744:	4008      	ands	r0, r1
   13746:	4313      	orrs	r3, r2
   13748:	4303      	orrs	r3, r0
                Init->CASLatency         |
                Init->WriteProtection));
  }

  return HAL_OK;
}
   1374a:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
   1374c:	606b      	str	r3, [r5, #4]
}
   1374e:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));
   13750:	f44f 7149 	mov.w	r1, #804	; 0x324
   13754:	482c      	ldr	r0, [pc, #176]	; (13808 <FMC_SDRAM_Init+0x180>)
   13756:	f005 fe5d 	bl	19414 <assert_failed>
  if (Init->SDBank == FMC_SDRAM_BANK1)
   1375a:	6821      	ldr	r1, [r4, #0]
   1375c:	6a62      	ldr	r2, [r4, #36]	; 0x24
   1375e:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
   13762:	2900      	cmp	r1, #0
   13764:	d1db      	bne.n	1371e <FMC_SDRAM_Init+0x96>
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   13766:	4303      	orrs	r3, r0
   13768:	e9d4 1001 	ldrd	r1, r0, [r4, #4]
   1376c:	430b      	orrs	r3, r1
   1376e:	68e1      	ldr	r1, [r4, #12]
   13770:	4303      	orrs	r3, r0
   13772:	6920      	ldr	r0, [r4, #16]
   13774:	430b      	orrs	r3, r1
   13776:	e9d4 1405 	ldrd	r1, r4, [r4, #20]
   1377a:	4303      	orrs	r3, r0
   1377c:	6828      	ldr	r0, [r5, #0]
   1377e:	430b      	orrs	r3, r1
   13780:	4922      	ldr	r1, [pc, #136]	; (1380c <FMC_SDRAM_Init+0x184>)
   13782:	4323      	orrs	r3, r4
   13784:	4001      	ands	r1, r0
}
   13786:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   13788:	430b      	orrs	r3, r1
   1378a:	4313      	orrs	r3, r2
   1378c:	602b      	str	r3, [r5, #0]
}
   1378e:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
   13790:	f240 3122 	movw	r1, #802	; 0x322
   13794:	481c      	ldr	r0, [pc, #112]	; (13808 <FMC_SDRAM_Init+0x180>)
   13796:	f005 fe3d 	bl	19414 <assert_failed>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
   1379a:	6a23      	ldr	r3, [r4, #32]
   1379c:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   137a0:	d0b2      	beq.n	13708 <FMC_SDRAM_Init+0x80>
   137a2:	f240 3123 	movw	r1, #803	; 0x323
   137a6:	4818      	ldr	r0, [pc, #96]	; (13808 <FMC_SDRAM_Init+0x180>)
   137a8:	f005 fe34 	bl	19414 <assert_failed>
   137ac:	e7ac      	b.n	13708 <FMC_SDRAM_Init+0x80>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
   137ae:	f44f 7148 	mov.w	r1, #800	; 0x320
   137b2:	4815      	ldr	r0, [pc, #84]	; (13808 <FMC_SDRAM_Init+0x180>)
   137b4:	f005 fe2e 	bl	19414 <assert_failed>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
   137b8:	69a3      	ldr	r3, [r4, #24]
   137ba:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   137be:	d098      	beq.n	136f2 <FMC_SDRAM_Init+0x6a>
   137c0:	f240 3121 	movw	r1, #801	; 0x321
   137c4:	4810      	ldr	r0, [pc, #64]	; (13808 <FMC_SDRAM_Init+0x180>)
   137c6:	f005 fe25 	bl	19414 <assert_failed>
   137ca:	e792      	b.n	136f2 <FMC_SDRAM_Init+0x6a>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
   137cc:	f240 311e 	movw	r1, #798	; 0x31e
   137d0:	480d      	ldr	r0, [pc, #52]	; (13808 <FMC_SDRAM_Init+0x180>)
   137d2:	f005 fe1f 	bl	19414 <assert_failed>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
   137d6:	6923      	ldr	r3, [r4, #16]
   137d8:	f033 0340 	bics.w	r3, r3, #64	; 0x40
   137dc:	f43f af7d 	beq.w	136da <FMC_SDRAM_Init+0x52>
   137e0:	f240 311f 	movw	r1, #799	; 0x31f
   137e4:	4808      	ldr	r0, [pc, #32]	; (13808 <FMC_SDRAM_Init+0x180>)
   137e6:	f005 fe15 	bl	19414 <assert_failed>
   137ea:	e776      	b.n	136da <FMC_SDRAM_Init+0x52>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
   137ec:	f240 311d 	movw	r1, #797	; 0x31d
   137f0:	4805      	ldr	r0, [pc, #20]	; (13808 <FMC_SDRAM_Init+0x180>)
   137f2:	f005 fe0f 	bl	19414 <assert_failed>
   137f6:	e765      	b.n	136c4 <FMC_SDRAM_Init+0x3c>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
   137f8:	f44f 7147 	mov.w	r1, #796	; 0x31c
   137fc:	4802      	ldr	r0, [pc, #8]	; (13808 <FMC_SDRAM_Init+0x180>)
   137fe:	f005 fe09 	bl	19414 <assert_failed>
   13802:	e758      	b.n	136b6 <FMC_SDRAM_Init+0x2e>
   13804:	52004140 	.word	0x52004140
   13808:	0002ffc0 	.word	0x0002ffc0
   1380c:	ffff8000 	.word	0xffff8000

00013810 <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
   13810:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   13812:	4b50      	ldr	r3, [pc, #320]	; (13954 <FMC_SDRAM_Timing_Init+0x144>)
{
   13814:	4605      	mov	r5, r0
   13816:	460c      	mov	r4, r1
   13818:	4616      	mov	r6, r2
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   1381a:	4298      	cmp	r0, r3
   1381c:	d004      	beq.n	13828 <FMC_SDRAM_Timing_Init+0x18>
   1381e:	f44f 7156 	mov.w	r1, #856	; 0x358
   13822:	484d      	ldr	r0, [pc, #308]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13824:	f005 fdf6 	bl	19414 <assert_failed>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
   13828:	6823      	ldr	r3, [r4, #0]
   1382a:	3b01      	subs	r3, #1
   1382c:	2b0f      	cmp	r3, #15
   1382e:	f200 808a 	bhi.w	13946 <FMC_SDRAM_Timing_Init+0x136>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
   13832:	6863      	ldr	r3, [r4, #4]
   13834:	3b01      	subs	r3, #1
   13836:	2b0f      	cmp	r3, #15
   13838:	d87f      	bhi.n	1393a <FMC_SDRAM_Timing_Init+0x12a>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
   1383a:	68a3      	ldr	r3, [r4, #8]
   1383c:	3b01      	subs	r3, #1
   1383e:	2b0f      	cmp	r3, #15
   13840:	d875      	bhi.n	1392e <FMC_SDRAM_Timing_Init+0x11e>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
   13842:	68e3      	ldr	r3, [r4, #12]
   13844:	3b01      	subs	r3, #1
   13846:	2b0f      	cmp	r3, #15
   13848:	d86b      	bhi.n	13922 <FMC_SDRAM_Timing_Init+0x112>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
   1384a:	6923      	ldr	r3, [r4, #16]
   1384c:	3b01      	subs	r3, #1
   1384e:	2b0f      	cmp	r3, #15
   13850:	d861      	bhi.n	13916 <FMC_SDRAM_Timing_Init+0x106>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
   13852:	6963      	ldr	r3, [r4, #20]
   13854:	3b01      	subs	r3, #1
   13856:	2b0f      	cmp	r3, #15
   13858:	d857      	bhi.n	1390a <FMC_SDRAM_Timing_Init+0xfa>
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
   1385a:	69a3      	ldr	r3, [r4, #24]
   1385c:	3b01      	subs	r3, #1
   1385e:	2b0f      	cmp	r3, #15
   13860:	d84d      	bhi.n	138fe <FMC_SDRAM_Timing_Init+0xee>
  assert_param(IS_FMC_SDRAM_BANK(Bank));
   13862:	2e01      	cmp	r6, #1
   13864:	d821      	bhi.n	138aa <FMC_SDRAM_Timing_Init+0x9a>
   13866:	68e3      	ldr	r3, [r4, #12]
   13868:	6961      	ldr	r1, [r4, #20]
   1386a:	3b01      	subs	r3, #1
   1386c:	3901      	subs	r1, #1
   1386e:	031b      	lsls	r3, r3, #12
   13870:	0509      	lsls	r1, r1, #20

  /* Set SDRAM device timing parameters */
  if (Bank == FMC_SDRAM_BANK1)
   13872:	bb2e      	cbnz	r6, 138c0 <FMC_SDRAM_Timing_Init+0xb0>
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
   13874:	6822      	ldr	r2, [r4, #0]
   13876:	430b      	orrs	r3, r1
   13878:	6860      	ldr	r0, [r4, #4]
   1387a:	3a01      	subs	r2, #1
   1387c:	68a1      	ldr	r1, [r4, #8]
   1387e:	1e47      	subs	r7, r0, #1
   13880:	6920      	ldr	r0, [r4, #16]
   13882:	4313      	orrs	r3, r2
   13884:	1e4e      	subs	r6, r1, #1
   13886:	3801      	subs	r0, #1
   13888:	69a1      	ldr	r1, [r4, #24]
   1388a:	ea43 1307 	orr.w	r3, r3, r7, lsl #4
   1388e:	68aa      	ldr	r2, [r5, #8]
   13890:	3901      	subs	r1, #1
   13892:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
   13896:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
   1389a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
                (((Timing->WriteRecoveryTime) - 1U)    << FMC_SDTRx_TWR_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTRx_TRCD_Pos)));
  }

  return HAL_OK;
}
   1389e:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
   138a0:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   138a4:	4313      	orrs	r3, r2
   138a6:	60ab      	str	r3, [r5, #8]
}
   138a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FMC_SDRAM_BANK(Bank));
   138aa:	f44f 7158 	mov.w	r1, #864	; 0x360
   138ae:	482a      	ldr	r0, [pc, #168]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   138b0:	f005 fdb0 	bl	19414 <assert_failed>
   138b4:	68e3      	ldr	r3, [r4, #12]
   138b6:	6961      	ldr	r1, [r4, #20]
   138b8:	3b01      	subs	r3, #1
   138ba:	3901      	subs	r1, #1
   138bc:	031b      	lsls	r3, r3, #12
   138be:	0509      	lsls	r1, r1, #20
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
   138c0:	68a8      	ldr	r0, [r5, #8]
   138c2:	430b      	orrs	r3, r1
   138c4:	4a25      	ldr	r2, [pc, #148]	; (1395c <FMC_SDRAM_Timing_Init+0x14c>)
   138c6:	4002      	ands	r2, r0
   138c8:	4313      	orrs	r3, r2
   138ca:	60ab      	str	r3, [r5, #8]
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
   138cc:	6820      	ldr	r0, [r4, #0]
   138ce:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
   138d2:	1e46      	subs	r6, r0, #1
   138d4:	1e5a      	subs	r2, r3, #1
   138d6:	1e4b      	subs	r3, r1, #1
   138d8:	6921      	ldr	r1, [r4, #16]
   138da:	0212      	lsls	r2, r2, #8
   138dc:	1e48      	subs	r0, r1, #1
   138de:	69a1      	ldr	r1, [r4, #24]
   138e0:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
   138e4:	68ea      	ldr	r2, [r5, #12]
   138e6:	3901      	subs	r1, #1
   138e8:	4333      	orrs	r3, r6
   138ea:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
   138ee:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
}
   138f2:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
   138f4:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   138f8:	4313      	orrs	r3, r2
   138fa:	60eb      	str	r3, [r5, #12]
}
   138fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
   138fe:	f240 315f 	movw	r1, #863	; 0x35f
   13902:	4815      	ldr	r0, [pc, #84]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13904:	f005 fd86 	bl	19414 <assert_failed>
   13908:	e7ab      	b.n	13862 <FMC_SDRAM_Timing_Init+0x52>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
   1390a:	f240 315e 	movw	r1, #862	; 0x35e
   1390e:	4812      	ldr	r0, [pc, #72]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13910:	f005 fd80 	bl	19414 <assert_failed>
   13914:	e7a1      	b.n	1385a <FMC_SDRAM_Timing_Init+0x4a>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
   13916:	f240 315d 	movw	r1, #861	; 0x35d
   1391a:	480f      	ldr	r0, [pc, #60]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   1391c:	f005 fd7a 	bl	19414 <assert_failed>
   13920:	e797      	b.n	13852 <FMC_SDRAM_Timing_Init+0x42>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
   13922:	f44f 7157 	mov.w	r1, #860	; 0x35c
   13926:	480c      	ldr	r0, [pc, #48]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13928:	f005 fd74 	bl	19414 <assert_failed>
   1392c:	e78d      	b.n	1384a <FMC_SDRAM_Timing_Init+0x3a>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
   1392e:	f240 315b 	movw	r1, #859	; 0x35b
   13932:	4809      	ldr	r0, [pc, #36]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13934:	f005 fd6e 	bl	19414 <assert_failed>
   13938:	e783      	b.n	13842 <FMC_SDRAM_Timing_Init+0x32>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
   1393a:	f240 315a 	movw	r1, #858	; 0x35a
   1393e:	4806      	ldr	r0, [pc, #24]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13940:	f005 fd68 	bl	19414 <assert_failed>
   13944:	e779      	b.n	1383a <FMC_SDRAM_Timing_Init+0x2a>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
   13946:	f240 3159 	movw	r1, #857	; 0x359
   1394a:	4803      	ldr	r0, [pc, #12]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   1394c:	f005 fd62 	bl	19414 <assert_failed>
   13950:	e76f      	b.n	13832 <FMC_SDRAM_Timing_Init+0x22>
   13952:	bf00      	nop
   13954:	52004140 	.word	0x52004140
   13958:	0002ffc0 	.word	0x0002ffc0
   1395c:	ff0f0fff 	.word	0xff0f0fff

00013960 <FMC_SDRAM_SendCommand>:
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   13960:	4b22      	ldr	r3, [pc, #136]	; (139ec <FMC_SDRAM_SendCommand+0x8c>)
   13962:	4298      	cmp	r0, r3
{
   13964:	b570      	push	{r4, r5, r6, lr}
   13966:	4605      	mov	r5, r0
   13968:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   1396a:	d004      	beq.n	13976 <FMC_SDRAM_SendCommand+0x16>
   1396c:	f240 31d9 	movw	r1, #985	; 0x3d9
   13970:	481f      	ldr	r0, [pc, #124]	; (139f0 <FMC_SDRAM_SendCommand+0x90>)
   13972:	f005 fd4f 	bl	19414 <assert_failed>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
   13976:	6823      	ldr	r3, [r4, #0]
   13978:	2b06      	cmp	r3, #6
   1397a:	d831      	bhi.n	139e0 <FMC_SDRAM_SendCommand+0x80>
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
   1397c:	6863      	ldr	r3, [r4, #4]
   1397e:	f023 0210 	bic.w	r2, r3, #16
   13982:	2a08      	cmp	r2, #8
   13984:	d001      	beq.n	1398a <FMC_SDRAM_SendCommand+0x2a>
   13986:	2b10      	cmp	r3, #16
   13988:	d11b      	bne.n	139c2 <FMC_SDRAM_SendCommand+0x62>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
   1398a:	68a3      	ldr	r3, [r4, #8]
   1398c:	3b01      	subs	r3, #1
   1398e:	2b0e      	cmp	r3, #14
   13990:	d820      	bhi.n	139d4 <FMC_SDRAM_SendCommand+0x74>
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));
   13992:	68e1      	ldr	r1, [r4, #12]
   13994:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
   13998:	d305      	bcc.n	139a6 <FMC_SDRAM_SendCommand+0x46>
   1399a:	f240 31dd 	movw	r1, #989	; 0x3dd
   1399e:	4814      	ldr	r0, [pc, #80]	; (139f0 <FMC_SDRAM_SendCommand+0x90>)
   139a0:	f005 fd38 	bl	19414 <assert_failed>
   139a4:	68e1      	ldr	r1, [r4, #12]

  /* Set command register */
  SET_BIT(Device->SDCMR, ((Command->CommandMode)                                                 |
   139a6:	6823      	ldr	r3, [r4, #0]
                          (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos)   |
                          ((Command->ModeRegisterDefinition)   << FMC_SDCMR_MRD_Pos)));
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Timeout);
  return HAL_OK;
}
   139a8:	2000      	movs	r0, #0
  SET_BIT(Device->SDCMR, ((Command->CommandMode)                                                 |
   139aa:	e9d4 6201 	ldrd	r6, r2, [r4, #4]
   139ae:	692c      	ldr	r4, [r5, #16]
   139b0:	4333      	orrs	r3, r6
   139b2:	3a01      	subs	r2, #1
   139b4:	4323      	orrs	r3, r4
   139b6:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
   139ba:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
   139be:	612b      	str	r3, [r5, #16]
}
   139c0:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
   139c2:	f240 31db 	movw	r1, #987	; 0x3db
   139c6:	480a      	ldr	r0, [pc, #40]	; (139f0 <FMC_SDRAM_SendCommand+0x90>)
   139c8:	f005 fd24 	bl	19414 <assert_failed>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
   139cc:	68a3      	ldr	r3, [r4, #8]
   139ce:	3b01      	subs	r3, #1
   139d0:	2b0e      	cmp	r3, #14
   139d2:	d9de      	bls.n	13992 <FMC_SDRAM_SendCommand+0x32>
   139d4:	f44f 7177 	mov.w	r1, #988	; 0x3dc
   139d8:	4805      	ldr	r0, [pc, #20]	; (139f0 <FMC_SDRAM_SendCommand+0x90>)
   139da:	f005 fd1b 	bl	19414 <assert_failed>
   139de:	e7d8      	b.n	13992 <FMC_SDRAM_SendCommand+0x32>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
   139e0:	f240 31da 	movw	r1, #986	; 0x3da
   139e4:	4802      	ldr	r0, [pc, #8]	; (139f0 <FMC_SDRAM_SendCommand+0x90>)
   139e6:	f005 fd15 	bl	19414 <assert_failed>
   139ea:	e7c7      	b.n	1397c <FMC_SDRAM_SendCommand+0x1c>
   139ec:	52004140 	.word	0x52004140
   139f0:	0002ffc0 	.word	0x0002ffc0

000139f4 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
   139f4:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   139f6:	4b0d      	ldr	r3, [pc, #52]	; (13a2c <FMC_SDRAM_ProgramRefreshRate+0x38>)
{
   139f8:	4604      	mov	r4, r0
   139fa:	460d      	mov	r5, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   139fc:	4298      	cmp	r0, r3
   139fe:	d004      	beq.n	13a0a <FMC_SDRAM_ProgramRefreshRate+0x16>
   13a00:	f240 31f2 	movw	r1, #1010	; 0x3f2
   13a04:	480a      	ldr	r0, [pc, #40]	; (13a30 <FMC_SDRAM_ProgramRefreshRate+0x3c>)
   13a06:	f005 fd05 	bl	19414 <assert_failed>
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
   13a0a:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
   13a0e:	d304      	bcc.n	13a1a <FMC_SDRAM_ProgramRefreshRate+0x26>
   13a10:	f240 31f3 	movw	r1, #1011	; 0x3f3
   13a14:	4806      	ldr	r0, [pc, #24]	; (13a30 <FMC_SDRAM_ProgramRefreshRate+0x3c>)
   13a16:	f005 fcfd 	bl	19414 <assert_failed>

  /* Set the refresh rate in command register */
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
   13a1a:	6963      	ldr	r3, [r4, #20]

  return HAL_OK;
}
   13a1c:	2000      	movs	r0, #0
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
   13a1e:	4905      	ldr	r1, [pc, #20]	; (13a34 <FMC_SDRAM_ProgramRefreshRate+0x40>)
   13a20:	4019      	ands	r1, r3
   13a22:	ea41 0145 	orr.w	r1, r1, r5, lsl #1
   13a26:	6161      	str	r1, [r4, #20]
}
   13a28:	bd38      	pop	{r3, r4, r5, pc}
   13a2a:	bf00      	nop
   13a2c:	52004140 	.word	0x52004140
   13a30:	0002ffc0 	.word	0x0002ffc0
   13a34:	ffffc001 	.word	0xffffc001

00013a38 <SDMMC_GetCmdResp1.part.2>:
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);

  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
   13a38:	4b30      	ldr	r3, [pc, #192]	; (13afc <SDMMC_GetCmdResp1.part.2+0xc4>)
  return (*(__IO uint32_t *) tmp);
   13a3a:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
   13a3c:	4013      	ands	r3, r2
   13a3e:	b34b      	cbz	r3, 13a94 <SDMMC_GetCmdResp1.part.2+0x5c>
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
   13a40:	2a00      	cmp	r2, #0
   13a42:	db29      	blt.n	13a98 <SDMMC_GetCmdResp1.part.2+0x60>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
   13a44:	0051      	lsls	r1, r2, #1
   13a46:	d42d      	bmi.n	13aa4 <SDMMC_GetCmdResp1.part.2+0x6c>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
   13a48:	0093      	lsls	r3, r2, #2
   13a4a:	d42d      	bmi.n	13aa8 <SDMMC_GetCmdResp1.part.2+0x70>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
   13a4c:	00d1      	lsls	r1, r2, #3
   13a4e:	d426      	bmi.n	13a9e <SDMMC_GetCmdResp1.part.2+0x66>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
   13a50:	0113      	lsls	r3, r2, #4
   13a52:	d42e      	bmi.n	13ab2 <SDMMC_GetCmdResp1.part.2+0x7a>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
   13a54:	0151      	lsls	r1, r2, #5
   13a56:	d42f      	bmi.n	13ab8 <SDMMC_GetCmdResp1.part.2+0x80>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
   13a58:	01d3      	lsls	r3, r2, #7
   13a5a:	d427      	bmi.n	13aac <SDMMC_GetCmdResp1.part.2+0x74>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
   13a5c:	0211      	lsls	r1, r2, #8
   13a5e:	d42e      	bmi.n	13abe <SDMMC_GetCmdResp1.part.2+0x86>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
   13a60:	0253      	lsls	r3, r2, #9
   13a62:	d42f      	bmi.n	13ac4 <SDMMC_GetCmdResp1.part.2+0x8c>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
   13a64:	0291      	lsls	r1, r2, #10
   13a66:	d430      	bmi.n	13aca <SDMMC_GetCmdResp1.part.2+0x92>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
   13a68:	02d3      	lsls	r3, r2, #11
   13a6a:	d431      	bmi.n	13ad0 <SDMMC_GetCmdResp1.part.2+0x98>
  {
    return SDMMC_ERROR_CC_ERR;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
   13a6c:	0351      	lsls	r1, r2, #13
   13a6e:	d432      	bmi.n	13ad6 <SDMMC_GetCmdResp1.part.2+0x9e>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
   13a70:	0393      	lsls	r3, r2, #14
   13a72:	d433      	bmi.n	13adc <SDMMC_GetCmdResp1.part.2+0xa4>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
   13a74:	03d1      	lsls	r1, r2, #15
   13a76:	d434      	bmi.n	13ae2 <SDMMC_GetCmdResp1.part.2+0xaa>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
   13a78:	0413      	lsls	r3, r2, #16
   13a7a:	d435      	bmi.n	13ae8 <SDMMC_GetCmdResp1.part.2+0xb0>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
   13a7c:	0451      	lsls	r1, r2, #17
   13a7e:	d436      	bmi.n	13aee <SDMMC_GetCmdResp1.part.2+0xb6>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
   13a80:	0493      	lsls	r3, r2, #18
   13a82:	d437      	bmi.n	13af4 <SDMMC_GetCmdResp1.part.2+0xbc>
  {
    return SDMMC_ERROR_ERASE_RESET;
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
   13a84:	f012 0f08 	tst.w	r2, #8
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
   13a88:	bf14      	ite	ne
   13a8a:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
   13a8e:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
   13a92:	4770      	bx	lr
    return SDMMC_ERROR_NONE;
   13a94:	4618      	mov	r0, r3
   13a96:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
   13a98:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
   13a9c:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
   13a9e:	f44f 7080 	mov.w	r0, #256	; 0x100
   13aa2:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
   13aa4:	2040      	movs	r0, #64	; 0x40
   13aa6:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
   13aa8:	2080      	movs	r0, #128	; 0x80
   13aaa:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
   13aac:	f44f 6000 	mov.w	r0, #2048	; 0x800
   13ab0:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
   13ab2:	f44f 7000 	mov.w	r0, #512	; 0x200
   13ab6:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
   13ab8:	f44f 6080 	mov.w	r0, #1024	; 0x400
   13abc:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
   13abe:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   13ac2:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
   13ac4:	f44f 5000 	mov.w	r0, #8192	; 0x2000
   13ac8:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
   13aca:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   13ace:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
   13ad0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   13ad4:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
   13ad6:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   13ada:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
   13adc:	f44f 2080 	mov.w	r0, #262144	; 0x40000
   13ae0:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
   13ae2:	f44f 2000 	mov.w	r0, #524288	; 0x80000
   13ae6:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
   13ae8:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   13aec:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
   13aee:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
   13af2:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
   13af4:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  }
}
   13af8:	4770      	bx	lr
   13afa:	bf00      	nop
   13afc:	fdffe008 	.word	0xfdffe008

00013b00 <SDMMC_Init>:
{
   13b00:	b084      	sub	sp, #16
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   13b02:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 13bbc <SDMMC_Init+0xbc>
{
   13b06:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13b0a:	4605      	mov	r5, r0
   13b0c:	a809      	add	r0, sp, #36	; 0x24
   13b0e:	460c      	mov	r4, r1
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   13b10:	4565      	cmp	r5, ip
   13b12:	e9dd 760c 	ldrd	r7, r6, [sp, #48]	; 0x30
{
   13b16:	e880 000e 	stmia.w	r0, {r1, r2, r3}
   13b1a:	e9dd 980a 	ldrd	r9, r8, [sp, #40]	; 0x28
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   13b1e:	d002      	beq.n	13b26 <SDMMC_Init+0x26>
   13b20:	4b23      	ldr	r3, [pc, #140]	; (13bb0 <SDMMC_Init+0xb0>)
   13b22:	429d      	cmp	r5, r3
   13b24:	d125      	bne.n	13b72 <SDMMC_Init+0x72>
  assert_param(IS_SDMMC_CLOCK_EDGE(Init.ClockEdge));
   13b26:	f434 3380 	bics.w	r3, r4, #65536	; 0x10000
   13b2a:	d129      	bne.n	13b80 <SDMMC_Init+0x80>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(Init.ClockPowerSave));
   13b2c:	f439 5380 	bics.w	r3, r9, #4096	; 0x1000
   13b30:	d12d      	bne.n	13b8e <SDMMC_Init+0x8e>
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
   13b32:	f438 4380 	bics.w	r3, r8, #16384	; 0x4000
   13b36:	d002      	beq.n	13b3e <SDMMC_Init+0x3e>
   13b38:	f5b8 4f00 	cmp.w	r8, #32768	; 0x8000
   13b3c:	d12c      	bne.n	13b98 <SDMMC_Init+0x98>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
   13b3e:	f437 3300 	bics.w	r3, r7, #131072	; 0x20000
   13b42:	d130      	bne.n	13ba6 <SDMMC_Init+0xa6>
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));
   13b44:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
   13b48:	d303      	bcc.n	13b52 <SDMMC_Init+0x52>
   13b4a:	21d7      	movs	r1, #215	; 0xd7
   13b4c:	4819      	ldr	r0, [pc, #100]	; (13bb4 <SDMMC_Init+0xb4>)
   13b4e:	f005 fc61 	bl	19414 <assert_failed>
  tmpreg |= (Init.ClockEdge           |\
   13b52:	ea44 0309 	orr.w	r3, r4, r9
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
   13b56:	6869      	ldr	r1, [r5, #4]
   13b58:	4a17      	ldr	r2, [pc, #92]	; (13bb8 <SDMMC_Init+0xb8>)
}
   13b5a:	2000      	movs	r0, #0
             Init.ClockPowerSave      |\
   13b5c:	ea43 0308 	orr.w	r3, r3, r8
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
   13b60:	400a      	ands	r2, r1
             Init.BusWide             |\
   13b62:	433b      	orrs	r3, r7
             Init.HardwareFlowControl |\
   13b64:	4333      	orrs	r3, r6
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
   13b66:	4313      	orrs	r3, r2
   13b68:	606b      	str	r3, [r5, #4]
}
   13b6a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13b6e:	b004      	add	sp, #16
   13b70:	4770      	bx	lr
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   13b72:	21d2      	movs	r1, #210	; 0xd2
   13b74:	480f      	ldr	r0, [pc, #60]	; (13bb4 <SDMMC_Init+0xb4>)
   13b76:	f005 fc4d 	bl	19414 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_EDGE(Init.ClockEdge));
   13b7a:	f434 3380 	bics.w	r3, r4, #65536	; 0x10000
   13b7e:	d0d5      	beq.n	13b2c <SDMMC_Init+0x2c>
   13b80:	21d3      	movs	r1, #211	; 0xd3
   13b82:	480c      	ldr	r0, [pc, #48]	; (13bb4 <SDMMC_Init+0xb4>)
   13b84:	f005 fc46 	bl	19414 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(Init.ClockPowerSave));
   13b88:	f439 5380 	bics.w	r3, r9, #4096	; 0x1000
   13b8c:	d0d1      	beq.n	13b32 <SDMMC_Init+0x32>
   13b8e:	21d4      	movs	r1, #212	; 0xd4
   13b90:	4808      	ldr	r0, [pc, #32]	; (13bb4 <SDMMC_Init+0xb4>)
   13b92:	f005 fc3f 	bl	19414 <assert_failed>
   13b96:	e7cc      	b.n	13b32 <SDMMC_Init+0x32>
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
   13b98:	21d5      	movs	r1, #213	; 0xd5
   13b9a:	4806      	ldr	r0, [pc, #24]	; (13bb4 <SDMMC_Init+0xb4>)
   13b9c:	f005 fc3a 	bl	19414 <assert_failed>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
   13ba0:	f437 3300 	bics.w	r3, r7, #131072	; 0x20000
   13ba4:	d0ce      	beq.n	13b44 <SDMMC_Init+0x44>
   13ba6:	21d6      	movs	r1, #214	; 0xd6
   13ba8:	4802      	ldr	r0, [pc, #8]	; (13bb4 <SDMMC_Init+0xb4>)
   13baa:	f005 fc33 	bl	19414 <assert_failed>
   13bae:	e7c9      	b.n	13b44 <SDMMC_Init+0x44>
   13bb0:	48022400 	.word	0x48022400
   13bb4:	0002fff8 	.word	0x0002fff8
   13bb8:	ffc02c00 	.word	0xffc02c00
   13bbc:	52007000 	.word	0x52007000

00013bc0 <SDMMC_ReadFIFO>:
  return (SDMMCx->FIFO);
   13bc0:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
   13bc4:	4770      	bx	lr
   13bc6:	bf00      	nop

00013bc8 <SDMMC_WriteFIFO>:
{
   13bc8:	4603      	mov	r3, r0
  SDMMCx->FIFO = *pWriteData;
   13bca:	680a      	ldr	r2, [r1, #0]
}
   13bcc:	2000      	movs	r0, #0
  SDMMCx->FIFO = *pWriteData;
   13bce:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
   13bd2:	4770      	bx	lr

00013bd4 <SDMMC_PowerState_ON>:
{
   13bd4:	4602      	mov	r2, r0
}
   13bd6:	2000      	movs	r0, #0
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
   13bd8:	6813      	ldr	r3, [r2, #0]
   13bda:	f043 0303 	orr.w	r3, r3, #3
   13bde:	6013      	str	r3, [r2, #0]
}
   13be0:	4770      	bx	lr
   13be2:	bf00      	nop

00013be4 <SDMMC_GetPowerState>:
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
   13be4:	6800      	ldr	r0, [r0, #0]
}
   13be6:	f000 0003 	and.w	r0, r0, #3
   13bea:	4770      	bx	lr

00013bec <SDMMC_GetResponse>:
{
   13bec:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_SDMMC_RESP(Response));
   13bee:	f031 030c 	bics.w	r3, r1, #12
{
   13bf2:	460d      	mov	r5, r1
   13bf4:	4604      	mov	r4, r0
  assert_param(IS_SDMMC_RESP(Response));
   13bf6:	d004      	beq.n	13c02 <SDMMC_GetResponse+0x16>
   13bf8:	f44f 71cc 	mov.w	r1, #408	; 0x198
   13bfc:	4802      	ldr	r0, [pc, #8]	; (13c08 <SDMMC_GetResponse+0x1c>)
   13bfe:	f005 fc09 	bl	19414 <assert_failed>
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
   13c02:	3414      	adds	r4, #20
  return (*(__IO uint32_t *) tmp);
   13c04:	5960      	ldr	r0, [r4, r5]
}
   13c06:	bd38      	pop	{r3, r4, r5, pc}
   13c08:	0002fff8 	.word	0x0002fff8

00013c0c <SDMMC_ConfigData>:
{
   13c0c:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
   13c0e:	684b      	ldr	r3, [r1, #4]
{
   13c10:	460c      	mov	r4, r1
   13c12:	4605      	mov	r5, r0
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
   13c14:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
   13c18:	d23b      	bcs.n	13c92 <SDMMC_ConfigData+0x86>
  assert_param(IS_SDMMC_BLOCK_SIZE(Data->DataBlockSize));
   13c1a:	68a2      	ldr	r2, [r4, #8]
   13c1c:	f032 0130 	bics.w	r1, r2, #48	; 0x30
   13c20:	bf14      	ite	ne
   13c22:	2301      	movne	r3, #1
   13c24:	2300      	moveq	r3, #0
   13c26:	2940      	cmp	r1, #64	; 0x40
   13c28:	bf0c      	ite	eq
   13c2a:	2300      	moveq	r3, #0
   13c2c:	f003 0301 	andne.w	r3, r3, #1
   13c30:	2ae0      	cmp	r2, #224	; 0xe0
   13c32:	bf0c      	ite	eq
   13c34:	2300      	moveq	r3, #0
   13c36:	f003 0301 	andne.w	r3, r3, #1
   13c3a:	2980      	cmp	r1, #128	; 0x80
   13c3c:	bf0c      	ite	eq
   13c3e:	2300      	moveq	r3, #0
   13c40:	f003 0301 	andne.w	r3, r3, #1
   13c44:	b11b      	cbz	r3, 13c4e <SDMMC_ConfigData+0x42>
   13c46:	f022 0210 	bic.w	r2, r2, #16
   13c4a:	2ac0      	cmp	r2, #192	; 0xc0
   13c4c:	d133      	bne.n	13cb6 <SDMMC_ConfigData+0xaa>
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
   13c4e:	68e3      	ldr	r3, [r4, #12]
   13c50:	f033 0302 	bics.w	r3, r3, #2
   13c54:	d129      	bne.n	13caa <SDMMC_ConfigData+0x9e>
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
   13c56:	6923      	ldr	r3, [r4, #16]
   13c58:	f033 0308 	bics.w	r3, r3, #8
   13c5c:	d11f      	bne.n	13c9e <SDMMC_ConfigData+0x92>
  assert_param(IS_SDMMC_DPSM(Data->DPSM));
   13c5e:	6963      	ldr	r3, [r4, #20]
   13c60:	2b01      	cmp	r3, #1
   13c62:	d904      	bls.n	13c6e <SDMMC_ConfigData+0x62>
   13c64:	f240 11b1 	movw	r1, #433	; 0x1b1
   13c68:	4816      	ldr	r0, [pc, #88]	; (13cc4 <SDMMC_ConfigData+0xb8>)
   13c6a:	f005 fbd3 	bl	19414 <assert_failed>
  SDMMCx->DTIMER = Data->DataTimeOut;
   13c6e:	6823      	ldr	r3, [r4, #0]
}
   13c70:	2000      	movs	r0, #0
  SDMMCx->DTIMER = Data->DataTimeOut;
   13c72:	626b      	str	r3, [r5, #36]	; 0x24
  SDMMCx->DLEN = Data->DataLength;
   13c74:	6863      	ldr	r3, [r4, #4]
   13c76:	62ab      	str	r3, [r5, #40]	; 0x28
                       Data->TransferDir   |\
   13c78:	6926      	ldr	r6, [r4, #16]
                       Data->TransferMode  |\
   13c7a:	6961      	ldr	r1, [r4, #20]
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
   13c7c:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   13c80:	4313      	orrs	r3, r2
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
   13c82:	6aea      	ldr	r2, [r5, #44]	; 0x2c
                       Data->TransferDir   |\
   13c84:	4333      	orrs	r3, r6
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
   13c86:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
                       Data->TransferMode  |\
   13c8a:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
   13c8c:	4313      	orrs	r3, r2
   13c8e:	62eb      	str	r3, [r5, #44]	; 0x2c
}
   13c90:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
   13c92:	f240 11ad 	movw	r1, #429	; 0x1ad
   13c96:	480b      	ldr	r0, [pc, #44]	; (13cc4 <SDMMC_ConfigData+0xb8>)
   13c98:	f005 fbbc 	bl	19414 <assert_failed>
   13c9c:	e7bd      	b.n	13c1a <SDMMC_ConfigData+0xe>
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
   13c9e:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
   13ca2:	4808      	ldr	r0, [pc, #32]	; (13cc4 <SDMMC_ConfigData+0xb8>)
   13ca4:	f005 fbb6 	bl	19414 <assert_failed>
   13ca8:	e7d9      	b.n	13c5e <SDMMC_ConfigData+0x52>
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
   13caa:	f240 11af 	movw	r1, #431	; 0x1af
   13cae:	4805      	ldr	r0, [pc, #20]	; (13cc4 <SDMMC_ConfigData+0xb8>)
   13cb0:	f005 fbb0 	bl	19414 <assert_failed>
   13cb4:	e7cf      	b.n	13c56 <SDMMC_ConfigData+0x4a>
  assert_param(IS_SDMMC_BLOCK_SIZE(Data->DataBlockSize));
   13cb6:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
   13cba:	4802      	ldr	r0, [pc, #8]	; (13cc4 <SDMMC_ConfigData+0xb8>)
   13cbc:	f005 fbaa 	bl	19414 <assert_failed>
   13cc0:	e7c5      	b.n	13c4e <SDMMC_ConfigData+0x42>
   13cc2:	bf00      	nop
   13cc4:	0002fff8 	.word	0x0002fff8

00013cc8 <SDMMC_CmdBlockLength>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13cc8:	4a1c      	ldr	r2, [pc, #112]	; (13d3c <SDMMC_CmdBlockLength+0x74>)
   13cca:	4b1d      	ldr	r3, [pc, #116]	; (13d40 <SDMMC_CmdBlockLength+0x78>)
{
   13ccc:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13cce:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13cd0:	f241 1410 	movw	r4, #4368	; 0x1110
  SDMMCx->ARG = Command->Argument;
   13cd4:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13cd6:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13cda:	68c1      	ldr	r1, [r0, #12]
   13cdc:	4d19      	ldr	r5, [pc, #100]	; (13d44 <SDMMC_CmdBlockLength+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13cde:	f241 3388 	movw	r3, #5000	; 0x1388
   13ce2:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13ce4:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13ce6:	4918      	ldr	r1, [pc, #96]	; (13d48 <SDMMC_CmdBlockLength+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13ce8:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13cec:	432c      	orrs	r4, r5
   13cee:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13cf0:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   13cf4:	d312      	bcc.n	13d1c <SDMMC_CmdBlockLength+0x54>
    sta_reg = SDMMCx->STA;
   13cf6:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13cf8:	420a      	tst	r2, r1
   13cfa:	d0f9      	beq.n	13cf0 <SDMMC_CmdBlockLength+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13cfc:	0494      	lsls	r4, r2, #18
   13cfe:	d4f7      	bmi.n	13cf0 <SDMMC_CmdBlockLength+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13d00:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13d02:	075a      	lsls	r2, r3, #29
   13d04:	d40e      	bmi.n	13d24 <SDMMC_CmdBlockLength+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13d06:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13d08:	07db      	lsls	r3, r3, #31
   13d0a:	d40f      	bmi.n	13d2c <SDMMC_CmdBlockLength+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13d0c:	4b0f      	ldr	r3, [pc, #60]	; (13d4c <SDMMC_CmdBlockLength+0x84>)
   13d0e:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13d10:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13d12:	b2db      	uxtb	r3, r3
   13d14:	2b10      	cmp	r3, #16
   13d16:	d00d      	beq.n	13d34 <SDMMC_CmdBlockLength+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13d18:	2001      	movs	r0, #1
  return errorstate;
   13d1a:	e001      	b.n	13d20 <SDMMC_CmdBlockLength+0x58>
      return SDMMC_ERROR_TIMEOUT;
   13d1c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   13d20:	bc30      	pop	{r4, r5}
   13d22:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13d24:	2304      	movs	r3, #4
   13d26:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   13d28:	4618      	mov	r0, r3
   13d2a:	e7f9      	b.n	13d20 <SDMMC_CmdBlockLength+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13d2c:	2301      	movs	r3, #1
   13d2e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13d30:	4618      	mov	r0, r3
   13d32:	e7f5      	b.n	13d20 <SDMMC_CmdBlockLength+0x58>
}
   13d34:	bc30      	pop	{r4, r5}
   13d36:	f7ff be7f 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   13d3a:	bf00      	nop
   13d3c:	0006280c 	.word	0x0006280c
   13d40:	10624dd3 	.word	0x10624dd3
   13d44:	fffee0c0 	.word	0xfffee0c0
   13d48:	00200045 	.word	0x00200045
   13d4c:	002000c5 	.word	0x002000c5

00013d50 <SDMMC_CmdReadSingleBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13d50:	4a1c      	ldr	r2, [pc, #112]	; (13dc4 <SDMMC_CmdReadSingleBlock+0x74>)
   13d52:	4b1d      	ldr	r3, [pc, #116]	; (13dc8 <SDMMC_CmdReadSingleBlock+0x78>)
{
   13d54:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13d56:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13d58:	f241 1411 	movw	r4, #4369	; 0x1111
  SDMMCx->ARG = Command->Argument;
   13d5c:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13d5e:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13d62:	68c1      	ldr	r1, [r0, #12]
   13d64:	4d19      	ldr	r5, [pc, #100]	; (13dcc <SDMMC_CmdReadSingleBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13d66:	f241 3388 	movw	r3, #5000	; 0x1388
   13d6a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13d6c:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13d6e:	4918      	ldr	r1, [pc, #96]	; (13dd0 <SDMMC_CmdReadSingleBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13d70:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13d74:	432c      	orrs	r4, r5
   13d76:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13d78:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   13d7c:	d312      	bcc.n	13da4 <SDMMC_CmdReadSingleBlock+0x54>
    sta_reg = SDMMCx->STA;
   13d7e:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13d80:	420a      	tst	r2, r1
   13d82:	d0f9      	beq.n	13d78 <SDMMC_CmdReadSingleBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13d84:	0494      	lsls	r4, r2, #18
   13d86:	d4f7      	bmi.n	13d78 <SDMMC_CmdReadSingleBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13d88:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13d8a:	075a      	lsls	r2, r3, #29
   13d8c:	d40e      	bmi.n	13dac <SDMMC_CmdReadSingleBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13d8e:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13d90:	07db      	lsls	r3, r3, #31
   13d92:	d40f      	bmi.n	13db4 <SDMMC_CmdReadSingleBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13d94:	4b0f      	ldr	r3, [pc, #60]	; (13dd4 <SDMMC_CmdReadSingleBlock+0x84>)
   13d96:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13d98:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13d9a:	b2db      	uxtb	r3, r3
   13d9c:	2b11      	cmp	r3, #17
   13d9e:	d00d      	beq.n	13dbc <SDMMC_CmdReadSingleBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13da0:	2001      	movs	r0, #1
  return errorstate;
   13da2:	e001      	b.n	13da8 <SDMMC_CmdReadSingleBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
   13da4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   13da8:	bc30      	pop	{r4, r5}
   13daa:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13dac:	2304      	movs	r3, #4
   13dae:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   13db0:	4618      	mov	r0, r3
   13db2:	e7f9      	b.n	13da8 <SDMMC_CmdReadSingleBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13db4:	2301      	movs	r3, #1
   13db6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13db8:	4618      	mov	r0, r3
   13dba:	e7f5      	b.n	13da8 <SDMMC_CmdReadSingleBlock+0x58>
}
   13dbc:	bc30      	pop	{r4, r5}
   13dbe:	f7ff be3b 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   13dc2:	bf00      	nop
   13dc4:	0006280c 	.word	0x0006280c
   13dc8:	10624dd3 	.word	0x10624dd3
   13dcc:	fffee0c0 	.word	0xfffee0c0
   13dd0:	00200045 	.word	0x00200045
   13dd4:	002000c5 	.word	0x002000c5

00013dd8 <SDMMC_CmdReadMultiBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13dd8:	4a1c      	ldr	r2, [pc, #112]	; (13e4c <SDMMC_CmdReadMultiBlock+0x74>)
   13dda:	4b1d      	ldr	r3, [pc, #116]	; (13e50 <SDMMC_CmdReadMultiBlock+0x78>)
{
   13ddc:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13dde:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13de0:	f241 1412 	movw	r4, #4370	; 0x1112
  SDMMCx->ARG = Command->Argument;
   13de4:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13de6:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13dea:	68c1      	ldr	r1, [r0, #12]
   13dec:	4d19      	ldr	r5, [pc, #100]	; (13e54 <SDMMC_CmdReadMultiBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13dee:	f241 3388 	movw	r3, #5000	; 0x1388
   13df2:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13df4:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13df6:	4918      	ldr	r1, [pc, #96]	; (13e58 <SDMMC_CmdReadMultiBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13df8:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13dfc:	432c      	orrs	r4, r5
   13dfe:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13e00:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   13e04:	d312      	bcc.n	13e2c <SDMMC_CmdReadMultiBlock+0x54>
    sta_reg = SDMMCx->STA;
   13e06:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13e08:	420a      	tst	r2, r1
   13e0a:	d0f9      	beq.n	13e00 <SDMMC_CmdReadMultiBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13e0c:	0494      	lsls	r4, r2, #18
   13e0e:	d4f7      	bmi.n	13e00 <SDMMC_CmdReadMultiBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13e10:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13e12:	075a      	lsls	r2, r3, #29
   13e14:	d40e      	bmi.n	13e34 <SDMMC_CmdReadMultiBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13e16:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13e18:	07db      	lsls	r3, r3, #31
   13e1a:	d40f      	bmi.n	13e3c <SDMMC_CmdReadMultiBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13e1c:	4b0f      	ldr	r3, [pc, #60]	; (13e5c <SDMMC_CmdReadMultiBlock+0x84>)
   13e1e:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13e20:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13e22:	b2db      	uxtb	r3, r3
   13e24:	2b12      	cmp	r3, #18
   13e26:	d00d      	beq.n	13e44 <SDMMC_CmdReadMultiBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13e28:	2001      	movs	r0, #1
  return errorstate;
   13e2a:	e001      	b.n	13e30 <SDMMC_CmdReadMultiBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
   13e2c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   13e30:	bc30      	pop	{r4, r5}
   13e32:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13e34:	2304      	movs	r3, #4
   13e36:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   13e38:	4618      	mov	r0, r3
   13e3a:	e7f9      	b.n	13e30 <SDMMC_CmdReadMultiBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13e3c:	2301      	movs	r3, #1
   13e3e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13e40:	4618      	mov	r0, r3
   13e42:	e7f5      	b.n	13e30 <SDMMC_CmdReadMultiBlock+0x58>
}
   13e44:	bc30      	pop	{r4, r5}
   13e46:	f7ff bdf7 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   13e4a:	bf00      	nop
   13e4c:	0006280c 	.word	0x0006280c
   13e50:	10624dd3 	.word	0x10624dd3
   13e54:	fffee0c0 	.word	0xfffee0c0
   13e58:	00200045 	.word	0x00200045
   13e5c:	002000c5 	.word	0x002000c5

00013e60 <SDMMC_CmdWriteSingleBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13e60:	4a1c      	ldr	r2, [pc, #112]	; (13ed4 <SDMMC_CmdWriteSingleBlock+0x74>)
   13e62:	4b1d      	ldr	r3, [pc, #116]	; (13ed8 <SDMMC_CmdWriteSingleBlock+0x78>)
{
   13e64:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13e66:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13e68:	f241 1418 	movw	r4, #4376	; 0x1118
  SDMMCx->ARG = Command->Argument;
   13e6c:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13e6e:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13e72:	68c1      	ldr	r1, [r0, #12]
   13e74:	4d19      	ldr	r5, [pc, #100]	; (13edc <SDMMC_CmdWriteSingleBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13e76:	f241 3388 	movw	r3, #5000	; 0x1388
   13e7a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13e7c:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13e7e:	4918      	ldr	r1, [pc, #96]	; (13ee0 <SDMMC_CmdWriteSingleBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13e80:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13e84:	432c      	orrs	r4, r5
   13e86:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13e88:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   13e8c:	d312      	bcc.n	13eb4 <SDMMC_CmdWriteSingleBlock+0x54>
    sta_reg = SDMMCx->STA;
   13e8e:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13e90:	420a      	tst	r2, r1
   13e92:	d0f9      	beq.n	13e88 <SDMMC_CmdWriteSingleBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13e94:	0494      	lsls	r4, r2, #18
   13e96:	d4f7      	bmi.n	13e88 <SDMMC_CmdWriteSingleBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13e98:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13e9a:	075a      	lsls	r2, r3, #29
   13e9c:	d40e      	bmi.n	13ebc <SDMMC_CmdWriteSingleBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13e9e:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13ea0:	07db      	lsls	r3, r3, #31
   13ea2:	d40f      	bmi.n	13ec4 <SDMMC_CmdWriteSingleBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13ea4:	4b0f      	ldr	r3, [pc, #60]	; (13ee4 <SDMMC_CmdWriteSingleBlock+0x84>)
   13ea6:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13ea8:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13eaa:	b2db      	uxtb	r3, r3
   13eac:	2b18      	cmp	r3, #24
   13eae:	d00d      	beq.n	13ecc <SDMMC_CmdWriteSingleBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13eb0:	2001      	movs	r0, #1
  return errorstate;
   13eb2:	e001      	b.n	13eb8 <SDMMC_CmdWriteSingleBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
   13eb4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   13eb8:	bc30      	pop	{r4, r5}
   13eba:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13ebc:	2304      	movs	r3, #4
   13ebe:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   13ec0:	4618      	mov	r0, r3
   13ec2:	e7f9      	b.n	13eb8 <SDMMC_CmdWriteSingleBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13ec4:	2301      	movs	r3, #1
   13ec6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13ec8:	4618      	mov	r0, r3
   13eca:	e7f5      	b.n	13eb8 <SDMMC_CmdWriteSingleBlock+0x58>
}
   13ecc:	bc30      	pop	{r4, r5}
   13ece:	f7ff bdb3 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   13ed2:	bf00      	nop
   13ed4:	0006280c 	.word	0x0006280c
   13ed8:	10624dd3 	.word	0x10624dd3
   13edc:	fffee0c0 	.word	0xfffee0c0
   13ee0:	00200045 	.word	0x00200045
   13ee4:	002000c5 	.word	0x002000c5

00013ee8 <SDMMC_CmdWriteMultiBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13ee8:	4a1c      	ldr	r2, [pc, #112]	; (13f5c <SDMMC_CmdWriteMultiBlock+0x74>)
   13eea:	4b1d      	ldr	r3, [pc, #116]	; (13f60 <SDMMC_CmdWriteMultiBlock+0x78>)
{
   13eec:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13eee:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13ef0:	f241 1419 	movw	r4, #4377	; 0x1119
  SDMMCx->ARG = Command->Argument;
   13ef4:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13ef6:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13efa:	68c1      	ldr	r1, [r0, #12]
   13efc:	4d19      	ldr	r5, [pc, #100]	; (13f64 <SDMMC_CmdWriteMultiBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13efe:	f241 3388 	movw	r3, #5000	; 0x1388
   13f02:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13f04:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13f06:	4918      	ldr	r1, [pc, #96]	; (13f68 <SDMMC_CmdWriteMultiBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f08:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13f0c:	432c      	orrs	r4, r5
   13f0e:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13f10:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   13f14:	d312      	bcc.n	13f3c <SDMMC_CmdWriteMultiBlock+0x54>
    sta_reg = SDMMCx->STA;
   13f16:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13f18:	420a      	tst	r2, r1
   13f1a:	d0f9      	beq.n	13f10 <SDMMC_CmdWriteMultiBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13f1c:	0494      	lsls	r4, r2, #18
   13f1e:	d4f7      	bmi.n	13f10 <SDMMC_CmdWriteMultiBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13f20:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13f22:	075a      	lsls	r2, r3, #29
   13f24:	d40e      	bmi.n	13f44 <SDMMC_CmdWriteMultiBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13f26:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13f28:	07db      	lsls	r3, r3, #31
   13f2a:	d40f      	bmi.n	13f4c <SDMMC_CmdWriteMultiBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13f2c:	4b0f      	ldr	r3, [pc, #60]	; (13f6c <SDMMC_CmdWriteMultiBlock+0x84>)
   13f2e:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13f30:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13f32:	b2db      	uxtb	r3, r3
   13f34:	2b19      	cmp	r3, #25
   13f36:	d00d      	beq.n	13f54 <SDMMC_CmdWriteMultiBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13f38:	2001      	movs	r0, #1
  return errorstate;
   13f3a:	e001      	b.n	13f40 <SDMMC_CmdWriteMultiBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
   13f3c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   13f40:	bc30      	pop	{r4, r5}
   13f42:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13f44:	2304      	movs	r3, #4
   13f46:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   13f48:	4618      	mov	r0, r3
   13f4a:	e7f9      	b.n	13f40 <SDMMC_CmdWriteMultiBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13f4c:	2301      	movs	r3, #1
   13f4e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13f50:	4618      	mov	r0, r3
   13f52:	e7f5      	b.n	13f40 <SDMMC_CmdWriteMultiBlock+0x58>
}
   13f54:	bc30      	pop	{r4, r5}
   13f56:	f7ff bd6f 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   13f5a:	bf00      	nop
   13f5c:	0006280c 	.word	0x0006280c
   13f60:	10624dd3 	.word	0x10624dd3
   13f64:	fffee0c0 	.word	0xfffee0c0
   13f68:	00200045 	.word	0x00200045
   13f6c:	002000c5 	.word	0x002000c5

00013f70 <SDMMC_CmdStopTransfer>:
{
   13f70:	b570      	push	{r4, r5, r6, lr}
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
   13f72:	68c3      	ldr	r3, [r0, #12]
  SDMMCx->ARG = Command->Argument;
   13f74:	2600      	movs	r6, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f76:	4a2a      	ldr	r2, [pc, #168]	; (14020 <SDMMC_CmdStopTransfer+0xb0>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13f78:	f241 140c 	movw	r4, #4364	; 0x110c
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
   13f7c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13f80:	4d28      	ldr	r5, [pc, #160]	; (14024 <SDMMC_CmdStopTransfer+0xb4>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f82:	6812      	ldr	r2, [r2, #0]
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
   13f84:	60c3      	str	r3, [r0, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
   13f86:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f88:	4b27      	ldr	r3, [pc, #156]	; (14028 <SDMMC_CmdStopTransfer+0xb8>)
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
   13f8a:	f021 0140 	bic.w	r1, r1, #64	; 0x40
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f8e:	fba3 3202 	umull	r3, r2, r3, r2
   13f92:	4b26      	ldr	r3, [pc, #152]	; (1402c <SDMMC_CmdStopTransfer+0xbc>)
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
   13f94:	60c1      	str	r1, [r0, #12]
  SDMMCx->ARG = Command->Argument;
   13f96:	6086      	str	r6, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f98:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13f9a:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f9c:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13fa0:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13fa2:	4923      	ldr	r1, [pc, #140]	; (14030 <SDMMC_CmdStopTransfer+0xc0>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13fa4:	432c      	orrs	r4, r5
   13fa6:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13fa8:	b1c3      	cbz	r3, 13fdc <SDMMC_CmdStopTransfer+0x6c>
    sta_reg = SDMMCx->STA;
   13faa:	6b42      	ldr	r2, [r0, #52]	; 0x34
   13fac:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13fae:	420a      	tst	r2, r1
   13fb0:	d0fa      	beq.n	13fa8 <SDMMC_CmdStopTransfer+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13fb2:	0492      	lsls	r2, r2, #18
   13fb4:	d4f8      	bmi.n	13fa8 <SDMMC_CmdStopTransfer+0x38>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13fb6:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13fb8:	075b      	lsls	r3, r3, #29
   13fba:	d417      	bmi.n	13fec <SDMMC_CmdStopTransfer+0x7c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13fbc:	6b44      	ldr	r4, [r0, #52]	; 0x34
   13fbe:	f014 0401 	ands.w	r4, r4, #1
   13fc2:	d11a      	bne.n	13ffa <SDMMC_CmdStopTransfer+0x8a>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13fc4:	4b1b      	ldr	r3, [pc, #108]	; (14034 <SDMMC_CmdStopTransfer+0xc4>)
   13fc6:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13fc8:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13fca:	b2db      	uxtb	r3, r3
   13fcc:	2b0c      	cmp	r3, #12
   13fce:	d01b      	beq.n	14008 <SDMMC_CmdStopTransfer+0x98>
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   13fd0:	68c3      	ldr	r3, [r0, #12]
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13fd2:	2401      	movs	r4, #1
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   13fd4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   13fd8:	60c3      	str	r3, [r0, #12]
   13fda:	e005      	b.n	13fe8 <SDMMC_CmdStopTransfer+0x78>
   13fdc:	68c3      	ldr	r3, [r0, #12]
      return SDMMC_ERROR_TIMEOUT;
   13fde:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   13fe2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   13fe6:	60c3      	str	r3, [r0, #12]
}
   13fe8:	4620      	mov	r0, r4
   13fea:	bd70      	pop	{r4, r5, r6, pc}
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13fec:	2404      	movs	r4, #4
   13fee:	6384      	str	r4, [r0, #56]	; 0x38
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   13ff0:	68c3      	ldr	r3, [r0, #12]
   13ff2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   13ff6:	60c3      	str	r3, [r0, #12]
   13ff8:	e7f6      	b.n	13fe8 <SDMMC_CmdStopTransfer+0x78>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13ffa:	2401      	movs	r4, #1
   13ffc:	6384      	str	r4, [r0, #56]	; 0x38
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   13ffe:	68c3      	ldr	r3, [r0, #12]
   14000:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   14004:	60c3      	str	r3, [r0, #12]
   14006:	e7ef      	b.n	13fe8 <SDMMC_CmdStopTransfer+0x78>
   14008:	4605      	mov	r5, r0
   1400a:	f7ff fd15 	bl	13a38 <SDMMC_GetCmdResp1.part.2>
  if (errorstate == SDMMC_ERROR_ADDR_OUT_OF_RANGE)
   1400e:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
   14012:	bf18      	it	ne
   14014:	4604      	movne	r4, r0
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   14016:	68eb      	ldr	r3, [r5, #12]
   14018:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   1401c:	60eb      	str	r3, [r5, #12]
   1401e:	e7e3      	b.n	13fe8 <SDMMC_CmdStopTransfer+0x78>
   14020:	0006280c 	.word	0x0006280c
   14024:	fffee0c0 	.word	0xfffee0c0
   14028:	10624dd3 	.word	0x10624dd3
   1402c:	05f5e100 	.word	0x05f5e100
   14030:	00200045 	.word	0x00200045
   14034:	002000c5 	.word	0x002000c5

00014038 <SDMMC_CmdSelDesel>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14038:	4b1c      	ldr	r3, [pc, #112]	; (140ac <SDMMC_CmdSelDesel+0x74>)
   1403a:	491d      	ldr	r1, [pc, #116]	; (140b0 <SDMMC_CmdSelDesel+0x78>)
{
   1403c:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1403e:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14040:	f241 1407 	movw	r4, #4359	; 0x1107
  SDMMCx->ARG = Command->Argument;
   14044:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14046:	4d1b      	ldr	r5, [pc, #108]	; (140b4 <SDMMC_CmdSelDesel+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14048:	fba1 3203 	umull	r3, r2, r1, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1404c:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1404e:	f241 3388 	movw	r3, #5000	; 0x1388
   14052:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14054:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   14056:	4918      	ldr	r1, [pc, #96]	; (140b8 <SDMMC_CmdSelDesel+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14058:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1405c:	432c      	orrs	r4, r5
   1405e:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   14060:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   14064:	d312      	bcc.n	1408c <SDMMC_CmdSelDesel+0x54>
    sta_reg = SDMMCx->STA;
   14066:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   14068:	420a      	tst	r2, r1
   1406a:	d0f9      	beq.n	14060 <SDMMC_CmdSelDesel+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1406c:	0494      	lsls	r4, r2, #18
   1406e:	d4f7      	bmi.n	14060 <SDMMC_CmdSelDesel+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   14070:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14072:	075a      	lsls	r2, r3, #29
   14074:	d40e      	bmi.n	14094 <SDMMC_CmdSelDesel+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   14076:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14078:	07db      	lsls	r3, r3, #31
   1407a:	d40f      	bmi.n	1409c <SDMMC_CmdSelDesel+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   1407c:	4b0f      	ldr	r3, [pc, #60]	; (140bc <SDMMC_CmdSelDesel+0x84>)
   1407e:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   14080:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   14082:	b2db      	uxtb	r3, r3
   14084:	2b07      	cmp	r3, #7
   14086:	d00d      	beq.n	140a4 <SDMMC_CmdSelDesel+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   14088:	2001      	movs	r0, #1
  return errorstate;
   1408a:	e001      	b.n	14090 <SDMMC_CmdSelDesel+0x58>
      return SDMMC_ERROR_TIMEOUT;
   1408c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   14090:	bc30      	pop	{r4, r5}
   14092:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14094:	2304      	movs	r3, #4
   14096:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   14098:	4618      	mov	r0, r3
   1409a:	e7f9      	b.n	14090 <SDMMC_CmdSelDesel+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   1409c:	2301      	movs	r3, #1
   1409e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   140a0:	4618      	mov	r0, r3
   140a2:	e7f5      	b.n	14090 <SDMMC_CmdSelDesel+0x58>
}
   140a4:	bc30      	pop	{r4, r5}
   140a6:	f7ff bcc7 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   140aa:	bf00      	nop
   140ac:	0006280c 	.word	0x0006280c
   140b0:	10624dd3 	.word	0x10624dd3
   140b4:	fffee0c0 	.word	0xfffee0c0
   140b8:	00200045 	.word	0x00200045
   140bc:	002000c5 	.word	0x002000c5

000140c0 <SDMMC_CmdGoIdleState>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   140c0:	4b12      	ldr	r3, [pc, #72]	; (1410c <SDMMC_CmdGoIdleState+0x4c>)
{
   140c2:	4602      	mov	r2, r0
  SDMMCx->ARG = Command->Argument;
   140c4:	2100      	movs	r1, #0
{
   140c6:	b410      	push	{r4}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   140c8:	4c11      	ldr	r4, [pc, #68]	; (14110 <SDMMC_CmdGoIdleState+0x50>)
   140ca:	6818      	ldr	r0, [r3, #0]
   140cc:	f241 3388 	movw	r3, #5000	; 0x1388
  SDMMCx->ARG = Command->Argument;
   140d0:	6091      	str	r1, [r2, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   140d2:	fba4 4000 	umull	r4, r0, r4, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   140d6:	490f      	ldr	r1, [pc, #60]	; (14114 <SDMMC_CmdGoIdleState+0x54>)
   140d8:	68d4      	ldr	r4, [r2, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   140da:	0a40      	lsrs	r0, r0, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   140dc:	4021      	ands	r1, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   140de:	fb03 f300 	mul.w	r3, r3, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   140e2:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
   140e6:	60d1      	str	r1, [r2, #12]
   140e8:	e002      	b.n	140f0 <SDMMC_CmdGoIdleState+0x30>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
   140ea:	6b51      	ldr	r1, [r2, #52]	; 0x34
   140ec:	0609      	lsls	r1, r1, #24
   140ee:	d407      	bmi.n	14100 <SDMMC_CmdGoIdleState+0x40>
    if (count-- == 0U)
   140f0:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   140f4:	d2f9      	bcs.n	140ea <SDMMC_CmdGoIdleState+0x2a>
      return SDMMC_ERROR_TIMEOUT;
   140f6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   140fa:	f85d 4b04 	ldr.w	r4, [sp], #4
   140fe:	4770      	bx	lr
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14100:	4b05      	ldr	r3, [pc, #20]	; (14118 <SDMMC_CmdGoIdleState+0x58>)
  return SDMMC_ERROR_NONE;
   14102:	2000      	movs	r0, #0
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14104:	6393      	str	r3, [r2, #56]	; 0x38
}
   14106:	f85d 4b04 	ldr.w	r4, [sp], #4
   1410a:	4770      	bx	lr
   1410c:	0006280c 	.word	0x0006280c
   14110:	10624dd3 	.word	0x10624dd3
   14114:	fffee0c0 	.word	0xfffee0c0
   14118:	002000c5 	.word	0x002000c5

0001411c <SDMMC_CmdOperCond>:
static uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1411c:	4a1c      	ldr	r2, [pc, #112]	; (14190 <SDMMC_CmdOperCond+0x74>)
{
   1411e:	4601      	mov	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14120:	4b1c      	ldr	r3, [pc, #112]	; (14194 <SDMMC_CmdOperCond+0x78>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14122:	f241 1008 	movw	r0, #4360	; 0x1108
{
   14126:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
   14128:	f44f 74d5 	mov.w	r4, #426	; 0x1aa
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1412c:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
   1412e:	608c      	str	r4, [r1, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14130:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14134:	68cd      	ldr	r5, [r1, #12]
   14136:	4c18      	ldr	r4, [pc, #96]	; (14198 <SDMMC_CmdOperCond+0x7c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14138:	f241 3388 	movw	r3, #5000	; 0x1388
   1413c:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1413e:	402c      	ands	r4, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14140:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14144:	4320      	orrs	r0, r4
   14146:	60c8      	str	r0, [r1, #12]

  do
  {
    if (count-- == 0U)
   14148:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   1414c:	d313      	bcc.n	14176 <SDMMC_CmdOperCond+0x5a>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
   1414e:	6b4a      	ldr	r2, [r1, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   14150:	f012 0f45 	tst.w	r2, #69	; 0x45
   14154:	d0f8      	beq.n	14148 <SDMMC_CmdOperCond+0x2c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   14156:	0492      	lsls	r2, r2, #18
   14158:	d4f6      	bmi.n	14148 <SDMMC_CmdOperCond+0x2c>

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   1415a:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   1415c:	075b      	lsls	r3, r3, #29
   1415e:	d40e      	bmi.n	1417e <SDMMC_CmdOperCond+0x62>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }

  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   14160:	6b48      	ldr	r0, [r1, #52]	; 0x34
   14162:	f010 0001 	ands.w	r0, r0, #1
   14166:	d10d      	bne.n	14184 <SDMMC_CmdOperCond+0x68>
  else
  {
    /* Nothing to do */
  }

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
   14168:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   1416a:	f013 0340 	ands.w	r3, r3, #64	; 0x40
   1416e:	d00c      	beq.n	1418a <SDMMC_CmdOperCond+0x6e>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
   14170:	2340      	movs	r3, #64	; 0x40
   14172:	638b      	str	r3, [r1, #56]	; 0x38
   14174:	e001      	b.n	1417a <SDMMC_CmdOperCond+0x5e>
      return SDMMC_ERROR_TIMEOUT;
   14176:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   1417a:	bc30      	pop	{r4, r5}
   1417c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   1417e:	2004      	movs	r0, #4
   14180:	6388      	str	r0, [r1, #56]	; 0x38
   14182:	e7fa      	b.n	1417a <SDMMC_CmdOperCond+0x5e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   14184:	2001      	movs	r0, #1
   14186:	6388      	str	r0, [r1, #56]	; 0x38
   14188:	e7f7      	b.n	1417a <SDMMC_CmdOperCond+0x5e>
  }

  return SDMMC_ERROR_NONE;
   1418a:	4618      	mov	r0, r3
  return errorstate;
   1418c:	e7f5      	b.n	1417a <SDMMC_CmdOperCond+0x5e>
   1418e:	bf00      	nop
   14190:	0006280c 	.word	0x0006280c
   14194:	10624dd3 	.word	0x10624dd3
   14198:	fffee0c0 	.word	0xfffee0c0

0001419c <SDMMC_CmdAppCommand>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1419c:	4a1c      	ldr	r2, [pc, #112]	; (14210 <SDMMC_CmdAppCommand+0x74>)
   1419e:	4b1d      	ldr	r3, [pc, #116]	; (14214 <SDMMC_CmdAppCommand+0x78>)
{
   141a0:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   141a2:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   141a4:	f241 1437 	movw	r4, #4407	; 0x1137
  SDMMCx->ARG = Command->Argument;
   141a8:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   141aa:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   141ae:	68c1      	ldr	r1, [r0, #12]
   141b0:	4d19      	ldr	r5, [pc, #100]	; (14218 <SDMMC_CmdAppCommand+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   141b2:	f241 3388 	movw	r3, #5000	; 0x1388
   141b6:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   141b8:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   141ba:	4918      	ldr	r1, [pc, #96]	; (1421c <SDMMC_CmdAppCommand+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   141bc:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   141c0:	432c      	orrs	r4, r5
   141c2:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   141c4:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   141c8:	d312      	bcc.n	141f0 <SDMMC_CmdAppCommand+0x54>
    sta_reg = SDMMCx->STA;
   141ca:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   141cc:	420a      	tst	r2, r1
   141ce:	d0f9      	beq.n	141c4 <SDMMC_CmdAppCommand+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   141d0:	0494      	lsls	r4, r2, #18
   141d2:	d4f7      	bmi.n	141c4 <SDMMC_CmdAppCommand+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   141d4:	6b43      	ldr	r3, [r0, #52]	; 0x34
   141d6:	075a      	lsls	r2, r3, #29
   141d8:	d40e      	bmi.n	141f8 <SDMMC_CmdAppCommand+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   141da:	6b43      	ldr	r3, [r0, #52]	; 0x34
   141dc:	07db      	lsls	r3, r3, #31
   141de:	d40f      	bmi.n	14200 <SDMMC_CmdAppCommand+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   141e0:	4b0f      	ldr	r3, [pc, #60]	; (14220 <SDMMC_CmdAppCommand+0x84>)
   141e2:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   141e4:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   141e6:	b2db      	uxtb	r3, r3
   141e8:	2b37      	cmp	r3, #55	; 0x37
   141ea:	d00d      	beq.n	14208 <SDMMC_CmdAppCommand+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   141ec:	2001      	movs	r0, #1
  return errorstate;
   141ee:	e001      	b.n	141f4 <SDMMC_CmdAppCommand+0x58>
      return SDMMC_ERROR_TIMEOUT;
   141f0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   141f4:	bc30      	pop	{r4, r5}
   141f6:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   141f8:	2304      	movs	r3, #4
   141fa:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   141fc:	4618      	mov	r0, r3
   141fe:	e7f9      	b.n	141f4 <SDMMC_CmdAppCommand+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   14200:	2301      	movs	r3, #1
   14202:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   14204:	4618      	mov	r0, r3
   14206:	e7f5      	b.n	141f4 <SDMMC_CmdAppCommand+0x58>
}
   14208:	bc30      	pop	{r4, r5}
   1420a:	f7ff bc15 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   1420e:	bf00      	nop
   14210:	0006280c 	.word	0x0006280c
   14214:	10624dd3 	.word	0x10624dd3
   14218:	fffee0c0 	.word	0xfffee0c0
   1421c:	00200045 	.word	0x00200045
   14220:	002000c5 	.word	0x002000c5

00014224 <SDMMC_CmdAppOperCommand>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14224:	4a15      	ldr	r2, [pc, #84]	; (1427c <SDMMC_CmdAppOperCommand+0x58>)
   14226:	4b16      	ldr	r3, [pc, #88]	; (14280 <SDMMC_CmdAppOperCommand+0x5c>)
{
   14228:	b430      	push	{r4, r5}
   1422a:	4604      	mov	r4, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1422c:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1422e:	f241 1029 	movw	r0, #4393	; 0x1129
  SDMMCx->ARG = Command->Argument;
   14232:	60a1      	str	r1, [r4, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14234:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14238:	68e5      	ldr	r5, [r4, #12]
   1423a:	4912      	ldr	r1, [pc, #72]	; (14284 <SDMMC_CmdAppOperCommand+0x60>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1423c:	f241 3388 	movw	r3, #5000	; 0x1388
   14240:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14242:	4029      	ands	r1, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14244:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14248:	4308      	orrs	r0, r1
   1424a:	60e0      	str	r0, [r4, #12]
    if (count-- == 0U)
   1424c:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   14250:	d30d      	bcc.n	1426e <SDMMC_CmdAppOperCommand+0x4a>
    sta_reg = SDMMCx->STA;
   14252:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   14254:	f012 0f45 	tst.w	r2, #69	; 0x45
   14258:	d0f8      	beq.n	1424c <SDMMC_CmdAppOperCommand+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   1425a:	0492      	lsls	r2, r2, #18
   1425c:	d4f6      	bmi.n	1424c <SDMMC_CmdAppOperCommand+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   1425e:	6b60      	ldr	r0, [r4, #52]	; 0x34
   14260:	f010 0004 	ands.w	r0, r0, #4
   14264:	d107      	bne.n	14276 <SDMMC_CmdAppOperCommand+0x52>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14266:	4b08      	ldr	r3, [pc, #32]	; (14288 <SDMMC_CmdAppOperCommand+0x64>)
   14268:	63a3      	str	r3, [r4, #56]	; 0x38
}
   1426a:	bc30      	pop	{r4, r5}
   1426c:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
   1426e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   14272:	bc30      	pop	{r4, r5}
   14274:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14276:	2004      	movs	r0, #4
   14278:	63a0      	str	r0, [r4, #56]	; 0x38
   1427a:	e7fa      	b.n	14272 <SDMMC_CmdAppOperCommand+0x4e>
   1427c:	0006280c 	.word	0x0006280c
   14280:	10624dd3 	.word	0x10624dd3
   14284:	fffee0c0 	.word	0xfffee0c0
   14288:	002000c5 	.word	0x002000c5

0001428c <SDMMC_CmdBusWidth>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1428c:	4a1c      	ldr	r2, [pc, #112]	; (14300 <SDMMC_CmdBusWidth+0x74>)
   1428e:	4b1d      	ldr	r3, [pc, #116]	; (14304 <SDMMC_CmdBusWidth+0x78>)
{
   14290:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14292:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14294:	f241 1406 	movw	r4, #4358	; 0x1106
  SDMMCx->ARG = Command->Argument;
   14298:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1429a:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1429e:	68c1      	ldr	r1, [r0, #12]
   142a0:	4d19      	ldr	r5, [pc, #100]	; (14308 <SDMMC_CmdBusWidth+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   142a2:	f241 3388 	movw	r3, #5000	; 0x1388
   142a6:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   142a8:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   142aa:	4918      	ldr	r1, [pc, #96]	; (1430c <SDMMC_CmdBusWidth+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   142ac:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   142b0:	432c      	orrs	r4, r5
   142b2:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   142b4:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   142b8:	d312      	bcc.n	142e0 <SDMMC_CmdBusWidth+0x54>
    sta_reg = SDMMCx->STA;
   142ba:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   142bc:	420a      	tst	r2, r1
   142be:	d0f9      	beq.n	142b4 <SDMMC_CmdBusWidth+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   142c0:	0494      	lsls	r4, r2, #18
   142c2:	d4f7      	bmi.n	142b4 <SDMMC_CmdBusWidth+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   142c4:	6b43      	ldr	r3, [r0, #52]	; 0x34
   142c6:	075a      	lsls	r2, r3, #29
   142c8:	d40e      	bmi.n	142e8 <SDMMC_CmdBusWidth+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   142ca:	6b43      	ldr	r3, [r0, #52]	; 0x34
   142cc:	07db      	lsls	r3, r3, #31
   142ce:	d40f      	bmi.n	142f0 <SDMMC_CmdBusWidth+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   142d0:	4b0f      	ldr	r3, [pc, #60]	; (14310 <SDMMC_CmdBusWidth+0x84>)
   142d2:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   142d4:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   142d6:	b2db      	uxtb	r3, r3
   142d8:	2b06      	cmp	r3, #6
   142da:	d00d      	beq.n	142f8 <SDMMC_CmdBusWidth+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   142dc:	2001      	movs	r0, #1
  return errorstate;
   142de:	e001      	b.n	142e4 <SDMMC_CmdBusWidth+0x58>
      return SDMMC_ERROR_TIMEOUT;
   142e0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   142e4:	bc30      	pop	{r4, r5}
   142e6:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   142e8:	2304      	movs	r3, #4
   142ea:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   142ec:	4618      	mov	r0, r3
   142ee:	e7f9      	b.n	142e4 <SDMMC_CmdBusWidth+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   142f0:	2301      	movs	r3, #1
   142f2:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   142f4:	4618      	mov	r0, r3
   142f6:	e7f5      	b.n	142e4 <SDMMC_CmdBusWidth+0x58>
}
   142f8:	bc30      	pop	{r4, r5}
   142fa:	f7ff bb9d 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   142fe:	bf00      	nop
   14300:	0006280c 	.word	0x0006280c
   14304:	10624dd3 	.word	0x10624dd3
   14308:	fffee0c0 	.word	0xfffee0c0
   1430c:	00200045 	.word	0x00200045
   14310:	002000c5 	.word	0x002000c5

00014314 <SDMMC_CmdSendSCR>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14314:	4a1c      	ldr	r2, [pc, #112]	; (14388 <SDMMC_CmdSendSCR+0x74>)
  SDMMCx->ARG = Command->Argument;
   14316:	2100      	movs	r1, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14318:	4b1c      	ldr	r3, [pc, #112]	; (1438c <SDMMC_CmdSendSCR+0x78>)
{
   1431a:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1431c:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1431e:	f241 1433 	movw	r4, #4403	; 0x1133
  SDMMCx->ARG = Command->Argument;
   14322:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14324:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14328:	68c1      	ldr	r1, [r0, #12]
   1432a:	4d19      	ldr	r5, [pc, #100]	; (14390 <SDMMC_CmdSendSCR+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1432c:	f241 3388 	movw	r3, #5000	; 0x1388
   14330:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14332:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   14334:	4917      	ldr	r1, [pc, #92]	; (14394 <SDMMC_CmdSendSCR+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14336:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1433a:	432c      	orrs	r4, r5
   1433c:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   1433e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   14342:	d312      	bcc.n	1436a <SDMMC_CmdSendSCR+0x56>
    sta_reg = SDMMCx->STA;
   14344:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   14346:	420a      	tst	r2, r1
   14348:	d0f9      	beq.n	1433e <SDMMC_CmdSendSCR+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1434a:	0494      	lsls	r4, r2, #18
   1434c:	d4f7      	bmi.n	1433e <SDMMC_CmdSendSCR+0x2a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   1434e:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14350:	075a      	lsls	r2, r3, #29
   14352:	d40e      	bmi.n	14372 <SDMMC_CmdSendSCR+0x5e>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   14354:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14356:	07db      	lsls	r3, r3, #31
   14358:	d40f      	bmi.n	1437a <SDMMC_CmdSendSCR+0x66>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   1435a:	4b0f      	ldr	r3, [pc, #60]	; (14398 <SDMMC_CmdSendSCR+0x84>)
   1435c:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   1435e:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   14360:	b2db      	uxtb	r3, r3
   14362:	2b33      	cmp	r3, #51	; 0x33
   14364:	d00d      	beq.n	14382 <SDMMC_CmdSendSCR+0x6e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   14366:	2001      	movs	r0, #1
  return errorstate;
   14368:	e001      	b.n	1436e <SDMMC_CmdSendSCR+0x5a>
      return SDMMC_ERROR_TIMEOUT;
   1436a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   1436e:	bc30      	pop	{r4, r5}
   14370:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14372:	2304      	movs	r3, #4
   14374:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   14376:	4618      	mov	r0, r3
   14378:	e7f9      	b.n	1436e <SDMMC_CmdSendSCR+0x5a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   1437a:	2301      	movs	r3, #1
   1437c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1437e:	4618      	mov	r0, r3
   14380:	e7f5      	b.n	1436e <SDMMC_CmdSendSCR+0x5a>
}
   14382:	bc30      	pop	{r4, r5}
   14384:	f7ff bb58 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   14388:	0006280c 	.word	0x0006280c
   1438c:	10624dd3 	.word	0x10624dd3
   14390:	fffee0c0 	.word	0xfffee0c0
   14394:	00200045 	.word	0x00200045
   14398:	002000c5 	.word	0x002000c5

0001439c <SDMMC_CmdSendCID>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1439c:	4a18      	ldr	r2, [pc, #96]	; (14400 <SDMMC_CmdSendCID+0x64>)
{
   1439e:	4601      	mov	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   143a0:	4b18      	ldr	r3, [pc, #96]	; (14404 <SDMMC_CmdSendCID+0x68>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   143a2:	f241 3002 	movw	r0, #4866	; 0x1302
{
   143a6:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
   143a8:	2400      	movs	r4, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   143aa:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
   143ac:	608c      	str	r4, [r1, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   143ae:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   143b2:	68cd      	ldr	r5, [r1, #12]
   143b4:	4c14      	ldr	r4, [pc, #80]	; (14408 <SDMMC_CmdSendCID+0x6c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   143b6:	f241 3388 	movw	r3, #5000	; 0x1388
   143ba:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   143bc:	402c      	ands	r4, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   143be:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   143c2:	4320      	orrs	r0, r4
   143c4:	60c8      	str	r0, [r1, #12]
    if (count-- == 0U)
   143c6:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   143ca:	d30f      	bcc.n	143ec <SDMMC_CmdSendCID+0x50>
    sta_reg = SDMMCx->STA;
   143cc:	6b4a      	ldr	r2, [r1, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   143ce:	f012 0f45 	tst.w	r2, #69	; 0x45
   143d2:	d0f8      	beq.n	143c6 <SDMMC_CmdSendCID+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   143d4:	0492      	lsls	r2, r2, #18
   143d6:	d4f6      	bmi.n	143c6 <SDMMC_CmdSendCID+0x2a>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   143d8:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   143da:	075b      	lsls	r3, r3, #29
   143dc:	d40a      	bmi.n	143f4 <SDMMC_CmdSendCID+0x58>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   143de:	6b48      	ldr	r0, [r1, #52]	; 0x34
   143e0:	f010 0001 	ands.w	r0, r0, #1
   143e4:	d109      	bne.n	143fa <SDMMC_CmdSendCID+0x5e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   143e6:	4b09      	ldr	r3, [pc, #36]	; (1440c <SDMMC_CmdSendCID+0x70>)
   143e8:	638b      	str	r3, [r1, #56]	; 0x38
   143ea:	e001      	b.n	143f0 <SDMMC_CmdSendCID+0x54>
      return SDMMC_ERROR_TIMEOUT;
   143ec:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   143f0:	bc30      	pop	{r4, r5}
   143f2:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   143f4:	2004      	movs	r0, #4
   143f6:	6388      	str	r0, [r1, #56]	; 0x38
   143f8:	e7fa      	b.n	143f0 <SDMMC_CmdSendCID+0x54>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   143fa:	2001      	movs	r0, #1
   143fc:	6388      	str	r0, [r1, #56]	; 0x38
   143fe:	e7f7      	b.n	143f0 <SDMMC_CmdSendCID+0x54>
   14400:	0006280c 	.word	0x0006280c
   14404:	10624dd3 	.word	0x10624dd3
   14408:	fffee0c0 	.word	0xfffee0c0
   1440c:	002000c5 	.word	0x002000c5

00014410 <SDMMC_CmdSendCSD>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14410:	4a18      	ldr	r2, [pc, #96]	; (14474 <SDMMC_CmdSendCSD+0x64>)
   14412:	4b19      	ldr	r3, [pc, #100]	; (14478 <SDMMC_CmdSendCSD+0x68>)
{
   14414:	b430      	push	{r4, r5}
   14416:	4604      	mov	r4, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14418:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1441a:	f241 3009 	movw	r0, #4873	; 0x1309
  SDMMCx->ARG = Command->Argument;
   1441e:	60a1      	str	r1, [r4, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14420:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14424:	68e5      	ldr	r5, [r4, #12]
   14426:	4915      	ldr	r1, [pc, #84]	; (1447c <SDMMC_CmdSendCSD+0x6c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14428:	f241 3388 	movw	r3, #5000	; 0x1388
   1442c:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1442e:	4029      	ands	r1, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14430:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14434:	4308      	orrs	r0, r1
   14436:	60e0      	str	r0, [r4, #12]
    if (count-- == 0U)
   14438:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   1443c:	d30f      	bcc.n	1445e <SDMMC_CmdSendCSD+0x4e>
    sta_reg = SDMMCx->STA;
   1443e:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   14440:	f012 0f45 	tst.w	r2, #69	; 0x45
   14444:	d0f8      	beq.n	14438 <SDMMC_CmdSendCSD+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   14446:	0492      	lsls	r2, r2, #18
   14448:	d4f6      	bmi.n	14438 <SDMMC_CmdSendCSD+0x28>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   1444a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1444c:	075b      	lsls	r3, r3, #29
   1444e:	d40a      	bmi.n	14466 <SDMMC_CmdSendCSD+0x56>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   14450:	6b60      	ldr	r0, [r4, #52]	; 0x34
   14452:	f010 0001 	ands.w	r0, r0, #1
   14456:	d109      	bne.n	1446c <SDMMC_CmdSendCSD+0x5c>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14458:	4b09      	ldr	r3, [pc, #36]	; (14480 <SDMMC_CmdSendCSD+0x70>)
   1445a:	63a3      	str	r3, [r4, #56]	; 0x38
   1445c:	e001      	b.n	14462 <SDMMC_CmdSendCSD+0x52>
      return SDMMC_ERROR_TIMEOUT;
   1445e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   14462:	bc30      	pop	{r4, r5}
   14464:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14466:	2004      	movs	r0, #4
   14468:	63a0      	str	r0, [r4, #56]	; 0x38
   1446a:	e7fa      	b.n	14462 <SDMMC_CmdSendCSD+0x52>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   1446c:	2001      	movs	r0, #1
   1446e:	63a0      	str	r0, [r4, #56]	; 0x38
   14470:	e7f7      	b.n	14462 <SDMMC_CmdSendCSD+0x52>
   14472:	bf00      	nop
   14474:	0006280c 	.word	0x0006280c
   14478:	10624dd3 	.word	0x10624dd3
   1447c:	fffee0c0 	.word	0xfffee0c0
   14480:	002000c5 	.word	0x002000c5

00014484 <SDMMC_CmdSetRelAdd>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14484:	4b25      	ldr	r3, [pc, #148]	; (1451c <SDMMC_CmdSetRelAdd+0x98>)
   14486:	4a26      	ldr	r2, [pc, #152]	; (14520 <SDMMC_CmdSetRelAdd+0x9c>)
{
   14488:	b470      	push	{r4, r5, r6}
  SDMMCx->ARG = Command->Argument;
   1448a:	2400      	movs	r4, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1448c:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1448e:	4d25      	ldr	r5, [pc, #148]	; (14524 <SDMMC_CmdSetRelAdd+0xa0>)
  SDMMCx->ARG = Command->Argument;
   14490:	6084      	str	r4, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14492:	f241 1403 	movw	r4, #4355	; 0x1103
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14496:	fba2 2303 	umull	r2, r3, r2, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1449a:	68c6      	ldr	r6, [r0, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1449c:	0a5a      	lsrs	r2, r3, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1449e:	4035      	ands	r5, r6
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   144a0:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   144a4:	432c      	orrs	r4, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   144a6:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   144aa:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   144ac:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   144b0:	d311      	bcc.n	144d6 <SDMMC_CmdSetRelAdd+0x52>
    sta_reg = SDMMCx->STA;
   144b2:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   144b4:	f012 0f45 	tst.w	r2, #69	; 0x45
   144b8:	d0f8      	beq.n	144ac <SDMMC_CmdSetRelAdd+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   144ba:	0496      	lsls	r6, r2, #18
   144bc:	d4f6      	bmi.n	144ac <SDMMC_CmdSetRelAdd+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   144be:	6b43      	ldr	r3, [r0, #52]	; 0x34
   144c0:	075d      	lsls	r5, r3, #29
   144c2:	d40c      	bmi.n	144de <SDMMC_CmdSetRelAdd+0x5a>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   144c4:	6b43      	ldr	r3, [r0, #52]	; 0x34
   144c6:	07dc      	lsls	r4, r3, #31
   144c8:	d40d      	bmi.n	144e6 <SDMMC_CmdSetRelAdd+0x62>
  return (uint8_t)(SDMMCx->RESPCMD);
   144ca:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   144cc:	b2db      	uxtb	r3, r3
   144ce:	2b03      	cmp	r3, #3
   144d0:	d00d      	beq.n	144ee <SDMMC_CmdSetRelAdd+0x6a>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   144d2:	2001      	movs	r0, #1
   144d4:	e001      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
      return SDMMC_ERROR_TIMEOUT;
   144d6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   144da:	bc70      	pop	{r4, r5, r6}
   144dc:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   144de:	2304      	movs	r3, #4
   144e0:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   144e2:	4618      	mov	r0, r3
   144e4:	e7f9      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   144e6:	2301      	movs	r3, #1
   144e8:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   144ea:	4618      	mov	r0, r3
   144ec:	e7f5      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   144ee:	4b0e      	ldr	r3, [pc, #56]	; (14528 <SDMMC_CmdSetRelAdd+0xa4>)
   144f0:	6383      	str	r3, [r0, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
   144f2:	6943      	ldr	r3, [r0, #20]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
   144f4:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
   144f8:	d009      	beq.n	1450e <SDMMC_CmdSetRelAdd+0x8a>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
   144fa:	045a      	lsls	r2, r3, #17
   144fc:	d40a      	bmi.n	14514 <SDMMC_CmdSetRelAdd+0x90>
    return SDMMC_ERROR_COM_CRC_FAILED;
   144fe:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   14502:	bf0c      	ite	eq
   14504:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
   14508:	f44f 5080 	movne.w	r0, #4096	; 0x1000
   1450c:	e7e5      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
    *pRCA = (uint16_t) (response_r1 >> 16);
   1450e:	0c1b      	lsrs	r3, r3, #16
   14510:	800b      	strh	r3, [r1, #0]
   14512:	e7e2      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
    return SDMMC_ERROR_ILLEGAL_CMD;
   14514:	f44f 5000 	mov.w	r0, #8192	; 0x2000
   14518:	e7df      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
   1451a:	bf00      	nop
   1451c:	0006280c 	.word	0x0006280c
   14520:	10624dd3 	.word	0x10624dd3
   14524:	fffee0c0 	.word	0xfffee0c0
   14528:	002000c5 	.word	0x002000c5

0001452c <SDMMC_CmdSendStatus>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1452c:	4a1c      	ldr	r2, [pc, #112]	; (145a0 <SDMMC_CmdSendStatus+0x74>)
   1452e:	4b1d      	ldr	r3, [pc, #116]	; (145a4 <SDMMC_CmdSendStatus+0x78>)
{
   14530:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14532:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14534:	f241 140d 	movw	r4, #4365	; 0x110d
  SDMMCx->ARG = Command->Argument;
   14538:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1453a:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1453e:	68c1      	ldr	r1, [r0, #12]
   14540:	4d19      	ldr	r5, [pc, #100]	; (145a8 <SDMMC_CmdSendStatus+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14542:	f241 3388 	movw	r3, #5000	; 0x1388
   14546:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14548:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1454a:	4918      	ldr	r1, [pc, #96]	; (145ac <SDMMC_CmdSendStatus+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1454c:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14550:	432c      	orrs	r4, r5
   14552:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   14554:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   14558:	d312      	bcc.n	14580 <SDMMC_CmdSendStatus+0x54>
    sta_reg = SDMMCx->STA;
   1455a:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   1455c:	420a      	tst	r2, r1
   1455e:	d0f9      	beq.n	14554 <SDMMC_CmdSendStatus+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   14560:	0494      	lsls	r4, r2, #18
   14562:	d4f7      	bmi.n	14554 <SDMMC_CmdSendStatus+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   14564:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14566:	075a      	lsls	r2, r3, #29
   14568:	d40e      	bmi.n	14588 <SDMMC_CmdSendStatus+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   1456a:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1456c:	07db      	lsls	r3, r3, #31
   1456e:	d40f      	bmi.n	14590 <SDMMC_CmdSendStatus+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14570:	4b0f      	ldr	r3, [pc, #60]	; (145b0 <SDMMC_CmdSendStatus+0x84>)
   14572:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   14574:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   14576:	b2db      	uxtb	r3, r3
   14578:	2b0d      	cmp	r3, #13
   1457a:	d00d      	beq.n	14598 <SDMMC_CmdSendStatus+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1457c:	2001      	movs	r0, #1
  return errorstate;
   1457e:	e001      	b.n	14584 <SDMMC_CmdSendStatus+0x58>
      return SDMMC_ERROR_TIMEOUT;
   14580:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   14584:	bc30      	pop	{r4, r5}
   14586:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14588:	2304      	movs	r3, #4
   1458a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   1458c:	4618      	mov	r0, r3
   1458e:	e7f9      	b.n	14584 <SDMMC_CmdSendStatus+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   14590:	2301      	movs	r3, #1
   14592:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   14594:	4618      	mov	r0, r3
   14596:	e7f5      	b.n	14584 <SDMMC_CmdSendStatus+0x58>
}
   14598:	bc30      	pop	{r4, r5}
   1459a:	f7ff ba4d 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   1459e:	bf00      	nop
   145a0:	0006280c 	.word	0x0006280c
   145a4:	10624dd3 	.word	0x10624dd3
   145a8:	fffee0c0 	.word	0xfffee0c0
   145ac:	00200045 	.word	0x00200045
   145b0:	002000c5 	.word	0x002000c5

000145b4 <SDMMC_CmdStatusRegister>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145b4:	4a1c      	ldr	r2, [pc, #112]	; (14628 <SDMMC_CmdStatusRegister+0x74>)
  SDMMCx->ARG = Command->Argument;
   145b6:	2100      	movs	r1, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145b8:	4b1c      	ldr	r3, [pc, #112]	; (1462c <SDMMC_CmdStatusRegister+0x78>)
{
   145ba:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145bc:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   145be:	f241 140d 	movw	r4, #4365	; 0x110d
  SDMMCx->ARG = Command->Argument;
   145c2:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145c4:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   145c8:	68c1      	ldr	r1, [r0, #12]
   145ca:	4d19      	ldr	r5, [pc, #100]	; (14630 <SDMMC_CmdStatusRegister+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145cc:	f241 3388 	movw	r3, #5000	; 0x1388
   145d0:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   145d2:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   145d4:	4917      	ldr	r1, [pc, #92]	; (14634 <SDMMC_CmdStatusRegister+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145d6:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   145da:	432c      	orrs	r4, r5
   145dc:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   145de:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   145e2:	d312      	bcc.n	1460a <SDMMC_CmdStatusRegister+0x56>
    sta_reg = SDMMCx->STA;
   145e4:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   145e6:	420a      	tst	r2, r1
   145e8:	d0f9      	beq.n	145de <SDMMC_CmdStatusRegister+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   145ea:	0494      	lsls	r4, r2, #18
   145ec:	d4f7      	bmi.n	145de <SDMMC_CmdStatusRegister+0x2a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   145ee:	6b43      	ldr	r3, [r0, #52]	; 0x34
   145f0:	075a      	lsls	r2, r3, #29
   145f2:	d40e      	bmi.n	14612 <SDMMC_CmdStatusRegister+0x5e>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   145f4:	6b43      	ldr	r3, [r0, #52]	; 0x34
   145f6:	07db      	lsls	r3, r3, #31
   145f8:	d40f      	bmi.n	1461a <SDMMC_CmdStatusRegister+0x66>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   145fa:	4b0f      	ldr	r3, [pc, #60]	; (14638 <SDMMC_CmdStatusRegister+0x84>)
   145fc:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   145fe:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   14600:	b2db      	uxtb	r3, r3
   14602:	2b0d      	cmp	r3, #13
   14604:	d00d      	beq.n	14622 <SDMMC_CmdStatusRegister+0x6e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   14606:	2001      	movs	r0, #1
  return errorstate;
   14608:	e001      	b.n	1460e <SDMMC_CmdStatusRegister+0x5a>
      return SDMMC_ERROR_TIMEOUT;
   1460a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   1460e:	bc30      	pop	{r4, r5}
   14610:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14612:	2304      	movs	r3, #4
   14614:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   14616:	4618      	mov	r0, r3
   14618:	e7f9      	b.n	1460e <SDMMC_CmdStatusRegister+0x5a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   1461a:	2301      	movs	r3, #1
   1461c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1461e:	4618      	mov	r0, r3
   14620:	e7f5      	b.n	1460e <SDMMC_CmdStatusRegister+0x5a>
}
   14622:	bc30      	pop	{r4, r5}
   14624:	f7ff ba08 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   14628:	0006280c 	.word	0x0006280c
   1462c:	10624dd3 	.word	0x10624dd3
   14630:	fffee0c0 	.word	0xfffee0c0
   14634:	00200045 	.word	0x00200045
   14638:	002000c5 	.word	0x002000c5

0001463c <SDMMC_CmdVoltageSwitch>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1463c:	4a1c      	ldr	r2, [pc, #112]	; (146b0 <SDMMC_CmdVoltageSwitch+0x74>)
  SDMMCx->ARG = Command->Argument;
   1463e:	2100      	movs	r1, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14640:	4b1c      	ldr	r3, [pc, #112]	; (146b4 <SDMMC_CmdVoltageSwitch+0x78>)
{
   14642:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14644:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14646:	f241 140b 	movw	r4, #4363	; 0x110b
  SDMMCx->ARG = Command->Argument;
   1464a:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1464c:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14650:	68c1      	ldr	r1, [r0, #12]
   14652:	4d19      	ldr	r5, [pc, #100]	; (146b8 <SDMMC_CmdVoltageSwitch+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14654:	f241 3388 	movw	r3, #5000	; 0x1388
   14658:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1465a:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1465c:	4917      	ldr	r1, [pc, #92]	; (146bc <SDMMC_CmdVoltageSwitch+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1465e:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14662:	432c      	orrs	r4, r5
   14664:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   14666:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   1466a:	d312      	bcc.n	14692 <SDMMC_CmdVoltageSwitch+0x56>
    sta_reg = SDMMCx->STA;
   1466c:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   1466e:	420a      	tst	r2, r1
   14670:	d0f9      	beq.n	14666 <SDMMC_CmdVoltageSwitch+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   14672:	0494      	lsls	r4, r2, #18
   14674:	d4f7      	bmi.n	14666 <SDMMC_CmdVoltageSwitch+0x2a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   14676:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14678:	075a      	lsls	r2, r3, #29
   1467a:	d40e      	bmi.n	1469a <SDMMC_CmdVoltageSwitch+0x5e>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   1467c:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1467e:	07db      	lsls	r3, r3, #31
   14680:	d40f      	bmi.n	146a2 <SDMMC_CmdVoltageSwitch+0x66>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14682:	4b0f      	ldr	r3, [pc, #60]	; (146c0 <SDMMC_CmdVoltageSwitch+0x84>)
   14684:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   14686:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   14688:	b2db      	uxtb	r3, r3
   1468a:	2b0b      	cmp	r3, #11
   1468c:	d00d      	beq.n	146aa <SDMMC_CmdVoltageSwitch+0x6e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1468e:	2001      	movs	r0, #1
  return errorstate;
   14690:	e001      	b.n	14696 <SDMMC_CmdVoltageSwitch+0x5a>
      return SDMMC_ERROR_TIMEOUT;
   14692:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   14696:	bc30      	pop	{r4, r5}
   14698:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   1469a:	2304      	movs	r3, #4
   1469c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   1469e:	4618      	mov	r0, r3
   146a0:	e7f9      	b.n	14696 <SDMMC_CmdVoltageSwitch+0x5a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   146a2:	2301      	movs	r3, #1
   146a4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   146a6:	4618      	mov	r0, r3
   146a8:	e7f5      	b.n	14696 <SDMMC_CmdVoltageSwitch+0x5a>
}
   146aa:	bc30      	pop	{r4, r5}
   146ac:	f7ff b9c4 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   146b0:	0006280c 	.word	0x0006280c
   146b4:	10624dd3 	.word	0x10624dd3
   146b8:	fffee0c0 	.word	0xfffee0c0
   146bc:	00200045 	.word	0x00200045
   146c0:	002000c5 	.word	0x002000c5

000146c4 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   146c4:	b084      	sub	sp, #16
   146c6:	b430      	push	{r4, r5}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   146c8:	9d08      	ldr	r5, [sp, #32]
{
   146ca:	ac03      	add	r4, sp, #12
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   146cc:	2d01      	cmp	r5, #1
{
   146ce:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   146d2:	d131      	bne.n	14738 <USB_CoreInit+0x74>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   146d4:	6b82      	ldr	r2, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   146d6:	4b2e      	ldr	r3, [pc, #184]	; (14790 <USB_CoreInit+0xcc>)
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   146d8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
   146dc:	990f      	ldr	r1, [sp, #60]	; 0x3c
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   146de:	6382      	str	r2, [r0, #56]	; 0x38
    if (cfg.use_external_vbus == 1U)
   146e0:	2901      	cmp	r1, #1
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   146e2:	68c2      	ldr	r2, [r0, #12]
   146e4:	ea03 0302 	and.w	r3, r3, r2
   146e8:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
   146ea:	68c3      	ldr	r3, [r0, #12]
   146ec:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
   146f0:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
   146f2:	d044      	beq.n	1477e <USB_CoreInit+0xba>
{
   146f4:	4b27      	ldr	r3, [pc, #156]	; (14794 <USB_CoreInit+0xd0>)
   146f6:	e001      	b.n	146fc <USB_CoreInit+0x38>
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
   146f8:	3b01      	subs	r3, #1
   146fa:	d045      	beq.n	14788 <USB_CoreInit+0xc4>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
   146fc:	6902      	ldr	r2, [r0, #16]
   146fe:	2a00      	cmp	r2, #0
   14700:	dafa      	bge.n	146f8 <USB_CoreInit+0x34>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
   14702:	6903      	ldr	r3, [r0, #16]
   14704:	4a23      	ldr	r2, [pc, #140]	; (14794 <USB_CoreInit+0xd0>)
   14706:	f043 0301 	orr.w	r3, r3, #1
   1470a:	6103      	str	r3, [r0, #16]
   1470c:	e001      	b.n	14712 <USB_CoreInit+0x4e>

  do
  {
    if (++count > 200000U)
   1470e:	3a01      	subs	r2, #1
   14710:	d03a      	beq.n	14788 <USB_CoreInit+0xc4>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
   14712:	6903      	ldr	r3, [r0, #16]
   14714:	f013 0301 	ands.w	r3, r3, #1
   14718:	d1f9      	bne.n	1470e <USB_CoreInit+0x4a>
  if (cfg.dma_enable == 1U)
   1471a:	9a06      	ldr	r2, [sp, #24]
   1471c:	2a01      	cmp	r2, #1
   1471e:	d107      	bne.n	14730 <USB_CoreInit+0x6c>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
   14720:	6882      	ldr	r2, [r0, #8]
   14722:	f042 0206 	orr.w	r2, r2, #6
   14726:	6082      	str	r2, [r0, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
   14728:	6882      	ldr	r2, [r0, #8]
   1472a:	f042 0220 	orr.w	r2, r2, #32
   1472e:	6082      	str	r2, [r0, #8]
}
   14730:	4618      	mov	r0, r3
   14732:	bc30      	pop	{r4, r5}
   14734:	b004      	add	sp, #16
   14736:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
   14738:	68c2      	ldr	r2, [r0, #12]
   1473a:	4b16      	ldr	r3, [pc, #88]	; (14794 <USB_CoreInit+0xd0>)
   1473c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   14740:	60c2      	str	r2, [r0, #12]
   14742:	e001      	b.n	14748 <USB_CoreInit+0x84>
    if (++count > 200000U)
   14744:	3b01      	subs	r3, #1
   14746:	d021      	beq.n	1478c <USB_CoreInit+0xc8>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
   14748:	6902      	ldr	r2, [r0, #16]
   1474a:	2a00      	cmp	r2, #0
   1474c:	dafa      	bge.n	14744 <USB_CoreInit+0x80>
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
   1474e:	6903      	ldr	r3, [r0, #16]
   14750:	4a10      	ldr	r2, [pc, #64]	; (14794 <USB_CoreInit+0xd0>)
   14752:	f043 0301 	orr.w	r3, r3, #1
   14756:	6103      	str	r3, [r0, #16]
   14758:	e001      	b.n	1475e <USB_CoreInit+0x9a>
    if (++count > 200000U)
   1475a:	3a01      	subs	r2, #1
   1475c:	d016      	beq.n	1478c <USB_CoreInit+0xc8>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
   1475e:	6903      	ldr	r3, [r0, #16]
   14760:	f013 0301 	ands.w	r3, r3, #1
   14764:	d1f9      	bne.n	1475a <USB_CoreInit+0x96>
    if (cfg.battery_charging_enable == 0U)
   14766:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14768:	b922      	cbnz	r2, 14774 <USB_CoreInit+0xb0>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
   1476a:	6b82      	ldr	r2, [r0, #56]	; 0x38
   1476c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   14770:	6382      	str	r2, [r0, #56]	; 0x38
   14772:	e7d2      	b.n	1471a <USB_CoreInit+0x56>
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   14774:	6b82      	ldr	r2, [r0, #56]	; 0x38
   14776:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
   1477a:	6382      	str	r2, [r0, #56]	; 0x38
   1477c:	e7cd      	b.n	1471a <USB_CoreInit+0x56>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
   1477e:	68c3      	ldr	r3, [r0, #12]
   14780:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   14784:	60c3      	str	r3, [r0, #12]
   14786:	e7b5      	b.n	146f4 <USB_CoreInit+0x30>
      return HAL_TIMEOUT;
   14788:	2303      	movs	r3, #3
   1478a:	e7c6      	b.n	1471a <USB_CoreInit+0x56>
   1478c:	2303      	movs	r3, #3
   1478e:	e7ea      	b.n	14766 <USB_CoreInit+0xa2>
   14790:	ffbdffbf 	.word	0xffbdffbf
   14794:	00030d40 	.word	0x00030d40

00014798 <USB_EnableGlobalInt>:
{
   14798:	4602      	mov	r2, r0
}
   1479a:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
   1479c:	6893      	ldr	r3, [r2, #8]
   1479e:	f043 0301 	orr.w	r3, r3, #1
   147a2:	6093      	str	r3, [r2, #8]
}
   147a4:	4770      	bx	lr
   147a6:	bf00      	nop

000147a8 <USB_DisableGlobalInt>:
{
   147a8:	4602      	mov	r2, r0
}
   147aa:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   147ac:	6893      	ldr	r3, [r2, #8]
   147ae:	f023 0301 	bic.w	r3, r3, #1
   147b2:	6093      	str	r3, [r2, #8]
}
   147b4:	4770      	bx	lr
   147b6:	bf00      	nop

000147b8 <USB_SetCurrentMode>:
{
   147b8:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
   147ba:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
   147bc:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
   147be:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
   147c2:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
   147c4:	d00b      	beq.n	147de <USB_SetCurrentMode+0x26>
  else if (mode == USB_DEVICE_MODE)
   147c6:	b941      	cbnz	r1, 147da <USB_SetCurrentMode+0x22>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
   147c8:	68c3      	ldr	r3, [r0, #12]
   147ca:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   147ce:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
   147d0:	2032      	movs	r0, #50	; 0x32
   147d2:	f7f3 fe15 	bl	8400 <HAL_Delay>
  return HAL_OK;
   147d6:	2000      	movs	r0, #0
}
   147d8:	bd08      	pop	{r3, pc}
    return HAL_ERROR;
   147da:	2001      	movs	r0, #1
}
   147dc:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
   147de:	68c3      	ldr	r3, [r0, #12]
   147e0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   147e4:	60c3      	str	r3, [r0, #12]
   147e6:	e7f3      	b.n	147d0 <USB_SetCurrentMode+0x18>

000147e8 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   147e8:	b084      	sub	sp, #16
   147ea:	b530      	push	{r4, r5, lr}
   147ec:	4604      	mov	r4, r0
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
   147ee:	2500      	movs	r5, #0
{
   147f0:	b083      	sub	sp, #12
  USBx_PCGCCTL = 0U;
   147f2:	f8c4 5e00 	str.w	r5, [r4, #3584]	; 0xe00

  /* Disable VBUS sensing */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
   147f6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
{
   147f8:	a807      	add	r0, sp, #28
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
   147fa:	f425 1500 	bic.w	r5, r5, #2097152	; 0x200000
   147fe:	63a5      	str	r5, [r4, #56]	; 0x38

  /* Disable Battery chargin detector */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
   14800:	6ba5      	ldr	r5, [r4, #56]	; 0x38
   14802:	f425 3500 	bic.w	r5, r5, #131072	; 0x20000
   14806:	63a5      	str	r5, [r4, #56]	; 0x38


  if ((USBx->CID & (0x1U << 8)) != 0U)
   14808:	6be5      	ldr	r5, [r4, #60]	; 0x3c
{
   1480a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if ((USBx->CID & (0x1U << 8)) != 0U)
   1480e:	05eb      	lsls	r3, r5, #23
   14810:	9908      	ldr	r1, [sp, #32]
   14812:	d565      	bpl.n	148e0 <USB_HostInit+0xf8>
  {
    if (cfg.speed == USB_OTG_SPEED_FULL)
   14814:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14816:	2b03      	cmp	r3, #3
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
   14818:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
    if (cfg.speed == USB_OTG_SPEED_FULL)
   1481c:	d063      	beq.n	148e6 <USB_HostInit+0xfe>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
   1481e:	f023 0304 	bic.w	r3, r3, #4
   14822:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   14826:	f44f 6284 	mov.w	r2, #1056	; 0x420
   1482a:	4b31      	ldr	r3, [pc, #196]	; (148f0 <USB_HostInit+0x108>)
   1482c:	6122      	str	r2, [r4, #16]
   1482e:	e001      	b.n	14834 <USB_HostInit+0x4c>
    if (++count > 200000U)
   14830:	3b01      	subs	r3, #1
   14832:	d002      	beq.n	1483a <USB_HostInit+0x52>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
   14834:	6922      	ldr	r2, [r4, #16]
   14836:	0695      	lsls	r5, r2, #26
   14838:	d4fa      	bmi.n	14830 <USB_HostInit+0x48>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
   1483a:	2210      	movs	r2, #16
   1483c:	4b2c      	ldr	r3, [pc, #176]	; (148f0 <USB_HostInit+0x108>)
   1483e:	6122      	str	r2, [r4, #16]
   14840:	e001      	b.n	14846 <USB_HostInit+0x5e>
    if (++count > 200000U)
   14842:	3b01      	subs	r3, #1
   14844:	d002      	beq.n	1484c <USB_HostInit+0x64>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
   14846:	6922      	ldr	r2, [r4, #16]
   14848:	06d0      	lsls	r0, r2, #27
   1484a:	d4fa      	bmi.n	14842 <USB_HostInit+0x5a>
  /* Make sure the FIFOs are flushed. */
  (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
  (void)USB_FlushRxFifo(USBx);

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
   1484c:	b159      	cbz	r1, 14866 <USB_HostInit+0x7e>
   1484e:	2200      	movs	r2, #0
   14850:	f504 63a0 	add.w	r3, r4, #1280	; 0x500
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
   14854:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    USBx_HC(i)->HCINTMSK = 0U;
   14858:	4610      	mov	r0, r2
  for (i = 0U; i < cfg.Host_channels; i++)
   1485a:	3201      	adds	r2, #1
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
   1485c:	609d      	str	r5, [r3, #8]
    USBx_HC(i)->HCINTMSK = 0U;
   1485e:	60d8      	str	r0, [r3, #12]
   14860:	3320      	adds	r3, #32
  for (i = 0U; i < cfg.Host_channels; i++)
   14862:	428a      	cmp	r2, r1
   14864:	d1f9      	bne.n	1485a <USB_HostInit+0x72>
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
   14866:	2300      	movs	r3, #0
   14868:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
   1486a:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
   1486e:	9301      	str	r3, [sp, #4]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   14870:	9b01      	ldr	r3, [sp, #4]
   14872:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
   14876:	9301      	str	r3, [sp, #4]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   14878:	9b01      	ldr	r3, [sp, #4]
   1487a:	04da      	lsls	r2, r3, #19
   1487c:	d404      	bmi.n	14888 <USB_HostInit+0xa0>
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
   1487e:	9b01      	ldr	r3, [sp, #4]
   14880:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   14884:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(200U);
   14888:	20c8      	movs	r0, #200	; 0xc8
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   1488a:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(200U);
   1488c:	f7f3 fdb8 	bl	8400 <HAL_Delay>
  USBx->GINTSTS = 0xFFFFFFFFU;
   14890:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  USBx->GINTMSK = 0U;
   14894:	2200      	movs	r2, #0
   14896:	61a2      	str	r2, [r4, #24]
  USBx->GINTSTS = 0xFFFFFFFFU;
   14898:	6163      	str	r3, [r4, #20]
  if ((USBx->CID & (0x1U << 8)) != 0U)
   1489a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1489c:	05db      	lsls	r3, r3, #23
   1489e:	d517      	bpl.n	148d0 <USB_HostInit+0xe8>
    USBx->GRXFSIZ  = 0x200U;
   148a0:	f44f 7100 	mov.w	r1, #512	; 0x200
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
   148a4:	4a13      	ldr	r2, [pc, #76]	; (148f4 <USB_HostInit+0x10c>)
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
   148a6:	4b14      	ldr	r3, [pc, #80]	; (148f8 <USB_HostInit+0x110>)
    USBx->GRXFSIZ  = 0x200U;
   148a8:	6261      	str	r1, [r4, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
   148aa:	62a2      	str	r2, [r4, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
   148ac:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
  if (cfg.dma_enable == 0U)
   148b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   148b2:	b91b      	cbnz	r3, 148bc <USB_HostInit+0xd4>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
   148b4:	69a3      	ldr	r3, [r4, #24]
   148b6:	f043 0310 	orr.w	r3, r3, #16
   148ba:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
   148bc:	69a2      	ldr	r2, [r4, #24]
}
   148be:	2000      	movs	r0, #0
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
   148c0:	4b0e      	ldr	r3, [pc, #56]	; (148fc <USB_HostInit+0x114>)
   148c2:	4313      	orrs	r3, r2
   148c4:	61a3      	str	r3, [r4, #24]
}
   148c6:	b003      	add	sp, #12
   148c8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   148cc:	b004      	add	sp, #16
   148ce:	4770      	bx	lr
    USBx->GRXFSIZ  = 0x80U;
   148d0:	2180      	movs	r1, #128	; 0x80
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
   148d2:	4a0b      	ldr	r2, [pc, #44]	; (14900 <USB_HostInit+0x118>)
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
   148d4:	4b0b      	ldr	r3, [pc, #44]	; (14904 <USB_HostInit+0x11c>)
    USBx->GRXFSIZ  = 0x80U;
   148d6:	6261      	str	r1, [r4, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
   148d8:	62a2      	str	r2, [r4, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
   148da:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
   148de:	e7e7      	b.n	148b0 <USB_HostInit+0xc8>
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
   148e0:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
   148e4:	e79b      	b.n	1481e <USB_HostInit+0x36>
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
   148e6:	f043 0304 	orr.w	r3, r3, #4
   148ea:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
   148ee:	e79a      	b.n	14826 <USB_HostInit+0x3e>
   148f0:	00030d40 	.word	0x00030d40
   148f4:	01000200 	.word	0x01000200
   148f8:	00e00300 	.word	0x00e00300
   148fc:	a3200008 	.word	0xa3200008
   14900:	00600080 	.word	0x00600080
   14904:	004000e0 	.word	0x004000e0

00014908 <USB_ResetPort>:
{
   14908:	b530      	push	{r4, r5, lr}
   1490a:	4604      	mov	r4, r0
   1490c:	b083      	sub	sp, #12
  __IO uint32_t hprt0 = 0U;
   1490e:	2500      	movs	r5, #0
  HAL_Delay(100U);                                 /* See Note #1 */
   14910:	2064      	movs	r0, #100	; 0x64
  __IO uint32_t hprt0 = 0U;
   14912:	9501      	str	r5, [sp, #4]
  hprt0 = USBx_HPRT0;
   14914:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
   14918:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   1491a:	9b01      	ldr	r3, [sp, #4]
   1491c:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
   14920:	9301      	str	r3, [sp, #4]
  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
   14922:	9b01      	ldr	r3, [sp, #4]
   14924:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   14928:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(100U);                                 /* See Note #1 */
   1492c:	f7f3 fd68 	bl	8400 <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
   14930:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(10U);
   14932:	200a      	movs	r0, #10
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
   14934:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   14938:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(10U);
   1493c:	f7f3 fd60 	bl	8400 <HAL_Delay>
}
   14940:	4628      	mov	r0, r5
   14942:	b003      	add	sp, #12
   14944:	bd30      	pop	{r4, r5, pc}
   14946:	bf00      	nop

00014948 <USB_DriveVbus>:
{
   14948:	b082      	sub	sp, #8
  __IO uint32_t hprt0 = 0U;
   1494a:	2300      	movs	r3, #0
   1494c:	9301      	str	r3, [sp, #4]
  hprt0 = USBx_HPRT0;
   1494e:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
   14952:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   14954:	9b01      	ldr	r3, [sp, #4]
   14956:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
   1495a:	9301      	str	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   1495c:	9b01      	ldr	r3, [sp, #4]
   1495e:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
   14962:	9b01      	ldr	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   14964:	d101      	bne.n	1496a <USB_DriveVbus+0x22>
   14966:	2901      	cmp	r1, #1
   14968:	d00a      	beq.n	14980 <USB_DriveVbus+0x38>
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   1496a:	04db      	lsls	r3, r3, #19
   1496c:	d505      	bpl.n	1497a <USB_DriveVbus+0x32>
   1496e:	b921      	cbnz	r1, 1497a <USB_DriveVbus+0x32>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
   14970:	9b01      	ldr	r3, [sp, #4]
   14972:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   14976:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
  }
  return HAL_OK;
}
   1497a:	2000      	movs	r0, #0
   1497c:	b002      	add	sp, #8
   1497e:	4770      	bx	lr
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
   14980:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   14984:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
}
   14988:	2000      	movs	r0, #0
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   1498a:	9b01      	ldr	r3, [sp, #4]
}
   1498c:	b002      	add	sp, #8
   1498e:	4770      	bx	lr

00014990 <USB_GetHostSpeed>:
  *            @arg HCD_SPEED_HIGH: High speed mode
  *            @arg HCD_SPEED_FULL: Full speed mode
  *            @arg HCD_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)
{
   14990:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
   14992:	2300      	movs	r3, #0
   14994:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
   14996:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
   1499a:	9301      	str	r3, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
   1499c:	9801      	ldr	r0, [sp, #4]
}
   1499e:	f3c0 4041 	ubfx	r0, r0, #17, #2
   149a2:	b002      	add	sp, #8
   149a4:	4770      	bx	lr
   149a6:	bf00      	nop

000149a8 <USB_GetCurrentFrame>:
*/
uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
   149a8:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   149ac:	6880      	ldr	r0, [r0, #8]
}
   149ae:	b280      	uxth	r0, r0
   149b0:	4770      	bx	lr
   149b2:	bf00      	nop

000149b4 <USB_HC_Init>:
                              uint8_t epnum,
                              uint8_t dev_address,
                              uint8_t speed,
                              uint8_t ep_type,
                              uint16_t mps)
{
   149b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   149b8:	4606      	mov	r6, r0
  HAL_StatusTypeDef ret = HAL_OK;
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t HCcharEpDir, HCcharLowSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
   149ba:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   149be:	2001      	movs	r0, #1
{
   149c0:	f89d 4020 	ldrb.w	r4, [sp, #32]
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
   149c4:	eb06 1541 	add.w	r5, r6, r1, lsl #5
   149c8:	f001 010f 	and.w	r1, r1, #15
   149cc:	f506 6980 	add.w	r9, r6, #1024	; 0x400
{
   149d0:	f89d e01c 	ldrb.w	lr, [sp, #28]
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
   149d4:	f505 68a0 	add.w	r8, r5, #1280	; 0x500
   149d8:	fa00 f101 	lsl.w	r1, r0, r1
   149dc:	f8c8 7008 	str.w	r7, [r8, #8]
   149e0:	b250      	sxtb	r0, r2
{
   149e2:	f8bd c024 	ldrh.w	ip, [sp, #36]	; 0x24

  /* Enable channel interrupts required for this transfer. */
  switch (ep_type)
   149e6:	2c03      	cmp	r4, #3
   149e8:	d85b      	bhi.n	14aa2 <USB_HC_Init+0xee>
   149ea:	e8df f004 	tbb	[pc, r4]
   149ee:	3d4a      	.short	0x3d4a
   149f0:	024a      	.short	0x024a
        }
      }
      break;

    case EP_TYPE_INTR:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   149f2:	f240 679d 	movw	r7, #1693	; 0x69d
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_NAKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
   149f6:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   149f8:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
   149fc:	db63      	blt.n	14ac6 <USB_HC_Init+0x112>
      ret = HAL_ERROR;
      break;
  }

  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   149fe:	f8d9 7018 	ldr.w	r7, [r9, #24]

  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   14a02:	2000      	movs	r0, #0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14a04:	4339      	orrs	r1, r7
  {
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
  }
  else
  {
    HCcharEpDir = 0U;
   14a06:	4607      	mov	r7, r0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14a08:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   14a0c:	69b1      	ldr	r1, [r6, #24]
   14a0e:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   14a12:	61b1      	str	r1, [r6, #24]
  else
  {
    HCcharLowSpeed = 0U;
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
   14a14:	0599      	lsls	r1, r3, #22
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
   14a16:	f3cc 030a 	ubfx	r3, ip, #0, #11
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
   14a1a:	02d2      	lsls	r2, r2, #11
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
   14a1c:	f1be 0f02 	cmp.w	lr, #2
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
   14a20:	f001 51fe 	and.w	r1, r1, #532676608	; 0x1fc00000
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
   14a24:	ea4f 4684 	mov.w	r6, r4, lsl #18
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
   14a28:	f402 42f0 	and.w	r2, r2, #30720	; 0x7800
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
   14a2c:	bf18      	it	ne
   14a2e:	f04f 0c00 	movne.w	ip, #0
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
   14a32:	ea43 0301 	orr.w	r3, r3, r1
   14a36:	f406 2140 	and.w	r1, r6, #786432	; 0xc0000
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
   14a3a:	bf08      	it	eq
   14a3c:	f44f 3c00 	moveq.w	ip, #131072	; 0x20000

  if (ep_type == EP_TYPE_INTR)
   14a40:	2c03      	cmp	r4, #3
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
   14a42:	ea43 0302 	orr.w	r3, r3, r2
   14a46:	ea43 0301 	orr.w	r3, r3, r1
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
   14a4a:	ea43 0307 	orr.w	r3, r3, r7
   14a4e:	ea43 030c 	orr.w	r3, r3, ip
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
   14a52:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
  if (ep_type == EP_TYPE_INTR)
   14a56:	d105      	bne.n	14a64 <USB_HC_Init+0xb0>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
   14a58:	f8d5 3500 	ldr.w	r3, [r5, #1280]	; 0x500
   14a5c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   14a60:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
  }

  return ret;
}
   14a64:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   14a68:	f240 2725 	movw	r7, #549	; 0x225
      if ((epnum & 0x80U) == 0x80U)
   14a6c:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   14a6e:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
   14a72:	dac4      	bge.n	149fe <USB_HC_Init+0x4a>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
   14a74:	f8d8 000c 	ldr.w	r0, [r8, #12]
   14a78:	f440 70c0 	orr.w	r0, r0, #384	; 0x180
   14a7c:	f8c8 000c 	str.w	r0, [r8, #12]
   14a80:	e027      	b.n	14ad2 <USB_HC_Init+0x11e>
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   14a82:	f240 479d 	movw	r7, #1181	; 0x49d
      if ((epnum & 0x80U) == 0x80U)
   14a86:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   14a88:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
   14a8c:	db1b      	blt.n	14ac6 <USB_HC_Init+0x112>
        if ((USBx->CID & (0x1U << 8)) != 0U)
   14a8e:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
   14a90:	05c0      	lsls	r0, r0, #23
   14a92:	d5b4      	bpl.n	149fe <USB_HC_Init+0x4a>
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   14a94:	f8d8 000c 	ldr.w	r0, [r8, #12]
   14a98:	f040 0060 	orr.w	r0, r0, #96	; 0x60
   14a9c:	f8c8 000c 	str.w	r0, [r8, #12]
   14aa0:	e7ad      	b.n	149fe <USB_HC_Init+0x4a>
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14aa2:	f8d9 7018 	ldr.w	r7, [r9, #24]
      ret = HAL_ERROR;
   14aa6:	2800      	cmp	r0, #0
   14aa8:	f04f 0001 	mov.w	r0, #1
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14aac:	ea41 0107 	orr.w	r1, r1, r7
      ret = HAL_ERROR;
   14ab0:	bfac      	ite	ge
   14ab2:	2700      	movge	r7, #0
   14ab4:	f44f 4700 	movlt.w	r7, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14ab8:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   14abc:	69b1      	ldr	r1, [r6, #24]
   14abe:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   14ac2:	61b1      	str	r1, [r6, #24]
   14ac4:	e7a6      	b.n	14a14 <USB_HC_Init+0x60>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   14ac6:	f8d8 000c 	ldr.w	r0, [r8, #12]
   14aca:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   14ace:	f8c8 000c 	str.w	r0, [r8, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14ad2:	f8d9 7018 	ldr.w	r7, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   14ad6:	2000      	movs	r0, #0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14ad8:	4339      	orrs	r1, r7
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
   14ada:	f44f 4700 	mov.w	r7, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14ade:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   14ae2:	69b1      	ldr	r1, [r6, #24]
   14ae4:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   14ae8:	61b1      	str	r1, [r6, #24]
   14aea:	e793      	b.n	14a14 <USB_HC_Init+0x60>

00014aec <USB_HC_StartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
{
   14aec:	b4f0      	push	{r4, r5, r6, r7}
   14aee:	784b      	ldrb	r3, [r1, #1]
  uint8_t  is_oddframe;
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = 256U;

  if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
   14af0:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
   14af2:	eb00 1343 	add.w	r3, r0, r3, lsl #5
   14af6:	05e4      	lsls	r4, r4, #23
   14af8:	f503 67a0 	add.w	r7, r3, #1280	; 0x500
   14afc:	d50a      	bpl.n	14b14 <USB_HC_StartXfer+0x28>
   14afe:	790c      	ldrb	r4, [r1, #4]
   14b00:	b944      	cbnz	r4, 14b14 <USB_HC_StartXfer+0x28>
  {
    if ((dma == 0U) && (hc->do_ping == 1U))
   14b02:	2a00      	cmp	r2, #0
   14b04:	d05f      	beq.n	14bc6 <USB_HC_StartXfer+0xda>
    {
      (void)USB_DoPing(USBx, hc->ch_num);
      return HAL_OK;
    }
    else if (dma == 1U)
   14b06:	2a01      	cmp	r2, #1
   14b08:	d104      	bne.n	14b14 <USB_HC_StartXfer+0x28>
    {
      USBx_HC(ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   14b0a:	68fd      	ldr	r5, [r7, #12]
   14b0c:	f025 0560 	bic.w	r5, r5, #96	; 0x60
   14b10:	60fd      	str	r5, [r7, #12]
      hc->do_ping = 0U;
   14b12:	714c      	strb	r4, [r1, #5]
      /* ... */
    }
  }

  /* Compute the expected number of packets associated to the transfer */
  if (hc->xfer_len > 0U)
   14b14:	690d      	ldr	r5, [r1, #16]
   14b16:	2d00      	cmp	r5, #0
   14b18:	d149      	bne.n	14bae <USB_HC_StartXfer+0xc2>
   14b1a:	f44f 2600 	mov.w	r6, #524288	; 0x80000
   14b1e:	f04f 0c01 	mov.w	ip, #1
  }
  else
  {
    num_packets = 1U;
  }
  if (hc->ep_is_in != 0U)
   14b22:	78cc      	ldrb	r4, [r1, #3]
   14b24:	b11c      	cbz	r4, 14b2e <USB_HC_StartXfer+0x42>
  {
    hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
   14b26:	890d      	ldrh	r5, [r1, #8]
   14b28:	fb0c f505 	mul.w	r5, ip, r5
   14b2c:	610d      	str	r5, [r1, #16]
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
   14b2e:	7a8c      	ldrb	r4, [r1, #10]
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
   14b30:	f3c5 0512 	ubfx	r5, r5, #0, #19
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
   14b34:	0764      	lsls	r4, r4, #29
   14b36:	f004 44c0 	and.w	r4, r4, #1610612736	; 0x60000000
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
   14b3a:	4334      	orrs	r4, r6
   14b3c:	432c      	orrs	r4, r5
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
   14b3e:	613c      	str	r4, [r7, #16]

  if (dma != 0U)
   14b40:	b10a      	cbz	r2, 14b46 <USB_HC_StartXfer+0x5a>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
   14b42:	68cc      	ldr	r4, [r1, #12]
   14b44:	617c      	str	r4, [r7, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
   14b46:	f500 6680 	add.w	r6, r0, #1024	; 0x400
   14b4a:	68b4      	ldr	r4, [r6, #8]
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   14b4c:	f8d3 7500 	ldr.w	r7, [r3, #1280]	; 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
   14b50:	43e4      	mvns	r4, r4

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
   14b52:	4d41      	ldr	r5, [pc, #260]	; (14c58 <USB_HC_StartXfer+0x16c>)
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   14b54:	f027 5700 	bic.w	r7, r7, #536870912	; 0x20000000
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
   14b58:	0764      	lsls	r4, r4, #29
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   14b5a:	f8c3 7500 	str.w	r7, [r3, #1280]	; 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
   14b5e:	f004 5400 	and.w	r4, r4, #536870912	; 0x20000000
   14b62:	f8d3 7500 	ldr.w	r7, [r3, #1280]	; 0x500
   14b66:	433c      	orrs	r4, r7
   14b68:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
  tmpreg = USBx_HC(ch_num)->HCCHAR;
   14b6c:	f8d3 4500 	ldr.w	r4, [r3, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
   14b70:	78cf      	ldrb	r7, [r1, #3]
  tmpreg = USBx_HC(ch_num)->HCCHAR;
   14b72:	602c      	str	r4, [r5, #0]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   14b74:	682c      	ldr	r4, [r5, #0]
   14b76:	f024 4480 	bic.w	r4, r4, #1073741824	; 0x40000000
   14b7a:	602c      	str	r4, [r5, #0]
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
   14b7c:	682c      	ldr	r4, [r5, #0]
  if (hc->ep_is_in != 0U)
   14b7e:	2f00      	cmp	r7, #0
   14b80:	d031      	beq.n	14be6 <USB_HC_StartXfer+0xfa>
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
   14b82:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
   14b86:	602c      	str	r4, [r5, #0]
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
   14b88:	682c      	ldr	r4, [r5, #0]
   14b8a:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
   14b8e:	602c      	str	r4, [r5, #0]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
   14b90:	682c      	ldr	r4, [r5, #0]
   14b92:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500

  if (dma == 0U) /* Slave mode */
   14b96:	bb1a      	cbnz	r2, 14be0 <USB_HC_StartXfer+0xf4>
  {
    if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
   14b98:	78cb      	ldrb	r3, [r1, #3]
   14b9a:	bb0b      	cbnz	r3, 14be0 <USB_HC_StartXfer+0xf4>
   14b9c:	690b      	ldr	r3, [r1, #16]
   14b9e:	b1fb      	cbz	r3, 14be0 <USB_HC_StartXfer+0xf4>
    {
      switch (hc->ep_type)
   14ba0:	79ca      	ldrb	r2, [r1, #7]
   14ba2:	2a03      	cmp	r2, #3
   14ba4:	d831      	bhi.n	14c0a <USB_HC_StartXfer+0x11e>
   14ba6:	e8df f002 	tbb	[pc, r2]
   14baa:	2944      	.short	0x2944
   14bac:	2944      	.short	0x2944
    num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
   14bae:	890e      	ldrh	r6, [r1, #8]
   14bb0:	1e6c      	subs	r4, r5, #1
   14bb2:	4434      	add	r4, r6
   14bb4:	fbb4 f4f6 	udiv	r4, r4, r6
    if (num_packets > max_hc_pkt_count)
   14bb8:	fa1f fc84 	uxth.w	ip, r4
   14bbc:	f5bc 7f80 	cmp.w	ip, #256	; 0x100
   14bc0:	d815      	bhi.n	14bee <USB_HC_StartXfer+0x102>
   14bc2:	04e6      	lsls	r6, r4, #19
   14bc4:	e7ad      	b.n	14b22 <USB_HC_StartXfer+0x36>
    if ((dma == 0U) && (hc->do_ping == 1U))
   14bc6:	794c      	ldrb	r4, [r1, #5]
   14bc8:	2c01      	cmp	r4, #1
   14bca:	d1a3      	bne.n	14b14 <USB_HC_StartXfer+0x28>
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t chnum = (uint32_t)ch_num;
  uint32_t num_packets = 1U;
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
   14bcc:	4a23      	ldr	r2, [pc, #140]	; (14c5c <USB_HC_StartXfer+0x170>)
   14bce:	613a      	str	r2, [r7, #16]
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
   14bd0:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   14bd4:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
  tmpreg |= USB_OTG_HCCHAR_CHENA;
   14bd8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  USBx_HC(chnum)->HCCHAR = tmpreg;
   14bdc:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   14be0:	2000      	movs	r0, #0
   14be2:	bcf0      	pop	{r4, r5, r6, r7}
   14be4:	4770      	bx	lr
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
   14be6:	f424 4400 	bic.w	r4, r4, #32768	; 0x8000
   14bea:	602c      	str	r4, [r5, #0]
   14bec:	e7cc      	b.n	14b88 <USB_HC_StartXfer+0x9c>
      hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
   14bee:	0235      	lsls	r5, r6, #8
   14bf0:	f44f 7c80 	mov.w	ip, #256	; 0x100
   14bf4:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
   14bf8:	610d      	str	r5, [r1, #16]
   14bfa:	e792      	b.n	14b22 <USB_HC_StartXfer+0x36>
          if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
   14bfc:	6934      	ldr	r4, [r6, #16]
          len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
   14bfe:	1cda      	adds	r2, r3, #3
          if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
   14c00:	b2a4      	uxth	r4, r4
   14c02:	f3c2 028f 	ubfx	r2, r2, #2, #16
   14c06:	4294      	cmp	r4, r2
   14c08:	d320      	bcc.n	14c4c <USB_HC_StartXfer+0x160>
    count32b = ((uint32_t)len + 3U) / 4U;
   14c0a:	b29b      	uxth	r3, r3
      (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
   14c0c:	68ca      	ldr	r2, [r1, #12]
   14c0e:	7849      	ldrb	r1, [r1, #1]
    count32b = ((uint32_t)len + 3U) / 4U;
   14c10:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
   14c12:	089b      	lsrs	r3, r3, #2
   14c14:	d0e4      	beq.n	14be0 <USB_HC_StartXfer+0xf4>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
   14c16:	eb00 3001 	add.w	r0, r0, r1, lsl #12
   14c1a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   14c1e:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
   14c22:	f852 1b04 	ldr.w	r1, [r2], #4
    for (i = 0U; i < count32b; i++)
   14c26:	4293      	cmp	r3, r2
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
   14c28:	6001      	str	r1, [r0, #0]
    for (i = 0U; i < count32b; i++)
   14c2a:	d1fa      	bne.n	14c22 <USB_HC_StartXfer+0x136>
}
   14c2c:	2000      	movs	r0, #0
   14c2e:	bcf0      	pop	{r4, r5, r6, r7}
   14c30:	4770      	bx	lr
          if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
   14c32:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
          len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
   14c34:	1cda      	adds	r2, r3, #3
          if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
   14c36:	b2a4      	uxth	r4, r4
   14c38:	f3c2 028f 	ubfx	r2, r2, #2, #16
   14c3c:	4294      	cmp	r4, r2
   14c3e:	d2e4      	bcs.n	14c0a <USB_HC_StartXfer+0x11e>
            USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
   14c40:	6983      	ldr	r3, [r0, #24]
   14c42:	f043 0320 	orr.w	r3, r3, #32
   14c46:	6183      	str	r3, [r0, #24]
   14c48:	690b      	ldr	r3, [r1, #16]
   14c4a:	e7de      	b.n	14c0a <USB_HC_StartXfer+0x11e>
            USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
   14c4c:	6983      	ldr	r3, [r0, #24]
   14c4e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   14c52:	6183      	str	r3, [r0, #24]
   14c54:	690b      	ldr	r3, [r1, #16]
   14c56:	e7d8      	b.n	14c0a <USB_HC_StartXfer+0x11e>
   14c58:	020e2d84 	.word	0x020e2d84
   14c5c:	80080000 	.word	0x80080000

00014c60 <USB_HC_Halt>:
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
   14c60:	eb00 1141 	add.w	r1, r0, r1, lsl #5
   14c64:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
   14c68:	f501 62a0 	add.w	r2, r1, #1280	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
   14c6c:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   14c70:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
   14c74:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   14c78:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
   14c7c:	d11f      	bne.n	14cbe <USB_HC_Halt+0x5e>
    if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
   14c7e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   14c80:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
   14c84:	d13c      	bne.n	14d00 <USB_HC_Halt+0xa0>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   14c86:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   14c8a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   14c8e:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   14c92:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   14c96:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   14c9a:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
   14c9e:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   14ca2:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   14ca6:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
   14caa:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
   14cae:	e001      	b.n	14cb4 <USB_HC_Halt+0x54>
        if (++count > 1000U)
   14cb0:	3b01      	subs	r3, #1
   14cb2:	d02b      	beq.n	14d0c <USB_HC_Halt+0xac>
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   14cb4:	6811      	ldr	r1, [r2, #0]
   14cb6:	2900      	cmp	r1, #0
   14cb8:	dbfa      	blt.n	14cb0 <USB_HC_Halt+0x50>
}
   14cba:	2000      	movs	r0, #0
   14cbc:	4770      	bx	lr
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
   14cbe:	f8d0 3410 	ldr.w	r3, [r0, #1040]	; 0x410
   14cc2:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
   14cc6:	d11b      	bne.n	14d00 <USB_HC_Halt+0xa0>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   14cc8:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   14ccc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   14cd0:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   14cd4:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   14cd8:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   14cdc:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
   14ce0:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   14ce4:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   14ce8:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
   14cec:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
   14cf0:	e001      	b.n	14cf6 <USB_HC_Halt+0x96>
        if (++count > 1000U)
   14cf2:	3b01      	subs	r3, #1
   14cf4:	d00a      	beq.n	14d0c <USB_HC_Halt+0xac>
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   14cf6:	6811      	ldr	r1, [r2, #0]
   14cf8:	2900      	cmp	r1, #0
   14cfa:	dbfa      	blt.n	14cf2 <USB_HC_Halt+0x92>
}
   14cfc:	2000      	movs	r0, #0
   14cfe:	4770      	bx	lr
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   14d00:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
   14d04:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   14d08:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
}
   14d0c:	2000      	movs	r0, #0
   14d0e:	4770      	bx	lr

00014d10 <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
   14d10:	b410      	push	{r4}
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   14d12:	6882      	ldr	r2, [r0, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   14d14:	f44f 6184 	mov.w	r1, #1056	; 0x420
{
   14d18:	4604      	mov	r4, r0
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   14d1a:	4b5b      	ldr	r3, [pc, #364]	; (14e88 <USB_StopHost+0x178>)
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   14d1c:	f022 0201 	bic.w	r2, r2, #1
   14d20:	6082      	str	r2, [r0, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   14d22:	6101      	str	r1, [r0, #16]
   14d24:	e001      	b.n	14d2a <USB_StopHost+0x1a>
    if (++count > 200000U)
   14d26:	3b01      	subs	r3, #1
   14d28:	d002      	beq.n	14d30 <USB_StopHost+0x20>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
   14d2a:	6922      	ldr	r2, [r4, #16]
   14d2c:	0691      	lsls	r1, r2, #26
   14d2e:	d4fa      	bmi.n	14d26 <USB_StopHost+0x16>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
   14d30:	2210      	movs	r2, #16
   14d32:	4b55      	ldr	r3, [pc, #340]	; (14e88 <USB_StopHost+0x178>)
   14d34:	6122      	str	r2, [r4, #16]
   14d36:	e001      	b.n	14d3c <USB_StopHost+0x2c>
    if (++count > 200000U)
   14d38:	3b01      	subs	r3, #1
   14d3a:	d002      	beq.n	14d42 <USB_StopHost+0x32>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
   14d3c:	6922      	ldr	r2, [r4, #16]
   14d3e:	06d2      	lsls	r2, r2, #27
   14d40:	d4fa      	bmi.n	14d38 <USB_StopHost+0x28>
  (void)USB_FlushRxFifo(USBx);

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
   14d42:	f8d4 2500 	ldr.w	r2, [r4, #1280]	; 0x500
   14d46:	f504 61a0 	add.w	r1, r4, #1280	; 0x500
   14d4a:	f504 60e0 	add.w	r0, r4, #1792	; 0x700
  uint32_t count = 0U;
   14d4e:	2300      	movs	r3, #0
   14d50:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value |=  USB_OTG_HCCHAR_CHDIS;
    value &= ~USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14d54:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14d58:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
    value = USBx_HC(i)->HCCHAR;
   14d5c:	f8d4 2520 	ldr.w	r2, [r4, #1312]	; 0x520
   14d60:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14d64:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14d68:	f8c4 2520 	str.w	r2, [r4, #1312]	; 0x520
    value = USBx_HC(i)->HCCHAR;
   14d6c:	f8d4 2540 	ldr.w	r2, [r4, #1344]	; 0x540
   14d70:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14d74:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14d78:	f8c4 2540 	str.w	r2, [r4, #1344]	; 0x540
    value = USBx_HC(i)->HCCHAR;
   14d7c:	f8d4 2560 	ldr.w	r2, [r4, #1376]	; 0x560
   14d80:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14d84:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14d88:	f8c4 2560 	str.w	r2, [r4, #1376]	; 0x560
    value = USBx_HC(i)->HCCHAR;
   14d8c:	f8d4 2580 	ldr.w	r2, [r4, #1408]	; 0x580
   14d90:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14d94:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14d98:	f8c4 2580 	str.w	r2, [r4, #1408]	; 0x580
    value = USBx_HC(i)->HCCHAR;
   14d9c:	f8d4 25a0 	ldr.w	r2, [r4, #1440]	; 0x5a0
   14da0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14da4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14da8:	f8c4 25a0 	str.w	r2, [r4, #1440]	; 0x5a0
    value = USBx_HC(i)->HCCHAR;
   14dac:	f8d4 25c0 	ldr.w	r2, [r4, #1472]	; 0x5c0
   14db0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14db4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14db8:	f8c4 25c0 	str.w	r2, [r4, #1472]	; 0x5c0
    value = USBx_HC(i)->HCCHAR;
   14dbc:	f8d4 25e0 	ldr.w	r2, [r4, #1504]	; 0x5e0
   14dc0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14dc4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14dc8:	f8c4 25e0 	str.w	r2, [r4, #1504]	; 0x5e0
    value = USBx_HC(i)->HCCHAR;
   14dcc:	f8d4 2600 	ldr.w	r2, [r4, #1536]	; 0x600
   14dd0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14dd4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14dd8:	f8c4 2600 	str.w	r2, [r4, #1536]	; 0x600
    value = USBx_HC(i)->HCCHAR;
   14ddc:	f8d4 2620 	ldr.w	r2, [r4, #1568]	; 0x620
   14de0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14de4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14de8:	f8c4 2620 	str.w	r2, [r4, #1568]	; 0x620
    value = USBx_HC(i)->HCCHAR;
   14dec:	f8d4 2640 	ldr.w	r2, [r4, #1600]	; 0x640
   14df0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14df4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14df8:	f8c4 2640 	str.w	r2, [r4, #1600]	; 0x640
    value = USBx_HC(i)->HCCHAR;
   14dfc:	f8d4 2660 	ldr.w	r2, [r4, #1632]	; 0x660
   14e00:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e04:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14e08:	f8c4 2660 	str.w	r2, [r4, #1632]	; 0x660
    value = USBx_HC(i)->HCCHAR;
   14e0c:	f8d4 2680 	ldr.w	r2, [r4, #1664]	; 0x680
   14e10:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e14:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14e18:	f8c4 2680 	str.w	r2, [r4, #1664]	; 0x680
    value = USBx_HC(i)->HCCHAR;
   14e1c:	f8d4 26a0 	ldr.w	r2, [r4, #1696]	; 0x6a0
   14e20:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e24:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14e28:	f8c4 26a0 	str.w	r2, [r4, #1696]	; 0x6a0
    value = USBx_HC(i)->HCCHAR;
   14e2c:	f8d4 26c0 	ldr.w	r2, [r4, #1728]	; 0x6c0
   14e30:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e34:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14e38:	f8c4 26c0 	str.w	r2, [r4, #1728]	; 0x6c0
    value = USBx_HC(i)->HCCHAR;
   14e3c:	f8d4 26e0 	ldr.w	r2, [r4, #1760]	; 0x6e0
   14e40:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e44:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14e48:	f8c4 26e0 	str.w	r2, [r4, #1760]	; 0x6e0
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
   14e4c:	680a      	ldr	r2, [r1, #0]
   14e4e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    value |= USB_OTG_HCCHAR_CHDIS;
    value |= USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e52:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    USBx_HC(i)->HCCHAR = value;
   14e56:	600a      	str	r2, [r1, #0]
   14e58:	e002      	b.n	14e60 <USB_StopHost+0x150>
      if (++count > 1000U)
      {
        break;
      }
    }
    while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   14e5a:	680a      	ldr	r2, [r1, #0]
   14e5c:	2a00      	cmp	r2, #0
   14e5e:	da03      	bge.n	14e68 <USB_StopHost+0x158>
      if (++count > 1000U)
   14e60:	3301      	adds	r3, #1
   14e62:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   14e66:	d9f8      	bls.n	14e5a <USB_StopHost+0x14a>
   14e68:	3120      	adds	r1, #32
  for (i = 0U; i <= 15U; i++)
   14e6a:	4281      	cmp	r1, r0
   14e6c:	d1ee      	bne.n	14e4c <USB_StopHost+0x13c>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = 0xFFFFFFFFU;
   14e6e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  USBx->GINTSTS = 0xFFFFFFFFU;

  (void)USB_EnableGlobalInt(USBx);

  return HAL_OK;
}
   14e72:	2000      	movs	r0, #0
  USBx_HOST->HAINT = 0xFFFFFFFFU;
   14e74:	f8c4 3414 	str.w	r3, [r4, #1044]	; 0x414
  USBx->GINTSTS = 0xFFFFFFFFU;
   14e78:	6163      	str	r3, [r4, #20]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
   14e7a:	68a3      	ldr	r3, [r4, #8]
   14e7c:	f043 0301 	orr.w	r3, r3, #1
   14e80:	60a3      	str	r3, [r4, #8]
}
   14e82:	f85d 4b04 	ldr.w	r4, [sp], #4
   14e86:	4770      	bx	lr
   14e88:	00030d40 	.word	0x00030d40

00014e8c <USBH_Init>:
USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost,
                              void (*pUsrFunc)(USBH_HandleTypeDef *phost,
                              uint8_t id), uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if (phost == NULL)
   14e8c:	b3a0      	cbz	r0, 14ef8 <USBH_Init+0x6c>
{
   14e8e:	b570      	push	{r4, r5, r6, lr}
   14e90:	4604      	mov	r4, r0

  /* Set DRiver ID */
  phost->id = id;

  /* Unlink class*/
  phost->pActiveClass = NULL;
   14e92:	2500      	movs	r5, #0
  phost->id = id;
   14e94:	f880 253c 	strb.w	r2, [r0, #1340]	; 0x53c
   14e98:	460e      	mov	r6, r1
   14e9a:	223c      	movs	r2, #60	; 0x3c
   14e9c:	4629      	mov	r1, r5
   14e9e:	f200 40f4 	addw	r0, r0, #1268	; 0x4f4
  phost->pActiveClass = NULL;
   14ea2:	f8c4 54ec 	str.w	r5, [r4, #1260]	; 0x4ec
  phost->ClassNumber = 0U;
   14ea6:	f8c4 54f0 	str.w	r5, [r4, #1264]	; 0x4f0
   14eaa:	f017 fd1a 	bl	2c8e2 <memset>
   14eae:	4629      	mov	r1, r5
   14eb0:	f44f 7200 	mov.w	r2, #512	; 0x200
   14eb4:	f504 708e 	add.w	r0, r4, #284	; 0x11c
   14eb8:	f017 fd13 	bl	2c8e2 <memset>
    phost->device.Data[i] = 0U;
  }

  phost->gState = HOST_IDLE;
  phost->EnumState = ENUM_IDLE;
  phost->RequestState = CMD_SEND;
   14ebc:	2301      	movs	r3, #1
  phost->Timer = 0U;

  phost->Control.state = CTRL_SETUP;
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   14ebe:	2140      	movs	r1, #64	; 0x40
  phost->Control.errorcount = 0U;

  phost->device.address = USBH_ADDRESS_DEFAULT;
   14ec0:	f44f 7280 	mov.w	r2, #256	; 0x100
  phost->gState = HOST_IDLE;
   14ec4:	7025      	strb	r5, [r4, #0]
  phost->EnumState = ENUM_IDLE;
   14ec6:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
   14ec8:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
  phost->Control.errorcount = 0U;
   14ecc:	7665      	strb	r5, [r4, #25]
  phost->device.is_connected = 0U;
   14ece:	f884 5320 	strb.w	r5, [r4, #800]	; 0x320
  phost->device.PortEnabled = 0U;
   14ed2:	f884 5323 	strb.w	r5, [r4, #803]	; 0x323
  phost->device.is_disconnected = 0U;
   14ed6:	f884 5321 	strb.w	r5, [r4, #801]	; 0x321
  phost->RequestState = CMD_SEND;
   14eda:	70a3      	strb	r3, [r4, #2]
  phost->device.is_ReEnumerated = 0U;
   14edc:	f884 5322 	strb.w	r5, [r4, #802]	; 0x322
  phost->Control.state = CTRL_SETUP;
   14ee0:	7623      	strb	r3, [r4, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   14ee2:	71a1      	strb	r1, [r4, #6]
  phost->device.address = USBH_ADDRESS_DEFAULT;
   14ee4:	f8c4 231c 	str.w	r2, [r4, #796]	; 0x31c
  if (pUsrFunc != NULL)
   14ee8:	b10e      	cbz	r6, 14eee <USBH_Init+0x62>
    phost->pUser = pUsrFunc;
   14eea:	f8c4 6544 	str.w	r6, [r4, #1348]	; 0x544
  USBH_LL_Init(phost);
   14eee:	4620      	mov	r0, r4
   14ef0:	f00e fd7a 	bl	239e8 <USBH_LL_Init>
  return USBH_OK;
   14ef4:	2000      	movs	r0, #0
}
   14ef6:	bd70      	pop	{r4, r5, r6, pc}
    return USBH_FAIL;
   14ef8:	2002      	movs	r0, #2
}
   14efa:	4770      	bx	lr

00014efc <USBH_DeInit>:
{
   14efc:	b538      	push	{r3, r4, r5, lr}
   14efe:	4604      	mov	r4, r0
   14f00:	223c      	movs	r2, #60	; 0x3c
   14f02:	2100      	movs	r1, #0
   14f04:	f200 40f4 	addw	r0, r0, #1268	; 0x4f4
   14f08:	f017 fceb 	bl	2c8e2 <memset>
   14f0c:	f44f 7200 	mov.w	r2, #512	; 0x200
   14f10:	2100      	movs	r1, #0
   14f12:	f504 708e 	add.w	r0, r4, #284	; 0x11c
   14f16:	f017 fce4 	bl	2c8e2 <memset>
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   14f1a:	2540      	movs	r5, #64	; 0x40
  phost->gState = HOST_IDLE;
   14f1c:	2300      	movs	r3, #0
  phost->RequestState = CMD_SEND;
   14f1e:	2201      	movs	r2, #1
  phost->device.address = USBH_ADDRESS_DEFAULT;
   14f20:	f44f 7080 	mov.w	r0, #256	; 0x100
  if (phost->pData != NULL)
   14f24:	f8d4 1540 	ldr.w	r1, [r4, #1344]	; 0x540
  phost->gState = HOST_IDLE;
   14f28:	7023      	strb	r3, [r4, #0]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   14f2a:	71a5      	strb	r5, [r4, #6]
  phost->Timer = 0U;
   14f2c:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
  phost->device.address = USBH_ADDRESS_DEFAULT;
   14f30:	f8c4 031c 	str.w	r0, [r4, #796]	; 0x31c
  phost->device.is_connected = 0U;
   14f34:	f884 3320 	strb.w	r3, [r4, #800]	; 0x320
  phost->EnumState = ENUM_IDLE;
   14f38:	7063      	strb	r3, [r4, #1]
  phost->device.is_disconnected = 0U;
   14f3a:	f884 3321 	strb.w	r3, [r4, #801]	; 0x321
  phost->Control.errorcount = 0U;
   14f3e:	7663      	strb	r3, [r4, #25]
  phost->device.PortEnabled = 0U;
   14f40:	f884 3323 	strb.w	r3, [r4, #803]	; 0x323
  phost->RequestState = CMD_SEND;
   14f44:	70a2      	strb	r2, [r4, #2]
  phost->device.is_ReEnumerated = 0U;
   14f46:	f884 3322 	strb.w	r3, [r4, #802]	; 0x322
  phost->Control.state = CTRL_SETUP;
   14f4a:	7622      	strb	r2, [r4, #24]
  if (phost->pData != NULL)
   14f4c:	b111      	cbz	r1, 14f54 <USBH_DeInit+0x58>
    USBH_LL_Stop(phost);
   14f4e:	4620      	mov	r0, r4
   14f50:	f00e fd84 	bl	23a5c <USBH_LL_Stop>
}
   14f54:	2000      	movs	r0, #0
   14f56:	bd38      	pop	{r3, r4, r5, pc}

00014f58 <USBH_RegisterClass>:
  */
USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
{
  USBH_StatusTypeDef status = USBH_OK;

  if (pclass != NULL)
   14f58:	b149      	cbz	r1, 14f6e <USBH_RegisterClass+0x16>
  {
    if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
   14f5a:	f8d0 34f0 	ldr.w	r3, [r0, #1264]	; 0x4f0
   14f5e:	b933      	cbnz	r3, 14f6e <USBH_RegisterClass+0x16>
    {
      /* link the class to the USB Host handle */
      phost->pClass[phost->ClassNumber++] = pclass;
   14f60:	2201      	movs	r2, #1
   14f62:	f8c0 14e8 	str.w	r1, [r0, #1256]	; 0x4e8
   14f66:	f8c0 24f0 	str.w	r2, [r0, #1264]	; 0x4f0
    USBH_ErrLog("Invalid Class handle");
    status = USBH_FAIL;
  }

  return status;
}
   14f6a:	4618      	mov	r0, r3
   14f6c:	4770      	bx	lr
    status = USBH_FAIL;
   14f6e:	2302      	movs	r3, #2
}
   14f70:	4618      	mov	r0, r3
   14f72:	4770      	bx	lr

00014f74 <USBH_SelectInterface>:
  */
USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
{
  USBH_StatusTypeDef status = USBH_OK;

  if (interface < phost->device.CfgDesc.bNumInterfaces)
   14f74:	f890 333c 	ldrb.w	r3, [r0, #828]	; 0x33c
   14f78:	428b      	cmp	r3, r1
   14f7a:	d903      	bls.n	14f84 <USBH_SelectInterface+0x10>
  {
    phost->device.current_interface = interface;
   14f7c:	f880 1324 	strb.w	r1, [r0, #804]	; 0x324
  USBH_StatusTypeDef status = USBH_OK;
   14f80:	2000      	movs	r0, #0
   14f82:	4770      	bx	lr
    USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
  }
  else
  {
    USBH_ErrLog("Cannot Select This Interface.");
    status = USBH_FAIL;
   14f84:	2002      	movs	r0, #2
  }

  return status;
}
   14f86:	4770      	bx	lr

00014f88 <USBH_FindInterface>:
  * @param  Protocol: Protocol code
  * @retval interface index in the configuration structure
  * @note : (1)interface index 0xFF means interface index not found
  */
uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
{
   14f88:	b430      	push	{r4, r5}
   14f8a:	f1a1 04ff 	sub.w	r4, r1, #255	; 0xff
  pcfg = &phost->device.CfgDesc;

  while (if_ix < USBH_MAX_NUM_INTERFACES)
  {
    pif = &pcfg->Itf_Desc[if_ix];
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   14f8e:	f890 5347 	ldrb.w	r5, [r0, #839]	; 0x347
   14f92:	fab4 f484 	clz	r4, r4
   14f96:	428d      	cmp	r5, r1
   14f98:	ea4f 1454 	mov.w	r4, r4, lsr #5
   14f9c:	d03c      	beq.n	15018 <USBH_FindInterface+0x90>
   14f9e:	2c00      	cmp	r4, #0
   14fa0:	d13a      	bne.n	15018 <USBH_FindInterface+0x90>
   14fa2:	f890 5371 	ldrb.w	r5, [r0, #881]	; 0x371
   14fa6:	428d      	cmp	r5, r1
   14fa8:	d044      	beq.n	15034 <USBH_FindInterface+0xac>
   14faa:	2c00      	cmp	r4, #0
   14fac:	d142      	bne.n	15034 <USBH_FindInterface+0xac>
   14fae:	f890 539b 	ldrb.w	r5, [r0, #923]	; 0x39b
   14fb2:	428d      	cmp	r5, r1
   14fb4:	d04c      	beq.n	15050 <USBH_FindInterface+0xc8>
   14fb6:	2c00      	cmp	r4, #0
   14fb8:	d14a      	bne.n	15050 <USBH_FindInterface+0xc8>
   14fba:	f890 53c5 	ldrb.w	r5, [r0, #965]	; 0x3c5
   14fbe:	428d      	cmp	r5, r1
   14fc0:	d054      	beq.n	1506c <USBH_FindInterface+0xe4>
   14fc2:	2c00      	cmp	r4, #0
   14fc4:	d152      	bne.n	1506c <USBH_FindInterface+0xe4>
   14fc6:	f890 53ef 	ldrb.w	r5, [r0, #1007]	; 0x3ef
   14fca:	428d      	cmp	r5, r1
   14fcc:	d05c      	beq.n	15088 <USBH_FindInterface+0x100>
   14fce:	2c00      	cmp	r4, #0
   14fd0:	d15a      	bne.n	15088 <USBH_FindInterface+0x100>
   14fd2:	f890 5419 	ldrb.w	r5, [r0, #1049]	; 0x419
   14fd6:	428d      	cmp	r5, r1
   14fd8:	d064      	beq.n	150a4 <USBH_FindInterface+0x11c>
   14fda:	2c00      	cmp	r4, #0
   14fdc:	d162      	bne.n	150a4 <USBH_FindInterface+0x11c>
   14fde:	f890 5443 	ldrb.w	r5, [r0, #1091]	; 0x443
   14fe2:	428d      	cmp	r5, r1
   14fe4:	d06c      	beq.n	150c0 <USBH_FindInterface+0x138>
   14fe6:	2c00      	cmp	r4, #0
   14fe8:	d16a      	bne.n	150c0 <USBH_FindInterface+0x138>
   14fea:	f890 546d 	ldrb.w	r5, [r0, #1133]	; 0x46d
   14fee:	428d      	cmp	r5, r1
   14ff0:	d074      	beq.n	150dc <USBH_FindInterface+0x154>
   14ff2:	2c00      	cmp	r4, #0
   14ff4:	d172      	bne.n	150dc <USBH_FindInterface+0x154>
   14ff6:	f890 5497 	ldrb.w	r5, [r0, #1175]	; 0x497
   14ffa:	428d      	cmp	r5, r1
   14ffc:	d07c      	beq.n	150f8 <USBH_FindInterface+0x170>
   14ffe:	2c00      	cmp	r4, #0
   15000:	d17a      	bne.n	150f8 <USBH_FindInterface+0x170>
   15002:	f890 54c1 	ldrb.w	r5, [r0, #1217]	; 0x4c1
   15006:	428d      	cmp	r5, r1
   15008:	f000 8086 	beq.w	15118 <USBH_FindInterface+0x190>
   1500c:	2c00      	cmp	r4, #0
   1500e:	f040 8083 	bne.w	15118 <USBH_FindInterface+0x190>
    {
      return  if_ix;
    }
    if_ix++;
  }
  return 0xFFU;
   15012:	20ff      	movs	r0, #255	; 0xff
}
   15014:	bc30      	pop	{r4, r5}
   15016:	4770      	bx	lr
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   15018:	f890 5348 	ldrb.w	r5, [r0, #840]	; 0x348
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   1501c:	4295      	cmp	r5, r2
   1501e:	d001      	beq.n	15024 <USBH_FindInterface+0x9c>
   15020:	2aff      	cmp	r2, #255	; 0xff
   15022:	d1be      	bne.n	14fa2 <USBH_FindInterface+0x1a>
   15024:	f890 5349 	ldrb.w	r5, [r0, #841]	; 0x349
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   15028:	429d      	cmp	r5, r3
   1502a:	d001      	beq.n	15030 <USBH_FindInterface+0xa8>
   1502c:	2bff      	cmp	r3, #255	; 0xff
   1502e:	d1b8      	bne.n	14fa2 <USBH_FindInterface+0x1a>
  uint8_t if_ix = 0U;
   15030:	2000      	movs	r0, #0
   15032:	e7ef      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   15034:	f890 5372 	ldrb.w	r5, [r0, #882]	; 0x372
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   15038:	4295      	cmp	r5, r2
   1503a:	d001      	beq.n	15040 <USBH_FindInterface+0xb8>
   1503c:	2aff      	cmp	r2, #255	; 0xff
   1503e:	d1b6      	bne.n	14fae <USBH_FindInterface+0x26>
   15040:	f890 5373 	ldrb.w	r5, [r0, #883]	; 0x373
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   15044:	429d      	cmp	r5, r3
   15046:	d001      	beq.n	1504c <USBH_FindInterface+0xc4>
   15048:	2bff      	cmp	r3, #255	; 0xff
   1504a:	d1b0      	bne.n	14fae <USBH_FindInterface+0x26>
    if_ix++;
   1504c:	2001      	movs	r0, #1
   1504e:	e7e1      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   15050:	f890 539c 	ldrb.w	r5, [r0, #924]	; 0x39c
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   15054:	4295      	cmp	r5, r2
   15056:	d001      	beq.n	1505c <USBH_FindInterface+0xd4>
   15058:	2aff      	cmp	r2, #255	; 0xff
   1505a:	d1ae      	bne.n	14fba <USBH_FindInterface+0x32>
   1505c:	f890 539d 	ldrb.w	r5, [r0, #925]	; 0x39d
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   15060:	429d      	cmp	r5, r3
   15062:	d001      	beq.n	15068 <USBH_FindInterface+0xe0>
   15064:	2bff      	cmp	r3, #255	; 0xff
   15066:	d1a8      	bne.n	14fba <USBH_FindInterface+0x32>
    if_ix++;
   15068:	2002      	movs	r0, #2
   1506a:	e7d3      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   1506c:	f890 53c6 	ldrb.w	r5, [r0, #966]	; 0x3c6
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   15070:	4295      	cmp	r5, r2
   15072:	d001      	beq.n	15078 <USBH_FindInterface+0xf0>
   15074:	2aff      	cmp	r2, #255	; 0xff
   15076:	d1a6      	bne.n	14fc6 <USBH_FindInterface+0x3e>
   15078:	f890 53c7 	ldrb.w	r5, [r0, #967]	; 0x3c7
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   1507c:	429d      	cmp	r5, r3
   1507e:	d001      	beq.n	15084 <USBH_FindInterface+0xfc>
   15080:	2bff      	cmp	r3, #255	; 0xff
   15082:	d1a0      	bne.n	14fc6 <USBH_FindInterface+0x3e>
    if_ix++;
   15084:	2003      	movs	r0, #3
   15086:	e7c5      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   15088:	f890 53f0 	ldrb.w	r5, [r0, #1008]	; 0x3f0
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   1508c:	4295      	cmp	r5, r2
   1508e:	d001      	beq.n	15094 <USBH_FindInterface+0x10c>
   15090:	2aff      	cmp	r2, #255	; 0xff
   15092:	d19e      	bne.n	14fd2 <USBH_FindInterface+0x4a>
   15094:	f890 53f1 	ldrb.w	r5, [r0, #1009]	; 0x3f1
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   15098:	429d      	cmp	r5, r3
   1509a:	d001      	beq.n	150a0 <USBH_FindInterface+0x118>
   1509c:	2bff      	cmp	r3, #255	; 0xff
   1509e:	d198      	bne.n	14fd2 <USBH_FindInterface+0x4a>
    if_ix++;
   150a0:	2004      	movs	r0, #4
   150a2:	e7b7      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   150a4:	f890 541a 	ldrb.w	r5, [r0, #1050]	; 0x41a
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   150a8:	4295      	cmp	r5, r2
   150aa:	d001      	beq.n	150b0 <USBH_FindInterface+0x128>
   150ac:	2aff      	cmp	r2, #255	; 0xff
   150ae:	d196      	bne.n	14fde <USBH_FindInterface+0x56>
   150b0:	f890 541b 	ldrb.w	r5, [r0, #1051]	; 0x41b
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   150b4:	429d      	cmp	r5, r3
   150b6:	d001      	beq.n	150bc <USBH_FindInterface+0x134>
   150b8:	2bff      	cmp	r3, #255	; 0xff
   150ba:	d190      	bne.n	14fde <USBH_FindInterface+0x56>
    if_ix++;
   150bc:	2005      	movs	r0, #5
   150be:	e7a9      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   150c0:	f890 5444 	ldrb.w	r5, [r0, #1092]	; 0x444
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   150c4:	4295      	cmp	r5, r2
   150c6:	d001      	beq.n	150cc <USBH_FindInterface+0x144>
   150c8:	2aff      	cmp	r2, #255	; 0xff
   150ca:	d18e      	bne.n	14fea <USBH_FindInterface+0x62>
   150cc:	f890 5445 	ldrb.w	r5, [r0, #1093]	; 0x445
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   150d0:	429d      	cmp	r5, r3
   150d2:	d001      	beq.n	150d8 <USBH_FindInterface+0x150>
   150d4:	2bff      	cmp	r3, #255	; 0xff
   150d6:	d188      	bne.n	14fea <USBH_FindInterface+0x62>
    if_ix++;
   150d8:	2006      	movs	r0, #6
   150da:	e79b      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   150dc:	f890 546e 	ldrb.w	r5, [r0, #1134]	; 0x46e
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   150e0:	4295      	cmp	r5, r2
   150e2:	d001      	beq.n	150e8 <USBH_FindInterface+0x160>
   150e4:	2aff      	cmp	r2, #255	; 0xff
   150e6:	d186      	bne.n	14ff6 <USBH_FindInterface+0x6e>
   150e8:	f890 546f 	ldrb.w	r5, [r0, #1135]	; 0x46f
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   150ec:	429d      	cmp	r5, r3
   150ee:	d001      	beq.n	150f4 <USBH_FindInterface+0x16c>
   150f0:	2bff      	cmp	r3, #255	; 0xff
   150f2:	d180      	bne.n	14ff6 <USBH_FindInterface+0x6e>
    if_ix++;
   150f4:	2007      	movs	r0, #7
   150f6:	e78d      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   150f8:	f890 5498 	ldrb.w	r5, [r0, #1176]	; 0x498
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   150fc:	4295      	cmp	r5, r2
   150fe:	d002      	beq.n	15106 <USBH_FindInterface+0x17e>
   15100:	2aff      	cmp	r2, #255	; 0xff
   15102:	f47f af7e 	bne.w	15002 <USBH_FindInterface+0x7a>
   15106:	f890 5499 	ldrb.w	r5, [r0, #1177]	; 0x499
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   1510a:	429d      	cmp	r5, r3
   1510c:	d002      	beq.n	15114 <USBH_FindInterface+0x18c>
   1510e:	2bff      	cmp	r3, #255	; 0xff
   15110:	f47f af77 	bne.w	15002 <USBH_FindInterface+0x7a>
    if_ix++;
   15114:	2008      	movs	r0, #8
   15116:	e77d      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   15118:	f890 14c2 	ldrb.w	r1, [r0, #1218]	; 0x4c2
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   1511c:	4291      	cmp	r1, r2
   1511e:	d002      	beq.n	15126 <USBH_FindInterface+0x19e>
   15120:	2aff      	cmp	r2, #255	; 0xff
   15122:	f47f af76 	bne.w	15012 <USBH_FindInterface+0x8a>
   15126:	f890 24c3 	ldrb.w	r2, [r0, #1219]	; 0x4c3
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   1512a:	429a      	cmp	r2, r3
   1512c:	d002      	beq.n	15134 <USBH_FindInterface+0x1ac>
   1512e:	2bff      	cmp	r3, #255	; 0xff
   15130:	f47f af6f 	bne.w	15012 <USBH_FindInterface+0x8a>
    if_ix++;
   15134:	2009      	movs	r0, #9
   15136:	e76d      	b.n	15014 <USBH_FindInterface+0x8c>

00015138 <USBH_Start>:
  *         Start the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Start(USBH_HandleTypeDef *phost)
{
   15138:	b510      	push	{r4, lr}
   1513a:	4604      	mov	r4, r0
  /* Start the low level driver  */
  USBH_LL_Start(phost);
   1513c:	f00e fc80 	bl	23a40 <USBH_LL_Start>

  /* Activate VBUS on the port */
  USBH_LL_DriverVBUS(phost, OTRUE);
   15140:	2101      	movs	r1, #1
   15142:	4620      	mov	r0, r4
   15144:	f00e fd00 	bl	23b48 <USBH_LL_DriverVBUS>

  return USBH_OK;
}
   15148:	2000      	movs	r0, #0
   1514a:	bd10      	pop	{r4, pc}

0001514c <USBH_Stop>:
  *         Stop the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Stop(USBH_HandleTypeDef *phost)
{
   1514c:	b510      	push	{r4, lr}
   1514e:	4604      	mov	r4, r0
  /* DeActivate VBUS on the port */
  USBH_LL_DriverVBUS(phost, 0);
   15150:	2100      	movs	r1, #0
   15152:	f00e fcf9 	bl	23b48 <USBH_LL_DriverVBUS>

  /* Stop and cleanup the low level driver  */
  USBH_LL_Stop(phost);
   15156:	4620      	mov	r0, r4
   15158:	f00e fc80 	bl	23a5c <USBH_LL_Stop>

  /* Free Control Pipes */
  USBH_FreePipe(phost, phost->Control.pipe_in);
   1515c:	7921      	ldrb	r1, [r4, #4]
   1515e:	4620      	mov	r0, r4
   15160:	f001 fa24 	bl	165ac <USBH_FreePipe>
  USBH_FreePipe(phost, phost->Control.pipe_out);
   15164:	7961      	ldrb	r1, [r4, #5]
   15166:	4620      	mov	r0, r4
   15168:	f001 fa20 	bl	165ac <USBH_FreePipe>

  return USBH_OK;
}
   1516c:	2000      	movs	r0, #0
   1516e:	bd10      	pop	{r4, pc}

00015170 <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
{
   15170:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO USBH_StatusTypeDef status = USBH_FAIL;
   15172:	2302      	movs	r3, #2
{
   15174:	b087      	sub	sp, #28
   15176:	4604      	mov	r4, r0
  __IO USBH_StatusTypeDef status = USBH_FAIL;
   15178:	f88d 3017 	strb.w	r3, [sp, #23]
  uint8_t idx = 0U;

  /* check for Host pending port disconnect event */
  if (phost->device.is_disconnected == 1U)
   1517c:	f890 3321 	ldrb.w	r3, [r0, #801]	; 0x321
   15180:	2b01      	cmp	r3, #1
   15182:	d101      	bne.n	15188 <USBH_Process+0x18>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
   15184:	2303      	movs	r3, #3
   15186:	7003      	strb	r3, [r0, #0]
  }

  switch (phost->gState)
   15188:	7823      	ldrb	r3, [r4, #0]
   1518a:	2b0b      	cmp	r3, #11
   1518c:	d84f      	bhi.n	1522e <USBH_Process+0xbe>
   1518e:	e8df f013 	tbh	[pc, r3, lsl #1]
   15192:	0059      	.short	0x0059
   15194:	0082006b 	.word	0x0082006b
   15198:	004e00b8 	.word	0x004e00b8
   1519c:	00f700ee 	.word	0x00f700ee
   151a0:	011f010c 	.word	0x011f010c
   151a4:	000c0117 	.word	0x000c0117
   151a8:	0051      	.short	0x0051
#endif
      break;

    case HOST_CHECK_CLASS:

      if (phost->ClassNumber == 0U)
   151aa:	f8d4 34f0 	ldr.w	r3, [r4, #1264]	; 0x4f0
   151ae:	2b00      	cmp	r3, #0
   151b0:	d03d      	beq.n	1522e <USBH_Process+0xbe>
      {
        USBH_UsrLog("No Class has been registered.");
      }
      else
      {
        phost->pActiveClass = NULL;
   151b2:	2300      	movs	r3, #0

        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
        {
          for (int j = 0; j < 10; j++)
          {
			  if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[j].bInterfaceClass)
   151b4:	f8d4 14e8 	ldr.w	r1, [r4, #1256]	; 0x4e8
   151b8:	f894 2347 	ldrb.w	r2, [r4, #839]	; 0x347
        phost->pActiveClass = NULL;
   151bc:	f8c4 34ec 	str.w	r3, [r4, #1260]	; 0x4ec
			  if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[j].bInterfaceClass)
   151c0:	790b      	ldrb	r3, [r1, #4]
   151c2:	429a      	cmp	r2, r3
   151c4:	d024      	beq.n	15210 <USBH_Process+0xa0>
   151c6:	f894 2371 	ldrb.w	r2, [r4, #881]	; 0x371
   151ca:	429a      	cmp	r2, r3
   151cc:	d020      	beq.n	15210 <USBH_Process+0xa0>
   151ce:	f894 239b 	ldrb.w	r2, [r4, #923]	; 0x39b
   151d2:	429a      	cmp	r2, r3
   151d4:	d01c      	beq.n	15210 <USBH_Process+0xa0>
   151d6:	f894 23c5 	ldrb.w	r2, [r4, #965]	; 0x3c5
   151da:	429a      	cmp	r2, r3
   151dc:	d018      	beq.n	15210 <USBH_Process+0xa0>
   151de:	f894 23ef 	ldrb.w	r2, [r4, #1007]	; 0x3ef
   151e2:	429a      	cmp	r2, r3
   151e4:	d014      	beq.n	15210 <USBH_Process+0xa0>
   151e6:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
   151ea:	429a      	cmp	r2, r3
   151ec:	d010      	beq.n	15210 <USBH_Process+0xa0>
   151ee:	f894 2443 	ldrb.w	r2, [r4, #1091]	; 0x443
   151f2:	429a      	cmp	r2, r3
   151f4:	d00c      	beq.n	15210 <USBH_Process+0xa0>
   151f6:	f894 246d 	ldrb.w	r2, [r4, #1133]	; 0x46d
   151fa:	429a      	cmp	r2, r3
   151fc:	d008      	beq.n	15210 <USBH_Process+0xa0>
   151fe:	f894 2497 	ldrb.w	r2, [r4, #1175]	; 0x497
   15202:	429a      	cmp	r2, r3
   15204:	d004      	beq.n	15210 <USBH_Process+0xa0>
   15206:	f894 24c1 	ldrb.w	r2, [r4, #1217]	; 0x4c1
   1520a:	429a      	cmp	r2, r3
   1520c:	f040 80c8 	bne.w	153a0 <USBH_Process+0x230>
			  {
				phost->pActiveClass = phost->pClass[idx];
   15210:	f8c4 14ec 	str.w	r1, [r4, #1260]	; 0x4ec
          }
        }

        if (phost->pActiveClass != NULL)
        {
          if (phost->pActiveClass->Init(phost) == USBH_OK)
   15214:	4620      	mov	r0, r4
   15216:	688b      	ldr	r3, [r1, #8]
   15218:	4798      	blx	r3
   1521a:	2800      	cmp	r0, #0
   1521c:	f040 80c0 	bne.w	153a0 <USBH_Process+0x230>
          {
            phost->gState = HOST_CLASS_REQUEST;
   15220:	2206      	movs	r2, #6
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);

            /* Inform user that a class has been activated */
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
   15222:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   15226:	4620      	mov	r0, r4
   15228:	2103      	movs	r1, #3
            phost->gState = HOST_CLASS_REQUEST;
   1522a:	7022      	strb	r2, [r4, #0]
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
   1522c:	4798      	blx	r3
    case HOST_ABORT_STATE:
    default :
      break;
  }
  return USBH_OK;
}
   1522e:	2000      	movs	r0, #0
   15230:	b007      	add	sp, #28
   15232:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (phost->pActiveClass != NULL)
   15234:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
   15238:	2b00      	cmp	r3, #0
   1523a:	d0f8      	beq.n	1522e <USBH_Process+0xbe>
        phost->pActiveClass->BgndProcess(phost);
   1523c:	695b      	ldr	r3, [r3, #20]
   1523e:	4620      	mov	r0, r4
   15240:	4798      	blx	r3
   15242:	e7f4      	b.n	1522e <USBH_Process+0xbe>
      if (phost->device.is_connected)
   15244:	f894 3320 	ldrb.w	r3, [r4, #800]	; 0x320
   15248:	2b00      	cmp	r3, #0
   1524a:	d0f0      	beq.n	1522e <USBH_Process+0xbe>
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
   1524c:	2301      	movs	r3, #1
        USBH_Delay(200U);
   1524e:	20c8      	movs	r0, #200	; 0xc8
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
   15250:	7023      	strb	r3, [r4, #0]
        USBH_Delay(200U);
   15252:	f00e fc9d 	bl	23b90 <USBH_Delay>
        USBH_LL_ResetPort(phost);
   15256:	4620      	mov	r0, r4
   15258:	f00e fc1c 	bl	23a94 <USBH_LL_ResetPort>
        phost->device.address = USBH_ADDRESS_DEFAULT;
   1525c:	2300      	movs	r3, #0
   1525e:	f884 331c 	strb.w	r3, [r4, #796]	; 0x31c
        phost->Timeout = 0U;
   15262:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
   15266:	e7e2      	b.n	1522e <USBH_Process+0xbe>
      if (phost->device.PortEnabled == 1U)
   15268:	f894 3323 	ldrb.w	r3, [r4, #803]	; 0x323
   1526c:	2b01      	cmp	r3, #1
   1526e:	f000 8145 	beq.w	154fc <USBH_Process+0x38c>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
   15272:	f8d4 3538 	ldr.w	r3, [r4, #1336]	; 0x538
   15276:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   1527a:	f240 80b7 	bls.w	153ec <USBH_Process+0x27c>
          phost->device.RstCnt++;
   1527e:	f894 331f 	ldrb.w	r3, [r4, #799]	; 0x31f
   15282:	3301      	adds	r3, #1
   15284:	b2db      	uxtb	r3, r3
          if (phost->device.RstCnt > 3U)
   15286:	2b03      	cmp	r3, #3
          phost->device.RstCnt++;
   15288:	f884 331f 	strb.w	r3, [r4, #799]	; 0x31f
          if (phost->device.RstCnt > 3U)
   1528c:	f200 8088 	bhi.w	153a0 <USBH_Process+0x230>
            phost->gState = HOST_IDLE;
   15290:	2300      	movs	r3, #0
   15292:	7023      	strb	r3, [r4, #0]
   15294:	e7cb      	b.n	1522e <USBH_Process+0xbe>
      if (phost->pUser != NULL)
   15296:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   1529a:	b113      	cbz	r3, 152a2 <USBH_Process+0x132>
        phost->pUser(phost, HOST_USER_CONNECTION);
   1529c:	2104      	movs	r1, #4
   1529e:	4620      	mov	r0, r4
   152a0:	4798      	blx	r3
      USBH_Delay(100U);
   152a2:	2064      	movs	r0, #100	; 0x64
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
   152a4:	2500      	movs	r5, #0
      USBH_Delay(100U);
   152a6:	f00e fc73 	bl	23b90 <USBH_Delay>
      phost->device.speed = USBH_LL_GetSpeed(phost);
   152aa:	4620      	mov	r0, r4
   152ac:	f00e fbe4 	bl	23a78 <USBH_LL_GetSpeed>
      phost->gState = HOST_ENUMERATION;
   152b0:	2305      	movs	r3, #5
      phost->device.speed = USBH_LL_GetSpeed(phost);
   152b2:	f884 031d 	strb.w	r0, [r4, #797]	; 0x31d
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
   152b6:	4629      	mov	r1, r5
      phost->gState = HOST_ENUMERATION;
   152b8:	7023      	strb	r3, [r4, #0]
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
   152ba:	4620      	mov	r0, r4
   152bc:	f001 f92c 	bl	16518 <USBH_AllocPipe>
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
   152c0:	2180      	movs	r1, #128	; 0x80
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
   152c2:	7160      	strb	r0, [r4, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
   152c4:	4620      	mov	r0, r4
   152c6:	f001 f927 	bl	16518 <USBH_AllocPipe>
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
   152ca:	79a7      	ldrb	r7, [r4, #6]
   152cc:	f894 631d 	ldrb.w	r6, [r4, #797]	; 0x31d
   152d0:	4601      	mov	r1, r0
   152d2:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   152d6:	2280      	movs	r2, #128	; 0x80
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
   152d8:	7120      	strb	r0, [r4, #4]
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
   152da:	4620      	mov	r0, r4
   152dc:	9702      	str	r7, [sp, #8]
   152de:	e9cd 6500 	strd	r6, r5, [sp]
   152e2:	f001 f903 	bl	164ec <USBH_OpenPipe>
      USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
   152e6:	79a7      	ldrb	r7, [r4, #6]
   152e8:	f894 631d 	ldrb.w	r6, [r4, #797]	; 0x31d
   152ec:	462a      	mov	r2, r5
   152ee:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   152f2:	4620      	mov	r0, r4
   152f4:	7961      	ldrb	r1, [r4, #5]
   152f6:	9501      	str	r5, [sp, #4]
   152f8:	9702      	str	r7, [sp, #8]
   152fa:	9600      	str	r6, [sp, #0]
   152fc:	f001 f8f6 	bl	164ec <USBH_OpenPipe>
      break;
   15300:	e795      	b.n	1522e <USBH_Process+0xbe>
      phost->device.is_disconnected = 0U;
   15302:	2500      	movs	r5, #0
   15304:	223c      	movs	r2, #60	; 0x3c
   15306:	f204 40f4 	addw	r0, r4, #1268	; 0x4f4
   1530a:	4629      	mov	r1, r5
   1530c:	f884 5321 	strb.w	r5, [r4, #801]	; 0x321
   15310:	f017 fae7 	bl	2c8e2 <memset>
   15314:	4629      	mov	r1, r5
   15316:	f44f 7200 	mov.w	r2, #512	; 0x200
   1531a:	f504 708e 	add.w	r0, r4, #284	; 0x11c
   1531e:	f017 fae0 	bl	2c8e2 <memset>
  phost->RequestState = CMD_SEND;
   15322:	2301      	movs	r3, #1
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   15324:	2040      	movs	r0, #64	; 0x40
  phost->device.address = USBH_ADDRESS_DEFAULT;
   15326:	f44f 7180 	mov.w	r1, #256	; 0x100
      if (phost->pActiveClass != NULL)
   1532a:	f8d4 24ec 	ldr.w	r2, [r4, #1260]	; 0x4ec
  phost->gState = HOST_IDLE;
   1532e:	7025      	strb	r5, [r4, #0]
  phost->EnumState = ENUM_IDLE;
   15330:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
   15332:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
  phost->Control.errorcount = 0U;
   15336:	7665      	strb	r5, [r4, #25]
  phost->RequestState = CMD_SEND;
   15338:	70a3      	strb	r3, [r4, #2]
  phost->Control.state = CTRL_SETUP;
   1533a:	7623      	strb	r3, [r4, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   1533c:	71a0      	strb	r0, [r4, #6]
  phost->device.address = USBH_ADDRESS_DEFAULT;
   1533e:	f8c4 131c 	str.w	r1, [r4, #796]	; 0x31c
      if (phost->pActiveClass != NULL)
   15342:	b122      	cbz	r2, 1534e <USBH_Process+0x1de>
        phost->pActiveClass->DeInit(phost);
   15344:	68d3      	ldr	r3, [r2, #12]
   15346:	4620      	mov	r0, r4
   15348:	4798      	blx	r3
        phost->pActiveClass = NULL;
   1534a:	f8c4 54ec 	str.w	r5, [r4, #1260]	; 0x4ec
      if (phost->pUser != NULL)
   1534e:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   15352:	b113      	cbz	r3, 1535a <USBH_Process+0x1ea>
        phost->pUser(phost, HOST_USER_DISCONNECTION);
   15354:	2105      	movs	r1, #5
   15356:	4620      	mov	r0, r4
   15358:	4798      	blx	r3
      if (phost->device.is_ReEnumerated == 1U)
   1535a:	f894 5322 	ldrb.w	r5, [r4, #802]	; 0x322
   1535e:	b2ed      	uxtb	r5, r5
   15360:	2d01      	cmp	r5, #1
   15362:	f000 80c0 	beq.w	154e6 <USBH_Process+0x376>
        USBH_LL_Start(phost);
   15366:	4620      	mov	r0, r4
   15368:	f00e fb6a 	bl	23a40 <USBH_LL_Start>
  return USBH_OK;
   1536c:	e75f      	b.n	1522e <USBH_Process+0xbe>
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
  USBH_StatusTypeDef Status = USBH_BUSY;
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;

  switch (phost->EnumState)
   1536e:	7863      	ldrb	r3, [r4, #1]
   15370:	2b07      	cmp	r3, #7
   15372:	d84d      	bhi.n	15410 <USBH_Process+0x2a0>
   15374:	e8df f003 	tbb	[pc, r3]
   15378:	a58b9b41 	.word	0xa58b9b41
   1537c:	5f656d75 	.word	0x5f656d75
      if (phost->pActiveClass != NULL)
   15380:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
   15384:	b163      	cbz	r3, 153a0 <USBH_Process+0x230>
        status = phost->pActiveClass->Requests(phost);
   15386:	691b      	ldr	r3, [r3, #16]
   15388:	4620      	mov	r0, r4
   1538a:	4798      	blx	r3
   1538c:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
   15390:	f89d 3017 	ldrb.w	r3, [sp, #23]
   15394:	b33b      	cbz	r3, 153e6 <USBH_Process+0x276>
        else if (status == USBH_FAIL)
   15396:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1539a:	2b02      	cmp	r3, #2
   1539c:	f47f af47 	bne.w	1522e <USBH_Process+0xbe>
        phost->gState = HOST_ABORT_STATE;
   153a0:	230d      	movs	r3, #13
}
   153a2:	2000      	movs	r0, #0
        phost->gState = HOST_ABORT_STATE;
   153a4:	7023      	strb	r3, [r4, #0]
}
   153a6:	b007      	add	sp, #28
   153a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (phost->pUser != NULL)
   153aa:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   153ae:	2b00      	cmp	r3, #0
   153b0:	f43f af3d 	beq.w	1522e <USBH_Process+0xbe>
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
   153b4:	2101      	movs	r1, #1
   153b6:	4620      	mov	r0, r4
   153b8:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
   153ba:	2308      	movs	r3, #8
   153bc:	7023      	strb	r3, [r4, #0]
   153be:	e736      	b.n	1522e <USBH_Process+0xbe>
      if ((phost->device.CfgDesc.bmAttributes) & (1U << 5))
   153c0:	f894 333f 	ldrb.w	r3, [r4, #831]	; 0x33f
   153c4:	069b      	lsls	r3, r3, #26
   153c6:	f100 8086 	bmi.w	154d6 <USBH_Process+0x366>
        phost->gState = HOST_CHECK_CLASS;
   153ca:	230a      	movs	r3, #10
   153cc:	7023      	strb	r3, [r4, #0]
   153ce:	e72e      	b.n	1522e <USBH_Process+0xbe>
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
   153d0:	f894 133d 	ldrb.w	r1, [r4, #829]	; 0x33d
   153d4:	4620      	mov	r0, r4
   153d6:	f000 fd8b 	bl	15ef0 <USBH_SetCfg>
   153da:	2800      	cmp	r0, #0
   153dc:	f47f af27 	bne.w	1522e <USBH_Process+0xbe>
        phost->gState = HOST_SET_WAKEUP_FEATURE;
   153e0:	2309      	movs	r3, #9
   153e2:	7023      	strb	r3, [r4, #0]
   153e4:	e723      	b.n	1522e <USBH_Process+0xbe>
          phost->gState = HOST_CLASS;
   153e6:	230b      	movs	r3, #11
   153e8:	7023      	strb	r3, [r4, #0]
   153ea:	e720      	b.n	1522e <USBH_Process+0xbe>
          phost->Timeout += 10U;
   153ec:	330a      	adds	r3, #10
          USBH_Delay(10U);
   153ee:	200a      	movs	r0, #10
          phost->Timeout += 10U;
   153f0:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
          USBH_Delay(10U);
   153f4:	f00e fbcc 	bl	23b90 <USBH_Delay>
   153f8:	e719      	b.n	1522e <USBH_Process+0xbe>
  {
    case ENUM_IDLE:
      /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
   153fa:	2108      	movs	r1, #8
   153fc:	4620      	mov	r0, r4
   153fe:	f000 f91f 	bl	15640 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
   15402:	4605      	mov	r5, r0
   15404:	2800      	cmp	r0, #0
   15406:	f000 80c1 	beq.w	1558c <USBH_Process+0x41c>
        /* Open Control pipes */
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
                      phost->device.speed, USBH_EP_CONTROL,
                      (uint16_t)phost->Control.pipe_size);
      }
      else if (ReqStatus == USBH_NOT_SUPPORTED)
   1540a:	2803      	cmp	r0, #3
   1540c:	f000 80aa 	beq.w	15564 <USBH_Process+0x3f4>
  USBH_StatusTypeDef Status = USBH_BUSY;
   15410:	2301      	movs	r3, #1
      status = USBH_HandleEnum(phost);
   15412:	f88d 3017 	strb.w	r3, [sp, #23]
      if (status == USBH_OK)
   15416:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1541a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   1541e:	2b00      	cmp	r3, #0
   15420:	f47f af05 	bne.w	1522e <USBH_Process+0xbe>
        if (phost->device.DevDesc.bNumConfigurations == 1U)
   15424:	f894 3337 	ldrb.w	r3, [r4, #823]	; 0x337
        phost->device.current_interface = 0U;
   15428:	f884 2324 	strb.w	r2, [r4, #804]	; 0x324
        if (phost->device.DevDesc.bNumConfigurations == 1U)
   1542c:	2b01      	cmp	r3, #1
   1542e:	d0c4      	beq.n	153ba <USBH_Process+0x24a>
          phost->gState = HOST_INPUT;
   15430:	2307      	movs	r3, #7
   15432:	7023      	strb	r3, [r4, #0]
   15434:	e6fb      	b.n	1522e <USBH_Process+0xbe>
#endif
      }
      break;

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
   15436:	f894 1336 	ldrb.w	r1, [r4, #822]	; 0x336
   1543a:	2900      	cmp	r1, #0
   1543c:	d174      	bne.n	15528 <USBH_Process+0x3b8>
        }
      }
      else
      {
        USBH_UsrLog("Serial Number : N/A");
        Status = USBH_OK;
   1543e:	460b      	mov	r3, r1
   15440:	e7e7      	b.n	15412 <USBH_Process+0x2a2>
      if (phost->device.DevDesc.iProduct != 0U)
   15442:	f894 1335 	ldrb.w	r1, [r4, #821]	; 0x335
   15446:	2900      	cmp	r1, #0
   15448:	d17f      	bne.n	1554a <USBH_Process+0x3da>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
   1544a:	2207      	movs	r2, #7
  USBH_StatusTypeDef Status = USBH_BUSY;
   1544c:	2301      	movs	r3, #1
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
   1544e:	7062      	strb	r2, [r4, #1]
   15450:	e7df      	b.n	15412 <USBH_Process+0x2a2>
      if (phost->device.DevDesc.iManufacturer != 0U)
   15452:	f894 1334 	ldrb.w	r1, [r4, #820]	; 0x334
   15456:	2900      	cmp	r1, #0
   15458:	d15a      	bne.n	15510 <USBH_Process+0x3a0>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   1545a:	2206      	movs	r2, #6
  USBH_StatusTypeDef Status = USBH_BUSY;
   1545c:	2301      	movs	r3, #1
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   1545e:	7062      	strb	r2, [r4, #1]
   15460:	e7d7      	b.n	15412 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
   15462:	f8b4 133a 	ldrh.w	r1, [r4, #826]	; 0x33a
   15466:	4620      	mov	r0, r4
   15468:	f000 f9f8 	bl	1585c <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
   1546c:	2800      	cmp	r0, #0
   1546e:	d04b      	beq.n	15508 <USBH_Process+0x398>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
   15470:	2803      	cmp	r0, #3
   15472:	d1cd      	bne.n	15410 <USBH_Process+0x2a0>
        phost->device.EnumCnt++;
   15474:	f894 331e 	ldrb.w	r3, [r4, #798]	; 0x31e
   15478:	3301      	adds	r3, #1
   1547a:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
   1547c:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
   1547e:	f884 331e 	strb.w	r3, [r4, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
   15482:	f240 80a6 	bls.w	155d2 <USBH_Process+0x462>
          phost->gState = HOST_ABORT_STATE;
   15486:	220d      	movs	r2, #13
  USBH_StatusTypeDef Status = USBH_BUSY;
   15488:	2301      	movs	r3, #1
          phost->gState = HOST_ABORT_STATE;
   1548a:	7022      	strb	r2, [r4, #0]
   1548c:	e7c1      	b.n	15412 <USBH_Process+0x2a2>
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
   1548e:	2101      	movs	r1, #1
   15490:	4620      	mov	r0, r4
   15492:	f000 fc47 	bl	15d24 <USBH_SetAddress>
      if (ReqStatus == USBH_OK)
   15496:	4606      	mov	r6, r0
   15498:	2800      	cmp	r0, #0
   1549a:	f000 80a7 	beq.w	155ec <USBH_Process+0x47c>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
   1549e:	2803      	cmp	r0, #3
   154a0:	d1b6      	bne.n	15410 <USBH_Process+0x2a0>
        phost->gState = HOST_ABORT_STATE;
   154a2:	210d      	movs	r1, #13
        phost->EnumState = ENUM_IDLE;
   154a4:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
   154a6:	2301      	movs	r3, #1
        phost->gState = HOST_ABORT_STATE;
   154a8:	7021      	strb	r1, [r4, #0]
        phost->EnumState = ENUM_IDLE;
   154aa:	7062      	strb	r2, [r4, #1]
   154ac:	e7b1      	b.n	15412 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
   154ae:	2112      	movs	r1, #18
   154b0:	4620      	mov	r0, r4
   154b2:	f000 f8c5 	bl	15640 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
   154b6:	2800      	cmp	r0, #0
   154b8:	d1da      	bne.n	15470 <USBH_Process+0x300>
        phost->EnumState = ENUM_SET_ADDR;
   154ba:	2202      	movs	r2, #2
  USBH_StatusTypeDef Status = USBH_BUSY;
   154bc:	2301      	movs	r3, #1
        phost->EnumState = ENUM_SET_ADDR;
   154be:	7062      	strb	r2, [r4, #1]
   154c0:	e7a7      	b.n	15412 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
   154c2:	2109      	movs	r1, #9
   154c4:	4620      	mov	r0, r4
   154c6:	f000 f9c9 	bl	1585c <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
   154ca:	2800      	cmp	r0, #0
   154cc:	d1d0      	bne.n	15470 <USBH_Process+0x300>
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
   154ce:	2204      	movs	r2, #4
  USBH_StatusTypeDef Status = USBH_BUSY;
   154d0:	2301      	movs	r3, #1
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
   154d2:	7062      	strb	r2, [r4, #1]
   154d4:	e79d      	b.n	15412 <USBH_Process+0x2a2>
        if (USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP) == USBH_OK)
   154d6:	2101      	movs	r1, #1
   154d8:	4620      	mov	r0, r4
   154da:	f000 fdef 	bl	160bc <USBH_SetFeature>
   154de:	2800      	cmp	r0, #0
   154e0:	f47f aea5 	bne.w	1522e <USBH_Process+0xbe>
   154e4:	e771      	b.n	153ca <USBH_Process+0x25a>
        phost->device.is_ReEnumerated = 0U;
   154e6:	2300      	movs	r3, #0
  USBH_LL_Start(phost);
   154e8:	4620      	mov	r0, r4
        phost->device.is_ReEnumerated = 0U;
   154ea:	f884 3322 	strb.w	r3, [r4, #802]	; 0x322
  USBH_LL_Start(phost);
   154ee:	f00e faa7 	bl	23a40 <USBH_LL_Start>
  USBH_LL_DriverVBUS(phost, OTRUE);
   154f2:	4629      	mov	r1, r5
   154f4:	4620      	mov	r0, r4
   154f6:	f00e fb27 	bl	23b48 <USBH_LL_DriverVBUS>
   154fa:	e698      	b.n	1522e <USBH_Process+0xbe>
        phost->device.RstCnt = 0U;
   154fc:	2200      	movs	r2, #0
        phost->gState = HOST_DEV_ATTACHED;
   154fe:	2302      	movs	r3, #2
        phost->device.RstCnt = 0U;
   15500:	f884 231f 	strb.w	r2, [r4, #799]	; 0x31f
        phost->gState = HOST_DEV_ATTACHED;
   15504:	7023      	strb	r3, [r4, #0]
   15506:	e692      	b.n	1522e <USBH_Process+0xbe>
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
   15508:	2205      	movs	r2, #5
  USBH_StatusTypeDef Status = USBH_BUSY;
   1550a:	2301      	movs	r3, #1
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
   1550c:	7062      	strb	r2, [r4, #1]
   1550e:	e780      	b.n	15412 <USBH_Process+0x2a2>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
   15510:	23ff      	movs	r3, #255	; 0xff
   15512:	f504 728e 	add.w	r2, r4, #284	; 0x11c
   15516:	4620      	mov	r0, r4
   15518:	f000 faf6 	bl	15b08 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
   1551c:	2800      	cmp	r0, #0
   1551e:	d09c      	beq.n	1545a <USBH_Process+0x2ea>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
   15520:	2803      	cmp	r0, #3
   15522:	f47f af75 	bne.w	15410 <USBH_Process+0x2a0>
   15526:	e798      	b.n	1545a <USBH_Process+0x2ea>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
   15528:	23ff      	movs	r3, #255	; 0xff
   1552a:	f504 728e 	add.w	r2, r4, #284	; 0x11c
   1552e:	4620      	mov	r0, r4
   15530:	f000 faea 	bl	15b08 <USBH_Get_StringDesc>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
   15534:	f1a0 0303 	sub.w	r3, r0, #3
   15538:	fab3 f383 	clz	r3, r3
   1553c:	095b      	lsrs	r3, r3, #5
   1553e:	2800      	cmp	r0, #0
   15540:	bf08      	it	eq
   15542:	2301      	moveq	r3, #1
  USBH_StatusTypeDef Status = USBH_BUSY;
   15544:	f083 0301 	eor.w	r3, r3, #1
   15548:	e763      	b.n	15412 <USBH_Process+0x2a2>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
   1554a:	23ff      	movs	r3, #255	; 0xff
   1554c:	f504 728e 	add.w	r2, r4, #284	; 0x11c
   15550:	4620      	mov	r0, r4
   15552:	f000 fad9 	bl	15b08 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
   15556:	2800      	cmp	r0, #0
   15558:	f43f af77 	beq.w	1544a <USBH_Process+0x2da>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
   1555c:	2803      	cmp	r0, #3
   1555e:	f47f af57 	bne.w	15410 <USBH_Process+0x2a0>
   15562:	e772      	b.n	1544a <USBH_Process+0x2da>
        phost->device.EnumCnt++;
   15564:	f894 331e 	ldrb.w	r3, [r4, #798]	; 0x31e
   15568:	3301      	adds	r3, #1
   1556a:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
   1556c:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
   1556e:	f884 331e 	strb.w	r3, [r4, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
   15572:	d888      	bhi.n	15486 <USBH_Process+0x316>
          USBH_FreePipe(phost, phost->Control.pipe_out);
   15574:	7961      	ldrb	r1, [r4, #5]
   15576:	4620      	mov	r0, r4
   15578:	f001 f818 	bl	165ac <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
   1557c:	7921      	ldrb	r1, [r4, #4]
   1557e:	4620      	mov	r0, r4
   15580:	f001 f814 	bl	165ac <USBH_FreePipe>
          phost->gState = HOST_IDLE;
   15584:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
   15586:	2301      	movs	r3, #1
          phost->gState = HOST_IDLE;
   15588:	7022      	strb	r2, [r4, #0]
   1558a:	e742      	b.n	15412 <USBH_Process+0x2a2>
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
   1558c:	f894 732d 	ldrb.w	r7, [r4, #813]	; 0x32d
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   15590:	2601      	movs	r6, #1
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
   15592:	f894 c31d 	ldrb.w	ip, [r4, #797]	; 0x31d
   15596:	2280      	movs	r2, #128	; 0x80
   15598:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   1559c:	4620      	mov	r0, r4
   1559e:	7921      	ldrb	r1, [r4, #4]
   155a0:	9501      	str	r5, [sp, #4]
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
   155a2:	71a7      	strb	r7, [r4, #6]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
   155a4:	9702      	str	r7, [sp, #8]
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   155a6:	7066      	strb	r6, [r4, #1]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
   155a8:	f8cd c000 	str.w	ip, [sp]
   155ac:	f000 ff9e 	bl	164ec <USBH_OpenPipe>
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
   155b0:	f894 c006 	ldrb.w	ip, [r4, #6]
   155b4:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
   155b8:	462a      	mov	r2, r5
   155ba:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   155be:	4620      	mov	r0, r4
   155c0:	7961      	ldrb	r1, [r4, #5]
   155c2:	9501      	str	r5, [sp, #4]
   155c4:	f8cd c008 	str.w	ip, [sp, #8]
   155c8:	9700      	str	r7, [sp, #0]
   155ca:	f000 ff8f 	bl	164ec <USBH_OpenPipe>
  USBH_StatusTypeDef Status = USBH_BUSY;
   155ce:	4633      	mov	r3, r6
   155d0:	e71f      	b.n	15412 <USBH_Process+0x2a2>
          USBH_FreePipe(phost, phost->Control.pipe_out);
   155d2:	7961      	ldrb	r1, [r4, #5]
   155d4:	4620      	mov	r0, r4
   155d6:	f000 ffe9 	bl	165ac <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
   155da:	7921      	ldrb	r1, [r4, #4]
   155dc:	4620      	mov	r0, r4
   155de:	f000 ffe5 	bl	165ac <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
   155e2:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
   155e4:	2301      	movs	r3, #1
          phost->EnumState = ENUM_IDLE;
   155e6:	7062      	strb	r2, [r4, #1]
          phost->gState = HOST_IDLE;
   155e8:	7022      	strb	r2, [r4, #0]
   155ea:	e712      	b.n	15412 <USBH_Process+0x2a2>
        USBH_Delay(2U);
   155ec:	2002      	movs	r0, #2
        phost->device.address = USBH_DEVICE_ADDRESS;
   155ee:	2501      	movs	r5, #1
        USBH_Delay(2U);
   155f0:	f00e face 	bl	23b90 <USBH_Delay>
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   155f4:	79a7      	ldrb	r7, [r4, #6]
        phost->EnumState = ENUM_GET_CFG_DESC;
   155f6:	2003      	movs	r0, #3
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   155f8:	7921      	ldrb	r1, [r4, #4]
   155fa:	9601      	str	r6, [sp, #4]
   155fc:	462b      	mov	r3, r5
        phost->EnumState = ENUM_GET_CFG_DESC;
   155fe:	7060      	strb	r0, [r4, #1]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   15600:	2280      	movs	r2, #128	; 0x80
        phost->device.address = USBH_DEVICE_ADDRESS;
   15602:	f884 531c 	strb.w	r5, [r4, #796]	; 0x31c
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   15606:	4620      	mov	r0, r4
   15608:	9702      	str	r7, [sp, #8]
   1560a:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
   1560e:	9700      	str	r7, [sp, #0]
   15610:	f000 ff6c 	bl	164ec <USBH_OpenPipe>
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
   15614:	f894 c006 	ldrb.w	ip, [r4, #6]
   15618:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
   1561c:	4632      	mov	r2, r6
   1561e:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   15622:	4620      	mov	r0, r4
   15624:	7961      	ldrb	r1, [r4, #5]
   15626:	9601      	str	r6, [sp, #4]
   15628:	f8cd c008 	str.w	ip, [sp, #8]
   1562c:	9700      	str	r7, [sp, #0]
   1562e:	f000 ff5d 	bl	164ec <USBH_OpenPipe>
  USBH_StatusTypeDef Status = USBH_BUSY;
   15632:	462b      	mov	r3, r5
   15634:	e6ed      	b.n	15412 <USBH_Process+0x2a2>
   15636:	bf00      	nop

00015638 <USBH_LL_SetTimer>:
  * @param  phost: Host Handle
  * @retval None
  */
void  USBH_LL_SetTimer(USBH_HandleTypeDef *phost, uint32_t time)
{
  phost->Timer = time;
   15638:	f8c0 1534 	str.w	r1, [r0, #1332]	; 0x534
}
   1563c:	4770      	bx	lr
   1563e:	bf00      	nop

00015640 <USBH_Get_DevDesc>:
  * @param  phost: Host Handle
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_DevDesc(USBH_HandleTypeDef *phost, uint8_t length)
{
   15640:	b570      	push	{r4, r5, r6, lr}
   15642:	4604      	mov	r4, r0
                                      uint8_t  req_type,
                                      uint16_t value_idx,
                                      uint8_t *buff,
                                      uint16_t length)
{
  if (phost->RequestState == CMD_SEND)
   15644:	7880      	ldrb	r0, [r0, #2]
{
   15646:	b082      	sub	sp, #8
  if (phost->RequestState == CMD_SEND)
   15648:	2801      	cmp	r0, #1
   1564a:	d011      	beq.n	15670 <USBH_Get_DevDesc+0x30>
                               uint16_t length)
{
  USBH_StatusTypeDef status;
  status = USBH_BUSY;

  switch (phost->RequestState)
   1564c:	2802      	cmp	r0, #2
   1564e:	d002      	beq.n	15656 <USBH_Get_DevDesc+0x16>
  status = USBH_BUSY;
   15650:	2001      	movs	r0, #1
}
   15652:	b002      	add	sp, #8
   15654:	bd70      	pop	{r4, r5, r6, pc}
{
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;

  switch (phost->Control.state)
   15656:	7e23      	ldrb	r3, [r4, #24]
   15658:	460d      	mov	r5, r1
   1565a:	3b01      	subs	r3, #1
   1565c:	2b0a      	cmp	r3, #10
   1565e:	d8f7      	bhi.n	15650 <USBH_Get_DevDesc+0x10>
   15660:	e8df f003 	tbb	[pc, r3]
   15664:	5548392f 	.word	0x5548392f
   15668:	8c7f6f60 	.word	0x8c7f6f60
   1566c:	ac9d      	.short	0xac9d
   1566e:	14          	.byte	0x14
   1566f:	00          	.byte	0x00
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   15670:	4e79      	ldr	r6, [pc, #484]	; (15858 <USBH_Get_DevDesc+0x218>)
    phost->Control.setup.b.wValue.w = value_idx;
   15672:	2500      	movs	r5, #0
                                   USB_DESC_DEVICE, phost->device.Data,
   15674:	f504 728e 	add.w	r2, r4, #284	; 0x11c
      phost->RequestState = CMD_WAIT;
   15678:	2302      	movs	r3, #2
    phost->Control.setup.b.wLength.w = length;
   1567a:	82e1      	strh	r1, [r4, #22]
      phost->Control.length = length;
   1567c:	81a1      	strh	r1, [r4, #12]
      phost->Control.state = CTRL_SETUP;
   1567e:	7620      	strb	r0, [r4, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   15680:	6126      	str	r6, [r4, #16]
    phost->Control.setup.b.wValue.w = value_idx;
   15682:	82a5      	strh	r5, [r4, #20]
      phost->Control.buff = buff;
   15684:	60a2      	str	r2, [r4, #8]
      phost->RequestState = CMD_WAIT;
   15686:	70a3      	strb	r3, [r4, #2]
}
   15688:	b002      	add	sp, #8
   1568a:	bd70      	pop	{r4, r5, r6, pc}
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   1568c:	7e63      	ldrb	r3, [r4, #25]
   1568e:	3301      	adds	r3, #1
   15690:	b2db      	uxtb	r3, r3
   15692:	2b02      	cmp	r3, #2
   15694:	7663      	strb	r3, [r4, #25]
   15696:	f240 80d7 	bls.w	15848 <USBH_Get_DevDesc+0x208>
        phost->RequestState = CMD_SEND;
      }
      else
      {
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
        phost->Control.errorcount = 0U;
   1569a:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   1569c:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   156a0:	2106      	movs	r1, #6
   156a2:	4620      	mov	r0, r4
   156a4:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");

        /* Free control pipes */
        USBH_FreePipe(phost, phost->Control.pipe_out);
   156a6:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   156a8:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   156aa:	4620      	mov	r0, r4
   156ac:	f000 ff7e 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   156b0:	7921      	ldrb	r1, [r4, #4]
   156b2:	4620      	mov	r0, r4
   156b4:	f000 ff7a 	bl	165ac <USBH_FreePipe>

        phost->gState = HOST_IDLE;
   156b8:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   156ba:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   156bc:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   156be:	70a3      	strb	r3, [r4, #2]
   156c0:	e7c7      	b.n	15652 <USBH_Get_DevDesc+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   156c2:	7962      	ldrb	r2, [r4, #5]
   156c4:	f104 0110 	add.w	r1, r4, #16
   156c8:	4620      	mov	r0, r4
   156ca:	f000 fec3 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   156ce:	2302      	movs	r3, #2
   156d0:	2001      	movs	r0, #1
   156d2:	7623      	strb	r3, [r4, #24]
   156d4:	e7bd      	b.n	15652 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   156d6:	7961      	ldrb	r1, [r4, #5]
   156d8:	4620      	mov	r0, r4
   156da:	f00e fa31 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   156de:	2801      	cmp	r0, #1
   156e0:	f000 80a7 	beq.w	15832 <USBH_Get_DevDesc+0x1f2>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   156e4:	2804      	cmp	r0, #4
   156e6:	d001      	beq.n	156ec <USBH_Get_DevDesc+0xac>
   156e8:	2802      	cmp	r0, #2
   156ea:	d1b1      	bne.n	15650 <USBH_Get_DevDesc+0x10>
          phost->Control.state = CTRL_ERROR;
   156ec:	230b      	movs	r3, #11
   156ee:	2001      	movs	r0, #1
   156f0:	7623      	strb	r3, [r4, #24]
   156f2:	e7ae      	b.n	15652 <USBH_Get_DevDesc+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   156f4:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   156f8:	4620      	mov	r0, r4
   156fa:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   156fc:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   156fe:	68a1      	ldr	r1, [r4, #8]
   15700:	89a2      	ldrh	r2, [r4, #12]
   15702:	f000 fecf 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   15706:	2304      	movs	r3, #4
   15708:	2001      	movs	r0, #1
   1570a:	7623      	strb	r3, [r4, #24]
   1570c:	e7a1      	b.n	15652 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1570e:	7921      	ldrb	r1, [r4, #4]
   15710:	4620      	mov	r0, r4
   15712:	f00e fa15 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15716:	2801      	cmp	r0, #1
   15718:	d058      	beq.n	157cc <USBH_Get_DevDesc+0x18c>
      if (URB_Status == USBH_URB_STALL)
   1571a:	2805      	cmp	r0, #5
   1571c:	d039      	beq.n	15792 <USBH_Get_DevDesc+0x152>
        if (URB_Status == USBH_URB_ERROR)
   1571e:	2804      	cmp	r0, #4
   15720:	d196      	bne.n	15650 <USBH_Get_DevDesc+0x10>
   15722:	e7e3      	b.n	156ec <USBH_Get_DevDesc+0xac>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   15724:	2501      	movs	r5, #1
   15726:	7963      	ldrb	r3, [r4, #5]
   15728:	89a2      	ldrh	r2, [r4, #12]
   1572a:	4620      	mov	r0, r4
   1572c:	68a1      	ldr	r1, [r4, #8]
   1572e:	9500      	str	r5, [sp, #0]
   15730:	f000 fea0 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15734:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15738:	2306      	movs	r3, #6
   1573a:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   1573c:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   1573e:	7623      	strb	r3, [r4, #24]
   15740:	e787      	b.n	15652 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15742:	7961      	ldrb	r1, [r4, #5]
   15744:	4620      	mov	r0, r4
   15746:	f00e f9fb 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1574a:	2801      	cmp	r0, #1
   1574c:	d06d      	beq.n	1582a <USBH_Get_DevDesc+0x1ea>
      else if (URB_Status == USBH_URB_STALL)
   1574e:	2805      	cmp	r0, #5
   15750:	d01f      	beq.n	15792 <USBH_Get_DevDesc+0x152>
      else if (URB_Status == USBH_URB_NOTREADY)
   15752:	2802      	cmp	r0, #2
   15754:	d074      	beq.n	15840 <USBH_Get_DevDesc+0x200>
        if (URB_Status == USBH_URB_ERROR)
   15756:	2804      	cmp	r0, #4
   15758:	f47f af7a 	bne.w	15650 <USBH_Get_DevDesc+0x10>
          phost->Control.state = CTRL_ERROR;
   1575c:	230b      	movs	r3, #11
   1575e:	7623      	strb	r3, [r4, #24]
   15760:	e7ab      	b.n	156ba <USBH_Get_DevDesc+0x7a>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   15762:	2200      	movs	r2, #0
   15764:	7923      	ldrb	r3, [r4, #4]
   15766:	4620      	mov	r0, r4
   15768:	4611      	mov	r1, r2
   1576a:	f000 fe9b 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1576e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15772:	2308      	movs	r3, #8
   15774:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   15776:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15778:	7623      	strb	r3, [r4, #24]
   1577a:	e76a      	b.n	15652 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1577c:	7921      	ldrb	r1, [r4, #4]
   1577e:	4620      	mov	r0, r4
   15780:	f00e f9de 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15784:	2801      	cmp	r0, #1
   15786:	d025      	beq.n	157d4 <USBH_Get_DevDesc+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   15788:	2804      	cmp	r0, #4
   1578a:	d0af      	beq.n	156ec <USBH_Get_DevDesc+0xac>
        if (URB_Status == USBH_URB_STALL)
   1578c:	2805      	cmp	r0, #5
   1578e:	f47f af5f 	bne.w	15650 <USBH_Get_DevDesc+0x10>
        phost->RequestState = CMD_SEND;
   15792:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   15794:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
   15796:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   15798:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   1579a:	7623      	strb	r3, [r4, #24]
   1579c:	e759      	b.n	15652 <USBH_Get_DevDesc+0x12>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   1579e:	2200      	movs	r2, #0
   157a0:	2501      	movs	r5, #1
   157a2:	7963      	ldrb	r3, [r4, #5]
   157a4:	4620      	mov	r0, r4
   157a6:	4611      	mov	r1, r2
   157a8:	9500      	str	r5, [sp, #0]
   157aa:	f000 fe63 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   157ae:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   157b2:	230a      	movs	r3, #10
   157b4:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   157b6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   157b8:	7623      	strb	r3, [r4, #24]
   157ba:	e74a      	b.n	15652 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   157bc:	7961      	ldrb	r1, [r4, #5]
   157be:	4620      	mov	r0, r4
   157c0:	f00e f9be 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   157c4:	2801      	cmp	r0, #1
   157c6:	d005      	beq.n	157d4 <USBH_Get_DevDesc+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   157c8:	2802      	cmp	r0, #2
   157ca:	d1a8      	bne.n	1571e <USBH_Get_DevDesc+0xde>
            phost->Control.state = CTRL_STATUS_OUT;
   157cc:	2309      	movs	r3, #9
   157ce:	2001      	movs	r0, #1
   157d0:	7623      	strb	r3, [r4, #24]
   157d2:	e73e      	b.n	15652 <USBH_Get_DevDesc+0x12>
        phost->RequestState = CMD_SEND;
   157d4:	2201      	movs	r2, #1
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
   157d6:	f894 311c 	ldrb.w	r3, [r4, #284]	; 0x11c
        phost->Control.state = CTRL_IDLE;
   157da:	2000      	movs	r0, #0
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
   157dc:	f894 111d 	ldrb.w	r1, [r4, #285]	; 0x11d
        phost->RequestState = CMD_SEND;
   157e0:	70a2      	strb	r2, [r4, #2]
  if (length > 8U)
   157e2:	2d08      	cmp	r5, #8
  dev_desc->bcdUSB             = LE16(buf +  2);
   157e4:	f8b4 211e 	ldrh.w	r2, [r4, #286]	; 0x11e
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
   157e8:	f884 3326 	strb.w	r3, [r4, #806]	; 0x326
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
   157ec:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
        phost->Control.state = CTRL_IDLE;
   157f0:	7620      	strb	r0, [r4, #24]
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
   157f2:	f884 1327 	strb.w	r1, [r4, #807]	; 0x327
  dev_desc->bcdUSB             = LE16(buf +  2);
   157f6:	f8a4 2328 	strh.w	r2, [r4, #808]	; 0x328
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
   157fa:	f8c4 332a 	str.w	r3, [r4, #810]	; 0x32a
  if (length > 8U)
   157fe:	f67f af28 	bls.w	15652 <USBH_Get_DevDesc+0x12>
    dev_desc->idVendor           = LE16(buf +  8);
   15802:	f8b4 5124 	ldrh.w	r5, [r4, #292]	; 0x124
    dev_desc->idProduct          = LE16(buf + 10);
   15806:	f8b4 1126 	ldrh.w	r1, [r4, #294]	; 0x126
    dev_desc->bcdDevice          = LE16(buf + 12);
   1580a:	f8b4 2128 	ldrh.w	r2, [r4, #296]	; 0x128
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
   1580e:	f8d4 312a 	ldr.w	r3, [r4, #298]	; 0x12a
    dev_desc->idVendor           = LE16(buf +  8);
   15812:	f8a4 532e 	strh.w	r5, [r4, #814]	; 0x32e
    dev_desc->idProduct          = LE16(buf + 10);
   15816:	f8a4 1330 	strh.w	r1, [r4, #816]	; 0x330
    dev_desc->bcdDevice          = LE16(buf + 12);
   1581a:	f8a4 2332 	strh.w	r2, [r4, #818]	; 0x332
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
   1581e:	f8c4 3334 	str.w	r3, [r4, #820]	; 0x334
}
   15822:	b002      	add	sp, #8
   15824:	bd70      	pop	{r4, r5, r6, pc}
          if (direction == USB_D2H)
   15826:	2a00      	cmp	r2, #0
   15828:	dbd0      	blt.n	157cc <USBH_Get_DevDesc+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   1582a:	2307      	movs	r3, #7
   1582c:	2001      	movs	r0, #1
   1582e:	7623      	strb	r3, [r4, #24]
   15830:	e70f      	b.n	15652 <USBH_Get_DevDesc+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   15832:	8ae3      	ldrh	r3, [r4, #22]
   15834:	f994 2010 	ldrsb.w	r2, [r4, #16]
   15838:	2b00      	cmp	r3, #0
   1583a:	d0f4      	beq.n	15826 <USBH_Get_DevDesc+0x1e6>
          if (direction == USB_D2H)
   1583c:	2a00      	cmp	r2, #0
   1583e:	db08      	blt.n	15852 <USBH_Get_DevDesc+0x212>
            phost->Control.state = CTRL_DATA_OUT;
   15840:	2305      	movs	r3, #5
   15842:	2001      	movs	r0, #1
   15844:	7623      	strb	r3, [r4, #24]
   15846:	e704      	b.n	15652 <USBH_Get_DevDesc+0x12>
        phost->Control.state = CTRL_SETUP;
   15848:	2301      	movs	r3, #1
   1584a:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   1584c:	4618      	mov	r0, r3
   1584e:	70a3      	strb	r3, [r4, #2]
   15850:	e6ff      	b.n	15652 <USBH_Get_DevDesc+0x12>
            phost->Control.state = CTRL_DATA_IN;
   15852:	2303      	movs	r3, #3
   15854:	7623      	strb	r3, [r4, #24]
   15856:	e6fc      	b.n	15652 <USBH_Get_DevDesc+0x12>
   15858:	01000680 	.word	0x01000680

0001585c <USBH_Get_CfgDesc>:
{
   1585c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (phost->RequestState == CMD_SEND)
   15860:	7883      	ldrb	r3, [r0, #2]
{
   15862:	b083      	sub	sp, #12
   15864:	4605      	mov	r5, r0
  uint8_t *pData = phost->device.CfgDesc_Raw;;
   15866:	f100 041c 	add.w	r4, r0, #28
  if (phost->RequestState == CMD_SEND)
   1586a:	2b01      	cmp	r3, #1
   1586c:	d012      	beq.n	15894 <USBH_Get_CfgDesc+0x38>
  switch (phost->RequestState)
   1586e:	2b02      	cmp	r3, #2
   15870:	d003      	beq.n	1587a <USBH_Get_CfgDesc+0x1e>
  status = USBH_BUSY;
   15872:	2001      	movs	r0, #1
}
   15874:	b003      	add	sp, #12
   15876:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  switch (phost->Control.state)
   1587a:	7e03      	ldrb	r3, [r0, #24]
   1587c:	460e      	mov	r6, r1
   1587e:	3b01      	subs	r3, #1
   15880:	2b0a      	cmp	r3, #10
   15882:	d8f6      	bhi.n	15872 <USBH_Get_CfgDesc+0x16>
   15884:	e8df f003 	tbb	[pc, r3]
   15888:	5145372e 	.word	0x5145372e
   1588c:	867a695b 	.word	0x867a695b
   15890:	a496      	.short	0xa496
   15892:	14          	.byte	0x14
   15893:	00          	.byte	0x00
    phost->Control.setup.b.wLength.w = length;
   15894:	82c1      	strh	r1, [r0, #22]
    phost->Control.setup.b.wValue.w = value_idx;
   15896:	2600      	movs	r6, #0
      phost->Control.buff = buff;
   15898:	6084      	str	r4, [r0, #8]
      phost->RequestState = CMD_WAIT;
   1589a:	2202      	movs	r2, #2
      phost->Control.length = length;
   1589c:	8181      	strh	r1, [r0, #12]
      status = USBH_BUSY;
   1589e:	4618      	mov	r0, r3
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   158a0:	4f98      	ldr	r7, [pc, #608]	; (15b04 <USBH_Get_CfgDesc+0x2a8>)
      phost->Control.state = CTRL_SETUP;
   158a2:	762b      	strb	r3, [r5, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   158a4:	612f      	str	r7, [r5, #16]
    phost->Control.setup.b.wValue.w = value_idx;
   158a6:	82ae      	strh	r6, [r5, #20]
      phost->RequestState = CMD_WAIT;
   158a8:	70aa      	strb	r2, [r5, #2]
}
   158aa:	b003      	add	sp, #12
   158ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   158b0:	7e43      	ldrb	r3, [r0, #25]
   158b2:	3301      	adds	r3, #1
   158b4:	b2db      	uxtb	r3, r3
   158b6:	2b02      	cmp	r3, #2
   158b8:	7643      	strb	r3, [r0, #25]
   158ba:	f240 811b 	bls.w	15af4 <USBH_Get_CfgDesc+0x298>
        phost->Control.errorcount = 0U;
   158be:	2400      	movs	r4, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   158c0:	f8d0 3544 	ldr.w	r3, [r0, #1348]	; 0x544
   158c4:	2106      	movs	r1, #6
   158c6:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   158c8:	7969      	ldrb	r1, [r5, #5]
        phost->Control.errorcount = 0U;
   158ca:	766c      	strb	r4, [r5, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   158cc:	4628      	mov	r0, r5
   158ce:	f000 fe6d 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   158d2:	7929      	ldrb	r1, [r5, #4]
   158d4:	4628      	mov	r0, r5
   158d6:	f000 fe69 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   158da:	702c      	strb	r4, [r5, #0]
        phost->RequestState = CMD_SEND;
   158dc:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   158de:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   158e0:	70ab      	strb	r3, [r5, #2]
   158e2:	e7c7      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   158e4:	7942      	ldrb	r2, [r0, #5]
   158e6:	f100 0110 	add.w	r1, r0, #16
   158ea:	f000 fdb3 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   158ee:	2302      	movs	r3, #2
   158f0:	2001      	movs	r0, #1
   158f2:	762b      	strb	r3, [r5, #24]
   158f4:	e7be      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   158f6:	7941      	ldrb	r1, [r0, #5]
   158f8:	f00e f922 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   158fc:	2801      	cmp	r0, #1
   158fe:	f000 80ee 	beq.w	15ade <USBH_Get_CfgDesc+0x282>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   15902:	2804      	cmp	r0, #4
   15904:	d001      	beq.n	1590a <USBH_Get_CfgDesc+0xae>
   15906:	2802      	cmp	r0, #2
   15908:	d1b3      	bne.n	15872 <USBH_Get_CfgDesc+0x16>
          phost->Control.state = CTRL_ERROR;
   1590a:	230b      	movs	r3, #11
   1590c:	2001      	movs	r0, #1
   1590e:	762b      	strb	r3, [r5, #24]
   15910:	e7b0      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      phost->Control.timer = (uint16_t)phost->Timer;
   15912:	f8d0 2534 	ldr.w	r2, [r0, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15916:	7903      	ldrb	r3, [r0, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   15918:	81c2      	strh	r2, [r0, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   1591a:	6881      	ldr	r1, [r0, #8]
   1591c:	8982      	ldrh	r2, [r0, #12]
   1591e:	f000 fdc1 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   15922:	2304      	movs	r3, #4
   15924:	2001      	movs	r0, #1
   15926:	762b      	strb	r3, [r5, #24]
   15928:	e7a4      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1592a:	7901      	ldrb	r1, [r0, #4]
   1592c:	f00e f908 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15930:	2801      	cmp	r0, #1
   15932:	d054      	beq.n	159de <USBH_Get_CfgDesc+0x182>
      if (URB_Status == USBH_URB_STALL)
   15934:	2805      	cmp	r0, #5
   15936:	d037      	beq.n	159a8 <USBH_Get_CfgDesc+0x14c>
        if (URB_Status == USBH_URB_ERROR)
   15938:	2804      	cmp	r0, #4
   1593a:	d19a      	bne.n	15872 <USBH_Get_CfgDesc+0x16>
   1593c:	e7e5      	b.n	1590a <USBH_Get_CfgDesc+0xae>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   1593e:	2401      	movs	r4, #1
   15940:	7943      	ldrb	r3, [r0, #5]
   15942:	8982      	ldrh	r2, [r0, #12]
   15944:	6881      	ldr	r1, [r0, #8]
   15946:	9400      	str	r4, [sp, #0]
   15948:	f000 fd94 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1594c:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15950:	2306      	movs	r3, #6
   15952:	4620      	mov	r0, r4
      phost->Control.timer = (uint16_t)phost->Timer;
   15954:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15956:	762b      	strb	r3, [r5, #24]
   15958:	e78c      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   1595a:	7941      	ldrb	r1, [r0, #5]
   1595c:	f00e f8f0 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15960:	2801      	cmp	r0, #1
   15962:	f000 80b8 	beq.w	15ad6 <USBH_Get_CfgDesc+0x27a>
      else if (URB_Status == USBH_URB_STALL)
   15966:	2805      	cmp	r0, #5
   15968:	d01e      	beq.n	159a8 <USBH_Get_CfgDesc+0x14c>
      else if (URB_Status == USBH_URB_NOTREADY)
   1596a:	2802      	cmp	r0, #2
   1596c:	f000 80be 	beq.w	15aec <USBH_Get_CfgDesc+0x290>
        if (URB_Status == USBH_URB_ERROR)
   15970:	2804      	cmp	r0, #4
   15972:	f47f af7e 	bne.w	15872 <USBH_Get_CfgDesc+0x16>
          phost->Control.state = CTRL_ERROR;
   15976:	230b      	movs	r3, #11
   15978:	762b      	strb	r3, [r5, #24]
   1597a:	e7af      	b.n	158dc <USBH_Get_CfgDesc+0x80>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   1597c:	2200      	movs	r2, #0
   1597e:	7903      	ldrb	r3, [r0, #4]
   15980:	4611      	mov	r1, r2
   15982:	f000 fd8f 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15986:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   1598a:	2308      	movs	r3, #8
   1598c:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   1598e:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15990:	762b      	strb	r3, [r5, #24]
   15992:	e76f      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15994:	7901      	ldrb	r1, [r0, #4]
   15996:	f00e f8d3 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1599a:	2801      	cmp	r0, #1
   1599c:	d023      	beq.n	159e6 <USBH_Get_CfgDesc+0x18a>
      else if (URB_Status == USBH_URB_ERROR)
   1599e:	2804      	cmp	r0, #4
   159a0:	d0b3      	beq.n	1590a <USBH_Get_CfgDesc+0xae>
        if (URB_Status == USBH_URB_STALL)
   159a2:	2805      	cmp	r0, #5
   159a4:	f47f af65 	bne.w	15872 <USBH_Get_CfgDesc+0x16>
        phost->RequestState = CMD_SEND;
   159a8:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   159aa:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
   159ac:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   159ae:	70aa      	strb	r2, [r5, #2]
        phost->Control.state = CTRL_IDLE;
   159b0:	762b      	strb	r3, [r5, #24]
   159b2:	e75f      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   159b4:	2200      	movs	r2, #0
   159b6:	2401      	movs	r4, #1
   159b8:	7943      	ldrb	r3, [r0, #5]
   159ba:	4611      	mov	r1, r2
   159bc:	9400      	str	r4, [sp, #0]
   159be:	f000 fd59 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   159c2:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   159c6:	230a      	movs	r3, #10
   159c8:	4620      	mov	r0, r4
      phost->Control.timer = (uint16_t)phost->Timer;
   159ca:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   159cc:	762b      	strb	r3, [r5, #24]
   159ce:	e751      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   159d0:	7941      	ldrb	r1, [r0, #5]
   159d2:	f00e f8b5 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   159d6:	2801      	cmp	r0, #1
   159d8:	d005      	beq.n	159e6 <USBH_Get_CfgDesc+0x18a>
      else if (URB_Status == USBH_URB_NOTREADY)
   159da:	2802      	cmp	r0, #2
   159dc:	d1ac      	bne.n	15938 <USBH_Get_CfgDesc+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   159de:	2309      	movs	r3, #9
   159e0:	2001      	movs	r0, #1
   159e2:	762b      	strb	r3, [r5, #24]
   159e4:	e746      	b.n	15874 <USBH_Get_CfgDesc+0x18>
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
   159e6:	7f2a      	ldrb	r2, [r5, #28]
        phost->RequestState = CMD_SEND;
   159e8:	2101      	movs	r1, #1
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
   159ea:	7f6b      	ldrb	r3, [r5, #29]
        phost->Control.state = CTRL_IDLE;
   159ec:	2700      	movs	r7, #0
  cfg_desc->wTotalLength        = LE16(buf + 2);
   159ee:	8be8      	ldrh	r0, [r5, #30]
  if (length > USB_CONFIGURATION_DESC_SIZE)
   159f0:	2e09      	cmp	r6, #9
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
   159f2:	f885 2338 	strb.w	r2, [r5, #824]	; 0x338
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
   159f6:	f885 3339 	strb.w	r3, [r5, #825]	; 0x339
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
   159fa:	6a2a      	ldr	r2, [r5, #32]
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
   159fc:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
        phost->RequestState = CMD_SEND;
   15a00:	70a9      	strb	r1, [r5, #2]
        phost->Control.state = CTRL_IDLE;
   15a02:	762f      	strb	r7, [r5, #24]
  cfg_desc->wTotalLength        = LE16(buf + 2);
   15a04:	f8a5 033a 	strh.w	r0, [r5, #826]	; 0x33a
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
   15a08:	f8c5 233c 	str.w	r2, [r5, #828]	; 0x33c
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
   15a0c:	f885 3340 	strb.w	r3, [r5, #832]	; 0x340
  if (length > USB_CONFIGURATION_DESC_SIZE)
   15a10:	d913      	bls.n	15a3a <USBH_Get_CfgDesc+0x1de>
   15a12:	46ac      	mov	ip, r5
    ptr = USB_LEN_CFG_DESC;
   15a14:	2209      	movs	r2, #9
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   15a16:	f04f 0e2a 	mov.w	lr, #42	; 0x2a
   15a1a:	b2fe      	uxtb	r6, r7
   15a1c:	2e09      	cmp	r6, #9
   15a1e:	bf8c      	ite	hi
   15a20:	2600      	movhi	r6, #0
   15a22:	2601      	movls	r6, #1
   15a24:	e007      	b.n	15a36 <USBH_Get_CfgDesc+0x1da>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
   15a26:	b146      	cbz	r6, 15a3a <USBH_Get_CfgDesc+0x1de>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a28:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
   15a2a:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a2c:	4413      	add	r3, r2
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
   15a2e:	7861      	ldrb	r1, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a30:	b29a      	uxth	r2, r3
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
   15a32:	2904      	cmp	r1, #4
   15a34:	d005      	beq.n	15a42 <USBH_Get_CfgDesc+0x1e6>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
   15a36:	4290      	cmp	r0, r2
   15a38:	d8f5      	bhi.n	15a26 <USBH_Get_CfgDesc+0x1ca>
        status = USBH_NOT_SUPPORTED;
   15a3a:	2000      	movs	r0, #0
}
   15a3c:	b003      	add	sp, #12
   15a3e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
   15a42:	7823      	ldrb	r3, [r4, #0]
        ep_ix = 0U;
   15a44:	2100      	movs	r1, #0
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   15a46:	fb0e f907 	mul.w	r9, lr, r7
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
   15a4a:	f88c 3342 	strb.w	r3, [ip, #834]	; 0x342
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);
   15a4e:	7863      	ldrb	r3, [r4, #1]
   15a50:	f88c 3343 	strb.w	r3, [ip, #835]	; 0x343
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);
   15a54:	78a3      	ldrb	r3, [r4, #2]
   15a56:	f88c 3344 	strb.w	r3, [ip, #836]	; 0x344
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);
   15a5a:	78e3      	ldrb	r3, [r4, #3]
   15a5c:	f88c 3345 	strb.w	r3, [ip, #837]	; 0x345
  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);
   15a60:	f894 8004 	ldrb.w	r8, [r4, #4]
   15a64:	f88c 8346 	strb.w	r8, [ip, #838]	; 0x346
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);
   15a68:	7963      	ldrb	r3, [r4, #5]
   15a6a:	f88c 3347 	strb.w	r3, [ip, #839]	; 0x347
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);
   15a6e:	79a3      	ldrb	r3, [r4, #6]
   15a70:	f88c 3348 	strb.w	r3, [ip, #840]	; 0x348
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);
   15a74:	79e3      	ldrb	r3, [r4, #7]
   15a76:	f88c 3349 	strb.w	r3, [ip, #841]	; 0x349
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8);
   15a7a:	7a23      	ldrb	r3, [r4, #8]
   15a7c:	f88c 334a 	strb.w	r3, [ip, #842]	; 0x34a
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
   15a80:	4290      	cmp	r0, r2
   15a82:	d922      	bls.n	15aca <USBH_Get_CfgDesc+0x26e>
   15a84:	4541      	cmp	r1, r8
   15a86:	d220      	bcs.n	15aca <USBH_Get_CfgDesc+0x26e>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a88:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
   15a8a:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a8c:	4413      	add	r3, r2
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
   15a8e:	7866      	ldrb	r6, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a90:	b29a      	uxth	r2, r3
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
   15a92:	2e05      	cmp	r6, #5
   15a94:	d1f4      	bne.n	15a80 <USBH_Get_CfgDesc+0x224>
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   15a96:	3101      	adds	r1, #1
   15a98:	7826      	ldrb	r6, [r4, #0]
   15a9a:	eb09 03c1 	add.w	r3, r9, r1, lsl #3
            ep_ix++;
   15a9e:	b2c9      	uxtb	r1, r1
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   15aa0:	442b      	add	r3, r5
   15aa2:	f883 6344 	strb.w	r6, [r3, #836]	; 0x344
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1);
   15aa6:	7866      	ldrb	r6, [r4, #1]
   15aa8:	f883 6345 	strb.w	r6, [r3, #837]	; 0x345
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2);
   15aac:	78a6      	ldrb	r6, [r4, #2]
   15aae:	f883 6346 	strb.w	r6, [r3, #838]	; 0x346
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3);
   15ab2:	78e6      	ldrb	r6, [r4, #3]
   15ab4:	f883 6347 	strb.w	r6, [r3, #839]	; 0x347
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4);
   15ab8:	88a6      	ldrh	r6, [r4, #4]
   15aba:	f8a3 6348 	strh.w	r6, [r3, #840]	; 0x348
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6);
   15abe:	79a6      	ldrb	r6, [r4, #6]
   15ac0:	f883 634a 	strb.w	r6, [r3, #842]	; 0x34a
   15ac4:	f89c 8346 	ldrb.w	r8, [ip, #838]	; 0x346
   15ac8:	e7da      	b.n	15a80 <USBH_Get_CfgDesc+0x224>
   15aca:	3701      	adds	r7, #1
   15acc:	f10c 0c2a 	add.w	ip, ip, #42	; 0x2a
   15ad0:	e7a3      	b.n	15a1a <USBH_Get_CfgDesc+0x1be>
          if (direction == USB_D2H)
   15ad2:	2b00      	cmp	r3, #0
   15ad4:	db83      	blt.n	159de <USBH_Get_CfgDesc+0x182>
            phost->Control.state = CTRL_STATUS_IN;
   15ad6:	2307      	movs	r3, #7
   15ad8:	2001      	movs	r0, #1
   15ada:	762b      	strb	r3, [r5, #24]
   15adc:	e6ca      	b.n	15874 <USBH_Get_CfgDesc+0x18>
        if (phost->Control.setup.b.wLength.w != 0U)
   15ade:	8aea      	ldrh	r2, [r5, #22]
   15ae0:	f995 3010 	ldrsb.w	r3, [r5, #16]
   15ae4:	2a00      	cmp	r2, #0
   15ae6:	d0f4      	beq.n	15ad2 <USBH_Get_CfgDesc+0x276>
          if (direction == USB_D2H)
   15ae8:	2b00      	cmp	r3, #0
   15aea:	db08      	blt.n	15afe <USBH_Get_CfgDesc+0x2a2>
            phost->Control.state = CTRL_DATA_OUT;
   15aec:	2305      	movs	r3, #5
   15aee:	2001      	movs	r0, #1
   15af0:	762b      	strb	r3, [r5, #24]
   15af2:	e6bf      	b.n	15874 <USBH_Get_CfgDesc+0x18>
        phost->Control.state = CTRL_SETUP;
   15af4:	2301      	movs	r3, #1
   15af6:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
   15af8:	4618      	mov	r0, r3
   15afa:	70ab      	strb	r3, [r5, #2]
   15afc:	e6ba      	b.n	15874 <USBH_Get_CfgDesc+0x18>
            phost->Control.state = CTRL_DATA_IN;
   15afe:	2303      	movs	r3, #3
   15b00:	762b      	strb	r3, [r5, #24]
   15b02:	e6b7      	b.n	15874 <USBH_Get_CfgDesc+0x18>
   15b04:	02000680 	.word	0x02000680

00015b08 <USBH_Get_StringDesc>:
{
   15b08:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (phost->RequestState == CMD_SEND)
   15b0a:	7885      	ldrb	r5, [r0, #2]
{
   15b0c:	b085      	sub	sp, #20
   15b0e:	4604      	mov	r4, r0
                                   phost->device.Data, length)) == USBH_OK)
   15b10:	f500 768e 	add.w	r6, r0, #284	; 0x11c
  if (phost->RequestState == CMD_SEND)
   15b14:	2d01      	cmp	r5, #1
   15b16:	d010      	beq.n	15b3a <USBH_Get_StringDesc+0x32>
  switch (phost->RequestState)
   15b18:	2d02      	cmp	r5, #2
   15b1a:	d002      	beq.n	15b22 <USBH_Get_StringDesc+0x1a>
  status = USBH_BUSY;
   15b1c:	2001      	movs	r0, #1
}
   15b1e:	b005      	add	sp, #20
   15b20:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (phost->Control.state)
   15b22:	7e01      	ldrb	r1, [r0, #24]
   15b24:	3901      	subs	r1, #1
   15b26:	290a      	cmp	r1, #10
   15b28:	d8f8      	bhi.n	15b1c <USBH_Get_StringDesc+0x14>
   15b2a:	e8df f001 	tbb	[pc, r1]
   15b2e:	3e34      	.short	0x3e34
   15b30:	74655a4d 	.word	0x74655a4d
   15b34:	b5a69184 	.word	0xb5a69184
   15b38:	19          	.byte	0x19
   15b39:	00          	.byte	0x00
  if ((status = USBH_GetDescriptor(phost,
   15b3a:	f441 7140 	orr.w	r1, r1, #768	; 0x300
    phost->Control.setup.b.wLength.w = length;
   15b3e:	82c3      	strh	r3, [r0, #22]
      phost->Control.buff = buff;
   15b40:	6086      	str	r6, [r0, #8]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   15b42:	f44f 6cd0 	mov.w	ip, #1664	; 0x680
    phost->Control.setup.b.wValue.w = value_idx;
   15b46:	8241      	strh	r1, [r0, #18]
      phost->Control.setup.b.wIndex.w = 0x0409U;
   15b48:	f240 4709 	movw	r7, #1033	; 0x409
      phost->Control.length = length;
   15b4c:	8183      	strh	r3, [r0, #12]
      phost->RequestState = CMD_WAIT;
   15b4e:	2202      	movs	r2, #2
      status = USBH_BUSY;
   15b50:	4628      	mov	r0, r5
      phost->Control.state = CTRL_SETUP;
   15b52:	7625      	strb	r5, [r4, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   15b54:	f8a4 c010 	strh.w	ip, [r4, #16]
      phost->Control.setup.b.wIndex.w = 0x0409U;
   15b58:	82a7      	strh	r7, [r4, #20]
      phost->RequestState = CMD_WAIT;
   15b5a:	70a2      	strb	r2, [r4, #2]
}
   15b5c:	b005      	add	sp, #20
   15b5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   15b60:	7e63      	ldrb	r3, [r4, #25]
   15b62:	3301      	adds	r3, #1
   15b64:	b2db      	uxtb	r3, r3
   15b66:	2b02      	cmp	r3, #2
   15b68:	7663      	strb	r3, [r4, #25]
   15b6a:	f240 80d3 	bls.w	15d14 <USBH_Get_StringDesc+0x20c>
        phost->Control.errorcount = 0U;
   15b6e:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   15b70:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   15b74:	2106      	movs	r1, #6
   15b76:	4620      	mov	r0, r4
   15b78:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15b7a:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   15b7c:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15b7e:	4620      	mov	r0, r4
   15b80:	f000 fd14 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   15b84:	7921      	ldrb	r1, [r4, #4]
   15b86:	4620      	mov	r0, r4
   15b88:	f000 fd10 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   15b8c:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   15b8e:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   15b90:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   15b92:	70a3      	strb	r3, [r4, #2]
   15b94:	e7c3      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   15b96:	7962      	ldrb	r2, [r4, #5]
   15b98:	f104 0110 	add.w	r1, r4, #16
   15b9c:	4620      	mov	r0, r4
   15b9e:	f000 fc59 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   15ba2:	2302      	movs	r3, #2
   15ba4:	2001      	movs	r0, #1
   15ba6:	7623      	strb	r3, [r4, #24]
   15ba8:	e7b9      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15baa:	7961      	ldrb	r1, [r4, #5]
   15bac:	4620      	mov	r0, r4
   15bae:	f00d ffc7 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15bb2:	2801      	cmp	r0, #1
   15bb4:	f000 80a3 	beq.w	15cfe <USBH_Get_StringDesc+0x1f6>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   15bb8:	2804      	cmp	r0, #4
   15bba:	d001      	beq.n	15bc0 <USBH_Get_StringDesc+0xb8>
   15bbc:	2802      	cmp	r0, #2
   15bbe:	d1ad      	bne.n	15b1c <USBH_Get_StringDesc+0x14>
          phost->Control.state = CTRL_ERROR;
   15bc0:	230b      	movs	r3, #11
   15bc2:	2001      	movs	r0, #1
   15bc4:	7623      	strb	r3, [r4, #24]
   15bc6:	e7aa      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      phost->Control.timer = (uint16_t)phost->Timer;
   15bc8:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15bcc:	4620      	mov	r0, r4
   15bce:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   15bd0:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15bd2:	68a1      	ldr	r1, [r4, #8]
   15bd4:	89a2      	ldrh	r2, [r4, #12]
   15bd6:	f000 fc65 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   15bda:	2304      	movs	r3, #4
   15bdc:	2001      	movs	r0, #1
   15bde:	7623      	strb	r3, [r4, #24]
   15be0:	e79d      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15be2:	7921      	ldrb	r1, [r4, #4]
   15be4:	4620      	mov	r0, r4
   15be6:	f00d ffab 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15bea:	2801      	cmp	r0, #1
   15bec:	d060      	beq.n	15cb0 <USBH_Get_StringDesc+0x1a8>
      if (URB_Status == USBH_URB_STALL)
   15bee:	2805      	cmp	r0, #5
   15bf0:	d03d      	beq.n	15c6e <USBH_Get_StringDesc+0x166>
        if (URB_Status == USBH_URB_ERROR)
   15bf2:	2804      	cmp	r0, #4
   15bf4:	d192      	bne.n	15b1c <USBH_Get_StringDesc+0x14>
   15bf6:	e7e3      	b.n	15bc0 <USBH_Get_StringDesc+0xb8>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   15bf8:	2501      	movs	r5, #1
   15bfa:	7963      	ldrb	r3, [r4, #5]
   15bfc:	89a2      	ldrh	r2, [r4, #12]
   15bfe:	4620      	mov	r0, r4
   15c00:	68a1      	ldr	r1, [r4, #8]
   15c02:	9500      	str	r5, [sp, #0]
   15c04:	f000 fc36 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15c08:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15c0c:	2306      	movs	r3, #6
   15c0e:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   15c10:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15c12:	7623      	strb	r3, [r4, #24]
   15c14:	e783      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15c16:	7961      	ldrb	r1, [r4, #5]
   15c18:	4620      	mov	r0, r4
   15c1a:	f00d ff91 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15c1e:	2801      	cmp	r0, #1
   15c20:	d069      	beq.n	15cf6 <USBH_Get_StringDesc+0x1ee>
      else if (URB_Status == USBH_URB_STALL)
   15c22:	2805      	cmp	r0, #5
   15c24:	d023      	beq.n	15c6e <USBH_Get_StringDesc+0x166>
      else if (URB_Status == USBH_URB_NOTREADY)
   15c26:	2802      	cmp	r0, #2
   15c28:	d070      	beq.n	15d0c <USBH_Get_StringDesc+0x204>
        if (URB_Status == USBH_URB_ERROR)
   15c2a:	2804      	cmp	r0, #4
   15c2c:	f47f af76 	bne.w	15b1c <USBH_Get_StringDesc+0x14>
          phost->Control.state = CTRL_ERROR;
   15c30:	230b      	movs	r3, #11
   15c32:	7623      	strb	r3, [r4, #24]
   15c34:	e7ab      	b.n	15b8e <USBH_Get_StringDesc+0x86>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   15c36:	2200      	movs	r2, #0
   15c38:	7923      	ldrb	r3, [r4, #4]
   15c3a:	4620      	mov	r0, r4
   15c3c:	4611      	mov	r1, r2
   15c3e:	f000 fc31 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15c42:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15c46:	2308      	movs	r3, #8
   15c48:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   15c4a:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15c4c:	7623      	strb	r3, [r4, #24]
   15c4e:	e766      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15c50:	7921      	ldrb	r1, [r4, #4]
   15c52:	4620      	mov	r0, r4
   15c54:	e9cd 2302 	strd	r2, r3, [sp, #8]
   15c58:	f00d ff72 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15c5c:	2801      	cmp	r0, #1
   15c5e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   15c62:	d029      	beq.n	15cb8 <USBH_Get_StringDesc+0x1b0>
      else if (URB_Status == USBH_URB_ERROR)
   15c64:	2804      	cmp	r0, #4
   15c66:	d0ab      	beq.n	15bc0 <USBH_Get_StringDesc+0xb8>
        if (URB_Status == USBH_URB_STALL)
   15c68:	2805      	cmp	r0, #5
   15c6a:	f47f af57 	bne.w	15b1c <USBH_Get_StringDesc+0x14>
        phost->RequestState = CMD_SEND;
   15c6e:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   15c70:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
   15c72:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   15c74:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   15c76:	7623      	strb	r3, [r4, #24]
   15c78:	e751      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   15c7a:	2200      	movs	r2, #0
   15c7c:	2501      	movs	r5, #1
   15c7e:	7963      	ldrb	r3, [r4, #5]
   15c80:	4620      	mov	r0, r4
   15c82:	4611      	mov	r1, r2
   15c84:	9500      	str	r5, [sp, #0]
   15c86:	f000 fbf5 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15c8a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   15c8e:	230a      	movs	r3, #10
   15c90:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   15c92:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   15c94:	7623      	strb	r3, [r4, #24]
   15c96:	e742      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15c98:	7961      	ldrb	r1, [r4, #5]
   15c9a:	4620      	mov	r0, r4
   15c9c:	e9cd 2302 	strd	r2, r3, [sp, #8]
   15ca0:	f00d ff4e 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15ca4:	2801      	cmp	r0, #1
   15ca6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   15caa:	d005      	beq.n	15cb8 <USBH_Get_StringDesc+0x1b0>
      else if (URB_Status == USBH_URB_NOTREADY)
   15cac:	2802      	cmp	r0, #2
   15cae:	d1a0      	bne.n	15bf2 <USBH_Get_StringDesc+0xea>
            phost->Control.state = CTRL_STATUS_OUT;
   15cb0:	2309      	movs	r3, #9
   15cb2:	2001      	movs	r0, #1
   15cb4:	7623      	strb	r3, [r4, #24]
   15cb6:	e732      	b.n	15b1e <USBH_Get_StringDesc+0x16>
  if (psrc[1] == USB_DESC_TYPE_STRING)
   15cb8:	f894 111d 	ldrb.w	r1, [r4, #285]	; 0x11d
        phost->RequestState = CMD_SEND;
   15cbc:	2501      	movs	r5, #1
        phost->Control.state = CTRL_IDLE;
   15cbe:	2000      	movs	r0, #0
  if (psrc[1] == USB_DESC_TYPE_STRING)
   15cc0:	2903      	cmp	r1, #3
        phost->RequestState = CMD_SEND;
   15cc2:	70a5      	strb	r5, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   15cc4:	7620      	strb	r0, [r4, #24]
  if (psrc[1] == USB_DESC_TYPE_STRING)
   15cc6:	f47f af2a 	bne.w	15b1e <USBH_Get_StringDesc+0x16>
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
   15cca:	f894 111c 	ldrb.w	r1, [r4, #284]	; 0x11c
   15cce:	3902      	subs	r1, #2
   15cd0:	428b      	cmp	r3, r1
   15cd2:	bf28      	it	cs
   15cd4:	460b      	movcs	r3, r1
   15cd6:	b299      	uxth	r1, r3
    for (idx = 0U; idx < strlength; idx += 2U)
   15cd8:	b13b      	cbz	r3, 15cea <USBH_Get_StringDesc+0x1e2>
      *pdest =  psrc[idx];
   15cda:	1833      	adds	r3, r6, r0
    for (idx = 0U; idx < strlength; idx += 2U)
   15cdc:	3002      	adds	r0, #2
   15cde:	b280      	uxth	r0, r0
      *pdest =  psrc[idx];
   15ce0:	789b      	ldrb	r3, [r3, #2]
    for (idx = 0U; idx < strlength; idx += 2U)
   15ce2:	4281      	cmp	r1, r0
      *pdest =  psrc[idx];
   15ce4:	f802 3b01 	strb.w	r3, [r2], #1
    for (idx = 0U; idx < strlength; idx += 2U)
   15ce8:	d8f7      	bhi.n	15cda <USBH_Get_StringDesc+0x1d2>
    *pdest = 0U; /* mark end of string */
   15cea:	2000      	movs	r0, #0
   15cec:	7010      	strb	r0, [r2, #0]
}
   15cee:	b005      	add	sp, #20
   15cf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if (direction == USB_D2H)
   15cf2:	2a00      	cmp	r2, #0
   15cf4:	dbdc      	blt.n	15cb0 <USBH_Get_StringDesc+0x1a8>
            phost->Control.state = CTRL_STATUS_IN;
   15cf6:	2307      	movs	r3, #7
   15cf8:	2001      	movs	r0, #1
   15cfa:	7623      	strb	r3, [r4, #24]
   15cfc:	e70f      	b.n	15b1e <USBH_Get_StringDesc+0x16>
        if (phost->Control.setup.b.wLength.w != 0U)
   15cfe:	8ae3      	ldrh	r3, [r4, #22]
   15d00:	f994 2010 	ldrsb.w	r2, [r4, #16]
   15d04:	2b00      	cmp	r3, #0
   15d06:	d0f4      	beq.n	15cf2 <USBH_Get_StringDesc+0x1ea>
          if (direction == USB_D2H)
   15d08:	2a00      	cmp	r2, #0
   15d0a:	db08      	blt.n	15d1e <USBH_Get_StringDesc+0x216>
            phost->Control.state = CTRL_DATA_OUT;
   15d0c:	2305      	movs	r3, #5
   15d0e:	2001      	movs	r0, #1
   15d10:	7623      	strb	r3, [r4, #24]
   15d12:	e704      	b.n	15b1e <USBH_Get_StringDesc+0x16>
        phost->Control.state = CTRL_SETUP;
   15d14:	2301      	movs	r3, #1
   15d16:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   15d18:	4618      	mov	r0, r3
   15d1a:	70a3      	strb	r3, [r4, #2]
   15d1c:	e6ff      	b.n	15b1e <USBH_Get_StringDesc+0x16>
            phost->Control.state = CTRL_DATA_IN;
   15d1e:	2303      	movs	r3, #3
   15d20:	7623      	strb	r3, [r4, #24]
   15d22:	e6fc      	b.n	15b1e <USBH_Get_StringDesc+0x16>

00015d24 <USBH_SetAddress>:
{
   15d24:	b530      	push	{r4, r5, lr}
   15d26:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   15d28:	7880      	ldrb	r0, [r0, #2]
{
   15d2a:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   15d2c:	2801      	cmp	r0, #1
   15d2e:	d011      	beq.n	15d54 <USBH_SetAddress+0x30>
  switch (phost->RequestState)
   15d30:	2802      	cmp	r0, #2
   15d32:	d002      	beq.n	15d3a <USBH_SetAddress+0x16>
  status = USBH_BUSY;
   15d34:	2001      	movs	r0, #1
}
   15d36:	b003      	add	sp, #12
   15d38:	bd30      	pop	{r4, r5, pc}
   15d3a:	461c      	mov	r4, r3
  switch (phost->Control.state)
   15d3c:	7e1b      	ldrb	r3, [r3, #24]
   15d3e:	3b01      	subs	r3, #1
   15d40:	2b0a      	cmp	r3, #10
   15d42:	d8f7      	bhi.n	15d34 <USBH_SetAddress+0x10>
   15d44:	e8df f003 	tbb	[pc, r3]
   15d48:	5447382e 	.word	0x5447382e
   15d4c:	8b7e6e5f 	.word	0x8b7e6e5f
   15d50:	ac9d      	.short	0xac9d
   15d52:	13          	.byte	0x13
   15d53:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
   15d54:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
   15d56:	f44f 65a0 	mov.w	r5, #1280	; 0x500
      phost->RequestState = CMD_WAIT;
   15d5a:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
   15d5c:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
   15d5e:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
   15d60:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
   15d62:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
   15d64:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   15d66:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   15d68:	709c      	strb	r4, [r3, #2]
}
   15d6a:	b003      	add	sp, #12
   15d6c:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   15d6e:	7e63      	ldrb	r3, [r4, #25]
   15d70:	3301      	adds	r3, #1
   15d72:	b2db      	uxtb	r3, r3
   15d74:	2b02      	cmp	r3, #2
   15d76:	7663      	strb	r3, [r4, #25]
   15d78:	f240 80b1 	bls.w	15ede <USBH_SetAddress+0x1ba>
        phost->Control.errorcount = 0U;
   15d7c:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   15d7e:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   15d82:	2106      	movs	r1, #6
   15d84:	4620      	mov	r0, r4
   15d86:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15d88:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   15d8a:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15d8c:	4620      	mov	r0, r4
   15d8e:	f000 fc0d 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   15d92:	7921      	ldrb	r1, [r4, #4]
   15d94:	4620      	mov	r0, r4
   15d96:	f000 fc09 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   15d9a:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   15d9c:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   15d9e:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   15da0:	70a3      	strb	r3, [r4, #2]
   15da2:	e7c8      	b.n	15d36 <USBH_SetAddress+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   15da4:	7962      	ldrb	r2, [r4, #5]
   15da6:	f104 0110 	add.w	r1, r4, #16
   15daa:	4620      	mov	r0, r4
   15dac:	f000 fb52 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   15db0:	2302      	movs	r3, #2
   15db2:	2001      	movs	r0, #1
   15db4:	7623      	strb	r3, [r4, #24]
   15db6:	e7be      	b.n	15d36 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15db8:	7961      	ldrb	r1, [r4, #5]
   15dba:	4620      	mov	r0, r4
   15dbc:	f00d fec0 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15dc0:	2801      	cmp	r0, #1
   15dc2:	f000 8081 	beq.w	15ec8 <USBH_SetAddress+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   15dc6:	2804      	cmp	r0, #4
   15dc8:	d001      	beq.n	15dce <USBH_SetAddress+0xaa>
   15dca:	2802      	cmp	r0, #2
   15dcc:	d1b2      	bne.n	15d34 <USBH_SetAddress+0x10>
          phost->Control.state = CTRL_ERROR;
   15dce:	230b      	movs	r3, #11
   15dd0:	2001      	movs	r0, #1
   15dd2:	7623      	strb	r3, [r4, #24]
   15dd4:	e7af      	b.n	15d36 <USBH_SetAddress+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   15dd6:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15dda:	4620      	mov	r0, r4
   15ddc:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   15dde:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15de0:	68a1      	ldr	r1, [r4, #8]
   15de2:	89a2      	ldrh	r2, [r4, #12]
   15de4:	f000 fb5e 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   15de8:	2304      	movs	r3, #4
   15dea:	2001      	movs	r0, #1
   15dec:	7623      	strb	r3, [r4, #24]
   15dee:	e7a2      	b.n	15d36 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15df0:	7921      	ldrb	r1, [r4, #4]
   15df2:	4620      	mov	r0, r4
   15df4:	f00d fea4 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15df8:	2801      	cmp	r0, #1
   15dfa:	d059      	beq.n	15eb0 <USBH_SetAddress+0x18c>
      if (URB_Status == USBH_URB_STALL)
   15dfc:	2805      	cmp	r0, #5
   15dfe:	d039      	beq.n	15e74 <USBH_SetAddress+0x150>
        if (URB_Status == USBH_URB_ERROR)
   15e00:	2804      	cmp	r0, #4
   15e02:	d197      	bne.n	15d34 <USBH_SetAddress+0x10>
   15e04:	e7e3      	b.n	15dce <USBH_SetAddress+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   15e06:	2501      	movs	r5, #1
   15e08:	7963      	ldrb	r3, [r4, #5]
   15e0a:	89a2      	ldrh	r2, [r4, #12]
   15e0c:	4620      	mov	r0, r4
   15e0e:	68a1      	ldr	r1, [r4, #8]
   15e10:	9500      	str	r5, [sp, #0]
   15e12:	f000 fb2f 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15e16:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15e1a:	2306      	movs	r3, #6
   15e1c:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   15e1e:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15e20:	7623      	strb	r3, [r4, #24]
   15e22:	e788      	b.n	15d36 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15e24:	7961      	ldrb	r1, [r4, #5]
   15e26:	4620      	mov	r0, r4
   15e28:	f00d fe8a 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15e2c:	2801      	cmp	r0, #1
   15e2e:	d047      	beq.n	15ec0 <USBH_SetAddress+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   15e30:	2805      	cmp	r0, #5
   15e32:	d01f      	beq.n	15e74 <USBH_SetAddress+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   15e34:	2802      	cmp	r0, #2
   15e36:	d04e      	beq.n	15ed6 <USBH_SetAddress+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   15e38:	2804      	cmp	r0, #4
   15e3a:	f47f af7b 	bne.w	15d34 <USBH_SetAddress+0x10>
          phost->Control.state = CTRL_ERROR;
   15e3e:	230b      	movs	r3, #11
   15e40:	7623      	strb	r3, [r4, #24]
   15e42:	e7ab      	b.n	15d9c <USBH_SetAddress+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   15e44:	2200      	movs	r2, #0
   15e46:	7923      	ldrb	r3, [r4, #4]
   15e48:	4620      	mov	r0, r4
   15e4a:	4611      	mov	r1, r2
   15e4c:	f000 fb2a 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15e50:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15e54:	2308      	movs	r3, #8
   15e56:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   15e58:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15e5a:	7623      	strb	r3, [r4, #24]
   15e5c:	e76b      	b.n	15d36 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15e5e:	7921      	ldrb	r1, [r4, #4]
   15e60:	4620      	mov	r0, r4
   15e62:	f00d fe6d 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15e66:	2801      	cmp	r0, #1
   15e68:	d026      	beq.n	15eb8 <USBH_SetAddress+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   15e6a:	2804      	cmp	r0, #4
   15e6c:	d0af      	beq.n	15dce <USBH_SetAddress+0xaa>
        if (URB_Status == USBH_URB_STALL)
   15e6e:	2805      	cmp	r0, #5
   15e70:	f47f af60 	bne.w	15d34 <USBH_SetAddress+0x10>
        status = USBH_NOT_SUPPORTED;
   15e74:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   15e76:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   15e78:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   15e7a:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   15e7c:	7623      	strb	r3, [r4, #24]
}
   15e7e:	b003      	add	sp, #12
   15e80:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   15e82:	2200      	movs	r2, #0
   15e84:	2501      	movs	r5, #1
   15e86:	7963      	ldrb	r3, [r4, #5]
   15e88:	4620      	mov	r0, r4
   15e8a:	4611      	mov	r1, r2
   15e8c:	9500      	str	r5, [sp, #0]
   15e8e:	f000 faf1 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15e92:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   15e96:	230a      	movs	r3, #10
   15e98:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   15e9a:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   15e9c:	7623      	strb	r3, [r4, #24]
   15e9e:	e74a      	b.n	15d36 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15ea0:	7961      	ldrb	r1, [r4, #5]
   15ea2:	4620      	mov	r0, r4
   15ea4:	f00d fe4c 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15ea8:	2801      	cmp	r0, #1
   15eaa:	d005      	beq.n	15eb8 <USBH_SetAddress+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   15eac:	2802      	cmp	r0, #2
   15eae:	d1a7      	bne.n	15e00 <USBH_SetAddress+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   15eb0:	2309      	movs	r3, #9
   15eb2:	2001      	movs	r0, #1
   15eb4:	7623      	strb	r3, [r4, #24]
   15eb6:	e73e      	b.n	15d36 <USBH_SetAddress+0x12>
        status = USBH_OK;
   15eb8:	2000      	movs	r0, #0
   15eba:	e7dc      	b.n	15e76 <USBH_SetAddress+0x152>
          if (direction == USB_D2H)
   15ebc:	2a00      	cmp	r2, #0
   15ebe:	dbf7      	blt.n	15eb0 <USBH_SetAddress+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   15ec0:	2307      	movs	r3, #7
   15ec2:	2001      	movs	r0, #1
   15ec4:	7623      	strb	r3, [r4, #24]
   15ec6:	e736      	b.n	15d36 <USBH_SetAddress+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   15ec8:	8ae3      	ldrh	r3, [r4, #22]
   15eca:	f994 2010 	ldrsb.w	r2, [r4, #16]
   15ece:	2b00      	cmp	r3, #0
   15ed0:	d0f4      	beq.n	15ebc <USBH_SetAddress+0x198>
          if (direction == USB_D2H)
   15ed2:	2a00      	cmp	r2, #0
   15ed4:	db08      	blt.n	15ee8 <USBH_SetAddress+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   15ed6:	2305      	movs	r3, #5
   15ed8:	2001      	movs	r0, #1
   15eda:	7623      	strb	r3, [r4, #24]
   15edc:	e72b      	b.n	15d36 <USBH_SetAddress+0x12>
        phost->Control.state = CTRL_SETUP;
   15ede:	2301      	movs	r3, #1
   15ee0:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   15ee2:	4618      	mov	r0, r3
   15ee4:	70a3      	strb	r3, [r4, #2]
   15ee6:	e726      	b.n	15d36 <USBH_SetAddress+0x12>
            phost->Control.state = CTRL_DATA_IN;
   15ee8:	2303      	movs	r3, #3
   15eea:	7623      	strb	r3, [r4, #24]
   15eec:	e723      	b.n	15d36 <USBH_SetAddress+0x12>
   15eee:	bf00      	nop

00015ef0 <USBH_SetCfg>:
{
   15ef0:	b530      	push	{r4, r5, lr}
   15ef2:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   15ef4:	7880      	ldrb	r0, [r0, #2]
{
   15ef6:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   15ef8:	2801      	cmp	r0, #1
   15efa:	d011      	beq.n	15f20 <USBH_SetCfg+0x30>
  switch (phost->RequestState)
   15efc:	2802      	cmp	r0, #2
   15efe:	d002      	beq.n	15f06 <USBH_SetCfg+0x16>
  status = USBH_BUSY;
   15f00:	2001      	movs	r0, #1
}
   15f02:	b003      	add	sp, #12
   15f04:	bd30      	pop	{r4, r5, pc}
   15f06:	461c      	mov	r4, r3
  switch (phost->Control.state)
   15f08:	7e1b      	ldrb	r3, [r3, #24]
   15f0a:	3b01      	subs	r3, #1
   15f0c:	2b0a      	cmp	r3, #10
   15f0e:	d8f7      	bhi.n	15f00 <USBH_SetCfg+0x10>
   15f10:	e8df f003 	tbb	[pc, r3]
   15f14:	5447382e 	.word	0x5447382e
   15f18:	8b7e6e5f 	.word	0x8b7e6e5f
   15f1c:	ac9d      	.short	0xac9d
   15f1e:	13          	.byte	0x13
   15f1f:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
   15f20:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   15f22:	f44f 6510 	mov.w	r5, #2304	; 0x900
      phost->RequestState = CMD_WAIT;
   15f26:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = cfg_idx;
   15f28:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
   15f2a:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   15f2c:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
   15f2e:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
   15f30:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   15f32:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   15f34:	709c      	strb	r4, [r3, #2]
}
   15f36:	b003      	add	sp, #12
   15f38:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   15f3a:	7e63      	ldrb	r3, [r4, #25]
   15f3c:	3301      	adds	r3, #1
   15f3e:	b2db      	uxtb	r3, r3
   15f40:	2b02      	cmp	r3, #2
   15f42:	7663      	strb	r3, [r4, #25]
   15f44:	f240 80b1 	bls.w	160aa <USBH_SetCfg+0x1ba>
        phost->Control.errorcount = 0U;
   15f48:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   15f4a:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   15f4e:	2106      	movs	r1, #6
   15f50:	4620      	mov	r0, r4
   15f52:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15f54:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   15f56:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15f58:	4620      	mov	r0, r4
   15f5a:	f000 fb27 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   15f5e:	7921      	ldrb	r1, [r4, #4]
   15f60:	4620      	mov	r0, r4
   15f62:	f000 fb23 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   15f66:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   15f68:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   15f6a:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   15f6c:	70a3      	strb	r3, [r4, #2]
   15f6e:	e7c8      	b.n	15f02 <USBH_SetCfg+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   15f70:	7962      	ldrb	r2, [r4, #5]
   15f72:	f104 0110 	add.w	r1, r4, #16
   15f76:	4620      	mov	r0, r4
   15f78:	f000 fa6c 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   15f7c:	2302      	movs	r3, #2
   15f7e:	2001      	movs	r0, #1
   15f80:	7623      	strb	r3, [r4, #24]
   15f82:	e7be      	b.n	15f02 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15f84:	7961      	ldrb	r1, [r4, #5]
   15f86:	4620      	mov	r0, r4
   15f88:	f00d fdda 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15f8c:	2801      	cmp	r0, #1
   15f8e:	f000 8081 	beq.w	16094 <USBH_SetCfg+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   15f92:	2804      	cmp	r0, #4
   15f94:	d001      	beq.n	15f9a <USBH_SetCfg+0xaa>
   15f96:	2802      	cmp	r0, #2
   15f98:	d1b2      	bne.n	15f00 <USBH_SetCfg+0x10>
          phost->Control.state = CTRL_ERROR;
   15f9a:	230b      	movs	r3, #11
   15f9c:	2001      	movs	r0, #1
   15f9e:	7623      	strb	r3, [r4, #24]
   15fa0:	e7af      	b.n	15f02 <USBH_SetCfg+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   15fa2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15fa6:	4620      	mov	r0, r4
   15fa8:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   15faa:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15fac:	68a1      	ldr	r1, [r4, #8]
   15fae:	89a2      	ldrh	r2, [r4, #12]
   15fb0:	f000 fa78 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   15fb4:	2304      	movs	r3, #4
   15fb6:	2001      	movs	r0, #1
   15fb8:	7623      	strb	r3, [r4, #24]
   15fba:	e7a2      	b.n	15f02 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15fbc:	7921      	ldrb	r1, [r4, #4]
   15fbe:	4620      	mov	r0, r4
   15fc0:	f00d fdbe 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15fc4:	2801      	cmp	r0, #1
   15fc6:	d059      	beq.n	1607c <USBH_SetCfg+0x18c>
      if (URB_Status == USBH_URB_STALL)
   15fc8:	2805      	cmp	r0, #5
   15fca:	d039      	beq.n	16040 <USBH_SetCfg+0x150>
        if (URB_Status == USBH_URB_ERROR)
   15fcc:	2804      	cmp	r0, #4
   15fce:	d197      	bne.n	15f00 <USBH_SetCfg+0x10>
   15fd0:	e7e3      	b.n	15f9a <USBH_SetCfg+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   15fd2:	2501      	movs	r5, #1
   15fd4:	7963      	ldrb	r3, [r4, #5]
   15fd6:	89a2      	ldrh	r2, [r4, #12]
   15fd8:	4620      	mov	r0, r4
   15fda:	68a1      	ldr	r1, [r4, #8]
   15fdc:	9500      	str	r5, [sp, #0]
   15fde:	f000 fa49 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15fe2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15fe6:	2306      	movs	r3, #6
   15fe8:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   15fea:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15fec:	7623      	strb	r3, [r4, #24]
   15fee:	e788      	b.n	15f02 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15ff0:	7961      	ldrb	r1, [r4, #5]
   15ff2:	4620      	mov	r0, r4
   15ff4:	f00d fda4 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15ff8:	2801      	cmp	r0, #1
   15ffa:	d047      	beq.n	1608c <USBH_SetCfg+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   15ffc:	2805      	cmp	r0, #5
   15ffe:	d01f      	beq.n	16040 <USBH_SetCfg+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   16000:	2802      	cmp	r0, #2
   16002:	d04e      	beq.n	160a2 <USBH_SetCfg+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   16004:	2804      	cmp	r0, #4
   16006:	f47f af7b 	bne.w	15f00 <USBH_SetCfg+0x10>
          phost->Control.state = CTRL_ERROR;
   1600a:	230b      	movs	r3, #11
   1600c:	7623      	strb	r3, [r4, #24]
   1600e:	e7ab      	b.n	15f68 <USBH_SetCfg+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   16010:	2200      	movs	r2, #0
   16012:	7923      	ldrb	r3, [r4, #4]
   16014:	4620      	mov	r0, r4
   16016:	4611      	mov	r1, r2
   16018:	f000 fa44 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1601c:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   16020:	2308      	movs	r3, #8
   16022:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   16024:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   16026:	7623      	strb	r3, [r4, #24]
   16028:	e76b      	b.n	15f02 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1602a:	7921      	ldrb	r1, [r4, #4]
   1602c:	4620      	mov	r0, r4
   1602e:	f00d fd87 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16032:	2801      	cmp	r0, #1
   16034:	d026      	beq.n	16084 <USBH_SetCfg+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   16036:	2804      	cmp	r0, #4
   16038:	d0af      	beq.n	15f9a <USBH_SetCfg+0xaa>
        if (URB_Status == USBH_URB_STALL)
   1603a:	2805      	cmp	r0, #5
   1603c:	f47f af60 	bne.w	15f00 <USBH_SetCfg+0x10>
        status = USBH_NOT_SUPPORTED;
   16040:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   16042:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   16044:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   16046:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   16048:	7623      	strb	r3, [r4, #24]
}
   1604a:	b003      	add	sp, #12
   1604c:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   1604e:	2200      	movs	r2, #0
   16050:	2501      	movs	r5, #1
   16052:	7963      	ldrb	r3, [r4, #5]
   16054:	4620      	mov	r0, r4
   16056:	4611      	mov	r1, r2
   16058:	9500      	str	r5, [sp, #0]
   1605a:	f000 fa0b 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1605e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   16062:	230a      	movs	r3, #10
   16064:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   16066:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   16068:	7623      	strb	r3, [r4, #24]
   1606a:	e74a      	b.n	15f02 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   1606c:	7961      	ldrb	r1, [r4, #5]
   1606e:	4620      	mov	r0, r4
   16070:	f00d fd66 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16074:	2801      	cmp	r0, #1
   16076:	d005      	beq.n	16084 <USBH_SetCfg+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   16078:	2802      	cmp	r0, #2
   1607a:	d1a7      	bne.n	15fcc <USBH_SetCfg+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   1607c:	2309      	movs	r3, #9
   1607e:	2001      	movs	r0, #1
   16080:	7623      	strb	r3, [r4, #24]
   16082:	e73e      	b.n	15f02 <USBH_SetCfg+0x12>
        status = USBH_OK;
   16084:	2000      	movs	r0, #0
   16086:	e7dc      	b.n	16042 <USBH_SetCfg+0x152>
          if (direction == USB_D2H)
   16088:	2a00      	cmp	r2, #0
   1608a:	dbf7      	blt.n	1607c <USBH_SetCfg+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   1608c:	2307      	movs	r3, #7
   1608e:	2001      	movs	r0, #1
   16090:	7623      	strb	r3, [r4, #24]
   16092:	e736      	b.n	15f02 <USBH_SetCfg+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   16094:	8ae3      	ldrh	r3, [r4, #22]
   16096:	f994 2010 	ldrsb.w	r2, [r4, #16]
   1609a:	2b00      	cmp	r3, #0
   1609c:	d0f4      	beq.n	16088 <USBH_SetCfg+0x198>
          if (direction == USB_D2H)
   1609e:	2a00      	cmp	r2, #0
   160a0:	db08      	blt.n	160b4 <USBH_SetCfg+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   160a2:	2305      	movs	r3, #5
   160a4:	2001      	movs	r0, #1
   160a6:	7623      	strb	r3, [r4, #24]
   160a8:	e72b      	b.n	15f02 <USBH_SetCfg+0x12>
        phost->Control.state = CTRL_SETUP;
   160aa:	2301      	movs	r3, #1
   160ac:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   160ae:	4618      	mov	r0, r3
   160b0:	70a3      	strb	r3, [r4, #2]
   160b2:	e726      	b.n	15f02 <USBH_SetCfg+0x12>
            phost->Control.state = CTRL_DATA_IN;
   160b4:	2303      	movs	r3, #3
   160b6:	7623      	strb	r3, [r4, #24]
   160b8:	e723      	b.n	15f02 <USBH_SetCfg+0x12>
   160ba:	bf00      	nop

000160bc <USBH_SetFeature>:
{
   160bc:	b530      	push	{r4, r5, lr}
   160be:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   160c0:	7880      	ldrb	r0, [r0, #2]
{
   160c2:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   160c4:	2801      	cmp	r0, #1
   160c6:	d011      	beq.n	160ec <USBH_SetFeature+0x30>
  switch (phost->RequestState)
   160c8:	2802      	cmp	r0, #2
   160ca:	d002      	beq.n	160d2 <USBH_SetFeature+0x16>
  status = USBH_BUSY;
   160cc:	2001      	movs	r0, #1
}
   160ce:	b003      	add	sp, #12
   160d0:	bd30      	pop	{r4, r5, pc}
   160d2:	461c      	mov	r4, r3
  switch (phost->Control.state)
   160d4:	7e1b      	ldrb	r3, [r3, #24]
   160d6:	3b01      	subs	r3, #1
   160d8:	2b0a      	cmp	r3, #10
   160da:	d8f7      	bhi.n	160cc <USBH_SetFeature+0x10>
   160dc:	e8df f003 	tbb	[pc, r3]
   160e0:	5447382e 	.word	0x5447382e
   160e4:	8b7e6e5f 	.word	0x8b7e6e5f
   160e8:	ac9d      	.short	0xac9d
   160ea:	13          	.byte	0x13
   160eb:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
   160ec:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   160ee:	f44f 7540 	mov.w	r5, #768	; 0x300
      phost->RequestState = CMD_WAIT;
   160f2:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = wValue;
   160f4:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
   160f6:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   160f8:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
   160fa:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
   160fc:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   160fe:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   16100:	709c      	strb	r4, [r3, #2]
}
   16102:	b003      	add	sp, #12
   16104:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   16106:	7e63      	ldrb	r3, [r4, #25]
   16108:	3301      	adds	r3, #1
   1610a:	b2db      	uxtb	r3, r3
   1610c:	2b02      	cmp	r3, #2
   1610e:	7663      	strb	r3, [r4, #25]
   16110:	f240 80b1 	bls.w	16276 <USBH_SetFeature+0x1ba>
        phost->Control.errorcount = 0U;
   16114:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   16116:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   1611a:	2106      	movs	r1, #6
   1611c:	4620      	mov	r0, r4
   1611e:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   16120:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   16122:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   16124:	4620      	mov	r0, r4
   16126:	f000 fa41 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   1612a:	7921      	ldrb	r1, [r4, #4]
   1612c:	4620      	mov	r0, r4
   1612e:	f000 fa3d 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   16132:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   16134:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   16136:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   16138:	70a3      	strb	r3, [r4, #2]
   1613a:	e7c8      	b.n	160ce <USBH_SetFeature+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   1613c:	7962      	ldrb	r2, [r4, #5]
   1613e:	f104 0110 	add.w	r1, r4, #16
   16142:	4620      	mov	r0, r4
   16144:	f000 f986 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   16148:	2302      	movs	r3, #2
   1614a:	2001      	movs	r0, #1
   1614c:	7623      	strb	r3, [r4, #24]
   1614e:	e7be      	b.n	160ce <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   16150:	7961      	ldrb	r1, [r4, #5]
   16152:	4620      	mov	r0, r4
   16154:	f00d fcf4 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16158:	2801      	cmp	r0, #1
   1615a:	f000 8081 	beq.w	16260 <USBH_SetFeature+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   1615e:	2804      	cmp	r0, #4
   16160:	d001      	beq.n	16166 <USBH_SetFeature+0xaa>
   16162:	2802      	cmp	r0, #2
   16164:	d1b2      	bne.n	160cc <USBH_SetFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   16166:	230b      	movs	r3, #11
   16168:	2001      	movs	r0, #1
   1616a:	7623      	strb	r3, [r4, #24]
   1616c:	e7af      	b.n	160ce <USBH_SetFeature+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   1616e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   16172:	4620      	mov	r0, r4
   16174:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   16176:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   16178:	68a1      	ldr	r1, [r4, #8]
   1617a:	89a2      	ldrh	r2, [r4, #12]
   1617c:	f000 f992 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   16180:	2304      	movs	r3, #4
   16182:	2001      	movs	r0, #1
   16184:	7623      	strb	r3, [r4, #24]
   16186:	e7a2      	b.n	160ce <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   16188:	7921      	ldrb	r1, [r4, #4]
   1618a:	4620      	mov	r0, r4
   1618c:	f00d fcd8 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16190:	2801      	cmp	r0, #1
   16192:	d059      	beq.n	16248 <USBH_SetFeature+0x18c>
      if (URB_Status == USBH_URB_STALL)
   16194:	2805      	cmp	r0, #5
   16196:	d039      	beq.n	1620c <USBH_SetFeature+0x150>
        if (URB_Status == USBH_URB_ERROR)
   16198:	2804      	cmp	r0, #4
   1619a:	d197      	bne.n	160cc <USBH_SetFeature+0x10>
   1619c:	e7e3      	b.n	16166 <USBH_SetFeature+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   1619e:	2501      	movs	r5, #1
   161a0:	7963      	ldrb	r3, [r4, #5]
   161a2:	89a2      	ldrh	r2, [r4, #12]
   161a4:	4620      	mov	r0, r4
   161a6:	68a1      	ldr	r1, [r4, #8]
   161a8:	9500      	str	r5, [sp, #0]
   161aa:	f000 f963 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   161ae:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   161b2:	2306      	movs	r3, #6
   161b4:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   161b6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   161b8:	7623      	strb	r3, [r4, #24]
   161ba:	e788      	b.n	160ce <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   161bc:	7961      	ldrb	r1, [r4, #5]
   161be:	4620      	mov	r0, r4
   161c0:	f00d fcbe 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   161c4:	2801      	cmp	r0, #1
   161c6:	d047      	beq.n	16258 <USBH_SetFeature+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   161c8:	2805      	cmp	r0, #5
   161ca:	d01f      	beq.n	1620c <USBH_SetFeature+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   161cc:	2802      	cmp	r0, #2
   161ce:	d04e      	beq.n	1626e <USBH_SetFeature+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   161d0:	2804      	cmp	r0, #4
   161d2:	f47f af7b 	bne.w	160cc <USBH_SetFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   161d6:	230b      	movs	r3, #11
   161d8:	7623      	strb	r3, [r4, #24]
   161da:	e7ab      	b.n	16134 <USBH_SetFeature+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   161dc:	2200      	movs	r2, #0
   161de:	7923      	ldrb	r3, [r4, #4]
   161e0:	4620      	mov	r0, r4
   161e2:	4611      	mov	r1, r2
   161e4:	f000 f95e 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   161e8:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   161ec:	2308      	movs	r3, #8
   161ee:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   161f0:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   161f2:	7623      	strb	r3, [r4, #24]
   161f4:	e76b      	b.n	160ce <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   161f6:	7921      	ldrb	r1, [r4, #4]
   161f8:	4620      	mov	r0, r4
   161fa:	f00d fca1 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   161fe:	2801      	cmp	r0, #1
   16200:	d026      	beq.n	16250 <USBH_SetFeature+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   16202:	2804      	cmp	r0, #4
   16204:	d0af      	beq.n	16166 <USBH_SetFeature+0xaa>
        if (URB_Status == USBH_URB_STALL)
   16206:	2805      	cmp	r0, #5
   16208:	f47f af60 	bne.w	160cc <USBH_SetFeature+0x10>
        status = USBH_NOT_SUPPORTED;
   1620c:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   1620e:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   16210:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   16212:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   16214:	7623      	strb	r3, [r4, #24]
}
   16216:	b003      	add	sp, #12
   16218:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   1621a:	2200      	movs	r2, #0
   1621c:	2501      	movs	r5, #1
   1621e:	7963      	ldrb	r3, [r4, #5]
   16220:	4620      	mov	r0, r4
   16222:	4611      	mov	r1, r2
   16224:	9500      	str	r5, [sp, #0]
   16226:	f000 f925 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1622a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   1622e:	230a      	movs	r3, #10
   16230:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   16232:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   16234:	7623      	strb	r3, [r4, #24]
   16236:	e74a      	b.n	160ce <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   16238:	7961      	ldrb	r1, [r4, #5]
   1623a:	4620      	mov	r0, r4
   1623c:	f00d fc80 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16240:	2801      	cmp	r0, #1
   16242:	d005      	beq.n	16250 <USBH_SetFeature+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   16244:	2802      	cmp	r0, #2
   16246:	d1a7      	bne.n	16198 <USBH_SetFeature+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   16248:	2309      	movs	r3, #9
   1624a:	2001      	movs	r0, #1
   1624c:	7623      	strb	r3, [r4, #24]
   1624e:	e73e      	b.n	160ce <USBH_SetFeature+0x12>
        status = USBH_OK;
   16250:	2000      	movs	r0, #0
   16252:	e7dc      	b.n	1620e <USBH_SetFeature+0x152>
          if (direction == USB_D2H)
   16254:	2a00      	cmp	r2, #0
   16256:	dbf7      	blt.n	16248 <USBH_SetFeature+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   16258:	2307      	movs	r3, #7
   1625a:	2001      	movs	r0, #1
   1625c:	7623      	strb	r3, [r4, #24]
   1625e:	e736      	b.n	160ce <USBH_SetFeature+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   16260:	8ae3      	ldrh	r3, [r4, #22]
   16262:	f994 2010 	ldrsb.w	r2, [r4, #16]
   16266:	2b00      	cmp	r3, #0
   16268:	d0f4      	beq.n	16254 <USBH_SetFeature+0x198>
          if (direction == USB_D2H)
   1626a:	2a00      	cmp	r2, #0
   1626c:	db08      	blt.n	16280 <USBH_SetFeature+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   1626e:	2305      	movs	r3, #5
   16270:	2001      	movs	r0, #1
   16272:	7623      	strb	r3, [r4, #24]
   16274:	e72b      	b.n	160ce <USBH_SetFeature+0x12>
        phost->Control.state = CTRL_SETUP;
   16276:	2301      	movs	r3, #1
   16278:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   1627a:	4618      	mov	r0, r3
   1627c:	70a3      	strb	r3, [r4, #2]
   1627e:	e726      	b.n	160ce <USBH_SetFeature+0x12>
            phost->Control.state = CTRL_DATA_IN;
   16280:	2303      	movs	r3, #3
   16282:	7623      	strb	r3, [r4, #24]
   16284:	e723      	b.n	160ce <USBH_SetFeature+0x12>
   16286:	bf00      	nop

00016288 <USBH_ClrFeature>:
{
   16288:	b530      	push	{r4, r5, lr}
   1628a:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   1628c:	7880      	ldrb	r0, [r0, #2]
{
   1628e:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   16290:	2801      	cmp	r0, #1
   16292:	d011      	beq.n	162b8 <USBH_ClrFeature+0x30>
  switch (phost->RequestState)
   16294:	2802      	cmp	r0, #2
   16296:	d002      	beq.n	1629e <USBH_ClrFeature+0x16>
  status = USBH_BUSY;
   16298:	2001      	movs	r0, #1
}
   1629a:	b003      	add	sp, #12
   1629c:	bd30      	pop	{r4, r5, pc}
   1629e:	461c      	mov	r4, r3
  switch (phost->Control.state)
   162a0:	7e1b      	ldrb	r3, [r3, #24]
   162a2:	3b01      	subs	r3, #1
   162a4:	2b0a      	cmp	r3, #10
   162a6:	d8f7      	bhi.n	16298 <USBH_ClrFeature+0x10>
   162a8:	e8df f003 	tbb	[pc, r3]
   162ac:	5447382e 	.word	0x5447382e
   162b0:	8b7e6e5f 	.word	0x8b7e6e5f
   162b4:	ac9d      	.short	0xac9d
   162b6:	13          	.byte	0x13
   162b7:	00          	.byte	0x00
    phost->Control.setup.b.wLength.w = 0U;
   162b8:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
   162ba:	f44f 7581 	mov.w	r5, #258	; 0x102
      phost->RequestState = CMD_WAIT;
   162be:	2402      	movs	r4, #2
    phost->Control.setup.b.wIndex.w = ep_num;
   162c0:	8299      	strh	r1, [r3, #20]
      phost->Control.state = CTRL_SETUP;
   162c2:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
   162c4:	611d      	str	r5, [r3, #16]
    phost->Control.setup.b.wLength.w = 0U;
   162c6:	82da      	strh	r2, [r3, #22]
      phost->Control.buff = buff;
   162c8:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   162ca:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   162cc:	709c      	strb	r4, [r3, #2]
}
   162ce:	b003      	add	sp, #12
   162d0:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   162d2:	7e63      	ldrb	r3, [r4, #25]
   162d4:	3301      	adds	r3, #1
   162d6:	b2db      	uxtb	r3, r3
   162d8:	2b02      	cmp	r3, #2
   162da:	7663      	strb	r3, [r4, #25]
   162dc:	f240 80b1 	bls.w	16442 <USBH_ClrFeature+0x1ba>
        phost->Control.errorcount = 0U;
   162e0:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   162e2:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   162e6:	2106      	movs	r1, #6
   162e8:	4620      	mov	r0, r4
   162ea:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   162ec:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   162ee:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   162f0:	4620      	mov	r0, r4
   162f2:	f000 f95b 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   162f6:	7921      	ldrb	r1, [r4, #4]
   162f8:	4620      	mov	r0, r4
   162fa:	f000 f957 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   162fe:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   16300:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   16302:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   16304:	70a3      	strb	r3, [r4, #2]
   16306:	e7c8      	b.n	1629a <USBH_ClrFeature+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   16308:	7962      	ldrb	r2, [r4, #5]
   1630a:	f104 0110 	add.w	r1, r4, #16
   1630e:	4620      	mov	r0, r4
   16310:	f000 f8a0 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   16314:	2302      	movs	r3, #2
   16316:	2001      	movs	r0, #1
   16318:	7623      	strb	r3, [r4, #24]
   1631a:	e7be      	b.n	1629a <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   1631c:	7961      	ldrb	r1, [r4, #5]
   1631e:	4620      	mov	r0, r4
   16320:	f00d fc0e 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16324:	2801      	cmp	r0, #1
   16326:	f000 8081 	beq.w	1642c <USBH_ClrFeature+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   1632a:	2804      	cmp	r0, #4
   1632c:	d001      	beq.n	16332 <USBH_ClrFeature+0xaa>
   1632e:	2802      	cmp	r0, #2
   16330:	d1b2      	bne.n	16298 <USBH_ClrFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   16332:	230b      	movs	r3, #11
   16334:	2001      	movs	r0, #1
   16336:	7623      	strb	r3, [r4, #24]
   16338:	e7af      	b.n	1629a <USBH_ClrFeature+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   1633a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   1633e:	4620      	mov	r0, r4
   16340:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   16342:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   16344:	68a1      	ldr	r1, [r4, #8]
   16346:	89a2      	ldrh	r2, [r4, #12]
   16348:	f000 f8ac 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   1634c:	2304      	movs	r3, #4
   1634e:	2001      	movs	r0, #1
   16350:	7623      	strb	r3, [r4, #24]
   16352:	e7a2      	b.n	1629a <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   16354:	7921      	ldrb	r1, [r4, #4]
   16356:	4620      	mov	r0, r4
   16358:	f00d fbf2 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1635c:	2801      	cmp	r0, #1
   1635e:	d059      	beq.n	16414 <USBH_ClrFeature+0x18c>
      if (URB_Status == USBH_URB_STALL)
   16360:	2805      	cmp	r0, #5
   16362:	d039      	beq.n	163d8 <USBH_ClrFeature+0x150>
        if (URB_Status == USBH_URB_ERROR)
   16364:	2804      	cmp	r0, #4
   16366:	d197      	bne.n	16298 <USBH_ClrFeature+0x10>
   16368:	e7e3      	b.n	16332 <USBH_ClrFeature+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   1636a:	2501      	movs	r5, #1
   1636c:	7963      	ldrb	r3, [r4, #5]
   1636e:	89a2      	ldrh	r2, [r4, #12]
   16370:	4620      	mov	r0, r4
   16372:	68a1      	ldr	r1, [r4, #8]
   16374:	9500      	str	r5, [sp, #0]
   16376:	f000 f87d 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1637a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   1637e:	2306      	movs	r3, #6
   16380:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   16382:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   16384:	7623      	strb	r3, [r4, #24]
   16386:	e788      	b.n	1629a <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   16388:	7961      	ldrb	r1, [r4, #5]
   1638a:	4620      	mov	r0, r4
   1638c:	f00d fbd8 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16390:	2801      	cmp	r0, #1
   16392:	d047      	beq.n	16424 <USBH_ClrFeature+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   16394:	2805      	cmp	r0, #5
   16396:	d01f      	beq.n	163d8 <USBH_ClrFeature+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   16398:	2802      	cmp	r0, #2
   1639a:	d04e      	beq.n	1643a <USBH_ClrFeature+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   1639c:	2804      	cmp	r0, #4
   1639e:	f47f af7b 	bne.w	16298 <USBH_ClrFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   163a2:	230b      	movs	r3, #11
   163a4:	7623      	strb	r3, [r4, #24]
   163a6:	e7ab      	b.n	16300 <USBH_ClrFeature+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   163a8:	2200      	movs	r2, #0
   163aa:	7923      	ldrb	r3, [r4, #4]
   163ac:	4620      	mov	r0, r4
   163ae:	4611      	mov	r1, r2
   163b0:	f000 f878 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   163b4:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   163b8:	2308      	movs	r3, #8
   163ba:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   163bc:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   163be:	7623      	strb	r3, [r4, #24]
   163c0:	e76b      	b.n	1629a <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   163c2:	7921      	ldrb	r1, [r4, #4]
   163c4:	4620      	mov	r0, r4
   163c6:	f00d fbbb 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   163ca:	2801      	cmp	r0, #1
   163cc:	d026      	beq.n	1641c <USBH_ClrFeature+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   163ce:	2804      	cmp	r0, #4
   163d0:	d0af      	beq.n	16332 <USBH_ClrFeature+0xaa>
        if (URB_Status == USBH_URB_STALL)
   163d2:	2805      	cmp	r0, #5
   163d4:	f47f af60 	bne.w	16298 <USBH_ClrFeature+0x10>
        status = USBH_NOT_SUPPORTED;
   163d8:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   163da:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   163dc:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   163de:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   163e0:	7623      	strb	r3, [r4, #24]
}
   163e2:	b003      	add	sp, #12
   163e4:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   163e6:	2200      	movs	r2, #0
   163e8:	2501      	movs	r5, #1
   163ea:	7963      	ldrb	r3, [r4, #5]
   163ec:	4620      	mov	r0, r4
   163ee:	4611      	mov	r1, r2
   163f0:	9500      	str	r5, [sp, #0]
   163f2:	f000 f83f 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   163f6:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   163fa:	230a      	movs	r3, #10
   163fc:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   163fe:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   16400:	7623      	strb	r3, [r4, #24]
   16402:	e74a      	b.n	1629a <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   16404:	7961      	ldrb	r1, [r4, #5]
   16406:	4620      	mov	r0, r4
   16408:	f00d fb9a 	bl	23b40 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1640c:	2801      	cmp	r0, #1
   1640e:	d005      	beq.n	1641c <USBH_ClrFeature+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   16410:	2802      	cmp	r0, #2
   16412:	d1a7      	bne.n	16364 <USBH_ClrFeature+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   16414:	2309      	movs	r3, #9
   16416:	2001      	movs	r0, #1
   16418:	7623      	strb	r3, [r4, #24]
   1641a:	e73e      	b.n	1629a <USBH_ClrFeature+0x12>
        status = USBH_OK;
   1641c:	2000      	movs	r0, #0
   1641e:	e7dc      	b.n	163da <USBH_ClrFeature+0x152>
          if (direction == USB_D2H)
   16420:	2a00      	cmp	r2, #0
   16422:	dbf7      	blt.n	16414 <USBH_ClrFeature+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   16424:	2307      	movs	r3, #7
   16426:	2001      	movs	r0, #1
   16428:	7623      	strb	r3, [r4, #24]
   1642a:	e736      	b.n	1629a <USBH_ClrFeature+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   1642c:	8ae3      	ldrh	r3, [r4, #22]
   1642e:	f994 2010 	ldrsb.w	r2, [r4, #16]
   16432:	2b00      	cmp	r3, #0
   16434:	d0f4      	beq.n	16420 <USBH_ClrFeature+0x198>
          if (direction == USB_D2H)
   16436:	2a00      	cmp	r2, #0
   16438:	db08      	blt.n	1644c <USBH_ClrFeature+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   1643a:	2305      	movs	r3, #5
   1643c:	2001      	movs	r0, #1
   1643e:	7623      	strb	r3, [r4, #24]
   16440:	e72b      	b.n	1629a <USBH_ClrFeature+0x12>
        phost->Control.state = CTRL_SETUP;
   16442:	2301      	movs	r3, #1
   16444:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   16446:	4618      	mov	r0, r3
   16448:	70a3      	strb	r3, [r4, #2]
   1644a:	e726      	b.n	1629a <USBH_ClrFeature+0x12>
            phost->Control.state = CTRL_DATA_IN;
   1644c:	2303      	movs	r3, #3
   1644e:	7623      	strb	r3, [r4, #24]
   16450:	e723      	b.n	1629a <USBH_ClrFeature+0x12>
   16452:	bf00      	nop

00016454 <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
   16454:	b530      	push	{r4, r5, lr}

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   16456:	2400      	movs	r4, #0
{
   16458:	b085      	sub	sp, #20
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   1645a:	2508      	movs	r5, #8
   1645c:	9101      	str	r1, [sp, #4]
   1645e:	4623      	mov	r3, r4
   16460:	4611      	mov	r1, r2
   16462:	9403      	str	r4, [sp, #12]
   16464:	9400      	str	r4, [sp, #0]
   16466:	4622      	mov	r2, r4
   16468:	9502      	str	r5, [sp, #8]
   1646a:	f00d fb4d 	bl	23b08 <USBH_LL_SubmitURB>
                    USBH_PID_SETUP,       /* Type setup       */
                    buff,                 /* data buffer      */
                    USBH_SETUP_PKT_SIZE,  /* data length      */
                    0U);
  return USBH_OK;
}
   1646e:	4620      	mov	r0, r4
   16470:	b005      	add	sp, #20
   16472:	bd30      	pop	{r4, r5, pc}

00016474 <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
   16474:	b570      	push	{r4, r5, r6, lr}
  if (phost->device.speed != USBH_SPEED_HIGH)
   16476:	f890 631d 	ldrb.w	r6, [r0, #797]	; 0x31d
{
   1647a:	b084      	sub	sp, #16
   1647c:	461d      	mov	r5, r3
  {
    do_ping = 0U;
  }

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   1647e:	2300      	movs	r3, #0
  if (phost->device.speed != USBH_SPEED_HIGH)
   16480:	2e00      	cmp	r6, #0
{
   16482:	f89d 4020 	ldrb.w	r4, [sp, #32]
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   16486:	f04f 0601 	mov.w	r6, #1
   1648a:	9202      	str	r2, [sp, #8]
    do_ping = 0U;
   1648c:	bf18      	it	ne
   1648e:	461c      	movne	r4, r3
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   16490:	461a      	mov	r2, r3
   16492:	e9cd 6100 	strd	r6, r1, [sp]
   16496:	9403      	str	r4, [sp, #12]
   16498:	4629      	mov	r1, r5
   1649a:	f00d fb35 	bl	23b08 <USBH_LL_SubmitURB>
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
}
   1649e:	2000      	movs	r0, #0
   164a0:	b004      	add	sp, #16
   164a2:	bd70      	pop	{r4, r5, r6, pc}

000164a4 <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
   164a4:	b570      	push	{r4, r5, r6, lr}
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   164a6:	2400      	movs	r4, #0
{
   164a8:	b084      	sub	sp, #16
   164aa:	461e      	mov	r6, r3
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   164ac:	2501      	movs	r5, #1
   164ae:	4623      	mov	r3, r4
   164b0:	9403      	str	r4, [sp, #12]
   164b2:	9500      	str	r5, [sp, #0]
   164b4:	e9cd 1201 	strd	r1, r2, [sp, #4]
   164b8:	4631      	mov	r1, r6
   164ba:	462a      	mov	r2, r5
   164bc:	f00d fb24 	bl	23b08 <USBH_LL_SubmitURB>
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;

}
   164c0:	4620      	mov	r0, r4
   164c2:	b004      	add	sp, #16
   164c4:	bd70      	pop	{r4, r5, r6, pc}
   164c6:	bf00      	nop

000164c8 <USBH_BulkReceiveData>:
  */
USBH_StatusTypeDef USBH_BulkReceiveData(USBH_HandleTypeDef *phost,
                                        uint8_t *buff,
                                        uint16_t length,
                                        uint8_t pipe_num)
{
   164c8:	b570      	push	{r4, r5, r6, lr}
   164ca:	461e      	mov	r6, r3
   164cc:	b084      	sub	sp, #16
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   164ce:	2400      	movs	r4, #0
   164d0:	2501      	movs	r5, #1
   164d2:	2302      	movs	r3, #2
   164d4:	9403      	str	r4, [sp, #12]
   164d6:	9500      	str	r5, [sp, #0]
   164d8:	e9cd 1201 	strd	r1, r2, [sp, #4]
   164dc:	4631      	mov	r1, r6
   164de:	462a      	mov	r2, r5
   164e0:	f00d fb12 	bl	23b08 <USBH_LL_SubmitURB>
                    USBH_PID_DATA,        /* Type Data        */
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;
}
   164e4:	4620      	mov	r0, r4
   164e6:	b004      	add	sp, #16
   164e8:	bd70      	pop	{r4, r5, r6, pc}
   164ea:	bf00      	nop

000164ec <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
   164ec:	b530      	push	{r4, r5, lr}
   164ee:	b085      	sub	sp, #20
   164f0:	f89d 4020 	ldrb.w	r4, [sp, #32]
   164f4:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
   164f8:	9400      	str	r4, [sp, #0]
{
   164fa:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
   164fe:	e9cd 5401 	strd	r5, r4, [sp, #4]
   16502:	f00d fad9 	bl	23ab8 <USBH_LL_OpenPipe>

  return USBH_OK;
}
   16506:	2000      	movs	r0, #0
   16508:	b005      	add	sp, #20
   1650a:	bd30      	pop	{r4, r5, pc}

0001650c <USBH_ClosePipe>:
  * @param  phost: Host Handle
  * @param  pipe_num: Pipe Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe_num)
{
   1650c:	b508      	push	{r3, lr}
  USBH_LL_ClosePipe(phost, pipe_num);
   1650e:	f00d faed 	bl	23aec <USBH_LL_ClosePipe>

  return USBH_OK;
}
   16512:	2000      	movs	r0, #0
   16514:	bd08      	pop	{r3, pc}
   16516:	bf00      	nop

00016518 <USBH_AllocPipe>:
  * @param  phost: Host Handle
  * @param  ep_addr: End point for which the Pipe to be allocated
  * @retval Pipe number
  */
uint8_t USBH_AllocPipe(USBH_HandleTypeDef *phost, uint8_t ep_addr)
{
   16518:	4603      	mov	r3, r0
{
  uint8_t idx = 0U;

  for (idx = 0U ; idx < 11U ; idx++)
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
   1651a:	f8d0 04f4 	ldr.w	r0, [r0, #1268]	; 0x4f4
   1651e:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
   16522:	d02a      	beq.n	1657a <USBH_AllocPipe+0x62>
   16524:	f8d3 24f8 	ldr.w	r2, [r3, #1272]	; 0x4f8
   16528:	0410      	lsls	r0, r2, #16
   1652a:	d52d      	bpl.n	16588 <USBH_AllocPipe+0x70>
   1652c:	f8d3 24fc 	ldr.w	r2, [r3, #1276]	; 0x4fc
   16530:	0412      	lsls	r2, r2, #16
   16532:	d52b      	bpl.n	1658c <USBH_AllocPipe+0x74>
   16534:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
   16538:	0410      	lsls	r0, r2, #16
   1653a:	d529      	bpl.n	16590 <USBH_AllocPipe+0x78>
   1653c:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   16540:	0412      	lsls	r2, r2, #16
   16542:	d527      	bpl.n	16594 <USBH_AllocPipe+0x7c>
   16544:	f8d3 2508 	ldr.w	r2, [r3, #1288]	; 0x508
   16548:	0410      	lsls	r0, r2, #16
   1654a:	d525      	bpl.n	16598 <USBH_AllocPipe+0x80>
   1654c:	f8d3 250c 	ldr.w	r2, [r3, #1292]	; 0x50c
   16550:	0412      	lsls	r2, r2, #16
   16552:	d525      	bpl.n	165a0 <USBH_AllocPipe+0x88>
   16554:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   16558:	0410      	lsls	r0, r2, #16
   1655a:	d523      	bpl.n	165a4 <USBH_AllocPipe+0x8c>
   1655c:	f8d3 2514 	ldr.w	r2, [r3, #1300]	; 0x514
   16560:	0412      	lsls	r2, r2, #16
   16562:	d51b      	bpl.n	1659c <USBH_AllocPipe+0x84>
   16564:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   16568:	0410      	lsls	r0, r2, #16
   1656a:	d505      	bpl.n	16578 <USBH_AllocPipe+0x60>
   1656c:	f8d3 251c 	ldr.w	r2, [r3, #1308]	; 0x51c
   16570:	0412      	lsls	r2, r2, #16
   16572:	d519      	bpl.n	165a8 <USBH_AllocPipe+0x90>
   16574:	20ff      	movs	r0, #255	; 0xff
}
   16576:	4770      	bx	lr
  for (idx = 0U ; idx < 11U ; idx++)
   16578:	2009      	movs	r0, #9
    phost->Pipes[pipe & 0xFU] = 0x8000U | ep_addr;
   1657a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
   1657e:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
   16582:	f8c3 14f4 	str.w	r1, [r3, #1268]	; 0x4f4
   16586:	4770      	bx	lr
  for (idx = 0U ; idx < 11U ; idx++)
   16588:	2001      	movs	r0, #1
   1658a:	e7f6      	b.n	1657a <USBH_AllocPipe+0x62>
   1658c:	2002      	movs	r0, #2
   1658e:	e7f4      	b.n	1657a <USBH_AllocPipe+0x62>
   16590:	2003      	movs	r0, #3
   16592:	e7f2      	b.n	1657a <USBH_AllocPipe+0x62>
   16594:	2004      	movs	r0, #4
   16596:	e7f0      	b.n	1657a <USBH_AllocPipe+0x62>
   16598:	2005      	movs	r0, #5
   1659a:	e7ee      	b.n	1657a <USBH_AllocPipe+0x62>
   1659c:	2008      	movs	r0, #8
   1659e:	e7ec      	b.n	1657a <USBH_AllocPipe+0x62>
   165a0:	2006      	movs	r0, #6
   165a2:	e7ea      	b.n	1657a <USBH_AllocPipe+0x62>
   165a4:	2007      	movs	r0, #7
   165a6:	e7e8      	b.n	1657a <USBH_AllocPipe+0x62>
   165a8:	200a      	movs	r0, #10
   165aa:	e7e6      	b.n	1657a <USBH_AllocPipe+0x62>

000165ac <USBH_FreePipe>:
  if (idx < 11U)
   165ac:	290a      	cmp	r1, #10
   165ae:	d807      	bhi.n	165c0 <USBH_FreePipe+0x14>
   165b0:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    phost->Pipes[idx] &= 0x7FFFU;
   165b4:	f8d0 34f4 	ldr.w	r3, [r0, #1268]	; 0x4f4
   165b8:	f3c3 030e 	ubfx	r3, r3, #0, #15
   165bc:	f8c0 34f4 	str.w	r3, [r0, #1268]	; 0x4f4
}
   165c0:	2000      	movs	r0, #0
   165c2:	4770      	bx	lr

000165c4 <FATFS_LinkDriver>:
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
   165c4:	4b11      	ldr	r3, [pc, #68]	; (1660c <FATFS_LinkDriver+0x48>)
   165c6:	7a5a      	ldrb	r2, [r3, #9]
   165c8:	b10a      	cbz	r2, 165ce <FATFS_LinkDriver+0xa>
  uint8_t ret = 1;
   165ca:	2001      	movs	r0, #1
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
}
   165cc:	4770      	bx	lr
{
   165ce:	b5f0      	push	{r4, r5, r6, r7, lr}
   165d0:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    disk.is_initialized[disk.nbr] = 0;
   165d4:	f893 e009 	ldrb.w	lr, [r3, #9]
    disk.drv[disk.nbr] = drv;
   165d8:	7a5e      	ldrb	r6, [r3, #9]
    path[1] = ':';
   165da:	f04f 0c3a 	mov.w	ip, #58	; 0x3a
    disk.lun[disk.nbr] = lun;
   165de:	7a5d      	ldrb	r5, [r3, #9]
    path[2] = '/';
   165e0:	272f      	movs	r7, #47	; 0x2f
    DiskNum = disk.nbr++;
   165e2:	7a5a      	ldrb	r2, [r3, #9]
    disk.drv[disk.nbr] = drv;
   165e4:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    disk.lun[disk.nbr] = lun;
   165e8:	441d      	add	r5, r3
    disk.is_initialized[disk.nbr] = 0;
   165ea:	f803 400e 	strb.w	r4, [r3, lr]
    DiskNum = disk.nbr++;
   165ee:	b2d2      	uxtb	r2, r2
    disk.drv[disk.nbr] = drv;
   165f0:	6070      	str	r0, [r6, #4]
    disk.lun[disk.nbr] = lun;
   165f2:	722c      	strb	r4, [r5, #8]
    DiskNum = disk.nbr++;
   165f4:	1c50      	adds	r0, r2, #1
    path[0] = DiskNum + '0';
   165f6:	3230      	adds	r2, #48	; 0x30
    DiskNum = disk.nbr++;
   165f8:	b2c0      	uxtb	r0, r0
   165fa:	7258      	strb	r0, [r3, #9]
    path[3] = 0;
   165fc:	4620      	mov	r0, r4
    path[0] = DiskNum + '0';
   165fe:	700a      	strb	r2, [r1, #0]
    path[3] = 0;
   16600:	70cc      	strb	r4, [r1, #3]
    path[1] = ':';
   16602:	f881 c001 	strb.w	ip, [r1, #1]
    path[2] = '/';
   16606:	708f      	strb	r7, [r1, #2]
}
   16608:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1660a:	bf00      	nop
   1660c:	020e2d88 	.word	0x020e2d88

00016610 <MIDI_Application>:
 * @brief  Main routine for MIDI application, looped in main.c
 * @param  None
 * @retval none
 */
void MIDI_Application(void)
{
   16610:	b510      	push	{r4, lr}
	if(Appli_state == APPLICATION_READY)
   16612:	4c15      	ldr	r4, [pc, #84]	; (16668 <MIDI_Application+0x58>)
   16614:	7823      	ldrb	r3, [r4, #0]
   16616:	2b02      	cmp	r3, #2
   16618:	d016      	beq.n	16648 <MIDI_Application+0x38>
	if(Appli_state == APPLICATION_RUNNING)
	{
			//....pffff......grrrrr......
	}

	if(Appli_state == APPLICATION_DISCONNECT)
   1661a:	2b04      	cmp	r3, #4
   1661c:	d000      	beq.n	16620 <MIDI_Application+0x10>
		HAL_Delay(10);
		MX_USB_HOST_Init();

	}

}
   1661e:	bd10      	pop	{r4, pc}
		Appli_state = APPLICATION_IDLE;
   16620:	2300      	movs	r3, #0
		setLED_USB(0);
   16622:	4618      	mov	r0, r3
		Appli_state = APPLICATION_IDLE;
   16624:	7023      	strb	r3, [r4, #0]
		setLED_USB(0);
   16626:	f002 ff05 	bl	19434 <setLED_USB>
		USBH_MIDI_Stop(&hUsbHostFS);
   1662a:	4810      	ldr	r0, [pc, #64]	; (1666c <MIDI_Application+0x5c>)
   1662c:	f00d f970 	bl	23910 <USBH_MIDI_Stop>
		HAL_Delay(10);
   16630:	200a      	movs	r0, #10
   16632:	f7f1 fee5 	bl	8400 <HAL_Delay>
		MX_USB_HOST_DeInit();
   16636:	f00c fff9 	bl	2362c <MX_USB_HOST_DeInit>
		HAL_Delay(10);
   1663a:	200a      	movs	r0, #10
   1663c:	f7f1 fee0 	bl	8400 <HAL_Delay>
}
   16640:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		MX_USB_HOST_Init();
   16644:	f00c bfd0 	b.w	235e8 <MX_USB_HOST_Init>
		USBH_MIDI_Receive(&hUsbHostFS, MIDI_RX_Buffer[MIDI_write_buffer], RX_BUFF_SIZE); // just once at the beginning, start the first reception
   16648:	4909      	ldr	r1, [pc, #36]	; (16670 <MIDI_Application+0x60>)
   1664a:	2240      	movs	r2, #64	; 0x40
   1664c:	4b09      	ldr	r3, [pc, #36]	; (16674 <MIDI_Application+0x64>)
   1664e:	7809      	ldrb	r1, [r1, #0]
   16650:	4806      	ldr	r0, [pc, #24]	; (1666c <MIDI_Application+0x5c>)
   16652:	eb03 1181 	add.w	r1, r3, r1, lsl #6
   16656:	f00d f971 	bl	2393c <USBH_MIDI_Receive>
		Appli_state = APPLICATION_RUNNING;
   1665a:	2303      	movs	r3, #3
		setLED_USB(1);
   1665c:	2001      	movs	r0, #1
		Appli_state = APPLICATION_RUNNING;
   1665e:	7023      	strb	r3, [r4, #0]
		setLED_USB(1);
   16660:	f002 fee8 	bl	19434 <setLED_USB>
   16664:	7823      	ldrb	r3, [r4, #0]
   16666:	e7d8      	b.n	1661a <MIDI_Application+0xa>
   16668:	020e2f1c 	.word	0x020e2f1c
   1666c:	00063aa0 	.word	0x00063aa0
   16670:	00062564 	.word	0x00062564
   16674:	00062a00 	.word	0x00062a00

00016678 <ProcessReceivedMidiDatas>:

}
volatile testInt = 0;
/*-----------------------------------------------------------------------------*/
void ProcessReceivedMidiDatas(void)
{
   16678:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t miniBufferPosition = 0;
	uint8_t processed = 0;
   1667c:	2500      	movs	r5, #0
   1667e:	4c3a      	ldr	r4, [pc, #232]	; (16768 <ProcessReceivedMidiDatas+0xf0>)
   16680:	4f3a      	ldr	r7, [pc, #232]	; (1676c <ProcessReceivedMidiDatas+0xf4>)
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
   16682:	f8df 8108 	ldr.w	r8, [pc, #264]	; 1678c <ProcessReceivedMidiDatas+0x114>
			(processed < 32)) // maximum notes to process in a frame * 4
	{

		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   16686:	f8df 9108 	ldr.w	r9, [pc, #264]	; 16790 <ProcessReceivedMidiDatas+0x118>
   1668a:	4e39      	ldr	r6, [pc, #228]	; (16770 <ProcessReceivedMidiDatas+0xf8>)
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
   1668c:	e008      	b.n	166a0 <ProcessReceivedMidiDatas+0x28>
		myUSB_FIFO_readPointer++;
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
		{
			parse_MIDI_Message();
		}
		if (myUSB_FIFO_readPointer >= USB_FIFO_SIZE)
   1668e:	8823      	ldrh	r3, [r4, #0]
   16690:	2bff      	cmp	r3, #255	; 0xff
   16692:	d903      	bls.n	1669c <ProcessReceivedMidiDatas+0x24>
		{
			myUSB_FIFO_overflowBit = 0;
   16694:	2300      	movs	r3, #0
   16696:	f888 3000 	strb.w	r3, [r8]
			myUSB_FIFO_readPointer = 0;
   1669a:	8023      	strh	r3, [r4, #0]
		}
		processed++;
   1669c:	3501      	adds	r5, #1
   1669e:	b2ed      	uxtb	r5, r5
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
   166a0:	883b      	ldrh	r3, [r7, #0]
   166a2:	8822      	ldrh	r2, [r4, #0]
   166a4:	429a      	cmp	r2, r3
   166a6:	d303      	bcc.n	166b0 <ProcessReceivedMidiDatas+0x38>
   166a8:	f898 3000 	ldrb.w	r3, [r8]
   166ac:	2b00      	cmp	r3, #0
   166ae:	d04c      	beq.n	1674a <ProcessReceivedMidiDatas+0xd2>
   166b0:	2d20      	cmp	r5, #32
   166b2:	d04e      	beq.n	16752 <ProcessReceivedMidiDatas+0xda>
		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
   166b4:	8822      	ldrh	r2, [r4, #0]
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   166b6:	8823      	ldrh	r3, [r4, #0]
		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
   166b8:	f002 0203 	and.w	r2, r2, #3
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   166bc:	b29b      	uxth	r3, r3
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
   166be:	2a03      	cmp	r2, #3
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   166c0:	f819 1003 	ldrb.w	r1, [r9, r3]
		myUSB_FIFO_readPointer++;
   166c4:	8823      	ldrh	r3, [r4, #0]
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   166c6:	54b1      	strb	r1, [r6, r2]
		myUSB_FIFO_readPointer++;
   166c8:	f103 0301 	add.w	r3, r3, #1
   166cc:	b29b      	uxth	r3, r3
   166ce:	8023      	strh	r3, [r4, #0]
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
   166d0:	d1dd      	bne.n	1668e <ProcessReceivedMidiDatas+0x16>
	switch(USB_message[1])
   166d2:	7873      	ldrb	r3, [r6, #1]
   166d4:	2b90      	cmp	r3, #144	; 0x90
   166d6:	d01a      	beq.n	1670e <ProcessReceivedMidiDatas+0x96>
   166d8:	d90a      	bls.n	166f0 <ProcessReceivedMidiDatas+0x78>
   166da:	2bb0      	cmp	r3, #176	; 0xb0
   166dc:	d024      	beq.n	16728 <ProcessReceivedMidiDatas+0xb0>
   166de:	2be0      	cmp	r3, #224	; 0xe0
   166e0:	d1d5      	bne.n	1668e <ProcessReceivedMidiDatas+0x16>
			pitchBend((USB_message[2]) + (USB_message[3] << 7));
   166e2:	78f0      	ldrb	r0, [r6, #3]
   166e4:	78b3      	ldrb	r3, [r6, #2]
   166e6:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
   166ea:	f00a ff7f 	bl	215ec <pitchBend>
   166ee:	e7ce      	b.n	1668e <ProcessReceivedMidiDatas+0x16>
	switch(USB_message[1])
   166f0:	2b80      	cmp	r3, #128	; 0x80
   166f2:	d1cc      	bne.n	1668e <ProcessReceivedMidiDatas+0x16>
			key = USB_message[2];
   166f4:	78b2      	ldrb	r2, [r6, #2]
			velocity = USB_message[3];
   166f6:	78f3      	ldrb	r3, [r6, #3]
			key = USB_message[2];
   166f8:	491e      	ldr	r1, [pc, #120]	; (16774 <ProcessReceivedMidiDatas+0xfc>)
			noteOff(key, velocity);
   166fa:	4610      	mov	r0, r2
			velocity = USB_message[3];
   166fc:	f8df c094 	ldr.w	ip, [pc, #148]	; 16794 <ProcessReceivedMidiDatas+0x11c>
			key = USB_message[2];
   16700:	700a      	strb	r2, [r1, #0]
			noteOff(key, velocity);
   16702:	4619      	mov	r1, r3
			velocity = USB_message[3];
   16704:	f88c 3000 	strb.w	r3, [ip]
			noteOff(key, velocity);
   16708:	f00a fda6 	bl	21258 <noteOff>
   1670c:	e7bf      	b.n	1668e <ProcessReceivedMidiDatas+0x16>
			key = USB_message[2];
   1670e:	78b2      	ldrb	r2, [r6, #2]
			velocity = USB_message[3];
   16710:	78f3      	ldrb	r3, [r6, #3]
			key = USB_message[2];
   16712:	4918      	ldr	r1, [pc, #96]	; (16774 <ProcessReceivedMidiDatas+0xfc>)
			noteOn(key, velocity);
   16714:	4610      	mov	r0, r2
			velocity = USB_message[3];
   16716:	f8df c07c 	ldr.w	ip, [pc, #124]	; 16794 <ProcessReceivedMidiDatas+0x11c>
			key = USB_message[2];
   1671a:	700a      	strb	r2, [r1, #0]
			noteOn(key, velocity);
   1671c:	4619      	mov	r1, r3
			velocity = USB_message[3];
   1671e:	f88c 3000 	strb.w	r3, [ip]
			noteOn(key, velocity);
   16722:	f00a fe51 	bl	213c8 <noteOn>
   16726:	e7b2      	b.n	1668e <ProcessReceivedMidiDatas+0x16>
			ctrl = USB_message[2];
   16728:	78b3      	ldrb	r3, [r6, #2]
   1672a:	4913      	ldr	r1, [pc, #76]	; (16778 <ProcessReceivedMidiDatas+0x100>)
			data = USB_message[3];
   1672c:	78f2      	ldrb	r2, [r6, #3]
			switch(ctrl)
   1672e:	2b40      	cmp	r3, #64	; 0x40
			ctrl = USB_message[2];
   16730:	700b      	strb	r3, [r1, #0]
			CCs[ctrl] = data;
   16732:	4812      	ldr	r0, [pc, #72]	; (1677c <ProcessReceivedMidiDatas+0x104>)
			data = USB_message[3];
   16734:	4912      	ldr	r1, [pc, #72]	; (16780 <ProcessReceivedMidiDatas+0x108>)
			CCs[ctrl] = data;
   16736:	54c2      	strb	r2, [r0, r3]
			data = USB_message[3];
   16738:	700a      	strb	r2, [r1, #0]
			switch(ctrl)
   1673a:	d1a8      	bne.n	1668e <ProcessReceivedMidiDatas+0x16>
   1673c:	4b11      	ldr	r3, [pc, #68]	; (16784 <ProcessReceivedMidiDatas+0x10c>)
   1673e:	781b      	ldrb	r3, [r3, #0]
					if (data)
   16740:	b162      	cbz	r2, 1675c <ProcessReceivedMidiDatas+0xe4>
						if (sustainInverted) 	sustainOff();
   16742:	b16b      	cbz	r3, 16760 <ProcessReceivedMidiDatas+0xe8>
   16744:	f00a ff5e 	bl	21604 <sustainOff>
   16748:	e7a1      	b.n	1668e <ProcessReceivedMidiDatas+0x16>
	}
	if (processed >= 32)
   1674a:	2d20      	cmp	r5, #32
   1674c:	d001      	beq.n	16752 <ProcessReceivedMidiDatas+0xda>
	{
		testInt = 1;
	}
}
   1674e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		testInt = 1;
   16752:	4b0d      	ldr	r3, [pc, #52]	; (16788 <ProcessReceivedMidiDatas+0x110>)
   16754:	2201      	movs	r2, #1
   16756:	601a      	str	r2, [r3, #0]
}
   16758:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
						if (sustainInverted) 	sustainOn();
   1675c:	2b00      	cmp	r3, #0
   1675e:	d0f1      	beq.n	16744 <ProcessReceivedMidiDatas+0xcc>
						else					sustainOn();
   16760:	f00a ff52 	bl	21608 <sustainOn>
   16764:	e793      	b.n	1668e <ProcessReceivedMidiDatas+0x16>
   16766:	bf00      	nop
   16768:	020e2f1e 	.word	0x020e2f1e
   1676c:	020e2f20 	.word	0x020e2f20
   16770:	020e2fcc 	.word	0x020e2fcc
   16774:	020e2fd0 	.word	0x020e2fd0
   16778:	020e2f45 	.word	0x020e2f45
   1677c:	020e2f48 	.word	0x020e2f48
   16780:	020e2fc9 	.word	0x020e2fc9
   16784:	020e2f44 	.word	0x020e2f44
   16788:	020e2d98 	.word	0x020e2d98
   1678c:	020e2f1d 	.word	0x020e2f1d
   16790:	020fb9a4 	.word	0x020fb9a4
   16794:	020e2fc8 	.word	0x020e2fc8

00016798 <MX_ADC1_Init>:
  ADC_MultiModeTypeDef multimode = {0};
  ADC_ChannelConfTypeDef sConfig = {0};

  /** Common config 
  */
  hadc1.Instance = ADC1;
   16798:	4b49      	ldr	r3, [pc, #292]	; (168c0 <MX_ADC1_Init+0x128>)
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV4;
   1679a:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  hadc1.Instance = ADC1;
   1679e:	4949      	ldr	r1, [pc, #292]	; (168c4 <MX_ADC1_Init+0x12c>)
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
   167a0:	2208      	movs	r2, #8
{
   167a2:	b530      	push	{r4, r5, lr}
  hadc1.Instance = ADC1;
   167a4:	6019      	str	r1, [r3, #0]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
  hadc1.Init.OversamplingMode = ENABLE;
  hadc1.Init.Oversampling.Ratio = 64;
   167a6:	2140      	movs	r1, #64	; 0x40
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV4;
   167a8:	6058      	str	r0, [r3, #4]
  hadc1.Init.Oversampling.RightBitShift = ADC_RIGHTBITSHIFT_6;
   167aa:	20c0      	movs	r0, #192	; 0xc0
{
   167ac:	b08b      	sub	sp, #44	; 0x2c
  hadc1.Init.NbrOfConversion = 6;
   167ae:	2506      	movs	r5, #6
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
   167b0:	2403      	movs	r4, #3
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
   167b2:	611a      	str	r2, [r3, #16]
  hadc1.Init.Oversampling.Ratio = 64;
   167b4:	63d9      	str	r1, [r3, #60]	; 0x3c
  ADC_MultiModeTypeDef multimode = {0};
   167b6:	2200      	movs	r2, #0
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
   167b8:	2101      	movs	r1, #1
  hadc1.Init.Oversampling.RightBitShift = ADC_RIGHTBITSHIFT_6;
   167ba:	6418      	str	r0, [r3, #64]	; 0x40
  hadc1.Init.Oversampling.TriggeredMode = ADC_TRIGGEREDMODE_SINGLE_TRIGGER;
  hadc1.Init.Oversampling.OversamplingStopReset = ADC_REGOVERSAMPLING_CONTINUED_MODE;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
   167bc:	4618      	mov	r0, r3
  hadc1.Init.NbrOfConversion = 6;
   167be:	619d      	str	r5, [r3, #24]
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
   167c0:	62dc      	str	r4, [r3, #44]	; 0x2c
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
   167c2:	609a      	str	r2, [r3, #8]
  ADC_MultiModeTypeDef multimode = {0};
   167c4:	9200      	str	r2, [sp, #0]
  ADC_ChannelConfTypeDef sConfig = {0};
   167c6:	9203      	str	r2, [sp, #12]
  hadc1.Init.LowPowerAutoWait = DISABLE;
   167c8:	751a      	strb	r2, [r3, #20]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
   167ca:	771a      	strb	r2, [r3, #28]
  hadc1.Init.Oversampling.TriggeredMode = ADC_TRIGGEREDMODE_SINGLE_TRIGGER;
   167cc:	645a      	str	r2, [r3, #68]	; 0x44
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
   167ce:	60d9      	str	r1, [r3, #12]
  hadc1.Init.ContinuousConvMode = ENABLE;
   167d0:	7559      	strb	r1, [r3, #21]
  hadc1.Init.OversamplingMode = ENABLE;
   167d2:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
  hadc1.Init.Oversampling.OversamplingStopReset = ADC_REGOVERSAMPLING_CONTINUED_MODE;
   167d6:	6499      	str	r1, [r3, #72]	; 0x48
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
   167d8:	e9c3 2209 	strd	r2, r2, [r3, #36]	; 0x24
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
   167dc:	e9c3 220c 	strd	r2, r2, [r3, #48]	; 0x30
  ADC_MultiModeTypeDef multimode = {0};
   167e0:	e9cd 2201 	strd	r2, r2, [sp, #4]
  ADC_ChannelConfTypeDef sConfig = {0};
   167e4:	e9cd 2204 	strd	r2, r2, [sp, #16]
   167e8:	e9cd 2206 	strd	r2, r2, [sp, #24]
   167ec:	e9cd 2208 	strd	r2, r2, [sp, #32]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
   167f0:	f7f2 fd06 	bl	9200 <HAL_ADC_Init>
   167f4:	2800      	cmp	r0, #0
   167f6:	d160      	bne.n	168ba <MX_ADC1_Init+0x122>
  {
    Error_Handler();
  }
  /** Configure the ADC multi-mode 
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
   167f8:	2300      	movs	r3, #0
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
   167fa:	4669      	mov	r1, sp
   167fc:	4830      	ldr	r0, [pc, #192]	; (168c0 <MX_ADC1_Init+0x128>)
  multimode.Mode = ADC_MODE_INDEPENDENT;
   167fe:	9300      	str	r3, [sp, #0]
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
   16800:	f7f3 f80e 	bl	9820 <HAL_ADCEx_MultiModeConfigChannel>
   16804:	2800      	cmp	r0, #0
   16806:	d155      	bne.n	168b4 <MX_ADC1_Init+0x11c>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_7;
   16808:	4b2f      	ldr	r3, [pc, #188]	; (168c8 <MX_ADC1_Init+0x130>)
  sConfig.Rank = ADC_REGULAR_RANK_1;
   1680a:	2106      	movs	r1, #6
  sConfig.SamplingTime = ADC_SAMPLETIME_64CYCLES_5;
   1680c:	2005      	movs	r0, #5
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
   1680e:	f240 74ff 	movw	r4, #2047	; 0x7ff
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
   16812:	2204      	movs	r2, #4
  sConfig.Channel = ADC_CHANNEL_7;
   16814:	9303      	str	r3, [sp, #12]
  sConfig.Offset = 0;
   16816:	2300      	movs	r3, #0
  sConfig.Rank = ADC_REGULAR_RANK_1;
   16818:	9104      	str	r1, [sp, #16]
  sConfig.SamplingTime = ADC_SAMPLETIME_64CYCLES_5;
   1681a:	9005      	str	r0, [sp, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1681c:	a903      	add	r1, sp, #12
   1681e:	4828      	ldr	r0, [pc, #160]	; (168c0 <MX_ADC1_Init+0x128>)
  sConfig.Offset = 0;
   16820:	9308      	str	r3, [sp, #32]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
   16822:	e9cd 4206 	strd	r4, r2, [sp, #24]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16826:	f7f1 ff57 	bl	86d8 <HAL_ADC_ConfigChannel>
   1682a:	2800      	cmp	r0, #0
   1682c:	d13f      	bne.n	168ae <MX_ADC1_Init+0x116>
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_19;
  sConfig.Rank = ADC_REGULAR_RANK_2;
   1682e:	230c      	movs	r3, #12
  sConfig.Channel = ADC_CHANNEL_19;
   16830:	4a26      	ldr	r2, [pc, #152]	; (168cc <MX_ADC1_Init+0x134>)
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16832:	4823      	ldr	r0, [pc, #140]	; (168c0 <MX_ADC1_Init+0x128>)
   16834:	eb0d 0103 	add.w	r1, sp, r3
  sConfig.Rank = ADC_REGULAR_RANK_2;
   16838:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1683c:	f7f1 ff4c 	bl	86d8 <HAL_ADC_ConfigChannel>
   16840:	bb90      	cbnz	r0, 168a8 <MX_ADC1_Init+0x110>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_14;
   16842:	4a23      	ldr	r2, [pc, #140]	; (168d0 <MX_ADC1_Init+0x138>)
  sConfig.Rank = ADC_REGULAR_RANK_3;
   16844:	2312      	movs	r3, #18
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16846:	a903      	add	r1, sp, #12
   16848:	481d      	ldr	r0, [pc, #116]	; (168c0 <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_3;
   1684a:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1684e:	f7f1 ff43 	bl	86d8 <HAL_ADC_ConfigChannel>
   16852:	bb30      	cbnz	r0, 168a2 <MX_ADC1_Init+0x10a>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_16;
   16854:	4a1f      	ldr	r2, [pc, #124]	; (168d4 <MX_ADC1_Init+0x13c>)
  sConfig.Rank = ADC_REGULAR_RANK_4;
   16856:	2318      	movs	r3, #24
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16858:	a903      	add	r1, sp, #12
   1685a:	4819      	ldr	r0, [pc, #100]	; (168c0 <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_4;
   1685c:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16860:	f7f1 ff3a 	bl	86d8 <HAL_ADC_ConfigChannel>
   16864:	b9d0      	cbnz	r0, 1689c <MX_ADC1_Init+0x104>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_15;
   16866:	4a1c      	ldr	r2, [pc, #112]	; (168d8 <MX_ADC1_Init+0x140>)
  sConfig.Rank = ADC_REGULAR_RANK_5;
   16868:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1686c:	a903      	add	r1, sp, #12
   1686e:	4814      	ldr	r0, [pc, #80]	; (168c0 <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_5;
   16870:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16874:	f7f1 ff30 	bl	86d8 <HAL_ADC_ConfigChannel>
   16878:	b968      	cbnz	r0, 16896 <MX_ADC1_Init+0xfe>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_8;
   1687a:	4a18      	ldr	r2, [pc, #96]	; (168dc <MX_ADC1_Init+0x144>)
  sConfig.Rank = ADC_REGULAR_RANK_6;
   1687c:	f44f 7383 	mov.w	r3, #262	; 0x106
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16880:	a903      	add	r1, sp, #12
   16882:	480f      	ldr	r0, [pc, #60]	; (168c0 <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_6;
   16884:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16888:	f7f1 ff26 	bl	86d8 <HAL_ADC_ConfigChannel>
   1688c:	b108      	cbz	r0, 16892 <MX_ADC1_Init+0xfa>
  {
    Error_Handler();
   1688e:	f002 fdbf 	bl	19410 <Error_Handler>
  }

}
   16892:	b00b      	add	sp, #44	; 0x2c
   16894:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
   16896:	f002 fdbb 	bl	19410 <Error_Handler>
   1689a:	e7ee      	b.n	1687a <MX_ADC1_Init+0xe2>
    Error_Handler();
   1689c:	f002 fdb8 	bl	19410 <Error_Handler>
   168a0:	e7e1      	b.n	16866 <MX_ADC1_Init+0xce>
    Error_Handler();
   168a2:	f002 fdb5 	bl	19410 <Error_Handler>
   168a6:	e7d5      	b.n	16854 <MX_ADC1_Init+0xbc>
    Error_Handler();
   168a8:	f002 fdb2 	bl	19410 <Error_Handler>
   168ac:	e7c9      	b.n	16842 <MX_ADC1_Init+0xaa>
    Error_Handler();
   168ae:	f002 fdaf 	bl	19410 <Error_Handler>
   168b2:	e7bc      	b.n	1682e <MX_ADC1_Init+0x96>
    Error_Handler();
   168b4:	f002 fdac 	bl	19410 <Error_Handler>
   168b8:	e7a6      	b.n	16808 <MX_ADC1_Init+0x70>
    Error_Handler();
   168ba:	f002 fda9 	bl	19410 <Error_Handler>
   168be:	e79b      	b.n	167f8 <MX_ADC1_Init+0x60>
   168c0:	020e2fd4 	.word	0x020e2fd4
   168c4:	40022000 	.word	0x40022000
   168c8:	1d500080 	.word	0x1d500080
   168cc:	4fb80000 	.word	0x4fb80000
   168d0:	3ac04000 	.word	0x3ac04000
   168d4:	43210000 	.word	0x43210000
   168d8:	3ef08000 	.word	0x3ef08000
   168dc:	21800100 	.word	0x21800100

000168e0 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
   168e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  HAL_DMA_MuxSyncConfigTypeDef pSyncConfig= {0};
  if(adcHandle->Instance==ADC1)
   168e4:	4b46      	ldr	r3, [pc, #280]	; (16a00 <HAL_ADC_MspInit+0x120>)
{
   168e6:	b08f      	sub	sp, #60	; 0x3c
  if(adcHandle->Instance==ADC1)
   168e8:	6802      	ldr	r2, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   168ea:	2400      	movs	r4, #0
  if(adcHandle->Instance==ADC1)
   168ec:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   168ee:	940d      	str	r4, [sp, #52]	; 0x34
   168f0:	e9cd 4409 	strd	r4, r4, [sp, #36]	; 0x24
   168f4:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  HAL_DMA_MuxSyncConfigTypeDef pSyncConfig= {0};
   168f8:	e9cd 4404 	strd	r4, r4, [sp, #16]
   168fc:	e9cd 4406 	strd	r4, r4, [sp, #24]
  if(adcHandle->Instance==ADC1)
   16900:	d002      	beq.n	16908 <HAL_ADC_MspInit+0x28>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
   16902:	b00f      	add	sp, #60	; 0x3c
   16904:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_ADC12_CLK_ENABLE();
   16908:	4b3e      	ldr	r3, [pc, #248]	; (16a04 <HAL_ADC_MspInit+0x124>)
   1690a:	4606      	mov	r6, r0
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_5;
   1690c:	2022      	movs	r0, #34	; 0x22
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   1690e:	2703      	movs	r7, #3
    __HAL_RCC_ADC12_CLK_ENABLE();
   16910:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   16914:	a909      	add	r1, sp, #36	; 0x24
    hdma_adc1.Instance = DMA2_Stream0;
   16916:	4d3c      	ldr	r5, [pc, #240]	; (16a08 <HAL_ADC_MspInit+0x128>)
    __HAL_RCC_ADC12_CLK_ENABLE();
   16918:	f042 0220 	orr.w	r2, r2, #32
   1691c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
   16920:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
   16924:	f002 0220 	and.w	r2, r2, #32
   16928:	9201      	str	r2, [sp, #4]
   1692a:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
   1692c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   16930:	f042 0204 	orr.w	r2, r2, #4
   16934:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   16938:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1693c:	f002 0204 	and.w	r2, r2, #4
   16940:	9202      	str	r2, [sp, #8]
   16942:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
   16944:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   16948:	f042 0201 	orr.w	r2, r2, #1
   1694c:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   16950:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_5;
   16954:	9009      	str	r0, [sp, #36]	; 0x24
    __HAL_RCC_GPIOA_CLK_ENABLE();
   16956:	f003 0301 	and.w	r3, r3, #1
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1695a:	482c      	ldr	r0, [pc, #176]	; (16a0c <HAL_ADC_MspInit+0x12c>)
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   1695c:	970a      	str	r7, [sp, #40]	; 0x28
    __HAL_RCC_GPIOA_CLK_ENABLE();
   1695e:	9303      	str	r3, [sp, #12]
   16960:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   16962:	f7f5 f92d 	bl	bbc0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5 
   16966:	23ad      	movs	r3, #173	; 0xad
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   16968:	a909      	add	r1, sp, #36	; 0x24
   1696a:	4829      	ldr	r0, [pc, #164]	; (16a10 <HAL_ADC_MspInit+0x130>)
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5 
   1696c:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1696e:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   16972:	f7f5 f925 	bl	bbc0 <HAL_GPIO_Init>
    hdma_adc1.Instance = DMA2_Stream0;
   16976:	4b27      	ldr	r3, [pc, #156]	; (16a14 <HAL_ADC_MspInit+0x134>)
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
   16978:	f44f 6080 	mov.w	r0, #1024	; 0x400
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
   1697c:	f04f 0e09 	mov.w	lr, #9
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   16980:	f44f 6c00 	mov.w	ip, #2048	; 0x800
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   16984:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
   16988:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
   1698c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    hdma_adc1.Instance = DMA2_Stream0;
   16990:	602b      	str	r3, [r5, #0]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   16992:	2304      	movs	r3, #4
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
   16994:	6128      	str	r0, [r5, #16]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
   16996:	4628      	mov	r0, r5
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
   16998:	60ac      	str	r4, [r5, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
   1699a:	60ec      	str	r4, [r5, #12]
    hdma_adc1.Init.PeriphBurst = DMA_PBURST_SINGLE;
   1699c:	632c      	str	r4, [r5, #48]	; 0x30
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
   1699e:	f8c5 e004 	str.w	lr, [r5, #4]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   169a2:	626b      	str	r3, [r5, #36]	; 0x24
    hdma_adc1.Init.MemBurst = DMA_MBURST_SINGLE;
   169a4:	e9c5 440a 	strd	r4, r4, [r5, #40]	; 0x28
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   169a8:	e9c5 c705 	strd	ip, r7, [r5, #20]
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
   169ac:	e9c5 1207 	strd	r1, r2, [r5, #28]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
   169b0:	f7f3 f9dc 	bl	9d6c <HAL_DMA_Init>
   169b4:	b9f0      	cbnz	r0, 169f4 <HAL_ADC_MspInit+0x114>
    pSyncConfig.EventEnable = ENABLE;
   169b6:	2301      	movs	r3, #1
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
   169b8:	f04f 0806 	mov.w	r8, #6
   169bc:	f44f 3900 	mov.w	r9, #131072	; 0x20000
    pSyncConfig.SyncEnable = DISABLE;
   169c0:	2200      	movs	r2, #0
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
   169c2:	a904      	add	r1, sp, #16
   169c4:	4810      	ldr	r0, [pc, #64]	; (16a08 <HAL_ADC_MspInit+0x128>)
    pSyncConfig.SyncEnable = DISABLE;
   169c6:	f88d 2018 	strb.w	r2, [sp, #24]
    pSyncConfig.EventEnable = ENABLE;
   169ca:	f88d 3019 	strb.w	r3, [sp, #25]
    pSyncConfig.RequestNumber = 1;
   169ce:	9307      	str	r3, [sp, #28]
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
   169d0:	e9cd 8904 	strd	r8, r9, [sp, #16]
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
   169d4:	f7f4 fc9c 	bl	b310 <HAL_DMAEx_ConfigMuxSync>
   169d8:	b978      	cbnz	r0, 169fa <HAL_ADC_MspInit+0x11a>
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
   169da:	2200      	movs	r2, #0
   169dc:	2105      	movs	r1, #5
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
   169de:	64f5      	str	r5, [r6, #76]	; 0x4c
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
   169e0:	2012      	movs	r0, #18
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
   169e2:	63ae      	str	r6, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
   169e4:	f7f2 fff6 	bl	99d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
   169e8:	2012      	movs	r0, #18
   169ea:	f7f3 f839 	bl	9a60 <HAL_NVIC_EnableIRQ>
}
   169ee:	b00f      	add	sp, #60	; 0x3c
   169f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      Error_Handler();
   169f4:	f002 fd0c 	bl	19410 <Error_Handler>
   169f8:	e7dd      	b.n	169b6 <HAL_ADC_MspInit+0xd6>
      Error_Handler();
   169fa:	f002 fd09 	bl	19410 <Error_Handler>
   169fe:	e7ec      	b.n	169da <HAL_ADC_MspInit+0xfa>
   16a00:	40022000 	.word	0x40022000
   16a04:	58024400 	.word	0x58024400
   16a08:	020e3038 	.word	0x020e3038
   16a0c:	58020800 	.word	0x58020800
   16a10:	58020000 	.word	0x58020000
   16a14:	40020410 	.word	0x40020410

00016a18 <audioFrame>:
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

void audioFrame(uint16_t buffer_offset)
{
   16a18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16a1c:	ed2d 8b04 	vpush	{d8-d9}
   16a20:	b087      	sub	sp, #28
   16a22:	4681      	mov	r9, r0
	//int32_t current_sample;
	uint32_t clipCatcher = 0;

	//tempCount5 = DWT->CYCCNT;

	buttonCheck();
   16a24:	f00b fd58 	bl	224d8 <buttonCheck>

	adcCheck();
   16a28:	f00c f8ee 	bl	22c08 <adcCheck>

	// if the USB write pointer has advanced (indicating unread data is in the buffer),
	// or the overflow bit is set, meaning that the write pointer wrapped around and the read pointer hasn't caught up to it yet
	// then process that new data this frame
	if ((myUSB_FIFO_overflowBit) || (myUSB_FIFO_writePointer > myUSB_FIFO_readPointer))
   16a2c:	4bbb      	ldr	r3, [pc, #748]	; (16d1c <audioFrame+0x304>)
   16a2e:	781b      	ldrb	r3, [r3, #0]
   16a30:	2b00      	cmp	r3, #0
   16a32:	f040 816f 	bne.w	16d14 <audioFrame+0x2fc>
   16a36:	4bba      	ldr	r3, [pc, #744]	; (16d20 <audioFrame+0x308>)
   16a38:	4aba      	ldr	r2, [pc, #744]	; (16d24 <audioFrame+0x30c>)
   16a3a:	881b      	ldrh	r3, [r3, #0]
   16a3c:	8812      	ldrh	r2, [r2, #0]
   16a3e:	429a      	cmp	r2, r3
   16a40:	f0c0 8168 	bcc.w	16d14 <audioFrame+0x2fc>
	{
		ProcessReceivedMidiDatas();
	}


	if (!loadingPreset)
   16a44:	4bb8      	ldr	r3, [pc, #736]	; (16d28 <audioFrame+0x310>)
   16a46:	781b      	ldrb	r3, [r3, #0]
   16a48:	2b00      	cmp	r3, #0
   16a4a:	d154      	bne.n	16af6 <audioFrame+0xde>
   16a4c:	4cb7      	ldr	r4, [pc, #732]	; (16d2c <audioFrame+0x314>)
   16a4e:	f8df 8324 	ldr.w	r8, [pc, #804]	; 16d74 <audioFrame+0x35c>
   16a52:	4627      	mov	r7, r4
   16a54:	f104 0518 	add.w	r5, r4, #24
   16a58:	f8df b31c 	ldr.w	fp, [pc, #796]	; 16d78 <audioFrame+0x360>
   16a5c:	4eb4      	ldr	r6, [pc, #720]	; (16d30 <audioFrame+0x318>)
	{

		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
		{
			smoothedADC[i] = tExpSmooth_tick(&adc[i]);
   16a5e:	4640      	mov	r0, r8
   16a60:	f108 0804 	add.w	r8, r8, #4
   16a64:	f011 f9d6 	bl	27e14 <tExpSmooth_tick>
			for (int i = 0; i < KNOB_PAGE_SIZE; i++)
			{
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
   16a68:	4bb2      	ldr	r3, [pc, #712]	; (16d34 <audioFrame+0x31c>)
			smoothedADC[i] = tExpSmooth_tick(&adc[i]);
   16a6a:	eca7 0a01 	vstmia	r7!, {s0}
		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   16a6e:	42bd      	cmp	r5, r7
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
   16a70:	f893 a000 	ldrb.w	sl, [r3]
   16a74:	f89b 3000 	ldrb.w	r3, [fp]
   16a78:	eb0a 028a 	add.w	r2, sl, sl, lsl #2
   16a7c:	ed94 7a00 	vldr	s14, [r4]
   16a80:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   16a84:	edd4 7a01 	vldr	s15, [r4, #4]
   16a88:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   16a8c:	f103 0c01 	add.w	ip, r3, #1
   16a90:	f103 0002 	add.w	r0, r3, #2
   16a94:	eb02 0e03 	add.w	lr, r2, r3
   16a98:	f103 0103 	add.w	r1, r3, #3
   16a9c:	4494      	add	ip, r2
   16a9e:	f103 0304 	add.w	r3, r3, #4
   16aa2:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
   16aa6:	4410      	add	r0, r2
   16aa8:	eb06 0c8c 	add.w	ip, r6, ip, lsl #2
   16aac:	4411      	add	r1, r2
   16aae:	ed8e 7a00 	vstr	s14, [lr]
   16ab2:	eb06 0080 	add.w	r0, r6, r0, lsl #2
   16ab6:	4413      	add	r3, r2
   16ab8:	f8d4 e008 	ldr.w	lr, [r4, #8]
   16abc:	edcc 7a00 	vstr	s15, [ip]
   16ac0:	eb06 0181 	add.w	r1, r6, r1, lsl #2
   16ac4:	f8c0 e000 	str.w	lr, [r0]
   16ac8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
   16acc:	f8d4 c00c 	ldr.w	ip, [r4, #12]
   16ad0:	6920      	ldr	r0, [r4, #16]
   16ad2:	f8c1 c000 	str.w	ip, [r1]
   16ad6:	6018      	str	r0, [r3, #0]
		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   16ad8:	d1c1      	bne.n	16a5e <audioFrame+0x46>
			}
		}


		if (cvAddParam[currentPreset] >= 0)
   16ada:	4b97      	ldr	r3, [pc, #604]	; (16d38 <audioFrame+0x320>)
   16adc:	f913 300a 	ldrsb.w	r3, [r3, sl]
   16ae0:	2b00      	cmp	r3, #0
   16ae2:	db04      	blt.n	16aee <audioFrame+0xd6>
		{
			presetKnobValues[currentPreset][cvAddParam[currentPreset]] = smoothedADC[5];
   16ae4:	441a      	add	r2, r3
   16ae6:	6963      	ldr	r3, [r4, #20]
   16ae8:	eb06 0282 	add.w	r2, r6, r2, lsl #2
   16aec:	6013      	str	r3, [r2, #0]
		}

		frameFunctions[currentPreset]();
   16aee:	4b93      	ldr	r3, [pc, #588]	; (16d3c <audioFrame+0x324>)
   16af0:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
   16af4:	4798      	blx	r3
	//if the codec isn't ready, keep the buffer as all zeros
	//otherwise, start computing audio!

	bufferCleared = TRUE;

	if (codecReady)
   16af6:	4b92      	ldr	r3, [pc, #584]	; (16d40 <audioFrame+0x328>)
	bufferCleared = TRUE;
   16af8:	2201      	movs	r2, #1
   16afa:	4992      	ldr	r1, [pc, #584]	; (16d44 <audioFrame+0x32c>)
	if (codecReady)
   16afc:	781b      	ldrb	r3, [r3, #0]
	bufferCleared = TRUE;
   16afe:	700a      	strb	r2, [r1, #0]
	if (codecReady)
   16b00:	2b00      	cmp	r3, #0
   16b02:	f000 813f 	beq.w	16d84 <audioFrame+0x36c>
   16b06:	eb09 0402 	add.w	r4, r9, r2
	uint32_t clipCatcher = 0;
   16b0a:	2500      	movs	r5, #0
   16b0c:	f8df 826c 	ldr.w	r8, [pc, #620]	; 16d7c <audioFrame+0x364>
   16b10:	4b85      	ldr	r3, [pc, #532]	; (16d28 <audioFrame+0x310>)
   16b12:	00a4      	lsls	r4, r4, #2
   16b14:	9501      	str	r5, [sp, #4]
   16b16:	f508 6b00 	add.w	fp, r8, #2048	; 0x800
   16b1a:	7819      	ldrb	r1, [r3, #0]
	{

		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
		{
			float theSamples[2];
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b1c:	ed9f 8a8a 	vldr	s16, [pc, #552]	; 16d48 <audioFrame+0x330>
	//uint32_t tempCount5 = DWT->CYCCNT;

	//cycleCountVals[1][2] = 0;


	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   16b20:	eddf 9a8a 	vldr	s19, [pc, #552]	; 16d4c <audioFrame+0x334>
   16b24:	ed9f 9a8a 	vldr	s18, [pc, #552]	; 16d50 <audioFrame+0x338>
	{
		clips |= 2;
	}


	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16b28:	eddf 8a8a 	vldr	s17, [pc, #552]	; 16d54 <audioFrame+0x33c>
   16b2c:	e00b      	b.n	16b46 <audioFrame+0x12e>
	if (loadingPreset)
   16b2e:	2300      	movs	r3, #0
   16b30:	461a      	mov	r2, r3
		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
   16b32:	3502      	adds	r5, #2
			audioOutBuffer[buffer_offset + i] = (int32_t)(theSamples[1] * TWO_TO_23);
   16b34:	f84b 2026 	str.w	r2, [fp, r6, lsl #2]
			audioOutBuffer[buffer_offset + i + 1] = (int32_t)(theSamples[0] * TWO_TO_23);
   16b38:	f84b 3004 	str.w	r3, [fp, r4]
   16b3c:	3408      	adds	r4, #8
		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
   16b3e:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
   16b42:	f000 8166 	beq.w	16e12 <audioFrame+0x3fa>
   16b46:	eb05 0609 	add.w	r6, r5, r9
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b4a:	f858 2004 	ldr.w	r2, [r8, r4]
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b4e:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b52:	0212      	lsls	r2, r2, #8
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b54:	021b      	lsls	r3, r3, #8
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b56:	ee00 2a90 	vmov	s1, r2
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b5a:	ee07 3a90 	vmov	s15, r3
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b5e:	eef8 0ae0 	vcvt.f32.s32	s1, s1
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b62:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b66:	ee60 0a88 	vmul.f32	s1, s1, s16
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b6a:	ee67 7a88 	vmul.f32	s15, s15, s16
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b6e:	edcd 0a05 	vstr	s1, [sp, #20]
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b72:	edcd 7a04 	vstr	s15, [sp, #16]
	if (loadingPreset)
   16b76:	2900      	cmp	r1, #0
   16b78:	d1d9      	bne.n	16b2e <audioFrame+0x116>
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   16b7a:	eef4 0ae9 	vcmpe.f32	s1, s19
   16b7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16b82:	eef4 0ac9 	vcmpe.f32	s1, s18
   16b86:	bf94      	ite	ls
   16b88:	2201      	movls	r2, #1
   16b8a:	2200      	movhi	r2, #0
   16b8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
   16b90:	eef4 7ac9 	vcmpe.f32	s15, s18
	uint32_t clips = 0;
   16b94:	bfa8      	it	ge
   16b96:	f042 0201 	orrge.w	r2, r2, #1
	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
   16b9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16b9e:	da04      	bge.n	16baa <audioFrame+0x192>
   16ba0:	eef4 7a69 	vcmp.f32	s15, s19
   16ba4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16ba8:	d801      	bhi.n	16bae <audioFrame+0x196>
		clips |= 2;
   16baa:	f042 0202 	orr.w	r2, r2, #2
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16bae:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   16bb2:	9203      	str	r2, [sp, #12]
   16bb4:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   16bb8:	4f67      	ldr	r7, [pc, #412]	; (16d58 <audioFrame+0x340>)
   16bba:	f012 fdb5 	bl	29728 <LEAF_clip>
   16bbe:	4867      	ldr	r0, [pc, #412]	; (16d5c <audioFrame+0x344>)
   16bc0:	f00d fae0 	bl	24184 <tEnvelopeFollower_tick>
   16bc4:	ee20 0a28 	vmul.f32	s0, s0, s17
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
   16bc8:	4865      	ldr	r0, [pc, #404]	; (16d60 <audioFrame+0x348>)
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16bca:	a904      	add	r1, sp, #16
   16bcc:	eddd 0a04 	vldr	s1, [sp, #16]
   16bd0:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16bd4:	eefc 7ac0 	vcvt.u32.f32	s15, s0
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
   16bd8:	6800      	ldr	r0, [r0, #0]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16bda:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   16bde:	9102      	str	r1, [sp, #8]
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
   16be0:	f8df a19c 	ldr.w	sl, [pc, #412]	; 16d80 <audioFrame+0x368>
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16be4:	ee17 3a90 	vmov	r3, s15
   16be8:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   16bec:	edd3 7a00 	vldr	s15, [r3]
   16bf0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
   16bf4:	ee17 3a90 	vmov	r3, s15
   16bf8:	b29b      	uxth	r3, r3
   16bfa:	6383      	str	r3, [r0, #56]	; 0x38
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16bfc:	f012 fd94 	bl	29728 <LEAF_clip>
   16c00:	4858      	ldr	r0, [pc, #352]	; (16d64 <audioFrame+0x34c>)
   16c02:	f00d fabf 	bl	24184 <tEnvelopeFollower_tick>
   16c06:	ee20 0a28 	vmul.f32	s0, s0, s17


	tickFunctions[currentPreset](samples);
   16c0a:	9902      	ldr	r1, [sp, #8]
   16c0c:	4b49      	ldr	r3, [pc, #292]	; (16d34 <audioFrame+0x31c>)
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16c0e:	eefc 7ac0 	vcvt.u32.f32	s15, s0
	tickFunctions[currentPreset](samples);
   16c12:	4608      	mov	r0, r1
   16c14:	f893 e000 	ldrb.w	lr, [r3]
   16c18:	4b53      	ldr	r3, [pc, #332]	; (16d68 <audioFrame+0x350>)
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16c1a:	ee17 1a90 	vmov	r1, s15
   16c1e:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   16c22:	edd1 7a00 	vldr	s15, [r1]
   16c26:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
   16c2a:	ee17 2a90 	vmov	r2, s15
   16c2e:	b291      	uxth	r1, r2
   16c30:	f8da 2000 	ldr.w	r2, [sl]
   16c34:	6391      	str	r1, [r2, #56]	; 0x38
	tickFunctions[currentPreset](samples);
   16c36:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
   16c3a:	4798      	blx	r3

	//now the samples array is output
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   16c3c:	eddd 0a05 	vldr	s1, [sp, #20]
   16c40:	9a03      	ldr	r2, [sp, #12]
   16c42:	eef4 0ac9 	vcmpe.f32	s1, s18
   16c46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16c4a:	da04      	bge.n	16c56 <audioFrame+0x23e>
   16c4c:	eef4 0a69 	vcmp.f32	s1, s19
   16c50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16c54:	d801      	bhi.n	16c5a <audioFrame+0x242>
	{
		clips |= 4;
   16c56:	f042 0204 	orr.w	r2, r2, #4
	}

	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
   16c5a:	eddd 7a04 	vldr	s15, [sp, #16]
   16c5e:	eef4 7ae9 	vcmpe.f32	s15, s19
   16c62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16c66:	d904      	bls.n	16c72 <audioFrame+0x25a>
   16c68:	eef4 7a49 	vcmp.f32	s15, s18
   16c6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16c70:	db01      	blt.n	16c76 <audioFrame+0x25e>
	{
		clips |= 8;
   16c72:	f042 0208 	orr.w	r2, r2, #8
   16c76:	9b01      	ldr	r3, [sp, #4]
	}
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[1], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16c78:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   16c7c:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   16c80:	4313      	orrs	r3, r2
   16c82:	9301      	str	r3, [sp, #4]
   16c84:	f012 fd50 	bl	29728 <LEAF_clip>
   16c88:	4838      	ldr	r0, [pc, #224]	; (16d6c <audioFrame+0x354>)
   16c8a:	f00d fa7b 	bl	24184 <tEnvelopeFollower_tick>
   16c8e:	ee60 7a28 	vmul.f32	s15, s0, s17
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, current_env);
   16c92:	f8da 3000 	ldr.w	r3, [sl]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16c96:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   16c9a:	eddd 0a04 	vldr	s1, [sp, #16]
   16c9e:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[1], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16ca2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   16ca6:	ee17 2a90 	vmov	r2, s15
   16caa:	eb07 0282 	add.w	r2, r7, r2, lsl #2
   16cae:	edd2 7a00 	vldr	s15, [r2]
   16cb2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, current_env);
   16cb6:	ee17 2a90 	vmov	r2, s15
   16cba:	b292      	uxth	r2, r2
   16cbc:	63da      	str	r2, [r3, #60]	; 0x3c
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16cbe:	f012 fd33 	bl	29728 <LEAF_clip>
   16cc2:	482b      	ldr	r0, [pc, #172]	; (16d70 <audioFrame+0x358>)
   16cc4:	f00d fa5e 	bl	24184 <tEnvelopeFollower_tick>
   16cc8:	ee20 0a28 	vmul.f32	s0, s0, s17
   16ccc:	4b16      	ldr	r3, [pc, #88]	; (16d28 <audioFrame+0x310>)
   16cce:	ed9d 7a05 	vldr	s14, [sp, #20]
   16cd2:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   16cd6:	7819      	ldrb	r1, [r3, #0]
   16cd8:	eddd 7a04 	vldr	s15, [sp, #16]
   16cdc:	eef0 6a47 	vmov.f32	s13, s14
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, current_env);
   16ce0:	f8da c000 	ldr.w	ip, [sl]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16ce4:	ee10 3a10 	vmov	r3, s0
   16ce8:	eeb0 7a67 	vmov.f32	s14, s15
   16cec:	eefe 6ae4 	vcvt.s32.f32	s13, s13, #23
   16cf0:	eb07 0783 	add.w	r7, r7, r3, lsl #2
   16cf4:	eebe 7ae4 	vcvt.s32.f32	s14, s14, #23
   16cf8:	edd7 7a00 	vldr	s15, [r7]
   16cfc:	ee16 2a90 	vmov	r2, s13
   16d00:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   16d04:	ee17 3a10 	vmov	r3, s14
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, current_env);
   16d08:	ee17 0a90 	vmov	r0, s15
   16d0c:	b280      	uxth	r0, r0
   16d0e:	f8cc 0034 	str.w	r0, [ip, #52]	; 0x34
   16d12:	e70e      	b.n	16b32 <audioFrame+0x11a>
		ProcessReceivedMidiDatas();
   16d14:	f7ff fcb0 	bl	16678 <ProcessReceivedMidiDatas>
   16d18:	e694      	b.n	16a44 <audioFrame+0x2c>
   16d1a:	bf00      	nop
   16d1c:	020e2f1d 	.word	0x020e2f1d
   16d20:	020e2f20 	.word	0x020e2f20
   16d24:	020e2f1e 	.word	0x020e2f1e
   16d28:	020e2f1b 	.word	0x020e2f1b
   16d2c:	020fb0ec 	.word	0x020fb0ec
   16d30:	020e55d8 	.word	0x020e55d8
   16d34:	020e2f19 	.word	0x020e2f19
   16d38:	020fb200 	.word	0x020fb200
   16d3c:	020e319c 	.word	0x020e319c
   16d40:	020e2dc0 	.word	0x020e2dc0
   16d44:	00062565 	.word	0x00062565
   16d48:	2ffffff6 	.word	0x2ffffff6
   16d4c:	bf7fffef 	.word	0xbf7fffef
   16d50:	3f7fffef 	.word	0x3f7fffef
   16d54:	43ff8000 	.word	0x43ff8000
   16d58:	020e31f4 	.word	0x020e31f4
   16d5c:	020e31e4 	.word	0x020e31e4
   16d60:	020faf48 	.word	0x020faf48
   16d64:	020e31ec 	.word	0x020e31ec
   16d68:	020e30b8 	.word	0x020e30b8
   16d6c:	020e31e8 	.word	0x020e31e8
   16d70:	020e31f0 	.word	0x020e31f0
   16d74:	020fb0c0 	.word	0x020fb0c0
   16d78:	020e2f1a 	.word	0x020e2f1a
   16d7c:	00062a80 	.word	0x00062a80
   16d80:	020faf08 	.word	0x020faf08
	uint32_t clipCatcher = 0;
   16d84:	9301      	str	r3, [sp, #4]
		numBuffersCleared++;
   16d86:	4a4b      	ldr	r2, [pc, #300]	; (16eb4 <audioFrame+0x49c>)
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   16d88:	494b      	ldr	r1, [pc, #300]	; (16eb8 <audioFrame+0x4a0>)
		numBuffersCleared++;
   16d8a:	6813      	ldr	r3, [r2, #0]
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   16d8c:	6809      	ldr	r1, [r1, #0]
		numBuffersCleared++;
   16d8e:	3301      	adds	r3, #1
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   16d90:	428b      	cmp	r3, r1
		numBuffersCleared++;
   16d92:	6013      	str	r3, [r2, #0]
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   16d94:	da47      	bge.n	16e26 <audioFrame+0x40e>
	uint32_t clipCatcher = 0;
   16d96:	2400      	movs	r4, #0
   16d98:	4d48      	ldr	r5, [pc, #288]	; (16ebc <audioFrame+0x4a4>)
   16d9a:	f8df 8148 	ldr.w	r8, [pc, #328]	; 16ee4 <audioFrame+0x4cc>
			clipCounter[i] = 80;
   16d9e:	2750      	movs	r7, #80	; 0x50
			clipHappened[i] = 0;
   16da0:	4e47      	ldr	r6, [pc, #284]	; (16ec0 <audioFrame+0x4a8>)
   16da2:	f8dd 9004 	ldr.w	r9, [sp, #4]
		if ((clipCatcher >> i) & 1)
   16da6:	fa29 f304 	lsr.w	r3, r9, r4
   16daa:	07db      	lsls	r3, r3, #31
   16dac:	d51c      	bpl.n	16de8 <audioFrame+0x3d0>
			switch (i)
   16dae:	2c02      	cmp	r4, #2
   16db0:	d06f      	beq.n	16e92 <audioFrame+0x47a>
   16db2:	2c03      	cmp	r4, #3
   16db4:	d069      	beq.n	16e8a <audioFrame+0x472>
   16db6:	2c01      	cmp	r4, #1
   16db8:	d063      	beq.n	16e82 <audioFrame+0x46a>
					setLED_leftin_clip(1);
   16dba:	2001      	movs	r0, #1
   16dbc:	f002 fbb0 	bl	19520 <setLED_leftin_clip>
			clipped[i] = 1;
   16dc0:	2101      	movs	r1, #1
			clipHappened[i] = 0;
   16dc2:	2200      	movs	r2, #0
   16dc4:	00a3      	lsls	r3, r4, #2
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
   16dc6:	2050      	movs	r0, #80	; 0x50
			clipCounter[i] = 80;
   16dc8:	f845 7024 	str.w	r7, [r5, r4, lsl #2]
			clipped[i] = 1;
   16dcc:	f808 1004 	strb.w	r1, [r8, r4]
			clipHappened[i] = 0;
   16dd0:	f846 2024 	str.w	r2, [r6, r4, lsl #2]
			clipCounter[i]--;
   16dd4:	3801      	subs	r0, #1
   16dd6:	50e8      	str	r0, [r5, r3]
	for (int i = 0; i < 4; i++)
   16dd8:	3401      	adds	r4, #1
   16dda:	2c04      	cmp	r4, #4
   16ddc:	d1e3      	bne.n	16da6 <audioFrame+0x38e>
}
   16dde:	b007      	add	sp, #28
   16de0:	ecbd 8b04 	vpop	{d8-d9}
   16de4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
   16de8:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   16dec:	00a3      	lsls	r3, r4, #2
   16dee:	f818 2004 	ldrb.w	r2, [r8, r4]
   16df2:	2800      	cmp	r0, #0
   16df4:	d15a      	bne.n	16eac <audioFrame+0x494>
		else if ((clipCounter[i] == 0) && (clipped[i] == 1))
   16df6:	2a01      	cmp	r2, #1
   16df8:	d1ee      	bne.n	16dd8 <audioFrame+0x3c0>
			switch (i)
   16dfa:	2c02      	cmp	r4, #2
   16dfc:	d04d      	beq.n	16e9a <audioFrame+0x482>
   16dfe:	2c03      	cmp	r4, #3
   16e00:	d051      	beq.n	16ea6 <audioFrame+0x48e>
   16e02:	2c01      	cmp	r4, #1
   16e04:	d04c      	beq.n	16ea0 <audioFrame+0x488>
					setLED_leftin_clip(0);
   16e06:	f002 fb8b 	bl	19520 <setLED_leftin_clip>
			clipped[i] = 0;
   16e0a:	2300      	movs	r3, #0
   16e0c:	f808 3004 	strb.w	r3, [r8, r4]
   16e10:	e7e2      	b.n	16dd8 <audioFrame+0x3c0>
			bufferCleared = 0;
   16e12:	4b2c      	ldr	r3, [pc, #176]	; (16ec4 <audioFrame+0x4ac>)
		if (!loadingPreset)
   16e14:	2900      	cmp	r1, #0
   16e16:	d032      	beq.n	16e7e <audioFrame+0x466>
	if (bufferCleared)
   16e18:	781b      	ldrb	r3, [r3, #0]
   16e1a:	2b00      	cmp	r3, #0
   16e1c:	d1b3      	bne.n	16d86 <audioFrame+0x36e>
	else numBuffersCleared = 0;
   16e1e:	4b25      	ldr	r3, [pc, #148]	; (16eb4 <audioFrame+0x49c>)
   16e20:	2200      	movs	r2, #0
   16e22:	601a      	str	r2, [r3, #0]
   16e24:	e7b7      	b.n	16d96 <audioFrame+0x37e>
			if (loadingPreset)
   16e26:	4b28      	ldr	r3, [pc, #160]	; (16ec8 <audioFrame+0x4b0>)
			numBuffersCleared = numBuffersToClearOnLoad;
   16e28:	6011      	str	r1, [r2, #0]
			if (loadingPreset)
   16e2a:	781b      	ldrb	r3, [r3, #0]
   16e2c:	2b00      	cmp	r3, #0
   16e2e:	d0b2      	beq.n	16d96 <audioFrame+0x37e>
				if (previousPreset != PresetNil)
   16e30:	4b26      	ldr	r3, [pc, #152]	; (16ecc <audioFrame+0x4b4>)
   16e32:	781b      	ldrb	r3, [r3, #0]
   16e34:	2b12      	cmp	r3, #18
   16e36:	d003      	beq.n	16e40 <audioFrame+0x428>
					freeFunctions[previousPreset]();
   16e38:	4a25      	ldr	r2, [pc, #148]	; (16ed0 <audioFrame+0x4b8>)
   16e3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16e3e:	4798      	blx	r3
				setLED_A(0);
   16e40:	2000      	movs	r0, #0
				knobPage = 0;
   16e42:	4604      	mov	r4, r0
				setLED_A(0);
   16e44:	f002 fb24 	bl	19490 <setLED_A>
				setLED_B(0);
   16e48:	4620      	mov	r0, r4
   16e4a:	f002 fb2f 	bl	194ac <setLED_B>
				setLED_C(0);
   16e4e:	4620      	mov	r0, r4
   16e50:	f002 fb3a 	bl	194c8 <setLED_C>
				setLED_Edit(0);
   16e54:	4620      	mov	r0, r4
   16e56:	f002 fadf 	bl	19418 <setLED_Edit>
				setLED_1(0);
   16e5a:	4620      	mov	r0, r4
   16e5c:	f002 faf8 	bl	19450 <setLED_1>
				knobPage = 0;
   16e60:	4b1c      	ldr	r3, [pc, #112]	; (16ed4 <audioFrame+0x4bc>)
   16e62:	701c      	strb	r4, [r3, #0]
				resetKnobValues();
   16e64:	f00b ffce 	bl	22e04 <resetKnobValues>
				allocFunctions[currentPreset]();
   16e68:	4b1b      	ldr	r3, [pc, #108]	; (16ed8 <audioFrame+0x4c0>)
				leaf.clearOnAllocation = 0;
   16e6a:	491c      	ldr	r1, [pc, #112]	; (16edc <audioFrame+0x4c4>)
				allocFunctions[currentPreset]();
   16e6c:	781a      	ldrb	r2, [r3, #0]
   16e6e:	4b1c      	ldr	r3, [pc, #112]	; (16ee0 <audioFrame+0x4c8>)
				leaf.clearOnAllocation = 0;
   16e70:	614c      	str	r4, [r1, #20]
				allocFunctions[currentPreset]();
   16e72:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   16e76:	4798      	blx	r3
				loadingPreset = 0;
   16e78:	4b13      	ldr	r3, [pc, #76]	; (16ec8 <audioFrame+0x4b0>)
   16e7a:	701c      	strb	r4, [r3, #0]
   16e7c:	e78b      	b.n	16d96 <audioFrame+0x37e>
			bufferCleared = 0;
   16e7e:	7019      	strb	r1, [r3, #0]
   16e80:	e7cd      	b.n	16e1e <audioFrame+0x406>
					setLED_rightin_clip(1);
   16e82:	4620      	mov	r0, r4
   16e84:	f002 fb5a 	bl	1953c <setLED_rightin_clip>
					break;
   16e88:	e79a      	b.n	16dc0 <audioFrame+0x3a8>
					setLED_rightout_clip(1);
   16e8a:	2001      	movs	r0, #1
   16e8c:	f002 fb3a 	bl	19504 <setLED_rightout_clip>
					break;
   16e90:	e796      	b.n	16dc0 <audioFrame+0x3a8>
					setLED_leftout_clip(1);
   16e92:	2001      	movs	r0, #1
   16e94:	f002 fb28 	bl	194e8 <setLED_leftout_clip>
					break;
   16e98:	e792      	b.n	16dc0 <audioFrame+0x3a8>
					setLED_leftout_clip(0);
   16e9a:	f002 fb25 	bl	194e8 <setLED_leftout_clip>
					break;
   16e9e:	e7b4      	b.n	16e0a <audioFrame+0x3f2>
					setLED_rightin_clip(0);
   16ea0:	f002 fb4c 	bl	1953c <setLED_rightin_clip>
					break;
   16ea4:	e7b1      	b.n	16e0a <audioFrame+0x3f2>
					setLED_rightout_clip(0);
   16ea6:	f002 fb2d 	bl	19504 <setLED_rightout_clip>
					break;
   16eaa:	e7ae      	b.n	16e0a <audioFrame+0x3f2>
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
   16eac:	2a01      	cmp	r2, #1
   16eae:	d193      	bne.n	16dd8 <audioFrame+0x3c0>
   16eb0:	e790      	b.n	16dd4 <audioFrame+0x3bc>
   16eb2:	bf00      	nop
   16eb4:	020e2dc4 	.word	0x020e2dc4
   16eb8:	00062568 	.word	0x00062568
   16ebc:	020e2d9c 	.word	0x020e2d9c
   16ec0:	020e2dac 	.word	0x020e2dac
   16ec4:	00062565 	.word	0x00062565
   16ec8:	020e2f1b 	.word	0x020e2f1b
   16ecc:	00062828 	.word	0x00062828
   16ed0:	020e3104 	.word	0x020e3104
   16ed4:	020e2f1a 	.word	0x020e2f1a
   16ed8:	020e2f19 	.word	0x020e2f19
   16edc:	020fbd68 	.word	0x020fbd68
   16ee0:	020e3150 	.word	0x020e3150
   16ee4:	020e2dbc 	.word	0x020e2dbc

00016ee8 <initFunctionPointers>:
}

*/

void initFunctionPointers(void)
{
   16ee8:	b430      	push	{r4, r5}
	allocFunctions[Vocoder] = SFXVocoderAlloc;
   16eea:	484b      	ldr	r0, [pc, #300]	; (17018 <initFunctionPointers+0x130>)
   16eec:	4c4b      	ldr	r4, [pc, #300]	; (1701c <initFunctionPointers+0x134>)
	frameFunctions[Vocoder] = SFXVocoderFrame;
	tickFunctions[Vocoder] = SFXVocoderTick;
	freeFunctions[Vocoder] = SFXVocoderFree;

	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
   16eee:	4d4c      	ldr	r5, [pc, #304]	; (17020 <initFunctionPointers+0x138>)
	allocFunctions[Vocoder] = SFXVocoderAlloc;
   16ef0:	6004      	str	r4, [r0, #0]
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
	tickFunctions[VocoderCh] = SFXVocoderChTick;
	freeFunctions[VocoderCh] = SFXVocoderChFree;

	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
   16ef2:	4b4c      	ldr	r3, [pc, #304]	; (17024 <initFunctionPointers+0x13c>)
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
	freeFunctions[Pitchshift] = SFXPitchShiftFree;

	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
   16ef4:	494c      	ldr	r1, [pc, #304]	; (17028 <initFunctionPointers+0x140>)
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
	freeFunctions[AutotuneMono] = SFXNeartuneFree;

	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
   16ef6:	4a4d      	ldr	r2, [pc, #308]	; (1702c <initFunctionPointers+0x144>)
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
	freeFunctions[AutotunePoly] = SFXAutotuneFree;

	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
   16ef8:	4c4d      	ldr	r4, [pc, #308]	; (17030 <initFunctionPointers+0x148>)
	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
   16efa:	6045      	str	r5, [r0, #4]
	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
   16efc:	6083      	str	r3, [r0, #8]
	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
   16efe:	60c1      	str	r1, [r0, #12]
	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
   16f00:	6102      	str	r2, [r0, #16]
	frameFunctions[Vocoder] = SFXVocoderFrame;
   16f02:	494c      	ldr	r1, [pc, #304]	; (17034 <initFunctionPointers+0x14c>)
	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
   16f04:	6144      	str	r4, [r0, #20]
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;

	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
   16f06:	4d4c      	ldr	r5, [pc, #304]	; (17038 <initFunctionPointers+0x150>)
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;

	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
   16f08:	4b4c      	ldr	r3, [pc, #304]	; (1703c <initFunctionPointers+0x154>)
	frameFunctions[Vocoder] = SFXVocoderFrame;
   16f0a:	4a4d      	ldr	r2, [pc, #308]	; (17040 <initFunctionPointers+0x158>)
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
   16f0c:	4c4d      	ldr	r4, [pc, #308]	; (17044 <initFunctionPointers+0x15c>)
	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
   16f0e:	6185      	str	r5, [r0, #24]
	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
   16f10:	61c3      	str	r3, [r0, #28]
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
   16f12:	4d4d      	ldr	r5, [pc, #308]	; (17048 <initFunctionPointers+0x160>)
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
   16f14:	4b4d      	ldr	r3, [pc, #308]	; (1704c <initFunctionPointers+0x164>)
	frameFunctions[Vocoder] = SFXVocoderFrame;
   16f16:	600a      	str	r2, [r1, #0]
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
   16f18:	604c      	str	r4, [r1, #4]
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
   16f1a:	4a4d      	ldr	r2, [pc, #308]	; (17050 <initFunctionPointers+0x168>)
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
   16f1c:	4c4d      	ldr	r4, [pc, #308]	; (17054 <initFunctionPointers+0x16c>)
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
   16f1e:	608d      	str	r5, [r1, #8]
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
   16f20:	60cb      	str	r3, [r1, #12]
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
   16f22:	4d4d      	ldr	r5, [pc, #308]	; (17058 <initFunctionPointers+0x170>)
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
   16f24:	4b4d      	ldr	r3, [pc, #308]	; (1705c <initFunctionPointers+0x174>)
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
   16f26:	610a      	str	r2, [r1, #16]
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
   16f28:	614c      	str	r4, [r1, #20]
	tickFunctions[Vocoder] = SFXVocoderTick;
   16f2a:	4a4d      	ldr	r2, [pc, #308]	; (17060 <initFunctionPointers+0x178>)
   16f2c:	4c4d      	ldr	r4, [pc, #308]	; (17064 <initFunctionPointers+0x17c>)
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
   16f2e:	618d      	str	r5, [r1, #24]
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
   16f30:	61cb      	str	r3, [r1, #28]
	tickFunctions[VocoderCh] = SFXVocoderChTick;
   16f32:	4d4d      	ldr	r5, [pc, #308]	; (17068 <initFunctionPointers+0x180>)
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
   16f34:	4b4d      	ldr	r3, [pc, #308]	; (1706c <initFunctionPointers+0x184>)
	tickFunctions[Vocoder] = SFXVocoderTick;
   16f36:	6014      	str	r4, [r2, #0]
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
   16f38:	4c4d      	ldr	r4, [pc, #308]	; (17070 <initFunctionPointers+0x188>)
	tickFunctions[VocoderCh] = SFXVocoderChTick;
   16f3a:	6055      	str	r5, [r2, #4]
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
   16f3c:	6093      	str	r3, [r2, #8]
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
   16f3e:	4d4d      	ldr	r5, [pc, #308]	; (17074 <initFunctionPointers+0x18c>)
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
   16f40:	4b4d      	ldr	r3, [pc, #308]	; (17078 <initFunctionPointers+0x190>)
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
   16f42:	60d4      	str	r4, [r2, #12]
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
   16f44:	4c4d      	ldr	r4, [pc, #308]	; (1707c <initFunctionPointers+0x194>)
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
   16f46:	6115      	str	r5, [r2, #16]
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
   16f48:	6153      	str	r3, [r2, #20]
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
   16f4a:	4d4d      	ldr	r5, [pc, #308]	; (17080 <initFunctionPointers+0x198>)
	freeFunctions[Vocoder] = SFXVocoderFree;
   16f4c:	4b4d      	ldr	r3, [pc, #308]	; (17084 <initFunctionPointers+0x19c>)
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
   16f4e:	6194      	str	r4, [r2, #24]
	freeFunctions[Vocoder] = SFXVocoderFree;
   16f50:	4c4d      	ldr	r4, [pc, #308]	; (17088 <initFunctionPointers+0x1a0>)
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
   16f52:	61d5      	str	r5, [r2, #28]
	freeFunctions[Vocoder] = SFXVocoderFree;
   16f54:	601c      	str	r4, [r3, #0]
	freeFunctions[VocoderCh] = SFXVocoderChFree;
   16f56:	4d4d      	ldr	r5, [pc, #308]	; (1708c <initFunctionPointers+0x1a4>)
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
   16f58:	4c4d      	ldr	r4, [pc, #308]	; (17090 <initFunctionPointers+0x1a8>)
	freeFunctions[VocoderCh] = SFXVocoderChFree;
   16f5a:	605d      	str	r5, [r3, #4]
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
   16f5c:	609c      	str	r4, [r3, #8]
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
   16f5e:	4d4d      	ldr	r5, [pc, #308]	; (17094 <initFunctionPointers+0x1ac>)
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
   16f60:	4c4d      	ldr	r4, [pc, #308]	; (17098 <initFunctionPointers+0x1b0>)
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
   16f62:	60dd      	str	r5, [r3, #12]
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
   16f64:	611c      	str	r4, [r3, #16]
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
   16f66:	4d4d      	ldr	r5, [pc, #308]	; (1709c <initFunctionPointers+0x1b4>)
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
   16f68:	4c4d      	ldr	r4, [pc, #308]	; (170a0 <initFunctionPointers+0x1b8>)
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
   16f6a:	615d      	str	r5, [r3, #20]
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
   16f6c:	619c      	str	r4, [r3, #24]
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
   16f6e:	4d4d      	ldr	r5, [pc, #308]	; (170a4 <initFunctionPointers+0x1bc>)

	allocFunctions[Distortion] = SFXDistortionAlloc;
   16f70:	4c4d      	ldr	r4, [pc, #308]	; (170a8 <initFunctionPointers+0x1c0>)
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
   16f72:	61dd      	str	r5, [r3, #28]
	allocFunctions[Distortion] = SFXDistortionAlloc;
   16f74:	6204      	str	r4, [r0, #32]
	frameFunctions[Distortion] = SFXDistortionFrame;
   16f76:	4d4d      	ldr	r5, [pc, #308]	; (170ac <initFunctionPointers+0x1c4>)
	tickFunctions[Distortion] = SFXDistortionTick;
   16f78:	4c4d      	ldr	r4, [pc, #308]	; (170b0 <initFunctionPointers+0x1c8>)
	frameFunctions[Distortion] = SFXDistortionFrame;
   16f7a:	620d      	str	r5, [r1, #32]
	tickFunctions[Distortion] = SFXDistortionTick;
   16f7c:	6214      	str	r4, [r2, #32]
	freeFunctions[Distortion] = SFXDistortionFree;
   16f7e:	4d4d      	ldr	r5, [pc, #308]	; (170b4 <initFunctionPointers+0x1cc>)

	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
   16f80:	4c4d      	ldr	r4, [pc, #308]	; (170b8 <initFunctionPointers+0x1d0>)
	freeFunctions[Distortion] = SFXDistortionFree;
   16f82:	621d      	str	r5, [r3, #32]
	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
   16f84:	6244      	str	r4, [r0, #36]	; 0x24
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
   16f86:	4d4d      	ldr	r5, [pc, #308]	; (170bc <initFunctionPointers+0x1d4>)
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
   16f88:	4c4d      	ldr	r4, [pc, #308]	; (170c0 <initFunctionPointers+0x1d8>)
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
   16f8a:	624d      	str	r5, [r1, #36]	; 0x24
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
   16f8c:	6254      	str	r4, [r2, #36]	; 0x24
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
   16f8e:	4d4d      	ldr	r5, [pc, #308]	; (170c4 <initFunctionPointers+0x1dc>)

	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
   16f90:	4c4d      	ldr	r4, [pc, #308]	; (170c8 <initFunctionPointers+0x1e0>)
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
   16f92:	625d      	str	r5, [r3, #36]	; 0x24
	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
   16f94:	6284      	str	r4, [r0, #40]	; 0x28
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
   16f96:	4d4d      	ldr	r5, [pc, #308]	; (170cc <initFunctionPointers+0x1e4>)
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
   16f98:	4c4d      	ldr	r4, [pc, #308]	; (170d0 <initFunctionPointers+0x1e8>)
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
   16f9a:	628d      	str	r5, [r1, #40]	; 0x28
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
   16f9c:	6294      	str	r4, [r2, #40]	; 0x28
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
   16f9e:	4d4d      	ldr	r5, [pc, #308]	; (170d4 <initFunctionPointers+0x1ec>)

	allocFunctions[Delay] = SFXDelayAlloc;
   16fa0:	4c4d      	ldr	r4, [pc, #308]	; (170d8 <initFunctionPointers+0x1f0>)
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
   16fa2:	629d      	str	r5, [r3, #40]	; 0x28
	allocFunctions[Delay] = SFXDelayAlloc;
   16fa4:	62c4      	str	r4, [r0, #44]	; 0x2c
	frameFunctions[Delay] = SFXDelayFrame;
   16fa6:	4d4d      	ldr	r5, [pc, #308]	; (170dc <initFunctionPointers+0x1f4>)
	tickFunctions[Delay] = SFXDelayTick;
   16fa8:	4c4d      	ldr	r4, [pc, #308]	; (170e0 <initFunctionPointers+0x1f8>)
	frameFunctions[Delay] = SFXDelayFrame;
   16faa:	62cd      	str	r5, [r1, #44]	; 0x2c
	tickFunctions[Delay] = SFXDelayTick;
   16fac:	62d4      	str	r4, [r2, #44]	; 0x2c
	freeFunctions[Delay] = SFXDelayFree;
   16fae:	4d4d      	ldr	r5, [pc, #308]	; (170e4 <initFunctionPointers+0x1fc>)

	allocFunctions[Reverb] = SFXReverbAlloc;
   16fb0:	4c4d      	ldr	r4, [pc, #308]	; (170e8 <initFunctionPointers+0x200>)
	freeFunctions[Delay] = SFXDelayFree;
   16fb2:	62dd      	str	r5, [r3, #44]	; 0x2c
	allocFunctions[Reverb] = SFXReverbAlloc;
   16fb4:	6304      	str	r4, [r0, #48]	; 0x30
	frameFunctions[Reverb] = SFXReverbFrame;
   16fb6:	4d4d      	ldr	r5, [pc, #308]	; (170ec <initFunctionPointers+0x204>)
	tickFunctions[Reverb] = SFXReverbTick;
   16fb8:	4c4d      	ldr	r4, [pc, #308]	; (170f0 <initFunctionPointers+0x208>)
	frameFunctions[Reverb] = SFXReverbFrame;
   16fba:	630d      	str	r5, [r1, #48]	; 0x30
	tickFunctions[Reverb] = SFXReverbTick;
   16fbc:	6314      	str	r4, [r2, #48]	; 0x30
	freeFunctions[Reverb] = SFXReverbFree;
   16fbe:	4d4d      	ldr	r5, [pc, #308]	; (170f4 <initFunctionPointers+0x20c>)

	allocFunctions[Reverb2] = SFXReverb2Alloc;
   16fc0:	4c4d      	ldr	r4, [pc, #308]	; (170f8 <initFunctionPointers+0x210>)
	freeFunctions[Reverb] = SFXReverbFree;
   16fc2:	631d      	str	r5, [r3, #48]	; 0x30
	allocFunctions[Reverb2] = SFXReverb2Alloc;
   16fc4:	6344      	str	r4, [r0, #52]	; 0x34
	frameFunctions[Reverb2] = SFXReverb2Frame;
   16fc6:	4d4d      	ldr	r5, [pc, #308]	; (170fc <initFunctionPointers+0x214>)
	tickFunctions[Reverb2] = SFXReverb2Tick;
   16fc8:	4c4d      	ldr	r4, [pc, #308]	; (17100 <initFunctionPointers+0x218>)
	frameFunctions[Reverb2] = SFXReverb2Frame;
   16fca:	634d      	str	r5, [r1, #52]	; 0x34
	tickFunctions[Reverb2] = SFXReverb2Tick;
   16fcc:	6354      	str	r4, [r2, #52]	; 0x34
	freeFunctions[Reverb2] = SFXReverb2Free;
   16fce:	4d4d      	ldr	r5, [pc, #308]	; (17104 <initFunctionPointers+0x21c>)

	allocFunctions[LivingString] = SFXLivingStringAlloc;
   16fd0:	4c4d      	ldr	r4, [pc, #308]	; (17108 <initFunctionPointers+0x220>)
	freeFunctions[Reverb2] = SFXReverb2Free;
   16fd2:	635d      	str	r5, [r3, #52]	; 0x34
	allocFunctions[LivingString] = SFXLivingStringAlloc;
   16fd4:	6384      	str	r4, [r0, #56]	; 0x38
	frameFunctions[LivingString] = SFXLivingStringFrame;
   16fd6:	4d4d      	ldr	r5, [pc, #308]	; (1710c <initFunctionPointers+0x224>)
	tickFunctions[LivingString] = SFXLivingStringTick;
   16fd8:	4c4d      	ldr	r4, [pc, #308]	; (17110 <initFunctionPointers+0x228>)
	frameFunctions[LivingString] = SFXLivingStringFrame;
   16fda:	638d      	str	r5, [r1, #56]	; 0x38
	tickFunctions[LivingString] = SFXLivingStringTick;
   16fdc:	6394      	str	r4, [r2, #56]	; 0x38
	freeFunctions[LivingString] = SFXLivingStringFree;
   16fde:	4d4d      	ldr	r5, [pc, #308]	; (17114 <initFunctionPointers+0x22c>)

	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
   16fe0:	4c4d      	ldr	r4, [pc, #308]	; (17118 <initFunctionPointers+0x230>)
	freeFunctions[LivingString] = SFXLivingStringFree;
   16fe2:	639d      	str	r5, [r3, #56]	; 0x38
	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
   16fe4:	63c4      	str	r4, [r0, #60]	; 0x3c
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
   16fe6:	4d4d      	ldr	r5, [pc, #308]	; (1711c <initFunctionPointers+0x234>)
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
   16fe8:	4c4d      	ldr	r4, [pc, #308]	; (17120 <initFunctionPointers+0x238>)
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
   16fea:	63cd      	str	r5, [r1, #60]	; 0x3c
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
   16fec:	63d4      	str	r4, [r2, #60]	; 0x3c
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
   16fee:	4d4d      	ldr	r5, [pc, #308]	; (17124 <initFunctionPointers+0x23c>)

	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
   16ff0:	4c4d      	ldr	r4, [pc, #308]	; (17128 <initFunctionPointers+0x240>)
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
   16ff2:	63dd      	str	r5, [r3, #60]	; 0x3c
	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
   16ff4:	6404      	str	r4, [r0, #64]	; 0x40
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
   16ff6:	4d4d      	ldr	r5, [pc, #308]	; (1712c <initFunctionPointers+0x244>)
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
   16ff8:	4c4d      	ldr	r4, [pc, #308]	; (17130 <initFunctionPointers+0x248>)
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
   16ffa:	640d      	str	r5, [r1, #64]	; 0x40
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
   16ffc:	6414      	str	r4, [r2, #64]	; 0x40
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
   16ffe:	4d4d      	ldr	r5, [pc, #308]	; (17134 <initFunctionPointers+0x24c>)

	allocFunctions[Rhodes] = SFXRhodesAlloc;
   17000:	4c4d      	ldr	r4, [pc, #308]	; (17138 <initFunctionPointers+0x250>)
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
   17002:	641d      	str	r5, [r3, #64]	; 0x40
	allocFunctions[Rhodes] = SFXRhodesAlloc;
   17004:	6444      	str	r4, [r0, #68]	; 0x44
	frameFunctions[Rhodes] = SFXRhodesFrame;
   17006:	4d4d      	ldr	r5, [pc, #308]	; (1713c <initFunctionPointers+0x254>)
	tickFunctions[Rhodes] = SFXRhodesTick;
   17008:	4c4d      	ldr	r4, [pc, #308]	; (17140 <initFunctionPointers+0x258>)
	freeFunctions[Rhodes] = SFXRhodesFree;
   1700a:	484e      	ldr	r0, [pc, #312]	; (17144 <initFunctionPointers+0x25c>)
	frameFunctions[Rhodes] = SFXRhodesFrame;
   1700c:	644d      	str	r5, [r1, #68]	; 0x44
	tickFunctions[Rhodes] = SFXRhodesTick;
   1700e:	6454      	str	r4, [r2, #68]	; 0x44
	freeFunctions[Rhodes] = SFXRhodesFree;
   17010:	6458      	str	r0, [r3, #68]	; 0x44
}
   17012:	bc30      	pop	{r4, r5}
   17014:	4770      	bx	lr
   17016:	bf00      	nop
   17018:	020e3150 	.word	0x020e3150
   1701c:	0001a7ed 	.word	0x0001a7ed
   17020:	0001adf9 	.word	0x0001adf9
   17024:	0001bc8d 	.word	0x0001bc8d
   17028:	0001bf61 	.word	0x0001bf61
   1702c:	0001c115 	.word	0x0001c115
   17030:	0001c30d 	.word	0x0001c30d
   17034:	020e319c 	.word	0x020e319c
   17038:	0001c675 	.word	0x0001c675
   1703c:	0001d0b9 	.word	0x0001d0b9
   17040:	0001a939 	.word	0x0001a939
   17044:	0001b215 	.word	0x0001b215
   17048:	0001bd49 	.word	0x0001bd49
   1704c:	0001c039 	.word	0x0001c039
   17050:	0001c13d 	.word	0x0001c13d
   17054:	0001c3b1 	.word	0x0001c3b1
   17058:	0001c7dd 	.word	0x0001c7dd
   1705c:	0001d1e9 	.word	0x0001d1e9
   17060:	020e30b8 	.word	0x020e30b8
   17064:	0001abad 	.word	0x0001abad
   17068:	0001b8e9 	.word	0x0001b8e9
   1706c:	0001bd4d 	.word	0x0001bd4d
   17070:	00021031 	.word	0x00021031
   17074:	0001c23d 	.word	0x0001c23d
   17078:	0001c3b5 	.word	0x0001c3b5
   1707c:	0001cac1 	.word	0x0001cac1
   17080:	0001d211 	.word	0x0001d211
   17084:	020e3104 	.word	0x020e3104
   17088:	0001ad85 	.word	0x0001ad85
   1708c:	0001bbd9 	.word	0x0001bbd9
   17090:	0001bf15 	.word	0x0001bf15
   17094:	0001c0f1 	.word	0x0001c0f1
   17098:	0001c301 	.word	0x0001c301
   1709c:	0001c645 	.word	0x0001c645
   170a0:	0001d089 	.word	0x0001d089
   170a4:	0001d7b1 	.word	0x0001d7b1
   170a8:	0001d7f1 	.word	0x0001d7f1
   170ac:	0001d8cd 	.word	0x0001d8cd
   170b0:	0001d995 	.word	0x0001d995
   170b4:	0001da81 	.word	0x0001da81
   170b8:	0001dab1 	.word	0x0001dab1
   170bc:	0001db0d 	.word	0x0001db0d
   170c0:	0001db35 	.word	0x0001db35
   170c4:	0001dc49 	.word	0x0001dc49
   170c8:	0001dc79 	.word	0x0001dc79
   170cc:	0001dca9 	.word	0x0001dca9
   170d0:	0001dcd1 	.word	0x0001dcd1
   170d4:	0001de39 	.word	0x0001de39
   170d8:	0001de55 	.word	0x0001de55
   170dc:	0001df49 	.word	0x0001df49
   170e0:	0001dfad 	.word	0x0001dfad
   170e4:	0001e225 	.word	0x0001e225
   170e8:	0001e27d 	.word	0x0001e27d
   170ec:	0001e2cd 	.word	0x0001e2cd
   170f0:	0001e35d 	.word	0x0001e35d
   170f4:	0001e45d 	.word	0x0001e45d
   170f8:	0001e479 	.word	0x0001e479
   170fc:	0001e545 	.word	0x0001e545
   17100:	0001e549 	.word	0x0001e549
   17104:	0001e705 	.word	0x0001e705
   17108:	0001e751 	.word	0x0001e751
   1710c:	0001e849 	.word	0x0001e849
   17110:	0001eca5 	.word	0x0001eca5
   17114:	0001ecfd 	.word	0x0001ecfd
   17118:	0001ed21 	.word	0x0001ed21
   1711c:	0001ee99 	.word	0x0001ee99
   17120:	0001f205 	.word	0x0001f205
   17124:	0001f2cd 	.word	0x0001f2cd
   17128:	0001f325 	.word	0x0001f325
   1712c:	0001f625 	.word	0x0001f625
   17130:	0001fcc1 	.word	0x0001fcc1
   17134:	0001fdf5 	.word	0x0001fdf5
   17138:	0001fe75 	.word	0x0001fe75
   1713c:	0001ffd9 	.word	0x0001ffd9
   17140:	000209c5 	.word	0x000209c5
   17144:	00020d41 	.word	0x00020d41

00017148 <audioInit>:
{
   17148:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   1714c:	4b47      	ldr	r3, [pc, #284]	; (1726c <audioInit+0x124>)
{
   1714e:	4606      	mov	r6, r0
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   17150:	ed9f 0a47 	vldr	s0, [pc, #284]	; 17270 <audioInit+0x128>
   17154:	2080      	movs	r0, #128	; 0x80
{
   17156:	4688      	mov	r8, r1
   17158:	4617      	mov	r7, r2
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   1715a:	4946      	ldr	r1, [pc, #280]	; (17274 <audioInit+0x12c>)
   1715c:	4a46      	ldr	r2, [pc, #280]	; (17278 <audioInit+0x130>)
   1715e:	4c47      	ldr	r4, [pc, #284]	; (1727c <audioInit+0x134>)
{
   17160:	ed2d 8b02 	vpush	{d8}
   17164:	b086      	sub	sp, #24
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
   17166:	eddf 8a46 	vldr	s17, [pc, #280]	; 17280 <audioInit+0x138>
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   1716a:	f015 fb43 	bl	2c7f4 <LEAF_init>
	tMempool_init (&smallPool, small_memory, SMALL_MEM_SIZE);
   1716e:	4a45      	ldr	r2, [pc, #276]	; (17284 <audioInit+0x13c>)
   17170:	4945      	ldr	r1, [pc, #276]	; (17288 <audioInit+0x140>)
   17172:	f104 0518 	add.w	r5, r4, #24
   17176:	4845      	ldr	r0, [pc, #276]	; (1728c <audioInit+0x144>)
   17178:	f012 fdea 	bl	29d50 <tMempool_init>
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE);
   1717c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
   17180:	4943      	ldr	r1, [pc, #268]	; (17290 <audioInit+0x148>)
   17182:	4844      	ldr	r0, [pc, #272]	; (17294 <audioInit+0x14c>)
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
   17184:	ed9f 8a44 	vldr	s16, [pc, #272]	; 17298 <audioInit+0x150>
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE);
   17188:	f012 fde2 	bl	29d50 <tMempool_init>
	initFunctionPointers();
   1718c:	f7ff feac 	bl	16ee8 <initFunctionPointers>
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
   17190:	4620      	mov	r0, r4
   17192:	3404      	adds	r4, #4
   17194:	eef0 0a68 	vmov.f32	s1, s17
   17198:	eeb0 0a48 	vmov.f32	s0, s16
   1719c:	f010 fdca 	bl	27d34 <tExpSmooth_init>
	for (int i = 0; i < 6; i++)
   171a0:	42ac      	cmp	r4, r5
   171a2:	d1f5      	bne.n	17190 <audioInit+0x48>
		tEnvelopeFollower_init(&LED_envelope[i], 0.0001f, .9995f);
   171a4:	eddf 0a3d 	vldr	s1, [pc, #244]	; 1729c <audioInit+0x154>
	loadingPreset = 1;
   171a8:	2401      	movs	r4, #1
		tEnvelopeFollower_init(&LED_envelope[i], 0.0001f, .9995f);
   171aa:	ed9f 0a3d 	vldr	s0, [pc, #244]	; 172a0 <audioInit+0x158>
   171ae:	483d      	ldr	r0, [pc, #244]	; (172a4 <audioInit+0x15c>)
   171b0:	f00c ffb0 	bl	24114 <tEnvelopeFollower_init>
   171b4:	eddf 0a39 	vldr	s1, [pc, #228]	; 1729c <audioInit+0x154>
   171b8:	ed9f 0a39 	vldr	s0, [pc, #228]	; 172a0 <audioInit+0x158>
   171bc:	483a      	ldr	r0, [pc, #232]	; (172a8 <audioInit+0x160>)
   171be:	f00c ffa9 	bl	24114 <tEnvelopeFollower_init>
   171c2:	eddf 0a36 	vldr	s1, [pc, #216]	; 1729c <audioInit+0x154>
   171c6:	ed9f 0a36 	vldr	s0, [pc, #216]	; 172a0 <audioInit+0x158>
   171ca:	4838      	ldr	r0, [pc, #224]	; (172ac <audioInit+0x164>)
   171cc:	f00c ffa2 	bl	24114 <tEnvelopeFollower_init>
   171d0:	eddf 0a32 	vldr	s1, [pc, #200]	; 1729c <audioInit+0x154>
   171d4:	ed9f 0a32 	vldr	s0, [pc, #200]	; 172a0 <audioInit+0x158>
   171d8:	4835      	ldr	r0, [pc, #212]	; (172b0 <audioInit+0x168>)
   171da:	f00c ff9b 	bl	24114 <tEnvelopeFollower_init>
	LEAF_generate_atodbPositiveClipped(atodbTable, -120.0f, 380.0f, ATODB_TABLE_SIZE);
   171de:	eddf 0a35 	vldr	s1, [pc, #212]	; 172b4 <audioInit+0x16c>
   171e2:	ed9f 0a35 	vldr	s0, [pc, #212]	; 172b8 <audioInit+0x170>
   171e6:	f44f 7100 	mov.w	r1, #512	; 0x200
   171ea:	4834      	ldr	r0, [pc, #208]	; (172bc <audioInit+0x174>)
   171ec:	f012 fb38 	bl	29860 <LEAF_generate_atodbPositiveClipped>
	initGlobalSFXObjects();
   171f0:	f003 f842 	bl	1a278 <initGlobalSFXObjects>
	previousPreset = PresetNil;
   171f4:	4b32      	ldr	r3, [pc, #200]	; (172c0 <audioInit+0x178>)
	loadingPreset = 1;
   171f6:	4933      	ldr	r1, [pc, #204]	; (172c4 <audioInit+0x17c>)
	previousPreset = PresetNil;
   171f8:	2212      	movs	r2, #18
	HAL_Delay(10);
   171fa:	200a      	movs	r0, #10
	previousPreset = PresetNil;
   171fc:	701a      	strb	r2, [r3, #0]
	loadingPreset = 1;
   171fe:	700c      	strb	r4, [r1, #0]
	HAL_Delay(10);
   17200:	f7f1 f8fe 	bl	8400 <HAL_Delay>
   17204:	f44f 6200 	mov.w	r2, #2048	; 0x800
   17208:	2100      	movs	r1, #0
   1720a:	482f      	ldr	r0, [pc, #188]	; (172c8 <audioInit+0x180>)
   1720c:	f015 fb69 	bl	2c8e2 <memset>
	HAL_Delay(1);
   17210:	4620      	mov	r0, r4
   17212:	f7f1 f8f5 	bl	8400 <HAL_Delay>
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
   17216:	4640      	mov	r0, r8
   17218:	f44f 7200 	mov.w	r2, #512	; 0x200
   1721c:	492a      	ldr	r1, [pc, #168]	; (172c8 <audioInit+0x180>)
   1721e:	f7f9 fe17 	bl	10e50 <HAL_SAI_Transmit_DMA>
   17222:	4b2a      	ldr	r3, [pc, #168]	; (172cc <audioInit+0x184>)
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
   17224:	f44f 7200 	mov.w	r2, #512	; 0x200
   17228:	4929      	ldr	r1, [pc, #164]	; (172d0 <audioInit+0x188>)
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
   1722a:	7018      	strb	r0, [r3, #0]
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
   1722c:	4638      	mov	r0, r7
   1722e:	f7f9 fe9f 	bl	10f70 <HAL_SAI_Receive_DMA>
   17232:	4b28      	ldr	r3, [pc, #160]	; (172d4 <audioInit+0x18c>)
   17234:	7018      	strb	r0, [r3, #0]
	AudioCodec_init(hi2c);
   17236:	4630      	mov	r0, r6
   17238:	f000 f8e0 	bl	173fc <AudioCodec_init>
	HAL_Delay(1);
   1723c:	4620      	mov	r0, r4
   1723e:	f7f1 f8df 	bl	8400 <HAL_Delay>
	HAL_I2C_MspDeInit(hi2c);
   17242:	4630      	mov	r0, r6
   17244:	f001 ff3e 	bl	190c4 <HAL_I2C_MspDeInit>
	GPIO_InitTypeDef GPIO_InitStruct = {0};
   17248:	2300      	movs	r3, #0
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   1724a:	f44f 6240 	mov.w	r2, #3072	; 0xc00
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1724e:	a901      	add	r1, sp, #4
   17250:	4821      	ldr	r0, [pc, #132]	; (172d8 <audioInit+0x190>)
	GPIO_InitTypeDef GPIO_InitStruct = {0};
   17252:	9302      	str	r3, [sp, #8]
   17254:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   17256:	9201      	str	r2, [sp, #4]
	GPIO_InitTypeDef GPIO_InitStruct = {0};
   17258:	e9cd 4303 	strd	r4, r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1725c:	f7f4 fcb0 	bl	bbc0 <HAL_GPIO_Init>
}
   17260:	b006      	add	sp, #24
   17262:	ecbd 8b02 	vpop	{d8}
   17266:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1726a:	bf00      	nop
   1726c:	00019395 	.word	0x00019395
   17270:	473b8000 	.word	0x473b8000
   17274:	00064000 	.word	0x00064000
   17278:	0007eb58 	.word	0x0007eb58
   1727c:	020fb0c0 	.word	0x020fb0c0
   17280:	3e4ccccd 	.word	0x3e4ccccd
   17284:	000139c8 	.word	0x000139c8
   17288:	020e5f24 	.word	0x020e5f24
   1728c:	020fabc0 	.word	0x020fabc0
   17290:	000e2b60 	.word	0x000e2b60
   17294:	020f9dd8 	.word	0x020f9dd8
   17298:	00000000 	.word	0x00000000
   1729c:	3f7fdf3b 	.word	0x3f7fdf3b
   172a0:	38d1b717 	.word	0x38d1b717
   172a4:	020e31e4 	.word	0x020e31e4
   172a8:	020e31e8 	.word	0x020e31e8
   172ac:	020e31ec 	.word	0x020e31ec
   172b0:	020e31f0 	.word	0x020e31f0
   172b4:	43be0000 	.word	0x43be0000
   172b8:	c2f00000 	.word	0xc2f00000
   172bc:	020e31f4 	.word	0x020e31f4
   172c0:	00062828 	.word	0x00062828
   172c4:	020e2f1b 	.word	0x020e2f1b
   172c8:	00063280 	.word	0x00063280
   172cc:	020e3100 	.word	0x020e3100
   172d0:	00062a80 	.word	0x00062a80
   172d4:	020e3198 	.word	0x020e3198
   172d8:	58020400 	.word	0x58020400

000172dc <HAL_SAI_ErrorCallback>:



void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
	setLED_Edit(1);
   172dc:	2001      	movs	r0, #1
   172de:	f002 b89b 	b.w	19418 <setLED_Edit>
   172e2:	bf00      	nop

000172e4 <HAL_SAI_TxCpltCallback>:
   172e4:	4770      	bx	lr
   172e6:	bf00      	nop

000172e8 <HAL_SAI_TxHalfCpltCallback>:
}

void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{

}
   172e8:	4770      	bx	lr
   172ea:	bf00      	nop

000172ec <HAL_SAI_RxCpltCallback>:


void HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai)
{
	audioFrame(HALF_BUFFER_SIZE);
   172ec:	f44f 7080 	mov.w	r0, #256	; 0x100
   172f0:	f7ff bb92 	b.w	16a18 <audioFrame>

000172f4 <HAL_SAI_RxHalfCpltCallback>:
}

void HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
	audioFrame(0);
   172f4:	2000      	movs	r0, #0
   172f6:	f7ff bb8f 	b.w	16a18 <audioFrame>
   172fa:	bf00      	nop

000172fc <MX_BDMA_Init>:
  */
void MX_BDMA_Init(void) 
{

  /* DMA controller clock enable */
  __HAL_RCC_BDMA_CLK_ENABLE();
   172fc:	4b10      	ldr	r3, [pc, #64]	; (17340 <MX_BDMA_Init+0x44>)

  /* DMA interrupt init */
  /* BDMA_Channel0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
   172fe:	2200      	movs	r2, #0
   17300:	2081      	movs	r0, #129	; 0x81
   17302:	4611      	mov	r1, r2
{
   17304:	b510      	push	{r4, lr}
  __HAL_RCC_BDMA_CLK_ENABLE();
   17306:	f8d3 40e0 	ldr.w	r4, [r3, #224]	; 0xe0
{
   1730a:	b082      	sub	sp, #8
  __HAL_RCC_BDMA_CLK_ENABLE();
   1730c:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
   17310:	f8c3 40e0 	str.w	r4, [r3, #224]	; 0xe0
   17314:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
   17318:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
   1731c:	9301      	str	r3, [sp, #4]
   1731e:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
   17320:	f7f2 fb58 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BDMA_Channel0_IRQn);
   17324:	2081      	movs	r0, #129	; 0x81
   17326:	f7f2 fb9b 	bl	9a60 <HAL_NVIC_EnableIRQ>
  /* BDMA_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BDMA_Channel1_IRQn, 0, 0);
   1732a:	2200      	movs	r2, #0
   1732c:	2082      	movs	r0, #130	; 0x82
   1732e:	4611      	mov	r1, r2
   17330:	f7f2 fb50 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);
   17334:	2082      	movs	r0, #130	; 0x82

}
   17336:	b002      	add	sp, #8
   17338:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);
   1733c:	f7f2 bb90 	b.w	9a60 <HAL_NVIC_EnableIRQ>
   17340:	58024400 	.word	0x58024400

00017344 <BSP_SD_ReadBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to read
  * @param  Timeout: Timeout for read operation
  * @retval SD status
  */
__weak uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
   17344:	b500      	push	{lr}
   17346:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;

  if (HAL_SD_ReadBlocks(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks, Timeout) != HAL_OK)
   17348:	9300      	str	r3, [sp, #0]
   1734a:	4613      	mov	r3, r2
   1734c:	460a      	mov	r2, r1
   1734e:	4601      	mov	r1, r0
   17350:	4804      	ldr	r0, [pc, #16]	; (17364 <BSP_SD_ReadBlocks+0x20>)
   17352:	f7f9 ff9b 	bl	1128c <HAL_SD_ReadBlocks>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;  
}
   17356:	3000      	adds	r0, #0
   17358:	bf18      	it	ne
   1735a:	2001      	movne	r0, #1
   1735c:	b003      	add	sp, #12
   1735e:	f85d fb04 	ldr.w	pc, [sp], #4
   17362:	bf00      	nop
   17364:	020e4790 	.word	0x020e4790

00017368 <BSP_SD_WriteBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to write
  * @param  Timeout: Timeout for write operation
  * @retval SD status
  */
__weak uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
   17368:	b500      	push	{lr}
   1736a:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;

  if (HAL_SD_WriteBlocks(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks, Timeout) != HAL_OK) 
   1736c:	9300      	str	r3, [sp, #0]
   1736e:	4613      	mov	r3, r2
   17370:	460a      	mov	r2, r1
   17372:	4601      	mov	r1, r0
   17374:	4804      	ldr	r0, [pc, #16]	; (17388 <BSP_SD_WriteBlocks+0x20>)
   17376:	f7fa f88b 	bl	11490 <HAL_SD_WriteBlocks>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;  
}
   1737a:	3000      	adds	r0, #0
   1737c:	bf18      	it	ne
   1737e:	2001      	movne	r0, #1
   17380:	b003      	add	sp, #12
   17382:	f85d fb04 	ldr.w	pc, [sp], #4
   17386:	bf00      	nop
   17388:	020e4790 	.word	0x020e4790

0001738c <BSP_SD_GetCardState>:
  *          This value can be one of the following values:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
__weak uint8_t BSP_SD_GetCardState(void)
{
   1738c:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
   1738e:	4803      	ldr	r0, [pc, #12]	; (1739c <BSP_SD_GetCardState+0x10>)
   17390:	f7fa fe1c 	bl	11fcc <HAL_SD_GetCardState>
}
   17394:	3804      	subs	r0, #4
   17396:	bf18      	it	ne
   17398:	2001      	movne	r0, #1
   1739a:	bd08      	pop	{r3, pc}
   1739c:	020e4790 	.word	0x020e4790

000173a0 <BSP_SD_GetCardInfo>:
  * @retval None 
  */
__weak void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&hsd1, CardInfo);
   173a0:	4601      	mov	r1, r0
   173a2:	4801      	ldr	r0, [pc, #4]	; (173a8 <BSP_SD_GetCardInfo+0x8>)
   173a4:	f7fa bc88 	b.w	11cb8 <HAL_SD_GetCardInfo>
   173a8:	020e4790 	.word	0x020e4790

000173ac <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
__weak uint8_t BSP_SD_IsDetected(void)
{
   173ac:	b500      	push	{lr}
  __IO uint8_t status = SD_PRESENT;
   173ae:	2301      	movs	r3, #1
{
   173b0:	b083      	sub	sp, #12
  __IO uint8_t status = SD_PRESENT;
   173b2:	f88d 3007 	strb.w	r3, [sp, #7]

  if (BSP_PlatformIsDetected() == 0x0) 
   173b6:	f000 fc69 	bl	17c8c <BSP_PlatformIsDetected>
   173ba:	b908      	cbnz	r0, 173c0 <BSP_SD_IsDetected+0x14>
  {
    status = SD_NOT_PRESENT;
   173bc:	f88d 0007 	strb.w	r0, [sp, #7]
  }

  return status;
   173c0:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
   173c4:	b003      	add	sp, #12
   173c6:	f85d fb04 	ldr.w	pc, [sp], #4
   173ca:	bf00      	nop

000173cc <BSP_SD_Init>:
{
   173cc:	b508      	push	{r3, lr}
  if (BSP_SD_IsDetected() != SD_PRESENT)
   173ce:	f7ff ffed 	bl	173ac <BSP_SD_IsDetected>
   173d2:	2801      	cmp	r0, #1
   173d4:	d001      	beq.n	173da <BSP_SD_Init+0xe>
    return MSD_ERROR_SD_NOT_PRESENT;
   173d6:	2002      	movs	r0, #2
}
   173d8:	bd08      	pop	{r3, pc}
  sd_state = HAL_SD_Init(&hsd1);
   173da:	4807      	ldr	r0, [pc, #28]	; (173f8 <BSP_SD_Init+0x2c>)
   173dc:	f7fa fd30 	bl	11e40 <HAL_SD_Init>
  if (sd_state == MSD_OK)
   173e0:	2800      	cmp	r0, #0
   173e2:	d1f9      	bne.n	173d8 <BSP_SD_Init+0xc>
    if (HAL_SD_ConfigWideBusOperation(&hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)
   173e4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   173e8:	4803      	ldr	r0, [pc, #12]	; (173f8 <BSP_SD_Init+0x2c>)
   173ea:	f7fa fc79 	bl	11ce0 <HAL_SD_ConfigWideBusOperation>
    return MSD_ERROR_SD_NOT_PRESENT;
   173ee:	3000      	adds	r0, #0
   173f0:	bf18      	it	ne
   173f2:	2001      	movne	r0, #1
}
   173f4:	bd08      	pop	{r3, pc}
   173f6:	bf00      	nop
   173f8:	020e4790 	.word	0x020e4790

000173fc <AudioCodec_init>:

volatile int blankCount = 0;
uint16_t addressCounter = 0;


void AudioCodec_init(I2C_HandleTypeDef* hi2c) {
   173fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	//pull codec reset pin high to start codec working
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
   17400:	2201      	movs	r2, #1
void AudioCodec_init(I2C_HandleTypeDef* hi2c) {
   17402:	b082      	sub	sp, #8
   17404:	4605      	mov	r5, r0

	HAL_Delay(2);
	//enable control port and put part in power-down mode while loading registers
	myI2cData[0] = 0x07;
	myI2cData[1] = 0x03;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17406:	4e40      	ldr	r6, [pc, #256]	; (17508 <AudioCodec_init+0x10c>)
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
   17408:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   1740c:	483f      	ldr	r0, [pc, #252]	; (1750c <AudioCodec_init+0x110>)
   1740e:	f7f4 ff11 	bl	c234 <HAL_GPIO_WritePin>
	HAL_Delay(2);
   17412:	2002      	movs	r0, #2
	myI2cData[0] = 0x07;
   17414:	4c3e      	ldr	r4, [pc, #248]	; (17510 <AudioCodec_init+0x114>)
	HAL_Delay(2);
   17416:	f7f0 fff3 	bl	8400 <HAL_Delay>
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1741a:	4f3e      	ldr	r7, [pc, #248]	; (17514 <AudioCodec_init+0x118>)
	myI2cData[0] = 0x07;
   1741c:	f240 3c07 	movw	ip, #775	; 0x307
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17420:	6831      	ldr	r1, [r6, #0]
   17422:	4622      	mov	r2, r4
   17424:	883b      	ldrh	r3, [r7, #0]
   17426:	4628      	mov	r0, r5
   17428:	9100      	str	r1, [sp, #0]
   1742a:	2120      	movs	r1, #32
   1742c:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 1751c <AudioCodec_init+0x120>
	myI2cData[0] = 0x07;
   17430:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17434:	f7f5 fa20 	bl	c878 <HAL_I2C_Master_Transmit>
	//HAL_Delay(2);

	myI2cData[0] = 0x01;
	myI2cData[1] = 0x41;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17438:	6831      	ldr	r1, [r6, #0]
	myI2cData[0] = 0x01;
   1743a:	f244 1c01 	movw	ip, #16641	; 0x4101
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1743e:	883b      	ldrh	r3, [r7, #0]
   17440:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17442:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17446:	4628      	mov	r0, r5
   17448:	9100      	str	r1, [sp, #0]
   1744a:	2120      	movs	r1, #32
	myI2cData[0] = 0x01;
   1744c:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17450:	f7f5 fa12 	bl	c878 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x02;
	myI2cData[1] = 0x00;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17454:	6832      	ldr	r2, [r6, #0]
	myI2cData[0] = 0x02;
   17456:	f04f 0c02 	mov.w	ip, #2
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1745a:	883b      	ldrh	r3, [r7, #0]
   1745c:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1745e:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17462:	4628      	mov	r0, r5
   17464:	9200      	str	r2, [sp, #0]
   17466:	4622      	mov	r2, r4
	myI2cData[0] = 0x02;
   17468:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1746c:	f7f5 fa04 	bl	c878 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x03;
	myI2cData[1] = 0x79;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17470:	6831      	ldr	r1, [r6, #0]
	myI2cData[0] = 0x03;
   17472:	f647 1c03 	movw	ip, #30979	; 0x7903
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17476:	883b      	ldrh	r3, [r7, #0]
   17478:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1747a:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1747e:	4628      	mov	r0, r5
   17480:	9100      	str	r1, [sp, #0]
   17482:	2120      	movs	r1, #32
	myI2cData[0] = 0x03;
   17484:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17488:	f7f5 f9f6 	bl	c878 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x04;
	myI2cData[1] = 0x01;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1748c:	6832      	ldr	r2, [r6, #0]
	myI2cData[0] = 0x04;
   1748e:	f44f 7c82 	mov.w	ip, #260	; 0x104
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17492:	883b      	ldrh	r3, [r7, #0]
   17494:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17496:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1749a:	4628      	mov	r0, r5
   1749c:	9200      	str	r2, [sp, #0]
   1749e:	4622      	mov	r2, r4
	myI2cData[0] = 0x04;
   174a0:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174a4:	f7f5 f9e8 	bl	c878 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x05;
	myI2cData[1] = 0x01;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174a8:	6831      	ldr	r1, [r6, #0]
	myI2cData[0] = 0x05;
   174aa:	f240 1c05 	movw	ip, #261	; 0x105
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174ae:	883b      	ldrh	r3, [r7, #0]
   174b0:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174b2:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174b6:	4628      	mov	r0, r5
   174b8:	9100      	str	r1, [sp, #0]
   174ba:	2120      	movs	r1, #32
	myI2cData[0] = 0x05;
   174bc:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174c0:	f7f5 f9da 	bl	c878 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x06;
	myI2cData[1] = 0x10;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174c4:	6832      	ldr	r2, [r6, #0]
	myI2cData[0] = 0x06;
   174c6:	f241 0c06 	movw	ip, #4102	; 0x1006
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174ca:	883b      	ldrh	r3, [r7, #0]
   174cc:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174ce:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174d2:	4628      	mov	r0, r5
   174d4:	9200      	str	r2, [sp, #0]
   174d6:	4622      	mov	r2, r4
	myI2cData[0] = 0x06;
   174d8:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174dc:	f7f5 f9cc 	bl	c878 <HAL_I2C_Master_Transmit>
	//HAL_Delay(1); // might not be necessary

	//turn off power down bit to start things cookin'
	myI2cData[0] = 0x07;
	myI2cData[1] = 0x02;
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174e0:	6831      	ldr	r1, [r6, #0]
   174e2:	4622      	mov	r2, r4
   174e4:	883b      	ldrh	r3, [r7, #0]
	myI2cData[0] = 0x07;
   174e6:	f240 2707 	movw	r7, #519	; 0x207
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174ea:	f888 0000 	strb.w	r0, [r8]
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174ee:	4628      	mov	r0, r5
   174f0:	9100      	str	r1, [sp, #0]
   174f2:	2120      	movs	r1, #32
	myI2cData[0] = 0x07;
   174f4:	8027      	strh	r7, [r4, #0]
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174f6:	f7f5 f9bf 	bl	c878 <HAL_I2C_Master_Transmit>


	//HAL_Delay(1); // might not be necessary
	codecReady = 1;
   174fa:	4b07      	ldr	r3, [pc, #28]	; (17518 <AudioCodec_init+0x11c>)
   174fc:	2201      	movs	r2, #1
   174fe:	701a      	strb	r2, [r3, #0]

}
   17500:	b002      	add	sp, #8
   17502:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17506:	bf00      	nop
   17508:	0006256c 	.word	0x0006256c
   1750c:	58020800 	.word	0x58020800
   17510:	020e2dc8 	.word	0x020e2dc8
   17514:	00062570 	.word	0x00062570
   17518:	020e2dc0 	.word	0x020e2dc0
   1751c:	020e39f4 	.word	0x020e39f4

00017520 <MX_DMA_Init>:
  */
void MX_DMA_Init(void) 
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
   17520:	4b1e      	ldr	r3, [pc, #120]	; (1759c <MX_DMA_Init+0x7c>)
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 3, 0);
   17522:	2200      	movs	r2, #0
   17524:	2103      	movs	r1, #3
   17526:	200c      	movs	r0, #12
{
   17528:	b510      	push	{r4, lr}
  __HAL_RCC_DMA2_CLK_ENABLE();
   1752a:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
{
   1752e:	b082      	sub	sp, #8
  __HAL_RCC_DMA2_CLK_ENABLE();
   17530:	f044 0402 	orr.w	r4, r4, #2
   17534:	f8c3 40d8 	str.w	r4, [r3, #216]	; 0xd8
   17538:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
   1753c:	f004 0402 	and.w	r4, r4, #2
   17540:	9400      	str	r4, [sp, #0]
   17542:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_DMA1_CLK_ENABLE();
   17544:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
   17548:	f044 0401 	orr.w	r4, r4, #1
   1754c:	f8c3 40d8 	str.w	r4, [r3, #216]	; 0xd8
   17550:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
   17554:	f003 0301 	and.w	r3, r3, #1
   17558:	9301      	str	r3, [sp, #4]
   1755a:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 3, 0);
   1755c:	f7f2 fa3a 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
   17560:	200c      	movs	r0, #12
   17562:	f7f2 fa7d 	bl	9a60 <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 3, 0);
   17566:	2200      	movs	r2, #0
   17568:	2103      	movs	r1, #3
   1756a:	200d      	movs	r0, #13
   1756c:	f7f2 fa32 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
   17570:	200d      	movs	r0, #13
   17572:	f7f2 fa75 	bl	9a60 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 4, 0);
   17576:	2200      	movs	r2, #0
   17578:	2104      	movs	r1, #4
   1757a:	2038      	movs	r0, #56	; 0x38
   1757c:	f7f2 fa2a 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
   17580:	2038      	movs	r0, #56	; 0x38
   17582:	f7f2 fa6d 	bl	9a60 <HAL_NVIC_EnableIRQ>
  /* DMAMUX1_OVR_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMAMUX1_OVR_IRQn, 0, 0);
   17586:	2200      	movs	r2, #0
   17588:	2066      	movs	r0, #102	; 0x66
   1758a:	4611      	mov	r1, r2
   1758c:	f7f2 fa22 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMAMUX1_OVR_IRQn);
   17590:	2066      	movs	r0, #102	; 0x66

}
   17592:	b002      	add	sp, #8
   17594:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(DMAMUX1_OVR_IRQn);
   17598:	f7f2 ba62 	b.w	9a60 <HAL_NVIC_EnableIRQ>
   1759c:	58024400 	.word	0x58024400

000175a0 <EE_VerifyPageFullWriteVariable>:
  *           - PAGE_FULL: if valid page is full
  *           - NO_VALID_PAGE: if no valid page was found
  *           - Flash error code: on write Flash error
  */
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
   175a0:	b510      	push	{r4, lr}
  HAL_StatusTypeDef FlashStatus = HAL_OK;
  uint16_t ValidPage = PAGE0;
  uint32_t Address = EEPROM_START_ADDRESS, PageEndAddress = EEPROM_START_ADDRESS+PAGE_SIZE;

  uint32_t data32[8] = {Data};
   175a2:	2300      	movs	r3, #0
{
   175a4:	b090      	sub	sp, #64	; 0x40
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   175a6:	4c25      	ldr	r4, [pc, #148]	; (1763c <EE_VerifyPageFullWriteVariable+0x9c>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   175a8:	4a25      	ldr	r2, [pc, #148]	; (17640 <EE_VerifyPageFullWriteVariable+0xa0>)
  uint32_t data32[8] = {Data};
   175aa:	9100      	str	r1, [sp, #0]
  uint32_t VirtAddress1[8] = {VirtAddress};
   175ac:	9008      	str	r0, [sp, #32]
  uint32_t data32[8] = {Data};
   175ae:	9307      	str	r3, [sp, #28]
  uint32_t VirtAddress1[8] = {VirtAddress};
   175b0:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t data32[8] = {Data};
   175b2:	e9cd 3301 	strd	r3, r3, [sp, #4]
   175b6:	e9cd 3303 	strd	r3, r3, [sp, #12]
   175ba:	e9cd 3305 	strd	r3, r3, [sp, #20]
  uint32_t VirtAddress1[8] = {VirtAddress};
   175be:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
   175c2:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
   175c6:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   175ca:	8823      	ldrh	r3, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   175cc:	8812      	ldrh	r2, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   175ce:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   175d0:	b292      	uxth	r2, r2
      if (PageStatus1 == VALID_PAGE)
   175d2:	b9ea      	cbnz	r2, 17610 <EE_VerifyPageFullWriteVariable+0x70>
        if (PageStatus0 == RECEIVE_DATA)
   175d4:	f64e 62ee 	movw	r2, #61166	; 0xeeee
          return PAGE0;         /* Page0 valid */
   175d8:	1a9b      	subs	r3, r3, r2
   175da:	bf18      	it	ne
   175dc:	2301      	movne	r3, #1
  {
    return  NO_VALID_PAGE;
  }

  /* Get the valid Page start Address */
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   175de:	f203 440e 	addw	r4, r3, #1038	; 0x40e

  /* Get the valid Page end Address */
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   175e2:	4a18      	ldr	r2, [pc, #96]	; (17644 <EE_VerifyPageFullWriteVariable+0xa4>)
   175e4:	3301      	adds	r3, #1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   175e6:	0464      	lsls	r4, r4, #17
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   175e8:	eb02 4243 	add.w	r2, r2, r3, lsl #17

  /* Check each active page address starting from begining */
  while (Address < PageEndAddress)
   175ec:	4294      	cmp	r4, r2
   175ee:	d303      	bcc.n	175f8 <EE_VerifyPageFullWriteVariable+0x58>
   175f0:	e016      	b.n	17620 <EE_VerifyPageFullWriteVariable+0x80>
     return FlashStatus;
    }
    else
    {
      /* Next address location */
      Address = Address + 64;
   175f2:	3440      	adds	r4, #64	; 0x40
  while (Address < PageEndAddress)
   175f4:	42a2      	cmp	r2, r4
   175f6:	d913      	bls.n	17620 <EE_VerifyPageFullWriteVariable+0x80>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
   175f8:	6823      	ldr	r3, [r4, #0]
   175fa:	3301      	adds	r3, #1
   175fc:	d1f9      	bne.n	175f2 <EE_VerifyPageFullWriteVariable+0x52>
      FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, ((uint32_t)data32));
   175fe:	466a      	mov	r2, sp
   17600:	4621      	mov	r1, r4
   17602:	2001      	movs	r0, #1
   17604:	f7f4 f858 	bl	b6b8 <HAL_FLASH_Program>
      if (FlashStatus != HAL_OK)
   17608:	b180      	cbz	r0, 1762c <EE_VerifyPageFullWriteVariable+0x8c>
     return FlashStatus;
   1760a:	b280      	uxth	r0, r0
    }
  }

  /* Return PAGE_FULL in case the valid page is full */
  return PAGE_FULL;
}
   1760c:	b010      	add	sp, #64	; 0x40
   1760e:	bd10      	pop	{r4, pc}
      else if (PageStatus0 == VALID_PAGE)
   17610:	b94b      	cbnz	r3, 17626 <EE_VerifyPageFullWriteVariable+0x86>
        if (PageStatus1 == RECEIVE_DATA)
   17612:	f64e 63ee 	movw	r3, #61166	; 0xeeee
          return PAGE0;         /* Page0 valid */
   17616:	1ad3      	subs	r3, r2, r3
   17618:	fab3 f383 	clz	r3, r3
   1761c:	095b      	lsrs	r3, r3, #5
   1761e:	e7de      	b.n	175de <EE_VerifyPageFullWriteVariable+0x3e>
  return PAGE_FULL;
   17620:	2080      	movs	r0, #128	; 0x80
}
   17622:	b010      	add	sp, #64	; 0x40
   17624:	bd10      	pop	{r4, pc}
    return  NO_VALID_PAGE;
   17626:	20ab      	movs	r0, #171	; 0xab
}
   17628:	b010      	add	sp, #64	; 0x40
   1762a:	bd10      	pop	{r4, pc}
     FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address + 32, ((uint32_t)VirtAddress1));
   1762c:	f104 0120 	add.w	r1, r4, #32
   17630:	aa08      	add	r2, sp, #32
   17632:	2001      	movs	r0, #1
   17634:	f7f4 f840 	bl	b6b8 <HAL_FLASH_Program>
   17638:	e7e7      	b.n	1760a <EE_VerifyPageFullWriteVariable+0x6a>
   1763a:	bf00      	nop
   1763c:	081c0000 	.word	0x081c0000
   17640:	081e0000 	.word	0x081e0000
   17644:	081bffff 	.word	0x081bffff

00017648 <EE_Init>:
{
   17648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t SectorError = 0;
   1764c:	f04f 0800 	mov.w	r8, #0
{
   17650:	b09f      	sub	sp, #124	; 0x7c
  uint32_t valid[8] = {0x0000};
   17652:	f04f 0920 	mov.w	r9, #32
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17656:	4cb3      	ldr	r4, [pc, #716]	; (17924 <EE_Init+0x2dc>)
  uint32_t valid[8] = {0x0000};
   17658:	4641      	mov	r1, r8
   1765a:	a80e      	add	r0, sp, #56	; 0x38
   1765c:	464a      	mov	r2, r9
  uint32_t SectorError = 0;
   1765e:	f8cd 8008 	str.w	r8, [sp, #8]
  uint32_t valid[8] = {0x0000};
   17662:	f015 f93e 	bl	2c8e2 <memset>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17666:	8825      	ldrh	r5, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17668:	4eaf      	ldr	r6, [pc, #700]	; (17928 <EE_Init+0x2e0>)
  switch (PageStatus0)
   1766a:	f64e 62ee 	movw	r2, #61166	; 0xeeee
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1766e:	b2ad      	uxth	r5, r5
  pEraseInit.Banks = FLASH_BANK_2 ;
   17670:	2302      	movs	r3, #2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17672:	8830      	ldrh	r0, [r6, #0]
  pEraseInit.Sector = PAGE0_ID;
   17674:	f04f 0b06 	mov.w	fp, #6
  pEraseInit.NbSectors = 1;
   17678:	f04f 0a01 	mov.w	sl, #1
  switch (PageStatus0)
   1767c:	4295      	cmp	r5, r2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1767e:	b287      	uxth	r7, r0
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
   17680:	f8cd 8010 	str.w	r8, [sp, #16]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   17684:	f8cd 9020 	str.w	r9, [sp, #32]
  pEraseInit.NbSectors = 1;
   17688:	f8cd a01c 	str.w	sl, [sp, #28]
  pEraseInit.Sector = PAGE0_ID;
   1768c:	e9cd 3b05 	strd	r3, fp, [sp, #20]
  switch (PageStatus0)
   17690:	f000 80bf 	beq.w	17812 <EE_Init+0x1ca>
   17694:	f64f 71ff 	movw	r1, #65535	; 0xffff
   17698:	428d      	cmp	r5, r1
   1769a:	f000 808e 	beq.w	177ba <EE_Init+0x172>
   1769e:	b35d      	cbz	r5, 176f8 <EE_Init+0xb0>
   176a0:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   176a2:	ab16      	add	r3, sp, #88	; 0x58
   176a4:	464a      	mov	r2, r9
   176a6:	4641      	mov	r1, r8
   176a8:	4618      	mov	r0, r3
   176aa:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   176ac:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
   176b0:	f015 f917 	bl	2c8e2 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   176b4:	9b01      	ldr	r3, [sp, #4]
    if (AddressValue != ERASED)
   176b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   176ba:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   176be:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   176c2:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   176c6:	e001      	b.n	176cc <EE_Init+0x84>
  while (Address <= PAGE0_END_ADDRESS)
   176c8:	42b4      	cmp	r4, r6
   176ca:	d009      	beq.n	176e0 <EE_Init+0x98>
    AddressValue = (*(__IO uint16_t*)Address);
   176cc:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   176ce:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   176d0:	429a      	cmp	r2, r3
   176d2:	d0f9      	beq.n	176c8 <EE_Init+0x80>
    FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   176d4:	a903      	add	r1, sp, #12
   176d6:	a809      	add	r0, sp, #36	; 0x24
   176d8:	f7f4 f968 	bl	b9ac <HAL_FLASHEx_Erase>
    if (FlashStatus != HAL_OK)
   176dc:	2800      	cmp	r0, #0
   176de:	d167      	bne.n	177b0 <EE_Init+0x168>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS,((uint32_t)valid));
   176e0:	9a00      	ldr	r2, [sp, #0]
   176e2:	2001      	movs	r0, #1
   176e4:	498f      	ldr	r1, [pc, #572]	; (17924 <EE_Init+0x2dc>)
   176e6:	f7f3 ffe7 	bl	b6b8 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
   176ea:	2800      	cmp	r0, #0
   176ec:	d160      	bne.n	177b0 <EE_Init+0x168>
  return HAL_OK;
   176ee:	2700      	movs	r7, #0
}
   176f0:	4638      	mov	r0, r7
   176f2:	b01f      	add	sp, #124	; 0x7c
   176f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
   176f8:	2f00      	cmp	r7, #0
   176fa:	f000 8101 	beq.w	17900 <EE_Init+0x2b8>
      else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
   176fe:	f64f 73ff 	movw	r3, #65535	; 0xffff
   17702:	429f      	cmp	r7, r3
   17704:	d0f3      	beq.n	176ee <EE_Init+0xa6>
  int16_t x = -1;
   17706:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1770a:	4e88      	ldr	r6, [pc, #544]	; (1792c <EE_Init+0x2e4>)
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   1770c:	f8df 822c 	ldr.w	r8, [pc, #556]	; 1793c <EE_Init+0x2f4>
      if (PageStatus0 == VALID_PAGE)
   17710:	f8df b22c 	ldr.w	fp, [pc, #556]	; 17940 <EE_Init+0x2f8>
   17714:	f8df 922c 	ldr.w	r9, [pc, #556]	; 17944 <EE_Init+0x2fc>
   17718:	f8df a22c 	ldr.w	sl, [pc, #556]	; 17948 <EE_Init+0x300>
      else if (PageStatus1 == VALID_PAGE)
   1771c:	4a84      	ldr	r2, [pc, #528]	; (17930 <EE_Init+0x2e8>)
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   1771e:	f8b8 3000 	ldrh.w	r3, [r8]
   17722:	f836 0015 	ldrh.w	r0, [r6, r5, lsl #1]
   17726:	4298      	cmp	r0, r3
            x = VarIdx;
   17728:	bf08      	it	eq
   1772a:	b22c      	sxtheq	r4, r5
          if (VarIdx != x)
   1772c:	42a5      	cmp	r5, r4
   1772e:	d01d      	beq.n	1776c <EE_Init+0x124>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17730:	4b7c      	ldr	r3, [pc, #496]	; (17924 <EE_Init+0x2dc>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17732:	497d      	ldr	r1, [pc, #500]	; (17928 <EE_Init+0x2e0>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17734:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17736:	8809      	ldrh	r1, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17738:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1773a:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
   1773c:	2b00      	cmp	r3, #0
   1773e:	f000 8122 	beq.w	17986 <EE_Init+0x33e>
      else if (PageStatus1 == VALID_PAGE)
   17742:	2900      	cmp	r1, #0
   17744:	f040 8151 	bne.w	179ea <EE_Init+0x3a2>
   17748:	497a      	ldr	r1, [pc, #488]	; (17934 <EE_Init+0x2ec>)
   1774a:	4694      	mov	ip, r2
   1774c:	4f7a      	ldr	r7, [pc, #488]	; (17938 <EE_Init+0x2f0>)
   1774e:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
   17750:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
   17752:	4288      	cmp	r0, r1
   17754:	d106      	bne.n	17764 <EE_Init+0x11c>
   17756:	e12c      	b.n	179b2 <EE_Init+0x36a>
    AddressValue = (*(__IO uint16_t*)Address);
   17758:	f833 7c20 	ldrh.w	r7, [r3, #-32]
    if (AddressValue == VirtAddress)
   1775c:	42b8      	cmp	r0, r7
   1775e:	f000 8126 	beq.w	179ae <EE_Init+0x366>
   17762:	460b      	mov	r3, r1
      Address = Address - 32;
   17764:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
   17768:	458c      	cmp	ip, r1
   1776a:	d3f5      	bcc.n	17758 <EE_Init+0x110>
   1776c:	3501      	adds	r5, #1
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
   1776e:	2d03      	cmp	r5, #3
   17770:	d1d5      	bne.n	1771e <EE_Init+0xd6>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE1_BASE_ADDRESS, ((uint32_t)valid));
   17772:	aa0e      	add	r2, sp, #56	; 0x38
   17774:	496c      	ldr	r1, [pc, #432]	; (17928 <EE_Init+0x2e0>)
   17776:	2001      	movs	r0, #1
   17778:	f7f3 ff9e 	bl	b6b8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   1777c:	b9c0      	cbnz	r0, 177b0 <EE_Init+0x168>
        pEraseInit.Sector = PAGE0_ID;
   1777e:	2006      	movs	r0, #6
        pEraseInit.Banks = FLASH_BANK_2 ;
   17780:	2502      	movs	r5, #2
        pEraseInit.NbSectors = 1;
   17782:	2401      	movs	r4, #1
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
   17784:	2220      	movs	r2, #32
        pEraseInit.Sector = PAGE0_ID;
   17786:	9006      	str	r0, [sp, #24]
    if (AddressValue != ERASED)
   17788:	f64f 71ff 	movw	r1, #65535	; 0xffff
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
   1778c:	4b65      	ldr	r3, [pc, #404]	; (17924 <EE_Init+0x2dc>)
  while (Address <= PAGE0_END_ADDRESS)
   1778e:	4866      	ldr	r0, [pc, #408]	; (17928 <EE_Init+0x2e0>)
        pEraseInit.Banks = FLASH_BANK_2 ;
   17790:	9505      	str	r5, [sp, #20]
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
   17792:	e9cd 4207 	strd	r4, r2, [sp, #28]
   17796:	e001      	b.n	1779c <EE_Init+0x154>
  while (Address <= PAGE0_END_ADDRESS)
   17798:	4283      	cmp	r3, r0
   1779a:	d0a8      	beq.n	176ee <EE_Init+0xa6>
    AddressValue = (*(__IO uint16_t*)Address);
   1779c:	881a      	ldrh	r2, [r3, #0]
    Address = Address + 4;
   1779e:	3304      	adds	r3, #4
    if (AddressValue != ERASED)
   177a0:	4291      	cmp	r1, r2
   177a2:	d0f9      	beq.n	17798 <EE_Init+0x150>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   177a4:	a902      	add	r1, sp, #8
   177a6:	a804      	add	r0, sp, #16
   177a8:	f7f4 f900 	bl	b9ac <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
   177ac:	2800      	cmp	r0, #0
   177ae:	d09e      	beq.n	176ee <EE_Init+0xa6>
        return FlashStatus;
   177b0:	b287      	uxth	r7, r0
}
   177b2:	4638      	mov	r0, r7
   177b4:	b01f      	add	sp, #124	; 0x7c
   177b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
   177ba:	b1ff      	cbz	r7, 177fc <EE_Init+0x1b4>
      else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
   177bc:	4297      	cmp	r7, r2
   177be:	f000 808b 	beq.w	178d8 <EE_Init+0x290>
   177c2:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   177c4:	ab16      	add	r3, sp, #88	; 0x58
   177c6:	464a      	mov	r2, r9
   177c8:	4641      	mov	r1, r8
   177ca:	4618      	mov	r0, r3
   177cc:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   177ce:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
   177d2:	f015 f886 	bl	2c8e2 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   177d6:	9b01      	ldr	r3, [sp, #4]
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   177d8:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   177dc:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   177e0:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   177e4:	e002      	b.n	177ec <EE_Init+0x1a4>
  while (Address <= PAGE0_END_ADDRESS)
   177e6:	42b4      	cmp	r4, r6
   177e8:	f43f af7a 	beq.w	176e0 <EE_Init+0x98>
    AddressValue = (*(__IO uint16_t*)Address);
   177ec:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   177ee:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   177f0:	429d      	cmp	r5, r3
   177f2:	d0f8      	beq.n	177e6 <EE_Init+0x19e>
   177f4:	e76e      	b.n	176d4 <EE_Init+0x8c>
  while (Address <= PAGE0_END_ADDRESS)
   177f6:	42b4      	cmp	r4, r6
   177f8:	f43f af79 	beq.w	176ee <EE_Init+0xa6>
    AddressValue = (*(__IO uint16_t*)Address);
   177fc:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   177fe:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   17800:	429d      	cmp	r5, r3
   17802:	d0f8      	beq.n	177f6 <EE_Init+0x1ae>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   17804:	a902      	add	r1, sp, #8
   17806:	a804      	add	r0, sp, #16
   17808:	f7f4 f8d0 	bl	b9ac <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
   1780c:	2800      	cmp	r0, #0
   1780e:	d1cf      	bne.n	177b0 <EE_Init+0x168>
   17810:	e76d      	b.n	176ee <EE_Init+0xa6>
      if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
   17812:	2f00      	cmp	r7, #0
   17814:	d13f      	bne.n	17896 <EE_Init+0x24e>
   17816:	463c      	mov	r4, r7
  int16_t x = -1;
   17818:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   1781c:	4e43      	ldr	r6, [pc, #268]	; (1792c <EE_Init+0x2e4>)
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   1781e:	f8df 812c 	ldr.w	r8, [pc, #300]	; 1794c <EE_Init+0x304>
      if (PageStatus0 == VALID_PAGE)
   17822:	f8df b11c 	ldr.w	fp, [pc, #284]	; 17940 <EE_Init+0x2f8>
   17826:	f8df a120 	ldr.w	sl, [pc, #288]	; 17948 <EE_Init+0x300>
   1782a:	f8df 9118 	ldr.w	r9, [pc, #280]	; 17944 <EE_Init+0x2fc>
      else if (PageStatus1 == VALID_PAGE)
   1782e:	4a40      	ldr	r2, [pc, #256]	; (17930 <EE_Init+0x2e8>)
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   17830:	f8b8 3000 	ldrh.w	r3, [r8]
   17834:	f836 0014 	ldrh.w	r0, [r6, r4, lsl #1]
   17838:	4298      	cmp	r0, r3
            x = VarIdx;
   1783a:	bf08      	it	eq
   1783c:	b225      	sxtheq	r5, r4
          if (VarIdx != x)
   1783e:	42ac      	cmp	r4, r5
   17840:	d01d      	beq.n	1787e <EE_Init+0x236>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17842:	4b38      	ldr	r3, [pc, #224]	; (17924 <EE_Init+0x2dc>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17844:	4938      	ldr	r1, [pc, #224]	; (17928 <EE_Init+0x2e0>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17846:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17848:	8809      	ldrh	r1, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1784a:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1784c:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
   1784e:	2b00      	cmp	r3, #0
   17850:	f000 8094 	beq.w	1797c <EE_Init+0x334>
      else if (PageStatus1 == VALID_PAGE)
   17854:	2900      	cmp	r1, #0
   17856:	f040 80c5 	bne.w	179e4 <EE_Init+0x39c>
   1785a:	4936      	ldr	r1, [pc, #216]	; (17934 <EE_Init+0x2ec>)
   1785c:	4694      	mov	ip, r2
   1785e:	4f36      	ldr	r7, [pc, #216]	; (17938 <EE_Init+0x2f0>)
   17860:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
   17862:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
   17864:	4288      	cmp	r0, r1
   17866:	d106      	bne.n	17876 <EE_Init+0x22e>
   17868:	e094      	b.n	17994 <EE_Init+0x34c>
    AddressValue = (*(__IO uint16_t*)Address);
   1786a:	f833 7c20 	ldrh.w	r7, [r3, #-32]
    if (AddressValue == VirtAddress)
   1786e:	42b8      	cmp	r0, r7
   17870:	f000 808e 	beq.w	17990 <EE_Init+0x348>
   17874:	460b      	mov	r3, r1
      Address = Address - 32;
   17876:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
   1787a:	4561      	cmp	r1, ip
   1787c:	d8f5      	bhi.n	1786a <EE_Init+0x222>
   1787e:	3401      	adds	r4, #1
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
   17880:	2c03      	cmp	r4, #3
   17882:	d1d5      	bne.n	17830 <EE_Init+0x1e8>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
   17884:	aa0e      	add	r2, sp, #56	; 0x38
   17886:	4927      	ldr	r1, [pc, #156]	; (17924 <EE_Init+0x2dc>)
   17888:	2001      	movs	r0, #1
   1788a:	f7f3 ff15 	bl	b6b8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   1788e:	2800      	cmp	r0, #0
   17890:	f43f af2d 	beq.w	176ee <EE_Init+0xa6>
   17894:	e78c      	b.n	177b0 <EE_Init+0x168>
      else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
   17896:	f64f 75ff 	movw	r5, #65535	; 0xffff
   1789a:	42af      	cmp	r7, r5
   1789c:	f000 8096 	beq.w	179cc <EE_Init+0x384>
   178a0:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   178a2:	ab16      	add	r3, sp, #88	; 0x58
   178a4:	464a      	mov	r2, r9
   178a6:	4641      	mov	r1, r8
   178a8:	4618      	mov	r0, r3
   178aa:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   178ac:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
   178b0:	f015 f817 	bl	2c8e2 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   178b4:	9b01      	ldr	r3, [sp, #4]
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   178b6:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   178ba:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   178be:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   178c2:	e002      	b.n	178ca <EE_Init+0x282>
  while (Address <= PAGE0_END_ADDRESS)
   178c4:	42b4      	cmp	r4, r6
   178c6:	f43f af0b 	beq.w	176e0 <EE_Init+0x98>
    AddressValue = (*(__IO uint16_t*)Address);
   178ca:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   178cc:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   178ce:	429d      	cmp	r5, r3
   178d0:	d0f8      	beq.n	178c4 <EE_Init+0x27c>
   178d2:	e6ff      	b.n	176d4 <EE_Init+0x8c>
  while (Address <= PAGE0_END_ADDRESS)
   178d4:	42b4      	cmp	r4, r6
   178d6:	d00a      	beq.n	178ee <EE_Init+0x2a6>
    AddressValue = (*(__IO uint16_t*)Address);
   178d8:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   178da:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   178dc:	429d      	cmp	r5, r3
   178de:	d0f9      	beq.n	178d4 <EE_Init+0x28c>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   178e0:	a902      	add	r1, sp, #8
   178e2:	a804      	add	r0, sp, #16
   178e4:	f7f4 f862 	bl	b9ac <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
   178e8:	2800      	cmp	r0, #0
   178ea:	f47f af61 	bne.w	177b0 <EE_Init+0x168>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE1_BASE_ADDRESS, ((uint32_t)valid));
   178ee:	aa0e      	add	r2, sp, #56	; 0x38
   178f0:	490d      	ldr	r1, [pc, #52]	; (17928 <EE_Init+0x2e0>)
   178f2:	2001      	movs	r0, #1
   178f4:	f7f3 fee0 	bl	b6b8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   178f8:	2800      	cmp	r0, #0
   178fa:	f43f aef8 	beq.w	176ee <EE_Init+0xa6>
   178fe:	e757      	b.n	177b0 <EE_Init+0x168>
   17900:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   17902:	ab16      	add	r3, sp, #88	; 0x58
   17904:	464a      	mov	r2, r9
   17906:	4639      	mov	r1, r7
   17908:	4618      	mov	r0, r3
   1790a:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   1790c:	9703      	str	r7, [sp, #12]
  uint32_t valid[8] = {0x0000};
   1790e:	f014 ffe8 	bl	2c8e2 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   17912:	9b01      	ldr	r3, [sp, #4]
    if (AddressValue != ERASED)
   17914:	f64f 72ff 	movw	r2, #65535	; 0xffff
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   17918:	9709      	str	r7, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   1791a:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   1791e:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   17922:	e017      	b.n	17954 <EE_Init+0x30c>
   17924:	081c0000 	.word	0x081c0000
   17928:	081e0000 	.word	0x081e0000
   1792c:	00062574 	.word	0x00062574
   17930:	081e0020 	.word	0x081e0020
   17934:	081fffe0 	.word	0x081fffe0
   17938:	081fffc0 	.word	0x081fffc0
   1793c:	081e0006 	.word	0x081e0006
   17940:	081dffc0 	.word	0x081dffc0
   17944:	081dffe0 	.word	0x081dffe0
   17948:	081c0020 	.word	0x081c0020
   1794c:	081c0006 	.word	0x081c0006
  while (Address <= PAGE0_END_ADDRESS)
   17950:	42b4      	cmp	r4, r6
   17952:	d00a      	beq.n	1796a <EE_Init+0x322>
    AddressValue = (*(__IO uint16_t*)Address);
   17954:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   17956:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   17958:	429a      	cmp	r2, r3
   1795a:	d0f9      	beq.n	17950 <EE_Init+0x308>
    FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   1795c:	a903      	add	r1, sp, #12
   1795e:	a809      	add	r0, sp, #36	; 0x24
   17960:	f7f4 f824 	bl	b9ac <HAL_FLASHEx_Erase>
    if (FlashStatus != HAL_OK)
   17964:	2800      	cmp	r0, #0
   17966:	f47f af23 	bne.w	177b0 <EE_Init+0x168>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS,((uint32_t)valid));
   1796a:	9a00      	ldr	r2, [sp, #0]
   1796c:	2001      	movs	r0, #1
   1796e:	4920      	ldr	r1, [pc, #128]	; (179f0 <EE_Init+0x3a8>)
   17970:	f7f3 fea2 	bl	b6b8 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
   17974:	2800      	cmp	r0, #0
   17976:	f43f aebb 	beq.w	176f0 <EE_Init+0xa8>
   1797a:	e719      	b.n	177b0 <EE_Init+0x168>
      if (PageStatus0 == VALID_PAGE)
   1797c:	465f      	mov	r7, fp
   1797e:	46d4      	mov	ip, sl
   17980:	4649      	mov	r1, r9
   17982:	464b      	mov	r3, r9
   17984:	e76d      	b.n	17862 <EE_Init+0x21a>
   17986:	465f      	mov	r7, fp
   17988:	4649      	mov	r1, r9
   1798a:	464b      	mov	r3, r9
   1798c:	46d4      	mov	ip, sl
   1798e:	e6df      	b.n	17750 <EE_Init+0x108>
   17990:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   17994:	8839      	ldrh	r1, [r7, #0]
   17996:	4b17      	ldr	r3, [pc, #92]	; (179f4 <EE_Init+0x3ac>)
   17998:	b289      	uxth	r1, r1
   1799a:	8019      	strh	r1, [r3, #0]
   1799c:	9200      	str	r2, [sp, #0]
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
   1799e:	f7ff fdff 	bl	175a0 <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != HAL_OK)
   179a2:	9a00      	ldr	r2, [sp, #0]
   179a4:	4607      	mov	r7, r0
   179a6:	2800      	cmp	r0, #0
   179a8:	f43f af69 	beq.w	1787e <EE_Init+0x236>
   179ac:	e6a0      	b.n	176f0 <EE_Init+0xa8>
   179ae:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   179b2:	8839      	ldrh	r1, [r7, #0]
   179b4:	4b0f      	ldr	r3, [pc, #60]	; (179f4 <EE_Init+0x3ac>)
   179b6:	b289      	uxth	r1, r1
   179b8:	8019      	strh	r1, [r3, #0]
   179ba:	9200      	str	r2, [sp, #0]
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
   179bc:	f7ff fdf0 	bl	175a0 <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != HAL_OK)
   179c0:	9a00      	ldr	r2, [sp, #0]
   179c2:	4607      	mov	r7, r0
   179c4:	2800      	cmp	r0, #0
   179c6:	f43f aed1 	beq.w	1776c <EE_Init+0x124>
   179ca:	e691      	b.n	176f0 <EE_Init+0xa8>
        pEraseInit.Sector = PAGE1_ID;
   179cc:	2307      	movs	r3, #7
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
   179ce:	aa0e      	add	r2, sp, #56	; 0x38
   179d0:	4621      	mov	r1, r4
   179d2:	4650      	mov	r0, sl
        pEraseInit.Sector = PAGE1_ID;
   179d4:	e9cd a305 	strd	sl, r3, [sp, #20]
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
   179d8:	f7f3 fe6e 	bl	b6b8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   179dc:	2800      	cmp	r0, #0
   179de:	f43f ae86 	beq.w	176ee <EE_Init+0xa6>
   179e2:	e6e5      	b.n	177b0 <EE_Init+0x168>
   179e4:	4b03      	ldr	r3, [pc, #12]	; (179f4 <EE_Init+0x3ac>)
   179e6:	8819      	ldrh	r1, [r3, #0]
   179e8:	e7d8      	b.n	1799c <EE_Init+0x354>
   179ea:	4b02      	ldr	r3, [pc, #8]	; (179f4 <EE_Init+0x3ac>)
   179ec:	8819      	ldrh	r1, [r3, #0]
   179ee:	e7e4      	b.n	179ba <EE_Init+0x372>
   179f0:	081c0000 	.word	0x081c0000
   179f4:	020e2dca 	.word	0x020e2dca

000179f8 <EE_ReadVariable>:
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   179f8:	4b15      	ldr	r3, [pc, #84]	; (17a50 <EE_ReadVariable+0x58>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   179fa:	4a16      	ldr	r2, [pc, #88]	; (17a54 <EE_ReadVariable+0x5c>)
{
   179fc:	b430      	push	{r4, r5}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   179fe:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17a00:	8812      	ldrh	r2, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17a02:	b29b      	uxth	r3, r3
      if (PageStatus0 == VALID_PAGE)
   17a04:	b133      	cbz	r3, 17a14 <EE_ReadVariable+0x1c>
   17a06:	b292      	uxth	r2, r2
      else if (PageStatus1 == VALID_PAGE)
   17a08:	b9fa      	cbnz	r2, 17a4a <EE_ReadVariable+0x52>
   17a0a:	4b13      	ldr	r3, [pc, #76]	; (17a58 <EE_ReadVariable+0x60>)
   17a0c:	4c13      	ldr	r4, [pc, #76]	; (17a5c <EE_ReadVariable+0x64>)
   17a0e:	461a      	mov	r2, r3
   17a10:	4d13      	ldr	r5, [pc, #76]	; (17a60 <EE_ReadVariable+0x68>)
   17a12:	e003      	b.n	17a1c <EE_ReadVariable+0x24>
      if (PageStatus0 == VALID_PAGE)
   17a14:	4b13      	ldr	r3, [pc, #76]	; (17a64 <EE_ReadVariable+0x6c>)
   17a16:	4c14      	ldr	r4, [pc, #80]	; (17a68 <EE_ReadVariable+0x70>)
   17a18:	461a      	mov	r2, r3
   17a1a:	4d14      	ldr	r5, [pc, #80]	; (17a6c <EE_ReadVariable+0x74>)
    AddressValue = (*(__IO uint16_t*)Address);
   17a1c:	8812      	ldrh	r2, [r2, #0]
    if (AddressValue == VirtAddress)
   17a1e:	4290      	cmp	r0, r2
   17a20:	d105      	bne.n	17a2e <EE_ReadVariable+0x36>
   17a22:	e00d      	b.n	17a40 <EE_ReadVariable+0x48>
    AddressValue = (*(__IO uint16_t*)Address);
   17a24:	f833 4c20 	ldrh.w	r4, [r3, #-32]
    if (AddressValue == VirtAddress)
   17a28:	42a0      	cmp	r0, r4
   17a2a:	d007      	beq.n	17a3c <EE_ReadVariable+0x44>
   17a2c:	4613      	mov	r3, r2
      Address = Address - 32;
   17a2e:	f1a3 0220 	sub.w	r2, r3, #32
  while (Address > (PageStartAddress + 32))
   17a32:	42aa      	cmp	r2, r5
   17a34:	d8f6      	bhi.n	17a24 <EE_ReadVariable+0x2c>
  uint16_t AddressValue = 0x5555, ReadStatus = 1;
   17a36:	2001      	movs	r0, #1
}
   17a38:	bc30      	pop	{r4, r5}
   17a3a:	4770      	bx	lr
   17a3c:	f1a3 0440 	sub.w	r4, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   17a40:	8823      	ldrh	r3, [r4, #0]
      ReadStatus = 0;
   17a42:	2000      	movs	r0, #0
      *Data = (*(__IO uint16_t*)(Address - 32));
   17a44:	800b      	strh	r3, [r1, #0]
}
   17a46:	bc30      	pop	{r4, r5}
   17a48:	4770      	bx	lr
    return  NO_VALID_PAGE;
   17a4a:	20ab      	movs	r0, #171	; 0xab
}
   17a4c:	bc30      	pop	{r4, r5}
   17a4e:	4770      	bx	lr
   17a50:	081c0000 	.word	0x081c0000
   17a54:	081e0000 	.word	0x081e0000
   17a58:	081fffe0 	.word	0x081fffe0
   17a5c:	081fffc0 	.word	0x081fffc0
   17a60:	081e0020 	.word	0x081e0020
   17a64:	081dffe0 	.word	0x081dffe0
   17a68:	081dffc0 	.word	0x081dffc0
   17a6c:	081c0020 	.word	0x081c0020

00017a70 <EE_WriteVariable>:
{
   17a70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t data32[8] = {Data};
   17a74:	2300      	movs	r3, #0
{
   17a76:	b099      	sub	sp, #100	; 0x64
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17a78:	4c71      	ldr	r4, [pc, #452]	; (17c40 <EE_WriteVariable+0x1d0>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17a7a:	4a72      	ldr	r2, [pc, #456]	; (17c44 <EE_WriteVariable+0x1d4>)
  uint32_t VirtAddress1[8] = {VirtAddress};
   17a7c:	9010      	str	r0, [sp, #64]	; 0x40
  uint32_t data32[8] = {Data};
   17a7e:	9108      	str	r1, [sp, #32]
   17a80:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t VirtAddress1[8] = {VirtAddress};
   17a82:	9317      	str	r3, [sp, #92]	; 0x5c
  uint32_t data32[8] = {Data};
   17a84:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
   17a88:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
   17a8c:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  uint32_t VirtAddress1[8] = {VirtAddress};
   17a90:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
   17a94:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
   17a98:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17a9c:	8823      	ldrh	r3, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17a9e:	8812      	ldrh	r2, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17aa0:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17aa2:	b292      	uxth	r2, r2
      if (PageStatus1 == VALID_PAGE)
   17aa4:	bb2a      	cbnz	r2, 17af2 <EE_WriteVariable+0x82>
        if (PageStatus0 == RECEIVE_DATA)
   17aa6:	f64e 62ee 	movw	r2, #61166	; 0xeeee
          return PAGE1;         /* Page1 valid */
   17aaa:	1a9b      	subs	r3, r3, r2
   17aac:	bf18      	it	ne
   17aae:	2301      	movne	r3, #1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   17ab0:	f203 470e 	addw	r7, r3, #1038	; 0x40e
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   17ab4:	4a64      	ldr	r2, [pc, #400]	; (17c48 <EE_WriteVariable+0x1d8>)
   17ab6:	3301      	adds	r3, #1
   17ab8:	4688      	mov	r8, r1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   17aba:	047f      	lsls	r7, r7, #17
   17abc:	4604      	mov	r4, r0
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   17abe:	eb02 4243 	add.w	r2, r2, r3, lsl #17
  while (Address < PageEndAddress)
   17ac2:	4297      	cmp	r7, r2
   17ac4:	d303      	bcc.n	17ace <EE_WriteVariable+0x5e>
   17ac6:	e021      	b.n	17b0c <EE_WriteVariable+0x9c>
      Address = Address + 64;
   17ac8:	3740      	adds	r7, #64	; 0x40
  while (Address < PageEndAddress)
   17aca:	42ba      	cmp	r2, r7
   17acc:	d91e      	bls.n	17b0c <EE_WriteVariable+0x9c>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
   17ace:	683b      	ldr	r3, [r7, #0]
   17ad0:	3301      	adds	r3, #1
   17ad2:	d1f9      	bne.n	17ac8 <EE_WriteVariable+0x58>
      FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, ((uint32_t)data32));
   17ad4:	ae08      	add	r6, sp, #32
   17ad6:	4639      	mov	r1, r7
   17ad8:	2001      	movs	r0, #1
   17ada:	4632      	mov	r2, r6
   17adc:	f7f3 fdec 	bl	b6b8 <HAL_FLASH_Program>
      if (FlashStatus != HAL_OK)
   17ae0:	2800      	cmp	r0, #0
   17ae2:	d03f      	beq.n	17b64 <EE_WriteVariable+0xf4>
     return FlashStatus;
   17ae4:	b285      	uxth	r5, r0
  if (Status == PAGE_FULL)
   17ae6:	2d80      	cmp	r5, #128	; 0x80
   17ae8:	d011      	beq.n	17b0e <EE_WriteVariable+0x9e>
}
   17aea:	4628      	mov	r0, r5
   17aec:	b019      	add	sp, #100	; 0x64
   17aee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      else if (PageStatus0 == VALID_PAGE)
   17af2:	b933      	cbnz	r3, 17b02 <EE_WriteVariable+0x92>
        if (PageStatus1 == RECEIVE_DATA)
   17af4:	f64e 63ee 	movw	r3, #61166	; 0xeeee
          return PAGE1;         /* Page1 valid */
   17af8:	1ad3      	subs	r3, r2, r3
   17afa:	fab3 f383 	clz	r3, r3
   17afe:	095b      	lsrs	r3, r3, #5
   17b00:	e7d6      	b.n	17ab0 <EE_WriteVariable+0x40>
    /* Old page ID where variable will be taken from */
    OldPageId = PAGE0_ID;
  }
  else
  {
    return NO_VALID_PAGE;       /* No valid Page */
   17b02:	25ab      	movs	r5, #171	; 0xab
}
   17b04:	4628      	mov	r0, r5
   17b06:	b019      	add	sp, #100	; 0x64
   17b08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   17b0c:	ae08      	add	r6, sp, #32
  uint32_t SectorError = 0;
   17b0e:	2500      	movs	r5, #0
  uint32_t valid[8] = {0x0000};
   17b10:	2220      	movs	r2, #32
   17b12:	4630      	mov	r0, r6
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17b14:	4f4b      	ldr	r7, [pc, #300]	; (17c44 <EE_WriteVariable+0x1d4>)
  uint32_t valid[8] = {0x0000};
   17b16:	4629      	mov	r1, r5
  uint32_t SectorError = 0;
   17b18:	9502      	str	r5, [sp, #8]
  uint32_t valid[8] = {0x0000};
   17b1a:	f014 fee2 	bl	2c8e2 <memset>
  uint32_t receive[8] = {0xEEEE};
   17b1e:	f64e 63ee 	movw	r3, #61166	; 0xeeee
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b22:	4947      	ldr	r1, [pc, #284]	; (17c40 <EE_WriteVariable+0x1d0>)
  uint32_t receive[8] = {0xEEEE};
   17b24:	9517      	str	r5, [sp, #92]	; 0x5c
   17b26:	9310      	str	r3, [sp, #64]	; 0x40
   17b28:	e9cd 5511 	strd	r5, r5, [sp, #68]	; 0x44
   17b2c:	e9cd 5513 	strd	r5, r5, [sp, #76]	; 0x4c
   17b30:	e9cd 5515 	strd	r5, r5, [sp, #84]	; 0x54
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b34:	880b      	ldrh	r3, [r1, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17b36:	883a      	ldrh	r2, [r7, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b38:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17b3a:	b292      	uxth	r2, r2
      if (PageStatus0 == VALID_PAGE)
   17b3c:	b17b      	cbz	r3, 17b5e <EE_WriteVariable+0xee>
      else if (PageStatus1 == VALID_PAGE)
   17b3e:	2a00      	cmp	r2, #0
   17b40:	d1df      	bne.n	17b02 <EE_WriteVariable+0x92>
    NewPageAddress = PAGE0_BASE_ADDRESS;
   17b42:	460f      	mov	r7, r1
      else if (PageStatus1 == VALID_PAGE)
   17b44:	f04f 0907 	mov.w	r9, #7
  }

  /* Set the new Page status to RECEIVE_DATA status */

  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)receive));
   17b48:	aa10      	add	r2, sp, #64	; 0x40
   17b4a:	4639      	mov	r1, r7
   17b4c:	2001      	movs	r0, #1
   17b4e:	f7f3 fdb3 	bl	b6b8 <HAL_FLASH_Program>

  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
   17b52:	b170      	cbz	r0, 17b72 <EE_WriteVariable+0x102>
  /* Set new Page status to VALID_PAGE status */
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)valid));
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
  {
    return FlashStatus;
   17b54:	b285      	uxth	r5, r0
}
   17b56:	4628      	mov	r0, r5
   17b58:	b019      	add	sp, #100	; 0x64
   17b5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus0 == VALID_PAGE)
   17b5e:	f04f 0906 	mov.w	r9, #6
   17b62:	e7f1      	b.n	17b48 <EE_WriteVariable+0xd8>
     FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address + 32, ((uint32_t)VirtAddress1));
   17b64:	f107 0120 	add.w	r1, r7, #32
   17b68:	aa10      	add	r2, sp, #64	; 0x40
   17b6a:	2001      	movs	r0, #1
   17b6c:	f7f3 fda4 	bl	b6b8 <HAL_FLASH_Program>
   17b70:	e7b8      	b.n	17ae4 <EE_WriteVariable+0x74>
  EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
   17b72:	4641      	mov	r1, r8
   17b74:	4620      	mov	r0, r4
   17b76:	f7ff fd13 	bl	175a0 <EE_VerifyPageFullWriteVariable>
  if (EepromStatus != HAL_OK)
   17b7a:	4605      	mov	r5, r0
   17b7c:	2800      	cmp	r0, #0
   17b7e:	d1b4      	bne.n	17aea <EE_WriteVariable+0x7a>
   17b80:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 17c58 <EE_WriteVariable+0x1e8>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b84:	4a2e      	ldr	r2, [pc, #184]	; (17c40 <EE_WriteVariable+0x1d0>)
   17b86:	f108 0a06 	add.w	sl, r8, #6
      if (PageStatus0 == VALID_PAGE)
   17b8a:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 17c5c <EE_WriteVariable+0x1ec>
    if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
   17b8e:	f838 0b02 	ldrh.w	r0, [r8], #2
   17b92:	4284      	cmp	r4, r0
   17b94:	d01b      	beq.n	17bce <EE_WriteVariable+0x15e>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b96:	8813      	ldrh	r3, [r2, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17b98:	492a      	ldr	r1, [pc, #168]	; (17c44 <EE_WriteVariable+0x1d4>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b9a:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17b9c:	8809      	ldrh	r1, [r1, #0]
   17b9e:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
   17ba0:	2b00      	cmp	r3, #0
   17ba2:	d034      	beq.n	17c0e <EE_WriteVariable+0x19e>
      else if (PageStatus1 == VALID_PAGE)
   17ba4:	2900      	cmp	r1, #0
   17ba6:	d148      	bne.n	17c3a <EE_WriteVariable+0x1ca>
   17ba8:	4928      	ldr	r1, [pc, #160]	; (17c4c <EE_WriteVariable+0x1dc>)
   17baa:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 17c60 <EE_WriteVariable+0x1f0>
   17bae:	f8df c0b4 	ldr.w	ip, [pc, #180]	; 17c64 <EE_WriteVariable+0x1f4>
   17bb2:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
   17bb4:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
   17bb6:	4288      	cmp	r0, r1
   17bb8:	d105      	bne.n	17bc6 <EE_WriteVariable+0x156>
   17bba:	e031      	b.n	17c20 <EE_WriteVariable+0x1b0>
    AddressValue = (*(__IO uint16_t*)Address);
   17bbc:	f833 cc20 	ldrh.w	ip, [r3, #-32]
    if (AddressValue == VirtAddress)
   17bc0:	4560      	cmp	r0, ip
   17bc2:	d02b      	beq.n	17c1c <EE_WriteVariable+0x1ac>
   17bc4:	460b      	mov	r3, r1
      Address = Address - 32;
   17bc6:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
   17bca:	458e      	cmp	lr, r1
   17bcc:	d3f6      	bcc.n	17bbc <EE_WriteVariable+0x14c>
  for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
   17bce:	45d0      	cmp	r8, sl
   17bd0:	d1dd      	bne.n	17b8e <EE_WriteVariable+0x11e>
  HAL_FLASH_Unlock();
   17bd2:	f7f3 fde7 	bl	b7a4 <HAL_FLASH_Unlock>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
   17bd6:	4b1e      	ldr	r3, [pc, #120]	; (17c50 <EE_WriteVariable+0x1e0>)
   17bd8:	f44f 008e 	mov.w	r0, #4653056	; 0x470000
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
   17bdc:	2100      	movs	r1, #0
  pEraseInit.Banks = FLASH_BANK_2 ;
   17bde:	2202      	movs	r2, #2
  pEraseInit.NbSectors = 1;
   17be0:	2401      	movs	r4, #1
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
   17be2:	6158      	str	r0, [r3, #20]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   17be4:	2320      	movs	r3, #32
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
   17be6:	9103      	str	r1, [sp, #12]
  FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   17be8:	a803      	add	r0, sp, #12
   17bea:	a902      	add	r1, sp, #8
  pEraseInit.Sector = OldPageId;
   17bec:	f8cd 9014 	str.w	r9, [sp, #20]
  pEraseInit.Banks = FLASH_BANK_2 ;
   17bf0:	9204      	str	r2, [sp, #16]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   17bf2:	e9cd 4306 	strd	r4, r3, [sp, #24]
  FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   17bf6:	f7f3 fed9 	bl	b9ac <HAL_FLASHEx_Erase>
  if (FlashStatus != HAL_OK)
   17bfa:	2800      	cmp	r0, #0
   17bfc:	d1aa      	bne.n	17b54 <EE_WriteVariable+0xe4>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)valid));
   17bfe:	4632      	mov	r2, r6
   17c00:	4639      	mov	r1, r7
   17c02:	4620      	mov	r0, r4
   17c04:	f7f3 fd58 	bl	b6b8 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
   17c08:	2800      	cmp	r0, #0
   17c0a:	d1a3      	bne.n	17b54 <EE_WriteVariable+0xe4>
   17c0c:	e76d      	b.n	17aea <EE_WriteVariable+0x7a>
      if (PageStatus0 == VALID_PAGE)
   17c0e:	f8df c058 	ldr.w	ip, [pc, #88]	; 17c68 <EE_WriteVariable+0x1f8>
   17c12:	4659      	mov	r1, fp
   17c14:	465b      	mov	r3, fp
   17c16:	f8df e054 	ldr.w	lr, [pc, #84]	; 17c6c <EE_WriteVariable+0x1fc>
   17c1a:	e7cb      	b.n	17bb4 <EE_WriteVariable+0x144>
   17c1c:	f1a3 0c40 	sub.w	ip, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   17c20:	f8bc 1000 	ldrh.w	r1, [ip]
   17c24:	4b0b      	ldr	r3, [pc, #44]	; (17c54 <EE_WriteVariable+0x1e4>)
   17c26:	b289      	uxth	r1, r1
   17c28:	8019      	strh	r1, [r3, #0]
   17c2a:	9201      	str	r2, [sp, #4]
        EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
   17c2c:	f7ff fcb8 	bl	175a0 <EE_VerifyPageFullWriteVariable>
        if (EepromStatus != HAL_OK)
   17c30:	9a01      	ldr	r2, [sp, #4]
   17c32:	2800      	cmp	r0, #0
   17c34:	d0cb      	beq.n	17bce <EE_WriteVariable+0x15e>
   17c36:	4605      	mov	r5, r0
  return Status;
   17c38:	e757      	b.n	17aea <EE_WriteVariable+0x7a>
   17c3a:	4b06      	ldr	r3, [pc, #24]	; (17c54 <EE_WriteVariable+0x1e4>)
   17c3c:	8819      	ldrh	r1, [r3, #0]
   17c3e:	e7f4      	b.n	17c2a <EE_WriteVariable+0x1ba>
   17c40:	081c0000 	.word	0x081c0000
   17c44:	081e0000 	.word	0x081e0000
   17c48:	081bffff 	.word	0x081bffff
   17c4c:	081fffe0 	.word	0x081fffe0
   17c50:	52002000 	.word	0x52002000
   17c54:	020e2dca 	.word	0x020e2dca
   17c58:	00062574 	.word	0x00062574
   17c5c:	081dffe0 	.word	0x081dffe0
   17c60:	081e0020 	.word	0x081e0020
   17c64:	081fffc0 	.word	0x081fffc0
   17c68:	081dffc0 	.word	0x081dffc0
   17c6c:	081c0020 	.word	0x081c0020

00017c70 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
   17c70:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
   17c72:	4903      	ldr	r1, [pc, #12]	; (17c80 <MX_FATFS_Init+0x10>)
   17c74:	4803      	ldr	r0, [pc, #12]	; (17c84 <MX_FATFS_Init+0x14>)
   17c76:	f7fe fca5 	bl	165c4 <FATFS_LinkDriver>
   17c7a:	4b03      	ldr	r3, [pc, #12]	; (17c88 <MX_FATFS_Init+0x18>)
   17c7c:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */     
  /* USER CODE END Init */
}
   17c7e:	bd08      	pop	{r3, pc}
   17c80:	020e39fc 	.word	0x020e39fc
   17c84:	00030c84 	.word	0x00030c84
   17c88:	020e39f8 	.word	0x020e39f8

00017c8c <BSP_PlatformIsDetected>:
  *
  ******************************************************************************
*/
#include "fatfs_platform.h"

uint8_t	BSP_PlatformIsDetected(void) {
   17c8c:	b508      	push	{r3, lr}
    uint8_t status = SD_PRESENT;
    /* Check SD card detect pin */
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
   17c8e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   17c92:	4803      	ldr	r0, [pc, #12]	; (17ca0 <BSP_PlatformIsDetected+0x14>)
   17c94:	f7f4 fabc 	bl	c210 <HAL_GPIO_ReadPin>
    }
    /* USER CODE BEGIN 1 */
    /* user code can be inserted here */
    /* USER CODE END 1 */ 
    return status;
}  
   17c98:	fab0 f080 	clz	r0, r0
   17c9c:	0940      	lsrs	r0, r0, #5
   17c9e:	bd08      	pop	{r3, pc}
   17ca0:	58020800 	.word	0x58020800

00017ca4 <MX_FMC_Init>:

SDRAM_HandleTypeDef hsdram1;

/* FMC initialization function */
void MX_FMC_Init(void)
{
   17ca4:	b570      	push	{r4, r5, r6, lr}
  FMC_SDRAM_TimingTypeDef SdramTiming = {0};

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
   17ca6:	4b18      	ldr	r3, [pc, #96]	; (17d08 <MX_FMC_Init+0x64>)
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
   17ca8:	2001      	movs	r0, #1
  hsdram1.Instance = FMC_SDRAM_DEVICE;
   17caa:	4d18      	ldr	r5, [pc, #96]	; (17d0c <MX_FMC_Init+0x68>)
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
   17cac:	2108      	movs	r1, #8
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
   17cae:	2410      	movs	r4, #16
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
   17cb0:	2240      	movs	r2, #64	; 0x40
  hsdram1.Instance = FMC_SDRAM_DEVICE;
   17cb2:	601d      	str	r5, [r3, #0]
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
   17cb4:	f44f 7580 	mov.w	r5, #256	; 0x100
{
   17cb8:	b088      	sub	sp, #32
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
  SdramTiming.ExitSelfRefreshDelay = 6;
  SdramTiming.SelfRefreshTime = 4;
   17cba:	2604      	movs	r6, #4
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
   17cbc:	6098      	str	r0, [r3, #8]
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_3;
   17cbe:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
   17cc2:	60d9      	str	r1, [r3, #12]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
   17cc4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
   17cc8:	611c      	str	r4, [r3, #16]
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
   17cca:	2400      	movs	r4, #0
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
   17ccc:	615a      	str	r2, [r3, #20]
  SdramTiming.LoadToActiveDelay = 2;
   17cce:	2202      	movs	r2, #2
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
   17cd0:	619d      	str	r5, [r3, #24]
  SdramTiming.ExitSelfRefreshDelay = 6;
   17cd2:	2506      	movs	r5, #6
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_3;
   17cd4:	6218      	str	r0, [r3, #32]
  SdramTiming.RowCycleDelay = 6;
  SdramTiming.WriteRecoveryTime = 2;
  SdramTiming.RPDelay = 2;
  SdramTiming.RCDDelay = 2;

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
   17cd6:	4618      	mov	r0, r3
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
   17cd8:	6259      	str	r1, [r3, #36]	; 0x24
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
   17cda:	eb0d 0106 	add.w	r1, sp, r6
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
   17cde:	605c      	str	r4, [r3, #4]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
   17ce0:	61dc      	str	r4, [r3, #28]
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
   17ce2:	629c      	str	r4, [r3, #40]	; 0x28
  SdramTiming.LoadToActiveDelay = 2;
   17ce4:	9201      	str	r2, [sp, #4]
  SdramTiming.RCDDelay = 2;
   17ce6:	9207      	str	r2, [sp, #28]
  SdramTiming.ExitSelfRefreshDelay = 6;
   17ce8:	9502      	str	r5, [sp, #8]
  SdramTiming.RPDelay = 2;
   17cea:	e9cd 2205 	strd	r2, r2, [sp, #20]
  SdramTiming.SelfRefreshTime = 4;
   17cee:	e9cd 6503 	strd	r6, r5, [sp, #12]
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
   17cf2:	f7fa f97f 	bl	11ff4 <HAL_SDRAM_Init>
   17cf6:	b108      	cbz	r0, 17cfc <MX_FMC_Init+0x58>
  {
    Error_Handler( );
   17cf8:	f001 fb8a 	bl	19410 <Error_Handler>
  }

  HAL_SetFMCMemorySwappingConfig(FMC_SWAPBMAP_SDRAM_SRAM);
   17cfc:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
   17d00:	f7f0 fb96 	bl	8430 <HAL_SetFMCMemorySwappingConfig>

}
   17d04:	b008      	add	sp, #32
   17d06:	bd70      	pop	{r4, r5, r6, pc}
   17d08:	020e3e60 	.word	0x020e3e60
   17d0c:	52004140 	.word	0x52004140

00017d10 <HAL_SDRAM_MspInit>:
static void HAL_FMC_MspInit(void){
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if (FMC_Initialized) {
   17d10:	4a2a      	ldr	r2, [pc, #168]	; (17dbc <HAL_SDRAM_MspInit+0xac>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   17d12:	2300      	movs	r3, #0
  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
   17d14:	b5f0      	push	{r4, r5, r6, r7, lr}
   17d16:	b087      	sub	sp, #28
  if (FMC_Initialized) {
   17d18:	6814      	ldr	r4, [r2, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   17d1a:	e9cd 3301 	strd	r3, r3, [sp, #4]
   17d1e:	e9cd 3303 	strd	r3, r3, [sp, #12]
   17d22:	9305      	str	r3, [sp, #20]
  if (FMC_Initialized) {
   17d24:	b10c      	cbz	r4, 17d2a <HAL_SDRAM_MspInit+0x1a>
  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
   17d26:	b007      	add	sp, #28
   17d28:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_RCC_FMC_CLK_ENABLE();
   17d2a:	4b25      	ldr	r3, [pc, #148]	; (17dc0 <HAL_SDRAM_MspInit+0xb0>)
  FMC_Initialized = 1;
   17d2c:	2101      	movs	r1, #1
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
   17d2e:	f64f 003f 	movw	r0, #63551	; 0xf83f
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17d32:	2702      	movs	r7, #2
  FMC_Initialized = 1;
   17d34:	6011      	str	r1, [r2, #0]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   17d36:	2603      	movs	r6, #3
  __HAL_RCC_FMC_CLK_ENABLE();
   17d38:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17d3c:	250c      	movs	r5, #12
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   17d3e:	a901      	add	r1, sp, #4
  __HAL_RCC_FMC_CLK_ENABLE();
   17d40:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   17d44:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
   17d48:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
   17d4c:	9001      	str	r0, [sp, #4]
  __HAL_RCC_FMC_CLK_ENABLE();
   17d4e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   17d52:	481c      	ldr	r0, [pc, #112]	; (17dc4 <HAL_SDRAM_MspInit+0xb4>)
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17d54:	9702      	str	r7, [sp, #8]
  __HAL_RCC_FMC_CLK_ENABLE();
   17d56:	9300      	str	r3, [sp, #0]
   17d58:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17d5a:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   17d5e:	f7f3 ff2f 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
   17d62:	230d      	movs	r3, #13
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   17d64:	a901      	add	r1, sp, #4
   17d66:	4818      	ldr	r0, [pc, #96]	; (17dc8 <HAL_SDRAM_MspInit+0xb8>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
   17d68:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17d6a:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   17d6c:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17d6e:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   17d72:	f7f3 ff25 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4 
   17d76:	f248 1337 	movw	r3, #33079	; 0x8137
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   17d7a:	a901      	add	r1, sp, #4
   17d7c:	4813      	ldr	r0, [pc, #76]	; (17dcc <HAL_SDRAM_MspInit+0xbc>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4 
   17d7e:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17d80:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   17d82:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17d84:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   17d88:	f7f3 ff1a 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
   17d8c:	f64f 7383 	movw	r3, #65411	; 0xff83
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   17d90:	a901      	add	r1, sp, #4
   17d92:	480f      	ldr	r0, [pc, #60]	; (17dd0 <HAL_SDRAM_MspInit+0xc0>)
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
   17d94:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17d96:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   17d98:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17d9a:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   17d9e:	f7f3 ff0f 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
   17da2:	f24c 7303 	movw	r3, #50947	; 0xc703
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   17da6:	a901      	add	r1, sp, #4
   17da8:	480a      	ldr	r0, [pc, #40]	; (17dd4 <HAL_SDRAM_MspInit+0xc4>)
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17daa:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   17dac:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
   17dae:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17db0:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   17db4:	f7f3 ff04 	bl	bbc0 <HAL_GPIO_Init>
}
   17db8:	b007      	add	sp, #28
   17dba:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17dbc:	020e2dcc 	.word	0x020e2dcc
   17dc0:	58024400 	.word	0x58024400
   17dc4:	58021400 	.word	0x58021400
   17dc8:	58020800 	.word	0x58020800
   17dcc:	58021800 	.word	0x58021800
   17dd0:	58021000 	.word	0x58021000
   17dd4:	58020c00 	.word	0x58020c00

00017dd8 <GFXdrawPixel.part.0>:
void GFXstartWrite(GFX* myGFX){
    // Overwrite in subclasses if desired!
}

// the most basic function, set a single pixel
void GFXdrawPixel(GFX* myGFX, int16_t x, int16_t y, uint16_t color) {
   17dd8:	b430      	push	{r4, r5}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
    return;

  // check rotation, move pixel around if necessary
  switch (GFXgetRotation(myGFX)) {
   17dda:	7a04      	ldrb	r4, [r0, #8]
   17ddc:	2c02      	cmp	r4, #2
   17dde:	d050      	beq.n	17e82 <GFXdrawPixel.part.0+0xaa>
   17de0:	2c03      	cmp	r4, #3
   17de2:	d048      	beq.n	17e76 <GFXdrawPixel.part.0+0x9e>
   17de4:	2c01      	cmp	r4, #1
   17de6:	d018      	beq.n	17e1a <GFXdrawPixel.part.0+0x42>
    y = myGFX->HEIGHT - y - 1;
    break;
  }

  // x is which column
    switch (color)
   17de8:	2b01      	cmp	r3, #1
   17dea:	d01e      	beq.n	17e2a <GFXdrawPixel.part.0+0x52>
   17dec:	d32f      	bcc.n	17e4e <GFXdrawPixel.part.0+0x76>
   17dee:	2b02      	cmp	r3, #2
   17df0:	d111      	bne.n	17e16 <GFXdrawPixel.part.0+0x3e>
    {
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
      case INVERSE: buffer[x+ (y/8)*myGFX->WIDTH] ^=  (1 << (y&7)); break;
   17df2:	2a00      	cmp	r2, #0
   17df4:	4613      	mov	r3, r2
   17df6:	8804      	ldrh	r4, [r0, #0]
   17df8:	f04f 0001 	mov.w	r0, #1
   17dfc:	bfb8      	it	lt
   17dfe:	1dd3      	addlt	r3, r2, #7
   17e00:	f002 0207 	and.w	r2, r2, #7
   17e04:	10db      	asrs	r3, r3, #3
   17e06:	fa00 f202 	lsl.w	r2, r0, r2
   17e0a:	fb13 1104 	smlabb	r1, r3, r4, r1
   17e0e:	4b21      	ldr	r3, [pc, #132]	; (17e94 <GFXdrawPixel.part.0+0xbc>)
   17e10:	5c58      	ldrb	r0, [r3, r1]
   17e12:	4042      	eors	r2, r0
   17e14:	545a      	strb	r2, [r3, r1]
    }

}
   17e16:	bc30      	pop	{r4, r5}
   17e18:	4770      	bx	lr
    x = myGFX->WIDTH - x - 1;
   17e1a:	43d4      	mvns	r4, r2
   17e1c:	8805      	ldrh	r5, [r0, #0]
    _swap_int16_t(x, y);
   17e1e:	460a      	mov	r2, r1
    switch (color)
   17e20:	2b01      	cmp	r3, #1
    x = myGFX->WIDTH - x - 1;
   17e22:	eb04 0105 	add.w	r1, r4, r5
   17e26:	b209      	sxth	r1, r1
    switch (color)
   17e28:	d1e0      	bne.n	17dec <GFXdrawPixel.part.0+0x14>
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
   17e2a:	2a00      	cmp	r2, #0
   17e2c:	4613      	mov	r3, r2
   17e2e:	8804      	ldrh	r4, [r0, #0]
   17e30:	f002 0007 	and.w	r0, r2, #7
   17e34:	bfb8      	it	lt
   17e36:	1dd3      	addlt	r3, r2, #7
   17e38:	2201      	movs	r2, #1
   17e3a:	10db      	asrs	r3, r3, #3
   17e3c:	4082      	lsls	r2, r0
   17e3e:	fb13 1104 	smlabb	r1, r3, r4, r1
   17e42:	4b14      	ldr	r3, [pc, #80]	; (17e94 <GFXdrawPixel.part.0+0xbc>)
   17e44:	5c58      	ldrb	r0, [r3, r1]
   17e46:	4302      	orrs	r2, r0
   17e48:	545a      	strb	r2, [r3, r1]
}
   17e4a:	bc30      	pop	{r4, r5}
   17e4c:	4770      	bx	lr
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
   17e4e:	2a00      	cmp	r2, #0
   17e50:	4613      	mov	r3, r2
   17e52:	8800      	ldrh	r0, [r0, #0]
   17e54:	f002 0407 	and.w	r4, r2, #7
   17e58:	bfb8      	it	lt
   17e5a:	1dd3      	addlt	r3, r2, #7
   17e5c:	2201      	movs	r2, #1
   17e5e:	10db      	asrs	r3, r3, #3
   17e60:	fb13 1100 	smlabb	r1, r3, r0, r1
   17e64:	480b      	ldr	r0, [pc, #44]	; (17e94 <GFXdrawPixel.part.0+0xbc>)
   17e66:	fa02 f304 	lsl.w	r3, r2, r4
   17e6a:	5c42      	ldrb	r2, [r0, r1]
   17e6c:	ea22 0203 	bic.w	r2, r2, r3
   17e70:	5442      	strb	r2, [r0, r1]
}
   17e72:	bc30      	pop	{r4, r5}
   17e74:	4770      	bx	lr
    y = myGFX->HEIGHT - y - 1;
   17e76:	43cc      	mvns	r4, r1
   17e78:	8845      	ldrh	r5, [r0, #2]
	_swap_int16_t(x, y);
   17e7a:	4611      	mov	r1, r2
    y = myGFX->HEIGHT - y - 1;
   17e7c:	1962      	adds	r2, r4, r5
   17e7e:	b212      	sxth	r2, r2
   17e80:	e7b2      	b.n	17de8 <GFXdrawPixel.part.0+0x10>
    x = myGFX->WIDTH - x - 1;
   17e82:	43c9      	mvns	r1, r1
    y = myGFX->HEIGHT - y - 1;
   17e84:	43d2      	mvns	r2, r2
    x = myGFX->WIDTH - x - 1;
   17e86:	8805      	ldrh	r5, [r0, #0]
    y = myGFX->HEIGHT - y - 1;
   17e88:	8844      	ldrh	r4, [r0, #2]
    x = myGFX->WIDTH - x - 1;
   17e8a:	4429      	add	r1, r5
    y = myGFX->HEIGHT - y - 1;
   17e8c:	4422      	add	r2, r4
    x = myGFX->WIDTH - x - 1;
   17e8e:	b209      	sxth	r1, r1
    y = myGFX->HEIGHT - y - 1;
   17e90:	b212      	sxth	r2, r2
   17e92:	e7a9      	b.n	17de8 <GFXdrawPixel.part.0+0x10>
   17e94:	020facfc 	.word	0x020facfc

00017e98 <GFXinit>:
	myGfx->WIDTH = w;
   17e98:	2300      	movs	r3, #0
	myGfx->_width    = w;
   17e9a:	8081      	strh	r1, [r0, #4]
	myGfx->_height   = h;
   17e9c:	80c2      	strh	r2, [r0, #6]
	myGfx->WIDTH = w;
   17e9e:	f361 030f 	bfi	r3, r1, #0, #16
	myGfx->rotation  = 0;
   17ea2:	2101      	movs	r1, #1
	myGfx->WIDTH = w;
   17ea4:	f362 431f 	bfi	r3, r2, #16, #16
	myGfx->fontHeight = 8;
   17ea8:	2208      	movs	r2, #8
	myGfx->rotation  = 0;
   17eaa:	6141      	str	r1, [r0, #20]
	myGfx->WIDTH = w;
   17eac:	6003      	str	r3, [r0, #0]
	myGfx->rotation  = 0;
   17eae:	2300      	movs	r3, #0
	myGfx->fontHeight = 8;
   17eb0:	61c2      	str	r2, [r0, #28]
	myGfx->rotation  = 0;
   17eb2:	6083      	str	r3, [r0, #8]
	myGfx->gfxFont   = NULL;
   17eb4:	6183      	str	r3, [r0, #24]
{
   17eb6:	b430      	push	{r4, r5}
	myGfx->rotation  = 0;
   17eb8:	f44f 3580 	mov.w	r5, #65536	; 0x10000
   17ebc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   17ec0:	e9c0 5403 	strd	r5, r4, [r0, #12]
}
   17ec4:	bc30      	pop	{r4, r5}
   17ec6:	4770      	bx	lr

00017ec8 <GFXwriteLine>:
        uint16_t color) {
   17ec8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17ecc:	b083      	sub	sp, #12
   17ece:	461e      	mov	r6, r3
   17ed0:	4617      	mov	r7, r2
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
   17ed2:	4694      	mov	ip, r2
        uint16_t color) {
   17ed4:	f9bd 5030 	ldrsh.w	r5, [sp, #48]	; 0x30
   17ed8:	4682      	mov	sl, r0
   17eda:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
   17ede:	1aab      	subs	r3, r5, r2
   17ee0:	1a72      	subs	r2, r6, r1
        uint16_t color) {
   17ee2:	9001      	str	r0, [sp, #4]
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
   17ee4:	2b00      	cmp	r3, #0
   17ee6:	bfb8      	it	lt
   17ee8:	425b      	neglt	r3, r3
   17eea:	2a00      	cmp	r2, #0
   17eec:	bfb8      	it	lt
   17eee:	4252      	neglt	r2, r2
    if (steep) {
   17ef0:	4293      	cmp	r3, r2
   17ef2:	dc7d      	bgt.n	17ff0 <GFXwriteLine+0x128>
   17ef4:	46ae      	mov	lr, r5
   17ef6:	462c      	mov	r4, r5
   17ef8:	46bb      	mov	fp, r7
   17efa:	4635      	mov	r5, r6
   17efc:	460f      	mov	r7, r1
   17efe:	4676      	mov	r6, lr
   17f00:	4661      	mov	r1, ip
   17f02:	4698      	mov	r8, r3
    if (x0 > x1) {
   17f04:	42af      	cmp	r7, r5
   17f06:	dd5f      	ble.n	17fc8 <GFXwriteLine+0x100>
    dx = x1 - x0;
   17f08:	eba7 0905 	sub.w	r9, r7, r5
   17f0c:	ebab 0004 	sub.w	r0, fp, r4
    if (y0 < y1) {
   17f10:	f64f 7bff 	movw	fp, #65535	; 0xffff
    dx = x1 - x0;
   17f14:	fa1f f989 	uxth.w	r9, r9
   17f18:	ea80 78e0 	eor.w	r8, r0, r0, asr #31
    int16_t err = dx / 2;
   17f1c:	fa0f f489 	sxth.w	r4, r9
   17f20:	eba8 78e0 	sub.w	r8, r8, r0, asr #31
   17f24:	2c00      	cmp	r4, #0
   17f26:	bfb8      	it	lt
   17f28:	3401      	addlt	r4, #1
    if (y0 < y1) {
   17f2a:	42b1      	cmp	r1, r6
   17f2c:	bfc8      	it	gt
   17f2e:	f04f 0b01 	movgt.w	fp, #1
    int16_t err = dx / 2;
   17f32:	1064      	asrs	r4, r4, #1
   17f34:	4293      	cmp	r3, r2
   17f36:	fa1f f888 	uxth.w	r8, r8
   17f3a:	dc3c      	bgt.n	17fb6 <GFXwriteLine+0xee>
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   17f3c:	2d00      	cmp	r5, #0
   17f3e:	db0f      	blt.n	17f60 <GFXwriteLine+0x98>
   17f40:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   17f44:	42ab      	cmp	r3, r5
   17f46:	dd0b      	ble.n	17f60 <GFXwriteLine+0x98>
   17f48:	0432      	lsls	r2, r6, #16
   17f4a:	d409      	bmi.n	17f60 <GFXwriteLine+0x98>
   17f4c:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   17f50:	4632      	mov	r2, r6
   17f52:	4629      	mov	r1, r5
   17f54:	9b01      	ldr	r3, [sp, #4]
   17f56:	42b0      	cmp	r0, r6
   17f58:	4650      	mov	r0, sl
   17f5a:	dd01      	ble.n	17f60 <GFXwriteLine+0x98>
   17f5c:	f7ff ff3c 	bl	17dd8 <GFXdrawPixel.part.0>
        err -= dy;
   17f60:	eba4 0408 	sub.w	r4, r4, r8
   17f64:	3501      	adds	r5, #1
   17f66:	b2a3      	uxth	r3, r4
   17f68:	b22d      	sxth	r5, r5
   17f6a:	b21c      	sxth	r4, r3
        if (err < 0) {
   17f6c:	2c00      	cmp	r4, #0
   17f6e:	da04      	bge.n	17f7a <GFXwriteLine+0xb2>
            y0 += ystep;
   17f70:	445e      	add	r6, fp
            err += dx;
   17f72:	eb09 0403 	add.w	r4, r9, r3
            y0 += ystep;
   17f76:	b236      	sxth	r6, r6
            err += dx;
   17f78:	b224      	sxth	r4, r4
    for (; x0<=x1; x0++) {
   17f7a:	42af      	cmp	r7, r5
   17f7c:	dade      	bge.n	17f3c <GFXwriteLine+0x74>
}
   17f7e:	b003      	add	sp, #12
   17f80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   17f84:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   17f88:	462a      	mov	r2, r5
   17f8a:	4631      	mov	r1, r6
   17f8c:	9b01      	ldr	r3, [sp, #4]
   17f8e:	4285      	cmp	r5, r0
   17f90:	4650      	mov	r0, sl
   17f92:	da01      	bge.n	17f98 <GFXwriteLine+0xd0>
   17f94:	f7ff ff20 	bl	17dd8 <GFXdrawPixel.part.0>
        err -= dy;
   17f98:	eba4 0408 	sub.w	r4, r4, r8
   17f9c:	3501      	adds	r5, #1
   17f9e:	b2a3      	uxth	r3, r4
   17fa0:	b22d      	sxth	r5, r5
   17fa2:	b21c      	sxth	r4, r3
        if (err < 0) {
   17fa4:	2c00      	cmp	r4, #0
   17fa6:	da04      	bge.n	17fb2 <GFXwriteLine+0xea>
            y0 += ystep;
   17fa8:	445e      	add	r6, fp
            err += dx;
   17faa:	eb03 0409 	add.w	r4, r3, r9
            y0 += ystep;
   17fae:	b236      	sxth	r6, r6
            err += dx;
   17fb0:	b224      	sxth	r4, r4
    for (; x0<=x1; x0++) {
   17fb2:	42af      	cmp	r7, r5
   17fb4:	dbe3      	blt.n	17f7e <GFXwriteLine+0xb6>
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   17fb6:	2e00      	cmp	r6, #0
   17fb8:	dbee      	blt.n	17f98 <GFXwriteLine+0xd0>
   17fba:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   17fbe:	429e      	cmp	r6, r3
   17fc0:	daea      	bge.n	17f98 <GFXwriteLine+0xd0>
   17fc2:	042b      	lsls	r3, r5, #16
   17fc4:	d4e8      	bmi.n	17f98 <GFXwriteLine+0xd0>
   17fc6:	e7dd      	b.n	17f84 <GFXwriteLine+0xbc>
    dx = x1 - x0;
   17fc8:	eba5 0907 	sub.w	r9, r5, r7
    if (y0 < y1) {
   17fcc:	4628      	mov	r0, r5
   17fce:	463d      	mov	r5, r7
    dx = x1 - x0;
   17fd0:	fa1f f989 	uxth.w	r9, r9
    int16_t err = dx / 2;
   17fd4:	fa0f f489 	sxth.w	r4, r9
   17fd8:	2c00      	cmp	r4, #0
   17fda:	bfb8      	it	lt
   17fdc:	3401      	addlt	r4, #1
    if (y0 < y1) {
   17fde:	42b1      	cmp	r1, r6
   17fe0:	460e      	mov	r6, r1
    int16_t err = dx / 2;
   17fe2:	ea4f 0464 	mov.w	r4, r4, asr #1
    if (y0 < y1) {
   17fe6:	da07      	bge.n	17ff8 <GFXwriteLine+0x130>
   17fe8:	f04f 0b01 	mov.w	fp, #1
   17fec:	4607      	mov	r7, r0
   17fee:	e7a1      	b.n	17f34 <GFXwriteLine+0x6c>
   17ff0:	4634      	mov	r4, r6
   17ff2:	468b      	mov	fp, r1
   17ff4:	4690      	mov	r8, r2
   17ff6:	e785      	b.n	17f04 <GFXwriteLine+0x3c>
   17ff8:	f64f 7bff 	movw	fp, #65535	; 0xffff
   17ffc:	4607      	mov	r7, r0
   17ffe:	e799      	b.n	17f34 <GFXwriteLine+0x6c>

00018000 <GFXdrawPixel>:
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   18000:	2900      	cmp	r1, #0
   18002:	db28      	blt.n	18056 <GFXdrawPixel+0x56>
void GFXdrawPixel(GFX* myGFX, int16_t x, int16_t y, uint16_t color) {
   18004:	b430      	push	{r4, r5}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   18006:	8884      	ldrh	r4, [r0, #4]
   18008:	42a1      	cmp	r1, r4
   1800a:	da22      	bge.n	18052 <GFXdrawPixel+0x52>
   1800c:	2a00      	cmp	r2, #0
   1800e:	db20      	blt.n	18052 <GFXdrawPixel+0x52>
   18010:	88c4      	ldrh	r4, [r0, #6]
   18012:	42a2      	cmp	r2, r4
   18014:	da1d      	bge.n	18052 <GFXdrawPixel+0x52>
  switch (GFXgetRotation(myGFX)) {
   18016:	7a04      	ldrb	r4, [r0, #8]
   18018:	2c02      	cmp	r4, #2
   1801a:	d04e      	beq.n	180ba <GFXdrawPixel+0xba>
   1801c:	2c03      	cmp	r4, #3
   1801e:	d046      	beq.n	180ae <GFXdrawPixel+0xae>
   18020:	2c01      	cmp	r4, #1
   18022:	d019      	beq.n	18058 <GFXdrawPixel+0x58>
    switch (color)
   18024:	2b01      	cmp	r3, #1
   18026:	d02f      	beq.n	18088 <GFXdrawPixel+0x88>
   18028:	d31c      	bcc.n	18064 <GFXdrawPixel+0x64>
   1802a:	2b02      	cmp	r3, #2
   1802c:	d111      	bne.n	18052 <GFXdrawPixel+0x52>
      case INVERSE: buffer[x+ (y/8)*myGFX->WIDTH] ^=  (1 << (y&7)); break;
   1802e:	2a00      	cmp	r2, #0
   18030:	4613      	mov	r3, r2
   18032:	8804      	ldrh	r4, [r0, #0]
   18034:	f04f 0001 	mov.w	r0, #1
   18038:	bfb8      	it	lt
   1803a:	1dd3      	addlt	r3, r2, #7
   1803c:	f002 0207 	and.w	r2, r2, #7
   18040:	10db      	asrs	r3, r3, #3
   18042:	fa00 f202 	lsl.w	r2, r0, r2
   18046:	fb13 1104 	smlabb	r1, r3, r4, r1
   1804a:	4b20      	ldr	r3, [pc, #128]	; (180cc <GFXdrawPixel+0xcc>)
   1804c:	5c58      	ldrb	r0, [r3, r1]
   1804e:	4042      	eors	r2, r0
   18050:	545a      	strb	r2, [r3, r1]
}
   18052:	bc30      	pop	{r4, r5}
   18054:	4770      	bx	lr
   18056:	4770      	bx	lr
    x = myGFX->WIDTH - x - 1;
   18058:	43d4      	mvns	r4, r2
   1805a:	8805      	ldrh	r5, [r0, #0]
   1805c:	460a      	mov	r2, r1
   1805e:	1961      	adds	r1, r4, r5
   18060:	b209      	sxth	r1, r1
   18062:	e7df      	b.n	18024 <GFXdrawPixel+0x24>
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
   18064:	2a00      	cmp	r2, #0
   18066:	4613      	mov	r3, r2
   18068:	8800      	ldrh	r0, [r0, #0]
   1806a:	f002 0407 	and.w	r4, r2, #7
   1806e:	bfb8      	it	lt
   18070:	1dd3      	addlt	r3, r2, #7
   18072:	2201      	movs	r2, #1
   18074:	10db      	asrs	r3, r3, #3
   18076:	40a2      	lsls	r2, r4
   18078:	fb13 1100 	smlabb	r1, r3, r0, r1
   1807c:	4813      	ldr	r0, [pc, #76]	; (180cc <GFXdrawPixel+0xcc>)
   1807e:	5c43      	ldrb	r3, [r0, r1]
   18080:	ea23 0302 	bic.w	r3, r3, r2
   18084:	5443      	strb	r3, [r0, r1]
   18086:	e7e4      	b.n	18052 <GFXdrawPixel+0x52>
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
   18088:	2a00      	cmp	r2, #0
   1808a:	4613      	mov	r3, r2
   1808c:	8804      	ldrh	r4, [r0, #0]
   1808e:	f04f 0001 	mov.w	r0, #1
   18092:	bfb8      	it	lt
   18094:	1dd3      	addlt	r3, r2, #7
   18096:	f002 0207 	and.w	r2, r2, #7
   1809a:	10db      	asrs	r3, r3, #3
   1809c:	fb13 1104 	smlabb	r1, r3, r4, r1
   180a0:	4c0a      	ldr	r4, [pc, #40]	; (180cc <GFXdrawPixel+0xcc>)
   180a2:	fa00 f302 	lsl.w	r3, r0, r2
   180a6:	5c62      	ldrb	r2, [r4, r1]
   180a8:	4313      	orrs	r3, r2
   180aa:	5463      	strb	r3, [r4, r1]
   180ac:	e7d1      	b.n	18052 <GFXdrawPixel+0x52>
    y = myGFX->HEIGHT - y - 1;
   180ae:	8844      	ldrh	r4, [r0, #2]
   180b0:	3c01      	subs	r4, #1
   180b2:	1a64      	subs	r4, r4, r1
   180b4:	4611      	mov	r1, r2
   180b6:	b222      	sxth	r2, r4
   180b8:	e7b4      	b.n	18024 <GFXdrawPixel+0x24>
    x = myGFX->WIDTH - x - 1;
   180ba:	8804      	ldrh	r4, [r0, #0]
    y = myGFX->HEIGHT - y - 1;
   180bc:	43d2      	mvns	r2, r2
   180be:	8845      	ldrh	r5, [r0, #2]
    x = myGFX->WIDTH - x - 1;
   180c0:	3c01      	subs	r4, #1
    y = myGFX->HEIGHT - y - 1;
   180c2:	442a      	add	r2, r5
    x = myGFX->WIDTH - x - 1;
   180c4:	1a61      	subs	r1, r4, r1
    y = myGFX->HEIGHT - y - 1;
   180c6:	b212      	sxth	r2, r2
    x = myGFX->WIDTH - x - 1;
   180c8:	b209      	sxth	r1, r1
   180ca:	e7ab      	b.n	18024 <GFXdrawPixel+0x24>
   180cc:	020facfc 	.word	0x020facfc

000180d0 <GFXfillRect>:
   180d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   180d4:	440b      	add	r3, r1
   180d6:	b089      	sub	sp, #36	; 0x24
   180d8:	428b      	cmp	r3, r1
   180da:	f8bd 504c 	ldrh.w	r5, [sp, #76]	; 0x4c
   180de:	f9bd 4048 	ldrsh.w	r4, [sp, #72]	; 0x48
   180e2:	9502      	str	r5, [sp, #8]
   180e4:	f340 80b5 	ble.w	18252 <GFXfillRect+0x182>
   180e8:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
   180ec:	4494      	add	ip, r2
   180ee:	fa0f fc8c 	sxth.w	ip, ip
   180f2:	4562      	cmp	r2, ip
   180f4:	bfcb      	itete	gt
   180f6:	4615      	movgt	r5, r2
   180f8:	4665      	movle	r5, ip
   180fa:	4664      	movgt	r4, ip
   180fc:	4614      	movle	r4, r2
   180fe:	9504      	str	r5, [sp, #16]
   18100:	9403      	str	r4, [sp, #12]
   18102:	1b2c      	subs	r4, r5, r4
   18104:	b2a4      	uxth	r4, r4
   18106:	b225      	sxth	r5, r4
   18108:	9407      	str	r4, [sp, #28]
   1810a:	ebac 0402 	sub.w	r4, ip, r2
   1810e:	2d00      	cmp	r5, #0
   18110:	bfb8      	it	lt
   18112:	3501      	addlt	r5, #1
   18114:	2c00      	cmp	r4, #0
   18116:	ea4f 0565 	mov.w	r5, r5, asr #1
   1811a:	bfb8      	it	lt
   1811c:	4264      	neglt	r4, r4
   1811e:	9506      	str	r5, [sp, #24]
   18120:	9405      	str	r4, [sp, #20]
   18122:	4562      	cmp	r2, ip
   18124:	f040 8098 	bne.w	18258 <GFXfillRect+0x188>
   18128:	2600      	movs	r6, #0
   1812a:	460c      	mov	r4, r1
   1812c:	4688      	mov	r8, r1
   1812e:	f8dd e014 	ldr.w	lr, [sp, #20]
   18132:	46b2      	mov	sl, r6
   18134:	4617      	mov	r7, r2
   18136:	fa1f fe8e 	uxth.w	lr, lr
   1813a:	9301      	str	r3, [sp, #4]
   1813c:	e046      	b.n	181cc <GFXfillRect+0xfc>
   1813e:	2f00      	cmp	r7, #0
   18140:	db35      	blt.n	181ae <GFXfillRect+0xde>
   18142:	f8b0 9004 	ldrh.w	r9, [r0, #4]
   18146:	454f      	cmp	r7, r9
   18148:	da31      	bge.n	181ae <GFXfillRect+0xde>
   1814a:	0beb      	lsrs	r3, r5, #15
   1814c:	d12f      	bne.n	181ae <GFXfillRect+0xde>
   1814e:	f8b0 9006 	ldrh.w	r9, [r0, #6]
   18152:	454c      	cmp	r4, r9
   18154:	da2b      	bge.n	181ae <GFXfillRect+0xde>
   18156:	f890 9008 	ldrb.w	r9, [r0, #8]
   1815a:	f1b9 0f02 	cmp.w	r9, #2
   1815e:	f000 80df 	beq.w	18320 <GFXfillRect+0x250>
   18162:	f1b9 0f03 	cmp.w	r9, #3
   18166:	f000 80d3 	beq.w	18310 <GFXfillRect+0x240>
   1816a:	f1b9 0f01 	cmp.w	r9, #1
   1816e:	f000 80c5 	beq.w	182fc <GFXfillRect+0x22c>
   18172:	46b9      	mov	r9, r7
   18174:	9b02      	ldr	r3, [sp, #8]
   18176:	2b01      	cmp	r3, #1
   18178:	f000 80a9 	beq.w	182ce <GFXfillRect+0x1fe>
   1817c:	d378      	bcc.n	18270 <GFXfillRect+0x1a0>
   1817e:	2b02      	cmp	r3, #2
   18180:	d115      	bne.n	181ae <GFXfillRect+0xde>
   18182:	2c00      	cmp	r4, #0
   18184:	46a3      	mov	fp, r4
   18186:	8803      	ldrh	r3, [r0, #0]
   18188:	bfb8      	it	lt
   1818a:	f104 0b07 	addlt.w	fp, r4, #7
   1818e:	f004 0407 	and.w	r4, r4, #7
   18192:	ea4f 0beb 	mov.w	fp, fp, asr #3
   18196:	fb1b 9903 	smlabb	r9, fp, r3, r9
   1819a:	2301      	movs	r3, #1
   1819c:	fa03 f404 	lsl.w	r4, r3, r4
   181a0:	4b81      	ldr	r3, [pc, #516]	; (183a8 <GFXfillRect+0x2d8>)
   181a2:	f813 b009 	ldrb.w	fp, [r3, r9]
   181a6:	ea84 040b 	eor.w	r4, r4, fp
   181aa:	f803 4009 	strb.w	r4, [r3, r9]
   181ae:	eba6 060e 	sub.w	r6, r6, lr
   181b2:	b2b4      	uxth	r4, r6
   181b4:	b226      	sxth	r6, r4
   181b6:	2e00      	cmp	r6, #0
   181b8:	da04      	bge.n	181c4 <GFXfillRect+0xf4>
   181ba:	3f01      	subs	r7, #1
   181bc:	eb04 060a 	add.w	r6, r4, sl
   181c0:	b23f      	sxth	r7, r7
   181c2:	b236      	sxth	r6, r6
   181c4:	1c6c      	adds	r4, r5, #1
   181c6:	b224      	sxth	r4, r4
   181c8:	4544      	cmp	r4, r8
   181ca:	dc3c      	bgt.n	18246 <GFXfillRect+0x176>
   181cc:	4562      	cmp	r2, ip
   181ce:	b2a5      	uxth	r5, r4
   181d0:	d1b5      	bne.n	1813e <GFXfillRect+0x6e>
   181d2:	2c00      	cmp	r4, #0
   181d4:	dbeb      	blt.n	181ae <GFXfillRect+0xde>
   181d6:	f8b0 9004 	ldrh.w	r9, [r0, #4]
   181da:	454c      	cmp	r4, r9
   181dc:	dae7      	bge.n	181ae <GFXfillRect+0xde>
   181de:	043b      	lsls	r3, r7, #16
   181e0:	d4e5      	bmi.n	181ae <GFXfillRect+0xde>
   181e2:	f8b0 9006 	ldrh.w	r9, [r0, #6]
   181e6:	454f      	cmp	r7, r9
   181e8:	dae1      	bge.n	181ae <GFXfillRect+0xde>
   181ea:	f890 9008 	ldrb.w	r9, [r0, #8]
   181ee:	f1b9 0f02 	cmp.w	r9, #2
   181f2:	f000 80cc 	beq.w	1838e <GFXfillRect+0x2be>
   181f6:	f1b9 0f03 	cmp.w	r9, #3
   181fa:	f000 80be 	beq.w	1837a <GFXfillRect+0x2aa>
   181fe:	f1b9 0f01 	cmp.w	r9, #1
   18202:	f000 80b2 	beq.w	1836a <GFXfillRect+0x29a>
   18206:	46b9      	mov	r9, r7
   18208:	9b02      	ldr	r3, [sp, #8]
   1820a:	2b01      	cmp	r3, #1
   1820c:	f000 8095 	beq.w	1833a <GFXfillRect+0x26a>
   18210:	d345      	bcc.n	1829e <GFXfillRect+0x1ce>
   18212:	2b02      	cmp	r3, #2
   18214:	d1cb      	bne.n	181ae <GFXfillRect+0xde>
   18216:	f1b9 0f00 	cmp.w	r9, #0
   1821a:	46cb      	mov	fp, r9
   1821c:	8803      	ldrh	r3, [r0, #0]
   1821e:	bfb8      	it	lt
   18220:	f109 0b07 	addlt.w	fp, r9, #7
   18224:	f009 0907 	and.w	r9, r9, #7
   18228:	ea4f 0beb 	mov.w	fp, fp, asr #3
   1822c:	fb1b 4b03 	smlabb	fp, fp, r3, r4
   18230:	2301      	movs	r3, #1
   18232:	fa03 f909 	lsl.w	r9, r3, r9
   18236:	4b5c      	ldr	r3, [pc, #368]	; (183a8 <GFXfillRect+0x2d8>)
   18238:	f813 400b 	ldrb.w	r4, [r3, fp]
   1823c:	ea89 0404 	eor.w	r4, r9, r4
   18240:	f803 400b 	strb.w	r4, [r3, fp]
   18244:	e7b3      	b.n	181ae <GFXfillRect+0xde>
   18246:	9b01      	ldr	r3, [sp, #4]
   18248:	3101      	adds	r1, #1
   1824a:	b209      	sxth	r1, r1
   1824c:	4299      	cmp	r1, r3
   1824e:	f6ff af68 	blt.w	18122 <GFXfillRect+0x52>
   18252:	b009      	add	sp, #36	; 0x24
   18254:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18258:	9c03      	ldr	r4, [sp, #12]
   1825a:	9e04      	ldr	r6, [sp, #16]
   1825c:	42b4      	cmp	r4, r6
   1825e:	dcf3      	bgt.n	18248 <GFXfillRect+0x178>
   18260:	46b0      	mov	r8, r6
   18262:	460f      	mov	r7, r1
   18264:	9e06      	ldr	r6, [sp, #24]
   18266:	f04f 0e00 	mov.w	lr, #0
   1826a:	f8dd a01c 	ldr.w	sl, [sp, #28]
   1826e:	e762      	b.n	18136 <GFXfillRect+0x66>
   18270:	2c00      	cmp	r4, #0
   18272:	46a3      	mov	fp, r4
   18274:	8803      	ldrh	r3, [r0, #0]
   18276:	bfb8      	it	lt
   18278:	f104 0b07 	addlt.w	fp, r4, #7
   1827c:	f004 0407 	and.w	r4, r4, #7
   18280:	ea4f 0beb 	mov.w	fp, fp, asr #3
   18284:	fb1b 9903 	smlabb	r9, fp, r3, r9
   18288:	2301      	movs	r3, #1
   1828a:	fa03 f404 	lsl.w	r4, r3, r4
   1828e:	4b46      	ldr	r3, [pc, #280]	; (183a8 <GFXfillRect+0x2d8>)
   18290:	f813 b009 	ldrb.w	fp, [r3, r9]
   18294:	ea2b 0404 	bic.w	r4, fp, r4
   18298:	f803 4009 	strb.w	r4, [r3, r9]
   1829c:	e787      	b.n	181ae <GFXfillRect+0xde>
   1829e:	f1b9 0f00 	cmp.w	r9, #0
   182a2:	46cb      	mov	fp, r9
   182a4:	8803      	ldrh	r3, [r0, #0]
   182a6:	bfb8      	it	lt
   182a8:	f109 0b07 	addlt.w	fp, r9, #7
   182ac:	f009 0907 	and.w	r9, r9, #7
   182b0:	ea4f 0beb 	mov.w	fp, fp, asr #3
   182b4:	fb1b 4b03 	smlabb	fp, fp, r3, r4
   182b8:	2301      	movs	r3, #1
   182ba:	fa03 f909 	lsl.w	r9, r3, r9
   182be:	4b3a      	ldr	r3, [pc, #232]	; (183a8 <GFXfillRect+0x2d8>)
   182c0:	f813 400b 	ldrb.w	r4, [r3, fp]
   182c4:	ea24 0409 	bic.w	r4, r4, r9
   182c8:	f803 400b 	strb.w	r4, [r3, fp]
   182cc:	e76f      	b.n	181ae <GFXfillRect+0xde>
   182ce:	2c00      	cmp	r4, #0
   182d0:	46a3      	mov	fp, r4
   182d2:	8803      	ldrh	r3, [r0, #0]
   182d4:	bfb8      	it	lt
   182d6:	f104 0b07 	addlt.w	fp, r4, #7
   182da:	f004 0407 	and.w	r4, r4, #7
   182de:	ea4f 0beb 	mov.w	fp, fp, asr #3
   182e2:	fb1b 9903 	smlabb	r9, fp, r3, r9
   182e6:	2301      	movs	r3, #1
   182e8:	fa03 f404 	lsl.w	r4, r3, r4
   182ec:	4b2e      	ldr	r3, [pc, #184]	; (183a8 <GFXfillRect+0x2d8>)
   182ee:	f813 b009 	ldrb.w	fp, [r3, r9]
   182f2:	ea44 040b 	orr.w	r4, r4, fp
   182f6:	f803 4009 	strb.w	r4, [r3, r9]
   182fa:	e758      	b.n	181ae <GFXfillRect+0xde>
   182fc:	f8b0 9000 	ldrh.w	r9, [r0]
   18300:	463c      	mov	r4, r7
   18302:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   18306:	eba9 0905 	sub.w	r9, r9, r5
   1830a:	fa0f f989 	sxth.w	r9, r9
   1830e:	e731      	b.n	18174 <GFXfillRect+0xa4>
   18310:	f8b0 b002 	ldrh.w	fp, [r0, #2]
   18314:	46a1      	mov	r9, r4
   18316:	f10b 34ff 	add.w	r4, fp, #4294967295	; 0xffffffff
   1831a:	1be4      	subs	r4, r4, r7
   1831c:	b224      	sxth	r4, r4
   1831e:	e729      	b.n	18174 <GFXfillRect+0xa4>
   18320:	f8b0 9000 	ldrh.w	r9, [r0]
   18324:	8844      	ldrh	r4, [r0, #2]
   18326:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   1832a:	3c01      	subs	r4, #1
   1832c:	eba9 0907 	sub.w	r9, r9, r7
   18330:	1b64      	subs	r4, r4, r5
   18332:	fa0f f989 	sxth.w	r9, r9
   18336:	b224      	sxth	r4, r4
   18338:	e71c      	b.n	18174 <GFXfillRect+0xa4>
   1833a:	f1b9 0f00 	cmp.w	r9, #0
   1833e:	46cb      	mov	fp, r9
   18340:	8803      	ldrh	r3, [r0, #0]
   18342:	bfb8      	it	lt
   18344:	f109 0b07 	addlt.w	fp, r9, #7
   18348:	f009 0907 	and.w	r9, r9, #7
   1834c:	ea4f 0beb 	mov.w	fp, fp, asr #3
   18350:	fb1b 4b03 	smlabb	fp, fp, r3, r4
   18354:	2301      	movs	r3, #1
   18356:	fa03 f909 	lsl.w	r9, r3, r9
   1835a:	4b13      	ldr	r3, [pc, #76]	; (183a8 <GFXfillRect+0x2d8>)
   1835c:	f813 400b 	ldrb.w	r4, [r3, fp]
   18360:	ea49 0404 	orr.w	r4, r9, r4
   18364:	f803 400b 	strb.w	r4, [r3, fp]
   18368:	e721      	b.n	181ae <GFXfillRect+0xde>
   1836a:	f8b0 b000 	ldrh.w	fp, [r0]
   1836e:	46a1      	mov	r9, r4
   18370:	f10b 34ff 	add.w	r4, fp, #4294967295	; 0xffffffff
   18374:	1be4      	subs	r4, r4, r7
   18376:	b224      	sxth	r4, r4
   18378:	e746      	b.n	18208 <GFXfillRect+0x138>
   1837a:	f8b0 9002 	ldrh.w	r9, [r0, #2]
   1837e:	463c      	mov	r4, r7
   18380:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   18384:	eba9 0905 	sub.w	r9, r9, r5
   18388:	fa0f f989 	sxth.w	r9, r9
   1838c:	e73c      	b.n	18208 <GFXfillRect+0x138>
   1838e:	8804      	ldrh	r4, [r0, #0]
   18390:	f8b0 9002 	ldrh.w	r9, [r0, #2]
   18394:	3c01      	subs	r4, #1
   18396:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   1839a:	1b64      	subs	r4, r4, r5
   1839c:	eba9 0907 	sub.w	r9, r9, r7
   183a0:	b224      	sxth	r4, r4
   183a2:	fa0f f989 	sxth.w	r9, r9
   183a6:	e72f      	b.n	18208 <GFXfillRect+0x138>
   183a8:	020facfc 	.word	0x020facfc

000183ac <GFXdrawChar>:

// TEXT- AND CHARACTER-HANDLING FUNCTIONS ----------------------------------

// Draw a character
void GFXdrawChar(GFX* myGFX, int16_t x, int16_t y, unsigned char c,
  uint16_t color, uint16_t bg, uint8_t size) {
   183ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   183b0:	b09b      	sub	sp, #108	; 0x6c
   183b2:	4682      	mov	sl, r0

    if(!myGFX->gfxFont) { // 'Classic' built-in font
   183b4:	6980      	ldr	r0, [r0, #24]
  uint16_t color, uint16_t bg, uint8_t size) {
   183b6:	9204      	str	r2, [sp, #16]
   183b8:	f8bd 2090 	ldrh.w	r2, [sp, #144]	; 0x90
   183bc:	920b      	str	r2, [sp, #44]	; 0x2c
   183be:	f8bd 2094 	ldrh.w	r2, [sp, #148]	; 0x94
   183c2:	9202      	str	r2, [sp, #8]
   183c4:	f89d 2098 	ldrb.w	r2, [sp, #152]	; 0x98
   183c8:	920d      	str	r2, [sp, #52]	; 0x34
    if(!myGFX->gfxFont) { // 'Classic' built-in font
   183ca:	2800      	cmp	r0, #0
   183cc:	f000 811e 	beq.w	1860c <GFXdrawChar+0x260>

        // Character is assumed previously filtered by write() to eliminate
        // newlines, returns, non-printable characters, etc.  Calling
        // drawChar() directly with 'bad' characters of font may cause mayhem!

        c -= (uint8_t)pgm_read_byte(&myGFX->gfxFont->first);
   183d0:	7a04      	ldrb	r4, [r0, #8]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
   183d2:	6842      	ldr	r2, [r0, #4]
        c -= (uint8_t)pgm_read_byte(&myGFX->gfxFont->first);
   183d4:	1b1b      	subs	r3, r3, r4
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&myGFX->gfxFont->bitmap);
   183d6:	6800      	ldr	r0, [r0, #0]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
   183d8:	b2db      	uxtb	r3, r3
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&myGFX->gfxFont->bitmap);
   183da:	9010      	str	r0, [sp, #64]	; 0x40
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
   183dc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3

        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
   183e0:	881a      	ldrh	r2, [r3, #0]
        uint8_t  w  = pgm_read_byte(&glyph->width),
                 h  = pgm_read_byte(&glyph->height);
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
                 yo = pgm_read_byte(&glyph->yOffset);
   183e2:	f993 0006 	ldrsb.w	r0, [r3, #6]
        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
   183e6:	920c      	str	r2, [sp, #48]	; 0x30
        uint8_t  w  = pgm_read_byte(&glyph->width),
   183e8:	789a      	ldrb	r2, [r3, #2]
                 yo = pgm_read_byte(&glyph->yOffset);
   183ea:	9019      	str	r0, [sp, #100]	; 0x64
        uint8_t  w  = pgm_read_byte(&glyph->width),
   183ec:	9209      	str	r2, [sp, #36]	; 0x24
                 h  = pgm_read_byte(&glyph->height);
   183ee:	78da      	ldrb	r2, [r3, #3]
   183f0:	9214      	str	r2, [sp, #80]	; 0x50
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
   183f2:	f993 2005 	ldrsb.w	r2, [r3, #5]
        uint8_t  xx, yy, bits = 0, bit = 0;
        int16_t  xo16 = 0, yo16 = 0;

        if(size > 1) {
   183f6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   183f8:	2b01      	cmp	r3, #1
   183fa:	f240 80a7 	bls.w	1854c <GFXdrawChar+0x1a0>
            xo16 = xo;
            yo16 = yo;
   183fe:	b200      	sxth	r0, r0
            xo16 = xo;
   18400:	b213      	sxth	r3, r2
            yo16 = yo;
   18402:	9015      	str	r0, [sp, #84]	; 0x54
        // this (a canvas object type for MCUs that can afford the RAM and
        // displays supporting setAddrWindow() and pushColors()), but haven't
        // implemented this yet.

        //startWrite();
        for(yy=0; yy<h; yy++) {
   18404:	9814      	ldr	r0, [sp, #80]	; 0x50
   18406:	2800      	cmp	r0, #0
   18408:	f000 80a6 	beq.w	18558 <GFXdrawChar+0x1ac>
   1840c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1840e:	2800      	cmp	r0, #0
   18410:	f000 80a2 	beq.w	18558 <GFXdrawChar+0x1ac>
                }
                if(bits & 0x80) {
                    if(size == 1) {
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
                    } else {
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   18414:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
   18418:	b289      	uxth	r1, r1
        uint8_t  xx, yy, bits = 0, bit = 0;
   1841a:	2000      	movs	r0, #0
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   1841c:	188a      	adds	r2, r1, r2
   1841e:	fb03 1104 	mla	r1, r3, r4, r1
   18422:	1e63      	subs	r3, r4, #1
        uint8_t  xx, yy, bits = 0, bit = 0;
   18424:	9007      	str	r0, [sp, #28]
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   18426:	9218      	str	r2, [sp, #96]	; 0x60
   18428:	9317      	str	r3, [sp, #92]	; 0x5c
   1842a:	b28b      	uxth	r3, r1
   1842c:	f8bd 2010 	ldrh.w	r2, [sp, #16]
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   18430:	940a      	str	r4, [sp, #40]	; 0x28
   18432:	9213      	str	r2, [sp, #76]	; 0x4c
        uint8_t  xx, yy, bits = 0, bit = 0;
   18434:	9002      	str	r0, [sp, #8]
        for(yy=0; yy<h; yy++) {
   18436:	900f      	str	r0, [sp, #60]	; 0x3c
   18438:	9316      	str	r3, [sp, #88]	; 0x58
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   1843a:	9a15      	ldr	r2, [sp, #84]	; 0x54
    int16_t err = dx / 2;
   1843c:	2700      	movs	r7, #0
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   1843e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   18440:	9913      	ldr	r1, [sp, #76]	; 0x4c
   18442:	4413      	add	r3, r2
   18444:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   18446:	fb03 1302 	mla	r3, r3, r2, r1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1844a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   1844c:	b29b      	uxth	r3, r3
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1844e:	189a      	adds	r2, r3, r2
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   18450:	b21b      	sxth	r3, r3
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   18452:	b211      	sxth	r1, r2
   18454:	461a      	mov	r2, r3
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   18456:	9311      	str	r3, [sp, #68]	; 0x44
   18458:	428b      	cmp	r3, r1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1845a:	9104      	str	r1, [sp, #16]
   1845c:	bfa8      	it	ge
   1845e:	460a      	movge	r2, r1
   18460:	428b      	cmp	r3, r1
   18462:	bfb8      	it	lt
   18464:	460b      	movlt	r3, r1
   18466:	9208      	str	r2, [sp, #32]
   18468:	9911      	ldr	r1, [sp, #68]	; 0x44
   1846a:	4699      	mov	r9, r3
    dx = x1 - x0;
   1846c:	1a9b      	subs	r3, r3, r2
   1846e:	9a04      	ldr	r2, [sp, #16]
   18470:	b29b      	uxth	r3, r3
   18472:	eba2 0801 	sub.w	r8, r2, r1
   18476:	9306      	str	r3, [sp, #24]
    int16_t err = dx / 2;
   18478:	b21b      	sxth	r3, r3
   1847a:	2b00      	cmp	r3, #0
   1847c:	bfb8      	it	lt
   1847e:	3301      	addlt	r3, #1
   18480:	f1b8 0f00 	cmp.w	r8, #0
   18484:	ea4f 0363 	mov.w	r3, r3, asr #1
   18488:	bfb8      	it	lt
   1848a:	f1c8 0800 	rsblt	r8, r8, #0
   1848e:	930e      	str	r3, [sp, #56]	; 0x38
   18490:	fa1f f888 	uxth.w	r8, r8
   18494:	9b16      	ldr	r3, [sp, #88]	; 0x58
   18496:	9303      	str	r3, [sp, #12]
   18498:	e00e      	b.n	184b8 <GFXdrawChar+0x10c>
                          size, size, color);
                    }
                }
                bits <<= 1;
   1849a:	9b02      	ldr	r3, [sp, #8]
   1849c:	3701      	adds	r7, #1
   1849e:	9a03      	ldr	r2, [sp, #12]
   184a0:	990a      	ldr	r1, [sp, #40]	; 0x28
   184a2:	005b      	lsls	r3, r3, #1
   184a4:	b2bf      	uxth	r7, r7
   184a6:	440a      	add	r2, r1
   184a8:	b2db      	uxtb	r3, r3
   184aa:	b292      	uxth	r2, r2
   184ac:	9302      	str	r3, [sp, #8]
            for(xx=0; xx<w; xx++) {
   184ae:	b2fb      	uxtb	r3, r7
   184b0:	9203      	str	r2, [sp, #12]
   184b2:	9a09      	ldr	r2, [sp, #36]	; 0x24
   184b4:	429a      	cmp	r2, r3
   184b6:	d97b      	bls.n	185b0 <GFXdrawChar+0x204>
                if(!(bit++ & 7)) {
   184b8:	9b07      	ldr	r3, [sp, #28]
   184ba:	443b      	add	r3, r7
   184bc:	0759      	lsls	r1, r3, #29
   184be:	d106      	bne.n	184ce <GFXdrawChar+0x122>
                    bits = pgm_read_byte(&bitmap[bo++]);
   184c0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   184c2:	9910      	ldr	r1, [sp, #64]	; 0x40
   184c4:	1c53      	adds	r3, r2, #1
   184c6:	5c8a      	ldrb	r2, [r1, r2]
   184c8:	b29b      	uxth	r3, r3
   184ca:	9202      	str	r2, [sp, #8]
   184cc:	930c      	str	r3, [sp, #48]	; 0x30
                if(bits & 0x80) {
   184ce:	9b02      	ldr	r3, [sp, #8]
   184d0:	061a      	lsls	r2, r3, #24
   184d2:	d5e2      	bpl.n	1849a <GFXdrawChar+0xee>
                    if(size == 1) {
   184d4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   184d6:	2b01      	cmp	r3, #1
   184d8:	d07a      	beq.n	185d0 <GFXdrawChar+0x224>
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   184da:	f9bd 600c 	ldrsh.w	r6, [sp, #12]
    for (int16_t i=x; i<x+w; i++) {
   184de:	4433      	add	r3, r6
   184e0:	42b3      	cmp	r3, r6
   184e2:	9305      	str	r3, [sp, #20]
   184e4:	ddd9      	ble.n	1849a <GFXdrawChar+0xee>
   184e6:	9712      	str	r7, [sp, #72]	; 0x48
   184e8:	9f11      	ldr	r7, [sp, #68]	; 0x44
    if (steep) {
   184ea:	9b04      	ldr	r3, [sp, #16]
   184ec:	429f      	cmp	r7, r3
   184ee:	d036      	beq.n	1855e <GFXdrawChar+0x1b2>
    for (; x0<=x1; x0++) {
   184f0:	9b08      	ldr	r3, [sp, #32]
   184f2:	454b      	cmp	r3, r9
   184f4:	dc23      	bgt.n	1853e <GFXdrawChar+0x192>
   184f6:	461c      	mov	r4, r3
   184f8:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   184fa:	46b3      	mov	fp, r6
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   184fc:	f1bb 0f00 	cmp.w	fp, #0
   18500:	db0f      	blt.n	18522 <GFXdrawChar+0x176>
   18502:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   18506:	459b      	cmp	fp, r3
   18508:	da0b      	bge.n	18522 <GFXdrawChar+0x176>
   1850a:	0423      	lsls	r3, r4, #16
   1850c:	d409      	bmi.n	18522 <GFXdrawChar+0x176>
   1850e:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   18512:	4622      	mov	r2, r4
   18514:	4659      	mov	r1, fp
   18516:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18518:	4284      	cmp	r4, r0
   1851a:	4650      	mov	r0, sl
   1851c:	da01      	bge.n	18522 <GFXdrawChar+0x176>
   1851e:	f7ff fc5b 	bl	17dd8 <GFXdrawPixel.part.0>
   18522:	3401      	adds	r4, #1
        if (err < 0) {
   18524:	2d00      	cmp	r5, #0
        err -= dy;
   18526:	b2ab      	uxth	r3, r5
   18528:	b224      	sxth	r4, r4
        if (err < 0) {
   1852a:	da06      	bge.n	1853a <GFXdrawChar+0x18e>
            err += dx;
   1852c:	9a06      	ldr	r2, [sp, #24]
            y0 += ystep;
   1852e:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
            err += dx;
   18532:	18d5      	adds	r5, r2, r3
            y0 += ystep;
   18534:	fa0f fb8b 	sxth.w	fp, fp
            err += dx;
   18538:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
   1853a:	45a1      	cmp	r9, r4
   1853c:	dade      	bge.n	184fc <GFXdrawChar+0x150>
   1853e:	3601      	adds	r6, #1
    for (int16_t i=x; i<x+w; i++) {
   18540:	9b05      	ldr	r3, [sp, #20]
   18542:	b236      	sxth	r6, r6
   18544:	429e      	cmp	r6, r3
   18546:	dbd0      	blt.n	184ea <GFXdrawChar+0x13e>
   18548:	9f12      	ldr	r7, [sp, #72]	; 0x48
   1854a:	e7a6      	b.n	1849a <GFXdrawChar+0xee>
        int16_t  xo16 = 0, yo16 = 0;
   1854c:	2300      	movs	r3, #0
        for(yy=0; yy<h; yy++) {
   1854e:	9814      	ldr	r0, [sp, #80]	; 0x50
        int16_t  xo16 = 0, yo16 = 0;
   18550:	9315      	str	r3, [sp, #84]	; 0x54
        for(yy=0; yy<h; yy++) {
   18552:	2800      	cmp	r0, #0
   18554:	f47f af5a 	bne.w	1840c <GFXdrawChar+0x60>
            }
        }
        //endWrite();

    } // End classic vs custom font
}
   18558:	b01b      	add	sp, #108	; 0x6c
   1855a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (steep) {
   1855e:	4634      	mov	r4, r6
   18560:	46bb      	mov	fp, r7
    int16_t err = dx / 2;
   18562:	2500      	movs	r5, #0
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   18564:	2c00      	cmp	r4, #0
   18566:	db10      	blt.n	1858a <GFXdrawChar+0x1de>
   18568:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   1856c:	42a3      	cmp	r3, r4
   1856e:	dd0c      	ble.n	1858a <GFXdrawChar+0x1de>
   18570:	f1bb 0f00 	cmp.w	fp, #0
   18574:	db09      	blt.n	1858a <GFXdrawChar+0x1de>
   18576:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   1857a:	465a      	mov	r2, fp
   1857c:	4621      	mov	r1, r4
   1857e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18580:	4558      	cmp	r0, fp
   18582:	4650      	mov	r0, sl
   18584:	dd01      	ble.n	1858a <GFXdrawChar+0x1de>
   18586:	f7ff fc27 	bl	17dd8 <GFXdrawPixel.part.0>
        err -= dy;
   1858a:	eba5 0508 	sub.w	r5, r5, r8
   1858e:	3401      	adds	r4, #1
   18590:	b22d      	sxth	r5, r5
   18592:	b224      	sxth	r4, r4
        if (err < 0) {
   18594:	2d00      	cmp	r5, #0
   18596:	da03      	bge.n	185a0 <GFXdrawChar+0x1f4>
            y0 += ystep;
   18598:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
   1859c:	fa0f fb8b 	sxth.w	fp, fp
    for (; x0<=x1; x0++) {
   185a0:	42a6      	cmp	r6, r4
   185a2:	dadf      	bge.n	18564 <GFXdrawChar+0x1b8>
   185a4:	3601      	adds	r6, #1
    for (int16_t i=x; i<x+w; i++) {
   185a6:	9b05      	ldr	r3, [sp, #20]
   185a8:	b236      	sxth	r6, r6
   185aa:	429e      	cmp	r6, r3
   185ac:	db9d      	blt.n	184ea <GFXdrawChar+0x13e>
   185ae:	e7cb      	b.n	18548 <GFXdrawChar+0x19c>
   185b0:	4611      	mov	r1, r2
   185b2:	9b07      	ldr	r3, [sp, #28]
        for(yy=0; yy<h; yy++) {
   185b4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   185b6:	440b      	add	r3, r1
   185b8:	3201      	adds	r2, #1
   185ba:	b2db      	uxtb	r3, r3
   185bc:	b2d2      	uxtb	r2, r2
   185be:	9307      	str	r3, [sp, #28]
   185c0:	9b14      	ldr	r3, [sp, #80]	; 0x50
   185c2:	920f      	str	r2, [sp, #60]	; 0x3c
   185c4:	4293      	cmp	r3, r2
   185c6:	f63f af38 	bhi.w	1843a <GFXdrawChar+0x8e>
}
   185ca:	b01b      	add	sp, #108	; 0x6c
   185cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   185d0:	9b18      	ldr	r3, [sp, #96]	; 0x60
   185d2:	18f9      	adds	r1, r7, r3
   185d4:	b209      	sxth	r1, r1
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   185d6:	2900      	cmp	r1, #0
   185d8:	f6ff af5f 	blt.w	1849a <GFXdrawChar+0xee>
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   185dc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   185de:	9a19      	ldr	r2, [sp, #100]	; 0x64
   185e0:	980f      	ldr	r0, [sp, #60]	; 0x3c
   185e2:	189a      	adds	r2, r3, r2
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   185e4:	f8ba 3004 	ldrh.w	r3, [sl, #4]
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   185e8:	4402      	add	r2, r0
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   185ea:	4299      	cmp	r1, r3
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   185ec:	b212      	sxth	r2, r2
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   185ee:	f6bf af54 	bge.w	1849a <GFXdrawChar+0xee>
   185f2:	2a00      	cmp	r2, #0
   185f4:	f6ff af51 	blt.w	1849a <GFXdrawChar+0xee>
   185f8:	f8ba 3006 	ldrh.w	r3, [sl, #6]
   185fc:	429a      	cmp	r2, r3
   185fe:	f6bf af4c 	bge.w	1849a <GFXdrawChar+0xee>
   18602:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18604:	4650      	mov	r0, sl
   18606:	f7ff fbe7 	bl	17dd8 <GFXdrawPixel.part.0>
   1860a:	e746      	b.n	1849a <GFXdrawChar+0xee>
        if((x >= myGFX->_width)            || // Clip right
   1860c:	f8ba 2004 	ldrh.w	r2, [sl, #4]
   18610:	4291      	cmp	r1, r2
   18612:	daa1      	bge.n	18558 <GFXdrawChar+0x1ac>
           (y >= myGFX->_height)           || // Clip bottom
   18614:	f8ba 2006 	ldrh.w	r2, [sl, #6]
        if((x >= myGFX->_width)            || // Clip right
   18618:	9c04      	ldr	r4, [sp, #16]
   1861a:	4294      	cmp	r4, r2
   1861c:	da9c      	bge.n	18558 <GFXdrawChar+0x1ac>
           ((x + 6 * size - 1) < 0) || // Clip left
   1861e:	2206      	movs	r2, #6
   18620:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   18622:	fb12 1205 	smlabb	r2, r2, r5, r1
           (y >= myGFX->_height)           || // Clip bottom
   18626:	2a00      	cmp	r2, #0
   18628:	dd96      	ble.n	18558 <GFXdrawChar+0x1ac>
           ((y + 8 * size - 1) < 0))   // Clip top
   1862a:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
           ((x + 6 * size - 1) < 0) || // Clip left
   1862e:	2a00      	cmp	r2, #0
   18630:	dd92      	ble.n	18558 <GFXdrawChar+0x1ac>
        if(!myGFX->_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
   18632:	f8ba 2016 	ldrh.w	r2, [sl, #22]
   18636:	b91a      	cbnz	r2, 18640 <GFXdrawChar+0x294>
   18638:	2baf      	cmp	r3, #175	; 0xaf
   1863a:	d901      	bls.n	18640 <GFXdrawChar+0x294>
   1863c:	3301      	adds	r3, #1
   1863e:	b2db      	uxtb	r3, r3
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
   18640:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18644:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
   18648:	b289      	uxth	r1, r1
   1864a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1864e:	9403      	str	r4, [sp, #12]
   18650:	1d4a      	adds	r2, r1, #5
   18652:	910f      	str	r1, [sp, #60]	; 0x3c
   18654:	009b      	lsls	r3, r3, #2
   18656:	9106      	str	r1, [sp, #24]
   18658:	b292      	uxth	r2, r2
   1865a:	9107      	str	r1, [sp, #28]
   1865c:	9308      	str	r3, [sp, #32]
   1865e:	1e63      	subs	r3, r4, #1
   18660:	920c      	str	r2, [sp, #48]	; 0x30
   18662:	9309      	str	r3, [sp, #36]	; 0x24
   18664:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   18668:	9a08      	ldr	r2, [sp, #32]
   1866a:	461d      	mov	r5, r3
   1866c:	9313      	str	r3, [sp, #76]	; 0x4c
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
   1866e:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
    for (int16_t i=x; i<x+w; i++) {
   18672:	2700      	movs	r7, #0
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
   18674:	f810 9002 	ldrb.w	r9, [r0, r2]
    for (int16_t i=x; i<x+w; i++) {
   18678:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    GFXdrawPixel(myGFX, x, y, color);
   1867a:	46b8      	mov	r8, r7
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
   1867c:	9305      	str	r3, [sp, #20]
    for (int16_t i=x; i<x+w; i++) {
   1867e:	189e      	adds	r6, r3, r2
    GFXdrawPixel(myGFX, x, y, color);
   18680:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
   18684:	930e      	str	r3, [sp, #56]	; 0x38
                if(line & 1) {
   18686:	f019 0f01 	tst.w	r9, #1
   1868a:	d037      	beq.n	186fc <GFXdrawChar+0x350>
                    if(size == 1)
   1868c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1868e:	2b01      	cmp	r3, #1
   18690:	d057      	beq.n	18742 <GFXdrawChar+0x396>
    for (int16_t i=x; i<x+w; i++) {
   18692:	9c05      	ldr	r4, [sp, #20]
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, color);
   18694:	fa0f fb85 	sxth.w	fp, r5
    for (int16_t i=x; i<x+w; i++) {
   18698:	42b4      	cmp	r4, r6
   1869a:	da11      	bge.n	186c0 <GFXdrawChar+0x314>
   1869c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1869e:	950a      	str	r5, [sp, #40]	; 0x28
   186a0:	18ef      	adds	r7, r5, r3
   186a2:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   186a4:	b23f      	sxth	r7, r7
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   186a6:	4623      	mov	r3, r4
   186a8:	4621      	mov	r1, r4
   186aa:	3401      	adds	r4, #1
   186ac:	9501      	str	r5, [sp, #4]
   186ae:	9700      	str	r7, [sp, #0]
   186b0:	465a      	mov	r2, fp
   186b2:	b224      	sxth	r4, r4
   186b4:	4650      	mov	r0, sl
   186b6:	f7ff fc07 	bl	17ec8 <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
   186ba:	42b4      	cmp	r4, r6
   186bc:	dbf3      	blt.n	186a6 <GFXdrawChar+0x2fa>
   186be:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   186c0:	9b03      	ldr	r3, [sp, #12]
   186c2:	f108 0801 	add.w	r8, r8, #1
            for(int8_t j=0; j<8; j++, line >>= 1) {
   186c6:	ea4f 0959 	mov.w	r9, r9, lsr #1
   186ca:	441d      	add	r5, r3
   186cc:	f1b8 0f08 	cmp.w	r8, #8
   186d0:	b2ad      	uxth	r5, r5
   186d2:	d1d8      	bne.n	18686 <GFXdrawChar+0x2da>
   186d4:	4619      	mov	r1, r3
   186d6:	9b07      	ldr	r3, [sp, #28]
   186d8:	9a06      	ldr	r2, [sp, #24]
   186da:	440b      	add	r3, r1
   186dc:	9908      	ldr	r1, [sp, #32]
   186de:	3201      	adds	r2, #1
   186e0:	b29b      	uxth	r3, r3
   186e2:	310c      	adds	r1, #12
   186e4:	b292      	uxth	r2, r2
   186e6:	9307      	str	r3, [sp, #28]
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
   186e8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   186ea:	9108      	str	r1, [sp, #32]
   186ec:	4293      	cmp	r3, r2
   186ee:	9206      	str	r2, [sp, #24]
   186f0:	d03b      	beq.n	1876a <GFXdrawChar+0x3be>
   186f2:	f8da 0018 	ldr.w	r0, [sl, #24]
   186f6:	460a      	mov	r2, r1
   186f8:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   186fa:	e7b8      	b.n	1866e <GFXdrawChar+0x2c2>
                } else if(bg != color) {
   186fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   186fe:	9a02      	ldr	r2, [sp, #8]
   18700:	4293      	cmp	r3, r2
   18702:	d0dd      	beq.n	186c0 <GFXdrawChar+0x314>
                    if(size == 1)
   18704:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18706:	2b01      	cmp	r3, #1
   18708:	d025      	beq.n	18756 <GFXdrawChar+0x3aa>
    for (int16_t i=x; i<x+w; i++) {
   1870a:	9c05      	ldr	r4, [sp, #20]
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
   1870c:	fa0f fb85 	sxth.w	fp, r5
    for (int16_t i=x; i<x+w; i++) {
   18710:	42b4      	cmp	r4, r6
   18712:	dad5      	bge.n	186c0 <GFXdrawChar+0x314>
   18714:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18716:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
   1871a:	46a9      	mov	r9, r5
   1871c:	18ef      	adds	r7, r5, r3
   1871e:	9d02      	ldr	r5, [sp, #8]
   18720:	b23f      	sxth	r7, r7
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   18722:	4623      	mov	r3, r4
   18724:	4621      	mov	r1, r4
   18726:	3401      	adds	r4, #1
   18728:	9501      	str	r5, [sp, #4]
   1872a:	9700      	str	r7, [sp, #0]
   1872c:	465a      	mov	r2, fp
   1872e:	b224      	sxth	r4, r4
   18730:	4650      	mov	r0, sl
   18732:	f7ff fbc9 	bl	17ec8 <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
   18736:	42b4      	cmp	r4, r6
   18738:	dbf3      	blt.n	18722 <GFXdrawChar+0x376>
   1873a:	464d      	mov	r5, r9
   1873c:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
   18740:	e7be      	b.n	186c0 <GFXdrawChar+0x314>
    GFXdrawPixel(myGFX, x, y, color);
   18742:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   18744:	4650      	mov	r0, sl
   18746:	990e      	ldr	r1, [sp, #56]	; 0x38
   18748:	eb03 0208 	add.w	r2, r3, r8
   1874c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1874e:	b212      	sxth	r2, r2
   18750:	f7ff fc56 	bl	18000 <GFXdrawPixel>
   18754:	e7b4      	b.n	186c0 <GFXdrawChar+0x314>
   18756:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   18758:	4650      	mov	r0, sl
   1875a:	990e      	ldr	r1, [sp, #56]	; 0x38
   1875c:	eb03 0208 	add.w	r2, r3, r8
   18760:	9b02      	ldr	r3, [sp, #8]
   18762:	b212      	sxth	r2, r2
   18764:	f7ff fc4c 	bl	18000 <GFXdrawPixel>
   18768:	e7aa      	b.n	186c0 <GFXdrawChar+0x314>
        if(bg != color) { // If opaque, draw vertical line for last column
   1876a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1876c:	9a02      	ldr	r2, [sp, #8]
   1876e:	4293      	cmp	r3, r2
   18770:	f43f aef2 	beq.w	18558 <GFXdrawChar+0x1ac>
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
   18774:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18776:	2b01      	cmp	r3, #1
   18778:	d01e      	beq.n	187b8 <GFXdrawChar+0x40c>
            else          GFXwriteFillRect(myGFX,x+5*size, y, size, 8*size, bg);
   1877a:	9b03      	ldr	r3, [sp, #12]
   1877c:	eb03 0583 	add.w	r5, r3, r3, lsl #2
   18780:	00dc      	lsls	r4, r3, #3
   18782:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   18784:	442b      	add	r3, r5
   18786:	b21d      	sxth	r5, r3
    for (int16_t i=x; i<x+w; i++) {
   18788:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1878a:	442b      	add	r3, r5
   1878c:	42ab      	cmp	r3, r5
   1878e:	461e      	mov	r6, r3
   18790:	f77f aee2 	ble.w	18558 <GFXdrawChar+0x1ac>
   18794:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   18796:	3b01      	subs	r3, #1
   18798:	441c      	add	r4, r3
   1879a:	b224      	sxth	r4, r4
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1879c:	9b02      	ldr	r3, [sp, #8]
   1879e:	4629      	mov	r1, r5
   187a0:	9400      	str	r4, [sp, #0]
   187a2:	4650      	mov	r0, sl
   187a4:	9301      	str	r3, [sp, #4]
   187a6:	462b      	mov	r3, r5
   187a8:	3501      	adds	r5, #1
   187aa:	9a04      	ldr	r2, [sp, #16]
   187ac:	f7ff fb8c 	bl	17ec8 <GFXwriteLine>
   187b0:	b22d      	sxth	r5, r5
    for (int16_t i=x; i<x+w; i++) {
   187b2:	42ae      	cmp	r6, r5
   187b4:	dcf2      	bgt.n	1879c <GFXdrawChar+0x3f0>
   187b6:	e6cf      	b.n	18558 <GFXdrawChar+0x1ac>
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   187b8:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   187ba:	4650      	mov	r0, sl
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
   187bc:	f9bd 3030 	ldrsh.w	r3, [sp, #48]	; 0x30
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   187c0:	3407      	adds	r4, #7
   187c2:	9225      	str	r2, [sp, #148]	; 0x94
   187c4:	4619      	mov	r1, r3
   187c6:	9a04      	ldr	r2, [sp, #16]
   187c8:	b224      	sxth	r4, r4
   187ca:	9424      	str	r4, [sp, #144]	; 0x90
}
   187cc:	b01b      	add	sp, #108	; 0x6c
   187ce:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   187d2:	f7ff bb79 	b.w	17ec8 <GFXwriteLine>
   187d6:	bf00      	nop

000187d8 <GFXwrite>:
        }
  }
}


void GFXwrite(GFX* myGFX, uint8_t c) {
   187d8:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(!myGFX->gfxFont) { // 'Classic' built-in font
   187da:	6983      	ldr	r3, [r0, #24]
void GFXwrite(GFX* myGFX, uint8_t c) {
   187dc:	b085      	sub	sp, #20
   187de:	4604      	mov	r4, r0
	if(!myGFX->gfxFont) { // 'Classic' built-in font
   187e0:	b32b      	cbz	r3, 1882e <GFXwrite+0x56>
			myGFX->cursor_x += myGFX->textsize * 6;          // Advance x one char
		}

	} else { // Custom font

		if(c == '\n') {
   187e2:	290a      	cmp	r1, #10
   187e4:	d018      	beq.n	18818 <GFXwrite+0x40>
			myGFX->cursor_x  = 0;
			myGFX->cursor_y += (int16_t)myGFX->textsize *
						(uint8_t)pgm_read_byte(&myGFX->gfxFont->yAdvance);
		} else if(c != '\r') {
   187e6:	290d      	cmp	r1, #13
   187e8:	d01f      	beq.n	1882a <GFXwrite+0x52>
			uint8_t first = pgm_read_byte(&myGFX->gfxFont->first);
   187ea:	7a1a      	ldrb	r2, [r3, #8]
			if((c >= first) && (c <= (uint8_t)pgm_read_byte(&myGFX->gfxFont->last))) {
   187ec:	4291      	cmp	r1, r2
   187ee:	d31c      	bcc.n	1882a <GFXwrite+0x52>
   187f0:	7a58      	ldrb	r0, [r3, #9]
   187f2:	4288      	cmp	r0, r1
   187f4:	d319      	bcc.n	1882a <GFXwrite+0x52>
				GFXglyph *glyph = &(((GFXglyph *)pgm_read_pointer(
				  &myGFX->gfxFont->glyph))[c - first]);
   187f6:	685d      	ldr	r5, [r3, #4]
   187f8:	1a8a      	subs	r2, r1, r2
   187fa:	89e0      	ldrh	r0, [r4, #14]
   187fc:	eb05 05c2 	add.w	r5, r5, r2, lsl #3
				uint8_t   w     = pgm_read_byte(&glyph->width),
						  h     = pgm_read_byte(&glyph->height);
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
   18800:	78eb      	ldrb	r3, [r5, #3]
				uint8_t   w     = pgm_read_byte(&glyph->width),
   18802:	78ae      	ldrb	r6, [r5, #2]
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
   18804:	b10b      	cbz	r3, 1880a <GFXwrite+0x32>
   18806:	2e00      	cmp	r6, #0
   18808:	d158      	bne.n	188bc <GFXwrite+0xe4>
					//     cursor_y += (int16_t)textsize *
					//       (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
					// }
					GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
				}
				myGFX->cursor_x += (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)myGFX->textsize;
   1880a:	792b      	ldrb	r3, [r5, #4]
   1880c:	89a2      	ldrh	r2, [r4, #12]
   1880e:	fb13 f300 	smulbb	r3, r3, r0
   18812:	4413      	add	r3, r2
   18814:	81a3      	strh	r3, [r4, #12]
			}
		}

	}
}
   18816:	e008      	b.n	1882a <GFXwrite+0x52>
			myGFX->cursor_x  = 0;
   18818:	2000      	movs	r0, #0
			myGFX->cursor_y += (int16_t)myGFX->textsize *
   1881a:	8962      	ldrh	r2, [r4, #10]
   1881c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
			myGFX->cursor_x  = 0;
   18820:	81a0      	strh	r0, [r4, #12]
			myGFX->cursor_y += (int16_t)myGFX->textsize *
   18822:	7a9b      	ldrb	r3, [r3, #10]
   18824:	fb01 2303 	mla	r3, r1, r3, r2
   18828:	8163      	strh	r3, [r4, #10]
}
   1882a:	b005      	add	sp, #20
   1882c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if(c == '\n') {                        // Newline?
   1882e:	290a      	cmp	r1, #10
   18830:	d03c      	beq.n	188ac <GFXwrite+0xd4>
		} else if(c != '\r') {                 // Ignore carriage returns
   18832:	290d      	cmp	r1, #13
   18834:	d0f9      	beq.n	1882a <GFXwrite+0x52>
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   18836:	8a85      	ldrh	r5, [r0, #20]
   18838:	8962      	ldrh	r2, [r4, #10]
			GFXcheckScrollWrap(myGFX, myGFX->textsize * 6 - myGFX->textsize * 2);
   1883a:	89c0      	ldrh	r0, [r0, #14]
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   1883c:	b135      	cbz	r5, 1884c <GFXwrite+0x74>
   1883e:	89a7      	ldrh	r7, [r4, #12]
			GFXcheckScrollWrap(myGFX, myGFX->textsize * 6 - myGFX->textsize * 2);
   18840:	0085      	lsls	r5, r0, #2
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   18842:	88a6      	ldrh	r6, [r4, #4]
   18844:	fa07 f585 	sxtah	r5, r7, r5
   18848:	42b5      	cmp	r5, r6
   1884a:	da6c      	bge.n	18926 <GFXwrite+0x14e>
    if (myGFX->autoscroll) {
   1884c:	8c23      	ldrh	r3, [r4, #32]
   1884e:	b1b3      	cbz	r3, 1887e <GFXwrite+0xa6>
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   18850:	8ba3      	ldrh	r3, [r4, #28]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   18852:	8be5      	ldrh	r5, [r4, #30]
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   18854:	fb13 f300 	smulbb	r3, r3, r0
        if (cursor >= myGFX->_height) {
   18858:	88e7      	ldrh	r7, [r4, #6]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   1885a:	fb15 f500 	smulbb	r5, r5, r0
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   1885e:	3b01      	subs	r3, #1
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   18860:	b2ad      	uxth	r5, r5
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   18862:	b29b      	uxth	r3, r3
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   18864:	195e      	adds	r6, r3, r5
   18866:	4416      	add	r6, r2
        if (cursor >= myGFX->_height) {
   18868:	b2b6      	uxth	r6, r6
   1886a:	42be      	cmp	r6, r7
   1886c:	d307      	bcc.n	1887e <GFXwrite+0xa6>
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   1886e:	43ed      	mvns	r5, r5
            myGFX->cursor_x  = 0;
   18870:	2600      	movs	r6, #0
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   18872:	443d      	add	r5, r7
            myGFX->cursor_x  = 0;
   18874:	81a6      	strh	r6, [r4, #12]
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   18876:	1aeb      	subs	r3, r5, r3
   18878:	b29a      	uxth	r2, r3
   1887a:	8162      	strh	r2, [r4, #10]
   1887c:	e001      	b.n	18882 <GFXwrite+0xaa>
   1887e:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
			GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
   18882:	8a67      	ldrh	r7, [r4, #18]
   18884:	b2c0      	uxtb	r0, r0
   18886:	8a25      	ldrh	r5, [r4, #16]
   18888:	460b      	mov	r3, r1
   1888a:	9002      	str	r0, [sp, #8]
   1888c:	b212      	sxth	r2, r2
   1888e:	4631      	mov	r1, r6
   18890:	4620      	mov	r0, r4
   18892:	e9cd 5700 	strd	r5, r7, [sp]
   18896:	f7ff fd89 	bl	183ac <GFXdrawChar>
			myGFX->cursor_x += myGFX->textsize * 6;          // Advance x one char
   1889a:	89e3      	ldrh	r3, [r4, #14]
   1889c:	89a2      	ldrh	r2, [r4, #12]
   1889e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   188a2:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   188a6:	81a3      	strh	r3, [r4, #12]
}
   188a8:	b005      	add	sp, #20
   188aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize;
   188ac:	8b82      	ldrh	r2, [r0, #28]
   188ae:	8961      	ldrh	r1, [r4, #10]
   188b0:	89c0      	ldrh	r0, [r0, #14]
			myGFX->cursor_x  = 0;                     // Reset x to zero,
   188b2:	81a3      	strh	r3, [r4, #12]
			myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize;
   188b4:	fb12 1300 	smlabb	r3, r2, r0, r1
   188b8:	8163      	strh	r3, [r4, #10]
   188ba:	e7b6      	b.n	1882a <GFXwrite+0x52>
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   188bc:	8aa3      	ldrh	r3, [r4, #20]
   188be:	8962      	ldrh	r2, [r4, #10]
   188c0:	b18b      	cbz	r3, 188e6 <GFXwrite+0x10e>
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
   188c2:	f995 3005 	ldrsb.w	r3, [r5, #5]
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   188c6:	89a7      	ldrh	r7, [r4, #12]
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
   188c8:	4433      	add	r3, r6
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   188ca:	88a6      	ldrh	r6, [r4, #4]
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
   188cc:	fb13 f300 	smulbb	r3, r3, r0
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   188d0:	fa07 f383 	sxtah	r3, r7, r3
   188d4:	42b3      	cmp	r3, r6
   188d6:	db06      	blt.n	188e6 <GFXwrite+0x10e>
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   188d8:	8ba3      	ldrh	r3, [r4, #28]
    	myGFX->cursor_x  = 0;            // Reset x to zero
   188da:	2600      	movs	r6, #0
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   188dc:	fb13 2200 	smlabb	r2, r3, r0, r2
    	myGFX->cursor_x  = 0;            // Reset x to zero
   188e0:	81a6      	strh	r6, [r4, #12]
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   188e2:	b292      	uxth	r2, r2
   188e4:	8162      	strh	r2, [r4, #10]
    if (myGFX->autoscroll) {
   188e6:	8c23      	ldrh	r3, [r4, #32]
   188e8:	b323      	cbz	r3, 18934 <GFXwrite+0x15c>
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   188ea:	8be3      	ldrh	r3, [r4, #30]
        if (cursor >= myGFX->_height) {
   188ec:	88e6      	ldrh	r6, [r4, #6]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   188ee:	fb13 f300 	smulbb	r3, r3, r0
   188f2:	b29b      	uxth	r3, r3
   188f4:	18d7      	adds	r7, r2, r3
        if (cursor >= myGFX->_height) {
   188f6:	b2bf      	uxth	r7, r7
   188f8:	42b7      	cmp	r7, r6
   188fa:	d31b      	bcc.n	18934 <GFXwrite+0x15c>
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   188fc:	1e72      	subs	r2, r6, #1
            myGFX->cursor_x  = 0;
   188fe:	2600      	movs	r6, #0
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   18900:	1ad3      	subs	r3, r2, r3
   18902:	46b4      	mov	ip, r6
            myGFX->cursor_x  = 0;
   18904:	81a6      	strh	r6, [r4, #12]
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   18906:	b29a      	uxth	r2, r3
   18908:	8162      	strh	r2, [r4, #10]
					GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
   1890a:	8a67      	ldrh	r7, [r4, #18]
   1890c:	b2c0      	uxtb	r0, r0
   1890e:	8a26      	ldrh	r6, [r4, #16]
   18910:	460b      	mov	r3, r1
   18912:	9002      	str	r0, [sp, #8]
   18914:	b212      	sxth	r2, r2
   18916:	4620      	mov	r0, r4
   18918:	4661      	mov	r1, ip
   1891a:	e9cd 6700 	strd	r6, r7, [sp]
   1891e:	f7ff fd45 	bl	183ac <GFXdrawChar>
   18922:	89e0      	ldrh	r0, [r4, #14]
   18924:	e771      	b.n	1880a <GFXwrite+0x32>
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   18926:	8ba5      	ldrh	r5, [r4, #28]
    	myGFX->cursor_x  = 0;            // Reset x to zero
   18928:	81a3      	strh	r3, [r4, #12]
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   1892a:	fb15 2200 	smlabb	r2, r5, r0, r2
   1892e:	b292      	uxth	r2, r2
   18930:	8162      	strh	r2, [r4, #10]
   18932:	e78b      	b.n	1884c <GFXwrite+0x74>
   18934:	f9b4 c00c 	ldrsh.w	ip, [r4, #12]
   18938:	e7e7      	b.n	1890a <GFXwrite+0x132>
   1893a:	bf00      	nop

0001893c <GFXsetCursor>:

void GFXsetCursor(GFX* myGFX, int16_t x, int16_t y) {
	myGFX->cursor_x = x;
   1893c:	8181      	strh	r1, [r0, #12]
	myGFX->cursor_y = y;
   1893e:	8142      	strh	r2, [r0, #10]
}
   18940:	4770      	bx	lr
   18942:	bf00      	nop

00018944 <GFXgetCursorX>:

int16_t GFXgetCursorX(GFX* myGFX)
{
    return myGFX->cursor_x;
}
   18944:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
   18948:	4770      	bx	lr
   1894a:	bf00      	nop

0001894c <GFXsetTextSize>:
{
    return myGFX->cursor_y;
}

void GFXsetTextSize(GFX* myGFX, uint8_t s) {
	myGFX->textsize = (s > 0) ? s : 1;
   1894c:	2900      	cmp	r1, #0
   1894e:	bf08      	it	eq
   18950:	2101      	moveq	r1, #1
   18952:	81c1      	strh	r1, [r0, #14]
}
   18954:	4770      	bx	lr
   18956:	bf00      	nop

00018958 <GFXsetTextColor>:

void GFXsetTextColor(GFX* myGFX, uint16_t c, uint16_t b) {
	myGFX->textcolor   = c;
   18958:	8201      	strh	r1, [r0, #16]
	myGFX->textbgcolor = b;
   1895a:	8242      	strh	r2, [r0, #18]
}
   1895c:	4770      	bx	lr
   1895e:	bf00      	nop

00018960 <GFXsetFont>:
// to this function to use correct CP437 character values in your code.
void GFXcp437(GFX* myGFX, uint8_t x) {
	myGFX->_cp437 = x;
}

void GFXsetFont(GFX* myGFX, const GFXfont *f) {
   18960:	6983      	ldr	r3, [r0, #24]

	if(f)
   18962:	b139      	cbz	r1, 18974 <GFXsetFont+0x14>
    {            // Font struct pointer passed in?
        if(!myGFX->gfxFont) { // And no current font struct?
   18964:	b10b      	cbz	r3, 1896a <GFXsetFont+0xa>
		}

		myGFX->fontHeight = 8;
		myGFX->fontDesc = 0;
	}
    myGFX->gfxFont = (GFXfont *)f;
   18966:	6181      	str	r1, [r0, #24]
}
   18968:	4770      	bx	lr
        	myGFX->cursor_y += 6;
   1896a:	8943      	ldrh	r3, [r0, #10]
    myGFX->gfxFont = (GFXfont *)f;
   1896c:	6181      	str	r1, [r0, #24]
        	myGFX->cursor_y += 6;
   1896e:	3306      	adds	r3, #6
   18970:	8143      	strh	r3, [r0, #10]
}
   18972:	4770      	bx	lr
	else if(myGFX->gfxFont)
   18974:	b113      	cbz	r3, 1897c <GFXsetFont+0x1c>
		myGFX->fontDesc = 0;
   18976:	83c1      	strh	r1, [r0, #30]
		uint8_t first  = (uint8_t) pgm_read_byte(&f->first);
   18978:	7a0b      	ldrb	r3, [r1, #8]
   1897a:	deff      	udf	#255	; 0xff
		myGFX->fontHeight = 8;
   1897c:	2308      	movs	r3, #8
   1897e:	61c3      	str	r3, [r0, #28]
   18980:	e7f1      	b.n	18966 <GFXsetFont+0x6>
   18982:	bf00      	nop

00018984 <OLEDparseInt>:
	'A', '#',
	'B', ' '
};

int OLEDparseInt(char* buffer, uint32_t myNumber, uint8_t numDigits)
{
   18984:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (int i = 0; i < numDigits; i++)
   18986:	4617      	mov	r7, r2
   18988:	b1ca      	cbz	r2, 189be <OLEDparseInt+0x3a>
   1898a:	460d      	mov	r5, r1
   1898c:	4606      	mov	r6, r0
   1898e:	1e54      	subs	r4, r2, #1
	{
		int whichPlace = (uint32_t)(powf(10.0f,(numDigits - 1) - i));
   18990:	ee07 4a90 	vmov	s15, r4
   18994:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   18998:	3c01      	subs	r4, #1
   1899a:	eef8 0ae7 	vcvt.f32.s32	s1, s15
   1899e:	f014 fa77 	bl	2ce90 <powf>
   189a2:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   189a6:	ee17 3a90 	vmov	r3, s15
		int thisDigit = (myNumber / whichPlace);
   189aa:	fbb5 f2f3 	udiv	r2, r5, r3
		buffer[i] = thisDigit + 48;
   189ae:	f102 0130 	add.w	r1, r2, #48	; 0x30
		myNumber -= thisDigit * whichPlace;
   189b2:	fb02 5513 	mls	r5, r2, r3, r5
	for (int i = 0; i < numDigits; i++)
   189b6:	1c63      	adds	r3, r4, #1
		buffer[i] = thisDigit + 48;
   189b8:	f806 1b01 	strb.w	r1, [r6], #1
	for (int i = 0; i < numDigits; i++)
   189bc:	d1e8      	bne.n	18990 <OLEDparseInt+0xc>
	}

	return numDigits;
}
   189be:	4638      	mov	r0, r7
   189c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   189c2:	bf00      	nop

000189c4 <OLEDparsePitch>:

int OLEDparsePitch(char* buffer, float midi, uint8_t showCents)
{
	int pclass, octave, note, neg = 0; float offset;

	note = (int)midi;
   189c4:	eebd 7ac0 	vcvt.s32.f32	s14, s0
	offset = midi - note;

	if ((midi + 0.5f) > (note+1))
   189c8:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	note = (int)midi;
   189cc:	ee17 3a10 	vmov	r3, s14
	offset = midi - note;
   189d0:	eef8 6ac7 	vcvt.f32.s32	s13, s14
	if ((midi + 0.5f) > (note+1))
   189d4:	ee70 7a27 	vadd.f32	s15, s0, s15
   189d8:	1c5a      	adds	r2, r3, #1
	offset = midi - note;
   189da:	ee30 0a66 	vsub.f32	s0, s0, s13
	if ((midi + 0.5f) > (note+1))
   189de:	ee07 2a10 	vmov	s14, r2
   189e2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
{
   189e6:	b470      	push	{r4, r5, r6}
	if ((midi + 0.5f) > (note+1))
   189e8:	eef4 7ac7 	vcmpe.f32	s15, s14
   189ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   189f0:	dd3a      	ble.n	18a68 <OLEDparsePitch+0xa4>
	{
		note += 1;
		offset = (1.0f - offset) + 0.01f;
   189f2:	eddf 7a20 	vldr	s15, [pc, #128]	; 18a74 <OLEDparsePitch+0xb0>
		note += 1;
   189f6:	4613      	mov	r3, r2
		neg = 1;
   189f8:	2601      	movs	r6, #1
		offset = (1.0f - offset) + 0.01f;
   189fa:	ee37 0ac0 	vsub.f32	s0, s15, s0
	}

	pclass = (note % 12);
   189fe:	4d1e      	ldr	r5, [pc, #120]	; (18a78 <OLEDparsePitch+0xb4>)
   18a00:	17da      	asrs	r2, r3, #31
	octave = (int)(note / 12) - 1;

	int idx = 0;

	buffer[idx++] = pitches[pclass*2];
   18a02:	4c1e      	ldr	r4, [pc, #120]	; (18a7c <OLEDparsePitch+0xb8>)
	pclass = (note % 12);
   18a04:	fb85 c503 	smull	ip, r5, r5, r3
   18a08:	ebc2 0265 	rsb	r2, r2, r5, asr #1
   18a0c:	eb02 0542 	add.w	r5, r2, r2, lsl #1
		buffer[i] = thisDigit + 48;
   18a10:	322f      	adds	r2, #47	; 0x2f
	pclass = (note % 12);
   18a12:	eba3 0385 	sub.w	r3, r3, r5, lsl #2
	buffer[idx++] = pitches[pclass*2];
   18a16:	f814 5013 	ldrb.w	r5, [r4, r3, lsl #1]
	buffer[idx++] = pitches[pclass*2+1];
   18a1a:	eb04 0343 	add.w	r3, r4, r3, lsl #1
	buffer[idx++] = pitches[pclass*2];
   18a1e:	7005      	strb	r5, [r0, #0]
	buffer[idx++] = pitches[pclass*2+1];
   18a20:	785b      	ldrb	r3, [r3, #1]
		buffer[i] = thisDigit + 48;
   18a22:	7082      	strb	r2, [r0, #2]
	buffer[idx++] = pitches[pclass*2+1];
   18a24:	7043      	strb	r3, [r0, #1]

	OLEDparseInt(&buffer[idx++], octave, 1);

	if (showCents)
   18a26:	b309      	cbz	r1, 18a6c <OLEDparsePitch+0xa8>
		if (neg == 1)
			buffer[idx++] = '-';
		else
			buffer[idx++] = '+';

		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
   18a28:	eddf 7a15 	vldr	s15, [pc, #84]	; 18a80 <OLEDparsePitch+0xbc>
		if (neg == 1)
   18a2c:	2e01      	cmp	r6, #1
		int thisDigit = (myNumber / whichPlace);
   18a2e:	4a15      	ldr	r2, [pc, #84]	; (18a84 <OLEDparsePitch+0xc0>)
		buffer[idx++] = ' ';
   18a30:	f04f 0120 	mov.w	r1, #32
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
   18a34:	ee20 0a27 	vmul.f32	s0, s0, s15
			buffer[idx++] = '+';
   18a38:	bf0c      	ite	eq
   18a3a:	232d      	moveq	r3, #45	; 0x2d
   18a3c:	232b      	movne	r3, #43	; 0x2b
		buffer[idx++] = ' ';
   18a3e:	70c1      	strb	r1, [r0, #3]
		idx += 2;
   18a40:	2107      	movs	r1, #7
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
   18a42:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   18a46:	7103      	strb	r3, [r0, #4]
   18a48:	ee17 3a90 	vmov	r3, s15
		int thisDigit = (myNumber / whichPlace);
   18a4c:	fba2 4203 	umull	r4, r2, r2, r3
   18a50:	08d2      	lsrs	r2, r2, #3
		myNumber -= thisDigit * whichPlace;
   18a52:	eb02 0482 	add.w	r4, r2, r2, lsl #2
		buffer[i] = thisDigit + 48;
   18a56:	3230      	adds	r2, #48	; 0x30
		myNumber -= thisDigit * whichPlace;
   18a58:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
		buffer[i] = thisDigit + 48;
   18a5c:	7142      	strb	r2, [r0, #5]
   18a5e:	3330      	adds	r3, #48	; 0x30
   18a60:	7183      	strb	r3, [r0, #6]
	}

	return idx;
}
   18a62:	4608      	mov	r0, r1
   18a64:	bc70      	pop	{r4, r5, r6}
   18a66:	4770      	bx	lr
	int pclass, octave, note, neg = 0; float offset;
   18a68:	2600      	movs	r6, #0
   18a6a:	e7c8      	b.n	189fe <OLEDparsePitch+0x3a>
	OLEDparseInt(&buffer[idx++], octave, 1);
   18a6c:	2103      	movs	r1, #3
}
   18a6e:	bc70      	pop	{r4, r5, r6}
   18a70:	4608      	mov	r0, r1
   18a72:	4770      	bx	lr
   18a74:	3f8147ae 	.word	0x3f8147ae
   18a78:	2aaaaaab 	.word	0x2aaaaaab
   18a7c:	0006257c 	.word	0x0006257c
   18a80:	42c80000 	.word	0x42c80000
   18a84:	cccccccd 	.word	0xcccccccd

00018a88 <OLEDparsePitchClass>:
int OLEDparsePitchClass(char* buffer, float midi)
{
	int pclass, note;
	float offset;

	note = (int)midi;
   18a88:	eebd 7ac0 	vcvt.s32.f32	s14, s0
	{
		note += 1;
		offset = (1.0f - offset) + 0.01f;
	}

	pclass = (note % 12);
   18a8c:	4a13      	ldr	r2, [pc, #76]	; (18adc <OLEDparsePitchClass+0x54>)
	if ((midi + 0.5f) > (note+1))
   18a8e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5

	int idx = 0;

	buffer[idx++] = pitches[pclass*2];
   18a92:	4913      	ldr	r1, [pc, #76]	; (18ae0 <OLEDparsePitchClass+0x58>)
	note = (int)midi;
   18a94:	ee17 3a10 	vmov	r3, s14
	if ((midi + 0.5f) > (note+1))
   18a98:	ee30 0a27 	vadd.f32	s0, s0, s15
{
   18a9c:	b430      	push	{r4, r5}
	if ((midi + 0.5f) > (note+1))
   18a9e:	1c5c      	adds	r4, r3, #1
{
   18aa0:	4605      	mov	r5, r0
	buffer[idx++] = pitches[pclass*2+1];

	return idx;
}
   18aa2:	2002      	movs	r0, #2
	if ((midi + 0.5f) > (note+1))
   18aa4:	ee07 4a90 	vmov	s15, r4
   18aa8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		note += 1;
   18aac:	eeb4 0a67 	vcmp.f32	s0, s15
   18ab0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   18ab4:	bfc8      	it	gt
   18ab6:	4623      	movgt	r3, r4
	pclass = (note % 12);
   18ab8:	fb82 2403 	smull	r2, r4, r2, r3
   18abc:	17da      	asrs	r2, r3, #31
   18abe:	ebc2 0264 	rsb	r2, r2, r4, asr #1
   18ac2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   18ac6:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
	buffer[idx++] = pitches[pclass*2];
   18aca:	f811 2013 	ldrb.w	r2, [r1, r3, lsl #1]
	buffer[idx++] = pitches[pclass*2+1];
   18ace:	eb01 0343 	add.w	r3, r1, r3, lsl #1
	buffer[idx++] = pitches[pclass*2];
   18ad2:	702a      	strb	r2, [r5, #0]
	buffer[idx++] = pitches[pclass*2+1];
   18ad4:	785b      	ldrb	r3, [r3, #1]
   18ad6:	706b      	strb	r3, [r5, #1]
}
   18ad8:	bc30      	pop	{r4, r5}
   18ada:	4770      	bx	lr
   18adc:	2aaaaaab 	.word	0x2aaaaaab
   18ae0:	0006257c 	.word	0x0006257c

00018ae4 <OLEDparseFixedFloat>:

int OLEDparseFixedFloat(char* buffer, float input, uint8_t numDigits, uint8_t numDecimal)
{
	float power = powf(10.0f, numDecimal);
   18ae4:	ee07 2a90 	vmov	s15, r2
{
   18ae8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18aec:	ed2d 8b02 	vpush	{d8}
   18af0:	b085      	sub	sp, #20
   18af2:	eeb0 8a40 	vmov.f32	s16, s0
	float power = powf(10.0f, numDecimal);
   18af6:	eef8 0a67 	vcvt.f32.u32	s1, s15
{
   18afa:	4680      	mov	r8, r0
	float power = powf(10.0f, numDecimal);
   18afc:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
{
   18b00:	9201      	str	r2, [sp, #4]
   18b02:	9102      	str	r1, [sp, #8]
	float power = powf(10.0f, numDecimal);
   18b04:	f014 f9c4 	bl	2ce90 <powf>
	float f = ((float)(int)(input * power + 0.5f)) / power;
   18b08:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   18b0c:	eee0 7a08 	vfma.f32	s15, s0, s16
   18b10:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   18b14:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   18b18:	ee87 7a80 	vdiv.f32	s14, s15, s0

	int nonzeroHasHappened = 0, decimalHasHappened = 0;

	int myNumber = (int)(f * power);
   18b1c:	ee27 0a00 	vmul.f32	s0, s14, s0
   18b20:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   18b24:	ee17 5a90 	vmov	r5, s15

	int idx = 0, i = 0;

	if (myNumber < 0)
   18b28:	2d00      	cmp	r5, #0
   18b2a:	f2c0 8082 	blt.w	18c32 <OLEDparseFixedFloat+0x14e>
	int idx = 0, i = 0;
   18b2e:	2600      	movs	r6, #0
		myNumber *= -1;
		buffer[idx++] = '-';
		i++;
	}

	while (i < numDigits)
   18b30:	9b02      	ldr	r3, [sp, #8]
   18b32:	429e      	cmp	r6, r3
   18b34:	da3e      	bge.n	18bb4 <OLEDparseFixedFloat+0xd0>
   18b36:	2400      	movs	r4, #0
   18b38:	1b9f      	subs	r7, r3, r6
   18b3a:	9603      	str	r6, [sp, #12]
		if ((decimalHasHappened == 0) && ((numDigits-i) == numDecimal))
		{
			if (nonzeroHasHappened == 0)
			{
				idx++; //get past the negative if there is one - this is hacky should figure out how to do it right
				buffer[idx-1] = '0';
   18b3c:	46a9      	mov	r9, r5
			decimalHasHappened = 1;
		}
		else
		{

			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18b3e:	f107 3aff 	add.w	sl, r7, #4294967295	; 0xffffffff
	while (i < numDigits)
   18b42:	9400      	str	r4, [sp, #0]
				buffer[idx-1] = '0';
   18b44:	46a3      	mov	fp, r4
   18b46:	e00d      	b.n	18b64 <OLEDparseFixedFloat+0x80>
			int thisDigit = (myNumber / whichPlace);

			if (nonzeroHasHappened == 0)
			{
				if (thisDigit > 0)
   18b48:	2b00      	cmp	r3, #0
   18b4a:	dd63      	ble.n	18c14 <OLEDparseFixedFloat+0x130>
				{
					buffer[idx++] = thisDigit + 48;
   18b4c:	f103 0e30 	add.w	lr, r3, #48	; 0x30
   18b50:	462e      	mov	r6, r5
					nonzeroHasHappened = 1;
   18b52:	f04f 0b01 	mov.w	fp, #1
					buffer[idx++] = thisDigit + 48;
   18b56:	f88c e000 	strb.w	lr, [ip]
   18b5a:	3401      	adds	r4, #1
   18b5c:	fb02 9913 	mls	r9, r2, r3, r9
	while (i < numDigits)
   18b60:	42bc      	cmp	r4, r7
   18b62:	d027      	beq.n	18bb4 <OLEDparseFixedFloat+0xd0>
		if ((decimalHasHappened == 0) && ((numDigits-i) == numDecimal))
   18b64:	9b00      	ldr	r3, [sp, #0]
   18b66:	1c75      	adds	r5, r6, #1
   18b68:	b91b      	cbnz	r3, 18b72 <OLEDparseFixedFloat+0x8e>
   18b6a:	1b3b      	subs	r3, r7, r4
   18b6c:	9a01      	ldr	r2, [sp, #4]
   18b6e:	429a      	cmp	r2, r3
   18b70:	d026      	beq.n	18bc0 <OLEDparseFixedFloat+0xdc>
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18b72:	ebaa 0304 	sub.w	r3, sl, r4
   18b76:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   18b7a:	ee07 3a90 	vmov	s15, r3
   18b7e:	eef8 0ae7 	vcvt.f32.s32	s1, s15
   18b82:	f014 f985 	bl	2ce90 <powf>
   18b86:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   18b8a:	eb08 0c06 	add.w	ip, r8, r6
   18b8e:	ee17 2a90 	vmov	r2, s15
			int thisDigit = (myNumber / whichPlace);
   18b92:	fb99 f3f2 	sdiv	r3, r9, r2
			if (nonzeroHasHappened == 0)
   18b96:	f1bb 0f00 	cmp.w	fp, #0
   18b9a:	d0d5      	beq.n	18b48 <OLEDparseFixedFloat+0x64>
					buffer[idx++] = ' ';
				}
			}
			else
			{
				buffer[idx++] = thisDigit + 48;
   18b9c:	f103 0130 	add.w	r1, r3, #48	; 0x30
   18ba0:	462e      	mov	r6, r5
   18ba2:	f04f 0b01 	mov.w	fp, #1
   18ba6:	f88c 1000 	strb.w	r1, [ip]
   18baa:	3401      	adds	r4, #1
   18bac:	fb02 9913 	mls	r9, r2, r3, r9
	while (i < numDigits)
   18bb0:	42bc      	cmp	r4, r7
   18bb2:	d1d7      	bne.n	18b64 <OLEDparseFixedFloat+0x80>
			i++;
		}
	}

	return idx;
}
   18bb4:	4630      	mov	r0, r6
   18bb6:	b005      	add	sp, #20
   18bb8:	ecbd 8b02 	vpop	{d8}
   18bbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (nonzeroHasHappened == 0)
   18bc0:	f1bb 0f00 	cmp.w	fp, #0
   18bc4:	d02c      	beq.n	18c20 <OLEDparseFixedFloat+0x13c>
   18bc6:	4632      	mov	r2, r6
	while (i < numDigits)
   18bc8:	9b03      	ldr	r3, [sp, #12]
			buffer[idx++] = '.';
   18bca:	f04f 012e 	mov.w	r1, #46	; 0x2e
	while (i < numDigits)
   18bce:	4423      	add	r3, r4
			buffer[idx++] = '.';
   18bd0:	f808 1002 	strb.w	r1, [r8, r2]
	while (i < numDigits)
   18bd4:	9a02      	ldr	r2, [sp, #8]
   18bd6:	4293      	cmp	r3, r2
   18bd8:	da31      	bge.n	18c3e <OLEDparseFixedFloat+0x15a>
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18bda:	ebaa 0304 	sub.w	r3, sl, r4
			decimalHasHappened = 1;
   18bde:	2201      	movs	r2, #1
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18be0:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
				buffer[idx++] = thisDigit + 48;
   18be4:	f04f 0b01 	mov.w	fp, #1
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18be8:	ee07 3a90 	vmov	s15, r3
			decimalHasHappened = 1;
   18bec:	9200      	str	r2, [sp, #0]
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18bee:	eef8 0ae7 	vcvt.f32.s32	s1, s15
   18bf2:	f014 f94d 	bl	2ce90 <powf>
   18bf6:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   18bfa:	eb08 0c05 	add.w	ip, r8, r5
   18bfe:	3501      	adds	r5, #1
   18c00:	ee17 2a90 	vmov	r2, s15
				buffer[idx++] = thisDigit + 48;
   18c04:	462e      	mov	r6, r5
			int thisDigit = (myNumber / whichPlace);
   18c06:	fb99 f3f2 	sdiv	r3, r9, r2
				buffer[idx++] = thisDigit + 48;
   18c0a:	f103 0130 	add.w	r1, r3, #48	; 0x30
   18c0e:	f88c 1000 	strb.w	r1, [ip]
   18c12:	e7ca      	b.n	18baa <OLEDparseFixedFloat+0xc6>
					buffer[idx++] = ' ';
   18c14:	f04f 0120 	mov.w	r1, #32
   18c18:	462e      	mov	r6, r5
   18c1a:	f88c 1000 	strb.w	r1, [ip]
   18c1e:	e79c      	b.n	18b5a <OLEDparseFixedFloat+0x76>
				buffer[idx-1] = '0';
   18c20:	eb08 0305 	add.w	r3, r8, r5
   18c24:	f04f 0130 	mov.w	r1, #48	; 0x30
   18c28:	462a      	mov	r2, r5
   18c2a:	1cb5      	adds	r5, r6, #2
   18c2c:	f803 1c01 	strb.w	r1, [r3, #-1]
   18c30:	e7ca      	b.n	18bc8 <OLEDparseFixedFloat+0xe4>
		buffer[idx++] = '-';
   18c32:	232d      	movs	r3, #45	; 0x2d
		myNumber *= -1;
   18c34:	426d      	negs	r5, r5
		buffer[idx++] = '-';
   18c36:	2601      	movs	r6, #1
   18c38:	f888 3000 	strb.w	r3, [r8]
   18c3c:	e778      	b.n	18b30 <OLEDparseFixedFloat+0x4c>
			buffer[idx++] = '.';
   18c3e:	462e      	mov	r6, r5
}
   18c40:	4630      	mov	r0, r6
   18c42:	b005      	add	sp, #20
   18c44:	ecbd 8b02 	vpop	{d8}
   18c48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00018c4c <MX_GPIO_Init>:
     PA13 (JTMS/SWDIO)   ------> DEBUG_JTMS-SWDIO
     PA14 (JTCK/SWCLK)   ------> DEBUG_JTCK-SWCLK
     PB3 (JTDO/TRACESWO)   ------> DEBUG_JTDO-SWO
*/
void MX_GPIO_Init(void)
{
   18c4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
   18c50:	4b8d      	ldr	r3, [pc, #564]	; (18e88 <MX_GPIO_Init+0x23c>)
{
   18c52:	b08f      	sub	sp, #60	; 0x3c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18c54:	2400      	movs	r4, #0
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : PC14 PC4 PC6 PC7 */
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   18c56:	2501      	movs	r5, #1
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   18c58:	f8df 8238 	ldr.w	r8, [pc, #568]	; 18e94 <MX_GPIO_Init+0x248>
   18c5c:	f244 01d0 	movw	r1, #16592	; 0x40d0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18c60:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   18c62:	4622      	mov	r2, r4
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18c64:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   18c66:	4640      	mov	r0, r8
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18c68:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
   18c6a:	f8df a22c 	ldr.w	sl, [pc, #556]	; 18e98 <MX_GPIO_Init+0x24c>
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   18c6e:	f8df 922c 	ldr.w	r9, [pc, #556]	; 18e9c <MX_GPIO_Init+0x250>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
   18c72:	f8df b22c 	ldr.w	fp, [pc, #556]	; 18ea0 <MX_GPIO_Init+0x254>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18c76:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  __HAL_RCC_GPIOE_CLK_ENABLE();
   18c7a:	f8d3 60e0 	ldr.w	r6, [r3, #224]	; 0xe0
   18c7e:	f046 0610 	orr.w	r6, r6, #16
   18c82:	f8c3 60e0 	str.w	r6, [r3, #224]	; 0xe0
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

  /*Configure GPIO pins : PF7 PF8 PF9 PF10 */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   18c86:	2603      	movs	r6, #3
  __HAL_RCC_GPIOE_CLK_ENABLE();
   18c88:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18c8c:	f007 0710 	and.w	r7, r7, #16
   18c90:	9701      	str	r7, [sp, #4]
   18c92:	9f01      	ldr	r7, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
   18c94:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18c98:	f047 0704 	orr.w	r7, r7, #4
   18c9c:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18ca0:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18ca4:	f007 0704 	and.w	r7, r7, #4
   18ca8:	9702      	str	r7, [sp, #8]
   18caa:	9f02      	ldr	r7, [sp, #8]
  __HAL_RCC_GPIOF_CLK_ENABLE();
   18cac:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cb0:	f047 0720 	orr.w	r7, r7, #32
   18cb4:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18cb8:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cbc:	f007 0720 	and.w	r7, r7, #32
   18cc0:	9703      	str	r7, [sp, #12]
   18cc2:	9f03      	ldr	r7, [sp, #12]
  __HAL_RCC_GPIOH_CLK_ENABLE();
   18cc4:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cc8:	f047 0780 	orr.w	r7, r7, #128	; 0x80
   18ccc:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18cd0:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cd4:	f007 0780 	and.w	r7, r7, #128	; 0x80
   18cd8:	9704      	str	r7, [sp, #16]
   18cda:	9f04      	ldr	r7, [sp, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
   18cdc:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18ce0:	432f      	orrs	r7, r5
   18ce2:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18ce6:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cea:	402f      	ands	r7, r5
   18cec:	9705      	str	r7, [sp, #20]
   18cee:	9f05      	ldr	r7, [sp, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
   18cf0:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cf4:	f047 0702 	orr.w	r7, r7, #2
   18cf8:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18cfc:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18d00:	f007 0702 	and.w	r7, r7, #2
   18d04:	9706      	str	r7, [sp, #24]
   18d06:	9f06      	ldr	r7, [sp, #24]
  __HAL_RCC_GPIOG_CLK_ENABLE();
   18d08:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18d0c:	f047 0740 	orr.w	r7, r7, #64	; 0x40
   18d10:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18d14:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18d18:	f007 0740 	and.w	r7, r7, #64	; 0x40
   18d1c:	9707      	str	r7, [sp, #28]
   18d1e:	9f07      	ldr	r7, [sp, #28]
  __HAL_RCC_GPIOD_CLK_ENABLE();
   18d20:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18d24:	f047 0708 	orr.w	r7, r7, #8
   18d28:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18d2c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
   18d30:	4f56      	ldr	r7, [pc, #344]	; (18e8c <MX_GPIO_Init+0x240>)
  __HAL_RCC_GPIOD_CLK_ENABLE();
   18d32:	f003 0308 	and.w	r3, r3, #8
   18d36:	9308      	str	r3, [sp, #32]
   18d38:	9b08      	ldr	r3, [sp, #32]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   18d3a:	f7f3 fa7b 	bl	c234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
   18d3e:	4622      	mov	r2, r4
   18d40:	4650      	mov	r0, sl
   18d42:	2140      	movs	r1, #64	; 0x40
   18d44:	f7f3 fa76 	bl	c234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   18d48:	4622      	mov	r2, r4
   18d4a:	4648      	mov	r0, r9
   18d4c:	f44f 61ea 	mov.w	r1, #1872	; 0x750
   18d50:	f7f3 fa70 	bl	c234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
   18d54:	4622      	mov	r2, r4
   18d56:	4658      	mov	r0, fp
   18d58:	2111      	movs	r1, #17
   18d5a:	f7f3 fa6b 	bl	c234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
   18d5e:	4622      	mov	r2, r4
   18d60:	4638      	mov	r0, r7
   18d62:	f44f 6198 	mov.w	r1, #1216	; 0x4c0
   18d66:	f7f3 fa65 	bl	c234 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_13;
   18d6a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18d6e:	a909      	add	r1, sp, #36	; 0x24
   18d70:	4640      	mov	r0, r8
  GPIO_InitStruct.Pin = GPIO_PIN_13;
   18d72:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18d74:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18d78:	f7f2 ff22 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
   18d7c:	f244 03d0 	movw	r3, #16592	; 0x40d0
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18d80:	a909      	add	r1, sp, #36	; 0x24
   18d82:	4640      	mov	r0, r8
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   18d84:	e9cd 3509 	strd	r3, r5, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   18d88:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18d8c:	f7f2 ff18 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_15;
   18d90:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
   18d94:	4b3e      	ldr	r3, [pc, #248]	; (18e90 <MX_GPIO_Init+0x244>)
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18d96:	4640      	mov	r0, r8
   18d98:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18d9a:	940b      	str	r4, [sp, #44]	; 0x2c

  /*Configure GPIO pins : PD11 PD7 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18d9c:	f508 6880 	add.w	r8, r8, #1024	; 0x400
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
   18da0:	e9cd 2309 	strd	r2, r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18da4:	f7f2 ff0c 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_6;
   18da8:	2340      	movs	r3, #64	; 0x40
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   18daa:	a909      	add	r1, sp, #36	; 0x24
   18dac:	4650      	mov	r0, sl
  GPIO_InitStruct.Pin = GPIO_PIN_6;
   18dae:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   18db0:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18db2:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   18db6:	f7f2 ff03 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
   18dba:	f44f 63f0 	mov.w	r3, #1920	; 0x780
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   18dbe:	4650      	mov	r0, sl
   18dc0:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18dc2:	940b      	str	r4, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   18dc4:	e9cd 3609 	strd	r3, r6, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   18dc8:	f7f2 fefa 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15;
   18dcc:	f248 0302 	movw	r3, #32770	; 0x8002
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   18dd0:	a909      	add	r1, sp, #36	; 0x24
   18dd2:	4648      	mov	r0, r9
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15;
   18dd4:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18dd6:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   18dda:	f7f2 fef1 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   18dde:	f44f 63ea 	mov.w	r3, #1872	; 0x750
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   18de2:	4648      	mov	r0, r9
   18de4:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   18de6:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   18de8:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18dea:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   18dee:	f7f2 fee7 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
   18df2:	2311      	movs	r3, #17
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18df4:	a909      	add	r1, sp, #36	; 0x24
   18df6:	4658      	mov	r0, fp
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
   18df8:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   18dfa:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18dfc:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18e00:	f7f2 fede 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
   18e04:	f24f 0302 	movw	r3, #61442	; 0xf002
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18e08:	a909      	add	r1, sp, #36	; 0x24
   18e0a:	4658      	mov	r0, fp
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
   18e0c:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
   18e0e:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18e12:	f7f2 fed5 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_9;
   18e16:	f44f 7301 	mov.w	r3, #516	; 0x204
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18e1a:	4658      	mov	r0, fp
   18e1c:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_9;
   18e1e:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18e20:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18e24:	f7f2 fecc 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
   18e28:	f44f 6308 	mov.w	r3, #2176	; 0x880
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18e2c:	a909      	add	r1, sp, #36	; 0x24
   18e2e:	4640      	mov	r0, r8
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
   18e30:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
   18e32:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18e36:	f7f2 fec3 	bl	bbc0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG3 PG9 PG13 PG14 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_13|GPIO_PIN_14;
   18e3a:	f246 2308 	movw	r3, #25096	; 0x6208
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e3e:	a909      	add	r1, sp, #36	; 0x24
   18e40:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_13|GPIO_PIN_14;
   18e42:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18e44:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e48:	f7f2 feba 	bl	bbc0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG6 PG7 PG10 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
   18e4c:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e50:	a909      	add	r1, sp, #36	; 0x24
   18e52:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
   18e54:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   18e56:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18e58:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e5c:	f7f2 feb0 	bl	bbc0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PD3 PD4 PD5 PD6 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
   18e60:	2378      	movs	r3, #120	; 0x78
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18e62:	4640      	mov	r0, r8
   18e64:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
   18e66:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18e68:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18e6c:	f7f2 fea8 	bl	bbc0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG11 PG12 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   18e70:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e74:	a909      	add	r1, sp, #36	; 0x24
   18e76:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   18e78:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
   18e7a:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e7e:	f7f2 fe9f 	bl	bbc0 <HAL_GPIO_Init>

}
   18e82:	b00f      	add	sp, #60	; 0x3c
   18e84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18e88:	58024400 	.word	0x58024400
   18e8c:	58021800 	.word	0x58021800
   18e90:	11110000 	.word	0x11110000
   18e94:	58020800 	.word	0x58020800
   18e98:	58021400 	.word	0x58021400
   18e9c:	58020000 	.word	0x58020000
   18ea0:	58020400 	.word	0x58020400

00018ea4 <MX_I2C2_Init>:
DMA_HandleTypeDef hdma_i2c4_rx;
DMA_HandleTypeDef hdma_i2c4_tx;

/* I2C2 init function */
void MX_I2C2_Init(void)
{
   18ea4:	b538      	push	{r3, r4, r5, lr}

  hi2c2.Instance = I2C2;
   18ea6:	4b13      	ldr	r3, [pc, #76]	; (18ef4 <MX_I2C2_Init+0x50>)
  hi2c2.Init.Timing = 0x505097F4;
  hi2c2.Init.OwnAddress1 = 0;
   18ea8:	2200      	movs	r2, #0
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   18eaa:	2101      	movs	r1, #1
  hi2c2.Instance = I2C2;
   18eac:	4d12      	ldr	r5, [pc, #72]	; (18ef8 <MX_I2C2_Init+0x54>)
  hi2c2.Init.Timing = 0x505097F4;
   18eae:	4c13      	ldr	r4, [pc, #76]	; (18efc <MX_I2C2_Init+0x58>)
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
   18eb0:	4618      	mov	r0, r3
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   18eb2:	621a      	str	r2, [r3, #32]
  hi2c2.Init.Timing = 0x505097F4;
   18eb4:	e9c3 5400 	strd	r5, r4, [r3]
  hi2c2.Init.OwnAddress1 = 0;
   18eb8:	e9c3 2102 	strd	r2, r1, [r3, #8]
  hi2c2.Init.OwnAddress2 = 0;
   18ebc:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   18ec0:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
   18ec4:	f7f3 fbea 	bl	c69c <HAL_I2C_Init>
   18ec8:	b988      	cbnz	r0, 18eee <MX_I2C2_Init+0x4a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
   18eca:	2100      	movs	r1, #0
   18ecc:	4809      	ldr	r0, [pc, #36]	; (18ef4 <MX_I2C2_Init+0x50>)
   18ece:	f7f4 fffd 	bl	decc <HAL_I2CEx_ConfigAnalogFilter>
   18ed2:	b948      	cbnz	r0, 18ee8 <MX_I2C2_Init+0x44>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
   18ed4:	2100      	movs	r1, #0
   18ed6:	4807      	ldr	r0, [pc, #28]	; (18ef4 <MX_I2C2_Init+0x50>)
   18ed8:	f7f5 f850 	bl	df7c <HAL_I2CEx_ConfigDigitalFilter>
   18edc:	b900      	cbnz	r0, 18ee0 <MX_I2C2_Init+0x3c>
  {
    Error_Handler();
  }

}
   18ede:	bd38      	pop	{r3, r4, r5, pc}
   18ee0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
   18ee4:	f000 ba94 	b.w	19410 <Error_Handler>
    Error_Handler();
   18ee8:	f000 fa92 	bl	19410 <Error_Handler>
   18eec:	e7f2      	b.n	18ed4 <MX_I2C2_Init+0x30>
    Error_Handler();
   18eee:	f000 fa8f 	bl	19410 <Error_Handler>
   18ef2:	e7ea      	b.n	18eca <MX_I2C2_Init+0x26>
   18ef4:	020e3f58 	.word	0x020e3f58
   18ef8:	40005800 	.word	0x40005800
   18efc:	505097f4 	.word	0x505097f4

00018f00 <MX_I2C4_Init>:
/* I2C4 init function */
void MX_I2C4_Init(void)
{
   18f00:	b538      	push	{r3, r4, r5, lr}

  hi2c4.Instance = I2C4;
   18f02:	4b13      	ldr	r3, [pc, #76]	; (18f50 <MX_I2C4_Init+0x50>)
  hi2c4.Init.Timing = 0x307075B1;
  hi2c4.Init.OwnAddress1 = 0;
   18f04:	2200      	movs	r2, #0
  hi2c4.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   18f06:	2101      	movs	r1, #1
  hi2c4.Instance = I2C4;
   18f08:	4d12      	ldr	r5, [pc, #72]	; (18f54 <MX_I2C4_Init+0x54>)
  hi2c4.Init.Timing = 0x307075B1;
   18f0a:	4c13      	ldr	r4, [pc, #76]	; (18f58 <MX_I2C4_Init+0x58>)
  hi2c4.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c4.Init.OwnAddress2 = 0;
  hi2c4.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
   18f0c:	4618      	mov	r0, r3
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   18f0e:	621a      	str	r2, [r3, #32]
  hi2c4.Init.Timing = 0x307075B1;
   18f10:	e9c3 5400 	strd	r5, r4, [r3]
  hi2c4.Init.OwnAddress1 = 0;
   18f14:	e9c3 2102 	strd	r2, r1, [r3, #8]
  hi2c4.Init.OwnAddress2 = 0;
   18f18:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   18f1c:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
   18f20:	f7f3 fbbc 	bl	c69c <HAL_I2C_Init>
   18f24:	b988      	cbnz	r0, 18f4a <MX_I2C4_Init+0x4a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c4, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
   18f26:	2100      	movs	r1, #0
   18f28:	4809      	ldr	r0, [pc, #36]	; (18f50 <MX_I2C4_Init+0x50>)
   18f2a:	f7f4 ffcf 	bl	decc <HAL_I2CEx_ConfigAnalogFilter>
   18f2e:	b948      	cbnz	r0, 18f44 <MX_I2C4_Init+0x44>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c4, 0) != HAL_OK)
   18f30:	2100      	movs	r1, #0
   18f32:	4807      	ldr	r0, [pc, #28]	; (18f50 <MX_I2C4_Init+0x50>)
   18f34:	f7f5 f822 	bl	df7c <HAL_I2CEx_ConfigDigitalFilter>
   18f38:	b900      	cbnz	r0, 18f3c <MX_I2C4_Init+0x3c>
  {
    Error_Handler();
  }

}
   18f3a:	bd38      	pop	{r3, r4, r5, pc}
   18f3c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
   18f40:	f000 ba66 	b.w	19410 <Error_Handler>
    Error_Handler();
   18f44:	f000 fa64 	bl	19410 <Error_Handler>
   18f48:	e7f2      	b.n	18f30 <MX_I2C4_Init+0x30>
    Error_Handler();
   18f4a:	f000 fa61 	bl	19410 <Error_Handler>
   18f4e:	e7ea      	b.n	18f26 <MX_I2C4_Init+0x26>
   18f50:	020e3f0c 	.word	0x020e3f0c
   18f54:	58001c00 	.word	0x58001c00
   18f58:	307075b1 	.word	0x307075b1

00018f5c <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
   18f5c:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(i2cHandle->Instance==I2C2)
   18f5e:	4a50      	ldr	r2, [pc, #320]	; (190a0 <HAL_I2C_MspInit+0x144>)
{
   18f60:	b08b      	sub	sp, #44	; 0x2c
  if(i2cHandle->Instance==I2C2)
   18f62:	6803      	ldr	r3, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18f64:	2400      	movs	r4, #0
  if(i2cHandle->Instance==I2C2)
   18f66:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18f68:	9409      	str	r4, [sp, #36]	; 0x24
   18f6a:	e9cd 4405 	strd	r4, r4, [sp, #20]
   18f6e:	e9cd 4407 	strd	r4, r4, [sp, #28]
  if(i2cHandle->Instance==I2C2)
   18f72:	d069      	beq.n	19048 <HAL_I2C_MspInit+0xec>
    __HAL_RCC_I2C2_CLK_ENABLE();
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
   18f74:	4a4b      	ldr	r2, [pc, #300]	; (190a4 <HAL_I2C_MspInit+0x148>)
   18f76:	4293      	cmp	r3, r2
   18f78:	d001      	beq.n	18f7e <HAL_I2C_MspInit+0x22>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
  /* USER CODE BEGIN I2C4_MspInit 1 */

  /* USER CODE END I2C4_MspInit 1 */
  }
}
   18f7a:	b00b      	add	sp, #44	; 0x2c
   18f7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18f7e:	4f4a      	ldr	r7, [pc, #296]	; (190a8 <HAL_I2C_MspInit+0x14c>)
   18f80:	4605      	mov	r5, r0
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
   18f82:	f44f 5040 	mov.w	r0, #12288	; 0x3000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   18f86:	2212      	movs	r2, #18
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18f88:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18f8c:	a905      	add	r1, sp, #20
    hdma_i2c4_rx.Instance = BDMA_Channel0;
   18f8e:	4e47      	ldr	r6, [pc, #284]	; (190ac <HAL_I2C_MspInit+0x150>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18f90:	f043 0308 	orr.w	r3, r3, #8
   18f94:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
   18f98:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
   18f9c:	9005      	str	r0, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
   18f9e:	2001      	movs	r0, #1
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18fa0:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   18fa4:	9206      	str	r2, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
   18fa6:	2204      	movs	r2, #4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
   18fa8:	9008      	str	r0, [sp, #32]
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18faa:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18fac:	4840      	ldr	r0, [pc, #256]	; (190b0 <HAL_I2C_MspInit+0x154>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18fae:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
   18fb0:	9209      	str	r2, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18fb2:	f7f2 fe05 	bl	bbc0 <HAL_GPIO_Init>
    __HAL_RCC_I2C4_CLK_ENABLE();
   18fb6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
    hdma_i2c4_rx.Init.Request = BDMA_REQUEST_I2C4_RX;
   18fba:	210d      	movs	r1, #13
    hdma_i2c4_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
   18fbc:	60b4      	str	r4, [r6, #8]
    hdma_i2c4_rx.Init.MemInc = DMA_MINC_ENABLE;
   18fbe:	f44f 6280 	mov.w	r2, #1024	; 0x400
    __HAL_RCC_I2C4_CLK_ENABLE();
   18fc2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    if (HAL_DMA_Init(&hdma_i2c4_rx) != HAL_OK)
   18fc6:	4630      	mov	r0, r6
    __HAL_RCC_I2C4_CLK_ENABLE();
   18fc8:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
   18fcc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
    hdma_i2c4_rx.Init.PeriphInc = DMA_PINC_DISABLE;
   18fd0:	60f4      	str	r4, [r6, #12]
    __HAL_RCC_I2C4_CLK_ENABLE();
   18fd2:	f003 0380 	and.w	r3, r3, #128	; 0x80
    hdma_i2c4_rx.Init.MemInc = DMA_MINC_ENABLE;
   18fd6:	6132      	str	r2, [r6, #16]
    __HAL_RCC_I2C4_CLK_ENABLE();
   18fd8:	9304      	str	r3, [sp, #16]
   18fda:	9b04      	ldr	r3, [sp, #16]
    hdma_i2c4_rx.Instance = BDMA_Channel0;
   18fdc:	4b35      	ldr	r3, [pc, #212]	; (190b4 <HAL_I2C_MspInit+0x158>)
    hdma_i2c4_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
   18fde:	e9c6 4405 	strd	r4, r4, [r6, #20]
    hdma_i2c4_rx.Init.Priority = DMA_PRIORITY_LOW;
   18fe2:	e9c6 4407 	strd	r4, r4, [r6, #28]
    hdma_i2c4_rx.Instance = BDMA_Channel0;
   18fe6:	e9c6 3100 	strd	r3, r1, [r6]
    if (HAL_DMA_Init(&hdma_i2c4_rx) != HAL_OK)
   18fea:	f7f0 febf 	bl	9d6c <HAL_DMA_Init>
   18fee:	2800      	cmp	r0, #0
   18ff0:	d153      	bne.n	1909a <HAL_I2C_MspInit+0x13e>
    hdma_i2c4_tx.Instance = BDMA_Channel1;
   18ff2:	4c31      	ldr	r4, [pc, #196]	; (190b8 <HAL_I2C_MspInit+0x15c>)
    hdma_i2c4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
   18ff4:	2300      	movs	r3, #0
    hdma_i2c4_tx.Instance = BDMA_Channel1;
   18ff6:	4831      	ldr	r0, [pc, #196]	; (190bc <HAL_I2C_MspInit+0x160>)
    hdma_i2c4_tx.Init.Request = BDMA_REQUEST_I2C4_TX;
   18ff8:	270e      	movs	r7, #14
    hdma_i2c4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
   18ffa:	2140      	movs	r1, #64	; 0x40
    hdma_i2c4_tx.Init.MemInc = DMA_MINC_ENABLE;
   18ffc:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_i2c4_tx.Instance = BDMA_Channel1;
   19000:	6020      	str	r0, [r4, #0]
    if (HAL_DMA_Init(&hdma_i2c4_tx) != HAL_OK)
   19002:	4620      	mov	r0, r4
    __HAL_LINKDMA(i2cHandle,hdmarx,hdma_i2c4_rx);
   19004:	63ee      	str	r6, [r5, #60]	; 0x3c
   19006:	63b5      	str	r5, [r6, #56]	; 0x38
    hdma_i2c4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
   19008:	e9c4 7101 	strd	r7, r1, [r4, #4]
    hdma_i2c4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
   1900c:	e9c4 3203 	strd	r3, r2, [r4, #12]
    hdma_i2c4_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
   19010:	e9c4 3305 	strd	r3, r3, [r4, #20]
    hdma_i2c4_tx.Init.Priority = DMA_PRIORITY_LOW;
   19014:	e9c4 3307 	strd	r3, r3, [r4, #28]
    if (HAL_DMA_Init(&hdma_i2c4_tx) != HAL_OK)
   19018:	f7f0 fea8 	bl	9d6c <HAL_DMA_Init>
   1901c:	2800      	cmp	r0, #0
   1901e:	d139      	bne.n	19094 <HAL_I2C_MspInit+0x138>
    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c4_tx);
   19020:	63ac      	str	r4, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 7, 0);
   19022:	2200      	movs	r2, #0
   19024:	2107      	movs	r1, #7
   19026:	205f      	movs	r0, #95	; 0x5f
    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c4_tx);
   19028:	63a5      	str	r5, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 7, 0);
   1902a:	f7f0 fcd3 	bl	99d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_EV_IRQn);
   1902e:	205f      	movs	r0, #95	; 0x5f
   19030:	f7f0 fd16 	bl	9a60 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C4_ER_IRQn, 7, 0);
   19034:	2200      	movs	r2, #0
   19036:	2107      	movs	r1, #7
   19038:	2060      	movs	r0, #96	; 0x60
   1903a:	f7f0 fccb 	bl	99d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
   1903e:	2060      	movs	r0, #96	; 0x60
   19040:	f7f0 fd0e 	bl	9a60 <HAL_NVIC_EnableIRQ>
}
   19044:	b00b      	add	sp, #44	; 0x2c
   19046:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
   19048:	4c17      	ldr	r4, [pc, #92]	; (190a8 <HAL_I2C_MspInit+0x14c>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
   1904a:	2204      	movs	r2, #4
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   1904c:	f44f 6640 	mov.w	r6, #3072	; 0xc00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   19050:	2512      	movs	r5, #18
    __HAL_RCC_GPIOB_CLK_ENABLE();
   19052:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   19056:	a905      	add	r1, sp, #20
   19058:	4819      	ldr	r0, [pc, #100]	; (190c0 <HAL_I2C_MspInit+0x164>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
   1905a:	f043 0302 	orr.w	r3, r3, #2
   1905e:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
   19062:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   19066:	9605      	str	r6, [sp, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
   19068:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   1906c:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
   1906e:	9209      	str	r2, [sp, #36]	; 0x24
    __HAL_RCC_GPIOB_CLK_ENABLE();
   19070:	9301      	str	r3, [sp, #4]
   19072:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   19074:	f7f2 fda4 	bl	bbc0 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
   19078:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
   1907c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   19080:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
   19084:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
   19088:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
   1908c:	9302      	str	r3, [sp, #8]
   1908e:	9b02      	ldr	r3, [sp, #8]
}
   19090:	b00b      	add	sp, #44	; 0x2c
   19092:	bdf0      	pop	{r4, r5, r6, r7, pc}
      Error_Handler();
   19094:	f000 f9bc 	bl	19410 <Error_Handler>
   19098:	e7c2      	b.n	19020 <HAL_I2C_MspInit+0xc4>
      Error_Handler();
   1909a:	f000 f9b9 	bl	19410 <Error_Handler>
   1909e:	e7a8      	b.n	18ff2 <HAL_I2C_MspInit+0x96>
   190a0:	40005800 	.word	0x40005800
   190a4:	58001c00 	.word	0x58001c00
   190a8:	58024400 	.word	0x58024400
   190ac:	020e3fa4 	.word	0x020e3fa4
   190b0:	58020c00 	.word	0x58020c00
   190b4:	58025408 	.word	0x58025408
   190b8:	020e3e94 	.word	0x020e3e94
   190bc:	5802541c 	.word	0x5802541c
   190c0:	58020400 	.word	0x58020400

000190c4 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{

  if(i2cHandle->Instance==I2C2)
   190c4:	4a18      	ldr	r2, [pc, #96]	; (19128 <HAL_I2C_MspDeInit+0x64>)
   190c6:	6803      	ldr	r3, [r0, #0]
   190c8:	4293      	cmp	r3, r2
   190ca:	d020      	beq.n	1910e <HAL_I2C_MspDeInit+0x4a>

  /* USER CODE BEGIN I2C2_MspDeInit 1 */

  /* USER CODE END I2C2_MspDeInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
   190cc:	4a17      	ldr	r2, [pc, #92]	; (1912c <HAL_I2C_MspDeInit+0x68>)
   190ce:	4293      	cmp	r3, r2
   190d0:	d000      	beq.n	190d4 <HAL_I2C_MspDeInit+0x10>
   190d2:	4770      	bx	lr
  {
  /* USER CODE BEGIN I2C4_MspDeInit 0 */

  /* USER CODE END I2C4_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C4_CLK_DISABLE();
   190d4:	f502 320a 	add.w	r2, r2, #141312	; 0x22800
  
    /**I2C4 GPIO Configuration    
    PD12     ------> I2C4_SCL
    PD13     ------> I2C4_SDA 
    */
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
   190d8:	f44f 5140 	mov.w	r1, #12288	; 0x3000
{
   190dc:	b510      	push	{r4, lr}
    __HAL_RCC_I2C4_CLK_DISABLE();
   190de:	f8d2 30f4 	ldr.w	r3, [r2, #244]	; 0xf4
   190e2:	4604      	mov	r4, r0
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
   190e4:	4812      	ldr	r0, [pc, #72]	; (19130 <HAL_I2C_MspDeInit+0x6c>)
    __HAL_RCC_I2C4_CLK_DISABLE();
   190e6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   190ea:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
   190ee:	f7f2 ff71 	bl	bfd4 <HAL_GPIO_DeInit>

    /* I2C4 DMA DeInit */
    HAL_DMA_DeInit(i2cHandle->hdmarx);
   190f2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   190f4:	f7f1 fa6a 	bl	a5cc <HAL_DMA_DeInit>
    HAL_DMA_DeInit(i2cHandle->hdmatx);
   190f8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   190fa:	f7f1 fa67 	bl	a5cc <HAL_DMA_DeInit>

    /* I2C4 interrupt Deinit */
    HAL_NVIC_DisableIRQ(I2C4_EV_IRQn);
   190fe:	205f      	movs	r0, #95	; 0x5f
   19100:	f7f0 fcc2 	bl	9a88 <HAL_NVIC_DisableIRQ>
    HAL_NVIC_DisableIRQ(I2C4_ER_IRQn);
   19104:	2060      	movs	r0, #96	; 0x60
  /* USER CODE BEGIN I2C4_MspDeInit 1 */

  /* USER CODE END I2C4_MspDeInit 1 */
  }
} 
   19106:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(I2C4_ER_IRQn);
   1910a:	f7f0 bcbd 	b.w	9a88 <HAL_NVIC_DisableIRQ>
    __HAL_RCC_I2C2_CLK_DISABLE();
   1910e:	4a09      	ldr	r2, [pc, #36]	; (19134 <HAL_I2C_MspDeInit+0x70>)
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
   19110:	f44f 6140 	mov.w	r1, #3072	; 0xc00
   19114:	4808      	ldr	r0, [pc, #32]	; (19138 <HAL_I2C_MspDeInit+0x74>)
    __HAL_RCC_I2C2_CLK_DISABLE();
   19116:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
   1911a:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   1911e:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
   19122:	f7f2 bf57 	b.w	bfd4 <HAL_GPIO_DeInit>
   19126:	bf00      	nop
   19128:	40005800 	.word	0x40005800
   1912c:	58001c00 	.word	0x58001c00
   19130:	58020c00 	.word	0x58020c00
   19134:	58024400 	.word	0x58024400
   19138:	58020400 	.word	0x58020400

0001913c <SCB_EnableDCache>:
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
   1913c:	4816      	ldr	r0, [pc, #88]	; (19198 <SCB_EnableDCache+0x5c>)
   1913e:	2300      	movs	r3, #0
{
   19140:	b4f0      	push	{r4, r5, r6, r7}
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
   19142:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
   19146:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
   1914a:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   1914e:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
   19152:	f3c5 06c9 	ubfx	r6, r5, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
   19156:	f3c5 354e 	ubfx	r5, r5, #13, #15
   1915a:	07b7      	lsls	r7, r6, #30
   1915c:	016d      	lsls	r5, r5, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   1915e:	ea05 040c 	and.w	r4, r5, ip
   19162:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
   19164:	4632      	mov	r2, r6
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   19166:	ea44 0301 	orr.w	r3, r4, r1
      } while (ways-- != 0U);
   1916a:	3a01      	subs	r2, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   1916c:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
   19170:	f8c0 3260 	str.w	r3, [r0, #608]	; 0x260
      } while (ways-- != 0U);
   19174:	1c53      	adds	r3, r2, #1
   19176:	d1f6      	bne.n	19166 <SCB_EnableDCache+0x2a>
   19178:	3d20      	subs	r5, #32
    } while(sets-- != 0U);
   1917a:	f115 0f20 	cmn.w	r5, #32
   1917e:	d1ee      	bne.n	1915e <SCB_EnableDCache+0x22>
   19180:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
   19184:	6943      	ldr	r3, [r0, #20]
   19186:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1918a:	6143      	str	r3, [r0, #20]
   1918c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   19190:	f3bf 8f6f 	isb	sy
}
   19194:	bcf0      	pop	{r4, r5, r6, r7}
   19196:	4770      	bx	lr
   19198:	e000ed00 	.word	0xe000ed00

0001919c <SystemClock_Config>:
{
   1919c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   191a0:	b0cc      	sub	sp, #304	; 0x130
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
   191a2:	224c      	movs	r2, #76	; 0x4c
   191a4:	2100      	movs	r1, #0
   191a6:	a80a      	add	r0, sp, #40	; 0x28
   191a8:	f013 fb9b 	bl	2c8e2 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
   191ac:	2220      	movs	r2, #32
   191ae:	2100      	movs	r1, #0
   191b0:	a802      	add	r0, sp, #8
   191b2:	f013 fb96 	bl	2c8e2 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
   191b6:	22bc      	movs	r2, #188	; 0xbc
   191b8:	2100      	movs	r1, #0
   191ba:	a81d      	add	r0, sp, #116	; 0x74
   191bc:	f013 fb91 	bl	2c8e2 <memset>
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
   191c0:	2002      	movs	r0, #2
   191c2:	f7f4 ff31 	bl	e028 <HAL_PWREx_ConfigSupply>
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
   191c6:	4b3f      	ldr	r3, [pc, #252]	; (192c4 <SystemClock_Config+0x128>)
   191c8:	2100      	movs	r1, #0
   191ca:	4a3f      	ldr	r2, [pc, #252]	; (192c8 <SystemClock_Config+0x12c>)
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
   191cc:	4618      	mov	r0, r3
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
   191ce:	9101      	str	r1, [sp, #4]
   191d0:	6999      	ldr	r1, [r3, #24]
   191d2:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
   191d6:	6199      	str	r1, [r3, #24]
   191d8:	699b      	ldr	r3, [r3, #24]
   191da:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
   191de:	9301      	str	r3, [sp, #4]
   191e0:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   191e2:	f043 0301 	orr.w	r3, r3, #1
   191e6:	62d3      	str	r3, [r2, #44]	; 0x2c
   191e8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   191ea:	f003 0301 	and.w	r3, r3, #1
   191ee:	9301      	str	r3, [sp, #4]
   191f0:	9b01      	ldr	r3, [sp, #4]
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
   191f2:	6983      	ldr	r3, [r0, #24]
   191f4:	049b      	lsls	r3, r3, #18
   191f6:	d5fc      	bpl.n	191f2 <SystemClock_Config+0x56>
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   191f8:	4a34      	ldr	r2, [pc, #208]	; (192cc <SystemClock_Config+0x130>)
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   191fa:	2402      	movs	r4, #2
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
   191fc:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
   19200:	f04f 0c21 	mov.w	ip, #33	; 0x21
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   19204:	6a93      	ldr	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
   19206:	2501      	movs	r5, #1
  RCC_OscInitStruct.PLL.PLLM = 10;
   19208:	210a      	movs	r1, #10
  RCC_OscInitStruct.PLL.PLLN = 384;
   1920a:	f44f 76c0 	mov.w	r6, #384	; 0x180
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   1920e:	f023 0303 	bic.w	r3, r3, #3
  RCC_OscInitStruct.PLL.PLLQ = 3;
   19212:	2703      	movs	r7, #3
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_1;
   19214:	f04f 0804 	mov.w	r8, #4
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   19218:	4323      	orrs	r3, r4
   1921a:	6293      	str	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
   1921c:	2300      	movs	r3, #0
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
   1921e:	900b      	str	r0, [sp, #44]	; 0x2c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   19220:	a80a      	add	r0, sp, #40	; 0x28
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
   19222:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
   19226:	9510      	str	r5, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = 2;
   19228:	9417      	str	r4, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLR = 2;
   1922a:	9419      	str	r4, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLQ = 3;
   1922c:	9718      	str	r7, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
   1922e:	931c      	str	r3, [sp, #112]	; 0x70
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
   19230:	e9cd 4413 	strd	r4, r4, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLN = 384;
   19234:	e9cd 1615 	strd	r1, r6, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
   19238:	e9cd 831a 	strd	r8, r3, [sp, #104]	; 0x68
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   1923c:	f7f4 ff34 	bl	e0a8 <HAL_RCC_OscConfig>
   19240:	b100      	cbz	r0, 19244 <SystemClock_Config+0xa8>
   19242:	e7fe      	b.n	19242 <SystemClock_Config+0xa6>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
   19244:	223f      	movs	r2, #63	; 0x3f
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   19246:	9703      	str	r7, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
   19248:	2708      	movs	r7, #8
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
   1924a:	2340      	movs	r3, #64	; 0x40
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
   1924c:	9202      	str	r2, [sp, #8]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
   1924e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
   19252:	9004      	str	r0, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
   19254:	4641      	mov	r1, r8
   19256:	eb0d 0007 	add.w	r0, sp, r7
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
   1925a:	9705      	str	r7, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
   1925c:	e9cd 3306 	strd	r3, r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
   19260:	e9cd 2308 	strd	r2, r3, [sp, #32]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
   19264:	f7f5 fb46 	bl	e8f4 <HAL_RCC_ClockConfig>
   19268:	4603      	mov	r3, r0
   1926a:	b100      	cbz	r0, 1926e <SystemClock_Config+0xd2>
   1926c:	e7fe      	b.n	1926c <SystemClock_Config+0xd0>
  PeriphClkInitStruct.PLL2.PLL2M = 25;
   1926e:	2219      	movs	r2, #25
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_SAI1
   19270:	f8df e05c 	ldr.w	lr, [pc, #92]	; 192d0 <SystemClock_Config+0x134>
  PeriphClkInitStruct.PLL2.PLL2N = 344;
   19274:	f44f 7cac 	mov.w	ip, #344	; 0x158
  PeriphClkInitStruct.PLL3.PLL3N = 384;
   19278:	9627      	str	r6, [sp, #156]	; 0x9c
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
   1927a:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  PeriphClkInitStruct.PLL2.PLL2P = 7;
   1927e:	2607      	movs	r6, #7
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
   19280:	a81d      	add	r0, sp, #116	; 0x74
  PeriphClkInitStruct.PLL2.PLL2Q = 2;
   19282:	9421      	str	r4, [sp, #132]	; 0x84
  PeriphClkInitStruct.PLL2.PLL2R = 1;
   19284:	9522      	str	r5, [sp, #136]	; 0x88
  PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
   19286:	9325      	str	r3, [sp, #148]	; 0x94
  PeriphClkInitStruct.FmcClockSelection = RCC_FMCCLKSOURCE_D1HCLK;
   19288:	932e      	str	r3, [sp, #184]	; 0xb8
  PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
   1928a:	9330      	str	r3, [sp, #192]	; 0xc0
  PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLL2;
   1928c:	9532      	str	r5, [sp, #200]	; 0xc8
  PeriphClkInitStruct.I2c4ClockSelection = RCC_I2C4CLKSOURCE_D3PCLK1;
   1928e:	9342      	str	r3, [sp, #264]	; 0x108
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
   19290:	9345      	str	r3, [sp, #276]	; 0x114
  PeriphClkInitStruct.PLL3.PLL3M = 25;
   19292:	9226      	str	r2, [sp, #152]	; 0x98
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
   19294:	913e      	str	r1, [sp, #248]	; 0xf8
  PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOWIDE;
   19296:	e9cd 3323 	strd	r3, r3, [sp, #140]	; 0x8c
  PeriphClkInitStruct.PLL3.PLL3Q = 8;
   1929a:	e9cd 4728 	strd	r4, r7, [sp, #160]	; 0xa0
  PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_0;
   1929e:	e9cd 432a 	strd	r4, r3, [sp, #168]	; 0xa8
  PeriphClkInitStruct.PLL3.PLL3FRACN = 0;
   192a2:	e9cd 332c 	strd	r3, r3, [sp, #176]	; 0xb0
  PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
   192a6:	e9cd 333c 	strd	r3, r3, [sp, #240]	; 0xf0
  PeriphClkInitStruct.PLL2.PLL2M = 25;
   192aa:	e9cd e21d 	strd	lr, r2, [sp, #116]	; 0x74
  PeriphClkInitStruct.PLL2.PLL2P = 7;
   192ae:	e9cd c61f 	strd	ip, r6, [sp, #124]	; 0x7c
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
   192b2:	f7f5 ffb7 	bl	f224 <HAL_RCCEx_PeriphCLKConfig>
   192b6:	b100      	cbz	r0, 192ba <SystemClock_Config+0x11e>
   192b8:	e7fe      	b.n	192b8 <SystemClock_Config+0x11c>
  HAL_PWREx_EnableUSBVoltageDetector();
   192ba:	f7f4 fee5 	bl	e088 <HAL_PWREx_EnableUSBVoltageDetector>
}
   192be:	b04c      	add	sp, #304	; 0x130
   192c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   192c4:	58024800 	.word	0x58024800
   192c8:	58000400 	.word	0x58000400
   192cc:	58024400 	.word	0x58024400
   192d0:	010f0118 	.word	0x010f0118

000192d4 <HAL_ADC_ConvCpltCallback>:
}
   192d4:	4770      	bx	lr
   192d6:	bf00      	nop

000192d8 <HAL_ADC_ConvHalfCpltCallback>:
   192d8:	4770      	bx	lr
   192da:	bf00      	nop

000192dc <SDRAM_Initialization_sequence>:
{
   192dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   192e0:	4c2b      	ldr	r4, [pc, #172]	; (19390 <SDRAM_Initialization_sequence+0xb4>)
{
   192e2:	b087      	sub	sp, #28
    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
   192e4:	2501      	movs	r5, #1
    __IO uint32_t tmpmrd = 0;
   192e6:	2600      	movs	r6, #0
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   192e8:	2710      	movs	r7, #16
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   192ea:	a902      	add	r1, sp, #8
   192ec:	f64f 72ff 	movw	r2, #65535	; 0xffff
   192f0:	4620      	mov	r0, r4
    Command.AutoRefreshNumber = 8;
   192f2:	f04f 0808 	mov.w	r8, #8
    __IO uint32_t tmpmrd = 0;
   192f6:	9601      	str	r6, [sp, #4]
    Command.ModeRegisterDefinition = 0;
   192f8:	9605      	str	r6, [sp, #20]
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
   192fa:	f04f 0903 	mov.w	r9, #3
    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
   192fe:	9502      	str	r5, [sp, #8]
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   19300:	e9cd 7503 	strd	r7, r5, [sp, #12]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19304:	f7f8 fe9e 	bl	12044 <HAL_SDRAM_SendCommand>
    HAL_Delay(1);
   19308:	4628      	mov	r0, r5
   1930a:	f7ef f879 	bl	8400 <HAL_Delay>
    Command.CommandMode = FMC_SDRAM_CMD_PALL;
   1930e:	2302      	movs	r3, #2
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19310:	eb0d 0108 	add.w	r1, sp, r8
   19314:	4620      	mov	r0, r4
   19316:	f64f 72ff 	movw	r2, #65535	; 0xffff
    Command.CommandMode = FMC_SDRAM_CMD_PALL;
   1931a:	9302      	str	r3, [sp, #8]
    Command.ModeRegisterDefinition = 0;
   1931c:	9605      	str	r6, [sp, #20]
    Command.AutoRefreshNumber = 1;
   1931e:	e9cd 7503 	strd	r7, r5, [sp, #12]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19322:	f7f8 fe8f 	bl	12044 <HAL_SDRAM_SendCommand>
    tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_4 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL
   19326:	f240 2222 	movw	r2, #546	; 0x222
    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
   1932a:	2304      	movs	r3, #4
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1932c:	eb0d 0108 	add.w	r1, sp, r8
    tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_4 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL
   19330:	9201      	str	r2, [sp, #4]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19332:	4620      	mov	r0, r4
    Command.ModeRegisterDefinition = tmpmrd;
   19334:	f8dd c004 	ldr.w	ip, [sp, #4]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19338:	f64f 72ff 	movw	r2, #65535	; 0xffff
    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
   1933c:	9302      	str	r3, [sp, #8]
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   1933e:	9703      	str	r7, [sp, #12]
    Command.ModeRegisterDefinition = tmpmrd;
   19340:	e9cd 5c04 	strd	r5, ip, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19344:	f7f8 fe7e 	bl	12044 <HAL_SDRAM_SendCommand>
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19348:	eb0d 0108 	add.w	r1, sp, r8
   1934c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   19350:	4620      	mov	r0, r4
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   19352:	9703      	str	r7, [sp, #12]
    Command.ModeRegisterDefinition = 0;
   19354:	9605      	str	r6, [sp, #20]
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
   19356:	f8cd 9008 	str.w	r9, [sp, #8]
    Command.AutoRefreshNumber = 8;
   1935a:	f8cd 8010 	str.w	r8, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1935e:	f7f8 fe71 	bl	12044 <HAL_SDRAM_SendCommand>
    HAL_Delay(1);
   19362:	4628      	mov	r0, r5
   19364:	f7ef f84c 	bl	8400 <HAL_Delay>
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19368:	eb0d 0108 	add.w	r1, sp, r8
   1936c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   19370:	4620      	mov	r0, r4
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   19372:	e9cd 9702 	strd	r9, r7, [sp, #8]
    Command.ModeRegisterDefinition = 0;
   19376:	e9cd 8604 	strd	r8, r6, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1937a:	f7f8 fe63 	bl	12044 <HAL_SDRAM_SendCommand>
    HAL_SDRAM_ProgramRefreshRate(&hsdram1, SDRAM_REFRESH_COUNT);
   1937e:	f240 5169 	movw	r1, #1385	; 0x569
   19382:	4620      	mov	r0, r4
   19384:	f7f8 fe80 	bl	12088 <HAL_SDRAM_ProgramRefreshRate>
}
   19388:	b007      	add	sp, #28
   1938a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1938e:	bf00      	nop
   19390:	020e3e60 	.word	0x020e3e60

00019394 <randomNumber>:
float randomNumber(void) {
   19394:	b500      	push	{lr}
   19396:	b083      	sub	sp, #12
	HAL_RNG_GenerateRandomNumber(&hrng, &rand);
   19398:	4807      	ldr	r0, [pc, #28]	; (193b8 <randomNumber+0x24>)
   1939a:	a901      	add	r1, sp, #4
   1939c:	f7f7 f8d8 	bl	10550 <HAL_RNG_GenerateRandomNumber>
	float num = (float)rand * INV_TWO_TO_32;
   193a0:	eddd 7a01 	vldr	s15, [sp, #4]
   193a4:	ed9f 0a05 	vldr	s0, [pc, #20]	; 193bc <randomNumber+0x28>
   193a8:	eef8 7a67 	vcvt.f32.u32	s15, s15
}
   193ac:	ee27 0a80 	vmul.f32	s0, s15, s0
   193b0:	b003      	add	sp, #12
   193b2:	f85d fb04 	ldr.w	pc, [sp], #4
   193b6:	bf00      	nop
   193b8:	020e455c 	.word	0x020e455c
   193bc:	2f80000d 	.word	0x2f80000d

000193c0 <MPU_Conf>:
{
   193c0:	b510      	push	{r4, lr}
   193c2:	b084      	sub	sp, #16
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   193c4:	2400      	movs	r4, #0
	HAL_MPU_Disable();
   193c6:	f7f0 fb91 	bl	9aec <HAL_MPU_Disable>
  MPU_InitStruct.BaseAddress = 0x30000000;
   193ca:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   193ce:	f240 1201 	movw	r2, #257	; 0x101
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   193d2:	4b0d      	ldr	r3, [pc, #52]	; (19408 <MPU_Conf+0x48>)
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   193d4:	4668      	mov	r0, sp
  MPU_InitStruct.BaseAddress = 0x30000000;
   193d6:	9101      	str	r1, [sp, #4]
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   193d8:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   193dc:	e9cd 3402 	strd	r3, r4, [sp, #8]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   193e0:	f7f0 fba6 	bl	9b30 <HAL_MPU_ConfigRegion>
  MPU_InitStruct.BaseAddress = 0x38000000;
   193e4:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   193e8:	f240 2201 	movw	r2, #513	; 0x201
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
   193ec:	4b07      	ldr	r3, [pc, #28]	; (1940c <MPU_Conf+0x4c>)
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   193ee:	4668      	mov	r0, sp
  MPU_InitStruct.BaseAddress = 0x38000000;
   193f0:	9101      	str	r1, [sp, #4]
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   193f2:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
   193f6:	9302      	str	r3, [sp, #8]
   193f8:	9403      	str	r4, [sp, #12]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   193fa:	f7f0 fb99 	bl	9b30 <HAL_MPU_ConfigRegion>
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
   193fe:	2004      	movs	r0, #4
   19400:	f7f0 fb84 	bl	9b0c <HAL_MPU_Enable>
}
   19404:	b004      	add	sp, #16
   19406:	bd10      	pop	{r4, pc}
   19408:	03010011 	.word	0x03010011
   1940c:	0301000f 	.word	0x0301000f

00019410 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
   19410:	e7fe      	b.n	19410 <Error_Handler>
   19412:	bf00      	nop

00019414 <assert_failed>:
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
   19414:	4770      	bx	lr
   19416:	bf00      	nop

00019418 <setLED_Edit>:
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
}

void setLED_Edit(uint8_t onOff)
{
	if (onOff)
   19418:	b920      	cbnz	r0, 19424 <setLED_Edit+0xc>
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_RESET);
   1941a:	4602      	mov	r2, r0
   1941c:	2180      	movs	r1, #128	; 0x80
   1941e:	4804      	ldr	r0, [pc, #16]	; (19430 <setLED_Edit+0x18>)
   19420:	f7f2 bf08 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
   19424:	2201      	movs	r2, #1
   19426:	2180      	movs	r1, #128	; 0x80
   19428:	4801      	ldr	r0, [pc, #4]	; (19430 <setLED_Edit+0x18>)
   1942a:	f7f2 bf03 	b.w	c234 <HAL_GPIO_WritePin>
   1942e:	bf00      	nop
   19430:	58020800 	.word	0x58020800

00019434 <setLED_USB>:
}


void setLED_USB(uint8_t onOff)
{
	if (onOff)
   19434:	b920      	cbnz	r0, 19440 <setLED_USB+0xc>
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);
   19436:	4602      	mov	r2, r0
   19438:	2140      	movs	r1, #64	; 0x40
   1943a:	4804      	ldr	r0, [pc, #16]	; (1944c <setLED_USB+0x18>)
   1943c:	f7f2 befa 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
   19440:	2201      	movs	r2, #1
   19442:	2140      	movs	r1, #64	; 0x40
   19444:	4801      	ldr	r0, [pc, #4]	; (1944c <setLED_USB+0x18>)
   19446:	f7f2 bef5 	b.w	c234 <HAL_GPIO_WritePin>
   1944a:	bf00      	nop
   1944c:	58021800 	.word	0x58021800

00019450 <setLED_1>:
}


void setLED_1(uint8_t onOff)
{
	if (onOff)
   19450:	b928      	cbnz	r0, 1945e <setLED_1+0xe>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET);
   19452:	4602      	mov	r2, r0
   19454:	f44f 6180 	mov.w	r1, #1024	; 0x400
   19458:	4804      	ldr	r0, [pc, #16]	; (1946c <setLED_1+0x1c>)
   1945a:	f7f2 beeb 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
   1945e:	2201      	movs	r2, #1
   19460:	f44f 6180 	mov.w	r1, #1024	; 0x400
   19464:	4801      	ldr	r0, [pc, #4]	; (1946c <setLED_1+0x1c>)
   19466:	f7f2 bee5 	b.w	c234 <HAL_GPIO_WritePin>
   1946a:	bf00      	nop
   1946c:	58020000 	.word	0x58020000

00019470 <setLED_2>:
	}
}

void setLED_2(uint8_t onOff)
{
	if (onOff)
   19470:	b928      	cbnz	r0, 1947e <setLED_2+0xe>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
   19472:	4602      	mov	r2, r0
   19474:	f44f 7180 	mov.w	r1, #256	; 0x100
   19478:	4804      	ldr	r0, [pc, #16]	; (1948c <setLED_2+0x1c>)
   1947a:	f7f2 bedb 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
   1947e:	2201      	movs	r2, #1
   19480:	f44f 7180 	mov.w	r1, #256	; 0x100
   19484:	4801      	ldr	r0, [pc, #4]	; (1948c <setLED_2+0x1c>)
   19486:	f7f2 bed5 	b.w	c234 <HAL_GPIO_WritePin>
   1948a:	bf00      	nop
   1948c:	58020000 	.word	0x58020000

00019490 <setLED_A>:
}


void setLED_A(uint8_t onOff)
{
	if (onOff)
   19490:	b920      	cbnz	r0, 1949c <setLED_A+0xc>
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_RESET);
   19492:	4602      	mov	r2, r0
   19494:	2140      	movs	r1, #64	; 0x40
   19496:	4804      	ldr	r0, [pc, #16]	; (194a8 <setLED_A+0x18>)
   19498:	f7f2 becc 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
   1949c:	2201      	movs	r2, #1
   1949e:	2140      	movs	r1, #64	; 0x40
   194a0:	4801      	ldr	r0, [pc, #4]	; (194a8 <setLED_A+0x18>)
   194a2:	f7f2 bec7 	b.w	c234 <HAL_GPIO_WritePin>
   194a6:	bf00      	nop
   194a8:	58020800 	.word	0x58020800

000194ac <setLED_B>:
	}
}

void setLED_B(uint8_t onOff)
{
	if (onOff)
   194ac:	b920      	cbnz	r0, 194b8 <setLED_B+0xc>
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_RESET);
   194ae:	4602      	mov	r2, r0
   194b0:	2180      	movs	r1, #128	; 0x80
   194b2:	4804      	ldr	r0, [pc, #16]	; (194c4 <setLED_B+0x18>)
   194b4:	f7f2 bebe 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
   194b8:	2201      	movs	r2, #1
   194ba:	2180      	movs	r1, #128	; 0x80
   194bc:	4801      	ldr	r0, [pc, #4]	; (194c4 <setLED_B+0x18>)
   194be:	f7f2 beb9 	b.w	c234 <HAL_GPIO_WritePin>
   194c2:	bf00      	nop
   194c4:	58021800 	.word	0x58021800

000194c8 <setLED_C>:
	}
}

void setLED_C(uint8_t onOff)
{
	if (onOff)
   194c8:	b928      	cbnz	r0, 194d6 <setLED_C+0xe>
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_RESET);
   194ca:	4602      	mov	r2, r0
   194cc:	f44f 6180 	mov.w	r1, #1024	; 0x400
   194d0:	4804      	ldr	r0, [pc, #16]	; (194e4 <setLED_C+0x1c>)
   194d2:	f7f2 beaf 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
   194d6:	2201      	movs	r2, #1
   194d8:	f44f 6180 	mov.w	r1, #1024	; 0x400
   194dc:	4801      	ldr	r0, [pc, #4]	; (194e4 <setLED_C+0x1c>)
   194de:	f7f2 bea9 	b.w	c234 <HAL_GPIO_WritePin>
   194e2:	bf00      	nop
   194e4:	58021800 	.word	0x58021800

000194e8 <setLED_leftout_clip>:
	}
}

void setLED_leftout_clip(uint8_t onOff)
{
	if (onOff)
   194e8:	b920      	cbnz	r0, 194f4 <setLED_leftout_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
   194ea:	4602      	mov	r2, r0
   194ec:	2110      	movs	r1, #16
   194ee:	4804      	ldr	r0, [pc, #16]	; (19500 <setLED_leftout_clip+0x18>)
   194f0:	f7f2 bea0 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
   194f4:	2201      	movs	r2, #1
   194f6:	2110      	movs	r1, #16
   194f8:	4801      	ldr	r0, [pc, #4]	; (19500 <setLED_leftout_clip+0x18>)
   194fa:	f7f2 be9b 	b.w	c234 <HAL_GPIO_WritePin>
   194fe:	bf00      	nop
   19500:	58020000 	.word	0x58020000

00019504 <setLED_rightout_clip>:
	}
}

void setLED_rightout_clip(uint8_t onOff)
{
	if (onOff)
   19504:	b920      	cbnz	r0, 19510 <setLED_rightout_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_RESET);
   19506:	4602      	mov	r2, r0
   19508:	2140      	movs	r1, #64	; 0x40
   1950a:	4804      	ldr	r0, [pc, #16]	; (1951c <setLED_rightout_clip+0x18>)
   1950c:	f7f2 be92 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
   19510:	2201      	movs	r2, #1
   19512:	2140      	movs	r1, #64	; 0x40
   19514:	4801      	ldr	r0, [pc, #4]	; (1951c <setLED_rightout_clip+0x18>)
   19516:	f7f2 be8d 	b.w	c234 <HAL_GPIO_WritePin>
   1951a:	bf00      	nop
   1951c:	58020000 	.word	0x58020000

00019520 <setLED_leftin_clip>:
	}
}

void setLED_leftin_clip(uint8_t onOff)
{
	if (onOff)
   19520:	b920      	cbnz	r0, 1952c <setLED_leftin_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_RESET);
   19522:	4602      	mov	r2, r0
   19524:	2110      	movs	r1, #16
   19526:	4804      	ldr	r0, [pc, #16]	; (19538 <setLED_leftin_clip+0x18>)
   19528:	f7f2 be84 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
   1952c:	2201      	movs	r2, #1
   1952e:	2110      	movs	r1, #16
   19530:	4801      	ldr	r0, [pc, #4]	; (19538 <setLED_leftin_clip+0x18>)
   19532:	f7f2 be7f 	b.w	c234 <HAL_GPIO_WritePin>
   19536:	bf00      	nop
   19538:	58020800 	.word	0x58020800

0001953c <setLED_rightin_clip>:
	}
}

void setLED_rightin_clip(uint8_t onOff)
{
	if (onOff)
   1953c:	b920      	cbnz	r0, 19548 <setLED_rightin_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
   1953e:	4602      	mov	r2, r0
   19540:	2101      	movs	r1, #1
   19542:	4804      	ldr	r0, [pc, #16]	; (19554 <setLED_rightin_clip+0x18>)
   19544:	f7f2 be76 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
   19548:	2201      	movs	r2, #1
   1954a:	4802      	ldr	r0, [pc, #8]	; (19554 <setLED_rightin_clip+0x18>)
   1954c:	4611      	mov	r1, r2
   1954e:	f7f2 be71 	b.w	c234 <HAL_GPIO_WritePin>
   19552:	bf00      	nop
   19554:	58020400 	.word	0x58020400

00019558 <OLED_writePreset>:
	}
//	OLED_draw();
}

void OLED_writePreset()
{
   19558:	b5f0      	push	{r4, r5, r6, r7, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
   1955a:	4935      	ldr	r1, [pc, #212]	; (19630 <OLED_writePreset+0xd8>)
{
   1955c:	b089      	sub	sp, #36	; 0x24
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
   1955e:	4835      	ldr	r0, [pc, #212]	; (19634 <OLED_writePreset+0xdc>)
}


void OLEDclear()
{
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   19560:	2600      	movs	r6, #0
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
   19562:	f7ff f9fd 	bl	18960 <GFXsetFont>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   19566:	2320      	movs	r3, #32
	itoa((currentPreset+1), tempString, 10);
   19568:	4f33      	ldr	r7, [pc, #204]	; (19638 <OLED_writePreset+0xe0>)
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   1956a:	4632      	mov	r2, r6
   1956c:	4631      	mov	r1, r6
   1956e:	9300      	str	r3, [sp, #0]
   19570:	4830      	ldr	r0, [pc, #192]	; (19634 <OLED_writePreset+0xdc>)
   19572:	2380      	movs	r3, #128	; 0x80
   19574:	9601      	str	r6, [sp, #4]
	itoa((currentPreset+1), tempString, 10);
   19576:	ac02      	add	r4, sp, #8
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   19578:	f7fe fdaa 	bl	180d0 <GFXfillRect>
	itoa((currentPreset+1), tempString, 10);
   1957c:	7838      	ldrb	r0, [r7, #0]
   1957e:	4621      	mov	r1, r4
   19580:	220a      	movs	r2, #10
   19582:	3001      	adds	r0, #1
   19584:	f013 f9a0 	bl	2c8c8 <itoa>
	strcat(tempString, ":");
   19588:	4620      	mov	r0, r4
   1958a:	f013 f9bb 	bl	2c904 <strlen>
   1958e:	4a2b      	ldr	r2, [pc, #172]	; (1963c <OLED_writePreset+0xe4>)
   19590:	4603      	mov	r3, r0
	strcat(tempString, modeNames[currentPreset]);
   19592:	783d      	ldrb	r5, [r7, #0]
	strcat(tempString, ":");
   19594:	8812      	ldrh	r2, [r2, #0]
   19596:	3001      	adds	r0, #1
	strcat(tempString, modeNames[currentPreset]);
   19598:	4929      	ldr	r1, [pc, #164]	; (19640 <OLED_writePreset+0xe8>)
	strcat(tempString, ":");
   1959a:	52e2      	strh	r2, [r4, r3]
	strcat(tempString, modeNames[currentPreset]);
   1959c:	4420      	add	r0, r4
   1959e:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
   195a2:	f013 f9a6 	bl	2c8f2 <stpcpy>
	int myLength = strlen(tempString);
   195a6:	1b05      	subs	r5, r0, r4

void OLEDwriteString(const char* myCharArray, uint8_t arrayLength, uint8_t startCursor, OLEDLine line)
{
	uint8_t cursorX = startCursor;
	uint8_t cursorY = 12 + (16 * (line%2));
	GFXsetCursor(&theGFX, cursorX, cursorY);
   195a8:	4631      	mov	r1, r6
   195aa:	220c      	movs	r2, #12

	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   195ac:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   195ae:	4821      	ldr	r0, [pc, #132]	; (19634 <OLED_writePreset+0xdc>)
   195b0:	f7ff f9c4 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   195b4:	2010      	movs	r0, #16
   195b6:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   195ba:	9601      	str	r6, [sp, #4]
   195bc:	9000      	str	r0, [sp, #0]
   195be:	4632      	mov	r2, r6
   195c0:	4631      	mov	r1, r6
   195c2:	009b      	lsls	r3, r3, #2
   195c4:	481b      	ldr	r0, [pc, #108]	; (19634 <OLED_writePreset+0xdc>)
   195c6:	f7fe fd83 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   195ca:	b145      	cbz	r5, 195de <OLED_writePreset+0x86>
	{
		GFXwrite(&theGFX, myCharArray[i]);
   195cc:	4e19      	ldr	r6, [pc, #100]	; (19634 <OLED_writePreset+0xdc>)
   195ce:	4425      	add	r5, r4
   195d0:	f814 1b01 	ldrb.w	r1, [r4], #1
   195d4:	4630      	mov	r0, r6
   195d6:	f7ff f8ff 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   195da:	42a5      	cmp	r5, r4
   195dc:	d1f8      	bne.n	195d0 <OLED_writePreset+0x78>
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   195de:	4919      	ldr	r1, [pc, #100]	; (19644 <OLED_writePreset+0xec>)
   195e0:	4814      	ldr	r0, [pc, #80]	; (19634 <OLED_writePreset+0xdc>)
   195e2:	f7ff f9bd 	bl	18960 <GFXsetFont>
	OLEDwriteString(modeNamesDetails[currentPreset], strlen(modeNamesDetails[currentPreset]), 0, SecondLine);
   195e6:	783a      	ldrb	r2, [r7, #0]
   195e8:	4b17      	ldr	r3, [pc, #92]	; (19648 <OLED_writePreset+0xf0>)
   195ea:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
   195ee:	4620      	mov	r0, r4
   195f0:	f013 f988 	bl	2c904 <strlen>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   195f4:	221c      	movs	r2, #28
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   195f6:	b2c5      	uxtb	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   195f8:	2100      	movs	r1, #0
   195fa:	480e      	ldr	r0, [pc, #56]	; (19634 <OLED_writePreset+0xdc>)
   195fc:	f7ff f99e 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19600:	2220      	movs	r2, #32
   19602:	2100      	movs	r1, #0
   19604:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19608:	9200      	str	r2, [sp, #0]
   1960a:	2210      	movs	r2, #16
   1960c:	9101      	str	r1, [sp, #4]
   1960e:	009b      	lsls	r3, r3, #2
   19610:	4808      	ldr	r0, [pc, #32]	; (19634 <OLED_writePreset+0xdc>)
   19612:	f7fe fd5d 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19616:	b14d      	cbz	r5, 1962c <OLED_writePreset+0xd4>
   19618:	3c01      	subs	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
   1961a:	4e06      	ldr	r6, [pc, #24]	; (19634 <OLED_writePreset+0xdc>)
   1961c:	4425      	add	r5, r4
   1961e:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   19622:	4630      	mov	r0, r6
   19624:	f7ff f8d8 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19628:	42ac      	cmp	r4, r5
   1962a:	d1f8      	bne.n	1961e <OLED_writePreset+0xc6>
}
   1962c:	b009      	add	sp, #36	; 0x24
   1962e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19630:	000305e8 	.word	0x000305e8
   19634:	020e4538 	.word	0x020e4538
   19638:	020e2f19 	.word	0x020e2f19
   1963c:	00030c80 	.word	0x00030c80
   19640:	020fafd8 	.word	0x020fafd8
   19644:	00030034 	.word	0x00030034
   19648:	020fb1b8 	.word	0x020fb1b8

0001964c <OLED_init>:
{
   1964c:	b530      	push	{r4, r5, lr}
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
   1964e:	2278      	movs	r2, #120	; 0x78
{
   19650:	b083      	sub	sp, #12
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
   19652:	2102      	movs	r1, #2
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
   19654:	4d28      	ldr	r5, [pc, #160]	; (196f8 <OLED_init+0xac>)
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
   19656:	f007 ffd9 	bl	2160c <ssd1306_begin>
   1965a:	f44f 7200 	mov.w	r2, #512	; 0x200
   1965e:	2100      	movs	r1, #0
   19660:	4826      	ldr	r0, [pc, #152]	; (196fc <OLED_init+0xb0>)
   19662:	f013 f93e 	bl	2c8e2 <memset>
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
   19666:	4b26      	ldr	r3, [pc, #152]	; (19700 <OLED_init+0xb4>)
   19668:	4926      	ldr	r1, [pc, #152]	; (19704 <OLED_init+0xb8>)
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
   1966a:	4a27      	ldr	r2, [pc, #156]	; (19708 <OLED_init+0xbc>)
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
   1966c:	6019      	str	r1, [r3, #0]
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
   1966e:	605a      	str	r2, [r3, #4]
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
   19670:	4826      	ldr	r0, [pc, #152]	; (1970c <OLED_init+0xc0>)
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
   19672:	4927      	ldr	r1, [pc, #156]	; (19710 <OLED_init+0xc4>)
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
   19674:	4a27      	ldr	r2, [pc, #156]	; (19714 <OLED_init+0xc8>)
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
   19676:	609d      	str	r5, [r3, #8]
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
   19678:	60d8      	str	r0, [r3, #12]
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
   1967a:	6119      	str	r1, [r3, #16]
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
   1967c:	615a      	str	r2, [r3, #20]
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
   1967e:	4d26      	ldr	r5, [pc, #152]	; (19718 <OLED_init+0xcc>)
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
   19680:	4826      	ldr	r0, [pc, #152]	; (1971c <OLED_init+0xd0>)
	buttonActionFunctions[Distortion] = UIDistortionButtons;
   19682:	4927      	ldr	r1, [pc, #156]	; (19720 <OLED_init+0xd4>)
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
   19684:	4a27      	ldr	r2, [pc, #156]	; (19724 <OLED_init+0xd8>)
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
   19686:	619d      	str	r5, [r3, #24]
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
   19688:	61d8      	str	r0, [r3, #28]
	buttonActionFunctions[Distortion] = UIDistortionButtons;
   1968a:	6219      	str	r1, [r3, #32]
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
   1968c:	625a      	str	r2, [r3, #36]	; 0x24
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
   1968e:	4d26      	ldr	r5, [pc, #152]	; (19728 <OLED_init+0xdc>)
	buttonActionFunctions[Delay] = UIDelayButtons;
   19690:	4826      	ldr	r0, [pc, #152]	; (1972c <OLED_init+0xe0>)
	buttonActionFunctions[Reverb] = UIReverbButtons;
   19692:	4927      	ldr	r1, [pc, #156]	; (19730 <OLED_init+0xe4>)
	buttonActionFunctions[Reverb2] = UIReverb2Buttons;
   19694:	4a27      	ldr	r2, [pc, #156]	; (19734 <OLED_init+0xe8>)
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
   19696:	629d      	str	r5, [r3, #40]	; 0x28
	buttonActionFunctions[Delay] = UIDelayButtons;
   19698:	62d8      	str	r0, [r3, #44]	; 0x2c
	buttonActionFunctions[Reverb] = UIReverbButtons;
   1969a:	6319      	str	r1, [r3, #48]	; 0x30
	buttonActionFunctions[Reverb2] = UIReverb2Buttons;
   1969c:	635a      	str	r2, [r3, #52]	; 0x34
	  GFXinit(&theGFX, 128, 32);
   1969e:	4c26      	ldr	r4, [pc, #152]	; (19738 <OLED_init+0xec>)
	buttonActionFunctions[LivingStringSynth] = UILivingStringSynthButtons;
   196a0:	4826      	ldr	r0, [pc, #152]	; (1973c <OLED_init+0xf0>)
	buttonActionFunctions[ClassicSynth] = UIClassicSynthButtons;
   196a2:	4927      	ldr	r1, [pc, #156]	; (19740 <OLED_init+0xf4>)
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
   196a4:	4a27      	ldr	r2, [pc, #156]	; (19744 <OLED_init+0xf8>)
	buttonActionFunctions[LivingString] = UILivingStringButtons;
   196a6:	4d28      	ldr	r5, [pc, #160]	; (19748 <OLED_init+0xfc>)
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
   196a8:	e9c3 1210 	strd	r1, r2, [r3, #64]	; 0x40
	buttonActionFunctions[LivingStringSynth] = UILivingStringSynthButtons;
   196ac:	e9c3 500e 	strd	r5, r0, [r3, #56]	; 0x38
	  initModeNames();
   196b0:	f008 fae2 	bl	21c78 <initModeNames>
	  GFXinit(&theGFX, 128, 32);
   196b4:	4620      	mov	r0, r4
   196b6:	2220      	movs	r2, #32
   196b8:	2180      	movs	r1, #128	; 0x80
   196ba:	f7fe fbed 	bl	17e98 <GFXinit>
	  GFXsetFont(&theGFX, &EuphemiaCAS8pt7b); //this one is elegant but definitely not monospaced can fit 9 Ms
   196be:	4620      	mov	r0, r4
   196c0:	4922      	ldr	r1, [pc, #136]	; (1974c <OLED_init+0x100>)
   196c2:	f7ff f94d 	bl	18960 <GFXsetFont>
	  GFXsetTextColor(&theGFX, 1, 0);
   196c6:	4620      	mov	r0, r4
   196c8:	2200      	movs	r2, #0
   196ca:	2101      	movs	r1, #1
   196cc:	f7ff f944 	bl	18958 <GFXsetTextColor>
	  GFXsetTextSize(&theGFX, 1);
   196d0:	4620      	mov	r0, r4
   196d2:	2101      	movs	r1, #1
   196d4:	f7ff f93a 	bl	1894c <GFXsetTextSize>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   196d8:	2200      	movs	r2, #0
   196da:	2320      	movs	r3, #32
   196dc:	4620      	mov	r0, r4
   196de:	4611      	mov	r1, r2
   196e0:	9201      	str	r2, [sp, #4]
   196e2:	9300      	str	r3, [sp, #0]
   196e4:	2380      	movs	r3, #128	; 0x80
   196e6:	f7fe fcf3 	bl	180d0 <GFXfillRect>
	  OLED_writePreset();
   196ea:	f7ff ff35 	bl	19558 <OLED_writePreset>
}
   196ee:	b003      	add	sp, #12
   196f0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	ssd1306_display_full_buffer();
   196f4:	f008 b8e8 	b.w	218c8 <ssd1306_display_full_buffer>
   196f8:	00022fbd 	.word	0x00022fbd
   196fc:	020facfc 	.word	0x020facfc
   19700:	020fb940 	.word	0x020fb940
   19704:	00022eb5 	.word	0x00022eb5
   19708:	00022f39 	.word	0x00022f39
   1970c:	00022fc5 	.word	0x00022fc5
   19710:	00023021 	.word	0x00023021
   19714:	00023029 	.word	0x00023029
   19718:	00023119 	.word	0x00023119
   1971c:	000231ad 	.word	0x000231ad
   19720:	00023231 	.word	0x00023231
   19724:	00023269 	.word	0x00023269
   19728:	000232a1 	.word	0x000232a1
   1972c:	000232d9 	.word	0x000232d9
   19730:	00023335 	.word	0x00023335
   19734:	00023391 	.word	0x00023391
   19738:	020e4538 	.word	0x020e4538
   1973c:	0002344d 	.word	0x0002344d
   19740:	000234d1 	.word	0x000234d1
   19744:	0002351d 	.word	0x0002351d
   19748:	000233c9 	.word	0x000233c9
   1974c:	000305e8 	.word	0x000305e8

00019750 <OLED_writeEditScreen>:
{
   19750:	b570      	push	{r4, r5, r6, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   19752:	4921      	ldr	r1, [pc, #132]	; (197d8 <OLED_writeEditScreen+0x88>)
{
   19754:	b082      	sub	sp, #8
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   19756:	4821      	ldr	r0, [pc, #132]	; (197dc <OLED_writeEditScreen+0x8c>)
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   19758:	2500      	movs	r5, #0
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1975a:	f7ff f901 	bl	18960 <GFXsetFont>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   1975e:	2320      	movs	r3, #32
   19760:	462a      	mov	r2, r5
   19762:	4629      	mov	r1, r5
   19764:	9501      	str	r5, [sp, #4]
   19766:	9300      	str	r3, [sp, #0]
   19768:	2380      	movs	r3, #128	; 0x80
   1976a:	481c      	ldr	r0, [pc, #112]	; (197dc <OLED_writeEditScreen+0x8c>)
   1976c:	f7fe fcb0 	bl	180d0 <GFXfillRect>
   19770:	4c1b      	ldr	r4, [pc, #108]	; (197e0 <OLED_writeEditScreen+0x90>)
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19772:	4629      	mov	r1, r5
   19774:	220c      	movs	r2, #12
   19776:	4819      	ldr	r0, [pc, #100]	; (197dc <OLED_writeEditScreen+0x8c>)
   19778:	f104 060f 	add.w	r6, r4, #15
   1977c:	f7ff f8de 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19780:	2310      	movs	r3, #16
   19782:	9501      	str	r5, [sp, #4]
   19784:	462a      	mov	r2, r5
   19786:	4629      	mov	r1, r5
		GFXwrite(&theGFX, myCharArray[i]);
   19788:	4d14      	ldr	r5, [pc, #80]	; (197dc <OLED_writeEditScreen+0x8c>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1978a:	9300      	str	r3, [sp, #0]
   1978c:	23b4      	movs	r3, #180	; 0xb4
   1978e:	4813      	ldr	r0, [pc, #76]	; (197dc <OLED_writeEditScreen+0x8c>)
   19790:	f7fe fc9e 	bl	180d0 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   19794:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   19798:	4628      	mov	r0, r5
   1979a:	f7ff f81d 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1979e:	42a6      	cmp	r6, r4
   197a0:	d1f8      	bne.n	19794 <OLED_writeEditScreen+0x44>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   197a2:	221c      	movs	r2, #28
   197a4:	2100      	movs	r1, #0
   197a6:	480d      	ldr	r0, [pc, #52]	; (197dc <OLED_writeEditScreen+0x8c>)
   197a8:	4c0e      	ldr	r4, [pc, #56]	; (197e4 <OLED_writeEditScreen+0x94>)
   197aa:	f7ff f8c7 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   197ae:	2100      	movs	r1, #0
   197b0:	2220      	movs	r2, #32
   197b2:	f104 0610 	add.w	r6, r4, #16
		GFXwrite(&theGFX, myCharArray[i]);
   197b6:	4d09      	ldr	r5, [pc, #36]	; (197dc <OLED_writeEditScreen+0x8c>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   197b8:	23c0      	movs	r3, #192	; 0xc0
   197ba:	4808      	ldr	r0, [pc, #32]	; (197dc <OLED_writeEditScreen+0x8c>)
   197bc:	e9cd 2100 	strd	r2, r1, [sp]
   197c0:	2210      	movs	r2, #16
   197c2:	f7fe fc85 	bl	180d0 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   197c6:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   197ca:	4628      	mov	r0, r5
   197cc:	f7ff f804 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   197d0:	42b4      	cmp	r4, r6
   197d2:	d1f8      	bne.n	197c6 <OLED_writeEditScreen+0x76>
}
   197d4:	b002      	add	sp, #8
   197d6:	bd70      	pop	{r4, r5, r6, pc}
   197d8:	00030034 	.word	0x00030034
   197dc:	020e4538 	.word	0x020e4538
   197e0:	00030c5b 	.word	0x00030c5b
   197e4:	00030c6b 	.word	0x00030c6b

000197e8 <OLED_writeTuning>:
{
   197e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   197ec:	2600      	movs	r6, #0
{
   197ee:	b083      	sub	sp, #12
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   197f0:	2710      	movs	r7, #16
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   197f2:	4936      	ldr	r1, [pc, #216]	; (198cc <OLED_writeTuning+0xe4>)
   197f4:	4836      	ldr	r0, [pc, #216]	; (198d0 <OLED_writeTuning+0xe8>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   197f6:	f04f 0920 	mov.w	r9, #32
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   197fa:	f7ff f8b1 	bl	18960 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   197fe:	2380      	movs	r3, #128	; 0x80
   19800:	4631      	mov	r1, r6
   19802:	463a      	mov	r2, r7
   19804:	4832      	ldr	r0, [pc, #200]	; (198d0 <OLED_writeTuning+0xe8>)
   19806:	9601      	str	r6, [sp, #4]
   19808:	9700      	str	r7, [sp, #0]
   1980a:	f7fe fc61 	bl	180d0 <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1980e:	4631      	mov	r1, r6
   19810:	221c      	movs	r2, #28
   19812:	482f      	ldr	r0, [pc, #188]	; (198d0 <OLED_writeTuning+0xe8>)
   19814:	f7ff f892 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19818:	2318      	movs	r3, #24
   1981a:	463a      	mov	r2, r7
   1981c:	4631      	mov	r1, r6
   1981e:	482c      	ldr	r0, [pc, #176]	; (198d0 <OLED_writeTuning+0xe8>)
   19820:	9601      	str	r6, [sp, #4]
   19822:	f8cd 9000 	str.w	r9, [sp]
   19826:	f7fe fc53 	bl	180d0 <GFXfillRect>
	OLEDwriteInt(currentTuning, 2, 12, SecondLine);
   1982a:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 198dc <OLED_writeTuning+0xf4>
		GFXwrite(&theGFX, myCharArray[i]);
   1982e:	2154      	movs	r1, #84	; 0x54
   19830:	4827      	ldr	r0, [pc, #156]	; (198d0 <OLED_writeTuning+0xe8>)
	}
}

void OLEDwriteInt(uint32_t myNumber, uint8_t numDigits, uint8_t startCursor, OLEDLine line)
{
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   19832:	4c28      	ldr	r4, [pc, #160]	; (198d4 <OLED_writeTuning+0xec>)
		GFXwrite(&theGFX, myCharArray[i]);
   19834:	f7fe ffd0 	bl	187d8 <GFXwrite>
   19838:	4631      	mov	r1, r6
   1983a:	4825      	ldr	r0, [pc, #148]	; (198d0 <OLED_writeTuning+0xe8>)
   1983c:	f7fe ffcc 	bl	187d8 <GFXwrite>
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   19840:	f8d8 1000 	ldr.w	r1, [r8]
   19844:	2202      	movs	r2, #2
   19846:	4620      	mov	r0, r4
   19848:	f7ff f89c 	bl	18984 <OLEDparseInt>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1984c:	221c      	movs	r2, #28
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1984e:	b2c5      	uxtb	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19850:	210c      	movs	r1, #12
   19852:	481f      	ldr	r0, [pc, #124]	; (198d0 <OLED_writeTuning+0xe8>)
   19854:	f7ff f872 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19858:	f8cd 9000 	str.w	r9, [sp]
   1985c:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19860:	9601      	str	r6, [sp, #4]
   19862:	463a      	mov	r2, r7
   19864:	210c      	movs	r1, #12
   19866:	009b      	lsls	r3, r3, #2
   19868:	4819      	ldr	r0, [pc, #100]	; (198d0 <OLED_writeTuning+0xe8>)
   1986a:	f7fe fc31 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1986e:	b145      	cbz	r5, 19882 <OLED_writeTuning+0x9a>
		GFXwrite(&theGFX, myCharArray[i]);
   19870:	4e17      	ldr	r6, [pc, #92]	; (198d0 <OLED_writeTuning+0xe8>)
   19872:	4425      	add	r5, r4
   19874:	f814 1b01 	ldrb.w	r1, [r4], #1
   19878:	4630      	mov	r0, r6
   1987a:	f7fe ffad 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1987e:	42ac      	cmp	r4, r5
   19880:	d1f8      	bne.n	19874 <OLED_writeTuning+0x8c>
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
   19882:	f8d8 3000 	ldr.w	r3, [r8]
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19886:	221c      	movs	r2, #28
   19888:	4811      	ldr	r0, [pc, #68]	; (198d0 <OLED_writeTuning+0xe8>)
   1988a:	2124      	movs	r1, #36	; 0x24
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
   1988c:	eb03 0543 	add.w	r5, r3, r3, lsl #1
   19890:	4c11      	ldr	r4, [pc, #68]	; (198d8 <OLED_writeTuning+0xf0>)
		GFXwrite(&theGFX, myCharArray[i]);
   19892:	4606      	mov	r6, r0
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
   19894:	eb03 0585 	add.w	r5, r3, r5, lsl #2
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19898:	f7ff f850 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1989c:	2300      	movs	r3, #0
   1989e:	2220      	movs	r2, #32
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
   198a0:	4425      	add	r5, r4
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   198a2:	9301      	str	r3, [sp, #4]
   198a4:	2124      	movs	r1, #36	; 0x24
   198a6:	9200      	str	r2, [sp, #0]
   198a8:	2390      	movs	r3, #144	; 0x90
   198aa:	2210      	movs	r2, #16
   198ac:	4630      	mov	r0, r6
   198ae:	1e6c      	subs	r4, r5, #1
   198b0:	350b      	adds	r5, #11
   198b2:	f7fe fc0d 	bl	180d0 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   198b6:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   198ba:	4630      	mov	r0, r6
   198bc:	f7fe ff8c 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   198c0:	42a5      	cmp	r5, r4
   198c2:	d1f8      	bne.n	198b6 <OLED_writeTuning+0xce>
}
   198c4:	b003      	add	sp, #12
   198c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   198ca:	bf00      	nop
   198cc:	00030034 	.word	0x00030034
   198d0:	020e4538 	.word	0x020e4538
   198d4:	020e4518 	.word	0x020e4518
   198d8:	00030cec 	.word	0x00030cec
   198dc:	020e2f14 	.word	0x020e2f14

000198e0 <OLED_draw>:
	ssd1306_display_full_buffer();
   198e0:	f007 bff2 	b.w	218c8 <ssd1306_display_full_buffer>

000198e4 <OLEDclearLine>:
{
   198e4:	4602      	mov	r2, r0
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   198e6:	2100      	movs	r1, #0
   198e8:	2380      	movs	r3, #128	; 0x80
   198ea:	4807      	ldr	r0, [pc, #28]	; (19908 <OLEDclearLine+0x24>)
{
   198ec:	b510      	push	{r4, lr}
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   198ee:	0854      	lsrs	r4, r2, #1
   198f0:	f002 0201 	and.w	r2, r2, #1
{
   198f4:	b082      	sub	sp, #8
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   198f6:	3401      	adds	r4, #1
   198f8:	0112      	lsls	r2, r2, #4
   198fa:	9101      	str	r1, [sp, #4]
   198fc:	0124      	lsls	r4, r4, #4
   198fe:	9400      	str	r4, [sp, #0]
   19900:	f7fe fbe6 	bl	180d0 <GFXfillRect>
}
   19904:	b002      	add	sp, #8
   19906:	bd10      	pop	{r4, pc}
   19908:	020e4538 	.word	0x020e4538

0001990c <OLEDwriteString>:
{
   1990c:	b5f0      	push	{r4, r5, r6, r7, lr}
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1990e:	4617      	mov	r7, r2
	uint8_t cursorY = 12 + (16 * (line%2));
   19910:	f003 0201 	and.w	r2, r3, #1
{
   19914:	461e      	mov	r6, r3
   19916:	b083      	sub	sp, #12
	uint8_t cursorY = 12 + (16 * (line%2));
   19918:	0112      	lsls	r2, r2, #4
{
   1991a:	460d      	mov	r5, r1
   1991c:	4604      	mov	r4, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1991e:	4639      	mov	r1, r7
   19920:	480e      	ldr	r0, [pc, #56]	; (1995c <OLEDwriteString+0x50>)
   19922:	320c      	adds	r2, #12
   19924:	f7ff f80a 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19928:	1c70      	adds	r0, r6, #1
   1992a:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1992e:	f04f 0c00 	mov.w	ip, #0
   19932:	0100      	lsls	r0, r0, #4
   19934:	4639      	mov	r1, r7
   19936:	0132      	lsls	r2, r6, #4
   19938:	009b      	lsls	r3, r3, #2
   1993a:	e9cd 0c00 	strd	r0, ip, [sp]
   1993e:	4807      	ldr	r0, [pc, #28]	; (1995c <OLEDwriteString+0x50>)
   19940:	f7fe fbc6 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19944:	b145      	cbz	r5, 19958 <OLEDwriteString+0x4c>
		GFXwrite(&theGFX, myCharArray[i]);
   19946:	4e05      	ldr	r6, [pc, #20]	; (1995c <OLEDwriteString+0x50>)
   19948:	4425      	add	r5, r4
   1994a:	f814 1b01 	ldrb.w	r1, [r4], #1
   1994e:	4630      	mov	r0, r6
   19950:	f7fe ff42 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19954:	42a5      	cmp	r5, r4
   19956:	d1f8      	bne.n	1994a <OLEDwriteString+0x3e>
}
   19958:	b003      	add	sp, #12
   1995a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1995c:	020e4538 	.word	0x020e4538

00019960 <OLEDwriteInt>:
{
   19960:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   19962:	4c16      	ldr	r4, [pc, #88]	; (199bc <OLEDwriteInt+0x5c>)
{
   19964:	461f      	mov	r7, r3
   19966:	b083      	sub	sp, #12
   19968:	4616      	mov	r6, r2
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   1996a:	460a      	mov	r2, r1
   1996c:	4601      	mov	r1, r0
   1996e:	4620      	mov	r0, r4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19970:	b236      	sxth	r6, r6
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   19972:	f7ff f807 	bl	18984 <OLEDparseInt>
	uint8_t cursorY = 12 + (16 * (line%2));
   19976:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   1997a:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1997c:	4631      	mov	r1, r6
	uint8_t cursorY = 12 + (16 * (line%2));
   1997e:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19980:	480f      	ldr	r0, [pc, #60]	; (199c0 <OLEDwriteInt+0x60>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19982:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19984:	320c      	adds	r2, #12
   19986:	f7fe ffd9 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1998a:	1c7a      	adds	r2, r7, #1
   1998c:	2000      	movs	r0, #0
   1998e:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19992:	0112      	lsls	r2, r2, #4
   19994:	4631      	mov	r1, r6
   19996:	009b      	lsls	r3, r3, #2
   19998:	e9cd 2000 	strd	r2, r0, [sp]
   1999c:	013a      	lsls	r2, r7, #4
   1999e:	4808      	ldr	r0, [pc, #32]	; (199c0 <OLEDwriteInt+0x60>)
   199a0:	f7fe fb96 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   199a4:	b145      	cbz	r5, 199b8 <OLEDwriteInt+0x58>
		GFXwrite(&theGFX, myCharArray[i]);
   199a6:	4e06      	ldr	r6, [pc, #24]	; (199c0 <OLEDwriteInt+0x60>)
   199a8:	4425      	add	r5, r4
   199aa:	f814 1b01 	ldrb.w	r1, [r4], #1
   199ae:	4630      	mov	r0, r6
   199b0:	f7fe ff12 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   199b4:	42a5      	cmp	r5, r4
   199b6:	d1f8      	bne.n	199aa <OLEDwriteInt+0x4a>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   199b8:	b003      	add	sp, #12
   199ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
   199bc:	020e4518 	.word	0x020e4518
   199c0:	020e4538 	.word	0x020e4538

000199c4 <OLEDwritePitch>:

	OLEDwriteLine(oled_buffer, len, line);
}

void OLEDwritePitch(float midi, uint8_t startCursor, OLEDLine line, uint8_t showCents)
{
   199c4:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   199c6:	4c16      	ldr	r4, [pc, #88]	; (19a20 <OLEDwritePitch+0x5c>)
{
   199c8:	460f      	mov	r7, r1
   199ca:	b083      	sub	sp, #12
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   199cc:	4611      	mov	r1, r2
{
   199ce:	4606      	mov	r6, r0
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   199d0:	4620      	mov	r0, r4
   199d2:	f7fe fff7 	bl	189c4 <OLEDparsePitch>
	uint8_t cursorY = 12 + (16 * (line%2));
   199d6:	f007 0201 	and.w	r2, r7, #1
	GFXsetCursor(&theGFX, cursorX, cursorY);
   199da:	b236      	sxth	r6, r6
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   199dc:	4605      	mov	r5, r0
	uint8_t cursorY = 12 + (16 * (line%2));
   199de:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   199e0:	4810      	ldr	r0, [pc, #64]	; (19a24 <OLEDwritePitch+0x60>)
   199e2:	4631      	mov	r1, r6
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   199e4:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   199e6:	320c      	adds	r2, #12
   199e8:	f7fe ffa8 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   199ec:	1c7a      	adds	r2, r7, #1
   199ee:	2000      	movs	r0, #0
   199f0:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   199f4:	0112      	lsls	r2, r2, #4
   199f6:	4631      	mov	r1, r6
   199f8:	009b      	lsls	r3, r3, #2
   199fa:	e9cd 2000 	strd	r2, r0, [sp]
   199fe:	013a      	lsls	r2, r7, #4
   19a00:	4808      	ldr	r0, [pc, #32]	; (19a24 <OLEDwritePitch+0x60>)
   19a02:	f7fe fb65 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19a06:	b145      	cbz	r5, 19a1a <OLEDwritePitch+0x56>
		GFXwrite(&theGFX, myCharArray[i]);
   19a08:	4e06      	ldr	r6, [pc, #24]	; (19a24 <OLEDwritePitch+0x60>)
   19a0a:	4425      	add	r5, r4
   19a0c:	f814 1b01 	ldrb.w	r1, [r4], #1
   19a10:	4630      	mov	r0, r6
   19a12:	f7fe fee1 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19a16:	42a5      	cmp	r5, r4
   19a18:	d1f8      	bne.n	19a0c <OLEDwritePitch+0x48>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   19a1a:	b003      	add	sp, #12
   19a1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19a1e:	bf00      	nop
   19a20:	020e4518 	.word	0x020e4518
   19a24:	020e4538 	.word	0x020e4538

00019a28 <OLEDwritePitchClass>:

void OLEDwritePitchClass(float midi, uint8_t startCursor, OLEDLine line)
{
   19a28:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparsePitchClass(oled_buffer, midi);
   19a2a:	4c15      	ldr	r4, [pc, #84]	; (19a80 <OLEDwritePitchClass+0x58>)
{
   19a2c:	460f      	mov	r7, r1
   19a2e:	b083      	sub	sp, #12
   19a30:	4606      	mov	r6, r0
	int len = OLEDparsePitchClass(oled_buffer, midi);
   19a32:	4620      	mov	r0, r4
   19a34:	f7ff f828 	bl	18a88 <OLEDparsePitchClass>
	uint8_t cursorY = 12 + (16 * (line%2));
   19a38:	f007 0201 	and.w	r2, r7, #1
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19a3c:	b236      	sxth	r6, r6
	int len = OLEDparsePitchClass(oled_buffer, midi);
   19a3e:	4605      	mov	r5, r0
	uint8_t cursorY = 12 + (16 * (line%2));
   19a40:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19a42:	4810      	ldr	r0, [pc, #64]	; (19a84 <OLEDwritePitchClass+0x5c>)
   19a44:	4631      	mov	r1, r6
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19a46:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19a48:	320c      	adds	r2, #12
   19a4a:	f7fe ff77 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19a4e:	1c7a      	adds	r2, r7, #1
   19a50:	2000      	movs	r0, #0
   19a52:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19a56:	0112      	lsls	r2, r2, #4
   19a58:	4631      	mov	r1, r6
   19a5a:	009b      	lsls	r3, r3, #2
   19a5c:	e9cd 2000 	strd	r2, r0, [sp]
   19a60:	013a      	lsls	r2, r7, #4
   19a62:	4808      	ldr	r0, [pc, #32]	; (19a84 <OLEDwritePitchClass+0x5c>)
   19a64:	f7fe fb34 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19a68:	b145      	cbz	r5, 19a7c <OLEDwritePitchClass+0x54>
		GFXwrite(&theGFX, myCharArray[i]);
   19a6a:	4e06      	ldr	r6, [pc, #24]	; (19a84 <OLEDwritePitchClass+0x5c>)
   19a6c:	4425      	add	r5, r4
   19a6e:	f814 1b01 	ldrb.w	r1, [r4], #1
   19a72:	4630      	mov	r0, r6
   19a74:	f7fe feb0 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19a78:	42a5      	cmp	r5, r4
   19a7a:	d1f8      	bne.n	19a6e <OLEDwritePitchClass+0x46>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   19a7c:	b003      	add	sp, #12
   19a7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19a80:	020e4518 	.word	0x020e4518
   19a84:	020e4538 	.word	0x020e4538

00019a88 <OLEDwriteFloat>:
	OLEDwriteLine(oled_buffer, len, line);
}


void OLEDwriteFloat(float input, uint8_t startCursor, OLEDLine line)
{
   19a88:	b5f0      	push	{r4, r5, r6, r7, lr}
   19a8a:	ed2d 8b02 	vpush	{d8}
   19a8e:	b083      	sub	sp, #12
   19a90:	4606      	mov	r6, r0
   19a92:	460f      	mov	r7, r1
   19a94:	eeb0 8a40 	vmov.f32	s16, s0
	int numDigits = 5;
	int numDecimal = 1;

	if (fastabsf(input)<1.0f)
   19a98:	f00f fd6c 	bl	29574 <fastabsf>
   19a9c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   19aa0:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19aa8:	d438      	bmi.n	19b1c <OLEDwriteFloat+0x94>
	{
		numDigits = 3;
		numDecimal = 2;
	}

	else if (fastabsf(input)<10.0f)
   19aaa:	eeb0 0a48 	vmov.f32	s0, s16
   19aae:	f00f fd61 	bl	29574 <fastabsf>
   19ab2:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
   19ab6:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19aba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19abe:	d530      	bpl.n	19b22 <OLEDwriteFloat+0x9a>
   19ac0:	2202      	movs	r2, #2
   19ac2:	2104      	movs	r1, #4
	{
		numDigits = 8;
		numDecimal = 0;
	}

	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
   19ac4:	4c41      	ldr	r4, [pc, #260]	; (19bcc <OLEDwriteFloat+0x144>)
   19ac6:	eeb0 0a48 	vmov.f32	s0, s16
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19aca:	b236      	sxth	r6, r6
	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
   19acc:	4620      	mov	r0, r4
   19ace:	f7ff f809 	bl	18ae4 <OLEDparseFixedFloat>
	uint8_t cursorY = 12 + (16 * (line%2));
   19ad2:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
   19ad6:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19ad8:	4631      	mov	r1, r6
	uint8_t cursorY = 12 + (16 * (line%2));
   19ada:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19adc:	483c      	ldr	r0, [pc, #240]	; (19bd0 <OLEDwriteFloat+0x148>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19ade:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19ae0:	320c      	adds	r2, #12
   19ae2:	f7fe ff2b 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19ae6:	1c7a      	adds	r2, r7, #1
   19ae8:	2000      	movs	r0, #0
   19aea:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19aee:	0112      	lsls	r2, r2, #4
   19af0:	4631      	mov	r1, r6
   19af2:	009b      	lsls	r3, r3, #2
   19af4:	e9cd 2000 	strd	r2, r0, [sp]
   19af8:	013a      	lsls	r2, r7, #4
   19afa:	4835      	ldr	r0, [pc, #212]	; (19bd0 <OLEDwriteFloat+0x148>)
   19afc:	f7fe fae8 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19b00:	b145      	cbz	r5, 19b14 <OLEDwriteFloat+0x8c>
		GFXwrite(&theGFX, myCharArray[i]);
   19b02:	4e33      	ldr	r6, [pc, #204]	; (19bd0 <OLEDwriteFloat+0x148>)
   19b04:	4425      	add	r5, r4
   19b06:	f814 1b01 	ldrb.w	r1, [r4], #1
   19b0a:	4630      	mov	r0, r6
   19b0c:	f7fe fe64 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19b10:	42ac      	cmp	r4, r5
   19b12:	d1f8      	bne.n	19b06 <OLEDwriteFloat+0x7e>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   19b14:	b003      	add	sp, #12
   19b16:	ecbd 8b02 	vpop	{d8}
   19b1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19b1c:	2202      	movs	r2, #2
   19b1e:	2103      	movs	r1, #3
   19b20:	e7d0      	b.n	19ac4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<100.0f)
   19b22:	eeb0 0a48 	vmov.f32	s0, s16
   19b26:	f00f fd25 	bl	29574 <fastabsf>
   19b2a:	eddf 7a2a 	vldr	s15, [pc, #168]	; 19bd4 <OLEDwriteFloat+0x14c>
   19b2e:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19b32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19b36:	d502      	bpl.n	19b3e <OLEDwriteFloat+0xb6>
   19b38:	2202      	movs	r2, #2
   19b3a:	2105      	movs	r1, #5
   19b3c:	e7c2      	b.n	19ac4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<1000.0f)
   19b3e:	eeb0 0a48 	vmov.f32	s0, s16
   19b42:	f00f fd17 	bl	29574 <fastabsf>
   19b46:	eddf 7a24 	vldr	s15, [pc, #144]	; 19bd8 <OLEDwriteFloat+0x150>
   19b4a:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19b4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19b52:	d502      	bpl.n	19b5a <OLEDwriteFloat+0xd2>
   19b54:	2201      	movs	r2, #1
   19b56:	2105      	movs	r1, #5
   19b58:	e7b4      	b.n	19ac4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<10000.0f)
   19b5a:	eeb0 0a48 	vmov.f32	s0, s16
   19b5e:	f00f fd09 	bl	29574 <fastabsf>
   19b62:	eddf 7a1e 	vldr	s15, [pc, #120]	; 19bdc <OLEDwriteFloat+0x154>
   19b66:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19b6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19b6e:	d502      	bpl.n	19b76 <OLEDwriteFloat+0xee>
   19b70:	2200      	movs	r2, #0
   19b72:	2105      	movs	r1, #5
   19b74:	e7a6      	b.n	19ac4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<100000.0f)
   19b76:	eeb0 0a48 	vmov.f32	s0, s16
   19b7a:	f00f fcfb 	bl	29574 <fastabsf>
   19b7e:	eddf 7a18 	vldr	s15, [pc, #96]	; 19be0 <OLEDwriteFloat+0x158>
   19b82:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19b86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19b8a:	d502      	bpl.n	19b92 <OLEDwriteFloat+0x10a>
   19b8c:	2200      	movs	r2, #0
   19b8e:	2106      	movs	r1, #6
   19b90:	e798      	b.n	19ac4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<1000000.0f)
   19b92:	eeb0 0a48 	vmov.f32	s0, s16
   19b96:	f00f fced 	bl	29574 <fastabsf>
   19b9a:	eddf 7a12 	vldr	s15, [pc, #72]	; 19be4 <OLEDwriteFloat+0x15c>
   19b9e:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19ba2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19ba6:	d502      	bpl.n	19bae <OLEDwriteFloat+0x126>
   19ba8:	2200      	movs	r2, #0
   19baa:	2107      	movs	r1, #7
   19bac:	e78a      	b.n	19ac4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<10000000.0f)
   19bae:	eeb0 0a48 	vmov.f32	s0, s16
   19bb2:	f00f fcdf 	bl	29574 <fastabsf>
   19bb6:	eddf 7a0c 	vldr	s15, [pc, #48]	; 19be8 <OLEDwriteFloat+0x160>
   19bba:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19bbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19bc2:	d5c7      	bpl.n	19b54 <OLEDwriteFloat+0xcc>
   19bc4:	2200      	movs	r2, #0
   19bc6:	2108      	movs	r1, #8
   19bc8:	e77c      	b.n	19ac4 <OLEDwriteFloat+0x3c>
   19bca:	bf00      	nop
   19bcc:	020e4518 	.word	0x020e4518
   19bd0:	020e4538 	.word	0x020e4538
   19bd4:	42c80000 	.word	0x42c80000
   19bd8:	447a0000 	.word	0x447a0000
   19bdc:	461c4000 	.word	0x461c4000
   19be0:	47c35000 	.word	0x47c35000
   19be4:	49742400 	.word	0x49742400
   19be8:	4b189680 	.word	0x4b189680

00019bec <OLED_writeKnobParameter.part.0>:
void OLED_writeKnobParameter(uint8_t whichKnob)
   19bec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19bf0:	f8df 9130 	ldr.w	r9, [pc, #304]	; 19d24 <OLED_writeKnobParameter.part.0+0x138>
void OLED_writeKnobParameter(uint8_t whichKnob)
   19bf4:	4606      	mov	r6, r0
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
   19bf6:	4f45      	ldr	r7, [pc, #276]	; (19d0c <OLED_writeKnobParameter.part.0+0x120>)
   19bf8:	2405      	movs	r4, #5
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19bfa:	f899 3000 	ldrb.w	r3, [r9]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19bfe:	0080      	lsls	r0, r0, #2
   19c00:	4943      	ldr	r1, [pc, #268]	; (19d10 <OLED_writeKnobParameter.part.0+0x124>)
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19c02:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   19c06:	f8df b120 	ldr.w	fp, [pc, #288]	; 19d28 <OLED_writeKnobParameter.part.0+0x13c>
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19c0a:	4401      	add	r1, r0
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19c0c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
void OLED_writeKnobParameter(uint8_t whichKnob)
   19c10:	ed2d 8b02 	vpush	{d8}
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
   19c14:	783a      	ldrb	r2, [r7, #0]
void OLED_writeKnobParameter(uint8_t whichKnob)
   19c16:	b083      	sub	sp, #12
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19c18:	6809      	ldr	r1, [r1, #0]
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
   19c1a:	fb14 6402 	smlabb	r4, r4, r2, r6
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19c1e:	4a3d      	ldr	r2, [pc, #244]	; (19d14 <OLED_writeKnobParameter.part.0+0x128>)
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19c20:	4423      	add	r3, r4
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19c22:	4402      	add	r2, r0
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19c24:	f85b 0023 	ldr.w	r0, [fp, r3, lsl #2]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19c28:	6011      	str	r1, [r2, #0]
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19c2a:	f012 fe6b 	bl	2c904 <strlen>
		if (len > 0)
   19c2e:	2800      	cmp	r0, #0
   19c30:	d066      	beq.n	19d00 <OLED_writeKnobParameter.part.0+0x114>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   19c32:	f04f 0800 	mov.w	r8, #0
   19c36:	f04f 0a10 	mov.w	sl, #16
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19c3a:	b2c5      	uxtb	r5, r0
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   19c3c:	4936      	ldr	r1, [pc, #216]	; (19d18 <OLED_writeKnobParameter.part.0+0x12c>)
   19c3e:	4837      	ldr	r0, [pc, #220]	; (19d1c <OLED_writeKnobParameter.part.0+0x130>)
   19c40:	f7fe fe8e 	bl	18960 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   19c44:	4641      	mov	r1, r8
   19c46:	4652      	mov	r2, sl
   19c48:	2380      	movs	r3, #128	; 0x80
   19c4a:	4834      	ldr	r0, [pc, #208]	; (19d1c <OLED_writeKnobParameter.part.0+0x130>)
   19c4c:	f8cd 8004 	str.w	r8, [sp, #4]
   19c50:	f8cd a000 	str.w	sl, [sp]
   19c54:	f7fe fa3c 	bl	180d0 <GFXfillRect>
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
   19c58:	f899 3000 	ldrb.w	r3, [r9]
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19c5c:	4641      	mov	r1, r8
   19c5e:	221c      	movs	r2, #28
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
   19c60:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19c64:	482d      	ldr	r0, [pc, #180]	; (19d1c <OLED_writeKnobParameter.part.0+0x130>)
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
   19c66:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   19c6a:	441c      	add	r4, r3
   19c6c:	f85b 4024 	ldr.w	r4, [fp, r4, lsl #2]
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19c70:	f7fe fe64 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19c74:	2020      	movs	r0, #32
   19c76:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19c7a:	f8cd 8004 	str.w	r8, [sp, #4]
   19c7e:	4652      	mov	r2, sl
   19c80:	9000      	str	r0, [sp, #0]
   19c82:	4641      	mov	r1, r8
   19c84:	009b      	lsls	r3, r3, #2
   19c86:	4825      	ldr	r0, [pc, #148]	; (19d1c <OLED_writeKnobParameter.part.0+0x130>)
   19c88:	f7fe fa22 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19c8c:	b155      	cbz	r5, 19ca4 <OLED_writeKnobParameter.part.0+0xb8>
   19c8e:	3c01      	subs	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
   19c90:	f8df 8088 	ldr.w	r8, [pc, #136]	; 19d1c <OLED_writeKnobParameter.part.0+0x130>
   19c94:	4425      	add	r5, r4
   19c96:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   19c9a:	4640      	mov	r0, r8
   19c9c:	f7fe fd9c 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19ca0:	42ac      	cmp	r4, r5
   19ca2:	d1f8      	bne.n	19c96 <OLED_writeKnobParameter.part.0+0xaa>
	return GFXgetCursorX(&theGFX);
   19ca4:	481d      	ldr	r0, [pc, #116]	; (19d1c <OLED_writeKnobParameter.part.0+0x130>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19ca6:	2420      	movs	r4, #32
	return GFXgetCursorX(&theGFX);
   19ca8:	f7fe fe4c 	bl	18944 <GFXgetCursorX>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19cac:	221c      	movs	r2, #28
   19cae:	b2c5      	uxtb	r5, r0
   19cb0:	481a      	ldr	r0, [pc, #104]	; (19d1c <OLED_writeKnobParameter.part.0+0x130>)
   19cb2:	4629      	mov	r1, r5
   19cb4:	f7fe fe42 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19cb8:	2300      	movs	r3, #0
   19cba:	4629      	mov	r1, r5
   19cbc:	2210      	movs	r2, #16
   19cbe:	4817      	ldr	r0, [pc, #92]	; (19d1c <OLED_writeKnobParameter.part.0+0x130>)
   19cc0:	e9cd 4300 	strd	r4, r3, [sp]
   19cc4:	230c      	movs	r3, #12
   19cc6:	f7fe fa03 	bl	180d0 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   19cca:	4621      	mov	r1, r4
   19ccc:	4813      	ldr	r0, [pc, #76]	; (19d1c <OLED_writeKnobParameter.part.0+0x130>)
   19cce:	f7fe fd83 	bl	187d8 <GFXwrite>
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   19cd2:	7839      	ldrb	r1, [r7, #0]
   19cd4:	2205      	movs	r2, #5
   19cd6:	4b12      	ldr	r3, [pc, #72]	; (19d20 <OLED_writeKnobParameter.part.0+0x134>)
	return GFXgetCursorX(&theGFX);
   19cd8:	4810      	ldr	r0, [pc, #64]	; (19d1c <OLED_writeKnobParameter.part.0+0x130>)
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   19cda:	fb12 6601 	smlabb	r6, r2, r1, r6
   19cde:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   19ce2:	ed96 8a00 	vldr	s16, [r6]
	return GFXgetCursorX(&theGFX);
   19ce6:	f7fe fe2d 	bl	18944 <GFXgetCursorX>
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   19cea:	2101      	movs	r1, #1
   19cec:	b2c0      	uxtb	r0, r0
   19cee:	eeb0 0a48 	vmov.f32	s0, s16
}
   19cf2:	b003      	add	sp, #12
   19cf4:	ecbd 8b02 	vpop	{d8}
   19cf8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   19cfc:	f7ff bec4 	b.w	19a88 <OLEDwriteFloat>
}
   19d00:	b003      	add	sp, #12
   19d02:	ecbd 8b02 	vpop	{d8}
   19d06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19d0a:	bf00      	nop
   19d0c:	020e2f1a 	.word	0x020e2f1a
   19d10:	020fb0ec 	.word	0x020fb0ec
   19d14:	020fb104 	.word	0x020fb104
   19d18:	00030034 	.word	0x00030034
   19d1c:	020e4538 	.word	0x020e4538
   19d20:	020fb05c 	.word	0x020fb05c
   19d24:	020e2f19 	.word	0x020e2f19
   19d28:	020fb22c 	.word	0x020fb22c

00019d2c <OLED_process>:
{
   19d2c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (writeKnobFlag >= 0)
   19d30:	4c2d      	ldr	r4, [pc, #180]	; (19de8 <OLED_process+0xbc>)
{
   19d32:	b083      	sub	sp, #12
	if (writeKnobFlag >= 0)
   19d34:	f994 0000 	ldrsb.w	r0, [r4]
   19d38:	2800      	cmp	r0, #0
   19d3a:	db03      	blt.n	19d44 <OLED_process+0x18>
	if (whichKnob < KNOB_PAGE_SIZE)
   19d3c:	2804      	cmp	r0, #4
   19d3e:	dd4e      	ble.n	19dde <OLED_process+0xb2>
		writeKnobFlag = -1;
   19d40:	23ff      	movs	r3, #255	; 0xff
   19d42:	7023      	strb	r3, [r4, #0]
	if (writeButtonFlag >= 0 && writeActionFlag >= 0) //These should always be set together
   19d44:	4e29      	ldr	r6, [pc, #164]	; (19dec <OLED_process+0xc0>)
   19d46:	f996 0000 	ldrsb.w	r0, [r6]
   19d4a:	2800      	cmp	r0, #0
   19d4c:	db44      	blt.n	19dd8 <OLED_process+0xac>
   19d4e:	4f28      	ldr	r7, [pc, #160]	; (19df0 <OLED_process+0xc4>)
   19d50:	f997 1000 	ldrsb.w	r1, [r7]
   19d54:	2900      	cmp	r1, #0
   19d56:	db3f      	blt.n	19dd8 <OLED_process+0xac>
	char* str = buttonActionFunctions[currentPreset](whichButton, whichAction);
   19d58:	4a26      	ldr	r2, [pc, #152]	; (19df4 <OLED_process+0xc8>)
   19d5a:	b2c9      	uxtb	r1, r1
   19d5c:	4b26      	ldr	r3, [pc, #152]	; (19df8 <OLED_process+0xcc>)
   19d5e:	b2c0      	uxtb	r0, r0
   19d60:	7812      	ldrb	r2, [r2, #0]
   19d62:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   19d66:	4798      	blx	r3
   19d68:	4604      	mov	r4, r0
	int len = strlen(str);
   19d6a:	f012 fdcb 	bl	2c904 <strlen>
	if (len > 0)
   19d6e:	b380      	cbz	r0, 19dd2 <OLED_process+0xa6>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   19d70:	f04f 0800 	mov.w	r8, #0
   19d74:	f04f 0910 	mov.w	r9, #16
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19d78:	b2c5      	uxtb	r5, r0
		GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   19d7a:	4920      	ldr	r1, [pc, #128]	; (19dfc <OLED_process+0xd0>)
   19d7c:	4820      	ldr	r0, [pc, #128]	; (19e00 <OLED_process+0xd4>)
   19d7e:	f7fe fdef 	bl	18960 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   19d82:	2380      	movs	r3, #128	; 0x80
   19d84:	4641      	mov	r1, r8
   19d86:	464a      	mov	r2, r9
   19d88:	481d      	ldr	r0, [pc, #116]	; (19e00 <OLED_process+0xd4>)
   19d8a:	f8cd 8004 	str.w	r8, [sp, #4]
   19d8e:	f8cd 9000 	str.w	r9, [sp]
   19d92:	f7fe f99d 	bl	180d0 <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19d96:	4641      	mov	r1, r8
   19d98:	221c      	movs	r2, #28
   19d9a:	4819      	ldr	r0, [pc, #100]	; (19e00 <OLED_process+0xd4>)
   19d9c:	f7fe fdce 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19da0:	2020      	movs	r0, #32
   19da2:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19da6:	f8cd 8004 	str.w	r8, [sp, #4]
   19daa:	9000      	str	r0, [sp, #0]
   19dac:	464a      	mov	r2, r9
   19dae:	4641      	mov	r1, r8
   19db0:	009b      	lsls	r3, r3, #2
   19db2:	4813      	ldr	r0, [pc, #76]	; (19e00 <OLED_process+0xd4>)
   19db4:	f7fe f98c 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19db8:	b15d      	cbz	r5, 19dd2 <OLED_process+0xa6>
   19dba:	4425      	add	r5, r4
		GFXwrite(&theGFX, myCharArray[i]);
   19dbc:	f8df 8040 	ldr.w	r8, [pc, #64]	; 19e00 <OLED_process+0xd4>
   19dc0:	3c01      	subs	r4, #1
   19dc2:	3d01      	subs	r5, #1
   19dc4:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   19dc8:	4640      	mov	r0, r8
   19dca:	f7fe fd05 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19dce:	42ac      	cmp	r4, r5
   19dd0:	d1f8      	bne.n	19dc4 <OLED_process+0x98>
		writeButtonFlag = -1;
   19dd2:	23ff      	movs	r3, #255	; 0xff
   19dd4:	7033      	strb	r3, [r6, #0]
		writeActionFlag = -1;
   19dd6:	703b      	strb	r3, [r7, #0]
}
   19dd8:	b003      	add	sp, #12
   19dda:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   19dde:	b2c0      	uxtb	r0, r0
   19de0:	f7ff ff04 	bl	19bec <OLED_writeKnobParameter.part.0>
   19de4:	e7ac      	b.n	19d40 <OLED_process+0x14>
   19de6:	bf00      	nop
   19de8:	0006282b 	.word	0x0006282b
   19dec:	0006282a 	.word	0x0006282a
   19df0:	00062829 	.word	0x00062829
   19df4:	020e2f19 	.word	0x020e2f19
   19df8:	020fb940 	.word	0x020fb940
   19dfc:	00030034 	.word	0x00030034
   19e00:	020e4538 	.word	0x020e4538

00019e04 <OLEDgetCursor>:
	}
}

int16_t OLEDgetCursor()
{
	return GFXgetCursorX(&theGFX);
   19e04:	4801      	ldr	r0, [pc, #4]	; (19e0c <OLEDgetCursor+0x8>)
   19e06:	f7fe bd9d 	b.w	18944 <GFXgetCursorX>
   19e0a:	bf00      	nop
   19e0c:	020e4538 	.word	0x020e4538

00019e10 <MX_RNG_Init>:

RNG_HandleTypeDef hrng;

/* RNG init function */
void MX_RNG_Init(void)
{
   19e10:	b508      	push	{r3, lr}

  hrng.Instance = RNG;
   19e12:	4b07      	ldr	r3, [pc, #28]	; (19e30 <MX_RNG_Init+0x20>)
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
   19e14:	2100      	movs	r1, #0
  hrng.Instance = RNG;
   19e16:	4a07      	ldr	r2, [pc, #28]	; (19e34 <MX_RNG_Init+0x24>)
  if (HAL_RNG_Init(&hrng) != HAL_OK)
   19e18:	4618      	mov	r0, r3
  hrng.Instance = RNG;
   19e1a:	e9c3 2100 	strd	r2, r1, [r3]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
   19e1e:	f7f6 fb3f 	bl	104a0 <HAL_RNG_Init>
   19e22:	b900      	cbnz	r0, 19e26 <MX_RNG_Init+0x16>
  {
    Error_Handler();
  }

}
   19e24:	bd08      	pop	{r3, pc}
   19e26:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
   19e2a:	f7ff baf1 	b.w	19410 <Error_Handler>
   19e2e:	bf00      	nop
   19e30:	020e455c 	.word	0x020e455c
   19e34:	48021800 	.word	0x48021800

00019e38 <HAL_RNG_MspInit>:

void HAL_RNG_MspInit(RNG_HandleTypeDef* rngHandle)
{

  if(rngHandle->Instance==RNG)
   19e38:	6802      	ldr	r2, [r0, #0]
   19e3a:	4b0a      	ldr	r3, [pc, #40]	; (19e64 <HAL_RNG_MspInit+0x2c>)
   19e3c:	429a      	cmp	r2, r3
   19e3e:	d000      	beq.n	19e42 <HAL_RNG_MspInit+0xa>
   19e40:	4770      	bx	lr
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */
    /* RNG clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
   19e42:	4b09      	ldr	r3, [pc, #36]	; (19e68 <HAL_RNG_MspInit+0x30>)
{
   19e44:	b082      	sub	sp, #8
    __HAL_RCC_RNG_CLK_ENABLE();
   19e46:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
   19e4a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   19e4e:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
   19e52:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
   19e56:	f003 0340 	and.w	r3, r3, #64	; 0x40
   19e5a:	9301      	str	r3, [sp, #4]
   19e5c:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }
}
   19e5e:	b002      	add	sp, #8
   19e60:	4770      	bx	lr
   19e62:	bf00      	nop
   19e64:	48021800 	.word	0x48021800
   19e68:	58024400 	.word	0x58024400

00019e6c <MX_SAI1_Init>:
DMA_HandleTypeDef hdma_sai1_a;
DMA_HandleTypeDef hdma_sai1_b;

/* SAI1 init function */
void MX_SAI1_Init(void)
{
   19e6c:	b570      	push	{r4, r5, r6, lr}

  hsai_BlockA1.Instance = SAI1_Block_A;
   19e6e:	481a      	ldr	r0, [pc, #104]	; (19ed8 <MX_SAI1_Init+0x6c>)
  hsai_BlockA1.Init.AudioMode = SAI_MODEMASTER_TX;
   19e70:	2500      	movs	r5, #0
  hsai_BlockA1.Instance = SAI1_Block_A;
   19e72:	4c1a      	ldr	r4, [pc, #104]	; (19edc <MX_SAI1_Init+0x70>)
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
  hsai_BlockA1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
   19e74:	2101      	movs	r1, #1
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
   19e76:	f64b 3280 	movw	r2, #48000	; 0xbb80
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
  hsai_BlockA1.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19e7a:	2302      	movs	r3, #2
  hsai_BlockA1.Instance = SAI1_Block_A;
   19e7c:	6020      	str	r0, [r4, #0]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19e7e:	4620      	mov	r0, r4
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
   19e80:	61e1      	str	r1, [r4, #28]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19e82:	4629      	mov	r1, r5
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
   19e84:	6222      	str	r2, [r4, #32]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19e86:	461a      	mov	r2, r3
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
   19e88:	60e5      	str	r5, [r4, #12]
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
   19e8a:	6365      	str	r5, [r4, #52]	; 0x34
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
   19e8c:	e9c4 5501 	strd	r5, r5, [r4, #4]
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
   19e90:	e9c4 5505 	strd	r5, r5, [r4, #20]
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
   19e94:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19e98:	f7f6 fb8a 	bl	105b0 <HAL_SAI_InitProtocol>
   19e9c:	b9c8      	cbnz	r0, 19ed2 <MX_SAI1_Init+0x66>
  {
    Error_Handler();
  }

  hsai_BlockB1.Instance = SAI1_Block_B;
   19e9e:	4c10      	ldr	r4, [pc, #64]	; (19ee0 <MX_SAI1_Init+0x74>)
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
   19ea0:	2500      	movs	r5, #0
  hsai_BlockB1.Instance = SAI1_Block_B;
   19ea2:	4910      	ldr	r1, [pc, #64]	; (19ee4 <MX_SAI1_Init+0x78>)
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
   19ea4:	2203      	movs	r2, #3
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
  hsai_BlockB1.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19ea6:	2302      	movs	r3, #2
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
   19ea8:	2601      	movs	r6, #1
  hsai_BlockB1.Instance = SAI1_Block_B;
   19eaa:	6021      	str	r1, [r4, #0]
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19eac:	4620      	mov	r0, r4
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
   19eae:	6062      	str	r2, [r4, #4]
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19eb0:	4629      	mov	r1, r5
   19eb2:	461a      	mov	r2, r3
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
   19eb4:	60a6      	str	r6, [r4, #8]
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
   19eb6:	61e6      	str	r6, [r4, #28]
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
   19eb8:	6165      	str	r5, [r4, #20]
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
   19eba:	60e5      	str	r5, [r4, #12]
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
   19ebc:	6365      	str	r5, [r4, #52]	; 0x34
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
   19ebe:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19ec2:	f7f6 fb75 	bl	105b0 <HAL_SAI_InitProtocol>
   19ec6:	b900      	cbnz	r0, 19eca <MX_SAI1_Init+0x5e>
  {
    Error_Handler();
  }

}
   19ec8:	bd70      	pop	{r4, r5, r6, pc}
   19eca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Error_Handler();
   19ece:	f7ff ba9f 	b.w	19410 <Error_Handler>
    Error_Handler();
   19ed2:	f7ff fa9d 	bl	19410 <Error_Handler>
   19ed6:	e7e2      	b.n	19e9e <MX_SAI1_Init+0x32>
   19ed8:	40015804 	.word	0x40015804
   19edc:	020e46f8 	.word	0x020e46f8
   19ee0:	020e4570 	.word	0x020e4570
   19ee4:	40015824 	.word	0x40015824

00019ee8 <HAL_SAI_MspInit>:
static uint32_t SAI1_client =0;

void HAL_SAI_MspInit(SAI_HandleTypeDef* hsai)
{
   19ee8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
/* SAI1 */
    if(hsai->Instance==SAI1_Block_A)
   19eec:	4a5e      	ldr	r2, [pc, #376]	; (1a068 <HAL_SAI_MspInit+0x180>)
{
   19eee:	b088      	sub	sp, #32
    if(hsai->Instance==SAI1_Block_A)
   19ef0:	6803      	ldr	r3, [r0, #0]
{
   19ef2:	4605      	mov	r5, r0
    if(hsai->Instance==SAI1_Block_A)
   19ef4:	4293      	cmp	r3, r2
   19ef6:	d040      	beq.n	19f7a <HAL_SAI_MspInit+0x92>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
    }
    if(hsai->Instance==SAI1_Block_B)
   19ef8:	4a5c      	ldr	r2, [pc, #368]	; (1a06c <HAL_SAI_MspInit+0x184>)
   19efa:	4293      	cmp	r3, r2
   19efc:	d002      	beq.n	19f04 <HAL_SAI_MspInit+0x1c>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
    }
}
   19efe:	b008      	add	sp, #32
   19f00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (SAI1_client == 0)
   19f04:	4c5a      	ldr	r4, [pc, #360]	; (1a070 <HAL_SAI_MspInit+0x188>)
   19f06:	6822      	ldr	r2, [r4, #0]
   19f08:	2a00      	cmp	r2, #0
   19f0a:	d07b      	beq.n	1a004 <HAL_SAI_MspInit+0x11c>
    SAI1_client ++;
   19f0c:	3201      	adds	r2, #1
    GPIO_InitStruct.Pin = GPIO_PIN_3;
   19f0e:	2008      	movs	r0, #8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   19f10:	2600      	movs	r6, #0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   19f12:	2302      	movs	r3, #2
    SAI1_client ++;
   19f14:	6022      	str	r2, [r4, #0]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   19f16:	2206      	movs	r2, #6
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19f18:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO_PIN_3;
   19f1a:	9003      	str	r0, [sp, #12]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19f1c:	4855      	ldr	r0, [pc, #340]	; (1a074 <HAL_SAI_MspInit+0x18c>)
    hdma_sai1_b.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
   19f1e:	f44f 4780 	mov.w	r7, #16384	; 0x4000
    hdma_sai1_b.Instance = DMA1_Stream2;
   19f22:	4c55      	ldr	r4, [pc, #340]	; (1a078 <HAL_SAI_MspInit+0x190>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   19f24:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
   19f26:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   19f28:	9207      	str	r2, [sp, #28]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   19f2a:	9605      	str	r6, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19f2c:	f7f1 fe48 	bl	bbc0 <HAL_GPIO_Init>
    hdma_sai1_b.Instance = DMA1_Stream2;
   19f30:	4a52      	ldr	r2, [pc, #328]	; (1a07c <HAL_SAI_MspInit+0x194>)
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
   19f32:	2358      	movs	r3, #88	; 0x58
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   19f34:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    hdma_sai1_b.Init.MemInc = DMA_MINC_ENABLE;
   19f38:	f44f 6c80 	mov.w	ip, #1024	; 0x400
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
   19f3c:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_sai1_b.Instance = DMA1_Stream2;
   19f40:	6022      	str	r2, [r4, #0]
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
   19f42:	6063      	str	r3, [r4, #4]
    hdma_sai1_b.Init.Priority = DMA_PRIORITY_VERY_HIGH;
   19f44:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   19f48:	2304      	movs	r3, #4
    hdma_sai1_b.Init.Direction = DMA_PERIPH_TO_MEMORY;
   19f4a:	60a6      	str	r6, [r4, #8]
    hdma_sai1_b.Init.PeriphInc = DMA_PINC_DISABLE;
   19f4c:	60e6      	str	r6, [r4, #12]
    hdma_sai1_b.Init.PeriphBurst = DMA_PBURST_SINGLE;
   19f4e:	6326      	str	r6, [r4, #48]	; 0x30
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   19f50:	e9c4 c004 	strd	ip, r0, [r4, #16]
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
   19f54:	4620      	mov	r0, r4
    hdma_sai1_b.Init.MemBurst = DMA_MBURST_SINGLE;
   19f56:	e9c4 660a 	strd	r6, r6, [r4, #40]	; 0x28
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
   19f5a:	e9c4 7106 	strd	r7, r1, [r4, #24]
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   19f5e:	e9c4 2308 	strd	r2, r3, [r4, #32]
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
   19f62:	f7ef ff03 	bl	9d6c <HAL_DMA_Init>
   19f66:	2800      	cmp	r0, #0
   19f68:	d162      	bne.n	1a030 <HAL_SAI_MspInit+0x148>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
   19f6a:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
   19f6e:	63a5      	str	r5, [r4, #56]	; 0x38
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
   19f70:	f8c5 4080 	str.w	r4, [r5, #128]	; 0x80
}
   19f74:	b008      	add	sp, #32
   19f76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (SAI1_client == 0)
   19f7a:	4c3d      	ldr	r4, [pc, #244]	; (1a070 <HAL_SAI_MspInit+0x188>)
   19f7c:	6822      	ldr	r2, [r4, #0]
   19f7e:	2a00      	cmp	r2, #0
   19f80:	d05c      	beq.n	1a03c <HAL_SAI_MspInit+0x154>
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5;
   19f82:	2024      	movs	r0, #36	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   19f84:	2600      	movs	r6, #0
    SAI1_client ++;
   19f86:	3201      	adds	r2, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   19f88:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   19f8a:	2303      	movs	r3, #3
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   19f8c:	f04f 0806 	mov.w	r8, #6
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19f90:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5;
   19f92:	9003      	str	r0, [sp, #12]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19f94:	4837      	ldr	r0, [pc, #220]	; (1a074 <HAL_SAI_MspInit+0x18c>)
    SAI1_client ++;
   19f96:	6022      	str	r2, [r4, #0]
    hdma_sai1_a.Instance = DMA1_Stream1;
   19f98:	4c39      	ldr	r4, [pc, #228]	; (1a080 <HAL_SAI_MspInit+0x198>)
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   19f9a:	e9cd 3806 	strd	r3, r8, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   19f9e:	e9cd 7604 	strd	r7, r6, [sp, #16]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19fa2:	f7f1 fe0d 	bl	bbc0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6;
   19fa6:	2350      	movs	r3, #80	; 0x50
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19fa8:	a903      	add	r1, sp, #12
   19faa:	4832      	ldr	r0, [pc, #200]	; (1a074 <HAL_SAI_MspInit+0x18c>)
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6;
   19fac:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   19fae:	e9cd 7806 	strd	r7, r8, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   19fb2:	e9cd 7604 	strd	r7, r6, [sp, #16]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19fb6:	f7f1 fe03 	bl	bbc0 <HAL_GPIO_Init>
    hdma_sai1_a.Instance = DMA1_Stream1;
   19fba:	4b32      	ldr	r3, [pc, #200]	; (1a084 <HAL_SAI_MspInit+0x19c>)
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
   19fbc:	2040      	movs	r0, #64	; 0x40
    hdma_sai1_a.Init.Request = DMA_REQUEST_SAI1_A;
   19fbe:	f04f 0857 	mov.w	r8, #87	; 0x57
    hdma_sai1_a.Init.MemInc = DMA_MINC_ENABLE;
   19fc2:	f44f 6e80 	mov.w	lr, #1024	; 0x400
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   19fc6:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    hdma_sai1_a.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
   19fca:	f44f 4780 	mov.w	r7, #16384	; 0x4000
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
   19fce:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_sai1_a.Init.Priority = DMA_PRIORITY_VERY_HIGH;
   19fd2:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_sai1_a.Instance = DMA1_Stream1;
   19fd6:	6023      	str	r3, [r4, #0]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   19fd8:	2304      	movs	r3, #4
    hdma_sai1_a.Init.PeriphInc = DMA_PINC_DISABLE;
   19fda:	60e6      	str	r6, [r4, #12]
    hdma_sai1_a.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
   19fdc:	62a6      	str	r6, [r4, #40]	; 0x28
    hdma_sai1_a.Init.MemBurst = DMA_MBURST_SINGLE;
   19fde:	62e6      	str	r6, [r4, #44]	; 0x2c
    hdma_sai1_a.Init.PeriphBurst = DMA_PBURST_SINGLE;
   19fe0:	6326      	str	r6, [r4, #48]	; 0x30
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
   19fe2:	e9c4 8001 	strd	r8, r0, [r4, #4]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
   19fe6:	4620      	mov	r0, r4
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   19fe8:	e9c4 ec04 	strd	lr, ip, [r4, #16]
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
   19fec:	e9c4 7106 	strd	r7, r1, [r4, #24]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   19ff0:	e9c4 2308 	strd	r2, r3, [r4, #32]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
   19ff4:	f7ef feba 	bl	9d6c <HAL_DMA_Init>
   19ff8:	b9e8      	cbnz	r0, 1a036 <HAL_SAI_MspInit+0x14e>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
   19ffa:	63a5      	str	r5, [r4, #56]	; 0x38
   19ffc:	682b      	ldr	r3, [r5, #0]
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
   19ffe:	e9c5 4420 	strd	r4, r4, [r5, #128]	; 0x80
   1a002:	e779      	b.n	19ef8 <HAL_SAI_MspInit+0x10>
       __HAL_RCC_SAI1_CLK_ENABLE();
   1a004:	4b20      	ldr	r3, [pc, #128]	; (1a088 <HAL_SAI_MspInit+0x1a0>)
      HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1a006:	2102      	movs	r1, #2
   1a008:	2057      	movs	r0, #87	; 0x57
       __HAL_RCC_SAI1_CLK_ENABLE();
   1a00a:	f8d3 60f0 	ldr.w	r6, [r3, #240]	; 0xf0
   1a00e:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
   1a012:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
   1a016:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
   1a01a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
   1a01e:	9302      	str	r3, [sp, #8]
   1a020:	9b02      	ldr	r3, [sp, #8]
      HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1a022:	f7ef fcd7 	bl	99d4 <HAL_NVIC_SetPriority>
      HAL_NVIC_EnableIRQ(SAI1_IRQn);
   1a026:	2057      	movs	r0, #87	; 0x57
   1a028:	f7ef fd1a 	bl	9a60 <HAL_NVIC_EnableIRQ>
   1a02c:	6822      	ldr	r2, [r4, #0]
   1a02e:	e76d      	b.n	19f0c <HAL_SAI_MspInit+0x24>
      Error_Handler();
   1a030:	f7ff f9ee 	bl	19410 <Error_Handler>
   1a034:	e799      	b.n	19f6a <HAL_SAI_MspInit+0x82>
      Error_Handler();
   1a036:	f7ff f9eb 	bl	19410 <Error_Handler>
   1a03a:	e7de      	b.n	19ffa <HAL_SAI_MspInit+0x112>
       __HAL_RCC_SAI1_CLK_ENABLE();
   1a03c:	4b12      	ldr	r3, [pc, #72]	; (1a088 <HAL_SAI_MspInit+0x1a0>)
    HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1a03e:	2102      	movs	r1, #2
   1a040:	2057      	movs	r0, #87	; 0x57
       __HAL_RCC_SAI1_CLK_ENABLE();
   1a042:	f8d3 60f0 	ldr.w	r6, [r3, #240]	; 0xf0
   1a046:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
   1a04a:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
   1a04e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
   1a052:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
   1a056:	9301      	str	r3, [sp, #4]
   1a058:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1a05a:	f7ef fcbb 	bl	99d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SAI1_IRQn);
   1a05e:	2057      	movs	r0, #87	; 0x57
   1a060:	f7ef fcfe 	bl	9a60 <HAL_NVIC_EnableIRQ>
   1a064:	6822      	ldr	r2, [r4, #0]
   1a066:	e78c      	b.n	19f82 <HAL_SAI_MspInit+0x9a>
   1a068:	40015804 	.word	0x40015804
   1a06c:	40015824 	.word	0x40015824
   1a070:	020e2dd4 	.word	0x020e2dd4
   1a074:	58021000 	.word	0x58021000
   1a078:	020e4680 	.word	0x020e4680
   1a07c:	40020040 	.word	0x40020040
   1a080:	020e4608 	.word	0x020e4608
   1a084:	40020028 	.word	0x40020028
   1a088:	58024400 	.word	0x58024400

0001a08c <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
   1a08c:	b538      	push	{r3, r4, r5, lr}
Stat = STA_NOINIT;  
   1a08e:	4c0a      	ldr	r4, [pc, #40]	; (1a0b8 <SD_initialize+0x2c>)
   1a090:	2501      	movs	r5, #1
   1a092:	7025      	strb	r5, [r4, #0]

#if !defined(DISABLE_SD_INIT)

  if(BSP_SD_Init() == MSD_OK)
   1a094:	f7fd f99a 	bl	173cc <BSP_SD_Init>
   1a098:	b108      	cbz	r0, 1a09e <SD_initialize+0x12>

#else
  Stat = SD_CheckStatus(lun);
#endif

  return Stat;
   1a09a:	7820      	ldrb	r0, [r4, #0]
}
   1a09c:	bd38      	pop	{r3, r4, r5, pc}
  Stat = STA_NOINIT;
   1a09e:	7025      	strb	r5, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
   1a0a0:	f7fd f974 	bl	1738c <BSP_SD_GetCardState>
   1a0a4:	b918      	cbnz	r0, 1a0ae <SD_initialize+0x22>
    Stat &= ~STA_NOINIT;
   1a0a6:	7823      	ldrb	r3, [r4, #0]
   1a0a8:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   1a0ac:	7023      	strb	r3, [r4, #0]
  return Stat;
   1a0ae:	7823      	ldrb	r3, [r4, #0]
   1a0b0:	b2db      	uxtb	r3, r3
    Stat = SD_CheckStatus(lun);
   1a0b2:	7023      	strb	r3, [r4, #0]
  return Stat;
   1a0b4:	7820      	ldrb	r0, [r4, #0]
}
   1a0b6:	bd38      	pop	{r3, r4, r5, pc}
   1a0b8:	00062594 	.word	0x00062594

0001a0bc <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
   1a0bc:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
   1a0be:	2301      	movs	r3, #1
   1a0c0:	4c05      	ldr	r4, [pc, #20]	; (1a0d8 <SD_status+0x1c>)
   1a0c2:	7023      	strb	r3, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
   1a0c4:	f7fd f962 	bl	1738c <BSP_SD_GetCardState>
   1a0c8:	b918      	cbnz	r0, 1a0d2 <SD_status+0x16>
    Stat &= ~STA_NOINIT;
   1a0ca:	7823      	ldrb	r3, [r4, #0]
   1a0cc:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   1a0d0:	7023      	strb	r3, [r4, #0]
  return Stat;
   1a0d2:	7820      	ldrb	r0, [r4, #0]
  return SD_CheckStatus(lun);
}
   1a0d4:	bd10      	pop	{r4, pc}
   1a0d6:	bf00      	nop
   1a0d8:	00062594 	.word	0x00062594

0001a0dc <SD_read>:
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
              
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
   1a0dc:	b508      	push	{r3, lr}
   1a0de:	4608      	mov	r0, r1
   1a0e0:	4611      	mov	r1, r2
   1a0e2:	461a      	mov	r2, r3
  DRESULT res = RES_ERROR;

  if(BSP_SD_ReadBlocks((uint32_t*)buff,
   1a0e4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a0e8:	f7fd f92c 	bl	17344 <BSP_SD_ReadBlocks>
   1a0ec:	b920      	cbnz	r0, 1a0f8 <SD_read+0x1c>
                       (uint32_t) (sector),
                       count, SD_TIMEOUT) == MSD_OK)
  {
    /* wait until the read operation is finished */
    while(BSP_SD_GetCardState()!= MSD_OK)
   1a0ee:	f7fd f94d 	bl	1738c <BSP_SD_GetCardState>
   1a0f2:	2800      	cmp	r0, #0
   1a0f4:	d1fb      	bne.n	1a0ee <SD_read+0x12>
    }
    res = RES_OK;
  }

  return res;
}
   1a0f6:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
   1a0f8:	2001      	movs	r0, #1
}
   1a0fa:	bd08      	pop	{r3, pc}

0001a0fc <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
   1a0fc:	4b16      	ldr	r3, [pc, #88]	; (1a158 <SD_ioctl+0x5c>)
   1a0fe:	781b      	ldrb	r3, [r3, #0]
   1a100:	07db      	lsls	r3, r3, #31
   1a102:	d408      	bmi.n	1a116 <SD_ioctl+0x1a>
{
   1a104:	b510      	push	{r4, lr}
   1a106:	4614      	mov	r4, r2
   1a108:	b08a      	sub	sp, #40	; 0x28

  switch (cmd)
   1a10a:	2903      	cmp	r1, #3
   1a10c:	d821      	bhi.n	1a152 <SD_ioctl+0x56>
   1a10e:	e8df f001 	tbb	[pc, r1]
   1a112:	0704      	.short	0x0704
   1a114:	170f      	.short	0x170f
  if (Stat & STA_NOINIT) return RES_NOTRDY;
   1a116:	2003      	movs	r0, #3
  default:
    res = RES_PARERR;
  }

  return res;
}
   1a118:	4770      	bx	lr
    res = RES_OK;
   1a11a:	2000      	movs	r0, #0
}
   1a11c:	b00a      	add	sp, #40	; 0x28
   1a11e:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
   1a120:	a801      	add	r0, sp, #4
   1a122:	f7fd f93d 	bl	173a0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
   1a126:	9b07      	ldr	r3, [sp, #28]
    res = RES_OK;
   1a128:	2000      	movs	r0, #0
    *(DWORD*)buff = CardInfo.LogBlockNbr;
   1a12a:	6023      	str	r3, [r4, #0]
}
   1a12c:	b00a      	add	sp, #40	; 0x28
   1a12e:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
   1a130:	a801      	add	r0, sp, #4
   1a132:	f7fd f935 	bl	173a0 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
   1a136:	9b08      	ldr	r3, [sp, #32]
    res = RES_OK;
   1a138:	2000      	movs	r0, #0
    *(WORD*)buff = CardInfo.LogBlockSize;
   1a13a:	8023      	strh	r3, [r4, #0]
}
   1a13c:	b00a      	add	sp, #40	; 0x28
   1a13e:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
   1a140:	a801      	add	r0, sp, #4
   1a142:	f7fd f92d 	bl	173a0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
   1a146:	9b08      	ldr	r3, [sp, #32]
   1a148:	2000      	movs	r0, #0
   1a14a:	0a5b      	lsrs	r3, r3, #9
   1a14c:	6023      	str	r3, [r4, #0]
}
   1a14e:	b00a      	add	sp, #40	; 0x28
   1a150:	bd10      	pop	{r4, pc}
    res = RES_PARERR;
   1a152:	2004      	movs	r0, #4
}
   1a154:	b00a      	add	sp, #40	; 0x28
   1a156:	bd10      	pop	{r4, pc}
   1a158:	00062594 	.word	0x00062594

0001a15c <SD_write>:
{
   1a15c:	b508      	push	{r3, lr}
   1a15e:	4608      	mov	r0, r1
   1a160:	4611      	mov	r1, r2
   1a162:	461a      	mov	r2, r3
  if(BSP_SD_WriteBlocks((uint32_t*)buff,
   1a164:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a168:	f7fd f8fe 	bl	17368 <BSP_SD_WriteBlocks>
   1a16c:	b920      	cbnz	r0, 1a178 <SD_write+0x1c>
    while(BSP_SD_GetCardState()!= MSD_OK)
   1a16e:	f7fd f90d 	bl	1738c <BSP_SD_GetCardState>
   1a172:	2800      	cmp	r0, #0
   1a174:	d1fb      	bne.n	1a16e <SD_write+0x12>
}
   1a176:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
   1a178:	2001      	movs	r0, #1
}
   1a17a:	bd08      	pop	{r3, pc}

0001a17c <MX_SDMMC1_SD_Init>:
SD_HandleTypeDef hsd1;

/* SDMMC1 init function */

void MX_SDMMC1_SD_Init(void)
{
   1a17c:	b410      	push	{r4}

  hsd1.Instance = SDMMC1;
   1a17e:	4b08      	ldr	r3, [pc, #32]	; (1a1a0 <MX_SDMMC1_SD_Init+0x24>)
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
   1a180:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  hsd1.Instance = SDMMC1;
   1a184:	4807      	ldr	r0, [pc, #28]	; (1a1a4 <MX_SDMMC1_SD_Init+0x28>)
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
  hsd1.Init.ClockDiv = 0;
  hsd1.Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
   1a186:	2101      	movs	r1, #1
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
   1a188:	2200      	movs	r2, #0
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
   1a18a:	60dc      	str	r4, [r3, #12]
  hsd1.Instance = SDMMC1;
   1a18c:	6018      	str	r0, [r3, #0]
  hsd1.Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
   1a18e:	6199      	str	r1, [r3, #24]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
   1a190:	e9c3 2201 	strd	r2, r2, [r3, #4]
  hsd1.Init.ClockDiv = 0;
   1a194:	e9c3 2204 	strd	r2, r2, [r3, #16]

}
   1a198:	f85d 4b04 	ldr.w	r4, [sp], #4
   1a19c:	4770      	bx	lr
   1a19e:	bf00      	nop
   1a1a0:	020e4790 	.word	0x020e4790
   1a1a4:	52007000 	.word	0x52007000

0001a1a8 <HAL_SD_MspInit>:

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
   1a1a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(sdHandle->Instance==SDMMC1)
   1a1ac:	4b2e      	ldr	r3, [pc, #184]	; (1a268 <HAL_SD_MspInit+0xc0>)
{
   1a1ae:	b088      	sub	sp, #32
  if(sdHandle->Instance==SDMMC1)
   1a1b0:	6802      	ldr	r2, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1a1b2:	2400      	movs	r4, #0
  if(sdHandle->Instance==SDMMC1)
   1a1b4:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1a1b6:	9407      	str	r4, [sp, #28]
   1a1b8:	e9cd 4403 	strd	r4, r4, [sp, #12]
   1a1bc:	e9cd 4405 	strd	r4, r4, [sp, #20]
  if(sdHandle->Instance==SDMMC1)
   1a1c0:	d002      	beq.n	1a1c8 <HAL_SD_MspInit+0x20>

  /* USER CODE BEGIN SDMMC1_MspInit 1 */

  /* USER CODE END SDMMC1_MspInit 1 */
  }
}
   1a1c2:	b008      	add	sp, #32
   1a1c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_SDMMC1_CLK_ENABLE();
   1a1c8:	4b28      	ldr	r3, [pc, #160]	; (1a26c <HAL_SD_MspInit+0xc4>)
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1a1ca:	250c      	movs	r5, #12
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
   1a1cc:	f44f 6070 	mov.w	r0, #3840	; 0xf00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1a1d0:	2702      	movs	r7, #2
    __HAL_RCC_SDMMC1_CLK_ENABLE();
   1a1d2:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   1a1d6:	2603      	movs	r6, #3
    GPIO_InitStruct.Pull = GPIO_PULLUP;
   1a1d8:	f04f 0801 	mov.w	r8, #1
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a1dc:	eb0d 0105 	add.w	r1, sp, r5
    __HAL_RCC_SDMMC1_CLK_ENABLE();
   1a1e0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   1a1e4:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
   1a1e8:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
   1a1ec:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
   1a1f0:	9200      	str	r2, [sp, #0]
   1a1f2:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOC_CLK_ENABLE();
   1a1f4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1a1f8:	f042 0204 	orr.w	r2, r2, #4
   1a1fc:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   1a200:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1a204:	f002 0204 	and.w	r2, r2, #4
   1a208:	9201      	str	r2, [sp, #4]
   1a20a:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1a20c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1a210:	f042 0208 	orr.w	r2, r2, #8
   1a214:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   1a218:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
   1a21c:	9003      	str	r0, [sp, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1a21e:	f003 0308 	and.w	r3, r3, #8
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a222:	4813      	ldr	r0, [pc, #76]	; (1a270 <HAL_SD_MspInit+0xc8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1a224:	9704      	str	r7, [sp, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1a226:	9302      	str	r3, [sp, #8]
   1a228:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1a22a:	9507      	str	r5, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   1a22c:	e9cd 8605 	strd	r8, r6, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a230:	f7f1 fcc6 	bl	bbc0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_12;
   1a234:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a238:	eb0d 0105 	add.w	r1, sp, r5
   1a23c:	480c      	ldr	r0, [pc, #48]	; (1a270 <HAL_SD_MspInit+0xc8>)
    GPIO_InitStruct.Pin = GPIO_PIN_12;
   1a23e:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1a240:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a242:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1a244:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a248:	f7f1 fcba 	bl	bbc0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2;
   1a24c:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1a24e:	eb0d 0105 	add.w	r1, sp, r5
   1a252:	4808      	ldr	r0, [pc, #32]	; (1a274 <HAL_SD_MspInit+0xcc>)
    GPIO_InitStruct.Pin = GPIO_PIN_2;
   1a254:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
   1a256:	e9cd 7804 	strd	r7, r8, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1a25a:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1a25e:	f7f1 fcaf 	bl	bbc0 <HAL_GPIO_Init>
}
   1a262:	b008      	add	sp, #32
   1a264:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a268:	52007000 	.word	0x52007000
   1a26c:	58024400 	.word	0x58024400
   1a270:	58020800 	.word	0x58020800
   1a274:	58020c00 	.word	0x58020c00

0001a278 <initGlobalSFXObjects>:
        float oversamplerArray[MAX_OVERSAMPLER_RATIO];



        void initGlobalSFXObjects()
        {
   1a278:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        void calculateNoteArray()
        {
            for (int i = 0; i < 128; i++)
            {
                float tempNote = i;
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1a27c:	4beb      	ldr	r3, [pc, #940]	; (1a62c <initGlobalSFXObjects+0x3b4>)
            for (int i = 0; i < 128; i++)
   1a27e:	2000      	movs	r0, #0
   1a280:	4ceb      	ldr	r4, [pc, #940]	; (1a630 <initGlobalSFXObjects+0x3b8>)
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1a282:	781f      	ldrb	r7, [r3, #0]
   1a284:	4eeb      	ldr	r6, [pc, #940]	; (1a634 <initGlobalSFXObjects+0x3bc>)
   1a286:	4dec      	ldr	r5, [pc, #944]	; (1a638 <initGlobalSFXObjects+0x3c0>)
                float tempNote = i;
   1a288:	ee07 0a90 	vmov	s15, r0
            for (int i = 0; i < 128; i++)
   1a28c:	3001      	adds	r0, #1
                float tempNote = i;
   1a28e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            for (int i = 0; i < 128; i++)
   1a292:	2880      	cmp	r0, #128	; 0x80
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1a294:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1a298:	ee17 3a90 	vmov	r3, s15
   1a29c:	eba3 0307 	sub.w	r3, r3, r7
   1a2a0:	fb85 2103 	smull	r2, r1, r5, r3
   1a2a4:	ea4f 72e3 	mov.w	r2, r3, asr #31
   1a2a8:	ebc2 0261 	rsb	r2, r2, r1, asr #1
   1a2ac:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1a2b0:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1a2b4:	ee07 3a90 	vmov	s15, r3
   1a2b8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1a2bc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1a2c0:	ee17 3a90 	vmov	r3, s15
   1a2c4:	eb06 0383 	add.w	r3, r6, r3, lsl #2
   1a2c8:	edd3 7a00 	vldr	s15, [r3]
   1a2cc:	ee37 7a87 	vadd.f32	s14, s15, s14
                notes[i] = tunedNote;
   1a2d0:	eca4 7a01 	vstmia	r4!, {s14}
            for (int i = 0; i < 128; i++)
   1a2d4:	d1d8      	bne.n	1a288 <initGlobalSFXObjects+0x10>
   1a2d6:	4cd9      	ldr	r4, [pc, #868]	; (1a63c <initGlobalSFXObjects+0x3c4>)
                tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
   1a2d8:	2600      	movs	r6, #0
   1a2da:	f8df a3b4 	ldr.w	sl, [pc, #948]	; 1a690 <initGlobalSFXObjects+0x418>
            tSimplePoly_initToPool(&poly, NUM_VOC_VOICES, &smallPool);
   1a2de:	2108      	movs	r1, #8
   1a2e0:	f104 0720 	add.w	r7, r4, #32
                tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
   1a2e4:	4dd6      	ldr	r5, [pc, #856]	; (1a640 <initGlobalSFXObjects+0x3c8>)
            tSimplePoly_initToPool(&poly, NUM_VOC_VOICES, &smallPool);
   1a2e6:	4ad6      	ldr	r2, [pc, #856]	; (1a640 <initGlobalSFXObjects+0x3c8>)
   1a2e8:	48d6      	ldr	r0, [pc, #856]	; (1a644 <initGlobalSFXObjects+0x3cc>)
   1a2ea:	f00f fdab 	bl	29e44 <tSimplePoly_initToPool>
                tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
   1a2ee:	4620      	mov	r0, r4
   1a2f0:	3404      	adds	r4, #4
   1a2f2:	4629      	mov	r1, r5
   1a2f4:	eddf 0ad4 	vldr	s1, [pc, #848]	; 1a648 <initGlobalSFXObjects+0x3d0>
   1a2f8:	ed9f 0ad4 	vldr	s0, [pc, #848]	; 1a64c <initGlobalSFXObjects+0x3d4>
   1a2fc:	f00d fd44 	bl	27d88 <tExpSmooth_initToPool>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
   1a300:	42a7      	cmp	r7, r4
   1a302:	d1f4      	bne.n	1a2ee <initGlobalSFXObjects+0x76>
            tExpSmooth_init(&comp, 1.0f, 0.01f);
   1a304:	eddf 0ad2 	vldr	s1, [pc, #840]	; 1a650 <initGlobalSFXObjects+0x3d8>
   1a308:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1a30c:	48d1      	ldr	r0, [pc, #836]	; (1a654 <initGlobalSFXObjects+0x3dc>)
            defaultPresetKnobValues[VocoderCh][2] = 1.0f; // quality
   1a30e:	f04f 547e 	mov.w	r4, #1065353216	; 0x3f800000
            tExpSmooth_init(&comp, 1.0f, 0.01f);
   1a312:	f00d fd0f 	bl	27d34 <tExpSmooth_init>
            LEAF_generate_exp(expBuffer, 1000.0f, -1.0f, 0.0f, -0.0008f, EXP_BUFFER_SIZE); //exponential buffer rising from 0 to 1
   1a316:	2180      	movs	r1, #128	; 0x80
   1a318:	eddf 1acf 	vldr	s3, [pc, #828]	; 1a658 <initGlobalSFXObjects+0x3e0>
   1a31c:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
   1a320:	ed9f 1aca 	vldr	s2, [pc, #808]	; 1a64c <initGlobalSFXObjects+0x3d4>
   1a324:	ed9f 0acd 	vldr	s0, [pc, #820]	; 1a65c <initGlobalSFXObjects+0x3e4>
   1a328:	48cd      	ldr	r0, [pc, #820]	; (1a660 <initGlobalSFXObjects+0x3e8>)
   1a32a:	f00f fa71 	bl	29810 <LEAF_generate_exp>
            LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE); // exponential decay buffer falling from 1 to 0
   1a32e:	f44f 7100 	mov.w	r1, #512	; 0x200
   1a332:	48cc      	ldr	r0, [pc, #816]	; (1a664 <initGlobalSFXObjects+0x3ec>)
   1a334:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   1a338:	eddf 1ac7 	vldr	s3, [pc, #796]	; 1a658 <initGlobalSFXObjects+0x3e0>
   1a33c:	eddf 0ac3 	vldr	s1, [pc, #780]	; 1a64c <initGlobalSFXObjects+0x3d4>
   1a340:	ed9f 0ac9 	vldr	s0, [pc, #804]	; 1a668 <initGlobalSFXObjects+0x3f0>
   1a344:	f00f fa64 	bl	29810 <LEAF_generate_exp>
            defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
   1a348:	4bc8      	ldr	r3, [pc, #800]	; (1a66c <initGlobalSFXObjects+0x3f4>)
            defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
   1a34a:	48c9      	ldr	r0, [pc, #804]	; (1a670 <initGlobalSFXObjects+0x3f8>)
            defaultPresetKnobValues[Vocoder][1] = 0.5f; // warp factor
   1a34c:	f04f 527c 	mov.w	r2, #1056964608	; 0x3f000000
            defaultPresetKnobValues[Pitchshift][5] = 0.25f; //offset
   1a350:	f04f 517a 	mov.w	r1, #1048576000	; 0x3e800000
            defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
   1a354:	4fc7      	ldr	r7, [pc, #796]	; (1a674 <initGlobalSFXObjects+0x3fc>)
            defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
   1a356:	f8df c33c 	ldr.w	ip, [pc, #828]	; 1a694 <initGlobalSFXObjects+0x41c>
            defaultPresetKnobValues[SamplerButtonPress][2] = 0.75f; // speed
   1a35a:	f04f 5e7d 	mov.w	lr, #1061158912	; 0x3f400000
            defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
   1a35e:	f8df 8338 	ldr.w	r8, [pc, #824]	; 1a698 <initGlobalSFXObjects+0x420>
            defaultPresetKnobValues[Delay][0] = 0.25f; // delayL
   1a362:	f203 494c 	addw	r9, r3, #1100	; 0x44c
            defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
   1a366:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
            defaultPresetKnobValues[Delay][1] = 0.25f; // delayR
   1a36a:	f503 6b8a 	add.w	fp, r3, #1104	; 0x450
            defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
   1a36e:	48c2      	ldr	r0, [pc, #776]	; (1a678 <initGlobalSFXObjects+0x400>)
            defaultPresetKnobValues[Vocoder][5] = 0.02f; // breathiness
   1a370:	f8c3 a014 	str.w	sl, [r3, #20]
            defaultPresetKnobValues[Delay][3] = 1.0f; // lowpass
   1a374:	f503 6a8b 	add.w	sl, r3, #1112	; 0x458
            defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
   1a378:	601f      	str	r7, [r3, #0]
            defaultPresetKnobValues[VocoderCh][0] = 0.4f; // volume
   1a37a:	665f      	str	r7, [r3, #100]	; 0x64
            defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
   1a37c:	f8c3 8008 	str.w	r8, [r3, #8]
            defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
   1a380:	f8c3 c010 	str.w	ip, [r3, #16]
            defaultPresetKnobValues[VocoderCh][4] = 0.2f; //noise thresh
   1a384:	f8c3 c074 	str.w	ip, [r3, #116]	; 0x74
            defaultPresetKnobValues[VocoderCh][2] = 1.0f; // quality
   1a388:	66dc      	str	r4, [r3, #108]	; 0x6c
            defaultPresetKnobValues[Pitchshift][5] = 0.25f; //offset
   1a38a:	f8c3 10dc 	str.w	r1, [r3, #220]	; 0xdc
            defaultPresetKnobValues[Pitchshift][6] = 0.25f;
   1a38e:	f8c3 10e0 	str.w	r1, [r3, #224]	; 0xe0
            defaultPresetKnobValues[Vocoder][3] = 0.0f; // sawToPulse
   1a392:	60de      	str	r6, [r3, #12]
            defaultPresetKnobValues[Vocoder][9] = 0.0f;
   1a394:	625e      	str	r6, [r3, #36]	; 0x24
            defaultPresetKnobValues[VocoderCh][5] = 0.0f;// saw->pulse fade
   1a396:	679e      	str	r6, [r3, #120]	; 0x78
            defaultPresetKnobValues[VocoderCh][8] = 0.0f; // breathiness
   1a398:	f8c3 6084 	str.w	r6, [r3, #132]	; 0x84
            defaultPresetKnobValues[VocoderCh][13] = 0.0f; // stereo
   1a39c:	f8c3 6098 	str.w	r6, [r3, #152]	; 0x98
            defaultPresetKnobValues[VocoderCh][14] = 0.0f; // barkpull
   1a3a0:	f8c3 609c 	str.w	r6, [r3, #156]	; 0x9c
            defaultPresetKnobValues[Pitchshift][2] = 0.0f; // f amount
   1a3a4:	f8c3 60d0 	str.w	r6, [r3, #208]	; 0xd0
            defaultPresetKnobValues[Vocoder][1] = 0.5f; // warp factor
   1a3a8:	605a      	str	r2, [r3, #4]
            defaultPresetKnobValues[Vocoder][6] = 0.5f; // tilt
   1a3aa:	619a      	str	r2, [r3, #24]
            defaultPresetKnobValues[Vocoder][7] = 0.5f; // pulse width
   1a3ac:	61da      	str	r2, [r3, #28]
            defaultPresetKnobValues[Vocoder][8] = 0.5f; // pulse shape
   1a3ae:	621a      	str	r2, [r3, #32]
            defaultPresetKnobValues[VocoderCh][1] = 0.5f; // warp factor
   1a3b0:	669a      	str	r2, [r3, #104]	; 0x68
            defaultPresetKnobValues[VocoderCh][3] = 0.5f; //band width
   1a3b2:	671a      	str	r2, [r3, #112]	; 0x70
            defaultPresetKnobValues[VocoderCh][6] = 0.5f; // pulse length
   1a3b4:	67da      	str	r2, [r3, #124]	; 0x7c
            defaultPresetKnobValues[VocoderCh][7] = 0.5f; // pulse width
   1a3b6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
            defaultPresetKnobValues[VocoderCh][10] = 0.5f;// squish
   1a3ba:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            defaultPresetKnobValues[VocoderCh][11] = 0.5f; // offset
   1a3be:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
            defaultPresetKnobValues[VocoderCh][12] = 0.5f; // tilt
   1a3c2:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
            defaultPresetKnobValues[Pitchshift][0] = 0.5f; // pitch
   1a3c6:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
            defaultPresetKnobValues[Pitchshift][1] = 0.5f; // fine pitch
   1a3ca:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
            defaultPresetKnobValues[Pitchshift][3] = 0.5f; // formant
   1a3ce:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
            defaultPresetKnobValues[Pitchshift][4] = 0.5f; //range
   1a3d2:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
            defaultPresetKnobValues[Pitchshift][7] = 0.25f;
   1a3d6:	f8c3 10e4 	str.w	r1, [r3, #228]	; 0xe4
            defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
   1a3da:	f8c3 02bc 	str.w	r0, [r3, #700]	; 0x2bc
            defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
   1a3de:	48a7      	ldr	r0, [pc, #668]	; (1a67c <initGlobalSFXObjects+0x404>)
            defaultPresetKnobValues[Pitchshift][8] = 0.25f;
   1a3e0:	f8c3 10e8 	str.w	r1, [r3, #232]	; 0xe8
            defaultPresetKnobValues[Pitchshift][9] = 0.25f;
   1a3e4:	f8c3 10ec 	str.w	r1, [r3, #236]	; 0xec
            defaultPresetKnobValues[AutotuneMono][1] = 1.0f; // amount
   1a3e8:	f8c3 4130 	str.w	r4, [r3, #304]	; 0x130
            defaultPresetKnobValues[AutotuneMono][3] = 1.0f; // leap allow
   1a3ec:	f8c3 4138 	str.w	r4, [r3, #312]	; 0x138
            defaultPresetKnobValues[AutotuneMono][4] = 0.25f; // hysteresis
   1a3f0:	f8c3 113c 	str.w	r1, [r3, #316]	; 0x13c
            defaultPresetKnobValues[AutotunePoly][0] = 1.0f; // fidelity thresh
   1a3f4:	f8c3 4190 	str.w	r4, [r3, #400]	; 0x190
            defaultPresetKnobValues[SamplerButtonPress][1] = 1.0f; // end
   1a3f8:	f8c3 41f8 	str.w	r4, [r3, #504]	; 0x1f8
            defaultPresetKnobValues[SamplerButtonPress][4] = 0.4f;//crossfade
   1a3fc:	f8c3 7204 	str.w	r7, [r3, #516]	; 0x204
            defaultPresetKnobValues[SamplerKeyboard][1] = 1.0f; // end
   1a400:	f8c3 425c 	str.w	r4, [r3, #604]	; 0x25c
            defaultPresetKnobValues[SamplerKeyboard][5] = 0.4f;//crossfade
   1a404:	f8c3 726c 	str.w	r7, [r3, #620]	; 0x26c
            defaultPresetKnobValues[SamplerAutoGrab][3] = 0.25f; // crossfade
   1a408:	f8c3 12c8 	str.w	r1, [r3, #712]	; 0x2c8
            defaultPresetKnobValues[SamplerButtonPress][2] = 0.75f; // speed
   1a40c:	f8c3 e1fc 	str.w	lr, [r3, #508]	; 0x1fc
            defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
   1a410:	f8c3 0198 	str.w	r0, [r3, #408]	; 0x198
            defaultPresetKnobValues[SamplerKeyboard][2] = 0.75f; // speed
   1a414:	f8c3 e260 	str.w	lr, [r3, #608]	; 0x260
            defaultPresetKnobValues[SamplerAutoGrab][2] = 0.75f; // speed
   1a418:	f8c3 e2c4 	str.w	lr, [r3, #708]	; 0x2c4
            defaultPresetKnobValues[AutotuneMono][0] = 0.0f; // pickiness
   1a41c:	f8c3 612c 	str.w	r6, [r3, #300]	; 0x12c
            defaultPresetKnobValues[AutotuneMono][2] = 0.5f; // speed
   1a420:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
            defaultPresetKnobValues[AutotunePoly][1] = 0.5f;
   1a424:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
            defaultPresetKnobValues[AutotunePoly][3] = 0.0f;
   1a428:	f8c3 619c 	str.w	r6, [r3, #412]	; 0x19c
            defaultPresetKnobValues[AutotunePoly][4] = 0.0f;
   1a42c:	f8c3 61a0 	str.w	r6, [r3, #416]	; 0x1a0
            defaultPresetKnobValues[SamplerButtonPress][0] = 0.0f; // start
   1a430:	f8c3 61f4 	str.w	r6, [r3, #500]	; 0x1f4
            defaultPresetKnobValues[SamplerButtonPress][3] = 0.5f; // speed mult
   1a434:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
            defaultPresetKnobValues[SamplerKeyboard][0] = 0.0f; // start
   1a438:	f8c3 6258 	str.w	r6, [r3, #600]	; 0x258
            defaultPresetKnobValues[SamplerKeyboard][3] = 0.5f; // speed mult
   1a43c:	f8c3 2264 	str.w	r2, [r3, #612]	; 0x264
            defaultPresetKnobValues[SamplerKeyboard][4] = 0.0f; //looping on
   1a440:	f8c3 6268 	str.w	r6, [r3, #616]	; 0x268
            defaultPresetKnobValues[SamplerKeyboard][6] = 0.0f;//velocity sensitivity
   1a444:	f8c3 6270 	str.w	r6, [r3, #624]	; 0x270
            defaultPresetKnobValues[SamplerAutoGrab][1] = 0.5f; // window
   1a448:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0
            defaultPresetKnobValues[SamplerAutoGrab][4] = 0.0f;
   1a44c:	f8c3 62cc 	str.w	r6, [r3, #716]	; 0x2cc
            defaultPresetKnobValues[SamplerAutoGrab][5] = 0.0f; // len rand
   1a450:	f8c3 62d0 	str.w	r6, [r3, #720]	; 0x2d0
            defaultPresetKnobValues[SamplerAutoGrab][6] = 0.0f; // speed rand
   1a454:	f8c3 62d4 	str.w	r6, [r3, #724]	; 0x2d4
            defaultPresetKnobValues[SamplerAutoGrab][7] = 0.0f;
   1a458:	f8c3 62d8 	str.w	r6, [r3, #728]	; 0x2d8
            defaultPresetKnobValues[SamplerAutoGrab][8] = 0.0f;
   1a45c:	f8c3 62dc 	str.w	r6, [r3, #732]	; 0x2dc
            defaultPresetKnobValues[Delay][0] = 0.25f; // delayL
   1a460:	f8c9 1000 	str.w	r1, [r9]
            defaultPresetKnobValues[Delay][4] = 0.5f; // feedback
   1a464:	f203 495c 	addw	r9, r3, #1116	; 0x45c
            defaultPresetKnobValues[Delay][3] = 1.0f; // lowpass
   1a468:	f8ca 4000 	str.w	r4, [sl]
            defaultPresetKnobValues[Reverb][1] = 0.5f; // in lowpass
   1a46c:	f203 4ab4 	addw	sl, r3, #1204	; 0x4b4
            defaultPresetKnobValues[Wavefolder][3] = 0.75f; // post gain
   1a470:	f8c3 e390 	str.w	lr, [r3, #912]	; 0x390
            defaultPresetKnobValues[Delay][5] = 1.0f; // post gain
   1a474:	f503 6e8c 	add.w	lr, r3, #1120	; 0x460
            defaultPresetKnobValues[Delay][1] = 0.25f; // delayR
   1a478:	f8cb 1000 	str.w	r1, [fp]
            defaultPresetKnobValues[Reverb][0] = 0.5f; // size
   1a47c:	f503 6b96 	add.w	fp, r3, #1200	; 0x4b0
            defaultPresetKnobValues[Delay][5] = 1.0f; // post gain
   1a480:	f8ce 4000 	str.w	r4, [lr]
            defaultPresetKnobValues[Reverb][3] = 0.5f; // fb lowpass
   1a484:	f203 4ebc 	addw	lr, r3, #1212	; 0x4bc
            defaultPresetKnobValues[Delay][4] = 0.5f; // feedback
   1a488:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[Reverb][2] = 0.5f; // in highpass
   1a48c:	f503 6997 	add.w	r9, r3, #1208	; 0x4b8
            defaultPresetKnobValues[Reverb][1] = 0.5f; // in lowpass
   1a490:	f8ca 2000 	str.w	r2, [sl]
            defaultPresetKnobValues[Reverb2][0] = 0.2f; // size
   1a494:	f203 5a14 	addw	sl, r3, #1300	; 0x514
            defaultPresetKnobValues[Reverb][0] = 0.5f; // size
   1a498:	f8cb 2000 	str.w	r2, [fp]
            defaultPresetKnobValues[Reverb][4] = 0.5f; // fb gain
   1a49c:	f503 6b98 	add.w	fp, r3, #1216	; 0x4c0
            defaultPresetKnobValues[Reverb2][0] = 0.2f; // size
   1a4a0:	f8ca c000 	str.w	ip, [sl]
            defaultPresetKnobValues[Delay][2] = 0.0f; // highpass
   1a4a4:	f203 4a54 	addw	sl, r3, #1108	; 0x454
            defaultPresetKnobValues[Reverb][2] = 0.5f; // in highpass
   1a4a8:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[Reverb2][1] = 0.5f; // lowpass
   1a4ac:	f503 69a3 	add.w	r9, r3, #1304	; 0x518
            defaultPresetKnobValues[Reverb][3] = 0.5f; // fb lowpass
   1a4b0:	f8ce 2000 	str.w	r2, [lr]
            defaultPresetKnobValues[Reverb2][2] = 0.5f; // highpass
   1a4b4:	f203 5e1c 	addw	lr, r3, #1308	; 0x51c
            defaultPresetKnobValues[Reverb][4] = 0.5f; // fb gain
   1a4b8:	f8cb 2000 	str.w	r2, [fp]
            defaultPresetKnobValues[Reverb2][3] = 0.5f; // peak freq
   1a4bc:	f503 6ba4 	add.w	fp, r3, #1312	; 0x520
            defaultPresetKnobValues[Reverb2][1] = 0.5f; // lowpass
   1a4c0:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[Reverb2][4] = 0.5f; // peak gain
   1a4c4:	f203 5924 	addw	r9, r3, #1316	; 0x524
            defaultPresetKnobValues[Reverb2][2] = 0.5f; // highpass
   1a4c8:	f8ce 2000 	str.w	r2, [lr]
            defaultPresetKnobValues[LivingString][1] = 0.1f; // detune
   1a4cc:	f203 5e7c 	addw	lr, r3, #1404	; 0x57c
            defaultPresetKnobValues[Delay][2] = 0.0f; // highpass
   1a4d0:	f8ca 6000 	str.w	r6, [sl]
            defaultPresetKnobValues[LivingString][5] = 0.25f; // prep pos
   1a4d4:	f203 5a8c 	addw	sl, r3, #1420	; 0x58c
            defaultPresetKnobValues[Distortion][0] = .25f; // pre gain
   1a4d8:	f8c3 1320 	str.w	r1, [r3, #800]	; 0x320
            defaultPresetKnobValues[Distortion][4] = 0.25f; //post gain
   1a4dc:	f8c3 1330 	str.w	r1, [r3, #816]	; 0x330
            defaultPresetKnobValues[Wavefolder][0] = 0.4f; // gain
   1a4e0:	f8c3 7384 	str.w	r7, [r3, #900]	; 0x384
            defaultPresetKnobValues[BitCrusher][0] = 0.1f; // quality
   1a4e4:	f8c3 03e8 	str.w	r0, [r3, #1000]	; 0x3e8
            defaultPresetKnobValues[SamplerAutoGrab][9] = 0.0f;
   1a4e8:	f8c3 62e0 	str.w	r6, [r3, #736]	; 0x2e0
            defaultPresetKnobValues[Distortion][1] = 0.5f; // tilt (low and high shelves, opposing gains)
   1a4ec:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
            defaultPresetKnobValues[Distortion][2] = 0.5f; // mid gain
   1a4f0:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
            defaultPresetKnobValues[Distortion][3] = 0.5f; // mid freq
   1a4f4:	f8c3 232c 	str.w	r2, [r3, #812]	; 0x32c
            defaultPresetKnobValues[Wavefolder][1] = 0.5f; // offset1
   1a4f8:	f8c3 2388 	str.w	r2, [r3, #904]	; 0x388
            defaultPresetKnobValues[Wavefolder][2] = 0.5f; // offset2
   1a4fc:	f8c3 238c 	str.w	r2, [r3, #908]	; 0x38c
            defaultPresetKnobValues[Wavefolder][4] = 0.0f;
   1a500:	f8c3 6394 	str.w	r6, [r3, #916]	; 0x394
            defaultPresetKnobValues[BitCrusher][1] = 0.5f; // samp ratio
   1a504:	f8c3 23ec 	str.w	r2, [r3, #1004]	; 0x3ec
            defaultPresetKnobValues[BitCrusher][2] = 0.0f; // rounding
   1a508:	f8c3 63f0 	str.w	r6, [r3, #1008]	; 0x3f0
            defaultPresetKnobValues[BitCrusher][3] = 0.0f; // operation
   1a50c:	f8c3 63f4 	str.w	r6, [r3, #1012]	; 0x3f4
            defaultPresetKnobValues[BitCrusher][4] = 0.5f; // post gain
   1a510:	f8c3 23f8 	str.w	r2, [r3, #1016]	; 0x3f8
            defaultPresetKnobValues[BitCrusher][5] = 0.0f; // pre gain
   1a514:	f8c3 63fc 	str.w	r6, [r3, #1020]	; 0x3fc
            defaultPresetKnobValues[Reverb2][3] = 0.5f; // peak freq
   1a518:	f8cb 2000 	str.w	r2, [fp]
            defaultPresetKnobValues[LivingString][4] = 0.5f; // pick pos
   1a51c:	f503 6bb1 	add.w	fp, r3, #1416	; 0x588
            defaultPresetKnobValues[Reverb2][4] = 0.5f; // peak gain
   1a520:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[LivingString][9] = 0.5f;
   1a524:	f203 599c 	addw	r9, r3, #1436	; 0x59c
            defaultPresetKnobValues[LivingString][1] = 0.1f; // detune
   1a528:	f8ce 0000 	str.w	r0, [lr]
            defaultPresetKnobValues[LivingStringSynth][0] = 0.5f;
   1a52c:	f203 5edc 	addw	lr, r3, #1500	; 0x5dc
            defaultPresetKnobValues[LivingString][5] = 0.25f; // prep pos
   1a530:	f8ca 1000 	str.w	r1, [sl]
            defaultPresetKnobValues[LivingStringSynth][2] = .85f; // decay
   1a534:	f203 5ae4 	addw	sl, r3, #1508	; 0x5e4
            defaultPresetKnobValues[LivingStringSynth][0] = 0.5f;
   1a538:	f8ce 2000 	str.w	r2, [lr]
            defaultPresetKnobValues[LivingStringSynth][3] = 1.0f; // damping
   1a53c:	f503 6ebd 	add.w	lr, r3, #1512	; 0x5e8
            defaultPresetKnobValues[LivingStringSynth][2] = .85f; // decay
   1a540:	f8ca 8000 	str.w	r8, [sl]
            defaultPresetKnobValues[LivingStringSynth][5] = 0.25f; // prep pos
   1a544:	f503 6abe 	add.w	sl, r3, #1520	; 0x5f0
            defaultPresetKnobValues[LivingString][9] = 0.5f;
   1a548:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[LivingStringSynth][4] = 0.4f; // pick pos
   1a54c:	f203 59ec 	addw	r9, r3, #1516	; 0x5ec
            defaultPresetKnobValues[LivingStringSynth][3] = 1.0f; // damping
   1a550:	f8ce 4000 	str.w	r4, [lr]
            defaultPresetKnobValues[LivingStringSynth][9] = 0.4f; // release time
   1a554:	f503 64c0 	add.w	r4, r3, #1536	; 0x600
            defaultPresetKnobValues[LivingStringSynth][5] = 0.25f; // prep pos
   1a558:	f8ca 1000 	str.w	r1, [sl]
            defaultPresetKnobValues[ClassicSynth][0] = 0.5f; // volume
   1a55c:	f503 6ec8 	add.w	lr, r3, #1600	; 0x640
            defaultPresetKnobValues[ClassicSynth][2] = 0.2f; // detune
   1a560:	f503 6ac9 	add.w	sl, r3, #1608	; 0x648
            defaultPresetKnobValues[LivingStringSynth][4] = 0.4f; // pick pos
   1a564:	f8c9 7000 	str.w	r7, [r9]
            defaultPresetKnobValues[ClassicSynth][0] = 0.5f; // volume
   1a568:	f8ce 2000 	str.w	r2, [lr]
            defaultPresetKnobValues[ClassicSynth][1] = 0.5f; // lowpass
   1a56c:	f203 6844 	addw	r8, r3, #1604	; 0x644
            defaultPresetKnobValues[ClassicSynth][2] = 0.2f; // detune
   1a570:	f8ca c000 	str.w	ip, [sl]
            defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
   1a574:	f503 69af 	add.w	r9, r3, #1400	; 0x578
            defaultPresetKnobValues[LivingStringSynth][9] = 0.4f; // release time
   1a578:	6027      	str	r7, [r4, #0]
            defaultPresetKnobValues[LivingString][2] = 0.3f; // decay
   1a57a:	f503 6eb0 	add.w	lr, r3, #1408	; 0x580
            defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
   1a57e:	4c40      	ldr	r4, [pc, #256]	; (1a680 <initGlobalSFXObjects+0x408>)
            defaultPresetKnobValues[LivingString][11] = 0.3f;// freq 3
   1a580:	f203 5ca4 	addw	ip, r3, #1444	; 0x5a4
            defaultPresetKnobValues[LivingString][12] = 0.3f;// freq 4
   1a584:	f503 67b5 	add.w	r7, r3, #1448	; 0x5a8
            defaultPresetKnobValues[ClassicSynth][1] = 0.5f; // lowpass
   1a588:	f8c8 2000 	str.w	r2, [r8]
            defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
   1a58c:	f8c9 4000 	str.w	r4, [r9]
            defaultPresetKnobValues[LivingString][10] = 0.3f;// freq 2
   1a590:	f503 68b4 	add.w	r8, r3, #1440	; 0x5a0
            defaultPresetKnobValues[LivingString][2] = 0.3f; // decay
   1a594:	f8ce 4000 	str.w	r4, [lr]
            defaultPresetKnobValues[LivingString][13] = 0.3f;// freq 5
   1a598:	f203 59ac 	addw	r9, r3, #1452	; 0x5ac
            defaultPresetKnobValues[LivingString][11] = 0.3f;// freq 3
   1a59c:	f8cc 4000 	str.w	r4, [ip]
            defaultPresetKnobValues[LivingString][14] = 0.3f;// freq 6
   1a5a0:	f503 6eb6 	add.w	lr, r3, #1456	; 0x5b0
            defaultPresetKnobValues[LivingStringSynth][8] = 0.3f; // feedback volume
   1a5a4:	f203 5afc 	addw	sl, r3, #1532	; 0x5fc
            defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
   1a5a8:	f203 5c84 	addw	ip, r3, #1412	; 0x584
            defaultPresetKnobValues[LivingString][12] = 0.3f;// freq 4
   1a5ac:	603c      	str	r4, [r7, #0]
            defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
   1a5ae:	4f35      	ldr	r7, [pc, #212]	; (1a684 <initGlobalSFXObjects+0x40c>)
            defaultPresetKnobValues[LivingString][10] = 0.3f;// freq 2
   1a5b0:	f8c8 4000 	str.w	r4, [r8]
            defaultPresetKnobValues[LivingString][6] = 0.0f; // prep index
   1a5b4:	f503 68b2 	add.w	r8, r3, #1424	; 0x590
            defaultPresetKnobValues[LivingString][13] = 0.3f;// freq 5
   1a5b8:	f8c9 4000 	str.w	r4, [r9]
            defaultPresetKnobValues[LivingString][7] = 0.0f; // let ring
   1a5bc:	f203 5994 	addw	r9, r3, #1428	; 0x594
            defaultPresetKnobValues[LivingString][4] = 0.5f; // pick pos
   1a5c0:	f8cb 2000 	str.w	r2, [fp]
            defaultPresetKnobValues[LivingStringSynth][1] = 0.5f;
   1a5c4:	f503 6bbc 	add.w	fp, r3, #1504	; 0x5e0
            defaultPresetKnobValues[LivingString][14] = 0.3f;// freq 6
   1a5c8:	f8ce 4000 	str.w	r4, [lr]
            defaultPresetKnobValues[LivingString][8] = 0.8f;
   1a5cc:	f503 6eb3 	add.w	lr, r3, #1432	; 0x598
            defaultPresetKnobValues[LivingStringSynth][8] = 0.3f; // feedback volume
   1a5d0:	f8ca 4000 	str.w	r4, [sl]
            defaultPresetKnobValues[ClassicSynth][5] = 0.0f;
   1a5d4:	f203 6454 	addw	r4, r3, #1620	; 0x654
            defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
   1a5d8:	f8cc 7000 	str.w	r7, [ip]
            defaultPresetKnobValues[LivingStringSynth][7] = 0.0f; // let ring
   1a5dc:	f503 6cbf 	add.w	ip, r3, #1528	; 0x5f8
            defaultPresetKnobValues[LivingString][8] = 0.8f;
   1a5e0:	eddf 7a29 	vldr	s15, [pc, #164]	; 1a688 <initGlobalSFXObjects+0x410>
            defaultPresetKnobValues[LivingStringSynth][6] = 0.0f; // prep index
   1a5e4:	f203 5af4 	addw	sl, r3, #1524	; 0x5f4
            defaultPresetKnobValues[LivingStringSynth][1] = 0.5f;
   1a5e8:	f8cb 2000 	str.w	r2, [fp]
            defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
   1a5ec:	f503 6bcb 	add.w	fp, r3, #1624	; 0x658
            defaultPresetKnobValues[LivingString][6] = 0.0f; // prep index
   1a5f0:	f8c8 6000 	str.w	r6, [r8]
            defaultPresetKnobValues[ClassicSynth][3] = 0.0f;
   1a5f4:	f203 684c 	addw	r8, r3, #1612	; 0x64c
            defaultPresetKnobValues[LivingString][7] = 0.0f; // let ring
   1a5f8:	f8c9 6000 	str.w	r6, [r9]
            defaultPresetKnobValues[ClassicSynth][4] = 0.0f;
   1a5fc:	f503 69ca 	add.w	r9, r3, #1616	; 0x650
            defaultPresetKnobValues[LivingString][8] = 0.8f;
   1a600:	edce 7a00 	vstr	s15, [lr]
            defaultPresetKnobValues[ClassicSynth][7] = 0.9f;
   1a604:	f203 6e5c 	addw	lr, r3, #1628	; 0x65c
            defaultPresetKnobValues[LivingStringSynth][7] = 0.0f; // let ring
   1a608:	f8cc 6000 	str.w	r6, [ip]
            defaultPresetKnobValues[ClassicSynth][8] = 0.1f;
   1a60c:	f503 6ccc 	add.w	ip, r3, #1632	; 0x660
            defaultPresetKnobValues[ClassicSynth][5] = 0.0f;
   1a610:	6026      	str	r6, [r4, #0]
            defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
   1a612:	4c1e      	ldr	r4, [pc, #120]	; (1a68c <initGlobalSFXObjects+0x414>)
            defaultPresetKnobValues[LivingStringSynth][6] = 0.0f; // prep index
   1a614:	f8ca 6000 	str.w	r6, [sl]
            defaultPresetKnobValues[ClassicSynth][11] = 0.06f;
   1a618:	f203 6a6c 	addw	sl, r3, #1644	; 0x66c
            defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
   1a61c:	f8cb 4000 	str.w	r4, [fp]
            defaultPresetKnobValues[ClassicSynth][3] = 0.0f;
   1a620:	f8c8 6000 	str.w	r6, [r8]
            defaultPresetKnobValues[ClassicSynth][9] = 0.1f;
   1a624:	f203 6864 	addw	r8, r3, #1636	; 0x664
   1a628:	e038      	b.n	1a69c <initGlobalSFXObjects+0x424>
   1a62a:	bf00      	nop
   1a62c:	020e2f18 	.word	0x020e2f18
   1a630:	020e5310 	.word	0x020e5310
   1a634:	020e2ee4 	.word	0x020e2ee4
   1a638:	2aaaaaab 	.word	0x2aaaaaab
   1a63c:	020fa1e4 	.word	0x020fa1e4
   1a640:	020fabc0 	.word	0x020fabc0
   1a644:	020f9de8 	.word	0x020f9de8
   1a648:	3ca3d70a 	.word	0x3ca3d70a
   1a64c:	00000000 	.word	0x00000000
   1a650:	3c23d70a 	.word	0x3c23d70a
   1a654:	020f9b24 	.word	0x020f9b24
   1a658:	ba51b717 	.word	0xba51b717
   1a65c:	447a0000 	.word	0x447a0000
   1a660:	020f990c 	.word	0x020f990c
   1a664:	020fa204 	.word	0x020fa204
   1a668:	3a83126f 	.word	0x3a83126f
   1a66c:	020e4830 	.word	0x020e4830
   1a670:	3f28f5c3 	.word	0x3f28f5c3
   1a674:	3ecccccd 	.word	0x3ecccccd
   1a678:	3f733333 	.word	0x3f733333
   1a67c:	3dcccccd 	.word	0x3dcccccd
   1a680:	3e99999a 	.word	0x3e99999a
   1a684:	3f666666 	.word	0x3f666666
   1a688:	3f4ccccd 	.word	0x3f4ccccd
   1a68c:	3d75c28f 	.word	0x3d75c28f
   1a690:	3ca3d70a 	.word	0x3ca3d70a
   1a694:	3e4ccccd 	.word	0x3e4ccccd
   1a698:	3f59999a 	.word	0x3f59999a
            defaultPresetKnobValues[ClassicSynth][4] = 0.0f;
   1a69c:	f8c9 6000 	str.w	r6, [r9]
            defaultPresetKnobValues[ClassicSynth][12] = 0.9f;
   1a6a0:	f503 69ce 	add.w	r9, r3, #1648	; 0x670
            defaultPresetKnobValues[ClassicSynth][7] = 0.9f;
   1a6a4:	f8ce 7000 	str.w	r7, [lr]
            defaultPresetKnobValues[ClassicSynth][13] = 0.1f;
   1a6a8:	f203 6e74 	addw	lr, r3, #1652	; 0x674
            defaultPresetKnobValues[ClassicSynth][8] = 0.1f;
   1a6ac:	f8cc 0000 	str.w	r0, [ip]
            defaultPresetKnobValues[ClassicSynth][14] = 0.1f;
   1a6b0:	f503 6ccf 	add.w	ip, r3, #1656	; 0x678
            defaultPresetKnobValues[ClassicSynth][9] = 0.1f;
   1a6b4:	f8c8 0000 	str.w	r0, [r8]
            defaultPresetKnobValues[ClassicSynth][16] = 0.06f;
   1a6b8:	f503 68d0 	add.w	r8, r3, #1664	; 0x680
            defaultPresetKnobValues[ClassicSynth][13] = 0.1f;
   1a6bc:	f8ce 0000 	str.w	r0, [lr]
            defaultPresetKnobValues[ClassicSynth][18] = 0.1f;
   1a6c0:	f503 6ed1 	add.w	lr, r3, #1672	; 0x688
            defaultPresetKnobValues[ClassicSynth][14] = 0.1f;
   1a6c4:	f8cc 0000 	str.w	r0, [ip]
            defaultPresetKnobValues[ClassicSynth][19] = 0.1f;
   1a6c8:	f203 6c8c 	addw	ip, r3, #1676	; 0x68c
            defaultPresetKnobValues[ClassicSynth][16] = 0.06f;
   1a6cc:	f8c8 4000 	str.w	r4, [r8]
            defaultPresetKnobValues[Rhodes][0] = 0.25f;
   1a6d0:	f203 68a4 	addw	r8, r3, #1700	; 0x6a4
            defaultPresetKnobValues[ClassicSynth][18] = 0.1f;
   1a6d4:	f8ce 0000 	str.w	r0, [lr]
            defaultPresetKnobValues[Rhodes][2] = 0.25f;
   1a6d8:	f203 6eac 	addw	lr, r3, #1708	; 0x6ac
            defaultPresetKnobValues[ClassicSynth][19] = 0.1f;
   1a6dc:	f8cc 0000 	str.w	r0, [ip]
            defaultPresetKnobValues[Rhodes][3] = 0.5f;
   1a6e0:	f503 6cd6 	add.w	ip, r3, #1712	; 0x6b0
            defaultPresetKnobValues[ClassicSynth][11] = 0.06f;
   1a6e4:	f8ca 4000 	str.w	r4, [sl]
            defaultPresetKnobValues[Rhodes][7] = 0.9f;
   1a6e8:	f503 60d8 	add.w	r0, r3, #1728	; 0x6c0
            defaultPresetKnobValues[Rhodes][1] = 0.25f;
   1a6ec:	f503 64d5 	add.w	r4, r3, #1704	; 0x6a8
            defaultPresetKnobValues[ClassicSynth][12] = 0.9f;
   1a6f0:	f8c9 7000 	str.w	r7, [r9]
            defaultPresetKnobValues[Rhodes][0] = 0.25f;
   1a6f4:	f8c8 1000 	str.w	r1, [r8]
            defaultPresetKnobValues[ClassicSynth][17] = 0.9f;
   1a6f8:	f203 6984 	addw	r9, r3, #1668	; 0x684
            defaultPresetKnobValues[Rhodes][1] = 0.25f;
   1a6fc:	6021      	str	r1, [r4, #0]
            defaultPresetKnobValues[Rhodes][9] = 0.5f;
   1a6fe:	f503 68d9 	add.w	r8, r3, #1736	; 0x6c8
            defaultPresetKnobValues[Rhodes][2] = 0.25f;
   1a702:	f8ce 1000 	str.w	r1, [lr]
            defaultPresetKnobValues[Rhodes][12] = 0.9f;
   1a706:	f203 64d4 	addw	r4, r3, #1748	; 0x6d4
            defaultPresetKnobValues[Rhodes][7] = 0.9f;
   1a70a:	6007      	str	r7, [r0, #0]
            defaultPresetKnobValues[Rhodes][14] = 0.5f;
   1a70c:	f203 6edc 	addw	lr, r3, #1756	; 0x6dc
            defaultPresetKnobValues[Rhodes][3] = 0.5f;
   1a710:	f8cc 2000 	str.w	r2, [ip]
            defaultPresetKnobValues[Rhodes][15] = 0.8f;
   1a714:	f503 61dc 	add.w	r1, r3, #1760	; 0x6e0
            defaultPresetKnobValues[Rhodes][18] = 0.5f;
   1a718:	f203 6cec 	addw	ip, r3, #1772	; 0x6ec
            defaultPresetKnobValues[Rhodes][19] = 0.5f;
   1a71c:	f503 60de 	add.w	r0, r3, #1776	; 0x6f0
            defaultPresetKnobValues[ClassicSynth][17] = 0.9f;
   1a720:	f8c9 7000 	str.w	r7, [r9]
            defaultPresetKnobValues[Rhodes][8] = 0.1007f;
   1a724:	f203 6ac4 	addw	sl, r3, #1732	; 0x6c4
            defaultPresetKnobValues[Rhodes][12] = 0.9f;
   1a728:	6027      	str	r7, [r4, #0]
            defaultPresetKnobValues[ClassicSynth][15] = 0.0f;
   1a72a:	f203 647c 	addw	r4, r3, #1660	; 0x67c
            defaultPresetKnobValues[Rhodes][9] = 0.5f;
   1a72e:	f8c8 2000 	str.w	r2, [r8]
            defaultPresetKnobValues[Rhodes][4] = 0.0f; //stereo spread
   1a732:	f203 67b4 	addw	r7, r3, #1716	; 0x6b4
            defaultPresetKnobValues[Rhodes][14] = 0.5f;
   1a736:	f8ce 2000 	str.w	r2, [lr]
            defaultPresetKnobValues[Rhodes][5] = 0.05f;
   1a73a:	f503 68d7 	add.w	r8, r3, #1720	; 0x6b8
            defaultPresetKnobValues[Rhodes][6] = 0.05f;
   1a73e:	f203 6ebc 	addw	lr, r3, #1724	; 0x6bc
            defaultPresetKnobValues[Rhodes][18] = 0.5f;
   1a742:	f8cc 2000 	str.w	r2, [ip]
            defaultPresetKnobValues[Rhodes][19] = 0.5f;
   1a746:	6002      	str	r2, [r0, #0]
            defaultPresetKnobValues[Rhodes][10] = 0.05f;
   1a748:	f203 6ccc 	addw	ip, r3, #1740	; 0x6cc
            defaultPresetKnobValues[Rhodes][11] = 0.05f;
   1a74c:	f503 60da 	add.w	r0, r3, #1744	; 0x6d0
            defaultPresetKnobValues[Rhodes][15] = 0.8f;
   1a750:	edc1 7a00 	vstr	s15, [r1]
            defaultPresetKnobValues[Rhodes][5] = 0.05f;
   1a754:	4920      	ldr	r1, [pc, #128]	; (1a7d8 <initGlobalSFXObjects+0x560>)
            defaultPresetKnobValues[ClassicSynth][10] = 0.0f;
   1a756:	f503 69cd 	add.w	r9, r3, #1640	; 0x668
            defaultPresetKnobValues[ClassicSynth][15] = 0.0f;
   1a75a:	6026      	str	r6, [r4, #0]
            defaultPresetKnobValues[Rhodes][13] = 0.1007f;
   1a75c:	f503 64db 	add.w	r4, r3, #1752	; 0x6d8
            defaultPresetKnobValues[Rhodes][4] = 0.0f; //stereo spread
   1a760:	603e      	str	r6, [r7, #0]
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1a762:	f203 67e4 	addw	r7, r3, #1764	; 0x6e4
            defaultPresetKnobValues[Rhodes][5] = 0.05f;
   1a766:	f8c8 1000 	str.w	r1, [r8]
            defaultPresetKnobValues[Rhodes][20] = 0.5f;
   1a76a:	f203 68f4 	addw	r8, r3, #1780	; 0x6f4
            defaultPresetKnobValues[Rhodes][6] = 0.05f;
   1a76e:	f8ce 1000 	str.w	r1, [lr]
            defaultPresetKnobValues[Rhodes][21] = 0.0f;
   1a772:	f503 6edf 	add.w	lr, r3, #1784	; 0x6f8
            defaultPresetKnobValues[Rhodes][10] = 0.05f;
   1a776:	f8cc 1000 	str.w	r1, [ip]
            defaultPresetKnobValues[Rhodes][22] = 0.00f;
   1a77a:	f203 6cfc 	addw	ip, r3, #1788	; 0x6fc
            defaultPresetKnobValues[Rhodes][11] = 0.05f;
   1a77e:	6001      	str	r1, [r0, #0]
            defaultPresetKnobValues[Rhodes][23] = 0.00f;
   1a780:	f503 60e0 	add.w	r0, r3, #1792	; 0x700
            defaultPresetKnobValues[Rhodes][8] = 0.1007f;
   1a784:	4915      	ldr	r1, [pc, #84]	; (1a7dc <initGlobalSFXObjects+0x564>)
   1a786:	4d16      	ldr	r5, [pc, #88]	; (1a7e0 <initGlobalSFXObjects+0x568>)
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1a788:	f8df b05c 	ldr.w	fp, [pc, #92]	; 1a7e8 <initGlobalSFXObjects+0x570>
            defaultPresetKnobValues[ClassicSynth][10] = 0.0f;
   1a78c:	f8c9 6000 	str.w	r6, [r9]
            defaultPresetKnobValues[Rhodes][17] = 0.7f;
   1a790:	f503 69dd 	add.w	r9, r3, #1768	; 0x6e8
            defaultPresetKnobValues[Rhodes][13] = 0.1007f;
   1a794:	6021      	str	r1, [r4, #0]
   1a796:	461c      	mov	r4, r3
            defaultPresetKnobValues[Rhodes][8] = 0.1007f;
   1a798:	f8ca 1000 	str.w	r1, [sl]
            defaultPresetKnobValues[Rhodes][24] = 0.00f;
   1a79c:	f203 7104 	addw	r1, r3, #1796	; 0x704
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1a7a0:	f8c7 b000 	str.w	fp, [r7]
   1a7a4:	f505 67e1 	add.w	r7, r5, #1800	; 0x708
            defaultPresetKnobValues[Rhodes][17] = 0.7f;
   1a7a8:	4b0e      	ldr	r3, [pc, #56]	; (1a7e4 <initGlobalSFXObjects+0x56c>)
   1a7aa:	f8c9 3000 	str.w	r3, [r9]
            defaultPresetKnobValues[Rhodes][20] = 0.5f;
   1a7ae:	f8c8 2000 	str.w	r2, [r8]
            defaultPresetKnobValues[Rhodes][21] = 0.0f;
   1a7b2:	f8ce 6000 	str.w	r6, [lr]
            defaultPresetKnobValues[Rhodes][22] = 0.00f;
   1a7b6:	f8cc 6000 	str.w	r6, [ip]
            defaultPresetKnobValues[Rhodes][23] = 0.00f;
   1a7ba:	6006      	str	r6, [r0, #0]
            defaultPresetKnobValues[Rhodes][24] = 0.00f;
   1a7bc:	600e      	str	r6, [r1, #0]
   1a7be:	4628      	mov	r0, r5
   1a7c0:	3564      	adds	r5, #100	; 0x64
   1a7c2:	4621      	mov	r1, r4
   1a7c4:	2264      	movs	r2, #100	; 0x64
   1a7c6:	f012 f881 	bl	2c8cc <memcpy>
            for (int p = 0; p < PresetNil; p++)
   1a7ca:	42af      	cmp	r7, r5
   1a7cc:	f104 0464 	add.w	r4, r4, #100	; 0x64
   1a7d0:	d1f5      	bne.n	1a7be <initGlobalSFXObjects+0x546>
        }
   1a7d2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a7d6:	bf00      	nop
   1a7d8:	3d4ccccd 	.word	0x3d4ccccd
   1a7dc:	3dce3bcd 	.word	0x3dce3bcd
   1a7e0:	020e55d8 	.word	0x020e55d8
   1a7e4:	3f333333 	.word	0x3f333333
   1a7e8:	3f19999a 	.word	0x3f19999a

0001a7ec <SFXVocoderAlloc>:
        {
   1a7ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            tTalkboxFloat_initToPool(&vocoder, 1024,  &smallPool);
   1a7f0:	4a3b      	ldr	r2, [pc, #236]	; (1a8e0 <SFXVocoderAlloc+0xf4>)
   1a7f2:	f44f 6180 	mov.w	r1, #1024	; 0x400
   1a7f6:	483b      	ldr	r0, [pc, #236]	; (1a8e4 <SFXVocoderAlloc+0xf8>)
            tHighpass_initToPool(&noiseHP, 4500.0f, &smallPool);
   1a7f8:	2400      	movs	r4, #0
            tSimplePoly_setNumVoices(&poly, numVoices);
   1a7fa:	f8df 9134 	ldr.w	r9, [pc, #308]	; 1a930 <SFXVocoderAlloc+0x144>
   1a7fe:	f8df 8134 	ldr.w	r8, [pc, #308]	; 1a934 <SFXVocoderAlloc+0x148>
   1a802:	4f39      	ldr	r7, [pc, #228]	; (1a8e8 <SFXVocoderAlloc+0xfc>)
                tSawtooth_initToPool(&osc[i], &smallPool);
   1a804:	4e36      	ldr	r6, [pc, #216]	; (1a8e0 <SFXVocoderAlloc+0xf4>)
        {
   1a806:	ed2d 8b02 	vpush	{d8}
            tTalkboxFloat_initToPool(&vocoder, 1024,  &smallPool);
   1a80a:	f00b fa83 	bl	25d14 <tTalkboxFloat_initToPool>
            tTalkboxFloat_setWarpOn(&vocoder, 1);
   1a80e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1a812:	4834      	ldr	r0, [pc, #208]	; (1a8e4 <SFXVocoderAlloc+0xf8>)
   1a814:	f00b fd32 	bl	2627c <tTalkboxFloat_setWarpOn>
            tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
   1a818:	4a31      	ldr	r2, [pc, #196]	; (1a8e0 <SFXVocoderAlloc+0xf4>)
   1a81a:	4621      	mov	r1, r4
   1a81c:	4833      	ldr	r0, [pc, #204]	; (1a8ec <SFXVocoderAlloc+0x100>)
   1a81e:	f00f ff57 	bl	2a6d0 <tNoise_initToPool>
            tZeroCrossing_initToPool(&zerox, 16, &smallPool);
   1a822:	4a2f      	ldr	r2, [pc, #188]	; (1a8e0 <SFXVocoderAlloc+0xf4>)
   1a824:	2110      	movs	r1, #16
   1a826:	4832      	ldr	r0, [pc, #200]	; (1a8f0 <SFXVocoderAlloc+0x104>)
   1a828:	f009 fcde 	bl	241e8 <tZeroCrossing_initToPool>
            tSimplePoly_setNumVoices(&poly, numVoices);
   1a82c:	f899 1000 	ldrb.w	r1, [r9]
   1a830:	4830      	ldr	r0, [pc, #192]	; (1a8f4 <SFXVocoderAlloc+0x108>)
   1a832:	f00f fdd9 	bl	2a3e8 <tSimplePoly_setNumVoices>
            tExpSmooth_initToPool(&noiseRamp, 0.0f, 0.005f, &smallPool);
   1a836:	492a      	ldr	r1, [pc, #168]	; (1a8e0 <SFXVocoderAlloc+0xf4>)
   1a838:	eddf 0a2f 	vldr	s1, [pc, #188]	; 1a8f8 <SFXVocoderAlloc+0x10c>
   1a83c:	ed9f 0a2f 	vldr	s0, [pc, #188]	; 1a8fc <SFXVocoderAlloc+0x110>
   1a840:	482f      	ldr	r0, [pc, #188]	; (1a900 <SFXVocoderAlloc+0x114>)
   1a842:	f00d faa1 	bl	27d88 <tExpSmooth_initToPool>
            tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
   1a846:	4a26      	ldr	r2, [pc, #152]	; (1a8e0 <SFXVocoderAlloc+0xf4>)
   1a848:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1a84c:	ed9f 0a2d 	vldr	s0, [pc, #180]	; 1a904 <SFXVocoderAlloc+0x118>
   1a850:	2106      	movs	r1, #6
   1a852:	482d      	ldr	r0, [pc, #180]	; (1a908 <SFXVocoderAlloc+0x11c>)
   1a854:	f00d fe26 	bl	284a4 <tVZFilter_initToPool>
            tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
   1a858:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1a85c:	ed9f 0a2b 	vldr	s0, [pc, #172]	; 1a90c <SFXVocoderAlloc+0x120>
   1a860:	2107      	movs	r1, #7
   1a862:	4a1f      	ldr	r2, [pc, #124]	; (1a8e0 <SFXVocoderAlloc+0xf4>)
   1a864:	482a      	ldr	r0, [pc, #168]	; (1a910 <SFXVocoderAlloc+0x124>)
   1a866:	f00d fe1d 	bl	284a4 <tVZFilter_initToPool>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
   1a86a:	eddf 8a2a 	vldr	s17, [pc, #168]	; 1a914 <SFXVocoderAlloc+0x128>
            tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1a86e:	4a1c      	ldr	r2, [pc, #112]	; (1a8e0 <SFXVocoderAlloc+0xf4>)
   1a870:	4621      	mov	r1, r4
   1a872:	4829      	ldr	r0, [pc, #164]	; (1a918 <SFXVocoderAlloc+0x12c>)
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
   1a874:	ed9f 8a29 	vldr	s16, [pc, #164]	; 1a91c <SFXVocoderAlloc+0x130>
            tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1a878:	f00f ff2a 	bl	2a6d0 <tNoise_initToPool>
            tHighpass_initToPool(&noiseHP, 4500.0f, &smallPool);
   1a87c:	4918      	ldr	r1, [pc, #96]	; (1a8e0 <SFXVocoderAlloc+0xf4>)
   1a87e:	ed9f 0a28 	vldr	s0, [pc, #160]	; 1a920 <SFXVocoderAlloc+0x134>
   1a882:	4828      	ldr	r0, [pc, #160]	; (1a924 <SFXVocoderAlloc+0x138>)
   1a884:	f00d fdca 	bl	2841c <tHighpass_initToPool>
   1a888:	193d      	adds	r5, r7, r4
                tSawtooth_initToPool(&osc[i], &smallPool);
   1a88a:	eb08 0004 	add.w	r0, r8, r4
   1a88e:	4631      	mov	r1, r6
   1a890:	3404      	adds	r4, #4
   1a892:	f00f fe67 	bl	2a564 <tSawtooth_initToPool>
                tRosenbergGlottalPulse_initToPool(&glottal[i], &smallPool);
   1a896:	4628      	mov	r0, r5
   1a898:	4631      	mov	r1, r6
   1a89a:	f00b fcfb 	bl	26294 <tRosenbergGlottalPulse_initToPool>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
   1a89e:	eef0 0a68 	vmov.f32	s1, s17
   1a8a2:	eeb0 0a48 	vmov.f32	s0, s16
   1a8a6:	4628      	mov	r0, r5
   1a8a8:	f00b fe0e 	bl	264c8 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
   1a8ac:	2c20      	cmp	r4, #32
   1a8ae:	d1eb      	bne.n	1a888 <SFXVocoderAlloc+0x9c>
            setLED_A(numVoices == 1);
   1a8b0:	f899 0000 	ldrb.w	r0, [r9]
   1a8b4:	f1a0 0001 	sub.w	r0, r0, #1
   1a8b8:	fab0 f080 	clz	r0, r0
   1a8bc:	0940      	lsrs	r0, r0, #5
   1a8be:	f7fe fde7 	bl	19490 <setLED_A>
            setLED_B(internalExternal);
   1a8c2:	4b19      	ldr	r3, [pc, #100]	; (1a928 <SFXVocoderAlloc+0x13c>)
   1a8c4:	7818      	ldrb	r0, [r3, #0]
   1a8c6:	f7fe fdf1 	bl	194ac <setLED_B>
            vocFreezeLPC = 0;
   1a8ca:	2300      	movs	r3, #0
   1a8cc:	4a17      	ldr	r2, [pc, #92]	; (1a92c <SFXVocoderAlloc+0x140>)
            setLED_C(vocFreezeLPC);
   1a8ce:	4618      	mov	r0, r3
            vocFreezeLPC = 0;
   1a8d0:	6013      	str	r3, [r2, #0]
        }
   1a8d2:	ecbd 8b02 	vpop	{d8}
   1a8d6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            setLED_C(vocFreezeLPC);
   1a8da:	f7fe bdf5 	b.w	194c8 <setLED_C>
   1a8de:	bf00      	nop
   1a8e0:	020fabc0 	.word	0x020fabc0
   1a8e4:	020faa08 	.word	0x020faa08
   1a8e8:	020e5110 	.word	0x020e5110
   1a8ec:	020e5d2c 	.word	0x020e5d2c
   1a8f0:	020f9f58 	.word	0x020f9f58
   1a8f4:	020f9de8 	.word	0x020f9de8
   1a8f8:	3ba3d70a 	.word	0x3ba3d70a
   1a8fc:	00000000 	.word	0x00000000
   1a900:	020faaf0 	.word	0x020faaf0
   1a904:	42a00000 	.word	0x42a00000
   1a908:	020f9dc4 	.word	0x020f9dc4
   1a90c:	463b8000 	.word	0x463b8000
   1a910:	020f9cec 	.word	0x020f9cec
   1a914:	3ecccccd 	.word	0x3ecccccd
   1a918:	020e50e0 	.word	0x020e50e0
   1a91c:	3e99999a 	.word	0x3e99999a
   1a920:	458ca000 	.word	0x458ca000
   1a924:	020e5d24 	.word	0x020e5d24
   1a928:	020e2e64 	.word	0x020e2e64
   1a92c:	020e2edc 	.word	0x020e2edc
   1a930:	000627ac 	.word	0x000627ac
   1a934:	020f9ba4 	.word	0x020f9ba4

0001a938 <SFXVocoderFrame>:
        {
   1a938:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1a93c:	4c84      	ldr	r4, [pc, #528]	; (1ab50 <SFXVocoderFrame+0x218>)
        {
   1a93e:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1a942:	7d23      	ldrb	r3, [r4, #20]
   1a944:	2b01      	cmp	r3, #1
   1a946:	d113      	bne.n	1a970 <SFXVocoderFrame+0x38>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1a948:	4d82      	ldr	r5, [pc, #520]	; (1ab54 <SFXVocoderFrame+0x21c>)
                tSimplePoly_setNumVoices(&poly, numVoices);
   1a94a:	4883      	ldr	r0, [pc, #524]	; (1ab58 <SFXVocoderFrame+0x220>)
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1a94c:	782a      	ldrb	r2, [r5, #0]
   1a94e:	2a01      	cmp	r2, #1
   1a950:	bf98      	it	ls
   1a952:	2308      	movls	r3, #8
                tSimplePoly_setNumVoices(&poly, numVoices);
   1a954:	4619      	mov	r1, r3
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1a956:	702b      	strb	r3, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
   1a958:	f00f fd46 	bl	2a3e8 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
   1a95c:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1a95e:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
   1a960:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1a964:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
   1a966:	fab0 f080 	clz	r0, r0
   1a96a:	0940      	lsrs	r0, r0, #5
   1a96c:	f7fe fd90 	bl	19490 <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1a970:	7e23      	ldrb	r3, [r4, #24]
   1a972:	2b01      	cmp	r3, #1
   1a974:	f000 80e0 	beq.w	1ab38 <SFXVocoderFrame+0x200>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1a978:	7f23      	ldrb	r3, [r4, #28]
   1a97a:	2b01      	cmp	r3, #1
   1a97c:	f000 80c9 	beq.w	1ab12 <SFXVocoderFrame+0x1da>
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1a980:	4b76      	ldr	r3, [pc, #472]	; (1ab5c <SFXVocoderFrame+0x224>)
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1a982:	eeb3 6a0e 	vmov.f32	s12, #62	; 0x41f00000  30.0
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1a986:	eddf 6a76 	vldr	s13, [pc, #472]	; 1ab60 <SFXVocoderFrame+0x228>
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1a98a:	eeba 7a0e 	vmov.f32	s14, #174	; 0xc1700000 -15.0
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1a98e:	ed93 5a01 	vldr	s10, [r3, #4]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1a992:	2400      	movs	r4, #0
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1a994:	eddf 7a73 	vldr	s15, [pc, #460]	; 1ab64 <SFXVocoderFrame+0x22c>
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1a998:	edd3 5a06 	vldr	s11, [r3, #24]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1a99c:	46a1      	mov	r9, r4
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1a99e:	eee5 7a26 	vfma.f32	s15, s10, s13
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1a9a2:	edd3 6a02 	vldr	s13, [r3, #8]
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1a9a6:	eea5 7a86 	vfma.f32	s14, s11, s12
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1a9aa:	ed9f 6a6f 	vldr	s12, [pc, #444]	; 1ab68 <SFXVocoderFrame+0x230>
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1a9ae:	4d6f      	ldr	r5, [pc, #444]	; (1ab6c <SFXVocoderFrame+0x234>)
   1a9b0:	6819      	ldr	r1, [r3, #0]
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1a9b2:	ee66 6a86 	vmul.f32	s13, s13, s12
            displayValues[3] = presetKnobValues[Vocoder][3]; //crossfade between sawtooth and glottal pulse
   1a9b6:	68da      	ldr	r2, [r3, #12]
            displayValues[4] = presetKnobValues[Vocoder][4]; //noise thresh
   1a9b8:	6918      	ldr	r0, [r3, #16]
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1a9ba:	6029      	str	r1, [r5, #0]
            tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
   1a9bc:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[5] = presetKnobValues[Vocoder][5]; //breathy
   1a9c0:	6959      	ldr	r1, [r3, #20]
            displayValues[3] = presetKnobValues[Vocoder][3]; //crossfade between sawtooth and glottal pulse
   1a9c2:	60ea      	str	r2, [r5, #12]
            displayValues[7] = presetKnobValues[Vocoder][7]; //pulse length
   1a9c4:	69da      	ldr	r2, [r3, #28]
            displayValues[8] = presetKnobValues[Vocoder][8]; //open length
   1a9c6:	6a1b      	ldr	r3, [r3, #32]
            displayValues[4] = presetKnobValues[Vocoder][4]; //noise thresh
   1a9c8:	6128      	str	r0, [r5, #16]
            tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
   1a9ca:	4869      	ldr	r0, [pc, #420]	; (1ab70 <SFXVocoderFrame+0x238>)
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1a9cc:	edc5 7a01 	vstr	s15, [r5, #4]
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1a9d0:	edc5 6a02 	vstr	s13, [r5, #8]
            displayValues[5] = presetKnobValues[Vocoder][5]; //breathy
   1a9d4:	6169      	str	r1, [r5, #20]
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1a9d6:	ed85 7a06 	vstr	s14, [r5, #24]
            displayValues[7] = presetKnobValues[Vocoder][7]; //pulse length
   1a9da:	61ea      	str	r2, [r5, #28]
            displayValues[8] = presetKnobValues[Vocoder][8]; //open length
   1a9dc:	622b      	str	r3, [r5, #32]
            tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
   1a9de:	f00b fc49 	bl	26274 <tTalkboxFloat_setWarpFactor>
            tTalkboxFloat_setQuality(&vocoder, displayValues[2]);
   1a9e2:	ed95 0a02 	vldr	s0, [r5, #8]
   1a9e6:	4862      	ldr	r0, [pc, #392]	; (1ab70 <SFXVocoderFrame+0x238>)
   1a9e8:	f00b fc26 	bl	26238 <tTalkboxFloat_setQuality>
   1a9ec:	4f61      	ldr	r7, [pc, #388]	; (1ab74 <SFXVocoderFrame+0x23c>)
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1a9ee:	4e5a      	ldr	r6, [pc, #360]	; (1ab58 <SFXVocoderFrame+0x220>)
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1a9f0:	ed9f 8a61 	vldr	s16, [pc, #388]	; 1ab78 <SFXVocoderFrame+0x240>
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1a9f4:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 1aba8 <SFXVocoderFrame+0x270>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1a9f8:	e04f      	b.n	1aa9a <SFXVocoderFrame+0x162>
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1a9fa:	f00f fd25 	bl	2a448 <tSimplePoly_getVelocity>
   1a9fe:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1aa02:	2800      	cmp	r0, #0
   1aa04:	4658      	mov	r0, fp
   1aa06:	fe30 0a08 	vselgt.f32	s0, s0, s16
   1aa0a:	f00d f9f9 	bl	27e00 <tExpSmooth_setDest>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1aa0e:	4651      	mov	r1, sl
   1aa10:	4630      	mov	r0, r6
   1aa12:	f00f fd0d 	bl	2a430 <tSimplePoly_getPitch>
   1aa16:	ee07 0a90 	vmov	s15, r0
   1aa1a:	4a58      	ldr	r2, [pc, #352]	; (1ab7c <SFXVocoderFrame+0x244>)
   1aa1c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1aa20:	4b57      	ldr	r3, [pc, #348]	; (1ab80 <SFXVocoderFrame+0x248>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1aa22:	ed92 0a00 	vldr	s0, [r2]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1aa26:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1aa28:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1aa2c:	4955      	ldr	r1, [pc, #340]	; (1ab84 <SFXVocoderFrame+0x24c>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1aa2e:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1aa32:	ee17 3a90 	vmov	r3, s15
   1aa36:	1a9b      	subs	r3, r3, r2
   1aa38:	fb88 2003 	smull	r2, r0, r8, r3
   1aa3c:	17da      	asrs	r2, r3, #31
   1aa3e:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1aa42:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1aa46:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1aa4a:	ee07 3a90 	vmov	s15, r3
   1aa4e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1aa52:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1aa56:	ee17 3a90 	vmov	r3, s15
   1aa5a:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1aa5e:	ed93 0a00 	vldr	s0, [r3]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1aa62:	ee37 0a00 	vadd.f32	s0, s14, s0
   1aa66:	f00e ff49 	bl	298fc <LEAF_midiToFrequency>
                tSawtooth_setFreq(&osc[i], freq[i]);
   1aa6a:	4847      	ldr	r0, [pc, #284]	; (1ab88 <SFXVocoderFrame+0x250>)
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1aa6c:	ed87 0a00 	vstr	s0, [r7]
                tSawtooth_setFreq(&osc[i], freq[i]);
   1aa70:	4420      	add	r0, r4
   1aa72:	f00f fd9f 	bl	2a5b4 <tSawtooth_setFreq>
   1aa76:	4b45      	ldr	r3, [pc, #276]	; (1ab8c <SFXVocoderFrame+0x254>)
                tRosenbergGlottalPulse_setFreq(&glottal[i], freq[i]);
   1aa78:	ecb7 0a01 	vldmia	r7!, {s0}
   1aa7c:	eb04 0a03 	add.w	sl, r4, r3
   1aa80:	3404      	adds	r4, #4
   1aa82:	4650      	mov	r0, sl
   1aa84:	f00b fcf6 	bl	26474 <tRosenbergGlottalPulse_setFreq>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], displayValues[8] * displayValues[7], displayValues[7]);
   1aa88:	edd5 0a07 	vldr	s1, [r5, #28]
   1aa8c:	ed95 0a08 	vldr	s0, [r5, #32]
   1aa90:	4650      	mov	r0, sl
   1aa92:	ee20 0a80 	vmul.f32	s0, s1, s0
   1aa96:	f00b fd17 	bl	264c8 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1aa9a:	4630      	mov	r0, r6
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1aa9c:	fa5f fa89 	uxtb.w	sl, r9
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1aaa0:	f00f fcaa 	bl	2a3f8 <tSimplePoly_getNumVoices>
   1aaa4:	4b3a      	ldr	r3, [pc, #232]	; (1ab90 <SFXVocoderFrame+0x258>)
   1aaa6:	4548      	cmp	r0, r9
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1aaa8:	4651      	mov	r1, sl
   1aaaa:	4630      	mov	r0, r6
   1aaac:	eb04 0b03 	add.w	fp, r4, r3
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1aab0:	f109 0901 	add.w	r9, r9, #1
   1aab4:	dca1      	bgt.n	1a9fa <SFXVocoderFrame+0xc2>
            if (tSimplePoly_getNumActiveVoices(&poly) != 0)
   1aab6:	4828      	ldr	r0, [pc, #160]	; (1ab58 <SFXVocoderFrame+0x220>)
   1aab8:	f00f fca2 	bl	2a400 <tSimplePoly_getNumActiveVoices>
   1aabc:	b9c0      	cbnz	r0, 1aaf0 <SFXVocoderFrame+0x1b8>
                tExpSmooth_setDest(&comp, 0.0f);
   1aabe:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 1ab78 <SFXVocoderFrame+0x240>
   1aac2:	4834      	ldr	r0, [pc, #208]	; (1ab94 <SFXVocoderFrame+0x25c>)
   1aac4:	f00d f99c 	bl	27e00 <tExpSmooth_setDest>
            tVZFilter_setGain(&shelf1, fasterdbtoa(-1.0f * displayValues[6]));
   1aac8:	ed95 0a06 	vldr	s0, [r5, #24]
   1aacc:	eeb1 0a40 	vneg.f32	s0, s0
   1aad0:	f00e fff0 	bl	29ab4 <fasterdbtoa>
   1aad4:	4830      	ldr	r0, [pc, #192]	; (1ab98 <SFXVocoderFrame+0x260>)
   1aad6:	f00e fb1f 	bl	29118 <tVZFilter_setGain>
            tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
   1aada:	ed95 0a06 	vldr	s0, [r5, #24]
   1aade:	f00e ffe1 	bl	29aa4 <fastdbtoa>
   1aae2:	482e      	ldr	r0, [pc, #184]	; (1ab9c <SFXVocoderFrame+0x264>)
        }
   1aae4:	ecbd 8b02 	vpop	{d8}
   1aae8:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
   1aaec:	f00e bb14 	b.w	29118 <tVZFilter_setGain>
                tExpSmooth_setDest(&comp, sqrtf(1.0f / tSimplePoly_getNumActiveVoices(&poly)));
   1aaf0:	4819      	ldr	r0, [pc, #100]	; (1ab58 <SFXVocoderFrame+0x220>)
   1aaf2:	f00f fc85 	bl	2a400 <tSimplePoly_getNumActiveVoices>
   1aaf6:	ee07 0a90 	vmov	s15, r0
   1aafa:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1aafe:	4825      	ldr	r0, [pc, #148]	; (1ab94 <SFXVocoderFrame+0x25c>)
   1ab00:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1ab04:	ee87 0a27 	vdiv.f32	s0, s14, s15
   1ab08:	eeb1 0ac0 	vsqrt.f32	s0, s0
   1ab0c:	f00d f978 	bl	27e00 <tExpSmooth_setDest>
   1ab10:	e7da      	b.n	1aac8 <SFXVocoderFrame+0x190>
                vocFreezeLPC = !vocFreezeLPC;
   1ab12:	4d23      	ldr	r5, [pc, #140]	; (1aba0 <SFXVocoderFrame+0x268>)
                tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
   1ab14:	4816      	ldr	r0, [pc, #88]	; (1ab70 <SFXVocoderFrame+0x238>)
                vocFreezeLPC = !vocFreezeLPC;
   1ab16:	682b      	ldr	r3, [r5, #0]
   1ab18:	fab3 f383 	clz	r3, r3
   1ab1c:	095b      	lsrs	r3, r3, #5
                tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
   1ab1e:	ee07 3a90 	vmov	s15, r3
                vocFreezeLPC = !vocFreezeLPC;
   1ab22:	602b      	str	r3, [r5, #0]
                tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
   1ab24:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   1ab28:	f00b fbae 	bl	26288 <tTalkboxFloat_setFreeze>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1ab2c:	2300      	movs	r3, #0
                setLED_C(vocFreezeLPC);
   1ab2e:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1ab30:	7723      	strb	r3, [r4, #28]
                setLED_C(vocFreezeLPC);
   1ab32:	f7fe fcc9 	bl	194c8 <setLED_C>
   1ab36:	e723      	b.n	1a980 <SFXVocoderFrame+0x48>
                internalExternal = !internalExternal;
   1ab38:	4a1a      	ldr	r2, [pc, #104]	; (1aba4 <SFXVocoderFrame+0x26c>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1ab3a:	2100      	movs	r1, #0
                internalExternal = !internalExternal;
   1ab3c:	7813      	ldrb	r3, [r2, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1ab3e:	7621      	strb	r1, [r4, #24]
                internalExternal = !internalExternal;
   1ab40:	fab3 f383 	clz	r3, r3
   1ab44:	095b      	lsrs	r3, r3, #5
                setLED_B(internalExternal);
   1ab46:	4618      	mov	r0, r3
                internalExternal = !internalExternal;
   1ab48:	7013      	strb	r3, [r2, #0]
                setLED_B(internalExternal);
   1ab4a:	f7fe fcaf 	bl	194ac <setLED_B>
   1ab4e:	e713      	b.n	1a978 <SFXVocoderFrame+0x40>
   1ab50:	020fafac 	.word	0x020fafac
   1ab54:	000627ac 	.word	0x000627ac
   1ab58:	020f9de8 	.word	0x020f9de8
   1ab5c:	020e55d8 	.word	0x020e55d8
   1ab60:	3ecccccd 	.word	0x3ecccccd
   1ab64:	be4ccccd 	.word	0xbe4ccccd
   1ab68:	3f8ccccd 	.word	0x3f8ccccd
   1ab6c:	020fb05c 	.word	0x020fb05c
   1ab70:	020faa08 	.word	0x020faa08
   1ab74:	020e5d04 	.word	0x020e5d04
   1ab78:	00000000 	.word	0x00000000
   1ab7c:	020e2ea0 	.word	0x020e2ea0
   1ab80:	020e2f18 	.word	0x020e2f18
   1ab84:	020e2ee4 	.word	0x020e2ee4
   1ab88:	020f9ba4 	.word	0x020f9ba4
   1ab8c:	020e5110 	.word	0x020e5110
   1ab90:	020fa1e4 	.word	0x020fa1e4
   1ab94:	020f9b24 	.word	0x020f9b24
   1ab98:	020f9dc4 	.word	0x020f9dc4
   1ab9c:	020f9cec 	.word	0x020f9cec
   1aba0:	020e2edc 	.word	0x020e2edc
   1aba4:	020e2e64 	.word	0x020e2e64
   1aba8:	2aaaaaab 	.word	0x2aaaaaab

0001abac <SFXVocoderTick>:
            if (internalExternal == 1)
   1abac:	4b60      	ldr	r3, [pc, #384]	; (1ad30 <SFXVocoderTick+0x184>)
        {
   1abae:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1abb2:	ed2d 8b08 	vpush	{d8-d11}
            if (internalExternal == 1)
   1abb6:	781b      	ldrb	r3, [r3, #0]
        {
   1abb8:	4680      	mov	r8, r0
   1abba:	ed90 8a01 	vldr	s16, [r0, #4]
            if (internalExternal == 1)
   1abbe:	2b01      	cmp	r3, #1
   1abc0:	f000 80b1 	beq.w	1ad26 <SFXVocoderTick+0x17a>
                zerocross = tZeroCrossing_tick(&zerox, input[1]);
   1abc4:	eeb0 0a48 	vmov.f32	s0, s16
   1abc8:	485a      	ldr	r0, [pc, #360]	; (1ad34 <SFXVocoderTick+0x188>)
   1abca:	f009 fb43 	bl	24254 <tZeroCrossing_tick>
                if (!vocChFreeze)
   1abce:	4b5a      	ldr	r3, [pc, #360]	; (1ad38 <SFXVocoderTick+0x18c>)
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1abd0:	4f5a      	ldr	r7, [pc, #360]	; (1ad3c <SFXVocoderTick+0x190>)
                if (!vocChFreeze)
   1abd2:	681b      	ldr	r3, [r3, #0]
   1abd4:	2b00      	cmp	r3, #0
   1abd6:	f000 808f 	beq.w	1acf8 <SFXVocoderTick+0x14c>
                noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1abda:	4859      	ldr	r0, [pc, #356]	; (1ad40 <SFXVocoderTick+0x194>)
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1abdc:	2400      	movs	r4, #0
                noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1abde:	f00d f919 	bl	27e14 <tExpSmooth_tick>
   1abe2:	eeb0 ba40 	vmov.f32	s22, s0
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1abe6:	4857      	ldr	r0, [pc, #348]	; (1ad44 <SFXVocoderTick+0x198>)
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1abe8:	4626      	mov	r6, r4
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1abea:	f00f fd87 	bl	2a6fc <tNoise_tick>
   1abee:	eddf 7a56 	vldr	s15, [pc, #344]	; 1ad48 <SFXVocoderTick+0x19c>
   1abf2:	ee20 0a0b 	vmul.f32	s0, s0, s22
            float sample = 0.0f;
   1abf6:	ed9f 9a55 	vldr	s18, [pc, #340]	; 1ad4c <SFXVocoderTick+0x1a0>
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1abfa:	f8df a180 	ldr.w	sl, [pc, #384]	; 1ad7c <SFXVocoderTick+0x1d0>
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1abfe:	f8df 9180 	ldr.w	r9, [pc, #384]	; 1ad80 <SFXVocoderTick+0x1d4>
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1ac02:	ee20 aa27 	vmul.f32	s20, s0, s15
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1ac06:	eddf aa52 	vldr	s21, [pc, #328]	; 1ad50 <SFXVocoderTick+0x1a4>
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ac0a:	e026      	b.n	1ac5a <SFXVocoderTick+0xae>
   1ac0c:	4d51      	ldr	r5, [pc, #324]	; (1ad54 <SFXVocoderTick+0x1a8>)
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1ac0e:	f00f fd03 	bl	2a618 <tSawtooth_tick>
   1ac12:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   1ac16:	4425      	add	r5, r4
   1ac18:	eef0 8a40 	vmov.f32	s17, s0
   1ac1c:	4628      	mov	r0, r5
   1ac1e:	f00d f8f9 	bl	27e14 <tExpSmooth_tick>
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1ac22:	484d      	ldr	r0, [pc, #308]	; (1ad58 <SFXVocoderTick+0x1ac>)
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1ac24:	edd7 7a03 	vldr	s15, [r7, #12]
   1ac28:	ee68 8a80 	vmul.f32	s17, s17, s0
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1ac2c:	4420      	add	r0, r4
   1ac2e:	3404      	adds	r4, #4
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1ac30:	ee38 8a67 	vsub.f32	s16, s16, s15
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1ac34:	f00b fbae 	bl	26394 <tRosenbergGlottalPulse_tickHQ>
   1ac38:	4628      	mov	r0, r5
   1ac3a:	eef0 9a40 	vmov.f32	s19, s0
   1ac3e:	f00d f8e9 	bl	27e14 <tExpSmooth_tick>
   1ac42:	edd7 7a03 	vldr	s15, [r7, #12]
   1ac46:	ee67 7aaa 	vmul.f32	s15, s15, s21
   1ac4a:	ee67 7aa9 	vmul.f32	s15, s15, s19
   1ac4e:	ee27 0a80 	vmul.f32	s0, s15, s0
   1ac52:	eea8 0a88 	vfma.f32	s0, s17, s16
   1ac56:	ee39 9a00 	vadd.f32	s18, s18, s0
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ac5a:	4650      	mov	r0, sl
   1ac5c:	f00f fbcc 	bl	2a3f8 <tSimplePoly_getNumVoices>
   1ac60:	42b0      	cmp	r0, r6
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1ac62:	eb09 0004 	add.w	r0, r9, r4
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ac66:	f106 0601 	add.w	r6, r6, #1
   1ac6a:	dccf      	bgt.n	1ac0c <SFXVocoderTick+0x60>
                sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
   1ac6c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1ac70:	ed97 7a05 	vldr	s14, [r7, #20]
   1ac74:	eddf 7a39 	vldr	s15, [pc, #228]	; 1ad5c <SFXVocoderTick+0x1b0>
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1ac78:	4839      	ldr	r0, [pc, #228]	; (1ad60 <SFXVocoderTick+0x1b4>)
                sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
   1ac7a:	eeb0 8a40 	vmov.f32	s16, s0
   1ac7e:	ee30 0a4b 	vsub.f32	s0, s0, s22
   1ac82:	eea7 8a67 	vfms.f32	s16, s14, s15
   1ac86:	ee28 8a00 	vmul.f32	s16, s16, s0
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1ac8a:	f00f fd37 	bl	2a6fc <tNoise_tick>
   1ac8e:	4835      	ldr	r0, [pc, #212]	; (1ad64 <SFXVocoderTick+0x1b8>)
   1ac90:	f00d fbf8 	bl	28484 <tHighpass_tick>
   1ac94:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
   1ac98:	edd7 7a05 	vldr	s15, [r7, #20]
                sample *= tExpSmooth_tick(&comp);
   1ac9c:	4832      	ldr	r0, [pc, #200]	; (1ad68 <SFXVocoderTick+0x1bc>)
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1ac9e:	ee67 7a87 	vmul.f32	s15, s15, s14
   1aca2:	ee27 0a80 	vmul.f32	s0, s15, s0
   1aca6:	eea9 0a08 	vfma.f32	s0, s18, s16
   1acaa:	ee3a aa00 	vadd.f32	s20, s20, s0
                sample *= tExpSmooth_tick(&comp);
   1acae:	f00d f8b1 	bl	27e14 <tExpSmooth_tick>
   1acb2:	ed98 8a01 	vldr	s16, [r8, #4]
   1acb6:	ee2a 0a00 	vmul.f32	s0, s20, s0
            sample = tanhf(sample);
   1acba:	f012 fa4f 	bl	2d15c <tanhf>
            sample = tTalkboxFloat_tick(&vocoder, sample, input[1]);
   1acbe:	eef0 0a48 	vmov.f32	s1, s16
   1acc2:	482a      	ldr	r0, [pc, #168]	; (1ad6c <SFXVocoderTick+0x1c0>)
   1acc4:	f00b f9e8 	bl	26098 <tTalkboxFloat_tick>
            sample = tVZFilter_tick(&shelf1, sample); //put it through the low shelf
   1acc8:	4829      	ldr	r0, [pc, #164]	; (1ad70 <SFXVocoderTick+0x1c4>)
   1acca:	f00d fdeb 	bl	288a4 <tVZFilter_tick>
            sample = tVZFilter_tick(&shelf2, sample); // now put that result through the high shelf
   1acce:	4829      	ldr	r0, [pc, #164]	; (1ad74 <SFXVocoderTick+0x1c8>)
   1acd0:	f00d fde8 	bl	288a4 <tVZFilter_tick>
            sample *= displayValues[0] * 0.6f;
   1acd4:	edd7 7a00 	vldr	s15, [r7]
   1acd8:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 1ad48 <SFXVocoderTick+0x19c>
   1acdc:	ee67 7a87 	vmul.f32	s15, s15, s14
            sample = tanhf(sample);
   1ace0:	ee27 0a80 	vmul.f32	s0, s15, s0
   1ace4:	f012 fa3a 	bl	2d15c <tanhf>
            input[0] = sample;
   1ace8:	ed88 0a00 	vstr	s0, [r8]
            input[1] = sample;
   1acec:	ed88 0a01 	vstr	s0, [r8, #4]
        }
   1acf0:	ecbd 8b08 	vpop	{d8-d11}
   1acf4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1acf8:	ed9f 6a1f 	vldr	s12, [pc, #124]	; 1ad78 <SFXVocoderTick+0x1cc>
   1acfc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   1ad00:	edd7 7a04 	vldr	s15, [r7, #16]
   1ad04:	ed9f 7a11 	vldr	s14, [pc, #68]	; 1ad4c <SFXVocoderTick+0x1a0>
   1ad08:	ee77 7ac6 	vsub.f32	s15, s15, s12
   1ad0c:	480c      	ldr	r0, [pc, #48]	; (1ad40 <SFXVocoderTick+0x194>)
   1ad0e:	eef4 7ac0 	vcmpe.f32	s15, s0
   1ad12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ad16:	bf54      	ite	pl
   1ad18:	eeb0 0a47 	vmovpl.f32	s0, s14
   1ad1c:	eeb0 0a66 	vmovmi.f32	s0, s13
   1ad20:	f00d f86e 	bl	27e00 <tExpSmooth_setDest>
   1ad24:	e759      	b.n	1abda <SFXVocoderTick+0x2e>
                sample = input[0];
   1ad26:	ed90 0a00 	vldr	s0, [r0]
   1ad2a:	4f04      	ldr	r7, [pc, #16]	; (1ad3c <SFXVocoderTick+0x190>)
   1ad2c:	e7c5      	b.n	1acba <SFXVocoderTick+0x10e>
   1ad2e:	bf00      	nop
   1ad30:	020e2e64 	.word	0x020e2e64
   1ad34:	020f9f58 	.word	0x020f9f58
   1ad38:	020e2ed8 	.word	0x020e2ed8
   1ad3c:	020fb05c 	.word	0x020fb05c
   1ad40:	020faaf0 	.word	0x020faaf0
   1ad44:	020e5d2c 	.word	0x020e5d2c
   1ad48:	3f19999a 	.word	0x3f19999a
   1ad4c:	00000000 	.word	0x00000000
   1ad50:	3ff33333 	.word	0x3ff33333
   1ad54:	020fa1e4 	.word	0x020fa1e4
   1ad58:	020e5110 	.word	0x020e5110
   1ad5c:	3e99999a 	.word	0x3e99999a
   1ad60:	020e50e0 	.word	0x020e50e0
   1ad64:	020e5d24 	.word	0x020e5d24
   1ad68:	020f9b24 	.word	0x020f9b24
   1ad6c:	020faa08 	.word	0x020faa08
   1ad70:	020f9dc4 	.word	0x020f9dc4
   1ad74:	020f9cec 	.word	0x020f9cec
   1ad78:	3dcccccd 	.word	0x3dcccccd
   1ad7c:	020f9de8 	.word	0x020f9de8
   1ad80:	020f9ba4 	.word	0x020f9ba4

0001ad84 <SFXVocoderFree>:
        {
   1ad84:	b570      	push	{r4, r5, r6, lr}
            tTalkboxFloat_free(&vocoder);
   1ad86:	4812      	ldr	r0, [pc, #72]	; (1add0 <SFXVocoderFree+0x4c>)
            tVZFilter_free(&shelf2);
   1ad88:	2400      	movs	r4, #0
            tTalkboxFloat_free(&vocoder);
   1ad8a:	f00a ff1f 	bl	25bcc <tTalkboxFloat_free>
            tNoise_free(&vocoderNoise);
   1ad8e:	4811      	ldr	r0, [pc, #68]	; (1add4 <SFXVocoderFree+0x50>)
   1ad90:	f00f fcb0 	bl	2a6f4 <tNoise_free>
            tZeroCrossing_free(&zerox);
   1ad94:	4810      	ldr	r0, [pc, #64]	; (1add8 <SFXVocoderFree+0x54>)
   1ad96:	f009 fa4d 	bl	24234 <tZeroCrossing_free>
            tExpSmooth_free(&noiseRamp);
   1ad9a:	4810      	ldr	r0, [pc, #64]	; (1addc <SFXVocoderFree+0x58>)
   1ad9c:	f00d f81a 	bl	27dd4 <tExpSmooth_free>
            tNoise_free(&breathNoise);
   1ada0:	480f      	ldr	r0, [pc, #60]	; (1ade0 <SFXVocoderFree+0x5c>)
   1ada2:	f00f fca7 	bl	2a6f4 <tNoise_free>
            tHighpass_free(&noiseHP);
   1ada6:	480f      	ldr	r0, [pc, #60]	; (1ade4 <SFXVocoderFree+0x60>)
   1ada8:	f00d fb58 	bl	2845c <tHighpass_free>
            tVZFilter_free(&shelf1);
   1adac:	480e      	ldr	r0, [pc, #56]	; (1ade8 <SFXVocoderFree+0x64>)
   1adae:	f00d fd6b 	bl	28888 <tVZFilter_free>
            tVZFilter_free(&shelf2);
   1adb2:	480e      	ldr	r0, [pc, #56]	; (1adec <SFXVocoderFree+0x68>)
   1adb4:	4e0e      	ldr	r6, [pc, #56]	; (1adf0 <SFXVocoderFree+0x6c>)
   1adb6:	4d0f      	ldr	r5, [pc, #60]	; (1adf4 <SFXVocoderFree+0x70>)
   1adb8:	f00d fd66 	bl	28888 <tVZFilter_free>
                tSawtooth_free(&osc[i]);
   1adbc:	1930      	adds	r0, r6, r4
   1adbe:	f00f fbf5 	bl	2a5ac <tSawtooth_free>
                tRosenbergGlottalPulse_free(&glottal[i]);
   1adc2:	1928      	adds	r0, r5, r4
   1adc4:	3404      	adds	r4, #4
   1adc6:	f00b fa75 	bl	262b4 <tRosenbergGlottalPulse_free>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
   1adca:	2c20      	cmp	r4, #32
   1adcc:	d1f6      	bne.n	1adbc <SFXVocoderFree+0x38>
        }
   1adce:	bd70      	pop	{r4, r5, r6, pc}
   1add0:	020faa08 	.word	0x020faa08
   1add4:	020e5d2c 	.word	0x020e5d2c
   1add8:	020f9f58 	.word	0x020f9f58
   1addc:	020faaf0 	.word	0x020faaf0
   1ade0:	020e50e0 	.word	0x020e50e0
   1ade4:	020e5d24 	.word	0x020e5d24
   1ade8:	020f9dc4 	.word	0x020f9dc4
   1adec:	020f9cec 	.word	0x020f9cec
   1adf0:	020f9ba4 	.word	0x020f9ba4
   1adf4:	020e5110 	.word	0x020e5110

0001adf8 <SFXVocoderChAlloc>:
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1adf8:	4bd7      	ldr	r3, [pc, #860]	; (1b158 <SFXVocoderChAlloc+0x360>)
   1adfa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1adfe:	ed9f 6ad7 	vldr	s12, [pc, #860]	; 1b15c <SFXVocoderChAlloc+0x364>
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1ae02:	eeb0 3a00 	vmov.f32	s6, #0	; 0x40000000  2.0
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1ae06:	4ad6      	ldr	r2, [pc, #856]	; (1b160 <SFXVocoderChAlloc+0x368>)
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1ae08:	eebf 5a00 	vmov.f32	s10, #240	; 0xbf800000 -1.0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ae0c:	eddf 6ad5 	vldr	s13, [pc, #852]	; 1b164 <SFXVocoderChAlloc+0x36c>
   1ae10:	eef2 2a00 	vmov.f32	s5, #32	; 0x41000000  8.0
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1ae14:	ed9f 2ad4 	vldr	s4, [pc, #848]	; 1b168 <SFXVocoderChAlloc+0x370>
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1ae18:	eef0 0a08 	vmov.f32	s1, #8	; 0x40400000  3.0
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1ae1c:	ed9f 4ad3 	vldr	s8, [pc, #844]	; 1b16c <SFXVocoderChAlloc+0x374>
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1ae20:	2107      	movs	r1, #7
   1ae22:	ed9f 0ad3 	vldr	s0, [pc, #844]	; 1b170 <SFXVocoderChAlloc+0x378>
        {
   1ae26:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ae2a:	ed2d 8b04 	vpush	{d8-d9}
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ae2e:	781b      	ldrb	r3, [r3, #0]
        {
   1ae30:	b083      	sub	sp, #12
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ae32:	edd2 4a1b 	vldr	s9, [r2, #108]	; 0x6c
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1ae36:	2400      	movs	r4, #0
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ae38:	ee07 3a10 	vmov	s14, r3
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1ae3c:	edd2 5a1c 	vldr	s11, [r2, #112]	; 0x70
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ae40:	ee64 4aa6 	vmul.f32	s9, s9, s13
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1ae44:	eddf 6acb 	vldr	s13, [pc, #812]	; 1b174 <SFXVocoderChAlloc+0x37c>
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ae48:	eeb8 7a47 	vcvt.f32.u32	s14, s14
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1ae4c:	edd2 1a1a 	vldr	s3, [r2, #104]	; 0x68
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1ae50:	4bc9      	ldr	r3, [pc, #804]	; (1b178 <SFXVocoderChAlloc+0x380>)
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1ae52:	f04f 0801 	mov.w	r8, #1
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ae56:	eefc 4ae4 	vcvt.u32.f32	s9, s9
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1ae5a:	6e57      	ldr	r7, [r2, #100]	; 0x64
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ae5c:	ee37 7a46 	vsub.f32	s14, s14, s12
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1ae60:	ed9f 6ac6 	vldr	s12, [pc, #792]	; 1b17c <SFXVocoderChAlloc+0x384>
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1ae64:	eea1 4a82 	vfma.f32	s8, s3, s4
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1ae68:	ed9f 2ac5 	vldr	s4, [pc, #788]	; 1b180 <SFXVocoderChAlloc+0x388>
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ae6c:	edcd 4a01 	vstr	s9, [sp, #4]
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1ae70:	eea5 6a83 	vfma.f32	s12, s11, s6
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ae74:	eec7 3a87 	vdiv.f32	s7, s15, s14
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ae78:	f89d 0004 	ldrb.w	r0, [sp, #4]
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1ae7c:	edd2 7a25 	vldr	s15, [r2, #148]	; 0x94
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1ae80:	4625      	mov	r5, r4
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1ae82:	ed9f 7ac0 	vldr	s14, [pc, #768]	; 1b184 <SFXVocoderChAlloc+0x38c>
            displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
   1ae86:	edd2 5a23 	vldr	s11, [r2, #140]	; 0x8c
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1ae8a:	edd2 4a24 	vldr	s9, [r2, #144]	; 0x90
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1ae8e:	eea7 5a83 	vfma.f32	s10, s15, s6
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ae92:	ee07 0a90 	vmov	s15, r0
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1ae96:	6f90      	ldr	r0, [r2, #120]	; 0x78
            displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
   1ae98:	ee75 5aa5 	vadd.f32	s11, s11, s11
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ae9c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1aea0:	f8d2 c074 	ldr.w	ip, [r2, #116]	; 0x74
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1aea4:	f8d2 a07c 	ldr.w	sl, [r2, #124]	; 0x7c
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1aea8:	ee64 4a82 	vmul.f32	s9, s9, s4
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1aeac:	f8d2 6080 	ldr.w	r6, [r2, #128]	; 0x80
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1aeb0:	ee77 7aa2 	vadd.f32	s15, s15, s5
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1aeb4:	601f      	str	r7, [r3, #0]
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1aeb6:	f8d2 7084 	ldr.w	r7, [r2, #132]	; 0x84
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1aeba:	f8d2 9088 	ldr.w	r9, [r2, #136]	; 0x88
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1aebe:	edc3 7a02 	vstr	s15, [r3, #8]
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1aec2:	6158      	str	r0, [r3, #20]
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1aec4:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1aec8:	ee63 6aa6 	vmul.f32	s13, s7, s13
            displayValues[14] = presetKnobValues[VocoderCh][14]; //odd/even
   1aecc:	f8d2 e09c 	ldr.w	lr, [r2, #156]	; 0x9c
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1aed0:	f8c3 c010 	str.w	ip, [r3, #16]
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1aed4:	f8c3 a018 	str.w	sl, [r3, #24]
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1aed8:	ee66 7a87 	vmul.f32	s15, s13, s14
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1aedc:	61de      	str	r6, [r3, #28]
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1aede:	621f      	str	r7, [r3, #32]
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1aee0:	f8df c318 	ldr.w	ip, [pc, #792]	; 1b1fc <SFXVocoderChAlloc+0x404>
            thisBandwidth = bandWidthInOctaves * myQ;
   1aee4:	ee26 7a27 	vmul.f32	s14, s12, s15
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1aee8:	4fa7      	ldr	r7, [pc, #668]	; (1b188 <SFXVocoderChAlloc+0x390>)
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1aeea:	f8df a314 	ldr.w	sl, [pc, #788]	; 1b200 <SFXVocoderChAlloc+0x408>
            thisBandwidth = bandWidthInOctaves * myQ;
   1aeee:	4ea7      	ldr	r6, [pc, #668]	; (1b18c <SFXVocoderChAlloc+0x394>)
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1aef0:	f8c3 9024 	str.w	r9, [r3, #36]	; 0x24
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1aef4:	ed83 4a01 	vstr	s8, [r3, #4]
            displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
   1aef8:	edc3 5a0a 	vstr	s11, [r3, #40]	; 0x28
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1aefc:	edc3 4a0b 	vstr	s9, [r3, #44]	; 0x2c
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1af00:	ed83 5a0c 	vstr	s10, [r3, #48]	; 0x30
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1af04:	4aa2      	ldr	r2, [pc, #648]	; (1b190 <SFXVocoderChAlloc+0x398>)
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1af06:	ed83 6a03 	vstr	s12, [r3, #12]
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1af0a:	6358      	str	r0, [r3, #52]	; 0x34
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1af0c:	48a1      	ldr	r0, [pc, #644]	; (1b194 <SFXVocoderChAlloc+0x39c>)
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1af0e:	edc7 7a00 	vstr	s15, [r7]
            displayValues[14] = presetKnobValues[VocoderCh][14]; //odd/even
   1af12:	f8c3 e038 	str.w	lr, [r3, #56]	; 0x38
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1af16:	edcc 3a00 	vstr	s7, [ip]
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1af1a:	edca 6a00 	vstr	s13, [sl]
            thisBandwidth = bandWidthInOctaves * myQ;
   1af1e:	ed86 7a00 	vstr	s14, [r6]
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1af22:	f00d fabf 	bl	284a4 <tVZFilter_initToPool>
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1af26:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1af2a:	489a      	ldr	r0, [pc, #616]	; (1b194 <SFXVocoderChAlloc+0x39c>)
   1af2c:	f8df b2d4 	ldr.w	fp, [pc, #724]	; 1b204 <SFXVocoderChAlloc+0x40c>
   1af30:	f00e f8f2 	bl	29118 <tVZFilter_setGain>
   1af34:	f8df 92d0 	ldr.w	r9, [pc, #720]	; 1b208 <SFXVocoderChAlloc+0x410>
   1af38:	4f97      	ldr	r7, [pc, #604]	; (1b198 <SFXVocoderChAlloc+0x3a0>)
                tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1af3a:	ed9f 9a98 	vldr	s18, [pc, #608]	; 1b19c <SFXVocoderChAlloc+0x3a4>
   1af3e:	eddf 8a98 	vldr	s17, [pc, #608]	; 1b1a0 <SFXVocoderChAlloc+0x3a8>
   1af42:	e004      	b.n	1af4e <SFXVocoderChAlloc+0x156>
   1af44:	3501      	adds	r5, #1
   1af46:	f108 0801 	add.w	r8, r8, #1
   1af4a:	3704      	adds	r7, #4
   1af4c:	3408      	adds	r4, #8
                float bandFreq = faster_mtof((i * bandWidthInSemitones) + 30.0f); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1af4e:	ee07 5a90 	vmov	s15, r5
   1af52:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
   1af56:	ed9a 7a00 	vldr	s14, [sl]
   1af5a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1af5e:	eea7 0a87 	vfma.f32	s0, s15, s14
   1af62:	f00e fd4f 	bl	29a04 <faster_mtof>
                bandGains[i] = 1.0f;
   1af66:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
                float bandFreq = faster_mtof((i * bandWidthInSemitones) + 30.0f); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1af6a:	eeb0 8a40 	vmov.f32	s16, s0
                    tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1af6e:	eb0b 0004 	add.w	r0, fp, r4
   1af72:	4a87      	ldr	r2, [pc, #540]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1af74:	2103      	movs	r1, #3
                bandGains[i] = 1.0f;
   1af76:	f849 3b04 	str.w	r3, [r9], #4
                if (i == 0)
   1af7a:	2d00      	cmp	r5, #0
   1af7c:	f000 80c2 	beq.w	1b104 <SFXVocoderChAlloc+0x30c>
   1af80:	edd6 7a00 	vldr	s15, [r6]
                else if (i == (MAX_NUM_VOCODER_BANDS-1))
   1af84:	2d17      	cmp	r5, #23
                    tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1af86:	eef0 0a67 	vmov.f32	s1, s15
                else if (i == (MAX_NUM_VOCODER_BANDS-1))
   1af8a:	f000 8092 	beq.w	1b0b2 <SFXVocoderChAlloc+0x2ba>
                    tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1af8e:	f00d fa89 	bl	284a4 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&analysisBands[i][1], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1af92:	4b84      	ldr	r3, [pc, #528]	; (1b1a4 <SFXVocoderChAlloc+0x3ac>)
   1af94:	4a7e      	ldr	r2, [pc, #504]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1af96:	eeb0 0a48 	vmov.f32	s0, s16
   1af9a:	1918      	adds	r0, r3, r4
   1af9c:	edd6 0a00 	vldr	s1, [r6]
   1afa0:	2103      	movs	r1, #3
   1afa2:	f00d fa7f 	bl	284a4 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1afa6:	4b80      	ldr	r3, [pc, #512]	; (1b1a8 <SFXVocoderChAlloc+0x3b0>)
   1afa8:	4a79      	ldr	r2, [pc, #484]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1afaa:	eeb0 0a48 	vmov.f32	s0, s16
   1afae:	1918      	adds	r0, r3, r4
   1afb0:	edd6 0a00 	vldr	s1, [r6]
   1afb4:	2103      	movs	r1, #3
   1afb6:	f00d fa75 	bl	284a4 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][1], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1afba:	4b7c      	ldr	r3, [pc, #496]	; (1b1ac <SFXVocoderChAlloc+0x3b4>)
   1afbc:	eeb0 0a48 	vmov.f32	s0, s16
   1afc0:	4a73      	ldr	r2, [pc, #460]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1afc2:	1918      	adds	r0, r3, r4
   1afc4:	2103      	movs	r1, #3
   1afc6:	edd6 0a00 	vldr	s1, [r6]
   1afca:	f00d fa6b 	bl	284a4 <tVZFilter_initToPool>
                tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1afce:	4970      	ldr	r1, [pc, #448]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1afd0:	eef0 0a49 	vmov.f32	s1, s18
   1afd4:	4638      	mov	r0, r7
   1afd6:	eeb0 0a68 	vmov.f32	s0, s17
   1afda:	f00c fed5 	bl	27d88 <tExpSmooth_initToPool>
            for (int i = 0; i < MAX_NUM_VOCODER_BANDS; i++)
   1afde:	f1b8 0f18 	cmp.w	r8, #24
   1afe2:	d1af      	bne.n	1af44 <SFXVocoderChAlloc+0x14c>
            tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1afe4:	2100      	movs	r1, #0
   1afe6:	4a6a      	ldr	r2, [pc, #424]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1afe8:	4871      	ldr	r0, [pc, #452]	; (1b1b0 <SFXVocoderChAlloc+0x3b8>)
            tHighpass_initToPool(&chVocFinalHP2, 20.0f, &smallPool);
   1afea:	460c      	mov	r4, r1
            tSimplePoly_setNumVoices(&poly, numVoices);
   1afec:	f8df 921c 	ldr.w	r9, [pc, #540]	; 1b20c <SFXVocoderChAlloc+0x414>
            tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1aff0:	f00f fb6e 	bl	2a6d0 <tNoise_initToPool>
            tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
   1aff4:	4a66      	ldr	r2, [pc, #408]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1aff6:	4621      	mov	r1, r4
   1aff8:	486e      	ldr	r0, [pc, #440]	; (1b1b4 <SFXVocoderChAlloc+0x3bc>)
   1affa:	f00f fb69 	bl	2a6d0 <tNoise_initToPool>
            tZeroCrossing_initToPool(&zerox, 256, &smallPool);
   1affe:	4a64      	ldr	r2, [pc, #400]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b000:	f44f 7180 	mov.w	r1, #256	; 0x100
   1b004:	486c      	ldr	r0, [pc, #432]	; (1b1b8 <SFXVocoderChAlloc+0x3c0>)
   1b006:	f009 f8ef 	bl	241e8 <tZeroCrossing_initToPool>
            tSimplePoly_setNumVoices(&poly, numVoices);
   1b00a:	f899 1000 	ldrb.w	r1, [r9]
   1b00e:	486b      	ldr	r0, [pc, #428]	; (1b1bc <SFXVocoderChAlloc+0x3c4>)
   1b010:	f00f f9ea 	bl	2a3e8 <tSimplePoly_setNumVoices>
            tExpSmooth_initToPool(&noiseRamp, 0.0f, 0.05f, &smallPool);
   1b014:	eddf 0a6a 	vldr	s1, [pc, #424]	; 1b1c0 <SFXVocoderChAlloc+0x3c8>
   1b018:	495d      	ldr	r1, [pc, #372]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b01a:	ed9f 0a61 	vldr	s0, [pc, #388]	; 1b1a0 <SFXVocoderChAlloc+0x3a8>
   1b01e:	4869      	ldr	r0, [pc, #420]	; (1b1c4 <SFXVocoderChAlloc+0x3cc>)
   1b020:	f00c feb2 	bl	27d88 <tExpSmooth_initToPool>
            tHighpass_initToPool(&noiseHP, 5000.0f, &smallPool);
   1b024:	495a      	ldr	r1, [pc, #360]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b026:	ed9f 0a68 	vldr	s0, [pc, #416]	; 1b1c8 <SFXVocoderChAlloc+0x3d0>
   1b02a:	4868      	ldr	r0, [pc, #416]	; (1b1cc <SFXVocoderChAlloc+0x3d4>)
   1b02c:	f00d f9f6 	bl	2841c <tHighpass_initToPool>
   1b030:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 1b210 <SFXVocoderChAlloc+0x418>
            tHighpass_initToPool(&chVocFinalHP1, 20.0f, &smallPool);
   1b034:	4956      	ldr	r1, [pc, #344]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b036:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1b03a:	4865      	ldr	r0, [pc, #404]	; (1b1d0 <SFXVocoderChAlloc+0x3d8>)
                tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
   1b03c:	eddf 8a65 	vldr	s17, [pc, #404]	; 1b1d4 <SFXVocoderChAlloc+0x3dc>
            tHighpass_initToPool(&chVocFinalHP1, 20.0f, &smallPool);
   1b040:	f00d f9ec 	bl	2841c <tHighpass_initToPool>
                tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
   1b044:	ed9f 8a64 	vldr	s16, [pc, #400]	; 1b1d8 <SFXVocoderChAlloc+0x3e0>
            tHighpass_initToPool(&chVocFinalHP2, 20.0f, &smallPool);
   1b048:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1b04c:	4f63      	ldr	r7, [pc, #396]	; (1b1dc <SFXVocoderChAlloc+0x3e4>)
                tSawtooth_initToPool(&osc[i], &smallPool);
   1b04e:	4e50      	ldr	r6, [pc, #320]	; (1b190 <SFXVocoderChAlloc+0x398>)
            tHighpass_initToPool(&chVocFinalHP2, 20.0f, &smallPool);
   1b050:	494f      	ldr	r1, [pc, #316]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b052:	4863      	ldr	r0, [pc, #396]	; (1b1e0 <SFXVocoderChAlloc+0x3e8>)
   1b054:	f00d f9e2 	bl	2841c <tHighpass_initToPool>
   1b058:	193d      	adds	r5, r7, r4
                tSawtooth_initToPool(&osc[i], &smallPool);
   1b05a:	eb08 0004 	add.w	r0, r8, r4
   1b05e:	4631      	mov	r1, r6
   1b060:	3404      	adds	r4, #4
   1b062:	f00f fa7f 	bl	2a564 <tSawtooth_initToPool>
                tRosenbergGlottalPulse_initToPool(&glottal[i], &smallPool);
   1b066:	4631      	mov	r1, r6
   1b068:	4628      	mov	r0, r5
   1b06a:	f00b f913 	bl	26294 <tRosenbergGlottalPulse_initToPool>
                tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
   1b06e:	eeb0 0a68 	vmov.f32	s0, s17
   1b072:	4628      	mov	r0, r5
   1b074:	f00b fa0c 	bl	26490 <tRosenbergGlottalPulse_setOpenLength>
                tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
   1b078:	eeb0 0a48 	vmov.f32	s0, s16
   1b07c:	4628      	mov	r0, r5
   1b07e:	f00b fa15 	bl	264ac <tRosenbergGlottalPulse_setPulseLength>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
   1b082:	2c20      	cmp	r4, #32
   1b084:	d1e8      	bne.n	1b058 <SFXVocoderChAlloc+0x260>
            setLED_A(numVoices == 1);
   1b086:	f899 0000 	ldrb.w	r0, [r9]
   1b08a:	f1a0 0001 	sub.w	r0, r0, #1
   1b08e:	fab0 f080 	clz	r0, r0
   1b092:	0940      	lsrs	r0, r0, #5
   1b094:	f7fe f9fc 	bl	19490 <setLED_A>
            setLED_B(internalExternal);
   1b098:	4b52      	ldr	r3, [pc, #328]	; (1b1e4 <SFXVocoderChAlloc+0x3ec>)
   1b09a:	7818      	ldrb	r0, [r3, #0]
   1b09c:	f7fe fa06 	bl	194ac <setLED_B>
            setLED_C(vocChFreeze);
   1b0a0:	4b51      	ldr	r3, [pc, #324]	; (1b1e8 <SFXVocoderChAlloc+0x3f0>)
   1b0a2:	7818      	ldrb	r0, [r3, #0]
        }
   1b0a4:	b003      	add	sp, #12
   1b0a6:	ecbd 8b04 	vpop	{d8-d9}
   1b0aa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            setLED_C(vocChFreeze);
   1b0ae:	f7fe ba0b 	b.w	194c8 <setLED_C>
                    tVZFilter_initToPool(&analysisBands[i][0], Highpass, bandFreq, thisBandwidth, &smallPool);
   1b0b2:	4a37      	ldr	r2, [pc, #220]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b0b4:	2100      	movs	r1, #0
   1b0b6:	484d      	ldr	r0, [pc, #308]	; (1b1ec <SFXVocoderChAlloc+0x3f4>)
   1b0b8:	f00d f9f4 	bl	284a4 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&analysisBands[i][1], Highpass, bandFreq, thisBandwidth, &smallPool);
   1b0bc:	edd6 0a00 	vldr	s1, [r6]
   1b0c0:	eeb0 0a48 	vmov.f32	s0, s16
   1b0c4:	4a32      	ldr	r2, [pc, #200]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b0c6:	2100      	movs	r1, #0
   1b0c8:	4849      	ldr	r0, [pc, #292]	; (1b1f0 <SFXVocoderChAlloc+0x3f8>)
   1b0ca:	f00d f9eb 	bl	284a4 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][0], Highpass, bandFreq, thisBandwidth, &smallPool);
   1b0ce:	edd6 0a00 	vldr	s1, [r6]
   1b0d2:	eeb0 0a48 	vmov.f32	s0, s16
   1b0d6:	4a2e      	ldr	r2, [pc, #184]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b0d8:	2100      	movs	r1, #0
   1b0da:	4846      	ldr	r0, [pc, #280]	; (1b1f4 <SFXVocoderChAlloc+0x3fc>)
   1b0dc:	f00d f9e2 	bl	284a4 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][1], Highpass, bandFreq, thisBandwidth, &smallPool);
   1b0e0:	eeb0 0a48 	vmov.f32	s0, s16
   1b0e4:	edd6 0a00 	vldr	s1, [r6]
   1b0e8:	2100      	movs	r1, #0
   1b0ea:	4a29      	ldr	r2, [pc, #164]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b0ec:	4842      	ldr	r0, [pc, #264]	; (1b1f8 <SFXVocoderChAlloc+0x400>)
   1b0ee:	f00d f9d9 	bl	284a4 <tVZFilter_initToPool>
                tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1b0f2:	4638      	mov	r0, r7
   1b0f4:	4926      	ldr	r1, [pc, #152]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b0f6:	eddf 0a29 	vldr	s1, [pc, #164]	; 1b19c <SFXVocoderChAlloc+0x3a4>
   1b0fa:	ed9f 0a29 	vldr	s0, [pc, #164]	; 1b1a0 <SFXVocoderChAlloc+0x3a8>
   1b0fe:	f00c fe43 	bl	27d88 <tExpSmooth_initToPool>
   1b102:	e76f      	b.n	1afe4 <SFXVocoderChAlloc+0x1ec>
                    tVZFilter_initToPool(&analysisBands[i][0], Lowpass, bandFreq, thisBandwidth, &smallPool);
   1b104:	edd6 0a00 	vldr	s1, [r6]
   1b108:	4658      	mov	r0, fp
   1b10a:	2101      	movs	r1, #1
   1b10c:	f00d f9ca 	bl	284a4 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&analysisBands[i][1], Lowpass, bandFreq, thisBandwidth, &smallPool);
   1b110:	edd6 0a00 	vldr	s1, [r6]
   1b114:	eeb0 0a48 	vmov.f32	s0, s16
   1b118:	4a1d      	ldr	r2, [pc, #116]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b11a:	2101      	movs	r1, #1
   1b11c:	4821      	ldr	r0, [pc, #132]	; (1b1a4 <SFXVocoderChAlloc+0x3ac>)
   1b11e:	f00d f9c1 	bl	284a4 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][0], Lowpass, bandFreq,thisBandwidth, &smallPool);
   1b122:	edd6 0a00 	vldr	s1, [r6]
   1b126:	eeb0 0a48 	vmov.f32	s0, s16
   1b12a:	4a19      	ldr	r2, [pc, #100]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b12c:	2101      	movs	r1, #1
   1b12e:	481e      	ldr	r0, [pc, #120]	; (1b1a8 <SFXVocoderChAlloc+0x3b0>)
   1b130:	f00d f9b8 	bl	284a4 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][1], Lowpass, bandFreq,thisBandwidth, &smallPool);
   1b134:	eeb0 0a48 	vmov.f32	s0, s16
   1b138:	edd6 0a00 	vldr	s1, [r6]
   1b13c:	2101      	movs	r1, #1
   1b13e:	4a14      	ldr	r2, [pc, #80]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b140:	481a      	ldr	r0, [pc, #104]	; (1b1ac <SFXVocoderChAlloc+0x3b4>)
   1b142:	f00d f9af 	bl	284a4 <tVZFilter_initToPool>
                tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1b146:	4912      	ldr	r1, [pc, #72]	; (1b190 <SFXVocoderChAlloc+0x398>)
   1b148:	eef0 0a49 	vmov.f32	s1, s18
   1b14c:	4638      	mov	r0, r7
   1b14e:	eeb0 0a68 	vmov.f32	s0, s17
   1b152:	f00c fe19 	bl	27d88 <tExpSmooth_initToPool>
   1b156:	e6f5      	b.n	1af44 <SFXVocoderChAlloc+0x14c>
   1b158:	000627ad 	.word	0x000627ad
   1b15c:	3f7d70a4 	.word	0x3f7d70a4
   1b160:	020e55d8 	.word	0x020e55d8
   1b164:	41873333 	.word	0x41873333
   1b168:	3f4ccccd 	.word	0x3f4ccccd
   1b16c:	becccccd 	.word	0xbecccccd
   1b170:	45bb8000 	.word	0x45bb8000
   1b174:	42c60000 	.word	0x42c60000
   1b178:	020fb05c 	.word	0x020fb05c
   1b17c:	3dcccccd 	.word	0x3dcccccd
   1b180:	42700000 	.word	0x42700000
   1b184:	3daaaaab 	.word	0x3daaaaab
   1b188:	020e5d30 	.word	0x020e5d30
   1b18c:	020e5108 	.word	0x020e5108
   1b190:	020fabc0 	.word	0x020fabc0
   1b194:	020f9eb8 	.word	0x020f9eb8
   1b198:	020f9ef4 	.word	0x020f9ef4
   1b19c:	3a83126f 	.word	0x3a83126f
   1b1a0:	00000000 	.word	0x00000000
   1b1a4:	020fab04 	.word	0x020fab04
   1b1a8:	020f9cf0 	.word	0x020f9cf0
   1b1ac:	020f9cf4 	.word	0x020f9cf4
   1b1b0:	020e50e0 	.word	0x020e50e0
   1b1b4:	020e5d2c 	.word	0x020e5d2c
   1b1b8:	020f9f58 	.word	0x020f9f58
   1b1bc:	020f9de8 	.word	0x020f9de8
   1b1c0:	3d4ccccd 	.word	0x3d4ccccd
   1b1c4:	020faaf0 	.word	0x020faaf0
   1b1c8:	459c4000 	.word	0x459c4000
   1b1cc:	020e5d24 	.word	0x020e5d24
   1b1d0:	020e5104 	.word	0x020e5104
   1b1d4:	3e99999a 	.word	0x3e99999a
   1b1d8:	3ecccccd 	.word	0x3ecccccd
   1b1dc:	020e5110 	.word	0x020e5110
   1b1e0:	020faaf4 	.word	0x020faaf4
   1b1e4:	020e2e64 	.word	0x020e2e64
   1b1e8:	020e2ed8 	.word	0x020e2ed8
   1b1ec:	020fabb8 	.word	0x020fabb8
   1b1f0:	020fabbc 	.word	0x020fabbc
   1b1f4:	020f9da8 	.word	0x020f9da8
   1b1f8:	020f9dac 	.word	0x020f9dac
   1b1fc:	000627a0 	.word	0x000627a0
   1b200:	020f9ddc 	.word	0x020f9ddc
   1b204:	020fab00 	.word	0x020fab00
   1b208:	020f9b40 	.word	0x020f9b40
   1b20c:	000627ac 	.word	0x000627ac
   1b210:	020f9ba4 	.word	0x020f9ba4

0001b214 <SFXVocoderChFrame>:
        {
   1b214:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1b218:	4c4c      	ldr	r4, [pc, #304]	; (1b34c <SFXVocoderChFrame+0x138>)
        {
   1b21a:	ed2d 8b08 	vpush	{d8-d11}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1b21e:	7d23      	ldrb	r3, [r4, #20]
        {
   1b220:	b087      	sub	sp, #28
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1b222:	2b01      	cmp	r3, #1
   1b224:	d113      	bne.n	1b24e <SFXVocoderChFrame+0x3a>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1b226:	4d4a      	ldr	r5, [pc, #296]	; (1b350 <SFXVocoderChFrame+0x13c>)
                tSimplePoly_setNumVoices(&poly, numVoices);
   1b228:	484a      	ldr	r0, [pc, #296]	; (1b354 <SFXVocoderChFrame+0x140>)
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1b22a:	782a      	ldrb	r2, [r5, #0]
   1b22c:	2a01      	cmp	r2, #1
   1b22e:	bf98      	it	ls
   1b230:	2308      	movls	r3, #8
                tSimplePoly_setNumVoices(&poly, numVoices);
   1b232:	4619      	mov	r1, r3
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1b234:	702b      	strb	r3, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
   1b236:	f00f f8d7 	bl	2a3e8 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
   1b23a:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1b23c:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
   1b23e:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1b242:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
   1b244:	fab0 f080 	clz	r0, r0
   1b248:	0940      	lsrs	r0, r0, #5
   1b24a:	f7fe f921 	bl	19490 <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1b24e:	7e23      	ldrb	r3, [r4, #24]
   1b250:	2b01      	cmp	r3, #1
   1b252:	f000 8295 	beq.w	1b780 <SFXVocoderChFrame+0x56c>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1b256:	7f23      	ldrb	r3, [r4, #28]
   1b258:	2b01      	cmp	r3, #1
   1b25a:	f000 82a0 	beq.w	1b79e <SFXVocoderChFrame+0x58a>
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1b25e:	4b3e      	ldr	r3, [pc, #248]	; (1b358 <SFXVocoderChFrame+0x144>)
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1b260:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b264:	eddf 6a3d 	vldr	s13, [pc, #244]	; 1b35c <SFXVocoderChFrame+0x148>
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1b268:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b26c:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1b270:	eeb8 6a00 	vmov.f32	s12, #128	; 0xc0000000 -2.0
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1b274:	ed93 5a1c 	vldr	s10, [r3, #112]	; 0x70
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1b278:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b27c:	ee27 7a26 	vmul.f32	s14, s14, s13
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1b280:	eddf 4a37 	vldr	s9, [pc, #220]	; 1b360 <SFXVocoderChFrame+0x14c>
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1b284:	ed93 2a1a 	vldr	s4, [r3, #104]	; 0x68
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b288:	eef2 2a00 	vmov.f32	s5, #32	; 0x41000000  8.0
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1b28c:	eee5 4a27 	vfma.f32	s9, s10, s15
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1b290:	ed9f 3a34 	vldr	s6, [pc, #208]	; 1b364 <SFXVocoderChFrame+0x150>
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b294:	eebc 7ac7 	vcvt.u32.f32	s14, s14
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1b298:	ed9f 4a33 	vldr	s8, [pc, #204]	; 1b368 <SFXVocoderChFrame+0x154>
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1b29c:	ed93 5a23 	vldr	s10, [r3, #140]	; 0x8c
            chVocOutputGain = 9.0f * displayValues[0];
   1b2a0:	eef2 6a02 	vmov.f32	s13, #34	; 0x41100000  9.0
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1b2a4:	eea2 4a03 	vfma.f32	s8, s4, s6
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1b2a8:	ed93 3a19 	vldr	s6, [r3, #100]	; 0x64
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b2ac:	ed8d 7a00 	vstr	s14, [sp]
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1b2b0:	ee35 5a23 	vadd.f32	s10, s10, s7
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b2b4:	f89d 2000 	ldrb.w	r2, [sp]
            chVocOutputGain = 9.0f * displayValues[0];
   1b2b8:	ee63 6a26 	vmul.f32	s13, s6, s13
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1b2bc:	ed93 7a25 	vldr	s14, [r3, #148]	; 0x94
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b2c0:	2500      	movs	r5, #0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b2c2:	ee07 2a90 	vmov	s15, r2
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1b2c6:	edd3 3a26 	vldr	s7, [r3, #152]	; 0x98
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1b2ca:	eea7 6a25 	vfma.f32	s12, s14, s11
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1b2ce:	ed9f 2a27 	vldr	s4, [pc, #156]	; 1b36c <SFXVocoderChFrame+0x158>
            oneMinusStereo = 1.0f - displayValues[13];
   1b2d2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1b2d6:	edd3 5a24 	vldr	s11, [r3, #144]	; 0x90
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b2da:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1b2de:	4c24      	ldr	r4, [pc, #144]	; (1b370 <SFXVocoderChFrame+0x15c>)
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1b2e0:	6f5e      	ldr	r6, [r3, #116]	; 0x74
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1b2e2:	ee65 5a82 	vmul.f32	s11, s11, s4
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1b2e6:	6f98      	ldr	r0, [r3, #120]	; 0x78
            oneMinusStereo = 1.0f - displayValues[13];
   1b2e8:	ee37 7a63 	vsub.f32	s14, s14, s7
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1b2ec:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b2ee:	ee77 7aa2 	vadd.f32	s15, s15, s5
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1b2f2:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b2f6:	46a9      	mov	r9, r5
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1b2f8:	6126      	str	r6, [r4, #16]
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1b2fa:	6160      	str	r0, [r4, #20]
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1b2fc:	f8d3 6084 	ldr.w	r6, [r3, #132]	; 0x84
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1b300:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1b304:	61a1      	str	r1, [r4, #24]
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1b306:	61e2      	str	r2, [r4, #28]
            displayValues[14] = presetKnobValues[VocoderCh][14]; //snap to bark scale
   1b308:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
            chVocOutputGain = 9.0f * displayValues[0];
   1b30c:	4a19      	ldr	r2, [pc, #100]	; (1b374 <SFXVocoderChFrame+0x160>)
            oneMinusStereo = 1.0f - displayValues[13];
   1b30e:	4b1a      	ldr	r3, [pc, #104]	; (1b378 <SFXVocoderChFrame+0x164>)
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1b310:	6226      	str	r6, [r4, #32]
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b312:	edc4 7a02 	vstr	s15, [r4, #8]
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1b316:	ed84 4a01 	vstr	s8, [r4, #4]
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1b31a:	edc4 4a03 	vstr	s9, [r4, #12]
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1b31e:	6260      	str	r0, [r4, #36]	; 0x24
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1b320:	ed84 5a0a 	vstr	s10, [r4, #40]	; 0x28
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1b324:	edc4 5a0b 	vstr	s11, [r4, #44]	; 0x2c
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1b328:	ed84 6a0c 	vstr	s12, [r4, #48]	; 0x30
            displayValues[14] = presetKnobValues[VocoderCh][14]; //snap to bark scale
   1b32c:	63a1      	str	r1, [r4, #56]	; 0x38
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1b32e:	ed84 3a00 	vstr	s6, [r4]
            chVocOutputGain = 9.0f * displayValues[0];
   1b332:	edc2 6a00 	vstr	s13, [r2]
   1b336:	4f11      	ldr	r7, [pc, #68]	; (1b37c <SFXVocoderChFrame+0x168>)
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1b338:	edc4 3a0d 	vstr	s7, [r4, #52]	; 0x34
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b33c:	4e05      	ldr	r6, [pc, #20]	; (1b354 <SFXVocoderChFrame+0x140>)
            oneMinusStereo = 1.0f - displayValues[13];
   1b33e:	ed83 7a00 	vstr	s14, [r3]
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1b342:	ed9f 8a0f 	vldr	s16, [pc, #60]	; 1b380 <SFXVocoderChFrame+0x16c>
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1b346:	f8df 803c 	ldr.w	r8, [pc, #60]	; 1b384 <SFXVocoderChFrame+0x170>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b34a:	e06d      	b.n	1b428 <SFXVocoderChFrame+0x214>
   1b34c:	020fafac 	.word	0x020fafac
   1b350:	000627ac 	.word	0x000627ac
   1b354:	020f9de8 	.word	0x020f9de8
   1b358:	020e55d8 	.word	0x020e55d8
   1b35c:	41873333 	.word	0x41873333
   1b360:	3dcccccd 	.word	0x3dcccccd
   1b364:	3f4ccccd 	.word	0x3f4ccccd
   1b368:	becccccd 	.word	0xbecccccd
   1b36c:	42700000 	.word	0x42700000
   1b370:	020fb05c 	.word	0x020fb05c
   1b374:	00062748 	.word	0x00062748
   1b378:	000627b0 	.word	0x000627b0
   1b37c:	020e5d04 	.word	0x020e5d04
   1b380:	00000000 	.word	0x00000000
   1b384:	2aaaaaab 	.word	0x2aaaaaab
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1b388:	f00f f85e 	bl	2a448 <tSimplePoly_getVelocity>
   1b38c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1b390:	2800      	cmp	r0, #0
   1b392:	4658      	mov	r0, fp
   1b394:	fe30 0a08 	vselgt.f32	s0, s0, s16
   1b398:	f00c fd32 	bl	27e00 <tExpSmooth_setDest>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1b39c:	4651      	mov	r1, sl
   1b39e:	4630      	mov	r0, r6
   1b3a0:	f00f f846 	bl	2a430 <tSimplePoly_getPitch>
   1b3a4:	ee07 0a90 	vmov	s15, r0
   1b3a8:	4ad0      	ldr	r2, [pc, #832]	; (1b6ec <SFXVocoderChFrame+0x4d8>)
   1b3aa:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1b3ae:	4bd0      	ldr	r3, [pc, #832]	; (1b6f0 <SFXVocoderChFrame+0x4dc>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1b3b0:	ed92 0a00 	vldr	s0, [r2]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1b3b4:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1b3b6:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1b3ba:	49ce      	ldr	r1, [pc, #824]	; (1b6f4 <SFXVocoderChFrame+0x4e0>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1b3bc:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1b3c0:	ee17 3a90 	vmov	r3, s15
   1b3c4:	1a9b      	subs	r3, r3, r2
   1b3c6:	fb88 2003 	smull	r2, r0, r8, r3
   1b3ca:	17da      	asrs	r2, r3, #31
   1b3cc:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1b3d0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1b3d4:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1b3d8:	ee07 3a90 	vmov	s15, r3
   1b3dc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1b3e0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1b3e4:	ee17 3a90 	vmov	r3, s15
   1b3e8:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1b3ec:	ed93 0a00 	vldr	s0, [r3]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1b3f0:	ee37 0a00 	vadd.f32	s0, s14, s0
   1b3f4:	f00e fa82 	bl	298fc <LEAF_midiToFrequency>
                tSawtooth_setFreq(&osc[i], freq[i]);
   1b3f8:	48bf      	ldr	r0, [pc, #764]	; (1b6f8 <SFXVocoderChFrame+0x4e4>)
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1b3fa:	ed87 0a00 	vstr	s0, [r7]
                tSawtooth_setFreq(&osc[i], freq[i]);
   1b3fe:	4428      	add	r0, r5
   1b400:	f00f f8d8 	bl	2a5b4 <tSawtooth_setFreq>
   1b404:	4bbd      	ldr	r3, [pc, #756]	; (1b6fc <SFXVocoderChFrame+0x4e8>)
                tRosenbergGlottalPulse_setFreq(&glottal[i], freq[i]);
   1b406:	ecb7 0a01 	vldmia	r7!, {s0}
   1b40a:	eb05 0a03 	add.w	sl, r5, r3
   1b40e:	3504      	adds	r5, #4
   1b410:	4650      	mov	r0, sl
   1b412:	f00b f82f 	bl	26474 <tRosenbergGlottalPulse_setFreq>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], displayValues[6] * displayValues[7], displayValues[6]);
   1b416:	edd4 0a06 	vldr	s1, [r4, #24]
   1b41a:	ed94 0a07 	vldr	s0, [r4, #28]
   1b41e:	4650      	mov	r0, sl
   1b420:	ee20 0a80 	vmul.f32	s0, s1, s0
   1b424:	f00b f850 	bl	264c8 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b428:	4630      	mov	r0, r6
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1b42a:	fa5f fa89 	uxtb.w	sl, r9
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b42e:	f00e ffe3 	bl	2a3f8 <tSimplePoly_getNumVoices>
   1b432:	4bb3      	ldr	r3, [pc, #716]	; (1b700 <SFXVocoderChFrame+0x4ec>)
   1b434:	4548      	cmp	r0, r9
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1b436:	4651      	mov	r1, sl
   1b438:	4630      	mov	r0, r6
   1b43a:	eb05 0b03 	add.w	fp, r5, r3
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b43e:	f109 0901 	add.w	r9, r9, #1
   1b442:	dca1      	bgt.n	1b388 <SFXVocoderChFrame+0x174>
            numberOfVocoderBands = displayValues[2];
   1b444:	ed94 7a02 	vldr	s14, [r4, #8]
            float warpFactor = 1.0f + displayValues[1];
   1b448:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b44c:	4ead      	ldr	r6, [pc, #692]	; (1b704 <SFXVocoderChFrame+0x4f0>)
            numberOfVocoderBands = displayValues[2];
   1b44e:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   1b452:	4dad      	ldr	r5, [pc, #692]	; (1b708 <SFXVocoderChFrame+0x4f4>)
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b454:	7833      	ldrb	r3, [r6, #0]
            float warpFactor = 1.0f + displayValues[1];
   1b456:	edd4 8a01 	vldr	s17, [r4, #4]
            numberOfVocoderBands = displayValues[2];
   1b45a:	ed8d 7a00 	vstr	s14, [sp]
   1b45e:	f89d 1000 	ldrb.w	r1, [sp]
            float warpFactor = 1.0f + displayValues[1];
   1b462:	ee78 8aa7 	vadd.f32	s17, s17, s15
            float myQ = displayValues[3];
   1b466:	ed94 8a03 	vldr	s16, [r4, #12]
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b46a:	428b      	cmp	r3, r1
            float bandSquish = displayValues[10];
   1b46c:	ed94 9a0a 	vldr	s18, [r4, #40]	; 0x28
            numberOfVocoderBands = displayValues[2];
   1b470:	7029      	strb	r1, [r5, #0]
            float bandOffset = displayValues[11];
   1b472:	ed94 aa0b 	vldr	s20, [r4, #44]	; 0x2c
            float myTilt = displayValues[12];
   1b476:	edd4 aa0c 	vldr	s21, [r4, #48]	; 0x30
            float barkPull = displayValues[14];
   1b47a:	edd4 9a0e 	vldr	s19, [r4, #56]	; 0x38
   1b47e:	f8df 82ec 	ldr.w	r8, [pc, #748]	; 1b76c <SFXVocoderChFrame+0x558>
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b482:	f000 8107 	beq.w	1b694 <SFXVocoderChFrame+0x480>
   1b486:	f8df a2e8 	ldr.w	sl, [pc, #744]	; 1b770 <SFXVocoderChFrame+0x55c>
   1b48a:	f8df b2e8 	ldr.w	fp, [pc, #744]	; 1b774 <SFXVocoderChFrame+0x560>
   1b48e:	4b9f      	ldr	r3, [pc, #636]	; (1b70c <SFXVocoderChFrame+0x4f8>)
   1b490:	9300      	str	r3, [sp, #0]
   1b492:	4b9f      	ldr	r3, [pc, #636]	; (1b710 <SFXVocoderChFrame+0x4fc>)
   1b494:	9301      	str	r3, [sp, #4]
   1b496:	4b9f      	ldr	r3, [pc, #636]	; (1b714 <SFXVocoderChFrame+0x500>)
   1b498:	9302      	str	r3, [sp, #8]
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b49a:	ee07 1a90 	vmov	s15, r1
   1b49e:	ed9f 6a9e 	vldr	s12, [pc, #632]	; 1b718 <SFXVocoderChFrame+0x504>
   1b4a2:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1b4a6:	ed9f 7a9d 	vldr	s14, [pc, #628]	; 1b71c <SFXVocoderChFrame+0x508>
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b4aa:	eef8 6a67 	vcvt.f32.u32	s13, s15
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1b4ae:	eddf 7a9c 	vldr	s15, [pc, #624]	; 1b720 <SFXVocoderChFrame+0x50c>
                alteringBands = 1;
   1b4b2:	499c      	ldr	r1, [pc, #624]	; (1b724 <SFXVocoderChFrame+0x510>)
   1b4b4:	f04f 0c01 	mov.w	ip, #1
                invMyQ = 1.0f / myQ;
   1b4b8:	ee85 5a88 	vdiv.f32	s10, s11, s16
   1b4bc:	4b9a      	ldr	r3, [pc, #616]	; (1b728 <SFXVocoderChFrame+0x514>)
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1b4be:	489b      	ldr	r0, [pc, #620]	; (1b72c <SFXVocoderChFrame+0x518>)
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b4c0:	4a9b      	ldr	r2, [pc, #620]	; (1b730 <SFXVocoderChFrame+0x51c>)
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1b4c2:	f8df e2b4 	ldr.w	lr, [pc, #692]	; 1b778 <SFXVocoderChFrame+0x564>
                thisBandwidth = bandWidthInOctaves * myQ;
   1b4c6:	4f9b      	ldr	r7, [pc, #620]	; (1b734 <SFXVocoderChFrame+0x520>)
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b4c8:	ee76 6ac6 	vsub.f32	s13, s13, s12
                alteringBands = 1;
   1b4cc:	9103      	str	r1, [sp, #12]
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1b4ce:	ee69 7a27 	vmul.f32	s15, s18, s15
                alteringBands = 1;
   1b4d2:	f8c1 c000 	str.w	ip, [r1]
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b4d6:	ee85 6aa6 	vdiv.f32	s12, s11, s13
                invMyQ = 1.0f / myQ;
   1b4da:	ed83 5a00 	vstr	s10, [r3]
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1b4de:	ee67 7a86 	vmul.f32	s15, s15, s12
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b4e2:	ed82 6a00 	vstr	s12, [r2]
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1b4e6:	ee27 7a87 	vmul.f32	s14, s15, s14
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1b4ea:	edc0 7a00 	vstr	s15, [r0]
                thisBandwidth = bandWidthInOctaves * myQ;
   1b4ee:	ee67 6a08 	vmul.f32	s13, s14, s16
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1b4f2:	ed8e 7a00 	vstr	s14, [lr]
                thisBandwidth = bandWidthInOctaves * myQ;
   1b4f6:	edc7 6a00 	vstr	s13, [r7]
                float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1b4fa:	f8df 9280 	ldr.w	r9, [pc, #640]	; 1b77c <SFXVocoderChFrame+0x568>
   1b4fe:	eeb0 0a4a 	vmov.f32	s0, s20
            float oneMinusBarkPull = 1.0f - barkPull;
   1b502:	eeb7 ba00 	vmov.f32	s22, #112	; 0x3f800000  1.0
                float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1b506:	ed99 7a00 	vldr	s14, [r9]
   1b50a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
            float oneMinusBarkPull = 1.0f - barkPull;
   1b50e:	ee7b ba69 	vsub.f32	s23, s22, s19
                float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1b512:	eea7 0a27 	vfma.f32	s0, s14, s15
   1b516:	e9cd 3204 	strd	r3, r2, [sp, #16]
   1b51a:	f00e fa73 	bl	29a04 <faster_mtof>
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b51e:	f8d9 c000 	ldr.w	ip, [r9]
                float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b522:	9a05      	ldr	r2, [sp, #20]
   1b524:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b528:	ea4f 018c 	mov.w	r1, ip, lsl #2
   1b52c:	4882      	ldr	r0, [pc, #520]	; (1b738 <SFXVocoderChFrame+0x524>)
                float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b52e:	edd2 6a00 	vldr	s13, [r2]
                float myHeight = currentBandToAlter * invNumberOfVocoderBands; //x value
   1b532:	ee06 ca10 	vmov	s12, ip
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b536:	4408      	add	r0, r1
                float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b538:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
                float myHeight = currentBandToAlter * invNumberOfVocoderBands; //x value
   1b53c:	eeb8 4ac6 	vcvt.f32.s32	s8, s12
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1b540:	4a7e      	ldr	r2, [pc, #504]	; (1b73c <SFXVocoderChFrame+0x528>)
                float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b542:	ee66 6aa7 	vmul.f32	s13, s13, s15
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b546:	edd0 7a00 	vldr	s15, [r0]
                float tiltOffset = (1.0f - ((myTilt * 0.5f) + 0.5f)) + 0.5f;
   1b54a:	ee7a 4a8b 	vadd.f32	s9, s21, s22
                bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b54e:	9b04      	ldr	r3, [sp, #16]
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b550:	ee69 7aa7 	vmul.f32	s15, s19, s15
                if (bandFreq > 5000.0f) // a way to keep the upper bands fixed so consonants are not stretched even though vowels are
   1b554:	eddf 5a7a 	vldr	s11, [pc, #488]	; 1b740 <SFXVocoderChFrame+0x52c>
                float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b558:	eea4 7a26 	vfma.f32	s14, s8, s13
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1b55c:	440a      	add	r2, r1
                float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b55e:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
                bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b562:	ed93 6a00 	vldr	s12, [r3]
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b566:	eeeb 7a80 	vfma.f32	s15, s23, s0
                bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b56a:	4b76      	ldr	r3, [pc, #472]	; (1b744 <SFXVocoderChFrame+0x530>)
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1b56c:	ee68 6a29 	vmul.f32	s13, s16, s19
   1b570:	edd2 0a00 	vldr	s1, [r2]
                bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b574:	4419      	add	r1, r3
                if (analysisOrSynthesis == 0)
   1b576:	4b74      	ldr	r3, [pc, #464]	; (1b748 <SFXVocoderChFrame+0x534>)
   1b578:	ea4f 00cc 	mov.w	r0, ip, lsl #3
                float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b57c:	eea4 7ac5 	vfms.f32	s14, s9, s10
                if (analysisOrSynthesis == 0)
   1b580:	681b      	ldr	r3, [r3, #0]
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1b582:	ee66 0aa0 	vmul.f32	s1, s13, s1
   1b586:	edd7 6a00 	vldr	s13, [r7]
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b58a:	eeb0 0a67 	vmov.f32	s0, s15
   1b58e:	eddf 7a6f 	vldr	s15, [pc, #444]	; 1b74c <SFXVocoderChFrame+0x538>
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1b592:	eee6 0aab 	vfma.f32	s1, s13, s23
                float tempWarpFactor = warpFactor;
   1b596:	eeb4 0ae5 	vcmpe.f32	s0, s11
   1b59a:	fe80 0a67 	vminnm.f32	s0, s0, s15
                bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b59e:	ee27 7a06 	vmul.f32	s14, s14, s12
                float tempWarpFactor = warpFactor;
   1b5a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b5a6:	ed81 7a00 	vstr	s14, [r1]
                float tempWarpFactor = warpFactor;
   1b5aa:	bf98      	it	ls
   1b5ac:	eeb0 ba68 	vmovls.f32	s22, s17
                if (analysisOrSynthesis == 0)
   1b5b0:	2b00      	cmp	r3, #0
   1b5b2:	f040 8100 	bne.w	1b7b6 <SFXVocoderChFrame+0x5a2>
                    tVZFilter_setFreqAndBandwidth(&analysisBands[currentBandToAlter][0], bandFreq, bandBandwidth);
   1b5b6:	4f66      	ldr	r7, [pc, #408]	; (1b750 <SFXVocoderChFrame+0x53c>)
   1b5b8:	4438      	add	r0, r7
   1b5ba:	f00d fbc1 	bl	28d40 <tVZFilter_setFreqAndBandwidth>
                    analysisBands[currentBandToAlter][1]->B = analysisBands[currentBandToAlter][0]->B;
   1b5be:	f8d9 3000 	ldr.w	r3, [r9]
   1b5c2:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b5c6:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
   1b5ca:	6b40      	ldr	r0, [r0, #52]	; 0x34
   1b5cc:	6851      	ldr	r1, [r2, #4]
   1b5ce:	6348      	str	r0, [r1, #52]	; 0x34
                    analysisBands[currentBandToAlter][1]->fc = analysisBands[currentBandToAlter][0]->fc;
   1b5d0:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b5d4:	6851      	ldr	r1, [r2, #4]
   1b5d6:	6a80      	ldr	r0, [r0, #40]	; 0x28
   1b5d8:	6288      	str	r0, [r1, #40]	; 0x28
                    analysisBands[currentBandToAlter][1]->R2 = analysisBands[currentBandToAlter][0]->R2;
   1b5da:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b5de:	6851      	ldr	r1, [r2, #4]
   1b5e0:	6940      	ldr	r0, [r0, #20]
   1b5e2:	6148      	str	r0, [r1, #20]
                    analysisBands[currentBandToAlter][1]->cL = analysisBands[currentBandToAlter][0]->cL;
   1b5e4:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b5e8:	6851      	ldr	r1, [r2, #4]
   1b5ea:	69c0      	ldr	r0, [r0, #28]
   1b5ec:	61c8      	str	r0, [r1, #28]
                    analysisBands[currentBandToAlter][1]->cB = analysisBands[currentBandToAlter][0]->cB;
   1b5ee:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b5f2:	6851      	ldr	r1, [r2, #4]
   1b5f4:	6a00      	ldr	r0, [r0, #32]
   1b5f6:	6208      	str	r0, [r1, #32]
                    analysisBands[currentBandToAlter][1]->cH = analysisBands[currentBandToAlter][0]->cH;
   1b5f8:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b5fc:	6851      	ldr	r1, [r2, #4]
   1b5fe:	6a40      	ldr	r0, [r0, #36]	; 0x24
   1b600:	6248      	str	r0, [r1, #36]	; 0x24
                    analysisBands[currentBandToAlter][1]->h = analysisBands[currentBandToAlter][0]->h;
   1b602:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b606:	6851      	ldr	r1, [r2, #4]
   1b608:	6980      	ldr	r0, [r0, #24]
   1b60a:	6188      	str	r0, [r1, #24]
                    analysisBands[currentBandToAlter][1]->g = analysisBands[currentBandToAlter][0]->g;
   1b60c:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
   1b610:	6852      	ldr	r2, [r2, #4]
   1b612:	6909      	ldr	r1, [r1, #16]
                    analysisOrSynthesis++;
   1b614:	484c      	ldr	r0, [pc, #304]	; (1b748 <SFXVocoderChFrame+0x534>)
                    analysisBands[currentBandToAlter][1]->g = analysisBands[currentBandToAlter][0]->g;
   1b616:	6111      	str	r1, [r2, #16]
                    analysisOrSynthesis++;
   1b618:	6802      	ldr	r2, [r0, #0]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b61a:	7829      	ldrb	r1, [r5, #0]
                    analysisOrSynthesis++;
   1b61c:	3201      	adds	r2, #1
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b61e:	428b      	cmp	r3, r1
                    analysisOrSynthesis++;
   1b620:	6002      	str	r2, [r0, #0]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b622:	db02      	blt.n	1b62a <SFXVocoderChFrame+0x416>
   1b624:	2a00      	cmp	r2, #0
   1b626:	f000 8105 	beq.w	1b834 <SFXVocoderChFrame+0x620>
            prevBandOffset = bandOffset;
   1b62a:	9b00      	ldr	r3, [sp, #0]
            prevNumberOfVocoderBands = numberOfVocoderBands;
   1b62c:	7031      	strb	r1, [r6, #0]
            prevBandOffset = bandOffset;
   1b62e:	ed83 aa00 	vstr	s20, [r3]
            prevMyTilt = myTilt;
   1b632:	9b01      	ldr	r3, [sp, #4]
            prevMyQ = myQ;
   1b634:	ed88 8a00 	vstr	s16, [r8]
            prevMyTilt = myTilt;
   1b638:	edc3 aa00 	vstr	s21, [r3]
            prevBarkPull = barkPull;
   1b63c:	9b02      	ldr	r3, [sp, #8]
            prevWarpFactor = warpFactor;
   1b63e:	edca 8a00 	vstr	s17, [sl]
            prevBandSquish = bandSquish;
   1b642:	ed8b 9a00 	vstr	s18, [fp]
            prevBarkPull = barkPull;
   1b646:	edc3 9a00 	vstr	s19, [r3]
            for (int i = 0; i < numberOfVocoderBands; i++)
   1b64a:	b199      	cbz	r1, 1b674 <SFXVocoderChFrame+0x460>
   1b64c:	4f41      	ldr	r7, [pc, #260]	; (1b754 <SFXVocoderChFrame+0x540>)
   1b64e:	2600      	movs	r6, #0
                tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
   1b650:	eddf 8a41 	vldr	s17, [pc, #260]	; 1b758 <SFXVocoderChFrame+0x544>
   1b654:	ed9f 8a41 	vldr	s16, [pc, #260]	; 1b75c <SFXVocoderChFrame+0x548>
   1b658:	eeb0 0a48 	vmov.f32	s0, s16
   1b65c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   1b660:	4638      	mov	r0, r7
            for (int i = 0; i < numberOfVocoderBands; i++)
   1b662:	3601      	adds	r6, #1
   1b664:	3704      	adds	r7, #4
                tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
   1b666:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1b66a:	f00c fbb7 	bl	27ddc <tExpSmooth_setFactor>
            for (int i = 0; i < numberOfVocoderBands; i++)
   1b66e:	782b      	ldrb	r3, [r5, #0]
   1b670:	42b3      	cmp	r3, r6
   1b672:	dcf1      	bgt.n	1b658 <SFXVocoderChFrame+0x444>
            if (tSimplePoly_getNumActiveVoices(&poly) != 0)
   1b674:	483a      	ldr	r0, [pc, #232]	; (1b760 <SFXVocoderChFrame+0x54c>)
   1b676:	f00e fec3 	bl	2a400 <tSimplePoly_getNumActiveVoices>
   1b67a:	2800      	cmp	r0, #0
   1b67c:	f040 80e0 	bne.w	1b840 <SFXVocoderChFrame+0x62c>
                tExpSmooth_setDest(&comp, 0.0f);
   1b680:	ed9f 0a38 	vldr	s0, [pc, #224]	; 1b764 <SFXVocoderChFrame+0x550>
   1b684:	4838      	ldr	r0, [pc, #224]	; (1b768 <SFXVocoderChFrame+0x554>)
        }
   1b686:	b007      	add	sp, #28
   1b688:	ecbd 8b08 	vpop	{d8-d11}
   1b68c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                tExpSmooth_setDest(&comp, 0.0f);
   1b690:	f00c bbb6 	b.w	27e00 <tExpSmooth_setDest>
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b694:	edd8 7a00 	vldr	s15, [r8]
   1b698:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 1b770 <SFXVocoderChFrame+0x55c>
   1b69c:	eef4 7a48 	vcmp.f32	s15, s16
   1b6a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b6a4:	f47f aef1 	bne.w	1b48a <SFXVocoderChFrame+0x276>
   1b6a8:	edda 7a00 	vldr	s15, [sl]
   1b6ac:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 1b774 <SFXVocoderChFrame+0x560>
   1b6b0:	eef4 7a68 	vcmp.f32	s15, s17
   1b6b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b6b8:	f47f aee9 	bne.w	1b48e <SFXVocoderChFrame+0x27a>
   1b6bc:	eddb 7a00 	vldr	s15, [fp]
   1b6c0:	4b12      	ldr	r3, [pc, #72]	; (1b70c <SFXVocoderChFrame+0x4f8>)
   1b6c2:	eef4 7a49 	vcmp.f32	s15, s18
   1b6c6:	9300      	str	r3, [sp, #0]
   1b6c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b6cc:	f040 80cd 	bne.w	1b86a <SFXVocoderChFrame+0x656>
   1b6d0:	edd3 7a00 	vldr	s15, [r3]
   1b6d4:	4b0e      	ldr	r3, [pc, #56]	; (1b710 <SFXVocoderChFrame+0x4fc>)
   1b6d6:	eef4 7a4a 	vcmp.f32	s15, s20
   1b6da:	9301      	str	r3, [sp, #4]
   1b6dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b6e0:	f000 80c8 	beq.w	1b874 <SFXVocoderChFrame+0x660>
   1b6e4:	4b0b      	ldr	r3, [pc, #44]	; (1b714 <SFXVocoderChFrame+0x500>)
   1b6e6:	9302      	str	r3, [sp, #8]
   1b6e8:	e6d7      	b.n	1b49a <SFXVocoderChFrame+0x286>
   1b6ea:	bf00      	nop
   1b6ec:	020e2ea0 	.word	0x020e2ea0
   1b6f0:	020e2f18 	.word	0x020e2f18
   1b6f4:	020e2ee4 	.word	0x020e2ee4
   1b6f8:	020f9ba4 	.word	0x020f9ba4
   1b6fc:	020e5110 	.word	0x020e5110
   1b700:	020fa1e4 	.word	0x020fa1e4
   1b704:	000627c4 	.word	0x000627c4
   1b708:	000627ad 	.word	0x000627ad
   1b70c:	000627b8 	.word	0x000627b8
   1b710:	020e2eac 	.word	0x020e2eac
   1b714:	020e2ea8 	.word	0x020e2ea8
   1b718:	3f7d70a4 	.word	0x3f7d70a4
   1b71c:	3daaaaab 	.word	0x3daaaaab
   1b720:	42bc0000 	.word	0x42bc0000
   1b724:	020e2ddc 	.word	0x020e2ddc
   1b728:	0006279c 	.word	0x0006279c
   1b72c:	020f9ddc 	.word	0x020f9ddc
   1b730:	000627a0 	.word	0x000627a0
   1b734:	020e5108 	.word	0x020e5108
   1b738:	00062688 	.word	0x00062688
   1b73c:	000626e8 	.word	0x000626e8
   1b740:	459c4000 	.word	0x459c4000
   1b744:	020f9b40 	.word	0x020f9b40
   1b748:	020e2de0 	.word	0x020e2de0
   1b74c:	467a0000 	.word	0x467a0000
   1b750:	020fab00 	.word	0x020fab00
   1b754:	020f9ef4 	.word	0x020f9ef4
   1b758:	3ac49ba6 	.word	0x3ac49ba6
   1b75c:	38d1b717 	.word	0x38d1b717
   1b760:	020f9de8 	.word	0x020f9de8
   1b764:	00000000 	.word	0x00000000
   1b768:	020f9b24 	.word	0x020f9b24
   1b76c:	000627c0 	.word	0x000627c0
   1b770:	000627cc 	.word	0x000627cc
   1b774:	000627bc 	.word	0x000627bc
   1b778:	020e5d30 	.word	0x020e5d30
   1b77c:	020e2e34 	.word	0x020e2e34
                internalExternal = !internalExternal;
   1b780:	4a4c      	ldr	r2, [pc, #304]	; (1b8b4 <SFXVocoderChFrame+0x6a0>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1b782:	2100      	movs	r1, #0
                internalExternal = !internalExternal;
   1b784:	7813      	ldrb	r3, [r2, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1b786:	7621      	strb	r1, [r4, #24]
                internalExternal = !internalExternal;
   1b788:	fab3 f383 	clz	r3, r3
   1b78c:	095b      	lsrs	r3, r3, #5
                setLED_B(internalExternal);
   1b78e:	4618      	mov	r0, r3
                internalExternal = !internalExternal;
   1b790:	7013      	strb	r3, [r2, #0]
                setLED_B(internalExternal);
   1b792:	f7fd fe8b 	bl	194ac <setLED_B>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1b796:	7f23      	ldrb	r3, [r4, #28]
   1b798:	2b01      	cmp	r3, #1
   1b79a:	f47f ad60 	bne.w	1b25e <SFXVocoderChFrame+0x4a>
                vocChFreeze = !vocChFreeze;
   1b79e:	4a46      	ldr	r2, [pc, #280]	; (1b8b8 <SFXVocoderChFrame+0x6a4>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1b7a0:	2100      	movs	r1, #0
                vocChFreeze = !vocChFreeze;
   1b7a2:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1b7a4:	7721      	strb	r1, [r4, #28]
                vocChFreeze = !vocChFreeze;
   1b7a6:	fab3 f383 	clz	r3, r3
   1b7aa:	095b      	lsrs	r3, r3, #5
                setLED_C(vocChFreeze);
   1b7ac:	4618      	mov	r0, r3
                vocChFreeze = !vocChFreeze;
   1b7ae:	6013      	str	r3, [r2, #0]
                setLED_C(vocChFreeze);
   1b7b0:	f7fd fe8a 	bl	194c8 <setLED_C>
   1b7b4:	e553      	b.n	1b25e <SFXVocoderChFrame+0x4a>
                    tVZFilter_setFreqAndBandwidth(&synthesisBands[currentBandToAlter][0], bandFreq * tempWarpFactor, bandBandwidth);
   1b7b6:	4f41      	ldr	r7, [pc, #260]	; (1b8bc <SFXVocoderChFrame+0x6a8>)
   1b7b8:	ee2b 0a00 	vmul.f32	s0, s22, s0
   1b7bc:	4438      	add	r0, r7
   1b7be:	f00d fabf 	bl	28d40 <tVZFilter_setFreqAndBandwidth>
                    synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
   1b7c2:	f8d9 3000 	ldr.w	r3, [r9]
                    analysisOrSynthesis = 0;
   1b7c6:	f04f 0e00 	mov.w	lr, #0
                    synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
   1b7ca:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b7ce:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
                    currentBandToAlter++;
   1b7d2:	f103 0c01 	add.w	ip, r3, #1
                    synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
   1b7d6:	6851      	ldr	r1, [r2, #4]
   1b7d8:	6b40      	ldr	r0, [r0, #52]	; 0x34
   1b7da:	6348      	str	r0, [r1, #52]	; 0x34
                    synthesisBands[currentBandToAlter][1]->fc = synthesisBands[currentBandToAlter][0]->fc;
   1b7dc:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b7e0:	6851      	ldr	r1, [r2, #4]
   1b7e2:	6a80      	ldr	r0, [r0, #40]	; 0x28
   1b7e4:	6288      	str	r0, [r1, #40]	; 0x28
                    synthesisBands[currentBandToAlter][1]->R2 = synthesisBands[currentBandToAlter][0]->R2;
   1b7e6:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b7ea:	6851      	ldr	r1, [r2, #4]
   1b7ec:	6940      	ldr	r0, [r0, #20]
   1b7ee:	6148      	str	r0, [r1, #20]
                    synthesisBands[currentBandToAlter][1]->cL = synthesisBands[currentBandToAlter][0]->cL;
   1b7f0:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b7f4:	6851      	ldr	r1, [r2, #4]
   1b7f6:	69c0      	ldr	r0, [r0, #28]
   1b7f8:	61c8      	str	r0, [r1, #28]
                    synthesisBands[currentBandToAlter][1]->cB = synthesisBands[currentBandToAlter][0]->cB;
   1b7fa:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b7fe:	6851      	ldr	r1, [r2, #4]
   1b800:	6a00      	ldr	r0, [r0, #32]
   1b802:	6208      	str	r0, [r1, #32]
                    synthesisBands[currentBandToAlter][1]->cH = synthesisBands[currentBandToAlter][0]->cH;
   1b804:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b808:	6851      	ldr	r1, [r2, #4]
   1b80a:	6a40      	ldr	r0, [r0, #36]	; 0x24
   1b80c:	6248      	str	r0, [r1, #36]	; 0x24
                    synthesisBands[currentBandToAlter][1]->h = synthesisBands[currentBandToAlter][0]->h;
   1b80e:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b812:	6851      	ldr	r1, [r2, #4]
   1b814:	6980      	ldr	r0, [r0, #24]
   1b816:	6188      	str	r0, [r1, #24]
                    synthesisBands[currentBandToAlter][1]->g = synthesisBands[currentBandToAlter][0]->g;
   1b818:	f857 3033 	ldr.w	r3, [r7, r3, lsl #3]
   1b81c:	6852      	ldr	r2, [r2, #4]
   1b81e:	691b      	ldr	r3, [r3, #16]
   1b820:	6113      	str	r3, [r2, #16]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b822:	7829      	ldrb	r1, [r5, #0]
                    analysisOrSynthesis = 0;
   1b824:	4b26      	ldr	r3, [pc, #152]	; (1b8c0 <SFXVocoderChFrame+0x6ac>)
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b826:	458c      	cmp	ip, r1
                    currentBandToAlter++;
   1b828:	f8c9 c000 	str.w	ip, [r9]
                    analysisOrSynthesis = 0;
   1b82c:	f8c3 e000 	str.w	lr, [r3]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b830:	f6ff aefb 	blt.w	1b62a <SFXVocoderChFrame+0x416>
                    alteringBands = 0;
   1b834:	2300      	movs	r3, #0
   1b836:	9a03      	ldr	r2, [sp, #12]
                    currentBandToAlter = 0;
   1b838:	f8c9 3000 	str.w	r3, [r9]
                    alteringBands = 0;
   1b83c:	6013      	str	r3, [r2, #0]
   1b83e:	e6f4      	b.n	1b62a <SFXVocoderChFrame+0x416>
                tExpSmooth_setDest(&comp, sqrtf(1.0f / tSimplePoly_getNumActiveVoices(&poly)));
   1b840:	4820      	ldr	r0, [pc, #128]	; (1b8c4 <SFXVocoderChFrame+0x6b0>)
   1b842:	f00e fddd 	bl	2a400 <tSimplePoly_getNumActiveVoices>
   1b846:	ee07 0a90 	vmov	s15, r0
   1b84a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1b84e:	481e      	ldr	r0, [pc, #120]	; (1b8c8 <SFXVocoderChFrame+0x6b4>)
   1b850:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1b854:	ee87 0a27 	vdiv.f32	s0, s14, s15
   1b858:	eeb1 0ac0 	vsqrt.f32	s0, s0
        }
   1b85c:	b007      	add	sp, #28
   1b85e:	ecbd 8b08 	vpop	{d8-d11}
   1b862:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                tExpSmooth_setDest(&comp, 0.0f);
   1b866:	f00c bacb 	b.w	27e00 <tExpSmooth_setDest>
   1b86a:	4b18      	ldr	r3, [pc, #96]	; (1b8cc <SFXVocoderChFrame+0x6b8>)
   1b86c:	9301      	str	r3, [sp, #4]
   1b86e:	4b18      	ldr	r3, [pc, #96]	; (1b8d0 <SFXVocoderChFrame+0x6bc>)
   1b870:	9302      	str	r3, [sp, #8]
   1b872:	e612      	b.n	1b49a <SFXVocoderChFrame+0x286>
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b874:	edd3 7a00 	vldr	s15, [r3]
   1b878:	4b15      	ldr	r3, [pc, #84]	; (1b8d0 <SFXVocoderChFrame+0x6bc>)
   1b87a:	eef4 7a6a 	vcmp.f32	s15, s21
   1b87e:	9302      	str	r3, [sp, #8]
   1b880:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b884:	f47f ae09 	bne.w	1b49a <SFXVocoderChFrame+0x286>
   1b888:	edd3 7a00 	vldr	s15, [r3]
   1b88c:	eef4 7a69 	vcmp.f32	s15, s19
   1b890:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b894:	f47f ae01 	bne.w	1b49a <SFXVocoderChFrame+0x286>
            if (alteringBands)
   1b898:	4b0e      	ldr	r3, [pc, #56]	; (1b8d4 <SFXVocoderChFrame+0x6c0>)
   1b89a:	9303      	str	r3, [sp, #12]
   1b89c:	681b      	ldr	r3, [r3, #0]
   1b89e:	2b00      	cmp	r3, #0
   1b8a0:	f43f aec3 	beq.w	1b62a <SFXVocoderChFrame+0x416>
   1b8a4:	4b0c      	ldr	r3, [pc, #48]	; (1b8d8 <SFXVocoderChFrame+0x6c4>)
   1b8a6:	4a0d      	ldr	r2, [pc, #52]	; (1b8dc <SFXVocoderChFrame+0x6c8>)
   1b8a8:	edd3 7a00 	vldr	s15, [r3]
   1b8ac:	4f0c      	ldr	r7, [pc, #48]	; (1b8e0 <SFXVocoderChFrame+0x6cc>)
   1b8ae:	4b0d      	ldr	r3, [pc, #52]	; (1b8e4 <SFXVocoderChFrame+0x6d0>)
   1b8b0:	e623      	b.n	1b4fa <SFXVocoderChFrame+0x2e6>
   1b8b2:	bf00      	nop
   1b8b4:	020e2e64 	.word	0x020e2e64
   1b8b8:	020e2ed8 	.word	0x020e2ed8
   1b8bc:	020f9cf0 	.word	0x020f9cf0
   1b8c0:	020e2de0 	.word	0x020e2de0
   1b8c4:	020f9de8 	.word	0x020f9de8
   1b8c8:	020f9b24 	.word	0x020f9b24
   1b8cc:	020e2eac 	.word	0x020e2eac
   1b8d0:	020e2ea8 	.word	0x020e2ea8
   1b8d4:	020e2ddc 	.word	0x020e2ddc
   1b8d8:	020f9ddc 	.word	0x020f9ddc
   1b8dc:	000627a0 	.word	0x000627a0
   1b8e0:	020e5108 	.word	0x020e5108
   1b8e4:	0006279c 	.word	0x0006279c

0001b8e8 <SFXVocoderChTick>:
        {
   1b8e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b8ec:	4605      	mov	r5, r0
            input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
   1b8ee:	489c      	ldr	r0, [pc, #624]	; (1bb60 <SFXVocoderChTick+0x278>)
        {
   1b8f0:	ed2d 8b06 	vpush	{d8-d10}
   1b8f4:	b083      	sub	sp, #12
            input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
   1b8f6:	ed95 0a01 	vldr	s0, [r5, #4]
   1b8fa:	f00c ffd3 	bl	288a4 <tVZFilter_tick>
            if (internalExternal == 1)
   1b8fe:	4b99      	ldr	r3, [pc, #612]	; (1bb64 <SFXVocoderChTick+0x27c>)
            input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
   1b900:	ed85 0a01 	vstr	s0, [r5, #4]
            if (internalExternal == 1)
   1b904:	781b      	ldrb	r3, [r3, #0]
   1b906:	2b01      	cmp	r3, #1
   1b908:	f040 80a8 	bne.w	1ba5c <SFXVocoderChTick+0x174>
                sample = input[0];
   1b90c:	ed95 0a00 	vldr	s0, [r5]
   1b910:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 1bbcc <SFXVocoderChTick+0x2e4>
            sample = LEAF_tanh(sample);
   1b914:	f00d ff58 	bl	297c8 <LEAF_tanh>
            input[1] = input[1] * (displayValues[0] * 30.0f);
   1b918:	eeb3 7a0e 	vmov.f32	s14, #62	; 0x41f00000  30.0
            sample = LEAF_tanh(sample);
   1b91c:	eeb0 9a40 	vmov.f32	s18, s0
            input[1] = input[1] * (displayValues[0] * 30.0f);
   1b920:	ed98 0a00 	vldr	s0, [r8]
   1b924:	edd5 7a01 	vldr	s15, [r5, #4]
   1b928:	ee20 0a07 	vmul.f32	s0, s0, s14
            for (int i = 0; i < numberOfVocoderBands; i++)
   1b92c:	4f8e      	ldr	r7, [pc, #568]	; (1bb68 <SFXVocoderChTick+0x280>)
            float output[2] = {0.0f, 0.0f};
   1b92e:	ed9f 8a8f 	vldr	s16, [pc, #572]	; 1bb6c <SFXVocoderChTick+0x284>
            for (int i = 0; i < numberOfVocoderBands; i++)
   1b932:	783b      	ldrb	r3, [r7, #0]
            input[1] = input[1] * (displayValues[0] * 30.0f);
   1b934:	ee20 0a27 	vmul.f32	s0, s0, s15
            float output[2] = {0.0f, 0.0f};
   1b938:	ed8d 8a00 	vstr	s16, [sp]
   1b93c:	ed8d 8a01 	vstr	s16, [sp, #4]
            input[1] = input[1] * (displayValues[0] * 30.0f);
   1b940:	ed85 0a01 	vstr	s0, [r5, #4]
            for (int i = 0; i < numberOfVocoderBands; i++)
   1b944:	2b00      	cmp	r3, #0
   1b946:	f000 8108 	beq.w	1bb5a <SFXVocoderChTick+0x272>
   1b94a:	f04f 0b00 	mov.w	fp, #0
                tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
   1b94e:	eef0 9a48 	vmov.f32	s19, s16
   1b952:	4e87      	ldr	r6, [pc, #540]	; (1bb70 <SFXVocoderChTick+0x288>)
   1b954:	46da      	mov	sl, fp
   1b956:	f8df 8278 	ldr.w	r8, [pc, #632]	; 1bbd0 <SFXVocoderChTick+0x2e8>
   1b95a:	e02f      	b.n	1b9bc <SFXVocoderChTick+0xd4>
                tempSamp = tExpSmooth_tick(&envFollowers[i]);
   1b95c:	4648      	mov	r0, r9
            for (int i = 0; i < numberOfVocoderBands; i++)
   1b95e:	f10b 0b01 	add.w	fp, fp, #1
                tempSamp = tExpSmooth_tick(&envFollowers[i]);
   1b962:	f00c fa57 	bl	27e14 <tExpSmooth_tick>
                tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
   1b966:	eeb0 1a00 	vmov.f32	s2, #0	; 0x40000000  2.0
   1b96a:	eef0 0a40 	vmov.f32	s1, s0
   1b96e:	eeb0 0a69 	vmov.f32	s0, s19
   1b972:	f00d fed9 	bl	29728 <LEAF_clip>
                tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][0], tempSynth);
   1b976:	4b7f      	ldr	r3, [pc, #508]	; (1bb74 <SFXVocoderChTick+0x28c>)
                tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
   1b978:	eef0 8a40 	vmov.f32	s17, s0
                tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][0], tempSynth);
   1b97c:	1918      	adds	r0, r3, r4
   1b97e:	eeb0 0a49 	vmov.f32	s0, s18
   1b982:	f00c ffcd 	bl	28920 <tVZFilter_tickEfficient>
                tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][1], tempSynth);
   1b986:	4b7c      	ldr	r3, [pc, #496]	; (1bb78 <SFXVocoderChTick+0x290>)
   1b988:	1918      	adds	r0, r3, r4
   1b98a:	f00c ffc9 	bl	28920 <tVZFilter_tickEfficient>
                output[oddEven] += tempSynth * tempSamp * bandGains[i];
   1b98e:	ee28 0a80 	vmul.f32	s0, s17, s0
   1b992:	ecf6 7a01 	vldmia	r6!, {s15}
   1b996:	ab02      	add	r3, sp, #8
   1b998:	a902      	add	r1, sp, #8
   1b99a:	eea0 8a27 	vfma.f32	s16, s0, s15
   1b99e:	eb03 028a 	add.w	r2, r3, sl, lsl #2
            for (int i = 0; i < numberOfVocoderBands; i++)
   1b9a2:	783b      	ldrb	r3, [r7, #0]
   1b9a4:	f00b 0a01 	and.w	sl, fp, #1
   1b9a8:	455b      	cmp	r3, fp
   1b9aa:	eb01 018a 	add.w	r1, r1, sl, lsl #2
                output[oddEven] += tempSynth * tempSamp * bandGains[i];
   1b9ae:	ed02 8a02 	vstr	s16, [r2, #-8]
            for (int i = 0; i < numberOfVocoderBands; i++)
   1b9b2:	dd1a      	ble.n	1b9ea <SFXVocoderChTick+0x102>
   1b9b4:	ed11 8a02 	vldr	s16, [r1, #-8]
   1b9b8:	ed95 0a01 	vldr	s0, [r5, #4]
   1b9bc:	4a6f      	ldr	r2, [pc, #444]	; (1bb7c <SFXVocoderChTick+0x294>)
   1b9be:	ea4f 04cb 	mov.w	r4, fp, lsl #3
                if (!vocChFreeze)
   1b9c2:	f8d8 3000 	ldr.w	r3, [r8]
   1b9c6:	eb02 098b 	add.w	r9, r2, fp, lsl #2
   1b9ca:	2b00      	cmp	r3, #0
   1b9cc:	d1c6      	bne.n	1b95c <SFXVocoderChTick+0x74>
                    tempSamp = tVZFilter_tickEfficient(&analysisBands[i][0], tempSamp);
   1b9ce:	4b6c      	ldr	r3, [pc, #432]	; (1bb80 <SFXVocoderChTick+0x298>)
   1b9d0:	1918      	adds	r0, r3, r4
   1b9d2:	f00c ffa5 	bl	28920 <tVZFilter_tickEfficient>
                    tempSamp = tVZFilter_tickEfficient(&analysisBands[i][1], tempSamp);
   1b9d6:	4b6b      	ldr	r3, [pc, #428]	; (1bb84 <SFXVocoderChTick+0x29c>)
   1b9d8:	1918      	adds	r0, r3, r4
   1b9da:	f00c ffa1 	bl	28920 <tVZFilter_tickEfficient>
                    tExpSmooth_setDest(&envFollowers[i], fabsf(tempSamp));
   1b9de:	4648      	mov	r0, r9
   1b9e0:	eeb0 0ac0 	vabs.f32	s0, s0
   1b9e4:	f00c fa0c 	bl	27e00 <tExpSmooth_setDest>
   1b9e8:	e7b8      	b.n	1b95c <SFXVocoderChTick+0x74>
   1b9ea:	ed9d 9a00 	vldr	s18, [sp]
   1b9ee:	ed9d 8a01 	vldr	s16, [sp, #4]
            float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
   1b9f2:	4e65      	ldr	r6, [pc, #404]	; (1bb88 <SFXVocoderChTick+0x2a0>)
   1b9f4:	eeb0 0a49 	vmov.f32	s0, s18
   1b9f8:	4c64      	ldr	r4, [pc, #400]	; (1bb8c <SFXVocoderChTick+0x2a4>)
   1b9fa:	ed96 7a00 	vldr	s14, [r6]
   1b9fe:	edd4 7a00 	vldr	s15, [r4]
   1ba02:	eea7 0a08 	vfma.f32	s0, s14, s16
   1ba06:	4862      	ldr	r0, [pc, #392]	; (1bb90 <SFXVocoderChTick+0x2a8>)
            input[0] = 0.98f * tanhf(finalSample1);
   1ba08:	eddf 8a62 	vldr	s17, [pc, #392]	; 1bb94 <SFXVocoderChTick+0x2ac>
            float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
   1ba0c:	ee20 0a27 	vmul.f32	s0, s0, s15
   1ba10:	f00c fd38 	bl	28484 <tHighpass_tick>
            float finalSample2 = tHighpass_tick(&chVocFinalHP2, (output[1] + (output[0] * oneMinusStereo)) * chVocOutputGain);
   1ba14:	edd6 7a00 	vldr	s15, [r6]
            float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
   1ba18:	eef0 9a40 	vmov.f32	s19, s0
            float finalSample2 = tHighpass_tick(&chVocFinalHP2, (output[1] + (output[0] * oneMinusStereo)) * chVocOutputGain);
   1ba1c:	ed94 0a00 	vldr	s0, [r4]
   1ba20:	eea7 8a89 	vfma.f32	s16, s15, s18
   1ba24:	485c      	ldr	r0, [pc, #368]	; (1bb98 <SFXVocoderChTick+0x2b0>)
   1ba26:	ee28 0a00 	vmul.f32	s0, s16, s0
   1ba2a:	f00c fd2b 	bl	28484 <tHighpass_tick>
   1ba2e:	eeb0 8a40 	vmov.f32	s16, s0
            input[0] = 0.98f * tanhf(finalSample1);
   1ba32:	eeb0 0a69 	vmov.f32	s0, s19
   1ba36:	f011 fb91 	bl	2d15c <tanhf>
   1ba3a:	ee60 7a28 	vmul.f32	s15, s0, s17
            input[1] = 0.98f * tanhf(finalSample2);
   1ba3e:	eeb0 0a48 	vmov.f32	s0, s16
            input[0] = 0.98f * tanhf(finalSample1);
   1ba42:	edc5 7a00 	vstr	s15, [r5]
            input[1] = 0.98f * tanhf(finalSample2);
   1ba46:	f011 fb89 	bl	2d15c <tanhf>
   1ba4a:	ee20 0a28 	vmul.f32	s0, s0, s17
   1ba4e:	ed85 0a01 	vstr	s0, [r5, #4]
        }
   1ba52:	b003      	add	sp, #12
   1ba54:	ecbd 8b06 	vpop	{d8-d10}
   1ba58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (!vocChFreeze)
   1ba5c:	f8df 8170 	ldr.w	r8, [pc, #368]	; 1bbd0 <SFXVocoderChTick+0x2e8>
                float zerocross = tZeroCrossing_tick(&zerox, input[1]);
   1ba60:	484e      	ldr	r0, [pc, #312]	; (1bb9c <SFXVocoderChTick+0x2b4>)
   1ba62:	f008 fbf7 	bl	24254 <tZeroCrossing_tick>
                if (!vocChFreeze)
   1ba66:	f8d8 3000 	ldr.w	r3, [r8]
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1ba6a:	f8df 8160 	ldr.w	r8, [pc, #352]	; 1bbcc <SFXVocoderChTick+0x2e4>
                if (!vocChFreeze)
   1ba6e:	b9ab      	cbnz	r3, 1ba9c <SFXVocoderChTick+0x1b4>
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1ba70:	ed9f 6a4b 	vldr	s12, [pc, #300]	; 1bba0 <SFXVocoderChTick+0x2b8>
   1ba74:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   1ba78:	edd8 7a04 	vldr	s15, [r8, #16]
   1ba7c:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 1bb6c <SFXVocoderChTick+0x284>
   1ba80:	ee77 7ac6 	vsub.f32	s15, s15, s12
   1ba84:	4847      	ldr	r0, [pc, #284]	; (1bba4 <SFXVocoderChTick+0x2bc>)
   1ba86:	eef4 7ac0 	vcmpe.f32	s15, s0
   1ba8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ba8e:	bf54      	ite	pl
   1ba90:	eeb0 0a47 	vmovpl.f32	s0, s14
   1ba94:	eeb0 0a66 	vmovmi.f32	s0, s13
   1ba98:	f00c f9b2 	bl	27e00 <tExpSmooth_setDest>
                float noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1ba9c:	4841      	ldr	r0, [pc, #260]	; (1bba4 <SFXVocoderChTick+0x2bc>)
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ba9e:	2400      	movs	r4, #0
                float noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1baa0:	f00c f9b8 	bl	27e14 <tExpSmooth_tick>
   1baa4:	eeb0 aa40 	vmov.f32	s20, s0
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
   1baa8:	483f      	ldr	r0, [pc, #252]	; (1bba8 <SFXVocoderChTick+0x2c0>)
   1baaa:	f00e fe27 	bl	2a6fc <tNoise_tick>
            float sample = 0.0f;
   1baae:	ed9f 9a2f 	vldr	s18, [pc, #188]	; 1bb6c <SFXVocoderChTick+0x284>
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
   1bab2:	ee60 8a0a 	vmul.f32	s17, s0, s20
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1bab6:	f8df 911c 	ldr.w	r9, [pc, #284]	; 1bbd4 <SFXVocoderChTick+0x2ec>
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1baba:	4f3c      	ldr	r7, [pc, #240]	; (1bbac <SFXVocoderChTick+0x2c4>)
                    if (tempRamp > 0.0001f)
   1babc:	eddf 9a3c 	vldr	s19, [pc, #240]	; 1bbb0 <SFXVocoderChTick+0x2c8>
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1bac0:	e005      	b.n	1bace <SFXVocoderChTick+0x1e6>
                            sample += tSawtooth_tick(&osc[i]) * tempRamp;
   1bac2:	1998      	adds	r0, r3, r6
   1bac4:	f00e fda8 	bl	2a618 <tSawtooth_tick>
   1bac8:	eea0 9a08 	vfma.f32	s18, s0, s16
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1bacc:	3401      	adds	r4, #1
   1bace:	4648      	mov	r0, r9
   1bad0:	00a6      	lsls	r6, r4, #2
   1bad2:	f00e fc91 	bl	2a3f8 <tSimplePoly_getNumVoices>
   1bad6:	42a0      	cmp	r0, r4
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1bad8:	eb07 0006 	add.w	r0, r7, r6
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1badc:	dd19      	ble.n	1bb12 <SFXVocoderChTick+0x22a>
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1bade:	f00c f999 	bl	27e14 <tExpSmooth_tick>
                    if (tempRamp > 0.0001f)
   1bae2:	eeb4 0ae9 	vcmpe.f32	s0, s19
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1bae6:	eeb0 8a40 	vmov.f32	s16, s0
                        if (displayValues[5] < 0.5f)
   1baea:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
                    if (tempRamp > 0.0001f)
   1baee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1baf2:	ddeb      	ble.n	1bacc <SFXVocoderChTick+0x1e4>
                        if (displayValues[5] < 0.5f)
   1baf4:	ed98 7a05 	vldr	s14, [r8, #20]
                            sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
   1baf8:	482e      	ldr	r0, [pc, #184]	; (1bbb4 <SFXVocoderChTick+0x2cc>)
                        if (displayValues[5] < 0.5f)
   1bafa:	eeb4 7ae7 	vcmpe.f32	s14, s15
                            sample += tSawtooth_tick(&osc[i]) * tempRamp;
   1bafe:	4b2e      	ldr	r3, [pc, #184]	; (1bbb8 <SFXVocoderChTick+0x2d0>)
                            sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
   1bb00:	4430      	add	r0, r6
                        if (displayValues[5] < 0.5f)
   1bb02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1bb06:	d4dc      	bmi.n	1bac2 <SFXVocoderChTick+0x1da>
                            sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
   1bb08:	f00a fbd8 	bl	262bc <tRosenbergGlottalPulse_tick>
   1bb0c:	eea0 9a08 	vfma.f32	s18, s0, s16
   1bb10:	e7dc      	b.n	1bacc <SFXVocoderChTick+0x1e4>
                sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
   1bb12:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1bb16:	edd8 6a08 	vldr	s13, [r8, #32]
   1bb1a:	ed9f 7a28 	vldr	s14, [pc, #160]	; 1bbbc <SFXVocoderChTick+0x2d4>
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1bb1e:	4828      	ldr	r0, [pc, #160]	; (1bbc0 <SFXVocoderChTick+0x2d8>)
                sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
   1bb20:	eeb0 8a67 	vmov.f32	s16, s15
   1bb24:	ee77 7aca 	vsub.f32	s15, s15, s20
   1bb28:	eea6 8ac7 	vfms.f32	s16, s13, s14
   1bb2c:	ee28 8a27 	vmul.f32	s16, s16, s15
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1bb30:	f00e fde4 	bl	2a6fc <tNoise_tick>
   1bb34:	4823      	ldr	r0, [pc, #140]	; (1bbc4 <SFXVocoderChTick+0x2dc>)
   1bb36:	f00c fca5 	bl	28484 <tHighpass_tick>
   1bb3a:	edd8 7a08 	vldr	s15, [r8, #32]
                sample *= tExpSmooth_tick(&comp);
   1bb3e:	4822      	ldr	r0, [pc, #136]	; (1bbc8 <SFXVocoderChTick+0x2e0>)
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1bb40:	ee77 7aa7 	vadd.f32	s15, s15, s15
   1bb44:	ee67 7a80 	vmul.f32	s15, s15, s0
   1bb48:	eee9 7a08 	vfma.f32	s15, s18, s16
   1bb4c:	ee78 8aa7 	vadd.f32	s17, s17, s15
                sample *= tExpSmooth_tick(&comp);
   1bb50:	f00c f960 	bl	27e14 <tExpSmooth_tick>
   1bb54:	ee28 0a80 	vmul.f32	s0, s17, s0
   1bb58:	e6dc      	b.n	1b914 <SFXVocoderChTick+0x2c>
            for (int i = 0; i < numberOfVocoderBands; i++)
   1bb5a:	eeb0 9a48 	vmov.f32	s18, s16
   1bb5e:	e748      	b.n	1b9f2 <SFXVocoderChTick+0x10a>
   1bb60:	020f9eb8 	.word	0x020f9eb8
   1bb64:	020e2e64 	.word	0x020e2e64
   1bb68:	000627ad 	.word	0x000627ad
   1bb6c:	00000000 	.word	0x00000000
   1bb70:	020f9b40 	.word	0x020f9b40
   1bb74:	020f9cf0 	.word	0x020f9cf0
   1bb78:	020f9cf4 	.word	0x020f9cf4
   1bb7c:	020f9ef4 	.word	0x020f9ef4
   1bb80:	020fab00 	.word	0x020fab00
   1bb84:	020fab04 	.word	0x020fab04
   1bb88:	000627b0 	.word	0x000627b0
   1bb8c:	00062748 	.word	0x00062748
   1bb90:	020e5104 	.word	0x020e5104
   1bb94:	3f7ae148 	.word	0x3f7ae148
   1bb98:	020faaf4 	.word	0x020faaf4
   1bb9c:	020f9f58 	.word	0x020f9f58
   1bba0:	3dcccccd 	.word	0x3dcccccd
   1bba4:	020faaf0 	.word	0x020faaf0
   1bba8:	020e5d2c 	.word	0x020e5d2c
   1bbac:	020fa1e4 	.word	0x020fa1e4
   1bbb0:	38d1b717 	.word	0x38d1b717
   1bbb4:	020e5110 	.word	0x020e5110
   1bbb8:	020f9ba4 	.word	0x020f9ba4
   1bbbc:	3e99999a 	.word	0x3e99999a
   1bbc0:	020e50e0 	.word	0x020e50e0
   1bbc4:	020e5d24 	.word	0x020e5d24
   1bbc8:	020f9b24 	.word	0x020f9b24
   1bbcc:	020fb05c 	.word	0x020fb05c
   1bbd0:	020e2ed8 	.word	0x020e2ed8
   1bbd4:	020f9de8 	.word	0x020f9de8

0001bbd8 <SFXVocoderChFree>:
        {
   1bbd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bbda:	4c1f      	ldr	r4, [pc, #124]	; (1bc58 <SFXVocoderChFree+0x80>)
   1bbdc:	4d1f      	ldr	r5, [pc, #124]	; (1bc5c <SFXVocoderChFree+0x84>)
   1bbde:	f104 07c0 	add.w	r7, r4, #192	; 0xc0
   1bbe2:	4e1f      	ldr	r6, [pc, #124]	; (1bc60 <SFXVocoderChFree+0x88>)
                tVZFilter_free(&analysisBands[i][0]);
   1bbe4:	4620      	mov	r0, r4
   1bbe6:	f00c fe4f 	bl	28888 <tVZFilter_free>
                tVZFilter_free(&analysisBands[i][1]);
   1bbea:	1d20      	adds	r0, r4, #4
   1bbec:	f00c fe4c 	bl	28888 <tVZFilter_free>
                tVZFilter_free(&synthesisBands[i][0]);
   1bbf0:	1f28      	subs	r0, r5, #4
   1bbf2:	f00c fe49 	bl	28888 <tVZFilter_free>
   1bbf6:	3408      	adds	r4, #8
                tVZFilter_free(&synthesisBands[i][1]);
   1bbf8:	4628      	mov	r0, r5
   1bbfa:	3508      	adds	r5, #8
   1bbfc:	f00c fe44 	bl	28888 <tVZFilter_free>
                tExpSmooth_free(&envFollowers[i]);
   1bc00:	4630      	mov	r0, r6
   1bc02:	f00c f8e7 	bl	27dd4 <tExpSmooth_free>
            for (int i = 0; i < MAX_NUM_VOCODER_BANDS; i++)
   1bc06:	42a7      	cmp	r7, r4
   1bc08:	f106 0604 	add.w	r6, r6, #4
   1bc0c:	d1ea      	bne.n	1bbe4 <SFXVocoderChFree+0xc>
            tNoise_free(&breathNoise);
   1bc0e:	4815      	ldr	r0, [pc, #84]	; (1bc64 <SFXVocoderChFree+0x8c>)
            tHighpass_free(&chVocFinalHP2);
   1bc10:	2400      	movs	r4, #0
            tNoise_free(&breathNoise);
   1bc12:	f00e fd6f 	bl	2a6f4 <tNoise_free>
            tNoise_free(&vocoderNoise);
   1bc16:	4814      	ldr	r0, [pc, #80]	; (1bc68 <SFXVocoderChFree+0x90>)
   1bc18:	f00e fd6c 	bl	2a6f4 <tNoise_free>
            tZeroCrossing_free(&zerox);
   1bc1c:	4813      	ldr	r0, [pc, #76]	; (1bc6c <SFXVocoderChFree+0x94>)
   1bc1e:	f008 fb09 	bl	24234 <tZeroCrossing_free>
            tExpSmooth_free(&noiseRamp);
   1bc22:	4813      	ldr	r0, [pc, #76]	; (1bc70 <SFXVocoderChFree+0x98>)
   1bc24:	f00c f8d6 	bl	27dd4 <tExpSmooth_free>
            tHighpass_free(&noiseHP);
   1bc28:	4812      	ldr	r0, [pc, #72]	; (1bc74 <SFXVocoderChFree+0x9c>)
   1bc2a:	f00c fc17 	bl	2845c <tHighpass_free>
            tVZFilter_free(&vocodec_highshelf);
   1bc2e:	4812      	ldr	r0, [pc, #72]	; (1bc78 <SFXVocoderChFree+0xa0>)
   1bc30:	f00c fe2a 	bl	28888 <tVZFilter_free>
            tHighpass_free(&chVocFinalHP1);
   1bc34:	4811      	ldr	r0, [pc, #68]	; (1bc7c <SFXVocoderChFree+0xa4>)
   1bc36:	f00c fc11 	bl	2845c <tHighpass_free>
            tHighpass_free(&chVocFinalHP2);
   1bc3a:	4811      	ldr	r0, [pc, #68]	; (1bc80 <SFXVocoderChFree+0xa8>)
   1bc3c:	4e11      	ldr	r6, [pc, #68]	; (1bc84 <SFXVocoderChFree+0xac>)
   1bc3e:	4d12      	ldr	r5, [pc, #72]	; (1bc88 <SFXVocoderChFree+0xb0>)
   1bc40:	f00c fc0c 	bl	2845c <tHighpass_free>
                tSawtooth_free(&osc[i]);
   1bc44:	1930      	adds	r0, r6, r4
   1bc46:	f00e fcb1 	bl	2a5ac <tSawtooth_free>
                tRosenbergGlottalPulse_free(&glottal[i]);
   1bc4a:	1928      	adds	r0, r5, r4
   1bc4c:	3404      	adds	r4, #4
   1bc4e:	f00a fb31 	bl	262b4 <tRosenbergGlottalPulse_free>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
   1bc52:	2c20      	cmp	r4, #32
   1bc54:	d1f6      	bne.n	1bc44 <SFXVocoderChFree+0x6c>
        }
   1bc56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1bc58:	020fab00 	.word	0x020fab00
   1bc5c:	020f9cf4 	.word	0x020f9cf4
   1bc60:	020f9ef4 	.word	0x020f9ef4
   1bc64:	020e50e0 	.word	0x020e50e0
   1bc68:	020e5d2c 	.word	0x020e5d2c
   1bc6c:	020f9f58 	.word	0x020f9f58
   1bc70:	020faaf0 	.word	0x020faaf0
   1bc74:	020e5d24 	.word	0x020e5d24
   1bc78:	020f9eb8 	.word	0x020f9eb8
   1bc7c:	020e5104 	.word	0x020e5104
   1bc80:	020faaf4 	.word	0x020faaf4
   1bc84:	020f9ba4 	.word	0x020f9ba4
   1bc88:	020e5110 	.word	0x020e5110

0001bc8c <SFXPitchShiftAlloc>:
        {
   1bc8c:	b510      	push	{r4, lr}
            tFormantShifter_initToPool(&fs, 7, &smallPool);
   1bc8e:	4a22      	ldr	r2, [pc, #136]	; (1bd18 <SFXPitchShiftAlloc+0x8c>)
   1bc90:	2107      	movs	r1, #7
   1bc92:	4822      	ldr	r0, [pc, #136]	; (1bd1c <SFXPitchShiftAlloc+0x90>)
            tRamp_init(&pitchshiftRamp, 100.0f, 1);
   1bc94:	4c22      	ldr	r4, [pc, #136]	; (1bd20 <SFXPitchShiftAlloc+0x94>)
        {
   1bc96:	ed2d 8b02 	vpush	{d8}
            tFormantShifter_initToPool(&fs, 7, &smallPool);
   1bc9a:	f00b f9ed 	bl	27078 <tFormantShifter_initToPool>
            tRetune_init(&retune, NUM_RETUNE, 1024, 512);
   1bc9e:	f44f 7300 	mov.w	r3, #512	; 0x200
   1bca2:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1bca6:	2101      	movs	r1, #1
   1bca8:	481e      	ldr	r0, [pc, #120]	; (1bd24 <SFXPitchShiftAlloc+0x98>)
   1bcaa:	f00a fe73 	bl	26994 <tRetune_init>
            tRetune_init(&retune2, NUM_RETUNE, 1024, 512);
   1bcae:	f44f 7300 	mov.w	r3, #512	; 0x200
   1bcb2:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1bcb6:	2101      	movs	r1, #1
   1bcb8:	481b      	ldr	r0, [pc, #108]	; (1bd28 <SFXPitchShiftAlloc+0x9c>)
   1bcba:	f00a fe6b 	bl	26994 <tRetune_init>
            tRamp_init(&pitchshiftRamp, 100.0f, 1);
   1bcbe:	4620      	mov	r0, r4
   1bcc0:	2101      	movs	r1, #1
   1bcc2:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 1bd2c <SFXPitchShiftAlloc+0xa0>
   1bcc6:	f00b ff81 	bl	27bcc <tRamp_init>
            tExpSmooth_init(&smoother1, 0.0f, 0.01f);
   1bcca:	eddf 8a19 	vldr	s17, [pc, #100]	; 1bd30 <SFXPitchShiftAlloc+0xa4>
   1bcce:	ed9f 8a19 	vldr	s16, [pc, #100]	; 1bd34 <SFXPitchShiftAlloc+0xa8>
            tRamp_setVal(&pitchshiftRamp, 1.0f);
   1bcd2:	4620      	mov	r0, r4
   1bcd4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1bcd8:	f00b fff2 	bl	27cc0 <tRamp_setVal>
            tSimplePoly_setNumVoices(&poly, 1);
   1bcdc:	2101      	movs	r1, #1
   1bcde:	4816      	ldr	r0, [pc, #88]	; (1bd38 <SFXPitchShiftAlloc+0xac>)
   1bce0:	f00e fb82 	bl	2a3e8 <tSimplePoly_setNumVoices>
            tExpSmooth_init(&smoother1, 0.0f, 0.01f);
   1bce4:	eef0 0a68 	vmov.f32	s1, s17
   1bce8:	eeb0 0a48 	vmov.f32	s0, s16
   1bcec:	4813      	ldr	r0, [pc, #76]	; (1bd3c <SFXPitchShiftAlloc+0xb0>)
   1bcee:	f00c f821 	bl	27d34 <tExpSmooth_init>
            tExpSmooth_init(&smoother2, 0.0f, 0.01f);
   1bcf2:	eef0 0a68 	vmov.f32	s1, s17
   1bcf6:	eeb0 0a48 	vmov.f32	s0, s16
   1bcfa:	4811      	ldr	r0, [pc, #68]	; (1bd40 <SFXPitchShiftAlloc+0xb4>)
   1bcfc:	f00c f81a 	bl	27d34 <tExpSmooth_init>
            tExpSmooth_init(&smoother3, 0.0f, 0.01f);
   1bd00:	eef0 0a68 	vmov.f32	s1, s17
   1bd04:	eeb0 0a48 	vmov.f32	s0, s16
   1bd08:	480e      	ldr	r0, [pc, #56]	; (1bd44 <SFXPitchShiftAlloc+0xb8>)
        }
   1bd0a:	ecbd 8b02 	vpop	{d8}
   1bd0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            tExpSmooth_init(&smoother3, 0.0f, 0.01f);
   1bd12:	f00c b80f 	b.w	27d34 <tExpSmooth_init>
   1bd16:	bf00      	nop
   1bd18:	020fabc0 	.word	0x020fabc0
   1bd1c:	020e522c 	.word	0x020e522c
   1bd20:	020f9f5c 	.word	0x020f9f5c
   1bd24:	020e4f50 	.word	0x020e4f50
   1bd28:	020fa114 	.word	0x020fa114
   1bd2c:	42c80000 	.word	0x42c80000
   1bd30:	3c23d70a 	.word	0x3c23d70a
   1bd34:	00000000 	.word	0x00000000
   1bd38:	020f9de8 	.word	0x020f9de8
   1bd3c:	020e510c 	.word	0x020e510c
   1bd40:	020f9908 	.word	0x020f9908
   1bd44:	020fa048 	.word	0x020fa048

0001bd48 <SFXPitchShiftFrame>:
        }
   1bd48:	4770      	bx	lr
   1bd4a:	bf00      	nop

0001bd4c <SFXPitchShiftTick>:
        {
   1bd4c:	b570      	push	{r4, r5, r6, lr}
   1bd4e:	ed2d 8b04 	vpush	{d8-d9}
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1bd52:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
   1bd56:	4e60      	ldr	r6, [pc, #384]	; (1bed8 <SFXPitchShiftTick+0x18c>)
   1bd58:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
            float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
   1bd5c:	ed9f 7a5f 	vldr	s14, [pc, #380]	; 1bedc <SFXPitchShiftTick+0x190>
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1bd60:	edd6 6a33 	vldr	s13, [r6, #204]	; 0xcc
        {
   1bd64:	b082      	sub	sp, #8
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1bd66:	eef0 5a48 	vmov.f32	s11, s16
            float myPitchFactorCoarse = (presetKnobValues[Pitchshift][0]*2.0f) - 1.0f;
   1bd6a:	ed96 6a32 	vldr	s12, [r6, #200]	; 0xc8
            displayValues[0] = myPitchFactorCombined;
   1bd6e:	4c5c      	ldr	r4, [pc, #368]	; (1bee0 <SFXPitchShiftTick+0x194>)
        {
   1bd70:	4605      	mov	r5, r0
            float myPitchFactorCoarse = (presetKnobValues[Pitchshift][0]*2.0f) - 1.0f;
   1bd72:	eea6 8a27 	vfma.f32	s16, s12, s15
            float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
   1bd76:	2100      	movs	r1, #0
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1bd78:	eee6 5aa7 	vfma.f32	s11, s13, s15
            float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
   1bd7c:	4859      	ldr	r0, [pc, #356]	; (1bee4 <SFXPitchShiftTick+0x198>)
            float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
   1bd7e:	eea5 8a87 	vfma.f32	s16, s11, s14
            displayValues[0] = myPitchFactorCombined;
   1bd82:	ed84 8a00 	vstr	s16, [r4]
            displayValues[1] = myPitchFactorCombined;
   1bd86:	ed84 8a01 	vstr	s16, [r4, #4]
            float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
   1bd8a:	f00e fb57 	bl	2a43c <tSimplePoly_getPitchAndCheckActive>
   1bd8e:	ee07 0a90 	vmov	s15, r0
   1bd92:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
            if (keyPitch >= 0)
   1bd96:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   1bd9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1bd9e:	f280 8094 	bge.w	1beca <SFXPitchShiftTick+0x17e>
                keyPitch = 1.0f;
   1bda2:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
            float myPitchFactor = fastexp2f(myPitchFactorCombined);
   1bda6:	eeb0 0a48 	vmov.f32	s0, s16
   1bdaa:	f00d fbeb 	bl	29584 <fastexp2f>
            myPitchFactor *= keyPitch;
   1bdae:	ee68 8a80 	vmul.f32	s17, s17, s0
            tRetune_setPitchFactor(&retune, myPitchFactor, 0);
   1bdb2:	2100      	movs	r1, #0
   1bdb4:	484c      	ldr	r0, [pc, #304]	; (1bee8 <SFXPitchShiftTick+0x19c>)
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1bdb6:	eebf 9a00 	vmov.f32	s18, #240	; 0xbf800000 -1.0
            tRetune_setPitchFactor(&retune, myPitchFactor, 0);
   1bdba:	eeb0 0a68 	vmov.f32	s0, s17
   1bdbe:	f00a ff09 	bl	26bd4 <tRetune_setPitchFactor>
            tRetune_setPitchFactor(&retune2, myPitchFactor, 0);
   1bdc2:	2100      	movs	r1, #0
   1bdc4:	4849      	ldr	r0, [pc, #292]	; (1beec <SFXPitchShiftTick+0x1a0>)
   1bdc6:	eeb0 0a68 	vmov.f32	s0, s17
   1bdca:	f00a ff03 	bl	26bd4 <tRetune_setPitchFactor>
            displayValues[2] = LEAF_clip( 0.0f,((presetKnobValues[Pitchshift][2]) * 3.0f) - 0.2f,3.0f);
   1bdce:	eeb0 1a08 	vmov.f32	s2, #8	; 0x40400000  3.0
   1bdd2:	edd6 7a34 	vldr	s15, [r6, #208]	; 0xd0
   1bdd6:	eddf 0a46 	vldr	s1, [pc, #280]	; 1bef0 <SFXPitchShiftTick+0x1a4>
   1bdda:	ed9f 0a46 	vldr	s0, [pc, #280]	; 1bef4 <SFXPitchShiftTick+0x1a8>
   1bdde:	eee7 0a81 	vfma.f32	s1, s15, s2
   1bde2:	f00d fca1 	bl	29728 <LEAF_clip>
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1bde6:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
            displayValues[2] = LEAF_clip( 0.0f,((presetKnobValues[Pitchshift][2]) * 3.0f) - 0.2f,3.0f);
   1bdea:	ed84 0a02 	vstr	s0, [r4, #8]
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1bdee:	eeb0 0a49 	vmov.f32	s0, s18
   1bdf2:	ed96 7a35 	vldr	s14, [r6, #212]	; 0xd4
   1bdf6:	eea7 0a27 	vfma.f32	s0, s14, s15
   1bdfa:	f00d fbc3 	bl	29584 <fastexp2f>
            tExpSmooth_setDest(&smoother3, displayValues[2]);
   1bdfe:	483e      	ldr	r0, [pc, #248]	; (1bef8 <SFXPitchShiftTick+0x1ac>)
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1be00:	ed84 0a03 	vstr	s0, [r4, #12]
            tExpSmooth_setDest(&smoother3, displayValues[2]);
   1be04:	ed94 0a02 	vldr	s0, [r4, #8]
   1be08:	f00b fffa 	bl	27e00 <tExpSmooth_setDest>
            tFormantShifter_setIntensity(&fs, tExpSmooth_tick(&smoother3)+.1f);
   1be0c:	483a      	ldr	r0, [pc, #232]	; (1bef8 <SFXPitchShiftTick+0x1ac>)
   1be0e:	f00c f801 	bl	27e14 <tExpSmooth_tick>
   1be12:	eddf 7a32 	vldr	s15, [pc, #200]	; 1bedc <SFXPitchShiftTick+0x190>
   1be16:	4839      	ldr	r0, [pc, #228]	; (1befc <SFXPitchShiftTick+0x1b0>)
   1be18:	ee30 0a27 	vadd.f32	s0, s0, s15
   1be1c:	f00b fbdc 	bl	275d8 <tFormantShifter_setIntensity>
            tFormantShifter_setShiftFactor(&fs, displayValues[3]);
   1be20:	ed94 0a03 	vldr	s0, [r4, #12]
   1be24:	4835      	ldr	r0, [pc, #212]	; (1befc <SFXPitchShiftTick+0x1b0>)
   1be26:	f00b fbd3 	bl	275d0 <tFormantShifter_setShiftFactor>
            if (displayValues[2] > 0.01f)
   1be2a:	eddf 7a35 	vldr	s15, [pc, #212]	; 1bf00 <SFXPitchShiftTick+0x1b4>
   1be2e:	ed94 7a02 	vldr	s14, [r4, #8]
                tRamp_setDest(&pitchshiftRamp, 1.0f);
   1be32:	4834      	ldr	r0, [pc, #208]	; (1bf04 <SFXPitchShiftTick+0x1b8>)
            if (displayValues[2] > 0.01f)
   1be34:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1be38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                tRamp_setDest(&pitchshiftRamp, -1.0f);
   1be3c:	bfcc      	ite	gt
   1be3e:	eeb0 0a49 	vmovgt.f32	s0, s18
                tRamp_setDest(&pitchshiftRamp, 1.0f);
   1be42:	eeb7 0a00 	vmovle.f32	s0, #112	; 0x3f800000  1.0
   1be46:	f00b ff2d 	bl	27ca4 <tRamp_setDest>
            float crossfadeVal = tRamp_tick(&pitchshiftRamp);
   1be4a:	482e      	ldr	r0, [pc, #184]	; (1bf04 <SFXPitchShiftTick+0x1b8>)
   1be4c:	f00b ff46 	bl	27cdc <tRamp_tick>
            LEAF_crossfade(crossfadeVal, myGains);
   1be50:	4668      	mov	r0, sp
   1be52:	f00d fbe5 	bl	29620 <LEAF_crossfade>
            tExpSmooth_setDest(&smoother1, myGains[0]);
   1be56:	ed9d 0a00 	vldr	s0, [sp]
   1be5a:	482b      	ldr	r0, [pc, #172]	; (1bf08 <SFXPitchShiftTick+0x1bc>)
   1be5c:	f00b ffd0 	bl	27e00 <tExpSmooth_setDest>
            tExpSmooth_setDest(&smoother2, myGains[1]);
   1be60:	ed9d 0a01 	vldr	s0, [sp, #4]
   1be64:	4829      	ldr	r0, [pc, #164]	; (1bf0c <SFXPitchShiftTick+0x1c0>)
   1be66:	f00b ffcb 	bl	27e00 <tExpSmooth_setDest>
            float formantsample = tanhf(tFormantShifter_remove(&fs, input[1]));
   1be6a:	4824      	ldr	r0, [pc, #144]	; (1befc <SFXPitchShiftTick+0x1b0>)
   1be6c:	ed95 0a01 	vldr	s0, [r5, #4]
   1be70:	f00b f9fa 	bl	27268 <tFormantShifter_remove>
   1be74:	f011 f972 	bl	2d15c <tanhf>
            float* samples = tRetune_tick(&retune2, formantsample);
   1be78:	481c      	ldr	r0, [pc, #112]	; (1beec <SFXPitchShiftTick+0x1a0>)
   1be7a:	f00a fdd7 	bl	26a2c <tRetune_tick>
            formantsample = samples[0];
   1be7e:	ed90 8a00 	vldr	s16, [r0]
            samples = tRetune_tick(&retune, sample);
   1be82:	ed95 0a01 	vldr	s0, [r5, #4]
   1be86:	4818      	ldr	r0, [pc, #96]	; (1bee8 <SFXPitchShiftTick+0x19c>)
   1be88:	f00a fdd0 	bl	26a2c <tRetune_tick>
            formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
   1be8c:	eeb0 0a48 	vmov.f32	s0, s16
            sample = samples[0];
   1be90:	ed90 8a00 	vldr	s16, [r0]
            formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
   1be94:	4819      	ldr	r0, [pc, #100]	; (1befc <SFXPitchShiftTick+0x1b0>)
   1be96:	f00b fa65 	bl	27364 <tFormantShifter_add>
   1be9a:	f011 f95f 	bl	2d15c <tanhf>
   1be9e:	481b      	ldr	r0, [pc, #108]	; (1bf0c <SFXPitchShiftTick+0x1c0>)
   1bea0:	eeb0 9a40 	vmov.f32	s18, s0
   1bea4:	f00b ffb6 	bl	27e14 <tExpSmooth_tick>
            sample = (sample * (tExpSmooth_tick(&smoother1))) +  formantsample;
   1bea8:	4817      	ldr	r0, [pc, #92]	; (1bf08 <SFXPitchShiftTick+0x1bc>)
            formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
   1beaa:	eef0 8a40 	vmov.f32	s17, s0
            sample = (sample * (tExpSmooth_tick(&smoother1))) +  formantsample;
   1beae:	f00b ffb1 	bl	27e14 <tExpSmooth_tick>
   1beb2:	ee20 0a08 	vmul.f32	s0, s0, s16
   1beb6:	eea9 0a28 	vfma.f32	s0, s18, s17
            input[0] = sample;
   1beba:	ed85 0a00 	vstr	s0, [r5]
            input[1] = sample;
   1bebe:	ed85 0a01 	vstr	s0, [r5, #4]
        }
   1bec2:	b002      	add	sp, #8
   1bec4:	ecbd 8b04 	vpop	{d8-d9}
   1bec8:	bd70      	pop	{r4, r5, r6, pc}
                keyPitch = LEAF_midiToFrequency(keyPitch) * 0.003822629969419f ;
   1beca:	eddf 8a11 	vldr	s17, [pc, #68]	; 1bf10 <SFXPitchShiftTick+0x1c4>
   1bece:	f00d fd15 	bl	298fc <LEAF_midiToFrequency>
   1bed2:	ee60 8a28 	vmul.f32	s17, s0, s17
   1bed6:	e766      	b.n	1bda6 <SFXPitchShiftTick+0x5a>
   1bed8:	020e55d8 	.word	0x020e55d8
   1bedc:	3dcccccd 	.word	0x3dcccccd
   1bee0:	020fb05c 	.word	0x020fb05c
   1bee4:	020f9de8 	.word	0x020f9de8
   1bee8:	020e4f50 	.word	0x020e4f50
   1beec:	020fa114 	.word	0x020fa114
   1bef0:	be4ccccd 	.word	0xbe4ccccd
   1bef4:	00000000 	.word	0x00000000
   1bef8:	020fa048 	.word	0x020fa048
   1befc:	020e522c 	.word	0x020e522c
   1bf00:	3c23d70a 	.word	0x3c23d70a
   1bf04:	020f9f5c 	.word	0x020f9f5c
   1bf08:	020e510c 	.word	0x020e510c
   1bf0c:	020f9908 	.word	0x020f9908
   1bf10:	3b7a8517 	.word	0x3b7a8517

0001bf14 <SFXPitchShiftFree>:
        {
   1bf14:	b508      	push	{r3, lr}
            tFormantShifter_free(&fs);
   1bf16:	480b      	ldr	r0, [pc, #44]	; (1bf44 <SFXPitchShiftFree+0x30>)
   1bf18:	f00b f96a 	bl	271f0 <tFormantShifter_free>
            tRetune_free(&retune);
   1bf1c:	480a      	ldr	r0, [pc, #40]	; (1bf48 <SFXPitchShiftFree+0x34>)
   1bf1e:	f00a fd43 	bl	269a8 <tRetune_free>
            tRetune_free(&retune2);
   1bf22:	480a      	ldr	r0, [pc, #40]	; (1bf4c <SFXPitchShiftFree+0x38>)
   1bf24:	f00a fd40 	bl	269a8 <tRetune_free>
            tRamp_free(&pitchshiftRamp);
   1bf28:	4809      	ldr	r0, [pc, #36]	; (1bf50 <SFXPitchShiftFree+0x3c>)
   1bf2a:	f00b feb7 	bl	27c9c <tRamp_free>
            tExpSmooth_free(&smoother1);
   1bf2e:	4809      	ldr	r0, [pc, #36]	; (1bf54 <SFXPitchShiftFree+0x40>)
   1bf30:	f00b ff50 	bl	27dd4 <tExpSmooth_free>
            tExpSmooth_free(&smoother2);
   1bf34:	4808      	ldr	r0, [pc, #32]	; (1bf58 <SFXPitchShiftFree+0x44>)
   1bf36:	f00b ff4d 	bl	27dd4 <tExpSmooth_free>
            tExpSmooth_free(&smoother3);
   1bf3a:	4808      	ldr	r0, [pc, #32]	; (1bf5c <SFXPitchShiftFree+0x48>)
        }
   1bf3c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tExpSmooth_free(&smoother3);
   1bf40:	f00b bf48 	b.w	27dd4 <tExpSmooth_free>
   1bf44:	020e522c 	.word	0x020e522c
   1bf48:	020e4f50 	.word	0x020e4f50
   1bf4c:	020fa114 	.word	0x020fa114
   1bf50:	020f9f5c 	.word	0x020f9f5c
   1bf54:	020e510c 	.word	0x020e510c
   1bf58:	020f9908 	.word	0x020f9908
   1bf5c:	020fa048 	.word	0x020fa048

0001bf60 <SFXNeartuneAlloc>:
        {
   1bf60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            leaf.clearOnAllocation = 1;
   1bf62:	2401      	movs	r4, #1
   1bf64:	4d28      	ldr	r5, [pc, #160]	; (1c008 <SFXNeartuneAlloc+0xa8>)
            tRetune_init(&autotuneMono, 1, 512, 256);
   1bf66:	f44f 7380 	mov.w	r3, #256	; 0x100
   1bf6a:	4828      	ldr	r0, [pc, #160]	; (1c00c <SFXNeartuneAlloc+0xac>)
   1bf6c:	4621      	mov	r1, r4
   1bf6e:	f44f 7200 	mov.w	r2, #512	; 0x200
            leaf.clearOnAllocation = 1;
   1bf72:	616c      	str	r4, [r5, #20]
            tRetune_init(&autotuneMono, 1, 512, 256);
   1bf74:	f00a fd0e 	bl	26994 <tRetune_init>
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1bf78:	4b25      	ldr	r3, [pc, #148]	; (1c010 <SFXNeartuneAlloc+0xb0>)
            for (int i = 0; i < 128; i++)
   1bf7a:	2100      	movs	r1, #0
   1bf7c:	4825      	ldr	r0, [pc, #148]	; (1c014 <SFXNeartuneAlloc+0xb4>)
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1bf7e:	781f      	ldrb	r7, [r3, #0]
   1bf80:	4e25      	ldr	r6, [pc, #148]	; (1c018 <SFXNeartuneAlloc+0xb8>)
   1bf82:	4d26      	ldr	r5, [pc, #152]	; (1c01c <SFXNeartuneAlloc+0xbc>)
                float tempNote = i;
   1bf84:	ee07 1a90 	vmov	s15, r1
            for (int i = 0; i < 128; i++)
   1bf88:	3101      	adds	r1, #1
                float tempNote = i;
   1bf8a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            for (int i = 0; i < 128; i++)
   1bf8e:	2980      	cmp	r1, #128	; 0x80
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1bf90:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1bf94:	ee17 3a90 	vmov	r3, s15
   1bf98:	eba3 0307 	sub.w	r3, r3, r7
   1bf9c:	fb85 2403 	smull	r2, r4, r5, r3
   1bfa0:	ea4f 72e3 	mov.w	r2, r3, asr #31
   1bfa4:	ebc2 0264 	rsb	r2, r2, r4, asr #1
   1bfa8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1bfac:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1bfb0:	ee07 3a90 	vmov	s15, r3
   1bfb4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1bfb8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1bfbc:	ee17 3a90 	vmov	r3, s15
   1bfc0:	eb06 0383 	add.w	r3, r6, r3, lsl #2
   1bfc4:	edd3 7a00 	vldr	s15, [r3]
   1bfc8:	ee77 7a87 	vadd.f32	s15, s15, s14
                notes[i] = tunedNote;
   1bfcc:	ece0 7a01 	vstmia	r0!, {s15}
            for (int i = 0; i < 128; i++)
   1bfd0:	d1d8      	bne.n	1bf84 <SFXNeartuneAlloc+0x24>
            tExpSmooth_init(&neartune_smoother, 1.0f, .007f);
   1bfd2:	eddf 0a13 	vldr	s1, [pc, #76]	; 1c020 <SFXNeartuneAlloc+0xc0>
   1bfd6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1bfda:	4812      	ldr	r0, [pc, #72]	; (1c024 <SFXNeartuneAlloc+0xc4>)
   1bfdc:	f00b feaa 	bl	27d34 <tExpSmooth_init>
            tRamp_init(&nearWetRamp, 20.0f, 1);
   1bfe0:	2101      	movs	r1, #1
   1bfe2:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1bfe6:	4810      	ldr	r0, [pc, #64]	; (1c028 <SFXNeartuneAlloc+0xc8>)
   1bfe8:	f00b fdf0 	bl	27bcc <tRamp_init>
            setLED_A(autotuneChromatic);
   1bfec:	4b0f      	ldr	r3, [pc, #60]	; (1c02c <SFXNeartuneAlloc+0xcc>)
   1bfee:	7818      	ldrb	r0, [r3, #0]
   1bff0:	f7fd fa4e 	bl	19490 <setLED_A>
            setLED_C(autotuneLock);
   1bff4:	4b0e      	ldr	r3, [pc, #56]	; (1c030 <SFXNeartuneAlloc+0xd0>)
   1bff6:	7818      	ldrb	r0, [r3, #0]
   1bff8:	f7fd fa66 	bl	194c8 <setLED_C>
            lastSnap = 1.0f;
   1bffc:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
   1c000:	4b0c      	ldr	r3, [pc, #48]	; (1c034 <SFXNeartuneAlloc+0xd4>)
   1c002:	601a      	str	r2, [r3, #0]
        }
   1c004:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c006:	bf00      	nop
   1c008:	020fbd68 	.word	0x020fbd68
   1c00c:	020f9de0 	.word	0x020f9de0
   1c010:	020e2f18 	.word	0x020e2f18
   1c014:	020e5310 	.word	0x020e5310
   1c018:	020e2ee4 	.word	0x020e2ee4
   1c01c:	2aaaaaab 	.word	0x2aaaaaab
   1c020:	3be56042 	.word	0x3be56042
   1c024:	020f9eb0 	.word	0x020f9eb0
   1c028:	020fac2c 	.word	0x020fac2c
   1c02c:	020e2de4 	.word	0x020e2de4
   1c030:	020e2de8 	.word	0x020e2de8
   1c034:	000627a8 	.word	0x000627a8

0001c038 <SFXNeartuneFrame>:
        {
   1c038:	b538      	push	{r3, r4, r5, lr}
            if ((tSimplePoly_getNumActiveVoices(&poly) != 0) || (autotuneChromatic == 1) || (autotuneLock == 1))
   1c03a:	4826      	ldr	r0, [pc, #152]	; (1c0d4 <SFXNeartuneFrame+0x9c>)
   1c03c:	f00e f9e0 	bl	2a400 <tSimplePoly_getNumActiveVoices>
   1c040:	b9e8      	cbnz	r0, 1c07e <SFXNeartuneFrame+0x46>
   1c042:	4b25      	ldr	r3, [pc, #148]	; (1c0d8 <SFXNeartuneFrame+0xa0>)
   1c044:	781b      	ldrb	r3, [r3, #0]
   1c046:	2b01      	cmp	r3, #1
   1c048:	d019      	beq.n	1c07e <SFXNeartuneFrame+0x46>
   1c04a:	4b24      	ldr	r3, [pc, #144]	; (1c0dc <SFXNeartuneFrame+0xa4>)
   1c04c:	681b      	ldr	r3, [r3, #0]
   1c04e:	2b01      	cmp	r3, #1
   1c050:	d015      	beq.n	1c07e <SFXNeartuneFrame+0x46>
            if (buttonActionsSFX[ButtonA][ActionPress])
   1c052:	4c23      	ldr	r4, [pc, #140]	; (1c0e0 <SFXNeartuneFrame+0xa8>)
                tRamp_setDest(&nearWetRamp, -1.0f);
   1c054:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   1c058:	4822      	ldr	r0, [pc, #136]	; (1c0e4 <SFXNeartuneFrame+0xac>)
   1c05a:	f00b fe23 	bl	27ca4 <tRamp_setDest>
            if (buttonActionsSFX[ButtonA][ActionPress])
   1c05e:	7d23      	ldrb	r3, [r4, #20]
   1c060:	b1b3      	cbz	r3, 1c090 <SFXNeartuneFrame+0x58>
                autotuneChromatic = !autotuneChromatic;
   1c062:	4a1d      	ldr	r2, [pc, #116]	; (1c0d8 <SFXNeartuneFrame+0xa0>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c064:	2100      	movs	r1, #0
                autotuneChromatic = !autotuneChromatic;
   1c066:	7813      	ldrb	r3, [r2, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c068:	7521      	strb	r1, [r4, #20]
                autotuneChromatic = !autotuneChromatic;
   1c06a:	fab3 f383 	clz	r3, r3
   1c06e:	095b      	lsrs	r3, r3, #5
                setLED_A(autotuneChromatic);
   1c070:	4618      	mov	r0, r3
                autotuneChromatic = !autotuneChromatic;
   1c072:	7013      	strb	r3, [r2, #0]
                setLED_A(autotuneChromatic);
   1c074:	f7fd fa0c 	bl	19490 <setLED_A>
            if (buttonActionsSFX[ButtonC][ActionPress])
   1c078:	7f23      	ldrb	r3, [r4, #28]
   1c07a:	b963      	cbnz	r3, 1c096 <SFXNeartuneFrame+0x5e>
        }
   1c07c:	bd38      	pop	{r3, r4, r5, pc}
            if (buttonActionsSFX[ButtonA][ActionPress])
   1c07e:	4c18      	ldr	r4, [pc, #96]	; (1c0e0 <SFXNeartuneFrame+0xa8>)
                tRamp_setDest(&nearWetRamp, 1.0f);
   1c080:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1c084:	4817      	ldr	r0, [pc, #92]	; (1c0e4 <SFXNeartuneFrame+0xac>)
   1c086:	f00b fe0d 	bl	27ca4 <tRamp_setDest>
            if (buttonActionsSFX[ButtonA][ActionPress])
   1c08a:	7d23      	ldrb	r3, [r4, #20]
   1c08c:	2b00      	cmp	r3, #0
   1c08e:	d1e8      	bne.n	1c062 <SFXNeartuneFrame+0x2a>
            if (buttonActionsSFX[ButtonC][ActionPress])
   1c090:	7f23      	ldrb	r3, [r4, #28]
   1c092:	2b00      	cmp	r3, #0
   1c094:	d0f2      	beq.n	1c07c <SFXNeartuneFrame+0x44>
                autotuneLock = !autotuneLock;
   1c096:	4d11      	ldr	r5, [pc, #68]	; (1c0dc <SFXNeartuneFrame+0xa4>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1c098:	2200      	movs	r2, #0
                autotuneLock = !autotuneLock;
   1c09a:	682b      	ldr	r3, [r5, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1c09c:	7722      	strb	r2, [r4, #28]
                autotuneLock = !autotuneLock;
   1c09e:	fab3 f383 	clz	r3, r3
   1c0a2:	095b      	lsrs	r3, r3, #5
                setLED_C(autotuneLock);
   1c0a4:	4618      	mov	r0, r3
                autotuneLock = !autotuneLock;
   1c0a6:	602b      	str	r3, [r5, #0]
                setLED_C(autotuneLock);
   1c0a8:	f7fd fa0e 	bl	194c8 <setLED_C>
                if (autotuneLock)
   1c0ac:	6829      	ldr	r1, [r5, #0]
   1c0ae:	b151      	cbz	r1, 1c0c6 <SFXNeartuneFrame+0x8e>
   1c0b0:	4d0d      	ldr	r5, [pc, #52]	; (1c0e8 <SFXNeartuneFrame+0xb0>)
   1c0b2:	4c0e      	ldr	r4, [pc, #56]	; (1c0ec <SFXNeartuneFrame+0xb4>)
   1c0b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1c0b6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1c0b8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1c0ba:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1c0bc:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1c0c0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        }
   1c0c4:	bd38      	pop	{r3, r4, r5, pc}
   1c0c6:	2230      	movs	r2, #48	; 0x30
   1c0c8:	4808      	ldr	r0, [pc, #32]	; (1c0ec <SFXNeartuneFrame+0xb4>)
   1c0ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1c0ce:	f010 bc08 	b.w	2c8e2 <memset>
   1c0d2:	bf00      	nop
   1c0d4:	020f9de8 	.word	0x020f9de8
   1c0d8:	020e2de4 	.word	0x020e2de4
   1c0dc:	020e2de8 	.word	0x020e2de8
   1c0e0:	020fafac 	.word	0x020fafac
   1c0e4:	020fac2c 	.word	0x020fac2c
   1c0e8:	020e2df8 	.word	0x020e2df8
   1c0ec:	020e2e70 	.word	0x020e2e70

0001c0f0 <SFXNeartuneFree>:
        {
   1c0f0:	b508      	push	{r3, lr}
            tRetune_free(&autotuneMono);
   1c0f2:	4805      	ldr	r0, [pc, #20]	; (1c108 <SFXNeartuneFree+0x18>)
   1c0f4:	f00a fc58 	bl	269a8 <tRetune_free>
            tExpSmooth_free(&neartune_smoother);
   1c0f8:	4804      	ldr	r0, [pc, #16]	; (1c10c <SFXNeartuneFree+0x1c>)
   1c0fa:	f00b fe6b 	bl	27dd4 <tExpSmooth_free>
            tRamp_free(&nearWetRamp);
   1c0fe:	4804      	ldr	r0, [pc, #16]	; (1c110 <SFXNeartuneFree+0x20>)
        }
   1c100:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tRamp_free(&nearWetRamp);
   1c104:	f00b bdca 	b.w	27c9c <tRamp_free>
   1c108:	020f9de0 	.word	0x020f9de0
   1c10c:	020f9eb0 	.word	0x020f9eb0
   1c110:	020fac2c 	.word	0x020fac2c

0001c114 <SFXAutotuneAlloc>:
        {
   1c114:	b508      	push	{r3, lr}
            tAutotune_init(&autotunePoly, NUM_AUTOTUNE, 1024, 512);
   1c116:	2104      	movs	r1, #4
   1c118:	f44f 7300 	mov.w	r3, #512	; 0x200
   1c11c:	4805      	ldr	r0, [pc, #20]	; (1c134 <SFXAutotuneAlloc+0x20>)
   1c11e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1c122:	f00a fe55 	bl	26dd0 <tAutotune_init>
            tSimplePoly_setNumVoices(&poly, NUM_AUTOTUNE);
   1c126:	2104      	movs	r1, #4
   1c128:	4803      	ldr	r0, [pc, #12]	; (1c138 <SFXAutotuneAlloc+0x24>)
        }
   1c12a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tSimplePoly_setNumVoices(&poly, NUM_AUTOTUNE);
   1c12e:	f00e b95b 	b.w	2a3e8 <tSimplePoly_setNumVoices>
   1c132:	bf00      	nop
   1c134:	020e5d00 	.word	0x020e5d00
   1c138:	020f9de8 	.word	0x020f9de8

0001c13c <SFXAutotuneFrame>:
        {
   1c13c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c140:	4f35      	ldr	r7, [pc, #212]	; (1c218 <SFXAutotuneFrame+0xdc>)
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c142:	2400      	movs	r4, #0
   1c144:	4d35      	ldr	r5, [pc, #212]	; (1c21c <SFXAutotuneFrame+0xe0>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c146:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 1c238 <SFXAutotuneFrame+0xfc>
        {
   1c14a:	ed2d 8b02 	vpush	{d8}
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1c14e:	ed9f 8a34 	vldr	s16, [pc, #208]	; 1c220 <SFXAutotuneFrame+0xe4>
        {
   1c152:	b082      	sub	sp, #8
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c154:	e03e      	b.n	1c1d4 <SFXAutotuneFrame+0x98>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c156:	f00e f96b 	bl	2a430 <tSimplePoly_getPitch>
   1c15a:	ee07 0a90 	vmov	s15, r0
   1c15e:	4a31      	ldr	r2, [pc, #196]	; (1c224 <SFXAutotuneFrame+0xe8>)
   1c160:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c164:	4b30      	ldr	r3, [pc, #192]	; (1c228 <SFXAutotuneFrame+0xec>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c166:	ed92 0a00 	vldr	s0, [r2]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c16a:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c16c:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1c170:	492e      	ldr	r1, [pc, #184]	; (1c22c <SFXAutotuneFrame+0xf0>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c172:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1c176:	ee17 3a90 	vmov	r3, s15
   1c17a:	1a9b      	subs	r3, r3, r2
   1c17c:	fb88 2003 	smull	r2, r0, r8, r3
   1c180:	17da      	asrs	r2, r3, #31
   1c182:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1c186:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1c18a:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1c18e:	ee07 3a90 	vmov	s15, r3
   1c192:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1c196:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1c19a:	ee17 3a90 	vmov	r3, s15
   1c19e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1c1a2:	ed93 0a00 	vldr	s0, [r3]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1c1a6:	ee37 0a00 	vadd.f32	s0, s14, s0
   1c1aa:	f00d fba7 	bl	298fc <LEAF_midiToFrequency>
   1c1ae:	4b20      	ldr	r3, [pc, #128]	; (1c230 <SFXAutotuneFrame+0xf4>)
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1c1b0:	4631      	mov	r1, r6
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1c1b2:	eca7 0a01 	vstmia	r7!, {s0}
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1c1b6:	4628      	mov	r0, r5
   1c1b8:	eb03 0684 	add.w	r6, r3, r4, lsl #2
   1c1bc:	f00e f944 	bl	2a448 <tSimplePoly_getVelocity>
   1c1c0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1c1c4:	2800      	cmp	r0, #0
   1c1c6:	4630      	mov	r0, r6
   1c1c8:	f104 0401 	add.w	r4, r4, #1
   1c1cc:	fe30 0a08 	vselgt.f32	s0, s0, s16
   1c1d0:	f00b fe16 	bl	27e00 <tExpSmooth_setDest>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c1d4:	4628      	mov	r0, r5
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c1d6:	b2e6      	uxtb	r6, r4
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c1d8:	f00e f90e 	bl	2a3f8 <tSimplePoly_getNumVoices>
   1c1dc:	42a0      	cmp	r0, r4
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c1de:	4631      	mov	r1, r6
   1c1e0:	4628      	mov	r0, r5
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c1e2:	dcb8      	bgt.n	1c156 <SFXAutotuneFrame+0x1a>
            int tempNumVoices = tSimplePoly_getNumActiveVoices(&poly);
   1c1e4:	480d      	ldr	r0, [pc, #52]	; (1c21c <SFXAutotuneFrame+0xe0>)
   1c1e6:	f00e f90b 	bl	2a400 <tSimplePoly_getNumActiveVoices>
            if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
   1c1ea:	9001      	str	r0, [sp, #4]
   1c1ec:	b920      	cbnz	r0, 1c1f8 <SFXAutotuneFrame+0xbc>
        }
   1c1ee:	b002      	add	sp, #8
   1c1f0:	ecbd 8b02 	vpop	{d8}
   1c1f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
   1c1f8:	ee07 0a90 	vmov	s15, r0
   1c1fc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1c200:	480c      	ldr	r0, [pc, #48]	; (1c234 <SFXAutotuneFrame+0xf8>)
   1c202:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1c206:	ee80 0a27 	vdiv.f32	s0, s0, s15
        }
   1c20a:	b002      	add	sp, #8
   1c20c:	ecbd 8b02 	vpop	{d8}
   1c210:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
   1c214:	f00b bdf4 	b.w	27e00 <tExpSmooth_setDest>
   1c218:	020e5d04 	.word	0x020e5d04
   1c21c:	020f9de8 	.word	0x020f9de8
   1c220:	00000000 	.word	0x00000000
   1c224:	020e2ea0 	.word	0x020e2ea0
   1c228:	020e2f18 	.word	0x020e2f18
   1c22c:	020e2ee4 	.word	0x020e2ee4
   1c230:	020fa1e4 	.word	0x020fa1e4
   1c234:	020f9b24 	.word	0x020f9b24
   1c238:	2aaaaaab 	.word	0x2aaaaaab

0001c23c <SFXAutotuneTick>:
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1c23c:	4b27      	ldr	r3, [pc, #156]	; (1c2dc <SFXAutotuneTick+0xa0>)
   1c23e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1c242:	ed9f 7a27 	vldr	s14, [pc, #156]	; 1c2e0 <SFXAutotuneTick+0xa4>
        {
   1c246:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c24a:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1c24e:	edd3 6a64 	vldr	s13, [r3, #400]	; 0x190
        {
   1c252:	4680      	mov	r8, r0
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1c254:	4b23      	ldr	r3, [pc, #140]	; (1c2e4 <SFXAutotuneTick+0xa8>)
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c256:	2400      	movs	r4, #0
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1c258:	eee6 7a87 	vfma.f32	s15, s13, s14
            tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
   1c25c:	4822      	ldr	r0, [pc, #136]	; (1c2e8 <SFXAutotuneTick+0xac>)
   1c25e:	4d23      	ldr	r5, [pc, #140]	; (1c2ec <SFXAutotuneTick+0xb0>)
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c260:	4f23      	ldr	r7, [pc, #140]	; (1c2f0 <SFXAutotuneTick+0xb4>)
                tAutotune_setFreq(&autotunePoly, freq[i], i);
   1c262:	4606      	mov	r6, r0
            tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
   1c264:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1c268:	edc3 7a00 	vstr	s15, [r3]
            tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
   1c26c:	f00a ff00 	bl	27070 <tAutotune_setFidelityThreshold>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c270:	e003      	b.n	1c27a <SFXAutotuneTick+0x3e>
                tAutotune_setFreq(&autotunePoly, freq[i], i);
   1c272:	ecb5 0a01 	vldmia	r5!, {s0}
   1c276:	f00a fef3 	bl	27060 <tAutotune_setFreq>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c27a:	4638      	mov	r0, r7
   1c27c:	f00e f8bc 	bl	2a3f8 <tSimplePoly_getNumVoices>
   1c280:	42a0      	cmp	r0, r4
                tAutotune_setFreq(&autotunePoly, freq[i], i);
   1c282:	4621      	mov	r1, r4
   1c284:	4630      	mov	r0, r6
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c286:	f104 0401 	add.w	r4, r4, #1
   1c28a:	dcf2      	bgt.n	1c272 <SFXAutotuneTick+0x36>
            float* samples = tAutotune_tick(&autotunePoly, input[1]);
   1c28c:	ed98 0a01 	vldr	s0, [r8, #4]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c290:	2400      	movs	r4, #0
            float* samples = tAutotune_tick(&autotunePoly, input[1]);
   1c292:	4815      	ldr	r0, [pc, #84]	; (1c2e8 <SFXAutotuneTick+0xac>)
   1c294:	f00a fde8 	bl	26e68 <tAutotune_tick>
            float sample = 0.0f;
   1c298:	ed9f 8a16 	vldr	s16, [pc, #88]	; 1c2f4 <SFXAutotuneTick+0xb8>
            float* samples = tAutotune_tick(&autotunePoly, input[1]);
   1c29c:	4605      	mov	r5, r0
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c29e:	4f14      	ldr	r7, [pc, #80]	; (1c2f0 <SFXAutotuneTick+0xb4>)
                sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
   1c2a0:	4e15      	ldr	r6, [pc, #84]	; (1c2f8 <SFXAutotuneTick+0xbc>)
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c2a2:	e005      	b.n	1c2b0 <SFXAutotuneTick+0x74>
                sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
   1c2a4:	ecf5 8a01 	vldmia	r5!, {s17}
   1c2a8:	f00b fdb4 	bl	27e14 <tExpSmooth_tick>
   1c2ac:	eea8 8a80 	vfma.f32	s16, s17, s0
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c2b0:	4638      	mov	r0, r7
   1c2b2:	f00e f8a1 	bl	2a3f8 <tSimplePoly_getNumVoices>
   1c2b6:	42a0      	cmp	r0, r4
                sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
   1c2b8:	eb06 0084 	add.w	r0, r6, r4, lsl #2
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c2bc:	f104 0401 	add.w	r4, r4, #1
   1c2c0:	dcf0      	bgt.n	1c2a4 <SFXAutotuneTick+0x68>
            sample *= tExpSmooth_tick(&comp);
   1c2c2:	480e      	ldr	r0, [pc, #56]	; (1c2fc <SFXAutotuneTick+0xc0>)
   1c2c4:	f00b fda6 	bl	27e14 <tExpSmooth_tick>
   1c2c8:	ee28 0a00 	vmul.f32	s0, s16, s0
            input[0] = sample;
   1c2cc:	ed88 0a00 	vstr	s0, [r8]
            input[1] = sample;
   1c2d0:	ed88 0a01 	vstr	s0, [r8, #4]
        }
   1c2d4:	ecbd 8b02 	vpop	{d8}
   1c2d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1c2dc:	020e55d8 	.word	0x020e55d8
   1c2e0:	3ef0a3d7 	.word	0x3ef0a3d7
   1c2e4:	020fb05c 	.word	0x020fb05c
   1c2e8:	020e5d00 	.word	0x020e5d00
   1c2ec:	020e5d04 	.word	0x020e5d04
   1c2f0:	020f9de8 	.word	0x020f9de8
   1c2f4:	00000000 	.word	0x00000000
   1c2f8:	020fa1e4 	.word	0x020fa1e4
   1c2fc:	020f9b24 	.word	0x020f9b24

0001c300 <SFXAutotuneFree>:
            tAutotune_free(&autotunePoly);
   1c300:	4801      	ldr	r0, [pc, #4]	; (1c308 <SFXAutotuneFree+0x8>)
   1c302:	f00a bd6f 	b.w	26de4 <tAutotune_free>
   1c306:	bf00      	nop
   1c308:	020e5d00 	.word	0x020e5d00

0001c30c <SFXSamplerBPAlloc>:
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1c30c:	4b1d      	ldr	r3, [pc, #116]	; (1c384 <SFXSamplerBPAlloc+0x78>)
   1c30e:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 1c388 <SFXSamplerBPAlloc+0x7c>
   1c312:	4a1e      	ldr	r2, [pc, #120]	; (1c38c <SFXSamplerBPAlloc+0x80>)
        {
   1c314:	b570      	push	{r4, r5, r6, lr}
   1c316:	ed2d 8b02 	vpush	{d8}
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1c31a:	edd3 7a00 	vldr	s15, [r3]
   1c31e:	4c1c      	ldr	r4, [pc, #112]	; (1c390 <SFXSamplerBPAlloc+0x84>)
   1c320:	ee67 7a87 	vmul.f32	s15, s15, s14
            tSampler_init(&sampler, &buff);
   1c324:	4e1b      	ldr	r6, [pc, #108]	; (1c394 <SFXSamplerBPAlloc+0x88>)
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1c326:	4620      	mov	r0, r4
            tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
   1c328:	eddf 8a1b 	vldr	s17, [pc, #108]	; 1c398 <SFXSamplerBPAlloc+0x8c>
   1c32c:	ed9f 8a1b 	vldr	s16, [pc, #108]	; 1c39c <SFXSamplerBPAlloc+0x90>
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1c330:	eefc 7ae7 	vcvt.u32.f32	s15, s15
            tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
   1c334:	4d1a      	ldr	r5, [pc, #104]	; (1c3a0 <SFXSamplerBPAlloc+0x94>)
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1c336:	ee17 1a90 	vmov	r1, s15
   1c33a:	f00f fc09 	bl	2bb50 <tBuffer_initToPool>
            tBuffer_setRecordMode(&buff, RecordOneShot);
   1c33e:	4620      	mov	r0, r4
   1c340:	2100      	movs	r1, #0
   1c342:	f00f fc6b 	bl	2bc1c <tBuffer_setRecordMode>
            tSampler_init(&sampler, &buff);
   1c346:	4621      	mov	r1, r4
   1c348:	4630      	mov	r0, r6
   1c34a:	f00f fc77 	bl	2bc3c <tSampler_init>
            tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
   1c34e:	4b15      	ldr	r3, [pc, #84]	; (1c3a4 <SFXSamplerBPAlloc+0x98>)
   1c350:	4630      	mov	r0, r6
   1c352:	6819      	ldr	r1, [r3, #0]
   1c354:	3101      	adds	r1, #1
   1c356:	b2c9      	uxtb	r1, r1
   1c358:	f00f fd18 	bl	2bd8c <tSampler_setMode>
            tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
   1c35c:	4629      	mov	r1, r5
   1c35e:	eef0 0a68 	vmov.f32	s1, s17
   1c362:	4811      	ldr	r0, [pc, #68]	; (1c3a8 <SFXSamplerBPAlloc+0x9c>)
   1c364:	eeb0 0a48 	vmov.f32	s0, s16
   1c368:	f00b fd0e 	bl	27d88 <tExpSmooth_initToPool>
            tExpSmooth_initToPool(&lengthSmooth, 0.0f, 0.01f, &smallPool);
   1c36c:	eef0 0a68 	vmov.f32	s1, s17
   1c370:	eeb0 0a48 	vmov.f32	s0, s16
   1c374:	4629      	mov	r1, r5
   1c376:	480d      	ldr	r0, [pc, #52]	; (1c3ac <SFXSamplerBPAlloc+0xa0>)
        }
   1c378:	ecbd 8b02 	vpop	{d8}
   1c37c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            tExpSmooth_initToPool(&lengthSmooth, 0.0f, 0.01f, &smallPool);
   1c380:	f00b bd02 	b.w	27d88 <tExpSmooth_initToPool>
   1c384:	020fbd68 	.word	0x020fbd68
   1c388:	432c0000 	.word	0x432c0000
   1c38c:	020f9dd8 	.word	0x020f9dd8
   1c390:	020e5eb8 	.word	0x020e5eb8
   1c394:	020f9b1c 	.word	0x020f9b1c
   1c398:	3c23d70a 	.word	0x3c23d70a
   1c39c:	00000000 	.word	0x00000000
   1c3a0:	020fabc0 	.word	0x020fabc0
   1c3a4:	020e2dec 	.word	0x020e2dec
   1c3a8:	020fa04c 	.word	0x020fa04c
   1c3ac:	020f98ec 	.word	0x020f98ec

0001c3b0 <SFXSamplerBPFrame>:
   1c3b0:	4770      	bx	lr
   1c3b2:	bf00      	nop

0001c3b4 <SFXSamplerBPTick>:
        {
   1c3b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            if (buttonActionsSFX[ButtonC][ActionPress])
   1c3b8:	4e91      	ldr	r6, [pc, #580]	; (1c600 <SFXSamplerBPTick+0x24c>)
        {
   1c3ba:	4607      	mov	r7, r0
            int recordPosition = tBuffer_getRecordPosition(&buff);
   1c3bc:	4891      	ldr	r0, [pc, #580]	; (1c604 <SFXSamplerBPTick+0x250>)
        {
   1c3be:	ed2d 8b02 	vpush	{d8}
            int recordPosition = tBuffer_getRecordPosition(&buff);
   1c3c2:	f00f fc23 	bl	2bc0c <tBuffer_getRecordPosition>
            if (buttonActionsSFX[ButtonC][ActionPress])
   1c3c6:	7f33      	ldrb	r3, [r6, #28]
            int recordPosition = tBuffer_getRecordPosition(&buff);
   1c3c8:	ee08 0a10 	vmov	s16, r0
            if (buttonActionsSFX[ButtonC][ActionPress])
   1c3cc:	2b00      	cmp	r3, #0
   1c3ce:	f040 80a8 	bne.w	1c522 <SFXSamplerBPTick+0x16e>
            if (buttonActionsSFX[ButtonB][ActionPress])
   1c3d2:	7e33      	ldrb	r3, [r6, #24]
   1c3d4:	f8df 825c 	ldr.w	r8, [pc, #604]	; 1c634 <SFXSamplerBPTick+0x280>
   1c3d8:	4c8b      	ldr	r4, [pc, #556]	; (1c608 <SFXSamplerBPTick+0x254>)
   1c3da:	4d8c      	ldr	r5, [pc, #560]	; (1c60c <SFXSamplerBPTick+0x258>)
   1c3dc:	2b00      	cmp	r3, #0
   1c3de:	f040 80b3 	bne.w	1c548 <SFXSamplerBPTick+0x194>
            if (buttonActionsSFX[ButtonA][ActionPress])
   1c3e2:	7d33      	ldrb	r3, [r6, #20]
   1c3e4:	2b00      	cmp	r3, #0
   1c3e6:	f040 80c6 	bne.w	1c576 <SFXSamplerBPTick+0x1c2>
            if (buttonActionsSFX[ButtonA][ActionRelease])
   1c3ea:	7d73      	ldrb	r3, [r6, #21]
   1c3ec:	2b00      	cmp	r3, #0
   1c3ee:	f040 80d1 	bne.w	1c594 <SFXSamplerBPTick+0x1e0>
            sampleLength = recordPosition * leaf.invSampleRate;
   1c3f2:	4b87      	ldr	r3, [pc, #540]	; (1c610 <SFXSamplerBPTick+0x25c>)
   1c3f4:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c3f8:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
            displayValues[0] = knobs[0] * sampleLength;
   1c3fc:	ed94 7a7d 	vldr	s14, [r4, #500]	; 0x1f4
            sampleLength = recordPosition * leaf.invSampleRate;
   1c400:	edd3 7a01 	vldr	s15, [r3, #4]
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c404:	edd4 0a7e 	vldr	s1, [r4, #504]	; 0x1f8
            sampleLength = recordPosition * leaf.invSampleRate;
   1c408:	ee68 7a27 	vmul.f32	s15, s16, s15
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c40c:	ed9f 0a81 	vldr	s0, [pc, #516]	; 1c614 <SFXSamplerBPTick+0x260>
   1c410:	ee38 1ac7 	vsub.f32	s2, s17, s14
            displayValues[0] = knobs[0] * sampleLength;
   1c414:	ee27 7a87 	vmul.f32	s14, s15, s14
            sampleLength = recordPosition * leaf.invSampleRate;
   1c418:	edc8 7a00 	vstr	s15, [r8]
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c41c:	ee21 1a27 	vmul.f32	s2, s2, s15
   1c420:	ee67 0aa0 	vmul.f32	s1, s15, s1
            displayValues[0] = knobs[0] * sampleLength;
   1c424:	ed85 7a00 	vstr	s14, [r5]
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c428:	f00d f97e 	bl	29728 <LEAF_clip>
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1c42c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1c430:	edd4 6a7f 	vldr	s13, [r4, #508]	; 0x1fc
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1c434:	ed94 7a80 	vldr	s14, [r4, #512]	; 0x200
   1c438:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1c43c:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c440:	ed85 0a01 	vstr	s0, [r5, #4]
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1c444:	ee76 6ae7 	vsub.f32	s13, s13, s15
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1c448:	ee77 7a67 	vsub.f32	s15, s14, s15
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1c44c:	ee66 6aa5 	vmul.f32	s13, s13, s11
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1c450:	ee67 7a86 	vmul.f32	s15, s15, s12
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1c454:	edc5 6a02 	vstr	s13, [r5, #8]
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1c458:	fef8 7a67 	vrinta.f32	s15, s15
            if (rate < 0.0f)
   1c45c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1c460:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1c464:	f100 80c0 	bmi.w	1c5e8 <SFXSamplerBPTick+0x234>
                rate += 1.0f;
   1c468:	ee77 7aa8 	vadd.f32	s15, s15, s17
            displayValues[4] = knobs[4] * 4000.0f;
   1c46c:	ed9f 6a6a 	vldr	s12, [pc, #424]	; 1c618 <SFXSamplerBPTick+0x264>
            samplerRate = displayValues[3] * displayValues[2];
   1c470:	ee66 6aa7 	vmul.f32	s13, s13, s15
            displayValues[4] = knobs[4] * 4000.0f;
   1c474:	ed94 7a81 	vldr	s14, [r4, #516]	; 0x204
            tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
   1c478:	ed94 0a7d 	vldr	s0, [r4, #500]	; 0x1f4
            displayValues[4] = knobs[4] * 4000.0f;
   1c47c:	ee27 7a06 	vmul.f32	s14, s14, s12
            samplerRate = displayValues[3] * displayValues[2];
   1c480:	4e66      	ldr	r6, [pc, #408]	; (1c61c <SFXSamplerBPTick+0x268>)
            tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
   1c482:	ee28 0a00 	vmul.f32	s0, s16, s0
   1c486:	4866      	ldr	r0, [pc, #408]	; (1c620 <SFXSamplerBPTick+0x26c>)
            samplerRate = displayValues[3] * displayValues[2];
   1c488:	edc6 6a00 	vstr	s13, [r6]
            displayValues[4] = knobs[4] * 4000.0f;
   1c48c:	ed85 7a04 	vstr	s14, [r5, #16]
            displayValues[3] = rate;
   1c490:	edc5 7a03 	vstr	s15, [r5, #12]
            tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
   1c494:	f00b fcb4 	bl	27e00 <tExpSmooth_setDest>
            tExpSmooth_setDest(&lengthSmooth, knobs[1] * recordPosition);
   1c498:	ed94 0a7e 	vldr	s0, [r4, #504]	; 0x1f8
   1c49c:	4861      	ldr	r0, [pc, #388]	; (1c624 <SFXSamplerBPTick+0x270>)
   1c49e:	ee28 0a00 	vmul.f32	s0, s16, s0
            samplePlayStart = tExpSmooth_tick(&startSmooth);
   1c4a2:	f8df 9194 	ldr.w	r9, [pc, #404]	; 1c638 <SFXSamplerBPTick+0x284>
            tExpSmooth_setDest(&lengthSmooth, knobs[1] * recordPosition);
   1c4a6:	f00b fcab 	bl	27e00 <tExpSmooth_setDest>
            samplePlayStart = tExpSmooth_tick(&startSmooth);
   1c4aa:	485d      	ldr	r0, [pc, #372]	; (1c620 <SFXSamplerBPTick+0x26c>)
   1c4ac:	f00b fcb2 	bl	27e14 <tExpSmooth_tick>
   1c4b0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1c4b4:	485b      	ldr	r0, [pc, #364]	; (1c624 <SFXSamplerBPTick+0x270>)
   1c4b6:	f8df 8184 	ldr.w	r8, [pc, #388]	; 1c63c <SFXSamplerBPTick+0x288>
            samplePlayStart = tExpSmooth_tick(&startSmooth);
   1c4ba:	ed89 0a00 	vstr	s0, [r9]
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1c4be:	f00b fca9 	bl	27e14 <tExpSmooth_tick>
            crossfadeLength = displayValues[4];
   1c4c2:	edd5 7a04 	vldr	s15, [r5, #16]
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1c4c6:	eebd 0ac0 	vcvt.s32.f32	s0, s0
            crossfadeLength = displayValues[4];
   1c4ca:	4c57      	ldr	r4, [pc, #348]	; (1c628 <SFXSamplerBPTick+0x274>)
   1c4cc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            tSampler_setStart(&sampler, samplePlayStart);
   1c4d0:	f8d9 1000 	ldr.w	r1, [r9]
   1c4d4:	4855      	ldr	r0, [pc, #340]	; (1c62c <SFXSamplerBPTick+0x278>)
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1c4d6:	ed88 0a00 	vstr	s0, [r8]
            crossfadeLength = displayValues[4];
   1c4da:	edc4 7a00 	vstr	s15, [r4]
            tSampler_setStart(&sampler, samplePlayStart);
   1c4de:	f00f fccb 	bl	2be78 <tSampler_setStart>
            tSampler_setLength(&sampler, samplePlayLength);
   1c4e2:	f8d8 1000 	ldr.w	r1, [r8]
   1c4e6:	4851      	ldr	r0, [pc, #324]	; (1c62c <SFXSamplerBPTick+0x278>)
   1c4e8:	f010 f8d4 	bl	2c694 <tSampler_setLength>
            tSampler_setRate(&sampler, samplerRate);
   1c4ec:	ed96 0a00 	vldr	s0, [r6]
   1c4f0:	484e      	ldr	r0, [pc, #312]	; (1c62c <SFXSamplerBPTick+0x278>)
   1c4f2:	f010 f969 	bl	2c7c8 <tSampler_setRate>
            tSampler_setCrossfadeLength(&sampler, crossfadeLength);
   1c4f6:	6821      	ldr	r1, [r4, #0]
   1c4f8:	484c      	ldr	r0, [pc, #304]	; (1c62c <SFXSamplerBPTick+0x278>)
   1c4fa:	f00f fc4b 	bl	2bd94 <tSampler_setCrossfadeLength>
            tBuffer_tick(&buff, input[1]);
   1c4fe:	ed97 0a01 	vldr	s0, [r7, #4]
   1c502:	4840      	ldr	r0, [pc, #256]	; (1c604 <SFXSamplerBPTick+0x250>)
   1c504:	f00f fb48 	bl	2bb98 <tBuffer_tick>
            sample = tanhf(tSampler_tick(&sampler));
   1c508:	4848      	ldr	r0, [pc, #288]	; (1c62c <SFXSamplerBPTick+0x278>)
   1c50a:	f00f fde1 	bl	2c0d0 <tSampler_tick>
   1c50e:	f010 fe25 	bl	2d15c <tanhf>
            input[0] = sample;
   1c512:	ed87 0a00 	vstr	s0, [r7]
            input[1] = sample;
   1c516:	ed87 0a01 	vstr	s0, [r7, #4]
        }
   1c51a:	ecbd 8b02 	vpop	{d8}
   1c51e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (samplePlaying)
   1c522:	4b43      	ldr	r3, [pc, #268]	; (1c630 <SFXSamplerBPTick+0x27c>)
   1c524:	781a      	ldrb	r2, [r3, #0]
   1c526:	2a00      	cmp	r2, #0
   1c528:	d140      	bne.n	1c5ac <SFXSamplerBPTick+0x1f8>
                    samplePlaying = 1;
   1c52a:	2201      	movs	r2, #1
                    tSampler_play(&sampler);
   1c52c:	483f      	ldr	r0, [pc, #252]	; (1c62c <SFXSamplerBPTick+0x278>)
   1c52e:	f8df 8104 	ldr.w	r8, [pc, #260]	; 1c634 <SFXSamplerBPTick+0x280>
   1c532:	4c35      	ldr	r4, [pc, #212]	; (1c608 <SFXSamplerBPTick+0x254>)
                    samplePlaying = 1;
   1c534:	701a      	strb	r2, [r3, #0]
   1c536:	4d35      	ldr	r5, [pc, #212]	; (1c60c <SFXSamplerBPTick+0x258>)
                    tSampler_play(&sampler);
   1c538:	f00f fc42 	bl	2bdc0 <tSampler_play>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1c53c:	2300      	movs	r3, #0
   1c53e:	7733      	strb	r3, [r6, #28]
            if (buttonActionsSFX[ButtonB][ActionPress])
   1c540:	7e33      	ldrb	r3, [r6, #24]
   1c542:	2b00      	cmp	r3, #0
   1c544:	f43f af4d 	beq.w	1c3e2 <SFXSamplerBPTick+0x2e>
                bpMode = !bpMode;
   1c548:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 1c640 <SFXSamplerBPTick+0x28c>
                tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
   1c54c:	4837      	ldr	r0, [pc, #220]	; (1c62c <SFXSamplerBPTick+0x278>)
                bpMode = !bpMode;
   1c54e:	f8d9 3000 	ldr.w	r3, [r9]
   1c552:	fab3 f383 	clz	r3, r3
   1c556:	095b      	lsrs	r3, r3, #5
                tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
   1c558:	1c59      	adds	r1, r3, #1
                bpMode = !bpMode;
   1c55a:	f8c9 3000 	str.w	r3, [r9]
                tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
   1c55e:	f00f fc15 	bl	2bd8c <tSampler_setMode>
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1c562:	2300      	movs	r3, #0
                setLED_B(bpMode);
   1c564:	f899 0000 	ldrb.w	r0, [r9]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1c568:	7633      	strb	r3, [r6, #24]
                setLED_B(bpMode);
   1c56a:	f7fc ff9f 	bl	194ac <setLED_B>
            if (buttonActionsSFX[ButtonA][ActionPress])
   1c56e:	7d33      	ldrb	r3, [r6, #20]
   1c570:	2b00      	cmp	r3, #0
   1c572:	f43f af3a 	beq.w	1c3ea <SFXSamplerBPTick+0x36>
                tSampler_stop(&sampler);
   1c576:	482d      	ldr	r0, [pc, #180]	; (1c62c <SFXSamplerBPTick+0x278>)
   1c578:	f00f fc72 	bl	2be60 <tSampler_stop>
                tBuffer_record(&buff);
   1c57c:	4821      	ldr	r0, [pc, #132]	; (1c604 <SFXSamplerBPTick+0x250>)
   1c57e:	f00f fb3b 	bl	2bbf8 <tBuffer_record>
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c582:	2300      	movs	r3, #0
                setLED_A(1);
   1c584:	2001      	movs	r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c586:	7533      	strb	r3, [r6, #20]
                setLED_A(1);
   1c588:	f7fc ff82 	bl	19490 <setLED_A>
            if (buttonActionsSFX[ButtonA][ActionRelease])
   1c58c:	7d73      	ldrb	r3, [r6, #21]
   1c58e:	2b00      	cmp	r3, #0
   1c590:	f43f af2f 	beq.w	1c3f2 <SFXSamplerBPTick+0x3e>
                tBuffer_stop(&buff);
   1c594:	481b      	ldr	r0, [pc, #108]	; (1c604 <SFXSamplerBPTick+0x250>)
   1c596:	f00f fb35 	bl	2bc04 <tBuffer_stop>
                if (samplePlaying) tSampler_play(&sampler);
   1c59a:	4b25      	ldr	r3, [pc, #148]	; (1c630 <SFXSamplerBPTick+0x27c>)
   1c59c:	781b      	ldrb	r3, [r3, #0]
   1c59e:	bb53      	cbnz	r3, 1c5f6 <SFXSamplerBPTick+0x242>
                buttonActionsSFX[ButtonA][ActionRelease] = 0;
   1c5a0:	2300      	movs	r3, #0
                setLED_A(0);
   1c5a2:	4618      	mov	r0, r3
                buttonActionsSFX[ButtonA][ActionRelease] = 0;
   1c5a4:	7573      	strb	r3, [r6, #21]
                setLED_A(0);
   1c5a6:	f7fc ff73 	bl	19490 <setLED_A>
   1c5aa:	e722      	b.n	1c3f2 <SFXSamplerBPTick+0x3e>
                    samplePlaying = 0;
   1c5ac:	2200      	movs	r2, #0
                    tSampler_stop(&sampler);
   1c5ae:	481f      	ldr	r0, [pc, #124]	; (1c62c <SFXSamplerBPTick+0x278>)
                    displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c5b0:	4c15      	ldr	r4, [pc, #84]	; (1c608 <SFXSamplerBPTick+0x254>)
                    samplePlaying = 0;
   1c5b2:	701a      	strb	r2, [r3, #0]
                    tSampler_stop(&sampler);
   1c5b4:	f00f fc54 	bl	2be60 <tSampler_stop>
                    displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c5b8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1c5bc:	ed94 1a7d 	vldr	s2, [r4, #500]	; 0x1f4
   1c5c0:	f8df 8070 	ldr.w	r8, [pc, #112]	; 1c634 <SFXSamplerBPTick+0x280>
   1c5c4:	edd4 0a7e 	vldr	s1, [r4, #504]	; 0x1f8
   1c5c8:	ee77 7ac1 	vsub.f32	s15, s15, s2
   1c5cc:	ed98 1a00 	vldr	s2, [r8]
   1c5d0:	4d0e      	ldr	r5, [pc, #56]	; (1c60c <SFXSamplerBPTick+0x258>)
   1c5d2:	ee61 0a20 	vmul.f32	s1, s2, s1
   1c5d6:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 1c614 <SFXSamplerBPTick+0x260>
   1c5da:	ee27 1a81 	vmul.f32	s2, s15, s2
   1c5de:	f00d f8a3 	bl	29728 <LEAF_clip>
   1c5e2:	ed85 0a01 	vstr	s0, [r5, #4]
   1c5e6:	e7a9      	b.n	1c53c <SFXSamplerBPTick+0x188>
                (rate = 1.0f / fabsf(rate-1.0f));
   1c5e8:	ee77 7ae8 	vsub.f32	s15, s15, s17
   1c5ec:	eeb0 7ae7 	vabs.f32	s14, s15
   1c5f0:	eec8 7a87 	vdiv.f32	s15, s17, s14
   1c5f4:	e73a      	b.n	1c46c <SFXSamplerBPTick+0xb8>
                if (samplePlaying) tSampler_play(&sampler);
   1c5f6:	480d      	ldr	r0, [pc, #52]	; (1c62c <SFXSamplerBPTick+0x278>)
   1c5f8:	f00f fbe2 	bl	2bdc0 <tSampler_play>
   1c5fc:	e7d0      	b.n	1c5a0 <SFXSamplerBPTick+0x1ec>
   1c5fe:	bf00      	nop
   1c600:	020fafac 	.word	0x020fafac
   1c604:	020e5eb8 	.word	0x020e5eb8
   1c608:	020e55d8 	.word	0x020e55d8
   1c60c:	020fb05c 	.word	0x020fb05c
   1c610:	020fbd68 	.word	0x020fbd68
   1c614:	00000000 	.word	0x00000000
   1c618:	457a0000 	.word	0x457a0000
   1c61c:	00062804 	.word	0x00062804
   1c620:	020fa04c 	.word	0x020fa04c
   1c624:	020f98ec 	.word	0x020f98ec
   1c628:	020e2e2c 	.word	0x020e2e2c
   1c62c:	020f9b1c 	.word	0x020f9b1c
   1c630:	00062800 	.word	0x00062800
   1c634:	020e2ec4 	.word	0x020e2ec4
   1c638:	020e2ecc 	.word	0x020e2ecc
   1c63c:	020e2ec8 	.word	0x020e2ec8
   1c640:	020e2dec 	.word	0x020e2dec

0001c644 <SFXSamplerBPFree>:
        {
   1c644:	b508      	push	{r3, lr}
            tBuffer_free(&buff);
   1c646:	4807      	ldr	r0, [pc, #28]	; (1c664 <SFXSamplerBPFree+0x20>)
   1c648:	f00f fa9a 	bl	2bb80 <tBuffer_free>
            tSampler_free(&sampler);
   1c64c:	4806      	ldr	r0, [pc, #24]	; (1c668 <SFXSamplerBPFree+0x24>)
   1c64e:	f00f fb91 	bl	2bd74 <tSampler_free>
            tExpSmooth_free(&startSmooth);
   1c652:	4806      	ldr	r0, [pc, #24]	; (1c66c <SFXSamplerBPFree+0x28>)
   1c654:	f00b fbbe 	bl	27dd4 <tExpSmooth_free>
            tExpSmooth_free(&lengthSmooth);
   1c658:	4805      	ldr	r0, [pc, #20]	; (1c670 <SFXSamplerBPFree+0x2c>)
        }
   1c65a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tExpSmooth_free(&lengthSmooth);
   1c65e:	f00b bbb9 	b.w	27dd4 <tExpSmooth_free>
   1c662:	bf00      	nop
   1c664:	020e5eb8 	.word	0x020e5eb8
   1c668:	020f9b1c 	.word	0x020f9b1c
   1c66c:	020fa04c 	.word	0x020fa04c
   1c670:	020f98ec 	.word	0x020f98ec

0001c674 <SFXSamplerKAlloc>:
        {
   1c674:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c678:	4b41      	ldr	r3, [pc, #260]	; (1c780 <SFXSamplerKAlloc+0x10c>)
            leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
   1c67a:	2200      	movs	r2, #0
   1c67c:	f8df b14c 	ldr.w	fp, [pc, #332]	; 1c7cc <SFXSamplerKAlloc+0x158>
            currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
   1c680:	2018      	movs	r0, #24
   1c682:	4940      	ldr	r1, [pc, #256]	; (1c784 <SFXSamplerKAlloc+0x110>)
   1c684:	4614      	mov	r4, r2
   1c686:	f8df a148 	ldr.w	sl, [pc, #328]	; 1c7d0 <SFXSamplerKAlloc+0x15c>
   1c68a:	f8df 9148 	ldr.w	r9, [pc, #328]	; 1c7d4 <SFXSamplerKAlloc+0x160>
   1c68e:	f8df 8148 	ldr.w	r8, [pc, #328]	; 1c7d8 <SFXSamplerKAlloc+0x164>
                tSampler_initToPool(&keySampler[i], &keyBuff[i], &smallPool);
   1c692:	4f3d      	ldr	r7, [pc, #244]	; (1c788 <SFXSamplerKAlloc+0x114>)
            leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
   1c694:	f8cb 2014 	str.w	r2, [fp, #20]
        {
   1c698:	ed2d 8b04 	vpush	{d8-d9}
   1c69c:	b085      	sub	sp, #20
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1c69e:	ed9f 9a3b 	vldr	s18, [pc, #236]	; 1c78c <SFXSamplerKAlloc+0x118>
                samplePlayStarts[i] = 0;
   1c6a2:	ed9f 8a3b 	vldr	s16, [pc, #236]	; 1c790 <SFXSamplerKAlloc+0x11c>
   1c6a6:	9303      	str	r3, [sp, #12]
   1c6a8:	4b3a      	ldr	r3, [pc, #232]	; (1c794 <SFXSamplerKAlloc+0x120>)
                crossfadeLengths[i] = 1000;
   1c6aa:	eddf 8a3b 	vldr	s17, [pc, #236]	; 1c798 <SFXSamplerKAlloc+0x124>
   1c6ae:	9300      	str	r3, [sp, #0]
   1c6b0:	4b3a      	ldr	r3, [pc, #232]	; (1c79c <SFXSamplerKAlloc+0x128>)
            currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
   1c6b2:	6008      	str	r0, [r1, #0]
   1c6b4:	9302      	str	r3, [sp, #8]
   1c6b6:	4b3a      	ldr	r3, [pc, #232]	; (1c7a0 <SFXSamplerKAlloc+0x12c>)
   1c6b8:	9301      	str	r3, [sp, #4]
                tBuffer_initToPool(&keyBuff[i], leaf.sampleRate * 3.5f, &largePool);
   1c6ba:	eef0 7a0c 	vmov.f32	s15, #12	; 0x40600000  3.5
   1c6be:	ed9b 7a00 	vldr	s14, [fp]
   1c6c2:	4b38      	ldr	r3, [pc, #224]	; (1c7a4 <SFXSamplerKAlloc+0x130>)
   1c6c4:	4a38      	ldr	r2, [pc, #224]	; (1c7a8 <SFXSamplerKAlloc+0x134>)
   1c6c6:	ee67 7a27 	vmul.f32	s15, s14, s15
   1c6ca:	191d      	adds	r5, r3, r4
   1c6cc:	4b37      	ldr	r3, [pc, #220]	; (1c7ac <SFXSamplerKAlloc+0x138>)
   1c6ce:	4628      	mov	r0, r5
   1c6d0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1c6d4:	191e      	adds	r6, r3, r4
   1c6d6:	ee17 1a90 	vmov	r1, s15
   1c6da:	f00f fa39 	bl	2bb50 <tBuffer_initToPool>
                tBuffer_setRecordMode(&keyBuff[i], RecordOneShot);
   1c6de:	4628      	mov	r0, r5
   1c6e0:	2100      	movs	r1, #0
   1c6e2:	f00f fa9b 	bl	2bc1c <tBuffer_setRecordMode>
                tSampler_initToPool(&keySampler[i], &keyBuff[i], &smallPool);
   1c6e6:	463a      	mov	r2, r7
   1c6e8:	4629      	mov	r1, r5
   1c6ea:	4630      	mov	r0, r6
   1c6ec:	f00f faf6 	bl	2bcdc <tSampler_initToPool>
                tSampler_setMode(&keySampler[i], PlayLoop);
   1c6f0:	4630      	mov	r0, r6
   1c6f2:	2101      	movs	r1, #1
   1c6f4:	f00f fb4a 	bl	2bd8c <tSampler_setMode>
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1c6f8:	4b2d      	ldr	r3, [pc, #180]	; (1c7b0 <SFXSamplerKAlloc+0x13c>)
   1c6fa:	4639      	mov	r1, r7
   1c6fc:	eef0 0a49 	vmov.f32	s1, s18
   1c700:	1918      	adds	r0, r3, r4
                samplePlayStarts[i] = 0;
   1c702:	9b03      	ldr	r3, [sp, #12]
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1c704:	ed9f 0a22 	vldr	s0, [pc, #136]	; 1c790 <SFXSamplerKAlloc+0x11c>
                samplePlayStarts[i] = 0;
   1c708:	eca3 8a01 	vstmia	r3!, {s16}
   1c70c:	9303      	str	r3, [sp, #12]
                samplePlayLengths[i] = 0;
   1c70e:	9b00      	ldr	r3, [sp, #0]
   1c710:	eca3 8a01 	vstmia	r3!, {s16}
   1c714:	9300      	str	r3, [sp, #0]
                detectedAttackPos[i] = 0;
   1c716:	9b02      	ldr	r3, [sp, #8]
   1c718:	461a      	mov	r2, r3
   1c71a:	2300      	movs	r3, #0
   1c71c:	f842 3f04 	str.w	r3, [r2, #4]!
                crossfadeLengths[i] = 1000;
   1c720:	9b01      	ldr	r3, [sp, #4]
                detectedAttackPos[i] = 0;
   1c722:	9202      	str	r2, [sp, #8]
                crossfadeLengths[i] = 1000;
   1c724:	ece3 8a01 	vstmia	r3!, {s17}
   1c728:	9301      	str	r3, [sp, #4]
                samplerKeyHeld[i] = 0;
   1c72a:	f04f 0300 	mov.w	r3, #0
   1c72e:	f80a 3f01 	strb.w	r3, [sl, #1]!
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1c732:	f00b fb29 	bl	27d88 <tExpSmooth_initToPool>
                loopOns[i] = 1;
   1c736:	2101      	movs	r1, #1
   1c738:	4b1e      	ldr	r3, [pc, #120]	; (1c7b4 <SFXSamplerKAlloc+0x140>)
                sampleRates[i] = 1.0f;
   1c73a:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
                loopOns[i] = 1;
   1c73e:	5119      	str	r1, [r3, r4]
   1c740:	3404      	adds	r4, #4
                sampleRates[i] = 1.0f;
   1c742:	f849 2b04 	str.w	r2, [r9], #4
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1c746:	2cc4      	cmp	r4, #196	; 0xc4
                sampleRatesMult[i] = 1.0f;
   1c748:	f848 2b04 	str.w	r2, [r8], #4
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1c74c:	d1b5      	bne.n	1c6ba <SFXSamplerKAlloc+0x46>
            tSimplePoly_setNumVoices(&poly, NUM_SAMPLER_VOICES);
   1c74e:	2106      	movs	r1, #6
   1c750:	4819      	ldr	r0, [pc, #100]	; (1c7b8 <SFXSamplerKAlloc+0x144>)
   1c752:	f00d fe49 	bl	2a3e8 <tSimplePoly_setNumVoices>
            setLED_B(controlAllKeys);
   1c756:	4919      	ldr	r1, [pc, #100]	; (1c7bc <SFXSamplerKAlloc+0x148>)
                waitingForDeactivation[i] = -1;
   1c758:	4b19      	ldr	r3, [pc, #100]	; (1c7c0 <SFXSamplerKAlloc+0x14c>)
   1c75a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
            setLED_B(controlAllKeys);
   1c75e:	7808      	ldrb	r0, [r1, #0]
                waitingForDeactivation[i] = -1;
   1c760:	e9c3 2200 	strd	r2, r2, [r3]
   1c764:	e9c3 2202 	strd	r2, r2, [r3, #8]
   1c768:	e9c3 2204 	strd	r2, r2, [r3, #16]
            setLED_B(controlAllKeys);
   1c76c:	f7fc fe9e 	bl	194ac <setLED_B>
            samp_thresh = 0.0002f;
   1c770:	4b14      	ldr	r3, [pc, #80]	; (1c7c4 <SFXSamplerKAlloc+0x150>)
   1c772:	4a15      	ldr	r2, [pc, #84]	; (1c7c8 <SFXSamplerKAlloc+0x154>)
   1c774:	601a      	str	r2, [r3, #0]
        }
   1c776:	b005      	add	sp, #20
   1c778:	ecbd 8b04 	vpop	{d8-d9}
   1c77c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c780:	020f9c0c 	.word	0x020f9c0c
   1c784:	0006277c 	.word	0x0006277c
   1c788:	020fabc0 	.word	0x020fabc0
   1c78c:	3d23d70a 	.word	0x3d23d70a
   1c790:	00000000 	.word	0x00000000
   1c794:	020e5148 	.word	0x020e5148
   1c798:	447a0000 	.word	0x447a0000
   1c79c:	020fac34 	.word	0x020fac34
   1c7a0:	020fa050 	.word	0x020fa050
   1c7a4:	020faa2c 	.word	0x020faa2c
   1c7a8:	020f9dd8 	.word	0x020f9dd8
   1c7ac:	020e5df4 	.word	0x020e5df4
   1c7b0:	020e4f54 	.word	0x020e4f54
   1c7b4:	020e5514 	.word	0x020e5514
   1c7b8:	020f9de8 	.word	0x020f9de8
   1c7bc:	020e2e28 	.word	0x020e2e28
   1c7c0:	020f9edc 	.word	0x020f9edc
   1c7c4:	020e2ebc 	.word	0x020e2ebc
   1c7c8:	3951b717 	.word	0x3951b717
   1c7cc:	020fbd68 	.word	0x020fbd68
   1c7d0:	020f9fff 	.word	0x020f9fff
   1c7d4:	020e5230 	.word	0x020e5230
   1c7d8:	020fa118 	.word	0x020fa118

0001c7dc <SFXSamplerKFrame>:
            int currentSamplerKey = currentSamplerKeyGlobal;
   1c7dc:	4aa5      	ldr	r2, [pc, #660]	; (1ca74 <SFXSamplerKFrame+0x298>)
            if (samplerKeyHeld[currentSamplerKey])
   1c7de:	4ba6      	ldr	r3, [pc, #664]	; (1ca78 <SFXSamplerKFrame+0x29c>)
        {
   1c7e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c7e4:	ed2d 8b04 	vpush	{d8-d9}
            int currentSamplerKey = currentSamplerKeyGlobal;
   1c7e8:	6814      	ldr	r4, [r2, #0]
        {
   1c7ea:	b083      	sub	sp, #12
            if (samplerKeyHeld[currentSamplerKey])
   1c7ec:	5d1b      	ldrb	r3, [r3, r4]
   1c7ee:	2b00      	cmp	r3, #0
   1c7f0:	f040 8101 	bne.w	1c9f6 <SFXSamplerKFrame+0x21a>
            if (buttonActionsSFX[ButtonA][ActionPress])
   1c7f4:	4da1      	ldr	r5, [pc, #644]	; (1ca7c <SFXSamplerKFrame+0x2a0>)
   1c7f6:	7d2b      	ldrb	r3, [r5, #20]
   1c7f8:	b163      	cbz	r3, 1c814 <SFXSamplerKFrame+0x38>
                tBuffer_setRecordPosition(&keyBuff[currentSamplerKey],0);
   1c7fa:	48a1      	ldr	r0, [pc, #644]	; (1ca80 <SFXSamplerKFrame+0x2a4>)
   1c7fc:	2100      	movs	r1, #0
   1c7fe:	eb00 0684 	add.w	r6, r0, r4, lsl #2
   1c802:	4630      	mov	r0, r6
   1c804:	f00f fa06 	bl	2bc14 <tBuffer_setRecordPosition>
                tBuffer_setRecordedLength(&keyBuff[currentSamplerKey],0);
   1c808:	4630      	mov	r0, r6
   1c80a:	2100      	movs	r1, #0
   1c80c:	f00f fa0e 	bl	2bc2c <tBuffer_setRecordedLength>
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c810:	2300      	movs	r3, #0
   1c812:	752b      	strb	r3, [r5, #20]
            if (buttonActionsSFX[ButtonB][ActionPress])
   1c814:	7e2b      	ldrb	r3, [r5, #24]
   1c816:	b153      	cbz	r3, 1c82e <SFXSamplerKFrame+0x52>
                controlAllKeys = !controlAllKeys;
   1c818:	4a9a      	ldr	r2, [pc, #616]	; (1ca84 <SFXSamplerKFrame+0x2a8>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1c81a:	2100      	movs	r1, #0
                controlAllKeys = !controlAllKeys;
   1c81c:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1c81e:	7629      	strb	r1, [r5, #24]
                controlAllKeys = !controlAllKeys;
   1c820:	fab3 f383 	clz	r3, r3
   1c824:	095b      	lsrs	r3, r3, #5
                setLED_B(controlAllKeys);
   1c826:	4618      	mov	r0, r3
                controlAllKeys = !controlAllKeys;
   1c828:	6013      	str	r3, [r2, #0]
                setLED_B(controlAllKeys);
   1c82a:	f7fc fe3f 	bl	194ac <setLED_B>
            if (buttonActionsSFX[ButtonC][ActionPress])
   1c82e:	7f2b      	ldrb	r3, [r5, #28]
   1c830:	2b00      	cmp	r3, #0
   1c832:	f000 80c2 	beq.w	1c9ba <SFXSamplerKFrame+0x1de>
                if (!controlAllKeys)
   1c836:	4a93      	ldr	r2, [pc, #588]	; (1ca84 <SFXSamplerKFrame+0x2a8>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1c838:	2300      	movs	r3, #0
                if (!controlAllKeys)
   1c83a:	f8d2 9000 	ldr.w	r9, [r2]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1c83e:	772b      	strb	r3, [r5, #28]
                if (!controlAllKeys)
   1c840:	f1b9 0f00 	cmp.w	r9, #0
   1c844:	d053      	beq.n	1c8ee <SFXSamplerKFrame+0x112>
   1c846:	2306      	movs	r3, #6
   1c848:	f8df 9268 	ldr.w	r9, [pc, #616]	; 1cab4 <SFXSamplerKFrame+0x2d8>
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c84c:	eddf 8a8e 	vldr	s17, [pc, #568]	; 1ca88 <SFXSamplerKFrame+0x2ac>
                                float previousPower = 0.0f;
   1c850:	ed9f 9a8e 	vldr	s18, [pc, #568]	; 1ca8c <SFXSamplerKFrame+0x2b0>
   1c854:	9301      	str	r3, [sp, #4]
   1c856:	4f8a      	ldr	r7, [pc, #552]	; (1ca80 <SFXSamplerKFrame+0x2a4>)
   1c858:	4e8d      	ldr	r6, [pc, #564]	; (1ca90 <SFXSamplerKFrame+0x2b4>)
   1c85a:	f8df 8238 	ldr.w	r8, [pc, #568]	; 1ca94 <SFXSamplerKFrame+0x2b8>
   1c85e:	e01c      	b.n	1c89a <SFXSamplerKFrame+0xbe>
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c860:	eeb4 8ac0 	vcmpe.f32	s16, s0
   1c864:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1c868:	d53b      	bpl.n	1c8e2 <SFXSamplerKFrame+0x106>
                                        int thePos = (i + detectedAttackPos[key] - 480) % buffLength;
   1c86a:	6833      	ldr	r3, [r6, #0]
   1c86c:	441d      	add	r5, r3
   1c86e:	f5a5 75f0 	sub.w	r5, r5, #480	; 0x1e0
   1c872:	fb95 f3f4 	sdiv	r3, r5, r4
   1c876:	fb04 5513 	mls	r5, r4, r3, r5
   1c87a:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
                                        samplePlayStarts[key] = thePos;
   1c87e:	ee07 5a90 	vmov	s15, r5
                                        detectedAttackPos[key] = thePos;
   1c882:	6035      	str	r5, [r6, #0]
                                        samplePlayStarts[key] = thePos;
   1c884:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1c888:	edc8 7a00 	vstr	s15, [r8]
   1c88c:	3604      	adds	r6, #4
   1c88e:	3704      	adds	r7, #4
   1c890:	f108 0804 	add.w	r8, r8, #4
                        for (int key = 0; key < NUM_SAMPLER_KEYS; key++)
   1c894:	45b1      	cmp	r9, r6
   1c896:	f000 80a4 	beq.w	1c9e2 <SFXSamplerKFrame+0x206>
                            int buffLength = tBuffer_getRecordedLength(&keyBuff[key]);
   1c89a:	4638      	mov	r0, r7
   1c89c:	f00f f9c2 	bl	2bc24 <tBuffer_getRecordedLength>
                            if (buffLength > 0)
   1c8a0:	1e04      	subs	r4, r0, #0
   1c8a2:	ddf3      	ble.n	1c88c <SFXSamplerKFrame+0xb0>
                                if (detectedAttackPos[key] > 0)
   1c8a4:	6833      	ldr	r3, [r6, #0]
   1c8a6:	2b00      	cmp	r3, #0
   1c8a8:	f300 808c 	bgt.w	1c9c4 <SFXSamplerKFrame+0x1e8>
                                float previousPower = 0.0f;
   1c8ac:	eeb0 0a49 	vmov.f32	s0, s18
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c8b0:	ee30 8a28 	vadd.f32	s16, s0, s17
        {
   1c8b4:	f04f 0b01 	mov.w	fp, #1
   1c8b8:	f8df a1fc 	ldr.w	sl, [pc, #508]	; 1cab8 <SFXSamplerKFrame+0x2dc>
   1c8bc:	f10b 35ff 	add.w	r5, fp, #4294967295	; 0xffffffff
                                    float testSample = tBuffer_get(&keyBuff[key], (i + detectedAttackPos[key]) % buffLength);
   1c8c0:	4638      	mov	r0, r7
   1c8c2:	442b      	add	r3, r5
   1c8c4:	fb93 f1f4 	sdiv	r1, r3, r4
   1c8c8:	fb04 3111 	mls	r1, r4, r1, r3
   1c8cc:	f00f f982 	bl	2bbd4 <tBuffer_get>
                                    currentPower = testSample*testSample;
   1c8d0:	ee20 0a00 	vmul.f32	s0, s0, s0
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c8d4:	edda 7a00 	vldr	s15, [sl]
   1c8d8:	eef4 7ac0 	vcmpe.f32	s15, s0
   1c8dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1c8e0:	d4be      	bmi.n	1c860 <SFXSamplerKFrame+0x84>
                                    if (i >= buffLength)
   1c8e2:	455c      	cmp	r4, fp
   1c8e4:	ddd2      	ble.n	1c88c <SFXSamplerKFrame+0xb0>
   1c8e6:	f10b 0b01 	add.w	fp, fp, #1
   1c8ea:	6833      	ldr	r3, [r6, #0]
   1c8ec:	e7e6      	b.n	1c8bc <SFXSamplerKFrame+0xe0>
                    int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1c8ee:	ea4f 0884 	mov.w	r8, r4, lsl #2
   1c8f2:	4f63      	ldr	r7, [pc, #396]	; (1ca80 <SFXSamplerKFrame+0x2a4>)
                    if (detectedAttackPos[currentSamplerKey] > 0)
   1c8f4:	4e66      	ldr	r6, [pc, #408]	; (1ca90 <SFXSamplerKFrame+0x2b4>)
                    int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1c8f6:	4447      	add	r7, r8
   1c8f8:	4638      	mov	r0, r7
   1c8fa:	f00f f993 	bl	2bc24 <tBuffer_getRecordedLength>
                    if (detectedAttackPos[currentSamplerKey] > 0)
   1c8fe:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
                    int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1c902:	4605      	mov	r5, r0
                    if (detectedAttackPos[currentSamplerKey] > 0)
   1c904:	2b00      	cmp	r3, #0
   1c906:	f300 80a4 	bgt.w	1ca52 <SFXSamplerKFrame+0x276>
                    float previousPower = 0.0f;
   1c90a:	ed9f 0a60 	vldr	s0, [pc, #384]	; 1ca8c <SFXSamplerKFrame+0x2b0>
                        if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c90e:	ed9f 8a5e 	vldr	s16, [pc, #376]	; 1ca88 <SFXSamplerKFrame+0x2ac>
   1c912:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 1cab8 <SFXSamplerKFrame+0x2dc>
   1c916:	ee30 8a08 	vadd.f32	s16, s0, s16
                        float testSample = tBuffer_get(&keyBuff[currentSamplerKey], (i + detectedAttackPos[currentSamplerKey]) % buffLength);
   1c91a:	444b      	add	r3, r9
   1c91c:	4638      	mov	r0, r7
   1c91e:	f109 0b01 	add.w	fp, r9, #1
   1c922:	fb93 f1f5 	sdiv	r1, r3, r5
   1c926:	fb05 3111 	mls	r1, r5, r1, r3
   1c92a:	f00f f953 	bl	2bbd4 <tBuffer_get>
                        currentPower = testSample*testSample;
   1c92e:	ee20 0a00 	vmul.f32	s0, s0, s0
                        if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c932:	edda 7a00 	vldr	s15, [sl]
   1c936:	eef4 7ac0 	vcmpe.f32	s15, s0
   1c93a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1c93e:	f140 8082 	bpl.w	1ca46 <SFXSamplerKFrame+0x26a>
   1c942:	eeb4 8ac0 	vcmpe.f32	s16, s0
   1c946:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1c94a:	d57c      	bpl.n	1ca46 <SFXSamplerKFrame+0x26a>
                            int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
   1c94c:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
                            OLEDclearLine(SecondLine);
   1c950:	2001      	movs	r0, #1
                            samplePlayStarts[currentSamplerKey] = thePos;
   1c952:	4a50      	ldr	r2, [pc, #320]	; (1ca94 <SFXSamplerKFrame+0x2b8>)
                            int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
   1c954:	444b      	add	r3, r9
                            samplePlayStarts[currentSamplerKey] = thePos;
   1c956:	4490      	add	r8, r2
                            int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
   1c958:	f5a3 72f0 	sub.w	r2, r3, #480	; 0x1e0
   1c95c:	fb92 f3f5 	sdiv	r3, r2, r5
   1c960:	fb05 2313 	mls	r3, r5, r3, r2
   1c964:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
                            samplePlayStarts[currentSamplerKey] = thePos;
   1c968:	ee07 3a90 	vmov	s15, r3
                            detectedAttackPos[currentSamplerKey] = thePos;
   1c96c:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
                            samplePlayStarts[currentSamplerKey] = thePos;
   1c970:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1c974:	edc8 7a00 	vstr	s15, [r8]
                            OLEDclearLine(SecondLine);
   1c978:	f7fc ffb4 	bl	198e4 <OLEDclearLine>
                            OLEDwriteString("ATKDETECT ", 10, 0, SecondLine);
   1c97c:	2200      	movs	r2, #0
   1c97e:	210a      	movs	r1, #10
   1c980:	2301      	movs	r3, #1
   1c982:	4845      	ldr	r0, [pc, #276]	; (1ca98 <SFXSamplerKFrame+0x2bc>)
   1c984:	f7fc ffc2 	bl	1990c <OLEDwriteString>
                            OLEDwriteFloat((samplePlayStarts[currentSamplerKey] / (float)buffLength) * (buffLength * leaf.invSampleRate), OLEDgetCursor(), SecondLine);
   1c988:	ee07 5a90 	vmov	s15, r5
   1c98c:	ed98 7a00 	vldr	s14, [r8]
   1c990:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1c994:	4b41      	ldr	r3, [pc, #260]	; (1ca9c <SFXSamplerKFrame+0x2c0>)
   1c996:	ee87 8a27 	vdiv.f32	s16, s14, s15
   1c99a:	ed93 7a01 	vldr	s14, [r3, #4]
   1c99e:	ee67 7a87 	vmul.f32	s15, s15, s14
   1c9a2:	ee28 8a27 	vmul.f32	s16, s16, s15
   1c9a6:	f7fd fa2d 	bl	19e04 <OLEDgetCursor>
   1c9aa:	2101      	movs	r1, #1
   1c9ac:	b2c0      	uxtb	r0, r0
   1c9ae:	eeb0 0a48 	vmov.f32	s0, s16
   1c9b2:	f7fd f869 	bl	19a88 <OLEDwriteFloat>
                        if (i >= buffLength)
   1c9b6:	455d      	cmp	r5, fp
   1c9b8:	dd34      	ble.n	1ca24 <SFXSamplerKFrame+0x248>
        }
   1c9ba:	b003      	add	sp, #12
   1c9bc:	ecbd 8b04 	vpop	{d8-d9}
   1c9c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                    previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
   1c9c4:	f241 22bf 	movw	r2, #4799	; 0x12bf
                                    detectedAttackPos[key] += 4800;
   1c9c8:	f503 5196 	add.w	r1, r3, #4800	; 0x12c0
                                    previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
   1c9cc:	4638      	mov	r0, r7
   1c9ce:	441a      	add	r2, r3
                                    detectedAttackPos[key] += 4800;
   1c9d0:	6031      	str	r1, [r6, #0]
                                    previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
   1c9d2:	fb92 f1f4 	sdiv	r1, r2, r4
   1c9d6:	fb04 2111 	mls	r1, r4, r1, r2
   1c9da:	f00f f8fb 	bl	2bbd4 <tBuffer_get>
   1c9de:	6833      	ldr	r3, [r6, #0]
   1c9e0:	e766      	b.n	1c8b0 <SFXSamplerKFrame+0xd4>
                    for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1c9e2:	9b01      	ldr	r3, [sp, #4]
   1c9e4:	3b01      	subs	r3, #1
   1c9e6:	9301      	str	r3, [sp, #4]
   1c9e8:	f47f af35 	bne.w	1c856 <SFXSamplerKFrame+0x7a>
        }
   1c9ec:	b003      	add	sp, #12
   1c9ee:	ecbd 8b04 	vpop	{d8-d9}
   1c9f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if ((tBuffer_isActive(&keyBuff[currentSamplerKey])) || (currentSamplerKey != prevSamplerKey)) //only write if recording
   1c9f6:	4822      	ldr	r0, [pc, #136]	; (1ca80 <SFXSamplerKFrame+0x2a4>)
   1c9f8:	eb00 0084 	add.w	r0, r0, r4, lsl #2
   1c9fc:	f00f f91a 	bl	2bc34 <tBuffer_isActive>
   1ca00:	4b27      	ldr	r3, [pc, #156]	; (1caa0 <SFXSamplerKFrame+0x2c4>)
   1ca02:	b158      	cbz	r0, 1ca1c <SFXSamplerKFrame+0x240>
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
   1ca04:	4a27      	ldr	r2, [pc, #156]	; (1caa4 <SFXSamplerKFrame+0x2c8>)
   1ca06:	2101      	movs	r1, #1
                    writeButtonFlag = ExtraMessage;
   1ca08:	4827      	ldr	r0, [pc, #156]	; (1caa8 <SFXSamplerKFrame+0x2cc>)
   1ca0a:	250a      	movs	r5, #10
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
   1ca0c:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
                    writeActionFlag = ActionHoldContinuous;
   1ca10:	2103      	movs	r1, #3
   1ca12:	4a26      	ldr	r2, [pc, #152]	; (1caac <SFXSamplerKFrame+0x2d0>)
                    writeButtonFlag = ExtraMessage;
   1ca14:	7005      	strb	r5, [r0, #0]
                    writeActionFlag = ActionHoldContinuous;
   1ca16:	7011      	strb	r1, [r2, #0]
                prevSamplerKey = currentSamplerKey;
   1ca18:	601c      	str	r4, [r3, #0]
   1ca1a:	e6eb      	b.n	1c7f4 <SFXSamplerKFrame+0x18>
                if ((tBuffer_isActive(&keyBuff[currentSamplerKey])) || (currentSamplerKey != prevSamplerKey)) //only write if recording
   1ca1c:	681a      	ldr	r2, [r3, #0]
   1ca1e:	42a2      	cmp	r2, r4
   1ca20:	d1f0      	bne.n	1ca04 <SFXSamplerKFrame+0x228>
   1ca22:	e7f9      	b.n	1ca18 <SFXSamplerKFrame+0x23c>
                            detectedAttackPos[currentSamplerKey] = 0;
   1ca24:	2500      	movs	r5, #0
                            OLEDclearLine(SecondLine);
   1ca26:	2001      	movs	r0, #1
                            detectedAttackPos[currentSamplerKey] = 0;
   1ca28:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
                            OLEDclearLine(SecondLine);
   1ca2c:	f7fc ff5a 	bl	198e4 <OLEDclearLine>
                            OLEDwriteString("NO ATK FOUND ", 10, 0, SecondLine);
   1ca30:	462a      	mov	r2, r5
   1ca32:	2301      	movs	r3, #1
   1ca34:	210a      	movs	r1, #10
   1ca36:	481e      	ldr	r0, [pc, #120]	; (1cab0 <SFXSamplerKFrame+0x2d4>)
        }
   1ca38:	b003      	add	sp, #12
   1ca3a:	ecbd 8b04 	vpop	{d8-d9}
   1ca3e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                            OLEDwriteString("NO ATK FOUND ", 10, 0, SecondLine);
   1ca42:	f7fc bf63 	b.w	1990c <OLEDwriteString>
                        if (i >= buffLength)
   1ca46:	455d      	cmp	r5, fp
   1ca48:	ddec      	ble.n	1ca24 <SFXSamplerKFrame+0x248>
        {
   1ca4a:	46d9      	mov	r9, fp
   1ca4c:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
   1ca50:	e763      	b.n	1c91a <SFXSamplerKFrame+0x13e>
                        previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
   1ca52:	f241 22bf 	movw	r2, #4799	; 0x12bf
                        detectedAttackPos[currentSamplerKey] += 4800;
   1ca56:	f503 5196 	add.w	r1, r3, #4800	; 0x12c0
                        previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
   1ca5a:	4638      	mov	r0, r7
   1ca5c:	441a      	add	r2, r3
                        detectedAttackPos[currentSamplerKey] += 4800;
   1ca5e:	f846 1024 	str.w	r1, [r6, r4, lsl #2]
                        previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
   1ca62:	fb92 f1f5 	sdiv	r1, r2, r5
   1ca66:	fb05 2111 	mls	r1, r5, r1, r2
   1ca6a:	f00f f8b3 	bl	2bbd4 <tBuffer_get>
   1ca6e:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
   1ca72:	e74c      	b.n	1c90e <SFXSamplerKFrame+0x132>
   1ca74:	0006277c 	.word	0x0006277c
   1ca78:	020fa000 	.word	0x020fa000
   1ca7c:	020fafac 	.word	0x020fafac
   1ca80:	020faa2c 	.word	0x020faa2c
   1ca84:	020e2e28 	.word	0x020e2e28
   1ca88:	3a03126f 	.word	0x3a03126f
   1ca8c:	00000000 	.word	0x00000000
   1ca90:	020fac38 	.word	0x020fac38
   1ca94:	020f9c0c 	.word	0x020f9c0c
   1ca98:	00030cd0 	.word	0x00030cd0
   1ca9c:	020fbd68 	.word	0x020fbd68
   1caa0:	000627c8 	.word	0x000627c8
   1caa4:	020fb11c 	.word	0x020fb11c
   1caa8:	0006282a 	.word	0x0006282a
   1caac:	00062829 	.word	0x00062829
   1cab0:	00030cc0 	.word	0x00030cc0
   1cab4:	020facfc 	.word	0x020facfc
   1cab8:	020e2ebc 	.word	0x020e2ebc
   1cabc:	00000000 	.word	0x00000000

0001cac0 <SFXSamplerKTick>:
            if (!controlAllKeys)
   1cac0:	4baf      	ldr	r3, [pc, #700]	; (1cd80 <SFXSamplerKTick+0x2c0>)
        {
   1cac2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1cac6:	ed2d 8b04 	vpush	{d8-d9}
            if (!controlAllKeys)
   1caca:	681b      	ldr	r3, [r3, #0]
        {
   1cacc:	b087      	sub	sp, #28
   1cace:	4682      	mov	sl, r0
            if (!controlAllKeys)
   1cad0:	2b00      	cmp	r3, #0
   1cad2:	f000 817d 	beq.w	1cdd0 <SFXSamplerKTick+0x310>
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1cad6:	2700      	movs	r7, #0
   1cad8:	4caa      	ldr	r4, [pc, #680]	; (1cd84 <SFXSamplerKTick+0x2c4>)
   1cada:	4dab      	ldr	r5, [pc, #684]	; (1cd88 <SFXSamplerKTick+0x2c8>)
   1cadc:	f8df 92dc 	ldr.w	r9, [pc, #732]	; 1cdbc <SFXSamplerKTick+0x2fc>
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1cae0:	eddf 8aaa 	vldr	s17, [pc, #680]	; 1cd8c <SFXSamplerKTick+0x2cc>
                    displayValues[5] = knobs[5] * 4000.0f;
   1cae4:	ed9f 8aaa 	vldr	s16, [pc, #680]	; 1cd90 <SFXSamplerKTick+0x2d0>
                    if (tSimplePoly_isOn(&poly, i) > 0)
   1cae8:	f8df b2dc 	ldr.w	fp, [pc, #732]	; 1cdc8 <SFXSamplerKTick+0x308>
   1caec:	9000      	str	r0, [sp, #0]
   1caee:	e003      	b.n	1caf8 <SFXSamplerKTick+0x38>
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1caf0:	3701      	adds	r7, #1
   1caf2:	2f06      	cmp	r7, #6
   1caf4:	f000 80f5 	beq.w	1cce2 <SFXSamplerKTick+0x222>
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1caf8:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
                    displayValues[0] = knobs[0];
   1cafc:	ed94 1a96 	vldr	s2, [r4, #600]	; 0x258
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1cb00:	edd4 0a97 	vldr	s1, [r4, #604]	; 0x25c
   1cb04:	eeb0 0a68 	vmov.f32	s0, s17
                    displayValues[0] = knobs[0];
   1cb08:	ed85 1a00 	vstr	s2, [r5]
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1cb0c:	ee39 1a41 	vsub.f32	s2, s18, s2
   1cb10:	f00c fe0a 	bl	29728 <LEAF_clip>
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cb14:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1cb18:	edd4 5a98 	vldr	s11, [r4, #608]	; 0x260
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1cb1c:	eeb2 7a0c 	vmov.f32	s14, #44	; 0x41600000  14.0
   1cb20:	edd4 6a99 	vldr	s13, [r4, #612]	; 0x264
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cb24:	eeb1 6a00 	vmov.f32	s12, #16	; 0x40800000  4.0
   1cb28:	ee75 5ae7 	vsub.f32	s11, s11, s15
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1cb2c:	ed85 0a01 	vstr	s0, [r5, #4]
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1cb30:	ee76 7ae7 	vsub.f32	s15, s13, s15
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cb34:	ee25 6a86 	vmul.f32	s12, s11, s12
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1cb38:	ee67 7a87 	vmul.f32	s15, s15, s14
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cb3c:	ed85 6a02 	vstr	s12, [r5, #8]
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1cb40:	fef8 7a67 	vrinta.f32	s15, s15
                    if (rate < 0.0f)
   1cb44:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1cb48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cb4c:	f100 8107 	bmi.w	1cd5e <SFXSamplerKTick+0x29e>
                        rate += 1.0f;
   1cb50:	ee77 7a89 	vadd.f32	s15, s15, s18
                    displayValues[5] = knobs[5] * 4000.0f;
   1cb54:	edd4 6a9b 	vldr	s13, [r4, #620]	; 0x26c
                    if (tSimplePoly_isOn(&poly, i) > 0)
   1cb58:	b2fe      	uxtb	r6, r7
                    displayValues[4] = roundf(knobs[4]);
   1cb5a:	ed94 7a9a 	vldr	s14, [r4, #616]	; 0x268
                    if (tSimplePoly_isOn(&poly, i) > 0)
   1cb5e:	4658      	mov	r0, fp
                    displayValues[5] = knobs[5] * 4000.0f;
   1cb60:	ee66 6a88 	vmul.f32	s13, s13, s16
                    displayValues[6] = knobs[6];
   1cb64:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
                    if (tSimplePoly_isOn(&poly, i) > 0)
   1cb68:	4631      	mov	r1, r6
                    displayValues[3] = rate;
   1cb6a:	edc5 7a03 	vstr	s15, [r5, #12]
                    displayValues[6] = knobs[6];
   1cb6e:	61ab      	str	r3, [r5, #24]
                    displayValues[4] = roundf(knobs[4]);
   1cb70:	fef8 7a47 	vrinta.f32	s15, s14
                    displayValues[5] = knobs[5] * 4000.0f;
   1cb74:	edc5 6a05 	vstr	s13, [r5, #20]
                    displayValues[4] = roundf(knobs[4]);
   1cb78:	edc5 7a04 	vstr	s15, [r5, #16]
                    if (tSimplePoly_isOn(&poly, i) > 0)
   1cb7c:	f00d fc6a 	bl	2a454 <tSimplePoly_isOn>
   1cb80:	2800      	cmp	r0, #0
   1cb82:	ddb5      	ble.n	1caf0 <SFXSamplerKTick+0x30>
                        int key = tSimplePoly_getPitch(&poly, i) - LOWEST_SAMPLER_KEY;
   1cb84:	4631      	mov	r1, r6
   1cb86:	4658      	mov	r0, fp
   1cb88:	f00d fc52 	bl	2a430 <tSimplePoly_getPitch>
   1cb8c:	f1a0 0a24 	sub.w	sl, r0, #36	; 0x24
                        if ((0 <= key) && (key < NUM_SAMPLER_KEYS))
   1cb90:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
   1cb94:	d8ac      	bhi.n	1caf0 <SFXSamplerKTick+0x30>
                            tBuffer_tick(&keyBuff[key], input[1]);
   1cb96:	4a7f      	ldr	r2, [pc, #508]	; (1cd94 <SFXSamplerKTick+0x2d4>)
   1cb98:	ea4f 068a 	mov.w	r6, sl, lsl #2
   1cb9c:	9b00      	ldr	r3, [sp, #0]
   1cb9e:	eb02 0806 	add.w	r8, r2, r6
   1cba2:	ed93 0a01 	vldr	s0, [r3, #4]
   1cba6:	4640      	mov	r0, r8
   1cba8:	f00e fff6 	bl	2bb98 <tBuffer_tick>
                            int recordedLength = tBuffer_getRecordedLength(&keyBuff[key]);
   1cbac:	4640      	mov	r0, r8
   1cbae:	f00f f839 	bl	2bc24 <tBuffer_getRecordedLength>
                            if (knobs[0] != prevKnobs[0])
   1cbb2:	edd4 6a96 	vldr	s13, [r4, #600]	; 0x258
                            sampleLength = recordedLength * leaf.invSampleRate;
   1cbb6:	ee07 0a90 	vmov	s15, r0
                            if (knobs[0] != prevKnobs[0])
   1cbba:	ed99 6a00 	vldr	s12, [r9]
                            sampleLength = recordedLength * leaf.invSampleRate;
   1cbbe:	4976      	ldr	r1, [pc, #472]	; (1cd98 <SFXSamplerKTick+0x2d8>)
   1cbc0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1cbc4:	4a75      	ldr	r2, [pc, #468]	; (1cd9c <SFXSamplerKTick+0x2dc>)
                            if (knobs[0] != prevKnobs[0])
   1cbc6:	eef4 6a46 	vcmp.f32	s13, s12
                            sampleLength = recordedLength * leaf.invSampleRate;
   1cbca:	ed91 7a01 	vldr	s14, [r1, #4]
   1cbce:	ee27 7a27 	vmul.f32	s14, s14, s15
                            if (knobs[0] != prevKnobs[0])
   1cbd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                            sampleLength = recordedLength * leaf.invSampleRate;
   1cbd6:	ed82 7a00 	vstr	s14, [r2]
                                samplePlayStarts[key]= (knobs[0] * recordedLength);
   1cbda:	4a71      	ldr	r2, [pc, #452]	; (1cda0 <SFXSamplerKTick+0x2e0>)
                            if (knobs[0] != prevKnobs[0])
   1cbdc:	f040 80c6 	bne.w	1cd6c <SFXSamplerKTick+0x2ac>
   1cbe0:	4432      	add	r2, r6
   1cbe2:	edd2 6a00 	vldr	s13, [r2]
                            if (knobs[1] != prevKnobs[1])
   1cbe6:	ed94 7a97 	vldr	s14, [r4, #604]	; 0x25c
   1cbea:	ed99 6a01 	vldr	s12, [r9, #4]
                                samplePlayLengths[key] = (knobs[1] * recordedLength);
   1cbee:	4a6d      	ldr	r2, [pc, #436]	; (1cda4 <SFXSamplerKTick+0x2e4>)
                            if (knobs[1] != prevKnobs[1])
   1cbf0:	eeb4 7a46 	vcmp.f32	s14, s12
   1cbf4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cbf8:	d004      	beq.n	1cc04 <SFXSamplerKTick+0x144>
                                samplePlayLengths[key] = (knobs[1] * recordedLength);
   1cbfa:	ee67 7a87 	vmul.f32	s15, s15, s14
   1cbfe:	1991      	adds	r1, r2, r6
   1cc00:	edc1 7a00 	vstr	s15, [r1]
                            if (knobs[2] != prevKnobs[2])
   1cc04:	ed94 7a98 	vldr	s14, [r4, #608]	; 0x260
   1cc08:	edd9 7a02 	vldr	s15, [r9, #8]
                                sampleRates[key] = displayValues[2];
   1cc0c:	4b66      	ldr	r3, [pc, #408]	; (1cda8 <SFXSamplerKTick+0x2e8>)
                            if (knobs[2] != prevKnobs[2])
   1cc0e:	eeb4 7a67 	vcmp.f32	s14, s15
                                sampleRates[key] = displayValues[2];
   1cc12:	9302      	str	r3, [sp, #8]
                            if (knobs[2] != prevKnobs[2])
   1cc14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cc18:	d002      	beq.n	1cc20 <SFXSamplerKTick+0x160>
                                sampleRates[key] = displayValues[2];
   1cc1a:	68a8      	ldr	r0, [r5, #8]
   1cc1c:	1999      	adds	r1, r3, r6
   1cc1e:	6008      	str	r0, [r1, #0]
                            if (knobs[3] != prevKnobs[3])
   1cc20:	ed94 7a99 	vldr	s14, [r4, #612]	; 0x264
   1cc24:	edd9 7a03 	vldr	s15, [r9, #12]
                                sampleRatesMult[key] = displayValues[3];
   1cc28:	4b60      	ldr	r3, [pc, #384]	; (1cdac <SFXSamplerKTick+0x2ec>)
                            if (knobs[3] != prevKnobs[3])
   1cc2a:	eeb4 7a67 	vcmp.f32	s14, s15
   1cc2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cc32:	d002      	beq.n	1cc3a <SFXSamplerKTick+0x17a>
                                sampleRatesMult[key] = displayValues[3];
   1cc34:	68e8      	ldr	r0, [r5, #12]
   1cc36:	1999      	adds	r1, r3, r6
   1cc38:	6008      	str	r0, [r1, #0]
                            if (knobs[4] != prevKnobs[4])
   1cc3a:	edd4 7a9a 	vldr	s15, [r4, #616]	; 0x268
   1cc3e:	ed99 7a04 	vldr	s14, [r9, #16]
   1cc42:	eef4 7a47 	vcmp.f32	s15, s14
   1cc46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cc4a:	f040 81d8 	bne.w	1cffe <SFXSamplerKTick+0x53e>
   1cc4e:	4958      	ldr	r1, [pc, #352]	; (1cdb0 <SFXSamplerKTick+0x2f0>)
   1cc50:	9101      	str	r1, [sp, #4]
                            if (knobs[5] != prevKnobs[5])
   1cc52:	ed94 7a9b 	vldr	s14, [r4, #620]	; 0x26c
   1cc56:	edd9 7a05 	vldr	s15, [r9, #20]
                                crossfadeLengths[key] = displayValues[5];
   1cc5a:	4956      	ldr	r1, [pc, #344]	; (1cdb4 <SFXSamplerKTick+0x2f4>)
                            if (knobs[5] != prevKnobs[5])
   1cc5c:	eeb4 7a67 	vcmp.f32	s14, s15
                                crossfadeLengths[key] = displayValues[5];
   1cc60:	9103      	str	r1, [sp, #12]
                            if (knobs[5] != prevKnobs[5])
   1cc62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cc66:	d002      	beq.n	1cc6e <SFXSamplerKTick+0x1ae>
                                crossfadeLengths[key] = displayValues[5];
   1cc68:	6968      	ldr	r0, [r5, #20]
   1cc6a:	4431      	add	r1, r6
   1cc6c:	6008      	str	r0, [r1, #0]
                            tSampler_setStart(&keySampler[key], samplePlayStarts[key]);
   1cc6e:	4852      	ldr	r0, [pc, #328]	; (1cdb8 <SFXSamplerKTick+0x2f8>)
   1cc70:	eefd 7ae6 	vcvt.s32.f32	s15, s13
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1cc74:	3701      	adds	r7, #1
                            tSampler_setStart(&keySampler[key], samplePlayStarts[key]);
   1cc76:	eb00 0806 	add.w	r8, r0, r6
   1cc7a:	ee17 1a90 	vmov	r1, s15
   1cc7e:	4640      	mov	r0, r8
   1cc80:	e9cd 3204 	strd	r3, r2, [sp, #16]
   1cc84:	f00f f8f8 	bl	2be78 <tSampler_setStart>
                            tSampler_setLength(&keySampler[key], samplePlayLengths[key]);
   1cc88:	9a05      	ldr	r2, [sp, #20]
   1cc8a:	4640      	mov	r0, r8
   1cc8c:	4432      	add	r2, r6
   1cc8e:	edd2 7a00 	vldr	s15, [r2]
   1cc92:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1cc96:	ee17 1a90 	vmov	r1, s15
   1cc9a:	f00f fcfb 	bl	2c694 <tSampler_setLength>
                            tSampler_setCrossfadeLength(&keySampler[key], crossfadeLengths[key]);
   1cc9e:	9b03      	ldr	r3, [sp, #12]
   1cca0:	4640      	mov	r0, r8
   1cca2:	4433      	add	r3, r6
   1cca4:	edd3 7a00 	vldr	s15, [r3]
   1cca8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1ccac:	ee17 1a90 	vmov	r1, s15
   1ccb0:	f00f f870 	bl	2bd94 <tSampler_setCrossfadeLength>
                            tSampler_setRate(&keySampler[key], sampleRates[key] * sampleRatesMult[key]);
   1ccb4:	9b02      	ldr	r3, [sp, #8]
   1ccb6:	4640      	mov	r0, r8
   1ccb8:	4433      	add	r3, r6
   1ccba:	461a      	mov	r2, r3
   1ccbc:	9b04      	ldr	r3, [sp, #16]
   1ccbe:	441e      	add	r6, r3
   1ccc0:	ed92 0a00 	vldr	s0, [r2]
   1ccc4:	edd6 7a00 	vldr	s15, [r6]
   1ccc8:	ee20 0a27 	vmul.f32	s0, s0, s15
   1cccc:	f00f fd7c 	bl	2c7c8 <tSampler_setRate>
                            tSampler_setMode(&keySampler[key], (PlayMode)loopOns[key]);
   1ccd0:	9b01      	ldr	r3, [sp, #4]
   1ccd2:	4640      	mov	r0, r8
   1ccd4:	f813 102a 	ldrb.w	r1, [r3, sl, lsl #2]
   1ccd8:	f00f f858 	bl	2bd8c <tSampler_setMode>
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1ccdc:	2f06      	cmp	r7, #6
   1ccde:	f47f af0b 	bne.w	1caf8 <SFXSamplerKTick+0x38>
   1cce2:	f8dd a000 	ldr.w	sl, [sp]
   1cce6:	f8df c0e4 	ldr.w	ip, [pc, #228]	; 1cdcc <SFXSamplerKTick+0x30c>
   1ccea:	2400      	movs	r4, #0
   1ccec:	4f33      	ldr	r7, [pc, #204]	; (1cdbc <SFXSamplerKTick+0x2fc>)
            float sample = 0.0f;
   1ccee:	ed9f 9a27 	vldr	s18, [pc, #156]	; 1cd8c <SFXSamplerKTick+0x2cc>
			if ( tempGain > 0.0001f)
   1ccf2:	eddf 8a33 	vldr	s17, [pc, #204]	; 1cdc0 <SFXSamplerKTick+0x300>
   1ccf6:	4d33      	ldr	r5, [pc, #204]	; (1cdc4 <SFXSamplerKTick+0x304>)
				sample += tSampler_tick(&keySampler[i]) * tempGain;
   1ccf8:	4e2f      	ldr	r6, [pc, #188]	; (1cdb8 <SFXSamplerKTick+0x2f8>)
   1ccfa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   1ccfe:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   1cd00:	e89c 0003 	ldmia.w	ip, {r0, r1}
   1cd04:	e887 0003 	stmia.w	r7, {r0, r1}
   1cd08:	e002      	b.n	1cd10 <SFXSamplerKTick+0x250>
   1cd0a:	3404      	adds	r4, #4
		for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1cd0c:	2cc4      	cmp	r4, #196	; 0xc4
   1cd0e:	d011      	beq.n	1cd34 <SFXSamplerKTick+0x274>
			float tempGain = tExpSmooth_tick(&kSamplerGains[i]);
   1cd10:	1928      	adds	r0, r5, r4
   1cd12:	f00b f87f 	bl	27e14 <tExpSmooth_tick>
			if ( tempGain > 0.0001f)
   1cd16:	eeb4 0ae8 	vcmpe.f32	s0, s17
			float tempGain = tExpSmooth_tick(&kSamplerGains[i]);
   1cd1a:	eeb0 8a40 	vmov.f32	s16, s0
			if ( tempGain > 0.0001f)
   1cd1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cd22:	ddf2      	ble.n	1cd0a <SFXSamplerKTick+0x24a>
				sample += tSampler_tick(&keySampler[i]) * tempGain;
   1cd24:	1930      	adds	r0, r6, r4
   1cd26:	3404      	adds	r4, #4
   1cd28:	f00f f9d2 	bl	2c0d0 <tSampler_tick>
   1cd2c:	eea0 9a08 	vfma.f32	s18, s0, s16
		for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1cd30:	2cc4      	cmp	r4, #196	; 0xc4
   1cd32:	d1ed      	bne.n	1cd10 <SFXSamplerKTick+0x250>
            sample = tanhf(sample) * 0.98;
   1cd34:	eeb0 0a49 	vmov.f32	s0, s18
   1cd38:	f010 fa10 	bl	2d15c <tanhf>
   1cd3c:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
   1cd40:	ed9f 7b0d 	vldr	d7, [pc, #52]	; 1cd78 <SFXSamplerKTick+0x2b8>
   1cd44:	ee20 0b07 	vmul.f64	d0, d0, d7
   1cd48:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
            input[0] = sample;
   1cd4c:	ed8a 0a00 	vstr	s0, [sl]
            input[1] = sample;
   1cd50:	ed8a 0a01 	vstr	s0, [sl, #4]
        }
   1cd54:	b007      	add	sp, #28
   1cd56:	ecbd 8b04 	vpop	{d8-d9}
   1cd5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        (rate = 1.0f / fabsf(rate-1.0f));
   1cd5e:	ee77 7ac9 	vsub.f32	s15, s15, s18
   1cd62:	eeb0 7ae7 	vabs.f32	s14, s15
   1cd66:	eec9 7a07 	vdiv.f32	s15, s18, s14
   1cd6a:	e6f3      	b.n	1cb54 <SFXSamplerKTick+0x94>
                                samplePlayStarts[key]= (knobs[0] * recordedLength);
   1cd6c:	ee67 6aa6 	vmul.f32	s13, s15, s13
   1cd70:	4432      	add	r2, r6
   1cd72:	edc2 6a00 	vstr	s13, [r2]
   1cd76:	e736      	b.n	1cbe6 <SFXSamplerKTick+0x126>
   1cd78:	f5c28f5c 	.word	0xf5c28f5c
   1cd7c:	3fef5c28 	.word	0x3fef5c28
   1cd80:	020e2e28 	.word	0x020e2e28
   1cd84:	020e55d8 	.word	0x020e55d8
   1cd88:	020fb05c 	.word	0x020fb05c
   1cd8c:	00000000 	.word	0x00000000
   1cd90:	457a0000 	.word	0x457a0000
   1cd94:	020faa2c 	.word	0x020faa2c
   1cd98:	020fbd68 	.word	0x020fbd68
   1cd9c:	020e2ec4 	.word	0x020e2ec4
   1cda0:	020f9c0c 	.word	0x020f9c0c
   1cda4:	020e5148 	.word	0x020e5148
   1cda8:	020e5230 	.word	0x020e5230
   1cdac:	020fa118 	.word	0x020fa118
   1cdb0:	020e5514 	.word	0x020e5514
   1cdb4:	020fa050 	.word	0x020fa050
   1cdb8:	020e5df4 	.word	0x020e5df4
   1cdbc:	020faa14 	.word	0x020faa14
   1cdc0:	38d1b717 	.word	0x38d1b717
   1cdc4:	020e4f54 	.word	0x020e4f54
   1cdc8:	020f9de8 	.word	0x020f9de8
   1cdcc:	020e5830 	.word	0x020e5830
            int currentSamplerKey = currentSamplerKeyGlobal;
   1cdd0:	4b9b      	ldr	r3, [pc, #620]	; (1d040 <SFXSamplerKTick+0x580>)
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1cdd2:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
                int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1cdd6:	489b      	ldr	r0, [pc, #620]	; (1d044 <SFXSamplerKTick+0x584>)
            int currentSamplerKey = currentSamplerKeyGlobal;
   1cdd8:	681f      	ldr	r7, [r3, #0]
                displayValues[0] = knobs[0] * sampleLength;
   1cdda:	4c9b      	ldr	r4, [pc, #620]	; (1d048 <SFXSamplerKTick+0x588>)
   1cddc:	00be      	lsls	r6, r7, #2
   1cdde:	4d9b      	ldr	r5, [pc, #620]	; (1d04c <SFXSamplerKTick+0x58c>)
                int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1cde0:	4430      	add	r0, r6
   1cde2:	f00e ff1f 	bl	2bc24 <tBuffer_getRecordedLength>
                sampleLength = recordedLength * leaf.invSampleRate;
   1cde6:	ee07 0a90 	vmov	s15, r0
   1cdea:	4b99      	ldr	r3, [pc, #612]	; (1d050 <SFXSamplerKTick+0x590>)
   1cdec:	eef8 8ae7 	vcvt.f32.s32	s17, s15
                displayValues[0] = knobs[0] * sampleLength;
   1cdf0:	ed94 7a96 	vldr	s14, [r4, #600]	; 0x258
                sampleLength = recordedLength * leaf.invSampleRate;
   1cdf4:	edd3 7a01 	vldr	s15, [r3, #4]
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1cdf8:	ee38 1a47 	vsub.f32	s2, s16, s14
   1cdfc:	edd4 0a97 	vldr	s1, [r4, #604]	; 0x25c
                sampleLength = recordedLength * leaf.invSampleRate;
   1ce00:	ee68 7aa7 	vmul.f32	s15, s17, s15
   1ce04:	4b93      	ldr	r3, [pc, #588]	; (1d054 <SFXSamplerKTick+0x594>)
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1ce06:	ed9f 0a94 	vldr	s0, [pc, #592]	; 1d058 <SFXSamplerKTick+0x598>
                displayValues[0] = knobs[0] * sampleLength;
   1ce0a:	ee27 7a87 	vmul.f32	s14, s15, s14
                sampleLength = recordedLength * leaf.invSampleRate;
   1ce0e:	edc3 7a00 	vstr	s15, [r3]
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1ce12:	ee21 1a27 	vmul.f32	s2, s2, s15
   1ce16:	ee67 0aa0 	vmul.f32	s1, s15, s1
                displayValues[0] = knobs[0] * sampleLength;
   1ce1a:	ed85 7a00 	vstr	s14, [r5]
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1ce1e:	f00c fc83 	bl	29728 <LEAF_clip>
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1ce22:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1ce26:	ed94 6a98 	vldr	s12, [r4, #608]	; 0x260
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1ce2a:	edd4 6a99 	vldr	s13, [r4, #612]	; 0x264
   1ce2e:	eeb2 7a0c 	vmov.f32	s14, #44	; 0x41600000  14.0
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1ce32:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1ce36:	ed85 0a01 	vstr	s0, [r5, #4]
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1ce3a:	ee76 4a67 	vsub.f32	s9, s12, s15
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1ce3e:	ee76 7ae7 	vsub.f32	s15, s13, s15
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1ce42:	ee64 4aa5 	vmul.f32	s9, s9, s11
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1ce46:	ee67 7a87 	vmul.f32	s15, s15, s14
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1ce4a:	edc5 4a02 	vstr	s9, [r5, #8]
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1ce4e:	fef8 7a67 	vrinta.f32	s15, s15
                if (rate < 0.0f)
   1ce52:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1ce56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ce5a:	f100 80e9 	bmi.w	1d030 <SFXSamplerKTick+0x570>
                    rate += 1.0f;
   1ce5e:	ee77 3a88 	vadd.f32	s7, s15, s16
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1ce62:	f8df 9218 	ldr.w	r9, [pc, #536]	; 1d07c <SFXSamplerKTick+0x5bc>
   1ce66:	ed94 5a96 	vldr	s10, [r4, #600]	; 0x258
   1ce6a:	edd9 5a00 	vldr	s11, [r9]
   1ce6e:	ed9f 3a7b 	vldr	s6, [pc, #492]	; 1d05c <SFXSamplerKTick+0x59c>
   1ce72:	ee75 5a65 	vsub.f32	s11, s10, s11
                displayValues[5] = knobs[5] * 4000.0f;
   1ce76:	edd4 7a9b 	vldr	s15, [r4, #620]	; 0x26c
   1ce7a:	eddf 2a79 	vldr	s5, [pc, #484]	; 1d060 <SFXSamplerKTick+0x5a0>
                displayValues[6] = knobs[6];
   1ce7e:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1ce82:	eef0 5ae5 	vabs.f32	s11, s11
                displayValues[4] = roundf(knobs[4]);
   1ce86:	ed94 7a9a 	vldr	s14, [r4, #616]	; 0x268
                displayValues[5] = knobs[5] * 4000.0f;
   1ce8a:	ee67 2aa2 	vmul.f32	s5, s15, s5
                displayValues[6] = knobs[6];
   1ce8e:	61ab      	str	r3, [r5, #24]
                displayValues[4] = roundf(knobs[4]);
   1ce90:	feb8 4a47 	vrinta.f32	s8, s14
                displayValues[3] = rate;
   1ce94:	edc5 3a03 	vstr	s7, [r5, #12]
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1ce98:	eef4 5ac3 	vcmpe.f32	s11, s6
                displayValues[4] = roundf(knobs[4]);
   1ce9c:	ed85 4a04 	vstr	s8, [r5, #16]
                displayValues[5] = knobs[5] * 4000.0f;
   1cea0:	edc5 2a05 	vstr	s5, [r5, #20]
                    samplePlayStarts[currentSamplerKey]= (knobs[0] * recordedLength);// + detectedAttackPos[currentSamplerKey];
   1cea4:	4b6f      	ldr	r3, [pc, #444]	; (1d064 <SFXSamplerKTick+0x5a4>)
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1cea6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ceaa:	f300 80b3 	bgt.w	1d014 <SFXSamplerKTick+0x554>
   1ceae:	4433      	add	r3, r6
   1ceb0:	ed93 5a00 	vldr	s10, [r3]
                if (fabsf(knobs[1]-prevKnobs[1])  > 0.0001f)
   1ceb4:	ed94 3a97 	vldr	s6, [r4, #604]	; 0x25c
   1ceb8:	edd9 5a01 	vldr	s11, [r9, #4]
   1cebc:	ed9f 2a67 	vldr	s4, [pc, #412]	; 1d05c <SFXSamplerKTick+0x59c>
   1cec0:	ee73 5a65 	vsub.f32	s11, s6, s11
                    samplePlayLengths[currentSamplerKey] = (knobs[1] * recordedLength);// - detectedAttackPos[currentSamplerKey];
   1cec4:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 1d080 <SFXSamplerKTick+0x5c0>
                if (fabsf(knobs[1]-prevKnobs[1])  > 0.0001f)
   1cec8:	eef0 5ae5 	vabs.f32	s11, s11
   1cecc:	eef4 5ac2 	vcmpe.f32	s11, s4
   1ced0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ced4:	dd05      	ble.n	1cee2 <SFXSamplerKTick+0x422>
                    samplePlayLengths[currentSamplerKey] = (knobs[1] * recordedLength);// - detectedAttackPos[currentSamplerKey];
   1ced6:	ee68 5a83 	vmul.f32	s11, s17, s6
   1ceda:	eb0b 0306 	add.w	r3, fp, r6
   1cede:	edc3 5a00 	vstr	s11, [r3]
                if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1cee2:	ed99 3a02 	vldr	s6, [r9, #8]
   1cee6:	eddf 5a5d 	vldr	s11, [pc, #372]	; 1d05c <SFXSamplerKTick+0x59c>
   1ceea:	ee36 6a43 	vsub.f32	s12, s12, s6
                    sampleRates[currentSamplerKey] = displayValues[2];
   1ceee:	4b5e      	ldr	r3, [pc, #376]	; (1d068 <SFXSamplerKTick+0x5a8>)
   1cef0:	9301      	str	r3, [sp, #4]
                if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1cef2:	eeb0 6ac6 	vabs.f32	s12, s12
   1cef6:	eeb4 6ae5 	vcmpe.f32	s12, s11
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1cefa:	edd9 5a03 	vldr	s11, [r9, #12]
   1cefe:	ed9f 6a57 	vldr	s12, [pc, #348]	; 1d05c <SFXSamplerKTick+0x59c>
   1cf02:	ee76 6ae5 	vsub.f32	s13, s13, s11
                if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1cf06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1cf0a:	eef0 6ae6 	vabs.f32	s13, s13
                    sampleRates[currentSamplerKey] = displayValues[2];
   1cf0e:	bfc8      	it	gt
   1cf10:	199b      	addgt	r3, r3, r6
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1cf12:	eef4 6ac6 	vcmpe.f32	s13, s12
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1cf16:	ed99 6a04 	vldr	s12, [r9, #16]
                    sampleRates[currentSamplerKey] = displayValues[2];
   1cf1a:	bfc8      	it	gt
   1cf1c:	edc3 4a00 	vstrgt	s9, [r3]
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1cf20:	ee37 7a46 	vsub.f32	s14, s14, s12
   1cf24:	eddf 6a4d 	vldr	s13, [pc, #308]	; 1d05c <SFXSamplerKTick+0x59c>
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1cf28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
   1cf2c:	4b4f      	ldr	r3, [pc, #316]	; (1d06c <SFXSamplerKTick+0x5ac>)
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1cf2e:	eeb0 7ac7 	vabs.f32	s14, s14
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
   1cf32:	9300      	str	r3, [sp, #0]
   1cf34:	bfc8      	it	gt
   1cf36:	199b      	addgt	r3, r3, r6
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1cf38:	eeb4 7ae6 	vcmpe.f32	s14, s13
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
   1cf3c:	bfc8      	it	gt
   1cf3e:	edc3 3a00 	vstrgt	s7, [r3]
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1cf42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cf46:	dc6b      	bgt.n	1d020 <SFXSamplerKTick+0x560>
   1cf48:	4a49      	ldr	r2, [pc, #292]	; (1d070 <SFXSamplerKTick+0x5b0>)
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1cf4a:	edd9 6a05 	vldr	s13, [r9, #20]
                tSampler_setLength(&keySampler[currentSamplerKey], samplePlayLengths[currentSamplerKey]);
   1cf4e:	44b3      	add	fp, r6
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1cf50:	ed9f 7a42 	vldr	s14, [pc, #264]	; 1d05c <SFXSamplerKTick+0x59c>
   1cf54:	ee77 7ae6 	vsub.f32	s15, s15, s13
                    crossfadeLengths[currentSamplerKey] = displayValues[5];
   1cf58:	f8df 9128 	ldr.w	r9, [pc, #296]	; 1d084 <SFXSamplerKTick+0x5c4>
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1cf5c:	4845      	ldr	r0, [pc, #276]	; (1d074 <SFXSamplerKTick+0x5b4>)
   1cf5e:	9202      	str	r2, [sp, #8]
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1cf60:	eef0 7ae7 	vabs.f32	s15, s15
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1cf64:	eb00 0806 	add.w	r8, r0, r6
   1cf68:	4c43      	ldr	r4, [pc, #268]	; (1d078 <SFXSamplerKTick+0x5b8>)
   1cf6a:	4640      	mov	r0, r8
   1cf6c:	4d35      	ldr	r5, [pc, #212]	; (1d044 <SFXSamplerKTick+0x584>)
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1cf6e:	eef4 7ac7 	vcmpe.f32	s15, s14
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1cf72:	eefd 7ac5 	vcvt.s32.f32	s15, s10
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1cf76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    crossfadeLengths[currentSamplerKey] = displayValues[5];
   1cf7a:	bfc4      	itt	gt
   1cf7c:	eb09 0106 	addgt.w	r1, r9, r6
   1cf80:	edc1 2a00 	vstrgt	s5, [r1]
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1cf84:	ee17 1a90 	vmov	r1, s15
   1cf88:	f00e ff76 	bl	2be78 <tSampler_setStart>
                tSampler_setLength(&keySampler[currentSamplerKey], samplePlayLengths[currentSamplerKey]);
   1cf8c:	eddb 7a00 	vldr	s15, [fp]
   1cf90:	4640      	mov	r0, r8
   1cf92:	f104 0b31 	add.w	fp, r4, #49	; 0x31
   1cf96:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1cf9a:	ee17 1a90 	vmov	r1, s15
   1cf9e:	f00f fb79 	bl	2c694 <tSampler_setLength>
                tSampler_setCrossfadeLength(&keySampler[currentSamplerKey], crossfadeLengths[currentSamplerKey]);
   1cfa2:	eb09 0306 	add.w	r3, r9, r6
   1cfa6:	4640      	mov	r0, r8
   1cfa8:	edd3 7a00 	vldr	s15, [r3]
   1cfac:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1cfb0:	ee17 1a90 	vmov	r1, s15
   1cfb4:	f00e feee 	bl	2bd94 <tSampler_setCrossfadeLength>
                tSampler_setRate(&keySampler[currentSamplerKey], sampleRates[currentSamplerKey] * sampleRatesMult[currentSamplerKey]);
   1cfb8:	9b01      	ldr	r3, [sp, #4]
   1cfba:	9a00      	ldr	r2, [sp, #0]
   1cfbc:	4640      	mov	r0, r8
   1cfbe:	4433      	add	r3, r6
   1cfc0:	4432      	add	r2, r6
   1cfc2:	ed93 0a00 	vldr	s0, [r3]
   1cfc6:	edd2 7a00 	vldr	s15, [r2]
   1cfca:	ee20 0a27 	vmul.f32	s0, s0, s15
   1cfce:	f00f fbfb 	bl	2c7c8 <tSampler_setRate>
                tSampler_setMode(&keySampler[currentSamplerKey], (PlayMode)loopOns[currentSamplerKey]);
   1cfd2:	9a02      	ldr	r2, [sp, #8]
   1cfd4:	4640      	mov	r0, r8
   1cfd6:	f812 1027 	ldrb.w	r1, [r2, r7, lsl #2]
   1cfda:	f00e fed7 	bl	2bd8c <tSampler_setMode>
   1cfde:	e004      	b.n	1cfea <SFXSamplerKTick+0x52a>
				for (int i = 0; i < NUM_SAMPLER_KEYS; ++i)
   1cfe0:	45a3      	cmp	fp, r4
   1cfe2:	f105 0504 	add.w	r5, r5, #4
   1cfe6:	f43f ae7e 	beq.w	1cce6 <SFXSamplerKTick+0x226>
					if (samplerKeyHeld[i] > 0)
   1cfea:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   1cfee:	2b00      	cmp	r3, #0
   1cff0:	d0f6      	beq.n	1cfe0 <SFXSamplerKTick+0x520>
						tBuffer_tick(&keyBuff[i], input[1]);
   1cff2:	ed9a 0a01 	vldr	s0, [sl, #4]
   1cff6:	4628      	mov	r0, r5
   1cff8:	f00e fdce 	bl	2bb98 <tBuffer_tick>
   1cffc:	e7f0      	b.n	1cfe0 <SFXSamplerKTick+0x520>
                                loopOns[key] = roundf(knobs[4]);
   1cffe:	fef8 7a67 	vrinta.f32	s15, s15
   1d002:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1d006:	491a      	ldr	r1, [pc, #104]	; (1d070 <SFXSamplerKTick+0x5b0>)
   1d008:	ee17 0a90 	vmov	r0, s15
   1d00c:	9101      	str	r1, [sp, #4]
   1d00e:	f841 002a 	str.w	r0, [r1, sl, lsl #2]
   1d012:	e61e      	b.n	1cc52 <SFXSamplerKTick+0x192>
                    samplePlayStarts[currentSamplerKey]= (knobs[0] * recordedLength);// + detectedAttackPos[currentSamplerKey];
   1d014:	ee28 5a85 	vmul.f32	s10, s17, s10
   1d018:	4433      	add	r3, r6
   1d01a:	ed83 5a00 	vstr	s10, [r3]
   1d01e:	e749      	b.n	1ceb4 <SFXSamplerKTick+0x3f4>
                    loopOns[currentSamplerKey] = roundf(knobs[4]);
   1d020:	eebd 4ac4 	vcvt.s32.f32	s8, s8
   1d024:	4a12      	ldr	r2, [pc, #72]	; (1d070 <SFXSamplerKTick+0x5b0>)
   1d026:	ee14 3a10 	vmov	r3, s8
   1d02a:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
   1d02e:	e78c      	b.n	1cf4a <SFXSamplerKTick+0x48a>
                    (rate = 1.0f / fabsf(rate-1.0f));
   1d030:	ee77 7ac8 	vsub.f32	s15, s15, s16
   1d034:	eef0 7ae7 	vabs.f32	s15, s15
   1d038:	eec8 3a27 	vdiv.f32	s7, s16, s15
   1d03c:	e711      	b.n	1ce62 <SFXSamplerKTick+0x3a2>
   1d03e:	bf00      	nop
   1d040:	0006277c 	.word	0x0006277c
   1d044:	020faa2c 	.word	0x020faa2c
   1d048:	020e55d8 	.word	0x020e55d8
   1d04c:	020fb05c 	.word	0x020fb05c
   1d050:	020fbd68 	.word	0x020fbd68
   1d054:	020e2ec4 	.word	0x020e2ec4
   1d058:	00000000 	.word	0x00000000
   1d05c:	38d1b717 	.word	0x38d1b717
   1d060:	457a0000 	.word	0x457a0000
   1d064:	020f9c0c 	.word	0x020f9c0c
   1d068:	020e5230 	.word	0x020e5230
   1d06c:	020fa118 	.word	0x020fa118
   1d070:	020e5514 	.word	0x020e5514
   1d074:	020e5df4 	.word	0x020e5df4
   1d078:	020f9fff 	.word	0x020f9fff
   1d07c:	020faa14 	.word	0x020faa14
   1d080:	020e5148 	.word	0x020e5148
   1d084:	020fa050 	.word	0x020fa050

0001d088 <SFXSamplerKFree>:
        {
   1d088:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d08a:	2400      	movs	r4, #0
   1d08c:	4f07      	ldr	r7, [pc, #28]	; (1d0ac <SFXSamplerKFree+0x24>)
   1d08e:	4e08      	ldr	r6, [pc, #32]	; (1d0b0 <SFXSamplerKFree+0x28>)
   1d090:	4d08      	ldr	r5, [pc, #32]	; (1d0b4 <SFXSamplerKFree+0x2c>)
                tBuffer_free(&keyBuff[i]);
   1d092:	1938      	adds	r0, r7, r4
   1d094:	f00e fd74 	bl	2bb80 <tBuffer_free>
                tSampler_free(&keySampler[i]);
   1d098:	1930      	adds	r0, r6, r4
   1d09a:	f00e fe6b 	bl	2bd74 <tSampler_free>
                tExpSmooth_free(&kSamplerGains[i]);
   1d09e:	1928      	adds	r0, r5, r4
   1d0a0:	3404      	adds	r4, #4
   1d0a2:	f00a fe97 	bl	27dd4 <tExpSmooth_free>
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1d0a6:	2cc4      	cmp	r4, #196	; 0xc4
   1d0a8:	d1f3      	bne.n	1d092 <SFXSamplerKFree+0xa>
        }
   1d0aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1d0ac:	020faa2c 	.word	0x020faa2c
   1d0b0:	020e5df4 	.word	0x020e5df4
   1d0b4:	020e4f54 	.word	0x020e4f54

0001d0b8 <SFXSamplerAutoAlloc>:
        {
   1d0b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
   1d0bc:	4d36      	ldr	r5, [pc, #216]	; (1d198 <SFXSamplerAutoAlloc+0xe0>)
   1d0be:	f8df 8124 	ldr.w	r8, [pc, #292]	; 1d1e4 <SFXSamplerAutoAlloc+0x12c>
   1d0c2:	4f36      	ldr	r7, [pc, #216]	; (1d19c <SFXSamplerAutoAlloc+0xe4>)
            tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
   1d0c4:	1d2e      	adds	r6, r5, #4
            tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
   1d0c6:	4642      	mov	r2, r8
   1d0c8:	4628      	mov	r0, r5
   1d0ca:	4639      	mov	r1, r7
            tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1d0cc:	4c34      	ldr	r4, [pc, #208]	; (1d1a0 <SFXSamplerAutoAlloc+0xe8>)
            tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
   1d0ce:	f00e fd3f 	bl	2bb50 <tBuffer_initToPool>
            tBuffer_setRecordMode(&asBuff[0], RecordOneShot);
   1d0d2:	4628      	mov	r0, r5
   1d0d4:	2100      	movs	r1, #0
   1d0d6:	f00e fda1 	bl	2bc1c <tBuffer_setRecordMode>
            tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
   1d0da:	4642      	mov	r2, r8
   1d0dc:	4639      	mov	r1, r7
   1d0de:	4630      	mov	r0, r6
            tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1d0e0:	4f30      	ldr	r7, [pc, #192]	; (1d1a4 <SFXSamplerAutoAlloc+0xec>)
            tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
   1d0e2:	f00e fd35 	bl	2bb50 <tBuffer_initToPool>
            tBuffer_setRecordMode(&asBuff[1], RecordOneShot);
   1d0e6:	4630      	mov	r0, r6
   1d0e8:	2100      	movs	r1, #0
   1d0ea:	f00e fd97 	bl	2bc1c <tBuffer_setRecordMode>
            tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1d0ee:	4622      	mov	r2, r4
   1d0f0:	4629      	mov	r1, r5
   1d0f2:	4638      	mov	r0, r7
            tSampler_initToPool(&asSampler[1], &asBuff[1], &smallPool);
   1d0f4:	1d3d      	adds	r5, r7, #4
            tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1d0f6:	f00e fdf1 	bl	2bcdc <tSampler_initToPool>
            tSampler_setMode(&asSampler[0], PlayLoop);
   1d0fa:	4638      	mov	r0, r7
   1d0fc:	2101      	movs	r1, #1
   1d0fe:	f00e fe45 	bl	2bd8c <tSampler_setMode>
            tSampler_initToPool(&asSampler[1], &asBuff[1], &smallPool);
   1d102:	4622      	mov	r2, r4
   1d104:	4631      	mov	r1, r6
   1d106:	4628      	mov	r0, r5
   1d108:	f00e fde8 	bl	2bcdc <tSampler_initToPool>
            tSampler_setMode(&asSampler[1], PlayLoop);
   1d10c:	4628      	mov	r0, r5
   1d10e:	2101      	movs	r1, #1
            randLengthVal = leaf.random() * 10000.0f;
   1d110:	4d25      	ldr	r5, [pc, #148]	; (1d1a8 <SFXSamplerAutoAlloc+0xf0>)
            tSampler_setMode(&asSampler[1], PlayLoop);
   1d112:	f00e fe3b 	bl	2bd8c <tSampler_setMode>
            tEnvelopeFollower_initToPool(&envfollow, 0.00001f, 0.9999f, &smallPool);
   1d116:	4621      	mov	r1, r4
   1d118:	eddf 0a24 	vldr	s1, [pc, #144]	; 1d1ac <SFXSamplerAutoAlloc+0xf4>
   1d11c:	ed9f 0a24 	vldr	s0, [pc, #144]	; 1d1b0 <SFXSamplerAutoAlloc+0xf8>
   1d120:	4824      	ldr	r0, [pc, #144]	; (1d1b4 <SFXSamplerAutoAlloc+0xfc>)
   1d122:	f007 f813 	bl	2414c <tEnvelopeFollower_initToPool>
            tExpSmooth_initToPool(&cfxSmooth, 0.0f, 0.01f, &smallPool);
   1d126:	4621      	mov	r1, r4
   1d128:	eddf 0a23 	vldr	s1, [pc, #140]	; 1d1b8 <SFXSamplerAutoAlloc+0x100>
            currentSampler = 1;
   1d12c:	2401      	movs	r4, #1
            tExpSmooth_initToPool(&cfxSmooth, 0.0f, 0.01f, &smallPool);
   1d12e:	ed9f 0a23 	vldr	s0, [pc, #140]	; 1d1bc <SFXSamplerAutoAlloc+0x104>
   1d132:	4823      	ldr	r0, [pc, #140]	; (1d1c0 <SFXSamplerAutoAlloc+0x108>)
   1d134:	f00a fe28 	bl	27d88 <tExpSmooth_initToPool>
            setLED_A(samplerMode == PlayBackAndForth);
   1d138:	4b22      	ldr	r3, [pc, #136]	; (1d1c4 <SFXSamplerAutoAlloc+0x10c>)
   1d13a:	7818      	ldrb	r0, [r3, #0]
   1d13c:	f1a0 0002 	sub.w	r0, r0, #2
   1d140:	fab0 f080 	clz	r0, r0
   1d144:	0940      	lsrs	r0, r0, #5
   1d146:	f7fc f9a3 	bl	19490 <setLED_A>
            setLED_B(triggerChannel);
   1d14a:	4b1f      	ldr	r3, [pc, #124]	; (1d1c8 <SFXSamplerAutoAlloc+0x110>)
   1d14c:	7818      	ldrb	r0, [r3, #0]
   1d14e:	f7fc f9ad 	bl	194ac <setLED_B>
            currentSampler = 1;
   1d152:	481e      	ldr	r0, [pc, #120]	; (1d1cc <SFXSamplerAutoAlloc+0x114>)
            sample_countdown = 0;
   1d154:	4a1e      	ldr	r2, [pc, #120]	; (1d1d0 <SFXSamplerAutoAlloc+0x118>)
   1d156:	2100      	movs	r1, #0
            currentSampler = 1;
   1d158:	7004      	strb	r4, [r0, #0]
            randLengthVal = leaf.random() * 10000.0f;
   1d15a:	692b      	ldr	r3, [r5, #16]
            sample_countdown = 0;
   1d15c:	6011      	str	r1, [r2, #0]
            randLengthVal = leaf.random() * 10000.0f;
   1d15e:	4798      	blx	r3
   1d160:	eddf 7a1c 	vldr	s15, [pc, #112]	; 1d1d4 <SFXSamplerAutoAlloc+0x11c>
   1d164:	4a1c      	ldr	r2, [pc, #112]	; (1d1d8 <SFXSamplerAutoAlloc+0x120>)
   1d166:	ee20 0a27 	vmul.f32	s0, s0, s15
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
   1d16a:	692b      	ldr	r3, [r5, #16]
            randLengthVal = leaf.random() * 10000.0f;
   1d16c:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   1d170:	ed82 0a00 	vstr	s0, [r2]
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
   1d174:	4798      	blx	r3
   1d176:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1d17a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
            setLED_C(pitchQuantization);
   1d17e:	4a17      	ldr	r2, [pc, #92]	; (1d1dc <SFXSamplerAutoAlloc+0x124>)
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
   1d180:	4b17      	ldr	r3, [pc, #92]	; (1d1e0 <SFXSamplerAutoAlloc+0x128>)
   1d182:	ee30 0a67 	vsub.f32	s0, s0, s15
            setLED_C(pitchQuantization);
   1d186:	7810      	ldrb	r0, [r2, #0]
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
   1d188:	ee20 0a07 	vmul.f32	s0, s0, s14
   1d18c:	ed83 0a00 	vstr	s0, [r3]
        }
   1d190:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            setLED_C(pitchQuantization);
   1d194:	f7fc b998 	b.w	194c8 <setLED_C>
   1d198:	020f9dc8 	.word	0x020f9dc8
   1d19c:	0002ee00 	.word	0x0002ee00
   1d1a0:	020fabc0 	.word	0x020fabc0
   1d1a4:	020fa03c 	.word	0x020fa03c
   1d1a8:	020fbd68 	.word	0x020fbd68
   1d1ac:	3f7ff972 	.word	0x3f7ff972
   1d1b0:	3727c5ac 	.word	0x3727c5ac
   1d1b4:	020fac30 	.word	0x020fac30
   1d1b8:	3c23d70a 	.word	0x3c23d70a
   1d1bc:	00000000 	.word	0x00000000
   1d1c0:	020f9b20 	.word	0x020f9b20
   1d1c4:	00062801 	.word	0x00062801
   1d1c8:	020e2ed5 	.word	0x020e2ed5
   1d1cc:	020e2e3c 	.word	0x020e2e3c
   1d1d0:	020e2ed0 	.word	0x020e2ed0
   1d1d4:	461c4000 	.word	0x461c4000
   1d1d8:	020e2eb4 	.word	0x020e2eb4
   1d1dc:	020e2ea4 	.word	0x020e2ea4
   1d1e0:	020e2eb8 	.word	0x020e2eb8
   1d1e4:	020f9dd8 	.word	0x020f9dd8

0001d1e8 <SFXSamplerAutoFrame>:
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1d1e8:	4b07      	ldr	r3, [pc, #28]	; (1d208 <SFXSamplerAutoFrame+0x20>)
   1d1ea:	7f1a      	ldrb	r2, [r3, #28]
   1d1ec:	2a01      	cmp	r2, #1
   1d1ee:	d000      	beq.n	1d1f2 <SFXSamplerAutoFrame+0xa>
        }
   1d1f0:	4770      	bx	lr
                pitchQuantization = !pitchQuantization;
   1d1f2:	4906      	ldr	r1, [pc, #24]	; (1d20c <SFXSamplerAutoFrame+0x24>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1d1f4:	2000      	movs	r0, #0
                pitchQuantization = !pitchQuantization;
   1d1f6:	680a      	ldr	r2, [r1, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1d1f8:	7718      	strb	r0, [r3, #28]
                pitchQuantization = !pitchQuantization;
   1d1fa:	fab2 f282 	clz	r2, r2
   1d1fe:	0952      	lsrs	r2, r2, #5
                setLED_C(pitchQuantization);
   1d200:	4610      	mov	r0, r2
                pitchQuantization = !pitchQuantization;
   1d202:	600a      	str	r2, [r1, #0]
                setLED_C(pitchQuantization);
   1d204:	f7fc b960 	b.w	194c8 <setLED_C>
   1d208:	020fafac 	.word	0x020fafac
   1d20c:	020e2ea4 	.word	0x020e2ea4

0001d210 <SFXSamplerAutoTick>:
        {
   1d210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (triggerChannel > 0)
   1d214:	f8df 935c 	ldr.w	r9, [pc, #860]	; 1d574 <SFXSamplerAutoTick+0x364>
        {
   1d218:	4604      	mov	r4, r0
            if (triggerChannel > 0)
   1d21a:	f899 3000 	ldrb.w	r3, [r9]
        {
   1d21e:	ed2d 8b06 	vpush	{d8-d10}
   1d222:	b089      	sub	sp, #36	; 0x24
            if (triggerChannel > 0)
   1d224:	2b00      	cmp	r3, #0
   1d226:	d072      	beq.n	1d30e <SFXSamplerAutoTick+0xfe>
                currentPower = tEnvelopeFollower_tick(&envfollow, input[0]);
   1d228:	4db9      	ldr	r5, [pc, #740]	; (1d510 <SFXSamplerAutoTick+0x300>)
   1d22a:	ed90 0a00 	vldr	s0, [r0]
   1d22e:	48b9      	ldr	r0, [pc, #740]	; (1d514 <SFXSamplerAutoTick+0x304>)
   1d230:	f006 ffa8 	bl	24184 <tEnvelopeFollower_tick>
   1d234:	ed85 0a00 	vstr	s0, [r5]
            samp_thresh = 1.0f - knobs[0];
   1d238:	4ab7      	ldr	r2, [pc, #732]	; (1d518 <SFXSamplerAutoTick+0x308>)
   1d23a:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1d23e:	4bb7      	ldr	r3, [pc, #732]	; (1d51c <SFXSamplerAutoTick+0x30c>)
   1d240:	eef6 4a00 	vmov.f32	s9, #96	; 0x3f000000  0.5
   1d244:	edd2 6ab0 	vldr	s13, [r2, #704]	; 0x2c0
   1d248:	edd3 7a00 	vldr	s15, [r3]
   1d24c:	49b4      	ldr	r1, [pc, #720]	; (1d520 <SFXSamplerAutoTick+0x310>)
   1d24e:	ee66 6aa7 	vmul.f32	s13, s13, s15
   1d252:	ed9f 5ab4 	vldr	s10, [pc, #720]	; 1d524 <SFXSamplerAutoTick+0x314>
   1d256:	ed9f 7ab4 	vldr	s14, [pc, #720]	; 1d528 <SFXSamplerAutoTick+0x318>
   1d25a:	edd2 7ab2 	vldr	s15, [r2, #712]	; 0x2c8
   1d25e:	eefd 6ae6 	vcvt.s32.f32	s13, s13
            samp_thresh = 1.0f - knobs[0];
   1d262:	ed92 6aaf 	vldr	s12, [r2, #700]	; 0x2bc
   1d266:	ee67 7a87 	vmul.f32	s15, s15, s14
            displayValues[0] = samp_thresh;
   1d26a:	4bb0      	ldr	r3, [pc, #704]	; (1d52c <SFXSamplerAutoTick+0x31c>)
            samp_thresh = 1.0f - knobs[0];
   1d26c:	ee35 6ac6 	vsub.f32	s12, s11, s12
   1d270:	f8df 8304 	ldr.w	r8, [pc, #772]	; 1d578 <SFXSamplerAutoTick+0x368>
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1d274:	ee16 0a90 	vmov	r0, s13
            if (pitchQuantization)
   1d278:	4ead      	ldr	r6, [pc, #692]	; (1d530 <SFXSamplerAutoTick+0x320>)
   1d27a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1d27e:	ed92 7ab1 	vldr	s14, [r2, #708]	; 0x2c4
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1d282:	eb01 0180 	add.w	r1, r1, r0, lsl #2
            displayValues[0] = samp_thresh;
   1d286:	ed83 6a00 	vstr	s12, [r3]
            samp_thresh = 1.0f - knobs[0];
   1d28a:	ed88 6a00 	vstr	s12, [r8]
   1d28e:	ee37 7a64 	vsub.f32	s14, s14, s9
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1d292:	edd1 0a00 	vldr	s1, [r1]
   1d296:	eef8 6ae7 	vcvt.f32.s32	s13, s15
   1d29a:	ed92 9ab4 	vldr	s18, [r2, #720]	; 0x2d0
   1d29e:	ee60 0a85 	vmul.f32	s1, s1, s10
            if (pitchQuantization)
   1d2a2:	6831      	ldr	r1, [r6, #0]
   1d2a4:	ed9f 5aa3 	vldr	s10, [pc, #652]	; 1d534 <SFXSamplerAutoTick+0x324>
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1d2a8:	eefd 8ae0 	vcvt.s32.f32	s17, s1
   1d2ac:	ee29 9a05 	vmul.f32	s18, s18, s10
            displayValues[1] = window_size;
   1d2b0:	eeb8 6ae8 	vcvt.f32.s32	s12, s17
   1d2b4:	ed83 6a01 	vstr	s12, [r3, #4]
            if (pitchQuantization)
   1d2b8:	b391      	cbz	r1, 1d320 <SFXSamplerAutoTick+0x110>
                rate = roundf((knobs[2] - 0.5f) * 14.0f);
   1d2ba:	eeb2 5a0c 	vmov.f32	s10, #44	; 0x41600000  14.0
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1d2be:	ed9f 6a9e 	vldr	s12, [pc, #632]	; 1d538 <SFXSamplerAutoTick+0x328>
                rate = roundf((knobs[2] - 0.5f) * 14.0f);
   1d2c2:	ee27 7a05 	vmul.f32	s14, s14, s10
   1d2c6:	feb8 7a47 	vrinta.f32	s14, s14
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1d2ca:	eeb4 7ac6 	vcmpe.f32	s14, s12
   1d2ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d2d2:	f100 81a4 	bmi.w	1d61e <SFXSamplerAutoTick+0x40e>
                else rate += 1.0f;
   1d2d6:	ee77 9a25 	vadd.f32	s19, s14, s11
            crossfadeLength = knobs[3] * 1000.0f;
   1d2da:	4f98      	ldr	r7, [pc, #608]	; (1d53c <SFXSamplerAutoTick+0x32c>)
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d2dc:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
            displayValues[3] = crossfadeLength;
   1d2e0:	edc3 6a03 	vstr	s13, [r3, #12]
            crossfadeLength = knobs[3] * 1000.0f;
   1d2e4:	edc7 7a00 	vstr	s15, [r7]
            displayValues[2] = rate;
   1d2e8:	edc3 9a02 	vstr	s19, [r3, #8]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d2ec:	eeb4 9ac7 	vcmpe.f32	s18, s14
   1d2f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d2f4:	f100 81aa 	bmi.w	1d64c <SFXSamplerAutoTick+0x43c>
            displayValues[5] = randLengthAmount;
   1d2f8:	ed83 9a05 	vstr	s18, [r3, #20]
                randRateAmount = roundf(knobs[6] * 8.0f);
   1d2fc:	eeb2 0a00 	vmov.f32	s0, #32	; 0x41000000  8.0
   1d300:	ed92 8ab5 	vldr	s16, [r2, #724]	; 0x2d4
   1d304:	ee28 8a00 	vmul.f32	s16, s16, s0
   1d308:	feb8 8a48 	vrinta.f32	s16, s16
   1d30c:	e02e      	b.n	1d36c <SFXSamplerAutoTick+0x15c>
                currentPower = tEnvelopeFollower_tick(&envfollow, input[1]);
   1d30e:	4d80      	ldr	r5, [pc, #512]	; (1d510 <SFXSamplerAutoTick+0x300>)
   1d310:	ed90 0a01 	vldr	s0, [r0, #4]
   1d314:	487f      	ldr	r0, [pc, #508]	; (1d514 <SFXSamplerAutoTick+0x304>)
   1d316:	f006 ff35 	bl	24184 <tEnvelopeFollower_tick>
   1d31a:	ed85 0a00 	vstr	s0, [r5]
   1d31e:	e78b      	b.n	1d238 <SFXSamplerAutoTick+0x28>
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d320:	eeb3 6a04 	vmov.f32	s12, #52	; 0x41a00000  20.0
            crossfadeLength = knobs[3] * 1000.0f;
   1d324:	4f85      	ldr	r7, [pc, #532]	; (1d53c <SFXSamplerAutoTick+0x32c>)
                rate = (knobs[2] - 0.5f) * 4.0f;
   1d326:	eef1 9a00 	vmov.f32	s19, #16	; 0x40800000  4.0
            displayValues[3] = crossfadeLength;
   1d32a:	edc3 6a03 	vstr	s13, [r3, #12]
            crossfadeLength = knobs[3] * 1000.0f;
   1d32e:	edc7 7a00 	vstr	s15, [r7]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d332:	eeb4 9ac6 	vcmpe.f32	s18, s12
                rate = (knobs[2] - 0.5f) * 4.0f;
   1d336:	ee67 9a29 	vmul.f32	s19, s14, s19
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d33a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            displayValues[2] = rate;
   1d33e:	edc3 9a02 	vstr	s19, [r3, #8]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d342:	f100 80d9 	bmi.w	1d4f8 <SFXSamplerAutoTick+0x2e8>
            displayValues[5] = randLengthAmount;
   1d346:	ed83 9a05 	vstr	s18, [r3, #20]
                randRateAmount = knobs[6] * 2.0f;
   1d34a:	ed92 8ab5 	vldr	s16, [r2, #724]	; 0x2d4
                if (randRateAmount < 0.01) randRateAmount = 0.0f;
   1d34e:	ed9f 7a7a 	vldr	s14, [pc, #488]	; 1d538 <SFXSamplerAutoTick+0x328>
                randRateAmount = knobs[6] * 2.0f;
   1d352:	ee38 8a08 	vadd.f32	s16, s16, s16
                if (randRateAmount < 0.01) randRateAmount = 0.0f;
   1d356:	ed9f 6b6c 	vldr	d6, [pc, #432]	; 1d508 <SFXSamplerAutoTick+0x2f8>
   1d35a:	eeb7 5ac8 	vcvt.f64.f32	d5, s16
   1d35e:	eeb4 5b46 	vcmp.f64	d5, d6
   1d362:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d366:	bf48      	it	mi
   1d368:	eeb0 8a47 	vmovmi.f32	s16, s14
            tSampler_setCrossfadeLength(&asSampler[0], crossfadeLength);
   1d36c:	ee17 1a90 	vmov	r1, s15
   1d370:	4873      	ldr	r0, [pc, #460]	; (1d540 <SFXSamplerAutoTick+0x330>)
            displayValues[6] = randRateAmount;
   1d372:	ed83 8a06 	vstr	s16, [r3, #24]
            tSampler_setCrossfadeLength(&asSampler[0], crossfadeLength);
   1d376:	f00e fd0d 	bl	2bd94 <tSampler_setCrossfadeLength>
            tSampler_setCrossfadeLength(&asSampler[1], crossfadeLength);
   1d37a:	6839      	ldr	r1, [r7, #0]
   1d37c:	4871      	ldr	r0, [pc, #452]	; (1d544 <SFXSamplerAutoTick+0x334>)
   1d37e:	f00e fd09 	bl	2bd94 <tSampler_setCrossfadeLength>
            if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
   1d382:	ed95 7a00 	vldr	s14, [r5]
   1d386:	edd8 7a00 	vldr	s15, [r8]
   1d38a:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 1d57c <SFXSamplerAutoTick+0x36c>
   1d38e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1d392:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d396:	f340 80b4 	ble.w	1d502 <SFXSamplerAutoTick+0x2f2>
   1d39a:	edda 7a00 	vldr	s15, [sl]
   1d39e:	eddf 6a6a 	vldr	s13, [pc, #424]	; 1d548 <SFXSamplerAutoTick+0x338>
   1d3a2:	ed95 7a00 	vldr	s14, [r5]
   1d3a6:	ee77 7aa6 	vadd.f32	s15, s15, s13
   1d3aa:	eef4 7ac7 	vcmpe.f32	s15, s14
   1d3ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d3b2:	f140 80a6 	bpl.w	1d502 <SFXSamplerAutoTick+0x2f2>
   1d3b6:	4f65      	ldr	r7, [pc, #404]	; (1d54c <SFXSamplerAutoTick+0x33c>)
   1d3b8:	f8df b1c4 	ldr.w	fp, [pc, #452]	; 1d580 <SFXSamplerAutoTick+0x370>
   1d3bc:	683b      	ldr	r3, [r7, #0]
   1d3be:	2b00      	cmp	r3, #0
   1d3c0:	f000 8149 	beq.w	1d656 <SFXSamplerAutoTick+0x446>
   1d3c4:	4b62      	ldr	r3, [pc, #392]	; (1d550 <SFXSamplerAutoTick+0x340>)
   1d3c6:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 1d584 <SFXSamplerAutoTick+0x374>
   1d3ca:	9301      	str	r3, [sp, #4]
   1d3cc:	4f61      	ldr	r7, [pc, #388]	; (1d554 <SFXSamplerAutoTick+0x344>)
   1d3ce:	4b5c      	ldr	r3, [pc, #368]	; (1d540 <SFXSamplerAutoTick+0x330>)
   1d3d0:	9302      	str	r3, [sp, #8]
            tBuffer_tick(&asBuff[0], input[1]);
   1d3d2:	ed94 0a01 	vldr	s0, [r4, #4]
   1d3d6:	4860      	ldr	r0, [pc, #384]	; (1d558 <SFXSamplerAutoTick+0x348>)
   1d3d8:	f00e fbde 	bl	2bb98 <tBuffer_tick>
            tBuffer_tick(&asBuff[1], input[1]);
   1d3dc:	ed94 0a01 	vldr	s0, [r4, #4]
   1d3e0:	485e      	ldr	r0, [pc, #376]	; (1d55c <SFXSamplerAutoTick+0x34c>)
   1d3e2:	f00e fbd9 	bl	2bb98 <tBuffer_tick>
            if (sample_countdown > 0)
   1d3e6:	f8db 2000 	ldr.w	r2, [fp]
   1d3ea:	2a00      	cmp	r2, #0
   1d3ec:	f000 80ce 	beq.w	1d58c <SFXSamplerAutoTick+0x37c>
                sample_countdown--;
   1d3f0:	3a01      	subs	r2, #1
   1d3f2:	f8cb 2000 	str.w	r2, [fp]
            if (pitchQuantization)
   1d3f6:	6833      	ldr	r3, [r6, #0]
   1d3f8:	ed98 0a00 	vldr	s0, [r8]
   1d3fc:	2b00      	cmp	r3, #0
   1d3fe:	f000 80f4 	beq.w	1d5ea <SFXSamplerAutoTick+0x3da>
                tSampler_setRate(&asSampler[0], rate * randRateVal);
   1d402:	ee29 0a80 	vmul.f32	s0, s19, s0
   1d406:	484e      	ldr	r0, [pc, #312]	; (1d540 <SFXSamplerAutoTick+0x330>)
   1d408:	f00f f9de 	bl	2c7c8 <tSampler_setRate>
                tSampler_setRate(&asSampler[1], rate * randRateVal);
   1d40c:	ed98 0a00 	vldr	s0, [r8]
   1d410:	484c      	ldr	r0, [pc, #304]	; (1d544 <SFXSamplerAutoTick+0x334>)
   1d412:	ee29 0a80 	vmul.f32	s0, s19, s0
   1d416:	f00f f9d7 	bl	2c7c8 <tSampler_setRate>
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d41a:	9b01      	ldr	r3, [sp, #4]
   1d41c:	ee18 2a90 	vmov	r2, s17
   1d420:	ed9f 1a40 	vldr	s2, [pc, #256]	; 1d524 <SFXSamplerAutoTick+0x314>
   1d424:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1d428:	681b      	ldr	r3, [r3, #0]
            if (buttonActionsSFX[ButtonA][ActionPress])
   1d42a:	4e4d      	ldr	r6, [pc, #308]	; (1d560 <SFXSamplerAutoTick+0x350>)
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d42c:	441a      	add	r2, r3
   1d42e:	ee00 2a90 	vmov	s1, r2
   1d432:	eef8 0ae0 	vcvt.f32.s32	s1, s1
   1d436:	f00c f977 	bl	29728 <LEAF_clip>
   1d43a:	eefd 7ac0 	vcvt.s32.f32	s15, s0
            tSampler_setEnd(&asSampler[0], finalWindowSize);
   1d43e:	4840      	ldr	r0, [pc, #256]	; (1d540 <SFXSamplerAutoTick+0x330>)
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d440:	ee17 1a90 	vmov	r1, s15
   1d444:	edc7 7a00 	vstr	s15, [r7]
            tSampler_setEnd(&asSampler[0], finalWindowSize);
   1d448:	f00e fdac 	bl	2bfa4 <tSampler_setEnd>
            tSampler_setEnd(&asSampler[1], finalWindowSize);
   1d44c:	6839      	ldr	r1, [r7, #0]
   1d44e:	483d      	ldr	r0, [pc, #244]	; (1d544 <SFXSamplerAutoTick+0x334>)
   1d450:	f00e fda8 	bl	2bfa4 <tSampler_setEnd>
            if (buttonActionsSFX[ButtonA][ActionPress])
   1d454:	7d33      	ldrb	r3, [r6, #20]
   1d456:	b14b      	cbz	r3, 1d46c <SFXSamplerAutoTick+0x25c>
                if (samplerMode == PlayLoop)
   1d458:	f8df 812c 	ldr.w	r8, [pc, #300]	; 1d588 <SFXSamplerAutoTick+0x378>
   1d45c:	f898 7000 	ldrb.w	r7, [r8]
   1d460:	2f01      	cmp	r7, #1
   1d462:	f000 815a 	beq.w	1d71a <SFXSamplerAutoTick+0x50a>
                else if (samplerMode == PlayBackAndForth)
   1d466:	2f02      	cmp	r7, #2
   1d468:	f000 8168 	beq.w	1d73c <SFXSamplerAutoTick+0x52c>
            if (buttonActionsSFX[ButtonB][ActionPress])
   1d46c:	7e33      	ldrb	r3, [r6, #24]
   1d46e:	2b00      	cmp	r3, #0
   1d470:	f040 80c8 	bne.w	1d604 <SFXSamplerAutoTick+0x3f4>
            float fade = tExpSmooth_tick(&cfxSmooth);
   1d474:	4e3b      	ldr	r6, [pc, #236]	; (1d564 <SFXSamplerAutoTick+0x354>)
   1d476:	4630      	mov	r0, r6
   1d478:	f00a fccc 	bl	27e14 <tExpSmooth_tick>
            if (fabsf(cfxSmooth->curr - cfxSmooth->dest) < 0.00001f)
   1d47c:	6833      	ldr	r3, [r6, #0]
   1d47e:	ed9f 7a3a 	vldr	s14, [pc, #232]	; 1d568 <SFXSamplerAutoTick+0x358>
   1d482:	edd3 7a03 	vldr	s15, [r3, #12]
   1d486:	edd3 6a04 	vldr	s13, [r3, #16]
   1d48a:	ee77 7ae6 	vsub.f32	s15, s15, s13
   1d48e:	eef0 7ae7 	vabs.f32	s15, s15
   1d492:	eef4 7ac7 	vcmpe.f32	s15, s14
   1d496:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d49a:	d502      	bpl.n	1d4a2 <SFXSamplerAutoTick+0x292>
                fadeDone = 1;
   1d49c:	4b33      	ldr	r3, [pc, #204]	; (1d56c <SFXSamplerAutoTick+0x35c>)
   1d49e:	2201      	movs	r2, #1
   1d4a0:	601a      	str	r2, [r3, #0]
            LEAF_crossfade((fade * 2.0f) - 1.0f, volumes);
   1d4a2:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
   1d4a6:	a806      	add	r0, sp, #24
   1d4a8:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   1d4ac:	eee0 7a07 	vfma.f32	s15, s0, s14
   1d4b0:	eeb0 0a67 	vmov.f32	s0, s15
   1d4b4:	f00c f8b4 	bl	29620 <LEAF_crossfade>
            sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
   1d4b8:	4821      	ldr	r0, [pc, #132]	; (1d540 <SFXSamplerAutoTick+0x330>)
   1d4ba:	f00e fe09 	bl	2c0d0 <tSampler_tick>
   1d4be:	4821      	ldr	r0, [pc, #132]	; (1d544 <SFXSamplerAutoTick+0x334>)
   1d4c0:	eef0 8a40 	vmov.f32	s17, s0
   1d4c4:	ed9d 8a07 	vldr	s16, [sp, #28]
   1d4c8:	f00e fe02 	bl	2c0d0 <tSampler_tick>
   1d4cc:	eddd 7a06 	vldr	s15, [sp, #24]
            input[0] = sample * 0.99f;
   1d4d0:	ed9f 7a27 	vldr	s14, [pc, #156]	; 1d570 <SFXSamplerAutoTick+0x360>
            sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
   1d4d4:	ee20 0a27 	vmul.f32	s0, s0, s15
            previousPower = currentPower;
   1d4d8:	682b      	ldr	r3, [r5, #0]
   1d4da:	f8ca 3000 	str.w	r3, [sl]
            sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
   1d4de:	eea8 0a88 	vfma.f32	s0, s17, s16
            input[0] = sample * 0.99f;
   1d4e2:	ee20 0a07 	vmul.f32	s0, s0, s14
   1d4e6:	ed84 0a00 	vstr	s0, [r4]
            input[1] = sample * 0.99f;
   1d4ea:	ed84 0a01 	vstr	s0, [r4, #4]
        }
   1d4ee:	b009      	add	sp, #36	; 0x24
   1d4f0:	ecbd 8b06 	vpop	{d8-d10}
   1d4f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            displayValues[5] = randLengthAmount;
   1d4f8:	ed9f 9a0f 	vldr	s18, [pc, #60]	; 1d538 <SFXSamplerAutoTick+0x328>
   1d4fc:	ed83 9a05 	vstr	s18, [r3, #20]
   1d500:	e723      	b.n	1d34a <SFXSamplerAutoTick+0x13a>
   1d502:	f8df b07c 	ldr.w	fp, [pc, #124]	; 1d580 <SFXSamplerAutoTick+0x370>
   1d506:	e75d      	b.n	1d3c4 <SFXSamplerAutoTick+0x1b4>
   1d508:	47ae147b 	.word	0x47ae147b
   1d50c:	3f847ae1 	.word	0x3f847ae1
   1d510:	020e2e38 	.word	0x020e2e38
   1d514:	020fac30 	.word	0x020fac30
   1d518:	020e55d8 	.word	0x020e55d8
   1d51c:	00062794 	.word	0x00062794
   1d520:	020f990c 	.word	0x020f990c
   1d524:	483b8000 	.word	0x483b8000
   1d528:	447a0000 	.word	0x447a0000
   1d52c:	020fb05c 	.word	0x020fb05c
   1d530:	020e2ea4 	.word	0x020e2ea4
   1d534:	459c4000 	.word	0x459c4000
   1d538:	00000000 	.word	0x00000000
   1d53c:	020e2e2c 	.word	0x020e2e2c
   1d540:	020fa03c 	.word	0x020fa03c
   1d544:	020fa040 	.word	0x020fa040
   1d548:	3a83126f 	.word	0x3a83126f
   1d54c:	020e2ec0 	.word	0x020e2ec0
   1d550:	020e2eb4 	.word	0x020e2eb4
   1d554:	00062798 	.word	0x00062798
   1d558:	020f9dc8 	.word	0x020f9dc8
   1d55c:	020f9dcc 	.word	0x020f9dcc
   1d560:	020fafac 	.word	0x020fafac
   1d564:	020f9b20 	.word	0x020f9b20
   1d568:	3727c5ac 	.word	0x3727c5ac
   1d56c:	020e2e4c 	.word	0x020e2e4c
   1d570:	3f7d70a4 	.word	0x3f7d70a4
   1d574:	020e2ed5 	.word	0x020e2ed5
   1d578:	020e2ebc 	.word	0x020e2ebc
   1d57c:	020e2eb0 	.word	0x020e2eb0
   1d580:	020e2ed0 	.word	0x020e2ed0
   1d584:	020e2eb8 	.word	0x020e2eb8
   1d588:	00062801 	.word	0x00062801
            else if (samp_triggered == 1)
   1d58c:	4b7b      	ldr	r3, [pc, #492]	; (1d77c <SFXSamplerAutoTick+0x56c>)
   1d58e:	6819      	ldr	r1, [r3, #0]
   1d590:	2901      	cmp	r1, #1
   1d592:	f47f af30 	bne.w	1d3f6 <SFXSamplerAutoTick+0x1e6>
                currentSampler = !currentSampler;
   1d596:	497a      	ldr	r1, [pc, #488]	; (1d780 <SFXSamplerAutoTick+0x570>)
                setLED_1(0);
   1d598:	4610      	mov	r0, r2
   1d59a:	9203      	str	r2, [sp, #12]
   1d59c:	9305      	str	r3, [sp, #20]
                currentSampler = !currentSampler;
   1d59e:	9104      	str	r1, [sp, #16]
                setLED_1(0);
   1d5a0:	f7fb ff56 	bl	19450 <setLED_1>
                currentSampler = !currentSampler;
   1d5a4:	9904      	ldr	r1, [sp, #16]
                tSampler_play(&asSampler[currentSampler]);
   1d5a6:	9b02      	ldr	r3, [sp, #8]
                currentSampler = !currentSampler;
   1d5a8:	f891 c000 	ldrb.w	ip, [r1]
   1d5ac:	9102      	str	r1, [sp, #8]
   1d5ae:	fabc fc8c 	clz	ip, ip
   1d5b2:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
                tSampler_play(&asSampler[currentSampler]);
   1d5b6:	eb03 008c 	add.w	r0, r3, ip, lsl #2
                currentSampler = !currentSampler;
   1d5ba:	f881 c000 	strb.w	ip, [r1]
                tSampler_play(&asSampler[currentSampler]);
   1d5be:	f00e fbff 	bl	2bdc0 <tSampler_play>
                tExpSmooth_setDest(&cfxSmooth,(float)currentSampler);
   1d5c2:	9902      	ldr	r1, [sp, #8]
   1d5c4:	486f      	ldr	r0, [pc, #444]	; (1d784 <SFXSamplerAutoTick+0x574>)
   1d5c6:	780b      	ldrb	r3, [r1, #0]
   1d5c8:	ee00 3a10 	vmov	s0, r3
   1d5cc:	eeb8 0a40 	vcvt.f32.u32	s0, s0
   1d5d0:	f00a fc16 	bl	27e00 <tExpSmooth_setDest>
                samp_triggered = 0;
   1d5d4:	9a03      	ldr	r2, [sp, #12]
   1d5d6:	9b05      	ldr	r3, [sp, #20]
                fadeDone = 0;
   1d5d8:	496b      	ldr	r1, [pc, #428]	; (1d788 <SFXSamplerAutoTick+0x578>)
                samp_triggered = 0;
   1d5da:	601a      	str	r2, [r3, #0]
            if (pitchQuantization)
   1d5dc:	6833      	ldr	r3, [r6, #0]
                fadeDone = 0;
   1d5de:	600a      	str	r2, [r1, #0]
   1d5e0:	ed98 0a00 	vldr	s0, [r8]
            if (pitchQuantization)
   1d5e4:	2b00      	cmp	r3, #0
   1d5e6:	f47f af0c 	bne.w	1d402 <SFXSamplerAutoTick+0x1f2>
                tSampler_setRate(&asSampler[0], rate + randRateVal);
   1d5ea:	ee39 0a80 	vadd.f32	s0, s19, s0
   1d5ee:	4867      	ldr	r0, [pc, #412]	; (1d78c <SFXSamplerAutoTick+0x57c>)
   1d5f0:	f00f f8ea 	bl	2c7c8 <tSampler_setRate>
                tSampler_setRate(&asSampler[1], rate + randRateVal);
   1d5f4:	ed98 0a00 	vldr	s0, [r8]
   1d5f8:	4865      	ldr	r0, [pc, #404]	; (1d790 <SFXSamplerAutoTick+0x580>)
   1d5fa:	ee39 0a80 	vadd.f32	s0, s19, s0
   1d5fe:	f00f f8e3 	bl	2c7c8 <tSampler_setRate>
   1d602:	e70a      	b.n	1d41a <SFXSamplerAutoTick+0x20a>
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1d604:	f899 3000 	ldrb.w	r3, [r9]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1d608:	2200      	movs	r2, #0
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1d60a:	fab3 f383 	clz	r3, r3
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1d60e:	7632      	strb	r2, [r6, #24]
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1d610:	095b      	lsrs	r3, r3, #5
                setLED_B(triggerChannel);
   1d612:	4618      	mov	r0, r3
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1d614:	f889 3000 	strb.w	r3, [r9]
                setLED_B(triggerChannel);
   1d618:	f7fb ff48 	bl	194ac <setLED_B>
   1d61c:	e72a      	b.n	1d474 <SFXSamplerAutoTick+0x264>
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1d61e:	ee37 7a65 	vsub.f32	s14, s14, s11
            crossfadeLength = knobs[3] * 1000.0f;
   1d622:	4f5c      	ldr	r7, [pc, #368]	; (1d794 <SFXSamplerAutoTick+0x584>)
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d624:	eeb3 5a04 	vmov.f32	s10, #52	; 0x41a00000  20.0
            displayValues[3] = crossfadeLength;
   1d628:	edc3 6a03 	vstr	s13, [r3, #12]
            crossfadeLength = knobs[3] * 1000.0f;
   1d62c:	edc7 7a00 	vstr	s15, [r7]
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1d630:	eeb0 7ac7 	vabs.f32	s14, s14
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d634:	eeb4 9a45 	vcmp.f32	s18, s10
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1d638:	eec5 9a87 	vdiv.f32	s19, s11, s14
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d63c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d640:	bf48      	it	mi
   1d642:	eeb0 9a46 	vmovmi.f32	s18, s12
            displayValues[2] = rate;
   1d646:	edc3 9a02 	vstr	s19, [r3, #8]
   1d64a:	e655      	b.n	1d2f8 <SFXSamplerAutoTick+0xe8>
            displayValues[5] = randLengthAmount;
   1d64c:	ed83 6a05 	vstr	s12, [r3, #20]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d650:	eeb0 9a46 	vmov.f32	s18, s12
   1d654:	e652      	b.n	1d2fc <SFXSamplerAutoTick+0xec>
            if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
   1d656:	f8db 2000 	ldr.w	r2, [fp]
   1d65a:	2a00      	cmp	r2, #0
   1d65c:	f47f aeb2 	bne.w	1d3c4 <SFXSamplerAutoTick+0x1b4>
   1d660:	4a49      	ldr	r2, [pc, #292]	; (1d788 <SFXSamplerAutoTick+0x578>)
   1d662:	6812      	ldr	r2, [r2, #0]
   1d664:	2a01      	cmp	r2, #1
   1d666:	f47f aead 	bne.w	1d3c4 <SFXSamplerAutoTick+0x1b4>
                randLengthVal = (leaf.random() - 0.5f) * randLengthAmount * 2.0f;
   1d66a:	f8df 813c 	ldr.w	r8, [pc, #316]	; 1d7a8 <SFXSamplerAutoTick+0x598>
   1d66e:	eeb6 aa00 	vmov.f32	s20, #96	; 0x3f000000  0.5
   1d672:	4b49      	ldr	r3, [pc, #292]	; (1d798 <SFXSamplerAutoTick+0x588>)
   1d674:	ee39 9a09 	vadd.f32	s18, s18, s18
   1d678:	f8d8 2010 	ldr.w	r2, [r8, #16]
   1d67c:	9301      	str	r3, [sp, #4]
   1d67e:	4790      	blx	r2
   1d680:	ee30 0a4a 	vsub.f32	s0, s0, s20
   1d684:	9b01      	ldr	r3, [sp, #4]
                if (pitchQuantization) randRateVal = roundf(leaf.random() * randRateAmount) + 1.0f;
   1d686:	6832      	ldr	r2, [r6, #0]
                randLengthVal = (leaf.random() - 0.5f) * randLengthAmount * 2.0f;
   1d688:	ee20 0a09 	vmul.f32	s0, s0, s18
   1d68c:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   1d690:	ed83 0a00 	vstr	s0, [r3]
                if (pitchQuantization) randRateVal = roundf(leaf.random() * randRateAmount) + 1.0f;
   1d694:	2a00      	cmp	r2, #0
   1d696:	d062      	beq.n	1d75e <SFXSamplerAutoTick+0x54e>
   1d698:	f8d8 2010 	ldr.w	r2, [r8, #16]
   1d69c:	4790      	blx	r2
   1d69e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1d6a2:	ee60 7a08 	vmul.f32	s15, s0, s16
   1d6a6:	f8df 8104 	ldr.w	r8, [pc, #260]	; 1d7ac <SFXSamplerAutoTick+0x59c>
   1d6aa:	fef8 7a67 	vrinta.f32	s15, s15
   1d6ae:	ee77 7a87 	vadd.f32	s15, s15, s14
   1d6b2:	edc8 7a00 	vstr	s15, [r8]
                samp_triggered = 1;
   1d6b6:	2201      	movs	r2, #1
                tSampler_stop(&asSampler[!currentSampler]);
   1d6b8:	4b34      	ldr	r3, [pc, #208]	; (1d78c <SFXSamplerAutoTick+0x57c>)
                setLED_1(1);
   1d6ba:	4610      	mov	r0, r2
                tSampler_stop(&asSampler[!currentSampler]);
   1d6bc:	9302      	str	r3, [sp, #8]
                samp_triggered = 1;
   1d6be:	603a      	str	r2, [r7, #0]
                setLED_1(1);
   1d6c0:	f7fb fec6 	bl	19450 <setLED_1>
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d6c4:	9a01      	ldr	r2, [sp, #4]
   1d6c6:	ee18 1a90 	vmov	r1, s17
   1d6ca:	ed9f 1a34 	vldr	s2, [pc, #208]	; 1d79c <SFXSamplerAutoTick+0x58c>
   1d6ce:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1d6d2:	6812      	ldr	r2, [r2, #0]
   1d6d4:	4f32      	ldr	r7, [pc, #200]	; (1d7a0 <SFXSamplerAutoTick+0x590>)
   1d6d6:	188a      	adds	r2, r1, r2
   1d6d8:	ee00 2a90 	vmov	s1, r2
   1d6dc:	eef8 0ae0 	vcvt.f32.s32	s1, s1
   1d6e0:	f00c f822 	bl	29728 <LEAF_clip>
                tSampler_stop(&asSampler[!currentSampler]);
   1d6e4:	4a26      	ldr	r2, [pc, #152]	; (1d780 <SFXSamplerAutoTick+0x570>)
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d6e6:	eefd 7ac0 	vcvt.s32.f32	s15, s0
                tSampler_stop(&asSampler[!currentSampler]);
   1d6ea:	9b02      	ldr	r3, [sp, #8]
   1d6ec:	7810      	ldrb	r0, [r2, #0]
   1d6ee:	fab0 f080 	clz	r0, r0
                sample_countdown = finalWindowSize;
   1d6f2:	edcb 7a00 	vstr	s15, [fp]
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d6f6:	edc7 7a00 	vstr	s15, [r7]
                tSampler_stop(&asSampler[!currentSampler]);
   1d6fa:	0940      	lsrs	r0, r0, #5
   1d6fc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1d700:	f00e fbae 	bl	2be60 <tSampler_stop>
                tBuffer_record(&asBuff[!currentSampler]);
   1d704:	4a1e      	ldr	r2, [pc, #120]	; (1d780 <SFXSamplerAutoTick+0x570>)
   1d706:	4827      	ldr	r0, [pc, #156]	; (1d7a4 <SFXSamplerAutoTick+0x594>)
   1d708:	7812      	ldrb	r2, [r2, #0]
   1d70a:	fab2 f282 	clz	r2, r2
   1d70e:	0952      	lsrs	r2, r2, #5
   1d710:	eb00 0082 	add.w	r0, r0, r2, lsl #2
   1d714:	f00e fa70 	bl	2bbf8 <tBuffer_record>
   1d718:	e65b      	b.n	1d3d2 <SFXSamplerAutoTick+0x1c2>
                    tSampler_setMode(&asSampler[0], PlayBackAndForth);
   1d71a:	2102      	movs	r1, #2
   1d71c:	481b      	ldr	r0, [pc, #108]	; (1d78c <SFXSamplerAutoTick+0x57c>)
   1d71e:	f00e fb35 	bl	2bd8c <tSampler_setMode>
                    tSampler_setMode(&asSampler[1], PlayBackAndForth);
   1d722:	2102      	movs	r1, #2
   1d724:	481a      	ldr	r0, [pc, #104]	; (1d790 <SFXSamplerAutoTick+0x580>)
   1d726:	f00e fb31 	bl	2bd8c <tSampler_setMode>
                    samplerMode = PlayBackAndForth;
   1d72a:	2302      	movs	r3, #2
                    setLED_A(1);
   1d72c:	4638      	mov	r0, r7
                    samplerMode = PlayBackAndForth;
   1d72e:	f888 3000 	strb.w	r3, [r8]
                    setLED_A(1);
   1d732:	f7fb fead 	bl	19490 <setLED_A>
                    buttonActionsSFX[ButtonA][ActionPress] = 0;
   1d736:	2300      	movs	r3, #0
   1d738:	7533      	strb	r3, [r6, #20]
   1d73a:	e697      	b.n	1d46c <SFXSamplerAutoTick+0x25c>
                    tSampler_setMode(&asSampler[0], PlayLoop);
   1d73c:	2101      	movs	r1, #1
   1d73e:	4813      	ldr	r0, [pc, #76]	; (1d78c <SFXSamplerAutoTick+0x57c>)
   1d740:	f00e fb24 	bl	2bd8c <tSampler_setMode>
                    tSampler_setMode(&asSampler[1], PlayLoop);
   1d744:	2101      	movs	r1, #1
   1d746:	4812      	ldr	r0, [pc, #72]	; (1d790 <SFXSamplerAutoTick+0x580>)
   1d748:	f00e fb20 	bl	2bd8c <tSampler_setMode>
                    samplerMode = PlayLoop;
   1d74c:	2301      	movs	r3, #1
                    setLED_A(0);
   1d74e:	2000      	movs	r0, #0
                    samplerMode = PlayLoop;
   1d750:	f888 3000 	strb.w	r3, [r8]
                    setLED_A(0);
   1d754:	f7fb fe9c 	bl	19490 <setLED_A>
                    buttonActionsSFX[ButtonA][ActionPress] = 0;
   1d758:	2300      	movs	r3, #0
   1d75a:	7533      	strb	r3, [r6, #20]
   1d75c:	e686      	b.n	1d46c <SFXSamplerAutoTick+0x25c>
                else randRateVal = (leaf.random() - 0.5f) * randRateAmount * 2.0f;
   1d75e:	f8d8 2010 	ldr.w	r2, [r8, #16]
   1d762:	ee38 8a08 	vadd.f32	s16, s16, s16
   1d766:	4790      	blx	r2
   1d768:	ee30 0a4a 	vsub.f32	s0, s0, s20
   1d76c:	f8df 803c 	ldr.w	r8, [pc, #60]	; 1d7ac <SFXSamplerAutoTick+0x59c>
   1d770:	ee20 8a08 	vmul.f32	s16, s0, s16
   1d774:	ed88 8a00 	vstr	s16, [r8]
   1d778:	e79d      	b.n	1d6b6 <SFXSamplerAutoTick+0x4a6>
   1d77a:	bf00      	nop
   1d77c:	020e2ec0 	.word	0x020e2ec0
   1d780:	020e2e3c 	.word	0x020e2e3c
   1d784:	020f9b20 	.word	0x020f9b20
   1d788:	020e2e4c 	.word	0x020e2e4c
   1d78c:	020fa03c 	.word	0x020fa03c
   1d790:	020fa040 	.word	0x020fa040
   1d794:	020e2e2c 	.word	0x020e2e2c
   1d798:	020e2eb4 	.word	0x020e2eb4
   1d79c:	483b8000 	.word	0x483b8000
   1d7a0:	00062798 	.word	0x00062798
   1d7a4:	020f9dc8 	.word	0x020f9dc8
   1d7a8:	020fbd68 	.word	0x020fbd68
   1d7ac:	020e2eb8 	.word	0x020e2eb8

0001d7b0 <SFXSamplerAutoFree>:
        {
   1d7b0:	b538      	push	{r3, r4, r5, lr}
            tBuffer_free(&asBuff[0]);
   1d7b2:	4d0b      	ldr	r5, [pc, #44]	; (1d7e0 <SFXSamplerAutoFree+0x30>)
            tSampler_free(&asSampler[0]);
   1d7b4:	4c0b      	ldr	r4, [pc, #44]	; (1d7e4 <SFXSamplerAutoFree+0x34>)
            tBuffer_free(&asBuff[0]);
   1d7b6:	4628      	mov	r0, r5
   1d7b8:	f00e f9e2 	bl	2bb80 <tBuffer_free>
            tBuffer_free(&asBuff[1]);
   1d7bc:	1d28      	adds	r0, r5, #4
   1d7be:	f00e f9df 	bl	2bb80 <tBuffer_free>
            tSampler_free(&asSampler[0]);
   1d7c2:	4620      	mov	r0, r4
   1d7c4:	f00e fad6 	bl	2bd74 <tSampler_free>
            tSampler_free(&asSampler[1]);
   1d7c8:	1d20      	adds	r0, r4, #4
   1d7ca:	f00e fad3 	bl	2bd74 <tSampler_free>
            tEnvelopeFollower_free(&envfollow);
   1d7ce:	4806      	ldr	r0, [pc, #24]	; (1d7e8 <SFXSamplerAutoFree+0x38>)
   1d7d0:	f006 fcd4 	bl	2417c <tEnvelopeFollower_free>
            tExpSmooth_free(&cfxSmooth);
   1d7d4:	4805      	ldr	r0, [pc, #20]	; (1d7ec <SFXSamplerAutoFree+0x3c>)
        }
   1d7d6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            tExpSmooth_free(&cfxSmooth);
   1d7da:	f00a bafb 	b.w	27dd4 <tExpSmooth_free>
   1d7de:	bf00      	nop
   1d7e0:	020f9dc8 	.word	0x020f9dc8
   1d7e4:	020fa03c 	.word	0x020fa03c
   1d7e8:	020fac30 	.word	0x020fac30
   1d7ec:	020f9b20 	.word	0x020f9b20

0001d7f0 <SFXDistortionAlloc>:
        {
   1d7f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            tOversampler_initToPool(&oversampler, distOS_ratio, OFALSE, &smallPool);
   1d7f4:	4e29      	ldr	r6, [pc, #164]	; (1d89c <SFXDistortionAlloc+0xac>)
            leaf.clearOnAllocation = 1;
   1d7f6:	2701      	movs	r7, #1
            tOversampler_initToPool(&oversampler, distOS_ratio, OFALSE, &smallPool);
   1d7f8:	4d29      	ldr	r5, [pc, #164]	; (1d8a0 <SFXDistortionAlloc+0xb0>)
   1d7fa:	2200      	movs	r2, #0
            leaf.clearOnAllocation = 1;
   1d7fc:	4c29      	ldr	r4, [pc, #164]	; (1d8a4 <SFXDistortionAlloc+0xb4>)
            tOversampler_initToPool(&oversampler, distOS_ratio, OFALSE, &smallPool);
   1d7fe:	4633      	mov	r3, r6
            tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
   1d800:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 1d8c4 <SFXDistortionAlloc+0xd4>
            tOversampler_initToPool(&oversampler, distOS_ratio, OFALSE, &smallPool);
   1d804:	6829      	ldr	r1, [r5, #0]
   1d806:	4828      	ldr	r0, [pc, #160]	; (1d8a8 <SFXDistortionAlloc+0xb8>)
            tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
   1d808:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 1d8c8 <SFXDistortionAlloc+0xd8>
            leaf.clearOnAllocation = 1;
   1d80c:	6167      	str	r7, [r4, #20]
            tOversampler_initToPool(&oversampler, distOS_ratio, OFALSE, &smallPool);
   1d80e:	f007 fce1 	bl	251d4 <tOversampler_initToPool>
            tVZFilter_initToPool(&bell1, Bell, 1000.0f, 1.9f, &smallPool);
   1d812:	4f26      	ldr	r7, [pc, #152]	; (1d8ac <SFXDistortionAlloc+0xbc>)
            tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
   1d814:	4632      	mov	r2, r6
   1d816:	4648      	mov	r0, r9
   1d818:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1d81c:	ed9f 0a24 	vldr	s0, [pc, #144]	; 1d8b0 <SFXDistortionAlloc+0xc0>
   1d820:	2106      	movs	r1, #6
   1d822:	f00a fe3f 	bl	284a4 <tVZFilter_initToPool>
            tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
   1d826:	4632      	mov	r2, r6
   1d828:	4640      	mov	r0, r8
   1d82a:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1d82e:	ed9f 0a21 	vldr	s0, [pc, #132]	; 1d8b4 <SFXDistortionAlloc+0xc4>
   1d832:	2107      	movs	r1, #7
   1d834:	f00a fe36 	bl	284a4 <tVZFilter_initToPool>
            tVZFilter_initToPool(&bell1, Bell, 1000.0f, 1.9f, &smallPool);
   1d838:	4632      	mov	r2, r6
   1d83a:	eddf 0a1f 	vldr	s1, [pc, #124]	; 1d8b8 <SFXDistortionAlloc+0xc8>
   1d83e:	2105      	movs	r1, #5
   1d840:	4638      	mov	r0, r7
   1d842:	ed9f 0a1e 	vldr	s0, [pc, #120]	; 1d8bc <SFXDistortionAlloc+0xcc>
   1d846:	f00a fe2d 	bl	284a4 <tVZFilter_initToPool>
            tVZFilter_setSampleRate(&shelf1, leaf.sampleRate * distOS_ratio);
   1d84a:	edd5 7a00 	vldr	s15, [r5]
   1d84e:	ed94 0a00 	vldr	s0, [r4]
   1d852:	4648      	mov	r0, r9
   1d854:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1d858:	ee27 0a80 	vmul.f32	s0, s15, s0
   1d85c:	f00b f818 	bl	28890 <tVZFilter_setSampleRate>
            tVZFilter_setSampleRate(&shelf2, leaf.sampleRate * distOS_ratio);
   1d860:	edd5 7a00 	vldr	s15, [r5]
   1d864:	ed94 0a00 	vldr	s0, [r4]
   1d868:	4640      	mov	r0, r8
   1d86a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1d86e:	ee27 0a80 	vmul.f32	s0, s15, s0
   1d872:	f00b f80d 	bl	28890 <tVZFilter_setSampleRate>
            tVZFilter_setSampleRate(&bell1, leaf.sampleRate * distOS_ratio);
   1d876:	ed95 0a00 	vldr	s0, [r5]
   1d87a:	edd4 7a00 	vldr	s15, [r4]
   1d87e:	4638      	mov	r0, r7
   1d880:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   1d884:	ee20 0a27 	vmul.f32	s0, s0, s15
   1d888:	f00b f802 	bl	28890 <tVZFilter_setSampleRate>
            setLED_A(distortionMode);
   1d88c:	4b0c      	ldr	r3, [pc, #48]	; (1d8c0 <SFXDistortionAlloc+0xd0>)
   1d88e:	7818      	ldrb	r0, [r3, #0]
   1d890:	f7fb fdfe 	bl	19490 <setLED_A>
            leaf.clearOnAllocation = 0;
   1d894:	2300      	movs	r3, #0
   1d896:	6163      	str	r3, [r4, #20]
        }
   1d898:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1d89c:	020fabc0 	.word	0x020fabc0
   1d8a0:	00062790 	.word	0x00062790
   1d8a4:	020fbd68 	.word	0x020fbd68
   1d8a8:	020faa10 	.word	0x020faa10
   1d8ac:	020f9c04 	.word	0x020f9c04
   1d8b0:	42a00000 	.word	0x42a00000
   1d8b4:	463b8000 	.word	0x463b8000
   1d8b8:	3ff33333 	.word	0x3ff33333
   1d8bc:	447a0000 	.word	0x447a0000
   1d8c0:	020e2e44 	.word	0x020e2e44
   1d8c4:	020f9dc4 	.word	0x020f9dc4
   1d8c8:	020f9cec 	.word	0x020f9cec

0001d8cc <SFXDistortionFrame>:
            if (buttonActionsSFX[ButtonA][ActionPress])
   1d8cc:	4a27      	ldr	r2, [pc, #156]	; (1d96c <SFXDistortionFrame+0xa0>)
        {
   1d8ce:	b510      	push	{r4, lr}
            if (buttonActionsSFX[ButtonA][ActionPress])
   1d8d0:	7d13      	ldrb	r3, [r2, #20]
   1d8d2:	b153      	cbz	r3, 1d8ea <SFXDistortionFrame+0x1e>
                distortionMode = !distortionMode;
   1d8d4:	4926      	ldr	r1, [pc, #152]	; (1d970 <SFXDistortionFrame+0xa4>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1d8d6:	2000      	movs	r0, #0
                distortionMode = !distortionMode;
   1d8d8:	780b      	ldrb	r3, [r1, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1d8da:	7510      	strb	r0, [r2, #20]
                distortionMode = !distortionMode;
   1d8dc:	fab3 f383 	clz	r3, r3
   1d8e0:	095b      	lsrs	r3, r3, #5
                setLED_A(distortionMode);
   1d8e2:	4618      	mov	r0, r3
                distortionMode = !distortionMode;
   1d8e4:	700b      	strb	r3, [r1, #0]
                setLED_A(distortionMode);
   1d8e6:	f7fb fdd3 	bl	19490 <setLED_A>
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1d8ea:	4b22      	ldr	r3, [pc, #136]	; (1d974 <SFXDistortionFrame+0xa8>)
   1d8ec:	eeb3 6a0e 	vmov.f32	s12, #62	; 0x41f00000  30.0
   1d8f0:	eeba 7a0e 	vmov.f32	s14, #174	; 0xc1700000 -15.0
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1d8f4:	eddf 6a20 	vldr	s13, [pc, #128]	; 1d978 <SFXDistortionFrame+0xac>
   1d8f8:	eefb 7a01 	vmov.f32	s15, #177	; 0xc1880000 -17.0
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1d8fc:	ed93 5ac9 	vldr	s10, [r3, #804]	; 0x324
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1d900:	edd3 5aca 	vldr	s11, [r3, #808]	; 0x328
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1d904:	eea5 7a06 	vfma.f32	s14, s10, s12
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1d908:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 1d97c <SFXDistortionFrame+0xb0>
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1d90c:	eee5 7aa6 	vfma.f32	s15, s11, s13
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1d910:	ed93 6acb 	vldr	s12, [r3, #812]	; 0x32c
   1d914:	eddf 6a1a 	vldr	s13, [pc, #104]	; 1d980 <SFXDistortionFrame+0xb4>
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1d918:	4c1a      	ldr	r4, [pc, #104]	; (1d984 <SFXDistortionFrame+0xb8>)
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1d91a:	eea6 0a26 	vfma.f32	s0, s12, s13
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1d91e:	ed84 7a01 	vstr	s14, [r4, #4]
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1d922:	edc4 7a02 	vstr	s15, [r4, #8]
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1d926:	f00c f86d 	bl	29a04 <faster_mtof>
            tVZFilter_setGain(&shelf1, fastdbtoa(-1.0f * displayValues[1]));
   1d92a:	edd4 7a01 	vldr	s15, [r4, #4]
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1d92e:	ed84 0a03 	vstr	s0, [r4, #12]
            tVZFilter_setGain(&shelf1, fastdbtoa(-1.0f * displayValues[1]));
   1d932:	eeb1 0a67 	vneg.f32	s0, s15
   1d936:	f00c f8b5 	bl	29aa4 <fastdbtoa>
   1d93a:	4813      	ldr	r0, [pc, #76]	; (1d988 <SFXDistortionFrame+0xbc>)
   1d93c:	f00b fbec 	bl	29118 <tVZFilter_setGain>
            tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[1]));
   1d940:	ed94 0a01 	vldr	s0, [r4, #4]
   1d944:	f00c f8ae 	bl	29aa4 <fastdbtoa>
   1d948:	4810      	ldr	r0, [pc, #64]	; (1d98c <SFXDistortionFrame+0xc0>)
   1d94a:	f00b fbe5 	bl	29118 <tVZFilter_setGain>
            tVZFilter_setFreq(&bell1, displayValues[3]);
   1d94e:	ed94 0a03 	vldr	s0, [r4, #12]
   1d952:	480f      	ldr	r0, [pc, #60]	; (1d990 <SFXDistortionFrame+0xc4>)
   1d954:	f00b f816 	bl	28984 <tVZFilter_setFreq>
            tVZFilter_setGain(&bell1, fastdbtoa(displayValues[2]));
   1d958:	ed94 0a02 	vldr	s0, [r4, #8]
   1d95c:	f00c f8a2 	bl	29aa4 <fastdbtoa>
   1d960:	480b      	ldr	r0, [pc, #44]	; (1d990 <SFXDistortionFrame+0xc4>)
        }
   1d962:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            tVZFilter_setGain(&bell1, fastdbtoa(displayValues[2]));
   1d966:	f00b bbd7 	b.w	29118 <tVZFilter_setGain>
   1d96a:	bf00      	nop
   1d96c:	020fafac 	.word	0x020fafac
   1d970:	020e2e44 	.word	0x020e2e44
   1d974:	020e55d8 	.word	0x020e55d8
   1d978:	42080000 	.word	0x42080000
   1d97c:	42280000 	.word	0x42280000
   1d980:	429a0000 	.word	0x429a0000
   1d984:	020fb05c 	.word	0x020fb05c
   1d988:	020f9dc4 	.word	0x020f9dc4
   1d98c:	020f9cec 	.word	0x020f9cec
   1d990:	020f9c04 	.word	0x020f9c04

0001d994 <SFXDistortionTick>:
        {
   1d994:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
   1d998:	4e2f      	ldr	r6, [pc, #188]	; (1da58 <SFXDistortionTick+0xc4>)
   1d99a:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
   1d99e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1d9a2:	4b2e      	ldr	r3, [pc, #184]	; (1da5c <SFXDistortionTick+0xc8>)
   1d9a4:	edd6 6ac8 	vldr	s13, [r6, #800]	; 0x320
        {
   1d9a8:	4683      	mov	fp, r0
            displayValues[4] = presetKnobValues[Distortion][4]; // 15.0f
   1d9aa:	f8d6 2330 	ldr.w	r2, [r6, #816]	; 0x330
            displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
   1d9ae:	eee6 7a87 	vfma.f32	s15, s13, s14
            for (int i = 0; i < distOS_ratio; i++)
   1d9b2:	4f2b      	ldr	r7, [pc, #172]	; (1da60 <SFXDistortionTick+0xcc>)
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
   1d9b4:	492b      	ldr	r1, [pc, #172]	; (1da64 <SFXDistortionTick+0xd0>)
        {
   1d9b6:	ed2d 8b02 	vpush	{d8}
            float sample = input[1];
   1d9ba:	ed90 0a01 	vldr	s0, [r0, #4]
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
   1d9be:	482a      	ldr	r0, [pc, #168]	; (1da68 <SFXDistortionTick+0xd4>)
   1d9c0:	ee27 0a80 	vmul.f32	s0, s15, s0
            displayValues[4] = presetKnobValues[Distortion][4]; // 15.0f
   1d9c4:	611a      	str	r2, [r3, #16]
            displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
   1d9c6:	edc3 7a00 	vstr	s15, [r3]
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
   1d9ca:	f007 fced 	bl	253a8 <tOversampler_upsample>
            for (int i = 0; i < distOS_ratio; i++)
   1d9ce:	683b      	ldr	r3, [r7, #0]
   1d9d0:	2b00      	cmp	r3, #0
   1d9d2:	dd2d      	ble.n	1da30 <SFXDistortionTick+0x9c>
   1d9d4:	4c23      	ldr	r4, [pc, #140]	; (1da64 <SFXDistortionTick+0xd0>)
   1d9d6:	2500      	movs	r5, #0
   1d9d8:	f8df a098 	ldr.w	sl, [pc, #152]	; 1da74 <SFXDistortionTick+0xe0>
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   1d9dc:	f8df 9098 	ldr.w	r9, [pc, #152]	; 1da78 <SFXDistortionTick+0xe4>
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   1d9e0:	f8df 8098 	ldr.w	r8, [pc, #152]	; 1da7c <SFXDistortionTick+0xe8>
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   1d9e4:	ed9f 8a21 	vldr	s16, [pc, #132]	; 1da6c <SFXDistortionTick+0xd8>
                if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
   1d9e8:	f89a 3000 	ldrb.w	r3, [sl]
   1d9ec:	ecb4 0a01 	vldmia	r4!, {s0}
   1d9f0:	bb53      	cbnz	r3, 1da48 <SFXDistortionTick+0xb4>
                else oversamplerArray[i] = tanhf(oversamplerArray[i]);
   1d9f2:	f00f fbb3 	bl	2d15c <tanhf>
   1d9f6:	ed04 0a01 	vstr	s0, [r4, #-4]
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   1d9fa:	4648      	mov	r0, r9
            for (int i = 0; i < distOS_ratio; i++)
   1d9fc:	3501      	adds	r5, #1
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   1d9fe:	f00a ff51 	bl	288a4 <tVZFilter_tick>
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   1da02:	4640      	mov	r0, r8
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   1da04:	ed04 0a01 	vstr	s0, [r4, #-4]
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   1da08:	f00a ff4c 	bl	288a4 <tVZFilter_tick>
                oversamplerArray[i] = tVZFilter_tick(&bell1, oversamplerArray[i]); // now add a bell (or peaking eq) filter
   1da0c:	4818      	ldr	r0, [pc, #96]	; (1da70 <SFXDistortionTick+0xdc>)
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   1da0e:	ed04 0a01 	vstr	s0, [r4, #-4]
                oversamplerArray[i] = tVZFilter_tick(&bell1, oversamplerArray[i]); // now add a bell (or peaking eq) filter
   1da12:	f00a ff47 	bl	288a4 <tVZFilter_tick>
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   1da16:	edd6 7acc 	vldr	s15, [r6, #816]	; 0x330
   1da1a:	ee20 0a27 	vmul.f32	s0, s0, s15
   1da1e:	f00f fb9d 	bl	2d15c <tanhf>
            for (int i = 0; i < distOS_ratio; i++)
   1da22:	683b      	ldr	r3, [r7, #0]
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   1da24:	ee20 0a08 	vmul.f32	s0, s0, s16
            for (int i = 0; i < distOS_ratio; i++)
   1da28:	42ab      	cmp	r3, r5
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   1da2a:	ed04 0a01 	vstr	s0, [r4, #-4]
            for (int i = 0; i < distOS_ratio; i++)
   1da2e:	dcdb      	bgt.n	1d9e8 <SFXDistortionTick+0x54>
            sample = tOversampler_downsample(&oversampler, oversamplerArray);
   1da30:	490c      	ldr	r1, [pc, #48]	; (1da64 <SFXDistortionTick+0xd0>)
   1da32:	480d      	ldr	r0, [pc, #52]	; (1da68 <SFXDistortionTick+0xd4>)
   1da34:	f007 fd02 	bl	2543c <tOversampler_downsample>
            input[0] = sample;
   1da38:	ed8b 0a00 	vstr	s0, [fp]
            input[1] = sample;
   1da3c:	ed8b 0a01 	vstr	s0, [fp, #4]
        }
   1da40:	ecbd 8b02 	vpop	{d8}
   1da44:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
   1da48:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   1da4c:	f00b fe12 	bl	29674 <LEAF_shaper>
   1da50:	ed04 0a01 	vstr	s0, [r4, #-4]
   1da54:	e7d1      	b.n	1d9fa <SFXDistortionTick+0x66>
   1da56:	bf00      	nop
   1da58:	020e55d8 	.word	0x020e55d8
   1da5c:	020fb05c 	.word	0x020fb05c
   1da60:	00062790 	.word	0x00062790
   1da64:	020f9b30 	.word	0x020f9b30
   1da68:	020faa10 	.word	0x020faa10
   1da6c:	3f733333 	.word	0x3f733333
   1da70:	020f9c04 	.word	0x020f9c04
   1da74:	020e2e44 	.word	0x020e2e44
   1da78:	020f9dc4 	.word	0x020f9dc4
   1da7c:	020f9cec 	.word	0x020f9cec

0001da80 <SFXDistortionFree>:
        {
   1da80:	b508      	push	{r3, lr}
            tOversampler_free(&oversampler);
   1da82:	4807      	ldr	r0, [pc, #28]	; (1daa0 <SFXDistortionFree+0x20>)
   1da84:	f007 fbf6 	bl	25274 <tOversampler_free>
            tVZFilter_free(&shelf1);
   1da88:	4806      	ldr	r0, [pc, #24]	; (1daa4 <SFXDistortionFree+0x24>)
   1da8a:	f00a fefd 	bl	28888 <tVZFilter_free>
            tVZFilter_free(&shelf2);
   1da8e:	4806      	ldr	r0, [pc, #24]	; (1daa8 <SFXDistortionFree+0x28>)
   1da90:	f00a fefa 	bl	28888 <tVZFilter_free>
            tVZFilter_free(&bell1);
   1da94:	4805      	ldr	r0, [pc, #20]	; (1daac <SFXDistortionFree+0x2c>)
        }
   1da96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tVZFilter_free(&bell1);
   1da9a:	f00a bef5 	b.w	28888 <tVZFilter_free>
   1da9e:	bf00      	nop
   1daa0:	020faa10 	.word	0x020faa10
   1daa4:	020f9dc4 	.word	0x020f9dc4
   1daa8:	020f9cec 	.word	0x020f9cec
   1daac:	020f9c04 	.word	0x020f9c04

0001dab0 <SFXWaveFolderAlloc>:
        {
   1dab0:	b538      	push	{r3, r4, r5, lr}
            tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   1dab2:	4c0f      	ldr	r4, [pc, #60]	; (1daf0 <SFXWaveFolderAlloc+0x40>)
            leaf.clearOnAllocation = 1;
   1dab4:	2301      	movs	r3, #1
   1dab6:	4d0f      	ldr	r5, [pc, #60]	; (1daf4 <SFXWaveFolderAlloc+0x44>)
            tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   1dab8:	4621      	mov	r1, r4
   1daba:	480f      	ldr	r0, [pc, #60]	; (1daf8 <SFXWaveFolderAlloc+0x48>)
            leaf.clearOnAllocation = 1;
   1dabc:	616b      	str	r3, [r5, #20]
            tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   1dabe:	f007 fcef 	bl	254a0 <tLockhartWavefolder_initToPool>
            tLockhartWavefolder_initToPool(&wavefolder2, &smallPool);
   1dac2:	4621      	mov	r1, r4
   1dac4:	480d      	ldr	r0, [pc, #52]	; (1dafc <SFXWaveFolderAlloc+0x4c>)
   1dac6:	f007 fceb 	bl	254a0 <tLockhartWavefolder_initToPool>
            tHighpass_initToPool(&wfHP, 10.0f, &smallPool);
   1daca:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   1dace:	4621      	mov	r1, r4
   1dad0:	480b      	ldr	r0, [pc, #44]	; (1db00 <SFXWaveFolderAlloc+0x50>)
   1dad2:	f00a fca3 	bl	2841c <tHighpass_initToPool>
            tOversampler_initToPool(&oversampler, 2, OFALSE, &smallPool);
   1dad6:	4623      	mov	r3, r4
   1dad8:	2200      	movs	r2, #0
   1dada:	2102      	movs	r1, #2
   1dadc:	4809      	ldr	r0, [pc, #36]	; (1db04 <SFXWaveFolderAlloc+0x54>)
   1dade:	f007 fb79 	bl	251d4 <tOversampler_initToPool>
            setLED_A(foldMode);
   1dae2:	4b09      	ldr	r3, [pc, #36]	; (1db08 <SFXWaveFolderAlloc+0x58>)
   1dae4:	7818      	ldrb	r0, [r3, #0]
   1dae6:	f7fb fcd3 	bl	19490 <setLED_A>
            leaf.clearOnAllocation = 0;
   1daea:	2300      	movs	r3, #0
   1daec:	616b      	str	r3, [r5, #20]
        }
   1daee:	bd38      	pop	{r3, r4, r5, pc}
   1daf0:	020fabc0 	.word	0x020fabc0
   1daf4:	020fbd68 	.word	0x020fbd68
   1daf8:	020e5018 	.word	0x020e5018
   1dafc:	020f9ce8 	.word	0x020f9ce8
   1db00:	020f9b2c 	.word	0x020f9b2c
   1db04:	020faa10 	.word	0x020faa10
   1db08:	020e2e54 	.word	0x020e2e54

0001db0c <SFXWaveFolderFrame>:
            if (buttonActionsSFX[ButtonA][ActionPress])
   1db0c:	4a07      	ldr	r2, [pc, #28]	; (1db2c <SFXWaveFolderFrame+0x20>)
   1db0e:	7d13      	ldrb	r3, [r2, #20]
   1db10:	b903      	cbnz	r3, 1db14 <SFXWaveFolderFrame+0x8>
        }
   1db12:	4770      	bx	lr
                foldMode = !foldMode;
   1db14:	4906      	ldr	r1, [pc, #24]	; (1db30 <SFXWaveFolderFrame+0x24>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1db16:	2000      	movs	r0, #0
                foldMode = !foldMode;
   1db18:	680b      	ldr	r3, [r1, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1db1a:	7510      	strb	r0, [r2, #20]
                foldMode = !foldMode;
   1db1c:	fab3 f383 	clz	r3, r3
   1db20:	095b      	lsrs	r3, r3, #5
                setLED_A(foldMode);
   1db22:	4618      	mov	r0, r3
                foldMode = !foldMode;
   1db24:	600b      	str	r3, [r1, #0]
                setLED_A(foldMode);
   1db26:	f7fb bcb3 	b.w	19490 <setLED_A>
   1db2a:	bf00      	nop
   1db2c:	020fafac 	.word	0x020fafac
   1db30:	020e2e54 	.word	0x020e2e54

0001db34 <SFXWaveFolderTick>:
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1db34:	4b3a      	ldr	r3, [pc, #232]	; (1dc20 <SFXWaveFolderTick+0xec>)
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   1db36:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1db3a:	eeb1 6a00 	vmov.f32	s12, #16	; 0x40800000  4.0
            if (foldMode == 0)
   1db3e:	4939      	ldr	r1, [pc, #228]	; (1dc24 <SFXWaveFolderTick+0xf0>)
        {
   1db40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1db44:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1db48:	ed93 0ae1 	vldr	s0, [r3, #900]	; 0x384
        {
   1db4c:	4606      	mov	r6, r0
            displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
   1db4e:	ed93 7ae3 	vldr	s14, [r3, #908]	; 0x38c
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   1db52:	edd3 7ae2 	vldr	s15, [r3, #904]	; 0x388
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1db56:	ee20 0a06 	vmul.f32	s0, s0, s12
            displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
   1db5a:	ee37 7a66 	vsub.f32	s14, s14, s13
            float sample = input[1];
   1db5e:	ed90 8a01 	vldr	s16, [r0, #4]
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   1db62:	ee77 7ae6 	vsub.f32	s15, s15, s13
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1db66:	4c30      	ldr	r4, [pc, #192]	; (1dc28 <SFXWaveFolderTick+0xf4>)
            displayValues[3] = presetKnobValues[Wavefolder][3];
   1db68:	f8d3 2390 	ldr.w	r2, [r3, #912]	; 0x390
            sample = sample * gain;
   1db6c:	ee20 8a08 	vmul.f32	s16, s0, s16
            if (foldMode == 0)
   1db70:	680b      	ldr	r3, [r1, #0]
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1db72:	ed84 0a00 	vstr	s0, [r4]
            displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
   1db76:	ed84 7a02 	vstr	s14, [r4, #8]
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   1db7a:	edc4 7a01 	vstr	s15, [r4, #4]
            displayValues[3] = presetKnobValues[Wavefolder][3];
   1db7e:	60e2      	str	r2, [r4, #12]
            if (foldMode == 0)
   1db80:	bb93      	cbnz	r3, 1dbe8 <SFXWaveFolderTick+0xb4>
   1db82:	4d2a      	ldr	r5, [pc, #168]	; (1dc2c <SFXWaveFolderTick+0xf8>)
                tOversampler_upsample(&oversampler, sample, oversamplerArray);
   1db84:	eeb0 0a48 	vmov.f32	s0, s16
   1db88:	4829      	ldr	r0, [pc, #164]	; (1dc30 <SFXWaveFolderTick+0xfc>)
   1db8a:	4629      	mov	r1, r5
                    oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
   1db8c:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 1dc38 <SFXWaveFolderTick+0x104>
   1db90:	f105 0708 	add.w	r7, r5, #8
                tOversampler_upsample(&oversampler, sample, oversamplerArray);
   1db94:	f007 fc08 	bl	253a8 <tOversampler_upsample>
                    oversamplerArray[i] = sample + displayValues[1];
   1db98:	edd4 7a01 	vldr	s15, [r4, #4]
                    oversamplerArray[i] *= displayValues[0];
   1db9c:	ed94 0a00 	vldr	s0, [r4]
                    oversamplerArray[i] = sample + displayValues[1];
   1dba0:	ee78 7a27 	vadd.f32	s15, s16, s15
                    oversamplerArray[i] = tanhf(oversamplerArray[i]);
   1dba4:	ee27 0a80 	vmul.f32	s0, s15, s0
   1dba8:	f00f fad8 	bl	2d15c <tanhf>
                    oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
   1dbac:	4640      	mov	r0, r8
                    oversamplerArray[i] = tanhf(oversamplerArray[i]);
   1dbae:	ed85 0a00 	vstr	s0, [r5]
                    oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
   1dbb2:	f007 fd01 	bl	255b8 <tLockhartWavefolder_tick>
                    oversamplerArray[i] = tanhf(oversamplerArray[i]);
   1dbb6:	f00f fad1 	bl	2d15c <tanhf>
   1dbba:	eca5 0a01 	vstmia	r5!, {s0}
                for (int i = 0; i < 2; i++)
   1dbbe:	42bd      	cmp	r5, r7
   1dbc0:	d1ea      	bne.n	1db98 <SFXWaveFolderTick+0x64>
                sample = tHighpass_tick(&wfHP, tOversampler_downsample(&oversampler, oversamplerArray)) * displayValues[3];
   1dbc2:	491a      	ldr	r1, [pc, #104]	; (1dc2c <SFXWaveFolderTick+0xf8>)
   1dbc4:	481a      	ldr	r0, [pc, #104]	; (1dc30 <SFXWaveFolderTick+0xfc>)
   1dbc6:	f007 fc39 	bl	2543c <tOversampler_downsample>
                sample = tHighpass_tick(&wfHP, sample) * displayValues[3];
   1dbca:	481a      	ldr	r0, [pc, #104]	; (1dc34 <SFXWaveFolderTick+0x100>)
   1dbcc:	f00a fc5a 	bl	28484 <tHighpass_tick>
   1dbd0:	edd4 7a03 	vldr	s15, [r4, #12]
   1dbd4:	ee20 0a27 	vmul.f32	s0, s0, s15
                input[0] = sample;
   1dbd8:	ed86 0a00 	vstr	s0, [r6]
                input[1] = sample;
   1dbdc:	ed86 0a01 	vstr	s0, [r6, #4]
        }
   1dbe0:	ecbd 8b02 	vpop	{d8}
   1dbe4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                sample = sample + displayValues[1];
   1dbe8:	ee77 7a88 	vadd.f32	s15, s15, s16
                sample = LEAF_tanh(sample);
   1dbec:	ee20 0a27 	vmul.f32	s0, s0, s15
   1dbf0:	f00b fdea 	bl	297c8 <LEAF_tanh>
                sample = tLockhartWavefolder_tick(&wavefolder1, sample);
   1dbf4:	4810      	ldr	r0, [pc, #64]	; (1dc38 <SFXWaveFolderTick+0x104>)
   1dbf6:	f007 fcdf 	bl	255b8 <tLockhartWavefolder_tick>
                sample = sample + displayValues[2];
   1dbfa:	edd4 7a02 	vldr	s15, [r4, #8]
                sample *= displayValues[0];
   1dbfe:	ed94 7a00 	vldr	s14, [r4]
                sample = sample + displayValues[2];
   1dc02:	ee30 0a27 	vadd.f32	s0, s0, s15
                sample = LEAF_tanh(sample);
   1dc06:	ee20 0a07 	vmul.f32	s0, s0, s14
   1dc0a:	f00b fddd 	bl	297c8 <LEAF_tanh>
                sample = tLockhartWavefolder_tick(&wavefolder2, sample);
   1dc0e:	480b      	ldr	r0, [pc, #44]	; (1dc3c <SFXWaveFolderTick+0x108>)
   1dc10:	f007 fcd2 	bl	255b8 <tLockhartWavefolder_tick>
                sample = tOversampler_tick(&oversampler, sample, oversampleBuf, &LEAF_tanh);
   1dc14:	4a0a      	ldr	r2, [pc, #40]	; (1dc40 <SFXWaveFolderTick+0x10c>)
   1dc16:	490b      	ldr	r1, [pc, #44]	; (1dc44 <SFXWaveFolderTick+0x110>)
   1dc18:	4805      	ldr	r0, [pc, #20]	; (1dc30 <SFXWaveFolderTick+0xfc>)
   1dc1a:	f007 fb3b 	bl	25294 <tOversampler_tick>
   1dc1e:	e7d4      	b.n	1dbca <SFXWaveFolderTick+0x96>
   1dc20:	020e55d8 	.word	0x020e55d8
   1dc24:	020e2e54 	.word	0x020e2e54
   1dc28:	020fb05c 	.word	0x020fb05c
   1dc2c:	020f9b30 	.word	0x020f9b30
   1dc30:	020faa10 	.word	0x020faa10
   1dc34:	020f9b2c 	.word	0x020f9b2c
   1dc38:	020e5018 	.word	0x020e5018
   1dc3c:	020f9ce8 	.word	0x020f9ce8
   1dc40:	000297c9 	.word	0x000297c9
   1dc44:	020fabc4 	.word	0x020fabc4

0001dc48 <SFXWaveFolderFree>:
        {
   1dc48:	b508      	push	{r3, lr}
            tLockhartWavefolder_free(&wavefolder1);
   1dc4a:	4807      	ldr	r0, [pc, #28]	; (1dc68 <SFXWaveFolderFree+0x20>)
   1dc4c:	f007 fcb0 	bl	255b0 <tLockhartWavefolder_free>
            tLockhartWavefolder_free(&wavefolder2);
   1dc50:	4806      	ldr	r0, [pc, #24]	; (1dc6c <SFXWaveFolderFree+0x24>)
   1dc52:	f007 fcad 	bl	255b0 <tLockhartWavefolder_free>
            tHighpass_free(&wfHP);
   1dc56:	4806      	ldr	r0, [pc, #24]	; (1dc70 <SFXWaveFolderFree+0x28>)
   1dc58:	f00a fc00 	bl	2845c <tHighpass_free>
            tOversampler_free(&oversampler);
   1dc5c:	4805      	ldr	r0, [pc, #20]	; (1dc74 <SFXWaveFolderFree+0x2c>)
        }
   1dc5e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tOversampler_free(&oversampler);
   1dc62:	f007 bb07 	b.w	25274 <tOversampler_free>
   1dc66:	bf00      	nop
   1dc68:	020e5018 	.word	0x020e5018
   1dc6c:	020f9ce8 	.word	0x020f9ce8
   1dc70:	020f9b2c 	.word	0x020f9b2c
   1dc74:	020faa10 	.word	0x020faa10

0001dc78 <SFXBitcrusherAlloc>:
        {
   1dc78:	b510      	push	{r4, lr}
            tCrusher_initToPool(&crush, &smallPool);
   1dc7a:	4c07      	ldr	r4, [pc, #28]	; (1dc98 <SFXBitcrusherAlloc+0x20>)
   1dc7c:	4807      	ldr	r0, [pc, #28]	; (1dc9c <SFXBitcrusherAlloc+0x24>)
   1dc7e:	4621      	mov	r1, r4
   1dc80:	f007 fdb2 	bl	257e8 <tCrusher_initToPool>
            tCrusher_initToPool(&crush2, &smallPool);
   1dc84:	4621      	mov	r1, r4
   1dc86:	4806      	ldr	r0, [pc, #24]	; (1dca0 <SFXBitcrusherAlloc+0x28>)
   1dc88:	f007 fdae 	bl	257e8 <tCrusher_initToPool>
            setLED_A(crusherStereo);
   1dc8c:	4b05      	ldr	r3, [pc, #20]	; (1dca4 <SFXBitcrusherAlloc+0x2c>)
        }
   1dc8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            setLED_A(crusherStereo);
   1dc92:	7818      	ldrb	r0, [r3, #0]
   1dc94:	f7fb bbfc 	b.w	19490 <setLED_A>
   1dc98:	020fabc0 	.word	0x020fabc0
   1dc9c:	020e5d28 	.word	0x020e5d28
   1dca0:	020e52f4 	.word	0x020e52f4
   1dca4:	020e2e30 	.word	0x020e2e30

0001dca8 <SFXBitcrusherFrame>:
            if (buttonActionsSFX[ButtonA][ActionPress])
   1dca8:	4a07      	ldr	r2, [pc, #28]	; (1dcc8 <SFXBitcrusherFrame+0x20>)
   1dcaa:	7d13      	ldrb	r3, [r2, #20]
   1dcac:	b903      	cbnz	r3, 1dcb0 <SFXBitcrusherFrame+0x8>
        }
   1dcae:	4770      	bx	lr
                crusherStereo = !crusherStereo;
   1dcb0:	4906      	ldr	r1, [pc, #24]	; (1dccc <SFXBitcrusherFrame+0x24>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1dcb2:	2000      	movs	r0, #0
                crusherStereo = !crusherStereo;
   1dcb4:	680b      	ldr	r3, [r1, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1dcb6:	7510      	strb	r0, [r2, #20]
                crusherStereo = !crusherStereo;
   1dcb8:	fab3 f383 	clz	r3, r3
   1dcbc:	095b      	lsrs	r3, r3, #5
                setLED_A(crusherStereo);
   1dcbe:	4618      	mov	r0, r3
                crusherStereo = !crusherStereo;
   1dcc0:	600b      	str	r3, [r1, #0]
                setLED_A(crusherStereo);
   1dcc2:	f7fb bbe5 	b.w	19490 <setLED_A>
   1dcc6:	bf00      	nop
   1dcc8:	020fafac 	.word	0x020fafac
   1dccc:	020e2e30 	.word	0x020e2e30

0001dcd0 <SFXBitcrusherTick>:
        {
   1dcd0:	b570      	push	{r4, r5, r6, lr}
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   1dcd2:	4d51      	ldr	r5, [pc, #324]	; (1de18 <SFXBitcrusherTick+0x148>)
        {
   1dcd4:	4606      	mov	r6, r0
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   1dcd6:	eddf 6a51 	vldr	s13, [pc, #324]	; 1de1c <SFXBitcrusherTick+0x14c>
   1dcda:	ed95 7afa 	vldr	s14, [r5, #1000]	; 0x3e8
   1dcde:	eddf 7a50 	vldr	s15, [pc, #320]	; 1de20 <SFXBitcrusherTick+0x150>
   1dce2:	4c50      	ldr	r4, [pc, #320]	; (1de24 <SFXBitcrusherTick+0x154>)
            tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
   1dce4:	eeb0 0a47 	vmov.f32	s0, s14
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   1dce8:	eee7 7a26 	vfma.f32	s15, s14, s13
            tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
   1dcec:	484e      	ldr	r0, [pc, #312]	; (1de28 <SFXBitcrusherTick+0x158>)
        {
   1dcee:	ed2d 8b02 	vpush	{d8}
            tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
   1dcf2:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   1dcf6:	ed9f 8a4d 	vldr	s16, [pc, #308]	; 1de2c <SFXBitcrusherTick+0x15c>
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   1dcfa:	edc4 7a00 	vstr	s15, [r4]
            tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
   1dcfe:	f007 fdfb 	bl	258f8 <tCrusher_setQuality>
            tCrusher_setQuality (&crush2, presetKnobValues[BitCrusher][0]);
   1dd02:	ed95 0afa 	vldr	s0, [r5, #1000]	; 0x3e8
   1dd06:	484a      	ldr	r0, [pc, #296]	; (1de30 <SFXBitcrusherTick+0x160>)
   1dd08:	f007 fdf6 	bl	258f8 <tCrusher_setQuality>
            displayValues[1] = presetKnobValues[BitCrusher][1];
   1dd0c:	edd5 7afb 	vldr	s15, [r5, #1004]	; 0x3ec
            tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
   1dd10:	4845      	ldr	r0, [pc, #276]	; (1de28 <SFXBitcrusherTick+0x158>)
   1dd12:	ee27 0aa8 	vmul.f32	s0, s15, s17
            displayValues[1] = presetKnobValues[BitCrusher][1];
   1dd16:	edc4 7a01 	vstr	s15, [r4, #4]
            tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
   1dd1a:	f007 fe19 	bl	25950 <tCrusher_setSamplingRatio>
            tCrusher_setSamplingRatio (&crush2, presetKnobValues[BitCrusher][1] * 0.5f);
   1dd1e:	ed95 0afb 	vldr	s0, [r5, #1004]	; 0x3ec
   1dd22:	4843      	ldr	r0, [pc, #268]	; (1de30 <SFXBitcrusherTick+0x160>)
   1dd24:	ee20 0a28 	vmul.f32	s0, s0, s17
   1dd28:	f007 fe12 	bl	25950 <tCrusher_setSamplingRatio>
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   1dd2c:	edd5 7afc 	vldr	s15, [r5, #1008]	; 0x3f0
            tCrusher_setRound (&crush, displayValues[2]);
   1dd30:	483d      	ldr	r0, [pc, #244]	; (1de28 <SFXBitcrusherTick+0x158>)
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   1dd32:	ee67 7a88 	vmul.f32	s15, s15, s16
            tCrusher_setRound (&crush, displayValues[2]);
   1dd36:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   1dd3a:	edc4 7a02 	vstr	s15, [r4, #8]
            tCrusher_setRound (&crush, displayValues[2]);
   1dd3e:	f007 fe01 	bl	25944 <tCrusher_setRound>
            tCrusher_setRound (&crush2, displayValues[2]);
   1dd42:	ed94 0a02 	vldr	s0, [r4, #8]
   1dd46:	483a      	ldr	r0, [pc, #232]	; (1de30 <SFXBitcrusherTick+0x160>)
   1dd48:	f007 fdfc 	bl	25944 <tCrusher_setRound>
            displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
   1dd4c:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
   1dd50:	ed95 0afd 	vldr	s0, [r5, #1012]	; 0x3f4
            tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
   1dd54:	4834      	ldr	r0, [pc, #208]	; (1de28 <SFXBitcrusherTick+0x158>)
            displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
   1dd56:	ee60 7a27 	vmul.f32	s15, s0, s15
   1dd5a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1dd5e:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1dd62:	edc4 7a03 	vstr	s15, [r4, #12]
            tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
   1dd66:	f007 fdbd 	bl	258e4 <tCrusher_setOperation>
            tCrusher_setOperation (&crush2, presetKnobValues[BitCrusher][3]);
   1dd6a:	ed95 0afd 	vldr	s0, [r5, #1012]	; 0x3f4
   1dd6e:	4830      	ldr	r0, [pc, #192]	; (1de30 <SFXBitcrusherTick+0x160>)
   1dd70:	f007 fdb8 	bl	258e4 <tCrusher_setOperation>
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   1dd74:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1dd78:	eeb1 7a04 	vmov.f32	s14, #20	; 0x40a00000  5.0
   1dd7c:	ed95 6aff 	vldr	s12, [r5, #1020]	; 0x3fc
            if (displayValues[0] < 0.1f)
   1dd80:	edd4 6a00 	vldr	s13, [r4]
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   1dd84:	eef0 5a67 	vmov.f32	s11, s15
            displayValues[4] = presetKnobValues[BitCrusher][4];
   1dd88:	f8d5 33f8 	ldr.w	r3, [r5, #1016]	; 0x3f8
            if (displayValues[0] < 0.1f)
   1dd8c:	eef4 6ac8 	vcmpe.f32	s13, s16
            displayValues[4] = presetKnobValues[BitCrusher][4];
   1dd90:	6123      	str	r3, [r4, #16]
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   1dd92:	eee6 5a07 	vfma.f32	s11, s12, s14
            if (displayValues[0] < 0.1f)
   1dd96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   1dd9a:	eeb0 7a65 	vmov.f32	s14, s11
   1dd9e:	edc4 5a05 	vstr	s11, [r4, #20]
            if (displayValues[0] < 0.1f)
   1dda2:	d41e      	bmi.n	1dde2 <SFXBitcrusherTick+0x112>
                volumeComp = (1.0f / (displayValues[3] + 1.0f));
   1dda4:	edd4 6a03 	vldr	s13, [r4, #12]
   1dda8:	ee76 6aa7 	vadd.f32	s13, s13, s15
   1ddac:	eec7 8aa6 	vdiv.f32	s17, s15, s13
            sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
   1ddb0:	ed96 0a01 	vldr	s0, [r6, #4]
   1ddb4:	481c      	ldr	r0, [pc, #112]	; (1de28 <SFXBitcrusherTick+0x158>)
   1ddb6:	ee27 0a00 	vmul.f32	s0, s14, s0
   1ddba:	f007 fd53 	bl	25864 <tCrusher_tick>
   1ddbe:	f00f f9cd 	bl	2d15c <tanhf>
            if (crusherStereo)
   1ddc2:	4b1c      	ldr	r3, [pc, #112]	; (1de34 <SFXBitcrusherTick+0x164>)
            sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
   1ddc4:	ee20 0a28 	vmul.f32	s0, s0, s17
   1ddc8:	ed94 8a04 	vldr	s16, [r4, #16]
            if (crusherStereo)
   1ddcc:	681b      	ldr	r3, [r3, #0]
            sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
   1ddce:	ee20 8a08 	vmul.f32	s16, s0, s16
            if (crusherStereo)
   1ddd2:	b94b      	cbnz	r3, 1dde8 <SFXBitcrusherTick+0x118>
                input[1] = sample;
   1ddd4:	ed86 8a01 	vstr	s16, [r6, #4]
            input[0] = sample;
   1ddd8:	ed86 8a00 	vstr	s16, [r6]
        }
   1dddc:	ecbd 8b02 	vpop	{d8}
   1dde0:	bd70      	pop	{r4, r5, r6, pc}
                volumeComp = 1.0f;
   1dde2:	eef0 8a67 	vmov.f32	s17, s15
   1dde6:	e7e3      	b.n	1ddb0 <SFXBitcrusherTick+0xe0>
                input[1] = tanhf(tCrusher_tick(&crush2, input[0] * displayValues[5])) * displayValues[4] * volumeComp;
   1dde8:	edd4 7a05 	vldr	s15, [r4, #20]
   1ddec:	ed96 0a00 	vldr	s0, [r6]
   1ddf0:	480f      	ldr	r0, [pc, #60]	; (1de30 <SFXBitcrusherTick+0x160>)
   1ddf2:	ee20 0a27 	vmul.f32	s0, s0, s15
   1ddf6:	f007 fd35 	bl	25864 <tCrusher_tick>
   1ddfa:	f00f f9af 	bl	2d15c <tanhf>
   1ddfe:	edd4 7a04 	vldr	s15, [r4, #16]
            input[0] = sample;
   1de02:	ed86 8a00 	vstr	s16, [r6]
                input[1] = tanhf(tCrusher_tick(&crush2, input[0] * displayValues[5])) * displayValues[4] * volumeComp;
   1de06:	ee68 8aa7 	vmul.f32	s17, s17, s15
   1de0a:	ee68 8a80 	vmul.f32	s17, s17, s0
   1de0e:	edc6 8a01 	vstr	s17, [r6, #4]
        }
   1de12:	ecbd 8b02 	vpop	{d8}
   1de16:	bd70      	pop	{r4, r5, r6, pc}
   1de18:	020e55d8 	.word	0x020e55d8
   1de1c:	3f7d70a4 	.word	0x3f7d70a4
   1de20:	3c23d70a 	.word	0x3c23d70a
   1de24:	020fb05c 	.word	0x020fb05c
   1de28:	020e5d28 	.word	0x020e5d28
   1de2c:	3dcccccd 	.word	0x3dcccccd
   1de30:	020e52f4 	.word	0x020e52f4
   1de34:	020e2e30 	.word	0x020e2e30

0001de38 <SFXBitcrusherFree>:
        {
   1de38:	b508      	push	{r3, lr}
            tCrusher_free(&crush);
   1de3a:	4804      	ldr	r0, [pc, #16]	; (1de4c <SFXBitcrusherFree+0x14>)
   1de3c:	f007 fd06 	bl	2584c <tCrusher_free>
            tCrusher_free(&crush2);
   1de40:	4803      	ldr	r0, [pc, #12]	; (1de50 <SFXBitcrusherFree+0x18>)
        }
   1de42:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tCrusher_free(&crush2);
   1de46:	f007 bd01 	b.w	2584c <tCrusher_free>
   1de4a:	bf00      	nop
   1de4c:	020e5d28 	.word	0x020e5d28
   1de50:	020e52f4 	.word	0x020e52f4

0001de54 <SFXDelayAlloc>:
        {
   1de54:	b570      	push	{r4, r5, r6, lr}
   1de56:	ed2d 8b04 	vpush	{d8-d9}
            tTapeDelay_init(&delay, 2000, 30000);
   1de5a:	ed9f 9a2a 	vldr	s18, [pc, #168]	; 1df04 <SFXDelayAlloc+0xb0>
            leaf.clearOnAllocation = 1;
   1de5e:	2501      	movs	r5, #1
   1de60:	4e29      	ldr	r6, [pc, #164]	; (1df08 <SFXDelayAlloc+0xb4>)
            tTapeDelay_init(&delay, 2000, 30000);
   1de62:	f247 5130 	movw	r1, #30000	; 0x7530
            tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
   1de66:	ed9f 8a29 	vldr	s16, [pc, #164]	; 1df0c <SFXDelayAlloc+0xb8>
            tTapeDelay_init(&delay, 2000, 30000);
   1de6a:	eeb0 0a49 	vmov.f32	s0, s18
            tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
   1de6e:	eddf 8a28 	vldr	s17, [pc, #160]	; 1df10 <SFXDelayAlloc+0xbc>
            delayShaper = 0;
   1de72:	2400      	movs	r4, #0
            tTapeDelay_init(&delay, 2000, 30000);
   1de74:	4827      	ldr	r0, [pc, #156]	; (1df14 <SFXDelayAlloc+0xc0>)
            leaf.clearOnAllocation = 1;
   1de76:	6175      	str	r5, [r6, #20]
            tTapeDelay_init(&delay, 2000, 30000);
   1de78:	f007 f86a 	bl	24f50 <tTapeDelay_init>
            tTapeDelay_init(&delay2, 2000, 30000);
   1de7c:	eeb0 0a49 	vmov.f32	s0, s18
   1de80:	f247 5130 	movw	r1, #30000	; 0x7530
   1de84:	4824      	ldr	r0, [pc, #144]	; (1df18 <SFXDelayAlloc+0xc4>)
   1de86:	f007 f863 	bl	24f50 <tTapeDelay_init>
            tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
   1de8a:	eef0 0a48 	vmov.f32	s1, s16
   1de8e:	eeb0 0a68 	vmov.f32	s0, s17
   1de92:	4629      	mov	r1, r5
   1de94:	4821      	ldr	r0, [pc, #132]	; (1df1c <SFXDelayAlloc+0xc8>)
   1de96:	f00a f8f1 	bl	2807c <tSVF_init>
            tSVF_init(&delayHP, SVFTypeHighpass, 20.f, .7f);
   1de9a:	eef0 0a48 	vmov.f32	s1, s16
   1de9e:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1dea2:	4621      	mov	r1, r4
   1dea4:	481e      	ldr	r0, [pc, #120]	; (1df20 <SFXDelayAlloc+0xcc>)
   1dea6:	f00a f8e9 	bl	2807c <tSVF_init>
            tSVF_init(&delayLP2, SVFTypeLowpass, 16000.f, .7f);
   1deaa:	eef0 0a48 	vmov.f32	s1, s16
   1deae:	eeb0 0a68 	vmov.f32	s0, s17
   1deb2:	4629      	mov	r1, r5
   1deb4:	481b      	ldr	r0, [pc, #108]	; (1df24 <SFXDelayAlloc+0xd0>)
   1deb6:	f00a f8e1 	bl	2807c <tSVF_init>
            tSVF_init(&delayHP2, SVFTypeHighpass, 20.f, .7f);
   1deba:	eef0 0a48 	vmov.f32	s1, s16
   1debe:	4621      	mov	r1, r4
   1dec0:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1dec4:	4818      	ldr	r0, [pc, #96]	; (1df28 <SFXDelayAlloc+0xd4>)
   1dec6:	f00a f8d9 	bl	2807c <tSVF_init>
            tHighpass_init(&delayShaperHp, 20.0f);
   1deca:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1dece:	4817      	ldr	r0, [pc, #92]	; (1df2c <SFXDelayAlloc+0xd8>)
   1ded0:	f00a fa84 	bl	283dc <tHighpass_init>
            tFeedbackLeveler_init(&feedbackControl, .99f, 0.01, 0.125f, 0);
   1ded4:	4621      	mov	r1, r4
   1ded6:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
   1deda:	eddf 0a15 	vldr	s1, [pc, #84]	; 1df30 <SFXDelayAlloc+0xdc>
   1dede:	ed9f 0a15 	vldr	s0, [pc, #84]	; 1df34 <SFXDelayAlloc+0xe0>
   1dee2:	4815      	ldr	r0, [pc, #84]	; (1df38 <SFXDelayAlloc+0xe4>)
   1dee4:	f007 fd4a 	bl	2597c <tFeedbackLeveler_init>
            capFeedback = 1;
   1dee8:	4b14      	ldr	r3, [pc, #80]	; (1df3c <SFXDelayAlloc+0xe8>)
            delayShaper = 0;
   1deea:	4a15      	ldr	r2, [pc, #84]	; (1df40 <SFXDelayAlloc+0xec>)
            setLED_A(delayShaper);
   1deec:	4620      	mov	r0, r4
            capFeedback = 1;
   1deee:	701d      	strb	r5, [r3, #0]
            freeze = 0;
   1def0:	4b14      	ldr	r3, [pc, #80]	; (1df44 <SFXDelayAlloc+0xf0>)
            delayShaper = 0;
   1def2:	6014      	str	r4, [r2, #0]
            freeze = 0;
   1def4:	601c      	str	r4, [r3, #0]
            setLED_A(delayShaper);
   1def6:	f7fb facb 	bl	19490 <setLED_A>
            leaf.clearOnAllocation = 0;
   1defa:	6174      	str	r4, [r6, #20]
        }
   1defc:	ecbd 8b04 	vpop	{d8-d9}
   1df00:	bd70      	pop	{r4, r5, r6, pc}
   1df02:	bf00      	nop
   1df04:	44fa0000 	.word	0x44fa0000
   1df08:	020fbd68 	.word	0x020fbd68
   1df0c:	3f333333 	.word	0x3f333333
   1df10:	467a0000 	.word	0x467a0000
   1df14:	020fa044 	.word	0x020fa044
   1df18:	020e5f20 	.word	0x020e5f20
   1df1c:	020f9f60 	.word	0x020f9f60
   1df20:	020f9ba0 	.word	0x020f9ba0
   1df24:	020f9ed8 	.word	0x020f9ed8
   1df28:	020f9dec 	.word	0x020f9dec
   1df2c:	020f9dd0 	.word	0x020f9dd0
   1df30:	3c23d70a 	.word	0x3c23d70a
   1df34:	3f7d70a4 	.word	0x3f7d70a4
   1df38:	020f9c08 	.word	0x020f9c08
   1df3c:	020e2df0 	.word	0x020e2df0
   1df40:	020e2e40 	.word	0x020e2e40
   1df44:	020e2e58 	.word	0x020e2e58

0001df48 <SFXDelayFrame>:
        {
   1df48:	b510      	push	{r4, lr}
            if (buttonActionsSFX[ButtonA][ActionPress])
   1df4a:	4c14      	ldr	r4, [pc, #80]	; (1df9c <SFXDelayFrame+0x54>)
   1df4c:	7d23      	ldrb	r3, [r4, #20]
   1df4e:	b9cb      	cbnz	r3, 1df84 <SFXDelayFrame+0x3c>
            if (buttonActionsSFX[ButtonB][ActionPress])
   1df50:	7e23      	ldrb	r3, [r4, #24]
   1df52:	b13b      	cbz	r3, 1df64 <SFXDelayFrame+0x1c>
                capFeedback = !capFeedback;
   1df54:	4a12      	ldr	r2, [pc, #72]	; (1dfa0 <SFXDelayFrame+0x58>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1df56:	2100      	movs	r1, #0
                capFeedback = !capFeedback;
   1df58:	7813      	ldrb	r3, [r2, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1df5a:	7621      	strb	r1, [r4, #24]
                capFeedback = !capFeedback;
   1df5c:	fab3 f383 	clz	r3, r3
   1df60:	095b      	lsrs	r3, r3, #5
   1df62:	7013      	strb	r3, [r2, #0]
            if (buttonActionsSFX[ButtonC][ActionPress])
   1df64:	7f23      	ldrb	r3, [r4, #28]
   1df66:	b903      	cbnz	r3, 1df6a <SFXDelayFrame+0x22>
        }
   1df68:	bd10      	pop	{r4, pc}
                freeze = !freeze;
   1df6a:	4a0e      	ldr	r2, [pc, #56]	; (1dfa4 <SFXDelayFrame+0x5c>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1df6c:	2100      	movs	r1, #0
                freeze = !freeze;
   1df6e:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1df70:	7721      	strb	r1, [r4, #28]
                freeze = !freeze;
   1df72:	fab3 f383 	clz	r3, r3
   1df76:	095b      	lsrs	r3, r3, #5
   1df78:	6013      	str	r3, [r2, #0]
                setLED_C(freeze);
   1df7a:	4618      	mov	r0, r3
        }
   1df7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                setLED_C(freeze);
   1df80:	f7fb baa2 	b.w	194c8 <setLED_C>
                delayShaper = !delayShaper;
   1df84:	4a08      	ldr	r2, [pc, #32]	; (1dfa8 <SFXDelayFrame+0x60>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1df86:	2100      	movs	r1, #0
                delayShaper = !delayShaper;
   1df88:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1df8a:	7521      	strb	r1, [r4, #20]
                delayShaper = !delayShaper;
   1df8c:	fab3 f383 	clz	r3, r3
   1df90:	095b      	lsrs	r3, r3, #5
                setLED_A(delayShaper);
   1df92:	4618      	mov	r0, r3
                delayShaper = !delayShaper;
   1df94:	6013      	str	r3, [r2, #0]
                setLED_A(delayShaper);
   1df96:	f7fb fa7b 	bl	19490 <setLED_A>
   1df9a:	e7d9      	b.n	1df50 <SFXDelayFrame+0x8>
   1df9c:	020fafac 	.word	0x020fafac
   1dfa0:	020e2df0 	.word	0x020e2df0
   1dfa4:	020e2e58 	.word	0x020e2e58
   1dfa8:	020e2e40 	.word	0x020e2e40

0001dfac <SFXDelayTick>:
        {
   1dfac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   1dfae:	4d88      	ldr	r5, [pc, #544]	; (1e1d0 <SFXDelayTick+0x224>)
        {
   1dfb0:	4607      	mov	r7, r0
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   1dfb2:	eddf 6a88 	vldr	s13, [pc, #544]	; 1e1d4 <SFXDelayTick+0x228>
   1dfb6:	462b      	mov	r3, r5
   1dfb8:	4c87      	ldr	r4, [pc, #540]	; (1e1d8 <SFXDelayTick+0x22c>)
        {
   1dfba:	ed2d 8b02 	vpush	{d8}
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   1dfbe:	eeb2 8a04 	vmov.f32	s16, #36	; 0x41200000  10.0
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   1dfc2:	ecb3 7a01 	vldmia	r3!, {s14}
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   1dfc6:	edd5 7a02 	vldr	s15, [r5, #8]
   1dfca:	eddf 8a84 	vldr	s17, [pc, #528]	; 1e1dc <SFXDelayTick+0x230>
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   1dfce:	ee27 7a26 	vmul.f32	s14, s14, s13
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   1dfd2:	eeb0 0a48 	vmov.f32	s0, s16
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   1dfd6:	ed84 7a00 	vstr	s14, [r4]
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   1dfda:	eea7 0aa8 	vfma.f32	s0, s15, s17
            displayValues[1] = presetKnobValues[Delay][1] * 30000.0f;
   1dfde:	edd3 7a00 	vldr	s15, [r3]
   1dfe2:	ee67 7aa6 	vmul.f32	s15, s15, s13
   1dfe6:	edc4 7a01 	vstr	s15, [r4, #4]
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   1dfea:	f00b fd0b 	bl	29a04 <faster_mtof>
   1dfee:	ed84 0a02 	vstr	s0, [r4, #8]
            displayValues[3] = faster_mtof((presetKnobValues[Delay][3] * 128) + 10.0f);
   1dff2:	eeb0 0a48 	vmov.f32	s0, s16
   1dff6:	edd5 7a03 	vldr	s15, [r5, #12]
   1dffa:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1dffe:	f00b fd01 	bl	29a04 <faster_mtof>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   1e002:	4b77      	ldr	r3, [pc, #476]	; (1e1e0 <SFXDelayTick+0x234>)
            displayValues[3] = faster_mtof((presetKnobValues[Delay][3] * 128) + 10.0f);
   1e004:	ed84 0a03 	vstr	s0, [r4, #12]
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   1e008:	781b      	ldrb	r3, [r3, #0]
   1e00a:	2b00      	cmp	r3, #0
   1e00c:	f040 80d1 	bne.w	1e1b2 <SFXDelayTick+0x206>
   1e010:	edd5 7a04 	vldr	s15, [r5, #16]
   1e014:	ed9f 7a73 	vldr	s14, [pc, #460]	; 1e1e4 <SFXDelayTick+0x238>
   1e018:	ee67 7a87 	vmul.f32	s15, s15, s14
            displayValues[5] = presetKnobValues[Delay][5];
   1e01c:	4b72      	ldr	r3, [pc, #456]	; (1e1e8 <SFXDelayTick+0x23c>)
            tSVF_setFreq(&delayHP, displayValues[2]);
   1e01e:	ed94 0a02 	vldr	s0, [r4, #8]
            displayValues[5] = presetKnobValues[Delay][5];
   1e022:	681b      	ldr	r3, [r3, #0]
            tSVF_setFreq(&delayHP, displayValues[2]);
   1e024:	4871      	ldr	r0, [pc, #452]	; (1e1ec <SFXDelayTick+0x240>)
            displayValues[5] = presetKnobValues[Delay][5];
   1e026:	6163      	str	r3, [r4, #20]
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   1e028:	edc4 7a04 	vstr	s15, [r4, #16]
            tSVF_setFreq(&delayHP, displayValues[2]);
   1e02c:	f00a f8da 	bl	281e4 <tSVF_setFreq>
            tSVF_setFreq(&delayHP2, displayValues[2]);
   1e030:	ed94 0a02 	vldr	s0, [r4, #8]
   1e034:	486e      	ldr	r0, [pc, #440]	; (1e1f0 <SFXDelayTick+0x244>)
   1e036:	f00a f8d5 	bl	281e4 <tSVF_setFreq>
            tSVF_setFreq(&delayLP, displayValues[3]);
   1e03a:	ed94 0a03 	vldr	s0, [r4, #12]
   1e03e:	486d      	ldr	r0, [pc, #436]	; (1e1f4 <SFXDelayTick+0x248>)
   1e040:	f00a f8d0 	bl	281e4 <tSVF_setFreq>
            tSVF_setFreq(&delayLP2, displayValues[3]);
   1e044:	ed94 0a03 	vldr	s0, [r4, #12]
   1e048:	486b      	ldr	r0, [pc, #428]	; (1e1f8 <SFXDelayTick+0x24c>)
   1e04a:	f00a f8cb 	bl	281e4 <tSVF_setFreq>
            if (delayShaper == 0)
   1e04e:	4b6b      	ldr	r3, [pc, #428]	; (1e1fc <SFXDelayTick+0x250>)
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   1e050:	4e6b      	ldr	r6, [pc, #428]	; (1e200 <SFXDelayTick+0x254>)
            if (delayShaper == 0)
   1e052:	681b      	ldr	r3, [r3, #0]
   1e054:	2b00      	cmp	r3, #0
   1e056:	d16d      	bne.n	1e134 <SFXDelayTick+0x188>
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   1e058:	ed94 7a04 	vldr	s14, [r4, #16]
   1e05c:	edd6 7a00 	vldr	s15, [r6]
   1e060:	ed97 0a01 	vldr	s0, [r7, #4]
                input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
   1e064:	4d67      	ldr	r5, [pc, #412]	; (1e204 <SFXDelayTick+0x258>)
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   1e066:	eea7 0a27 	vfma.f32	s0, s14, s15
   1e06a:	f00f f877 	bl	2d15c <tanhf>
   1e06e:	4866      	ldr	r0, [pc, #408]	; (1e208 <SFXDelayTick+0x25c>)
   1e070:	f007 fce6 	bl	25a40 <tFeedbackLeveler_tick>
                input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
   1e074:	edd5 7a00 	vldr	s15, [r5]
   1e078:	ed94 7a04 	vldr	s14, [r4, #16]
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   1e07c:	eef0 8a40 	vmov.f32	s17, s0
                input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
   1e080:	ed97 0a01 	vldr	s0, [r7, #4]
   1e084:	eea7 0a27 	vfma.f32	s0, s14, s15
   1e088:	f00f f868 	bl	2d15c <tanhf>
   1e08c:	485e      	ldr	r0, [pc, #376]	; (1e208 <SFXDelayTick+0x25c>)
   1e08e:	f007 fcd7 	bl	25a40 <tFeedbackLeveler_tick>
   1e092:	eeb0 8a40 	vmov.f32	s16, s0
            tTapeDelay_setDelay(&delay, displayValues[0]);
   1e096:	ed94 0a00 	vldr	s0, [r4]
   1e09a:	485c      	ldr	r0, [pc, #368]	; (1e20c <SFXDelayTick+0x260>)
   1e09c:	f007 f840 	bl	25120 <tTapeDelay_setDelay>
            tTapeDelay_setDelay(&delay2, displayValues[1]);
   1e0a0:	ed94 0a01 	vldr	s0, [r4, #4]
   1e0a4:	485a      	ldr	r0, [pc, #360]	; (1e210 <SFXDelayTick+0x264>)
   1e0a6:	f007 f83b 	bl	25120 <tTapeDelay_setDelay>
            if (!freeze)
   1e0aa:	4b5a      	ldr	r3, [pc, #360]	; (1e214 <SFXDelayTick+0x268>)
   1e0ac:	681b      	ldr	r3, [r3, #0]
   1e0ae:	2b00      	cmp	r3, #0
   1e0b0:	d070      	beq.n	1e194 <SFXDelayTick+0x1e8>
                delayFB1 = tTapeDelay_tick(&delay, delayFB1);
   1e0b2:	4856      	ldr	r0, [pc, #344]	; (1e20c <SFXDelayTick+0x260>)
   1e0b4:	ed96 0a00 	vldr	s0, [r6]
   1e0b8:	f006 ffbc 	bl	25034 <tTapeDelay_tick>
                delayFB2 = tTapeDelay_tick(&delay2, delayFB2);
   1e0bc:	4854      	ldr	r0, [pc, #336]	; (1e210 <SFXDelayTick+0x264>)
                delayFB1 = tTapeDelay_tick(&delay, delayFB1);
   1e0be:	ed86 0a00 	vstr	s0, [r6]
                delayFB2 = tTapeDelay_tick(&delay2, delayFB2);
   1e0c2:	ed95 0a00 	vldr	s0, [r5]
   1e0c6:	f006 ffb5 	bl	25034 <tTapeDelay_tick>
   1e0ca:	ed85 0a00 	vstr	s0, [r5]
            delayFB1 = tSVF_tick(&delayLP, delayFB1);
   1e0ce:	4849      	ldr	r0, [pc, #292]	; (1e1f4 <SFXDelayTick+0x248>)
   1e0d0:	ed96 0a00 	vldr	s0, [r6]
   1e0d4:	f00a f850 	bl	28178 <tSVF_tick>
            delayFB2 = tSVF_tick(&delayLP2, delayFB2);
   1e0d8:	4847      	ldr	r0, [pc, #284]	; (1e1f8 <SFXDelayTick+0x24c>)
            delayFB1 = tSVF_tick(&delayLP, delayFB1);
   1e0da:	ed86 0a00 	vstr	s0, [r6]
            delayFB2 = tSVF_tick(&delayLP2, delayFB2);
   1e0de:	ed95 0a00 	vldr	s0, [r5]
   1e0e2:	f00a f849 	bl	28178 <tSVF_tick>
            delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
   1e0e6:	4841      	ldr	r0, [pc, #260]	; (1e1ec <SFXDelayTick+0x240>)
            delayFB2 = tSVF_tick(&delayLP2, delayFB2);
   1e0e8:	ed85 0a00 	vstr	s0, [r5]
            delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
   1e0ec:	ed96 0a00 	vldr	s0, [r6]
   1e0f0:	f00a f842 	bl	28178 <tSVF_tick>
   1e0f4:	f00f f832 	bl	2d15c <tanhf>
            delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
   1e0f8:	483d      	ldr	r0, [pc, #244]	; (1e1f0 <SFXDelayTick+0x244>)
            delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
   1e0fa:	ed86 0a00 	vstr	s0, [r6]
            delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
   1e0fe:	ed95 0a00 	vldr	s0, [r5]
   1e102:	f00a f839 	bl	28178 <tSVF_tick>
   1e106:	f00f f829 	bl	2d15c <tanhf>
            input[0] = delayFB1 * displayValues[5];
   1e10a:	edd4 7a05 	vldr	s15, [r4, #20]
   1e10e:	ed96 7a00 	vldr	s14, [r6]
            delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
   1e112:	ed85 0a00 	vstr	s0, [r5]
            input[0] = delayFB1 * displayValues[5];
   1e116:	ee67 7a87 	vmul.f32	s15, s15, s14
   1e11a:	edc7 7a00 	vstr	s15, [r7]
            input[1] = delayFB2 * displayValues[5];
   1e11e:	edd4 7a05 	vldr	s15, [r4, #20]
   1e122:	ed95 7a00 	vldr	s14, [r5]
   1e126:	ee67 7a87 	vmul.f32	s15, s15, s14
   1e12a:	edc7 7a01 	vstr	s15, [r7, #4]
        }
   1e12e:	ecbd 8b02 	vpop	{d8}
   1e132:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
   1e134:	ed96 7a00 	vldr	s14, [r6]
   1e138:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
   1e13c:	edd4 7a04 	vldr	s15, [r4, #16]
   1e140:	ed97 0a01 	vldr	s0, [r7, #4]
   1e144:	ee67 7a87 	vmul.f32	s15, s15, s14
                input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
   1e148:	4d2e      	ldr	r5, [pc, #184]	; (1e204 <SFXDelayTick+0x258>)
                input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
   1e14a:	eef0 0a48 	vmov.f32	s1, s16
   1e14e:	eea7 0a88 	vfma.f32	s0, s15, s16
   1e152:	f00b fa8f 	bl	29674 <LEAF_shaper>
   1e156:	4830      	ldr	r0, [pc, #192]	; (1e218 <SFXDelayTick+0x26c>)
   1e158:	f00a f994 	bl	28484 <tHighpass_tick>
   1e15c:	482a      	ldr	r0, [pc, #168]	; (1e208 <SFXDelayTick+0x25c>)
   1e15e:	f007 fc6f 	bl	25a40 <tFeedbackLeveler_tick>
                input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
   1e162:	ed95 7a00 	vldr	s14, [r5]
   1e166:	edd4 7a04 	vldr	s15, [r4, #16]
                input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
   1e16a:	eef0 8a40 	vmov.f32	s17, s0
                input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
   1e16e:	ed97 0a01 	vldr	s0, [r7, #4]
   1e172:	eef0 0a48 	vmov.f32	s1, s16
   1e176:	ee67 7a87 	vmul.f32	s15, s15, s14
   1e17a:	eea7 0a88 	vfma.f32	s0, s15, s16
   1e17e:	f00b fa79 	bl	29674 <LEAF_shaper>
   1e182:	4825      	ldr	r0, [pc, #148]	; (1e218 <SFXDelayTick+0x26c>)
   1e184:	f00a f97e 	bl	28484 <tHighpass_tick>
   1e188:	481f      	ldr	r0, [pc, #124]	; (1e208 <SFXDelayTick+0x25c>)
   1e18a:	f007 fc59 	bl	25a40 <tFeedbackLeveler_tick>
   1e18e:	eeb0 8a40 	vmov.f32	s16, s0
   1e192:	e780      	b.n	1e096 <SFXDelayTick+0xea>
                delayFB1 = tTapeDelay_tick(&delay, input1);
   1e194:	481d      	ldr	r0, [pc, #116]	; (1e20c <SFXDelayTick+0x260>)
   1e196:	eeb0 0a68 	vmov.f32	s0, s17
   1e19a:	f006 ff4b 	bl	25034 <tTapeDelay_tick>
                delayFB2 = tTapeDelay_tick(&delay2, input2);
   1e19e:	481c      	ldr	r0, [pc, #112]	; (1e210 <SFXDelayTick+0x264>)
                delayFB1 = tTapeDelay_tick(&delay, input1);
   1e1a0:	ed86 0a00 	vstr	s0, [r6]
                delayFB2 = tTapeDelay_tick(&delay2, input2);
   1e1a4:	eeb0 0a48 	vmov.f32	s0, s16
   1e1a8:	f006 ff44 	bl	25034 <tTapeDelay_tick>
   1e1ac:	ed85 0a00 	vstr	s0, [r5]
   1e1b0:	e78d      	b.n	1e0ce <SFXDelayTick+0x122>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   1e1b2:	eddf 7a0c 	vldr	s15, [pc, #48]	; 1e1e4 <SFXDelayTick+0x238>
   1e1b6:	edd5 0a04 	vldr	s1, [r5, #16]
   1e1ba:	ed9f 1a18 	vldr	s2, [pc, #96]	; 1e21c <SFXDelayTick+0x270>
   1e1be:	ee60 0aa7 	vmul.f32	s1, s1, s15
   1e1c2:	ed9f 0a17 	vldr	s0, [pc, #92]	; 1e220 <SFXDelayTick+0x274>
   1e1c6:	f00b faaf 	bl	29728 <LEAF_clip>
   1e1ca:	eef0 7a40 	vmov.f32	s15, s0
   1e1ce:	e725      	b.n	1e01c <SFXDelayTick+0x70>
   1e1d0:	020e5a24 	.word	0x020e5a24
   1e1d4:	46ea6000 	.word	0x46ea6000
   1e1d8:	020fb05c 	.word	0x020fb05c
   1e1dc:	43000000 	.word	0x43000000
   1e1e0:	020e2df0 	.word	0x020e2df0
   1e1e4:	3f8ccccd 	.word	0x3f8ccccd
   1e1e8:	020e5a38 	.word	0x020e5a38
   1e1ec:	020f9ba0 	.word	0x020f9ba0
   1e1f0:	020f9dec 	.word	0x020f9dec
   1e1f4:	020f9f60 	.word	0x020f9f60
   1e1f8:	020f9ed8 	.word	0x020f9ed8
   1e1fc:	020e2e40 	.word	0x020e2e40
   1e200:	020f9de4 	.word	0x020f9de4
   1e204:	020faaf8 	.word	0x020faaf8
   1e208:	020f9c08 	.word	0x020f9c08
   1e20c:	020fa044 	.word	0x020fa044
   1e210:	020e5f20 	.word	0x020e5f20
   1e214:	020e2e58 	.word	0x020e2e58
   1e218:	020f9dd0 	.word	0x020f9dd0
   1e21c:	3f666666 	.word	0x3f666666
   1e220:	00000000 	.word	0x00000000

0001e224 <SFXDelayFree>:
        {
   1e224:	b508      	push	{r3, lr}
            tTapeDelay_free(&delay);
   1e226:	480d      	ldr	r0, [pc, #52]	; (1e25c <SFXDelayFree+0x38>)
   1e228:	f006 fef8 	bl	2501c <tTapeDelay_free>
            tTapeDelay_free(&delay2);
   1e22c:	480c      	ldr	r0, [pc, #48]	; (1e260 <SFXDelayFree+0x3c>)
   1e22e:	f006 fef5 	bl	2501c <tTapeDelay_free>
            tSVF_free(&delayLP);
   1e232:	480c      	ldr	r0, [pc, #48]	; (1e264 <SFXDelayFree+0x40>)
   1e234:	f009 ff9c 	bl	28170 <tSVF_free>
            tSVF_free(&delayHP);
   1e238:	480b      	ldr	r0, [pc, #44]	; (1e268 <SFXDelayFree+0x44>)
   1e23a:	f009 ff99 	bl	28170 <tSVF_free>
            tSVF_free(&delayLP2);
   1e23e:	480b      	ldr	r0, [pc, #44]	; (1e26c <SFXDelayFree+0x48>)
   1e240:	f009 ff96 	bl	28170 <tSVF_free>
            tSVF_free(&delayHP2);
   1e244:	480a      	ldr	r0, [pc, #40]	; (1e270 <SFXDelayFree+0x4c>)
   1e246:	f009 ff93 	bl	28170 <tSVF_free>
            tHighpass_free(&delayShaperHp);
   1e24a:	480a      	ldr	r0, [pc, #40]	; (1e274 <SFXDelayFree+0x50>)
   1e24c:	f00a f906 	bl	2845c <tHighpass_free>
            tFeedbackLeveler_free(&feedbackControl);
   1e250:	4809      	ldr	r0, [pc, #36]	; (1e278 <SFXDelayFree+0x54>)
        }
   1e252:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tFeedbackLeveler_free(&feedbackControl);
   1e256:	f007 bbe3 	b.w	25a20 <tFeedbackLeveler_free>
   1e25a:	bf00      	nop
   1e25c:	020fa044 	.word	0x020fa044
   1e260:	020e5f20 	.word	0x020e5f20
   1e264:	020f9f60 	.word	0x020f9f60
   1e268:	020f9ba0 	.word	0x020f9ba0
   1e26c:	020f9ed8 	.word	0x020f9ed8
   1e270:	020f9dec 	.word	0x020f9dec
   1e274:	020f9dd0 	.word	0x020f9dd0
   1e278:	020f9c08 	.word	0x020f9c08

0001e27c <SFXReverbAlloc>:
        {
   1e27c:	b570      	push	{r4, r5, r6, lr}
            tDattorroReverb_init(&reverb);
   1e27e:	4e0d      	ldr	r6, [pc, #52]	; (1e2b4 <SFXReverbAlloc+0x38>)
            leaf.clearOnAllocation = 1;
   1e280:	2501      	movs	r5, #1
   1e282:	4c0d      	ldr	r4, [pc, #52]	; (1e2b8 <SFXReverbAlloc+0x3c>)
            tDattorroReverb_init(&reverb);
   1e284:	4630      	mov	r0, r6
            leaf.clearOnAllocation = 1;
   1e286:	6165      	str	r5, [r4, #20]
            tDattorroReverb_init(&reverb);
   1e288:	f00d f954 	bl	2b534 <tDattorroReverb_init>
            tExpSmooth_init(&sizeSmoother, 0.5f, 0.001f);
   1e28c:	eddf 0a0b 	vldr	s1, [pc, #44]	; 1e2bc <SFXReverbAlloc+0x40>
   1e290:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
   1e294:	480a      	ldr	r0, [pc, #40]	; (1e2c0 <SFXReverbAlloc+0x44>)
   1e296:	f009 fd4d 	bl	27d34 <tExpSmooth_init>
            tDattorroReverb_setMix(&reverb, 1.0f);
   1e29a:	4630      	mov	r0, r6
   1e29c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1e2a0:	f00d fb4e 	bl	2b940 <tDattorroReverb_setMix>
            freeze = 0;
   1e2a4:	2300      	movs	r3, #0
            capFeedback = 1;
   1e2a6:	4907      	ldr	r1, [pc, #28]	; (1e2c4 <SFXReverbAlloc+0x48>)
            freeze = 0;
   1e2a8:	4a07      	ldr	r2, [pc, #28]	; (1e2c8 <SFXReverbAlloc+0x4c>)
            capFeedback = 1;
   1e2aa:	700d      	strb	r5, [r1, #0]
            leaf.clearOnAllocation = 0;
   1e2ac:	6163      	str	r3, [r4, #20]
            freeze = 0;
   1e2ae:	6013      	str	r3, [r2, #0]
        }
   1e2b0:	bd70      	pop	{r4, r5, r6, pc}
   1e2b2:	bf00      	nop
   1e2b4:	020e5510 	.word	0x020e5510
   1e2b8:	020fbd68 	.word	0x020fbd68
   1e2bc:	3a83126f 	.word	0x3a83126f
   1e2c0:	020faa04 	.word	0x020faa04
   1e2c4:	020e2df0 	.word	0x020e2df0
   1e2c8:	020e2e58 	.word	0x020e2e58

0001e2cc <SFXReverbFrame>:
            if (buttonActionsSFX[ButtonB][ActionPress])
   1e2cc:	4a1c      	ldr	r2, [pc, #112]	; (1e340 <SFXReverbFrame+0x74>)
        {
   1e2ce:	b570      	push	{r4, r5, r6, lr}
   1e2d0:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonB][ActionPress])
   1e2d4:	7e13      	ldrb	r3, [r2, #24]
   1e2d6:	b13b      	cbz	r3, 1e2e8 <SFXReverbFrame+0x1c>
                capFeedback = !capFeedback;
   1e2d8:	491a      	ldr	r1, [pc, #104]	; (1e344 <SFXReverbFrame+0x78>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1e2da:	2000      	movs	r0, #0
                capFeedback = !capFeedback;
   1e2dc:	780b      	ldrb	r3, [r1, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1e2de:	7610      	strb	r0, [r2, #24]
                capFeedback = !capFeedback;
   1e2e0:	fab3 f383 	clz	r3, r3
   1e2e4:	095b      	lsrs	r3, r3, #5
   1e2e6:	700b      	strb	r3, [r1, #0]
            displayValues[1] = faster_mtof(presetKnobValues[Reverb][1]*129.0f);
   1e2e8:	4e17      	ldr	r6, [pc, #92]	; (1e348 <SFXReverbFrame+0x7c>)
   1e2ea:	ed9f 8a18 	vldr	s16, [pc, #96]	; 1e34c <SFXReverbFrame+0x80>
   1e2ee:	4635      	mov	r5, r6
   1e2f0:	4c17      	ldr	r4, [pc, #92]	; (1e350 <SFXReverbFrame+0x84>)
   1e2f2:	ecb5 0a01 	vldmia	r5!, {s0}
   1e2f6:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e2fa:	f00b fb83 	bl	29a04 <faster_mtof>
            tDattorroReverb_setFeedbackFilter(&reverb, displayValues[1]);
   1e2fe:	4815      	ldr	r0, [pc, #84]	; (1e354 <SFXReverbFrame+0x88>)
            displayValues[1] = faster_mtof(presetKnobValues[Reverb][1]*129.0f);
   1e300:	ed84 0a01 	vstr	s0, [r4, #4]
            tDattorroReverb_setFeedbackFilter(&reverb, displayValues[1]);
   1e304:	f00d fc04 	bl	2bb10 <tDattorroReverb_setFeedbackFilter>
            displayValues[2] =  faster_mtof(presetKnobValues[Reverb][2]*123.0f);
   1e308:	eddf 7a13 	vldr	s15, [pc, #76]	; 1e358 <SFXReverbFrame+0x8c>
   1e30c:	ed95 0a00 	vldr	s0, [r5]
   1e310:	ee20 0a27 	vmul.f32	s0, s0, s15
   1e314:	f00b fb76 	bl	29a04 <faster_mtof>
            tDattorroReverb_setHP(&reverb, displayValues[2]);
   1e318:	480e      	ldr	r0, [pc, #56]	; (1e354 <SFXReverbFrame+0x88>)
            displayValues[2] =  faster_mtof(presetKnobValues[Reverb][2]*123.0f);
   1e31a:	ed84 0a02 	vstr	s0, [r4, #8]
            tDattorroReverb_setHP(&reverb, displayValues[2]);
   1e31e:	f00d fb5d 	bl	2b9dc <tDattorroReverb_setHP>
            displayValues[3] = faster_mtof(presetKnobValues[Reverb][3]*129.0f);
   1e322:	ed96 0a02 	vldr	s0, [r6, #8]
   1e326:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e32a:	f00b fb6b 	bl	29a04 <faster_mtof>
            tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
   1e32e:	4809      	ldr	r0, [pc, #36]	; (1e354 <SFXReverbFrame+0x88>)
            displayValues[3] = faster_mtof(presetKnobValues[Reverb][3]*129.0f);
   1e330:	ed84 0a03 	vstr	s0, [r4, #12]
        }
   1e334:	ecbd 8b02 	vpop	{d8}
   1e338:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
   1e33c:	f00d bbd2 	b.w	2bae4 <tDattorroReverb_setInputFilter>
   1e340:	020fafac 	.word	0x020fafac
   1e344:	020e2df0 	.word	0x020e2df0
   1e348:	020e5a8c 	.word	0x020e5a8c
   1e34c:	43010000 	.word	0x43010000
   1e350:	020fb05c 	.word	0x020fb05c
   1e354:	020e5510 	.word	0x020e5510
   1e358:	42f60000 	.word	0x42f60000

0001e35c <SFXReverbTick>:
            if (buttonActionsSFX[ButtonC][ActionPress])
   1e35c:	4b34      	ldr	r3, [pc, #208]	; (1e430 <SFXReverbTick+0xd4>)
        {
   1e35e:	b570      	push	{r4, r5, r6, lr}
   1e360:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonC][ActionPress])
   1e364:	7f1a      	ldrb	r2, [r3, #28]
        {
   1e366:	b082      	sub	sp, #8
   1e368:	4604      	mov	r4, r0
            if (buttonActionsSFX[ButtonC][ActionPress])
   1e36a:	2a00      	cmp	r2, #0
   1e36c:	d144      	bne.n	1e3f8 <SFXReverbTick+0x9c>
            input[1] *= 4.0f;
   1e36e:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
   1e372:	edd4 7a01 	vldr	s15, [r4, #4]
            displayValues[0] = presetKnobValues[Reverb][0];
   1e376:	4e2f      	ldr	r6, [pc, #188]	; (1e434 <SFXReverbTick+0xd8>)
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   1e378:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 1e438 <SFXReverbTick+0xdc>
            input[1] *= 4.0f;
   1e37c:	ee67 7aa6 	vmul.f32	s15, s15, s13
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   1e380:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 1e43c <SFXReverbTick+0xe0>
            displayValues[0] = presetKnobValues[Reverb][0];
   1e384:	4d2e      	ldr	r5, [pc, #184]	; (1e440 <SFXReverbTick+0xe4>)
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   1e386:	482f      	ldr	r0, [pc, #188]	; (1e444 <SFXReverbTick+0xe8>)
            input[1] *= 4.0f;
   1e388:	edc4 7a01 	vstr	s15, [r4, #4]
            displayValues[0] = presetKnobValues[Reverb][0];
   1e38c:	edd6 7a00 	vldr	s15, [r6]
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   1e390:	eea7 0a87 	vfma.f32	s0, s15, s14
            displayValues[0] = presetKnobValues[Reverb][0];
   1e394:	edc5 7a00 	vstr	s15, [r5]
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   1e398:	f009 fd32 	bl	27e00 <tExpSmooth_setDest>
            float tempSize = tExpSmooth_tick(&sizeSmoother);
   1e39c:	4829      	ldr	r0, [pc, #164]	; (1e444 <SFXReverbTick+0xe8>)
   1e39e:	f009 fd39 	bl	27e14 <tExpSmooth_tick>
            tDattorroReverb_setSize(&reverb, tempSize);
   1e3a2:	4829      	ldr	r0, [pc, #164]	; (1e448 <SFXReverbTick+0xec>)
   1e3a4:	f00d fb38 	bl	2ba18 <tDattorroReverb_setSize>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
   1e3a8:	4b28      	ldr	r3, [pc, #160]	; (1e44c <SFXReverbTick+0xf0>)
   1e3aa:	781b      	ldrb	r3, [r3, #0]
   1e3ac:	bba3      	cbnz	r3, 1e418 <SFXReverbTick+0xbc>
   1e3ae:	edd6 7a04 	vldr	s15, [r6, #16]
            tDattorroReverb_setFeedbackGain(&reverb, displayValues[4]);
   1e3b2:	eeb0 0a67 	vmov.f32	s0, s15
   1e3b6:	4824      	ldr	r0, [pc, #144]	; (1e448 <SFXReverbTick+0xec>)
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
   1e3b8:	edc5 7a04 	vstr	s15, [r5, #16]
            tDattorroReverb_setFeedbackGain(&reverb, displayValues[4]);
   1e3bc:	f00d fbc4 	bl	2bb48 <tDattorroReverb_setFeedbackGain>
            sample = tanhf(stereo[0]) * 0.99f;
   1e3c0:	ed9f 8a23 	vldr	s16, [pc, #140]	; 1e450 <SFXReverbTick+0xf4>
            tDattorroReverb_tickStereo(&reverb, input[1], stereo);
   1e3c4:	4669      	mov	r1, sp
   1e3c6:	4820      	ldr	r0, [pc, #128]	; (1e448 <SFXReverbTick+0xec>)
   1e3c8:	ed94 0a01 	vldr	s0, [r4, #4]
   1e3cc:	f00d f910 	bl	2b5f0 <tDattorroReverb_tickStereo>
            sample = tanhf(stereo[0]) * 0.99f;
   1e3d0:	ed9d 0a00 	vldr	s0, [sp]
   1e3d4:	f00e fec2 	bl	2d15c <tanhf>
   1e3d8:	ee60 7a08 	vmul.f32	s15, s0, s16
            input[1] = tanhf(stereo[1]) * 0.99f;
   1e3dc:	ed9d 0a01 	vldr	s0, [sp, #4]
            input[0] = sample;
   1e3e0:	edc4 7a00 	vstr	s15, [r4]
            input[1] = tanhf(stereo[1]) * 0.99f;
   1e3e4:	f00e feba 	bl	2d15c <tanhf>
   1e3e8:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e3ec:	ed84 0a01 	vstr	s0, [r4, #4]
        }
   1e3f0:	b002      	add	sp, #8
   1e3f2:	ecbd 8b02 	vpop	{d8}
   1e3f6:	bd70      	pop	{r4, r5, r6, pc}
                freeze = !freeze;
   1e3f8:	4d16      	ldr	r5, [pc, #88]	; (1e454 <SFXReverbTick+0xf8>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e3fa:	2100      	movs	r1, #0
                tDattorroReverb_setFreeze(&reverb, freeze);
   1e3fc:	4812      	ldr	r0, [pc, #72]	; (1e448 <SFXReverbTick+0xec>)
                freeze = !freeze;
   1e3fe:	682a      	ldr	r2, [r5, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e400:	7719      	strb	r1, [r3, #28]
                freeze = !freeze;
   1e402:	fab2 f282 	clz	r2, r2
   1e406:	0952      	lsrs	r2, r2, #5
                tDattorroReverb_setFreeze(&reverb, freeze);
   1e408:	4611      	mov	r1, r2
                freeze = !freeze;
   1e40a:	602a      	str	r2, [r5, #0]
                tDattorroReverb_setFreeze(&reverb, freeze);
   1e40c:	f00d faa8 	bl	2b960 <tDattorroReverb_setFreeze>
                setLED_C(freeze);
   1e410:	7828      	ldrb	r0, [r5, #0]
   1e412:	f7fb f859 	bl	194c8 <setLED_C>
   1e416:	e7aa      	b.n	1e36e <SFXReverbTick+0x12>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
   1e418:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
   1e41c:	edd6 0a04 	vldr	s1, [r6, #16]
   1e420:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 1e458 <SFXReverbTick+0xfc>
   1e424:	f00b f980 	bl	29728 <LEAF_clip>
   1e428:	eef0 7a40 	vmov.f32	s15, s0
   1e42c:	e7c1      	b.n	1e3b2 <SFXReverbTick+0x56>
   1e42e:	bf00      	nop
   1e430:	020fafac 	.word	0x020fafac
   1e434:	020e5a88 	.word	0x020e5a88
   1e438:	3f666666 	.word	0x3f666666
   1e43c:	3dcccccd 	.word	0x3dcccccd
   1e440:	020fb05c 	.word	0x020fb05c
   1e444:	020faa04 	.word	0x020faa04
   1e448:	020e5510 	.word	0x020e5510
   1e44c:	020e2df0 	.word	0x020e2df0
   1e450:	3f7d70a4 	.word	0x3f7d70a4
   1e454:	020e2e58 	.word	0x020e2e58
   1e458:	00000000 	.word	0x00000000

0001e45c <SFXReverbFree>:
        {
   1e45c:	b508      	push	{r3, lr}
            tDattorroReverb_free(&reverb);
   1e45e:	4804      	ldr	r0, [pc, #16]	; (1e470 <SFXReverbFree+0x14>)
   1e460:	f00d f86e 	bl	2b540 <tDattorroReverb_free>
            tExpSmooth_free(&sizeSmoother);
   1e464:	4803      	ldr	r0, [pc, #12]	; (1e474 <SFXReverbFree+0x18>)
        }
   1e466:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tExpSmooth_free(&sizeSmoother);
   1e46a:	f009 bcb3 	b.w	27dd4 <tExpSmooth_free>
   1e46e:	bf00      	nop
   1e470:	020e5510 	.word	0x020e5510
   1e474:	020faa04 	.word	0x020faa04

0001e478 <SFXReverb2Alloc>:
        {
   1e478:	b570      	push	{r4, r5, r6, lr}
            tNReverb_init(&reverb2, 1.0f);
   1e47a:	4e26      	ldr	r6, [pc, #152]	; (1e514 <SFXReverb2Alloc+0x9c>)
            leaf.clearOnAllocation = 1;
   1e47c:	2401      	movs	r4, #1
   1e47e:	4d26      	ldr	r5, [pc, #152]	; (1e518 <SFXReverb2Alloc+0xa0>)
            tNReverb_init(&reverb2, 1.0f);
   1e480:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1e484:	4630      	mov	r0, r6
            leaf.clearOnAllocation = 1;
   1e486:	616c      	str	r4, [r5, #20]
        {
   1e488:	ed2d 8b04 	vpush	{d8-d9}
            tSVF_init(&lowpass, SVFTypeLowpass, 18000.0f, 0.75f);
   1e48c:	ed9f 9a23 	vldr	s18, [pc, #140]	; 1e51c <SFXReverb2Alloc+0xa4>
            tNReverb_init(&reverb2, 1.0f);
   1e490:	f00c fd7a 	bl	2af88 <tNReverb_init>
            tSVF_init(&highpass, SVFTypeHighpass, 40.0f, 0.75f);
   1e494:	eddf 8a22 	vldr	s17, [pc, #136]	; 1e520 <SFXReverb2Alloc+0xa8>
            tNReverb_setMix(&reverb2, 1.0f);
   1e498:	4630      	mov	r0, r6
   1e49a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
            tSVF_init(&bandpass, SVFTypeBandpass, 2000.0f, 1.0f);
   1e49e:	ed9f 8a21 	vldr	s16, [pc, #132]	; 1e524 <SFXReverb2Alloc+0xac>
            tNReverb_setMix(&reverb2, 1.0f);
   1e4a2:	f00c fdd9 	bl	2b058 <tNReverb_setMix>
            tSVF_init(&lowpass, SVFTypeLowpass, 18000.0f, 0.75f);
   1e4a6:	eeb0 0a49 	vmov.f32	s0, s18
   1e4aa:	4621      	mov	r1, r4
   1e4ac:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   1e4b0:	481d      	ldr	r0, [pc, #116]	; (1e528 <SFXReverb2Alloc+0xb0>)
   1e4b2:	f009 fde3 	bl	2807c <tSVF_init>
            tSVF_init(&highpass, SVFTypeHighpass, 40.0f, 0.75f);
   1e4b6:	eeb0 0a68 	vmov.f32	s0, s17
   1e4ba:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   1e4be:	2100      	movs	r1, #0
   1e4c0:	481a      	ldr	r0, [pc, #104]	; (1e52c <SFXReverb2Alloc+0xb4>)
   1e4c2:	f009 fddb 	bl	2807c <tSVF_init>
            tSVF_init(&bandpass, SVFTypeBandpass, 2000.0f, 1.0f);
   1e4c6:	eeb0 0a48 	vmov.f32	s0, s16
   1e4ca:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   1e4ce:	2102      	movs	r1, #2
   1e4d0:	4817      	ldr	r0, [pc, #92]	; (1e530 <SFXReverb2Alloc+0xb8>)
   1e4d2:	f009 fdd3 	bl	2807c <tSVF_init>
            tSVF_init(&lowpass2, SVFTypeLowpass, 18000.0f, 0.75f);
   1e4d6:	eeb0 0a49 	vmov.f32	s0, s18
   1e4da:	4621      	mov	r1, r4
   1e4dc:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   1e4e0:	4814      	ldr	r0, [pc, #80]	; (1e534 <SFXReverb2Alloc+0xbc>)
   1e4e2:	f009 fdcb 	bl	2807c <tSVF_init>
            tSVF_init(&highpass2, SVFTypeHighpass, 40.0f, 0.75f);
   1e4e6:	eeb0 0a68 	vmov.f32	s0, s17
   1e4ea:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   1e4ee:	2100      	movs	r1, #0
   1e4f0:	4811      	ldr	r0, [pc, #68]	; (1e538 <SFXReverb2Alloc+0xc0>)
   1e4f2:	f009 fdc3 	bl	2807c <tSVF_init>
            tSVF_init(&bandpass2, SVFTypeBandpass, 2000.0f, 1.0f);
   1e4f6:	eeb0 0a48 	vmov.f32	s0, s16
   1e4fa:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   1e4fe:	2102      	movs	r1, #2
   1e500:	480e      	ldr	r0, [pc, #56]	; (1e53c <SFXReverb2Alloc+0xc4>)
   1e502:	f009 fdbb 	bl	2807c <tSVF_init>
            freeze = 0;
   1e506:	2300      	movs	r3, #0
   1e508:	4a0d      	ldr	r2, [pc, #52]	; (1e540 <SFXReverb2Alloc+0xc8>)
            leaf.clearOnAllocation = 0;
   1e50a:	616b      	str	r3, [r5, #20]
            freeze = 0;
   1e50c:	6013      	str	r3, [r2, #0]
        }
   1e50e:	ecbd 8b04 	vpop	{d8-d9}
   1e512:	bd70      	pop	{r4, r5, r6, pc}
   1e514:	020faafc 	.word	0x020faafc
   1e518:	020fbd68 	.word	0x020fbd68
   1e51c:	468ca000 	.word	0x468ca000
   1e520:	42200000 	.word	0x42200000
   1e524:	44fa0000 	.word	0x44fa0000
   1e528:	020e5210 	.word	0x020e5210
   1e52c:	020faa0c 	.word	0x020faa0c
   1e530:	020f9ed4 	.word	0x020f9ed4
   1e534:	020f9b28 	.word	0x020f9b28
   1e538:	020f9dd4 	.word	0x020f9dd4
   1e53c:	020f9eb4 	.word	0x020f9eb4
   1e540:	020e2e58 	.word	0x020e2e58

0001e544 <SFXReverb2Frame>:
   1e544:	4770      	bx	lr
   1e546:	bf00      	nop

0001e548 <SFXReverb2Tick>:
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   1e548:	4b5f      	ldr	r3, [pc, #380]	; (1e6c8 <SFXReverb2Tick+0x180>)
   1e54a:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
        {
   1e54e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1e552:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   1e556:	ed93 0a00 	vldr	s0, [r3]
        {
   1e55a:	b083      	sub	sp, #12
            if (!freeze)
   1e55c:	f8df 919c 	ldr.w	r9, [pc, #412]	; 1e6fc <SFXReverb2Tick+0x1b4>
        {
   1e560:	4605      	mov	r5, r0
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   1e562:	ee20 0a27 	vmul.f32	s0, s0, s15
   1e566:	4c59      	ldr	r4, [pc, #356]	; (1e6cc <SFXReverb2Tick+0x184>)
            if (!freeze)
   1e568:	f8d9 3000 	ldr.w	r3, [r9]
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   1e56c:	ed84 0a00 	vstr	s0, [r4]
            if (!freeze)
   1e570:	2b00      	cmp	r3, #0
   1e572:	f040 8092 	bne.w	1e69a <SFXReverb2Tick+0x152>
                tNReverb_setT60(&reverb2, displayValues[0]);
   1e576:	4856      	ldr	r0, [pc, #344]	; (1e6d0 <SFXReverb2Tick+0x188>)
   1e578:	f00c fd2a 	bl	2afd0 <tNReverb_setT60>
            displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
   1e57c:	4e55      	ldr	r6, [pc, #340]	; (1e6d4 <SFXReverb2Tick+0x18c>)
   1e57e:	eddf 7a56 	vldr	s15, [pc, #344]	; 1e6d8 <SFXReverb2Tick+0x190>
   1e582:	4637      	mov	r7, r6
            displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
   1e584:	ed9f 8a55 	vldr	s16, [pc, #340]	; 1e6dc <SFXReverb2Tick+0x194>
            if (buttonActionsSFX[ButtonC][ActionPress])
   1e588:	f8df 8174 	ldr.w	r8, [pc, #372]	; 1e700 <SFXReverb2Tick+0x1b8>
            displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
   1e58c:	ecb7 0a01 	vldmia	r7!, {s0}
   1e590:	ee20 0a27 	vmul.f32	s0, s0, s15
   1e594:	f00b fa36 	bl	29a04 <faster_mtof>
            tSVF_setFreq(&lowpass, displayValues[1]);
   1e598:	4851      	ldr	r0, [pc, #324]	; (1e6e0 <SFXReverb2Tick+0x198>)
            displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
   1e59a:	ed84 0a01 	vstr	s0, [r4, #4]
            tSVF_setFreq(&lowpass, displayValues[1]);
   1e59e:	f009 fe21 	bl	281e4 <tSVF_setFreq>
            tSVF_setFreq(&lowpass2, displayValues[1]);
   1e5a2:	4850      	ldr	r0, [pc, #320]	; (1e6e4 <SFXReverb2Tick+0x19c>)
   1e5a4:	ed94 0a01 	vldr	s0, [r4, #4]
   1e5a8:	f009 fe1c 	bl	281e4 <tSVF_setFreq>
            displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
   1e5ac:	ed97 0a00 	vldr	s0, [r7]
   1e5b0:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e5b4:	f00b fa26 	bl	29a04 <faster_mtof>
            tSVF_setFreq(&highpass, displayValues[2]);
   1e5b8:	484b      	ldr	r0, [pc, #300]	; (1e6e8 <SFXReverb2Tick+0x1a0>)
            displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
   1e5ba:	ed84 0a02 	vstr	s0, [r4, #8]
            tSVF_setFreq(&highpass, displayValues[2]);
   1e5be:	f009 fe11 	bl	281e4 <tSVF_setFreq>
            tSVF_setFreq(&highpass2, displayValues[2]);
   1e5c2:	484a      	ldr	r0, [pc, #296]	; (1e6ec <SFXReverb2Tick+0x1a4>)
   1e5c4:	ed94 0a02 	vldr	s0, [r4, #8]
   1e5c8:	f009 fe0c 	bl	281e4 <tSVF_setFreq>
            displayValues[3] = faster_mtof(presetKnobValues[Reverb2][3]*128.0f);
   1e5cc:	ed96 0a02 	vldr	s0, [r6, #8]
   1e5d0:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e5d4:	f00b fa16 	bl	29a04 <faster_mtof>
            tSVF_setFreq(&bandpass, displayValues[3]);
   1e5d8:	4845      	ldr	r0, [pc, #276]	; (1e6f0 <SFXReverb2Tick+0x1a8>)
            displayValues[3] = faster_mtof(presetKnobValues[Reverb2][3]*128.0f);
   1e5da:	ed84 0a03 	vstr	s0, [r4, #12]
            tSVF_setFreq(&bandpass, displayValues[3]);
   1e5de:	f009 fe01 	bl	281e4 <tSVF_setFreq>
            tSVF_setFreq(&bandpass2, displayValues[3]);
   1e5e2:	ed94 0a03 	vldr	s0, [r4, #12]
   1e5e6:	4843      	ldr	r0, [pc, #268]	; (1e6f4 <SFXReverb2Tick+0x1ac>)
   1e5e8:	f009 fdfc 	bl	281e4 <tSVF_setFreq>
            displayValues[4] = (presetKnobValues[Reverb2][4] * 4.0f) - 2.0f;
   1e5ec:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   1e5f0:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
   1e5f4:	edd6 6a03 	vldr	s13, [r6, #12]
            if (buttonActionsSFX[ButtonC][ActionPress])
   1e5f8:	f898 301c 	ldrb.w	r3, [r8, #28]
            displayValues[4] = (presetKnobValues[Reverb2][4] * 4.0f) - 2.0f;
   1e5fc:	eee6 7a87 	vfma.f32	s15, s13, s14
   1e600:	edc4 7a04 	vstr	s15, [r4, #16]
            if (buttonActionsSFX[ButtonC][ActionPress])
   1e604:	2b00      	cmp	r3, #0
   1e606:	d150      	bne.n	1e6aa <SFXReverb2Tick+0x162>
            if (buttonActionsSFX[ButtonA][ActionPress])
   1e608:	f898 3014 	ldrb.w	r3, [r8, #20]
   1e60c:	b163      	cbz	r3, 1e628 <SFXReverb2Tick+0xe0>
                freeze = !freeze;
   1e60e:	f8d9 3000 	ldr.w	r3, [r9]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1e612:	2200      	movs	r2, #0
                freeze = !freeze;
   1e614:	fab3 f383 	clz	r3, r3
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1e618:	f888 2014 	strb.w	r2, [r8, #20]
                freeze = !freeze;
   1e61c:	095b      	lsrs	r3, r3, #5
                setLED_C(freeze);
   1e61e:	4618      	mov	r0, r3
                freeze = !freeze;
   1e620:	f8c9 3000 	str.w	r3, [r9]
                setLED_C(freeze);
   1e624:	f7fa ff50 	bl	194c8 <setLED_C>
            tNReverb_tickStereo(&reverb2, input[1], stereoOuts);
   1e628:	4669      	mov	r1, sp
   1e62a:	ed95 0a01 	vldr	s0, [r5, #4]
   1e62e:	4828      	ldr	r0, [pc, #160]	; (1e6d0 <SFXReverb2Tick+0x188>)
   1e630:	f00c fd16 	bl	2b060 <tNReverb_tickStereo>
            float leftOut = tSVF_tick(&lowpass, stereoOuts[0]);
   1e634:	ed9d 0a00 	vldr	s0, [sp]
   1e638:	4829      	ldr	r0, [pc, #164]	; (1e6e0 <SFXReverb2Tick+0x198>)
   1e63a:	f009 fd9d 	bl	28178 <tSVF_tick>
            leftOut = tSVF_tick(&highpass, leftOut);
   1e63e:	482a      	ldr	r0, [pc, #168]	; (1e6e8 <SFXReverb2Tick+0x1a0>)
   1e640:	f009 fd9a 	bl	28178 <tSVF_tick>
            leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
   1e644:	482a      	ldr	r0, [pc, #168]	; (1e6f0 <SFXReverb2Tick+0x1a8>)
            leftOut = tSVF_tick(&highpass, leftOut);
   1e646:	eef0 8a40 	vmov.f32	s17, s0
            leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
   1e64a:	f009 fd95 	bl	28178 <tSVF_tick>
   1e64e:	edd4 7a04 	vldr	s15, [r4, #16]
            float rightOutTemp = tSVF_tick(&lowpass2, stereoOuts[1]);
   1e652:	4824      	ldr	r0, [pc, #144]	; (1e6e4 <SFXReverb2Tick+0x19c>)
            leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
   1e654:	eee0 8a27 	vfma.f32	s17, s0, s15
            float rightOutTemp = tSVF_tick(&lowpass2, stereoOuts[1]);
   1e658:	ed9d 0a01 	vldr	s0, [sp, #4]
   1e65c:	f009 fd8c 	bl	28178 <tSVF_tick>
            rightOutTemp = tSVF_tick(&highpass2, rightOutTemp);
   1e660:	4822      	ldr	r0, [pc, #136]	; (1e6ec <SFXReverb2Tick+0x1a4>)
   1e662:	f009 fd89 	bl	28178 <tSVF_tick>
            rightOutTemp += tSVF_tick(&bandpass, rightOutTemp) * displayValues[4];
   1e666:	4822      	ldr	r0, [pc, #136]	; (1e6f0 <SFXReverb2Tick+0x1a8>)
            rightOutTemp = tSVF_tick(&highpass2, rightOutTemp);
   1e668:	eeb0 8a40 	vmov.f32	s16, s0
            rightOutTemp += tSVF_tick(&bandpass, rightOutTemp) * displayValues[4];
   1e66c:	f009 fd84 	bl	28178 <tSVF_tick>
   1e670:	edd4 7a04 	vldr	s15, [r4, #16]
   1e674:	eea0 8a27 	vfma.f32	s16, s0, s15
            sample = tanhf(leftOut);
   1e678:	eeb0 0a68 	vmov.f32	s0, s17
   1e67c:	f00e fd6e 	bl	2d15c <tanhf>
            input[0] = sample;
   1e680:	ed85 0a00 	vstr	s0, [r5]
            input[1] = tanhf(rightOutTemp);
   1e684:	eeb0 0a48 	vmov.f32	s0, s16
   1e688:	f00e fd68 	bl	2d15c <tanhf>
   1e68c:	ed85 0a01 	vstr	s0, [r5, #4]
        }
   1e690:	b003      	add	sp, #12
   1e692:	ecbd 8b02 	vpop	{d8}
   1e696:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                tNReverb_setT60(&reverb2, 1000.0f);
   1e69a:	ed9f 0a17 	vldr	s0, [pc, #92]	; 1e6f8 <SFXReverb2Tick+0x1b0>
   1e69e:	480c      	ldr	r0, [pc, #48]	; (1e6d0 <SFXReverb2Tick+0x188>)
   1e6a0:	f00c fc96 	bl	2afd0 <tNReverb_setT60>
                input[1] = 0.0f;
   1e6a4:	2300      	movs	r3, #0
   1e6a6:	606b      	str	r3, [r5, #4]
   1e6a8:	e768      	b.n	1e57c <SFXReverb2Tick+0x34>
                freeze = !freeze;
   1e6aa:	f8d9 3000 	ldr.w	r3, [r9]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e6ae:	2200      	movs	r2, #0
                freeze = !freeze;
   1e6b0:	fab3 f383 	clz	r3, r3
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e6b4:	f888 201c 	strb.w	r2, [r8, #28]
                freeze = !freeze;
   1e6b8:	095b      	lsrs	r3, r3, #5
                setLED_C(freeze);
   1e6ba:	4618      	mov	r0, r3
                freeze = !freeze;
   1e6bc:	f8c9 3000 	str.w	r3, [r9]
                setLED_C(freeze);
   1e6c0:	f7fa ff02 	bl	194c8 <setLED_C>
   1e6c4:	e7a0      	b.n	1e608 <SFXReverb2Tick+0xc0>
   1e6c6:	bf00      	nop
   1e6c8:	020e5aec 	.word	0x020e5aec
   1e6cc:	020fb05c 	.word	0x020fb05c
   1e6d0:	020faafc 	.word	0x020faafc
   1e6d4:	020e5af0 	.word	0x020e5af0
   1e6d8:	43070000 	.word	0x43070000
   1e6dc:	43000000 	.word	0x43000000
   1e6e0:	020e5210 	.word	0x020e5210
   1e6e4:	020f9b28 	.word	0x020f9b28
   1e6e8:	020faa0c 	.word	0x020faa0c
   1e6ec:	020f9dd4 	.word	0x020f9dd4
   1e6f0:	020f9ed4 	.word	0x020f9ed4
   1e6f4:	020f9eb4 	.word	0x020f9eb4
   1e6f8:	447a0000 	.word	0x447a0000
   1e6fc:	020e2e58 	.word	0x020e2e58
   1e700:	020fafac 	.word	0x020fafac

0001e704 <SFXReverb2Free>:
        {
   1e704:	b508      	push	{r3, lr}
            tNReverb_free(&reverb2);
   1e706:	480b      	ldr	r0, [pc, #44]	; (1e734 <SFXReverb2Free+0x30>)
   1e708:	f00c fc44 	bl	2af94 <tNReverb_free>
            tSVF_free(&lowpass);
   1e70c:	480a      	ldr	r0, [pc, #40]	; (1e738 <SFXReverb2Free+0x34>)
   1e70e:	f009 fd2f 	bl	28170 <tSVF_free>
            tSVF_free(&highpass);
   1e712:	480a      	ldr	r0, [pc, #40]	; (1e73c <SFXReverb2Free+0x38>)
   1e714:	f009 fd2c 	bl	28170 <tSVF_free>
            tSVF_free(&bandpass);
   1e718:	4809      	ldr	r0, [pc, #36]	; (1e740 <SFXReverb2Free+0x3c>)
   1e71a:	f009 fd29 	bl	28170 <tSVF_free>
            tSVF_free(&lowpass2);
   1e71e:	4809      	ldr	r0, [pc, #36]	; (1e744 <SFXReverb2Free+0x40>)
   1e720:	f009 fd26 	bl	28170 <tSVF_free>
            tSVF_free(&highpass2);
   1e724:	4808      	ldr	r0, [pc, #32]	; (1e748 <SFXReverb2Free+0x44>)
   1e726:	f009 fd23 	bl	28170 <tSVF_free>
            tSVF_free(&bandpass2);
   1e72a:	4808      	ldr	r0, [pc, #32]	; (1e74c <SFXReverb2Free+0x48>)
        }
   1e72c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tSVF_free(&bandpass2);
   1e730:	f009 bd1e 	b.w	28170 <tSVF_free>
   1e734:	020faafc 	.word	0x020faafc
   1e738:	020e5210 	.word	0x020e5210
   1e73c:	020faa0c 	.word	0x020faa0c
   1e740:	020f9ed4 	.word	0x020f9ed4
   1e744:	020f9b28 	.word	0x020f9b28
   1e748:	020f9dd4 	.word	0x020f9dd4
   1e74c:	020f9eb4 	.word	0x020f9eb4

0001e750 <SFXLivingStringAlloc>:
        {
   1e750:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            levMode = 0;
   1e754:	2300      	movs	r3, #0
   1e756:	4e2b      	ldr	r6, [pc, #172]	; (1e804 <SFXLivingStringAlloc+0xb4>)
   1e758:	4d2b      	ldr	r5, [pc, #172]	; (1e808 <SFXLivingStringAlloc+0xb8>)
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   1e75a:	2106      	movs	r1, #6
   1e75c:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 1e840 <SFXLivingStringAlloc+0xf0>
   1e760:	461c      	mov	r4, r3
   1e762:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 1e844 <SFXLivingStringAlloc+0xf4>
   1e766:	4f29      	ldr	r7, [pc, #164]	; (1e80c <SFXLivingStringAlloc+0xbc>)
   1e768:	4829      	ldr	r0, [pc, #164]	; (1e810 <SFXLivingStringAlloc+0xc0>)
            levMode = 0;
   1e76a:	6033      	str	r3, [r6, #0]
        {
   1e76c:	ed2d 8b06 	vpush	{d8-d10}
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
   1e770:	eddf aa28 	vldr	s21, [pc, #160]	; 1e814 <SFXLivingStringAlloc+0xc4>
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   1e774:	f00b fe38 	bl	2a3e8 <tSimplePoly_setNumVoices>
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
   1e778:	ed9f aa27 	vldr	s20, [pc, #156]	; 1e818 <SFXLivingStringAlloc+0xc8>
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   1e77c:	eddf 9a27 	vldr	s19, [pc, #156]	; 1e81c <SFXLivingStringAlloc+0xcc>
   1e780:	ed9f 9a27 	vldr	s18, [pc, #156]	; 1e820 <SFXLivingStringAlloc+0xd0>
   1e784:	ed9f 8a27 	vldr	s16, [pc, #156]	; 1e824 <SFXLivingStringAlloc+0xd4>
   1e788:	eddf 8a27 	vldr	s17, [pc, #156]	; 1e828 <SFXLivingStringAlloc+0xd8>
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
   1e78c:	f8d9 3010 	ldr.w	r3, [r9, #16]
   1e790:	4798      	blx	r3
   1e792:	eef0 7a4a 	vmov.f32	s15, s20
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   1e796:	ed9f 3a1f 	vldr	s6, [pc, #124]	; 1e814 <SFXLivingStringAlloc+0xc4>
   1e79a:	eb08 0004 	add.w	r0, r8, r4
   1e79e:	eeb4 4a00 	vmov.f32	s8, #64	; 0x3e000000  0.125
   1e7a2:	6831      	ldr	r1, [r6, #0]
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
   1e7a4:	eee0 7a2a 	vfma.f32	s15, s0, s21
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   1e7a8:	ed9f 0a20 	vldr	s0, [pc, #128]	; 1e82c <SFXLivingStringAlloc+0xdc>
   1e7ac:	eef0 3a69 	vmov.f32	s7, s19
   1e7b0:	eeb0 1a43 	vmov.f32	s2, s6
   1e7b4:	eeb0 2a49 	vmov.f32	s4, s18
   1e7b8:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
   1e7bc:	eef0 1a48 	vmov.f32	s3, s16
   1e7c0:	eef0 0a68 	vmov.f32	s1, s17
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
   1e7c4:	ece5 7a01 	vstmia	r5!, {s15}
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   1e7c8:	f00c f910 	bl	2a9ec <tComplexLivingString_init>
                tExpSmooth_initToPool(&stringGains[i], 0.0f, 0.002f, &smallPool);
   1e7cc:	1938      	adds	r0, r7, r4
   1e7ce:	3404      	adds	r4, #4
   1e7d0:	4917      	ldr	r1, [pc, #92]	; (1e830 <SFXLivingStringAlloc+0xe0>)
   1e7d2:	eddf 0a18 	vldr	s1, [pc, #96]	; 1e834 <SFXLivingStringAlloc+0xe4>
   1e7d6:	eeb0 0a48 	vmov.f32	s0, s16
   1e7da:	f009 fad5 	bl	27d88 <tExpSmooth_initToPool>
            for (int i = 0; i < NUM_STRINGS; i++)
   1e7de:	2c18      	cmp	r4, #24
   1e7e0:	d1d4      	bne.n	1e78c <SFXLivingStringAlloc+0x3c>
            ignoreFreqKnobs = 0;
   1e7e2:	2300      	movs	r3, #0
   1e7e4:	4a14      	ldr	r2, [pc, #80]	; (1e838 <SFXLivingStringAlloc+0xe8>)
            setLED_A(ignoreFreqKnobs);
   1e7e6:	4618      	mov	r0, r3
            ignoreFreqKnobs = 0;
   1e7e8:	6013      	str	r3, [r2, #0]
            setLED_A(ignoreFreqKnobs);
   1e7ea:	f7fa fe51 	bl	19490 <setLED_A>
            setLED_B(independentStrings);
   1e7ee:	4b13      	ldr	r3, [pc, #76]	; (1e83c <SFXLivingStringAlloc+0xec>)
   1e7f0:	7818      	ldrb	r0, [r3, #0]
   1e7f2:	f7fa fe5b 	bl	194ac <setLED_B>
            setLED_C(levMode);
   1e7f6:	7830      	ldrb	r0, [r6, #0]
        }
   1e7f8:	ecbd 8b06 	vpop	{d8-d10}
   1e7fc:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            setLED_C(levMode);
   1e800:	f7fa be62 	b.w	194c8 <setLED_C>
   1e804:	020e2e68 	.word	0x020e2e68
   1e808:	020e5130 	.word	0x020e5130
   1e80c:	020f98f0 	.word	0x020f98f0
   1e810:	020f9de8 	.word	0x020f9de8
   1e814:	3e99999a 	.word	0x3e99999a
   1e818:	be19999a 	.word	0xbe19999a
   1e81c:	3c23d70a 	.word	0x3c23d70a
   1e820:	460ca000 	.word	0x460ca000
   1e824:	00000000 	.word	0x00000000
   1e828:	3f4ccccd 	.word	0x3f4ccccd
   1e82c:	43dc0000 	.word	0x43dc0000
   1e830:	020fabc0 	.word	0x020fabc0
   1e834:	3b03126f 	.word	0x3b03126f
   1e838:	020e2e5c 	.word	0x020e2e5c
   1e83c:	020e2e60 	.word	0x020e2e60
   1e840:	020fbd68 	.word	0x020fbd68
   1e844:	020e4f38 	.word	0x020e4f38

0001e848 <SFXLivingStringFrame>:
        {
   1e848:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1e84c:	4dba      	ldr	r5, [pc, #744]	; (1eb38 <SFXLivingStringFrame+0x2f0>)
        {
   1e84e:	ed2d 8b04 	vpush	{d8-d9}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1e852:	7d2b      	ldrb	r3, [r5, #20]
        {
   1e854:	b083      	sub	sp, #12
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1e856:	2b01      	cmp	r3, #1
   1e858:	f000 820a 	beq.w	1ec70 <SFXLivingStringFrame+0x428>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1e85c:	7f2b      	ldrb	r3, [r5, #28]
   1e85e:	2b01      	cmp	r3, #1
   1e860:	f000 813b 	beq.w	1eada <SFXLivingStringFrame+0x292>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1e864:	7e2b      	ldrb	r3, [r5, #24]
   1e866:	4fb5      	ldr	r7, [pc, #724]	; (1eb3c <SFXLivingStringFrame+0x2f4>)
   1e868:	2b01      	cmp	r3, #1
                independentStrings = !independentStrings;
   1e86a:	4eb5      	ldr	r6, [pc, #724]	; (1eb40 <SFXLivingStringFrame+0x2f8>)
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1e86c:	f000 8151 	beq.w	1eb12 <SFXLivingStringFrame+0x2ca>
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   1e870:	f8df b300 	ldr.w	fp, [pc, #768]	; 1eb74 <SFXLivingStringFrame+0x32c>
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e874:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   1e878:	eddf 8ab2 	vldr	s17, [pc, #712]	; 1eb44 <SFXLivingStringFrame+0x2fc>
   1e87c:	465d      	mov	r5, fp
   1e87e:	4cb2      	ldr	r4, [pc, #712]	; (1eb48 <SFXLivingStringFrame+0x300>)
   1e880:	ecb5 0a01 	vldmia	r5!, {s0}
   1e884:	ee20 0a28 	vmul.f32	s0, s0, s17
   1e888:	f00b f838 	bl	298fc <LEAF_midiToFrequency>
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   1e88c:	eef2 7a08 	vmov.f32	s15, #40	; 0x41400000  12.0
   1e890:	eddb 6a03 	vldr	s13, [fp, #12]
   1e894:	ed9f 7aad 	vldr	s14, [pc, #692]	; 1eb4c <SFXLivingStringFrame+0x304>
            displayValues[2] = presetKnobValues[LivingString][2]; //decay
   1e898:	f8db 2008 	ldr.w	r2, [fp, #8]
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   1e89c:	eee6 7a87 	vfma.f32	s15, s13, s14
            displayValues[1] = presetKnobValues[LivingString][1]; //detune
   1e8a0:	6829      	ldr	r1, [r5, #0]
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   1e8a2:	ed84 0a00 	vstr	s0, [r4]
            displayValues[2] = presetKnobValues[LivingString][2]; //decay
   1e8a6:	60a2      	str	r2, [r4, #8]
            displayValues[1] = presetKnobValues[LivingString][1]; //detune
   1e8a8:	6061      	str	r1, [r4, #4]
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   1e8aa:	eeb0 0a67 	vmov.f32	s0, s15
   1e8ae:	f00b f885 	bl	299bc <mtof>
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   1e8b2:	ed9b 4a04 	vldr	s8, [fp, #16]
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   1e8b6:	ed9b 5a05 	vldr	s10, [fp, #20]
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   1e8ba:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
   1e8be:	eeb7 4ac4 	vcvt.f64.f32	d4, s8
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   1e8c2:	ed84 0a03 	vstr	s0, [r4, #12]
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   1e8c6:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e8ca:	ed9b 2a06 	vldr	s4, [fp, #24]
   1e8ce:	eef2 2a00 	vmov.f32	s5, #32	; 0x41000000  8.0
   1e8d2:	eeb9 0a00 	vmov.f32	s0, #144	; 0xc0800000 -4.0
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   1e8d6:	ed9f 3b94 	vldr	d3, [pc, #592]	; 1eb28 <SFXLivingStringFrame+0x2e0>
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   1e8da:	ed9f 7b95 	vldr	d7, [pc, #596]	; 1eb30 <SFXLivingStringFrame+0x2e8>
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e8de:	eea2 0a22 	vfma.f32	s0, s4, s5
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   1e8e2:	eea4 6b03 	vfma.f64	d6, d4, d3
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   1e8e6:	eea5 7b03 	vfma.f64	d7, d5, d3
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   1e8ea:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
   1e8ee:	ed84 6a04 	vstr	s12, [r4, #16]
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   1e8f2:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
   1e8f6:	ed84 7a05 	vstr	s14, [r4, #20]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e8fa:	f00e fc2f 	bl	2d15c <tanhf>
   1e8fe:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
            displayValues[7] = presetKnobValues[LivingString][7];// let ring
   1e902:	f8db 201c 	ldr.w	r2, [fp, #28]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e906:	ee30 0a08 	vadd.f32	s0, s0, s16
            if (!independentStrings)
   1e90a:	6836      	ldr	r6, [r6, #0]
            displayValues[7] = presetKnobValues[LivingString][7];// let ring
   1e90c:	61e2      	str	r2, [r4, #28]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e90e:	ee20 0a27 	vmul.f32	s0, s0, s15
   1e912:	ed84 0a06 	vstr	s0, [r4, #24]
            if (!independentStrings)
   1e916:	2e00      	cmp	r6, #0
   1e918:	f040 8134 	bne.w	1eb84 <SFXLivingStringFrame+0x33c>
                if (!ignoreFreqKnobs)
   1e91c:	4b8c      	ldr	r3, [pc, #560]	; (1eb50 <SFXLivingStringFrame+0x308>)
   1e91e:	f8d3 9000 	ldr.w	r9, [r3]
   1e922:	f1b9 0f00 	cmp.w	r9, #0
   1e926:	f000 808b 	beq.w	1ea40 <SFXLivingStringFrame+0x1f8>
   1e92a:	f8df 824c 	ldr.w	r8, [pc, #588]	; 1eb78 <SFXLivingStringFrame+0x330>
   1e92e:	46b1      	mov	r9, r6
   1e930:	4b88      	ldr	r3, [pc, #544]	; (1eb54 <SFXLivingStringFrame+0x30c>)
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1e932:	f8cd 8000 	str.w	r8, [sp]
   1e936:	46b0      	mov	r8, r6
   1e938:	9701      	str	r7, [sp, #4]
   1e93a:	461f      	mov	r7, r3
   1e93c:	f8df a23c 	ldr.w	sl, [pc, #572]	; 1eb7c <SFXLivingStringFrame+0x334>
   1e940:	f8df b23c 	ldr.w	fp, [pc, #572]	; 1eb80 <SFXLivingStringFrame+0x338>
   1e944:	ed9f 9a84 	vldr	s18, [pc, #528]	; 1eb58 <SFXLivingStringFrame+0x310>
   1e948:	eddf 8a84 	vldr	s17, [pc, #528]	; 1eb5c <SFXLivingStringFrame+0x314>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1e94c:	fa5f f688 	uxtb.w	r6, r8
   1e950:	9b01      	ldr	r3, [sp, #4]
   1e952:	4883      	ldr	r0, [pc, #524]	; (1eb60 <SFXLivingStringFrame+0x318>)
   1e954:	4631      	mov	r1, r6
   1e956:	eb03 0509 	add.w	r5, r3, r9
   1e95a:	f00b fd69 	bl	2a430 <tSimplePoly_getPitch>
   1e95e:	ee07 0a90 	vmov	s15, r0
   1e962:	ed9b 0a00 	vldr	s0, [fp]
   1e966:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e96a:	4b7e      	ldr	r3, [pc, #504]	; (1eb64 <SFXLivingStringFrame+0x31c>)
   1e96c:	7818      	ldrb	r0, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1e96e:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e972:	4b7d      	ldr	r3, [pc, #500]	; (1eb68 <SFXLivingStringFrame+0x320>)
   1e974:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1e978:	ee17 1a90 	vmov	r1, s15
   1e97c:	1a09      	subs	r1, r1, r0
   1e97e:	fb83 3c01 	smull	r3, ip, r3, r1
   1e982:	17c8      	asrs	r0, r1, #31
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1e984:	4b79      	ldr	r3, [pc, #484]	; (1eb6c <SFXLivingStringFrame+0x324>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e986:	ebc0 006c 	rsb	r0, r0, ip, asr #1
   1e98a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1e98e:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
   1e992:	ee07 0a90 	vmov	s15, r0
   1e996:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1e99a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1e99e:	ee17 1a90 	vmov	r1, s15
   1e9a2:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   1e9a6:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1e9aa:	ee37 0a00 	vadd.f32	s0, s14, s0
   1e9ae:	f00a ffa5 	bl	298fc <LEAF_midiToFrequency>
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1e9b2:	eef0 6a48 	vmov.f32	s13, s16
   1e9b6:	ecb7 7a01 	vldmia	r7!, {s14}
   1e9ba:	4628      	mov	r0, r5
   1e9bc:	edd4 7a01 	vldr	s15, [r4, #4]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1e9c0:	ecaa 0a01 	vstmia	sl!, {s0}
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1e9c4:	eee7 6a27 	vfma.f32	s13, s14, s15
   1e9c8:	ee26 0a80 	vmul.f32	s0, s13, s0
   1e9cc:	f00c f860 	bl	2aa90 <tComplexLivingString_setFreq>
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1e9d0:	eeb0 0a68 	vmov.f32	s0, s17
   1e9d4:	edd4 7a02 	vldr	s15, [r4, #8]
   1e9d8:	4628      	mov	r0, r5
   1e9da:	eea7 0a89 	vfma.f32	s0, s15, s18
   1e9de:	f00c f8bf 	bl	2ab60 <tComplexLivingString_setDecay>
                        tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   1e9e2:	4628      	mov	r0, r5
   1e9e4:	ed94 0a03 	vldr	s0, [r4, #12]
   1e9e8:	f00c f89a 	bl	2ab20 <tComplexLivingString_setDampFreq>
                        tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   1e9ec:	4628      	mov	r0, r5
   1e9ee:	ed94 0a04 	vldr	s0, [r4, #16]
   1e9f2:	f00c f865 	bl	2aac0 <tComplexLivingString_setPickPos>
                        tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   1e9f6:	4628      	mov	r0, r5
   1e9f8:	ed94 0a05 	vldr	s0, [r4, #20]
   1e9fc:	f00c f870 	bl	2aae0 <tComplexLivingString_setPrepPos>
                        tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   1ea00:	ed94 0a06 	vldr	s0, [r4, #24]
   1ea04:	4628      	mov	r0, r5
   1ea06:	f00c f87d 	bl	2ab04 <tComplexLivingString_setPrepIndex>
                        if (tSimplePoly_isOn(&poly, i))
   1ea0a:	4631      	mov	r1, r6
   1ea0c:	4854      	ldr	r0, [pc, #336]	; (1eb60 <SFXLivingStringFrame+0x318>)
   1ea0e:	f00b fd21 	bl	2a454 <tSimplePoly_isOn>
   1ea12:	9b00      	ldr	r3, [sp, #0]
                            tExpSmooth_setDest(&stringGains[i], 1.0f);
   1ea14:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1ea18:	eb03 0109 	add.w	r1, r3, r9
                        if (tSimplePoly_isOn(&poly, i))
   1ea1c:	b908      	cbnz	r0, 1ea22 <SFXLivingStringFrame+0x1da>
                            tExpSmooth_setDest(&stringGains[i], displayValues[7]);
   1ea1e:	ed94 0a07 	vldr	s0, [r4, #28]
                    for (int i = 0; i < NUM_STRINGS; i++)
   1ea22:	f108 0801 	add.w	r8, r8, #1
                            tExpSmooth_setDest(&stringGains[i], displayValues[7]);
   1ea26:	4608      	mov	r0, r1
   1ea28:	f009 f9ea 	bl	27e00 <tExpSmooth_setDest>
   1ea2c:	f109 0904 	add.w	r9, r9, #4
                    for (int i = 0; i < NUM_STRINGS; i++)
   1ea30:	f1b8 0f06 	cmp.w	r8, #6
   1ea34:	d18a      	bne.n	1e94c <SFXLivingStringFrame+0x104>
        }
   1ea36:	b003      	add	sp, #12
   1ea38:	ecbd 8b04 	vpop	{d8-d9}
   1ea3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ea40:	f8df a110 	ldr.w	sl, [pc, #272]	; 1eb54 <SFXLivingStringFrame+0x30c>
                if (!ignoreFreqKnobs)
   1ea44:	464e      	mov	r6, r9
   1ea46:	f8df 8130 	ldr.w	r8, [pc, #304]	; 1eb78 <SFXLivingStringFrame+0x330>
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1ea4a:	ed9f 9a43 	vldr	s18, [pc, #268]	; 1eb58 <SFXLivingStringFrame+0x310>
   1ea4e:	eddf 8a43 	vldr	s17, [pc, #268]	; 1eb5c <SFXLivingStringFrame+0x314>
                        float freqVal = displayValues[0] * (i+1);
   1ea52:	f109 0901 	add.w	r9, r9, #1
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1ea56:	eeb0 0a48 	vmov.f32	s0, s16
   1ea5a:	ecba 6a01 	vldmia	sl!, {s12}
   1ea5e:	19bd      	adds	r5, r7, r6
   1ea60:	edd4 6a01 	vldr	s13, [r4, #4]
                        float freqVal = displayValues[0] * (i+1);
   1ea64:	ee07 9a90 	vmov	s15, r9
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1ea68:	4628      	mov	r0, r5
                        float freqVal = displayValues[0] * (i+1);
   1ea6a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   1ea6e:	edd4 7a00 	vldr	s15, [r4]
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1ea72:	eea6 0a26 	vfma.f32	s0, s12, s13
                        float freqVal = displayValues[0] * (i+1);
   1ea76:	ee67 7a27 	vmul.f32	s15, s14, s15
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1ea7a:	ee27 0a80 	vmul.f32	s0, s15, s0
   1ea7e:	f00c f807 	bl	2aa90 <tComplexLivingString_setFreq>
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1ea82:	eeb0 0a68 	vmov.f32	s0, s17
   1ea86:	edd4 7a02 	vldr	s15, [r4, #8]
   1ea8a:	4628      	mov	r0, r5
   1ea8c:	eea7 0a89 	vfma.f32	s0, s15, s18
   1ea90:	f00c f866 	bl	2ab60 <tComplexLivingString_setDecay>
                        tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   1ea94:	4628      	mov	r0, r5
   1ea96:	ed94 0a03 	vldr	s0, [r4, #12]
   1ea9a:	f00c f841 	bl	2ab20 <tComplexLivingString_setDampFreq>
                        tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   1ea9e:	4628      	mov	r0, r5
   1eaa0:	ed94 0a04 	vldr	s0, [r4, #16]
   1eaa4:	f00c f80c 	bl	2aac0 <tComplexLivingString_setPickPos>
                        tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   1eaa8:	4628      	mov	r0, r5
   1eaaa:	ed94 0a05 	vldr	s0, [r4, #20]
   1eaae:	f00c f817 	bl	2aae0 <tComplexLivingString_setPrepPos>
                        tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   1eab2:	4628      	mov	r0, r5
   1eab4:	ed94 0a06 	vldr	s0, [r4, #24]
   1eab8:	f00c f824 	bl	2ab04 <tComplexLivingString_setPrepIndex>
                        tExpSmooth_setDest(&stringGains[i], 1.0f);
   1eabc:	eb08 0006 	add.w	r0, r8, r6
   1eac0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1eac4:	3604      	adds	r6, #4
   1eac6:	f009 f99b 	bl	27e00 <tExpSmooth_setDest>
                    for (int i = 0; i < NUM_STRINGS; i++)
   1eaca:	f1b9 0f06 	cmp.w	r9, #6
   1eace:	d1c0      	bne.n	1ea52 <SFXLivingStringFrame+0x20a>
        }
   1ead0:	b003      	add	sp, #12
   1ead2:	ecbd 8b04 	vpop	{d8-d9}
   1ead6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                levMode = !levMode;
   1eada:	4e25      	ldr	r6, [pc, #148]	; (1eb70 <SFXLivingStringFrame+0x328>)
   1eadc:	4f17      	ldr	r7, [pc, #92]	; (1eb3c <SFXLivingStringFrame+0x2f4>)
   1eade:	6831      	ldr	r1, [r6, #0]
   1eae0:	463c      	mov	r4, r7
   1eae2:	f107 0818 	add.w	r8, r7, #24
   1eae6:	fab1 f181 	clz	r1, r1
   1eaea:	0949      	lsrs	r1, r1, #5
   1eaec:	6031      	str	r1, [r6, #0]
   1eaee:	e000      	b.n	1eaf2 <SFXLivingStringFrame+0x2aa>
   1eaf0:	6831      	ldr	r1, [r6, #0]
                    tComplexLivingString_setLevMode(&theString[i], levMode);
   1eaf2:	4620      	mov	r0, r4
   1eaf4:	3404      	adds	r4, #4
   1eaf6:	f00c f84b 	bl	2ab90 <tComplexLivingString_setLevMode>
                for (int i = 0; i < NUM_STRINGS; i++)
   1eafa:	4544      	cmp	r4, r8
   1eafc:	d1f8      	bne.n	1eaf0 <SFXLivingStringFrame+0x2a8>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1eafe:	2300      	movs	r3, #0
                setLED_C(levMode);
   1eb00:	7830      	ldrb	r0, [r6, #0]
                independentStrings = !independentStrings;
   1eb02:	4e0f      	ldr	r6, [pc, #60]	; (1eb40 <SFXLivingStringFrame+0x2f8>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1eb04:	772b      	strb	r3, [r5, #28]
                setLED_C(levMode);
   1eb06:	f7fa fcdf 	bl	194c8 <setLED_C>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1eb0a:	7e2b      	ldrb	r3, [r5, #24]
   1eb0c:	2b01      	cmp	r3, #1
   1eb0e:	f47f aeaf 	bne.w	1e870 <SFXLivingStringFrame+0x28>
                independentStrings = !independentStrings;
   1eb12:	6833      	ldr	r3, [r6, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1eb14:	2200      	movs	r2, #0
                independentStrings = !independentStrings;
   1eb16:	fab3 f383 	clz	r3, r3
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1eb1a:	762a      	strb	r2, [r5, #24]
                independentStrings = !independentStrings;
   1eb1c:	095b      	lsrs	r3, r3, #5
                setLED_B(independentStrings);
   1eb1e:	4618      	mov	r0, r3
                independentStrings = !independentStrings;
   1eb20:	6033      	str	r3, [r6, #0]
                setLED_B(independentStrings);
   1eb22:	f7fa fcc3 	bl	194ac <setLED_B>
   1eb26:	e6a3      	b.n	1e870 <SFXLivingStringFrame+0x28>
   1eb28:	eb851eb8 	.word	0xeb851eb8
   1eb2c:	3fdeb851 	.word	0x3fdeb851
   1eb30:	40000000 	.word	0x40000000
   1eb34:	3f947ae1 	.word	0x3f947ae1
   1eb38:	020fafac 	.word	0x020fafac
   1eb3c:	020e4f38 	.word	0x020e4f38
   1eb40:	020e2e60 	.word	0x020e2e60
   1eb44:	42b40000 	.word	0x42b40000
   1eb48:	020fb05c 	.word	0x020fb05c
   1eb4c:	43020000 	.word	0x43020000
   1eb50:	020e2e5c 	.word	0x020e2e5c
   1eb54:	020e5130 	.word	0x020e5130
   1eb58:	3c75c28f 	.word	0x3c75c28f
   1eb5c:	3f7eb852 	.word	0x3f7eb852
   1eb60:	020f9de8 	.word	0x020f9de8
   1eb64:	020e2f18 	.word	0x020e2f18
   1eb68:	2aaaaaab 	.word	0x2aaaaaab
   1eb6c:	020e2ee4 	.word	0x020e2ee4
   1eb70:	020e2e68 	.word	0x020e2e68
   1eb74:	020e5b50 	.word	0x020e5b50
   1eb78:	020f98f0 	.word	0x020f98f0
   1eb7c:	020e5d04 	.word	0x020e5d04
   1eb80:	020e2ea0 	.word	0x020e2ea0
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   1eb84:	ed9b 0a0a 	vldr	s0, [fp, #40]	; 0x28
                displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
   1eb88:	2600      	movs	r6, #0
   1eb8a:	4d41      	ldr	r5, [pc, #260]	; (1ec90 <SFXLivingStringFrame+0x448>)
   1eb8c:	f104 0a24 	add.w	sl, r4, #36	; 0x24
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   1eb90:	ee20 0a28 	vmul.f32	s0, s0, s17
                for (int i = 0; i < NUM_STRINGS; i++)
   1eb94:	46b1      	mov	r9, r6
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   1eb96:	f00a feb1 	bl	298fc <LEAF_midiToFrequency>
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   1eb9a:	eddb 7a0b 	vldr	s15, [fp, #44]	; 0x2c
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   1eb9e:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   1eba2:	ee27 0aa8 	vmul.f32	s0, s15, s17
                    tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1eba6:	eddf 9a3b 	vldr	s19, [pc, #236]	; 1ec94 <SFXLivingStringFrame+0x44c>
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   1ebaa:	f00a fea7 	bl	298fc <LEAF_midiToFrequency>
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   1ebae:	eddb 7a0c 	vldr	s15, [fp, #48]	; 0x30
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   1ebb2:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   1ebb6:	ee27 0aa8 	vmul.f32	s0, s15, s17
                    tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1ebba:	ed9f 9a37 	vldr	s18, [pc, #220]	; 1ec98 <SFXLivingStringFrame+0x450>
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   1ebbe:	f00a fe9d 	bl	298fc <LEAF_midiToFrequency>
                displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
   1ebc2:	eddb 7a0d 	vldr	s15, [fp, #52]	; 0x34
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   1ebc6:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
                displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
   1ebca:	ee27 0aa8 	vmul.f32	s0, s15, s17
   1ebce:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 1eca0 <SFXLivingStringFrame+0x458>
   1ebd2:	f00a fe93 	bl	298fc <LEAF_midiToFrequency>
                displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
   1ebd6:	eddb 7a0e 	vldr	s15, [fp, #56]	; 0x38
   1ebda:	46ab      	mov	fp, r5
                displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
   1ebdc:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
                displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
   1ebe0:	ee27 0aa8 	vmul.f32	s0, s15, s17
   1ebe4:	f00a fe8a 	bl	298fc <LEAF_midiToFrequency>
   1ebe8:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
                    float freqVal = i == 0 ? displayValues[0] : displayValues[9+i];
   1ebec:	2e00      	cmp	r6, #0
   1ebee:	d04b      	beq.n	1ec88 <SFXLivingStringFrame+0x440>
   1ebf0:	edda 7a00 	vldr	s15, [sl]
                    tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1ebf4:	eeb0 0a48 	vmov.f32	s0, s16
   1ebf8:	ecfb 6a01 	vldmia	fp!, {s13}
   1ebfc:	ed94 7a01 	vldr	s14, [r4, #4]
   1ec00:	eb07 0509 	add.w	r5, r7, r9
                for (int i = 0; i < NUM_STRINGS; i++)
   1ec04:	3601      	adds	r6, #1
   1ec06:	f10a 0a04 	add.w	sl, sl, #4
                    tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1ec0a:	eea6 0a87 	vfma.f32	s0, s13, s14
   1ec0e:	4628      	mov	r0, r5
   1ec10:	ee20 0a27 	vmul.f32	s0, s0, s15
   1ec14:	f00b ff3c 	bl	2aa90 <tComplexLivingString_setFreq>
                    tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1ec18:	eeb0 0a49 	vmov.f32	s0, s18
   1ec1c:	edd4 7a02 	vldr	s15, [r4, #8]
   1ec20:	4628      	mov	r0, r5
   1ec22:	eea7 0aa9 	vfma.f32	s0, s15, s19
   1ec26:	f00b ff9b 	bl	2ab60 <tComplexLivingString_setDecay>
                    tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   1ec2a:	4628      	mov	r0, r5
   1ec2c:	ed94 0a03 	vldr	s0, [r4, #12]
   1ec30:	f00b ff76 	bl	2ab20 <tComplexLivingString_setDampFreq>
                    tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   1ec34:	4628      	mov	r0, r5
   1ec36:	ed94 0a04 	vldr	s0, [r4, #16]
   1ec3a:	f00b ff41 	bl	2aac0 <tComplexLivingString_setPickPos>
                    tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   1ec3e:	4628      	mov	r0, r5
   1ec40:	ed94 0a05 	vldr	s0, [r4, #20]
   1ec44:	f00b ff4c 	bl	2aae0 <tComplexLivingString_setPrepPos>
                    tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   1ec48:	4628      	mov	r0, r5
   1ec4a:	ed94 0a06 	vldr	s0, [r4, #24]
   1ec4e:	f00b ff59 	bl	2ab04 <tComplexLivingString_setPrepIndex>
                    tExpSmooth_setDest(&stringGains[i], 1.0f);
   1ec52:	eb08 0009 	add.w	r0, r8, r9
   1ec56:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1ec5a:	f109 0904 	add.w	r9, r9, #4
   1ec5e:	f009 f8cf 	bl	27e00 <tExpSmooth_setDest>
                for (int i = 0; i < NUM_STRINGS; i++)
   1ec62:	2e06      	cmp	r6, #6
   1ec64:	d1c2      	bne.n	1ebec <SFXLivingStringFrame+0x3a4>
        }
   1ec66:	b003      	add	sp, #12
   1ec68:	ecbd 8b04 	vpop	{d8-d9}
   1ec6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                ignoreFreqKnobs = !ignoreFreqKnobs;
   1ec70:	4a0a      	ldr	r2, [pc, #40]	; (1ec9c <SFXLivingStringFrame+0x454>)
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1ec72:	2100      	movs	r1, #0
                ignoreFreqKnobs = !ignoreFreqKnobs;
   1ec74:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1ec76:	7529      	strb	r1, [r5, #20]
                ignoreFreqKnobs = !ignoreFreqKnobs;
   1ec78:	fab3 f383 	clz	r3, r3
   1ec7c:	095b      	lsrs	r3, r3, #5
                setLED_A(ignoreFreqKnobs);
   1ec7e:	4618      	mov	r0, r3
                ignoreFreqKnobs = !ignoreFreqKnobs;
   1ec80:	6013      	str	r3, [r2, #0]
                setLED_A(ignoreFreqKnobs);
   1ec82:	f7fa fc05 	bl	19490 <setLED_A>
   1ec86:	e5e9      	b.n	1e85c <SFXLivingStringFrame+0x14>
                    float freqVal = i == 0 ? displayValues[0] : displayValues[9+i];
   1ec88:	edd4 7a00 	vldr	s15, [r4]
   1ec8c:	e7b2      	b.n	1ebf4 <SFXLivingStringFrame+0x3ac>
   1ec8e:	bf00      	nop
   1ec90:	020e5130 	.word	0x020e5130
   1ec94:	3c75c28f 	.word	0x3c75c28f
   1ec98:	3f7eb852 	.word	0x3f7eb852
   1ec9c:	020e2e5c 	.word	0x020e2e5c
   1eca0:	020f98f0 	.word	0x020f98f0

0001eca4 <SFXLivingStringTick>:
        {
   1eca4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1eca6:	4605      	mov	r5, r0
   1eca8:	2400      	movs	r4, #0
   1ecaa:	4f10      	ldr	r7, [pc, #64]	; (1ecec <SFXLivingStringTick+0x48>)
   1ecac:	4e10      	ldr	r6, [pc, #64]	; (1ecf0 <SFXLivingStringTick+0x4c>)
   1ecae:	ed2d 8b02 	vpush	{d8}
            float sample = 0.0f;
   1ecb2:	ed9f 8a10 	vldr	s16, [pc, #64]	; 1ecf4 <SFXLivingStringTick+0x50>
                float tick = tComplexLivingString_tick(&theString[i], input[1]);
   1ecb6:	1938      	adds	r0, r7, r4
   1ecb8:	ed95 0a01 	vldr	s0, [r5, #4]
   1ecbc:	f00b ff7e 	bl	2abbc <tComplexLivingString_tick>
                sample += tick * tExpSmooth_tick(&stringGains[i]);
   1ecc0:	1930      	adds	r0, r6, r4
   1ecc2:	3404      	adds	r4, #4
                float tick = tComplexLivingString_tick(&theString[i], input[1]);
   1ecc4:	eef0 8a40 	vmov.f32	s17, s0
                sample += tick * tExpSmooth_tick(&stringGains[i]);
   1ecc8:	f009 f8a4 	bl	27e14 <tExpSmooth_tick>
            for (int i = 0; i < NUM_STRINGS; i++)
   1eccc:	2c18      	cmp	r4, #24
                sample += tick * tExpSmooth_tick(&stringGains[i]);
   1ecce:	eea0 8a28 	vfma.f32	s16, s0, s17
            for (int i = 0; i < NUM_STRINGS; i++)
   1ecd2:	d1f0      	bne.n	1ecb6 <SFXLivingStringTick+0x12>
            sample *= 0.1625f;
   1ecd4:	eddf 7a08 	vldr	s15, [pc, #32]	; 1ecf8 <SFXLivingStringTick+0x54>
   1ecd8:	ee28 8a27 	vmul.f32	s16, s16, s15
            input[0] = sample;
   1ecdc:	ed85 8a00 	vstr	s16, [r5]
            input[1] = sample;
   1ece0:	ed85 8a01 	vstr	s16, [r5, #4]
        }
   1ece4:	ecbd 8b02 	vpop	{d8}
   1ece8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ecea:	bf00      	nop
   1ecec:	020e4f38 	.word	0x020e4f38
   1ecf0:	020f98f0 	.word	0x020f98f0
   1ecf4:	00000000 	.word	0x00000000
   1ecf8:	3e266666 	.word	0x3e266666

0001ecfc <SFXLivingStringFree>:
        {
   1ecfc:	b570      	push	{r4, r5, r6, lr}
   1ecfe:	2400      	movs	r4, #0
   1ed00:	4e05      	ldr	r6, [pc, #20]	; (1ed18 <SFXLivingStringFree+0x1c>)
   1ed02:	4d06      	ldr	r5, [pc, #24]	; (1ed1c <SFXLivingStringFree+0x20>)
                tComplexLivingString_free(&theString[i]);
   1ed04:	1930      	adds	r0, r6, r4
   1ed06:	f00b fe77 	bl	2a9f8 <tComplexLivingString_free>
                tExpSmooth_free(&stringGains[i]);
   1ed0a:	1928      	adds	r0, r5, r4
   1ed0c:	3404      	adds	r4, #4
   1ed0e:	f009 f861 	bl	27dd4 <tExpSmooth_free>
            for (int i = 0; i < NUM_STRINGS; i++)
   1ed12:	2c18      	cmp	r4, #24
   1ed14:	d1f6      	bne.n	1ed04 <SFXLivingStringFree+0x8>
        }
   1ed16:	bd70      	pop	{r4, r5, r6, pc}
   1ed18:	020e4f38 	.word	0x020e4f38
   1ed1c:	020f98f0 	.word	0x020f98f0

0001ed20 <SFXLivingStringSynthAlloc>:
            levMode = 1;
   1ed20:	4a44      	ldr	r2, [pc, #272]	; (1ee34 <SFXLivingStringSynthAlloc+0x114>)
   1ed22:	2001      	movs	r0, #1
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   1ed24:	2106      	movs	r1, #6
        {
   1ed26:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            leaf.clearOnAllocation = 0;
   1ed2a:	2300      	movs	r3, #0
   1ed2c:	f8df b158 	ldr.w	fp, [pc, #344]	; 1ee88 <SFXLivingStringSynthAlloc+0x168>
   1ed30:	4e41      	ldr	r6, [pc, #260]	; (1ee38 <SFXLivingStringSynthAlloc+0x118>)
   1ed32:	f8df a158 	ldr.w	sl, [pc, #344]	; 1ee8c <SFXLivingStringSynthAlloc+0x16c>
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   1ed36:	461c      	mov	r4, r3
   1ed38:	f8df 9154 	ldr.w	r9, [pc, #340]	; 1ee90 <SFXLivingStringSynthAlloc+0x170>
   1ed3c:	f8df 8154 	ldr.w	r8, [pc, #340]	; 1ee94 <SFXLivingStringSynthAlloc+0x174>
   1ed40:	4f3e      	ldr	r7, [pc, #248]	; (1ee3c <SFXLivingStringSynthAlloc+0x11c>)
                tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   1ed42:	4d3f      	ldr	r5, [pc, #252]	; (1ee40 <SFXLivingStringSynthAlloc+0x120>)
            leaf.clearOnAllocation = 0;
   1ed44:	f8cb 3014 	str.w	r3, [fp, #20]
        {
   1ed48:	ed2d 8b06 	vpush	{d8-d10}
                tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
   1ed4c:	ed9f aa3d 	vldr	s20, [pc, #244]	; 1ee44 <SFXLivingStringSynthAlloc+0x124>
   1ed50:	eddf 8a3d 	vldr	s17, [pc, #244]	; 1ee48 <SFXLivingStringSynthAlloc+0x128>
   1ed54:	eddf 9a3d 	vldr	s19, [pc, #244]	; 1ee4c <SFXLivingStringSynthAlloc+0x12c>
   1ed58:	ed9f 9a3d 	vldr	s18, [pc, #244]	; 1ee50 <SFXLivingStringSynthAlloc+0x130>
                tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   1ed5c:	ed9f 8a3d 	vldr	s16, [pc, #244]	; 1ee54 <SFXLivingStringSynthAlloc+0x134>
            levMode = 1;
   1ed60:	6010      	str	r0, [r2, #0]
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   1ed62:	483d      	ldr	r0, [pc, #244]	; (1ee58 <SFXLivingStringSynthAlloc+0x138>)
   1ed64:	f00b fb40 	bl	2a3e8 <tSimplePoly_setNumVoices>
                tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
   1ed68:	eeb4 4a00 	vmov.f32	s8, #64	; 0x3e000000  0.125
   1ed6c:	eddf 1a36 	vldr	s3, [pc, #216]	; 1ee48 <SFXLivingStringSynthAlloc+0x128>
   1ed70:	eef0 3a4a 	vmov.f32	s7, s20
   1ed74:	eb0a 0004 	add.w	r0, sl, r4
   1ed78:	eeb0 3a68 	vmov.f32	s6, s17
   1ed7c:	6831      	ldr	r1, [r6, #0]
   1ed7e:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
   1ed82:	eddf 0a36 	vldr	s1, [pc, #216]	; 1ee5c <SFXLivingStringSynthAlloc+0x13c>
   1ed86:	eeb0 2a69 	vmov.f32	s4, s19
   1ed8a:	ed9f 0a35 	vldr	s0, [pc, #212]	; 1ee60 <SFXLivingStringSynthAlloc+0x140>
   1ed8e:	eeb0 1a49 	vmov.f32	s2, s18
   1ed92:	f00b fe2b 	bl	2a9ec <tComplexLivingString_init>
                tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   1ed96:	eb09 0004 	add.w	r0, r9, r4
   1ed9a:	4629      	mov	r1, r5
   1ed9c:	eef0 0a48 	vmov.f32	s1, s16
   1eda0:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   1eda4:	f009 f846 	bl	27e34 <tSlide_initToPool>
                tSlide_initToPool(&stringInEnvs[i], 12.0f, 1000.0f, &smallPool);
   1eda8:	eb08 0004 	add.w	r0, r8, r4
   1edac:	4629      	mov	r1, r5
   1edae:	eef0 0a48 	vmov.f32	s1, s16
   1edb2:	eeb2 0a08 	vmov.f32	s0, #40	; 0x41400000  12.0
   1edb6:	f009 f83d 	bl	27e34 <tSlide_initToPool>
                tADSR4_initToPool(&pluckEnvs[i], 4.0f, 70.0f, 0.0f, 5.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1edba:	1938      	adds	r0, r7, r4
   1edbc:	3404      	adds	r4, #4
   1edbe:	462b      	mov	r3, r5
   1edc0:	f44f 7200 	mov.w	r2, #512	; 0x200
   1edc4:	4927      	ldr	r1, [pc, #156]	; (1ee64 <SFXLivingStringSynthAlloc+0x144>)
   1edc6:	eef1 1a04 	vmov.f32	s3, #20	; 0x40a00000  5.0
   1edca:	eddf 0a27 	vldr	s1, [pc, #156]	; 1ee68 <SFXLivingStringSynthAlloc+0x148>
   1edce:	eeb0 1a68 	vmov.f32	s2, s17
   1edd2:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1edd6:	f008 fc1f 	bl	27618 <tADSR4_initToPool>
            for (int i = 0; i < NUM_STRINGS; i++)
   1edda:	2c18      	cmp	r4, #24
   1eddc:	d1c4      	bne.n	1ed68 <SFXLivingStringSynthAlloc+0x48>
            tVZFilter_initToPool(&pluckFilt, BandpassPeak, 2000.0f, 4.0f, &smallPool);
   1edde:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
   1ede2:	ed9f 0a22 	vldr	s0, [pc, #136]	; 1ee6c <SFXLivingStringSynthAlloc+0x14c>
   1ede6:	4a16      	ldr	r2, [pc, #88]	; (1ee40 <SFXLivingStringSynthAlloc+0x120>)
   1ede8:	2103      	movs	r1, #3
   1edea:	4821      	ldr	r0, [pc, #132]	; (1ee70 <SFXLivingStringSynthAlloc+0x150>)
   1edec:	f009 fb5a 	bl	284a4 <tVZFilter_initToPool>
            tNoise_initToPool(&stringPluckNoise, WhiteNoise, &smallPool);
   1edf0:	4a13      	ldr	r2, [pc, #76]	; (1ee40 <SFXLivingStringSynthAlloc+0x120>)
   1edf2:	2100      	movs	r1, #0
   1edf4:	481f      	ldr	r0, [pc, #124]	; (1ee74 <SFXLivingStringSynthAlloc+0x154>)
   1edf6:	f00b fc6b 	bl	2a6d0 <tNoise_initToPool>
            setLED_A(numVoices == 1);
   1edfa:	4b1f      	ldr	r3, [pc, #124]	; (1ee78 <SFXLivingStringSynthAlloc+0x158>)
   1edfc:	7818      	ldrb	r0, [r3, #0]
   1edfe:	f1a0 0001 	sub.w	r0, r0, #1
   1ee02:	fab0 f080 	clz	r0, r0
   1ee06:	0940      	lsrs	r0, r0, #5
   1ee08:	f7fa fb42 	bl	19490 <setLED_A>
            setLED_B(voicePluck);
   1ee0c:	4b1b      	ldr	r3, [pc, #108]	; (1ee7c <SFXLivingStringSynthAlloc+0x15c>)
   1ee0e:	7818      	ldrb	r0, [r3, #0]
   1ee10:	f7fa fb4c 	bl	194ac <setLED_B>
            setLED_C(levModeStr);
   1ee14:	7830      	ldrb	r0, [r6, #0]
   1ee16:	f7fa fb57 	bl	194c8 <setLED_C>
            samplesPerMs = leaf.sampleRate / 1000.0f;
   1ee1a:	eddb 7a00 	vldr	s15, [fp]
   1ee1e:	ed9f 7a18 	vldr	s14, [pc, #96]	; 1ee80 <SFXLivingStringSynthAlloc+0x160>
   1ee22:	4b18      	ldr	r3, [pc, #96]	; (1ee84 <SFXLivingStringSynthAlloc+0x164>)
   1ee24:	ee67 7a87 	vmul.f32	s15, s15, s14
   1ee28:	edc3 7a00 	vstr	s15, [r3]
        }
   1ee2c:	ecbd 8b06 	vpop	{d8-d10}
   1ee30:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ee34:	020e2e68 	.word	0x020e2e68
   1ee38:	020e2e6c 	.word	0x020e2e6c
   1ee3c:	020f9cd0 	.word	0x020f9cd0
   1ee40:	020fabc0 	.word	0x020fabc0
   1ee44:	3c23d70a 	.word	0x3c23d70a
   1ee48:	00000000 	.word	0x00000000
   1ee4c:	460ca000 	.word	0x460ca000
   1ee50:	3e99999a 	.word	0x3e99999a
   1ee54:	447a0000 	.word	0x447a0000
   1ee58:	020f9de8 	.word	0x020f9de8
   1ee5c:	3e4ccccd 	.word	0x3e4ccccd
   1ee60:	43dc0000 	.word	0x43dc0000
   1ee64:	020fa204 	.word	0x020fa204
   1ee68:	428c0000 	.word	0x428c0000
   1ee6c:	44fa0000 	.word	0x44fa0000
   1ee70:	020fac34 	.word	0x020fac34
   1ee74:	020e520c 	.word	0x020e520c
   1ee78:	000627ac 	.word	0x000627ac
   1ee7c:	020e2ee0 	.word	0x020e2ee0
   1ee80:	3a83126f 	.word	0x3a83126f
   1ee84:	00062808 	.word	0x00062808
   1ee88:	020fbd68 	.word	0x020fbd68
   1ee8c:	020e4f38 	.word	0x020e4f38
   1ee90:	020f9ebc 	.word	0x020f9ebc
   1ee94:	020f9f84 	.word	0x020f9f84

0001ee98 <SFXLivingStringSynthFrame>:
        {
   1ee98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1ee9c:	4dc0      	ldr	r5, [pc, #768]	; (1f1a0 <SFXLivingStringSynthFrame+0x308>)
        {
   1ee9e:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1eea2:	7d2b      	ldrb	r3, [r5, #20]
        {
   1eea4:	b083      	sub	sp, #12
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1eea6:	2b01      	cmp	r3, #1
   1eea8:	d113      	bne.n	1eed2 <SFXLivingStringSynthFrame+0x3a>
                numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
   1eeaa:	4cbe      	ldr	r4, [pc, #760]	; (1f1a4 <SFXLivingStringSynthFrame+0x30c>)
                tSimplePoly_setNumVoices(&poly, numVoices);
   1eeac:	48be      	ldr	r0, [pc, #760]	; (1f1a8 <SFXLivingStringSynthFrame+0x310>)
                numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
   1eeae:	7822      	ldrb	r2, [r4, #0]
   1eeb0:	2a01      	cmp	r2, #1
   1eeb2:	bf98      	it	ls
   1eeb4:	2306      	movls	r3, #6
                tSimplePoly_setNumVoices(&poly, numVoices);
   1eeb6:	4619      	mov	r1, r3
                numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
   1eeb8:	7023      	strb	r3, [r4, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
   1eeba:	f00b fa95 	bl	2a3e8 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
   1eebe:	7820      	ldrb	r0, [r4, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1eec0:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
   1eec2:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1eec6:	752b      	strb	r3, [r5, #20]
                setLED_A(numVoices == 1);
   1eec8:	fab0 f080 	clz	r0, r0
   1eecc:	0940      	lsrs	r0, r0, #5
   1eece:	f7fa fadf 	bl	19490 <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1eed2:	7e2b      	ldrb	r3, [r5, #24]
   1eed4:	2b01      	cmp	r3, #1
   1eed6:	f000 814a 	beq.w	1f16e <SFXLivingStringSynthFrame+0x2d6>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1eeda:	7f2b      	ldrb	r3, [r5, #28]
   1eedc:	2b01      	cmp	r3, #1
   1eede:	f000 812d 	beq.w	1f13c <SFXLivingStringSynthFrame+0x2a4>
   1eee2:	f8df a318 	ldr.w	sl, [pc, #792]	; 1f1fc <SFXLivingStringSynthFrame+0x364>
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1eee6:	4db1      	ldr	r5, [pc, #708]	; (1f1ac <SFXLivingStringSynthFrame+0x314>)
   1eee8:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   1eeec:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1eef0:	eddf 6aaf 	vldr	s13, [pc, #700]	; 1f1b0 <SFXLivingStringSynthFrame+0x318>
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1eef4:	462b      	mov	r3, r5
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   1eef6:	ed95 6a03 	vldr	s12, [r5, #12]
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1eefa:	4cae      	ldr	r4, [pc, #696]	; (1f1b4 <SFXLivingStringSynthFrame+0x31c>)
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1eefc:	2600      	movs	r6, #0
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1eefe:	ecf3 7a01 	vldmia	r3!, {s15}
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   1ef02:	eea6 0a26 	vfma.f32	s0, s12, s13
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   1ef06:	eddf 8aac 	vldr	s17, [pc, #688]	; 1f1b8 <SFXLivingStringSynthFrame+0x320>
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1ef0a:	ee67 7a87 	vmul.f32	s15, s15, s14
            displayValues[1] = presetKnobValues[LivingStringSynth][1]; //lowpass
   1ef0e:	681a      	ldr	r2, [r3, #0]
            displayValues[2] = presetKnobValues[LivingStringSynth][2]; //decay
   1ef10:	68ab      	ldr	r3, [r5, #8]
            displayValues[1] = presetKnobValues[LivingStringSynth][1]; //lowpass
   1ef12:	6062      	str	r2, [r4, #4]
            displayValues[2] = presetKnobValues[LivingStringSynth][2]; //decay
   1ef14:	60a3      	str	r3, [r4, #8]
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1ef16:	edc4 7a00 	vstr	s15, [r4]
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   1ef1a:	f00a fd73 	bl	29a04 <faster_mtof>
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1ef1e:	eeb2 7a01 	vmov.f32	s14, #33	; 0x41080000  8.5
   1ef22:	edd5 6a06 	vldr	s13, [r5, #24]
   1ef26:	eef9 7a01 	vmov.f32	s15, #145	; 0xc0880000 -4.250
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   1ef2a:	ed95 4a04 	vldr	s8, [r5, #16]
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   1ef2e:	ed95 5a05 	vldr	s10, [r5, #20]
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   1ef32:	eeb7 4ac4 	vcvt.f64.f32	d4, s8
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   1ef36:	ed84 0a03 	vstr	s0, [r4, #12]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1ef3a:	eee6 7a87 	vfma.f32	s15, s13, s14
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   1ef3e:	ed9f 8a9f 	vldr	s16, [pc, #636]	; 1f1bc <SFXLivingStringSynthFrame+0x324>
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   1ef42:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
   1ef46:	f8df b2b8 	ldr.w	fp, [pc, #696]	; 1f200 <SFXLivingStringSynthFrame+0x368>
   1ef4a:	4f9d      	ldr	r7, [pc, #628]	; (1f1c0 <SFXLivingStringSynthFrame+0x328>)
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   1ef4c:	ed9f 3b8e 	vldr	d3, [pc, #568]	; 1f188 <SFXLivingStringSynthFrame+0x2f0>
   1ef50:	ed9f 6b8f 	vldr	d6, [pc, #572]	; 1f190 <SFXLivingStringSynthFrame+0x2f8>
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1ef54:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   1ef58:	ed9f 7b8f 	vldr	d7, [pc, #572]	; 1f198 <SFXLivingStringSynthFrame+0x300>
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   1ef5c:	eea4 6b03 	vfma.f64	d6, d4, d3
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   1ef60:	eea5 7b03 	vfma.f64	d7, d5, d3
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   1ef64:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
   1ef68:	ed84 6a04 	vstr	s12, [r4, #16]
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   1ef6c:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
   1ef70:	ed84 7a05 	vstr	s14, [r4, #20]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1ef74:	f00a fc28 	bl	297c8 <LEAF_tanh>
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1ef78:	4b92      	ldr	r3, [pc, #584]	; (1f1c4 <SFXLivingStringSynthFrame+0x32c>)
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1ef7a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1ef7e:	edd5 7a09 	vldr	s15, [r5, #36]	; 0x24
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1ef82:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1ef86:	edd3 5a00 	vldr	s11, [r3]
            displayValues[8] = presetKnobValues[LivingStringSynth][8];//feedback level
   1ef8a:	6a2a      	ldr	r2, [r5, #32]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1ef8c:	ee30 0a07 	vadd.f32	s0, s0, s14
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1ef90:	ee67 7aa5 	vmul.f32	s15, s15, s11
   1ef94:	4b8c      	ldr	r3, [pc, #560]	; (1f1c8 <SFXLivingStringSynthFrame+0x330>)
            displayValues[8] = presetKnobValues[LivingStringSynth][8];//feedback level
   1ef96:	6222      	str	r2, [r4, #32]
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1ef98:	eddf 6a8c 	vldr	s13, [pc, #560]	; 1f1cc <SFXLivingStringSynthFrame+0x334>
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1ef9c:	ee20 0a06 	vmul.f32	s0, s0, s12
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1efa0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            displayValues[7] = presetKnobValues[LivingStringSynth][7];//let Ring
   1efa4:	69e9      	ldr	r1, [r5, #28]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1efa6:	ed84 0a06 	vstr	s0, [r4, #24]
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1efaa:	ee17 2a90 	vmov	r2, s15
            displayValues[7] = presetKnobValues[LivingStringSynth][7];//let Ring
   1efae:	61e1      	str	r1, [r4, #28]
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1efb0:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1efb4:	edd3 7a00 	vldr	s15, [r3]
   1efb8:	ee67 7aa6 	vmul.f32	s15, s15, s13
   1efbc:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   1efc0:	eeb0 0a48 	vmov.f32	s0, s16
   1efc4:	edd4 7a02 	vldr	s15, [r4, #8]
   1efc8:	eb0a 0506 	add.w	r5, sl, r6
   1efcc:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1efd0:	4628      	mov	r0, r5
   1efd2:	f00b fdc5 	bl	2ab60 <tComplexLivingString_setDecay>
                tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   1efd6:	4628      	mov	r0, r5
   1efd8:	ed94 0a03 	vldr	s0, [r4, #12]
   1efdc:	f00b fda0 	bl	2ab20 <tComplexLivingString_setDampFreq>
                tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   1efe0:	4628      	mov	r0, r5
   1efe2:	ed94 0a04 	vldr	s0, [r4, #16]
   1efe6:	f00b fd6b 	bl	2aac0 <tComplexLivingString_setPickPos>
                tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   1efea:	4628      	mov	r0, r5
   1efec:	ed94 0a05 	vldr	s0, [r4, #20]
   1eff0:	f00b fd76 	bl	2aae0 <tComplexLivingString_setPrepPos>
                tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   1eff4:	4628      	mov	r0, r5
   1eff6:	ed94 0a06 	vldr	s0, [r4, #24]
   1effa:	f00b fd83 	bl	2ab04 <tComplexLivingString_setPrepIndex>
                tSlide_setDownSlide(&stringOutEnvs[i], displayValues[9] * samplesPerMs);
   1effe:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   1f002:	edd7 7a00 	vldr	s15, [r7]
   1f006:	eb0b 0006 	add.w	r0, fp, r6
   1f00a:	3604      	adds	r6, #4
   1f00c:	ee20 0a27 	vmul.f32	s0, s0, s15
   1f010:	f008 ff3a 	bl	27e88 <tSlide_setDownSlide>
            for (int i = 0; i < NUM_STRINGS; i++)
   1f014:	2e18      	cmp	r6, #24
   1f016:	d1d3      	bne.n	1efc0 <SFXLivingStringSynthFrame+0x128>
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   1f018:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1f01c:	ed94 7a01 	vldr	s14, [r4, #4]
   1f020:	eddf 7a6b 	vldr	s15, [pc, #428]	; 1f1d0 <SFXLivingStringSynthFrame+0x338>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f024:	2500      	movs	r5, #0
   1f026:	4b6b      	ldr	r3, [pc, #428]	; (1f1d4 <SFXLivingStringSynthFrame+0x33c>)
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   1f028:	eea7 0a27 	vfma.f32	s0, s14, s15
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f02c:	462e      	mov	r6, r5
   1f02e:	9301      	str	r3, [sp, #4]
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   1f030:	f00a fce8 	bl	29a04 <faster_mtof>
   1f034:	4868      	ldr	r0, [pc, #416]	; (1f1d8 <SFXLivingStringSynthFrame+0x340>)
   1f036:	f009 fca5 	bl	28984 <tVZFilter_setFreq>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f03a:	f8df 816c 	ldr.w	r8, [pc, #364]	; 1f1a8 <SFXLivingStringSynthFrame+0x310>
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   1f03e:	eddf 8a67 	vldr	s17, [pc, #412]	; 1f1dc <SFXLivingStringSynthFrame+0x344>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f042:	e01a      	b.n	1f07a <SFXLivingStringSynthFrame+0x1e2>
                    tComplexLivingString_setTargetLev(&theString[i],voiceOn * displayValues[8]);
   1f044:	ed94 0a08 	vldr	s0, [r4, #32]
   1f048:	ee28 0a00 	vmul.f32	s0, s16, s0
   1f04c:	f00b fd8c 	bl	2ab68 <tComplexLivingString_setTargetLev>
                if (voiceOn)
   1f050:	eeb5 8a40 	vcmp.f32	s16, #0.0
   1f054:	4f62      	ldr	r7, [pc, #392]	; (1f1e0 <SFXLivingStringSynthFrame+0x348>)
   1f056:	eb0b 0305 	add.w	r3, fp, r5
                    tSlide_setDest(&stringOutEnvs[i], 1.0f);
   1f05a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1f05e:	442f      	add	r7, r5
                if (voiceOn)
   1f060:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    tSlide_setDest(&stringOutEnvs[i], 1.0f);
   1f064:	4618      	mov	r0, r3
                if (voiceOn)
   1f066:	d05a      	beq.n	1f11e <SFXLivingStringSynthFrame+0x286>
                    tSlide_setDest(&stringOutEnvs[i], 1.0f);
   1f068:	f008 ff16 	bl	27e98 <tSlide_setDest>
                    tSlide_setDest(&stringInEnvs[i], 1.0f);
   1f06c:	4638      	mov	r0, r7
   1f06e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1f072:	f008 ff11 	bl	27e98 <tSlide_setDest>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f076:	3601      	adds	r6, #1
   1f078:	3504      	adds	r5, #4
   1f07a:	4640      	mov	r0, r8
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f07c:	fa5f f986 	uxtb.w	r9, r6
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f080:	f00b f9ba 	bl	2a3f8 <tSimplePoly_getNumVoices>
   1f084:	42b0      	cmp	r0, r6
   1f086:	eb0a 0705 	add.w	r7, sl, r5
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f08a:	4649      	mov	r1, r9
   1f08c:	4640      	mov	r0, r8
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f08e:	dd50      	ble.n	1f132 <SFXLivingStringSynthFrame+0x29a>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f090:	f00b f9ce 	bl	2a430 <tSimplePoly_getPitch>
   1f094:	ee07 0a90 	vmov	s15, r0
   1f098:	4a52      	ldr	r2, [pc, #328]	; (1f1e4 <SFXLivingStringSynthFrame+0x34c>)
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   1f09a:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f09e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f0a2:	4b51      	ldr	r3, [pc, #324]	; (1f1e8 <SFXLivingStringSynthFrame+0x350>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f0a4:	ed92 0a00 	vldr	s0, [r2]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f0a8:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f0aa:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1f0ae:	494f      	ldr	r1, [pc, #316]	; (1f1ec <SFXLivingStringSynthFrame+0x354>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f0b0:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1f0b4:	ee17 3a90 	vmov	r3, s15
   1f0b8:	1a9b      	subs	r3, r3, r2
   1f0ba:	4a4d      	ldr	r2, [pc, #308]	; (1f1f0 <SFXLivingStringSynthFrame+0x358>)
   1f0bc:	fb82 2003 	smull	r2, r0, r2, r3
   1f0c0:	17da      	asrs	r2, r3, #31
   1f0c2:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1f0c6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1f0ca:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1f0ce:	ee07 3a90 	vmov	s15, r3
   1f0d2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1f0d6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1f0da:	ee17 3a90 	vmov	r3, s15
   1f0de:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   1f0e2:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1f0e6:	ee37 0a00 	vadd.f32	s0, s14, s0
   1f0ea:	f00a fc07 	bl	298fc <LEAF_midiToFrequency>
   1f0ee:	9b01      	ldr	r3, [sp, #4]
                tComplexLivingString_setFreq(&theString[i], freq[i]);
   1f0f0:	4638      	mov	r0, r7
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1f0f2:	eca3 0a01 	vstmia	r3!, {s0}
   1f0f6:	9301      	str	r3, [sp, #4]
                tComplexLivingString_setFreq(&theString[i], freq[i]);
   1f0f8:	f00b fcca 	bl	2aa90 <tComplexLivingString_setFreq>
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   1f0fc:	4649      	mov	r1, r9
   1f0fe:	4640      	mov	r0, r8
   1f100:	f00b f9a2 	bl	2a448 <tSimplePoly_getVelocity>
                if (levModeStr)
   1f104:	4b3b      	ldr	r3, [pc, #236]	; (1f1f4 <SFXLivingStringSynthFrame+0x35c>)
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   1f106:	2800      	cmp	r0, #0
                    tComplexLivingString_setTargetLev(&theString[i],1.0f);
   1f108:	eeb0 0a48 	vmov.f32	s0, s16
                if (levModeStr)
   1f10c:	681b      	ldr	r3, [r3, #0]
                    tComplexLivingString_setTargetLev(&theString[i],1.0f);
   1f10e:	4638      	mov	r0, r7
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   1f110:	fe38 8a28 	vselgt.f32	s16, s16, s17
                if (levModeStr)
   1f114:	2b00      	cmp	r3, #0
   1f116:	d195      	bne.n	1f044 <SFXLivingStringSynthFrame+0x1ac>
                    tComplexLivingString_setTargetLev(&theString[i],1.0f);
   1f118:	f00b fd26 	bl	2ab68 <tComplexLivingString_setTargetLev>
   1f11c:	e798      	b.n	1f050 <SFXLivingStringSynthFrame+0x1b8>
                    tSlide_setDest(&stringOutEnvs[i], displayValues[7]);
   1f11e:	ed94 0a07 	vldr	s0, [r4, #28]
   1f122:	f008 feb9 	bl	27e98 <tSlide_setDest>
                    tSlide_setDest(&stringInEnvs[i], 0.0f);
   1f126:	eeb0 0a68 	vmov.f32	s0, s17
   1f12a:	4638      	mov	r0, r7
   1f12c:	f008 feb4 	bl	27e98 <tSlide_setDest>
   1f130:	e7a1      	b.n	1f076 <SFXLivingStringSynthFrame+0x1de>
        }
   1f132:	b003      	add	sp, #12
   1f134:	ecbd 8b02 	vpop	{d8}
   1f138:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                levModeStr = !levModeStr;
   1f13c:	4e2d      	ldr	r6, [pc, #180]	; (1f1f4 <SFXLivingStringSynthFrame+0x35c>)
   1f13e:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 1f1fc <SFXLivingStringSynthFrame+0x364>
   1f142:	6831      	ldr	r1, [r6, #0]
   1f144:	4654      	mov	r4, sl
   1f146:	f10a 0718 	add.w	r7, sl, #24
   1f14a:	fab1 f181 	clz	r1, r1
   1f14e:	0949      	lsrs	r1, r1, #5
   1f150:	6031      	str	r1, [r6, #0]
   1f152:	e000      	b.n	1f156 <SFXLivingStringSynthFrame+0x2be>
   1f154:	6831      	ldr	r1, [r6, #0]
                    tComplexLivingString_setLevMode(&theString[i], levModeStr);
   1f156:	4620      	mov	r0, r4
   1f158:	3404      	adds	r4, #4
   1f15a:	f00b fd19 	bl	2ab90 <tComplexLivingString_setLevMode>
                for (int i = 0; i < NUM_STRINGS; i++)
   1f15e:	42a7      	cmp	r7, r4
   1f160:	d1f8      	bne.n	1f154 <SFXLivingStringSynthFrame+0x2bc>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1f162:	2300      	movs	r3, #0
                setLED_C(levModeStr);
   1f164:	7830      	ldrb	r0, [r6, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   1f166:	772b      	strb	r3, [r5, #28]
                setLED_C(levModeStr);
   1f168:	f7fa f9ae 	bl	194c8 <setLED_C>
   1f16c:	e6bb      	b.n	1eee6 <SFXLivingStringSynthFrame+0x4e>
                voicePluck = !voicePluck;
   1f16e:	4a22      	ldr	r2, [pc, #136]	; (1f1f8 <SFXLivingStringSynthFrame+0x360>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1f170:	2100      	movs	r1, #0
                voicePluck = !voicePluck;
   1f172:	6813      	ldr	r3, [r2, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1f174:	7629      	strb	r1, [r5, #24]
                voicePluck = !voicePluck;
   1f176:	fab3 f383 	clz	r3, r3
   1f17a:	095b      	lsrs	r3, r3, #5
                setLED_B(voicePluck);
   1f17c:	4618      	mov	r0, r3
                voicePluck = !voicePluck;
   1f17e:	6013      	str	r3, [r2, #0]
                setLED_B(voicePluck);
   1f180:	f7fa f994 	bl	194ac <setLED_B>
   1f184:	e6a9      	b.n	1eeda <SFXLivingStringSynthFrame+0x42>
   1f186:	bf00      	nop
   1f188:	c28f5c29 	.word	0xc28f5c29
   1f18c:	3fdc28f5 	.word	0x3fdc28f5
   1f190:	00000000 	.word	0x00000000
   1f194:	3fe0a3d7 	.word	0x3fe0a3d7
   1f198:	40000000 	.word	0x40000000
   1f19c:	3fa47ae1 	.word	0x3fa47ae1
   1f1a0:	020fafac 	.word	0x020fafac
   1f1a4:	000627ac 	.word	0x000627ac
   1f1a8:	020f9de8 	.word	0x020f9de8
   1f1ac:	020e5bb4 	.word	0x020e5bb4
   1f1b0:	42ee0000 	.word	0x42ee0000
   1f1b4:	020fb05c 	.word	0x020fb05c
   1f1b8:	3ca3d70a 	.word	0x3ca3d70a
   1f1bc:	3f7ae148 	.word	0x3f7ae148
   1f1c0:	00062808 	.word	0x00062808
   1f1c4:	00062794 	.word	0x00062794
   1f1c8:	020f990c 	.word	0x020f990c
   1f1cc:	46000000 	.word	0x46000000
   1f1d0:	42c80000 	.word	0x42c80000
   1f1d4:	020e5d04 	.word	0x020e5d04
   1f1d8:	020fac34 	.word	0x020fac34
   1f1dc:	00000000 	.word	0x00000000
   1f1e0:	020f9f84 	.word	0x020f9f84
   1f1e4:	020e2ea0 	.word	0x020e2ea0
   1f1e8:	020e2f18 	.word	0x020e2f18
   1f1ec:	020e2ee4 	.word	0x020e2ee4
   1f1f0:	2aaaaaab 	.word	0x2aaaaaab
   1f1f4:	020e2e6c 	.word	0x020e2e6c
   1f1f8:	020e2ee0 	.word	0x020e2ee0
   1f1fc:	020e4f38 	.word	0x020e4f38
   1f200:	020f9ebc 	.word	0x020f9ebc

0001f204 <SFXLivingStringSynthTick>:
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   1f204:	4b27      	ldr	r3, [pc, #156]	; (1f2a4 <SFXLivingStringSynthTick+0xa0>)
        {
   1f206:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1f20a:	ed2d 8b06 	vpush	{d8-d10}
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   1f20e:	ed93 8a00 	vldr	s16, [r3]
        {
   1f212:	4606      	mov	r6, r0
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   1f214:	4824      	ldr	r0, [pc, #144]	; (1f2a8 <SFXLivingStringSynthTick+0xa4>)
            pluck = tVZFilter_tick(&pluckFilt, pluck);
   1f216:	2400      	movs	r4, #0
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   1f218:	f00b fa70 	bl	2a6fc <tNoise_tick>
            pluck = tVZFilter_tick(&pluckFilt, pluck);
   1f21c:	4823      	ldr	r0, [pc, #140]	; (1f2ac <SFXLivingStringSynthTick+0xa8>)
   1f21e:	ee28 0a00 	vmul.f32	s0, s16, s0
            float sample = 0.0f;
   1f222:	ed9f 9a23 	vldr	s18, [pc, #140]	; 1f2b0 <SFXLivingStringSynthTick+0xac>
            pluck = tVZFilter_tick(&pluckFilt, pluck);
   1f226:	f009 fb3d 	bl	288a4 <tVZFilter_tick>
   1f22a:	eeb0 aa40 	vmov.f32	s20, s0
   1f22e:	f8df a090 	ldr.w	sl, [pc, #144]	; 1f2c0 <SFXLivingStringSynthTick+0xbc>
   1f232:	f8df 9090 	ldr.w	r9, [pc, #144]	; 1f2c4 <SFXLivingStringSynthTick+0xc0>
   1f236:	f8df 8090 	ldr.w	r8, [pc, #144]	; 1f2c8 <SFXLivingStringSynthTick+0xc4>
   1f23a:	4f1e      	ldr	r7, [pc, #120]	; (1f2b4 <SFXLivingStringSynthTick+0xb0>)
                inputSample = (input[1] * voicePluck) + (pluck * tADSR4_tick(&pluckEnvs[i]));
   1f23c:	edda 7a00 	vldr	s15, [sl]
   1f240:	eb09 0004 	add.w	r0, r9, r4
   1f244:	edd6 9a01 	vldr	s19, [r6, #4]
   1f248:	eb08 0504 	add.w	r5, r8, r4
   1f24c:	eef8 8ae7 	vcvt.f32.s32	s17, s15
   1f250:	f008 fa9e 	bl	27790 <tADSR4_tick>
   1f254:	ee20 8a0a 	vmul.f32	s16, s0, s20
                sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
   1f258:	4628      	mov	r0, r5
   1f25a:	f008 fe21 	bl	27ea0 <tSlide_tickNoInput>
   1f25e:	1938      	adds	r0, r7, r4
   1f260:	3404      	adds	r4, #4
                inputSample = (input[1] * voicePluck) + (pluck * tADSR4_tick(&pluckEnvs[i]));
   1f262:	eea9 8aa8 	vfma.f32	s16, s19, s17
                sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
   1f266:	ee20 0a08 	vmul.f32	s0, s0, s16
   1f26a:	f00b fca7 	bl	2abbc <tComplexLivingString_tick>
   1f26e:	4628      	mov	r0, r5
   1f270:	eeb0 8a40 	vmov.f32	s16, s0
   1f274:	f008 fe14 	bl	27ea0 <tSlide_tickNoInput>
            for (int i = 0; i < NUM_STRINGS; i++)
   1f278:	2c18      	cmp	r4, #24
                sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
   1f27a:	eea8 9a00 	vfma.f32	s18, s16, s0
            for (int i = 0; i < NUM_STRINGS; i++)
   1f27e:	d1dd      	bne.n	1f23c <SFXLivingStringSynthTick+0x38>
            sample *= 0.1625f;
   1f280:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 1f2b8 <SFXLivingStringSynthTick+0xb4>
            sample = LEAF_tanh(sample) * 0.98f;
   1f284:	ee29 0a00 	vmul.f32	s0, s18, s0
   1f288:	f00a fa9e 	bl	297c8 <LEAF_tanh>
   1f28c:	eddf 7a0b 	vldr	s15, [pc, #44]	; 1f2bc <SFXLivingStringSynthTick+0xb8>
   1f290:	ee20 0a27 	vmul.f32	s0, s0, s15
            input[0] = sample;
   1f294:	ed86 0a00 	vstr	s0, [r6]
            input[1] = sample;
   1f298:	ed86 0a01 	vstr	s0, [r6, #4]
        }
   1f29c:	ecbd 8b06 	vpop	{d8-d10}
   1f2a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1f2a4:	020fb05c 	.word	0x020fb05c
   1f2a8:	020e520c 	.word	0x020e520c
   1f2ac:	020fac34 	.word	0x020fac34
   1f2b0:	00000000 	.word	0x00000000
   1f2b4:	020e4f38 	.word	0x020e4f38
   1f2b8:	3e266666 	.word	0x3e266666
   1f2bc:	3f7ae148 	.word	0x3f7ae148
   1f2c0:	020e2ee0 	.word	0x020e2ee0
   1f2c4:	020f9cd0 	.word	0x020f9cd0
   1f2c8:	020f9ebc 	.word	0x020f9ebc

0001f2cc <SFXLivingStringSynthFree>:
        {
   1f2cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f2d0:	2400      	movs	r4, #0
   1f2d2:	f8df 804c 	ldr.w	r8, [pc, #76]	; 1f320 <SFXLivingStringSynthFree+0x54>
   1f2d6:	4f0d      	ldr	r7, [pc, #52]	; (1f30c <SFXLivingStringSynthFree+0x40>)
   1f2d8:	4e0d      	ldr	r6, [pc, #52]	; (1f310 <SFXLivingStringSynthFree+0x44>)
   1f2da:	4d0e      	ldr	r5, [pc, #56]	; (1f314 <SFXLivingStringSynthFree+0x48>)
                tComplexLivingString_free(&theString[i]);
   1f2dc:	eb08 0004 	add.w	r0, r8, r4
   1f2e0:	f00b fb8a 	bl	2a9f8 <tComplexLivingString_free>
                tSlide_free(&stringInEnvs[i]);
   1f2e4:	1938      	adds	r0, r7, r4
   1f2e6:	f008 fdcb 	bl	27e80 <tSlide_free>
                tSlide_free(&stringOutEnvs[i]);
   1f2ea:	1930      	adds	r0, r6, r4
   1f2ec:	f008 fdc8 	bl	27e80 <tSlide_free>
                tADSR4_free(&pluckEnvs[i]);
   1f2f0:	1928      	adds	r0, r5, r4
   1f2f2:	3404      	adds	r4, #4
   1f2f4:	f008 f9ea 	bl	276cc <tADSR4_free>
            for (int i = 0; i < NUM_STRINGS; i++)
   1f2f8:	2c18      	cmp	r4, #24
   1f2fa:	d1ef      	bne.n	1f2dc <SFXLivingStringSynthFree+0x10>
            tVZFilter_free(&pluckFilt);
   1f2fc:	4806      	ldr	r0, [pc, #24]	; (1f318 <SFXLivingStringSynthFree+0x4c>)
   1f2fe:	f009 fac3 	bl	28888 <tVZFilter_free>
            tNoise_free(&stringPluckNoise);
   1f302:	4806      	ldr	r0, [pc, #24]	; (1f31c <SFXLivingStringSynthFree+0x50>)
        }
   1f304:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            tNoise_free(&stringPluckNoise);
   1f308:	f00b b9f4 	b.w	2a6f4 <tNoise_free>
   1f30c:	020f9f84 	.word	0x020f9f84
   1f310:	020f9ebc 	.word	0x020f9ebc
   1f314:	020f9cd0 	.word	0x020f9cd0
   1f318:	020fac34 	.word	0x020fac34
   1f31c:	020e520c 	.word	0x020e520c
   1f320:	020e4f38 	.word	0x020e4f38

0001f324 <SFXClassicSynthAlloc>:
            tSimplePoly_setNumVoices(&poly, numVoices);
   1f324:	4aa3      	ldr	r2, [pc, #652]	; (1f5b4 <SFXClassicSynthAlloc+0x290>)
   1f326:	48a4      	ldr	r0, [pc, #656]	; (1f5b8 <SFXClassicSynthAlloc+0x294>)
        {
   1f328:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            leaf.clearOnAllocation = 1;
   1f32c:	2301      	movs	r3, #1
   1f32e:	f8df a2f0 	ldr.w	sl, [pc, #752]	; 1f620 <SFXClassicSynthAlloc+0x2fc>
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   1f332:	f04f 0800 	mov.w	r8, #0
            leaf.clearOnAllocation = 1;
   1f336:	f8ca 3014 	str.w	r3, [sl, #20]
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   1f33a:	4644      	mov	r4, r8
        {
   1f33c:	ed2d 8b08 	vpush	{d8-d11}
            tSimplePoly_setNumVoices(&poly, numVoices);
   1f340:	7811      	ldrb	r1, [r2, #0]
   1f342:	f00b f851 	bl	2a3e8 <tSimplePoly_setNumVoices>
            displayValues[0] = knobs[0]; //synth volume
   1f346:	4b9d      	ldr	r3, [pc, #628]	; (1f5bc <SFXClassicSynthAlloc+0x298>)
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f348:	4a9d      	ldr	r2, [pc, #628]	; (1f5c0 <SFXClassicSynthAlloc+0x29c>)
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f34a:	eef0 4a00 	vmov.f32	s9, #0	; 0x40000000  2.0
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f34e:	ed93 5a05 	vldr	s10, [r3, #20]
            displayValues[0] = knobs[0]; //synth volume
   1f352:	461f      	mov	r7, r3
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f354:	edd2 7a00 	vldr	s15, [r2]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f358:	edd3 5a06 	vldr	s11, [r3, #24]
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f35c:	ed93 6a08 	vldr	s12, [r3, #32]
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f360:	ee27 5a85 	vmul.f32	s10, s15, s10
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f364:	edd3 6a0a 	vldr	s13, [r3, #40]	; 0x28
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f368:	ee67 5aa5 	vmul.f32	s11, s15, s11
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f36c:	ed93 7a0b 	vldr	s14, [r3, #44]	; 0x2c
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f370:	ee27 6a86 	vmul.f32	s12, s15, s12
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f374:	ee67 6aa6 	vmul.f32	s13, s15, s13
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f378:	eddf 8a92 	vldr	s17, [pc, #584]	; 1f5c4 <SFXClassicSynthAlloc+0x2a0>
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f37c:	ee27 7a87 	vmul.f32	s14, s15, s14
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f380:	4a91      	ldr	r2, [pc, #580]	; (1f5c8 <SFXClassicSynthAlloc+0x2a4>)
   1f382:	eebd 5ac5 	vcvt.s32.f32	s10, s10
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f386:	ed93 4a04 	vldr	s8, [r3, #16]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f38a:	eefd 5ae5 	vcvt.s32.f32	s11, s11
            displayValues[0] = knobs[0]; //synth volume
   1f38e:	f857 eb04 	ldr.w	lr, [r7], #4
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f392:	eebd 6ac6 	vcvt.s32.f32	s12, s12
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   1f396:	ed9f aa8d 	vldr	s20, [pc, #564]	; 1f5cc <SFXClassicSynthAlloc+0x2a8>
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f39a:	eefd 6ae6 	vcvt.s32.f32	s13, s13
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f39e:	ee15 ca10 	vmov	ip, s10
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f3a2:	eebd 7ac7 	vcvt.s32.f32	s14, s14
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f3a6:	ee15 6a90 	vmov	r6, s11
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f3aa:	eef0 3a68 	vmov.f32	s7, s17
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f3ae:	ee16 5a10 	vmov	r5, s12
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3b2:	ee16 0a90 	vmov	r0, s13
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3b6:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f3ba:	ee17 1a10 	vmov	r1, s14
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f3be:	eb02 0686 	add.w	r6, r2, r6, lsl #2
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f3c2:	eb02 0585 	add.w	r5, r2, r5, lsl #2
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f3c6:	eee4 3a24 	vfma.f32	s7, s8, s9
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3ca:	eb02 0080 	add.w	r0, r2, r0, lsl #2
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   1f3ce:	edd7 4a00 	vldr	s9, [r7]
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f3d2:	eb02 0181 	add.w	r1, r2, r1, lsl #2
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   1f3d6:	ed9f 7a7e 	vldr	s14, [pc, #504]	; 1f5d0 <SFXClassicSynthAlloc+0x2ac>
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3da:	ed9f 6a7e 	vldr	s12, [pc, #504]	; 1f5d4 <SFXClassicSynthAlloc+0x2b0>
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f3de:	edd5 5a00 	vldr	s11, [r5]
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   1f3e2:	ee64 4a87 	vmul.f32	s9, s9, s14
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3e6:	ed9c 4a00 	vldr	s8, [ip]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f3ea:	ed96 5a00 	vldr	s10, [r6]
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f3ee:	ee65 5a86 	vmul.f32	s11, s11, s12
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3f2:	edd0 6a00 	vldr	s13, [r0]
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3f6:	ee24 4a06 	vmul.f32	s8, s8, s12
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f3fa:	ed91 7a00 	vldr	s14, [r1]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f3fe:	ee25 5a06 	vmul.f32	s10, s10, s12
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f402:	ee66 6a86 	vmul.f32	s13, s13, s12
            displayValues[0] = knobs[0]; //synth volume
   1f406:	4d74      	ldr	r5, [pc, #464]	; (1f5d8 <SFXClassicSynthAlloc+0x2b4>)
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f408:	ee27 7a06 	vmul.f32	s14, s14, s12
            displayValues[7] = knobs[7]; //sus
   1f40c:	69de      	ldr	r6, [r3, #28]
            displayValues[12] = knobs[12]; //sus
   1f40e:	6b19      	ldr	r1, [r3, #48]	; 0x30
            displayValues[2] = knobs[2]; //keyfollow filter cutoff
   1f410:	f8d3 c008 	ldr.w	ip, [r3, #8]
            displayValues[3] = knobs[3]; //detune
   1f414:	68df      	ldr	r7, [r3, #12]
            displayValues[9] = knobs[9]; //leak
   1f416:	6a58      	ldr	r0, [r3, #36]	; 0x24
            displayValues[7] = knobs[7]; //sus
   1f418:	61ee      	str	r6, [r5, #28]
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f41a:	edc5 6a0a 	vstr	s13, [r5, #40]	; 0x28
            displayValues[12] = knobs[12]; //sus
   1f41e:	6329      	str	r1, [r5, #48]	; 0x30
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f420:	ed85 4a05 	vstr	s8, [r5, #20]
            displayValues[0] = knobs[0]; //synth volume
   1f424:	f8c5 e000 	str.w	lr, [r5]
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   1f428:	edc5 4a01 	vstr	s9, [r5, #4]
            displayValues[2] = knobs[2]; //keyfollow filter cutoff
   1f42c:	f8c5 c008 	str.w	ip, [r5, #8]
            displayValues[3] = knobs[3]; //detune
   1f430:	60ef      	str	r7, [r5, #12]
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f432:	edc5 3a04 	vstr	s7, [r5, #16]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f436:	ed85 5a06 	vstr	s10, [r5, #24]
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f43a:	edc5 5a08 	vstr	s11, [r5, #32]
            displayValues[9] = knobs[9]; //leak
   1f43e:	6268      	str	r0, [r5, #36]	; 0x24
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f440:	ed85 7a0b 	vstr	s14, [r5, #44]	; 0x2c
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f444:	ed93 7a0d 	vldr	s14, [r3, #52]	; 0x34
            displayValues[14] = knobs[14]; //leak
   1f448:	6b99      	ldr	r1, [r3, #56]	; 0x38
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f44a:	ee67 7a87 	vmul.f32	s15, s15, s14
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   1f44e:	ed93 7a0f 	vldr	s14, [r3, #60]	; 0x3c
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   1f452:	6c1b      	ldr	r3, [r3, #64]	; 0x40
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   1f454:	eddf 6a61 	vldr	s13, [pc, #388]	; 1f5dc <SFXClassicSynthAlloc+0x2b8>
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f458:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   1f45c:	642b      	str	r3, [r5, #64]	; 0x40
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   1f45e:	ee27 7a26 	vmul.f32	s14, s14, s13
                    tSawtooth_initToPool(&osc[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   1f462:	4e5f      	ldr	r6, [pc, #380]	; (1f5e0 <SFXClassicSynthAlloc+0x2bc>)
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   1f464:	eddf 9a5f 	vldr	s19, [pc, #380]	; 1f5e4 <SFXClassicSynthAlloc+0x2c0>
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f468:	ee17 3a90 	vmov	r3, s15
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
   1f46c:	ed9f 9a5e 	vldr	s18, [pc, #376]	; 1f5e8 <SFXClassicSynthAlloc+0x2c4>
            displayValues[14] = knobs[14]; //leak
   1f470:	63a9      	str	r1, [r5, #56]	; 0x38
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f472:	eb02 0283 	add.w	r2, r2, r3, lsl #2
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   1f476:	ed85 7a0f 	vstr	s14, [r5, #60]	; 0x3c
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f47a:	edd2 7a00 	vldr	s15, [r2]
   1f47e:	ee27 6a86 	vmul.f32	s12, s15, s12
   1f482:	ed85 6a0d 	vstr	s12, [r5, #52]	; 0x34
   1f486:	4b59      	ldr	r3, [pc, #356]	; (1f5ec <SFXClassicSynthAlloc+0x2c8>)
   1f488:	f104 0b0c 	add.w	fp, r4, #12
   1f48c:	eb03 0904 	add.w	r9, r3, r4
                    tSawtooth_initToPool(&osc[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   1f490:	4b57      	ldr	r3, [pc, #348]	; (1f5f0 <SFXClassicSynthAlloc+0x2cc>)
   1f492:	4631      	mov	r1, r6
   1f494:	1918      	adds	r0, r3, r4
   1f496:	f00b f865 	bl	2a564 <tSawtooth_initToPool>
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   1f49a:	f8da 3010 	ldr.w	r3, [sl, #16]
   1f49e:	4798      	blx	r3
   1f4a0:	eef0 7a69 	vmov.f32	s15, s19
   1f4a4:	4b53      	ldr	r3, [pc, #332]	; (1f5f4 <SFXClassicSynthAlloc+0x2d0>)
                    tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   1f4a6:	4631      	mov	r1, r6
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   1f4a8:	eee0 7a0a 	vfma.f32	s15, s0, s20
   1f4ac:	191f      	adds	r7, r3, r4
   1f4ae:	3404      	adds	r4, #4
                    tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   1f4b0:	4638      	mov	r0, r7
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   1f4b2:	ece9 7a01 	vstmia	r9!, {s15}
                    tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   1f4b6:	f006 feed 	bl	26294 <tRosenbergGlottalPulse_initToPool>
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
   1f4ba:	eeb0 0a49 	vmov.f32	s0, s18
   1f4be:	4638      	mov	r0, r7
   1f4c0:	f006 ffe6 	bl	26490 <tRosenbergGlottalPulse_setOpenLength>
                    tRosenbergGlottalPulse_setPulseLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.4f);
   1f4c4:	eeb0 0a68 	vmov.f32	s0, s17
   1f4c8:	4638      	mov	r0, r7
   1f4ca:	f006 ffef 	bl	264ac <tRosenbergGlottalPulse_setPulseLength>
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   1f4ce:	455c      	cmp	r4, fp
   1f4d0:	d1de      	bne.n	1f490 <SFXClassicSynthAlloc+0x16c>
   1f4d2:	4b49      	ldr	r3, [pc, #292]	; (1f5f8 <SFXClassicSynthAlloc+0x2d4>)
                tEfficientSVF_initToPool(&synthLP[i], SVFTypeLowpass, 6000.0f, displayValues[4], &smallPool);
   1f4d4:	f241 7270 	movw	r2, #6000	; 0x1770
   1f4d8:	4848      	ldr	r0, [pc, #288]	; (1f5fc <SFXClassicSynthAlloc+0x2d8>)
   1f4da:	2101      	movs	r1, #1
   1f4dc:	eb03 0908 	add.w	r9, r3, r8
   1f4e0:	ed95 0a04 	vldr	s0, [r5, #16]
   1f4e4:	4440      	add	r0, r8
   1f4e6:	4633      	mov	r3, r6
   1f4e8:	f008 feaa 	bl	28240 <tEfficientSVF_initToPool>
                tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   1f4ec:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
                tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1f4f0:	4633      	mov	r3, r6
   1f4f2:	f44f 7200 	mov.w	r2, #512	; 0x200
   1f4f6:	4942      	ldr	r1, [pc, #264]	; (1f600 <SFXClassicSynthAlloc+0x2dc>)
   1f4f8:	4648      	mov	r0, r9
   1f4fa:	edd5 1a08 	vldr	s3, [r5, #32]
   1f4fe:	ed95 1a07 	vldr	s2, [r5, #28]
   1f502:	edd5 0a06 	vldr	s1, [r5, #24]
   1f506:	ed95 0a05 	vldr	s0, [r5, #20]
   1f50a:	f008 f885 	bl	27618 <tADSR4_initToPool>
                tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   1f50e:	eddf aa3d 	vldr	s21, [pc, #244]	; 1f604 <SFXClassicSynthAlloc+0x2e0>
   1f512:	edd5 7a09 	vldr	s15, [r5, #36]	; 0x24
   1f516:	4648      	mov	r0, r9
   1f518:	4f3b      	ldr	r7, [pc, #236]	; (1f608 <SFXClassicSynthAlloc+0x2e4>)
   1f51a:	eeb0 0a6a 	vmov.f32	s0, s21
   1f51e:	ee78 7a67 	vsub.f32	s15, s16, s15
   1f522:	ed9f ba3a 	vldr	s22, [pc, #232]	; 1f60c <SFXClassicSynthAlloc+0x2e8>
   1f526:	4447      	add	r7, r8
   1f528:	f108 0804 	add.w	r8, r8, #4
   1f52c:	eea7 0a8b 	vfma.f32	s0, s15, s22
   1f530:	f008 f910 	bl	27754 <tADSR4_setLeakFactor>
                tADSR4_initToPool(&polyFiltEnvs[i], displayValues[10], displayValues[11], displayValues[12], displayValues[13], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1f534:	4638      	mov	r0, r7
   1f536:	4633      	mov	r3, r6
   1f538:	f44f 7200 	mov.w	r2, #512	; 0x200
   1f53c:	4930      	ldr	r1, [pc, #192]	; (1f600 <SFXClassicSynthAlloc+0x2dc>)
   1f53e:	edd5 1a0d 	vldr	s3, [r5, #52]	; 0x34
   1f542:	ed95 1a0c 	vldr	s2, [r5, #48]	; 0x30
   1f546:	edd5 0a0b 	vldr	s1, [r5, #44]	; 0x2c
   1f54a:	ed95 0a0a 	vldr	s0, [r5, #40]	; 0x28
   1f54e:	f008 f863 	bl	27618 <tADSR4_initToPool>
                tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   1f552:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
   1f556:	eeb0 0a6a 	vmov.f32	s0, s21
   1f55a:	4638      	mov	r0, r7
   1f55c:	ee38 8a67 	vsub.f32	s16, s16, s15
   1f560:	eea8 0a0b 	vfma.f32	s0, s16, s22
   1f564:	f008 f8f6 	bl	27754 <tADSR4_setLeakFactor>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
   1f568:	f1b8 0f20 	cmp.w	r8, #32
   1f56c:	d18b      	bne.n	1f486 <SFXClassicSynthAlloc+0x162>
            tCycle_initToPool(&pwmLFO1, &smallPool);
   1f56e:	491c      	ldr	r1, [pc, #112]	; (1f5e0 <SFXClassicSynthAlloc+0x2bc>)
   1f570:	4827      	ldr	r0, [pc, #156]	; (1f610 <SFXClassicSynthAlloc+0x2ec>)
   1f572:	f00a ff79 	bl	2a468 <tCycle_initToPool>
            tCycle_initToPool(&pwmLFO2, &smallPool);
   1f576:	491a      	ldr	r1, [pc, #104]	; (1f5e0 <SFXClassicSynthAlloc+0x2bc>)
   1f578:	4826      	ldr	r0, [pc, #152]	; (1f614 <SFXClassicSynthAlloc+0x2f0>)
   1f57a:	f00a ff75 	bl	2a468 <tCycle_initToPool>
            tCycle_setFreq(&pwmLFO1, 63.0f);
   1f57e:	ed9f 0a26 	vldr	s0, [pc, #152]	; 1f618 <SFXClassicSynthAlloc+0x2f4>
   1f582:	4823      	ldr	r0, [pc, #140]	; (1f610 <SFXClassicSynthAlloc+0x2ec>)
   1f584:	f00a ff82 	bl	2a48c <tCycle_setFreq>
            tCycle_setFreq(&pwmLFO2, 72.11f);
   1f588:	ed9f 0a24 	vldr	s0, [pc, #144]	; 1f61c <SFXClassicSynthAlloc+0x2f8>
   1f58c:	4821      	ldr	r0, [pc, #132]	; (1f614 <SFXClassicSynthAlloc+0x2f0>)
   1f58e:	f00a ff7d 	bl	2a48c <tCycle_setFreq>
            setLED_A(numVoices == 1);
   1f592:	4b08      	ldr	r3, [pc, #32]	; (1f5b4 <SFXClassicSynthAlloc+0x290>)
   1f594:	7818      	ldrb	r0, [r3, #0]
   1f596:	f1a0 0001 	sub.w	r0, r0, #1
   1f59a:	fab0 f080 	clz	r0, r0
   1f59e:	0940      	lsrs	r0, r0, #5
   1f5a0:	f7f9 ff76 	bl	19490 <setLED_A>
            leaf.clearOnAllocation = 0;
   1f5a4:	2300      	movs	r3, #0
        }
   1f5a6:	ecbd 8b08 	vpop	{d8-d11}
            leaf.clearOnAllocation = 0;
   1f5aa:	f8ca 3014 	str.w	r3, [sl, #20]
        }
   1f5ae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1f5b2:	bf00      	nop
   1f5b4:	000627ac 	.word	0x000627ac
   1f5b8:	020f9de8 	.word	0x020f9de8
   1f5bc:	020e5c18 	.word	0x020e5c18
   1f5c0:	00062794 	.word	0x00062794
   1f5c4:	3ecccccd 	.word	0x3ecccccd
   1f5c8:	020f990c 	.word	0x020f990c
   1f5cc:	3cd844d0 	.word	0x3cd844d0
   1f5d0:	45800000 	.word	0x45800000
   1f5d4:	46000000 	.word	0x46000000
   1f5d8:	020fb05c 	.word	0x020fb05c
   1f5dc:	457ff000 	.word	0x457ff000
   1f5e0:	020fabc0 	.word	0x020fabc0
   1f5e4:	bc5844d0 	.word	0xbc5844d0
   1f5e8:	3e99999a 	.word	0x3e99999a
   1f5ec:	020fabcc 	.word	0x020fabcc
   1f5f0:	020f9ba4 	.word	0x020f9ba4
   1f5f4:	020e5110 	.word	0x020e5110
   1f5f8:	020f9f64 	.word	0x020f9f64
   1f5fc:	020e5ce0 	.word	0x020e5ce0
   1f600:	020fa204 	.word	0x020fa204
   1f604:	3f7ffcb9 	.word	0x3f7ffcb9
   1f608:	020e4810 	.word	0x020e4810
   1f60c:	3851b717 	.word	0x3851b717
   1f610:	020f9f54 	.word	0x020f9f54
   1f614:	020fa038 	.word	0x020fa038
   1f618:	427c0000 	.word	0x427c0000
   1f61c:	42903852 	.word	0x42903852
   1f620:	020fbd68 	.word	0x020fbd68

0001f624 <SFXClassicSynthFrame>:
        {
   1f624:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1f628:	4cbd      	ldr	r4, [pc, #756]	; (1f920 <SFXClassicSynthFrame+0x2fc>)
        {
   1f62a:	ed2d 8b08 	vpush	{d8-d11}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1f62e:	7d23      	ldrb	r3, [r4, #20]
        {
   1f630:	b085      	sub	sp, #20
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1f632:	2b01      	cmp	r3, #1
   1f634:	f000 80f5 	beq.w	1f822 <SFXClassicSynthFrame+0x1fe>
   1f638:	4bba      	ldr	r3, [pc, #744]	; (1f924 <SFXClassicSynthFrame+0x300>)
   1f63a:	9302      	str	r3, [sp, #8]
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1f63c:	7e23      	ldrb	r3, [r4, #24]
   1f63e:	2b01      	cmp	r3, #1
   1f640:	f000 8108 	beq.w	1f854 <SFXClassicSynthFrame+0x230>
            if (writeKnobFlag != -1)
   1f644:	4bb8      	ldr	r3, [pc, #736]	; (1f928 <SFXClassicSynthFrame+0x304>)
   1f646:	f993 2000 	ldrsb.w	r2, [r3]
   1f64a:	1c53      	adds	r3, r2, #1
   1f64c:	d01d      	beq.n	1f68a <SFXClassicSynthFrame+0x66>
                switch(writeKnobFlag + (knobPage * KNOB_PAGE_SIZE))
   1f64e:	49b7      	ldr	r1, [pc, #732]	; (1f92c <SFXClassicSynthFrame+0x308>)
   1f650:	2305      	movs	r3, #5
   1f652:	7809      	ldrb	r1, [r1, #0]
   1f654:	fb13 2301 	smlabb	r3, r3, r1, r2
   1f658:	2b10      	cmp	r3, #16
   1f65a:	d816      	bhi.n	1f68a <SFXClassicSynthFrame+0x66>
   1f65c:	e8df f013 	tbh	[pc, r3, lsl #1]
   1f660:	02f70011 	.word	0x02f70011
   1f664:	02ed02f2 	.word	0x02ed02f2
   1f668:	02a302ce 	.word	0x02a302ce
   1f66c:	025f0278 	.word	0x025f0278
   1f670:	020f0234 	.word	0x020f0234
   1f674:	01b901e4 	.word	0x01b901e4
   1f678:	013501a0 	.word	0x013501a0
   1f67c:	01050110 	.word	0x01050110
   1f680:	0100      	.short	0x0100
                        displayValues[0] = knobs[0]; //synth volume
   1f682:	4bab      	ldr	r3, [pc, #684]	; (1f930 <SFXClassicSynthFrame+0x30c>)
   1f684:	4eab      	ldr	r6, [pc, #684]	; (1f934 <SFXClassicSynthFrame+0x310>)
   1f686:	681b      	ldr	r3, [r3, #0]
   1f688:	6033      	str	r3, [r6, #0]
            float tempLFO1 = (tCycle_tick(&pwmLFO1) * 0.25f) + 0.5f; // pulse length
   1f68a:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
   1f68e:	48aa      	ldr	r0, [pc, #680]	; (1f938 <SFXClassicSynthFrame+0x314>)
   1f690:	eeb5 8a00 	vmov.f32	s16, #80	; 0x3e800000  0.250
   1f694:	f00a ff08 	bl	2a4a8 <tCycle_tick>
            float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
   1f698:	48a8      	ldr	r0, [pc, #672]	; (1f93c <SFXClassicSynthFrame+0x318>)
            float tempLFO1 = (tCycle_tick(&pwmLFO1) * 0.25f) + 0.5f; // pulse length
   1f69a:	eef0 9a68 	vmov.f32	s19, s17
   1f69e:	eee0 9a08 	vfma.f32	s19, s0, s16
            float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
   1f6a2:	f00a ff01 	bl	2a4a8 <tCycle_tick>
   1f6a6:	eee0 8a08 	vfma.f32	s17, s0, s16
            for (int i = 0; i < numVoices; i++)
   1f6aa:	9b02      	ldr	r3, [sp, #8]
   1f6ac:	781b      	ldrb	r3, [r3, #0]
            float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
   1f6ae:	ee68 8aa9 	vmul.f32	s17, s17, s19
            for (int i = 0; i < numVoices; i++)
   1f6b2:	2b00      	cmp	r3, #0
   1f6b4:	f000 80a3 	beq.w	1f7fe <SFXClassicSynthFrame+0x1da>
   1f6b8:	f04f 0a00 	mov.w	sl, #0
   1f6bc:	4ba0      	ldr	r3, [pc, #640]	; (1f940 <SFXClassicSynthFrame+0x31c>)
   1f6be:	f8df 82dc 	ldr.w	r8, [pc, #732]	; 1f99c <SFXClassicSynthFrame+0x378>
   1f6c2:	4657      	mov	r7, sl
   1f6c4:	4e9b      	ldr	r6, [pc, #620]	; (1f934 <SFXClassicSynthFrame+0x310>)
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
   1f6c6:	f8df b2a8 	ldr.w	fp, [pc, #680]	; 1f970 <SFXClassicSynthFrame+0x34c>
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
   1f6ca:	eddf ba9e 	vldr	s23, [pc, #632]	; 1f944 <SFXClassicSynthFrame+0x320>
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   1f6ce:	ed9f ba9e 	vldr	s22, [pc, #632]	; 1f948 <SFXClassicSynthFrame+0x324>
   1f6d2:	eddf aa9e 	vldr	s21, [pc, #632]	; 1f94c <SFXClassicSynthFrame+0x328>
   1f6d6:	9301      	str	r3, [sp, #4]
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
   1f6d8:	b2fb      	uxtb	r3, r7
   1f6da:	4a9d      	ldr	r2, [pc, #628]	; (1f950 <SFXClassicSynthFrame+0x32c>)
   1f6dc:	4658      	mov	r0, fp
                    float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
   1f6de:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
   1f6e2:	461c      	mov	r4, r3
   1f6e4:	4619      	mov	r1, r3
   1f6e6:	9303      	str	r3, [sp, #12]
   1f6e8:	eb02 050a 	add.w	r5, r2, sl
   1f6ec:	f00a fea0 	bl	2a430 <tSimplePoly_getPitch>
   1f6f0:	ee07 0a90 	vmov	s15, r0
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f6f4:	4621      	mov	r1, r4
   1f6f6:	4658      	mov	r0, fp
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
   1f6f8:	eeb8 aae7 	vcvt.f32.s32	s20, s15
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f6fc:	f00a fe98 	bl	2a430 <tSimplePoly_getPitch>
   1f700:	ee07 0a90 	vmov	s15, r0
   1f704:	4b93      	ldr	r3, [pc, #588]	; (1f954 <SFXClassicSynthFrame+0x330>)
   1f706:	f10a 090c 	add.w	r9, sl, #12
   1f70a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   1f70e:	ed93 0a00 	vldr	s0, [r3]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f712:	4b91      	ldr	r3, [pc, #580]	; (1f958 <SFXClassicSynthFrame+0x334>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f714:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f718:	7818      	ldrb	r0, [r3, #0]
   1f71a:	4b90      	ldr	r3, [pc, #576]	; (1f95c <SFXClassicSynthFrame+0x338>)
   1f71c:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1f720:	ee17 1a90 	vmov	r1, s15
   1f724:	1a09      	subs	r1, r1, r0
   1f726:	fb83 3401 	smull	r3, r4, r3, r1
   1f72a:	17c8      	asrs	r0, r1, #31
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1f72c:	4b8c      	ldr	r3, [pc, #560]	; (1f960 <SFXClassicSynthFrame+0x33c>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f72e:	ebc0 0064 	rsb	r0, r0, r4, asr #1
   1f732:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1f736:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
   1f73a:	ee07 0a90 	vmov	s15, r0
   1f73e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1f742:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1f746:	ee17 1a90 	vmov	r1, s15
   1f74a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   1f74e:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   1f752:	ee37 0a00 	vadd.f32	s0, s14, s0
   1f756:	f00a f8d1 	bl	298fc <LEAF_midiToFrequency>
   1f75a:	eca8 0a01 	vstmia	r8!, {s0}
                    float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
   1f75e:	eeb0 8a49 	vmov.f32	s16, s18
   1f762:	ecb5 7a01 	vldmia	r5!, {s14}
   1f766:	edd6 7a03 	vldr	s15, [r6, #12]
   1f76a:	4b7e      	ldr	r3, [pc, #504]	; (1f964 <SFXClassicSynthFrame+0x340>)
   1f76c:	eea7 8a27 	vfma.f32	s16, s14, s15
   1f770:	eb03 040a 	add.w	r4, r3, sl
                    tSawtooth_setFreq(&osc[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
   1f774:	4b7c      	ldr	r3, [pc, #496]	; (1f968 <SFXClassicSynthFrame+0x344>)
   1f776:	eb03 000a 	add.w	r0, r3, sl
   1f77a:	f10a 0a04 	add.w	sl, sl, #4
                    float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
   1f77e:	ee28 8a00 	vmul.f32	s16, s16, s0
                    tSawtooth_setFreq(&osc[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
   1f782:	eeb0 0a48 	vmov.f32	s0, s16
   1f786:	f00a ff15 	bl	2a5b4 <tSawtooth_setFreq>
                    tRosenbergGlottalPulse_setFreq(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
   1f78a:	eeb0 0a48 	vmov.f32	s0, s16
   1f78e:	4620      	mov	r0, r4
   1f790:	f006 fe70 	bl	26474 <tRosenbergGlottalPulse_setFreq>
                    tRosenbergGlottalPulse_setPulseLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempLFO1);
   1f794:	eeb0 0a69 	vmov.f32	s0, s19
   1f798:	4620      	mov	r0, r4
   1f79a:	f006 fe87 	bl	264ac <tRosenbergGlottalPulse_setPulseLength>
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempLFO2);
   1f79e:	eeb0 0a68 	vmov.f32	s0, s17
   1f7a2:	4620      	mov	r0, r4
   1f7a4:	f006 fe74 	bl	26490 <tRosenbergGlottalPulse_setOpenLength>
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   1f7a8:	45ca      	cmp	sl, r9
   1f7aa:	d002      	beq.n	1f7b2 <SFXClassicSynthFrame+0x18e>
   1f7ac:	ed18 0a01 	vldr	s0, [r8, #-4]
   1f7b0:	e7d5      	b.n	1f75e <SFXClassicSynthFrame+0x13a>
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
   1f7b2:	edd6 7a02 	vldr	s15, [r6, #8]
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   1f7b6:	eeb0 1a4b 	vmov.f32	s2, s22
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
   1f7ba:	edd6 0a01 	vldr	s1, [r6, #4]
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   1f7be:	eeb0 0a6a 	vmov.f32	s0, s21
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
   1f7c2:	ee67 7aab 	vmul.f32	s15, s15, s23
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   1f7c6:	eeea 0a27 	vfma.f32	s1, s20, s15
   1f7ca:	f009 ffad 	bl	29728 <LEAF_clip>
                if (numVoices > 1)
   1f7ce:	9b02      	ldr	r3, [sp, #8]
                filtFreqs[i] = (uint16_t) tempFreq2;
   1f7d0:	eebc 0ac0 	vcvt.u32.f32	s0, s0
                if (numVoices > 1)
   1f7d4:	7819      	ldrb	r1, [r3, #0]
                filtFreqs[i] = (uint16_t) tempFreq2;
   1f7d6:	9b01      	ldr	r3, [sp, #4]
   1f7d8:	ee10 2a10 	vmov	r2, s0
                if (numVoices > 1)
   1f7dc:	2901      	cmp	r1, #1
                filtFreqs[i] = (uint16_t) tempFreq2;
   1f7de:	f823 2f02 	strh.w	r2, [r3, #2]!
   1f7e2:	9301      	str	r3, [sp, #4]
                if (numVoices > 1)
   1f7e4:	d907      	bls.n	1f7f6 <SFXClassicSynthFrame+0x1d2>
                    if (poly->voices[i][0] == -2)
   1f7e6:	f8db 0000 	ldr.w	r0, [fp]
   1f7ea:	6900      	ldr	r0, [r0, #16]
   1f7ec:	f850 0027 	ldr.w	r0, [r0, r7, lsl #2]
   1f7f0:	6800      	ldr	r0, [r0, #0]
   1f7f2:	3002      	adds	r0, #2
   1f7f4:	d008      	beq.n	1f808 <SFXClassicSynthFrame+0x1e4>
            for (int i = 0; i < numVoices; i++)
   1f7f6:	3701      	adds	r7, #1
   1f7f8:	42b9      	cmp	r1, r7
   1f7fa:	f73f af6d 	bgt.w	1f6d8 <SFXClassicSynthFrame+0xb4>
        }
   1f7fe:	b005      	add	sp, #20
   1f800:	ecbd 8b08 	vpop	{d8-d11}
   1f804:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        if (polyEnvs[i]->whichStage == env_idle)
   1f808:	4b58      	ldr	r3, [pc, #352]	; (1f96c <SFXClassicSynthFrame+0x348>)
   1f80a:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   1f80e:	6a80      	ldr	r0, [r0, #40]	; 0x28
   1f810:	2800      	cmp	r0, #0
   1f812:	d1f0      	bne.n	1f7f6 <SFXClassicSynthFrame+0x1d2>
                            tSimplePoly_deactivateVoice(&poly, i);
   1f814:	9903      	ldr	r1, [sp, #12]
   1f816:	4658      	mov	r0, fp
   1f818:	f00a fd30 	bl	2a27c <tSimplePoly_deactivateVoice>
   1f81c:	9b02      	ldr	r3, [sp, #8]
   1f81e:	7819      	ldrb	r1, [r3, #0]
   1f820:	e7e9      	b.n	1f7f6 <SFXClassicSynthFrame+0x1d2>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1f822:	4d40      	ldr	r5, [pc, #256]	; (1f924 <SFXClassicSynthFrame+0x300>)
                tSimplePoly_setNumVoices(&poly, numVoices);
   1f824:	4852      	ldr	r0, [pc, #328]	; (1f970 <SFXClassicSynthFrame+0x34c>)
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1f826:	782a      	ldrb	r2, [r5, #0]
   1f828:	9502      	str	r5, [sp, #8]
   1f82a:	2a01      	cmp	r2, #1
   1f82c:	bf98      	it	ls
   1f82e:	2308      	movls	r3, #8
                tSimplePoly_setNumVoices(&poly, numVoices);
   1f830:	4619      	mov	r1, r3
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1f832:	702b      	strb	r3, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
   1f834:	f00a fdd8 	bl	2a3e8 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
   1f838:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1f83a:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
   1f83c:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   1f840:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
   1f842:	fab0 f080 	clz	r0, r0
   1f846:	0940      	lsrs	r0, r0, #5
   1f848:	f7f9 fe22 	bl	19490 <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1f84c:	7e23      	ldrb	r3, [r4, #24]
   1f84e:	2b01      	cmp	r3, #1
   1f850:	f47f aef8 	bne.w	1f644 <SFXClassicSynthFrame+0x20>
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1f854:	2300      	movs	r3, #0
                setLED_Edit(0);
   1f856:	4618      	mov	r0, r3
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1f858:	7623      	strb	r3, [r4, #24]
                setLED_Edit(0);
   1f85a:	f7f9 fddd 	bl	19418 <setLED_Edit>
   1f85e:	e6f1      	b.n	1f644 <SFXClassicSynthFrame+0x20>
                        displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   1f860:	4b44      	ldr	r3, [pc, #272]	; (1f974 <SFXClassicSynthFrame+0x350>)
   1f862:	4e34      	ldr	r6, [pc, #208]	; (1f934 <SFXClassicSynthFrame+0x310>)
   1f864:	681b      	ldr	r3, [r3, #0]
   1f866:	6433      	str	r3, [r6, #64]	; 0x40
                        break;
   1f868:	e70f      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   1f86a:	4b43      	ldr	r3, [pc, #268]	; (1f978 <SFXClassicSynthFrame+0x354>)
   1f86c:	ed9f 7a36 	vldr	s14, [pc, #216]	; 1f948 <SFXClassicSynthFrame+0x324>
   1f870:	edd3 7a00 	vldr	s15, [r3]
   1f874:	4e2f      	ldr	r6, [pc, #188]	; (1f934 <SFXClassicSynthFrame+0x310>)
   1f876:	ee67 7a87 	vmul.f32	s15, s15, s14
   1f87a:	edc6 7a0f 	vstr	s15, [r6, #60]	; 0x3c
                        break;
   1f87e:	e704      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[14] = knobs[14]; //leak
   1f880:	4b3e      	ldr	r3, [pc, #248]	; (1f97c <SFXClassicSynthFrame+0x358>)
                        for (int i = 0; i < numVoices; i++)
   1f882:	9f02      	ldr	r7, [sp, #8]
                        displayValues[14] = knobs[14]; //leak
   1f884:	edd3 7a00 	vldr	s15, [r3]
   1f888:	4e2a      	ldr	r6, [pc, #168]	; (1f934 <SFXClassicSynthFrame+0x310>)
                        for (int i = 0; i < numVoices; i++)
   1f88a:	783b      	ldrb	r3, [r7, #0]
                        displayValues[14] = knobs[14]; //leak
   1f88c:	edc6 7a0e 	vstr	s15, [r6, #56]	; 0x38
                        for (int i = 0; i < numVoices; i++)
   1f890:	2b00      	cmp	r3, #0
   1f892:	f43f aefa 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
                            tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   1f896:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   1f89a:	4d39      	ldr	r5, [pc, #228]	; (1f980 <SFXClassicSynthFrame+0x35c>)
                        for (int i = 0; i < numVoices; i++)
   1f89c:	2400      	movs	r4, #0
                            tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   1f89e:	eddf 8a39 	vldr	s17, [pc, #228]	; 1f984 <SFXClassicSynthFrame+0x360>
   1f8a2:	ed9f 8a39 	vldr	s16, [pc, #228]	; 1f988 <SFXClassicSynthFrame+0x364>
   1f8a6:	e001      	b.n	1f8ac <SFXClassicSynthFrame+0x288>
   1f8a8:	edd6 7a0e 	vldr	s15, [r6, #56]	; 0x38
   1f8ac:	ee79 7a67 	vsub.f32	s15, s18, s15
   1f8b0:	4628      	mov	r0, r5
   1f8b2:	eeb0 0a48 	vmov.f32	s0, s16
                        for (int i = 0; i < numVoices; i++)
   1f8b6:	3401      	adds	r4, #1
   1f8b8:	3504      	adds	r5, #4
                            tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   1f8ba:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1f8be:	f007 ff49 	bl	27754 <tADSR4_setLeakFactor>
                        for (int i = 0; i < numVoices; i++)
   1f8c2:	783b      	ldrb	r3, [r7, #0]
   1f8c4:	42a3      	cmp	r3, r4
   1f8c6:	dcef      	bgt.n	1f8a8 <SFXClassicSynthFrame+0x284>
   1f8c8:	e6df      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f8ca:	4a30      	ldr	r2, [pc, #192]	; (1f98c <SFXClassicSynthFrame+0x368>)
   1f8cc:	4b30      	ldr	r3, [pc, #192]	; (1f990 <SFXClassicSynthFrame+0x36c>)
   1f8ce:	edd2 7a00 	vldr	s15, [r2]
   1f8d2:	ed93 7a00 	vldr	s14, [r3]
   1f8d6:	4b2f      	ldr	r3, [pc, #188]	; (1f994 <SFXClassicSynthFrame+0x370>)
   1f8d8:	ee67 7a87 	vmul.f32	s15, s15, s14
   1f8dc:	ed9f 7a2e 	vldr	s14, [pc, #184]	; 1f998 <SFXClassicSynthFrame+0x374>
                        for (int i = 0; i < numVoices; i++)
   1f8e0:	9f02      	ldr	r7, [sp, #8]
                        displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f8e2:	4e14      	ldr	r6, [pc, #80]	; (1f934 <SFXClassicSynthFrame+0x310>)
   1f8e4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
                        for (int i = 0; i < numVoices; i++)
   1f8e8:	783a      	ldrb	r2, [r7, #0]
                        displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f8ea:	ee17 1a90 	vmov	r1, s15
   1f8ee:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1f8f2:	ed93 0a00 	vldr	s0, [r3]
   1f8f6:	ee20 0a07 	vmul.f32	s0, s0, s14
   1f8fa:	ed86 0a0d 	vstr	s0, [r6, #52]	; 0x34
                        for (int i = 0; i < numVoices; i++)
   1f8fe:	2a00      	cmp	r2, #0
   1f900:	f43f aec3 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
   1f904:	4d1e      	ldr	r5, [pc, #120]	; (1f980 <SFXClassicSynthFrame+0x35c>)
   1f906:	2400      	movs	r4, #0
   1f908:	e001      	b.n	1f90e <SFXClassicSynthFrame+0x2ea>
   1f90a:	ed96 0a0d 	vldr	s0, [r6, #52]	; 0x34
                            tADSR4_setRelease(&polyFiltEnvs[i], displayValues[13]);
   1f90e:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
   1f910:	3401      	adds	r4, #1
                            tADSR4_setRelease(&polyFiltEnvs[i], displayValues[13]);
   1f912:	f007 ff11 	bl	27738 <tADSR4_setRelease>
                        for (int i = 0; i < numVoices; i++)
   1f916:	783b      	ldrb	r3, [r7, #0]
   1f918:	3504      	adds	r5, #4
   1f91a:	42a3      	cmp	r3, r4
   1f91c:	dcf5      	bgt.n	1f90a <SFXClassicSynthFrame+0x2e6>
   1f91e:	e6b4      	b.n	1f68a <SFXClassicSynthFrame+0x66>
   1f920:	020fafac 	.word	0x020fafac
   1f924:	000627ac 	.word	0x000627ac
   1f928:	0006282b 	.word	0x0006282b
   1f92c:	020e2f1a 	.word	0x020e2f1a
   1f930:	020e5c18 	.word	0x020e5c18
   1f934:	020fb05c 	.word	0x020fb05c
   1f938:	020f9f54 	.word	0x020f9f54
   1f93c:	020fa038 	.word	0x020fa038
   1f940:	020f9b0a 	.word	0x020f9b0a
   1f944:	42800000 	.word	0x42800000
   1f948:	457ff000 	.word	0x457ff000
   1f94c:	00000000 	.word	0x00000000
   1f950:	020fabcc 	.word	0x020fabcc
   1f954:	020e2ea0 	.word	0x020e2ea0
   1f958:	020e2f18 	.word	0x020e2f18
   1f95c:	2aaaaaab 	.word	0x2aaaaaab
   1f960:	020e2ee4 	.word	0x020e2ee4
   1f964:	020e5110 	.word	0x020e5110
   1f968:	020f9ba4 	.word	0x020f9ba4
   1f96c:	020f9f64 	.word	0x020f9f64
   1f970:	020f9de8 	.word	0x020f9de8
   1f974:	020e5c58 	.word	0x020e5c58
   1f978:	020e5c54 	.word	0x020e5c54
   1f97c:	020e5c50 	.word	0x020e5c50
   1f980:	020e4810 	.word	0x020e4810
   1f984:	3851b717 	.word	0x3851b717
   1f988:	3f7ffcb9 	.word	0x3f7ffcb9
   1f98c:	020e5c4c 	.word	0x020e5c4c
   1f990:	00062794 	.word	0x00062794
   1f994:	020f990c 	.word	0x020f990c
   1f998:	46000000 	.word	0x46000000
   1f99c:	020e5d04 	.word	0x020e5d04
                        displayValues[12] = knobs[12]; //sus
   1f9a0:	4bb0      	ldr	r3, [pc, #704]	; (1fc64 <SFXClassicSynthFrame+0x640>)
                        for (int i = 0; i < numVoices; i++)
   1f9a2:	9f02      	ldr	r7, [sp, #8]
                        displayValues[12] = knobs[12]; //sus
   1f9a4:	ed93 0a00 	vldr	s0, [r3]
   1f9a8:	4eaf      	ldr	r6, [pc, #700]	; (1fc68 <SFXClassicSynthFrame+0x644>)
                        for (int i = 0; i < numVoices; i++)
   1f9aa:	783b      	ldrb	r3, [r7, #0]
                        displayValues[12] = knobs[12]; //sus
   1f9ac:	ed86 0a0c 	vstr	s0, [r6, #48]	; 0x30
                        for (int i = 0; i < numVoices; i++)
   1f9b0:	2b00      	cmp	r3, #0
   1f9b2:	f43f ae6a 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
   1f9b6:	4dad      	ldr	r5, [pc, #692]	; (1fc6c <SFXClassicSynthFrame+0x648>)
   1f9b8:	2400      	movs	r4, #0
   1f9ba:	e001      	b.n	1f9c0 <SFXClassicSynthFrame+0x39c>
   1f9bc:	ed96 0a0c 	vldr	s0, [r6, #48]	; 0x30
                            tADSR4_setSustain(&polyFiltEnvs[i], displayValues[12]);
   1f9c0:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
   1f9c2:	3401      	adds	r4, #1
                            tADSR4_setSustain(&polyFiltEnvs[i], displayValues[12]);
   1f9c4:	f007 fea2 	bl	2770c <tADSR4_setSustain>
                        for (int i = 0; i < numVoices; i++)
   1f9c8:	783b      	ldrb	r3, [r7, #0]
   1f9ca:	3504      	adds	r5, #4
   1f9cc:	42a3      	cmp	r3, r4
   1f9ce:	dcf5      	bgt.n	1f9bc <SFXClassicSynthFrame+0x398>
   1f9d0:	e65b      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f9d2:	4aa7      	ldr	r2, [pc, #668]	; (1fc70 <SFXClassicSynthFrame+0x64c>)
   1f9d4:	4ba7      	ldr	r3, [pc, #668]	; (1fc74 <SFXClassicSynthFrame+0x650>)
   1f9d6:	edd2 7a00 	vldr	s15, [r2]
   1f9da:	ed93 7a00 	vldr	s14, [r3]
   1f9de:	4ba6      	ldr	r3, [pc, #664]	; (1fc78 <SFXClassicSynthFrame+0x654>)
   1f9e0:	ee67 7a87 	vmul.f32	s15, s15, s14
   1f9e4:	ed9f 7aa5 	vldr	s14, [pc, #660]	; 1fc7c <SFXClassicSynthFrame+0x658>
                        for (int i = 0; i < numVoices; i++)
   1f9e8:	9f02      	ldr	r7, [sp, #8]
                        displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f9ea:	4e9f      	ldr	r6, [pc, #636]	; (1fc68 <SFXClassicSynthFrame+0x644>)
   1f9ec:	eefd 7ae7 	vcvt.s32.f32	s15, s15
                        for (int i = 0; i < numVoices; i++)
   1f9f0:	783a      	ldrb	r2, [r7, #0]
                        displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f9f2:	ee17 1a90 	vmov	r1, s15
   1f9f6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1f9fa:	ed93 0a00 	vldr	s0, [r3]
   1f9fe:	ee20 0a07 	vmul.f32	s0, s0, s14
   1fa02:	ed86 0a0b 	vstr	s0, [r6, #44]	; 0x2c
                        for (int i = 0; i < numVoices; i++)
   1fa06:	2a00      	cmp	r2, #0
   1fa08:	f43f ae3f 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
   1fa0c:	4d97      	ldr	r5, [pc, #604]	; (1fc6c <SFXClassicSynthFrame+0x648>)
   1fa0e:	2400      	movs	r4, #0
   1fa10:	e001      	b.n	1fa16 <SFXClassicSynthFrame+0x3f2>
   1fa12:	ed96 0a0b 	vldr	s0, [r6, #44]	; 0x2c
                            tADSR4_setDecay(&polyFiltEnvs[i], displayValues[11]);
   1fa16:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
   1fa18:	3401      	adds	r4, #1
                            tADSR4_setDecay(&polyFiltEnvs[i], displayValues[11]);
   1fa1a:	f007 fe69 	bl	276f0 <tADSR4_setDecay>
                        for (int i = 0; i < numVoices; i++)
   1fa1e:	783b      	ldrb	r3, [r7, #0]
   1fa20:	3504      	adds	r5, #4
   1fa22:	42a3      	cmp	r3, r4
   1fa24:	dcf5      	bgt.n	1fa12 <SFXClassicSynthFrame+0x3ee>
   1fa26:	e630      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1fa28:	4a95      	ldr	r2, [pc, #596]	; (1fc80 <SFXClassicSynthFrame+0x65c>)
   1fa2a:	4b92      	ldr	r3, [pc, #584]	; (1fc74 <SFXClassicSynthFrame+0x650>)
   1fa2c:	edd2 7a00 	vldr	s15, [r2]
   1fa30:	ed93 7a00 	vldr	s14, [r3]
   1fa34:	4b90      	ldr	r3, [pc, #576]	; (1fc78 <SFXClassicSynthFrame+0x654>)
   1fa36:	ee67 7a87 	vmul.f32	s15, s15, s14
   1fa3a:	ed9f 7a90 	vldr	s14, [pc, #576]	; 1fc7c <SFXClassicSynthFrame+0x658>
                        for (int i = 0; i < numVoices; i++)
   1fa3e:	9f02      	ldr	r7, [sp, #8]
                        displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1fa40:	4e89      	ldr	r6, [pc, #548]	; (1fc68 <SFXClassicSynthFrame+0x644>)
   1fa42:	eefd 7ae7 	vcvt.s32.f32	s15, s15
                        for (int i = 0; i < numVoices; i++)
   1fa46:	783a      	ldrb	r2, [r7, #0]
                        displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1fa48:	ee17 1a90 	vmov	r1, s15
   1fa4c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1fa50:	ed93 0a00 	vldr	s0, [r3]
   1fa54:	ee20 0a07 	vmul.f32	s0, s0, s14
   1fa58:	ed86 0a0a 	vstr	s0, [r6, #40]	; 0x28
                        for (int i = 0; i < numVoices; i++)
   1fa5c:	2a00      	cmp	r2, #0
   1fa5e:	f43f ae14 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
   1fa62:	4d82      	ldr	r5, [pc, #520]	; (1fc6c <SFXClassicSynthFrame+0x648>)
   1fa64:	2400      	movs	r4, #0
   1fa66:	e001      	b.n	1fa6c <SFXClassicSynthFrame+0x448>
   1fa68:	ed96 0a0a 	vldr	s0, [r6, #40]	; 0x28
                            tADSR4_setAttack(&polyFiltEnvs[i], displayValues[10]);
   1fa6c:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
   1fa6e:	3401      	adds	r4, #1
                            tADSR4_setAttack(&polyFiltEnvs[i], displayValues[10]);
   1fa70:	f007 fe30 	bl	276d4 <tADSR4_setAttack>
                        for (int i = 0; i < numVoices; i++)
   1fa74:	783b      	ldrb	r3, [r7, #0]
   1fa76:	3504      	adds	r5, #4
   1fa78:	42a3      	cmp	r3, r4
   1fa7a:	dcf5      	bgt.n	1fa68 <SFXClassicSynthFrame+0x444>
   1fa7c:	e605      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[9] = knobs[9]; //leak
   1fa7e:	4b81      	ldr	r3, [pc, #516]	; (1fc84 <SFXClassicSynthFrame+0x660>)
                        for (int i = 0; i < numVoices; i++)
   1fa80:	9f02      	ldr	r7, [sp, #8]
                        displayValues[9] = knobs[9]; //leak
   1fa82:	edd3 7a00 	vldr	s15, [r3]
   1fa86:	4e78      	ldr	r6, [pc, #480]	; (1fc68 <SFXClassicSynthFrame+0x644>)
                        for (int i = 0; i < numVoices; i++)
   1fa88:	783b      	ldrb	r3, [r7, #0]
                        displayValues[9] = knobs[9]; //leak
   1fa8a:	edc6 7a09 	vstr	s15, [r6, #36]	; 0x24
                        for (int i = 0; i < numVoices; i++)
   1fa8e:	2b00      	cmp	r3, #0
   1fa90:	f43f adfb 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
                            tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   1fa94:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   1fa98:	4d7b      	ldr	r5, [pc, #492]	; (1fc88 <SFXClassicSynthFrame+0x664>)
                        for (int i = 0; i < numVoices; i++)
   1fa9a:	2400      	movs	r4, #0
                            tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   1fa9c:	eddf 8a7b 	vldr	s17, [pc, #492]	; 1fc8c <SFXClassicSynthFrame+0x668>
   1faa0:	ed9f 8a7b 	vldr	s16, [pc, #492]	; 1fc90 <SFXClassicSynthFrame+0x66c>
   1faa4:	e001      	b.n	1faaa <SFXClassicSynthFrame+0x486>
   1faa6:	edd6 7a09 	vldr	s15, [r6, #36]	; 0x24
   1faaa:	ee79 7a67 	vsub.f32	s15, s18, s15
   1faae:	4628      	mov	r0, r5
   1fab0:	eeb0 0a48 	vmov.f32	s0, s16
                        for (int i = 0; i < numVoices; i++)
   1fab4:	3401      	adds	r4, #1
   1fab6:	3504      	adds	r5, #4
                            tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   1fab8:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1fabc:	f007 fe4a 	bl	27754 <tADSR4_setLeakFactor>
                        for (int i = 0; i < numVoices; i++)
   1fac0:	783b      	ldrb	r3, [r7, #0]
   1fac2:	42a3      	cmp	r3, r4
   1fac4:	dcef      	bgt.n	1faa6 <SFXClassicSynthFrame+0x482>
   1fac6:	e5e0      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1fac8:	4a72      	ldr	r2, [pc, #456]	; (1fc94 <SFXClassicSynthFrame+0x670>)
   1faca:	4b6a      	ldr	r3, [pc, #424]	; (1fc74 <SFXClassicSynthFrame+0x650>)
   1facc:	edd2 7a00 	vldr	s15, [r2]
   1fad0:	ed93 7a00 	vldr	s14, [r3]
   1fad4:	4b68      	ldr	r3, [pc, #416]	; (1fc78 <SFXClassicSynthFrame+0x654>)
   1fad6:	ee67 7a87 	vmul.f32	s15, s15, s14
   1fada:	ed9f 7a68 	vldr	s14, [pc, #416]	; 1fc7c <SFXClassicSynthFrame+0x658>
                        for (int i = 0; i < numVoices; i++)
   1fade:	9f02      	ldr	r7, [sp, #8]
                        displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1fae0:	4e61      	ldr	r6, [pc, #388]	; (1fc68 <SFXClassicSynthFrame+0x644>)
   1fae2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
                        for (int i = 0; i < numVoices; i++)
   1fae6:	783a      	ldrb	r2, [r7, #0]
                        displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1fae8:	ee17 1a90 	vmov	r1, s15
   1faec:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1faf0:	ed93 0a00 	vldr	s0, [r3]
   1faf4:	ee20 0a07 	vmul.f32	s0, s0, s14
   1faf8:	ed86 0a08 	vstr	s0, [r6, #32]
                        for (int i = 0; i < numVoices; i++)
   1fafc:	2a00      	cmp	r2, #0
   1fafe:	f43f adc4 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
   1fb02:	4d61      	ldr	r5, [pc, #388]	; (1fc88 <SFXClassicSynthFrame+0x664>)
   1fb04:	2400      	movs	r4, #0
   1fb06:	e001      	b.n	1fb0c <SFXClassicSynthFrame+0x4e8>
   1fb08:	ed96 0a08 	vldr	s0, [r6, #32]
                            tADSR4_setRelease(&polyEnvs[i], displayValues[8]);
   1fb0c:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
   1fb0e:	3401      	adds	r4, #1
                            tADSR4_setRelease(&polyEnvs[i], displayValues[8]);
   1fb10:	f007 fe12 	bl	27738 <tADSR4_setRelease>
                        for (int i = 0; i < numVoices; i++)
   1fb14:	783b      	ldrb	r3, [r7, #0]
   1fb16:	3504      	adds	r5, #4
   1fb18:	42a3      	cmp	r3, r4
   1fb1a:	dcf5      	bgt.n	1fb08 <SFXClassicSynthFrame+0x4e4>
   1fb1c:	e5b5      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[7] = knobs[7]; //sus
   1fb1e:	4b5e      	ldr	r3, [pc, #376]	; (1fc98 <SFXClassicSynthFrame+0x674>)
                        for (int i = 0; i < numVoices; i++)
   1fb20:	9f02      	ldr	r7, [sp, #8]
                        displayValues[7] = knobs[7]; //sus
   1fb22:	ed93 0a00 	vldr	s0, [r3]
   1fb26:	4e50      	ldr	r6, [pc, #320]	; (1fc68 <SFXClassicSynthFrame+0x644>)
                        for (int i = 0; i < numVoices; i++)
   1fb28:	783b      	ldrb	r3, [r7, #0]
                        displayValues[7] = knobs[7]; //sus
   1fb2a:	ed86 0a07 	vstr	s0, [r6, #28]
                        for (int i = 0; i < numVoices; i++)
   1fb2e:	2b00      	cmp	r3, #0
   1fb30:	f43f adab 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
   1fb34:	4d54      	ldr	r5, [pc, #336]	; (1fc88 <SFXClassicSynthFrame+0x664>)
   1fb36:	2400      	movs	r4, #0
   1fb38:	e001      	b.n	1fb3e <SFXClassicSynthFrame+0x51a>
   1fb3a:	ed96 0a07 	vldr	s0, [r6, #28]
                            tADSR4_setSustain(&polyEnvs[i], displayValues[7]);
   1fb3e:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
   1fb40:	3401      	adds	r4, #1
                            tADSR4_setSustain(&polyEnvs[i], displayValues[7]);
   1fb42:	f007 fde3 	bl	2770c <tADSR4_setSustain>
                        for (int i = 0; i < numVoices; i++)
   1fb46:	783b      	ldrb	r3, [r7, #0]
   1fb48:	3504      	adds	r5, #4
   1fb4a:	42a3      	cmp	r3, r4
   1fb4c:	dcf5      	bgt.n	1fb3a <SFXClassicSynthFrame+0x516>
   1fb4e:	e59c      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1fb50:	4a52      	ldr	r2, [pc, #328]	; (1fc9c <SFXClassicSynthFrame+0x678>)
   1fb52:	4b48      	ldr	r3, [pc, #288]	; (1fc74 <SFXClassicSynthFrame+0x650>)
   1fb54:	edd2 7a00 	vldr	s15, [r2]
   1fb58:	ed93 7a00 	vldr	s14, [r3]
   1fb5c:	4b46      	ldr	r3, [pc, #280]	; (1fc78 <SFXClassicSynthFrame+0x654>)
   1fb5e:	ee67 7a87 	vmul.f32	s15, s15, s14
   1fb62:	ed9f 7a46 	vldr	s14, [pc, #280]	; 1fc7c <SFXClassicSynthFrame+0x658>
                        for (int i = 0; i < numVoices; i++)
   1fb66:	9f02      	ldr	r7, [sp, #8]
                        displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1fb68:	4e3f      	ldr	r6, [pc, #252]	; (1fc68 <SFXClassicSynthFrame+0x644>)
   1fb6a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
                        for (int i = 0; i < numVoices; i++)
   1fb6e:	783a      	ldrb	r2, [r7, #0]
                        displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1fb70:	ee17 1a90 	vmov	r1, s15
   1fb74:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1fb78:	ed93 0a00 	vldr	s0, [r3]
   1fb7c:	ee20 0a07 	vmul.f32	s0, s0, s14
   1fb80:	ed86 0a06 	vstr	s0, [r6, #24]
                        for (int i = 0; i < numVoices; i++)
   1fb84:	2a00      	cmp	r2, #0
   1fb86:	f43f ad80 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
   1fb8a:	4d3f      	ldr	r5, [pc, #252]	; (1fc88 <SFXClassicSynthFrame+0x664>)
   1fb8c:	2400      	movs	r4, #0
   1fb8e:	e001      	b.n	1fb94 <SFXClassicSynthFrame+0x570>
   1fb90:	ed96 0a06 	vldr	s0, [r6, #24]
                            tADSR4_setDecay(&polyEnvs[i], displayValues[6]);
   1fb94:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
   1fb96:	3401      	adds	r4, #1
                            tADSR4_setDecay(&polyEnvs[i], displayValues[6]);
   1fb98:	f007 fdaa 	bl	276f0 <tADSR4_setDecay>
                        for (int i = 0; i < numVoices; i++)
   1fb9c:	783b      	ldrb	r3, [r7, #0]
   1fb9e:	3504      	adds	r5, #4
   1fba0:	42a3      	cmp	r3, r4
   1fba2:	dcf5      	bgt.n	1fb90 <SFXClassicSynthFrame+0x56c>
   1fba4:	e571      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1fba6:	4a3e      	ldr	r2, [pc, #248]	; (1fca0 <SFXClassicSynthFrame+0x67c>)
   1fba8:	4b32      	ldr	r3, [pc, #200]	; (1fc74 <SFXClassicSynthFrame+0x650>)
   1fbaa:	edd2 7a00 	vldr	s15, [r2]
   1fbae:	ed93 7a00 	vldr	s14, [r3]
   1fbb2:	4b31      	ldr	r3, [pc, #196]	; (1fc78 <SFXClassicSynthFrame+0x654>)
   1fbb4:	ee67 7a87 	vmul.f32	s15, s15, s14
   1fbb8:	ed9f 7a30 	vldr	s14, [pc, #192]	; 1fc7c <SFXClassicSynthFrame+0x658>
                        for (int i = 0; i < numVoices; i++)
   1fbbc:	9f02      	ldr	r7, [sp, #8]
                        displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1fbbe:	4e2a      	ldr	r6, [pc, #168]	; (1fc68 <SFXClassicSynthFrame+0x644>)
   1fbc0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
                        for (int i = 0; i < numVoices; i++)
   1fbc4:	783a      	ldrb	r2, [r7, #0]
                        displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1fbc6:	ee17 1a90 	vmov	r1, s15
   1fbca:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1fbce:	ed93 0a00 	vldr	s0, [r3]
   1fbd2:	ee20 0a07 	vmul.f32	s0, s0, s14
   1fbd6:	ed86 0a05 	vstr	s0, [r6, #20]
                        for (int i = 0; i < numVoices; i++)
   1fbda:	2a00      	cmp	r2, #0
   1fbdc:	f43f ad55 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
   1fbe0:	4d29      	ldr	r5, [pc, #164]	; (1fc88 <SFXClassicSynthFrame+0x664>)
   1fbe2:	2400      	movs	r4, #0
   1fbe4:	e001      	b.n	1fbea <SFXClassicSynthFrame+0x5c6>
   1fbe6:	ed96 0a05 	vldr	s0, [r6, #20]
                            tADSR4_setAttack(&polyEnvs[i], displayValues[5]);
   1fbea:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
   1fbec:	3401      	adds	r4, #1
                            tADSR4_setAttack(&polyEnvs[i], displayValues[5]);
   1fbee:	f007 fd71 	bl	276d4 <tADSR4_setAttack>
                        for (int i = 0; i < numVoices; i++)
   1fbf2:	783b      	ldrb	r3, [r7, #0]
   1fbf4:	3504      	adds	r5, #4
   1fbf6:	42a3      	cmp	r3, r4
   1fbf8:	dcf5      	bgt.n	1fbe6 <SFXClassicSynthFrame+0x5c2>
   1fbfa:	e546      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1fbfc:	4b29      	ldr	r3, [pc, #164]	; (1fca4 <SFXClassicSynthFrame+0x680>)
   1fbfe:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   1fc02:	ed9f 0a29 	vldr	s0, [pc, #164]	; 1fca8 <SFXClassicSynthFrame+0x684>
   1fc06:	ed93 7a00 	vldr	s14, [r3]
                        for (int i = 0; i < numVoices; i++)
   1fc0a:	9f02      	ldr	r7, [sp, #8]
                        displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1fc0c:	eea7 0a27 	vfma.f32	s0, s14, s15
   1fc10:	4e15      	ldr	r6, [pc, #84]	; (1fc68 <SFXClassicSynthFrame+0x644>)
                        for (int i = 0; i < numVoices; i++)
   1fc12:	783b      	ldrb	r3, [r7, #0]
                        displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1fc14:	ed86 0a04 	vstr	s0, [r6, #16]
                        for (int i = 0; i < numVoices; i++)
   1fc18:	2b00      	cmp	r3, #0
   1fc1a:	f43f ad36 	beq.w	1f68a <SFXClassicSynthFrame+0x66>
   1fc1e:	4d23      	ldr	r5, [pc, #140]	; (1fcac <SFXClassicSynthFrame+0x688>)
   1fc20:	2400      	movs	r4, #0
   1fc22:	e001      	b.n	1fc28 <SFXClassicSynthFrame+0x604>
   1fc24:	ed96 0a04 	vldr	s0, [r6, #16]
                            tEfficientSVF_setQ(&synthLP[i],displayValues[4]);
   1fc28:	4628      	mov	r0, r5
                        for (int i = 0; i < numVoices; i++)
   1fc2a:	3401      	adds	r4, #1
                            tEfficientSVF_setQ(&synthLP[i],displayValues[4]);
   1fc2c:	f008 fbba 	bl	283a4 <tEfficientSVF_setQ>
                        for (int i = 0; i < numVoices; i++)
   1fc30:	783b      	ldrb	r3, [r7, #0]
   1fc32:	3504      	adds	r5, #4
   1fc34:	42a3      	cmp	r3, r4
   1fc36:	dcf5      	bgt.n	1fc24 <SFXClassicSynthFrame+0x600>
   1fc38:	e527      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[3] = knobs[3]; //detune
   1fc3a:	4b1d      	ldr	r3, [pc, #116]	; (1fcb0 <SFXClassicSynthFrame+0x68c>)
   1fc3c:	4e0a      	ldr	r6, [pc, #40]	; (1fc68 <SFXClassicSynthFrame+0x644>)
   1fc3e:	681b      	ldr	r3, [r3, #0]
   1fc40:	60f3      	str	r3, [r6, #12]
                        break;
   1fc42:	e522      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[2] = knobs[2]; //keyfollow filter cutoff
   1fc44:	4b1b      	ldr	r3, [pc, #108]	; (1fcb4 <SFXClassicSynthFrame+0x690>)
   1fc46:	4e08      	ldr	r6, [pc, #32]	; (1fc68 <SFXClassicSynthFrame+0x644>)
   1fc48:	681b      	ldr	r3, [r3, #0]
   1fc4a:	60b3      	str	r3, [r6, #8]
                        break;
   1fc4c:	e51d      	b.n	1f68a <SFXClassicSynthFrame+0x66>
                        displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   1fc4e:	4b1a      	ldr	r3, [pc, #104]	; (1fcb8 <SFXClassicSynthFrame+0x694>)
   1fc50:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 1fcbc <SFXClassicSynthFrame+0x698>
   1fc54:	edd3 7a00 	vldr	s15, [r3]
   1fc58:	4e03      	ldr	r6, [pc, #12]	; (1fc68 <SFXClassicSynthFrame+0x644>)
   1fc5a:	ee67 7a87 	vmul.f32	s15, s15, s14
   1fc5e:	edc6 7a01 	vstr	s15, [r6, #4]
                        break;
   1fc62:	e512      	b.n	1f68a <SFXClassicSynthFrame+0x66>
   1fc64:	020e5c48 	.word	0x020e5c48
   1fc68:	020fb05c 	.word	0x020fb05c
   1fc6c:	020e4810 	.word	0x020e4810
   1fc70:	020e5c44 	.word	0x020e5c44
   1fc74:	00062794 	.word	0x00062794
   1fc78:	020f990c 	.word	0x020f990c
   1fc7c:	46000000 	.word	0x46000000
   1fc80:	020e5c40 	.word	0x020e5c40
   1fc84:	020e5c3c 	.word	0x020e5c3c
   1fc88:	020f9f64 	.word	0x020f9f64
   1fc8c:	3851b717 	.word	0x3851b717
   1fc90:	3f7ffcb9 	.word	0x3f7ffcb9
   1fc94:	020e5c38 	.word	0x020e5c38
   1fc98:	020e5c34 	.word	0x020e5c34
   1fc9c:	020e5c30 	.word	0x020e5c30
   1fca0:	020e5c2c 	.word	0x020e5c2c
   1fca4:	020e5c28 	.word	0x020e5c28
   1fca8:	3ecccccd 	.word	0x3ecccccd
   1fcac:	020e5ce0 	.word	0x020e5ce0
   1fcb0:	020e5c24 	.word	0x020e5c24
   1fcb4:	020e5c20 	.word	0x020e5c20
   1fcb8:	020e5c1c 	.word	0x020e5c1c
   1fcbc:	45800000 	.word	0x45800000

0001fcc0 <SFXClassicSynthTick>:
        {
   1fcc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1fcc4:	2500      	movs	r5, #0
   1fcc6:	f8df a124 	ldr.w	sl, [pc, #292]	; 1fdec <SFXClassicSynthTick+0x12c>
   1fcca:	260c      	movs	r6, #12
   1fccc:	4c3e      	ldr	r4, [pc, #248]	; (1fdc8 <SFXClassicSynthTick+0x108>)
   1fcce:	46a9      	mov	r9, r5
        {
   1fcd0:	ed2d 8b08 	vpush	{d8-d11}
   1fcd4:	b083      	sub	sp, #12
            float sample = 0.0f;
   1fcd6:	eddf aa3d 	vldr	s21, [pc, #244]	; 1fdcc <SFXClassicSynthTick+0x10c>
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   1fcda:	ed9f ba3d 	vldr	s22, [pc, #244]	; 1fdd0 <SFXClassicSynthTick+0x110>
        {
   1fcde:	9001      	str	r0, [sp, #4]
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   1fce0:	eef0 ba6a 	vmov.f32	s23, s21
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1fce4:	483b      	ldr	r0, [pc, #236]	; (1fdd4 <SFXClassicSynthTick+0x114>)
   1fce6:	f00a fb87 	bl	2a3f8 <tSimplePoly_getNumVoices>
   1fcea:	4548      	cmp	r0, r9
   1fcec:	dd58      	ble.n	1fda0 <SFXClassicSynthTick+0xe0>
                float env = tADSR4_tick(&polyEnvs[i]);
   1fcee:	483a      	ldr	r0, [pc, #232]	; (1fdd8 <SFXClassicSynthTick+0x118>)
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   1fcf0:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
   1fcf4:	eb05 0b45 	add.w	fp, r5, r5, lsl #1
                float tempSample = 0.0f;
   1fcf8:	eddf 8a34 	vldr	s17, [pc, #208]	; 1fdcc <SFXClassicSynthTick+0x10c>
                float env = tADSR4_tick(&polyEnvs[i]);
   1fcfc:	4428      	add	r0, r5
   1fcfe:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 1fdf0 <SFXClassicSynthTick+0x130>
   1fd02:	f007 fd45 	bl	27790 <tADSR4_tick>
   1fd06:	eef0 9a40 	vmov.f32	s19, s0
   1fd0a:	4f34      	ldr	r7, [pc, #208]	; (1fddc <SFXClassicSynthTick+0x11c>)
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   1fd0c:	eb08 000b 	add.w	r0, r8, fp
   1fd10:	f00a fc82 	bl	2a618 <tSawtooth_tick>
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   1fd14:	eb07 000b 	add.w	r0, r7, fp
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   1fd18:	eeb0 9a40 	vmov.f32	s18, s0
   1fd1c:	ed94 8a10 	vldr	s16, [r4, #64]	; 0x40
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   1fd20:	f006 facc 	bl	262bc <tRosenbergGlottalPulse_tick>
   1fd24:	edd4 7a10 	vldr	s15, [r4, #64]	; 0x40
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   1fd28:	ee3a 8a48 	vsub.f32	s16, s20, s16
   1fd2c:	f10b 0b04 	add.w	fp, fp, #4
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   1fd30:	ee20 0a27 	vmul.f32	s0, s0, s15
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   1fd34:	45b3      	cmp	fp, r6
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   1fd36:	eea9 0a08 	vfma.f32	s0, s18, s16
   1fd3a:	eee9 8a80 	vfma.f32	s17, s19, s0
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   1fd3e:	d1e5      	bne.n	1fd0c <SFXClassicSynthTick+0x4c>
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   1fd40:	f83a 3f02 	ldrh.w	r3, [sl, #2]!
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1fd44:	f109 0901 	add.w	r9, r9, #1
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   1fd48:	4825      	ldr	r0, [pc, #148]	; (1fde0 <SFXClassicSynthTick+0x120>)
   1fd4a:	360c      	adds	r6, #12
   1fd4c:	ee08 3a10 	vmov	s16, r3
   1fd50:	ed94 9a0f 	vldr	s18, [r4, #60]	; 0x3c
   1fd54:	4428      	add	r0, r5
   1fd56:	4f23      	ldr	r7, [pc, #140]	; (1fde4 <SFXClassicSynthTick+0x124>)
   1fd58:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
   1fd5c:	f007 fd18 	bl	27790 <tADSR4_tick>
   1fd60:	eeb0 1a4b 	vmov.f32	s2, s22
   1fd64:	442f      	add	r7, r5
   1fd66:	3504      	adds	r5, #4
   1fd68:	eef0 0a48 	vmov.f32	s1, s16
   1fd6c:	eee9 0a00 	vfma.f32	s1, s18, s0
   1fd70:	eeb0 0a6b 	vmov.f32	s0, s23
   1fd74:	f009 fcd8 	bl	29728 <LEAF_clip>
   1fd78:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   1fd7c:	4638      	mov	r0, r7
   1fd7e:	ee10 3a10 	vmov	r3, s0
   1fd82:	b299      	uxth	r1, r3
   1fd84:	f008 faea 	bl	2835c <tEfficientSVF_setFreq>
                sample += tEfficientSVF_tick(&synthLP[i], tempSample);
   1fd88:	4638      	mov	r0, r7
   1fd8a:	eeb0 0a68 	vmov.f32	s0, s17
   1fd8e:	f008 fa95 	bl	282bc <tEfficientSVF_tick>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1fd92:	4810      	ldr	r0, [pc, #64]	; (1fdd4 <SFXClassicSynthTick+0x114>)
                sample += tEfficientSVF_tick(&synthLP[i], tempSample);
   1fd94:	ee7a aa80 	vadd.f32	s21, s21, s0
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1fd98:	f00a fb2e 	bl	2a3f8 <tSimplePoly_getNumVoices>
   1fd9c:	4548      	cmp	r0, r9
   1fd9e:	dca6      	bgt.n	1fcee <SFXClassicSynthTick+0x2e>
            sample *= INV_NUM_OSC_PER_VOICE * displayValues[0];
   1fda0:	ed94 0a00 	vldr	s0, [r4]
   1fda4:	eddf 7a10 	vldr	s15, [pc, #64]	; 1fde8 <SFXClassicSynthTick+0x128>
   1fda8:	ee20 0a27 	vmul.f32	s0, s0, s15
            sample = tanhf(sample);
   1fdac:	ee20 0a2a 	vmul.f32	s0, s0, s21
   1fdb0:	f00d f9d4 	bl	2d15c <tanhf>
            input[0] = sample;
   1fdb4:	9b01      	ldr	r3, [sp, #4]
   1fdb6:	ed83 0a00 	vstr	s0, [r3]
            input[1] = sample;
   1fdba:	ed83 0a01 	vstr	s0, [r3, #4]
        }
   1fdbe:	b003      	add	sp, #12
   1fdc0:	ecbd 8b08 	vpop	{d8-d11}
   1fdc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1fdc8:	020fb05c 	.word	0x020fb05c
   1fdcc:	00000000 	.word	0x00000000
   1fdd0:	457ff000 	.word	0x457ff000
   1fdd4:	020f9de8 	.word	0x020f9de8
   1fdd8:	020f9f64 	.word	0x020f9f64
   1fddc:	020e5110 	.word	0x020e5110
   1fde0:	020e4810 	.word	0x020e4810
   1fde4:	020e5ce0 	.word	0x020e5ce0
   1fde8:	3ea8f5c3 	.word	0x3ea8f5c3
   1fdec:	020f9b0a 	.word	0x020f9b0a
   1fdf0:	020f9ba4 	.word	0x020f9ba4

0001fdf4 <SFXClassicSynthFree>:
        {
   1fdf4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1fdf8:	2500      	movs	r5, #0
   1fdfa:	260c      	movs	r6, #12
   1fdfc:	f8df 8064 	ldr.w	r8, [pc, #100]	; 1fe64 <SFXClassicSynthFree+0x70>
   1fe00:	4f15      	ldr	r7, [pc, #84]	; (1fe58 <SFXClassicSynthFree+0x64>)
   1fe02:	f8df b064 	ldr.w	fp, [pc, #100]	; 1fe68 <SFXClassicSynthFree+0x74>
   1fe06:	f8df a064 	ldr.w	sl, [pc, #100]	; 1fe6c <SFXClassicSynthFree+0x78>
   1fe0a:	f8df 9064 	ldr.w	r9, [pc, #100]	; 1fe70 <SFXClassicSynthFree+0x7c>
   1fe0e:	eb05 0445 	add.w	r4, r5, r5, lsl #1
                    tSawtooth_free(&osc[(i * NUM_OSC_PER_VOICE) + j]);
   1fe12:	eb08 0004 	add.w	r0, r8, r4
   1fe16:	f00a fbc9 	bl	2a5ac <tSawtooth_free>
                    tRosenbergGlottalPulse_free(&glottal[(i * NUM_OSC_PER_VOICE) + j]);
   1fe1a:	1938      	adds	r0, r7, r4
   1fe1c:	3404      	adds	r4, #4
   1fe1e:	f006 fa49 	bl	262b4 <tRosenbergGlottalPulse_free>
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   1fe22:	42b4      	cmp	r4, r6
   1fe24:	d1f5      	bne.n	1fe12 <SFXClassicSynthFree+0x1e>
                tEfficientSVF_free(&synthLP[i]);
   1fe26:	eb0b 0005 	add.w	r0, fp, r5
   1fe2a:	f104 060c 	add.w	r6, r4, #12
   1fe2e:	f008 fa41 	bl	282b4 <tEfficientSVF_free>
                tADSR4_free(&polyEnvs[i]);
   1fe32:	eb0a 0005 	add.w	r0, sl, r5
   1fe36:	f007 fc49 	bl	276cc <tADSR4_free>
                tADSR4_free(&polyFiltEnvs[i]);
   1fe3a:	eb09 0005 	add.w	r0, r9, r5
   1fe3e:	3504      	adds	r5, #4
   1fe40:	f007 fc44 	bl	276cc <tADSR4_free>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
   1fe44:	2d20      	cmp	r5, #32
   1fe46:	d1e2      	bne.n	1fe0e <SFXClassicSynthFree+0x1a>
            tCycle_free(&pwmLFO1);
   1fe48:	4804      	ldr	r0, [pc, #16]	; (1fe5c <SFXClassicSynthFree+0x68>)
   1fe4a:	f00a fb1b 	bl	2a484 <tCycle_free>
            tCycle_free(&pwmLFO2);
   1fe4e:	4804      	ldr	r0, [pc, #16]	; (1fe60 <SFXClassicSynthFree+0x6c>)
        }
   1fe50:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            tCycle_free(&pwmLFO2);
   1fe54:	f00a bb16 	b.w	2a484 <tCycle_free>
   1fe58:	020e5110 	.word	0x020e5110
   1fe5c:	020f9f54 	.word	0x020f9f54
   1fe60:	020fa038 	.word	0x020fa038
   1fe64:	020f9ba4 	.word	0x020f9ba4
   1fe68:	020e5ce0 	.word	0x020e5ce0
   1fe6c:	020f9f64 	.word	0x020f9f64
   1fe70:	020e4810 	.word	0x020e4810

0001fe74 <SFXRhodesAlloc>:
        {
   1fe74:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            leaf.clearOnAllocation = 1;
   1fe78:	2101      	movs	r1, #1
            soundNames[0] = "DARK  ";
   1fe7a:	f8df b150 	ldr.w	fp, [pc, #336]	; 1ffcc <SFXRhodesAlloc+0x158>
   1fe7e:	4a41      	ldr	r2, [pc, #260]	; (1ff84 <SFXRhodesAlloc+0x110>)
            soundNames[4] = "CUSTOM";
   1fe80:	2400      	movs	r4, #0
            soundNames[1] = "LIGHT ";
   1fe82:	4b41      	ldr	r3, [pc, #260]	; (1ff88 <SFXRhodesAlloc+0x114>)
            leaf.clearOnAllocation = 1;
   1fe84:	4841      	ldr	r0, [pc, #260]	; (1ff8c <SFXRhodesAlloc+0x118>)
            soundNames[0] = "DARK  ";
   1fe86:	f8cb 2000 	str.w	r2, [fp]
            soundNames[1] = "LIGHT ";
   1fe8a:	f8cb 3004 	str.w	r3, [fp, #4]
            soundNames[3] = "PAD   ";
   1fe8e:	4a40      	ldr	r2, [pc, #256]	; (1ff90 <SFXRhodesAlloc+0x11c>)
            soundNames[4] = "CUSTOM";
   1fe90:	4b40      	ldr	r3, [pc, #256]	; (1ff94 <SFXRhodesAlloc+0x120>)
   1fe92:	f8df a13c 	ldr.w	sl, [pc, #316]	; 1ffd0 <SFXRhodesAlloc+0x15c>
   1fe96:	f8df 913c 	ldr.w	r9, [pc, #316]	; 1ffd4 <SFXRhodesAlloc+0x160>
   1fe9a:	f8cb 3010 	str.w	r3, [fp, #16]
        {
   1fe9e:	ed2d 8b04 	vpush	{d8-d9}
            leaf.clearOnAllocation = 1;
   1fea2:	6141      	str	r1, [r0, #20]
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1fea4:	ed9f 9a3c 	vldr	s18, [pc, #240]	; 1ff98 <SFXRhodesAlloc+0x124>
            soundNames[2] = "BASS  ";
   1fea8:	493c      	ldr	r1, [pc, #240]	; (1ff9c <SFXRhodesAlloc+0x128>)
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1feaa:	eddf 8a3d 	vldr	s17, [pc, #244]	; 1ffa0 <SFXRhodesAlloc+0x12c>
                    tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
   1feae:	ed9f 8a3d 	vldr	s16, [pc, #244]	; 1ffa4 <SFXRhodesAlloc+0x130>
            soundNames[3] = "PAD   ";
   1feb2:	e9cb 1202 	strd	r1, r2, [fp, #8]
   1feb6:	f104 0818 	add.w	r8, r4, #24
                    tCycle_initToPool(&FM_sines[i][j], &smallPool);
   1feba:	4e3b      	ldr	r6, [pc, #236]	; (1ffa8 <SFXRhodesAlloc+0x134>)
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1febc:	4f3b      	ldr	r7, [pc, #236]	; (1ffac <SFXRhodesAlloc+0x138>)
   1febe:	eb09 0504 	add.w	r5, r9, r4
                    tCycle_initToPool(&FM_sines[i][j], &smallPool);
   1fec2:	eb0a 0004 	add.w	r0, sl, r4
   1fec6:	4631      	mov	r1, r6
   1fec8:	3404      	adds	r4, #4
   1feca:	f00a facd 	bl	2a468 <tCycle_initToPool>
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1fece:	4628      	mov	r0, r5
   1fed0:	4633      	mov	r3, r6
   1fed2:	f44f 7200 	mov.w	r2, #512	; 0x200
   1fed6:	4639      	mov	r1, r7
   1fed8:	eef0 1a49 	vmov.f32	s3, s18
   1fedc:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
   1fee0:	eef0 0a68 	vmov.f32	s1, s17
   1fee4:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   1fee8:	f007 fb96 	bl	27618 <tADSR4_initToPool>
                    tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
   1feec:	eeb0 0a48 	vmov.f32	s0, s16
   1fef0:	4628      	mov	r0, r5
   1fef2:	f007 fc2f 	bl	27754 <tADSR4_setLeakFactor>
                for (int j = 0; j < 6; j++)
   1fef6:	4544      	cmp	r4, r8
   1fef8:	d1e1      	bne.n	1febe <SFXRhodesAlloc+0x4a>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
   1fefa:	2cc0      	cmp	r4, #192	; 0xc0
   1fefc:	d1db      	bne.n	1feb6 <SFXRhodesAlloc+0x42>
   1fefe:	4c2c      	ldr	r4, [pc, #176]	; (1ffb0 <SFXRhodesAlloc+0x13c>)
                tExpSmooth_initToPool(&susSmoothers[i], 1.0f, 0.01f, &smallPool);
   1ff00:	4e29      	ldr	r6, [pc, #164]	; (1ffa8 <SFXRhodesAlloc+0x134>)
   1ff02:	f104 0518 	add.w	r5, r4, #24
   1ff06:	ed9f 8a2b 	vldr	s16, [pc, #172]	; 1ffb4 <SFXRhodesAlloc+0x140>
   1ff0a:	4620      	mov	r0, r4
   1ff0c:	3404      	adds	r4, #4
   1ff0e:	4631      	mov	r1, r6
   1ff10:	eef0 0a48 	vmov.f32	s1, s16
   1ff14:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1ff18:	f007 ff36 	bl	27d88 <tExpSmooth_initToPool>
            for (int i = 0; i < 6; i++)
   1ff1c:	42a5      	cmp	r5, r4
   1ff1e:	d1f4      	bne.n	1ff0a <SFXRhodesAlloc+0x96>
            tCycle_initToPool(&tremolo, &smallPool);
   1ff20:	4921      	ldr	r1, [pc, #132]	; (1ffa8 <SFXRhodesAlloc+0x134>)
   1ff22:	4825      	ldr	r0, [pc, #148]	; (1ffb8 <SFXRhodesAlloc+0x144>)
   1ff24:	f00a faa0 	bl	2a468 <tCycle_initToPool>
            tCycle_setFreq(&tremolo, 3.0f);
   1ff28:	eeb0 0a08 	vmov.f32	s0, #8	; 0x40400000  3.0
   1ff2c:	4822      	ldr	r0, [pc, #136]	; (1ffb8 <SFXRhodesAlloc+0x144>)
   1ff2e:	f00a faad 	bl	2a48c <tCycle_setFreq>
            tSimplePoly_setNumVoices(&poly, NUM_VOC_VOICES);
   1ff32:	2108      	movs	r1, #8
   1ff34:	4821      	ldr	r0, [pc, #132]	; (1ffbc <SFXRhodesAlloc+0x148>)
   1ff36:	f00a fa57 	bl	2a3e8 <tSimplePoly_setNumVoices>
            setLED_A(numVoices == 1);
   1ff3a:	4b21      	ldr	r3, [pc, #132]	; (1ffc0 <SFXRhodesAlloc+0x14c>)
   1ff3c:	7818      	ldrb	r0, [r3, #0]
   1ff3e:	f1a0 0001 	sub.w	r0, r0, #1
   1ff42:	fab0 f080 	clz	r0, r0
   1ff46:	0940      	lsrs	r0, r0, #5
   1ff48:	f7f9 faa2 	bl	19490 <setLED_A>
            setLED_C(tremoloStereo == 1);
   1ff4c:	4b1d      	ldr	r3, [pc, #116]	; (1ffc4 <SFXRhodesAlloc+0x150>)
   1ff4e:	7818      	ldrb	r0, [r3, #0]
   1ff50:	f1a0 0001 	sub.w	r0, r0, #1
   1ff54:	fab0 f080 	clz	r0, r0
   1ff58:	0940      	lsrs	r0, r0, #5
   1ff5a:	f7f9 fab5 	bl	194c8 <setLED_C>
            OLEDclearLine(SecondLine);
   1ff5e:	2001      	movs	r0, #1
   1ff60:	f7f9 fcc0 	bl	198e4 <OLEDclearLine>
            OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
   1ff64:	4918      	ldr	r1, [pc, #96]	; (1ffc8 <SFXRhodesAlloc+0x154>)
   1ff66:	2301      	movs	r3, #1
   1ff68:	2200      	movs	r2, #0
   1ff6a:	6808      	ldr	r0, [r1, #0]
   1ff6c:	2106      	movs	r1, #6
   1ff6e:	f85b 0020 	ldr.w	r0, [fp, r0, lsl #2]
   1ff72:	f7f9 fccb 	bl	1990c <OLEDwriteString>
            leaf.clearOnAllocation = 0;
   1ff76:	2300      	movs	r3, #0
   1ff78:	4a04      	ldr	r2, [pc, #16]	; (1ff8c <SFXRhodesAlloc+0x118>)
   1ff7a:	6153      	str	r3, [r2, #20]
        }
   1ff7c:	ecbd 8b04 	vpop	{d8-d9}
   1ff80:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ff84:	00030c98 	.word	0x00030c98
   1ff88:	00030ca0 	.word	0x00030ca0
   1ff8c:	020fbd68 	.word	0x020fbd68
   1ff90:	00030cb0 	.word	0x00030cb0
   1ff94:	00030cb8 	.word	0x00030cb8
   1ff98:	42c80000 	.word	0x42c80000
   1ff9c:	00030ca8 	.word	0x00030ca8
   1ffa0:	447a0000 	.word	0x447a0000
   1ffa4:	3f7ffeb0 	.word	0x3f7ffeb0
   1ffa8:	020fabc0 	.word	0x020fabc0
   1ffac:	020fa204 	.word	0x020fa204
   1ffb0:	020e52f8 	.word	0x020e52f8
   1ffb4:	3c23d70a 	.word	0x3c23d70a
   1ffb8:	020fa034 	.word	0x020fa034
   1ffbc:	020f9de8 	.word	0x020f9de8
   1ffc0:	000627ac 	.word	0x000627ac
   1ffc4:	020e2ed4 	.word	0x020e2ed4
   1ffc8:	020e2dd8 	.word	0x020e2dd8
   1ffcc:	020f9db0 	.word	0x020f9db0
   1ffd0:	020e5d34 	.word	0x020e5d34
   1ffd4:	020f9df0 	.word	0x020f9df0

0001ffd8 <SFXRhodesFrame>:
        {
   1ffd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1ffdc:	4ce0      	ldr	r4, [pc, #896]	; (20360 <SFXRhodesFrame+0x388>)
        {
   1ffde:	ed2d 8b04 	vpush	{d8-d9}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1ffe2:	7d23      	ldrb	r3, [r4, #20]
        {
   1ffe4:	b083      	sub	sp, #12
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1ffe6:	2b01      	cmp	r3, #1
   1ffe8:	f000 8456 	beq.w	20898 <SFXRhodesFrame+0x8c0>
   1ffec:	4bdd      	ldr	r3, [pc, #884]	; (20364 <SFXRhodesFrame+0x38c>)
   1ffee:	9301      	str	r3, [sp, #4]
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1fff0:	7e23      	ldrb	r3, [r4, #24]
   1fff2:	2b01      	cmp	r3, #1
   1fff4:	d10e      	bne.n	20014 <SFXRhodesFrame+0x3c>
                Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
   1fff6:	48dc      	ldr	r0, [pc, #880]	; (20368 <SFXRhodesFrame+0x390>)
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1fff8:	2100      	movs	r1, #0
                Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
   1fffa:	4adc      	ldr	r2, [pc, #880]	; (2036c <SFXRhodesFrame+0x394>)
   1fffc:	6803      	ldr	r3, [r0, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
   1fffe:	7621      	strb	r1, [r4, #24]
                Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
   20000:	3301      	adds	r3, #1
   20002:	fb82 2103 	smull	r2, r1, r2, r3
   20006:	17da      	asrs	r2, r3, #31
   20008:	ebc2 0261 	rsb	r2, r2, r1, asr #1
   2000c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   20010:	1a9b      	subs	r3, r3, r2
   20012:	6003      	str	r3, [r0, #0]
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   20014:	7f23      	ldrb	r3, [r4, #28]
   20016:	2b01      	cmp	r3, #1
   20018:	f000 8455 	beq.w	208c6 <SFXRhodesFrame+0x8ee>
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   2001c:	4dd4      	ldr	r5, [pc, #848]	; (20370 <SFXRhodesFrame+0x398>)
   2001e:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20022:	4bd4      	ldr	r3, [pc, #848]	; (20374 <SFXRhodesFrame+0x39c>)
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   20024:	eeb2 2a04 	vmov.f32	s4, #36	; 0x41200000  10.0
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   20028:	ed95 6a08 	vldr	s12, [r5, #32]
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   2002c:	4628      	mov	r0, r5
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   2002e:	edd3 6a00 	vldr	s13, [r3]
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   20032:	eefa 0a04 	vmov.f32	s1, #164	; 0xc1200000 -10.0
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20036:	ed95 7a05 	vldr	s14, [r5, #20]
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   2003a:	edd5 7a06 	vldr	s15, [r5, #24]
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   2003e:	ee26 7a87 	vmul.f32	s14, s13, s14
   20042:	49cd      	ldr	r1, [pc, #820]	; (20378 <SFXRhodesFrame+0x3a0>)
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   20044:	ee66 7aa7 	vmul.f32	s15, s13, s15
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   20048:	ecf0 3a01 	vldmia	r0!, {s7}
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   2004c:	ee66 6a86 	vmul.f32	s13, s13, s12
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   20050:	edd5 4a03 	vldr	s9, [r5, #12]
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20054:	eebd 7ac7 	vcvt.s32.f32	s14, s14
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   20058:	ed9f 1ac8 	vldr	s2, [pc, #800]	; 2037c <SFXRhodesFrame+0x3a4>
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   2005c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20060:	eddf 2ac7 	vldr	s5, [pc, #796]	; 20380 <SFXRhodesFrame+0x3a8>
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   20064:	eefd 6ae6 	vcvt.s32.f32	s13, s13
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   20068:	ed95 6a0a 	vldr	s12, [r5, #40]	; 0x28
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   2006c:	ee17 2a10 	vmov	r2, s14
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   20070:	ee63 3aa5 	vmul.f32	s7, s7, s11
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   20074:	ee17 3a90 	vmov	r3, s15
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   20078:	eddf 7ac2 	vldr	s15, [pc, #776]	; 20384 <SFXRhodesFrame+0x3ac>
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   2007c:	ee16 4a90 	vmov	r4, s13
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20080:	eb01 0282 	add.w	r2, r1, r2, lsl #2
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   20084:	eb01 0383 	add.w	r3, r1, r3, lsl #2
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   20088:	ee64 4aa7 	vmul.f32	s9, s9, s15
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   2008c:	eb01 0184 	add.w	r1, r1, r4, lsl #2
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20090:	ed92 3a00 	vldr	s6, [r2]
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   20094:	ed93 5a00 	vldr	s10, [r3]
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   20098:	ee66 6a01 	vmul.f32	s13, s12, s2
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   2009c:	edd1 5a00 	vldr	s11, [r1]
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   200a0:	ee23 3a22 	vmul.f32	s6, s6, s5
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   200a4:	ed95 4a02 	vldr	s8, [r5, #8]
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   200a8:	ee25 5a22 	vmul.f32	s10, s10, s5
            FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
   200ac:	ed95 7a0b 	vldr	s14, [r5, #44]	; 0x2c
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   200b0:	ee65 5aa2 	vmul.f32	s11, s11, s5
            FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
   200b4:	edd5 7a0c 	vldr	s15, [r5, #48]	; 0x30
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   200b8:	ee24 4a02 	vmul.f32	s8, s8, s4
            FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
   200bc:	ee27 7a01 	vmul.f32	s14, s14, s2
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   200c0:	4cb1      	ldr	r4, [pc, #708]	; (20388 <SFXRhodesFrame+0x3b0>)
            FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
   200c2:	ee67 7a81 	vmul.f32	s15, s15, s2
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   200c6:	4eb1      	ldr	r6, [pc, #708]	; (2038c <SFXRhodesFrame+0x3b4>)
            displayValues[9] = presetKnobValues[Rhodes][9];
   200c8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
            displayValues[1] = presetKnobValues[Rhodes][1]; // tremelo amount
   200ca:	6800      	ldr	r0, [r0, #0]
            displayValues[4] = presetKnobValues[Rhodes][4]; //pan spread
   200cc:	6929      	ldr	r1, [r5, #16]
            displayValues[7] = presetKnobValues[Rhodes][7];
   200ce:	69ea      	ldr	r2, [r5, #28]
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   200d0:	ed84 4a02 	vstr	s8, [r4, #8]
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   200d4:	edc4 5a08 	vstr	s11, [r4, #32]
            displayValues[9] = presetKnobValues[Rhodes][9];
   200d8:	6263      	str	r3, [r4, #36]	; 0x24
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   200da:	ed84 3a05 	vstr	s6, [r4, #20]
            displayValues[1] = presetKnobValues[Rhodes][1]; // tremelo amount
   200de:	6060      	str	r0, [r4, #4]
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   200e0:	edc4 3a00 	vstr	s7, [r4]
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   200e4:	edc4 4a03 	vstr	s9, [r4, #12]
            displayValues[4] = presetKnobValues[Rhodes][4]; //pan spread
   200e8:	6121      	str	r1, [r4, #16]
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   200ea:	ed84 5a06 	vstr	s10, [r4, #24]
            displayValues[7] = presetKnobValues[Rhodes][7];
   200ee:	61e2      	str	r2, [r4, #28]
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   200f0:	edc4 6a0a 	vstr	s13, [r4, #40]	; 0x28
   200f4:	edc6 6a18 	vstr	s13, [r6, #96]	; 0x60
            FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
   200f8:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c
   200fc:	ed86 7a19 	vstr	s14, [r6, #100]	; 0x64
            FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
   20100:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
   20104:	edc6 7a1a 	vstr	s15, [r6, #104]	; 0x68
            FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
   20108:	ed95 7a0d 	vldr	s14, [r5, #52]	; 0x34
            FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
   2010c:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
            FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
   20110:	ee27 7a01 	vmul.f32	s14, s14, s2
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   20114:	edd5 6a15 	vldr	s13, [r5, #84]	; 0x54
            FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
   20118:	ee67 7a81 	vmul.f32	s15, s15, s2
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2011c:	f8df 8294 	ldr.w	r8, [pc, #660]	; 203b4 <SFXRhodesFrame+0x3dc>
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   20120:	eee6 0a81 	vfma.f32	s1, s13, s2
   20124:	ed9f 0a9a 	vldr	s0, [pc, #616]	; 20390 <SFXRhodesFrame+0x3b8>
            FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
   20128:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
   2012c:	ed86 7a1b 	vstr	s14, [r6, #108]	; 0x6c
            FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
   20130:	edc4 7a0e 	vstr	s15, [r4, #56]	; 0x38
   20134:	edc6 7a1c 	vstr	s15, [r6, #112]	; 0x70
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   20138:	f009 faf6 	bl	29728 <LEAF_clip>
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2013c:	ed95 4a0f 	vldr	s8, [r5, #60]	; 0x3c
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20140:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   20144:	edd8 6a0f 	vldr	s13, [r8, #60]	; 0x3c
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20148:	4b92      	ldr	r3, [pc, #584]	; (20394 <SFXRhodesFrame+0x3bc>)
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2014a:	eef4 6a44 	vcmp.f32	s13, s8
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   2014e:	ed84 0a15 	vstr	s0, [r4, #84]	; 0x54
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20152:	ed93 7a00 	vldr	s14, [r3]
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   20156:	ed86 0a1d 	vstr	s0, [r6, #116]	; 0x74
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2015a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2015e:	ee75 7ac7 	vsub.f32	s15, s11, s14
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   20162:	d01a      	beq.n	2019a <SFXRhodesFrame+0x1c2>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20164:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   20168:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   2016c:	ee74 6a66 	vsub.f32	s13, s8, s13
   20170:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20174:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
   20178:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2017c:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20180:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
   20184:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20188:	f100 83ca 	bmi.w	20920 <SFXRhodesFrame+0x948>
                    else rate += 1.0f;
   2018c:	ee36 6a25 	vadd.f32	s12, s12, s11
                    FM_freqRatios[4][k-15] = rate;
   20190:	4a81      	ldr	r2, [pc, #516]	; (20398 <SFXRhodesFrame+0x3c0>)
                    displayValues[k] = rate;
   20192:	ed84 6a0f 	vstr	s12, [r4, #60]	; 0x3c
                    FM_freqRatios[4][k-15] = rate;
   20196:	ed82 6a18 	vstr	s12, [r2, #96]	; 0x60
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2019a:	4a80      	ldr	r2, [pc, #512]	; (2039c <SFXRhodesFrame+0x3c4>)
   2019c:	edd8 6a10 	vldr	s13, [r8, #64]	; 0x40
   201a0:	edd2 4a00 	vldr	s9, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
   201a4:	ed88 4a0f 	vstr	s8, [r8, #60]	; 0x3c
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   201a8:	eef4 6a64 	vcmp.f32	s13, s9
   201ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   201b0:	d01e      	beq.n	201f0 <SFXRhodesFrame+0x218>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   201b2:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   201b6:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   201ba:	ee74 6ae6 	vsub.f32	s13, s9, s13
   201be:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   201c2:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
   201c6:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   201ca:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   201ce:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   201d2:	eef0 6a46 	vmov.f32	s13, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   201d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   201da:	f100 83a8 	bmi.w	2092e <SFXRhodesFrame+0x956>
                    else rate += 1.0f;
   201de:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   201e2:	ee36 6a86 	vadd.f32	s12, s13, s12
                    FM_freqRatios[4][k-15] = rate;
   201e6:	4a6c      	ldr	r2, [pc, #432]	; (20398 <SFXRhodesFrame+0x3c0>)
                    displayValues[k] = rate;
   201e8:	ed84 6a10 	vstr	s12, [r4, #64]	; 0x40
                    FM_freqRatios[4][k-15] = rate;
   201ec:	ed82 6a19 	vstr	s12, [r2, #100]	; 0x64
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   201f0:	4a6b      	ldr	r2, [pc, #428]	; (203a0 <SFXRhodesFrame+0x3c8>)
   201f2:	edd8 6a11 	vldr	s13, [r8, #68]	; 0x44
   201f6:	ed92 5a00 	vldr	s10, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
   201fa:	edc8 4a10 	vstr	s9, [r8, #64]	; 0x40
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   201fe:	eef4 6a45 	vcmp.f32	s13, s10
   20202:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20206:	d01e      	beq.n	20246 <SFXRhodesFrame+0x26e>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20208:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   2020c:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   20210:	ee75 6a66 	vsub.f32	s13, s10, s13
   20214:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20218:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
   2021c:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20220:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20224:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20228:	eef0 6a46 	vmov.f32	s13, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2022c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20230:	f100 8386 	bmi.w	20940 <SFXRhodesFrame+0x968>
                    else rate += 1.0f;
   20234:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   20238:	ee36 6a86 	vadd.f32	s12, s13, s12
                    FM_freqRatios[4][k-15] = rate;
   2023c:	4a56      	ldr	r2, [pc, #344]	; (20398 <SFXRhodesFrame+0x3c0>)
                    displayValues[k] = rate;
   2023e:	ed84 6a11 	vstr	s12, [r4, #68]	; 0x44
                    FM_freqRatios[4][k-15] = rate;
   20242:	ed82 6a1a 	vstr	s12, [r2, #104]	; 0x68
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   20246:	4a57      	ldr	r2, [pc, #348]	; (203a4 <SFXRhodesFrame+0x3cc>)
   20248:	edd8 6a12 	vldr	s13, [r8, #72]	; 0x48
   2024c:	edd2 5a00 	vldr	s11, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
   20250:	ed88 5a11 	vstr	s10, [r8, #68]	; 0x44
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   20254:	eef4 6a65 	vcmp.f32	s13, s11
   20258:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2025c:	d01e      	beq.n	2029c <SFXRhodesFrame+0x2c4>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2025e:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   20262:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   20266:	ee75 6ae6 	vsub.f32	s13, s11, s13
   2026a:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2026e:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
   20272:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20276:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2027a:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2027e:	eef0 6a46 	vmov.f32	s13, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20282:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20286:	f100 832b 	bmi.w	208e0 <SFXRhodesFrame+0x908>
                    else rate += 1.0f;
   2028a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2028e:	ee36 6a86 	vadd.f32	s12, s13, s12
                    FM_freqRatios[4][k-15] = rate;
   20292:	4a41      	ldr	r2, [pc, #260]	; (20398 <SFXRhodesFrame+0x3c0>)
                    displayValues[k] = rate;
   20294:	ed84 6a12 	vstr	s12, [r4, #72]	; 0x48
                    FM_freqRatios[4][k-15] = rate;
   20298:	ed82 6a1b 	vstr	s12, [r2, #108]	; 0x6c
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2029c:	4a42      	ldr	r2, [pc, #264]	; (203a8 <SFXRhodesFrame+0x3d0>)
   2029e:	edd8 6a13 	vldr	s13, [r8, #76]	; 0x4c
   202a2:	ed92 6a00 	vldr	s12, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
   202a6:	edc8 5a12 	vstr	s11, [r8, #72]	; 0x48
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   202aa:	eef4 6a46 	vcmp.f32	s13, s12
   202ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   202b2:	d01e      	beq.n	202f2 <SFXRhodesFrame+0x31a>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   202b4:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   202b8:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
   202bc:	ee76 6a66 	vsub.f32	s13, s12, s13
   202c0:	ee66 6aa3 	vmul.f32	s13, s13, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   202c4:	ee67 3aa6 	vmul.f32	s7, s15, s13
                    float snapRate = roundf(rawRate);
   202c8:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   202cc:	eee7 3a26 	vfma.f32	s7, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   202d0:	eef5 3ac0 	vcmpe.f32	s7, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   202d4:	eef0 6a63 	vmov.f32	s13, s7
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   202d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   202dc:	f100 8309 	bmi.w	208f2 <SFXRhodesFrame+0x91a>
                    else rate += 1.0f;
   202e0:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
   202e4:	ee76 3aa3 	vadd.f32	s7, s13, s7
                    FM_freqRatios[4][k-15] = rate;
   202e8:	4a2b      	ldr	r2, [pc, #172]	; (20398 <SFXRhodesFrame+0x3c0>)
                    displayValues[k] = rate;
   202ea:	edc4 3a13 	vstr	s7, [r4, #76]	; 0x4c
                    FM_freqRatios[4][k-15] = rate;
   202ee:	edc2 3a1c 	vstr	s7, [r2, #112]	; 0x70
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   202f2:	4a2e      	ldr	r2, [pc, #184]	; (203ac <SFXRhodesFrame+0x3d4>)
   202f4:	edd8 3a14 	vldr	s7, [r8, #80]	; 0x50
   202f8:	edd2 6a00 	vldr	s13, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
   202fc:	ed88 6a13 	vstr	s12, [r8, #76]	; 0x4c
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   20300:	eef4 6a63 	vcmp.f32	s13, s7
   20304:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20308:	d01c      	beq.n	20344 <SFXRhodesFrame+0x36c>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2030a:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
   2030e:	eeb2 3a0c 	vmov.f32	s6, #44	; 0x41600000  14.0
   20312:	ee76 3ae3 	vsub.f32	s7, s13, s7
   20316:	ee63 3a83 	vmul.f32	s7, s7, s6
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2031a:	ee67 7aa3 	vmul.f32	s15, s15, s7
                    float snapRate = roundf(rawRate);
   2031e:	fef8 3a63 	vrinta.f32	s7, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20322:	eee7 7a23 	vfma.f32	s15, s14, s7
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20326:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2032a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2032e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20332:	f100 82e7 	bmi.w	20904 <SFXRhodesFrame+0x92c>
                    else rate += 1.0f;
   20336:	ee77 7a87 	vadd.f32	s15, s15, s14
                    FM_freqRatios[4][k-15] = rate;
   2033a:	4a17      	ldr	r2, [pc, #92]	; (20398 <SFXRhodesFrame+0x3c0>)
                    displayValues[k] = rate;
   2033c:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
                    FM_freqRatios[4][k-15] = rate;
   20340:	edc2 7a1d 	vstr	s15, [r2, #116]	; 0x74
            if (presetKnobValues[Rhodes][22] != prevKnobValues[22])
   20344:	4a1a      	ldr	r2, [pc, #104]	; (203b0 <SFXRhodesFrame+0x3d8>)
   20346:	edd8 7a16 	vldr	s15, [r8, #88]	; 0x58
   2034a:	ed92 7a00 	vldr	s14, [r2]
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
   2034e:	edc8 6a14 	vstr	s13, [r8, #80]	; 0x50
            if (presetKnobValues[Rhodes][22] != prevKnobValues[22])
   20352:	eeb4 7a67 	vcmp.f32	s14, s15
   20356:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2035a:	f000 80e4 	beq.w	20526 <SFXRhodesFrame+0x54e>
   2035e:	e02b      	b.n	203b8 <SFXRhodesFrame+0x3e0>
   20360:	020fafac 	.word	0x020fafac
   20364:	000627ac 	.word	0x000627ac
   20368:	020e2dd8 	.word	0x020e2dd8
   2036c:	66666667 	.word	0x66666667
   20370:	020e5c7c 	.word	0x020e5c7c
   20374:	00062794 	.word	0x00062794
   20378:	020f990c 	.word	0x020f990c
   2037c:	447a0000 	.word	0x447a0000
   20380:	46000000 	.word	0x46000000
   20384:	3fa66666 	.word	0x3fa66666
   20388:	020fb05c 	.word	0x020fb05c
   2038c:	00062610 	.word	0x00062610
   20390:	00000000 	.word	0x00000000
   20394:	000627b4 	.word	0x000627b4
   20398:	00062598 	.word	0x00062598
   2039c:	020e5cbc 	.word	0x020e5cbc
   203a0:	020e5cc0 	.word	0x020e5cc0
   203a4:	020e5cc4 	.word	0x020e5cc4
   203a8:	020e5cc8 	.word	0x020e5cc8
   203ac:	020e5ccc 	.word	0x020e5ccc
   203b0:	020e5cd4 	.word	0x020e5cd4
   203b4:	020f9f9c 	.word	0x020f9f9c
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   203b8:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
                overtoneSnap = displayValues[22] = presetKnobValues[Rhodes][22];
   203bc:	ed84 7a16 	vstr	s14, [r4, #88]	; 0x58
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   203c0:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
                overtoneSnap = displayValues[22] = presetKnobValues[Rhodes][22];
   203c4:	ed83 7a00 	vstr	s14, [r3]
   203c8:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   203cc:	ee34 4a67 	vsub.f32	s8, s8, s15
   203d0:	ee73 7a47 	vsub.f32	s15, s6, s14
   203d4:	ee24 4a23 	vmul.f32	s8, s8, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   203d8:	ee64 3a27 	vmul.f32	s7, s8, s15
                    float snapRate = roundf(rawRate);
   203dc:	feb8 4a44 	vrinta.f32	s8, s8
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   203e0:	eee7 3a04 	vfma.f32	s7, s14, s8
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   203e4:	eef5 3ac0 	vcmpe.f32	s7, #0.0
   203e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   203ec:	f100 8291 	bmi.w	20912 <SFXRhodesFrame+0x93a>
                    else rate += 1.0f;
   203f0:	ee33 4a83 	vadd.f32	s8, s7, s6
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   203f4:	eeb6 3a00 	vmov.f32	s6, #96	; 0x3f000000  0.5
                    FM_freqRatios[4][k-15] = rate;
   203f8:	4bbd      	ldr	r3, [pc, #756]	; (206f0 <SFXRhodesFrame+0x718>)
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   203fa:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
                    displayValues[k] = rate;
   203fe:	ed84 4a0f 	vstr	s8, [r4, #60]	; 0x3c
                    FM_freqRatios[4][k-15] = rate;
   20402:	ed83 4a18 	vstr	s8, [r3, #96]	; 0x60
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20406:	ee74 4ac3 	vsub.f32	s9, s9, s6
   2040a:	ee64 4aa3 	vmul.f32	s9, s9, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2040e:	ee24 4aa7 	vmul.f32	s8, s9, s15
                    float snapRate = roundf(rawRate);
   20412:	fef8 4a64 	vrinta.f32	s9, s9
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20416:	eea7 4a24 	vfma.f32	s8, s14, s9
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2041a:	eeb5 4ac0 	vcmpe.f32	s8, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2041e:	eef0 4a44 	vmov.f32	s9, s8
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20422:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
   20426:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2042a:	f100 82ae 	bmi.w	2098a <SFXRhodesFrame+0x9b2>
                    else rate += 1.0f;
   2042e:	ee74 4a84 	vadd.f32	s9, s9, s8
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20432:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
   20436:	edc4 4a10 	vstr	s9, [r4, #64]	; 0x40
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2043a:	eeb2 4a0c 	vmov.f32	s8, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
   2043e:	edc3 4a19 	vstr	s9, [r3, #100]	; 0x64
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20442:	ee35 5a63 	vsub.f32	s10, s10, s7
   20446:	ee25 5a04 	vmul.f32	s10, s10, s8
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2044a:	ee65 4a27 	vmul.f32	s9, s10, s15
                    float snapRate = roundf(rawRate);
   2044e:	feb8 5a45 	vrinta.f32	s10, s10
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20452:	eee7 4a05 	vfma.f32	s9, s14, s10
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20456:	eef5 4ac0 	vcmpe.f32	s9, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2045a:	eeb0 5a64 	vmov.f32	s10, s9
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2045e:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
   20462:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20466:	f100 8289 	bmi.w	2097c <SFXRhodesFrame+0x9a4>
                    else rate += 1.0f;
   2046a:	ee35 5a24 	vadd.f32	s10, s10, s9
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2046e:	eeb6 4a00 	vmov.f32	s8, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
   20472:	ed84 5a11 	vstr	s10, [r4, #68]	; 0x44
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20476:	eef2 4a0c 	vmov.f32	s9, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
   2047a:	ed83 5a1a 	vstr	s10, [r3, #104]	; 0x68
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2047e:	ee75 5ac4 	vsub.f32	s11, s11, s8
   20482:	ee65 5aa4 	vmul.f32	s11, s11, s9
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20486:	ee25 5aa7 	vmul.f32	s10, s11, s15
                    float snapRate = roundf(rawRate);
   2048a:	fef8 5a65 	vrinta.f32	s11, s11
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2048e:	eea7 5a25 	vfma.f32	s10, s14, s11
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20492:	eeb5 5ac0 	vcmpe.f32	s10, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20496:	eef0 5a45 	vmov.f32	s11, s10
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2049a:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   2049e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   204a2:	f100 8264 	bmi.w	2096e <SFXRhodesFrame+0x996>
                    else rate += 1.0f;
   204a6:	ee75 5a85 	vadd.f32	s11, s11, s10
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204aa:	eef6 4a00 	vmov.f32	s9, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
   204ae:	edc4 5a12 	vstr	s11, [r4, #72]	; 0x48
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204b2:	eeb2 5a0c 	vmov.f32	s10, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
   204b6:	edc3 5a1b 	vstr	s11, [r3, #108]	; 0x6c
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204ba:	ee36 6a64 	vsub.f32	s12, s12, s9
   204be:	ee26 6a05 	vmul.f32	s12, s12, s10
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   204c2:	ee66 5a27 	vmul.f32	s11, s12, s15
                    float snapRate = roundf(rawRate);
   204c6:	feb8 6a46 	vrinta.f32	s12, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   204ca:	eee7 5a06 	vfma.f32	s11, s14, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   204ce:	eef5 5ac0 	vcmpe.f32	s11, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   204d2:	eeb0 6a65 	vmov.f32	s12, s11
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   204d6:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   204da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   204de:	f100 823f 	bmi.w	20960 <SFXRhodesFrame+0x988>
                    else rate += 1.0f;
   204e2:	ee36 6a25 	vadd.f32	s12, s12, s11
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204e6:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
   204ea:	ed84 6a13 	vstr	s12, [r4, #76]	; 0x4c
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204ee:	eef2 5a0c 	vmov.f32	s11, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
   204f2:	ed83 6a1c 	vstr	s12, [r3, #112]	; 0x70
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204f6:	ee76 6ac5 	vsub.f32	s13, s13, s10
   204fa:	ee66 6aa5 	vmul.f32	s13, s13, s11
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   204fe:	ee66 7aa7 	vmul.f32	s15, s13, s15
                    float snapRate = roundf(rawRate);
   20502:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20506:	eee7 7a26 	vfma.f32	s15, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2050a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2050e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   20512:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20516:	f100 821c 	bmi.w	20952 <SFXRhodesFrame+0x97a>
                    else rate += 1.0f;
   2051a:	ee77 7aa6 	vadd.f32	s15, s15, s13
                    displayValues[k] = rate;
   2051e:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
                    FM_freqRatios[4][k-15] = rate;
   20522:	edc3 7a1d 	vstr	s15, [r3, #116]	; 0x74
            displayValues[23] = presetKnobValues[Rhodes][23];
   20526:	4b73      	ldr	r3, [pc, #460]	; (206f4 <SFXRhodesFrame+0x71c>)
            prevKnobValues[22] = presetKnobValues[Rhodes][22];
   20528:	ed88 7a16 	vstr	s14, [r8, #88]	; 0x58
            displayValues[23] = presetKnobValues[Rhodes][23];
   2052c:	edd3 7a00 	vldr	s15, [r3]
            if (prevDisplayValues[23] != displayValues[23])
   20530:	4b71      	ldr	r3, [pc, #452]	; (206f8 <SFXRhodesFrame+0x720>)
            displayValues[23] = presetKnobValues[Rhodes][23];
   20532:	edc4 7a17 	vstr	s15, [r4, #92]	; 0x5c
            if (prevDisplayValues[23] != displayValues[23])
   20536:	edd3 6a17 	vldr	s13, [r3, #92]	; 0x5c
   2053a:	eef4 7a66 	vcmp.f32	s15, s13
   2053e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20542:	d03b      	beq.n	205bc <SFXRhodesFrame+0x5e4>
   20544:	f8df 91e0 	ldr.w	r9, [pc, #480]	; 20728 <SFXRhodesFrame+0x750>
                    randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
   20548:	eeb0 9a00 	vmov.f32	s18, #0	; 0x40000000  2.0
   2054c:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
   20550:	4f6a      	ldr	r7, [pc, #424]	; (206fc <SFXRhodesFrame+0x724>)
   20552:	f109 0518 	add.w	r5, r9, #24
            if (prevDisplayValues[23] != displayValues[23])
   20556:	464e      	mov	r6, r9
                    randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
   20558:	ed9f 8a69 	vldr	s16, [pc, #420]	; 20700 <SFXRhodesFrame+0x728>
                    float randomNumberDraw = (leaf.random() * 2.0f) + 0.08f;
   2055c:	693b      	ldr	r3, [r7, #16]
   2055e:	4798      	blx	r3
                    randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
   20560:	eeb0 7a48 	vmov.f32	s14, s16
   20564:	eef0 6a68 	vmov.f32	s13, s17
   20568:	edd4 7a17 	vldr	s15, [r4, #92]	; 0x5c
   2056c:	eea0 7a09 	vfma.f32	s14, s0, s18
   20570:	eee7 6a27 	vfma.f32	s13, s14, s15
   20574:	ece6 6a01 	vstmia	r6!, {s13}
                for (int i = 0; i < 6; i++)
   20578:	42ae      	cmp	r6, r5
   2057a:	d1ef      	bne.n	2055c <SFXRhodesFrame+0x584>
   2057c:	4f61      	ldr	r7, [pc, #388]	; (20704 <SFXRhodesFrame+0x72c>)
                        tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(10.0f, displayValues[6] * randomDecays[j], 20000.0f))); //FM_decays[Rsound][j] * displayValues[6]);
   2057e:	ed9f 8a62 	vldr	s16, [pc, #392]	; 20708 <SFXRhodesFrame+0x730>
   20582:	f107 0ac0 	add.w	sl, r7, #192	; 0xc0
            if (prevDisplayValues[23] != displayValues[23])
   20586:	46bb      	mov	fp, r7
   20588:	464d      	mov	r5, r9
                        tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(10.0f, displayValues[6] * randomDecays[j], 20000.0f))); //FM_decays[Rsound][j] * displayValues[6]);
   2058a:	ecf5 0a01 	vldmia	r5!, {s1}
   2058e:	eeb0 1a48 	vmov.f32	s2, s16
   20592:	edd4 7a06 	vldr	s15, [r4, #24]
   20596:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   2059a:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2059e:	f009 f8c3 	bl	29728 <LEAF_clip>
   205a2:	4658      	mov	r0, fp
   205a4:	f007 f8a4 	bl	276f0 <tADSR4_setDecay>
                    for (int j = 0; j < 6; j++)
   205a8:	42b5      	cmp	r5, r6
   205aa:	f10b 0b04 	add.w	fp, fp, #4
   205ae:	d1ec      	bne.n	2058a <SFXRhodesFrame+0x5b2>
   205b0:	3718      	adds	r7, #24
                for (int i = 0; i < NUM_VOC_VOICES; i++)
   205b2:	4557      	cmp	r7, sl
   205b4:	d1e7      	bne.n	20586 <SFXRhodesFrame+0x5ae>
   205b6:	4b4f      	ldr	r3, [pc, #316]	; (206f4 <SFXRhodesFrame+0x71c>)
   205b8:	edd3 6a00 	vldr	s13, [r3]
            displayValues[24] = presetKnobValues[Rhodes][24];
   205bc:	4b53      	ldr	r3, [pc, #332]	; (2070c <SFXRhodesFrame+0x734>)
            if (prevDisplayValues[24] != displayValues[24])
   205be:	4a4e      	ldr	r2, [pc, #312]	; (206f8 <SFXRhodesFrame+0x720>)
            displayValues[24] = presetKnobValues[Rhodes][24];
   205c0:	ed93 7a00 	vldr	s14, [r3]
            if (prevDisplayValues[24] != displayValues[24])
   205c4:	edd2 7a18 	vldr	s15, [r2, #96]	; 0x60
            prevKnobValues[23] = presetKnobValues[Rhodes][23];
   205c8:	edc8 6a17 	vstr	s13, [r8, #92]	; 0x5c
            if (prevDisplayValues[24] != displayValues[24])
   205cc:	eeb4 7a67 	vcmp.f32	s14, s15
            displayValues[24] = presetKnobValues[Rhodes][24];
   205d0:	ed84 7a18 	vstr	s14, [r4, #96]	; 0x60
            if (prevDisplayValues[24] != displayValues[24])
   205d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   205d8:	d024      	beq.n	20624 <SFXRhodesFrame+0x64c>
   205da:	4d4d      	ldr	r5, [pc, #308]	; (20710 <SFXRhodesFrame+0x738>)
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   205dc:	eeb0 9a00 	vmov.f32	s18, #0	; 0x40000000  2.0
   205e0:	eeff 8a00 	vmov.f32	s17, #240	; 0xbf800000 -1.0
   205e4:	4e4b      	ldr	r6, [pc, #300]	; (20714 <SFXRhodesFrame+0x73c>)
   205e6:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   205ea:	f105 0818 	add.w	r8, r5, #24
   205ee:	4f43      	ldr	r7, [pc, #268]	; (206fc <SFXRhodesFrame+0x724>)
                    float randomNumberDraw = leaf.random() * 2.0f;
   205f0:	693b      	ldr	r3, [r7, #16]
   205f2:	4798      	blx	r3
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   205f4:	eeb0 7a68 	vmov.f32	s14, s17
   205f8:	eef0 6a48 	vmov.f32	s13, s16
   205fc:	edd4 7a18 	vldr	s15, [r4, #96]	; 0x60
                    tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   20600:	4630      	mov	r0, r6
   20602:	3604      	adds	r6, #4
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   20604:	eea0 7a09 	vfma.f32	s14, s0, s18
                    tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   20608:	ed94 0a07 	vldr	s0, [r4, #28]
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   2060c:	eee7 6a27 	vfma.f32	s13, s14, s15
   20610:	ece5 6a01 	vstmia	r5!, {s13}
                    tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   20614:	ee26 0a80 	vmul.f32	s0, s13, s0
   20618:	f007 fbf2 	bl	27e00 <tExpSmooth_setDest>
                for (int i = 0; i < 6; i++)
   2061c:	4545      	cmp	r5, r8
   2061e:	d1e7      	bne.n	205f0 <SFXRhodesFrame+0x618>
   20620:	edd4 7a18 	vldr	s15, [r4, #96]	; 0x60
            prevDisplayValues[24] = displayValues[24];
   20624:	4b34      	ldr	r3, [pc, #208]	; (206f8 <SFXRhodesFrame+0x720>)
   20626:	f04f 0806 	mov.w	r8, #6
   2062a:	f8df a100 	ldr.w	sl, [pc, #256]	; 2072c <SFXRhodesFrame+0x754>
   2062e:	f103 0714 	add.w	r7, r3, #20
   20632:	4e39      	ldr	r6, [pc, #228]	; (20718 <SFXRhodesFrame+0x740>)
                                    tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
   20634:	ed9f 8a34 	vldr	s16, [pc, #208]	; 20708 <SFXRhodesFrame+0x730>
            prevDisplayValues[24] = displayValues[24];
   20638:	edc3 7a18 	vstr	s15, [r3, #96]	; 0x60
                if (prevDisplayValues[k] != displayValues[k])
   2063c:	ecb7 7a01 	vldmia	r7!, {s14}
   20640:	ecfa 7a01 	vldmia	sl!, {s15}
   20644:	eeb4 7a67 	vcmp.f32	s14, s15
   20648:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2064c:	d01a      	beq.n	20684 <SFXRhodesFrame+0x6ac>
                    switch(k)
   2064e:	f1a8 0307 	sub.w	r3, r8, #7
   20652:	2b03      	cmp	r3, #3
   20654:	d805      	bhi.n	20662 <SFXRhodesFrame+0x68a>
   20656:	e8df f013 	tbh	[pc, r3, lsl #1]
   2065a:	00fd      	.short	0x00fd
   2065c:	00d200e6 	.word	0x00d200e6
   20660:	001d      	.short	0x001d
   20662:	4d28      	ldr	r5, [pc, #160]	; (20704 <SFXRhodesFrame+0x72c>)
   20664:	f105 0bc0 	add.w	fp, r5, #192	; 0xc0
   20668:	f105 0918 	add.w	r9, r5, #24
                                    tADSR4_setAttack(&FM_envs[i][j], displayValues[5] );
   2066c:	4628      	mov	r0, r5
   2066e:	3504      	adds	r5, #4
   20670:	ed94 0a05 	vldr	s0, [r4, #20]
   20674:	f007 f82e 	bl	276d4 <tADSR4_setAttack>
                                for (int j = 0; j < 6; j++)
   20678:	45a9      	cmp	r9, r5
   2067a:	d1f7      	bne.n	2066c <SFXRhodesFrame+0x694>
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
   2067c:	45d9      	cmp	r9, fp
   2067e:	d1f3      	bne.n	20668 <SFXRhodesFrame+0x690>
   20680:	ed5a 7a01 	vldr	s15, [sl, #-4]
            for (int k = 5; k < 10; k++)
   20684:	f1b8 0f0a 	cmp.w	r8, #10
                prevDisplayValues[k] = displayValues[k];
   20688:	ed47 7a01 	vstr	s15, [r7, #-4]
            for (int k = 5; k < 10; k++)
   2068c:	d020      	beq.n	206d0 <SFXRhodesFrame+0x6f8>
   2068e:	f108 0801 	add.w	r8, r8, #1
   20692:	e7d3      	b.n	2063c <SFXRhodesFrame+0x664>
   20694:	4d1b      	ldr	r5, [pc, #108]	; (20704 <SFXRhodesFrame+0x72c>)
                                    tADSR4_setLeakFactor(&FM_envs[i][j], ((1.0f - displayValues[9])  * 0.00004f) + 0.99996f);
   20696:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   2069a:	eddf 8a20 	vldr	s17, [pc, #128]	; 2071c <SFXRhodesFrame+0x744>
   2069e:	f105 07c0 	add.w	r7, r5, #192	; 0xc0
   206a2:	ed9f 8a1f 	vldr	s16, [pc, #124]	; 20720 <SFXRhodesFrame+0x748>
   206a6:	f105 0618 	add.w	r6, r5, #24
   206aa:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   206ae:	eeb0 0a48 	vmov.f32	s0, s16
   206b2:	4628      	mov	r0, r5
   206b4:	3504      	adds	r5, #4
   206b6:	ee79 7a67 	vsub.f32	s15, s18, s15
   206ba:	eea7 0aa8 	vfma.f32	s0, s15, s17
   206be:	f007 f849 	bl	27754 <tADSR4_setLeakFactor>
                                for (int j = 0; j < 6; j++)
   206c2:	42b5      	cmp	r5, r6
   206c4:	d1f1      	bne.n	206aa <SFXRhodesFrame+0x6d2>
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
   206c6:	42bd      	cmp	r5, r7
   206c8:	d1ed      	bne.n	206a6 <SFXRhodesFrame+0x6ce>
                prevDisplayValues[k] = displayValues[k];
   206ca:	6a63      	ldr	r3, [r4, #36]	; 0x24
   206cc:	4a0a      	ldr	r2, [pc, #40]	; (206f8 <SFXRhodesFrame+0x720>)
   206ce:	6253      	str	r3, [r2, #36]	; 0x24
            for (int i = 0; i < numVoices; i++)
   206d0:	9b01      	ldr	r3, [sp, #4]
   206d2:	781b      	ldrb	r3, [r3, #0]
   206d4:	2b00      	cmp	r3, #0
   206d6:	f000 8088 	beq.w	207ea <SFXRhodesFrame+0x812>
   206da:	f8df a054 	ldr.w	sl, [pc, #84]	; 20730 <SFXRhodesFrame+0x758>
   206de:	2500      	movs	r5, #0
   206e0:	f8df b050 	ldr.w	fp, [pc, #80]	; 20734 <SFXRhodesFrame+0x75c>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   206e4:	4656      	mov	r6, sl
   206e6:	f8df 9050 	ldr.w	r9, [pc, #80]	; 20738 <SFXRhodesFrame+0x760>
   206ea:	4f0e      	ldr	r7, [pc, #56]	; (20724 <SFXRhodesFrame+0x74c>)
                        if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
   206ec:	46d8      	mov	r8, fp
   206ee:	e028      	b.n	20742 <SFXRhodesFrame+0x76a>
   206f0:	00062598 	.word	0x00062598
   206f4:	020e5cd8 	.word	0x020e5cd8
   206f8:	020e5ebc 	.word	0x020e5ebc
   206fc:	020fbd68 	.word	0x020fbd68
   20700:	bf6b851f 	.word	0xbf6b851f
   20704:	020f9df0 	.word	0x020f9df0
   20708:	469c4000 	.word	0x469c4000
   2070c:	020e5cdc 	.word	0x020e5cdc
   20710:	000627e8 	.word	0x000627e8
   20714:	020e52f8 	.word	0x020e52f8
   20718:	000627e8 	.word	0x000627e8
   2071c:	3827c5ac 	.word	0x3827c5ac
   20720:	3f7ffd61 	.word	0x3f7ffd61
   20724:	020e2f18 	.word	0x020e2f18
   20728:	000627d0 	.word	0x000627d0
   2072c:	020fb070 	.word	0x020fb070
   20730:	020f9de8 	.word	0x020f9de8
   20734:	020e5d04 	.word	0x020e5d04
   20738:	020e2ea0 	.word	0x020e2ea0
            for (int i = 0; i < numVoices; i++)
   2073c:	3501      	adds	r5, #1
   2073e:	42ab      	cmp	r3, r5
   20740:	dd53      	ble.n	207ea <SFXRhodesFrame+0x812>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   20742:	fa5f fb85 	uxtb.w	fp, r5
   20746:	4630      	mov	r0, r6
   20748:	4659      	mov	r1, fp
   2074a:	f009 fe71 	bl	2a430 <tSimplePoly_getPitch>
   2074e:	ee07 0a90 	vmov	s15, r0
   20752:	ed99 0a00 	vldr	s0, [r9]
   20756:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   2075a:	7839      	ldrb	r1, [r7, #0]
   2075c:	4a8e      	ldr	r2, [pc, #568]	; (20998 <SFXRhodesFrame+0x9c0>)
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   2075e:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   20762:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   20766:	ee17 3a90 	vmov	r3, s15
   2076a:	1a5b      	subs	r3, r3, r1
   2076c:	fb82 2003 	smull	r2, r0, r2, r3
   20770:	17d9      	asrs	r1, r3, #31
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   20772:	4a8a      	ldr	r2, [pc, #552]	; (2099c <SFXRhodesFrame+0x9c4>)
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   20774:	ebc1 0160 	rsb	r1, r1, r0, asr #1
   20778:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   2077c:	eba3 0381 	sub.w	r3, r3, r1, lsl #2
   20780:	ee07 3a90 	vmov	s15, r3
   20784:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   20788:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2078c:	ee17 3a90 	vmov	r3, s15
   20790:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   20794:	ed93 0a00 	vldr	s0, [r3]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   20798:	ee37 0a00 	vadd.f32	s0, s14, s0
   2079c:	f009 f8ae 	bl	298fc <LEAF_midiToFrequency>
                if (numVoices > 1)
   207a0:	9b01      	ldr	r3, [sp, #4]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
   207a2:	eca8 0a01 	vstmia	r8!, {s0}
                if (numVoices > 1)
   207a6:	781b      	ldrb	r3, [r3, #0]
   207a8:	2b01      	cmp	r3, #1
   207aa:	d9c7      	bls.n	2073c <SFXRhodesFrame+0x764>
                    if (poly->voices[i][0] == -2)
   207ac:	f8da 1000 	ldr.w	r1, [sl]
   207b0:	6909      	ldr	r1, [r1, #16]
   207b2:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
   207b6:	6809      	ldr	r1, [r1, #0]
   207b8:	3102      	adds	r1, #2
   207ba:	d1bf      	bne.n	2073c <SFXRhodesFrame+0x764>
   207bc:	eb05 0145 	add.w	r1, r5, r5, lsl #1
                        if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
   207c0:	4a77      	ldr	r2, [pc, #476]	; (209a0 <SFXRhodesFrame+0x9c8>)
   207c2:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
   207c6:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
   207ca:	6a80      	ldr	r0, [r0, #40]	; 0x28
   207cc:	2800      	cmp	r0, #0
   207ce:	d1b5      	bne.n	2073c <SFXRhodesFrame+0x764>
   207d0:	6889      	ldr	r1, [r1, #8]
   207d2:	6a89      	ldr	r1, [r1, #40]	; 0x28
   207d4:	2900      	cmp	r1, #0
   207d6:	d1b1      	bne.n	2073c <SFXRhodesFrame+0x764>
                            tSimplePoly_deactivateVoice(&poly, i);
   207d8:	4659      	mov	r1, fp
   207da:	4630      	mov	r0, r6
   207dc:	f009 fd4e 	bl	2a27c <tSimplePoly_deactivateVoice>
   207e0:	9b01      	ldr	r3, [sp, #4]
            for (int i = 0; i < numVoices; i++)
   207e2:	3501      	adds	r5, #1
   207e4:	781b      	ldrb	r3, [r3, #0]
   207e6:	42ab      	cmp	r3, r5
   207e8:	dcab      	bgt.n	20742 <SFXRhodesFrame+0x76a>
            tCycle_setFreq(&tremolo, displayValues[2]);
   207ea:	ed94 0a02 	vldr	s0, [r4, #8]
   207ee:	486d      	ldr	r0, [pc, #436]	; (209a4 <SFXRhodesFrame+0x9cc>)
        }
   207f0:	b003      	add	sp, #12
   207f2:	ecbd 8b04 	vpop	{d8-d9}
   207f6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            tCycle_setFreq(&tremolo, displayValues[2]);
   207fa:	f009 be47 	b.w	2a48c <tCycle_setFreq>
   207fe:	4d68      	ldr	r5, [pc, #416]	; (209a0 <SFXRhodesFrame+0x9c8>)
   20800:	f105 0bc0 	add.w	fp, r5, #192	; 0xc0
   20804:	f105 0918 	add.w	r9, r5, #24
                                    tADSR4_setRelease(&FM_envs[i][j], displayValues[8]);
   20808:	4628      	mov	r0, r5
   2080a:	3504      	adds	r5, #4
   2080c:	ed94 0a08 	vldr	s0, [r4, #32]
   20810:	f006 ff92 	bl	27738 <tADSR4_setRelease>
                                for (int j = 0; j < 6; j++)
   20814:	45a9      	cmp	r9, r5
   20816:	d1f7      	bne.n	20808 <SFXRhodesFrame+0x830>
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
   20818:	45ab      	cmp	fp, r5
   2081a:	d1f3      	bne.n	20804 <SFXRhodesFrame+0x82c>
                prevDisplayValues[k] = displayValues[k];
   2081c:	f85a 3c04 	ldr.w	r3, [sl, #-4]
   20820:	f847 3c04 	str.w	r3, [r7, #-4]
   20824:	e733      	b.n	2068e <SFXRhodesFrame+0x6b6>
   20826:	4d60      	ldr	r5, [pc, #384]	; (209a8 <SFXRhodesFrame+0x9d0>)
   20828:	f8df 9190 	ldr.w	r9, [pc, #400]	; 209bc <SFXRhodesFrame+0x9e4>
   2082c:	f105 0b18 	add.w	fp, r5, #24
                                tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   20830:	ecb5 0a01 	vldmia	r5!, {s0}
   20834:	4648      	mov	r0, r9
   20836:	edd4 7a07 	vldr	s15, [r4, #28]
   2083a:	f109 0904 	add.w	r9, r9, #4
   2083e:	ee20 0a27 	vmul.f32	s0, s0, s15
   20842:	f007 fadd 	bl	27e00 <tExpSmooth_setDest>
                            for (int i = 0; i < 6; i++)
   20846:	45ab      	cmp	fp, r5
   20848:	d1f2      	bne.n	20830 <SFXRhodesFrame+0x858>
                prevDisplayValues[k] = displayValues[k];
   2084a:	f85a 3c04 	ldr.w	r3, [sl, #-4]
   2084e:	f847 3c04 	str.w	r3, [r7, #-4]
   20852:	e71c      	b.n	2068e <SFXRhodesFrame+0x6b6>
   20854:	f8df 9148 	ldr.w	r9, [pc, #328]	; 209a0 <SFXRhodesFrame+0x9c8>
   20858:	f8df b164 	ldr.w	fp, [pc, #356]	; 209c0 <SFXRhodesFrame+0x9e8>
            prevDisplayValues[24] = displayValues[24];
   2085c:	464d      	mov	r5, r9
                                    tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
   2085e:	ecfb 0a01 	vldmia	fp!, {s1}
   20862:	eeb0 1a48 	vmov.f32	s2, s16
   20866:	edd4 7a06 	vldr	s15, [r4, #24]
   2086a:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
   2086e:	ee60 0aa7 	vmul.f32	s1, s1, s15
   20872:	f008 ff59 	bl	29728 <LEAF_clip>
   20876:	4628      	mov	r0, r5
   20878:	f006 ff3a 	bl	276f0 <tADSR4_setDecay>
                                for (int j = 0; j < 6; j++)
   2087c:	455e      	cmp	r6, fp
   2087e:	f105 0504 	add.w	r5, r5, #4
   20882:	d1ec      	bne.n	2085e <SFXRhodesFrame+0x886>
   20884:	f109 0918 	add.w	r9, r9, #24
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
   20888:	4b48      	ldr	r3, [pc, #288]	; (209ac <SFXRhodesFrame+0x9d4>)
   2088a:	454b      	cmp	r3, r9
   2088c:	d1e4      	bne.n	20858 <SFXRhodesFrame+0x880>
                prevDisplayValues[k] = displayValues[k];
   2088e:	f85a 3c04 	ldr.w	r3, [sl, #-4]
   20892:	f847 3c04 	str.w	r3, [r7, #-4]
   20896:	e6fa      	b.n	2068e <SFXRhodesFrame+0x6b6>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   20898:	4d45      	ldr	r5, [pc, #276]	; (209b0 <SFXRhodesFrame+0x9d8>)
                tSimplePoly_setNumVoices(&poly, numVoices);
   2089a:	4846      	ldr	r0, [pc, #280]	; (209b4 <SFXRhodesFrame+0x9dc>)
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   2089c:	782a      	ldrb	r2, [r5, #0]
   2089e:	9501      	str	r5, [sp, #4]
   208a0:	2a01      	cmp	r2, #1
   208a2:	bf98      	it	ls
   208a4:	2308      	movls	r3, #8
                tSimplePoly_setNumVoices(&poly, numVoices);
   208a6:	4619      	mov	r1, r3
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   208a8:	702b      	strb	r3, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
   208aa:	f009 fd9d 	bl	2a3e8 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
   208ae:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   208b0:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
   208b2:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
   208b6:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
   208b8:	fab0 f080 	clz	r0, r0
   208bc:	0940      	lsrs	r0, r0, #5
   208be:	f7f8 fde7 	bl	19490 <setLED_A>
   208c2:	f7ff bb95 	b.w	1fff0 <SFXRhodesFrame+0x18>
                tremoloStereo = !tremoloStereo;
   208c6:	4a3c      	ldr	r2, [pc, #240]	; (209b8 <SFXRhodesFrame+0x9e0>)
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   208c8:	2100      	movs	r1, #0
                tremoloStereo = !tremoloStereo;
   208ca:	7813      	ldrb	r3, [r2, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
   208cc:	7721      	strb	r1, [r4, #28]
                tremoloStereo = !tremoloStereo;
   208ce:	fab3 f383 	clz	r3, r3
   208d2:	095b      	lsrs	r3, r3, #5
                setLED_C(tremoloStereo == 1);
   208d4:	4618      	mov	r0, r3
                tremoloStereo = !tremoloStereo;
   208d6:	7013      	strb	r3, [r2, #0]
                setLED_C(tremoloStereo == 1);
   208d8:	f7f8 fdf6 	bl	194c8 <setLED_C>
   208dc:	f7ff bb9e 	b.w	2001c <SFXRhodesFrame+0x44>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   208e0:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
   208e4:	ee76 6a63 	vsub.f32	s13, s12, s7
   208e8:	eef0 6ae6 	vabs.f32	s13, s13
   208ec:	ee83 6aa6 	vdiv.f32	s12, s7, s13
   208f0:	e4cf      	b.n	20292 <SFXRhodesFrame+0x2ba>
   208f2:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
   208f6:	ee73 6ac3 	vsub.f32	s13, s7, s6
   208fa:	eef0 6ae6 	vabs.f32	s13, s13
   208fe:	eec3 3a26 	vdiv.f32	s7, s6, s13
   20902:	e4f1      	b.n	202e8 <SFXRhodesFrame+0x310>
   20904:	ee77 7ac7 	vsub.f32	s15, s15, s14
   20908:	eef0 3ae7 	vabs.f32	s7, s15
   2090c:	eec7 7a23 	vdiv.f32	s15, s14, s7
   20910:	e513      	b.n	2033a <SFXRhodesFrame+0x362>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20912:	ee33 4ac3 	vsub.f32	s8, s7, s6
   20916:	eef0 3ac4 	vabs.f32	s7, s8
   2091a:	ee83 4a23 	vdiv.f32	s8, s6, s7
   2091e:	e569      	b.n	203f4 <SFXRhodesFrame+0x41c>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20920:	ee76 6a65 	vsub.f32	s13, s12, s11
   20924:	eef0 6ae6 	vabs.f32	s13, s13
   20928:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   2092c:	e430      	b.n	20190 <SFXRhodesFrame+0x1b8>
   2092e:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   20932:	ee76 6a65 	vsub.f32	s13, s12, s11
   20936:	eef0 6ae6 	vabs.f32	s13, s13
   2093a:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   2093e:	e452      	b.n	201e6 <SFXRhodesFrame+0x20e>
   20940:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   20944:	ee76 6a65 	vsub.f32	s13, s12, s11
   20948:	eef0 6ae6 	vabs.f32	s13, s13
   2094c:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   20950:	e474      	b.n	2023c <SFXRhodesFrame+0x264>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20952:	ee77 7ae6 	vsub.f32	s15, s15, s13
   20956:	eeb0 6ae7 	vabs.f32	s12, s15
   2095a:	eec6 7a86 	vdiv.f32	s15, s13, s12
   2095e:	e5de      	b.n	2051e <SFXRhodesFrame+0x546>
   20960:	ee36 6a65 	vsub.f32	s12, s12, s11
   20964:	eeb0 5ac6 	vabs.f32	s10, s12
   20968:	ee85 6a85 	vdiv.f32	s12, s11, s10
   2096c:	e5bb      	b.n	204e6 <SFXRhodesFrame+0x50e>
   2096e:	ee75 5ac5 	vsub.f32	s11, s11, s10
   20972:	eef0 4ae5 	vabs.f32	s9, s11
   20976:	eec5 5a24 	vdiv.f32	s11, s10, s9
   2097a:	e596      	b.n	204aa <SFXRhodesFrame+0x4d2>
   2097c:	ee35 5a64 	vsub.f32	s10, s10, s9
   20980:	eeb0 4ac5 	vabs.f32	s8, s10
   20984:	ee84 5a84 	vdiv.f32	s10, s9, s8
   20988:	e571      	b.n	2046e <SFXRhodesFrame+0x496>
   2098a:	ee74 4ac4 	vsub.f32	s9, s9, s8
   2098e:	eef0 3ae4 	vabs.f32	s7, s9
   20992:	eec4 4a23 	vdiv.f32	s9, s8, s7
   20996:	e54c      	b.n	20432 <SFXRhodesFrame+0x45a>
   20998:	2aaaaaab 	.word	0x2aaaaaab
   2099c:	020e2ee4 	.word	0x020e2ee4
   209a0:	020f9df0 	.word	0x020f9df0
   209a4:	020fa034 	.word	0x020fa034
   209a8:	000627e8 	.word	0x000627e8
   209ac:	020f9eb0 	.word	0x020f9eb0
   209b0:	000627ac 	.word	0x000627ac
   209b4:	020f9de8 	.word	0x020f9de8
   209b8:	020e2ed4 	.word	0x020e2ed4
   209bc:	020e52f8 	.word	0x020e52f8
   209c0:	000627d0 	.word	0x000627d0

000209c4 <SFXRhodesTick>:
        {
   209c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   209c8:	f8df 8364 	ldr.w	r8, [pc, #868]	; 20d30 <SFXRhodesTick+0x36c>
   209cc:	4cc8      	ldr	r4, [pc, #800]	; (20cf0 <SFXRhodesTick+0x32c>)
   209ce:	f108 0518 	add.w	r5, r8, #24
   209d2:	4646      	mov	r6, r8
   209d4:	ed2d 8b08 	vpush	{d8-d11}
   209d8:	b08d      	sub	sp, #52	; 0x34
   209da:	900b      	str	r0, [sp, #44]	; 0x2c
                sustainsFinal[i] = tExpSmooth_tick(&susSmoothers[i]);
   209dc:	4620      	mov	r0, r4
   209de:	3404      	adds	r4, #4
   209e0:	f007 fa18 	bl	27e14 <tExpSmooth_tick>
   209e4:	eca6 0a01 	vstmia	r6!, {s0}
            for (int i = 0; i < 6; i++)
   209e8:	42ae      	cmp	r6, r5
   209ea:	d1f7      	bne.n	209dc <SFXRhodesTick+0x18>
   209ec:	4bc1      	ldr	r3, [pc, #772]	; (20cf4 <SFXRhodesTick+0x330>)
   209ee:	f103 09c0 	add.w	r9, r3, #192	; 0xc0
   209f2:	461f      	mov	r7, r3
        {
   209f4:	463d      	mov	r5, r7
   209f6:	4644      	mov	r4, r8
                    tADSR4_setSustain(&FM_envs[i][j], sustainsFinal[j]); //FM_sustains[Rsound][j] * displayValues[7]);
   209f8:	ecb4 0a01 	vldmia	r4!, {s0}
   209fc:	4628      	mov	r0, r5
   209fe:	f006 fe85 	bl	2770c <tADSR4_setSustain>
   20a02:	3504      	adds	r5, #4
                for (int j = 0; j < 6; j++)
   20a04:	42a6      	cmp	r6, r4
   20a06:	d1f7      	bne.n	209f8 <SFXRhodesTick+0x34>
   20a08:	3718      	adds	r7, #24
            for (int i = 0; i < NUM_VOC_VOICES; i++)
   20a0a:	454f      	cmp	r7, r9
   20a0c:	d1f2      	bne.n	209f4 <SFXRhodesTick+0x30>
            for (int i = 0; i < numVoices; i++)
   20a0e:	4bba      	ldr	r3, [pc, #744]	; (20cf8 <SFXRhodesTick+0x334>)
   20a10:	781b      	ldrb	r3, [r3, #0]
   20a12:	2b00      	cmp	r3, #0
   20a14:	f000 8164 	beq.w	20ce0 <SFXRhodesTick+0x31c>
   20a18:	4bb6      	ldr	r3, [pc, #728]	; (20cf4 <SFXRhodesTick+0x330>)
   20a1a:	f04f 0a00 	mov.w	sl, #0
   20a1e:	f8df 8314 	ldr.w	r8, [pc, #788]	; 20d34 <SFXRhodesTick+0x370>
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20a22:	eef7 aa00 	vmov.f32	s21, #112	; 0x3f800000  1.0
   20a26:	f103 0014 	add.w	r0, r3, #20
            float rightSample = 0.0f;
   20a2a:	ed9f 9ab4 	vldr	s18, [pc, #720]	; 20cfc <SFXRhodesTick+0x338>
   20a2e:	49b4      	ldr	r1, [pc, #720]	; (20d00 <SFXRhodesTick+0x33c>)
   20a30:	4642      	mov	r2, r8
   20a32:	900a      	str	r0, [sp, #40]	; 0x28
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20a34:	eeb6 aa00 	vmov.f32	s20, #96	; 0x3f000000  0.5
   20a38:	48b2      	ldr	r0, [pc, #712]	; (20d04 <SFXRhodesTick+0x340>)
            float leftSample = 0.0f;
   20a3a:	eef0 9a49 	vmov.f32	s19, s18
   20a3e:	46d0      	mov	r8, sl
   20a40:	f8df 92f4 	ldr.w	r9, [pc, #756]	; 20d38 <SFXRhodesTick+0x374>
   20a44:	9003      	str	r0, [sp, #12]
   20a46:	f103 0010 	add.w	r0, r3, #16
   20a4a:	4caf      	ldr	r4, [pc, #700]	; (20d08 <SFXRhodesTick+0x344>)
   20a4c:	9009      	str	r0, [sp, #36]	; 0x24
   20a4e:	f103 000c 	add.w	r0, r3, #12
   20a52:	f8df b2e8 	ldr.w	fp, [pc, #744]	; 20d3c <SFXRhodesTick+0x378>
   20a56:	9008      	str	r0, [sp, #32]
   20a58:	1d18      	adds	r0, r3, #4
   20a5a:	3308      	adds	r3, #8
   20a5c:	4dab      	ldr	r5, [pc, #684]	; (20d0c <SFXRhodesTick+0x348>)
   20a5e:	9006      	str	r0, [sp, #24]
   20a60:	9307      	str	r3, [sp, #28]
   20a62:	460b      	mov	r3, r1
   20a64:	4651      	mov	r1, sl
   20a66:	4692      	mov	sl, r2
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   20a68:	f8d9 7000 	ldr.w	r7, [r9]
            for (int i = 0; i < numVoices; i++)
   20a6c:	3101      	adds	r1, #1
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   20a6e:	ed9a 0a00 	vldr	s0, [sl]
   20a72:	eb07 0747 	add.w	r7, r7, r7, lsl #1
   20a76:	eddb 7a00 	vldr	s15, [fp]
                float myFrequency = freq[i];
   20a7a:	ecf3 8a01 	vldmia	r3!, {s17}
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   20a7e:	00ff      	lsls	r7, r7, #3
   20a80:	ee67 7a80 	vmul.f32	s15, s15, s0
   20a84:	4aa2      	ldr	r2, [pc, #648]	; (20d10 <SFXRhodesTick+0x34c>)
   20a86:	eb05 0c07 	add.w	ip, r5, r7
   20a8a:	4427      	add	r7, r4
   20a8c:	eb02 0608 	add.w	r6, r2, r8
                float myFrequency = freq[i];
   20a90:	9305      	str	r3, [sp, #20]
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   20a92:	ed9c 0a05 	vldr	s0, [ip, #20]
   20a96:	3a04      	subs	r2, #4
            for (int i = 0; i < numVoices; i++)
   20a98:	9104      	str	r1, [sp, #16]
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   20a9a:	4630      	mov	r0, r6
   20a9c:	ee27 0a80 	vmul.f32	s0, s15, s0
   20aa0:	4b9c      	ldr	r3, [pc, #624]	; (20d14 <SFXRhodesTick+0x350>)
   20aa2:	499d      	ldr	r1, [pc, #628]	; (20d18 <SFXRhodesTick+0x354>)
   20aa4:	4442      	add	r2, r8
   20aa6:	ed97 7a05 	vldr	s14, [r7, #20]
   20aaa:	4443      	add	r3, r8
   20aac:	4441      	add	r1, r8
   20aae:	9202      	str	r2, [sp, #8]
   20ab0:	eea7 0a28 	vfma.f32	s0, s14, s17
   20ab4:	9301      	str	r3, [sp, #4]
   20ab6:	9100      	str	r1, [sp, #0]
   20ab8:	f009 fce8 	bl	2a48c <tCycle_setFreq>
                feedback_output = tCycle_tick(&FM_sines[i][5]);
   20abc:	4630      	mov	r0, r6
   20abe:	4f97      	ldr	r7, [pc, #604]	; (20d1c <SFXRhodesTick+0x358>)
   20ac0:	f009 fcf2 	bl	2a4a8 <tCycle_tick>
                tCycle_setFreq(&FM_sines[i][4], (myFrequency  * FM_freqRatios[Rsound][4]) + (FM_indices[Rsound][4] * feedback_output * displayValues[0] * tADSR4_tick(&FM_envs[i][5])));
   20ac4:	f8d9 0000 	ldr.w	r0, [r9]
   20ac8:	edda 7a00 	vldr	s15, [sl]
   20acc:	4447      	add	r7, r8
   20ace:	eb00 0040 	add.w	r0, r0, r0, lsl #1
                feedback_output = tCycle_tick(&FM_sines[i][5]);
   20ad2:	ed8b 0a00 	vstr	s0, [fp]
                tCycle_setFreq(&FM_sines[i][4], (myFrequency  * FM_freqRatios[Rsound][4]) + (FM_indices[Rsound][4] * feedback_output * displayValues[0] * tADSR4_tick(&FM_envs[i][5])));
   20ad6:	00c0      	lsls	r0, r0, #3
   20ad8:	eb05 0c00 	add.w	ip, r5, r0
   20adc:	1826      	adds	r6, r4, r0
   20ade:	980a      	ldr	r0, [sp, #40]	; 0x28
   20ae0:	ed9c 8a04 	vldr	s16, [ip, #16]
   20ae4:	4440      	add	r0, r8
   20ae6:	ed96 ba04 	vldr	s22, [r6, #16]
   20aea:	ee28 8a27 	vmul.f32	s16, s16, s15
   20aee:	4e8c      	ldr	r6, [pc, #560]	; (20d20 <SFXRhodesTick+0x35c>)
   20af0:	4446      	add	r6, r8
   20af2:	ee28 8a00 	vmul.f32	s16, s16, s0
   20af6:	f006 fe4b 	bl	27790 <tADSR4_tick>
   20afa:	9802      	ldr	r0, [sp, #8]
   20afc:	ee28 0a00 	vmul.f32	s0, s16, s0
   20b00:	eeab 0a28 	vfma.f32	s0, s22, s17
   20b04:	f009 fcc2 	bl	2a48c <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][3], (myFrequency  * FM_freqRatios[Rsound][3]) + (FM_indices[Rsound][3] * displayValues[0] * tCycle_tick(&FM_sines[i][4]) * tADSR4_tickNoInterp(&FM_envs[i][4])));
   20b08:	f8d9 2000 	ldr.w	r2, [r9]
   20b0c:	edda 7a00 	vldr	s15, [sl]
   20b10:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   20b14:	9802      	ldr	r0, [sp, #8]
   20b16:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   20b1a:	eb05 0e0c 	add.w	lr, r5, ip
   20b1e:	44a4      	add	ip, r4
   20b20:	ed9e 8a03 	vldr	s16, [lr, #12]
   20b24:	ed9c ba03 	vldr	s22, [ip, #12]
   20b28:	ee28 8a27 	vmul.f32	s16, s16, s15
   20b2c:	f009 fcbc 	bl	2a4a8 <tCycle_tick>
   20b30:	9a09      	ldr	r2, [sp, #36]	; 0x24
   20b32:	ee28 8a00 	vmul.f32	s16, s16, s0
   20b36:	eb02 0008 	add.w	r0, r2, r8
   20b3a:	f006 ff87 	bl	27a4c <tADSR4_tickNoInterp>
   20b3e:	9801      	ldr	r0, [sp, #4]
   20b40:	ee28 0a00 	vmul.f32	s0, s16, s0
   20b44:	eeab 0a28 	vfma.f32	s0, s22, s17
   20b48:	f009 fca0 	bl	2a48c <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][2], (myFrequency  * FM_freqRatios[Rsound][2]) + (FM_indices[Rsound][2] * displayValues[0] * tCycle_tick(&FM_sines[i][3]) * tADSR4_tickNoInterp(&FM_envs[i][3])));
   20b4c:	f8d9 2000 	ldr.w	r2, [r9]
   20b50:	edda 7a00 	vldr	s15, [sl]
   20b54:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   20b58:	9801      	ldr	r0, [sp, #4]
   20b5a:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   20b5e:	eb05 0e0c 	add.w	lr, r5, ip
   20b62:	44a4      	add	ip, r4
   20b64:	ed9e 8a02 	vldr	s16, [lr, #8]
   20b68:	ed9c ba02 	vldr	s22, [ip, #8]
   20b6c:	ee28 8a27 	vmul.f32	s16, s16, s15
   20b70:	f009 fc9a 	bl	2a4a8 <tCycle_tick>
   20b74:	9b08      	ldr	r3, [sp, #32]
   20b76:	ee28 8a00 	vmul.f32	s16, s16, s0
   20b7a:	eb03 0008 	add.w	r0, r3, r8
   20b7e:	f006 ff65 	bl	27a4c <tADSR4_tickNoInterp>
   20b82:	9800      	ldr	r0, [sp, #0]
   20b84:	ee28 0a00 	vmul.f32	s0, s16, s0
   20b88:	eeab 0a28 	vfma.f32	s0, s22, s17
   20b8c:	f009 fc7e 	bl	2a48c <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][1], myFrequency  * FM_freqRatios[Rsound][1]);
   20b90:	f8d9 2000 	ldr.w	r2, [r9]
   20b94:	4638      	mov	r0, r7
   20b96:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   20b9a:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
   20b9e:	ed9c 0a01 	vldr	s0, [ip, #4]
   20ba2:	ee28 0a80 	vmul.f32	s0, s17, s0
   20ba6:	f009 fc71 	bl	2a48c <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][0],( myFrequency  * FM_freqRatios[Rsound][0]) + (FM_indices[Rsound][0] * displayValues[0] * tCycle_tick(&FM_sines[i][1]) * tADSR4_tickNoInterp(&FM_envs[i][1])));
   20baa:	f8d9 2000 	ldr.w	r2, [r9]
   20bae:	4638      	mov	r0, r7
   20bb0:	edda 7a00 	vldr	s15, [sl]
   20bb4:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   20bb8:	ea4f 07cc 	mov.w	r7, ip, lsl #3
   20bbc:	eb05 0c07 	add.w	ip, r5, r7
   20bc0:	4427      	add	r7, r4
   20bc2:	ed9c 8a00 	vldr	s16, [ip]
   20bc6:	ed97 ba00 	vldr	s22, [r7]
   20bca:	ee28 8a27 	vmul.f32	s16, s16, s15
   20bce:	f009 fc6b 	bl	2a4a8 <tCycle_tick>
   20bd2:	9b06      	ldr	r3, [sp, #24]
   20bd4:	ee28 8a00 	vmul.f32	s16, s16, s0
   20bd8:	eb03 0008 	add.w	r0, r3, r8
   20bdc:	f006 ff36 	bl	27a4c <tADSR4_tickNoInterp>
   20be0:	4630      	mov	r0, r6
   20be2:	ee28 0a00 	vmul.f32	s0, s16, s0
   20be6:	eeab 0a28 	vfma.f32	s0, s22, s17
   20bea:	f009 fc4f 	bl	2a48c <tCycle_setFreq>
                sample += (tCycle_tick(&FM_sines[i][2]) * tADSR4_tickNoInterp(&FM_envs[i][2]));
   20bee:	9800      	ldr	r0, [sp, #0]
   20bf0:	f009 fc5a 	bl	2a4a8 <tCycle_tick>
   20bf4:	9b07      	ldr	r3, [sp, #28]
   20bf6:	eeb0 ba40 	vmov.f32	s22, s0
   20bfa:	eb03 0008 	add.w	r0, r3, r8
   20bfe:	f006 ff25 	bl	27a4c <tADSR4_tickNoInterp>
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   20c02:	4630      	mov	r0, r6
                sample += (tCycle_tick(&FM_sines[i][2]) * tADSR4_tickNoInterp(&FM_envs[i][2]));
   20c04:	eef0 8a40 	vmov.f32	s17, s0
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   20c08:	f009 fc4e 	bl	2a4a8 <tCycle_tick>
   20c0c:	4b39      	ldr	r3, [pc, #228]	; (20cf4 <SFXRhodesTick+0x330>)
   20c0e:	eeb0 8a40 	vmov.f32	s16, s0
   20c12:	eb03 0008 	add.w	r0, r3, r8
   20c16:	f108 0818 	add.w	r8, r8, #24
   20c1a:	f006 ff17 	bl	27a4c <tADSR4_tickNoInterp>
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20c1e:	9b03      	ldr	r3, [sp, #12]
   20c20:	edda 7a04 	vldr	s15, [sl, #16]
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   20c24:	ee28 0a00 	vmul.f32	s0, s16, s0
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20c28:	ecf3 6a01 	vldmia	r3!, {s13}
   20c2c:	ee3a 6ae7 	vsub.f32	s12, s21, s15
            for (int i = 0; i < numVoices; i++)
   20c30:	9904      	ldr	r1, [sp, #16]
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20c32:	ee3a 7ae6 	vsub.f32	s14, s21, s13
   20c36:	9303      	str	r3, [sp, #12]
                rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
   20c38:	ee67 6aa6 	vmul.f32	s13, s15, s13
            for (int i = 0; i < numVoices; i++)
   20c3c:	4b2e      	ldr	r3, [pc, #184]	; (20cf8 <SFXRhodesTick+0x334>)
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   20c3e:	eeab 0a28 	vfma.f32	s0, s22, s17
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20c42:	ee67 7a27 	vmul.f32	s15, s14, s15
            for (int i = 0; i < numVoices; i++)
   20c46:	7818      	ldrb	r0, [r3, #0]
                rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
   20c48:	eee6 6a0a 	vfma.f32	s13, s12, s20
            for (int i = 0; i < numVoices; i++)
   20c4c:	9b05      	ldr	r3, [sp, #20]
   20c4e:	4288      	cmp	r0, r1
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20c50:	eee6 7a0a 	vfma.f32	s15, s12, s20
                rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
   20c54:	eea6 9a80 	vfma.f32	s18, s13, s0
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20c58:	eee7 9a80 	vfma.f32	s19, s15, s0
            for (int i = 0; i < numVoices; i++)
   20c5c:	f73f af04 	bgt.w	20a68 <SFXRhodesTick+0xa4>
   20c60:	eddf 7a30 	vldr	s15, [pc, #192]	; 20d24 <SFXRhodesTick+0x360>
   20c64:	46d0      	mov	r8, sl
   20c66:	ee69 9aa7 	vmul.f32	s19, s19, s15
   20c6a:	ee29 9a27 	vmul.f32	s18, s18, s15
            float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
   20c6e:	482e      	ldr	r0, [pc, #184]	; (20d28 <SFXRhodesTick+0x364>)
   20c70:	f009 fc1a 	bl	2a4a8 <tCycle_tick>
   20c74:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   20c78:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   20c7c:	edd8 6a01 	vldr	s13, [r8, #4]
            if (tremoloStereo)
   20c80:	4b2a      	ldr	r3, [pc, #168]	; (20d2c <SFXRhodesTick+0x368>)
            float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
   20c82:	ee30 0a27 	vadd.f32	s0, s0, s15
   20c86:	ee26 7a87 	vmul.f32	s14, s13, s14
            if (tremoloStereo)
   20c8a:	781b      	ldrb	r3, [r3, #0]
   20c8c:	ee77 7ae6 	vsub.f32	s15, s15, s13
            float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
   20c90:	ee20 7a07 	vmul.f32	s14, s0, s14
   20c94:	ee37 0a87 	vadd.f32	s0, s15, s14
            if (tremoloStereo)
   20c98:	b9cb      	cbnz	r3, 20cce <SFXRhodesTick+0x30a>
                rightSample *= ((tremoloSignal) + (1.0f - displayValues[1]));
   20c9a:	ee29 9a00 	vmul.f32	s18, s18, s0
            leftSample *= displayValues[3]; //drive
   20c9e:	ed98 8a03 	vldr	s16, [r8, #12]
   20ca2:	ee68 9a29 	vmul.f32	s19, s16, s19
            leftSample = tanhf(leftSample);
   20ca6:	ee29 0a80 	vmul.f32	s0, s19, s0
   20caa:	f00c fa57 	bl	2d15c <tanhf>
   20cae:	eef0 8a40 	vmov.f32	s17, s0
            rightSample = tanhf(rightSample);
   20cb2:	ee28 0a09 	vmul.f32	s0, s16, s18
   20cb6:	f00c fa51 	bl	2d15c <tanhf>
            input[0] = leftSample;
   20cba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   20cbc:	edc3 8a00 	vstr	s17, [r3]
            input[1] = rightSample;
   20cc0:	ed83 0a01 	vstr	s0, [r3, #4]
        }
   20cc4:	b00d      	add	sp, #52	; 0x34
   20cc6:	ecbd 8b08 	vpop	{d8-d11}
   20cca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                rightSample *= ((1.0f-tremoloSignal) + (1.0f - displayValues[1]));
   20cce:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   20cd2:	ee77 6ae6 	vsub.f32	s13, s15, s13
   20cd6:	ee36 7ac7 	vsub.f32	s14, s13, s14
   20cda:	ee27 9a09 	vmul.f32	s18, s14, s18
   20cde:	e7de      	b.n	20c9e <SFXRhodesTick+0x2da>
            for (int i = 0; i < numVoices; i++)
   20ce0:	ed9f 9a06 	vldr	s18, [pc, #24]	; 20cfc <SFXRhodesTick+0x338>
   20ce4:	f8df 804c 	ldr.w	r8, [pc, #76]	; 20d34 <SFXRhodesTick+0x370>
   20ce8:	eef0 9a49 	vmov.f32	s19, s18
   20cec:	e7bf      	b.n	20c6e <SFXRhodesTick+0x2aa>
   20cee:	bf00      	nop
   20cf0:	020e52f8 	.word	0x020e52f8
   20cf4:	020f9df0 	.word	0x020f9df0
   20cf8:	000627ac 	.word	0x000627ac
   20cfc:	00000000 	.word	0x00000000
   20d00:	020e5d04 	.word	0x020e5d04
   20d04:	020e50e4 	.word	0x020e50e4
   20d08:	00062598 	.word	0x00062598
   20d0c:	00062610 	.word	0x00062610
   20d10:	020e5d48 	.word	0x020e5d48
   20d14:	020e5d40 	.word	0x020e5d40
   20d18:	020e5d3c 	.word	0x020e5d3c
   20d1c:	020e5d38 	.word	0x020e5d38
   20d20:	020e5d34 	.word	0x020e5d34
   20d24:	3ecccccd 	.word	0x3ecccccd
   20d28:	020fa034 	.word	0x020fa034
   20d2c:	020e2ed4 	.word	0x020e2ed4
   20d30:	020e5214 	.word	0x020e5214
   20d34:	020fb05c 	.word	0x020fb05c
   20d38:	020e2dd8 	.word	0x020e2dd8
   20d3c:	020e2e50 	.word	0x020e2e50

00020d40 <SFXRhodesFree>:
        {
   20d40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   20d42:	2400      	movs	r4, #0
   20d44:	4f12      	ldr	r7, [pc, #72]	; (20d90 <SFXRhodesFree+0x50>)
   20d46:	4e13      	ldr	r6, [pc, #76]	; (20d94 <SFXRhodesFree+0x54>)
   20d48:	f104 0518 	add.w	r5, r4, #24
                    tCycle_free(&FM_sines[i][j]);
   20d4c:	1938      	adds	r0, r7, r4
   20d4e:	f009 fb99 	bl	2a484 <tCycle_free>
                    tADSR4_free(&FM_envs[i][j]);
   20d52:	1930      	adds	r0, r6, r4
   20d54:	3404      	adds	r4, #4
   20d56:	f006 fcb9 	bl	276cc <tADSR4_free>
                for (int j = 0; j < 6; j++)
   20d5a:	42ac      	cmp	r4, r5
   20d5c:	d1f6      	bne.n	20d4c <SFXRhodesFree+0xc>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
   20d5e:	2cc0      	cmp	r4, #192	; 0xc0
   20d60:	d1f2      	bne.n	20d48 <SFXRhodesFree+0x8>
                tExpSmooth_free(&susSmoothers[i]);
   20d62:	480d      	ldr	r0, [pc, #52]	; (20d98 <SFXRhodesFree+0x58>)
   20d64:	f007 f836 	bl	27dd4 <tExpSmooth_free>
   20d68:	480c      	ldr	r0, [pc, #48]	; (20d9c <SFXRhodesFree+0x5c>)
   20d6a:	f007 f833 	bl	27dd4 <tExpSmooth_free>
   20d6e:	480c      	ldr	r0, [pc, #48]	; (20da0 <SFXRhodesFree+0x60>)
   20d70:	f007 f830 	bl	27dd4 <tExpSmooth_free>
   20d74:	480b      	ldr	r0, [pc, #44]	; (20da4 <SFXRhodesFree+0x64>)
   20d76:	f007 f82d 	bl	27dd4 <tExpSmooth_free>
   20d7a:	480b      	ldr	r0, [pc, #44]	; (20da8 <SFXRhodesFree+0x68>)
   20d7c:	f007 f82a 	bl	27dd4 <tExpSmooth_free>
   20d80:	480a      	ldr	r0, [pc, #40]	; (20dac <SFXRhodesFree+0x6c>)
   20d82:	f007 f827 	bl	27dd4 <tExpSmooth_free>
            tCycle_free(&tremolo);
   20d86:	480a      	ldr	r0, [pc, #40]	; (20db0 <SFXRhodesFree+0x70>)
        }
   20d88:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            tCycle_free(&tremolo);
   20d8c:	f009 bb7a 	b.w	2a484 <tCycle_free>
   20d90:	020e5d34 	.word	0x020e5d34
   20d94:	020f9df0 	.word	0x020f9df0
   20d98:	020e52f8 	.word	0x020e52f8
   20d9c:	020e52fc 	.word	0x020e52fc
   20da0:	020e5300 	.word	0x020e5300
   20da4:	020e5304 	.word	0x020e5304
   20da8:	020e5308 	.word	0x020e5308
   20dac:	020e530c 	.word	0x020e530c
   20db0:	020fa034 	.word	0x020fa034

00020db4 <calculateNoteArray>:
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   20db4:	4b17      	ldr	r3, [pc, #92]	; (20e14 <calculateNoteArray+0x60>)
            for (int i = 0; i < 128; i++)
   20db6:	2100      	movs	r1, #0
   20db8:	4817      	ldr	r0, [pc, #92]	; (20e18 <calculateNoteArray+0x64>)
        {
   20dba:	b4f0      	push	{r4, r5, r6, r7}
   20dbc:	4e17      	ldr	r6, [pc, #92]	; (20e1c <calculateNoteArray+0x68>)
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   20dbe:	781f      	ldrb	r7, [r3, #0]
   20dc0:	4d17      	ldr	r5, [pc, #92]	; (20e20 <calculateNoteArray+0x6c>)
                float tempNote = i;
   20dc2:	ee07 1a90 	vmov	s15, r1
            for (int i = 0; i < 128; i++)
   20dc6:	3101      	adds	r1, #1
                float tempNote = i;
   20dc8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            for (int i = 0; i < 128; i++)
   20dcc:	2980      	cmp	r1, #128	; 0x80
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   20dce:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   20dd2:	ee17 3a90 	vmov	r3, s15
   20dd6:	eba3 0307 	sub.w	r3, r3, r7
   20dda:	fb85 2403 	smull	r2, r4, r5, r3
   20dde:	ea4f 72e3 	mov.w	r2, r3, asr #31
   20de2:	ebc2 0264 	rsb	r2, r2, r4, asr #1
   20de6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   20dea:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   20dee:	ee07 3a90 	vmov	s15, r3
   20df2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   20df6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   20dfa:	ee17 3a90 	vmov	r3, s15
   20dfe:	eb06 0383 	add.w	r3, r6, r3, lsl #2
   20e02:	edd3 7a00 	vldr	s15, [r3]
   20e06:	ee77 7a87 	vadd.f32	s15, s15, s14
                notes[i] = tunedNote;
   20e0a:	ece0 7a01 	vstmia	r0!, {s15}
            for (int i = 0; i < 128; i++)
   20e0e:	d1d8      	bne.n	20dc2 <calculateNoteArray+0xe>
            }
        }
   20e10:	bcf0      	pop	{r4, r5, r6, r7}
   20e12:	4770      	bx	lr
   20e14:	020e2f18 	.word	0x020e2f18
   20e18:	020e5310 	.word	0x020e5310
   20e1c:	020e2ee4 	.word	0x020e2ee4
   20e20:	2aaaaaab 	.word	0x2aaaaaab

00020e24 <nearestNoteWithHysteresis>:

        int lastNearNote = -1;


        float nearestNoteWithHysteresis(float note, float hysteresis)
        {
   20e24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            float leastDifference = fastabsf(note - notes[0]);
   20e28:	4f76      	ldr	r7, [pc, #472]	; (21004 <nearestNoteWithHysteresis+0x1e0>)
        {
   20e2a:	ed2d 8b04 	vpush	{d8-d9}
   20e2e:	eef0 8a40 	vmov.f32	s17, s0
            float leastDifference = fastabsf(note - notes[0]);
   20e32:	ed97 0a00 	vldr	s0, [r7]
        {
   20e36:	eeb0 9a60 	vmov.f32	s18, s1
            float leastDifference = fastabsf(note - notes[0]);
   20e3a:	ee38 0ac0 	vsub.f32	s0, s17, s0
   20e3e:	f008 fb99 	bl	29574 <fastabsf>
            float difference;
            int nearIndex = 0;
            int* chord;
            float output = 0.0f;

            if (autotuneChromatic > 0)
   20e42:	4b71      	ldr	r3, [pc, #452]	; (21008 <nearestNoteWithHysteresis+0x1e4>)
            {
                chord = chromaticArray;
   20e44:	4971      	ldr	r1, [pc, #452]	; (2100c <nearestNoteWithHysteresis+0x1e8>)
            float leastDifference = fastabsf(note - notes[0]);
   20e46:	eeb0 8a40 	vmov.f32	s16, s0
            if (autotuneChromatic > 0)
   20e4a:	f893 8000 	ldrb.w	r8, [r3]
            }
            else
            {
                chord = chordArray;
            }
            if (autotuneLock > 0)
   20e4e:	4a70      	ldr	r2, [pc, #448]	; (21010 <nearestNoteWithHysteresis+0x1ec>)
                chord = chromaticArray;
   20e50:	4b70      	ldr	r3, [pc, #448]	; (21014 <nearestNoteWithHysteresis+0x1f0>)
            if (autotuneLock > 0)
   20e52:	6812      	ldr	r2, [r2, #0]
                chord = chromaticArray;
   20e54:	f1b8 0f00 	cmp.w	r8, #0
   20e58:	bf0c      	ite	eq
   20e5a:	4688      	moveq	r8, r1
   20e5c:	4698      	movne	r8, r3
            {
                chord = lockArray;
   20e5e:	4b6e      	ldr	r3, [pc, #440]	; (21018 <nearestNoteWithHysteresis+0x1f4>)
   20e60:	2a00      	cmp	r2, #0
   20e62:	bf18      	it	ne
   20e64:	4698      	movne	r8, r3
            }
            int hasNotes = 0;
            for (int i = 0; i < 12; i++)
            {
                if (chord[i] > 0)
   20e66:	e9d8 3200 	ldrd	r3, r2, [r8]
   20e6a:	f8d8 0008 	ldr.w	r0, [r8, #8]
   20e6e:	2b00      	cmp	r3, #0
   20e70:	bfcc      	ite	gt
   20e72:	2301      	movgt	r3, #1
   20e74:	2300      	movle	r3, #0
                {
                    hasNotes = 1;
   20e76:	2a00      	cmp	r2, #0
                if (chord[i] > 0)
   20e78:	e9d8 1203 	ldrd	r1, r2, [r8, #12]
                    hasNotes = 1;
   20e7c:	bfc8      	it	gt
   20e7e:	2301      	movgt	r3, #1
   20e80:	2800      	cmp	r0, #0
                if (chord[i] > 0)
   20e82:	f8d8 0014 	ldr.w	r0, [r8, #20]
                    hasNotes = 1;
   20e86:	bfc8      	it	gt
   20e88:	2301      	movgt	r3, #1
   20e8a:	2900      	cmp	r1, #0
                if (chord[i] > 0)
   20e8c:	f8d8 1018 	ldr.w	r1, [r8, #24]
                    hasNotes = 1;
   20e90:	bfc8      	it	gt
   20e92:	2301      	movgt	r3, #1
   20e94:	2a00      	cmp	r2, #0
                if (chord[i] > 0)
   20e96:	f8d8 201c 	ldr.w	r2, [r8, #28]
                    hasNotes = 1;
   20e9a:	bfc8      	it	gt
   20e9c:	2301      	movgt	r3, #1
   20e9e:	2800      	cmp	r0, #0
                if (chord[i] > 0)
   20ea0:	f8d8 0020 	ldr.w	r0, [r8, #32]
                    hasNotes = 1;
   20ea4:	bfc8      	it	gt
   20ea6:	2301      	movgt	r3, #1
   20ea8:	2900      	cmp	r1, #0
                if (chord[i] > 0)
   20eaa:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
                    hasNotes = 1;
   20eae:	bfc8      	it	gt
   20eb0:	2301      	movgt	r3, #1
   20eb2:	2a00      	cmp	r2, #0
                if (chord[i] > 0)
   20eb4:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
                    hasNotes = 1;
   20eb8:	bfc8      	it	gt
   20eba:	2301      	movgt	r3, #1
   20ebc:	2800      	cmp	r0, #0
   20ebe:	bfc8      	it	gt
   20ec0:	2301      	movgt	r3, #1
   20ec2:	2900      	cmp	r1, #0
   20ec4:	bfc8      	it	gt
   20ec6:	2301      	movgt	r3, #1
                if (chord[i] > 0)
   20ec8:	2a00      	cmp	r2, #0
   20eca:	f340 808d 	ble.w	20fe8 <nearestNoteWithHysteresis+0x1c4>
   20ece:	4d53      	ldr	r5, [pc, #332]	; (2101c <nearestNoteWithHysteresis+0x1f8>)

            }
            if (hasNotes)
            {

                for(int i = 1; i < 128; i++)
   20ed0:	2401      	movs	r4, #1
            int nearIndex = 0;
   20ed2:	2600      	movs	r6, #0
                {
                    if (chord[i%12] > 0)
   20ed4:	f8df 914c 	ldr.w	r9, [pc, #332]	; 21024 <nearestNoteWithHysteresis+0x200>
   20ed8:	e003      	b.n	20ee2 <nearestNoteWithHysteresis+0xbe>
                for(int i = 1; i < 128; i++)
   20eda:	3401      	adds	r4, #1
   20edc:	3504      	adds	r5, #4
   20ede:	2c80      	cmp	r4, #128	; 0x80
   20ee0:	d01c      	beq.n	20f1c <nearestNoteWithHysteresis+0xf8>
                    if (chord[i%12] > 0)
   20ee2:	fba9 2304 	umull	r2, r3, r9, r4
   20ee6:	08db      	lsrs	r3, r3, #3
   20ee8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   20eec:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
   20ef0:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
   20ef4:	2b00      	cmp	r3, #0
   20ef6:	ddf0      	ble.n	20eda <nearestNoteWithHysteresis+0xb6>
                    {
                        difference = fastabsf(note - notes[i]);
   20ef8:	ed95 0a00 	vldr	s0, [r5]
   20efc:	ee38 0ac0 	vsub.f32	s0, s17, s0
   20f00:	f008 fb38 	bl	29574 <fastabsf>
                        if(difference < leastDifference)
   20f04:	eeb4 0ac8 	vcmpe.f32	s0, s16
   20f08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20f0c:	d5e5      	bpl.n	20eda <nearestNoteWithHysteresis+0xb6>
   20f0e:	4626      	mov	r6, r4
                for(int i = 1; i < 128; i++)
   20f10:	3401      	adds	r4, #1
                        {
                            leastDifference = difference;
   20f12:	eeb0 8a40 	vmov.f32	s16, s0
   20f16:	3504      	adds	r5, #4
                for(int i = 1; i < 128; i++)
   20f18:	2c80      	cmp	r4, #128	; 0x80
   20f1a:	d1e2      	bne.n	20ee2 <nearestNoteWithHysteresis+0xbe>
                            nearIndex = i;
                        }
                    }
                }

                if (lastNearNote == -1)
   20f1c:	4840      	ldr	r0, [pc, #256]	; (21020 <nearestNoteWithHysteresis+0x1fc>)
   20f1e:	6801      	ldr	r1, [r0, #0]
   20f20:	1c4b      	adds	r3, r1, #1
   20f22:	d058      	beq.n	20fd6 <nearestNoteWithHysteresis+0x1b2>
   20f24:	eb07 0381 	add.w	r3, r7, r1, lsl #2
                {
                    output = notes[nearIndex];
                    lastNearNote = nearIndex;
                    return output;
                }
                if (nearIndex != lastNearNote)
   20f28:	42b1      	cmp	r1, r6
   20f2a:	ed93 0a00 	vldr	s0, [r3]
   20f2e:	d057      	beq.n	20fe0 <nearestNoteWithHysteresis+0x1bc>
   20f30:	460b      	mov	r3, r1
                {
                    //check if it's beyond the hysteresis

                    //find closest note in chord upward from lastNearNote
                    int upNote = 0;
   20f32:	2400      	movs	r4, #0
                    int downNote = 128;
                    int i = lastNearNote;
                    while ((i < 128) && (upNote == 0))
                    {
                        i++;
                        if (chord[i%12] > 0)
   20f34:	f8df c0f0 	ldr.w	ip, [pc, #240]	; 21028 <nearestNoteWithHysteresis+0x204>
   20f38:	e00f      	b.n	20f5a <nearestNoteWithHysteresis+0x136>
   20f3a:	ebc2 0265 	rsb	r2, r2, r5, asr #1
                    while ((i < 128) && (upNote == 0))
   20f3e:	b9a4      	cbnz	r4, 20f6a <nearestNoteWithHysteresis+0x146>
                        if (chord[i%12] > 0)
   20f40:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   20f44:	eba3 0282 	sub.w	r2, r3, r2, lsl #2
   20f48:	f858 2022 	ldr.w	r2, [r8, r2, lsl #2]
   20f4c:	2a00      	cmp	r2, #0
   20f4e:	bfcc      	ite	gt
   20f50:	461c      	movgt	r4, r3
   20f52:	2400      	movle	r4, #0
                        {
                            upNote = i;
                        }
                        if (i == 128)
                        {
                            upNote = 128;
   20f54:	2b80      	cmp	r3, #128	; 0x80
   20f56:	bf08      	it	eq
   20f58:	461c      	moveq	r4, r3
                    while ((i < 128) && (upNote == 0))
   20f5a:	2b7f      	cmp	r3, #127	; 0x7f
                        i++;
   20f5c:	f103 0301 	add.w	r3, r3, #1
                        if (chord[i%12] > 0)
   20f60:	fb8c 2503 	smull	r2, r5, ip, r3
   20f64:	ea4f 72e3 	mov.w	r2, r3, asr #31
                    while ((i < 128) && (upNote == 0))
   20f68:	dde7      	ble.n	20f3a <nearestNoteWithHysteresis+0x116>
                    int downNote = 128;
   20f6a:	2280      	movs	r2, #128	; 0x80
                    }
                    i = lastNearNote;
                    while ((i > 0) && (downNote == 128))
                    {
                        i--;
                        if (chord[i%12] > 0)
   20f6c:	4d2d      	ldr	r5, [pc, #180]	; (21024 <nearestNoteWithHysteresis+0x200>)
   20f6e:	e010      	b.n	20f92 <nearestNoteWithHysteresis+0x16e>
                    while ((i > 0) && (downNote == 128))
   20f70:	2a80      	cmp	r2, #128	; 0x80
                        if (chord[i%12] > 0)
   20f72:	ea4f 03d3 	mov.w	r3, r3, lsr #3
                    while ((i > 0) && (downNote == 128))
   20f76:	d112      	bne.n	20f9e <nearestNoteWithHysteresis+0x17a>
                        if (chord[i%12] > 0)
   20f78:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   20f7c:	eba1 0383 	sub.w	r3, r1, r3, lsl #2
   20f80:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
   20f84:	2b00      	cmp	r3, #0
   20f86:	bfcc      	ite	gt
   20f88:	460a      	movgt	r2, r1
   20f8a:	2280      	movle	r2, #128	; 0x80
                        {
                            downNote = i;
                        }
                        if (i == 0)
                        {
                            downNote = 0;
   20f8c:	2900      	cmp	r1, #0
   20f8e:	bf08      	it	eq
   20f90:	460a      	moveq	r2, r1
                    while ((i > 0) && (downNote == 128))
   20f92:	2900      	cmp	r1, #0
                        i--;
   20f94:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
                        if (chord[i%12] > 0)
   20f98:	fba5 c301 	umull	ip, r3, r5, r1
                    while ((i > 0) && (downNote == 128))
   20f9c:	dce8      	bgt.n	20f70 <nearestNoteWithHysteresis+0x14c>
                        }
                    }
                    //now should have adjacent notes in array available
                    //calculate the differences that should be necessary to move away
                    float upperNearHyst = (notes[upNote] - notes[lastNearNote]) * hysteresis;
                    float lowerNearHyst = (notes[lastNearNote] - notes[downNote]) * -hysteresis;
   20f9e:	eb07 0282 	add.w	r2, r7, r2, lsl #2

                    float theDifference = note - notes[lastNearNote];
   20fa2:	ee78 8ac0 	vsub.f32	s17, s17, s0
                    float lowerNearHyst = (notes[lastNearNote] - notes[downNote]) * -hysteresis;
   20fa6:	edd2 7a00 	vldr	s15, [r2]
   20faa:	ee70 7a67 	vsub.f32	s15, s0, s15
                    if ((theDifference > upperNearHyst) || (theDifference < lowerNearHyst))
   20fae:	ee69 7a67 	vnmul.f32	s15, s18, s15
   20fb2:	eef4 7ae8 	vcmpe.f32	s15, s17
   20fb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20fba:	dc0c      	bgt.n	20fd6 <nearestNoteWithHysteresis+0x1b2>
                    float upperNearHyst = (notes[upNote] - notes[lastNearNote]) * hysteresis;
   20fbc:	eb07 0484 	add.w	r4, r7, r4, lsl #2
   20fc0:	edd4 7a00 	vldr	s15, [r4]
   20fc4:	ee77 7ac0 	vsub.f32	s15, s15, s0
   20fc8:	ee27 9a89 	vmul.f32	s18, s15, s18
                    if ((theDifference > upperNearHyst) || (theDifference < lowerNearHyst))
   20fcc:	eeb4 9a68 	vcmp.f32	s18, s17
   20fd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20fd4:	d504      	bpl.n	20fe0 <nearestNoteWithHysteresis+0x1bc>
                    {
                        output = notes[nearIndex];
   20fd6:	eb07 0786 	add.w	r7, r7, r6, lsl #2
                        lastNearNote = nearIndex;
   20fda:	6006      	str	r6, [r0, #0]
                        output = notes[nearIndex];
   20fdc:	ed97 0a00 	vldr	s0, [r7]
            else
            {
                output = -1.0f; //signal that there are no notes to snap to
            }
            return output;
        }
   20fe0:	ecbd 8b04 	vpop	{d8-d9}
   20fe4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (chord[i] > 0)
   20fe8:	f8d8 202c 	ldr.w	r2, [r8, #44]	; 0x2c
   20fec:	2a00      	cmp	r2, #0
   20fee:	f73f af6e 	bgt.w	20ece <nearestNoteWithHysteresis+0xaa>
            if (hasNotes)
   20ff2:	2b00      	cmp	r3, #0
   20ff4:	f47f af6b 	bne.w	20ece <nearestNoteWithHysteresis+0xaa>
                output = -1.0f; //signal that there are no notes to snap to
   20ff8:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
        }
   20ffc:	ecbd 8b04 	vpop	{d8-d9}
   21000:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   21004:	020e5310 	.word	0x020e5310
   21008:	020e2de4 	.word	0x020e2de4
   2100c:	020e2df8 	.word	0x020e2df8
   21010:	020e2de8 	.word	0x020e2de8
   21014:	0006274c 	.word	0x0006274c
   21018:	020e2e70 	.word	0x020e2e70
   2101c:	020e5314 	.word	0x020e5314
   21020:	000627a4 	.word	0x000627a4
   21024:	aaaaaaab 	.word	0xaaaaaaab
   21028:	2aaaaaab 	.word	0x2aaaaaab
   2102c:	00000000 	.word	0x00000000

00021030 <SFXNeartuneTick>:
        {
   21030:	b5f0      	push	{r4, r5, r6, r7, lr}
   21032:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   21036:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
   2103a:	4d75      	ldr	r5, [pc, #468]	; (21210 <SFXNeartuneTick+0x1e0>)
   2103c:	eddf 7a75 	vldr	s15, [pc, #468]	; 21214 <SFXNeartuneTick+0x1e4>
        {
   21040:	b083      	sub	sp, #12
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   21042:	ed95 7a4b 	vldr	s14, [r5, #300]	; 0x12c
        {
   21046:	4606      	mov	r6, r0
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   21048:	eef0 6a48 	vmov.f32	s13, s16
   2104c:	4c72      	ldr	r4, [pc, #456]	; (21218 <SFXNeartuneTick+0x1e8>)
            tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
   2104e:	4873      	ldr	r0, [pc, #460]	; (2121c <SFXNeartuneTick+0x1ec>)
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   21050:	eee7 6a27 	vfma.f32	s13, s14, s15
            tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
   21054:	eeb0 0a66 	vmov.f32	s0, s13
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   21058:	edc4 6a00 	vstr	s13, [r4]
            tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
   2105c:	f005 fdcc 	bl	26bf8 <tRetune_setFidelityThreshold>
            displayValues[1] = LEAF_clip(0.0f, presetKnobValues[AutotuneMono][1] * 1.1f, 1.0f); // amount of forcing to new pitch
   21060:	eddf 7a6f 	vldr	s15, [pc, #444]	; 21220 <SFXNeartuneTick+0x1f0>
   21064:	edd5 0a4c 	vldr	s1, [r5, #304]	; 0x130
   21068:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   2106c:	ed9f 0a6d 	vldr	s0, [pc, #436]	; 21224 <SFXNeartuneTick+0x1f4>
   21070:	ee60 0aa7 	vmul.f32	s1, s1, s15
   21074:	f008 fb58 	bl	29728 <LEAF_clip>
            displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
   21078:	eef2 5a08 	vmov.f32	s11, #40	; 0x41400000  12.0
   2107c:	edd5 7a4e 	vldr	s15, [r5, #312]	; 0x138
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   21080:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
            displayValues[2] = presetKnobValues[AutotuneMono][2]; //speed to get to desired pitch shift
   21084:	edd5 6a4d 	vldr	s13, [r5, #308]	; 0x134
            displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
   21088:	ee67 7aa5 	vmul.f32	s15, s15, s11
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   2108c:	ed95 7a4f 	vldr	s14, [r5, #316]	; 0x13c
            if (displayValues[2] > .90f)
   21090:	eddf 5a65 	vldr	s11, [pc, #404]	; 21228 <SFXNeartuneTick+0x1f8>
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   21094:	ee37 7a06 	vadd.f32	s14, s14, s12
            displayValues[1] = LEAF_clip(0.0f, presetKnobValues[AutotuneMono][1] * 1.1f, 1.0f); // amount of forcing to new pitch
   21098:	ed84 0a01 	vstr	s0, [r4, #4]
            if (displayValues[2] > .90f)
   2109c:	eef4 6ae5 	vcmpe.f32	s13, s11
            displayValues[2] = presetKnobValues[AutotuneMono][2]; //speed to get to desired pitch shift
   210a0:	edc4 6a02 	vstr	s13, [r4, #8]
            displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
   210a4:	edc4 7a03 	vstr	s15, [r4, #12]
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   210a8:	ee27 7a08 	vmul.f32	s14, s14, s16
            if (displayValues[2] > .90f)
   210ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   210b0:	ed84 7a04 	vstr	s14, [r4, #16]
            if (displayValues[2] > .90f)
   210b4:	f300 8084 	bgt.w	211c0 <SFXNeartuneTick+0x190>
   210b8:	ee66 7aa6 	vmul.f32	s15, s13, s13
   210bc:	ee67 7aa6 	vmul.f32	s15, s15, s13
            tExpSmooth_setFactor(&neartune_smoother, expBuffer[(int)(displayValues[2] * displayValues[2] * displayValues[2] * expBufferSizeMinusOne)]);
   210c0:	4a5a      	ldr	r2, [pc, #360]	; (2122c <SFXNeartuneTick+0x1fc>)
   210c2:	4b5b      	ldr	r3, [pc, #364]	; (21230 <SFXNeartuneTick+0x200>)
   210c4:	ed92 7a00 	vldr	s14, [r2]
   210c8:	485a      	ldr	r0, [pc, #360]	; (21234 <SFXNeartuneTick+0x204>)
   210ca:	ee67 7a87 	vmul.f32	s15, s15, s14
   210ce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   210d2:	ee17 2a90 	vmov	r2, s15
   210d6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   210da:	ed93 0a00 	vldr	s0, [r3]
   210de:	f006 fe7d 	bl	27ddc <tExpSmooth_setFactor>
            float destFactor = tExpSmooth_tick(&neartune_smoother);
   210e2:	4854      	ldr	r0, [pc, #336]	; (21234 <SFXNeartuneTick+0x204>)
   210e4:	f006 fe96 	bl	27e14 <tExpSmooth_tick>
            float detectedPeriod = tRetune_getInputPeriod(&autotuneMono);
   210e8:	484c      	ldr	r0, [pc, #304]	; (2121c <SFXNeartuneTick+0x1ec>)
            float destFactor = tExpSmooth_tick(&neartune_smoother);
   210ea:	eef0 8a40 	vmov.f32	s17, s0
            float detectedPeriod = tRetune_getInputPeriod(&autotuneMono);
   210ee:	f005 fd87 	bl	26c00 <tRetune_getInputPeriod>
            if (detectedPeriod > 0.0f)
   210f2:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   210f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   210fa:	dd3b      	ble.n	21174 <SFXNeartuneTick+0x144>
                detectedNote = LEAF_frequencyToMidi(1.0f / detectedPeriod);
   210fc:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   21100:	4d4d      	ldr	r5, [pc, #308]	; (21238 <SFXNeartuneTick+0x208>)
   21102:	ee88 0a00 	vdiv.f32	s0, s16, s0
   21106:	f008 faa1 	bl	2964c <LEAF_frequencyToMidi>
                desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
   2110a:	edd4 0a04 	vldr	s1, [r4, #16]
                detectedNote = LEAF_frequencyToMidi(1.0f / detectedPeriod);
   2110e:	ed85 0a00 	vstr	s0, [r5]
                desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
   21112:	f7ff fe87 	bl	20e24 <nearestNoteWithHysteresis>
   21116:	4b49      	ldr	r3, [pc, #292]	; (2123c <SFXNeartuneTick+0x20c>)
                if (desiredSnap > 0.0f)
   21118:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
                desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
   2111c:	ed83 0a00 	vstr	s0, [r3]
                if (desiredSnap > 0.0f)
   21120:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   21124:	dd68      	ble.n	211f8 <SFXNeartuneTick+0x1c8>
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   21126:	edd4 6a01 	vldr	s13, [r4, #4]
   2112a:	edd5 7a00 	vldr	s15, [r5]
   2112e:	ee38 8a66 	vsub.f32	s16, s16, s13
                    factorDiff = (fabsf(destinationNote-lastSnap));
   21132:	4c43      	ldr	r4, [pc, #268]	; (21240 <SFXNeartuneTick+0x210>)
                    changeAmount = (fabsf(destinationNote-detectedNote));
   21134:	4a43      	ldr	r2, [pc, #268]	; (21244 <SFXNeartuneTick+0x214>)
                    factorDiff = (fabsf(destinationNote-lastSnap));
   21136:	ed94 7a00 	vldr	s14, [r4]
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   2113a:	ee28 8a27 	vmul.f32	s16, s16, s15
                    factorDiff = (fabsf(destinationNote-lastSnap));
   2113e:	4b42      	ldr	r3, [pc, #264]	; (21248 <SFXNeartuneTick+0x218>)
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   21140:	4f42      	ldr	r7, [pc, #264]	; (2124c <SFXNeartuneTick+0x21c>)
   21142:	eea0 8a26 	vfma.f32	s16, s0, s13
                    if ((changeAmount < 11.9))
   21146:	ed9f 6b30 	vldr	d6, [pc, #192]	; 21208 <SFXNeartuneTick+0x1d8>
                    changeAmount = (fabsf(destinationNote-detectedNote));
   2114a:	ee78 7a67 	vsub.f32	s15, s16, s15
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   2114e:	ed87 8a00 	vstr	s16, [r7]
                    factorDiff = (fabsf(destinationNote-lastSnap));
   21152:	ee38 7a47 	vsub.f32	s14, s16, s14
                    changeAmount = (fabsf(destinationNote-detectedNote));
   21156:	eef0 7ae7 	vabs.f32	s15, s15
                    factorDiff = (fabsf(destinationNote-lastSnap));
   2115a:	eeb0 7ac7 	vabs.f32	s14, s14
                    if ((changeAmount < 11.9))
   2115e:	eeb7 5ae7 	vcvt.f64.f32	d5, s15
                    changeAmount = (fabsf(destinationNote-detectedNote));
   21162:	edc2 7a00 	vstr	s15, [r2]
                    factorDiff = (fabsf(destinationNote-lastSnap));
   21166:	ed83 7a00 	vstr	s14, [r3]
                    if ((changeAmount < 11.9))
   2116a:	eeb4 5bc6 	vcmpe.f64	d5, d6
   2116e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   21172:	d42a      	bmi.n	211ca <SFXNeartuneTick+0x19a>
            tRetune_setPitchFactor(&autotuneMono, destFactor, 0);
   21174:	2100      	movs	r1, #0
   21176:	eeb0 0a68 	vmov.f32	s0, s17
   2117a:	4828      	ldr	r0, [pc, #160]	; (2121c <SFXNeartuneTick+0x1ec>)
   2117c:	f005 fd2a 	bl	26bd4 <tRetune_setPitchFactor>
            float* samples = tRetune_tick(&autotuneMono, input[1]);
   21180:	ed96 0a01 	vldr	s0, [r6, #4]
   21184:	4825      	ldr	r0, [pc, #148]	; (2121c <SFXNeartuneTick+0x1ec>)
   21186:	f005 fc51 	bl	26a2c <tRetune_tick>
   2118a:	4604      	mov	r4, r0
            LEAF_crossfade(tRamp_tick(&nearWetRamp), fades);
   2118c:	4830      	ldr	r0, [pc, #192]	; (21250 <SFXNeartuneTick+0x220>)
   2118e:	f006 fda5 	bl	27cdc <tRamp_tick>
   21192:	4668      	mov	r0, sp
   21194:	f008 fa44 	bl	29620 <LEAF_crossfade>
            sample += input[1] * fades[1]; // crossfade to dry signal if no notes held down.
   21198:	edd6 7a01 	vldr	s15, [r6, #4]
   2119c:	ed9d 7a01 	vldr	s14, [sp, #4]
   211a0:	edd4 6a00 	vldr	s13, [r4]
   211a4:	ee67 7a87 	vmul.f32	s15, s15, s14
   211a8:	ed9d 7a00 	vldr	s14, [sp]
   211ac:	eee6 7a87 	vfma.f32	s15, s13, s14
            input[0] = sample;
   211b0:	edc6 7a00 	vstr	s15, [r6]
            input[1] = sample;
   211b4:	edc6 7a01 	vstr	s15, [r6, #4]
        }
   211b8:	b003      	add	sp, #12
   211ba:	ecbd 8b02 	vpop	{d8}
   211be:	bdf0      	pop	{r4, r5, r6, r7, pc}
                displayValues[2] = 1.0f;
   211c0:	eef0 7a46 	vmov.f32	s15, s12
   211c4:	ed84 6a02 	vstr	s12, [r4, #8]
   211c8:	e77a      	b.n	210c0 <SFXNeartuneTick+0x90>
                        destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
   211ca:	eeb0 0a48 	vmov.f32	s0, s16
   211ce:	f008 fb95 	bl	298fc <LEAF_midiToFrequency>
   211d2:	eeb0 8a40 	vmov.f32	s16, s0
   211d6:	ed95 0a00 	vldr	s0, [r5]
   211da:	f008 fb8f 	bl	298fc <LEAF_midiToFrequency>
   211de:	4b1d      	ldr	r3, [pc, #116]	; (21254 <SFXNeartuneTick+0x224>)
   211e0:	eec8 7a00 	vdiv.f32	s15, s16, s0
                        tExpSmooth_setDest(&neartune_smoother, destinationFactor);
   211e4:	4813      	ldr	r0, [pc, #76]	; (21234 <SFXNeartuneTick+0x204>)
   211e6:	eeb0 0a67 	vmov.f32	s0, s15
                        destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
   211ea:	edc3 7a00 	vstr	s15, [r3]
                        tExpSmooth_setDest(&neartune_smoother, destinationFactor);
   211ee:	f006 fe07 	bl	27e00 <tExpSmooth_setDest>
                        lastSnap = destinationNote;
   211f2:	683b      	ldr	r3, [r7, #0]
   211f4:	6023      	str	r3, [r4, #0]
   211f6:	e7bd      	b.n	21174 <SFXNeartuneTick+0x144>
                    tExpSmooth_setDest(&neartune_smoother, 1.0f);
   211f8:	eeb0 0a48 	vmov.f32	s0, s16
   211fc:	480d      	ldr	r0, [pc, #52]	; (21234 <SFXNeartuneTick+0x204>)
   211fe:	f006 fdff 	bl	27e00 <tExpSmooth_setDest>
   21202:	e7b7      	b.n	21174 <SFXNeartuneTick+0x144>
   21204:	f3af 8000 	nop.w
   21208:	cccccccd 	.word	0xcccccccd
   2120c:	4027cccc 	.word	0x4027cccc
   21210:	020e55d8 	.word	0x020e55d8
   21214:	3efae148 	.word	0x3efae148
   21218:	020fb05c 	.word	0x020fb05c
   2121c:	020f9de0 	.word	0x020f9de0
   21220:	3f8ccccd 	.word	0x3f8ccccd
   21224:	00000000 	.word	0x00000000
   21228:	3f666666 	.word	0x3f666666
   2122c:	00062794 	.word	0x00062794
   21230:	020f990c 	.word	0x020f990c
   21234:	020f9eb0 	.word	0x020f9eb0
   21238:	0006278c 	.word	0x0006278c
   2123c:	00062780 	.word	0x00062780
   21240:	000627a8 	.word	0x000627a8
   21244:	020e2df4 	.word	0x020e2df4
   21248:	020e2e48 	.word	0x020e2e48
   2124c:	00062788 	.word	0x00062788
   21250:	020fac2c 	.word	0x020fac2c
   21254:	00062784 	.word	0x00062784

00021258 <noteOff>:
            }
        }

        void noteOff(int key, int velocity)
        {
            if (chordArray[key%12] > 0) chordArray[key%12]--;
   21258:	4a4d      	ldr	r2, [pc, #308]	; (21390 <noteOff+0x138>)
   2125a:	494e      	ldr	r1, [pc, #312]	; (21394 <noteOff+0x13c>)
   2125c:	fb82 3200 	smull	r3, r2, r2, r0
   21260:	17c3      	asrs	r3, r0, #31
   21262:	ebc3 0362 	rsb	r3, r3, r2, asr #1
   21266:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   2126a:	eba0 0383 	sub.w	r3, r0, r3, lsl #2
        {
   2126e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            if (chordArray[key%12] > 0) chordArray[key%12]--;
   21272:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
        {
   21276:	4604      	mov	r4, r0
            if (chordArray[key%12] > 0) chordArray[key%12]--;
   21278:	2a00      	cmp	r2, #0
   2127a:	dd02      	ble.n	21282 <noteOff+0x2a>
   2127c:	3a01      	subs	r2, #1
   2127e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]



            if (currentPreset == Rhodes)
   21282:	4b45      	ldr	r3, [pc, #276]	; (21398 <noteOff+0x140>)
   21284:	781b      	ldrb	r3, [r3, #0]
   21286:	2b11      	cmp	r3, #17
   21288:	d03b      	beq.n	21302 <noteOff+0xaa>
                        tADSR4_off(&FM_envs[voice][j]);
                    }
                }

            }
            else if (currentPreset == ClassicSynth)
   2128a:	2b10      	cmp	r3, #16
   2128c:	d056      	beq.n	2133c <noteOff+0xe4>
                    tADSR4_off(&polyEnvs[voice]);
                    tADSR4_off(&polyFiltEnvs[voice]);
                }
            }

            else if (currentPreset == SamplerKeyboard)
   2128e:	2b06      	cmp	r3, #6
   21290:	d00c      	beq.n	212ac <noteOff+0x54>
                    UISamplerKButtons(ButtonC, ActionHoldContinuous);
                    tSampler_stop(&keySampler[key-LOWEST_SAMPLER_KEY]);
                    waitingForDeactivation[voice] = key;
                }
            }
            else if (currentPreset == LivingStringSynth)
   21292:	2b0f      	cmp	r3, #15
   21294:	b2e1      	uxtb	r1, r4
            {
                int voice;

                voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   21296:	4841      	ldr	r0, [pc, #260]	; (2139c <noteOff+0x144>)
            else if (currentPreset == LivingStringSynth)
   21298:	d065      	beq.n	21366 <noteOff+0x10e>
                    tADSR4_off(&pluckEnvs[voice]);
                }
            }
            else
            {
                tSimplePoly_noteOff(&poly, key);
   2129a:	f008 ff55 	bl	2a148 <tSimplePoly_noteOff>
            }

            if (tSimplePoly_getNumActiveVoices(&poly) < 1)
   2129e:	483f      	ldr	r0, [pc, #252]	; (2139c <noteOff+0x144>)
   212a0:	f009 f8ae 	bl	2a400 <tSimplePoly_getNumActiveVoices>
   212a4:	2800      	cmp	r0, #0
   212a6:	dd27      	ble.n	212f8 <noteOff+0xa0>
            {
                setLED_2(0);
            }

        }
   212a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                if (key >= LOWEST_SAMPLER_KEY && key < LOWEST_SAMPLER_KEY + NUM_SAMPLER_KEYS)
   212ac:	f1a4 0524 	sub.w	r5, r4, #36	; 0x24
   212b0:	2d30      	cmp	r5, #48	; 0x30
   212b2:	d8f4      	bhi.n	2129e <noteOff+0x46>
   212b4:	00af      	lsls	r7, r5, #2
                    if (tBuffer_isActive(&keyBuff[key-LOWEST_SAMPLER_KEY]) == 1)
   212b6:	4e3a      	ldr	r6, [pc, #232]	; (213a0 <noteOff+0x148>)
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   212b8:	b2e1      	uxtb	r1, r4
   212ba:	4838      	ldr	r0, [pc, #224]	; (2139c <noteOff+0x144>)
                    if (tBuffer_isActive(&keyBuff[key-LOWEST_SAMPLER_KEY]) == 1)
   212bc:	443e      	add	r6, r7
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   212be:	f009 f827 	bl	2a310 <tSimplePoly_markPendingNoteOff>
   212c2:	4680      	mov	r8, r0
                    if (tBuffer_isActive(&keyBuff[key-LOWEST_SAMPLER_KEY]) == 1)
   212c4:	4630      	mov	r0, r6
   212c6:	f00a fcb5 	bl	2bc34 <tBuffer_isActive>
   212ca:	2801      	cmp	r0, #1
   212cc:	d058      	beq.n	21380 <noteOff+0x128>
                        tExpSmooth_setDest(&kSamplerGains[key-LOWEST_SAMPLER_KEY], 0.0f);
   212ce:	4835      	ldr	r0, [pc, #212]	; (213a4 <noteOff+0x14c>)
   212d0:	ed9f 0a35 	vldr	s0, [pc, #212]	; 213a8 <noteOff+0x150>
   212d4:	4438      	add	r0, r7
   212d6:	f006 fd93 	bl	27e00 <tExpSmooth_setDest>
                    samplerKeyHeld[key-LOWEST_SAMPLER_KEY] = 0;
   212da:	4b34      	ldr	r3, [pc, #208]	; (213ac <noteOff+0x154>)
   212dc:	2200      	movs	r2, #0
                    UISamplerKButtons(ButtonC, ActionHoldContinuous);
   212de:	2103      	movs	r1, #3
   212e0:	2007      	movs	r0, #7
                    samplerKeyHeld[key-LOWEST_SAMPLER_KEY] = 0;
   212e2:	555a      	strb	r2, [r3, r5]
                    UISamplerKButtons(ButtonC, ActionHoldContinuous);
   212e4:	f001 ff18 	bl	23118 <UISamplerKButtons>
                    tSampler_stop(&keySampler[key-LOWEST_SAMPLER_KEY]);
   212e8:	4831      	ldr	r0, [pc, #196]	; (213b0 <noteOff+0x158>)
   212ea:	4438      	add	r0, r7
   212ec:	f00a fdb8 	bl	2be60 <tSampler_stop>
                    waitingForDeactivation[voice] = key;
   212f0:	4b30      	ldr	r3, [pc, #192]	; (213b4 <noteOff+0x15c>)
   212f2:	f843 4028 	str.w	r4, [r3, r8, lsl #2]
   212f6:	e7d2      	b.n	2129e <noteOff+0x46>
                setLED_2(0);
   212f8:	2000      	movs	r0, #0
        }
   212fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
                setLED_2(0);
   212fe:	f7f8 b8b7 	b.w	19470 <setLED_2>
                if (tSimplePoly_getNumVoices(&poly) > 1)
   21302:	4826      	ldr	r0, [pc, #152]	; (2139c <noteOff+0x144>)
   21304:	f009 f878 	bl	2a3f8 <tSimplePoly_getNumVoices>
   21308:	2801      	cmp	r0, #1
   2130a:	b2e1      	uxtb	r1, r4
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   2130c:	4823      	ldr	r0, [pc, #140]	; (2139c <noteOff+0x144>)
                if (tSimplePoly_getNumVoices(&poly) > 1)
   2130e:	dd12      	ble.n	21336 <noteOff+0xde>
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   21310:	f008 fffe 	bl	2a310 <tSimplePoly_markPendingNoteOff>
                if (voice >= 0)
   21314:	2800      	cmp	r0, #0
   21316:	dbc2      	blt.n	2129e <noteOff+0x46>
   21318:	4c27      	ldr	r4, [pc, #156]	; (213b8 <noteOff+0x160>)
   2131a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   2131e:	f104 0518 	add.w	r5, r4, #24
   21322:	00c0      	lsls	r0, r0, #3
   21324:	4404      	add	r4, r0
   21326:	4405      	add	r5, r0
                        tADSR4_off(&FM_envs[voice][j]);
   21328:	4620      	mov	r0, r4
   2132a:	3404      	adds	r4, #4
   2132c:	f006 fa28 	bl	27780 <tADSR4_off>
                    for (int j = 0; j < 6; j++)
   21330:	42a5      	cmp	r5, r4
   21332:	d1f9      	bne.n	21328 <noteOff+0xd0>
   21334:	e7b3      	b.n	2129e <noteOff+0x46>
                    voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   21336:	f008 ff07 	bl	2a148 <tSimplePoly_noteOff>
   2133a:	e7eb      	b.n	21314 <noteOff+0xbc>
                if (tSimplePoly_getNumVoices(&poly) > 1)
   2133c:	4817      	ldr	r0, [pc, #92]	; (2139c <noteOff+0x144>)
   2133e:	f009 f85b 	bl	2a3f8 <tSimplePoly_getNumVoices>
   21342:	2801      	cmp	r0, #1
   21344:	b2e1      	uxtb	r1, r4
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   21346:	4815      	ldr	r0, [pc, #84]	; (2139c <noteOff+0x144>)
                if (tSimplePoly_getNumVoices(&poly) > 1)
   21348:	dd17      	ble.n	2137a <noteOff+0x122>
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   2134a:	f008 ffe1 	bl	2a310 <tSimplePoly_markPendingNoteOff>
                if (voice >= 0)
   2134e:	2800      	cmp	r0, #0
   21350:	dba5      	blt.n	2129e <noteOff+0x46>
   21352:	0084      	lsls	r4, r0, #2
                    tADSR4_off(&polyEnvs[voice]);
   21354:	4819      	ldr	r0, [pc, #100]	; (213bc <noteOff+0x164>)
   21356:	4420      	add	r0, r4
   21358:	f006 fa12 	bl	27780 <tADSR4_off>
                    tADSR4_off(&polyFiltEnvs[voice]);
   2135c:	4818      	ldr	r0, [pc, #96]	; (213c0 <noteOff+0x168>)
   2135e:	4420      	add	r0, r4
   21360:	f006 fa0e 	bl	27780 <tADSR4_off>
   21364:	e79b      	b.n	2129e <noteOff+0x46>
                voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   21366:	f008 feef 	bl	2a148 <tSimplePoly_noteOff>
                if (voice >= 0)
   2136a:	2800      	cmp	r0, #0
   2136c:	db97      	blt.n	2129e <noteOff+0x46>
                    tADSR4_off(&pluckEnvs[voice]);
   2136e:	4b15      	ldr	r3, [pc, #84]	; (213c4 <noteOff+0x16c>)
   21370:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   21374:	f006 fa04 	bl	27780 <tADSR4_off>
   21378:	e791      	b.n	2129e <noteOff+0x46>
                    voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   2137a:	f008 fee5 	bl	2a148 <tSimplePoly_noteOff>
   2137e:	e7e6      	b.n	2134e <noteOff+0xf6>
                        tBuffer_stop(&keyBuff[key-LOWEST_SAMPLER_KEY]);
   21380:	4630      	mov	r0, r6
   21382:	f00a fc3f 	bl	2bc04 <tBuffer_stop>
                        UISamplerKButtons(ButtonUp, ActionPress);
   21386:	2100      	movs	r1, #0
   21388:	2004      	movs	r0, #4
   2138a:	f001 fec5 	bl	23118 <UISamplerKButtons>
   2138e:	e7a4      	b.n	212da <noteOff+0x82>
   21390:	2aaaaaab 	.word	0x2aaaaaab
   21394:	020e2df8 	.word	0x020e2df8
   21398:	020e2f19 	.word	0x020e2f19
   2139c:	020f9de8 	.word	0x020f9de8
   213a0:	020faa2c 	.word	0x020faa2c
   213a4:	020e4f54 	.word	0x020e4f54
   213a8:	00000000 	.word	0x00000000
   213ac:	020fa000 	.word	0x020fa000
   213b0:	020e5df4 	.word	0x020e5df4
   213b4:	020f9edc 	.word	0x020f9edc
   213b8:	020f9df0 	.word	0x020f9df0
   213bc:	020f9f64 	.word	0x020f9f64
   213c0:	020e4810 	.word	0x020e4810
   213c4:	020f9cd0 	.word	0x020f9cd0

000213c8 <noteOn>:
            if (!velocity)
   213c8:	2900      	cmp	r1, #0
   213ca:	d038      	beq.n	2143e <noteOn+0x76>
                chordArray[key%12]++;
   213cc:	4a73      	ldr	r2, [pc, #460]	; (2159c <noteOn+0x1d4>)
        {
   213ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   213d0:	4604      	mov	r4, r0
   213d2:	460d      	mov	r5, r1
                chordArray[key%12]++;
   213d4:	17c3      	asrs	r3, r0, #31
   213d6:	4872      	ldr	r0, [pc, #456]	; (215a0 <noteOn+0x1d8>)
   213d8:	fb82 1204 	smull	r1, r2, r2, r4
                if (currentPreset == AutotuneMono)
   213dc:	4971      	ldr	r1, [pc, #452]	; (215a4 <noteOn+0x1dc>)
                chordArray[key%12]++;
   213de:	ebc3 0362 	rsb	r3, r3, r2, asr #1
   213e2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   213e6:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
        {
   213ea:	ed2d 8b02 	vpush	{d8}
                chordArray[key%12]++;
   213ee:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
                if (currentPreset == AutotuneMono)
   213f2:	7809      	ldrb	r1, [r1, #0]
                chordArray[key%12]++;
   213f4:	3201      	adds	r2, #1
                if (currentPreset == AutotuneMono)
   213f6:	2903      	cmp	r1, #3
                chordArray[key%12]++;
   213f8:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
                if (currentPreset == AutotuneMono)
   213fc:	d010      	beq.n	21420 <noteOn+0x58>
                if (currentPreset == Rhodes)
   213fe:	2911      	cmp	r1, #17
   21400:	d03a      	beq.n	21478 <noteOn+0xb0>
                else if (currentPreset == ClassicSynth)
   21402:	2910      	cmp	r1, #16
   21404:	d05f      	beq.n	214c6 <noteOn+0xfe>
                else if (currentPreset == SamplerKeyboard)
   21406:	2906      	cmp	r1, #6
   21408:	d123      	bne.n	21452 <noteOn+0x8a>
                    if ((key >= LOWEST_SAMPLER_KEY) && key < (LOWEST_SAMPLER_KEY + NUM_SAMPLER_KEYS))
   2140a:	f1a4 0624 	sub.w	r6, r4, #36	; 0x24
   2140e:	2e30      	cmp	r6, #48	; 0x30
   21410:	d972      	bls.n	214f8 <noteOn+0x130>
                setLED_2(1);
   21412:	2001      	movs	r0, #1
        }
   21414:	ecbd 8b02 	vpop	{d8}
   21418:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                setLED_2(1);
   2141c:	f7f8 b828 	b.w	19470 <setLED_2>
                    if (autotuneLock)
   21420:	4a61      	ldr	r2, [pc, #388]	; (215a8 <noteOn+0x1e0>)
   21422:	6812      	ldr	r2, [r2, #0]
   21424:	b96a      	cbnz	r2, 21442 <noteOn+0x7a>
   21426:	b2ea      	uxtb	r2, r5
                    tSimplePoly_noteOn(&poly, key, velocity);
   21428:	4621      	mov	r1, r4
   2142a:	4860      	ldr	r0, [pc, #384]	; (215ac <noteOn+0x1e4>)
   2142c:	f008 fd60 	bl	29ef0 <tSimplePoly_noteOn>
                setLED_2(1);
   21430:	2001      	movs	r0, #1
        }
   21432:	ecbd 8b02 	vpop	{d8}
   21436:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                setLED_2(1);
   2143a:	f7f8 b819 	b.w	19470 <setLED_2>
                noteOff(key, velocity);
   2143e:	f7ff bf0b 	b.w	21258 <noteOff>
                        lockArray[key%12]++;
   21442:	485b      	ldr	r0, [pc, #364]	; (215b0 <noteOn+0x1e8>)
   21444:	b2ea      	uxtb	r2, r5
   21446:	f850 1023 	ldr.w	r1, [r0, r3, lsl #2]
   2144a:	3101      	adds	r1, #1
   2144c:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
   21450:	e7ea      	b.n	21428 <noteOn+0x60>
                else if (currentPreset == LivingStringSynth)
   21452:	290f      	cmp	r1, #15
   21454:	b2ea      	uxtb	r2, r5
   21456:	d1e7      	bne.n	21428 <noteOn+0x60>
                    int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
   21458:	4621      	mov	r1, r4
   2145a:	4854      	ldr	r0, [pc, #336]	; (215ac <noteOn+0x1e4>)
   2145c:	f008 fd48 	bl	29ef0 <tSimplePoly_noteOn>
                    if (whichVoice >= 0)
   21460:	2800      	cmp	r0, #0
   21462:	dbd6      	blt.n	21412 <noteOn+0x4a>
                        tADSR4_on(&pluckEnvs[whichVoice], velocity * 0.0078125f);
   21464:	4b53      	ldr	r3, [pc, #332]	; (215b4 <noteOn+0x1ec>)
   21466:	ee00 5a10 	vmov	s0, r5
   2146a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   2146e:	eeba 0aec 	vcvt.f32.s32	s0, s0, #7
   21472:	f006 f973 	bl	2775c <tADSR4_on>
   21476:	e7cc      	b.n	21412 <noteOn+0x4a>
                    int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
   21478:	b2ea      	uxtb	r2, r5
   2147a:	4621      	mov	r1, r4
   2147c:	484b      	ldr	r0, [pc, #300]	; (215ac <noteOn+0x1e4>)
   2147e:	f008 fd37 	bl	29ef0 <tSimplePoly_noteOn>
                    if (whichVoice >= 0)
   21482:	1e07      	subs	r7, r0, #0
   21484:	dbc5      	blt.n	21412 <noteOn+0x4a>
   21486:	eb07 0647 	add.w	r6, r7, r7, lsl #1
   2148a:	4b4b      	ldr	r3, [pc, #300]	; (215b8 <noteOn+0x1f0>)
                            tADSR4_on(&FM_envs[whichVoice][j], velocity * 0.0078125f);
   2148c:	ee08 5a10 	vmov	s16, r5
   21490:	00f2      	lsls	r2, r6, #3
   21492:	f103 0618 	add.w	r6, r3, #24
   21496:	eeba 8aec 	vcvt.f32.s32	s16, s16, #7
   2149a:	18d5      	adds	r5, r2, r3
   2149c:	4416      	add	r6, r2
   2149e:	4628      	mov	r0, r5
   214a0:	3504      	adds	r5, #4
   214a2:	eeb0 0a48 	vmov.f32	s0, s16
   214a6:	f006 f959 	bl	2775c <tADSR4_on>
                        for (int j = 0; j < 6; j++)
   214aa:	42ae      	cmp	r6, r5
   214ac:	d1f7      	bne.n	2149e <noteOn+0xd6>
                        panValues[whichVoice] = key * 0.0078125; // divide by 128.0f
   214ae:	ee07 4a10 	vmov	s14, r4
   214b2:	eeba 7bec 	vcvt.f64.s32	d7, d7, #7
   214b6:	4b41      	ldr	r3, [pc, #260]	; (215bc <noteOn+0x1f4>)
   214b8:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   214bc:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
   214c0:	ed87 7a00 	vstr	s14, [r7]
   214c4:	e7a5      	b.n	21412 <noteOn+0x4a>
                    int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
   214c6:	4621      	mov	r1, r4
   214c8:	b2ea      	uxtb	r2, r5
   214ca:	4838      	ldr	r0, [pc, #224]	; (215ac <noteOn+0x1e4>)
   214cc:	f008 fd10 	bl	29ef0 <tSimplePoly_noteOn>
                    if (whichVoice >= 0)
   214d0:	2800      	cmp	r0, #0
   214d2:	db9e      	blt.n	21412 <noteOn+0x4a>
                        tADSR4_on(&polyEnvs[whichVoice], velocity * 0.0078125f);
   214d4:	ee08 5a10 	vmov	s16, r5
   214d8:	0084      	lsls	r4, r0, #2
   214da:	4839      	ldr	r0, [pc, #228]	; (215c0 <noteOn+0x1f8>)
   214dc:	eeba 8aec 	vcvt.f32.s32	s16, s16, #7
   214e0:	4420      	add	r0, r4
   214e2:	eeb0 0a48 	vmov.f32	s0, s16
   214e6:	f006 f939 	bl	2775c <tADSR4_on>
                        tADSR4_on(&polyFiltEnvs[whichVoice], velocity * 0.0078125f);
   214ea:	4836      	ldr	r0, [pc, #216]	; (215c4 <noteOn+0x1fc>)
   214ec:	eeb0 0a48 	vmov.f32	s0, s16
   214f0:	4420      	add	r0, r4
   214f2:	f006 f933 	bl	2775c <tADSR4_on>
   214f6:	e78c      	b.n	21412 <noteOn+0x4a>
                        int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
   214f8:	4621      	mov	r1, r4
   214fa:	b2ea      	uxtb	r2, r5
   214fc:	482b      	ldr	r0, [pc, #172]	; (215ac <noteOn+0x1e4>)
   214fe:	f008 fcf7 	bl	29ef0 <tSimplePoly_noteOn>
                        if (whichVoice >= 0)
   21502:	2800      	cmp	r0, #0
   21504:	db85      	blt.n	21412 <noteOn+0x4a>
                            if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
   21506:	4f30      	ldr	r7, [pc, #192]	; (215c8 <noteOn+0x200>)
                            currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
   21508:	4c30      	ldr	r4, [pc, #192]	; (215cc <noteOn+0x204>)
                            if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
   2150a:	eb07 0086 	add.w	r0, r7, r6, lsl #2
                            currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
   2150e:	6026      	str	r6, [r4, #0]
                            if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
   21510:	f00a fb88 	bl	2bc24 <tBuffer_getRecordedLength>
   21514:	b968      	cbnz	r0, 21532 <noteOn+0x16a>
                                tBuffer_record(&keyBuff[currentSamplerKeyGlobal]);
   21516:	6820      	ldr	r0, [r4, #0]
   21518:	eb07 0080 	add.w	r0, r7, r0, lsl #2
   2151c:	f00a fb6c 	bl	2bbf8 <tBuffer_record>
                                newBuffer[currentSamplerKeyGlobal] = 1;
   21520:	6823      	ldr	r3, [r4, #0]
   21522:	4a2b      	ldr	r2, [pc, #172]	; (215d0 <noteOn+0x208>)
   21524:	2101      	movs	r1, #1
   21526:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                            samplerKeyHeld[currentSamplerKeyGlobal] = 1;
   2152a:	4a2a      	ldr	r2, [pc, #168]	; (215d4 <noteOn+0x20c>)
   2152c:	2101      	movs	r1, #1
   2152e:	54d1      	strb	r1, [r2, r3]
   21530:	e76f      	b.n	21412 <noteOn+0x4a>
                                tSampler_play(&keySampler[currentSamplerKeyGlobal]);
   21532:	4b29      	ldr	r3, [pc, #164]	; (215d8 <noteOn+0x210>)
   21534:	6820      	ldr	r0, [r4, #0]
                                if (newBuffer[currentSamplerKeyGlobal])
   21536:	4e26      	ldr	r6, [pc, #152]	; (215d0 <noteOn+0x208>)
                                tSampler_play(&keySampler[currentSamplerKeyGlobal]);
   21538:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   2153c:	f00a fc40 	bl	2bdc0 <tSampler_play>
                                if (newBuffer[currentSamplerKeyGlobal])
   21540:	6823      	ldr	r3, [r4, #0]
   21542:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
   21546:	b9ba      	cbnz	r2, 21578 <noteOn+0x1b0>
   21548:	009a      	lsls	r2, r3, #2
                                float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
   2154a:	4b24      	ldr	r3, [pc, #144]	; (215dc <noteOn+0x214>)
   2154c:	ee07 5a90 	vmov	s15, r5
   21550:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   21554:	eddf 6a22 	vldr	s13, [pc, #136]	; 215e0 <noteOn+0x218>
   21558:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   2155c:	edd3 7a06 	vldr	s15, [r3, #24]
                                tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
   21560:	4820      	ldr	r0, [pc, #128]	; (215e4 <noteOn+0x21c>)
                                float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
   21562:	ee30 0a67 	vsub.f32	s0, s0, s15
   21566:	ee67 7aa6 	vmul.f32	s15, s15, s13
                                tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
   2156a:	4410      	add	r0, r2
   2156c:	eea7 0a27 	vfma.f32	s0, s14, s15
   21570:	f006 fc46 	bl	27e00 <tExpSmooth_setDest>
   21574:	6823      	ldr	r3, [r4, #0]
   21576:	e7d8      	b.n	2152a <noteOn+0x162>
                                    int recordLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]);
   21578:	eb07 0083 	add.w	r0, r7, r3, lsl #2
   2157c:	f00a fb52 	bl	2bc24 <tBuffer_getRecordedLength>
                                    samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
   21580:	6823      	ldr	r3, [r4, #0]
   21582:	ee07 0a90 	vmov	s15, r0
   21586:	4918      	ldr	r1, [pc, #96]	; (215e8 <noteOn+0x220>)
   21588:	009a      	lsls	r2, r3, #2
                                    newBuffer[currentSamplerKeyGlobal] = 0;
   2158a:	2000      	movs	r0, #0
                                    samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
   2158c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   21590:	4411      	add	r1, r2
                                    newBuffer[currentSamplerKeyGlobal] = 0;
   21592:	f846 0023 	str.w	r0, [r6, r3, lsl #2]
                                    samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
   21596:	edc1 7a00 	vstr	s15, [r1]
   2159a:	e7d6      	b.n	2154a <noteOn+0x182>
   2159c:	2aaaaaab 	.word	0x2aaaaaab
   215a0:	020e2df8 	.word	0x020e2df8
   215a4:	020e2f19 	.word	0x020e2f19
   215a8:	020e2de8 	.word	0x020e2de8
   215ac:	020f9de8 	.word	0x020f9de8
   215b0:	020e2e70 	.word	0x020e2e70
   215b4:	020f9cd0 	.word	0x020f9cd0
   215b8:	020f9df0 	.word	0x020f9df0
   215bc:	020e50e4 	.word	0x020e50e4
   215c0:	020f9f64 	.word	0x020f9f64
   215c4:	020e4810 	.word	0x020e4810
   215c8:	020faa2c 	.word	0x020faa2c
   215cc:	0006277c 	.word	0x0006277c
   215d0:	020e501c 	.word	0x020e501c
   215d4:	020fa000 	.word	0x020fa000
   215d8:	020e5df4 	.word	0x020e5df4
   215dc:	020fb05c 	.word	0x020fb05c
   215e0:	3c000000 	.word	0x3c000000
   215e4:	020e4f54 	.word	0x020e4f54
   215e8:	020e5148 	.word	0x020e5148

000215ec <pitchBend>:


        void pitchBend(int data)
        {
            pitchBendValue = (data - 8192) * 0.000244140625f;
   215ec:	f5a0 5300 	sub.w	r3, r0, #8192	; 0x2000
   215f0:	ee07 3a90 	vmov	s15, r3
   215f4:	4b02      	ldr	r3, [pc, #8]	; (21600 <pitchBend+0x14>)
   215f6:	eefa 7aca 	vcvt.f32.s32	s15, s15, #12
   215fa:	edc3 7a00 	vstr	s15, [r3]
        }
   215fe:	4770      	bx	lr
   21600:	020e2ea0 	.word	0x020e2ea0

00021604 <sustainOff>:
   21604:	4770      	bx	lr
   21606:	bf00      	nop

00021608 <sustainOn>:
        }

        void sustainOn()
        {

        }
   21608:	4770      	bx	lr
   2160a:	bf00      	nop

0002160c <ssd1306_begin>:
uint8_t OLED_i2c_address;
uint8_t OLED_externalVCC;
I2C_HandleTypeDef* OLED_i2c_handle;

void ssd1306_begin(I2C_HandleTypeDef* hi2c, uint8_t vccstate, uint8_t i2caddr)
{
   2160c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	OLED_i2c_address = i2caddr;
   21610:	4ea9      	ldr	r6, [pc, #676]	; (218b8 <ssd1306_begin+0x2ac>)
{
   21612:	4688      	mov	r8, r1
	OLED_externalVCC = vccstate;
	OLED_i2c_handle = hi2c;
   21614:	4da9      	ldr	r5, [pc, #676]	; (218bc <ssd1306_begin+0x2b0>)
{
   21616:	b084      	sub	sp, #16
	OLED_externalVCC = vccstate;
   21618:	4ba9      	ldr	r3, [pc, #676]	; (218c0 <ssd1306_begin+0x2b4>)

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   2161a:	f44f 7100 	mov.w	r1, #512	; 0x200
	OLED_i2c_address = i2caddr;
   2161e:	7032      	strb	r2, [r6, #0]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   21620:	2201      	movs	r2, #1
	OLED_i2c_handle = hi2c;
   21622:	6028      	str	r0, [r5, #0]

void ssd1306_command(uint8_t c) {
	// I2C
	//	uint8_t control = 0x00;   // Co = 0, D/C = 0

	uint8_t i2c_message[2] = {0,0};
   21624:	ac04      	add	r4, sp, #16
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   21626:	48a7      	ldr	r0, [pc, #668]	; (218c4 <ssd1306_begin+0x2b8>)
	i2c_message[1] = c;
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21628:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	OLED_externalVCC = vccstate;
   2162c:	f883 8000 	strb.w	r8, [r3]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   21630:	f7ea fe00 	bl	c234 <HAL_GPIO_WritePin>
	HAL_Delay(1);
   21634:	2001      	movs	r0, #1
   21636:	f7e6 fee3 	bl	8400 <HAL_Delay>
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET); //PULL RESET LINE HIGH
   2163a:	2200      	movs	r2, #0
   2163c:	f44f 7100 	mov.w	r1, #512	; 0x200
   21640:	48a0      	ldr	r0, [pc, #640]	; (218c4 <ssd1306_begin+0x2b8>)
   21642:	f7ea fdf7 	bl	c234 <HAL_GPIO_WritePin>
	HAL_Delay(10);
   21646:	200a      	movs	r0, #10
   21648:	f7e6 feda 	bl	8400 <HAL_Delay>
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   2164c:	2201      	movs	r2, #1
   2164e:	f44f 7100 	mov.w	r1, #512	; 0x200
   21652:	489c      	ldr	r0, [pc, #624]	; (218c4 <ssd1306_begin+0x2b8>)
   21654:	f7ea fdee 	bl	c234 <HAL_GPIO_WritePin>
	uint8_t i2c_message[2] = {0,0};
   21658:	f44f 432e 	mov.w	r3, #44544	; 0xae00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2165c:	7831      	ldrb	r1, [r6, #0]
   2165e:	6828      	ldr	r0, [r5, #0]
   21660:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   21662:	f824 3d04 	strh.w	r3, [r4, #-4]!
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21666:	2302      	movs	r3, #2
   21668:	4622      	mov	r2, r4
   2166a:	f7eb f905 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2166e:	f44f 4c55 	mov.w	ip, #54528	; 0xd500
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21672:	7831      	ldrb	r1, [r6, #0]
   21674:	4622      	mov	r2, r4
   21676:	6828      	ldr	r0, [r5, #0]
   21678:	2302      	movs	r3, #2
   2167a:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   2167c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21680:	f7eb f8fa 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21684:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21688:	7831      	ldrb	r1, [r6, #0]
   2168a:	6828      	ldr	r0, [r5, #0]
   2168c:	4622      	mov	r2, r4
   2168e:	9700      	str	r7, [sp, #0]
   21690:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21692:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21696:	f7eb f8ef 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2169a:	f44f 4c28 	mov.w	ip, #43008	; 0xa800
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2169e:	7831      	ldrb	r1, [r6, #0]
   216a0:	6828      	ldr	r0, [r5, #0]
   216a2:	4622      	mov	r2, r4
   216a4:	9700      	str	r7, [sp, #0]
   216a6:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   216a8:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   216ac:	f7eb f8e4 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   216b0:	f44f 5cf8 	mov.w	ip, #7936	; 0x1f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   216b4:	7831      	ldrb	r1, [r6, #0]
   216b6:	6828      	ldr	r0, [r5, #0]
   216b8:	4622      	mov	r2, r4
   216ba:	9700      	str	r7, [sp, #0]
   216bc:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   216be:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   216c2:	f7eb f8d9 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   216c6:	f44f 4c53 	mov.w	ip, #54016	; 0xd300
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   216ca:	7831      	ldrb	r1, [r6, #0]
   216cc:	6828      	ldr	r0, [r5, #0]
   216ce:	4622      	mov	r2, r4
   216d0:	9700      	str	r7, [sp, #0]
   216d2:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   216d4:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   216d8:	f7eb f8ce 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   216dc:	f04f 0c00 	mov.w	ip, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   216e0:	7831      	ldrb	r1, [r6, #0]
   216e2:	6828      	ldr	r0, [r5, #0]
   216e4:	4622      	mov	r2, r4
   216e6:	9700      	str	r7, [sp, #0]
   216e8:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   216ea:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   216ee:	f7eb f8c3 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   216f2:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   216f6:	7831      	ldrb	r1, [r6, #0]
   216f8:	6828      	ldr	r0, [r5, #0]
   216fa:	4622      	mov	r2, r4
   216fc:	9700      	str	r7, [sp, #0]
   216fe:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21700:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21704:	f7eb f8b8 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21708:	f44f 4c0d 	mov.w	ip, #36096	; 0x8d00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2170c:	7831      	ldrb	r1, [r6, #0]
   2170e:	6828      	ldr	r0, [r5, #0]
   21710:	4622      	mov	r2, r4
   21712:	9700      	str	r7, [sp, #0]
   21714:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21716:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2171a:	f7eb f8ad 	bl	c878 <HAL_I2C_Master_Transmit>
	if (vccstate == SSD1306_EXTERNALVCC)
   2171e:	f1b8 0f01 	cmp.w	r8, #1
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21722:	6828      	ldr	r0, [r5, #0]
   21724:	7831      	ldrb	r1, [r6, #0]
   21726:	4622      	mov	r2, r4
	uint8_t i2c_message[2] = {0,0};
   21728:	bf0c      	ite	eq
   2172a:	f44f 5c80 	moveq.w	ip, #4096	; 0x1000
   2172e:	f44f 5ca0 	movne.w	ip, #5120	; 0x1400
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21732:	9700      	str	r7, [sp, #0]
   21734:	2302      	movs	r3, #2
   21736:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
   2173a:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2173e:	f7eb f89b 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21742:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21746:	7831      	ldrb	r1, [r6, #0]
   21748:	4622      	mov	r2, r4
   2174a:	6828      	ldr	r0, [r5, #0]
   2174c:	2302      	movs	r3, #2
   2174e:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   21750:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21754:	f7eb f890 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21758:	f04f 0c00 	mov.w	ip, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2175c:	7831      	ldrb	r1, [r6, #0]
   2175e:	6828      	ldr	r0, [r5, #0]
   21760:	4622      	mov	r2, r4
   21762:	9700      	str	r7, [sp, #0]
   21764:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21766:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2176a:	f7eb f885 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2176e:	f44f 4c21 	mov.w	ip, #41216	; 0xa100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21772:	7831      	ldrb	r1, [r6, #0]
   21774:	6828      	ldr	r0, [r5, #0]
   21776:	4622      	mov	r2, r4
   21778:	9700      	str	r7, [sp, #0]
   2177a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2177c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21780:	f7eb f87a 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21784:	f44f 4c48 	mov.w	ip, #51200	; 0xc800
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21788:	7831      	ldrb	r1, [r6, #0]
   2178a:	6828      	ldr	r0, [r5, #0]
   2178c:	4622      	mov	r2, r4
   2178e:	9700      	str	r7, [sp, #0]
   21790:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21792:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21796:	f7eb f86f 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2179a:	f44f 4c5a 	mov.w	ip, #55808	; 0xda00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2179e:	7831      	ldrb	r1, [r6, #0]
   217a0:	6828      	ldr	r0, [r5, #0]
   217a2:	4622      	mov	r2, r4
   217a4:	9700      	str	r7, [sp, #0]
   217a6:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   217a8:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217ac:	f7eb f864 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   217b0:	f44f 7c00 	mov.w	ip, #512	; 0x200
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217b4:	7831      	ldrb	r1, [r6, #0]
   217b6:	6828      	ldr	r0, [r5, #0]
   217b8:	4622      	mov	r2, r4
   217ba:	9700      	str	r7, [sp, #0]
   217bc:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   217be:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217c2:	f7eb f859 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   217c6:	f44f 4c01 	mov.w	ip, #33024	; 0x8100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217ca:	7831      	ldrb	r1, [r6, #0]
   217cc:	6828      	ldr	r0, [r5, #0]
   217ce:	4622      	mov	r2, r4
   217d0:	9700      	str	r7, [sp, #0]
   217d2:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   217d4:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217d8:	f7eb f84e 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   217dc:	f44f 4c0f 	mov.w	ip, #36608	; 0x8f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217e0:	7831      	ldrb	r1, [r6, #0]
   217e2:	6828      	ldr	r0, [r5, #0]
   217e4:	4622      	mov	r2, r4
   217e6:	9700      	str	r7, [sp, #0]
   217e8:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   217ea:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217ee:	f7eb f843 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   217f2:	f44f 4c59 	mov.w	ip, #55552	; 0xd900
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217f6:	7831      	ldrb	r1, [r6, #0]
   217f8:	6828      	ldr	r0, [r5, #0]
   217fa:	4622      	mov	r2, r4
   217fc:	9700      	str	r7, [sp, #0]
   217fe:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21800:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21804:	f7eb f838 	bl	c878 <HAL_I2C_Master_Transmit>
	if (vccstate == SSD1306_EXTERNALVCC)
   21808:	f1b8 0f01 	cmp.w	r8, #1
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2180c:	6828      	ldr	r0, [r5, #0]
   2180e:	7831      	ldrb	r1, [r6, #0]
   21810:	4622      	mov	r2, r4
	uint8_t i2c_message[2] = {0,0};
   21812:	bf0c      	ite	eq
   21814:	f44f 5c08 	moveq.w	ip, #8704	; 0x2200
   21818:	f44f 4c71 	movne.w	ip, #61696	; 0xf100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2181c:	9700      	str	r7, [sp, #0]
   2181e:	2302      	movs	r3, #2
   21820:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
   21824:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21828:	f7eb f826 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2182c:	f44f 4c5b 	mov.w	ip, #56064	; 0xdb00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21830:	7831      	ldrb	r1, [r6, #0]
   21832:	4622      	mov	r2, r4
   21834:	6828      	ldr	r0, [r5, #0]
   21836:	2302      	movs	r3, #2
   21838:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   2183a:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2183e:	f7eb f81b 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21842:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21846:	7831      	ldrb	r1, [r6, #0]
   21848:	6828      	ldr	r0, [r5, #0]
   2184a:	4622      	mov	r2, r4
   2184c:	9700      	str	r7, [sp, #0]
   2184e:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21850:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21854:	f7eb f810 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21858:	f44f 4c24 	mov.w	ip, #41984	; 0xa400
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2185c:	7831      	ldrb	r1, [r6, #0]
   2185e:	6828      	ldr	r0, [r5, #0]
   21860:	4622      	mov	r2, r4
   21862:	9700      	str	r7, [sp, #0]
   21864:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21866:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2186a:	f7eb f805 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2186e:	f44f 4c26 	mov.w	ip, #42496	; 0xa600
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21872:	7831      	ldrb	r1, [r6, #0]
   21874:	6828      	ldr	r0, [r5, #0]
   21876:	4622      	mov	r2, r4
   21878:	9700      	str	r7, [sp, #0]
   2187a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2187c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21880:	f7ea fffa 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21884:	f44f 5c38 	mov.w	ip, #11776	; 0x2e00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21888:	7831      	ldrb	r1, [r6, #0]
   2188a:	6828      	ldr	r0, [r5, #0]
   2188c:	4622      	mov	r2, r4
   2188e:	9700      	str	r7, [sp, #0]
   21890:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21892:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21896:	f7ea ffef 	bl	c878 <HAL_I2C_Master_Transmit>
   2189a:	6828      	ldr	r0, [r5, #0]
   2189c:	4622      	mov	r2, r4
   2189e:	7831      	ldrb	r1, [r6, #0]
	uint8_t i2c_message[2] = {0,0};
   218a0:	f44f 452f 	mov.w	r5, #44800	; 0xaf00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218a4:	2302      	movs	r3, #2
   218a6:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   218a8:	f8ad 500c 	strh.w	r5, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218ac:	f7ea ffe4 	bl	c878 <HAL_I2C_Master_Transmit>
}
   218b0:	b004      	add	sp, #16
   218b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   218b6:	bf00      	nop
   218b8:	020faf04 	.word	0x020faf04
   218bc:	020faf00 	.word	0x020faf00
   218c0:	020faefc 	.word	0x020faefc
   218c4:	58020000 	.word	0x58020000

000218c8 <ssd1306_display_full_buffer>:
  ssd1306_command(contrast);
}



void ssd1306_display_full_buffer(void) {
   218c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   218cc:	b084      	sub	sp, #16
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218ce:	4e2d      	ldr	r6, [pc, #180]	; (21984 <ssd1306_display_full_buffer+0xbc>)
   218d0:	4d2d      	ldr	r5, [pc, #180]	; (21988 <ssd1306_display_full_buffer+0xc0>)
   218d2:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
   218d6:	ac04      	add	r4, sp, #16
   218d8:	f44f 5204 	mov.w	r2, #8448	; 0x2100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218dc:	7831      	ldrb	r1, [r6, #0]
	uint8_t i2c_message[2] = {0,0};
   218de:	f04f 0800 	mov.w	r8, #0
   218e2:	f824 2d04 	strh.w	r2, [r4, #-4]!
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218e6:	2302      	movs	r3, #2
   218e8:	4622      	mov	r2, r4
   218ea:	6828      	ldr	r0, [r5, #0]
   218ec:	9700      	str	r7, [sp, #0]
   218ee:	f7ea ffc3 	bl	c878 <HAL_I2C_Master_Transmit>
   218f2:	7831      	ldrb	r1, [r6, #0]
   218f4:	4622      	mov	r2, r4
   218f6:	6828      	ldr	r0, [r5, #0]
   218f8:	9700      	str	r7, [sp, #0]
   218fa:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   218fc:	f8ad 800c 	strh.w	r8, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21900:	f7ea ffba 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21904:	f44f 4cfe 	mov.w	ip, #32512	; 0x7f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21908:	7831      	ldrb	r1, [r6, #0]
   2190a:	4622      	mov	r2, r4
   2190c:	6828      	ldr	r0, [r5, #0]
   2190e:	9700      	str	r7, [sp, #0]
   21910:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21912:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21916:	f7ea ffaf 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2191a:	f44f 5c08 	mov.w	ip, #8704	; 0x2200
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2191e:	7831      	ldrb	r1, [r6, #0]
   21920:	4622      	mov	r2, r4
   21922:	6828      	ldr	r0, [r5, #0]
   21924:	9700      	str	r7, [sp, #0]
   21926:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21928:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2192c:	f7ea ffa4 	bl	c878 <HAL_I2C_Master_Transmit>
   21930:	7831      	ldrb	r1, [r6, #0]
   21932:	4622      	mov	r2, r4
   21934:	6828      	ldr	r0, [r5, #0]
   21936:	2302      	movs	r3, #2
   21938:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   2193a:	f8ad 800c 	strh.w	r8, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2193e:	f7ea ff9b 	bl	c878 <HAL_I2C_Master_Transmit>
//		HAL_I2C_Master_Transmit_DMA(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 17);
////		HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 17, 2000);
////		HAL_Delay(1);
//		i--;
//	}
	displayBufferChunk[0] = 0x40;
   21942:	f8df 804c 	ldr.w	r8, [pc, #76]	; 21990 <ssd1306_display_full_buffer+0xc8>
	uint8_t i2c_message[2] = {0,0};
   21946:	f44f 7c40 	mov.w	ip, #768	; 0x300
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2194a:	7831      	ldrb	r1, [r6, #0]
   2194c:	4622      	mov	r2, r4
   2194e:	6828      	ldr	r0, [r5, #0]
   21950:	2302      	movs	r3, #2
   21952:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   21954:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21958:	f7ea ff8e 	bl	c878 <HAL_I2C_Master_Transmit>
	displayBufferChunk[0] = 0x40;
   2195c:	4640      	mov	r0, r8
   2195e:	2340      	movs	r3, #64	; 0x40
   21960:	f44f 7200 	mov.w	r2, #512	; 0x200
   21964:	4909      	ldr	r1, [pc, #36]	; (2198c <ssd1306_display_full_buffer+0xc4>)
   21966:	f800 3b01 	strb.w	r3, [r0], #1
   2196a:	f00a ffaf 	bl	2c8cc <memcpy>
	for (int i = 0; i < 512; i++)
	{
		displayBufferChunk[i+1] = buffer[i];
	}
	HAL_I2C_Master_Transmit_DMA(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 513);
   2196e:	4642      	mov	r2, r8
   21970:	7831      	ldrb	r1, [r6, #0]
   21972:	f240 2301 	movw	r3, #513	; 0x201
   21976:	6828      	ldr	r0, [r5, #0]
   21978:	f7eb f8a8 	bl	cacc <HAL_I2C_Master_Transmit_DMA>
}
   2197c:	b004      	add	sp, #16
   2197e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21982:	bf00      	nop
   21984:	020faf04 	.word	0x020faf04
   21988:	020faf00 	.word	0x020faf00
   2198c:	020facfc 	.word	0x020facfc
   21990:	020e2b60 	.word	0x020e2b60

00021994 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
   21994:	4b07      	ldr	r3, [pc, #28]	; (219b4 <HAL_MspInit+0x20>)
{
   21996:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
   21998:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
   2199c:	f042 0202 	orr.w	r2, r2, #2
   219a0:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
   219a4:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
   219a8:	f003 0302 	and.w	r3, r3, #2
   219ac:	9301      	str	r3, [sp, #4]
   219ae:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
   219b0:	b002      	add	sp, #8
   219b2:	4770      	bx	lr
   219b4:	58024400 	.word	0x58024400

000219b8 <_exit>:
	errno = EINVAL;
	return -1;
}

void _exit (int status)
{
   219b8:	b508      	push	{r3, lr}
	errno = EINVAL;
   219ba:	f00a ff43 	bl	2c844 <__errno>
   219be:	2316      	movs	r3, #22
   219c0:	6003      	str	r3, [r0, #0]
   219c2:	e7fe      	b.n	219c2 <_exit+0xa>

000219c4 <MX_TIM3_Init>:
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;

/* TIM3 init function */
void MX_TIM3_Init(void)
{
   219c4:	b530      	push	{r4, r5, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  htim3.Instance = TIM3;
   219c6:	4c39      	ldr	r4, [pc, #228]	; (21aac <MX_TIM3_Init+0xe8>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   219c8:	2300      	movs	r3, #0
{
   219ca:	b093      	sub	sp, #76	; 0x4c
  htim3.Init.Prescaler = 0;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 1024;
   219cc:	f44f 6280 	mov.w	r2, #1024	; 0x400
  htim3.Instance = TIM3;
   219d0:	4937      	ldr	r1, [pc, #220]	; (21ab0 <MX_TIM3_Init+0xec>)
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
   219d2:	4620      	mov	r0, r4
  htim3.Init.Period = 1024;
   219d4:	60e2      	str	r2, [r4, #12]
  htim3.Instance = TIM3;
   219d6:	6021      	str	r1, [r4, #0]
  htim3.Init.Prescaler = 0;
   219d8:	6063      	str	r3, [r4, #4]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   219da:	9303      	str	r3, [sp, #12]
  TIM_OC_InitTypeDef sConfigOC = {0};
   219dc:	930b      	str	r3, [sp, #44]	; 0x2c
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
   219de:	60a3      	str	r3, [r4, #8]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
   219e0:	6123      	str	r3, [r4, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
   219e2:	61a3      	str	r3, [r4, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   219e4:	e9cd 3304 	strd	r3, r3, [sp, #16]
  TIM_OC_InitTypeDef sConfigOC = {0};
   219e8:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
   219ec:	e9cd 330e 	strd	r3, r3, [sp, #56]	; 0x38
   219f0:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
   219f4:	f7f0 fd72 	bl	124dc <HAL_TIM_PWM_Init>
   219f8:	bb38      	cbnz	r0, 21a4a <MX_TIM3_Init+0x86>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   219fa:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
   219fc:	a903      	add	r1, sp, #12
   219fe:	482b      	ldr	r0, [pc, #172]	; (21aac <MX_TIM3_Init+0xe8>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   21a00:	9303      	str	r3, [sp, #12]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
   21a02:	9305      	str	r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
   21a04:	f7f1 fd70 	bl	134e8 <HAL_TIMEx_MasterConfigSynchronization>
   21a08:	b9e0      	cbnz	r0, 21a44 <MX_TIM3_Init+0x80>
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
   21a0a:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
   21a0c:	2560      	movs	r5, #96	; 0x60
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   21a0e:	a90b      	add	r1, sp, #44	; 0x2c
   21a10:	2204      	movs	r2, #4
   21a12:	4826      	ldr	r0, [pc, #152]	; (21aac <MX_TIM3_Init+0xe8>)
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
   21a14:	930d      	str	r3, [sp, #52]	; 0x34
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
   21a16:	930f      	str	r3, [sp, #60]	; 0x3c
  sConfigOC.Pulse = 0;
   21a18:	e9cd 530b 	strd	r5, r3, [sp, #44]	; 0x2c
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   21a1c:	f7f1 fad6 	bl	12fcc <HAL_TIM_PWM_ConfigChannel>
   21a20:	b108      	cbz	r0, 21a26 <MX_TIM3_Init+0x62>
  {
    Error_Handler();
   21a22:	f7f7 fcf5 	bl	19410 <Error_Handler>
}
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(timHandle->Instance==TIM3)
   21a26:	6822      	ldr	r2, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21a28:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM3)
   21a2a:	4921      	ldr	r1, [pc, #132]	; (21ab0 <MX_TIM3_Init+0xec>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21a2c:	930a      	str	r3, [sp, #40]	; 0x28
  if(timHandle->Instance==TIM3)
   21a2e:	428a      	cmp	r2, r1
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21a30:	e9cd 3306 	strd	r3, r3, [sp, #24]
   21a34:	e9cd 3308 	strd	r3, r3, [sp, #32]
  if(timHandle->Instance==TIM3)
   21a38:	d021      	beq.n	21a7e <MX_TIM3_Init+0xba>

  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM4)
   21a3a:	4b1e      	ldr	r3, [pc, #120]	; (21ab4 <MX_TIM3_Init+0xf0>)
   21a3c:	429a      	cmp	r2, r3
   21a3e:	d007      	beq.n	21a50 <MX_TIM3_Init+0x8c>
}
   21a40:	b013      	add	sp, #76	; 0x4c
   21a42:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
   21a44:	f7f7 fce4 	bl	19410 <Error_Handler>
   21a48:	e7df      	b.n	21a0a <MX_TIM3_Init+0x46>
    Error_Handler();
   21a4a:	f7f7 fce1 	bl	19410 <Error_Handler>
   21a4e:	e7d4      	b.n	219fa <MX_TIM3_Init+0x36>
  {
  /* USER CODE BEGIN TIM4_MspPostInit 0 */

  /* USER CODE END TIM4_MspPostInit 0 */
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21a50:	4b19      	ldr	r3, [pc, #100]	; (21ab8 <MX_TIM3_Init+0xf4>)
    PB6     ------> TIM4_CH1
    PB7     ------> TIM4_CH2
    PB8     ------> TIM4_CH3 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21a52:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   21a54:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21a58:	a906      	add	r1, sp, #24
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21a5a:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21a5e:	4817      	ldr	r0, [pc, #92]	; (21abc <MX_TIM3_Init+0xf8>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21a60:	4322      	orrs	r2, r4
   21a62:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   21a66:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   21a6a:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21a6c:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21a6e:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
   21a70:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21a72:	9302      	str	r3, [sp, #8]
   21a74:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21a76:	f7ea f8a3 	bl	bbc0 <HAL_GPIO_Init>
}
   21a7a:	b013      	add	sp, #76	; 0x4c
   21a7c:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21a7e:	4b0e      	ldr	r3, [pc, #56]	; (21ab8 <MX_TIM3_Init+0xf4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21a80:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   21a82:	2520      	movs	r5, #32
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21a84:	a906      	add	r1, sp, #24
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21a86:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21a8a:	480c      	ldr	r0, [pc, #48]	; (21abc <MX_TIM3_Init+0xf8>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21a8c:	4322      	orrs	r2, r4
   21a8e:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   21a92:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   21a96:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21a98:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21a9a:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
   21a9c:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21a9e:	9301      	str	r3, [sp, #4]
   21aa0:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21aa2:	f7ea f88d 	bl	bbc0 <HAL_GPIO_Init>
}
   21aa6:	b013      	add	sp, #76	; 0x4c
   21aa8:	bd30      	pop	{r4, r5, pc}
   21aaa:	bf00      	nop
   21aac:	020faf48 	.word	0x020faf48
   21ab0:	40000400 	.word	0x40000400
   21ab4:	40000800 	.word	0x40000800
   21ab8:	58024400 	.word	0x58024400
   21abc:	58020400 	.word	0x58020400

00021ac0 <MX_TIM4_Init>:
{
   21ac0:	b530      	push	{r4, r5, lr}
  htim4.Instance = TIM4;
   21ac2:	4c4e      	ldr	r4, [pc, #312]	; (21bfc <MX_TIM4_Init+0x13c>)
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
   21ac4:	2300      	movs	r3, #0
{
   21ac6:	b097      	sub	sp, #92	; 0x5c
  htim4.Init.Period = 1024;
   21ac8:	f44f 6280 	mov.w	r2, #1024	; 0x400
  htim4.Instance = TIM4;
   21acc:	494c      	ldr	r1, [pc, #304]	; (21c00 <MX_TIM4_Init+0x140>)
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
   21ace:	4620      	mov	r0, r4
  htim4.Init.Period = 1024;
   21ad0:	60e2      	str	r2, [r4, #12]
  htim4.Instance = TIM4;
   21ad2:	6021      	str	r1, [r4, #0]
  htim4.Init.Prescaler = 0;
   21ad4:	6063      	str	r3, [r4, #4]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
   21ad6:	9306      	str	r3, [sp, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   21ad8:	9303      	str	r3, [sp, #12]
  TIM_OC_InitTypeDef sConfigOC = {0};
   21ada:	930f      	str	r3, [sp, #60]	; 0x3c
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
   21adc:	60a3      	str	r3, [r4, #8]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
   21ade:	6123      	str	r3, [r4, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
   21ae0:	61a3      	str	r3, [r4, #24]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
   21ae2:	9309      	str	r3, [sp, #36]	; 0x24
   21ae4:	e9cd 3307 	strd	r3, r3, [sp, #28]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   21ae8:	e9cd 3304 	strd	r3, r3, [sp, #16]
  TIM_OC_InitTypeDef sConfigOC = {0};
   21aec:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
   21af0:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
   21af4:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
   21af8:	f7f0 fbda 	bl	122b0 <HAL_TIM_Base_Init>
   21afc:	2800      	cmp	r0, #0
   21afe:	d14d      	bne.n	21b9c <MX_TIM4_Init+0xdc>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
   21b00:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
   21b04:	a906      	add	r1, sp, #24
   21b06:	483d      	ldr	r0, [pc, #244]	; (21bfc <MX_TIM4_Init+0x13c>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
   21b08:	9306      	str	r3, [sp, #24]
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
   21b0a:	f7f0 fee7 	bl	128dc <HAL_TIM_ConfigClockSource>
   21b0e:	2800      	cmp	r0, #0
   21b10:	d141      	bne.n	21b96 <MX_TIM4_Init+0xd6>
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
   21b12:	483a      	ldr	r0, [pc, #232]	; (21bfc <MX_TIM4_Init+0x13c>)
   21b14:	f7f0 fce2 	bl	124dc <HAL_TIM_PWM_Init>
   21b18:	2800      	cmp	r0, #0
   21b1a:	d139      	bne.n	21b90 <MX_TIM4_Init+0xd0>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   21b1c:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
   21b1e:	a903      	add	r1, sp, #12
   21b20:	4836      	ldr	r0, [pc, #216]	; (21bfc <MX_TIM4_Init+0x13c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   21b22:	9303      	str	r3, [sp, #12]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
   21b24:	9305      	str	r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
   21b26:	f7f1 fcdf 	bl	134e8 <HAL_TIMEx_MasterConfigSynchronization>
   21b2a:	bb70      	cbnz	r0, 21b8a <MX_TIM4_Init+0xca>
  sConfigOC.Pulse = 0;
   21b2c:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
   21b2e:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
   21b30:	a90f      	add	r1, sp, #60	; 0x3c
   21b32:	4832      	ldr	r0, [pc, #200]	; (21bfc <MX_TIM4_Init+0x13c>)
   21b34:	461a      	mov	r2, r3
  sConfigOC.Pulse = 0;
   21b36:	9310      	str	r3, [sp, #64]	; 0x40
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
   21b38:	9311      	str	r3, [sp, #68]	; 0x44
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
   21b3a:	9313      	str	r3, [sp, #76]	; 0x4c
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
   21b3c:	950f      	str	r5, [sp, #60]	; 0x3c
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
   21b3e:	f7f1 fa45 	bl	12fcc <HAL_TIM_PWM_ConfigChannel>
   21b42:	b9f8      	cbnz	r0, 21b84 <MX_TIM4_Init+0xc4>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   21b44:	2204      	movs	r2, #4
   21b46:	a90f      	add	r1, sp, #60	; 0x3c
   21b48:	482c      	ldr	r0, [pc, #176]	; (21bfc <MX_TIM4_Init+0x13c>)
   21b4a:	f7f1 fa3f 	bl	12fcc <HAL_TIM_PWM_ConfigChannel>
   21b4e:	b9b0      	cbnz	r0, 21b7e <MX_TIM4_Init+0xbe>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
   21b50:	a90f      	add	r1, sp, #60	; 0x3c
   21b52:	2208      	movs	r2, #8
   21b54:	4829      	ldr	r0, [pc, #164]	; (21bfc <MX_TIM4_Init+0x13c>)
   21b56:	f7f1 fa39 	bl	12fcc <HAL_TIM_PWM_ConfigChannel>
   21b5a:	b108      	cbz	r0, 21b60 <MX_TIM4_Init+0xa0>
    Error_Handler();
   21b5c:	f7f7 fc58 	bl	19410 <Error_Handler>
  if(timHandle->Instance==TIM3)
   21b60:	6822      	ldr	r2, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21b62:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM3)
   21b64:	4927      	ldr	r1, [pc, #156]	; (21c04 <MX_TIM4_Init+0x144>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21b66:	930e      	str	r3, [sp, #56]	; 0x38
  if(timHandle->Instance==TIM3)
   21b68:	428a      	cmp	r2, r1
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21b6a:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
   21b6e:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  if(timHandle->Instance==TIM3)
   21b72:	d02d      	beq.n	21bd0 <MX_TIM4_Init+0x110>
  else if(timHandle->Instance==TIM4)
   21b74:	4b22      	ldr	r3, [pc, #136]	; (21c00 <MX_TIM4_Init+0x140>)
   21b76:	429a      	cmp	r2, r3
   21b78:	d013      	beq.n	21ba2 <MX_TIM4_Init+0xe2>
}
   21b7a:	b017      	add	sp, #92	; 0x5c
   21b7c:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
   21b7e:	f7f7 fc47 	bl	19410 <Error_Handler>
   21b82:	e7e5      	b.n	21b50 <MX_TIM4_Init+0x90>
    Error_Handler();
   21b84:	f7f7 fc44 	bl	19410 <Error_Handler>
   21b88:	e7dc      	b.n	21b44 <MX_TIM4_Init+0x84>
    Error_Handler();
   21b8a:	f7f7 fc41 	bl	19410 <Error_Handler>
   21b8e:	e7cd      	b.n	21b2c <MX_TIM4_Init+0x6c>
    Error_Handler();
   21b90:	f7f7 fc3e 	bl	19410 <Error_Handler>
   21b94:	e7c2      	b.n	21b1c <MX_TIM4_Init+0x5c>
    Error_Handler();
   21b96:	f7f7 fc3b 	bl	19410 <Error_Handler>
   21b9a:	e7ba      	b.n	21b12 <MX_TIM4_Init+0x52>
    Error_Handler();
   21b9c:	f7f7 fc38 	bl	19410 <Error_Handler>
   21ba0:	e7ae      	b.n	21b00 <MX_TIM4_Init+0x40>
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21ba2:	4b19      	ldr	r3, [pc, #100]	; (21c08 <MX_TIM4_Init+0x148>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21ba4:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   21ba6:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21baa:	a90a      	add	r1, sp, #40	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bac:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21bb0:	4816      	ldr	r0, [pc, #88]	; (21c0c <MX_TIM4_Init+0x14c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bb2:	4322      	orrs	r2, r4
   21bb4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   21bb8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   21bbc:	950a      	str	r5, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bbe:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21bc0:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
   21bc2:	940e      	str	r4, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bc4:	9302      	str	r3, [sp, #8]
   21bc6:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21bc8:	f7e9 fffa 	bl	bbc0 <HAL_GPIO_Init>
}
   21bcc:	b017      	add	sp, #92	; 0x5c
   21bce:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bd0:	4b0d      	ldr	r3, [pc, #52]	; (21c08 <MX_TIM4_Init+0x148>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21bd2:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   21bd4:	2520      	movs	r5, #32
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21bd6:	a90a      	add	r1, sp, #40	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bd8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21bdc:	480b      	ldr	r0, [pc, #44]	; (21c0c <MX_TIM4_Init+0x14c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bde:	4322      	orrs	r2, r4
   21be0:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   21be4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   21be8:	950a      	str	r5, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bea:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21bec:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
   21bee:	940e      	str	r4, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bf0:	9301      	str	r3, [sp, #4]
   21bf2:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21bf4:	f7e9 ffe4 	bl	bbc0 <HAL_GPIO_Init>
}
   21bf8:	b017      	add	sp, #92	; 0x5c
   21bfa:	bd30      	pop	{r4, r5, pc}
   21bfc:	020faf08 	.word	0x020faf08
   21c00:	40000800 	.word	0x40000800
   21c04:	40000400 	.word	0x40000400
   21c08:	58024400 	.word	0x58024400
   21c0c:	58020400 	.word	0x58020400

00021c10 <HAL_TIM_PWM_MspInit>:
  if(tim_pwmHandle->Instance==TIM3)
   21c10:	6802      	ldr	r2, [r0, #0]
   21c12:	4b0a      	ldr	r3, [pc, #40]	; (21c3c <HAL_TIM_PWM_MspInit+0x2c>)
   21c14:	429a      	cmp	r2, r3
   21c16:	d000      	beq.n	21c1a <HAL_TIM_PWM_MspInit+0xa>
   21c18:	4770      	bx	lr
    __HAL_RCC_TIM3_CLK_ENABLE();
   21c1a:	4b09      	ldr	r3, [pc, #36]	; (21c40 <HAL_TIM_PWM_MspInit+0x30>)
{
   21c1c:	b082      	sub	sp, #8
    __HAL_RCC_TIM3_CLK_ENABLE();
   21c1e:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
   21c22:	f042 0202 	orr.w	r2, r2, #2
   21c26:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
   21c2a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
   21c2e:	f003 0302 	and.w	r3, r3, #2
   21c32:	9301      	str	r3, [sp, #4]
   21c34:	9b01      	ldr	r3, [sp, #4]
}
   21c36:	b002      	add	sp, #8
   21c38:	4770      	bx	lr
   21c3a:	bf00      	nop
   21c3c:	40000400 	.word	0x40000400
   21c40:	58024400 	.word	0x58024400

00021c44 <HAL_TIM_Base_MspInit>:
  if(tim_baseHandle->Instance==TIM4)
   21c44:	6802      	ldr	r2, [r0, #0]
   21c46:	4b0a      	ldr	r3, [pc, #40]	; (21c70 <HAL_TIM_Base_MspInit+0x2c>)
   21c48:	429a      	cmp	r2, r3
   21c4a:	d000      	beq.n	21c4e <HAL_TIM_Base_MspInit+0xa>
   21c4c:	4770      	bx	lr
    __HAL_RCC_TIM4_CLK_ENABLE();
   21c4e:	4b09      	ldr	r3, [pc, #36]	; (21c74 <HAL_TIM_Base_MspInit+0x30>)
{
   21c50:	b082      	sub	sp, #8
    __HAL_RCC_TIM4_CLK_ENABLE();
   21c52:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
   21c56:	f042 0204 	orr.w	r2, r2, #4
   21c5a:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
   21c5e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
   21c62:	f003 0304 	and.w	r3, r3, #4
   21c66:	9301      	str	r3, [sp, #4]
   21c68:	9b01      	ldr	r3, [sp, #4]
}
   21c6a:	b002      	add	sp, #8
   21c6c:	4770      	bx	lr
   21c6e:	bf00      	nop
   21c70:	40000800 	.word	0x40000800
   21c74:	58024400 	.word	0x58024400

00021c78 <initModeNames>:
        VocodecPresetType currentPreset = (VocodecPresetType)0;
        VocodecPresetType previousPreset = PresetNil;
        uint8_t loadingPreset = 0;

        void initModeNames(void)
        {
   21c78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   21c7c:	4ad2      	ldr	r2, [pc, #840]	; (21fc8 <initModeNames+0x350>)
   21c7e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
            for (int i = 0; i < NUM_ADC_CHANNELS; i++)
            {
                floatADCUI[i] = -1.0f;
                orderedParams[i] = i;
   21c82:	4cd2      	ldr	r4, [pc, #840]	; (21fcc <initModeNames+0x354>)
            }
            orderedParams[6] = ButtonA;
            orderedParams[7] = ButtonB;
   21c84:	f04f 0906 	mov.w	r9, #6
                floatADCUI[i] = -1.0f;
   21c88:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
                cvAddParam[i] = -1;
            }

            modeNames[Vocoder] = "VOCODER1";
            shortModeNames[Vocoder] = "VL";
            modeNamesDetails[Vocoder] = "LPC";
   21c8c:	f8df b45c 	ldr.w	fp, [pc, #1116]	; 220ec <initModeNames+0x474>
                floatADCUI[i] = -1.0f;
   21c90:	4bcf      	ldr	r3, [pc, #828]	; (21fd0 <initModeNames+0x358>)
            orderedParams[7] = ButtonB;
   21c92:	f884 9007 	strb.w	r9, [r4, #7]
                orderedParams[i] = i;
   21c96:	f04f 0904 	mov.w	r9, #4
   21c9a:	6017      	str	r7, [r2, #0]
   21c9c:	6057      	str	r7, [r2, #4]
   21c9e:	6097      	str	r7, [r2, #8]
   21ca0:	60d7      	str	r7, [r2, #12]
   21ca2:	8217      	strh	r7, [r2, #16]
   21ca4:	f8df e448 	ldr.w	lr, [pc, #1096]	; 220f0 <initModeNames+0x478>
            modeNamesDetails[Vocoder] = "LPC";
   21ca8:	4aca      	ldr	r2, [pc, #808]	; (21fd4 <initModeNames+0x35c>)
                floatADCUI[i] = -1.0f;
   21caa:	edc3 7a00 	vstr	s15, [r3]
   21cae:	edc3 7a01 	vstr	s15, [r3, #4]
   21cb2:	edc3 7a02 	vstr	s15, [r3, #8]
   21cb6:	edc3 7a03 	vstr	s15, [r3, #12]
   21cba:	edc3 7a04 	vstr	s15, [r3, #16]
   21cbe:	edc3 7a05 	vstr	s15, [r3, #20]
                orderedParams[i] = i;
   21cc2:	f8c4 e000 	str.w	lr, [r4]
            numPages[Vocoder] = 2;
            knobParamNames[Vocoder][0] = "VOLUME";
   21cc6:	4bc4      	ldr	r3, [pc, #784]	; (21fd8 <initModeNames+0x360>)
            knobParamNames[Vocoder][1] = "WARP";
   21cc8:	f8df e428 	ldr.w	lr, [pc, #1064]	; 220f4 <initModeNames+0x47c>
                orderedParams[i] = i;
   21ccc:	f884 9004 	strb.w	r9, [r4, #4]
   21cd0:	f04f 0905 	mov.w	r9, #5
            modeNamesDetails[Vocoder] = "LPC";
   21cd4:	f8cb 2000 	str.w	r2, [fp]
            knobParamNames[Vocoder][0] = "VOLUME";
   21cd8:	4ac0      	ldr	r2, [pc, #768]	; (21fdc <initModeNames+0x364>)
                orderedParams[i] = i;
   21cda:	f884 9005 	strb.w	r9, [r4, #5]
            orderedParams[6] = ButtonA;
   21cde:	f884 9006 	strb.w	r9, [r4, #6]
            knobParamNames[Vocoder][2] = "QUALITY";
            knobParamNames[Vocoder][3] = "SAWtoPULSE";
   21ce2:	4cbf      	ldr	r4, [pc, #764]	; (21fe0 <initModeNames+0x368>)
            modeNames[Vocoder] = "VOCODER1";
   21ce4:	f8df 8410 	ldr.w	r8, [pc, #1040]	; 220f8 <initModeNames+0x480>
   21ce8:	f8df a410 	ldr.w	sl, [pc, #1040]	; 220fc <initModeNames+0x484>
            knobParamNames[Vocoder][7] = "PULSEWIDTH";
            knobParamNames[Vocoder][8] = "PULSESHAPE";
            knobParamNames[Vocoder][9] = "";


            modeNames[VocoderCh] = "VOCODER2";
   21cec:	4dbd      	ldr	r5, [pc, #756]	; (21fe4 <initModeNames+0x36c>)
            shortModeNames[Vocoder] = "VL";
   21cee:	f8df c410 	ldr.w	ip, [pc, #1040]	; 22100 <initModeNames+0x488>
   21cf2:	48bd      	ldr	r0, [pc, #756]	; (21fe8 <initModeNames+0x370>)
            shortModeNames[VocoderCh] = "VC";
   21cf4:	49bd      	ldr	r1, [pc, #756]	; (21fec <initModeNames+0x374>)
            knobParamNames[Vocoder][4] = "NOISTHRESH";
   21cf6:	4fbe      	ldr	r7, [pc, #760]	; (21ff0 <initModeNames+0x378>)
            shortModeNames[Vocoder] = "VL";
   21cf8:	f8cc 0000 	str.w	r0, [ip]
            shortModeNames[VocoderCh] = "VC";
   21cfc:	f8cc 1004 	str.w	r1, [ip, #4]
            knobParamNames[Vocoder][8] = "PULSESHAPE";
   21d00:	48bc      	ldr	r0, [pc, #752]	; (21ff4 <initModeNames+0x37c>)
            knobParamNames[Vocoder][9] = "";
   21d02:	49bd      	ldr	r1, [pc, #756]	; (21ff8 <initModeNames+0x380>)
            modeNamesDetails[VocoderCh] = "CHANNEL";
   21d04:	4ebd      	ldr	r6, [pc, #756]	; (21ffc <initModeNames+0x384>)
            knobParamNames[Vocoder][4] = "NOISTHRESH";
   21d06:	611f      	str	r7, [r3, #16]
            modeNamesDetails[VocoderCh] = "CHANNEL";
   21d08:	f8cb 6004 	str.w	r6, [fp, #4]
            knobParamNames[VocoderCh][11] = "BANDOFF";
            knobParamNames[VocoderCh][12] = "TILT";
            knobParamNames[VocoderCh][13] = "STEREO";
            knobParamNames[VocoderCh][14] = "BARKPULL";

            modeNames[Pitchshift] = "PITCHSHIFT";
   21d0c:	f8df 93f4 	ldr.w	r9, [pc, #1012]	; 22104 <initModeNames+0x48c>
            knobParamNames[VocoderCh][10] = "BANDSQUISH";
   21d10:	4ebb      	ldr	r6, [pc, #748]	; (22000 <initModeNames+0x388>)
            knobParamNames[Vocoder][1] = "WARP";
   21d12:	e9c3 2e00 	strd	r2, lr, [r3]
            knobParamNames[Vocoder][2] = "QUALITY";
   21d16:	4abb      	ldr	r2, [pc, #748]	; (22004 <initModeNames+0x38c>)
            knobParamNames[Vocoder][3] = "SAWtoPULSE";
   21d18:	e9c3 2402 	strd	r2, r4, [r3, #8]
            knobParamNames[Vocoder][5] = "BREATH";
   21d1c:	4aba      	ldr	r2, [pc, #744]	; (22008 <initModeNames+0x390>)
            modeNames[VocoderCh] = "VOCODER2";
   21d1e:	e9c8 a500 	strd	sl, r5, [r8]
            knobParamNames[Vocoder][5] = "BREATH";
   21d22:	615a      	str	r2, [r3, #20]
            knobParamNames[Vocoder][7] = "PULSEWIDTH";
   21d24:	4db9      	ldr	r5, [pc, #740]	; (2200c <initModeNames+0x394>)
            knobParamNames[Vocoder][6] = "TILT";
   21d26:	4aba      	ldr	r2, [pc, #744]	; (22010 <initModeNames+0x398>)
            knobParamNames[VocoderCh][3] = "BANDWIDTH";
   21d28:	f8df a3dc 	ldr.w	sl, [pc, #988]	; 22108 <initModeNames+0x490>
            knobParamNames[Vocoder][7] = "PULSEWIDTH";
   21d2c:	e9c3 2506 	strd	r2, r5, [r3, #24]
            knobParamNames[VocoderCh][0] = "VOLUME";
   21d30:	4aaa      	ldr	r2, [pc, #680]	; (21fdc <initModeNames+0x364>)
            knobParamNames[Vocoder][9] = "";
   21d32:	e9c3 0108 	strd	r0, r1, [r3, #32]
            knobParamNames[VocoderCh][1] = "WARP";
   21d36:	e9c3 2e19 	strd	r2, lr, [r3, #100]	; 0x64
            knobParamNames[VocoderCh][2] = "QUALITY";
   21d3a:	4ab2      	ldr	r2, [pc, #712]	; (22004 <initModeNames+0x38c>)
            knobParamNames[VocoderCh][5] = "SAWtoPULSE";
   21d3c:	679c      	str	r4, [r3, #120]	; 0x78
            knobParamNames[VocoderCh][2] = "QUALITY";
   21d3e:	66da      	str	r2, [r3, #108]	; 0x6c
            knobParamNames[VocoderCh][14] = "BARKPULL";
   21d40:	4cb4      	ldr	r4, [pc, #720]	; (22014 <initModeNames+0x39c>)
            knobParamNames[VocoderCh][7] = "PULSESHAPE";
   21d42:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
            knobParamNames[VocoderCh][8] = "BREATH";
   21d46:	4ab0      	ldr	r2, [pc, #704]	; (22008 <initModeNames+0x390>)
            knobParamNames[VocoderCh][12] = "TILT";
   21d48:	48b1      	ldr	r0, [pc, #708]	; (22010 <initModeNames+0x398>)
            modeNames[Pitchshift] = "PITCHSHIFT";
   21d4a:	f8c8 9008 	str.w	r9, [r8, #8]
            knobParamNames[VocoderCh][4] = "NOISTHRESH";
   21d4e:	675f      	str	r7, [r3, #116]	; 0x74
            knobParamNames[VocoderCh][11] = "BANDOFF";
   21d50:	f8df e3b8 	ldr.w	lr, [pc, #952]	; 2210c <initModeNames+0x494>
            knobParamNames[VocoderCh][6] = "PULSEWIDTH";
   21d54:	67dd      	str	r5, [r3, #124]	; 0x7c
            shortModeNames[Pitchshift] = "PS";
   21d56:	4fb0      	ldr	r7, [pc, #704]	; (22018 <initModeNames+0x3a0>)
            modeNamesDetails[Pitchshift] = "";
            numPages[Pitchshift] = 2;
            knobParamNames[Pitchshift][0] = "SHIFT";
   21d58:	4db0      	ldr	r5, [pc, #704]	; (2201c <initModeNames+0x3a4>)
            knobParamNames[VocoderCh][8] = "BREATH";
   21d5a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            knobParamNames[VocoderCh][12] = "TILT";
   21d5e:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
            knobParamNames[Pitchshift][1] = "FINE";
   21d62:	4aaf      	ldr	r2, [pc, #700]	; (22020 <initModeNames+0x3a8>)
            knobParamNames[Pitchshift][2] = "F AMT";
   21d64:	f8df 93a8 	ldr.w	r9, [pc, #936]	; 22110 <initModeNames+0x498>
            knobParamNames[Pitchshift][3] = "FORMANT";
   21d68:	48ae      	ldr	r0, [pc, #696]	; (22024 <initModeNames+0x3ac>)
            knobParamNames[VocoderCh][10] = "BANDSQUISH";
   21d6a:	f8c3 608c 	str.w	r6, [r3, #140]	; 0x8c
            knobParamNames[VocoderCh][14] = "BARKPULL";
   21d6e:	f8c3 409c 	str.w	r4, [r3, #156]	; 0x9c
            knobParamNames[Pitchshift][4] = "RANGE";
   21d72:	4ead      	ldr	r6, [pc, #692]	; (22028 <initModeNames+0x3b0>)
            knobParamNames[Pitchshift][6] = "";
            knobParamNames[Pitchshift][7] = "";
            knobParamNames[Pitchshift][8] = "";
            knobParamNames[Pitchshift][9] = "";

            modeNames[AutotuneMono] = "AUTOTUNE";
   21d74:	4cad      	ldr	r4, [pc, #692]	; (2202c <initModeNames+0x3b4>)
            shortModeNames[Pitchshift] = "PS";
   21d76:	f8cc 7008 	str.w	r7, [ip, #8]
            modeNames[AutotuneMono] = "AUTOTUNE";
   21d7a:	f8c8 400c 	str.w	r4, [r8, #12]
            knobParamNames[VocoderCh][11] = "BANDOFF";
   21d7e:	f8c3 e090 	str.w	lr, [r3, #144]	; 0x90
            shortModeNames[AutotuneMono] = "NT";
   21d82:	4fab      	ldr	r7, [pc, #684]	; (22030 <initModeNames+0x3b8>)
            knobParamNames[Pitchshift][5] = "OFFSET";
   21d84:	f8df e38c 	ldr.w	lr, [pc, #908]	; 22114 <initModeNames+0x49c>
            knobParamNames[Pitchshift][0] = "SHIFT";
   21d88:	f8c3 50c8 	str.w	r5, [r3, #200]	; 0xc8
            knobParamNames[Pitchshift][1] = "FINE";
   21d8c:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
            modeNamesDetails[AutotuneMono] = "";
            numPages[AutotuneMono] = 1;
            knobParamNames[AutotuneMono][0] = "PICKINESS";
            knobParamNames[AutotuneMono][1] = "AMOUNT";
   21d90:	4da8      	ldr	r5, [pc, #672]	; (22034 <initModeNames+0x3bc>)
            knobParamNames[VocoderCh][9] = "SPEED";
   21d92:	4aa9      	ldr	r2, [pc, #676]	; (22038 <initModeNames+0x3c0>)
            knobParamNames[Pitchshift][4] = "RANGE";
   21d94:	f8c3 60d8 	str.w	r6, [r3, #216]	; 0xd8
            knobParamNames[VocoderCh][13] = "STEREO";
   21d98:	4ca8      	ldr	r4, [pc, #672]	; (2203c <initModeNames+0x3c4>)
            knobParamNames[AutotuneMono][2] = "SPEED";
            knobParamNames[AutotuneMono][3] = "LEAPALLOW";
   21d9a:	4ea9      	ldr	r6, [pc, #676]	; (22040 <initModeNames+0x3c8>)
            modeNamesDetails[Pitchshift] = "";
   21d9c:	f8cb 1008 	str.w	r1, [fp, #8]
            modeNamesDetails[AutotuneMono] = "";
   21da0:	f8cb 100c 	str.w	r1, [fp, #12]
            shortModeNames[AutotuneMono] = "NT";
   21da4:	f8cc 700c 	str.w	r7, [ip, #12]
            knobParamNames[VocoderCh][3] = "BANDWIDTH";
   21da8:	f8c3 a070 	str.w	sl, [r3, #112]	; 0x70
            knobParamNames[Pitchshift][5] = "OFFSET";
   21dac:	f8c3 e0dc 	str.w	lr, [r3, #220]	; 0xdc
            knobParamNames[AutotuneMono][4] = "HYSTERESIS";


            modeNames[AutotunePoly] = "HARMONIZE";
            shortModeNames[AutotunePoly] = "AT";
   21db0:	4fa4      	ldr	r7, [pc, #656]	; (22044 <initModeNames+0x3cc>)
            knobParamNames[AutotuneMono][1] = "AMOUNT";
   21db2:	f8c3 5130 	str.w	r5, [r3, #304]	; 0x130
            knobParamNames[VocoderCh][9] = "SPEED";
   21db6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            knobParamNames[AutotunePoly][2] = "";
            knobParamNames[AutotunePoly][3] = "";
            knobParamNames[AutotunePoly][4] = "";


            modeNames[SamplerButtonPress] = "SAMPLER BP";
   21dba:	4da3      	ldr	r5, [pc, #652]	; (22048 <initModeNames+0x3d0>)
            knobParamNames[VocoderCh][13] = "STEREO";
   21dbc:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
            shortModeNames[SamplerButtonPress] = "SB";
   21dc0:	f8df e354 	ldr.w	lr, [pc, #852]	; 22118 <initModeNames+0x4a0>
            knobParamNames[SamplerButtonPress][4] = "CROSSFADE";



            modeNames[SamplerKeyboard] = "KEYSAMPLER";
            shortModeNames[SamplerKeyboard] = "KS";
   21dc4:	4ca1      	ldr	r4, [pc, #644]	; (2204c <initModeNames+0x3d4>)
            modeNames[AutotunePoly] = "HARMONIZE";
   21dc6:	f8df a354 	ldr.w	sl, [pc, #852]	; 2211c <initModeNames+0x4a4>
            knobParamNames[Pitchshift][3] = "FORMANT";
   21dca:	e9c3 9034 	strd	r9, r0, [r3, #208]	; 0xd0
            knobParamNames[AutotuneMono][0] = "PICKINESS";
   21dce:	48a0      	ldr	r0, [pc, #640]	; (22050 <initModeNames+0x3d8>)
            knobParamNames[AutotuneMono][4] = "HYSTERESIS";
   21dd0:	f8df 934c 	ldr.w	r9, [pc, #844]	; 22120 <initModeNames+0x4a8>
            knobParamNames[Pitchshift][7] = "";
   21dd4:	e9c3 1138 	strd	r1, r1, [r3, #224]	; 0xe0
            knobParamNames[Pitchshift][9] = "";
   21dd8:	e9c3 113a 	strd	r1, r1, [r3, #232]	; 0xe8
            knobParamNames[AutotuneMono][0] = "PICKINESS";
   21ddc:	f8c3 012c 	str.w	r0, [r3, #300]	; 0x12c
            knobParamNames[AutotuneMono][3] = "LEAPALLOW";
   21de0:	f8c3 6138 	str.w	r6, [r3, #312]	; 0x138
            modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
   21de4:	4e9b      	ldr	r6, [pc, #620]	; (22054 <initModeNames+0x3dc>)
            shortModeNames[AutotunePoly] = "AT";
   21de6:	f8cc 7010 	str.w	r7, [ip, #16]
            modeNames[SamplerButtonPress] = "SAMPLER BP";
   21dea:	f8c8 5014 	str.w	r5, [r8, #20]
            modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
   21dee:	f8cb 6014 	str.w	r6, [fp, #20]
            knobParamNames[AutotunePoly][0] = "PICKINESS";
   21df2:	f8c3 0190 	str.w	r0, [r3, #400]	; 0x190
            modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
   21df6:	4f98      	ldr	r7, [pc, #608]	; (22058 <initModeNames+0x3e0>)
            modeNames[SamplerKeyboard] = "KEYSAMPLER";
   21df8:	4898      	ldr	r0, [pc, #608]	; (2205c <initModeNames+0x3e4>)
            numPages[SamplerKeyboard] = 2;
            knobParamNames[SamplerKeyboard][0] = "START";
            knobParamNames[SamplerKeyboard][1] = "LENGTH";
            knobParamNames[SamplerKeyboard][2] = "SPEED";
            knobParamNames[SamplerKeyboard][3] = "SPEEDMULT";
            knobParamNames[SamplerKeyboard][4] = "LOOP ON";
   21dfa:	4d99      	ldr	r5, [pc, #612]	; (22060 <initModeNames+0x3e8>)
            knobParamNames[SamplerKeyboard][7] = "";
            knobParamNames[SamplerKeyboard][8] = "";
            knobParamNames[SamplerKeyboard][9] = "";


            modeNames[SamplerAutoGrab] = "AUTOSAMP";
   21dfc:	4e99      	ldr	r6, [pc, #612]	; (22064 <initModeNames+0x3ec>)
            shortModeNames[SamplerButtonPress] = "SB";
   21dfe:	f8cc e014 	str.w	lr, [ip, #20]
            modeNames[SamplerKeyboard] = "KEYSAMPLER";
   21e02:	f8c8 0018 	str.w	r0, [r8, #24]
            shortModeNames[SamplerKeyboard] = "KS";
   21e06:	f8cc 4018 	str.w	r4, [ip, #24]
            knobParamNames[SamplerButtonPress][0] = "START";
   21e0a:	4897      	ldr	r0, [pc, #604]	; (22068 <initModeNames+0x3f0>)
            knobParamNames[SamplerButtonPress][1] = "LENGTH";
   21e0c:	4c97      	ldr	r4, [pc, #604]	; (2206c <initModeNames+0x3f4>)
            modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
   21e0e:	f8cb 7018 	str.w	r7, [fp, #24]
            modeNames[SamplerAutoGrab] = "AUTOSAMP";
   21e12:	f8c8 601c 	str.w	r6, [r8, #28]
            knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
   21e16:	4f96      	ldr	r7, [pc, #600]	; (22070 <initModeNames+0x3f8>)
            knobParamNames[SamplerKeyboard][6] = "VELO SENS";
   21e18:	f8df e308 	ldr.w	lr, [pc, #776]	; 22124 <initModeNames+0x4ac>
            knobParamNames[SamplerKeyboard][4] = "LOOP ON";
   21e1c:	f8c3 5268 	str.w	r5, [r3, #616]	; 0x268
            shortModeNames[SamplerAutoGrab] = "AS";
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
            numPages[SamplerAutoGrab] = 2;
            knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
   21e20:	4e94      	ldr	r6, [pc, #592]	; (22074 <initModeNames+0x3fc>)
            knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
   21e22:	4d95      	ldr	r5, [pc, #596]	; (22078 <initModeNames+0x400>)
            modeNamesDetails[AutotunePoly] = "";
   21e24:	f8cb 1010 	str.w	r1, [fp, #16]
            modeNames[AutotunePoly] = "HARMONIZE";
   21e28:	f8c8 a010 	str.w	sl, [r8, #16]
            knobParamNames[AutotuneMono][2] = "SPEED";
   21e2c:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
            knobParamNames[AutotunePoly][1] = "";
   21e30:	f8c3 1194 	str.w	r1, [r3, #404]	; 0x194
            knobParamNames[AutotunePoly][2] = "";
   21e34:	f8c3 1198 	str.w	r1, [r3, #408]	; 0x198
            knobParamNames[AutotunePoly][3] = "";
   21e38:	f8c3 119c 	str.w	r1, [r3, #412]	; 0x19c
            knobParamNames[AutotunePoly][4] = "";
   21e3c:	f8c3 11a0 	str.w	r1, [r3, #416]	; 0x1a0
            knobParamNames[SamplerButtonPress][2] = "SPEED";
   21e40:	f8c3 21fc 	str.w	r2, [r3, #508]	; 0x1fc
            knobParamNames[SamplerKeyboard][2] = "SPEED";
   21e44:	f8c3 2260 	str.w	r2, [r3, #608]	; 0x260
            knobParamNames[SamplerKeyboard][7] = "";
   21e48:	f8c3 1274 	str.w	r1, [r3, #628]	; 0x274
            knobParamNames[SamplerKeyboard][8] = "";
   21e4c:	f8c3 1278 	str.w	r1, [r3, #632]	; 0x278
            knobParamNames[SamplerKeyboard][9] = "";
   21e50:	f8c3 127c 	str.w	r1, [r3, #636]	; 0x27c
            knobParamNames[AutotuneMono][4] = "HYSTERESIS";
   21e54:	f8c3 913c 	str.w	r9, [r3, #316]	; 0x13c
            knobParamNames[SamplerKeyboard][6] = "VELO SENS";
   21e58:	f8c3 e270 	str.w	lr, [r3, #624]	; 0x270
            shortModeNames[SamplerAutoGrab] = "AS";
   21e5c:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 22128 <initModeNames+0x4b0>
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
   21e60:	f8df a2c8 	ldr.w	sl, [pc, #712]	; 2212c <initModeNames+0x4b4>
            knobParamNames[SamplerButtonPress][0] = "START";
   21e64:	f8c3 01f4 	str.w	r0, [r3, #500]	; 0x1f4
            knobParamNames[SamplerKeyboard][0] = "START";
   21e68:	f8c3 0258 	str.w	r0, [r3, #600]	; 0x258
            knobParamNames[SamplerButtonPress][1] = "LENGTH";
   21e6c:	f8c3 41f8 	str.w	r4, [r3, #504]	; 0x1f8
            knobParamNames[SamplerAutoGrab][1] = "WINDOW";
   21e70:	4882      	ldr	r0, [pc, #520]	; (2207c <initModeNames+0x404>)
            knobParamNames[SamplerKeyboard][1] = "LENGTH";
   21e72:	f8c3 425c 	str.w	r4, [r3, #604]	; 0x25c
            knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
   21e76:	f8c3 7200 	str.w	r7, [r3, #512]	; 0x200
            knobParamNames[SamplerAutoGrab][2] = "SPEED";
            knobParamNames[SamplerAutoGrab][3] = "CROSSFADE";
            knobParamNames[SamplerAutoGrab][4] = "";
            knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
   21e7a:	4c81      	ldr	r4, [pc, #516]	; (22080 <initModeNames+0x408>)
            knobParamNames[SamplerKeyboard][3] = "SPEEDMULT";
   21e7c:	f8c3 7264 	str.w	r7, [r3, #612]	; 0x264
            knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
   21e80:	f8c3 5204 	str.w	r5, [r3, #516]	; 0x204
            knobParamNames[SamplerKeyboard][5] = "CROSSFADE";
   21e84:	f8c3 526c 	str.w	r5, [r3, #620]	; 0x26c
            knobParamNames[SamplerAutoGrab][2] = "SPEED";
   21e88:	f8c3 22c4 	str.w	r2, [r3, #708]	; 0x2c4
            knobParamNames[SamplerAutoGrab][3] = "CROSSFADE";
   21e8c:	f8c3 52c8 	str.w	r5, [r3, #712]	; 0x2c8

            modeNames[BitCrusher] = "BITCRUSH";
            shortModeNames[BitCrusher] = "BC";
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
            numPages[BitCrusher] = 2;
            knobParamNames[BitCrusher][0] = "QUALITY";
   21e90:	4a5c      	ldr	r2, [pc, #368]	; (22004 <initModeNames+0x38c>)
            knobParamNames[Distortion][1] = "TILT";
   21e92:	4d5f      	ldr	r5, [pc, #380]	; (22010 <initModeNames+0x398>)
            knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
   21e94:	f8c3 62bc 	str.w	r6, [r3, #700]	; 0x2bc
            modeNames[Wavefolder] = "WAVEFOLD";
   21e98:	4e7a      	ldr	r6, [pc, #488]	; (22084 <initModeNames+0x40c>)
            shortModeNames[SamplerAutoGrab] = "AS";
   21e9a:	f8cc 901c 	str.w	r9, [ip, #28]
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
   21e9e:	f8cb a01c 	str.w	sl, [fp, #28]
            modeNames[Wavefolder] = "WAVEFOLD";
   21ea2:	f8c8 6024 	str.w	r6, [r8, #36]	; 0x24
            knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
   21ea6:	f8df e288 	ldr.w	lr, [pc, #648]	; 22130 <initModeNames+0x4b8>
            modeNames[Distortion] = "DISTORT";
   21eaa:	f8df 9288 	ldr.w	r9, [pc, #648]	; 22134 <initModeNames+0x4bc>
            shortModeNames[Distortion] = "DT";
   21eae:	4f76      	ldr	r7, [pc, #472]	; (22088 <initModeNames+0x410>)
            knobParamNames[Distortion][1] = "TILT";
   21eb0:	f8c3 5324 	str.w	r5, [r3, #804]	; 0x324
            knobParamNames[BitCrusher][0] = "QUALITY";
   21eb4:	f8c3 23e8 	str.w	r2, [r3, #1000]	; 0x3e8
            modeNamesDetails[Distortion] = "WITH EQ";
   21eb8:	4d74      	ldr	r5, [pc, #464]	; (2208c <initModeNames+0x414>)
            knobParamNames[Distortion][2] = "MID GAIN";
   21eba:	4a75      	ldr	r2, [pc, #468]	; (22090 <initModeNames+0x418>)
            knobParamNames[Distortion][3] = "MID FREQ";
   21ebc:	f8df a278 	ldr.w	sl, [pc, #632]	; 22138 <initModeNames+0x4c0>
            knobParamNames[SamplerAutoGrab][1] = "WINDOW";
   21ec0:	f8c3 02c0 	str.w	r0, [r3, #704]	; 0x2c0
            knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
   21ec4:	f8c3 42d0 	str.w	r4, [r3, #720]	; 0x2d0
            shortModeNames[Wavefolder] = "WF";
   21ec8:	4872      	ldr	r0, [pc, #456]	; (22094 <initModeNames+0x41c>)
            modeNamesDetails[Wavefolder] = "SERGE STYLE";
   21eca:	4c73      	ldr	r4, [pc, #460]	; (22098 <initModeNames+0x420>)
            knobParamNames[BitCrusher][1] = "SAMP RATIO";
   21ecc:	4e73      	ldr	r6, [pc, #460]	; (2209c <initModeNames+0x424>)
            modeNames[Distortion] = "DISTORT";
   21ece:	f8c8 9020 	str.w	r9, [r8, #32]
            shortModeNames[Distortion] = "DT";
   21ed2:	f8cc 7020 	str.w	r7, [ip, #32]
            modeNamesDetails[Distortion] = "WITH EQ";
   21ed6:	f8cb 5020 	str.w	r5, [fp, #32]
            shortModeNames[Wavefolder] = "WF";
   21eda:	f8cc 0024 	str.w	r0, [ip, #36]	; 0x24
            modeNamesDetails[Wavefolder] = "SERGE STYLE";
   21ede:	f8cb 4024 	str.w	r4, [fp, #36]	; 0x24
            knobParamNames[Distortion][0] = "PRE GAIN";
   21ee2:	486f      	ldr	r0, [pc, #444]	; (220a0 <initModeNames+0x428>)
            knobParamNames[Distortion][4] = "POST GAIN";
   21ee4:	4c6f      	ldr	r4, [pc, #444]	; (220a4 <initModeNames+0x42c>)
            knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
   21ee6:	f8c3 e2d4 	str.w	lr, [r3, #724]	; 0x2d4
            knobParamNames[Wavefolder][1] = "OFFSET1";
   21eea:	f8df 9250 	ldr.w	r9, [pc, #592]	; 2213c <initModeNames+0x4c4>
            knobParamNames[Wavefolder][0] = "GAIN";
   21eee:	f8df e250 	ldr.w	lr, [pc, #592]	; 22140 <initModeNames+0x4c8>
            knobParamNames[Wavefolder][2] = "OFFSET2";
   21ef2:	4f6d      	ldr	r7, [pc, #436]	; (220a8 <initModeNames+0x430>)
            modeNames[BitCrusher] = "BITCRUSH";
   21ef4:	4d6d      	ldr	r5, [pc, #436]	; (220ac <initModeNames+0x434>)
            knobParamNames[Distortion][2] = "MID GAIN";
   21ef6:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
            knobParamNames[Distortion][3] = "MID FREQ";
   21efa:	f8c3 a32c 	str.w	sl, [r3, #812]	; 0x32c
            shortModeNames[BitCrusher] = "BC";
   21efe:	4a6c      	ldr	r2, [pc, #432]	; (220b0 <initModeNames+0x438>)
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
   21f00:	f8df a240 	ldr.w	sl, [pc, #576]	; 22144 <initModeNames+0x4cc>
            knobParamNames[BitCrusher][1] = "SAMP RATIO";
   21f04:	f8c3 63ec 	str.w	r6, [r3, #1004]	; 0x3ec
            knobParamNames[BitCrusher][8] = "";
            knobParamNames[BitCrusher][9] = "";

            modeNames[Delay] = "DELAY";
            shortModeNames[Delay] = "DL";
            modeNamesDetails[Delay] = "STEREO";
   21f08:	4e4c      	ldr	r6, [pc, #304]	; (2203c <initModeNames+0x3c4>)
            modeNames[BitCrusher] = "BITCRUSH";
   21f0a:	f8c8 5028 	str.w	r5, [r8, #40]	; 0x28
            shortModeNames[BitCrusher] = "BC";
   21f0e:	f8cc 2028 	str.w	r2, [ip, #40]	; 0x28
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
   21f12:	f8cb a028 	str.w	sl, [fp, #40]	; 0x28
            knobParamNames[SamplerAutoGrab][4] = "";
   21f16:	f8c3 12cc 	str.w	r1, [r3, #716]	; 0x2cc
            knobParamNames[SamplerAutoGrab][7] = "";
   21f1a:	f8c3 12d8 	str.w	r1, [r3, #728]	; 0x2d8
            knobParamNames[SamplerAutoGrab][8] = "";
   21f1e:	f8c3 12dc 	str.w	r1, [r3, #732]	; 0x2dc
            knobParamNames[SamplerAutoGrab][9] = "";
   21f22:	f8c3 12e0 	str.w	r1, [r3, #736]	; 0x2e0
            knobParamNames[Wavefolder][4] = "";
   21f26:	f8c3 1394 	str.w	r1, [r3, #916]	; 0x394
            knobParamNames[Wavefolder][0] = "GAIN";
   21f2a:	f8c3 e384 	str.w	lr, [r3, #900]	; 0x384
            knobParamNames[Wavefolder][1] = "OFFSET1";
   21f2e:	f8c3 9388 	str.w	r9, [r3, #904]	; 0x388
            knobParamNames[Wavefolder][2] = "OFFSET2";
   21f32:	f8c3 738c 	str.w	r7, [r3, #908]	; 0x38c
            knobParamNames[Distortion][0] = "PRE GAIN";
   21f36:	f8c3 0320 	str.w	r0, [r3, #800]	; 0x320
            knobParamNames[Distortion][4] = "POST GAIN";
   21f3a:	f8c3 4330 	str.w	r4, [r3, #816]	; 0x330
            knobParamNames[Wavefolder][3] = "POST GAIN";
   21f3e:	f8c3 4390 	str.w	r4, [r3, #912]	; 0x390
            modeNamesDetails[Delay] = "STEREO";
   21f42:	f8cb 602c 	str.w	r6, [fp, #44]	; 0x2c
            knobParamNames[BitCrusher][4] = "POST GAIN";
   21f46:	f8c3 43f8 	str.w	r4, [r3, #1016]	; 0x3f8
            knobParamNames[Delay][0] = "DELAY_L";
            knobParamNames[Delay][1] = "DELAY_R";
            knobParamNames[Delay][2] = "HIGHPASS";
            knobParamNames[Delay][3] = "LOWPASS";
            knobParamNames[Delay][4] = "FEEDBACK";
            knobParamNames[Delay][5] = "POST GAIN";
   21f4a:	f8c3 4460 	str.w	r4, [r3, #1120]	; 0x460
            knobParamNames[Delay][6] = "POST GAIN";
   21f4e:	f8c3 4464 	str.w	r4, [r3, #1124]	; 0x464
            knobParamNames[Delay][7] = "POST GAIN";
   21f52:	f8c3 4468 	str.w	r4, [r3, #1128]	; 0x468
            knobParamNames[Delay][8] = "POST GAIN";
   21f56:	f8c3 446c 	str.w	r4, [r3, #1132]	; 0x46c
            knobParamNames[Delay][1] = "DELAY_R";
   21f5a:	4e56      	ldr	r6, [pc, #344]	; (220b4 <initModeNames+0x43c>)
            numPages[Reverb] = 1;
            knobParamNames[Reverb][0] = "SIZE";
            knobParamNames[Reverb][1] = "FB LOPASS";
            knobParamNames[Reverb][2] = "IN HIPASS";
            knobParamNames[Reverb][3] = "IN LOPASS";
            knobParamNames[Reverb][4] = "FB GAIN";
   21f5c:	4c56      	ldr	r4, [pc, #344]	; (220b8 <initModeNames+0x440>)
            knobParamNames[BitCrusher][2] = "ROUNDING";
   21f5e:	f8df e1e8 	ldr.w	lr, [pc, #488]	; 22148 <initModeNames+0x4d0>
            knobParamNames[BitCrusher][3] = "OPERATION";
   21f62:	f8df 91e8 	ldr.w	r9, [pc, #488]	; 2214c <initModeNames+0x4d4>
            modeNames[Delay] = "DELAY";
   21f66:	4f55      	ldr	r7, [pc, #340]	; (220bc <initModeNames+0x444>)
            shortModeNames[Delay] = "DL";
   21f68:	4d55      	ldr	r5, [pc, #340]	; (220c0 <initModeNames+0x448>)
            knobParamNames[Delay][0] = "DELAY_L";
   21f6a:	4a56      	ldr	r2, [pc, #344]	; (220c4 <initModeNames+0x44c>)
            knobParamNames[BitCrusher][5] = "PRE GAIN";
   21f6c:	f8c3 03fc 	str.w	r0, [r3, #1020]	; 0x3fc
            knobParamNames[Delay][1] = "DELAY_R";
   21f70:	f8c3 6450 	str.w	r6, [r3, #1104]	; 0x450
            knobParamNames[Reverb][2] = "IN HIPASS";
   21f74:	4854      	ldr	r0, [pc, #336]	; (220c8 <initModeNames+0x450>)
            knobParamNames[Reverb][1] = "FB LOPASS";
   21f76:	4e55      	ldr	r6, [pc, #340]	; (220cc <initModeNames+0x454>)
            knobParamNames[Reverb][4] = "FB GAIN";
   21f78:	f8c3 44c0 	str.w	r4, [r3, #1216]	; 0x4c0
            knobParamNames[Delay][3] = "LOWPASS";
   21f7c:	4c54      	ldr	r4, [pc, #336]	; (220d0 <initModeNames+0x458>)
            modeNames[Delay] = "DELAY";
   21f7e:	f8c8 702c 	str.w	r7, [r8, #44]	; 0x2c
            shortModeNames[Delay] = "DL";
   21f82:	f8cc 502c 	str.w	r5, [ip, #44]	; 0x2c
            modeNames[Reverb] = "REVERB1";
   21f86:	f8df a1c8 	ldr.w	sl, [pc, #456]	; 22150 <initModeNames+0x4d8>
            knobParamNames[BitCrusher][2] = "ROUNDING";
   21f8a:	f8c3 e3f0 	str.w	lr, [r3, #1008]	; 0x3f0
            knobParamNames[BitCrusher][3] = "OPERATION";
   21f8e:	f8c3 93f4 	str.w	r9, [r3, #1012]	; 0x3f4
            knobParamNames[Reverb][3] = "IN LOPASS";
   21f92:	f8df e1c0 	ldr.w	lr, [pc, #448]	; 22154 <initModeNames+0x4dc>
            modeNamesDetails[Reverb] = "DATTORRO ALG";
   21f96:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 22158 <initModeNames+0x4e0>


            modeNames[Reverb2] = "REVERB2";
   21f9a:	4f4e      	ldr	r7, [pc, #312]	; (220d4 <initModeNames+0x45c>)
            shortModeNames[Reverb2] = "RV";
            modeNamesDetails[Reverb2] = "NREVERB ALG";
   21f9c:	4d4e      	ldr	r5, [pc, #312]	; (220d8 <initModeNames+0x460>)
            knobParamNames[Delay][0] = "DELAY_L";
   21f9e:	f8c3 244c 	str.w	r2, [r3, #1100]	; 0x44c
            knobParamNames[Reverb][1] = "FB LOPASS";
   21fa2:	f8c3 64b4 	str.w	r6, [r3, #1204]	; 0x4b4
            knobParamNames[Delay][2] = "HIGHPASS";
   21fa6:	4a4d      	ldr	r2, [pc, #308]	; (220dc <initModeNames+0x464>)
            shortModeNames[Reverb] = "RV";
   21fa8:	4e4d      	ldr	r6, [pc, #308]	; (220e0 <initModeNames+0x468>)
            knobParamNames[Reverb][2] = "IN HIPASS";
   21faa:	f8c3 04b8 	str.w	r0, [r3, #1208]	; 0x4b8
            knobParamNames[Delay][3] = "LOWPASS";
   21fae:	f8c3 4458 	str.w	r4, [r3, #1112]	; 0x458
            knobParamNames[Reverb][0] = "SIZE";
   21fb2:	484c      	ldr	r0, [pc, #304]	; (220e4 <initModeNames+0x46c>)
            knobParamNames[Delay][4] = "FEEDBACK";
   21fb4:	4c4c      	ldr	r4, [pc, #304]	; (220e8 <initModeNames+0x470>)
            modeNames[Reverb] = "REVERB1";
   21fb6:	f8c8 a030 	str.w	sl, [r8, #48]	; 0x30
            modeNamesDetails[Reverb] = "DATTORRO ALG";
   21fba:	f8cb 9030 	str.w	r9, [fp, #48]	; 0x30
            modeNames[Reverb2] = "REVERB2";
   21fbe:	f8c8 7034 	str.w	r7, [r8, #52]	; 0x34
            modeNamesDetails[Reverb2] = "NREVERB ALG";
   21fc2:	f8cb 5034 	str.w	r5, [fp, #52]	; 0x34
   21fc6:	e0c9      	b.n	2215c <initModeNames+0x4e4>
   21fc8:	020fb200 	.word	0x020fb200
   21fcc:	020fb020 	.word	0x020fb020
   21fd0:	020fb104 	.word	0x020fb104
   21fd4:	00031df8 	.word	0x00031df8
   21fd8:	020fb22c 	.word	0x020fb22c
   21fdc:	00031dfc 	.word	0x00031dfc
   21fe0:	00031e14 	.word	0x00031e14
   21fe4:	00031e54 	.word	0x00031e54
   21fe8:	00031df4 	.word	0x00031df4
   21fec:	00031e60 	.word	0x00031e60
   21ff0:	00031e20 	.word	0x00031e20
   21ff4:	00031e48 	.word	0x00031e48
   21ff8:	00031d64 	.word	0x00031d64
   21ffc:	00031e64 	.word	0x00031e64
   22000:	00031e80 	.word	0x00031e80
   22004:	00031e0c 	.word	0x00031e0c
   22008:	00031e2c 	.word	0x00031e2c
   2200c:	00031e3c 	.word	0x00031e3c
   22010:	00031e34 	.word	0x00031e34
   22014:	00031e9c 	.word	0x00031e9c
   22018:	00031eb4 	.word	0x00031eb4
   2201c:	00031eb8 	.word	0x00031eb8
   22020:	00031ec0 	.word	0x00031ec0
   22024:	00031ed0 	.word	0x00031ed0
   22028:	00031ed8 	.word	0x00031ed8
   2202c:	00031ee8 	.word	0x00031ee8
   22030:	00031f04 	.word	0x00031f04
   22034:	00031f00 	.word	0x00031f00
   22038:	00031e78 	.word	0x00031e78
   2203c:	00031e94 	.word	0x00031e94
   22040:	00031f08 	.word	0x00031f08
   22044:	00031f2c 	.word	0x00031f2c
   22048:	00031f30 	.word	0x00031f30
   2204c:	00031f84 	.word	0x00031f84
   22050:	00031ef4 	.word	0x00031ef4
   22054:	00031f40 	.word	0x00031f40
   22058:	00031f88 	.word	0x00031f88
   2205c:	00031f78 	.word	0x00031f78
   22060:	00031f94 	.word	0x00031f94
   22064:	00031fa8 	.word	0x00031fa8
   22068:	00031f50 	.word	0x00031f50
   2206c:	00031f58 	.word	0x00031f58
   22070:	00031f60 	.word	0x00031f60
   22074:	00031fc8 	.word	0x00031fc8
   22078:	00031f6c 	.word	0x00031f6c
   2207c:	00031fd4 	.word	0x00031fd4
   22080:	00031fdc 	.word	0x00031fdc
   22084:	00032038 	.word	0x00032038
   22088:	00031ffc 	.word	0x00031ffc
   2208c:	00032000 	.word	0x00032000
   22090:	00032014 	.word	0x00032014
   22094:	00032044 	.word	0x00032044
   22098:	00032048 	.word	0x00032048
   2209c:	00032080 	.word	0x00032080
   220a0:	00032008 	.word	0x00032008
   220a4:	0003202c 	.word	0x0003202c
   220a8:	0003205c 	.word	0x0003205c
   220ac:	00032064 	.word	0x00032064
   220b0:	00032070 	.word	0x00032070
   220b4:	000320b8 	.word	0x000320b8
   220b8:	00032128 	.word	0x00032128
   220bc:	000320a4 	.word	0x000320a4
   220c0:	000320ac 	.word	0x000320ac
   220c4:	000320b0 	.word	0x000320b0
   220c8:	00032110 	.word	0x00032110
   220cc:	00032104 	.word	0x00032104
   220d0:	000320cc 	.word	0x000320cc
   220d4:	00032130 	.word	0x00032130
   220d8:	00032138 	.word	0x00032138
   220dc:	000320c0 	.word	0x000320c0
   220e0:	000320e8 	.word	0x000320e8
   220e4:	000320fc 	.word	0x000320fc
   220e8:	000320d4 	.word	0x000320d4
   220ec:	020fb1b8 	.word	0x020fb1b8
   220f0:	03020100 	.word	0x03020100
   220f4:	00031e04 	.word	0x00031e04
   220f8:	020fafd8 	.word	0x020fafd8
   220fc:	00031de8 	.word	0x00031de8
   22100:	020fb148 	.word	0x020fb148
   22104:	00031ea8 	.word	0x00031ea8
   22108:	00031e6c 	.word	0x00031e6c
   2210c:	00031e8c 	.word	0x00031e8c
   22110:	00031ec8 	.word	0x00031ec8
   22114:	00031ee0 	.word	0x00031ee0
   22118:	00031f3c 	.word	0x00031f3c
   2211c:	00031f20 	.word	0x00031f20
   22120:	00031f14 	.word	0x00031f14
   22124:	00031f9c 	.word	0x00031f9c
   22128:	00031fb4 	.word	0x00031fb4
   2212c:	00031fb8 	.word	0x00031fb8
   22130:	00031fe8 	.word	0x00031fe8
   22134:	00031ff4 	.word	0x00031ff4
   22138:	00032020 	.word	0x00032020
   2213c:	00032054 	.word	0x00032054
   22140:	00032018 	.word	0x00032018
   22144:	00032074 	.word	0x00032074
   22148:	0003208c 	.word	0x0003208c
   2214c:	00032098 	.word	0x00032098
   22150:	000320e0 	.word	0x000320e0
   22154:	0003211c 	.word	0x0003211c
   22158:	000320ec 	.word	0x000320ec
            knobParamNames[BitCrusher][6] = "";
   2215c:	f8c3 1400 	str.w	r1, [r3, #1024]	; 0x400
            knobParamNames[BitCrusher][7] = "";
   22160:	f8c3 1404 	str.w	r1, [r3, #1028]	; 0x404
            knobParamNames[BitCrusher][8] = "";
   22164:	f8c3 1408 	str.w	r1, [r3, #1032]	; 0x408
            knobParamNames[BitCrusher][9] = "";
   22168:	f8c3 140c 	str.w	r1, [r3, #1036]	; 0x40c
            knobParamNames[Delay][9] = "";
   2216c:	f8c3 1470 	str.w	r1, [r3, #1136]	; 0x470
            knobParamNames[Reverb][3] = "IN LOPASS";
   22170:	f8c3 e4bc 	str.w	lr, [r3, #1212]	; 0x4bc
            knobParamNames[Delay][2] = "HIGHPASS";
   22174:	f8c3 2454 	str.w	r2, [r3, #1108]	; 0x454
            knobParamNames[Delay][4] = "FEEDBACK";
   22178:	f8c3 445c 	str.w	r4, [r3, #1116]	; 0x45c
            knobParamNames[Reverb][0] = "SIZE";
   2217c:	f8c3 04b0 	str.w	r0, [r3, #1200]	; 0x4b0
            numPages[Reverb2] = 1;
            knobParamNames[Reverb2][0] = "SIZE";
            knobParamNames[Reverb2][1] = "LOWPASS";
            knobParamNames[Reverb2][2] = "HIGHPASS";
            knobParamNames[Reverb2][3] = "PEAK_FREQ";
   22180:	f8df e2fc 	ldr.w	lr, [pc, #764]	; 22480 <initModeNames+0x808>

            modeNames[LivingString] = "STRING1";
            shortModeNames[LivingString] = "LS";
            modeNamesDetails[LivingString] = "SYMP STRING";
            numPages[LivingString] = 3;
            knobParamNames[LivingString][0] = "FREQ1";
   22184:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 22484 <initModeNames+0x80c>
            knobParamNames[LivingString][5] = "PREP POS";
            knobParamNames[LivingString][6] = "PREP FORCE";
            knobParamNames[LivingString][7] = "LET RING";
            knobParamNames[LivingString][8] = "";
            knobParamNames[LivingString][9] = "";
            knobParamNames[LivingString][10] = "FREQ2";
   22188:	4f8d      	ldr	r7, [pc, #564]	; (223c0 <initModeNames+0x748>)
            knobParamNames[LivingString][11] = "FREQ3";
   2218a:	4d8e      	ldr	r5, [pc, #568]	; (223c4 <initModeNames+0x74c>)
            knobParamNames[Reverb2][1] = "LOWPASS";
   2218c:	4c8e      	ldr	r4, [pc, #568]	; (223c8 <initModeNames+0x750>)
            knobParamNames[LivingString][12] = "FREQ4";
   2218e:	f8df a2f8 	ldr.w	sl, [pc, #760]	; 22488 <initModeNames+0x810>
            shortModeNames[Reverb2] = "RV";
   22192:	e9cc 660c 	strd	r6, r6, [ip, #48]	; 0x30
            knobParamNames[Reverb2][0] = "SIZE";
   22196:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
            knobParamNames[Reverb2][2] = "HIGHPASS";
   2219a:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
            knobParamNames[Reverb2][4] = "PEAK_GAIN";
   2219e:	4a8b      	ldr	r2, [pc, #556]	; (223cc <initModeNames+0x754>)
            knobParamNames[Reverb2][3] = "PEAK_FREQ";
   221a0:	f8c3 e520 	str.w	lr, [r3, #1312]	; 0x520
            knobParamNames[Reverb2][4] = "PEAK_GAIN";
   221a4:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
            knobParamNames[LivingString][4] = "PICK POS";
   221a8:	4a89      	ldr	r2, [pc, #548]	; (223d0 <initModeNames+0x758>)
            knobParamNames[LivingString][13] = "FREQ5";
            knobParamNames[LivingString][14] = "FREQ6";
   221aa:	f8df e2e0 	ldr.w	lr, [pc, #736]	; 2248c <initModeNames+0x814>
            knobParamNames[LivingString][4] = "PICK POS";
   221ae:	f8c3 2588 	str.w	r2, [r3, #1416]	; 0x588
            modeNames[LivingString] = "STRING1";
   221b2:	4a88      	ldr	r2, [pc, #544]	; (223d4 <initModeNames+0x75c>)
            knobParamNames[LivingString][13] = "FREQ5";
   221b4:	4e88      	ldr	r6, [pc, #544]	; (223d8 <initModeNames+0x760>)
            modeNames[LivingString] = "STRING1";
   221b6:	f8c8 2038 	str.w	r2, [r8, #56]	; 0x38
            knobParamNames[LivingString][14] = "FREQ6";
   221ba:	f8c3 e5b0 	str.w	lr, [r3, #1456]	; 0x5b0
            knobParamNames[LivingString][3] = "DAMPING";
   221be:	4a87      	ldr	r2, [pc, #540]	; (223dc <initModeNames+0x764>)

            modeNames[LivingStringSynth] = "STRING2";
            shortModeNames[LivingStringSynth] = "SS";
            modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
   221c0:	f8df e2cc 	ldr.w	lr, [pc, #716]	; 22490 <initModeNames+0x818>
            knobParamNames[Reverb2][1] = "LOWPASS";
   221c4:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
            modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
   221c8:	f8cb e03c 	str.w	lr, [fp, #60]	; 0x3c
            numPages[LivingStringSynth] = 2;
            knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
   221cc:	4c84      	ldr	r4, [pc, #528]	; (223e0 <initModeNames+0x768>)
            knobParamNames[LivingString][0] = "FREQ1";
   221ce:	f8c3 9578 	str.w	r9, [r3, #1400]	; 0x578
            knobParamNames[LivingString][10] = "FREQ2";
   221d2:	f8c3 75a0 	str.w	r7, [r3, #1440]	; 0x5a0
            knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
   221d6:	f8df 92bc 	ldr.w	r9, [pc, #700]	; 22494 <initModeNames+0x81c>
            shortModeNames[LivingString] = "LS";
   221da:	4f82      	ldr	r7, [pc, #520]	; (223e4 <initModeNames+0x76c>)
            knobParamNames[LivingString][11] = "FREQ3";
   221dc:	f8c3 55a4 	str.w	r5, [r3, #1444]	; 0x5a4
            modeNames[LivingStringSynth] = "STRING2";
   221e0:	4881      	ldr	r0, [pc, #516]	; (223e8 <initModeNames+0x770>)
            modeNamesDetails[LivingString] = "SYMP STRING";
   221e2:	4d82      	ldr	r5, [pc, #520]	; (223ec <initModeNames+0x774>)
            knobParamNames[LivingString][13] = "FREQ5";
   221e4:	f8c3 65ac 	str.w	r6, [r3, #1452]	; 0x5ac
            numPages[Vocoder] = 2;
   221e8:	f8df e2ac 	ldr.w	lr, [pc, #684]	; 22498 <initModeNames+0x820>
            shortModeNames[LivingStringSynth] = "SS";
   221ec:	4e80      	ldr	r6, [pc, #512]	; (223f0 <initModeNames+0x778>)
            knobParamNames[LivingString][3] = "DAMPING";
   221ee:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
            knobParamNames[LivingStringSynth][2] = "DECAY";
            knobParamNames[LivingStringSynth][3] = "DAMPING";
   221f2:	f8c3 25e8 	str.w	r2, [r3, #1512]	; 0x5e8
            numPages[Vocoder] = 2;
   221f6:	4a7f      	ldr	r2, [pc, #508]	; (223f4 <initModeNames+0x77c>)
            shortModeNames[LivingString] = "LS";
   221f8:	f8cc 7038 	str.w	r7, [ip, #56]	; 0x38
            modeNamesDetails[LivingString] = "SYMP STRING";
   221fc:	f8cb 5038 	str.w	r5, [fp, #56]	; 0x38
            knobParamNames[LivingString][5] = "PREP POS";
   22200:	4f7d      	ldr	r7, [pc, #500]	; (223f8 <initModeNames+0x780>)
            knobParamNames[LivingString][6] = "PREP FORCE";
   22202:	4d7e      	ldr	r5, [pc, #504]	; (223fc <initModeNames+0x784>)
            modeNames[LivingStringSynth] = "STRING2";
   22204:	f8c8 003c 	str.w	r0, [r8, #60]	; 0x3c
            shortModeNames[LivingStringSynth] = "SS";
   22208:	f8cc 603c 	str.w	r6, [ip, #60]	; 0x3c
            knobParamNames[LivingString][7] = "LET RING";
   2220c:	487c      	ldr	r0, [pc, #496]	; (22400 <initModeNames+0x788>)
            knobParamNames[LivingString][2] = "DECAY";
   2220e:	4e7d      	ldr	r6, [pc, #500]	; (22404 <initModeNames+0x78c>)
            numPages[Vocoder] = 2;
   22210:	f8c2 e000 	str.w	lr, [r2]
            knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
   22214:	f8c3 45dc 	str.w	r4, [r3, #1500]	; 0x5dc
            numPages[Vocoder] = 2;
   22218:	f8df e280 	ldr.w	lr, [pc, #640]	; 2249c <initModeNames+0x824>
            knobParamNames[LivingString][1] = "DETUNE";
   2221c:	4c7a      	ldr	r4, [pc, #488]	; (22408 <initModeNames+0x790>)
            knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
   2221e:	f8c3 95e0 	str.w	r9, [r3, #1504]	; 0x5e0
            numPages[Vocoder] = 2;
   22222:	f8df 927c 	ldr.w	r9, [pc, #636]	; 224a0 <initModeNames+0x828>
   22226:	f8c2 e004 	str.w	lr, [r2, #4]
   2222a:	f8c2 900c 	str.w	r9, [r2, #12]
            knobParamNames[LivingString][8] = "";
   2222e:	f8c3 1598 	str.w	r1, [r3, #1432]	; 0x598
            knobParamNames[LivingString][9] = "";
   22232:	f8c3 159c 	str.w	r1, [r3, #1436]	; 0x59c
            knobParamNames[LivingString][12] = "FREQ4";
   22236:	f8c3 a5a8 	str.w	sl, [r3, #1448]	; 0x5a8
            knobParamNames[LivingString][1] = "DETUNE";
   2223a:	f8c3 457c 	str.w	r4, [r3, #1404]	; 0x57c
            knobParamNames[LivingString][2] = "DECAY";
   2223e:	f8c3 6580 	str.w	r6, [r3, #1408]	; 0x580
            knobParamNames[LivingStringSynth][2] = "DECAY";
   22242:	f8c3 65e4 	str.w	r6, [r3, #1508]	; 0x5e4
            knobParamNames[LivingString][5] = "PREP POS";
   22246:	f8c3 758c 	str.w	r7, [r3, #1420]	; 0x58c
            knobParamNames[LivingString][6] = "PREP FORCE";
   2224a:	f8c3 5590 	str.w	r5, [r3, #1424]	; 0x590
            knobParamNames[LivingString][7] = "LET RING";
   2224e:	f8c3 0594 	str.w	r0, [r3, #1428]	; 0x594
            numPages[Vocoder] = 2;
   22252:	f8c2 e008 	str.w	lr, [r2, #8]
            knobParamNames[LivingStringSynth][4] = "PICK_POS";
            knobParamNames[LivingStringSynth][5] = "PREP POS";
            knobParamNames[LivingStringSynth][6] = "PREP FORCE";
            knobParamNames[LivingStringSynth][7] = "LET RING";
   22256:	f8c3 05f8 	str.w	r0, [r3, #1528]	; 0x5f8
            knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
            knobParamNames[ClassicSynth][14] = "F_LEAK";
            knobParamNames[ClassicSynth][15] = "F_AMOUNT";
            knobParamNames[ClassicSynth][16] = "SAW/PULSE";
            knobParamNames[ClassicSynth][17] = "";
   2225a:	f8c3 1684 	str.w	r1, [r3, #1668]	; 0x684
            knobParamNames[ClassicSynth][0] = "VOLUME";
   2225e:	486b      	ldr	r0, [pc, #428]	; (2240c <initModeNames+0x794>)
            knobParamNames[ClassicSynth][18] = "";
   22260:	f8c3 1688 	str.w	r1, [r3, #1672]	; 0x688
            knobParamNames[ClassicSynth][19] = "";
   22264:	f8c3 168c 	str.w	r1, [r3, #1676]	; 0x68c
            numPages[ClassicSynth] = 4;
   22268:	f04f 0104 	mov.w	r1, #4
            knobParamNames[LivingStringSynth][4] = "PICK_POS";
   2226c:	f8df 9234 	ldr.w	r9, [pc, #564]	; 224a4 <initModeNames+0x82c>
            numPages[ClassicSynth] = 4;
   22270:	7411      	strb	r1, [r2, #16]
            knobParamNames[ClassicSynth][0] = "VOLUME";
   22272:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
            knobParamNames[LivingStringSynth][8] = "FB LEVEL";
   22276:	4a66      	ldr	r2, [pc, #408]	; (22410 <initModeNames+0x798>)
            knobParamNames[ClassicSynth][1] = "LOWPASS";
   22278:	4853      	ldr	r0, [pc, #332]	; (223c8 <initModeNames+0x750>)
            knobParamNames[LivingStringSynth][4] = "PICK_POS";
   2227a:	f8c3 95ec 	str.w	r9, [r3, #1516]	; 0x5ec
            knobParamNames[LivingStringSynth][5] = "PREP POS";
   2227e:	f8c3 75f0 	str.w	r7, [r3, #1520]	; 0x5f0
            knobParamNames[ClassicSynth][4] = "FILTER Q";
   22282:	f8df a224 	ldr.w	sl, [pc, #548]	; 224a8 <initModeNames+0x830>
            knobParamNames[LivingStringSynth][6] = "PREP FORCE";
   22286:	f8c3 55f4 	str.w	r5, [r3, #1524]	; 0x5f4
            knobParamNames[ClassicSynth][10] = "F_ATTACK";
   2228a:	f8df 9220 	ldr.w	r9, [pc, #544]	; 224ac <initModeNames+0x834>
            knobParamNames[ClassicSynth][11] = "F_DECAY";
   2228e:	f8df e220 	ldr.w	lr, [pc, #544]	; 224b0 <initModeNames+0x838>
            knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
   22292:	4f60      	ldr	r7, [pc, #384]	; (22414 <initModeNames+0x79c>)
            knobParamNames[ClassicSynth][1] = "LOWPASS";
   22294:	f8c3 0644 	str.w	r0, [r3, #1604]	; 0x644
            knobParamNames[ClassicSynth][3] = "DETUNE";
   22298:	f8c3 464c 	str.w	r4, [r3, #1612]	; 0x64c
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
   2229c:	485e      	ldr	r0, [pc, #376]	; (22418 <initModeNames+0x7a0>)
            knobParamNames[ClassicSynth][14] = "F_LEAK";
   2229e:	4d5f      	ldr	r5, [pc, #380]	; (2241c <initModeNames+0x7a4>)
            knobParamNames[ClassicSynth][6] = "DECAY";
   222a0:	f8c3 6658 	str.w	r6, [r3, #1624]	; 0x658
            knobParamNames[ClassicSynth][15] = "F_AMOUNT";
   222a4:	4c5e      	ldr	r4, [pc, #376]	; (22420 <initModeNames+0x7a8>)
            knobParamNames[ClassicSynth][16] = "SAW/PULSE";
   222a6:	495f      	ldr	r1, [pc, #380]	; (22424 <initModeNames+0x7ac>)
            knobParamNames[LivingStringSynth][8] = "FB LEVEL";
   222a8:	f8c3 25fc 	str.w	r2, [r3, #1532]	; 0x5fc
            knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
   222ac:	4e5e      	ldr	r6, [pc, #376]	; (22428 <initModeNames+0x7b0>)
            modeNames[ClassicSynth] = "POLYSYNTH";
   222ae:	4a5f      	ldr	r2, [pc, #380]	; (2242c <initModeNames+0x7b4>)
            knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
   222b0:	f8c3 6648 	str.w	r6, [r3, #1608]	; 0x648
            modeNames[ClassicSynth] = "POLYSYNTH";
   222b4:	f8c8 2040 	str.w	r2, [r8, #64]	; 0x40
            knobParamNames[ClassicSynth][4] = "FILTER Q";
   222b8:	f8c3 a650 	str.w	sl, [r3, #1616]	; 0x650
            knobParamNames[ClassicSynth][10] = "F_ATTACK";
   222bc:	f8c3 9668 	str.w	r9, [r3, #1640]	; 0x668
            modeNamesDetails[ClassicSynth] = "VCO+VCF";
   222c0:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 224b4 <initModeNames+0x83c>

            modeNames[Rhodes] = "RHODES";
   222c4:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 224b8 <initModeNames+0x840>
            knobParamNames[ClassicSynth][11] = "F_DECAY";
   222c8:	f8c3 e66c 	str.w	lr, [r3, #1644]	; 0x66c
            knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
   222cc:	f8c3 7670 	str.w	r7, [r3, #1648]	; 0x670
            shortModeNames[Rhodes] = "RD";
   222d0:	f8df e1e8 	ldr.w	lr, [pc, #488]	; 224bc <initModeNames+0x844>
            modeNamesDetails[Rhodes] = "DARK";
   222d4:	4f56      	ldr	r7, [pc, #344]	; (22430 <initModeNames+0x7b8>)
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
   222d6:	f8c3 0674 	str.w	r0, [r3, #1652]	; 0x674
            knobParamNames[ClassicSynth][14] = "F_LEAK";
   222da:	f8c3 5678 	str.w	r5, [r3, #1656]	; 0x678
            knobParamNames[LivingStringSynth][9] = "RELEASE";
   222de:	4855      	ldr	r0, [pc, #340]	; (22434 <initModeNames+0x7bc>)
            knobParamNames[ClassicSynth][5] = "ATTACK";
   222e0:	4d55      	ldr	r5, [pc, #340]	; (22438 <initModeNames+0x7c0>)
            knobParamNames[ClassicSynth][15] = "F_AMOUNT";
   222e2:	f8c3 467c 	str.w	r4, [r3, #1660]	; 0x67c
            knobParamNames[ClassicSynth][16] = "SAW/PULSE";
   222e6:	f8c3 1680 	str.w	r1, [r3, #1664]	; 0x680
            knobParamNames[ClassicSynth][7] = "SUSTAIN";
   222ea:	4c54      	ldr	r4, [pc, #336]	; (2243c <initModeNames+0x7c4>)
            knobParamNames[ClassicSynth][9] = "LEAK";
   222ec:	4954      	ldr	r1, [pc, #336]	; (22440 <initModeNames+0x7c8>)
            numPages[Rhodes] = 5;
            knobParamNames[Rhodes][0] = "BRIGHTNESS";
   222ee:	4a55      	ldr	r2, [pc, #340]	; (22444 <initModeNames+0x7cc>)
            shortModeNames[ClassicSynth] = "CS";
   222f0:	4e55      	ldr	r6, [pc, #340]	; (22448 <initModeNames+0x7d0>)
            modeNamesDetails[ClassicSynth] = "VCO+VCF";
   222f2:	f8cb a040 	str.w	sl, [fp, #64]	; 0x40
            shortModeNames[ClassicSynth] = "CS";
   222f6:	f8cc 6040 	str.w	r6, [ip, #64]	; 0x40
            modeNames[Rhodes] = "RHODES";
   222fa:	f8c8 9044 	str.w	r9, [r8, #68]	; 0x44
            shortModeNames[Rhodes] = "RD";
   222fe:	f8cc e044 	str.w	lr, [ip, #68]	; 0x44
            modeNamesDetails[Rhodes] = "DARK";
   22302:	f8cb 7044 	str.w	r7, [fp, #68]	; 0x44
            numPages[Rhodes] = 5;
   22306:	f04f 0705 	mov.w	r7, #5
            knobParamNames[LivingStringSynth][9] = "RELEASE";
   2230a:	f8c3 0600 	str.w	r0, [r3, #1536]	; 0x600
            knobParamNames[ClassicSynth][8] = "RELEASE";
   2230e:	f8c3 0660 	str.w	r0, [r3, #1632]	; 0x660
            knobParamNames[ClassicSynth][5] = "ATTACK";
   22312:	f8c3 5654 	str.w	r5, [r3, #1620]	; 0x654
            knobParamNames[ClassicSynth][7] = "SUSTAIN";
   22316:	f8c3 465c 	str.w	r4, [r3, #1628]	; 0x65c
            knobParamNames[ClassicSynth][9] = "LEAK";
   2231a:	f8c3 1664 	str.w	r1, [r3, #1636]	; 0x664
            knobParamNames[Rhodes][0] = "BRIGHTNESS";
   2231e:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
            knobParamNames[Rhodes][1] = "TREM DEPTH";
   22322:	4a4a      	ldr	r2, [pc, #296]	; (2244c <initModeNames+0x7d4>)
            numPages[Rhodes] = 5;
   22324:	4e33      	ldr	r6, [pc, #204]	; (223f4 <initModeNames+0x77c>)
            knobParamNames[Rhodes][1] = "TREM DEPTH";
   22326:	f8c3 26a8 	str.w	r2, [r3, #1704]	; 0x6a8
            knobParamNames[Rhodes][2] = "TREM RATE";
   2232a:	4a49      	ldr	r2, [pc, #292]	; (22450 <initModeNames+0x7d8>)
            numPages[Rhodes] = 5;
   2232c:	7477      	strb	r7, [r6, #17]
            knobParamNames[Rhodes][2] = "TREM RATE";
   2232e:	f8c3 26ac 	str.w	r2, [r3, #1708]	; 0x6ac
            knobParamNames[Rhodes][3] = "DRIVE";
   22332:	4a48      	ldr	r2, [pc, #288]	; (22454 <initModeNames+0x7dc>)
            knobParamNames[Rhodes][4] = "PAN SPREAD";
            knobParamNames[Rhodes][5] = "ATTACK";
            knobParamNames[Rhodes][6] = "DECAY";
   22334:	4e33      	ldr	r6, [pc, #204]	; (22404 <initModeNames+0x78c>)
            knobParamNames[Rhodes][3] = "DRIVE";
   22336:	f8c3 26b0 	str.w	r2, [r3, #1712]	; 0x6b0
            knobParamNames[Rhodes][4] = "PAN SPREAD";
   2233a:	4a47      	ldr	r2, [pc, #284]	; (22458 <initModeNames+0x7e0>)
            knobParamNames[Rhodes][7] = "SUSTAIN";
            knobParamNames[Rhodes][8] = "RELEASE";
            knobParamNames[Rhodes][9] = "LEAK";
   2233c:	f8c3 16c8 	str.w	r1, [r3, #1736]	; 0x6c8
            knobParamNames[Rhodes][4] = "PAN SPREAD";
   22340:	f8c3 26b4 	str.w	r2, [r3, #1716]	; 0x6b4
            knobParamNames[Rhodes][16] = "RATIO2";
            knobParamNames[Rhodes][17] = "RATIO3";
            knobParamNames[Rhodes][18] = "RATIO4";
            knobParamNames[Rhodes][19] = "RATIO5";
            knobParamNames[Rhodes][20] = "RATIO6";
            knobParamNames[Rhodes][21] = "FEEDBACK";
   22344:	4945      	ldr	r1, [pc, #276]	; (2245c <initModeNames+0x7e4>)
            knobParamNames[Rhodes][10] = "INDEX1";
   22346:	4a46      	ldr	r2, [pc, #280]	; (22460 <initModeNames+0x7e8>)
            knobParamNames[Rhodes][12] = "INDEX3";
   22348:	f8df a174 	ldr.w	sl, [pc, #372]	; 224c0 <initModeNames+0x848>
            knobParamNames[Rhodes][13] = "INDEX4";
   2234c:	f8df 9174 	ldr.w	r9, [pc, #372]	; 224c4 <initModeNames+0x84c>
            knobParamNames[Rhodes][14] = "INDEX5";
   22350:	f8df 8174 	ldr.w	r8, [pc, #372]	; 224c8 <initModeNames+0x850>
            knobParamNames[Rhodes][15] = "RATIO1";
   22354:	f8df e174 	ldr.w	lr, [pc, #372]	; 224cc <initModeNames+0x854>
            knobParamNames[Rhodes][5] = "ATTACK";
   22358:	f8c3 56b8 	str.w	r5, [r3, #1720]	; 0x6b8
            knobParamNames[Rhodes][16] = "RATIO2";
   2235c:	f8df c170 	ldr.w	ip, [pc, #368]	; 224d0 <initModeNames+0x858>
            knobParamNames[Rhodes][6] = "DECAY";
   22360:	f8c3 66bc 	str.w	r6, [r3, #1724]	; 0x6bc
            knobParamNames[Rhodes][17] = "RATIO3";
   22364:	4f3f      	ldr	r7, [pc, #252]	; (22464 <initModeNames+0x7ec>)
            knobParamNames[Rhodes][7] = "SUSTAIN";
   22366:	f8c3 46c0 	str.w	r4, [r3, #1728]	; 0x6c0
            knobParamNames[Rhodes][18] = "RATIO4";
   2236a:	4e3f      	ldr	r6, [pc, #252]	; (22468 <initModeNames+0x7f0>)
            knobParamNames[Rhodes][8] = "RELEASE";
   2236c:	f8c3 06c4 	str.w	r0, [r3, #1732]	; 0x6c4
            knobParamNames[Rhodes][19] = "RATIO5";
   22370:	4d3e      	ldr	r5, [pc, #248]	; (2246c <initModeNames+0x7f4>)
            knobParamNames[Rhodes][20] = "RATIO6";
   22372:	4c3f      	ldr	r4, [pc, #252]	; (22470 <initModeNames+0x7f8>)
            knobParamNames[Rhodes][21] = "FEEDBACK";
   22374:	f8c3 16f8 	str.w	r1, [r3, #1784]	; 0x6f8
            knobParamNames[Rhodes][22] = "TUNE SNAP";
   22378:	483e      	ldr	r0, [pc, #248]	; (22474 <initModeNames+0x7fc>)
            knobParamNames[Rhodes][23] = "RAND DECAY";
   2237a:	493f      	ldr	r1, [pc, #252]	; (22478 <initModeNames+0x800>)
            knobParamNames[Rhodes][24] = "RAND SUST";
   2237c:	f8df b154 	ldr.w	fp, [pc, #340]	; 224d4 <initModeNames+0x85c>
            knobParamNames[Rhodes][10] = "INDEX1";
   22380:	f8c3 26cc 	str.w	r2, [r3, #1740]	; 0x6cc
            knobParamNames[Rhodes][11] = "INDEX2";
   22384:	4a3d      	ldr	r2, [pc, #244]	; (2247c <initModeNames+0x804>)
            knobParamNames[Rhodes][12] = "INDEX3";
   22386:	f8c3 a6d4 	str.w	sl, [r3, #1748]	; 0x6d4
            knobParamNames[Rhodes][11] = "INDEX2";
   2238a:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0
            knobParamNames[Rhodes][13] = "INDEX4";
   2238e:	f8c3 96d8 	str.w	r9, [r3, #1752]	; 0x6d8
            knobParamNames[Rhodes][14] = "INDEX5";
   22392:	f8c3 86dc 	str.w	r8, [r3, #1756]	; 0x6dc
            knobParamNames[Rhodes][15] = "RATIO1";
   22396:	f8c3 e6e0 	str.w	lr, [r3, #1760]	; 0x6e0
            knobParamNames[Rhodes][16] = "RATIO2";
   2239a:	f8c3 c6e4 	str.w	ip, [r3, #1764]	; 0x6e4
            knobParamNames[Rhodes][17] = "RATIO3";
   2239e:	f8c3 76e8 	str.w	r7, [r3, #1768]	; 0x6e8
            knobParamNames[Rhodes][18] = "RATIO4";
   223a2:	f8c3 66ec 	str.w	r6, [r3, #1772]	; 0x6ec
            knobParamNames[Rhodes][19] = "RATIO5";
   223a6:	f8c3 56f0 	str.w	r5, [r3, #1776]	; 0x6f0
            knobParamNames[Rhodes][20] = "RATIO6";
   223aa:	f8c3 46f4 	str.w	r4, [r3, #1780]	; 0x6f4
            knobParamNames[Rhodes][22] = "TUNE SNAP";
   223ae:	f8c3 06fc 	str.w	r0, [r3, #1788]	; 0x6fc
            knobParamNames[Rhodes][23] = "RAND DECAY";
   223b2:	f8c3 1700 	str.w	r1, [r3, #1792]	; 0x700
            knobParamNames[Rhodes][24] = "RAND SUST";
   223b6:	f8c3 b704 	str.w	fp, [r3, #1796]	; 0x704
        }
   223ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   223be:	bf00      	nop
   223c0:	000321c4 	.word	0x000321c4
   223c4:	000321cc 	.word	0x000321cc
   223c8:	000320cc 	.word	0x000320cc
   223cc:	00032150 	.word	0x00032150
   223d0:	00032194 	.word	0x00032194
   223d4:	0003215c 	.word	0x0003215c
   223d8:	000321dc 	.word	0x000321dc
   223dc:	0003218c 	.word	0x0003218c
   223e0:	00032204 	.word	0x00032204
   223e4:	00032164 	.word	0x00032164
   223e8:	000321ec 	.word	0x000321ec
   223ec:	00032168 	.word	0x00032168
   223f0:	000322ec 	.word	0x000322ec
   223f4:	020fb0d8 	.word	0x020fb0d8
   223f8:	000321a0 	.word	0x000321a0
   223fc:	000321ac 	.word	0x000321ac
   22400:	000321b8 	.word	0x000321b8
   22404:	00032184 	.word	0x00032184
   22408:	0003217c 	.word	0x0003217c
   2240c:	00031dfc 	.word	0x00031dfc
   22410:	00032228 	.word	0x00032228
   22414:	00032298 	.word	0x00032298
   22418:	000322a4 	.word	0x000322a4
   2241c:	000322b0 	.word	0x000322b0
   22420:	000322b8 	.word	0x000322b8
   22424:	000322c4 	.word	0x000322c4
   22428:	00032254 	.word	0x00032254
   2242c:	0003223c 	.word	0x0003223c
   22430:	000322dc 	.word	0x000322dc
   22434:	00032234 	.word	0x00032234
   22438:	0003226c 	.word	0x0003226c
   2243c:	00032274 	.word	0x00032274
   22440:	0003227c 	.word	0x0003227c
   22444:	000322e4 	.word	0x000322e4
   22448:	00032248 	.word	0x00032248
   2244c:	000322f0 	.word	0x000322f0
   22450:	000322fc 	.word	0x000322fc
   22454:	00032308 	.word	0x00032308
   22458:	00032310 	.word	0x00032310
   2245c:	000320d4 	.word	0x000320d4
   22460:	0003231c 	.word	0x0003231c
   22464:	00032354 	.word	0x00032354
   22468:	0003235c 	.word	0x0003235c
   2246c:	00032364 	.word	0x00032364
   22470:	0003236c 	.word	0x0003236c
   22474:	00032374 	.word	0x00032374
   22478:	00032380 	.word	0x00032380
   2247c:	00032324 	.word	0x00032324
   22480:	00032144 	.word	0x00032144
   22484:	00032174 	.word	0x00032174
   22488:	000321d4 	.word	0x000321d4
   2248c:	000321e4 	.word	0x000321e4
   22490:	000321f4 	.word	0x000321f4
   22494:	00032210 	.word	0x00032210
   22498:	01020302 	.word	0x01020302
   2249c:	02020101 	.word	0x02020101
   224a0:	02030101 	.word	0x02030101
   224a4:	0003221c 	.word	0x0003221c
   224a8:	00032260 	.word	0x00032260
   224ac:	00032284 	.word	0x00032284
   224b0:	00032290 	.word	0x00032290
   224b4:	0003224c 	.word	0x0003224c
   224b8:	000322d0 	.word	0x000322d0
   224bc:	000322d8 	.word	0x000322d8
   224c0:	0003232c 	.word	0x0003232c
   224c4:	00032334 	.word	0x00032334
   224c8:	0003233c 	.word	0x0003233c
   224cc:	00032344 	.word	0x00032344
   224d0:	0003234c 	.word	0x0003234c
   224d4:	0003238c 	.word	0x0003238c

000224d8 <buttonCheck>:

        void buttonCheck(void)
        {
#ifndef __cplusplus
            if (codecReady)
   224d8:	4ba0      	ldr	r3, [pc, #640]	; (2275c <buttonCheck+0x284>)
   224da:	781b      	ldrb	r3, [r3, #0]
   224dc:	2b00      	cmp	r3, #0
   224de:	f000 80e7 	beq.w	226b0 <buttonCheck+0x1d8>
                 buttonValues[8] = !HAL_GPIO_ReadPin(GPIOG, GPIO_PIN_11); // D
                 buttonValues[9] = !HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_10); // E
                 */

                //A little more efficient since it avoids a function call
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   224e2:	499f      	ldr	r1, [pc, #636]	; (22760 <buttonCheck+0x288>)
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
#else
                {
#endif
                    for (int i = 0; i < NUM_BUTTONS; i++)
   224e4:	2300      	movs	r3, #0
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   224e6:	4a9f      	ldr	r2, [pc, #636]	; (22764 <buttonCheck+0x28c>)
        {
   224e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   224ec:	6908      	ldr	r0, [r1, #16]
        {
   224ee:	b087      	sub	sp, #28
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
                            buttonActionsUI[i][ActionHoldContinuous] = TRUE;
                            writeButtonFlag = i;
                            writeActionFlag = ActionHoldContinuous;
                        }
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
   224f0:	4f9d      	ldr	r7, [pc, #628]	; (22768 <buttonCheck+0x290>)
   224f2:	4694      	mov	ip, r2
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   224f4:	f480 5000 	eor.w	r0, r0, #8192	; 0x2000
                        {
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   224f8:	4d9c      	ldr	r5, [pc, #624]	; (2276c <buttonCheck+0x294>)
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
   224fa:	f8d7 a000 	ldr.w	sl, [r7]
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   224fe:	f3c0 3040 	ubfx	r0, r0, #13, #1
   22502:	4f9b      	ldr	r7, [pc, #620]	; (22770 <buttonCheck+0x298>)
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   22504:	4c9b      	ldr	r4, [pc, #620]	; (22774 <buttonCheck+0x29c>)
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   22506:	7010      	strb	r0, [r2, #0]
                buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
   22508:	6908      	ldr	r0, [r1, #16]
   2250a:	f997 7000 	ldrsb.w	r7, [r7]
   2250e:	f480 5080 	eor.w	r0, r0, #4096	; 0x1000
                buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
   22512:	4e99      	ldr	r6, [pc, #612]	; (22778 <buttonCheck+0x2a0>)
   22514:	9701      	str	r7, [sp, #4]
                buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
   22516:	f3c0 3000 	ubfx	r0, r0, #12, #1
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   2251a:	682d      	ldr	r5, [r5, #0]
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   2251c:	6824      	ldr	r4, [r4, #0]
                buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
   2251e:	7050      	strb	r0, [r2, #1]
                buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
   22520:	6908      	ldr	r0, [r1, #16]
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   22522:	9405      	str	r4, [sp, #20]
                buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
   22524:	f480 4080 	eor.w	r0, r0, #16384	; 0x4000
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   22528:	9504      	str	r5, [sp, #16]
   2252a:	4f94      	ldr	r7, [pc, #592]	; (2277c <buttonCheck+0x2a4>)
                buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
   2252c:	f3c0 3080 	ubfx	r0, r0, #14, #1
   22530:	4c93      	ldr	r4, [pc, #588]	; (22780 <buttonCheck+0x2a8>)
   22532:	f997 b000 	ldrsb.w	fp, [r7]
   22536:	7090      	strb	r0, [r2, #2]
                buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
   22538:	6930      	ldr	r0, [r6, #16]
   2253a:	4f92      	ldr	r7, [pc, #584]	; (22784 <buttonCheck+0x2ac>)
   2253c:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
   22540:	f8df e268 	ldr.w	lr, [pc, #616]	; 227ac <buttonCheck+0x2d4>
   22544:	f3c0 20c0 	ubfx	r0, r0, #11, #1
   22548:	70d0      	strb	r0, [r2, #3]
                buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
   2254a:	690d      	ldr	r5, [r1, #16]
                buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
   2254c:	6908      	ldr	r0, [r1, #16]
                buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
   2254e:	f485 4900 	eor.w	r9, r5, #32768	; 0x8000
                buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
   22552:	6936      	ldr	r6, [r6, #16]
                buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
   22554:	f080 0802 	eor.w	r8, r0, #2
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   22558:	488b      	ldr	r0, [pc, #556]	; (22788 <buttonCheck+0x2b0>)
                buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
   2255a:	690d      	ldr	r5, [r1, #16]
                buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
   2255c:	f086 0680 	eor.w	r6, r6, #128	; 0x80
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   22560:	6900      	ldr	r0, [r0, #16]
                buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
   22562:	f3c9 39c0 	ubfx	r9, r9, #15, #1
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
   22566:	6909      	ldr	r1, [r1, #16]
                buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
   22568:	f485 6500 	eor.w	r5, r5, #2048	; 0x800
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   2256c:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
                buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
   22570:	f3c8 0840 	ubfx	r8, r8, #1, #1
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
   22574:	f481 6180 	eor.w	r1, r1, #1024	; 0x400
                buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
   22578:	f3c6 16c0 	ubfx	r6, r6, #7, #1
                buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
   2257c:	f3c5 25c0 	ubfx	r5, r5, #11, #1
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   22580:	f3c0 20c0 	ubfx	r0, r0, #11, #1
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
   22584:	f3c1 2180 	ubfx	r1, r1, #10, #1
                buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
   22588:	f882 9004 	strb.w	r9, [r2, #4]
                buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
   2258c:	f882 8005 	strb.w	r8, [r2, #5]
                buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
   22590:	7196      	strb	r6, [r2, #6]
                buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
   22592:	71d5      	strb	r5, [r2, #7]
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   22594:	7210      	strb	r0, [r2, #8]
   22596:	f8df 8218 	ldr.w	r8, [pc, #536]	; 227b0 <buttonCheck+0x2d8>
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
   2259a:	7251      	strb	r1, [r2, #9]
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
   2259c:	f8df 91f8 	ldr.w	r9, [pc, #504]	; 22798 <buttonCheck+0x2c0>
   225a0:	e00f      	b.n	225c2 <buttonCheck+0xea>
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   225a2:	f858 1002 	ldr.w	r1, [r8, r2]
   225a6:	9804      	ldr	r0, [sp, #16]
   225a8:	4281      	cmp	r1, r0
   225aa:	d202      	bcs.n	225b2 <buttonCheck+0xda>
   225ac:	3101      	adds	r1, #1
   225ae:	f848 1002 	str.w	r1, [r8, r2]
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   225b2:	9805      	ldr	r0, [sp, #20]
   225b4:	4288      	cmp	r0, r1
   225b6:	d801      	bhi.n	225bc <buttonCheck+0xe4>
   225b8:	2d01      	cmp	r5, #1
   225ba:	d07a      	beq.n	226b2 <buttonCheck+0x1da>
                    for (int i = 0; i < NUM_BUTTONS; i++)
   225bc:	3301      	adds	r3, #1
   225be:	2b0a      	cmp	r3, #10
   225c0:	d037      	beq.n	22632 <buttonCheck+0x15a>
                        if (buttonValues[i] != buttonValuesPrev[i])
   225c2:	f81c 1b01 	ldrb.w	r1, [ip], #1
   225c6:	f817 2f01 	ldrb.w	r2, [r7, #1]!
   225ca:	f854 0f04 	ldr.w	r0, [r4, #4]!
   225ce:	428a      	cmp	r2, r1
   225d0:	d001      	beq.n	225d6 <buttonCheck+0xfe>
                            buttonHysteresis[i]++;
   225d2:	3001      	adds	r0, #1
   225d4:	6020      	str	r0, [r4, #0]
                        if (cleanButtonValues[i] == 1)
   225d6:	f81e 5003 	ldrb.w	r5, [lr, r3]
   225da:	009a      	lsls	r2, r3, #2
   225dc:	2d01      	cmp	r5, #1
   225de:	d10d      	bne.n	225fc <buttonCheck+0x124>
                            writeButtonFlag = i;
   225e0:	b25e      	sxtb	r6, r3
                            writeActionFlag = ActionHoldContinuous;
   225e2:	f04f 0b03 	mov.w	fp, #3
                            writeButtonFlag = i;
   225e6:	9601      	str	r6, [sp, #4]
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
   225e8:	eb09 0602 	add.w	r6, r9, r2
   225ec:	9602      	str	r6, [sp, #8]
                            buttonActionsUI[i][ActionHoldContinuous] = TRUE;
   225ee:	4e67      	ldr	r6, [pc, #412]	; (2278c <buttonCheck+0x2b4>)
   225f0:	4416      	add	r6, r2
   225f2:	9603      	str	r6, [sp, #12]
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
   225f4:	9e02      	ldr	r6, [sp, #8]
   225f6:	70f5      	strb	r5, [r6, #3]
                            buttonActionsUI[i][ActionHoldContinuous] = TRUE;
   225f8:	9e03      	ldr	r6, [sp, #12]
   225fa:	70f5      	strb	r5, [r6, #3]
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
   225fc:	4582      	cmp	sl, r0
   225fe:	d8d0      	bhi.n	225a2 <buttonCheck+0xca>
                            }
                        }
                        else
                        {
                            cleanButtonValues[i] = buttonValues[i];
                            buttonHysteresis[i] = 0;
   22600:	2000      	movs	r0, #0
                            buttonCounters[i] = 0;

                            if (cleanButtonValues[i] == 1)
   22602:	2901      	cmp	r1, #1
                            cleanButtonValues[i] = buttonValues[i];
   22604:	f80e 1003 	strb.w	r1, [lr, r3]
                            buttonHysteresis[i] = 0;
   22608:	6020      	str	r0, [r4, #0]
                            buttonCounters[i] = 0;
   2260a:	f848 0002 	str.w	r0, [r8, r2]
                            if (cleanButtonValues[i] == 1)
   2260e:	d045      	beq.n	2269c <buttonCheck+0x1c4>
                                buttonActionsSFX[i][ActionPress] = TRUE;
                                buttonActionsUI[i][ActionPress] = TRUE;
                                writeButtonFlag = i;
                                writeActionFlag = ActionPress;
                            }
                            else if (cleanButtonValues[i] == 0)
   22610:	b959      	cbnz	r1, 2262a <buttonCheck+0x152>
                            {
                                buttonActionsSFX[i][ActionRelease] = TRUE;
                                buttonActionsUI[i][ActionRelease] = TRUE;
   22612:	4d5e      	ldr	r5, [pc, #376]	; (2278c <buttonCheck+0x2b4>)
                                buttonActionsSFX[i][ActionRelease] = TRUE;
   22614:	eb09 0002 	add.w	r0, r9, r2
                                writeButtonFlag = i;
                                writeActionFlag = ActionRelease;
   22618:	f04f 0b01 	mov.w	fp, #1
                                buttonActionsUI[i][ActionRelease] = TRUE;
   2261c:	442a      	add	r2, r5
                                writeButtonFlag = i;
   2261e:	b25d      	sxtb	r5, r3
   22620:	9501      	str	r5, [sp, #4]
                                buttonActionsSFX[i][ActionRelease] = TRUE;
   22622:	f04f 0501 	mov.w	r5, #1
   22626:	7045      	strb	r5, [r0, #1]
                                buttonActionsUI[i][ActionRelease] = TRUE;
   22628:	7055      	strb	r5, [r2, #1]
                            }
                            buttonValuesPrev[i] = buttonValues[i];
   2262a:	7039      	strb	r1, [r7, #0]
                    for (int i = 0; i < NUM_BUTTONS; i++)
   2262c:	3301      	adds	r3, #1
   2262e:	2b0a      	cmp	r3, #10
   22630:	d1c7      	bne.n	225c2 <buttonCheck+0xea>

                    // make some if statements if you want to find the "attack" of the buttons (getting the "press" action)

                    /// DEFINE GLOBAL BUTTON BEHAVIOR HERE

                    if (buttonActionsUI[ButtonLeft][ActionPress] == 1)
   22632:	4b56      	ldr	r3, [pc, #344]	; (2278c <buttonCheck+0x2b4>)
   22634:	4a4e      	ldr	r2, [pc, #312]	; (22770 <buttonCheck+0x298>)
   22636:	791b      	ldrb	r3, [r3, #4]
   22638:	9901      	ldr	r1, [sp, #4]
   2263a:	2b01      	cmp	r3, #1
   2263c:	7011      	strb	r1, [r2, #0]
   2263e:	4a4f      	ldr	r2, [pc, #316]	; (2277c <buttonCheck+0x2a4>)
   22640:	f882 b000 	strb.w	fp, [r2]
   22644:	f000 815c 	beq.w	22900 <buttonCheck+0x428>
                        loadingPreset = 1;
                        OLED_writePreset();
                        writeCurrentPresetToFlash();
                        clearButtonActions();
                    }
                    if (buttonActionsUI[ButtonRight][ActionPress] == 1)
   22648:	4b50      	ldr	r3, [pc, #320]	; (2278c <buttonCheck+0x2b4>)
   2264a:	7a1b      	ldrb	r3, [r3, #8]
   2264c:	2b01      	cmp	r3, #1
   2264e:	f000 8191 	beq.w	22974 <buttonCheck+0x49c>
                        loadingPreset = 1;
                        OLED_writePreset();
                        writeCurrentPresetToFlash();
                        clearButtonActions();
                    }
                    if (buttonActionsUI[ButtonD][ActionPress] == 1)
   22652:	4b4e      	ldr	r3, [pc, #312]	; (2278c <buttonCheck+0x2b4>)
   22654:	f893 3020 	ldrb.w	r3, [r3, #32]
   22658:	2b01      	cmp	r3, #1
   2265a:	f000 81c6 	beq.w	229ea <buttonCheck+0x512>
                        }
                        changeTuning();
                        OLED_writeTuning();
                        buttonActionsUI[ButtonD][ActionPress] = 0;
                    }
                    if (buttonActionsUI[ButtonE][ActionPress] == 1)
   2265e:	4b4b      	ldr	r3, [pc, #300]	; (2278c <buttonCheck+0x2b4>)
   22660:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   22664:	2b01      	cmp	r3, #1
   22666:	f000 81fd 	beq.w	22a64 <buttonCheck+0x58c>
                        changeTuning();
                        OLED_writeTuning();
                        buttonActionsUI[ButtonE][ActionPress] = 0;
                    }

                    if (buttonActionsUI[ButtonEdit][ActionPress])
   2266a:	4b48      	ldr	r3, [pc, #288]	; (2278c <buttonCheck+0x2b4>)
   2266c:	781b      	ldrb	r3, [r3, #0]
   2266e:	2b00      	cmp	r3, #0
   22670:	f040 81e9 	bne.w	22a46 <buttonCheck+0x56e>
                    {
                        OLED_writeEditScreen();
                        setLED_Edit(1);
                        buttonActionsUI[ButtonEdit][ActionPress] = 0;
                    }
                    if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
   22674:	4b45      	ldr	r3, [pc, #276]	; (2278c <buttonCheck+0x2b4>)
   22676:	78db      	ldrb	r3, [r3, #3]
   22678:	2b01      	cmp	r3, #1
                    {
                        if (buttonActionsUI[ButtonC][ActionPress] == 1)
   2267a:	4b44      	ldr	r3, [pc, #272]	; (2278c <buttonCheck+0x2b4>)
                    if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
   2267c:	d026      	beq.n	226cc <buttonCheck+0x1f4>
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
                        }

                        //            OLEDdrawFloatArray(audioDisplayBuffer, -1.0f, 1.0f, 128, displayBufferIndex, 0, BothLines);
                    }
                    if (buttonActionsUI[ButtonEdit][ActionRelease] == 1)
   2267e:	785b      	ldrb	r3, [r3, #1]
   22680:	2b01      	cmp	r3, #1
   22682:	d038      	beq.n	226f6 <buttonCheck+0x21e>
                        buttonActionsUI[ButtonEdit][ActionRelease] = 0;
                        buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
                        buttonActionsSFX[ButtonEdit][ActionHoldContinuous] = 0;

                    }
                    if (buttonActionsUI[ButtonDown][ActionPress] == 1)
   22684:	4b41      	ldr	r3, [pc, #260]	; (2278c <buttonCheck+0x2b4>)
   22686:	7b1b      	ldrb	r3, [r3, #12]
   22688:	2b01      	cmp	r3, #1
   2268a:	d044      	beq.n	22716 <buttonCheck+0x23e>
                        decrementPage();
                        OLEDwriteString("P", 1, 110, FirstLine);
                        OLEDwriteInt(knobPage, 1, 120, FirstLine);
                        buttonActionsUI[ButtonDown][ActionPress] = 0;
                    }
                    if (buttonActionsUI[ButtonUp][ActionPress] == 1)
   2268c:	4b3f      	ldr	r3, [pc, #252]	; (2278c <buttonCheck+0x2b4>)
   2268e:	7c1b      	ldrb	r3, [r3, #16]
   22690:	2b01      	cmp	r3, #1
   22692:	f000 80e3 	beq.w	2285c <buttonCheck+0x384>
                    //            OLEDwriteString(" ", 1, getCursorX(), SecondLine);
                    //            OLEDwriteString(paramNames[orderedParams[currentParamIndex]], getCursorX(), SecondLine);
                    //            buttonActionsUI[ButtonEdit][ActionPress] = 0;
                    //        }
                }
            }
   22696:	b007      	add	sp, #28
   22698:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                writeButtonFlag = i;
   2269c:	b258      	sxtb	r0, r3
                                buttonActionsSFX[i][ActionPress] = TRUE;
   2269e:	f809 1002 	strb.w	r1, [r9, r2]
                                writeActionFlag = ActionPress;
   226a2:	f04f 0b00 	mov.w	fp, #0
                            buttonValuesPrev[i] = buttonValues[i];
   226a6:	7039      	strb	r1, [r7, #0]
                                writeButtonFlag = i;
   226a8:	9001      	str	r0, [sp, #4]
                                buttonActionsUI[i][ActionPress] = TRUE;
   226aa:	4838      	ldr	r0, [pc, #224]	; (2278c <buttonCheck+0x2b4>)
   226ac:	5481      	strb	r1, [r0, r2]
   226ae:	e7bd      	b.n	2262c <buttonCheck+0x154>
   226b0:	4770      	bx	lr
                                buttonActionsUI[i][ActionHoldInstant] = TRUE;
   226b2:	4836      	ldr	r0, [pc, #216]	; (2278c <buttonCheck+0x2b4>)
                                buttonActionsSFX[i][ActionHoldInstant] = TRUE;
   226b4:	eb09 0102 	add.w	r1, r9, r2
                                writeActionFlag = ActionHoldInstant;
   226b8:	f04f 0b02 	mov.w	fp, #2
                                buttonActionsUI[i][ActionHoldInstant] = TRUE;
   226bc:	4402      	add	r2, r0
                                writeButtonFlag = i;
   226be:	b258      	sxtb	r0, r3
   226c0:	9001      	str	r0, [sp, #4]
                                buttonActionsSFX[i][ActionHoldInstant] = TRUE;
   226c2:	f04f 0001 	mov.w	r0, #1
   226c6:	7088      	strb	r0, [r1, #2]
                                buttonActionsUI[i][ActionHoldInstant] = TRUE;
   226c8:	7090      	strb	r0, [r2, #2]
   226ca:	e777      	b.n	225bc <buttonCheck+0xe4>
                        if (buttonActionsUI[ButtonC][ActionPress] == 1)
   226cc:	7f1c      	ldrb	r4, [r3, #28]
   226ce:	2c01      	cmp	r4, #1
   226d0:	f000 8261 	beq.w	22b96 <buttonCheck+0x6be>
                        if (buttonActionsUI[ButtonDown][ActionPress])
   226d4:	4d2d      	ldr	r5, [pc, #180]	; (2278c <buttonCheck+0x2b4>)
   226d6:	7b2b      	ldrb	r3, [r5, #12]
   226d8:	b14b      	cbz	r3, 226ee <buttonCheck+0x216>
                            cvAddParam[currentPreset] = -1;
   226da:	4a2d      	ldr	r2, [pc, #180]	; (22790 <buttonCheck+0x2b8>)
                            buttonActionsUI[ButtonDown][ActionPress] = 0;
   226dc:	2300      	movs	r3, #0
                            cvAddParam[currentPreset] = -1;
   226de:	20ff      	movs	r0, #255	; 0xff
   226e0:	4c2c      	ldr	r4, [pc, #176]	; (22794 <buttonCheck+0x2bc>)
   226e2:	7811      	ldrb	r1, [r2, #0]
                            buttonActionsSFX[ButtonDown][ActionPress] = 0;
   226e4:	4a2c      	ldr	r2, [pc, #176]	; (22798 <buttonCheck+0x2c0>)
                            cvAddParam[currentPreset] = -1;
   226e6:	5460      	strb	r0, [r4, r1]
                            buttonActionsUI[ButtonDown][ActionPress] = 0;
   226e8:	732b      	strb	r3, [r5, #12]
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   226ea:	70eb      	strb	r3, [r5, #3]
                            buttonActionsSFX[ButtonDown][ActionPress] = 0;
   226ec:	7313      	strb	r3, [r2, #12]
                    if (buttonActionsUI[ButtonEdit][ActionRelease] == 1)
   226ee:	4b27      	ldr	r3, [pc, #156]	; (2278c <buttonCheck+0x2b4>)
   226f0:	785b      	ldrb	r3, [r3, #1]
   226f2:	2b01      	cmp	r3, #1
   226f4:	d1ca      	bne.n	2268c <buttonCheck+0x1b4>
                        OLED_writePreset();
   226f6:	f7f6 ff2f 	bl	19558 <OLED_writePreset>
                        setLED_Edit(0);
   226fa:	2000      	movs	r0, #0
   226fc:	f7f6 fe8c 	bl	19418 <setLED_Edit>
                        buttonActionsSFX[ButtonEdit][ActionRelease] = 0;
   22700:	2300      	movs	r3, #0
   22702:	4a25      	ldr	r2, [pc, #148]	; (22798 <buttonCheck+0x2c0>)
                        buttonActionsUI[ButtonEdit][ActionRelease] = 0;
   22704:	4921      	ldr	r1, [pc, #132]	; (2278c <buttonCheck+0x2b4>)
                        buttonActionsSFX[ButtonEdit][ActionRelease] = 0;
   22706:	7053      	strb	r3, [r2, #1]
                        buttonActionsUI[ButtonEdit][ActionRelease] = 0;
   22708:	704b      	strb	r3, [r1, #1]
                        buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   2270a:	70cb      	strb	r3, [r1, #3]
                        buttonActionsSFX[ButtonEdit][ActionHoldContinuous] = 0;
   2270c:	70d3      	strb	r3, [r2, #3]
                    if (buttonActionsUI[ButtonDown][ActionPress] == 1)
   2270e:	4b1f      	ldr	r3, [pc, #124]	; (2278c <buttonCheck+0x2b4>)
   22710:	7b1b      	ldrb	r3, [r3, #12]
   22712:	2b01      	cmp	r3, #1
   22714:	d1ba      	bne.n	2268c <buttonCheck+0x1b4>

            }

            void decrementPage(void)
            {
                if (knobPage == 0) knobPage = numPages[currentPreset] - 1;
   22716:	4f21      	ldr	r7, [pc, #132]	; (2279c <buttonCheck+0x2c4>)
   22718:	4d1d      	ldr	r5, [pc, #116]	; (22790 <buttonCheck+0x2b8>)
   2271a:	783b      	ldrb	r3, [r7, #0]
   2271c:	7829      	ldrb	r1, [r5, #0]
   2271e:	2b00      	cmp	r3, #0
   22720:	f000 8231 	beq.w	22b86 <buttonCheck+0x6ae>
                else knobPage--;
   22724:	3b01      	subs	r3, #1
   22726:	b2db      	uxtb	r3, r3
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   22728:	4a1d      	ldr	r2, [pc, #116]	; (227a0 <buttonCheck+0x2c8>)
   2272a:	eb03 0b83 	add.w	fp, r3, r3, lsl #2
   2272e:	2064      	movs	r0, #100	; 0x64
   22730:	4c18      	ldr	r4, [pc, #96]	; (22794 <buttonCheck+0x2bc>)
   22732:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
                }
            }

            void setKnobValues(float* values)
            {
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22736:	f04f 0900 	mov.w	r9, #0
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   2273a:	fb00 2001 	mla	r0, r0, r1, r2
   2273e:	4a19      	ldr	r2, [pc, #100]	; (227a4 <buttonCheck+0x2cc>)
   22740:	9401      	str	r4, [sp, #4]
   22742:	9203      	str	r2, [sp, #12]
                    {
                        knob = 5;
                    }
                    knobActive[knob] = 0;
                    floatADCUI[knob] = -1.0f;
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22744:	f10b 0214 	add.w	r2, fp, #20
   22748:	4c17      	ldr	r4, [pc, #92]	; (227a8 <buttonCheck+0x2d0>)
   2274a:	4606      	mov	r6, r0
   2274c:	1882      	adds	r2, r0, r2
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   2274e:	9004      	str	r0, [sp, #16]
   22750:	f8df 8060 	ldr.w	r8, [pc, #96]	; 227b4 <buttonCheck+0x2dc>
   22754:	9402      	str	r4, [sp, #8]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22756:	9205      	str	r2, [sp, #20]
   22758:	703b      	strb	r3, [r7, #0]
   2275a:	e043      	b.n	227e4 <buttonCheck+0x30c>
   2275c:	020e2dc0 	.word	0x020e2dc0
   22760:	58020400 	.word	0x58020400
   22764:	020fb934 	.word	0x020fb934
   22768:	00062820 	.word	0x00062820
   2276c:	00062818 	.word	0x00062818
   22770:	0006282a 	.word	0x0006282a
   22774:	0006281c 	.word	0x0006281c
   22778:	58020c00 	.word	0x58020c00
   2277c:	00062829 	.word	0x00062829
   22780:	020fb024 	.word	0x020fb024
   22784:	020faf87 	.word	0x020faf87
   22788:	58021800 	.word	0x58021800
   2278c:	020fb11c 	.word	0x020fb11c
   22790:	020e2f19 	.word	0x020e2f19
   22794:	020fb200 	.word	0x020fb200
   22798:	020fafac 	.word	0x020fafac
   2279c:	020e2f1a 	.word	0x020e2f1a
   227a0:	020e55d8 	.word	0x020e55d8
   227a4:	020fa1dc 	.word	0x020fa1dc
   227a8:	020fb0ec 	.word	0x020fb0ec
   227ac:	020fb050 	.word	0x020fb050
   227b0:	020fb190 	.word	0x020fb190
   227b4:	020fb104 	.word	0x020fb104
                    knobActive[knob] = 0;
   227b8:	9b03      	ldr	r3, [sp, #12]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   227ba:	ed9a 0a00 	vldr	s0, [sl]
                    knobActive[knob] = 0;
   227be:	f803 e009 	strb.w	lr, [r3, r9]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   227c2:	f109 0901 	add.w	r9, r9, #1
                    floatADCUI[knob] = -1.0f;
   227c6:	edcc 7a00 	vstr	s15, [ip]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   227ca:	f005 fb1d 	bl	27e08 <tExpSmooth_setValAndDest>

                    smoothedADC[knob] = values[knob];
   227ce:	9b02      	ldr	r3, [sp, #8]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   227d0:	f1b9 0f05 	cmp.w	r9, #5
                    smoothedADC[knob] = values[knob];
   227d4:	441c      	add	r4, r3
   227d6:	f8da 3000 	ldr.w	r3, [sl]
   227da:	6023      	str	r3, [r4, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   227dc:	d02a      	beq.n	22834 <buttonCheck+0x35c>
   227de:	783b      	ldrb	r3, [r7, #0]
   227e0:	7829      	ldrb	r1, [r5, #0]
   227e2:	9e04      	ldr	r6, [sp, #16]
   227e4:	ea4f 0489 	mov.w	r4, r9, lsl #2
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   227e8:	2205      	movs	r2, #5
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   227ea:	48b9      	ldr	r0, [pc, #740]	; (22ad0 <buttonCheck+0x5f8>)
                    floatADCUI[knob] = -1.0f;
   227ec:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   227f0:	eb0b 0a04 	add.w	sl, fp, r4
                    knobActive[knob] = 0;
   227f4:	f04f 0e00 	mov.w	lr, #0
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   227f8:	fb12 9203 	smlabb	r2, r2, r3, r9
                    floatADCUI[knob] = -1.0f;
   227fc:	eb08 0c04 	add.w	ip, r8, r4
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22800:	44b2      	add	sl, r6
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   22802:	9e01      	ldr	r6, [sp, #4]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22804:	4420      	add	r0, r4
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   22806:	5671      	ldrsb	r1, [r6, r1]
   22808:	428a      	cmp	r2, r1
   2280a:	d1d5      	bne.n	227b8 <buttonCheck+0x2e0>
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   2280c:	9c05      	ldr	r4, [sp, #20]
                    knobActive[knob] = 0;
   2280e:	2200      	movs	r2, #0
                    floatADCUI[knob] = -1.0f;
   22810:	4bb0      	ldr	r3, [pc, #704]	; (22ad4 <buttonCheck+0x5fc>)
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22812:	f109 0901 	add.w	r9, r9, #1
                    knobActive[knob] = 0;
   22816:	9903      	ldr	r1, [sp, #12]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22818:	ed94 0a00 	vldr	s0, [r4]
   2281c:	48ae      	ldr	r0, [pc, #696]	; (22ad8 <buttonCheck+0x600>)
                    knobActive[knob] = 0;
   2281e:	714a      	strb	r2, [r1, #5]
                    floatADCUI[knob] = -1.0f;
   22820:	f8c8 3014 	str.w	r3, [r8, #20]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22824:	f005 faf0 	bl	27e08 <tExpSmooth_setValAndDest>
                    smoothedADC[knob] = values[knob];
   22828:	6823      	ldr	r3, [r4, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   2282a:	f1b9 0f05 	cmp.w	r9, #5
                    smoothedADC[knob] = values[knob];
   2282e:	9a02      	ldr	r2, [sp, #8]
   22830:	6153      	str	r3, [r2, #20]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22832:	d1d4      	bne.n	227de <buttonCheck+0x306>
                        OLEDwriteString("P", 1, 110, FirstLine);
   22834:	2300      	movs	r3, #0
   22836:	226e      	movs	r2, #110	; 0x6e
   22838:	2101      	movs	r1, #1
   2283a:	48a8      	ldr	r0, [pc, #672]	; (22adc <buttonCheck+0x604>)
   2283c:	f7f7 f866 	bl	1990c <OLEDwriteString>
                        OLEDwriteInt(knobPage, 1, 120, FirstLine);
   22840:	2300      	movs	r3, #0
   22842:	2278      	movs	r2, #120	; 0x78
   22844:	7838      	ldrb	r0, [r7, #0]
   22846:	2101      	movs	r1, #1
   22848:	f7f7 f88a 	bl	19960 <OLEDwriteInt>
                        buttonActionsUI[ButtonDown][ActionPress] = 0;
   2284c:	2300      	movs	r3, #0
   2284e:	4aa4      	ldr	r2, [pc, #656]	; (22ae0 <buttonCheck+0x608>)
   22850:	7313      	strb	r3, [r2, #12]
                    if (buttonActionsUI[ButtonUp][ActionPress] == 1)
   22852:	4ba3      	ldr	r3, [pc, #652]	; (22ae0 <buttonCheck+0x608>)
   22854:	7c1b      	ldrb	r3, [r3, #16]
   22856:	2b01      	cmp	r3, #1
   22858:	f47f af1d 	bne.w	22696 <buttonCheck+0x1be>
                knobPage = (knobPage + 1) % numPages[currentPreset];
   2285c:	4fa1      	ldr	r7, [pc, #644]	; (22ae4 <buttonCheck+0x60c>)
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   2285e:	2464      	movs	r4, #100	; 0x64
                knobPage = (knobPage + 1) % numPages[currentPreset];
   22860:	4da1      	ldr	r5, [pc, #644]	; (22ae8 <buttonCheck+0x610>)
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22862:	f04f 0a00 	mov.w	sl, #0
                knobPage = (knobPage + 1) % numPages[currentPreset];
   22866:	783b      	ldrb	r3, [r7, #0]
   22868:	7829      	ldrb	r1, [r5, #0]
   2286a:	4aa0      	ldr	r2, [pc, #640]	; (22aec <buttonCheck+0x614>)
   2286c:	4ea0      	ldr	r6, [pc, #640]	; (22af0 <buttonCheck+0x618>)
   2286e:	5c50      	ldrb	r0, [r2, r1]
   22870:	1c5a      	adds	r2, r3, #1
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   22872:	4ba0      	ldr	r3, [pc, #640]	; (22af4 <buttonCheck+0x61c>)
   22874:	9601      	str	r6, [sp, #4]
   22876:	fb04 3401 	mla	r4, r4, r1, r3
   2287a:	4b9f      	ldr	r3, [pc, #636]	; (22af8 <buttonCheck+0x620>)
   2287c:	f8df 82a8 	ldr.w	r8, [pc, #680]	; 22b28 <buttonCheck+0x650>
   22880:	9303      	str	r3, [sp, #12]
   22882:	4626      	mov	r6, r4
   22884:	4b9d      	ldr	r3, [pc, #628]	; (22afc <buttonCheck+0x624>)
   22886:	9404      	str	r4, [sp, #16]
   22888:	9302      	str	r3, [sp, #8]
                knobPage = (knobPage + 1) % numPages[currentPreset];
   2288a:	fb92 f3f0 	sdiv	r3, r2, r0
   2288e:	fb00 2313 	mls	r3, r0, r3, r2
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   22892:	eb03 0983 	add.w	r9, r3, r3, lsl #2
                knobPage = (knobPage + 1) % numPages[currentPreset];
   22896:	b2db      	uxtb	r3, r3
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   22898:	ea4f 0989 	mov.w	r9, r9, lsl #2
                knobPage = (knobPage + 1) % numPages[currentPreset];
   2289c:	703b      	strb	r3, [r7, #0]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   2289e:	f109 0214 	add.w	r2, r9, #20
   228a2:	18a2      	adds	r2, r4, r2
   228a4:	9205      	str	r2, [sp, #20]
   228a6:	ea4f 048a 	mov.w	r4, sl, lsl #2
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   228aa:	2205      	movs	r2, #5
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   228ac:	4888      	ldr	r0, [pc, #544]	; (22ad0 <buttonCheck+0x5f8>)
                    floatADCUI[knob] = -1.0f;
   228ae:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   228b2:	eb09 0b04 	add.w	fp, r9, r4
                    knobActive[knob] = 0;
   228b6:	f04f 0e00 	mov.w	lr, #0
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   228ba:	fb12 a203 	smlabb	r2, r2, r3, sl
                    floatADCUI[knob] = -1.0f;
   228be:	eb08 0c04 	add.w	ip, r8, r4
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   228c2:	44b3      	add	fp, r6
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   228c4:	9e01      	ldr	r6, [sp, #4]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   228c6:	4420      	add	r0, r4
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   228c8:	5671      	ldrsb	r1, [r6, r1]
   228ca:	428a      	cmp	r2, r1
   228cc:	f000 812e 	beq.w	22b2c <buttonCheck+0x654>
                    knobActive[knob] = 0;
   228d0:	9b03      	ldr	r3, [sp, #12]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   228d2:	ed9b 0a00 	vldr	s0, [fp]
                    knobActive[knob] = 0;
   228d6:	f803 e00a 	strb.w	lr, [r3, sl]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   228da:	f10a 0a01 	add.w	sl, sl, #1
                    floatADCUI[knob] = -1.0f;
   228de:	edcc 7a00 	vstr	s15, [ip]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   228e2:	f005 fa91 	bl	27e08 <tExpSmooth_setValAndDest>
                    smoothedADC[knob] = values[knob];
   228e6:	9b02      	ldr	r3, [sp, #8]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   228e8:	f1ba 0f05 	cmp.w	sl, #5
                    smoothedADC[knob] = values[knob];
   228ec:	441c      	add	r4, r3
   228ee:	f8db 3000 	ldr.w	r3, [fp]
   228f2:	6023      	str	r3, [r4, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   228f4:	f000 812f 	beq.w	22b56 <buttonCheck+0x67e>
   228f8:	783b      	ldrb	r3, [r7, #0]
   228fa:	7829      	ldrb	r1, [r5, #0]
   228fc:	9e04      	ldr	r6, [sp, #16]
   228fe:	e7d2      	b.n	228a6 <buttonCheck+0x3ce>
                        previousPreset = currentPreset;
   22900:	4d79      	ldr	r5, [pc, #484]	; (22ae8 <buttonCheck+0x610>)
   22902:	4a7f      	ldr	r2, [pc, #508]	; (22b00 <buttonCheck+0x628>)
   22904:	782b      	ldrb	r3, [r5, #0]
   22906:	7013      	strb	r3, [r2, #0]
                        if (currentPreset <= 0) currentPreset = (VocodecPresetType)((int)PresetNil - 1);
   22908:	2b00      	cmp	r3, #0
   2290a:	f000 813a 	beq.w	22b82 <buttonCheck+0x6aa>
                        else currentPreset = (VocodecPresetType)((int)currentPreset - 1);
   2290e:	3b01      	subs	r3, #1
   22910:	b2db      	uxtb	r3, r3
                        loadingPreset = 1;
   22912:	2101      	movs	r1, #1
   22914:	4a7b      	ldr	r2, [pc, #492]	; (22b04 <buttonCheck+0x62c>)
   22916:	702b      	strb	r3, [r5, #0]
   22918:	7011      	strb	r1, [r2, #0]
                        OLED_writePreset();
   2291a:	f7f6 fe1d 	bl	19558 <OLED_writePreset>
                if((EE_WriteVariable(VirtAddVarTab[0],  currentPreset)) != HAL_OK)
   2291e:	4b7a      	ldr	r3, [pc, #488]	; (22b08 <buttonCheck+0x630>)
   22920:	7829      	ldrb	r1, [r5, #0]
   22922:	8818      	ldrh	r0, [r3, #0]
   22924:	f7f5 f8a4 	bl	17a70 <EE_WriteVariable>
   22928:	b108      	cbz	r0, 2292e <buttonCheck+0x456>
                    Error_Handler();
   2292a:	f7f6 fd71 	bl	19410 <Error_Handler>
                        buttonActionsUI[b][a] = 0;
   2292e:	2300      	movs	r3, #0
                        buttonActionsSFX[b][a] = 0;
   22930:	4a76      	ldr	r2, [pc, #472]	; (22b0c <buttonCheck+0x634>)
                        buttonActionsUI[b][a] = 0;
   22932:	486b      	ldr	r0, [pc, #428]	; (22ae0 <buttonCheck+0x608>)
   22934:	21ff      	movs	r1, #255	; 0xff
                        buttonActionsSFX[b][a] = 0;
   22936:	6013      	str	r3, [r2, #0]
                        buttonActionsUI[b][a] = 0;
   22938:	6083      	str	r3, [r0, #8]
   2293a:	60c3      	str	r3, [r0, #12]
   2293c:	6103      	str	r3, [r0, #16]
   2293e:	6143      	str	r3, [r0, #20]
   22940:	6183      	str	r3, [r0, #24]
   22942:	61c3      	str	r3, [r0, #28]
   22944:	6203      	str	r3, [r0, #32]
   22946:	6243      	str	r3, [r0, #36]	; 0x24
   22948:	6283      	str	r3, [r0, #40]	; 0x28
   2294a:	6003      	str	r3, [r0, #0]
   2294c:	6043      	str	r3, [r0, #4]
                        buttonActionsSFX[b][a] = 0;
   2294e:	6053      	str	r3, [r2, #4]
   22950:	6093      	str	r3, [r2, #8]
   22952:	60d3      	str	r3, [r2, #12]
   22954:	6113      	str	r3, [r2, #16]
   22956:	6153      	str	r3, [r2, #20]
   22958:	6193      	str	r3, [r2, #24]
   2295a:	61d3      	str	r3, [r2, #28]
   2295c:	6213      	str	r3, [r2, #32]
   2295e:	6253      	str	r3, [r2, #36]	; 0x24
   22960:	6293      	str	r3, [r2, #40]	; 0x28
   22962:	4b6b      	ldr	r3, [pc, #428]	; (22b10 <buttonCheck+0x638>)
   22964:	7019      	strb	r1, [r3, #0]
   22966:	4b6b      	ldr	r3, [pc, #428]	; (22b14 <buttonCheck+0x63c>)
   22968:	7019      	strb	r1, [r3, #0]
                    if (buttonActionsUI[ButtonRight][ActionPress] == 1)
   2296a:	4b5d      	ldr	r3, [pc, #372]	; (22ae0 <buttonCheck+0x608>)
   2296c:	7a1b      	ldrb	r3, [r3, #8]
   2296e:	2b01      	cmp	r3, #1
   22970:	f47f ae6f 	bne.w	22652 <buttonCheck+0x17a>
                        previousPreset = currentPreset;
   22974:	4d5c      	ldr	r5, [pc, #368]	; (22ae8 <buttonCheck+0x610>)
   22976:	4a62      	ldr	r2, [pc, #392]	; (22b00 <buttonCheck+0x628>)
   22978:	782b      	ldrb	r3, [r5, #0]
                        if (currentPreset >= PresetNil - 1) currentPreset = (VocodecPresetType)0;
   2297a:	2b10      	cmp	r3, #16
                        previousPreset = currentPreset;
   2297c:	7013      	strb	r3, [r2, #0]
                        if (currentPreset >= PresetNil - 1) currentPreset = (VocodecPresetType)0;
   2297e:	f200 80fe 	bhi.w	22b7e <buttonCheck+0x6a6>
                        else currentPreset = (VocodecPresetType)((int)currentPreset + 1);
   22982:	3301      	adds	r3, #1
   22984:	b2db      	uxtb	r3, r3
                        loadingPreset = 1;
   22986:	2101      	movs	r1, #1
   22988:	4a5e      	ldr	r2, [pc, #376]	; (22b04 <buttonCheck+0x62c>)
   2298a:	702b      	strb	r3, [r5, #0]
   2298c:	7011      	strb	r1, [r2, #0]
                        OLED_writePreset();
   2298e:	f7f6 fde3 	bl	19558 <OLED_writePreset>
                if((EE_WriteVariable(VirtAddVarTab[0],  currentPreset)) != HAL_OK)
   22992:	4b5d      	ldr	r3, [pc, #372]	; (22b08 <buttonCheck+0x630>)
   22994:	7829      	ldrb	r1, [r5, #0]
   22996:	8818      	ldrh	r0, [r3, #0]
   22998:	f7f5 f86a 	bl	17a70 <EE_WriteVariable>
   2299c:	b108      	cbz	r0, 229a2 <buttonCheck+0x4ca>
                    Error_Handler();
   2299e:	f7f6 fd37 	bl	19410 <Error_Handler>
                        buttonActionsUI[b][a] = 0;
   229a2:	2300      	movs	r3, #0
                        buttonActionsSFX[b][a] = 0;
   229a4:	4a59      	ldr	r2, [pc, #356]	; (22b0c <buttonCheck+0x634>)
                        buttonActionsUI[b][a] = 0;
   229a6:	484e      	ldr	r0, [pc, #312]	; (22ae0 <buttonCheck+0x608>)
   229a8:	21ff      	movs	r1, #255	; 0xff
                        buttonActionsSFX[b][a] = 0;
   229aa:	6013      	str	r3, [r2, #0]
                        buttonActionsUI[b][a] = 0;
   229ac:	6203      	str	r3, [r0, #32]
   229ae:	6243      	str	r3, [r0, #36]	; 0x24
   229b0:	6283      	str	r3, [r0, #40]	; 0x28
   229b2:	6003      	str	r3, [r0, #0]
   229b4:	6043      	str	r3, [r0, #4]
   229b6:	6083      	str	r3, [r0, #8]
   229b8:	60c3      	str	r3, [r0, #12]
   229ba:	6103      	str	r3, [r0, #16]
   229bc:	6143      	str	r3, [r0, #20]
   229be:	6183      	str	r3, [r0, #24]
   229c0:	61c3      	str	r3, [r0, #28]
                        buttonActionsSFX[b][a] = 0;
   229c2:	6053      	str	r3, [r2, #4]
   229c4:	6093      	str	r3, [r2, #8]
   229c6:	60d3      	str	r3, [r2, #12]
   229c8:	6113      	str	r3, [r2, #16]
   229ca:	6153      	str	r3, [r2, #20]
   229cc:	6193      	str	r3, [r2, #24]
   229ce:	61d3      	str	r3, [r2, #28]
   229d0:	6213      	str	r3, [r2, #32]
   229d2:	6253      	str	r3, [r2, #36]	; 0x24
   229d4:	6293      	str	r3, [r2, #40]	; 0x28
   229d6:	4b4e      	ldr	r3, [pc, #312]	; (22b10 <buttonCheck+0x638>)
   229d8:	7019      	strb	r1, [r3, #0]
   229da:	4b4e      	ldr	r3, [pc, #312]	; (22b14 <buttonCheck+0x63c>)
   229dc:	7019      	strb	r1, [r3, #0]
                    if (buttonActionsUI[ButtonD][ActionPress] == 1)
   229de:	4b40      	ldr	r3, [pc, #256]	; (22ae0 <buttonCheck+0x608>)
   229e0:	f893 3020 	ldrb.w	r3, [r3, #32]
   229e4:	2b01      	cmp	r3, #1
   229e6:	f47f ae3a 	bne.w	2265e <buttonCheck+0x186>
                        if (currentTuning == 0)
   229ea:	4a4b      	ldr	r2, [pc, #300]	; (22b18 <buttonCheck+0x640>)
   229ec:	6813      	ldr	r3, [r2, #0]
   229ee:	2b00      	cmp	r3, #0
   229f0:	f040 80c3 	bne.w	22b7a <buttonCheck+0x6a2>
                            currentTuning = NUM_TUNINGS - 1;
   229f4:	233e      	movs	r3, #62	; 0x3e
                    centsDeviation[i] = tuningPresets[currentTuning][i];
   229f6:	eb03 0143 	add.w	r1, r3, r3, lsl #1
   229fa:	4c48      	ldr	r4, [pc, #288]	; (22b1c <buttonCheck+0x644>)
   229fc:	4f48      	ldr	r7, [pc, #288]	; (22b20 <buttonCheck+0x648>)
   229fe:	eb04 1401 	add.w	r4, r4, r1, lsl #4
   22a02:	6013      	str	r3, [r2, #0]
   22a04:	f104 0c30 	add.w	ip, r4, #48	; 0x30
   22a08:	6820      	ldr	r0, [r4, #0]
   22a0a:	3410      	adds	r4, #16
   22a0c:	f854 1c0c 	ldr.w	r1, [r4, #-12]
   22a10:	463d      	mov	r5, r7
   22a12:	f854 2c08 	ldr.w	r2, [r4, #-8]
   22a16:	3710      	adds	r7, #16
   22a18:	f854 3c04 	ldr.w	r3, [r4, #-4]
   22a1c:	4564      	cmp	r4, ip
   22a1e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   22a20:	d1f2      	bne.n	22a08 <buttonCheck+0x530>
                if (currentPreset == AutotuneMono)
   22a22:	4b31      	ldr	r3, [pc, #196]	; (22ae8 <buttonCheck+0x610>)
   22a24:	781b      	ldrb	r3, [r3, #0]
   22a26:	2b03      	cmp	r3, #3
   22a28:	f000 80b2 	beq.w	22b90 <buttonCheck+0x6b8>
                        OLED_writeTuning();
   22a2c:	f7f6 fedc 	bl	197e8 <OLED_writeTuning>
                        buttonActionsUI[ButtonD][ActionPress] = 0;
   22a30:	2300      	movs	r3, #0
   22a32:	4a2b      	ldr	r2, [pc, #172]	; (22ae0 <buttonCheck+0x608>)
   22a34:	f882 3020 	strb.w	r3, [r2, #32]
                    if (buttonActionsUI[ButtonE][ActionPress] == 1)
   22a38:	4b29      	ldr	r3, [pc, #164]	; (22ae0 <buttonCheck+0x608>)
   22a3a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   22a3e:	2b01      	cmp	r3, #1
   22a40:	f47f ae13 	bne.w	2266a <buttonCheck+0x192>
   22a44:	e00e      	b.n	22a64 <buttonCheck+0x58c>
                        OLED_writeEditScreen();
   22a46:	f7f6 fe83 	bl	19750 <OLED_writeEditScreen>
                        setLED_Edit(1);
   22a4a:	2001      	movs	r0, #1
   22a4c:	f7f6 fce4 	bl	19418 <setLED_Edit>
                        buttonActionsUI[ButtonEdit][ActionPress] = 0;
   22a50:	2300      	movs	r3, #0
   22a52:	4a23      	ldr	r2, [pc, #140]	; (22ae0 <buttonCheck+0x608>)
   22a54:	7013      	strb	r3, [r2, #0]
                    if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
   22a56:	4b22      	ldr	r3, [pc, #136]	; (22ae0 <buttonCheck+0x608>)
   22a58:	78db      	ldrb	r3, [r3, #3]
   22a5a:	2b01      	cmp	r3, #1
                        if (buttonActionsUI[ButtonC][ActionPress] == 1)
   22a5c:	4b20      	ldr	r3, [pc, #128]	; (22ae0 <buttonCheck+0x608>)
                    if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
   22a5e:	f47f ae0e 	bne.w	2267e <buttonCheck+0x1a6>
   22a62:	e633      	b.n	226cc <buttonCheck+0x1f4>
                        currentTuning = (currentTuning + 1) % NUM_TUNINGS;
   22a64:	492c      	ldr	r1, [pc, #176]	; (22b18 <buttonCheck+0x640>)
   22a66:	4b2f      	ldr	r3, [pc, #188]	; (22b24 <buttonCheck+0x64c>)
   22a68:	680a      	ldr	r2, [r1, #0]
                    centsDeviation[i] = tuningPresets[currentTuning][i];
   22a6a:	4c2c      	ldr	r4, [pc, #176]	; (22b1c <buttonCheck+0x644>)
                        currentTuning = (currentTuning + 1) % NUM_TUNINGS;
   22a6c:	3201      	adds	r2, #1
   22a6e:	4f2c      	ldr	r7, [pc, #176]	; (22b20 <buttonCheck+0x648>)
   22a70:	fba3 0302 	umull	r0, r3, r3, r2
   22a74:	1ad0      	subs	r0, r2, r3
   22a76:	eb03 0350 	add.w	r3, r3, r0, lsr #1
   22a7a:	095b      	lsrs	r3, r3, #5
   22a7c:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
   22a80:	1ad3      	subs	r3, r2, r3
                    centsDeviation[i] = tuningPresets[currentTuning][i];
   22a82:	eb03 0243 	add.w	r2, r3, r3, lsl #1
                        currentTuning = (currentTuning + 1) % NUM_TUNINGS;
   22a86:	600b      	str	r3, [r1, #0]
                    centsDeviation[i] = tuningPresets[currentTuning][i];
   22a88:	eb04 1402 	add.w	r4, r4, r2, lsl #4
   22a8c:	f104 0c30 	add.w	ip, r4, #48	; 0x30
   22a90:	6820      	ldr	r0, [r4, #0]
   22a92:	3410      	adds	r4, #16
   22a94:	f854 1c0c 	ldr.w	r1, [r4, #-12]
   22a98:	463d      	mov	r5, r7
   22a9a:	f854 2c08 	ldr.w	r2, [r4, #-8]
   22a9e:	3710      	adds	r7, #16
   22aa0:	f854 3c04 	ldr.w	r3, [r4, #-4]
   22aa4:	4564      	cmp	r4, ip
   22aa6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   22aa8:	d1f2      	bne.n	22a90 <buttonCheck+0x5b8>
                if (currentPreset == AutotuneMono)
   22aaa:	4b0f      	ldr	r3, [pc, #60]	; (22ae8 <buttonCheck+0x610>)
   22aac:	781b      	ldrb	r3, [r3, #0]
   22aae:	2b03      	cmp	r3, #3
   22ab0:	d101      	bne.n	22ab6 <buttonCheck+0x5de>
                    calculateNoteArray();
   22ab2:	f7fe f97f 	bl	20db4 <calculateNoteArray>
                        OLED_writeTuning();
   22ab6:	f7f6 fe97 	bl	197e8 <OLED_writeTuning>
                        buttonActionsUI[ButtonE][ActionPress] = 0;
   22aba:	2300      	movs	r3, #0
   22abc:	4a08      	ldr	r2, [pc, #32]	; (22ae0 <buttonCheck+0x608>)
   22abe:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                    if (buttonActionsUI[ButtonEdit][ActionPress])
   22ac2:	4b07      	ldr	r3, [pc, #28]	; (22ae0 <buttonCheck+0x608>)
   22ac4:	781b      	ldrb	r3, [r3, #0]
   22ac6:	2b00      	cmp	r3, #0
   22ac8:	f43f add4 	beq.w	22674 <buttonCheck+0x19c>
   22acc:	e7bb      	b.n	22a46 <buttonCheck+0x56e>
   22ace:	bf00      	nop
   22ad0:	020fb0c0 	.word	0x020fb0c0
   22ad4:	bf800000 	.word	0xbf800000
   22ad8:	020fb0d4 	.word	0x020fb0d4
   22adc:	0003237c 	.word	0x0003237c
   22ae0:	020fb11c 	.word	0x020fb11c
   22ae4:	020e2f1a 	.word	0x020e2f1a
   22ae8:	020e2f19 	.word	0x020e2f19
   22aec:	020fb0d8 	.word	0x020fb0d8
   22af0:	020fb200 	.word	0x020fb200
   22af4:	020e55d8 	.word	0x020e55d8
   22af8:	020fa1dc 	.word	0x020fa1dc
   22afc:	020fb0ec 	.word	0x020fb0ec
   22b00:	00062828 	.word	0x00062828
   22b04:	020e2f1b 	.word	0x020e2f1b
   22b08:	00062574 	.word	0x00062574
   22b0c:	020fafac 	.word	0x020fafac
   22b10:	0006282a 	.word	0x0006282a
   22b14:	00062829 	.word	0x00062829
   22b18:	020e2f14 	.word	0x020e2f14
   22b1c:	00031020 	.word	0x00031020
   22b20:	020e2ee4 	.word	0x020e2ee4
   22b24:	04104105 	.word	0x04104105
   22b28:	020fb104 	.word	0x020fb104
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22b2c:	9c05      	ldr	r4, [sp, #20]
                    knobActive[knob] = 0;
   22b2e:	2200      	movs	r2, #0
                    floatADCUI[knob] = -1.0f;
   22b30:	4b2c      	ldr	r3, [pc, #176]	; (22be4 <buttonCheck+0x70c>)
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22b32:	f10a 0a01 	add.w	sl, sl, #1
                    knobActive[knob] = 0;
   22b36:	9903      	ldr	r1, [sp, #12]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22b38:	ed94 0a00 	vldr	s0, [r4]
   22b3c:	482a      	ldr	r0, [pc, #168]	; (22be8 <buttonCheck+0x710>)
                    knobActive[knob] = 0;
   22b3e:	714a      	strb	r2, [r1, #5]
                    floatADCUI[knob] = -1.0f;
   22b40:	f8c8 3014 	str.w	r3, [r8, #20]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22b44:	f005 f960 	bl	27e08 <tExpSmooth_setValAndDest>
                    smoothedADC[knob] = values[knob];
   22b48:	6823      	ldr	r3, [r4, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22b4a:	f1ba 0f05 	cmp.w	sl, #5
                    smoothedADC[knob] = values[knob];
   22b4e:	9a02      	ldr	r2, [sp, #8]
   22b50:	6153      	str	r3, [r2, #20]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22b52:	f47f aed1 	bne.w	228f8 <buttonCheck+0x420>
                        OLEDwriteString("P", 1, 110, FirstLine);
   22b56:	2300      	movs	r3, #0
   22b58:	226e      	movs	r2, #110	; 0x6e
   22b5a:	2101      	movs	r1, #1
   22b5c:	4823      	ldr	r0, [pc, #140]	; (22bec <buttonCheck+0x714>)
   22b5e:	f7f6 fed5 	bl	1990c <OLEDwriteString>
                        OLEDwriteInt(knobPage, 1, 120, FirstLine);
   22b62:	7838      	ldrb	r0, [r7, #0]
   22b64:	2300      	movs	r3, #0
   22b66:	2278      	movs	r2, #120	; 0x78
   22b68:	2101      	movs	r1, #1
   22b6a:	f7f6 fef9 	bl	19960 <OLEDwriteInt>
                        buttonActionsUI[ButtonUp][ActionPress] = 0;
   22b6e:	2300      	movs	r3, #0
   22b70:	4a1f      	ldr	r2, [pc, #124]	; (22bf0 <buttonCheck+0x718>)
   22b72:	7413      	strb	r3, [r2, #16]
            }
   22b74:	b007      	add	sp, #28
   22b76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                            currentTuning = (currentTuning - 1);
   22b7a:	3b01      	subs	r3, #1
   22b7c:	e73b      	b.n	229f6 <buttonCheck+0x51e>
                        if (currentPreset >= PresetNil - 1) currentPreset = (VocodecPresetType)0;
   22b7e:	2300      	movs	r3, #0
   22b80:	e701      	b.n	22986 <buttonCheck+0x4ae>
                        if (currentPreset <= 0) currentPreset = (VocodecPresetType)((int)PresetNil - 1);
   22b82:	2311      	movs	r3, #17
   22b84:	e6c5      	b.n	22912 <buttonCheck+0x43a>
                if (knobPage == 0) knobPage = numPages[currentPreset] - 1;
   22b86:	4b1b      	ldr	r3, [pc, #108]	; (22bf4 <buttonCheck+0x71c>)
   22b88:	5c5b      	ldrb	r3, [r3, r1]
   22b8a:	3b01      	subs	r3, #1
   22b8c:	b2db      	uxtb	r3, r3
   22b8e:	e5cb      	b.n	22728 <buttonCheck+0x250>
                    calculateNoteArray();
   22b90:	f7fe f910 	bl	20db4 <calculateNoteArray>
   22b94:	e74a      	b.n	22a2c <buttonCheck+0x554>
                            keyCenter = (keyCenter + 1) % 12;
   22b96:	4d18      	ldr	r5, [pc, #96]	; (22bf8 <buttonCheck+0x720>)
                            OLEDclearLine(SecondLine);
   22b98:	4620      	mov	r0, r4
                            keyCenter = (keyCenter + 1) % 12;
   22b9a:	4b18      	ldr	r3, [pc, #96]	; (22bfc <buttonCheck+0x724>)
   22b9c:	782a      	ldrb	r2, [r5, #0]
   22b9e:	3201      	adds	r2, #1
   22ba0:	fba3 1302 	umull	r1, r3, r3, r2
   22ba4:	08db      	lsrs	r3, r3, #3
   22ba6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   22baa:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
   22bae:	702b      	strb	r3, [r5, #0]
                            OLEDclearLine(SecondLine);
   22bb0:	f7f6 fe98 	bl	198e4 <OLEDclearLine>
                            OLEDwriteString("KEY: ", 5, 0, SecondLine);
   22bb4:	2200      	movs	r2, #0
   22bb6:	4623      	mov	r3, r4
   22bb8:	2105      	movs	r1, #5
   22bba:	4811      	ldr	r0, [pc, #68]	; (22c00 <buttonCheck+0x728>)
   22bbc:	f7f6 fea6 	bl	1990c <OLEDwriteString>
                            OLEDwritePitchClass(keyCenter+60, 64, SecondLine);
   22bc0:	782b      	ldrb	r3, [r5, #0]
   22bc2:	4621      	mov	r1, r4
   22bc4:	2040      	movs	r0, #64	; 0x40
   22bc6:	333c      	adds	r3, #60	; 0x3c
   22bc8:	ee00 3a10 	vmov	s0, r3
   22bcc:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   22bd0:	f7f6 ff2a 	bl	19a28 <OLEDwritePitchClass>
                            buttonActionsUI[ButtonC][ActionPress] = 0;
   22bd4:	2300      	movs	r3, #0
   22bd6:	4906      	ldr	r1, [pc, #24]	; (22bf0 <buttonCheck+0x718>)
                            buttonActionsSFX[ButtonC][ActionPress] = 0;
   22bd8:	4a0a      	ldr	r2, [pc, #40]	; (22c04 <buttonCheck+0x72c>)
                            buttonActionsUI[ButtonC][ActionPress] = 0;
   22bda:	770b      	strb	r3, [r1, #28]
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   22bdc:	70cb      	strb	r3, [r1, #3]
                            buttonActionsSFX[ButtonC][ActionPress] = 0;
   22bde:	7713      	strb	r3, [r2, #28]
   22be0:	e578      	b.n	226d4 <buttonCheck+0x1fc>
   22be2:	bf00      	nop
   22be4:	bf800000 	.word	0xbf800000
   22be8:	020fb0d4 	.word	0x020fb0d4
   22bec:	0003237c 	.word	0x0003237c
   22bf0:	020fb11c 	.word	0x020fb11c
   22bf4:	020fb0d8 	.word	0x020fb0d8
   22bf8:	020e2f18 	.word	0x020e2f18
   22bfc:	aaaaaaab 	.word	0xaaaaaaab
   22c00:	00031de0 	.word	0x00031de0
   22c04:	020fafac 	.word	0x020fafac

00022c08 <adcCheck>:
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   22c08:	486f      	ldr	r0, [pc, #444]	; (22dc8 <adcCheck+0x1c0>)
   22c0a:	eddf 4a70 	vldr	s9, [pc, #448]	; 22dcc <adcCheck+0x1c4>
            {
   22c0e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   22c12:	8801      	ldrh	r1, [r0, #0]
   22c14:	8842      	ldrh	r2, [r0, #2]
   22c16:	8883      	ldrh	r3, [r0, #4]
   22c18:	0989      	lsrs	r1, r1, #6
   22c1a:	0992      	lsrs	r2, r2, #6
                if (firstADCPass)
   22c1c:	4e6c      	ldr	r6, [pc, #432]	; (22dd0 <adcCheck+0x1c8>)
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   22c1e:	099b      	lsrs	r3, r3, #6
   22c20:	ee05 1a10 	vmov	s10, r1
   22c24:	ee05 2a90 	vmov	s11, r2
   22c28:	88c1      	ldrh	r1, [r0, #6]
   22c2a:	ee06 3a10 	vmov	s12, r3
   22c2e:	8902      	ldrh	r2, [r0, #8]
   22c30:	8943      	ldrh	r3, [r0, #10]
   22c32:	0989      	lsrs	r1, r1, #6
   22c34:	0992      	lsrs	r2, r2, #6
   22c36:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
   22c3a:	099b      	lsrs	r3, r3, #6
   22c3c:	ee06 1a90 	vmov	s13, r1
   22c40:	ee07 2a10 	vmov	s14, r2
   22c44:	eef8 5ae5 	vcvt.f32.s32	s11, s11
   22c48:	ee07 3a90 	vmov	s15, r3
   22c4c:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
   22c50:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   22c54:	4c5f      	ldr	r4, [pc, #380]	; (22dd4 <adcCheck+0x1cc>)
   22c56:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
                if (firstADCPass)
   22c5a:	6832      	ldr	r2, [r6, #0]
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   22c5c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   22c60:	ee25 5a24 	vmul.f32	s10, s10, s9
   22c64:	ee65 5aa4 	vmul.f32	s11, s11, s9
   22c68:	ee26 6a24 	vmul.f32	s12, s12, s9
   22c6c:	ee66 6aa4 	vmul.f32	s13, s13, s9
   22c70:	ed84 5a00 	vstr	s10, [r4]
   22c74:	ee27 7a24 	vmul.f32	s14, s14, s9
   22c78:	edc4 5a01 	vstr	s11, [r4, #4]
   22c7c:	ee67 7aa4 	vmul.f32	s15, s15, s9
   22c80:	ed84 6a02 	vstr	s12, [r4, #8]
   22c84:	edc4 6a03 	vstr	s13, [r4, #12]
   22c88:	ed84 7a04 	vstr	s14, [r4, #16]
   22c8c:	edc4 7a05 	vstr	s15, [r4, #20]
                if (firstADCPass)
   22c90:	b142      	cbz	r2, 22ca4 <adcCheck+0x9c>
   22c92:	4d51      	ldr	r5, [pc, #324]	; (22dd8 <adcCheck+0x1d0>)
                    firstADCPass = 0;
   22c94:	2700      	movs	r7, #0
   22c96:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   22c98:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   22c9a:	e894 0003 	ldmia.w	r4, {r0, r1}
   22c9e:	6037      	str	r7, [r6, #0]
   22ca0:	e885 0003 	stmia.w	r5, {r0, r1}
   22ca4:	4d4b      	ldr	r5, [pc, #300]	; (22dd4 <adcCheck+0x1cc>)
            {
   22ca6:	f04f 0b00 	mov.w	fp, #0
   22caa:	4e4b      	ldr	r6, [pc, #300]	; (22dd8 <adcCheck+0x1d0>)
   22cac:	4c4b      	ldr	r4, [pc, #300]	; (22ddc <adcCheck+0x1d4>)
   22cae:	4f4c      	ldr	r7, [pc, #304]	; (22de0 <adcCheck+0x1d8>)
   22cb0:	f8df 8144 	ldr.w	r8, [pc, #324]	; 22df8 <adcCheck+0x1f0>
   22cb4:	f8df 9144 	ldr.w	r9, [pc, #324]	; 22dfc <adcCheck+0x1f4>
                            else writeKnobFlag = i;
   22cb8:	f8df a144 	ldr.w	sl, [pc, #324]	; 22e00 <adcCheck+0x1f8>
   22cbc:	e031      	b.n	22d22 <adcCheck+0x11a>
                        if (buttonActionsUI[ButtonEdit][ActionHoldContinuous])
   22cbe:	4949      	ldr	r1, [pc, #292]	; (22de4 <adcCheck+0x1dc>)
   22cc0:	78ca      	ldrb	r2, [r1, #3]
   22cc2:	b16a      	cbz	r2, 22ce0 <adcCheck+0xd8>
                            if (i != 5) cvAddParam[currentPreset] = i + (knobPage * KNOB_PAGE_SIZE);;
   22cc4:	f1bb 0f05 	cmp.w	fp, #5
   22cc8:	d008      	beq.n	22cdc <adcCheck+0xd4>
   22cca:	4a47      	ldr	r2, [pc, #284]	; (22de8 <adcCheck+0x1e0>)
   22ccc:	4847      	ldr	r0, [pc, #284]	; (22dec <adcCheck+0x1e4>)
   22cce:	7812      	ldrb	r2, [r2, #0]
   22cd0:	7800      	ldrb	r0, [r0, #0]
   22cd2:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   22cd6:	4b46      	ldr	r3, [pc, #280]	; (22df0 <adcCheck+0x1e8>)
   22cd8:	445a      	add	r2, fp
   22cda:	541a      	strb	r2, [r3, r0]
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   22cdc:	2200      	movs	r2, #0
   22cde:	70ca      	strb	r2, [r1, #3]
                        lastFloatADC[i] = floatADC[i];
   22ce0:	ed15 0a01 	vldr	s0, [r5, #-4]
                        if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   22ce4:	f1bb 0f05 	cmp.w	fp, #5
                        lastFloatADC[i] = floatADC[i];
   22ce8:	ed06 0a01 	vstr	s0, [r6, #-4]
                        if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   22cec:	d05e      	beq.n	22dac <adcCheck+0x1a4>
                        else writeKnobFlag = i;
   22cee:	fa4f f28b 	sxtb.w	r2, fp
                    if (floatADCUI[i] >= 0.0f)
   22cf2:	edd4 7a00 	vldr	s15, [r4]
                        knobActive[i] = 1;
   22cf6:	2101      	movs	r1, #1
   22cf8:	f88a 2000 	strb.w	r2, [sl]
                    if (floatADCUI[i] >= 0.0f)
   22cfc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
                        knobActive[i] = 1;
   22d00:	f809 100b 	strb.w	r1, [r9, fp]
                    if (floatADCUI[i] >= 0.0f)
   22d04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22d08:	da28      	bge.n	22d5c <adcCheck+0x154>
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   22d0a:	4b3a      	ldr	r3, [pc, #232]	; (22df4 <adcCheck+0x1ec>)
   22d0c:	eb03 008b 	add.w	r0, r3, fp, lsl #2
   22d10:	f005 f876 	bl	27e00 <tExpSmooth_setDest>
                for (int i = 0; i < 6; i++)
   22d14:	f10b 0b01 	add.w	fp, fp, #1
   22d18:	3404      	adds	r4, #4
   22d1a:	3704      	adds	r7, #4
   22d1c:	f1bb 0f06 	cmp.w	fp, #6
   22d20:	d042      	beq.n	22da8 <adcCheck+0x1a0>
                    if (fastabsf(floatADC[i] - lastFloatADC[i]) > adcHysteresisThreshold)
   22d22:	ecf6 7a01 	vldmia	r6!, {s15}
   22d26:	ecb5 0a01 	vldmia	r5!, {s0}
   22d2a:	ee30 0a67 	vsub.f32	s0, s0, s15
   22d2e:	f006 fc21 	bl	29574 <fastabsf>
   22d32:	edd8 7a00 	vldr	s15, [r8]
   22d36:	eeb4 0ae7 	vcmpe.f32	s0, s15
   22d3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22d3e:	dcbe      	bgt.n	22cbe <adcCheck+0xb6>
                    if (floatADCUI[i] >= 0.0f)
   22d40:	edd4 7a00 	vldr	s15, [r4]
   22d44:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   22d48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22d4c:	da06      	bge.n	22d5c <adcCheck+0x154>
   22d4e:	f819 200b 	ldrb.w	r2, [r9, fp]
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   22d52:	2a00      	cmp	r2, #0
   22d54:	d0de      	beq.n	22d14 <adcCheck+0x10c>
   22d56:	ed15 0a01 	vldr	s0, [r5, #-4]
   22d5a:	e7d6      	b.n	22d0a <adcCheck+0x102>
                        if (fastabsf(smoothedADC[i] - floatADCUI[i]) > adcHysteresisThreshold)
   22d5c:	ed97 0a00 	vldr	s0, [r7]
   22d60:	ee30 0a67 	vsub.f32	s0, s0, s15
   22d64:	f006 fc06 	bl	29574 <fastabsf>
   22d68:	edd8 7a00 	vldr	s15, [r8]
   22d6c:	f819 200b 	ldrb.w	r2, [r9, fp]
   22d70:	eeb4 0ae7 	vcmpe.f32	s0, s15
   22d74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22d78:	ddeb      	ble.n	22d52 <adcCheck+0x14a>
                            if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   22d7a:	f1bb 0f05 	cmp.w	fp, #5
   22d7e:	d004      	beq.n	22d8a <adcCheck+0x182>
                            else writeKnobFlag = i;
   22d80:	f88a b000 	strb.w	fp, [sl]
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   22d84:	2a00      	cmp	r2, #0
   22d86:	d0c5      	beq.n	22d14 <adcCheck+0x10c>
   22d88:	e7e5      	b.n	22d56 <adcCheck+0x14e>
                            if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   22d8a:	4917      	ldr	r1, [pc, #92]	; (22de8 <adcCheck+0x1e0>)
   22d8c:	4817      	ldr	r0, [pc, #92]	; (22dec <adcCheck+0x1e4>)
   22d8e:	7809      	ldrb	r1, [r1, #0]
   22d90:	7800      	ldrb	r0, [r0, #0]
   22d92:	ebc1 1c81 	rsb	ip, r1, r1, lsl #6
   22d96:	4b16      	ldr	r3, [pc, #88]	; (22df0 <adcCheck+0x1e8>)
   22d98:	ebc1 018c 	rsb	r1, r1, ip, lsl #2
   22d9c:	5c18      	ldrb	r0, [r3, r0]
   22d9e:	4401      	add	r1, r0
   22da0:	f88a 1000 	strb.w	r1, [sl]
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   22da4:	2a00      	cmp	r2, #0
   22da6:	d1d6      	bne.n	22d56 <adcCheck+0x14e>
            }
   22da8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   22dac:	490e      	ldr	r1, [pc, #56]	; (22de8 <adcCheck+0x1e0>)
   22dae:	4a0f      	ldr	r2, [pc, #60]	; (22dec <adcCheck+0x1e4>)
   22db0:	7809      	ldrb	r1, [r1, #0]
   22db2:	7812      	ldrb	r2, [r2, #0]
   22db4:	ebc1 1081 	rsb	r0, r1, r1, lsl #6
   22db8:	4b0d      	ldr	r3, [pc, #52]	; (22df0 <adcCheck+0x1e8>)
   22dba:	ebc1 0180 	rsb	r1, r1, r0, lsl #2
   22dbe:	5c9a      	ldrb	r2, [r3, r2]
   22dc0:	440a      	add	r2, r1
   22dc2:	b252      	sxtb	r2, r2
   22dc4:	e795      	b.n	22cf2 <adcCheck+0xea>
   22dc6:	bf00      	nop
   22dc8:	00063a80 	.word	0x00063a80
   22dcc:	3a800000 	.word	0x3a800000
   22dd0:	00062824 	.word	0x00062824
   22dd4:	020faf94 	.word	0x020faf94
   22dd8:	020fb214 	.word	0x020fb214
   22ddc:	020fb104 	.word	0x020fb104
   22de0:	020fb0ec 	.word	0x020fb0ec
   22de4:	020fb11c 	.word	0x020fb11c
   22de8:	020e2f1a 	.word	0x020e2f1a
   22dec:	020e2f19 	.word	0x020e2f19
   22df0:	020fb200 	.word	0x020fb200
   22df4:	020fb0c0 	.word	0x020fb0c0
   22df8:	00062814 	.word	0x00062814
   22dfc:	020fa1dc 	.word	0x020fa1dc
   22e00:	0006282b 	.word	0x0006282b

00022e04 <resetKnobValues>:
            {
   22e04:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
                    floatADCUI[i] = -1.0f;
   22e08:	4820      	ldr	r0, [pc, #128]	; (22e8c <resetKnobValues+0x88>)
                    knobActive[i] = 0;
   22e0a:	2600      	movs	r6, #0
   22e0c:	4f20      	ldr	r7, [pc, #128]	; (22e90 <resetKnobValues+0x8c>)
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22e0e:	f04f 0a05 	mov.w	sl, #5
                for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   22e12:	4634      	mov	r4, r6
                    floatADCUI[i] = -1.0f;
   22e14:	f8df b098 	ldr.w	fp, [pc, #152]	; 22eb0 <resetKnobValues+0xac>
                    knobActive[i] = 0;
   22e18:	46b1      	mov	r9, r6
   22e1a:	f8df 8090 	ldr.w	r8, [pc, #144]	; 22eac <resetKnobValues+0xa8>
   22e1e:	4d1d      	ldr	r5, [pc, #116]	; (22e94 <resetKnobValues+0x90>)
                    floatADCUI[i] = -1.0f;
   22e20:	f84b 0b04 	str.w	r0, [fp], #4
            {
   22e24:	ed2d 8b02 	vpush	{d8}
                    knobActive[i] = 0;
   22e28:	f807 6b01 	strb.w	r6, [r7], #1
                    floatADCUI[i] = -1.0f;
   22e2c:	ee08 0a90 	vmov	s17, r0
   22e30:	4e19      	ldr	r6, [pc, #100]	; (22e98 <resetKnobValues+0x94>)
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22e32:	4b1a      	ldr	r3, [pc, #104]	; (22e9c <resetKnobValues+0x98>)
                    tExpSmooth_setValAndDest(&adc[i], value);
   22e34:	4628      	mov	r0, r5
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22e36:	7832      	ldrb	r2, [r6, #0]
   22e38:	3504      	adds	r5, #4
   22e3a:	781b      	ldrb	r3, [r3, #0]
   22e3c:	fb1a 4202 	smlabb	r2, sl, r2, r4
                for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   22e40:	3401      	adds	r4, #1
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22e42:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   22e46:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   22e4a:	4413      	add	r3, r2
   22e4c:	4a14      	ldr	r2, [pc, #80]	; (22ea0 <resetKnobValues+0x9c>)
   22e4e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   22e52:	ed93 8a00 	vldr	s16, [r3]
                    tExpSmooth_setValAndDest(&adc[i], value);
   22e56:	eeb0 0a48 	vmov.f32	s0, s16
   22e5a:	f004 ffd5 	bl	27e08 <tExpSmooth_setValAndDest>
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22e5e:	2c05      	cmp	r4, #5
                    smoothedADC[i] = value;
   22e60:	eca8 8a01 	vstmia	r8!, {s16}
                    knobActive[i] = 0;
   22e64:	f807 9b01 	strb.w	r9, [r7], #1
                    floatADCUI[i] = -1.0f;
   22e68:	eceb 8a01 	vstmia	fp!, {s17}
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22e6c:	d1e1      	bne.n	22e32 <resetKnobValues+0x2e>
                    tExpSmooth_setValAndDest(&adc[i], value);
   22e6e:	ed9f 8a0d 	vldr	s16, [pc, #52]	; 22ea4 <resetKnobValues+0xa0>
   22e72:	480d      	ldr	r0, [pc, #52]	; (22ea8 <resetKnobValues+0xa4>)
   22e74:	eeb0 0a48 	vmov.f32	s0, s16
   22e78:	f004 ffc6 	bl	27e08 <tExpSmooth_setValAndDest>
                    smoothedADC[i] = value;
   22e7c:	4b0b      	ldr	r3, [pc, #44]	; (22eac <resetKnobValues+0xa8>)
   22e7e:	ed83 8a05 	vstr	s16, [r3, #20]
            }
   22e82:	ecbd 8b02 	vpop	{d8}
   22e86:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22e8a:	bf00      	nop
   22e8c:	bf800000 	.word	0xbf800000
   22e90:	020fa1dc 	.word	0x020fa1dc
   22e94:	020fb0c0 	.word	0x020fb0c0
   22e98:	020e2f1a 	.word	0x020e2f1a
   22e9c:	020e2f19 	.word	0x020e2f19
   22ea0:	020e55d8 	.word	0x020e55d8
   22ea4:	00000000 	.word	0x00000000
   22ea8:	020fb0d4 	.word	0x020fb0d4
   22eac:	020fb0ec 	.word	0x020fb0ec
   22eb0:	020fb104 	.word	0x020fb104

00022eb4 <UIVocoderButtons>:
            }

            const char* UIVocoderButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
   22eb4:	4b15      	ldr	r3, [pc, #84]	; (22f0c <UIVocoderButtons+0x58>)
            {
   22eb6:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
   22eb8:	7d1a      	ldrb	r2, [r3, #20]
   22eba:	2a01      	cmp	r2, #1
   22ebc:	d01b      	beq.n	22ef6 <UIVocoderButtons+0x42>
                const char* writeString = "";
   22ebe:	4814      	ldr	r0, [pc, #80]	; (22f10 <UIVocoderButtons+0x5c>)
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
   22ec0:	7e1a      	ldrb	r2, [r3, #24]
   22ec2:	2a01      	cmp	r2, #1
   22ec4:	d108      	bne.n	22ed8 <UIVocoderButtons+0x24>
                {
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   22ec6:	4a13      	ldr	r2, [pc, #76]	; (22f14 <UIVocoderButtons+0x60>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   22ec8:	2400      	movs	r4, #0
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   22eca:	4813      	ldr	r0, [pc, #76]	; (22f18 <UIVocoderButtons+0x64>)
   22ecc:	7811      	ldrb	r1, [r2, #0]
   22ece:	4a13      	ldr	r2, [pc, #76]	; (22f1c <UIVocoderButtons+0x68>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   22ed0:	761c      	strb	r4, [r3, #24]
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   22ed2:	42a1      	cmp	r1, r4
   22ed4:	bf08      	it	eq
   22ed6:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
   22ed8:	7f1a      	ldrb	r2, [r3, #28]
   22eda:	2a01      	cmp	r2, #1
   22edc:	d108      	bne.n	22ef0 <UIVocoderButtons+0x3c>
                {
                    writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
   22ede:	4a10      	ldr	r2, [pc, #64]	; (22f20 <UIVocoderButtons+0x6c>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   22ee0:	2400      	movs	r4, #0
                    writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
   22ee2:	4810      	ldr	r0, [pc, #64]	; (22f24 <UIVocoderButtons+0x70>)
   22ee4:	6811      	ldr	r1, [r2, #0]
   22ee6:	4a10      	ldr	r2, [pc, #64]	; (22f28 <UIVocoderButtons+0x74>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   22ee8:	771c      	strb	r4, [r3, #28]
                    writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
   22eea:	42a1      	cmp	r1, r4
   22eec:	bf08      	it	eq
   22eee:	4610      	moveq	r0, r2
                }
                return writeString;
            }
   22ef0:	f85d 4b04 	ldr.w	r4, [sp], #4
   22ef4:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   22ef6:	4a0d      	ldr	r2, [pc, #52]	; (22f2c <UIVocoderButtons+0x78>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   22ef8:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   22efa:	480d      	ldr	r0, [pc, #52]	; (22f30 <UIVocoderButtons+0x7c>)
   22efc:	7811      	ldrb	r1, [r2, #0]
   22efe:	4a0d      	ldr	r2, [pc, #52]	; (22f34 <UIVocoderButtons+0x80>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   22f00:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   22f02:	2901      	cmp	r1, #1
   22f04:	bf98      	it	ls
   22f06:	4610      	movls	r0, r2
   22f08:	e7da      	b.n	22ec0 <UIVocoderButtons+0xc>
   22f0a:	bf00      	nop
   22f0c:	020fb11c 	.word	0x020fb11c
   22f10:	00031d64 	.word	0x00031d64
   22f14:	020e2e64 	.word	0x020e2e64
   22f18:	00031d98 	.word	0x00031d98
   22f1c:	00031da4 	.word	0x00031da4
   22f20:	020e2edc 	.word	0x020e2edc
   22f24:	00031db0 	.word	0x00031db0
   22f28:	00031db8 	.word	0x00031db8
   22f2c:	000627ac 	.word	0x000627ac
   22f30:	00031d88 	.word	0x00031d88
   22f34:	00031d90 	.word	0x00031d90

00022f38 <UIVocoderChButtons>:

            const char* UIVocoderChButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
   22f38:	4b15      	ldr	r3, [pc, #84]	; (22f90 <UIVocoderChButtons+0x58>)
            {
   22f3a:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
   22f3c:	7d1a      	ldrb	r2, [r3, #20]
   22f3e:	2a01      	cmp	r2, #1
   22f40:	d01b      	beq.n	22f7a <UIVocoderChButtons+0x42>
                const char* writeString = "";
   22f42:	4814      	ldr	r0, [pc, #80]	; (22f94 <UIVocoderChButtons+0x5c>)
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
   22f44:	7e1a      	ldrb	r2, [r3, #24]
   22f46:	2a01      	cmp	r2, #1
   22f48:	d108      	bne.n	22f5c <UIVocoderChButtons+0x24>
                {
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   22f4a:	4a13      	ldr	r2, [pc, #76]	; (22f98 <UIVocoderChButtons+0x60>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   22f4c:	2400      	movs	r4, #0
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   22f4e:	4813      	ldr	r0, [pc, #76]	; (22f9c <UIVocoderChButtons+0x64>)
   22f50:	7811      	ldrb	r1, [r2, #0]
   22f52:	4a13      	ldr	r2, [pc, #76]	; (22fa0 <UIVocoderChButtons+0x68>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   22f54:	761c      	strb	r4, [r3, #24]
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   22f56:	42a1      	cmp	r1, r4
   22f58:	bf08      	it	eq
   22f5a:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
   22f5c:	7f1a      	ldrb	r2, [r3, #28]
   22f5e:	2a01      	cmp	r2, #1
   22f60:	d108      	bne.n	22f74 <UIVocoderChButtons+0x3c>
                {
                    writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
   22f62:	4a10      	ldr	r2, [pc, #64]	; (22fa4 <UIVocoderChButtons+0x6c>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   22f64:	2400      	movs	r4, #0
                    writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
   22f66:	4810      	ldr	r0, [pc, #64]	; (22fa8 <UIVocoderChButtons+0x70>)
   22f68:	6811      	ldr	r1, [r2, #0]
   22f6a:	4a10      	ldr	r2, [pc, #64]	; (22fac <UIVocoderChButtons+0x74>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   22f6c:	771c      	strb	r4, [r3, #28]
                    writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
   22f6e:	42a1      	cmp	r1, r4
   22f70:	bf08      	it	eq
   22f72:	4610      	moveq	r0, r2
                }
                return writeString;
            }
   22f74:	f85d 4b04 	ldr.w	r4, [sp], #4
   22f78:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   22f7a:	4a0d      	ldr	r2, [pc, #52]	; (22fb0 <UIVocoderChButtons+0x78>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   22f7c:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   22f7e:	480d      	ldr	r0, [pc, #52]	; (22fb4 <UIVocoderChButtons+0x7c>)
   22f80:	7811      	ldrb	r1, [r2, #0]
   22f82:	4a0d      	ldr	r2, [pc, #52]	; (22fb8 <UIVocoderChButtons+0x80>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   22f84:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   22f86:	2901      	cmp	r1, #1
   22f88:	bf98      	it	ls
   22f8a:	4610      	movls	r0, r2
   22f8c:	e7da      	b.n	22f44 <UIVocoderChButtons+0xc>
   22f8e:	bf00      	nop
   22f90:	020fb11c 	.word	0x020fb11c
   22f94:	00031d64 	.word	0x00031d64
   22f98:	020e2e64 	.word	0x020e2e64
   22f9c:	00031d98 	.word	0x00031d98
   22fa0:	00031da4 	.word	0x00031da4
   22fa4:	020e2ed8 	.word	0x020e2ed8
   22fa8:	00031db0 	.word	0x00031db0
   22fac:	00031db8 	.word	0x00031db8
   22fb0:	000627ac 	.word	0x000627ac
   22fb4:	00031d88 	.word	0x00031d88
   22fb8:	00031d90 	.word	0x00031d90

00022fbc <UIPitchShiftButtons>:

            const char* UIPitchShiftButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                return writeString;
            }
   22fbc:	4800      	ldr	r0, [pc, #0]	; (22fc0 <UIPitchShiftButtons+0x4>)
   22fbe:	4770      	bx	lr
   22fc0:	00031d64 	.word	0x00031d64

00022fc4 <UINeartuneButtons>:

            const char* UINeartuneButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
   22fc4:	4b0e      	ldr	r3, [pc, #56]	; (23000 <UINeartuneButtons+0x3c>)
            {
   22fc6:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress])
   22fc8:	7d1a      	ldrb	r2, [r3, #20]
   22fca:	b1b2      	cbz	r2, 22ffa <UINeartuneButtons+0x36>
                {
                    writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
   22fcc:	4a0d      	ldr	r2, [pc, #52]	; (23004 <UINeartuneButtons+0x40>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   22fce:	2400      	movs	r4, #0
                    writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
   22fd0:	480d      	ldr	r0, [pc, #52]	; (23008 <UINeartuneButtons+0x44>)
   22fd2:	7811      	ldrb	r1, [r2, #0]
   22fd4:	4a0d      	ldr	r2, [pc, #52]	; (2300c <UINeartuneButtons+0x48>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   22fd6:	751c      	strb	r4, [r3, #20]
                    writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
   22fd8:	42a1      	cmp	r1, r4
   22fda:	bf08      	it	eq
   22fdc:	4610      	moveq	r0, r2
                }

                if (buttonActionsUI[ButtonC][ActionPress])
   22fde:	7f1a      	ldrb	r2, [r3, #28]
   22fe0:	b142      	cbz	r2, 22ff4 <UINeartuneButtons+0x30>
                {
                    writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
   22fe2:	4a0b      	ldr	r2, [pc, #44]	; (23010 <UINeartuneButtons+0x4c>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   22fe4:	2400      	movs	r4, #0
                    writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
   22fe6:	480b      	ldr	r0, [pc, #44]	; (23014 <UINeartuneButtons+0x50>)
   22fe8:	6811      	ldr	r1, [r2, #0]
   22fea:	4a0b      	ldr	r2, [pc, #44]	; (23018 <UINeartuneButtons+0x54>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   22fec:	771c      	strb	r4, [r3, #28]
                    writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
   22fee:	42a1      	cmp	r1, r4
   22ff0:	bf08      	it	eq
   22ff2:	4610      	moveq	r0, r2
                }


                return writeString;
            }
   22ff4:	f85d 4b04 	ldr.w	r4, [sp], #4
   22ff8:	4770      	bx	lr
                const char* writeString = "";
   22ffa:	4808      	ldr	r0, [pc, #32]	; (2301c <UINeartuneButtons+0x58>)
   22ffc:	e7ef      	b.n	22fde <UINeartuneButtons+0x1a>
   22ffe:	bf00      	nop
   23000:	020fb11c 	.word	0x020fb11c
   23004:	020e2de4 	.word	0x020e2de4
   23008:	00031c8c 	.word	0x00031c8c
   2300c:	00031c9c 	.word	0x00031c9c
   23010:	020e2de8 	.word	0x020e2de8
   23014:	00031cac 	.word	0x00031cac
   23018:	00031cbc 	.word	0x00031cbc
   2301c:	00031d64 	.word	0x00031d64

00023020 <UIAutotuneButtons>:
   23020:	4800      	ldr	r0, [pc, #0]	; (23024 <UIAutotuneButtons+0x4>)
   23022:	4770      	bx	lr
   23024:	00031d64 	.word	0x00031d64

00023028 <UISamplerBPButtons>:
                const char* writeString = "";
                return writeString;
            }

            const char* UISamplerBPButtons(VocodecButton button, ButtonAction action)
            {
   23028:	b570      	push	{r4, r5, r6, lr}
                const char* writeString = "";
                if (buttonActionsUI[ButtonC][ActionPress])
   2302a:	4c31      	ldr	r4, [pc, #196]	; (230f0 <UISamplerBPButtons+0xc8>)
   2302c:	7f23      	ldrb	r3, [r4, #28]
   2302e:	2b00      	cmp	r3, #0
   23030:	d144      	bne.n	230bc <UISamplerBPButtons+0x94>
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
                    buttonActionsUI[ButtonC][ActionPress] = 0;
                }

                if (buttonActionsUI[ButtonB][ActionPress])
   23032:	7e23      	ldrb	r3, [r4, #24]
   23034:	bb83      	cbnz	r3, 23098 <UISamplerBPButtons+0x70>
                {
                    OLEDclearLine(SecondLine);
                    OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
                    buttonActionsUI[ButtonB][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonA][ActionHoldContinuous])
   23036:	7de3      	ldrb	r3, [r4, #23]
   23038:	b9db      	cbnz	r3, 23072 <UISamplerBPButtons+0x4a>
                    OLEDclearLine(SecondLine);
                    OLEDwriteString("RECORDING", 9, 0, SecondLine);
                    OLEDwriteFloat(sampleLength, 84, SecondLine);
                    buttonActionsUI[ButtonA][ActionHoldContinuous] = 0;
                }
                if (buttonActionsUI[ButtonA][ActionRelease])
   2303a:	7d63      	ldrb	r3, [r4, #21]
   2303c:	b1bb      	cbz	r3, 2306e <UISamplerBPButtons+0x46>
                {
                    OLEDclearLine(SecondLine);
   2303e:	2001      	movs	r0, #1
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
   23040:	4d2c      	ldr	r5, [pc, #176]	; (230f4 <UISamplerBPButtons+0xcc>)
                    OLEDclearLine(SecondLine);
   23042:	f7f6 fc4f 	bl	198e4 <OLEDclearLine>
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
   23046:	4b2c      	ldr	r3, [pc, #176]	; (230f8 <UISamplerBPButtons+0xd0>)
   23048:	2101      	movs	r1, #1
   2304a:	2000      	movs	r0, #0
   2304c:	ed93 0a00 	vldr	s0, [r3]
   23050:	f7f6 fd1a 	bl	19a88 <OLEDwriteFloat>
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
   23054:	4a29      	ldr	r2, [pc, #164]	; (230fc <UISamplerBPButtons+0xd4>)
   23056:	482a      	ldr	r0, [pc, #168]	; (23100 <UISamplerBPButtons+0xd8>)
   23058:	2301      	movs	r3, #1
   2305a:	7816      	ldrb	r6, [r2, #0]
   2305c:	2107      	movs	r1, #7
   2305e:	2230      	movs	r2, #48	; 0x30
   23060:	2e00      	cmp	r6, #0
   23062:	bf08      	it	eq
   23064:	4628      	moveq	r0, r5
   23066:	f7f6 fc51 	bl	1990c <OLEDwriteString>
                    buttonActionsUI[ButtonA][ActionRelease] = 0;
   2306a:	2300      	movs	r3, #0
   2306c:	7563      	strb	r3, [r4, #21]
                }
                return writeString;
            }
   2306e:	4825      	ldr	r0, [pc, #148]	; (23104 <UISamplerBPButtons+0xdc>)
   23070:	bd70      	pop	{r4, r5, r6, pc}
                    OLEDclearLine(SecondLine);
   23072:	2001      	movs	r0, #1
   23074:	f7f6 fc36 	bl	198e4 <OLEDclearLine>
                    OLEDwriteString("RECORDING", 9, 0, SecondLine);
   23078:	2301      	movs	r3, #1
   2307a:	2200      	movs	r2, #0
   2307c:	2109      	movs	r1, #9
   2307e:	4822      	ldr	r0, [pc, #136]	; (23108 <UISamplerBPButtons+0xe0>)
   23080:	f7f6 fc44 	bl	1990c <OLEDwriteString>
                    OLEDwriteFloat(sampleLength, 84, SecondLine);
   23084:	4b1c      	ldr	r3, [pc, #112]	; (230f8 <UISamplerBPButtons+0xd0>)
   23086:	2101      	movs	r1, #1
   23088:	2054      	movs	r0, #84	; 0x54
   2308a:	ed93 0a00 	vldr	s0, [r3]
   2308e:	f7f6 fcfb 	bl	19a88 <OLEDwriteFloat>
                    buttonActionsUI[ButtonA][ActionHoldContinuous] = 0;
   23092:	2300      	movs	r3, #0
   23094:	75e3      	strb	r3, [r4, #23]
   23096:	e7d0      	b.n	2303a <UISamplerBPButtons+0x12>
                    OLEDclearLine(SecondLine);
   23098:	2001      	movs	r0, #1
                    OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
   2309a:	4d1c      	ldr	r5, [pc, #112]	; (2310c <UISamplerBPButtons+0xe4>)
                    OLEDclearLine(SecondLine);
   2309c:	f7f6 fc22 	bl	198e4 <OLEDclearLine>
                    OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
   230a0:	4a1b      	ldr	r2, [pc, #108]	; (23110 <UISamplerBPButtons+0xe8>)
   230a2:	481c      	ldr	r0, [pc, #112]	; (23114 <UISamplerBPButtons+0xec>)
   230a4:	2301      	movs	r3, #1
   230a6:	6816      	ldr	r6, [r2, #0]
   230a8:	2200      	movs	r2, #0
   230aa:	210c      	movs	r1, #12
   230ac:	4296      	cmp	r6, r2
   230ae:	bf08      	it	eq
   230b0:	4628      	moveq	r0, r5
   230b2:	f7f6 fc2b 	bl	1990c <OLEDwriteString>
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   230b6:	2300      	movs	r3, #0
   230b8:	7623      	strb	r3, [r4, #24]
   230ba:	e7bc      	b.n	23036 <UISamplerBPButtons+0xe>
                    OLEDclearLine(SecondLine);
   230bc:	2001      	movs	r0, #1
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
   230be:	4d0d      	ldr	r5, [pc, #52]	; (230f4 <UISamplerBPButtons+0xcc>)
                    OLEDclearLine(SecondLine);
   230c0:	f7f6 fc10 	bl	198e4 <OLEDclearLine>
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
   230c4:	4b0c      	ldr	r3, [pc, #48]	; (230f8 <UISamplerBPButtons+0xd0>)
   230c6:	2101      	movs	r1, #1
   230c8:	2000      	movs	r0, #0
   230ca:	ed93 0a00 	vldr	s0, [r3]
   230ce:	f7f6 fcdb 	bl	19a88 <OLEDwriteFloat>
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
   230d2:	4a0a      	ldr	r2, [pc, #40]	; (230fc <UISamplerBPButtons+0xd4>)
   230d4:	480a      	ldr	r0, [pc, #40]	; (23100 <UISamplerBPButtons+0xd8>)
   230d6:	2301      	movs	r3, #1
   230d8:	7816      	ldrb	r6, [r2, #0]
   230da:	2107      	movs	r1, #7
   230dc:	2230      	movs	r2, #48	; 0x30
   230de:	2e00      	cmp	r6, #0
   230e0:	bf08      	it	eq
   230e2:	4628      	moveq	r0, r5
   230e4:	f7f6 fc12 	bl	1990c <OLEDwriteString>
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   230e8:	2300      	movs	r3, #0
   230ea:	7723      	strb	r3, [r4, #28]
   230ec:	e7a1      	b.n	23032 <UISamplerBPButtons+0xa>
   230ee:	bf00      	nop
   230f0:	020fb11c 	.word	0x020fb11c
   230f4:	00031d40 	.word	0x00031d40
   230f8:	020e2ec4 	.word	0x020e2ec4
   230fc:	00062800 	.word	0x00062800
   23100:	00031d38 	.word	0x00031d38
   23104:	00031d64 	.word	0x00031d64
   23108:	00031d68 	.word	0x00031d68
   2310c:	00031d58 	.word	0x00031d58
   23110:	020e2dec 	.word	0x020e2dec
   23114:	00031d48 	.word	0x00031d48

00023118 <UISamplerKButtons>:

            const char* UISamplerKButtons(VocodecButton button, ButtonAction action)
            {
   23118:	b510      	push	{r4, lr}
                const char* writeString = "";


                if (buttonActionsUI[ExtraMessage][ActionHoldContinuous] || buttonActionsUI[ButtonA][ActionPress])
   2311a:	4c1d      	ldr	r4, [pc, #116]	; (23190 <UISamplerKButtons+0x78>)
   2311c:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
            {
   23120:	ed2d 8b02 	vpush	{d8}
                if (buttonActionsUI[ExtraMessage][ActionHoldContinuous] || buttonActionsUI[ButtonA][ActionPress])
   23124:	b97b      	cbnz	r3, 23146 <UISamplerKButtons+0x2e>
   23126:	7d23      	ldrb	r3, [r4, #20]
   23128:	b96b      	cbnz	r3, 23146 <UISamplerKButtons+0x2e>
                    OLEDwriteFloat(sampleLength, OLEDgetCursor(), SecondLine);
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 0;
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }

                if (buttonActionsUI[ButtonB][ActionPress])
   2312a:	7e23      	ldrb	r3, [r4, #24]
   2312c:	b363      	cbz	r3, 23188 <UISamplerKButtons+0x70>
                {
                    writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
   2312e:	4b19      	ldr	r3, [pc, #100]	; (23194 <UISamplerKButtons+0x7c>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   23130:	2100      	movs	r1, #0
                    writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
   23132:	4819      	ldr	r0, [pc, #100]	; (23198 <UISamplerKButtons+0x80>)
   23134:	681a      	ldr	r2, [r3, #0]
   23136:	4b19      	ldr	r3, [pc, #100]	; (2319c <UISamplerKButtons+0x84>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   23138:	7621      	strb	r1, [r4, #24]
                    writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
   2313a:	428a      	cmp	r2, r1
   2313c:	bf08      	it	eq
   2313e:	4618      	moveq	r0, r3
                }
                return writeString;
            }
   23140:	ecbd 8b02 	vpop	{d8}
   23144:	bd10      	pop	{r4, pc}
                    OLEDclearLine(SecondLine);
   23146:	2001      	movs	r0, #1
   23148:	f7f6 fbcc 	bl	198e4 <OLEDclearLine>
                    OLEDwritePitch(currentSamplerKeyGlobal + LOWEST_SAMPLER_KEY, 0, SecondLine, false);
   2314c:	4b14      	ldr	r3, [pc, #80]	; (231a0 <UISamplerKButtons+0x88>)
   2314e:	2200      	movs	r2, #0
   23150:	2101      	movs	r1, #1
   23152:	681b      	ldr	r3, [r3, #0]
   23154:	4610      	mov	r0, r2
   23156:	3324      	adds	r3, #36	; 0x24
   23158:	ee00 3a10 	vmov	s0, r3
   2315c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   23160:	f7f6 fc30 	bl	199c4 <OLEDwritePitch>
                    OLEDwriteFloat(sampleLength, OLEDgetCursor(), SecondLine);
   23164:	4b0f      	ldr	r3, [pc, #60]	; (231a4 <UISamplerKButtons+0x8c>)
   23166:	ed93 8a00 	vldr	s16, [r3]
   2316a:	f7f6 fe4b 	bl	19e04 <OLEDgetCursor>
   2316e:	2101      	movs	r1, #1
   23170:	b2c0      	uxtb	r0, r0
   23172:	eeb0 0a48 	vmov.f32	s0, s16
   23176:	f7f6 fc87 	bl	19a88 <OLEDwriteFloat>
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 0;
   2317a:	2300      	movs	r3, #0
   2317c:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   23180:	7523      	strb	r3, [r4, #20]
                if (buttonActionsUI[ButtonB][ActionPress])
   23182:	7e23      	ldrb	r3, [r4, #24]
   23184:	2b00      	cmp	r3, #0
   23186:	d1d2      	bne.n	2312e <UISamplerKButtons+0x16>
                const char* writeString = "";
   23188:	4807      	ldr	r0, [pc, #28]	; (231a8 <UISamplerKButtons+0x90>)
            }
   2318a:	ecbd 8b02 	vpop	{d8}
   2318e:	bd10      	pop	{r4, pc}
   23190:	020fb11c 	.word	0x020fb11c
   23194:	020e2e28 	.word	0x020e2e28
   23198:	00031d74 	.word	0x00031d74
   2319c:	00031d7c 	.word	0x00031d7c
   231a0:	0006277c 	.word	0x0006277c
   231a4:	020e2ec4 	.word	0x020e2ec4
   231a8:	00031d64 	.word	0x00031d64

000231ac <UISamplerAutoButtons>:

            const char* UISamplerAutoButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
   231ac:	4b15      	ldr	r3, [pc, #84]	; (23204 <UISamplerAutoButtons+0x58>)
            {
   231ae:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress])
   231b0:	7d1a      	ldrb	r2, [r3, #20]
   231b2:	b15a      	cbz	r2, 231cc <UISamplerAutoButtons+0x20>
                {
                    if (samplerMode == PlayLoop)
   231b4:	4a14      	ldr	r2, [pc, #80]	; (23208 <UISamplerAutoButtons+0x5c>)
   231b6:	7812      	ldrb	r2, [r2, #0]
   231b8:	2a01      	cmp	r2, #1
   231ba:	d021      	beq.n	23200 <UISamplerAutoButtons+0x54>
                    {
                        writeString = "LOOP";
                    }
                    else if (samplerMode == PlayBackAndForth)
                    {
                        writeString = "BACK'N'FORTH";
   231bc:	4813      	ldr	r0, [pc, #76]	; (2320c <UISamplerAutoButtons+0x60>)
   231be:	4914      	ldr	r1, [pc, #80]	; (23210 <UISamplerAutoButtons+0x64>)
   231c0:	2a02      	cmp	r2, #2
   231c2:	bf08      	it	eq
   231c4:	4608      	moveq	r0, r1
                    }
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   231c6:	2200      	movs	r2, #0
   231c8:	751a      	strb	r2, [r3, #20]
   231ca:	e000      	b.n	231ce <UISamplerAutoButtons+0x22>
                const char* writeString = "";
   231cc:	480f      	ldr	r0, [pc, #60]	; (2320c <UISamplerAutoButtons+0x60>)
                }
                if (buttonActionsUI[ButtonB][ActionPress])
   231ce:	7e1a      	ldrb	r2, [r3, #24]
   231d0:	b142      	cbz	r2, 231e4 <UISamplerAutoButtons+0x38>
                {
                    writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
   231d2:	4a10      	ldr	r2, [pc, #64]	; (23214 <UISamplerAutoButtons+0x68>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   231d4:	2400      	movs	r4, #0
                    writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
   231d6:	4810      	ldr	r0, [pc, #64]	; (23218 <UISamplerAutoButtons+0x6c>)
   231d8:	7811      	ldrb	r1, [r2, #0]
   231da:	4a10      	ldr	r2, [pc, #64]	; (2321c <UISamplerAutoButtons+0x70>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   231dc:	761c      	strb	r4, [r3, #24]
                    writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
   231de:	42a1      	cmp	r1, r4
   231e0:	bf08      	it	eq
   231e2:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress])
   231e4:	7f1a      	ldrb	r2, [r3, #28]
   231e6:	b142      	cbz	r2, 231fa <UISamplerAutoButtons+0x4e>
                {
                    writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
   231e8:	4a0d      	ldr	r2, [pc, #52]	; (23220 <UISamplerAutoButtons+0x74>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   231ea:	2400      	movs	r4, #0
                    writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
   231ec:	480d      	ldr	r0, [pc, #52]	; (23224 <UISamplerAutoButtons+0x78>)
   231ee:	6811      	ldr	r1, [r2, #0]
   231f0:	4a0d      	ldr	r2, [pc, #52]	; (23228 <UISamplerAutoButtons+0x7c>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   231f2:	771c      	strb	r4, [r3, #28]
                    writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
   231f4:	42a1      	cmp	r1, r4
   231f6:	bf08      	it	eq
   231f8:	4610      	moveq	r0, r2
                }
                return writeString;
            }
   231fa:	f85d 4b04 	ldr.w	r4, [sp], #4
   231fe:	4770      	bx	lr
                        writeString = "LOOP";
   23200:	480a      	ldr	r0, [pc, #40]	; (2322c <UISamplerAutoButtons+0x80>)
   23202:	e7e0      	b.n	231c6 <UISamplerAutoButtons+0x1a>
   23204:	020fb11c 	.word	0x020fb11c
   23208:	00062801 	.word	0x00062801
   2320c:	00031d64 	.word	0x00031d64
   23210:	00031cf8 	.word	0x00031cf8
   23214:	020e2ed5 	.word	0x020e2ed5
   23218:	00031d08 	.word	0x00031d08
   2321c:	00031d14 	.word	0x00031d14
   23220:	020e2ea4 	.word	0x020e2ea4
   23224:	00031d20 	.word	0x00031d20
   23228:	00031d2c 	.word	0x00031d2c
   2322c:	00031cf0 	.word	0x00031cf0

00023230 <UIDistortionButtons>:

            const char* UIDistortionButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
   23230:	4b08      	ldr	r3, [pc, #32]	; (23254 <UIDistortionButtons+0x24>)
   23232:	7d1a      	ldrb	r2, [r3, #20]
   23234:	b162      	cbz	r2, 23250 <UIDistortionButtons+0x20>
                {
                    writeString = distortionMode ? "SHAPER" : "TANH";
   23236:	4a08      	ldr	r2, [pc, #32]	; (23258 <UIDistortionButtons+0x28>)
   23238:	4808      	ldr	r0, [pc, #32]	; (2325c <UIDistortionButtons+0x2c>)
            {
   2323a:	b410      	push	{r4}
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   2323c:	2400      	movs	r4, #0
                    writeString = distortionMode ? "SHAPER" : "TANH";
   2323e:	7811      	ldrb	r1, [r2, #0]
   23240:	4a07      	ldr	r2, [pc, #28]	; (23260 <UIDistortionButtons+0x30>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   23242:	751c      	strb	r4, [r3, #20]
                    writeString = distortionMode ? "SHAPER" : "TANH";
   23244:	42a1      	cmp	r1, r4
   23246:	bf08      	it	eq
   23248:	4610      	moveq	r0, r2
                }
                return writeString;
            }
   2324a:	f85d 4b04 	ldr.w	r4, [sp], #4
   2324e:	4770      	bx	lr
                const char* writeString = "";
   23250:	4804      	ldr	r0, [pc, #16]	; (23264 <UIDistortionButtons+0x34>)
            }
   23252:	4770      	bx	lr
   23254:	020fb11c 	.word	0x020fb11c
   23258:	020e2e44 	.word	0x020e2e44
   2325c:	00031c1c 	.word	0x00031c1c
   23260:	00031c24 	.word	0x00031c24
   23264:	00031d64 	.word	0x00031d64

00023268 <UIWaveFolderButtons>:

            const char* UIWaveFolderButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
   23268:	4b08      	ldr	r3, [pc, #32]	; (2328c <UIWaveFolderButtons+0x24>)
   2326a:	7d1a      	ldrb	r2, [r3, #20]
   2326c:	b162      	cbz	r2, 23288 <UIWaveFolderButtons+0x20>
                {
                    writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
   2326e:	4a08      	ldr	r2, [pc, #32]	; (23290 <UIWaveFolderButtons+0x28>)
   23270:	4808      	ldr	r0, [pc, #32]	; (23294 <UIWaveFolderButtons+0x2c>)
            {
   23272:	b410      	push	{r4}
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   23274:	2400      	movs	r4, #0
                    writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
   23276:	6811      	ldr	r1, [r2, #0]
   23278:	4a07      	ldr	r2, [pc, #28]	; (23298 <UIWaveFolderButtons+0x30>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   2327a:	751c      	strb	r4, [r3, #20]
                    writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
   2327c:	42a1      	cmp	r1, r4
   2327e:	bf08      	it	eq
   23280:	4610      	moveq	r0, r2
                }
                return writeString;
            }
   23282:	f85d 4b04 	ldr.w	r4, [sp], #4
   23286:	4770      	bx	lr
                const char* writeString = "";
   23288:	4804      	ldr	r0, [pc, #16]	; (2329c <UIWaveFolderButtons+0x34>)
            }
   2328a:	4770      	bx	lr
   2328c:	020fb11c 	.word	0x020fb11c
   23290:	020e2e54 	.word	0x020e2e54
   23294:	00031dc4 	.word	0x00031dc4
   23298:	00031dd4 	.word	0x00031dd4
   2329c:	00031d64 	.word	0x00031d64

000232a0 <UIBitcrusherButtons>:

            const char* UIBitcrusherButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";

                if (buttonActionsUI[ButtonA][ActionPress])
   232a0:	4b08      	ldr	r3, [pc, #32]	; (232c4 <UIBitcrusherButtons+0x24>)
   232a2:	7d1a      	ldrb	r2, [r3, #20]
   232a4:	b162      	cbz	r2, 232c0 <UIBitcrusherButtons+0x20>
                {
                    writeString = crusherStereo ? "STEREO" : "MONO";
   232a6:	4a08      	ldr	r2, [pc, #32]	; (232c8 <UIBitcrusherButtons+0x28>)
   232a8:	4808      	ldr	r0, [pc, #32]	; (232cc <UIBitcrusherButtons+0x2c>)
            {
   232aa:	b410      	push	{r4}
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   232ac:	2400      	movs	r4, #0
                    writeString = crusherStereo ? "STEREO" : "MONO";
   232ae:	6811      	ldr	r1, [r2, #0]
   232b0:	4a07      	ldr	r2, [pc, #28]	; (232d0 <UIBitcrusherButtons+0x30>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   232b2:	751c      	strb	r4, [r3, #20]
                    writeString = crusherStereo ? "STEREO" : "MONO";
   232b4:	42a1      	cmp	r1, r4
   232b6:	bf08      	it	eq
   232b8:	4610      	moveq	r0, r2
                }


                return writeString;
            }
   232ba:	f85d 4b04 	ldr.w	r4, [sp], #4
   232be:	4770      	bx	lr
                const char* writeString = "";
   232c0:	4804      	ldr	r0, [pc, #16]	; (232d4 <UIBitcrusherButtons+0x34>)
            }
   232c2:	4770      	bx	lr
   232c4:	020fb11c 	.word	0x020fb11c
   232c8:	020e2e30 	.word	0x020e2e30
   232cc:	00031e94 	.word	0x00031e94
   232d0:	00031d90 	.word	0x00031d90
   232d4:	00031d64 	.word	0x00031d64

000232d8 <UIDelayButtons>:

            const char* UIDelayButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
   232d8:	4b0e      	ldr	r3, [pc, #56]	; (23314 <UIDelayButtons+0x3c>)
            {
   232da:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress])
   232dc:	7d1a      	ldrb	r2, [r3, #20]
   232de:	b1b2      	cbz	r2, 2330e <UIDelayButtons+0x36>
                {
                    writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
   232e0:	4a0d      	ldr	r2, [pc, #52]	; (23318 <UIDelayButtons+0x40>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   232e2:	2400      	movs	r4, #0
                    writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
   232e4:	480d      	ldr	r0, [pc, #52]	; (2331c <UIDelayButtons+0x44>)
   232e6:	6811      	ldr	r1, [r2, #0]
   232e8:	4a0d      	ldr	r2, [pc, #52]	; (23320 <UIDelayButtons+0x48>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   232ea:	751c      	strb	r4, [r3, #20]
                    writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
   232ec:	42a1      	cmp	r1, r4
   232ee:	bf08      	it	eq
   232f0:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonB][ActionPress])
   232f2:	7e1a      	ldrb	r2, [r3, #24]
   232f4:	b142      	cbz	r2, 23308 <UIDelayButtons+0x30>
                {
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   232f6:	4a0b      	ldr	r2, [pc, #44]	; (23324 <UIDelayButtons+0x4c>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   232f8:	2400      	movs	r4, #0
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   232fa:	480b      	ldr	r0, [pc, #44]	; (23328 <UIDelayButtons+0x50>)
   232fc:	7811      	ldrb	r1, [r2, #0]
   232fe:	4a0b      	ldr	r2, [pc, #44]	; (2332c <UIDelayButtons+0x54>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   23300:	761c      	strb	r4, [r3, #24]
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   23302:	42a1      	cmp	r1, r4
   23304:	bf08      	it	eq
   23306:	4610      	moveq	r0, r2
                }
                return writeString;
            }
   23308:	f85d 4b04 	ldr.w	r4, [sp], #4
   2330c:	4770      	bx	lr
                const char* writeString = "";
   2330e:	4808      	ldr	r0, [pc, #32]	; (23330 <UIDelayButtons+0x58>)
   23310:	e7ef      	b.n	232f2 <UIDelayButtons+0x1a>
   23312:	bf00      	nop
   23314:	020fb11c 	.word	0x020fb11c
   23318:	020e2e40 	.word	0x020e2e40
   2331c:	00031bf0 	.word	0x00031bf0
   23320:	00031bfc 	.word	0x00031bfc
   23324:	020e2df0 	.word	0x020e2df0
   23328:	00031c08 	.word	0x00031c08
   2332c:	00031c10 	.word	0x00031c10
   23330:	00031d64 	.word	0x00031d64

00023334 <UIReverbButtons>:

            const char* UIReverbButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonC][ActionPress])
   23334:	4b0e      	ldr	r3, [pc, #56]	; (23370 <UIReverbButtons+0x3c>)
            {
   23336:	b410      	push	{r4}
                if (buttonActionsUI[ButtonC][ActionPress])
   23338:	7f1a      	ldrb	r2, [r3, #28]
   2333a:	b1b2      	cbz	r2, 2336a <UIReverbButtons+0x36>
                {
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
   2333c:	4a0d      	ldr	r2, [pc, #52]	; (23374 <UIReverbButtons+0x40>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   2333e:	2400      	movs	r4, #0
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
   23340:	480d      	ldr	r0, [pc, #52]	; (23378 <UIReverbButtons+0x44>)
   23342:	6811      	ldr	r1, [r2, #0]
   23344:	4a0d      	ldr	r2, [pc, #52]	; (2337c <UIReverbButtons+0x48>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   23346:	771c      	strb	r4, [r3, #28]
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
   23348:	42a1      	cmp	r1, r4
   2334a:	bf08      	it	eq
   2334c:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonB][ActionPress])
   2334e:	7e1a      	ldrb	r2, [r3, #24]
   23350:	b142      	cbz	r2, 23364 <UIReverbButtons+0x30>
                {
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   23352:	4a0b      	ldr	r2, [pc, #44]	; (23380 <UIReverbButtons+0x4c>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   23354:	2400      	movs	r4, #0
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   23356:	480b      	ldr	r0, [pc, #44]	; (23384 <UIReverbButtons+0x50>)
   23358:	7811      	ldrb	r1, [r2, #0]
   2335a:	4a0b      	ldr	r2, [pc, #44]	; (23388 <UIReverbButtons+0x54>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   2335c:	761c      	strb	r4, [r3, #24]
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   2335e:	42a1      	cmp	r1, r4
   23360:	bf08      	it	eq
   23362:	4610      	moveq	r0, r2
                }
                return writeString;
            }
   23364:	f85d 4b04 	ldr.w	r4, [sp], #4
   23368:	4770      	bx	lr
                const char* writeString = "";
   2336a:	4808      	ldr	r0, [pc, #32]	; (2338c <UIReverbButtons+0x58>)
   2336c:	e7ef      	b.n	2334e <UIReverbButtons+0x1a>
   2336e:	bf00      	nop
   23370:	020fb11c 	.word	0x020fb11c
   23374:	020e2e58 	.word	0x020e2e58
   23378:	00031ccc 	.word	0x00031ccc
   2337c:	00031cd4 	.word	0x00031cd4
   23380:	020e2df0 	.word	0x020e2df0
   23384:	00031c08 	.word	0x00031c08
   23388:	00031c10 	.word	0x00031c10
   2338c:	00031d64 	.word	0x00031d64

00023390 <UIReverb2Buttons>:

            const char* UIReverb2Buttons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonC][ActionPress])
   23390:	4b08      	ldr	r3, [pc, #32]	; (233b4 <UIReverb2Buttons+0x24>)
   23392:	7f1a      	ldrb	r2, [r3, #28]
   23394:	b162      	cbz	r2, 233b0 <UIReverb2Buttons+0x20>
                {
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
   23396:	4a08      	ldr	r2, [pc, #32]	; (233b8 <UIReverb2Buttons+0x28>)
   23398:	4808      	ldr	r0, [pc, #32]	; (233bc <UIReverb2Buttons+0x2c>)
            {
   2339a:	b410      	push	{r4}
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   2339c:	2400      	movs	r4, #0
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
   2339e:	6811      	ldr	r1, [r2, #0]
   233a0:	4a07      	ldr	r2, [pc, #28]	; (233c0 <UIReverb2Buttons+0x30>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   233a2:	771c      	strb	r4, [r3, #28]
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
   233a4:	42a1      	cmp	r1, r4
   233a6:	bf08      	it	eq
   233a8:	4610      	moveq	r0, r2
                }
                return writeString;
            }
   233aa:	f85d 4b04 	ldr.w	r4, [sp], #4
   233ae:	4770      	bx	lr
                const char* writeString = "";
   233b0:	4804      	ldr	r0, [pc, #16]	; (233c4 <UIReverb2Buttons+0x34>)
            }
   233b2:	4770      	bx	lr
   233b4:	020fb11c 	.word	0x020fb11c
   233b8:	020e2e58 	.word	0x020e2e58
   233bc:	00031ccc 	.word	0x00031ccc
   233c0:	00031cd4 	.word	0x00031cd4
   233c4:	00031d64 	.word	0x00031d64

000233c8 <UILivingStringButtons>:

            const char* UILivingStringButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
   233c8:	4b15      	ldr	r3, [pc, #84]	; (23420 <UILivingStringButtons+0x58>)
            {
   233ca:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
   233cc:	7d1a      	ldrb	r2, [r3, #20]
   233ce:	2a01      	cmp	r2, #1
   233d0:	d01b      	beq.n	2340a <UILivingStringButtons+0x42>
                const char* writeString = "";
   233d2:	4814      	ldr	r0, [pc, #80]	; (23424 <UILivingStringButtons+0x5c>)
                {
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
   233d4:	7f1a      	ldrb	r2, [r3, #28]
   233d6:	2a01      	cmp	r2, #1
   233d8:	d108      	bne.n	233ec <UILivingStringButtons+0x24>
                {
                    writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
   233da:	4a13      	ldr	r2, [pc, #76]	; (23428 <UILivingStringButtons+0x60>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   233dc:	2400      	movs	r4, #0
                    writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
   233de:	4813      	ldr	r0, [pc, #76]	; (2342c <UILivingStringButtons+0x64>)
   233e0:	6811      	ldr	r1, [r2, #0]
   233e2:	4a13      	ldr	r2, [pc, #76]	; (23430 <UILivingStringButtons+0x68>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   233e4:	771c      	strb	r4, [r3, #28]
                    writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
   233e6:	42a1      	cmp	r1, r4
   233e8:	bfd8      	it	le
   233ea:	4610      	movle	r0, r2
                }

                if (buttonActionsUI[ButtonB][ActionPress] == 1)
   233ec:	7e1a      	ldrb	r2, [r3, #24]
   233ee:	2a01      	cmp	r2, #1
   233f0:	d108      	bne.n	23404 <UILivingStringButtons+0x3c>
                {
                    writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
   233f2:	4a10      	ldr	r2, [pc, #64]	; (23434 <UILivingStringButtons+0x6c>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   233f4:	2400      	movs	r4, #0
                    writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
   233f6:	4810      	ldr	r0, [pc, #64]	; (23438 <UILivingStringButtons+0x70>)
   233f8:	6811      	ldr	r1, [r2, #0]
   233fa:	4a10      	ldr	r2, [pc, #64]	; (2343c <UILivingStringButtons+0x74>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   233fc:	761c      	strb	r4, [r3, #24]
                    writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
   233fe:	42a1      	cmp	r1, r4
   23400:	bfd8      	it	le
   23402:	4610      	movle	r0, r2
                }

                return writeString;
            }
   23404:	f85d 4b04 	ldr.w	r4, [sp], #4
   23408:	4770      	bx	lr
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
   2340a:	4a0d      	ldr	r2, [pc, #52]	; (23440 <UILivingStringButtons+0x78>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   2340c:	2400      	movs	r4, #0
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
   2340e:	480d      	ldr	r0, [pc, #52]	; (23444 <UILivingStringButtons+0x7c>)
   23410:	6811      	ldr	r1, [r2, #0]
   23412:	4a0d      	ldr	r2, [pc, #52]	; (23448 <UILivingStringButtons+0x80>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   23414:	751c      	strb	r4, [r3, #20]
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
   23416:	42a1      	cmp	r1, r4
   23418:	bfd8      	it	le
   2341a:	4610      	movle	r0, r2
   2341c:	e7da      	b.n	233d4 <UILivingStringButtons+0xc>
   2341e:	bf00      	nop
   23420:	020fb11c 	.word	0x020fb11c
   23424:	00031d64 	.word	0x00031d64
   23428:	020e2e68 	.word	0x020e2e68
   2342c:	00031c44 	.word	0x00031c44
   23430:	00031c4c 	.word	0x00031c4c
   23434:	020e2e60 	.word	0x020e2e60
   23438:	00031c58 	.word	0x00031c58
   2343c:	00031c68 	.word	0x00031c68
   23440:	020e2e5c 	.word	0x020e2e5c
   23444:	00031c2c 	.word	0x00031c2c
   23448:	00031c38 	.word	0x00031c38

0002344c <UILivingStringSynthButtons>:

            const char* UILivingStringSynthButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
   2344c:	4b15      	ldr	r3, [pc, #84]	; (234a4 <UILivingStringSynthButtons+0x58>)
            {
   2344e:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
   23450:	7d1a      	ldrb	r2, [r3, #20]
   23452:	2a01      	cmp	r2, #1
   23454:	d01b      	beq.n	2348e <UILivingStringSynthButtons+0x42>
                const char* writeString = "";
   23456:	4814      	ldr	r0, [pc, #80]	; (234a8 <UILivingStringSynthButtons+0x5c>)
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
   23458:	7e1a      	ldrb	r2, [r3, #24]
   2345a:	2a01      	cmp	r2, #1
   2345c:	d108      	bne.n	23470 <UILivingStringSynthButtons+0x24>
                {
                    writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
   2345e:	4a13      	ldr	r2, [pc, #76]	; (234ac <UILivingStringSynthButtons+0x60>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   23460:	2400      	movs	r4, #0
                    writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
   23462:	4813      	ldr	r0, [pc, #76]	; (234b0 <UILivingStringSynthButtons+0x64>)
   23464:	6811      	ldr	r1, [r2, #0]
   23466:	4a13      	ldr	r2, [pc, #76]	; (234b4 <UILivingStringSynthButtons+0x68>)
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   23468:	761c      	strb	r4, [r3, #24]
                    writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
   2346a:	42a1      	cmp	r1, r4
   2346c:	bfd8      	it	le
   2346e:	4610      	movle	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
   23470:	7f1a      	ldrb	r2, [r3, #28]
   23472:	2a01      	cmp	r2, #1
   23474:	d108      	bne.n	23488 <UILivingStringSynthButtons+0x3c>
                {
                    writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
   23476:	4a10      	ldr	r2, [pc, #64]	; (234b8 <UILivingStringSynthButtons+0x6c>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   23478:	2400      	movs	r4, #0
                    writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
   2347a:	4810      	ldr	r0, [pc, #64]	; (234bc <UILivingStringSynthButtons+0x70>)
   2347c:	6811      	ldr	r1, [r2, #0]
   2347e:	4a10      	ldr	r2, [pc, #64]	; (234c0 <UILivingStringSynthButtons+0x74>)
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   23480:	771c      	strb	r4, [r3, #28]
                    writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
   23482:	42a1      	cmp	r1, r4
   23484:	bfd8      	it	le
   23486:	4610      	movle	r0, r2
                }
                return writeString;
            }
   23488:	f85d 4b04 	ldr.w	r4, [sp], #4
   2348c:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   2348e:	4a0d      	ldr	r2, [pc, #52]	; (234c4 <UILivingStringSynthButtons+0x78>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   23490:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   23492:	480d      	ldr	r0, [pc, #52]	; (234c8 <UILivingStringSynthButtons+0x7c>)
   23494:	7811      	ldrb	r1, [r2, #0]
   23496:	4a0d      	ldr	r2, [pc, #52]	; (234cc <UILivingStringSynthButtons+0x80>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   23498:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   2349a:	2901      	cmp	r1, #1
   2349c:	bf98      	it	ls
   2349e:	4610      	movls	r0, r2
   234a0:	e7da      	b.n	23458 <UILivingStringSynthButtons+0xc>
   234a2:	bf00      	nop
   234a4:	020fb11c 	.word	0x020fb11c
   234a8:	00031d64 	.word	0x00031d64
   234ac:	020e2ee0 	.word	0x020e2ee0
   234b0:	00031c74 	.word	0x00031c74
   234b4:	00031c80 	.word	0x00031c80
   234b8:	020e2e6c 	.word	0x020e2e6c
   234bc:	00031c44 	.word	0x00031c44
   234c0:	00031c4c 	.word	0x00031c4c
   234c4:	000627ac 	.word	0x000627ac
   234c8:	00031d88 	.word	0x00031d88
   234cc:	00031d90 	.word	0x00031d90

000234d0 <UIClassicSynthButtons>:

            const char* UIClassicSynthButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
   234d0:	4b0d      	ldr	r3, [pc, #52]	; (23508 <UIClassicSynthButtons+0x38>)
   234d2:	7d1a      	ldrb	r2, [r3, #20]
   234d4:	2a01      	cmp	r2, #1
   234d6:	d006      	beq.n	234e6 <UIClassicSynthButtons+0x16>
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress])
   234d8:	7e1a      	ldrb	r2, [r3, #24]
                const char* writeString = "";
   234da:	480c      	ldr	r0, [pc, #48]	; (2350c <UIClassicSynthButtons+0x3c>)
                if (buttonActionsUI[ButtonB][ActionPress])
   234dc:	b112      	cbz	r2, 234e4 <UIClassicSynthButtons+0x14>
                {
                    //writeString = knobPage == 0 ? "SETTINGS" : "ADSR";
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   234de:	2200      	movs	r2, #0
   234e0:	761a      	strb	r2, [r3, #24]
   234e2:	4770      	bx	lr
                }
                return writeString;
            }
   234e4:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   234e6:	4a0a      	ldr	r2, [pc, #40]	; (23510 <UIClassicSynthButtons+0x40>)
   234e8:	480a      	ldr	r0, [pc, #40]	; (23514 <UIClassicSynthButtons+0x44>)
            {
   234ea:	b410      	push	{r4}
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   234ec:	7811      	ldrb	r1, [r2, #0]
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   234ee:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   234f0:	4a09      	ldr	r2, [pc, #36]	; (23518 <UIClassicSynthButtons+0x48>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   234f2:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   234f4:	2901      	cmp	r1, #1
   234f6:	bf98      	it	ls
   234f8:	4610      	movls	r0, r2
                if (buttonActionsUI[ButtonB][ActionPress])
   234fa:	7e1a      	ldrb	r2, [r3, #24]
   234fc:	b10a      	cbz	r2, 23502 <UIClassicSynthButtons+0x32>
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   234fe:	2200      	movs	r2, #0
   23500:	761a      	strb	r2, [r3, #24]
            }
   23502:	f85d 4b04 	ldr.w	r4, [sp], #4
   23506:	4770      	bx	lr
   23508:	020fb11c 	.word	0x020fb11c
   2350c:	00031d64 	.word	0x00031d64
   23510:	000627ac 	.word	0x000627ac
   23514:	00031d88 	.word	0x00031d88
   23518:	00031d90 	.word	0x00031d90

0002351c <UIRhodesButtons>:

            const char* UIRhodesButtons(VocodecButton button, ButtonAction action)
            {
   2351c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
   2351e:	4c1f      	ldr	r4, [pc, #124]	; (2359c <UIRhodesButtons+0x80>)
   23520:	7d23      	ldrb	r3, [r4, #20]
   23522:	2b01      	cmp	r3, #1
   23524:	d008      	beq.n	23538 <UIRhodesButtons+0x1c>
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
   23526:	7e25      	ldrb	r5, [r4, #24]
                const char* writeString = "";
   23528:	4e1d      	ldr	r6, [pc, #116]	; (235a0 <UIRhodesButtons+0x84>)
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
   2352a:	2d01      	cmp	r5, #1
   2352c:	d010      	beq.n	23550 <UIRhodesButtons+0x34>
                {
                    buttonActionsUI[ButtonB][ActionPress] = 0;
                    OLEDclearLine(SecondLine);
                    OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
   2352e:	7f25      	ldrb	r5, [r4, #28]
   23530:	2d01      	cmp	r5, #1
   23532:	d01f      	beq.n	23574 <UIRhodesButtons+0x58>
                    OLEDclearLine(SecondLine);
                    OLEDwriteString("STEREO TREMO", 12, 0, SecondLine);
                    OLEDwriteInt(tremoloStereo, 1, 110, SecondLine);
                }
                return writeString;
            }
   23534:	4630      	mov	r0, r6
   23536:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   23538:	4b1a      	ldr	r3, [pc, #104]	; (235a4 <UIRhodesButtons+0x88>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   2353a:	2100      	movs	r1, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   2353c:	4e1a      	ldr	r6, [pc, #104]	; (235a8 <UIRhodesButtons+0x8c>)
   2353e:	781a      	ldrb	r2, [r3, #0]
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
   23540:	7e25      	ldrb	r5, [r4, #24]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   23542:	4b1a      	ldr	r3, [pc, #104]	; (235ac <UIRhodesButtons+0x90>)
                    buttonActionsUI[ButtonA][ActionPress] = 0;
   23544:	7521      	strb	r1, [r4, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
   23546:	2a01      	cmp	r2, #1
   23548:	bf98      	it	ls
   2354a:	461e      	movls	r6, r3
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
   2354c:	2d01      	cmp	r5, #1
   2354e:	d1ee      	bne.n	2352e <UIRhodesButtons+0x12>
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   23550:	2700      	movs	r7, #0
                    OLEDclearLine(SecondLine);
   23552:	4628      	mov	r0, r5
                    buttonActionsUI[ButtonB][ActionPress] = 0;
   23554:	7627      	strb	r7, [r4, #24]
                    OLEDclearLine(SecondLine);
   23556:	f7f6 f9c5 	bl	198e4 <OLEDclearLine>
                    OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
   2355a:	4915      	ldr	r1, [pc, #84]	; (235b0 <UIRhodesButtons+0x94>)
   2355c:	462b      	mov	r3, r5
   2355e:	4815      	ldr	r0, [pc, #84]	; (235b4 <UIRhodesButtons+0x98>)
   23560:	463a      	mov	r2, r7
   23562:	680d      	ldr	r5, [r1, #0]
   23564:	2106      	movs	r1, #6
   23566:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
   2356a:	f7f6 f9cf 	bl	1990c <OLEDwriteString>
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
   2356e:	7f25      	ldrb	r5, [r4, #28]
   23570:	2d01      	cmp	r5, #1
   23572:	d1df      	bne.n	23534 <UIRhodesButtons+0x18>
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   23574:	2700      	movs	r7, #0
                    OLEDclearLine(SecondLine);
   23576:	4628      	mov	r0, r5
                    buttonActionsUI[ButtonC][ActionPress] = 0;
   23578:	7727      	strb	r7, [r4, #28]
                    OLEDclearLine(SecondLine);
   2357a:	f7f6 f9b3 	bl	198e4 <OLEDclearLine>
                    OLEDwriteString("STEREO TREMO", 12, 0, SecondLine);
   2357e:	462b      	mov	r3, r5
   23580:	463a      	mov	r2, r7
   23582:	210c      	movs	r1, #12
   23584:	480c      	ldr	r0, [pc, #48]	; (235b8 <UIRhodesButtons+0x9c>)
   23586:	f7f6 f9c1 	bl	1990c <OLEDwriteString>
                    OLEDwriteInt(tremoloStereo, 1, 110, SecondLine);
   2358a:	4a0c      	ldr	r2, [pc, #48]	; (235bc <UIRhodesButtons+0xa0>)
   2358c:	462b      	mov	r3, r5
   2358e:	4629      	mov	r1, r5
   23590:	7810      	ldrb	r0, [r2, #0]
   23592:	226e      	movs	r2, #110	; 0x6e
   23594:	f7f6 f9e4 	bl	19960 <OLEDwriteInt>
            }
   23598:	4630      	mov	r0, r6
   2359a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2359c:	020fb11c 	.word	0x020fb11c
   235a0:	00031d64 	.word	0x00031d64
   235a4:	000627ac 	.word	0x000627ac
   235a8:	00031d88 	.word	0x00031d88
   235ac:	00031d90 	.word	0x00031d90
   235b0:	020e2dd8 	.word	0x020e2dd8
   235b4:	020f9db0 	.word	0x020f9db0
   235b8:	00031ce0 	.word	0x00031ce0
   235bc:	020e2ed4 	.word	0x020e2ed4

000235c0 <USBH_UserProcess>:
 * user callback definition
 */
static void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)
{
  /* USER CODE BEGIN CALL_BACK_1 */
  switch(id)
   235c0:	2904      	cmp	r1, #4
   235c2:	d00b      	beq.n	235dc <USBH_UserProcess+0x1c>
   235c4:	2905      	cmp	r1, #5
   235c6:	d005      	beq.n	235d4 <USBH_UserProcess+0x14>
   235c8:	2902      	cmp	r1, #2
   235ca:	d000      	beq.n	235ce <USBH_UserProcess+0xe>

  default:
  break;
  }
  /* USER CODE END CALL_BACK_1 */
}
   235cc:	4770      	bx	lr
  Appli_state = APPLICATION_READY;
   235ce:	4b05      	ldr	r3, [pc, #20]	; (235e4 <USBH_UserProcess+0x24>)
   235d0:	7019      	strb	r1, [r3, #0]
  break;
   235d2:	4770      	bx	lr
  Appli_state = APPLICATION_DISCONNECT;
   235d4:	4b03      	ldr	r3, [pc, #12]	; (235e4 <USBH_UserProcess+0x24>)
   235d6:	2204      	movs	r2, #4
   235d8:	701a      	strb	r2, [r3, #0]
  break;
   235da:	4770      	bx	lr
  Appli_state = APPLICATION_START;
   235dc:	4b01      	ldr	r3, [pc, #4]	; (235e4 <USBH_UserProcess+0x24>)
   235de:	2201      	movs	r2, #1
   235e0:	701a      	strb	r2, [r3, #0]
}
   235e2:	4770      	bx	lr
   235e4:	020e2f1c 	.word	0x020e2f1c

000235e8 <MX_USB_HOST_Init>:
{
   235e8:	b508      	push	{r3, lr}
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, HOST_FS) != USBH_OK)
   235ea:	2201      	movs	r2, #1
   235ec:	490c      	ldr	r1, [pc, #48]	; (23620 <MX_USB_HOST_Init+0x38>)
   235ee:	480d      	ldr	r0, [pc, #52]	; (23624 <MX_USB_HOST_Init+0x3c>)
   235f0:	f7f1 fc4c 	bl	14e8c <USBH_Init>
   235f4:	b988      	cbnz	r0, 2361a <MX_USB_HOST_Init+0x32>
  if (USBH_RegisterClass(&hUsbHostFS, USBH_MIDI_CLASS) != USBH_OK)
   235f6:	490c      	ldr	r1, [pc, #48]	; (23628 <MX_USB_HOST_Init+0x40>)
   235f8:	480a      	ldr	r0, [pc, #40]	; (23624 <MX_USB_HOST_Init+0x3c>)
   235fa:	f7f1 fcad 	bl	14f58 <USBH_RegisterClass>
   235fe:	b948      	cbnz	r0, 23614 <MX_USB_HOST_Init+0x2c>
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
   23600:	4808      	ldr	r0, [pc, #32]	; (23624 <MX_USB_HOST_Init+0x3c>)
   23602:	f7f1 fd99 	bl	15138 <USBH_Start>
   23606:	b108      	cbz	r0, 2360c <MX_USB_HOST_Init+0x24>
    Error_Handler();
   23608:	f7f5 ff02 	bl	19410 <Error_Handler>
}
   2360c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnableUSBVoltageDetector();
   23610:	f7ea bd3a 	b.w	e088 <HAL_PWREx_EnableUSBVoltageDetector>
    Error_Handler();
   23614:	f7f5 fefc 	bl	19410 <Error_Handler>
   23618:	e7f2      	b.n	23600 <MX_USB_HOST_Init+0x18>
    Error_Handler();
   2361a:	f7f5 fef9 	bl	19410 <Error_Handler>
   2361e:	e7ea      	b.n	235f6 <MX_USB_HOST_Init+0xe>
   23620:	000235c1 	.word	0x000235c1
   23624:	00063aa0 	.word	0x00063aa0
   23628:	0006282c 	.word	0x0006282c

0002362c <MX_USB_HOST_DeInit>:
{
   2362c:	b508      	push	{r3, lr}
  if (USBH_Stop(&hUsbHostFS) != USBH_OK)
   2362e:	4808      	ldr	r0, [pc, #32]	; (23650 <MX_USB_HOST_DeInit+0x24>)
   23630:	f7f1 fd8c 	bl	1514c <USBH_Stop>
   23634:	b948      	cbnz	r0, 2364a <MX_USB_HOST_DeInit+0x1e>
  if (USBH_DeInit(&hUsbHostFS) != USBH_OK)
   23636:	4806      	ldr	r0, [pc, #24]	; (23650 <MX_USB_HOST_DeInit+0x24>)
   23638:	f7f1 fc60 	bl	14efc <USBH_DeInit>
   2363c:	b108      	cbz	r0, 23642 <MX_USB_HOST_DeInit+0x16>
    Error_Handler();
   2363e:	f7f5 fee7 	bl	19410 <Error_Handler>
}
   23642:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_DisableUSBVoltageDetector();
   23646:	f7ea bd27 	b.w	e098 <HAL_PWREx_DisableUSBVoltageDetector>
    Error_Handler();
   2364a:	f7f5 fee1 	bl	19410 <Error_Handler>
   2364e:	e7f2      	b.n	23636 <MX_USB_HOST_DeInit+0xa>
   23650:	00063aa0 	.word	0x00063aa0

00023654 <MX_USB_HOST_Process>:
{
   23654:	b508      	push	{r3, lr}
	MIDI_Application();
   23656:	f7f2 ffdb 	bl	16610 <MIDI_Application>
	USBH_Process(&hUsbHostFS);
   2365a:	4802      	ldr	r0, [pc, #8]	; (23664 <MX_USB_HOST_Process+0x10>)
}
   2365c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	USBH_Process(&hUsbHostFS);
   23660:	f7f1 bd86 	b.w	15170 <USBH_Process>
   23664:	00063aa0 	.word	0x00063aa0

00023668 <USBH_MIDI_ClassRequest>:
 *         for MIDI class.
 * @param  phost: Host handle
 * @retval USBH Status
 */
static USBH_StatusTypeDef USBH_MIDI_ClassRequest (USBH_HandleTypeDef *phost)
{   
   23668:	b508      	push	{r3, lr}

	phost->pUser(phost, HOST_USER_CLASS_ACTIVE);
   2366a:	2102      	movs	r1, #2
   2366c:	f8d0 3544 	ldr.w	r3, [r0, #1348]	; 0x544
   23670:	4798      	blx	r3

	return USBH_OK;
}
   23672:	2000      	movs	r0, #0
   23674:	bd08      	pop	{r3, pc}
   23676:	bf00      	nop

00023678 <USBH_MIDI_Process>:
 *         (background process)
 * @param  phost: Host handle
 * @retval USBH Status
 */
static USBH_StatusTypeDef USBH_MIDI_Process (USBH_HandleTypeDef *phost)
{
   23678:	b510      	push	{r4, lr}
	USBH_StatusTypeDef status = USBH_BUSY;
	USBH_StatusTypeDef req_status = USBH_OK;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   2367a:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
   2367e:	69dc      	ldr	r4, [r3, #28]

	switch(MIDI_Handle->state)
   23680:	7823      	ldrb	r3, [r4, #0]
   23682:	b153      	cbz	r3, 2369a <USBH_MIDI_Process+0x22>
   23684:	2b02      	cmp	r3, #2
   23686:	d106      	bne.n	23696 <USBH_MIDI_Process+0x1e>
		//MIDI_ProcessTransmission(phost);
		//MIDI_ProcessReception(phost);
		break;

	case MIDI_ERROR_STATE:
		req_status = USBH_ClrFeature(phost, 0x00);
   23688:	2100      	movs	r1, #0
   2368a:	f7f2 fdfd 	bl	16288 <USBH_ClrFeature>

		if(req_status == USBH_OK )
   2368e:	b910      	cbnz	r0, 23696 <USBH_MIDI_Process+0x1e>
		{
			/*Change the state to waiting*/
			MIDI_Handle->state = MIDI_IDLE_STATE ;
   23690:	7020      	strb	r0, [r4, #0]
	USBH_StatusTypeDef status = USBH_BUSY;
   23692:	2001      	movs	r0, #1
		break;

	}

	return status;
}
   23694:	bd10      	pop	{r4, pc}
	USBH_StatusTypeDef status = USBH_BUSY;
   23696:	2001      	movs	r0, #1
}
   23698:	bd10      	pop	{r4, pc}
		status = USBH_OK;
   2369a:	4618      	mov	r0, r3
}
   2369c:	bd10      	pop	{r4, pc}
   2369e:	bf00      	nop

000236a0 <USBH_MIDI_SOFProcess>:
  *         The function is for managing SOF callback
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MIDI_SOFProcess (USBH_HandleTypeDef *phost)
{
   236a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBH_StatusTypeDef status = USBH_BUSY;
	USBH_StatusTypeDef req_status = USBH_OK;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   236a4:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
{
   236a8:	b083      	sub	sp, #12
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   236aa:	69dc      	ldr	r4, [r3, #28]
	USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
	uint16_t length;
	switch(MIDI_Handle->state)
   236ac:	7823      	ldrb	r3, [r4, #0]
   236ae:	2b01      	cmp	r3, #1
   236b0:	d00a      	beq.n	236c8 <USBH_MIDI_SOFProcess+0x28>
   236b2:	2b02      	cmp	r3, #2
   236b4:	d104      	bne.n	236c0 <USBH_MIDI_SOFProcess+0x20>
				break;
		}
		break;

	case MIDI_ERROR_STATE:
		req_status = USBH_ClrFeature(phost, 0x00);
   236b6:	2100      	movs	r1, #0
   236b8:	f7f2 fde6 	bl	16288 <USBH_ClrFeature>

		if(req_status == USBH_OK )
   236bc:	b900      	cbnz	r0, 236c0 <USBH_MIDI_SOFProcess+0x20>
		{
			/*Change the state to waiting*/
			MIDI_Handle->state = MIDI_IDLE_STATE ;
   236be:	7020      	strb	r0, [r4, #0]
		break;

	}

	return USBH_OK;
}
   236c0:	2000      	movs	r0, #0
   236c2:	b003      	add	sp, #12
   236c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch(MIDI_Handle->data_rx_state)
   236c8:	7e63      	ldrb	r3, [r4, #25]
   236ca:	2b03      	cmp	r3, #3
   236cc:	d06f      	beq.n	237ae <USBH_MIDI_SOFProcess+0x10e>
   236ce:	2b04      	cmp	r3, #4
   236d0:	d1f6      	bne.n	236c0 <USBH_MIDI_SOFProcess+0x20>
				URB_Status = USBH_LL_GetURBState(phost, MIDI_Handle->InPipe);
   236d2:	7861      	ldrb	r1, [r4, #1]
   236d4:	4605      	mov	r5, r0
   236d6:	f000 fa33 	bl	23b40 <USBH_LL_GetURBState>
				if(URB_Status == USBH_URB_DONE )
   236da:	2801      	cmp	r0, #1
   236dc:	d1f0      	bne.n	236c0 <USBH_MIDI_SOFProcess+0x20>
					length = USBH_LL_GetLastXferSize(phost, MIDI_Handle->InPipe);
   236de:	7861      	ldrb	r1, [r4, #1]
   236e0:	4628      	mov	r0, r5
   236e2:	f000 f9e5 	bl	23ab0 <USBH_LL_GetLastXferSize>
					if(((MIDI_Handle->RxDataLength - length) > 0) && (length > MIDI_Handle->InEpSize))
   236e6:	8ae3      	ldrh	r3, [r4, #22]
   236e8:	b286      	uxth	r6, r0
   236ea:	1b9a      	subs	r2, r3, r6
   236ec:	2a00      	cmp	r2, #0
   236ee:	dd02      	ble.n	236f6 <USBH_MIDI_SOFProcess+0x56>
   236f0:	8922      	ldrh	r2, [r4, #8]
   236f2:	42b2      	cmp	r2, r6
   236f4:	d366      	bcc.n	237c4 <USBH_MIDI_SOFProcess+0x124>
						MIDI_write_buffer = !MIDI_write_buffer;
   236f6:	4837      	ldr	r0, [pc, #220]	; (237d4 <USBH_MIDI_SOFProcess+0x134>)
						MIDI_Handle->data_rx_state = MIDI_IDLE;
   236f8:	2300      	movs	r3, #0
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   236fa:	4937      	ldr	r1, [pc, #220]	; (237d8 <USBH_MIDI_SOFProcess+0x138>)
						MIDI_write_buffer = !MIDI_write_buffer;
   236fc:	f890 c000 	ldrb.w	ip, [r0]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   23700:	780a      	ldrb	r2, [r1, #0]
						MIDI_write_buffer = !MIDI_write_buffer;
   23702:	fabc fc8c 	clz	ip, ip
						MIDI_Handle->data_rx_state = MIDI_IDLE;
   23706:	7663      	strb	r3, [r4, #25]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   23708:	fab2 f282 	clz	r2, r2
						MIDI_write_buffer = !MIDI_write_buffer;
   2370c:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   23710:	0952      	lsrs	r2, r2, #5
						MIDI_write_buffer = !MIDI_write_buffer;
   23712:	f880 c000 	strb.w	ip, [r0]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   23716:	700a      	strb	r2, [r1, #0]
						for (int i = 0; i < length; i++)
   23718:	2e00      	cmp	r6, #0
   2371a:	d035      	beq.n	23788 <USBH_MIDI_SOFProcess+0xe8>
   2371c:	482f      	ldr	r0, [pc, #188]	; (237dc <USBH_MIDI_SOFProcess+0x13c>)
								myUSB_FIFO_overflowBit = 1;
   2371e:	f04f 0801 	mov.w	r8, #1
   23722:	492f      	ldr	r1, [pc, #188]	; (237e0 <USBH_MIDI_SOFProcess+0x140>)
								myUSB_FIFO_writePointer = 0;
   23724:	469e      	mov	lr, r3
   23726:	eb00 1282 	add.w	r2, r0, r2, lsl #6
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   2372a:	4f2e      	ldr	r7, [pc, #184]	; (237e4 <USBH_MIDI_SOFProcess+0x144>)
								myUSB_FIFO_overflowBit = 1;
   2372c:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 237e8 <USBH_MIDI_SOFProcess+0x148>
   23730:	9401      	str	r4, [sp, #4]
							if ((i % 4) == 0)
   23732:	f003 0003 	and.w	r0, r3, #3
   23736:	3301      	adds	r3, #1
   23738:	b9d8      	cbnz	r0, 23772 <USBH_MIDI_SOFProcess+0xd2>
								if (MIDI_RX_Buffer[MIDI_read_buffer][i] > 0)
   2373a:	7810      	ldrb	r0, [r2, #0]
   2373c:	b1c8      	cbz	r0, 23772 <USBH_MIDI_SOFProcess+0xd2>
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   2373e:	f8b1 b000 	ldrh.w	fp, [r1]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
   23742:	f892 a001 	ldrb.w	sl, [r2, #1]
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   23746:	fa1f fb8b 	uxth.w	fp, fp
									myUSB_FIFO[myUSB_FIFO_writePointer+2] = MIDI_RX_Buffer[MIDI_read_buffer][i+2];
   2374a:	7894      	ldrb	r4, [r2, #2]
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   2374c:	f807 000b 	strb.w	r0, [r7, fp]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
   23750:	8808      	ldrh	r0, [r1, #0]
									myUSB_FIFO[myUSB_FIFO_writePointer+3] = MIDI_RX_Buffer[MIDI_read_buffer][i+3];
   23752:	f892 b003 	ldrb.w	fp, [r2, #3]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
   23756:	3001      	adds	r0, #1
   23758:	f807 a000 	strb.w	sl, [r7, r0]
									myUSB_FIFO[myUSB_FIFO_writePointer+2] = MIDI_RX_Buffer[MIDI_read_buffer][i+2];
   2375c:	8808      	ldrh	r0, [r1, #0]
   2375e:	3002      	adds	r0, #2
   23760:	543c      	strb	r4, [r7, r0]
									myUSB_FIFO[myUSB_FIFO_writePointer+3] = MIDI_RX_Buffer[MIDI_read_buffer][i+3];
   23762:	8808      	ldrh	r0, [r1, #0]
   23764:	3003      	adds	r0, #3
   23766:	f807 b000 	strb.w	fp, [r7, r0]
									myUSB_FIFO_writePointer+=4;
   2376a:	8808      	ldrh	r0, [r1, #0]
   2376c:	3004      	adds	r0, #4
   2376e:	b280      	uxth	r0, r0
   23770:	8008      	strh	r0, [r1, #0]
							if (myUSB_FIFO_writePointer >= 256)
   23772:	8808      	ldrh	r0, [r1, #0]
   23774:	3201      	adds	r2, #1
   23776:	28ff      	cmp	r0, #255	; 0xff
   23778:	d903      	bls.n	23782 <USBH_MIDI_SOFProcess+0xe2>
								myUSB_FIFO_writePointer = 0;
   2377a:	f8a1 e000 	strh.w	lr, [r1]
								myUSB_FIFO_overflowBit = 1;
   2377e:	f889 8000 	strb.w	r8, [r9]
						for (int i = 0; i < length; i++)
   23782:	429e      	cmp	r6, r3
   23784:	d1d5      	bne.n	23732 <USBH_MIDI_SOFProcess+0x92>
   23786:	9c01      	ldr	r4, [sp, #4]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
   23788:	2304      	movs	r3, #4
   2378a:	7663      	strb	r3, [r4, #25]
 * @retval None
 */
USBH_StatusTypeDef  USBH_MIDI_Receive(USBH_HandleTypeDef *phost, uint8_t *pbuff, uint16_t length)
{
	USBH_StatusTypeDef Status = USBH_BUSY;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   2378c:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
   23790:	69db      	ldr	r3, [r3, #28]

	if((MIDI_Handle->state == MIDI_IDLE_STATE) || (MIDI_Handle->state == MIDI_TRANSFER_DATA))
   23792:	781a      	ldrb	r2, [r3, #0]
   23794:	2a01      	cmp	r2, #1
   23796:	d893      	bhi.n	236c0 <USBH_MIDI_SOFProcess+0x20>
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
   23798:	4a10      	ldr	r2, [pc, #64]	; (237dc <USBH_MIDI_SOFProcess+0x13c>)
	{
		MIDI_Handle->pRxData = pbuff;
		MIDI_Handle->RxDataLength = length;
   2379a:	2440      	movs	r4, #64	; 0x40
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   2379c:	2001      	movs	r0, #1
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   2379e:	2103      	movs	r1, #3
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
   237a0:	eb02 128c 	add.w	r2, r2, ip, lsl #6
		MIDI_Handle->RxDataLength = length;
   237a4:	82dc      	strh	r4, [r3, #22]
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   237a6:	7018      	strb	r0, [r3, #0]
		MIDI_Handle->pRxData = pbuff;
   237a8:	611a      	str	r2, [r3, #16]
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   237aa:	7659      	strb	r1, [r3, #25]
   237ac:	e788      	b.n	236c0 <USBH_MIDI_SOFProcess+0x20>
				USBH_BulkReceiveData (phost,
   237ae:	7863      	ldrb	r3, [r4, #1]
   237b0:	8922      	ldrh	r2, [r4, #8]
   237b2:	6921      	ldr	r1, [r4, #16]
   237b4:	f7f2 fe88 	bl	164c8 <USBH_BulkReceiveData>
				MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
   237b8:	2304      	movs	r3, #4
}
   237ba:	2000      	movs	r0, #0
				MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
   237bc:	7663      	strb	r3, [r4, #25]
}
   237be:	b003      	add	sp, #12
   237c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						MIDI_Handle->pRxData += length;
   237c4:	6922      	ldr	r2, [r4, #16]
						MIDI_Handle->RxDataLength -= length ;
   237c6:	1b98      	subs	r0, r3, r6
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   237c8:	2303      	movs	r3, #3
						MIDI_Handle->pRxData += length;
   237ca:	4432      	add	r2, r6
						MIDI_Handle->RxDataLength -= length ;
   237cc:	82e0      	strh	r0, [r4, #22]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   237ce:	7663      	strb	r3, [r4, #25]
						MIDI_Handle->pRxData += length;
   237d0:	6122      	str	r2, [r4, #16]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   237d2:	e775      	b.n	236c0 <USBH_MIDI_SOFProcess+0x20>
   237d4:	00062564 	.word	0x00062564
   237d8:	020e2d94 	.word	0x020e2d94
   237dc:	00062a00 	.word	0x00062a00
   237e0:	020e2f20 	.word	0x020e2f20
   237e4:	020fb9a4 	.word	0x020fb9a4
   237e8:	020e2f1d 	.word	0x020e2f1d

000237ec <USBH_MIDI_InterfaceDeInit>:
{
   237ec:	b538      	push	{r3, r4, r5, lr}
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   237ee:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
{
   237f2:	4605      	mov	r5, r0
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   237f4:	69dc      	ldr	r4, [r3, #28]
	if ( MIDI_Handle->OutPipe)
   237f6:	78a1      	ldrb	r1, [r4, #2]
   237f8:	b949      	cbnz	r1, 2380e <USBH_MIDI_InterfaceDeInit+0x22>
	if ( MIDI_Handle->InPipe)
   237fa:	7861      	ldrb	r1, [r4, #1]
   237fc:	b991      	cbnz	r1, 23824 <USBH_MIDI_InterfaceDeInit+0x38>
	if(phost->pActiveClass->pData)
   237fe:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
   23802:	69da      	ldr	r2, [r3, #28]
   23804:	b10a      	cbz	r2, 2380a <USBH_MIDI_InterfaceDeInit+0x1e>
		phost->pActiveClass->pData = 0;
   23806:	2200      	movs	r2, #0
   23808:	61da      	str	r2, [r3, #28]
}
   2380a:	2000      	movs	r0, #0
   2380c:	bd38      	pop	{r3, r4, r5, pc}
		USBH_ClosePipe(phost, MIDI_Handle->OutPipe);
   2380e:	f7f2 fe7d 	bl	1650c <USBH_ClosePipe>
		USBH_FreePipe  (phost, MIDI_Handle->OutPipe);
   23812:	78a1      	ldrb	r1, [r4, #2]
   23814:	4628      	mov	r0, r5
   23816:	f7f2 fec9 	bl	165ac <USBH_FreePipe>
		MIDI_Handle->OutPipe = 0;     /* Reset the Channel as Free */
   2381a:	2300      	movs	r3, #0
	if ( MIDI_Handle->InPipe)
   2381c:	7861      	ldrb	r1, [r4, #1]
		MIDI_Handle->OutPipe = 0;     /* Reset the Channel as Free */
   2381e:	70a3      	strb	r3, [r4, #2]
	if ( MIDI_Handle->InPipe)
   23820:	2900      	cmp	r1, #0
   23822:	d0ec      	beq.n	237fe <USBH_MIDI_InterfaceDeInit+0x12>
		USBH_ClosePipe(phost, MIDI_Handle->InPipe);
   23824:	4628      	mov	r0, r5
   23826:	f7f2 fe71 	bl	1650c <USBH_ClosePipe>
		USBH_FreePipe  (phost, MIDI_Handle->InPipe);
   2382a:	7861      	ldrb	r1, [r4, #1]
   2382c:	4628      	mov	r0, r5
   2382e:	f7f2 febd 	bl	165ac <USBH_FreePipe>
		MIDI_Handle->InPipe = 0;     /* Reset the Channel as Free */
   23832:	2300      	movs	r3, #0
   23834:	7063      	strb	r3, [r4, #1]
   23836:	e7e2      	b.n	237fe <USBH_MIDI_InterfaceDeInit+0x12>

00023838 <USBH_MIDI_InterfaceInit>:
{	
   23838:	b5f0      	push	{r4, r5, r6, r7, lr}
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
   2383a:	23ff      	movs	r3, #255	; 0xff
{	
   2383c:	b085      	sub	sp, #20
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
   2383e:	2203      	movs	r2, #3
   23840:	2101      	movs	r1, #1
{	
   23842:	4605      	mov	r5, r0
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
   23844:	f7f1 fba0 	bl	14f88 <USBH_FindInterface>
	if(interface == 0xFF) /* No Valid Interface */
   23848:	28ff      	cmp	r0, #255	; 0xff
   2384a:	d058      	beq.n	238fe <USBH_MIDI_InterfaceInit+0xc6>
		USBH_SelectInterface (phost, interface);
   2384c:	4601      	mov	r1, r0
   2384e:	4628      	mov	r0, r5
   23850:	f7f1 fb90 	bl	14f74 <USBH_SelectInterface>
		phost->pActiveClass->pData = &myMIDIHandle;
   23854:	4c2d      	ldr	r4, [pc, #180]	; (2390c <USBH_MIDI_InterfaceInit+0xd4>)
   23856:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
   2385a:	222a      	movs	r2, #42	; 0x2a
		phost->pActiveClass->pData = &myMIDIHandle;
   2385c:	61dc      	str	r4, [r3, #28]
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
   2385e:	f895 3324 	ldrb.w	r3, [r5, #804]	; 0x324
   23862:	fb02 5203 	mla	r2, r2, r3, r5
   23866:	f892 134e 	ldrb.w	r1, [r2, #846]	; 0x34e
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
   2386a:	f8b2 2350 	ldrh.w	r2, [r2, #848]	; 0x350
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
   2386e:	0608      	lsls	r0, r1, #24
   23870:	d442      	bmi.n	238f8 <USBH_MIDI_InterfaceInit+0xc0>
			myMIDIHandle.OutEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress);
   23872:	70e1      	strb	r1, [r4, #3]
			myMIDIHandle.OutEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
   23874:	80e2      	strh	r2, [r4, #6]
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress & 0x80)
   23876:	222a      	movs	r2, #42	; 0x2a
   23878:	fb02 5303 	mla	r3, r2, r3, r5
   2387c:	f893 1356 	ldrb.w	r1, [r3, #854]	; 0x356
   23880:	f8b3 3358 	ldrh.w	r3, [r3, #856]	; 0x358
   23884:	060a      	lsls	r2, r1, #24
   23886:	d43d      	bmi.n	23904 <USBH_MIDI_InterfaceInit+0xcc>
			myMIDIHandle.OutEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress);
   23888:	70e1      	strb	r1, [r4, #3]
			myMIDIHandle.OutEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].wMaxPacketSize;
   2388a:	80e3      	strh	r3, [r4, #6]
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
   2388c:	4628      	mov	r0, r5
		USBH_OpenPipe  (phost,
   2388e:	2702      	movs	r7, #2
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
   23890:	f7f2 fe42 	bl	16518 <USBH_AllocPipe>
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
   23894:	7921      	ldrb	r1, [r4, #4]
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
   23896:	70a0      	strb	r0, [r4, #2]
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
   23898:	4628      	mov	r0, r5
   2389a:	f7f2 fe3d 	bl	16518 <USBH_AllocPipe>
		USBH_OpenPipe  (phost,
   2389e:	f8b4 c006 	ldrh.w	ip, [r4, #6]
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
   238a2:	7060      	strb	r0, [r4, #1]
		myMIDIHandle.state = MIDI_IDLE_STATE;
   238a4:	2600      	movs	r6, #0
		USBH_OpenPipe  (phost,
   238a6:	f895 031d 	ldrb.w	r0, [r5, #797]	; 0x31d
   238aa:	f895 331c 	ldrb.w	r3, [r5, #796]	; 0x31c
   238ae:	78e2      	ldrb	r2, [r4, #3]
   238b0:	78a1      	ldrb	r1, [r4, #2]
   238b2:	9000      	str	r0, [sp, #0]
   238b4:	4628      	mov	r0, r5
   238b6:	e9cd 7c01 	strd	r7, ip, [sp, #4]
   238ba:	f7f2 fe17 	bl	164ec <USBH_OpenPipe>
		USBH_OpenPipe  (phost,
   238be:	f895 331c 	ldrb.w	r3, [r5, #796]	; 0x31c
   238c2:	f8b4 c008 	ldrh.w	ip, [r4, #8]
   238c6:	4628      	mov	r0, r5
   238c8:	9701      	str	r7, [sp, #4]
   238ca:	f895 731d 	ldrb.w	r7, [r5, #797]	; 0x31d
   238ce:	7922      	ldrb	r2, [r4, #4]
   238d0:	f8cd c008 	str.w	ip, [sp, #8]
   238d4:	7861      	ldrb	r1, [r4, #1]
   238d6:	9700      	str	r7, [sp, #0]
   238d8:	f7f2 fe08 	bl	164ec <USBH_OpenPipe>
		USBH_LL_SetToggle  (phost, myMIDIHandle.InPipe,0);
   238dc:	4632      	mov	r2, r6
   238de:	7861      	ldrb	r1, [r4, #1]
   238e0:	4628      	mov	r0, r5
		myMIDIHandle.state = MIDI_IDLE_STATE;
   238e2:	7026      	strb	r6, [r4, #0]
		USBH_LL_SetToggle  (phost, myMIDIHandle.InPipe,0);
   238e4:	f000 f942 	bl	23b6c <USBH_LL_SetToggle>
		USBH_LL_SetToggle  (phost, myMIDIHandle.OutPipe,0);
   238e8:	4632      	mov	r2, r6
   238ea:	78a1      	ldrb	r1, [r4, #2]
   238ec:	4628      	mov	r0, r5
   238ee:	f000 f93d 	bl	23b6c <USBH_LL_SetToggle>
   238f2:	4630      	mov	r0, r6
}
   238f4:	b005      	add	sp, #20
   238f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myMIDIHandle.InEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress);
   238f8:	7121      	strb	r1, [r4, #4]
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
   238fa:	8122      	strh	r2, [r4, #8]
   238fc:	e7bb      	b.n	23876 <USBH_MIDI_InterfaceInit+0x3e>
		status = USBH_FAIL;
   238fe:	2002      	movs	r0, #2
}
   23900:	b005      	add	sp, #20
   23902:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myMIDIHandle.InEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress);
   23904:	7121      	strb	r1, [r4, #4]
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].wMaxPacketSize;
   23906:	8123      	strh	r3, [r4, #8]
   23908:	78e1      	ldrb	r1, [r4, #3]
   2390a:	e7bf      	b.n	2388c <USBH_MIDI_InterfaceInit+0x54>
   2390c:	020fb988 	.word	0x020fb988

00023910 <USBH_MIDI_Stop>:
  if(phost->gState == HOST_CLASS)
   23910:	7802      	ldrb	r2, [r0, #0]
   23912:	2a0b      	cmp	r2, #11
   23914:	d001      	beq.n	2391a <USBH_MIDI_Stop+0xa>
}
   23916:	2000      	movs	r0, #0
   23918:	4770      	bx	lr
{
   2391a:	b538      	push	{r3, r4, r5, lr}
  MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   2391c:	f8d0 24ec 	ldr.w	r2, [r0, #1260]	; 0x4ec
    MIDI_Handle->state = MIDI_IDLE_STATE;
   23920:	2300      	movs	r3, #0
   23922:	4604      	mov	r4, r0
  MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   23924:	69d5      	ldr	r5, [r2, #28]
    MIDI_Handle->state = MIDI_IDLE_STATE;
   23926:	702b      	strb	r3, [r5, #0]
    USBH_ClosePipe(phost, MIDI_Handle->InPipe);
   23928:	7869      	ldrb	r1, [r5, #1]
   2392a:	f7f2 fdef 	bl	1650c <USBH_ClosePipe>
    USBH_ClosePipe(phost, MIDI_Handle->OutPipe);
   2392e:	78a9      	ldrb	r1, [r5, #2]
   23930:	4620      	mov	r0, r4
   23932:	f7f2 fdeb 	bl	1650c <USBH_ClosePipe>
}
   23936:	2000      	movs	r0, #0
   23938:	bd38      	pop	{r3, r4, r5, pc}
   2393a:	bf00      	nop

0002393c <USBH_MIDI_Receive>:
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   2393c:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
   23940:	69db      	ldr	r3, [r3, #28]
	if((MIDI_Handle->state == MIDI_IDLE_STATE) || (MIDI_Handle->state == MIDI_TRANSFER_DATA))
   23942:	7818      	ldrb	r0, [r3, #0]
   23944:	2801      	cmp	r0, #1
   23946:	d901      	bls.n	2394c <USBH_MIDI_Receive+0x10>
	USBH_StatusTypeDef Status = USBH_BUSY;
   23948:	2001      	movs	r0, #1
#if (USBH_USE_OS == 1)
		osMessagePut ( phost->os_event, USBH_CLASS_EVENT, 0);
#endif
	}
	return Status;
}
   2394a:	4770      	bx	lr
{
   2394c:	b430      	push	{r4, r5}
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   2394e:	2501      	movs	r5, #1
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   23950:	2403      	movs	r4, #3
		MIDI_Handle->pRxData = pbuff;
   23952:	6119      	str	r1, [r3, #16]
		Status = USBH_OK;
   23954:	2000      	movs	r0, #0
		MIDI_Handle->RxDataLength = length;
   23956:	82da      	strh	r2, [r3, #22]
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   23958:	701d      	strb	r5, [r3, #0]
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   2395a:	765c      	strb	r4, [r3, #25]
}
   2395c:	bc30      	pop	{r4, r5}
   2395e:	4770      	bx	lr

00023960 <HAL_HCD_MspInit>:
                       LL Driver Callbacks (HCD -> USB Host Library)
*******************************************************************************/
/* MSP Init */

void HAL_HCD_MspInit(HCD_HandleTypeDef* hcdHandle)
{
   23960:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hcdHandle->Instance==USB_OTG_FS)
   23962:	4b1e      	ldr	r3, [pc, #120]	; (239dc <HAL_HCD_MspInit+0x7c>)
{
   23964:	b088      	sub	sp, #32
  if(hcdHandle->Instance==USB_OTG_FS)
   23966:	6802      	ldr	r2, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   23968:	2400      	movs	r4, #0
  if(hcdHandle->Instance==USB_OTG_FS)
   2396a:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   2396c:	9407      	str	r4, [sp, #28]
   2396e:	e9cd 4403 	strd	r4, r4, [sp, #12]
   23972:	e9cd 4405 	strd	r4, r4, [sp, #20]
  if(hcdHandle->Instance==USB_OTG_FS)
   23976:	d001      	beq.n	2397c <HAL_HCD_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */
//
  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
   23978:	b008      	add	sp, #32
   2397a:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
   2397c:	4d18      	ldr	r5, [pc, #96]	; (239e0 <HAL_HCD_MspInit+0x80>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   2397e:	2202      	movs	r2, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   23980:	2003      	movs	r0, #3
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   23982:	f44f 56c0 	mov.w	r6, #6144	; 0x1800
    __HAL_RCC_GPIOA_CLK_ENABLE();
   23986:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   2398a:	a903      	add	r1, sp, #12
    __HAL_RCC_GPIOA_CLK_ENABLE();
   2398c:	f043 0301 	orr.w	r3, r3, #1
   23990:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
   23994:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   23998:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
   2399a:	220a      	movs	r2, #10
    __HAL_RCC_GPIOA_CLK_ENABLE();
   2399c:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   239a0:	9006      	str	r0, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   239a2:	4810      	ldr	r0, [pc, #64]	; (239e4 <HAL_HCD_MspInit+0x84>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
   239a4:	9301      	str	r3, [sp, #4]
   239a6:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
   239a8:	9207      	str	r2, [sp, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   239aa:	9603      	str	r6, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   239ac:	f7e8 f908 	bl	bbc0 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
   239b0:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
   239b4:	4622      	mov	r2, r4
   239b6:	2101      	movs	r1, #1
   239b8:	2065      	movs	r0, #101	; 0x65
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
   239ba:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   239be:	f8c5 30d8 	str.w	r3, [r5, #216]	; 0xd8
   239c2:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
   239c6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
   239ca:	9302      	str	r3, [sp, #8]
   239cc:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
   239ce:	f7e6 f801 	bl	99d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
   239d2:	2065      	movs	r0, #101	; 0x65
   239d4:	f7e6 f844 	bl	9a60 <HAL_NVIC_EnableIRQ>
}
   239d8:	b008      	add	sp, #32
   239da:	bd70      	pop	{r4, r5, r6, pc}
   239dc:	40080000 	.word	0x40080000
   239e0:	58024400 	.word	0x58024400
   239e4:	58020000 	.word	0x58020000

000239e8 <USBH_LL_Init>:
  * @brief  Initialize the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
{
   239e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Init USB_IP */
  if (phost->id == HOST_FS) {
   239ea:	f890 353c 	ldrb.w	r3, [r0, #1340]	; 0x53c
   239ee:	2b01      	cmp	r3, #1
   239f0:	d001      	beq.n	239f6 <USBH_LL_Init+0xe>
  }

  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
  }
  return USBH_OK;
}
   239f2:	2000      	movs	r0, #0
   239f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   239f6:	4a10      	ldr	r2, [pc, #64]	; (23a38 <USBH_LL_Init+0x50>)
   239f8:	4604      	mov	r4, r0
  hhcd_USB_OTG_FS.Init.Host_channels = 6;
   239fa:	2606      	movs	r6, #6
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   239fc:	4f0f      	ldr	r7, [pc, #60]	; (23a3c <USBH_LL_Init+0x54>)
  hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
   239fe:	2502      	movs	r5, #2
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
   23a00:	2100      	movs	r1, #0
  phost->pData = &hhcd_USB_OTG_FS;
   23a02:	f8c0 2540 	str.w	r2, [r0, #1344]	; 0x540
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
   23a06:	4610      	mov	r0, r2
  hhcd_USB_OTG_FS.pData = phost;
   23a08:	f8c2 42c0 	str.w	r4, [r2, #704]	; 0x2c0
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   23a0c:	6017      	str	r7, [r2, #0]
  hhcd_USB_OTG_FS.Init.Host_channels = 6;
   23a0e:	6096      	str	r6, [r2, #8]
  hhcd_USB_OTG_FS.Init.dma_enable = ENABLE;
   23a10:	e9c2 3303 	strd	r3, r3, [r2, #12]
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
   23a14:	e9c2 5106 	strd	r5, r1, [r2, #24]
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
   23a18:	f7e8 fc74 	bl	c304 <HAL_HCD_Init>
   23a1c:	b940      	cbnz	r0, 23a30 <USBH_LL_Init+0x48>
  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
   23a1e:	4806      	ldr	r0, [pc, #24]	; (23a38 <USBH_LL_Init+0x50>)
   23a20:	f7e8 fd7a 	bl	c518 <HAL_HCD_GetCurrentFrame>
   23a24:	4601      	mov	r1, r0
   23a26:	4620      	mov	r0, r4
   23a28:	f7f1 fe06 	bl	15638 <USBH_LL_SetTimer>
}
   23a2c:	2000      	movs	r0, #0
   23a2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Error_Handler( );
   23a30:	f7f5 fcee 	bl	19410 <Error_Handler>
   23a34:	e7f3      	b.n	23a1e <USBH_LL_Init+0x36>
   23a36:	bf00      	nop
   23a38:	020fbaa4 	.word	0x020fbaa4
   23a3c:	40080000 	.word	0x40080000

00023a40 <USBH_LL_Start>:
  * @brief  Start the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
{
   23a40:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Start(phost->pData);
   23a42:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23a46:	f7e8 fd2d 	bl	c4a4 <HAL_HCD_Start>
   23a4a:	2803      	cmp	r0, #3
   23a4c:	d802      	bhi.n	23a54 <USBH_LL_Start+0x14>
   23a4e:	4b02      	ldr	r3, [pc, #8]	; (23a58 <USBH_LL_Start+0x18>)
   23a50:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   23a52:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_Start(phost->pData);
   23a54:	2002      	movs	r0, #2
}
   23a56:	bd08      	pop	{r3, pc}
   23a58:	000323a4 	.word	0x000323a4

00023a5c <USBH_LL_Stop>:
  * @brief  Stop the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
{
   23a5c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Stop(phost->pData);
   23a5e:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23a62:	f7e8 fd35 	bl	c4d0 <HAL_HCD_Stop>
   23a66:	2803      	cmp	r0, #3
   23a68:	d802      	bhi.n	23a70 <USBH_LL_Stop+0x14>
   23a6a:	4b02      	ldr	r3, [pc, #8]	; (23a74 <USBH_LL_Stop+0x18>)
   23a6c:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
 
  return usb_status;
}
   23a6e:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_Stop(phost->pData);
   23a70:	2002      	movs	r0, #2
}
   23a72:	bd08      	pop	{r3, pc}
   23a74:	000323a4 	.word	0x000323a4

00023a78 <USBH_LL_GetSpeed>:
  * @brief  Return the USB host speed from the low level driver.
  * @param  phost: Host handle
  * @retval USBH speeds
  */
USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
{
   23a78:	b508      	push	{r3, lr}
  USBH_SpeedTypeDef speed = USBH_SPEED_FULL;

  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
   23a7a:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23a7e:	f7e8 fd4f 	bl	c520 <HAL_HCD_GetCurrentSpeed>
   23a82:	2802      	cmp	r0, #2
   23a84:	d802      	bhi.n	23a8c <USBH_LL_GetSpeed+0x14>
   23a86:	4b02      	ldr	r3, [pc, #8]	; (23a90 <USBH_LL_GetSpeed+0x18>)
   23a88:	5c18      	ldrb	r0, [r3, r0]
  default:
   speed = USBH_SPEED_FULL;
    break;
  }
  return  speed;
}
   23a8a:	bd08      	pop	{r3, pc}
  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
   23a8c:	2001      	movs	r0, #1
}
   23a8e:	bd08      	pop	{r3, pc}
   23a90:	000323a0 	.word	0x000323a0

00023a94 <USBH_LL_ResetPort>:
  * @brief  Reset the Host port of the low level driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef *phost)
{
   23a94:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_ResetPort(phost->pData);
   23a96:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23a9a:	f7e8 fd2b 	bl	c4f4 <HAL_HCD_ResetPort>
   23a9e:	2803      	cmp	r0, #3
   23aa0:	d802      	bhi.n	23aa8 <USBH_LL_ResetPort+0x14>
   23aa2:	4b02      	ldr	r3, [pc, #8]	; (23aac <USBH_LL_ResetPort+0x18>)
   23aa4:	5c18      	ldrb	r0, [r3, r0]
  
  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   23aa6:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_ResetPort(phost->pData);
   23aa8:	2002      	movs	r0, #2
}
   23aaa:	bd08      	pop	{r3, pc}
   23aac:	000323a4 	.word	0x000323a4

00023ab0 <USBH_LL_GetLastXferSize>:
  * @param  pipe: Pipe index
  * @retval Packet size
  */
uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
   23ab0:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23ab4:	f7e8 bd2a 	b.w	c50c <HAL_HCD_HC_GetXferCount>

00023ab8 <USBH_LL_OpenPipe>:
  * @param  mps: Endpoint max packet size
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num, uint8_t epnum,
                                    uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
   23ab8:	b530      	push	{r4, r5, lr}
   23aba:	b085      	sub	sp, #20
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   23abc:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
{
   23ac0:	f89d 4020 	ldrb.w	r4, [sp, #32]
   23ac4:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   23ac8:	9400      	str	r4, [sp, #0]
{
   23aca:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   23ace:	e9cd 5401 	strd	r5, r4, [sp, #4]
   23ad2:	f7e8 fbc9 	bl	c268 <HAL_HCD_HC_Init>
   23ad6:	2803      	cmp	r0, #3
   23ad8:	d803      	bhi.n	23ae2 <USBH_LL_OpenPipe+0x2a>
   23ada:	4b03      	ldr	r3, [pc, #12]	; (23ae8 <USBH_LL_OpenPipe+0x30>)
   23adc:	5c18      	ldrb	r0, [r3, r0]
                               dev_address, speed, ep_type, mps);

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   23ade:	b005      	add	sp, #20
   23ae0:	bd30      	pop	{r4, r5, pc}
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   23ae2:	2002      	movs	r0, #2
}
   23ae4:	b005      	add	sp, #20
   23ae6:	bd30      	pop	{r4, r5, pc}
   23ae8:	000323a4 	.word	0x000323a4

00023aec <USBH_LL_ClosePipe>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)
{
   23aec:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
   23aee:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23af2:	f7e8 fbf5 	bl	c2e0 <HAL_HCD_HC_Halt>
   23af6:	2803      	cmp	r0, #3
   23af8:	d802      	bhi.n	23b00 <USBH_LL_ClosePipe+0x14>
   23afa:	4b02      	ldr	r3, [pc, #8]	; (23b04 <USBH_LL_ClosePipe+0x18>)
   23afc:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   23afe:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
   23b00:	2002      	movs	r0, #2
}
   23b02:	bd08      	pop	{r3, pc}
   23b04:	000323a4 	.word	0x000323a4

00023b08 <USBH_LL_SubmitURB>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t direction,
                                     uint8_t ep_type, uint8_t token, uint8_t *pbuff, uint16_t length,
                                     uint8_t do_ping)
{
   23b08:	b530      	push	{r4, r5, lr}
   23b0a:	b085      	sub	sp, #20
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   23b0c:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
{
   23b10:	f89d 5020 	ldrb.w	r5, [sp, #32]
   23b14:	9c09      	ldr	r4, [sp, #36]	; 0x24
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   23b16:	9500      	str	r5, [sp, #0]
   23b18:	9401      	str	r4, [sp, #4]
{
   23b1a:	f8bd 5028 	ldrh.w	r5, [sp, #40]	; 0x28
   23b1e:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   23b22:	e9cd 5402 	strd	r5, r4, [sp, #8]
   23b26:	f7e8 fc4d 	bl	c3c4 <HAL_HCD_HC_SubmitRequest>
   23b2a:	2803      	cmp	r0, #3
   23b2c:	d803      	bhi.n	23b36 <USBH_LL_SubmitURB+0x2e>
   23b2e:	4b03      	ldr	r3, [pc, #12]	; (23b3c <USBH_LL_SubmitURB+0x34>)
   23b30:	5c18      	ldrb	r0, [r3, r0]
                                        ep_type, token, pbuff, length,
                                        do_ping);
  usb_status =  USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   23b32:	b005      	add	sp, #20
   23b34:	bd30      	pop	{r4, r5, pc}
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   23b36:	2002      	movs	r0, #2
}
   23b38:	b005      	add	sp, #20
   23b3a:	bd30      	pop	{r4, r5, pc}
   23b3c:	000323a4 	.word	0x000323a4

00023b40 <USBH_LL_GetURBState>:
  *            @arg URB_ERROR
  *            @arg URB_STALL
  */
USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
   23b40:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23b44:	f7e8 bcda 	b.w	c4fc <HAL_HCD_HC_GetURBState>

00023b48 <USBH_LL_DriverVBUS>:
  *           0 : VBUS Active
  *           1 : VBUS Inactive
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
{
   23b48:	b508      	push	{r3, lr}
  if (phost->id == HOST_FS) {
   23b4a:	f890 353c 	ldrb.w	r3, [r0, #1340]	; 0x53c
   23b4e:	2b01      	cmp	r3, #1
   23b50:	d004      	beq.n	23b5c <USBH_LL_DriverVBUS+0x14>

  /* USER CODE BEGIN 0 */

  /* USER CODE END 0*/

  HAL_Delay(200);
   23b52:	20c8      	movs	r0, #200	; 0xc8
   23b54:	f7e4 fc54 	bl	8400 <HAL_Delay>
  return USBH_OK;
}
   23b58:	2000      	movs	r0, #0
   23b5a:	bd08      	pop	{r3, pc}
    MX_DriverVbusFS(state);
   23b5c:	4608      	mov	r0, r1
   23b5e:	f000 f819 	bl	23b94 <MX_DriverVbusFS>
  HAL_Delay(200);
   23b62:	20c8      	movs	r0, #200	; 0xc8
   23b64:	f7e4 fc4c 	bl	8400 <HAL_Delay>
}
   23b68:	2000      	movs	r0, #0
   23b6a:	bd08      	pop	{r3, pc}

00023b6c <USBH_LL_SetToggle>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)
{
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
   23b6c:	f8d0 3540 	ldr.w	r3, [r0, #1344]	; 0x540

  if(pHandle->hc[pipe].ep_is_in)
   23b70:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   23b74:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   23b78:	f891 303b 	ldrb.w	r3, [r1, #59]	; 0x3b
   23b7c:	b91b      	cbnz	r3, 23b86 <USBH_LL_SetToggle+0x1a>
  {
    pHandle->hc[pipe].toggle_in = toggle;
  }
  else
  {
    pHandle->hc[pipe].toggle_out = toggle;
   23b7e:	f881 2051 	strb.w	r2, [r1, #81]	; 0x51
  }

  return USBH_OK;
}
   23b82:	2000      	movs	r0, #0
   23b84:	4770      	bx	lr
    pHandle->hc[pipe].toggle_in = toggle;
   23b86:	f881 2050 	strb.w	r2, [r1, #80]	; 0x50
}
   23b8a:	2000      	movs	r0, #0
   23b8c:	4770      	bx	lr
   23b8e:	bf00      	nop

00023b90 <USBH_Delay>:
  * @param  Delay: Delay in ms
  * @retval None
  */
void USBH_Delay(uint32_t Delay)
{
  HAL_Delay(Delay);
   23b90:	f7e4 bc36 	b.w	8400 <HAL_Delay>

00023b94 <MX_DriverVbusFS>:
  {
    /* Drive low Charge pump */
    data = GPIO_PIN_RESET;
  }
  /* USER CODE END PREPARE_GPIO_DATA_VBUS_FS */
  HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,(GPIO_PinState)data);
   23b94:	fab0 f280 	clz	r2, r0
   23b98:	2140      	movs	r1, #64	; 0x40
   23b9a:	4802      	ldr	r0, [pc, #8]	; (23ba4 <MX_DriverVbusFS+0x10>)
   23b9c:	0952      	lsrs	r2, r2, #5
   23b9e:	f7e8 bb49 	b.w	c234 <HAL_GPIO_WritePin>
   23ba2:	bf00      	nop
   23ba4:	58021400 	.word	0x58021400

00023ba8 <mayer_fht>:
 REAL f0,g0,f1,g1,f2,g2,f3,g3; */
 int  k,k1,k2,k3,k4,kx;
 REAL *fi,*fn,*gi;
 TRIG_VARS;

 for (k1=1,k2=0;k1<n;k1++)
   23ba8:	2901      	cmp	r1, #1
{
   23baa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23bae:	ed2d 8b02 	vpush	{d8}
   23bb2:	b08b      	sub	sp, #44	; 0x2c
 for (k1=1,k2=0;k1<n;k1++)
   23bb4:	f340 822d 	ble.w	24012 <mayer_fht+0x46a>
    {
     REAL aa;
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
   23bb8:	ea4f 0c61 	mov.w	ip, r1, asr #1
   23bbc:	1d07      	adds	r7, r0, #4
 for (k1=1,k2=0;k1<n;k1++)
   23bbe:	2400      	movs	r4, #0
   23bc0:	2601      	movs	r6, #1
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
   23bc2:	ea3c 0304 	bics.w	r3, ip, r4
   23bc6:	ea8c 0204 	eor.w	r2, ip, r4
   23bca:	f040 8220 	bne.w	2400e <mayer_fht+0x466>
   23bce:	4663      	mov	r3, ip
   23bd0:	105b      	asrs	r3, r3, #1
   23bd2:	ea83 0402 	eor.w	r4, r3, r2
   23bd6:	ea23 0502 	bic.w	r5, r3, r2
   23bda:	4622      	mov	r2, r4
   23bdc:	2d00      	cmp	r5, #0
   23bde:	d0f7      	beq.n	23bd0 <mayer_fht+0x28>
     if (k1>k2)
   23be0:	42b4      	cmp	r4, r6
   23be2:	da05      	bge.n	23bf0 <mayer_fht+0x48>
        {
             aa=fz[k1];fz[k1]=fz[k2];fz[k2]=aa;
   23be4:	eb00 0384 	add.w	r3, r0, r4, lsl #2
   23be8:	683a      	ldr	r2, [r7, #0]
   23bea:	681d      	ldr	r5, [r3, #0]
   23bec:	603d      	str	r5, [r7, #0]
   23bee:	601a      	str	r2, [r3, #0]
 for (k1=1,k2=0;k1<n;k1++)
   23bf0:	3601      	adds	r6, #1
   23bf2:	3704      	adds	r7, #4
   23bf4:	42b1      	cmp	r1, r6
   23bf6:	d1e4      	bne.n	23bc2 <mayer_fht+0x1a>
        }
    }
 for ( k=0 ; (1<<k)<n ; k++ );
   23bf8:	2300      	movs	r3, #0
   23bfa:	2401      	movs	r4, #1
   23bfc:	3301      	adds	r3, #1
   23bfe:	fa04 f203 	lsl.w	r2, r4, r3
   23c02:	42b2      	cmp	r2, r6
   23c04:	dbfa      	blt.n	23bfc <mayer_fht+0x54>
 k  &= 1;
 if (k==0)
   23c06:	f013 0301 	ands.w	r3, r3, #1
   23c0a:	eb00 0a86 	add.w	sl, r0, r6, lsl #2
   23c0e:	9301      	str	r3, [sp, #4]
   23c10:	f000 8201 	beq.w	24016 <mayer_fht+0x46e>
             fi[1 ] = (f1+f3);
            }
    }
 else
    {
         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)
   23c14:	4550      	cmp	r0, sl
   23c16:	d266      	bcs.n	23ce6 <mayer_fht+0x13e>
   23c18:	f100 0320 	add.w	r3, r0, #32
   23c1c:	f100 0440 	add.w	r4, r0, #64	; 0x40
   23c20:	f1c3 021f 	rsb	r2, r3, #31
   23c24:	4452      	add	r2, sl
   23c26:	f022 021f 	bic.w	r2, r2, #31
             bf0     = (bs1 + bs2);
             bg1     = (bc1 - bc2);     
             bg0     = (bc1 + bc2);
             bf3     = (bs3 - bs4);     
             bf2     = (bs3 + bs4);
             bg3     = SQRT2*bc4;               
   23c2a:	ed9f 3be9 	vldr	d3, [pc, #932]	; 23fd0 <mayer_fht+0x428>
   23c2e:	4422      	add	r2, r4
             bc3     = fi[4 ] - gi[4 ];
   23c30:	ed53 7a03 	vldr	s15, [r3, #-12]
   23c34:	3320      	adds	r3, #32
             bc4     = fi[6 ] - gi[6 ];
   23c36:	ed13 6a0a 	vldr	s12, [r3, #-40]	; 0xffffffd8
   23c3a:	ed13 7a09 	vldr	s14, [r3, #-36]	; 0xffffffdc
             bc3     = fi[4 ] - gi[4 ];
   23c3e:	ed53 6a0c 	vldr	s13, [r3, #-48]	; 0xffffffd0
             bc4     = fi[6 ] - gi[6 ];
   23c42:	ee36 2a47 	vsub.f32	s4, s12, s14
             bc1     = fi[0 ] - gi[0 ];
   23c46:	ed53 5a0f 	vldr	s11, [r3, #-60]	; 0xffffffc4
             bc3     = fi[4 ] - gi[4 ];
   23c4a:	ee36 0ae7 	vsub.f32	s0, s13, s15
             bc2     = fi[2 ] - gi[2 ];
   23c4e:	ed53 4a0e 	vldr	s9, [r3, #-56]	; 0xffffffc8
             bc1     = fi[0 ] - gi[0 ];
   23c52:	ed13 5a10 	vldr	s10, [r3, #-64]	; 0xffffffc0
             bs3     = fi[4 ] + gi[4 ];
   23c56:	ee76 6aa7 	vadd.f32	s13, s13, s15
             bg3     = SQRT2*bc4;               
   23c5a:	eeb7 2ac2 	vcvt.f64.f32	d2, s4
             bc2     = fi[2 ] - gi[2 ];
   23c5e:	ed53 7a0d 	vldr	s15, [r3, #-52]	; 0xffffffcc
             bg2     = SQRT2*bc3;
   23c62:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
             bc1     = fi[0 ] - gi[0 ];
   23c66:	ee75 1a65 	vsub.f32	s3, s10, s11
             bg3     = SQRT2*bc4;               
   23c6a:	ee22 2b03 	vmul.f64	d2, d2, d3
             bg2     = SQRT2*bc3;
   23c6e:	ee20 0b03 	vmul.f64	d0, d0, d3
             bc2     = fi[2 ] - gi[2 ];
   23c72:	ee34 4ae7 	vsub.f32	s8, s9, s15
             bs1     = fi[0 ] + gi[0 ];
   23c76:	ee35 5a25 	vadd.f32	s10, s10, s11
             bg3     = SQRT2*bc4;               
   23c7a:	eeb7 2bc2 	vcvt.f32.f64	s4, d2
             bs2     = fi[2 ] + gi[2 ];
   23c7e:	ee74 5aa7 	vadd.f32	s11, s9, s15
             bg2     = SQRT2*bc3;
   23c82:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
             bs4     = fi[6 ] + gi[6 ];
   23c86:	ee76 7a07 	vadd.f32	s15, s12, s14
             bg0     = (bc1 + bc2);
   23c8a:	ee31 1a84 	vadd.f32	s2, s3, s8
             bg1     = (bc1 - bc2);     
   23c8e:	ee71 4ac4 	vsub.f32	s9, s3, s8
             bf1     = (bs1 - bs2);     
   23c92:	ee35 7a65 	vsub.f32	s14, s10, s11
             bf2     = (bs3 + bs4);
   23c96:	ee36 6aa7 	vadd.f32	s12, s13, s15
             bf0     = (bs1 + bs2);
   23c9a:	ee75 5a25 	vadd.f32	s11, s10, s11
             bf3     = (bs3 - bs4);     
   23c9e:	ee76 7ae7 	vsub.f32	s15, s13, s15
             fi[4 ] = bf0 - bf2;
             fi[0 ] = bf0 + bf2;
             fi[6 ] = bf1 - bf3;
             fi[2 ] = bf1 + bf3;
             gi[4 ] = bg0 - bg2;
   23ca2:	ee31 5a40 	vsub.f32	s10, s2, s0
             gi[0 ] = bg0 + bg2;
             gi[6 ] = bg1 - bg3;
   23ca6:	ee74 6ac2 	vsub.f32	s13, s9, s4
             gi[0 ] = bg0 + bg2;
   23caa:	ee31 0a00 	vadd.f32	s0, s2, s0
             gi[4 ] = bg0 - bg2;
   23cae:	ed03 5a0b 	vstr	s10, [r3, #-44]	; 0xffffffd4
             gi[2 ] = bg1 + bg3;
   23cb2:	ee34 2a82 	vadd.f32	s4, s9, s4
             gi[6 ] = bg1 - bg3;
   23cb6:	ed43 6a09 	vstr	s13, [r3, #-36]	; 0xffffffdc
             fi[4 ] = bf0 - bf2;
   23cba:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[6 ] = bf1 - bf3;
   23cbe:	ee77 6a67 	vsub.f32	s13, s14, s15
             gi[0 ] = bg0 + bg2;
   23cc2:	ed03 0a0f 	vstr	s0, [r3, #-60]	; 0xffffffc4
             fi[0 ] = bf0 + bf2;
   23cc6:	ee35 6a86 	vadd.f32	s12, s11, s12
             gi[2 ] = bg1 + bg3;
   23cca:	ed03 2a0d 	vstr	s4, [r3, #-52]	; 0xffffffcc
             fi[2 ] = bf1 + bf3;
   23cce:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[4 ] = bf0 - bf2;
   23cd2:	ed03 5a0c 	vstr	s10, [r3, #-48]	; 0xffffffd0
             fi[6 ] = bf1 - bf3;
   23cd6:	ed43 6a0a 	vstr	s13, [r3, #-40]	; 0xffffffd8
             fi[0 ] = bf0 + bf2;
   23cda:	ed03 6a10 	vstr	s12, [r3, #-64]	; 0xffffffc0
             fi[2 ] = bf1 + bf3;
   23cde:	ed43 7a0e 	vstr	s15, [r3, #-56]	; 0xffffffc8
         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)
   23ce2:	429a      	cmp	r2, r3
   23ce4:	d1a4      	bne.n	23c30 <mayer_fht+0x88>
            }
    }
 if (n<16) return;
   23ce6:	290f      	cmp	r1, #15
   23ce8:	f340 818c 	ble.w	24004 <mayer_fht+0x45c>
   23cec:	9b01      	ldr	r3, [sp, #4]
   23cee:	3301      	adds	r3, #1
             fi[0 ]  = f0         + f2;
             fi[k3]  = f1         - f3;
             fi[k1]  = f1         + f3;
             g1      = gi[0 ] - gi[k1];
             g0      = gi[0 ] + gi[k1];
             g3      = SQRT2  * gi[k3];
   23cf0:	ed9f 8bb7 	vldr	d8, [pc, #732]	; 23fd0 <mayer_fht+0x428>
   23cf4:	009b      	lsls	r3, r3, #2
   23cf6:	e9cd 0108 	strd	r0, r1, [sp, #32]
   23cfa:	9306      	str	r3, [sp, #24]
     k  += 2;
   23cfc:	9901      	ldr	r1, [sp, #4]
     k1  = 1  << k;
   23cfe:	2501      	movs	r5, #1
             f1      = fi[0 ] - fi[k1];
   23d00:	2204      	movs	r2, #4
             g2      = SQRT2  * gi[k2];
             gi[k2]  = g0         - g2;
             gi[0 ]  = g0         + g2;
             gi[k3]  = g1         - g3;
             gi[k1]  = g1         + g3;
             gi     += k4;
   23d02:	9808      	ldr	r0, [sp, #32]
     k  += 2;
   23d04:	3102      	adds	r1, #2
             gi     += k4;
   23d06:	4603      	mov	r3, r0
     k1  = 1  << k;
   23d08:	408d      	lsls	r5, r1
             f1      = fi[0 ] - fi[k1];
   23d0a:	fa02 f401 	lsl.w	r4, r2, r1
     k  += 2;
   23d0e:	9101      	str	r1, [sp, #4]
     kx  = k1 >> 1;
   23d10:	106f      	asrs	r7, r5, #1
   23d12:	eb00 0e04 	add.w	lr, r0, r4
     k3  = k2 + k1;
   23d16:	eb05 0145 	add.w	r1, r5, r5, lsl #1
             f1      = fi[0 ] - fi[k1];
   23d1a:	9403      	str	r4, [sp, #12]
         gi  = fi + kx;
   23d1c:	eb00 0287 	add.w	r2, r0, r7, lsl #2
     kx  = k1 >> 1;
   23d20:	9702      	str	r7, [sp, #8]
             f3      = fi[k2] - fi[k3];
   23d22:	0089      	lsls	r1, r1, #2
   23d24:	00ee      	lsls	r6, r5, #3
   23d26:	eb02 0c04 	add.w	ip, r2, r4
   23d2a:	460c      	mov	r4, r1
   23d2c:	9105      	str	r1, [sp, #20]
   23d2e:	9604      	str	r6, [sp, #16]
   23d30:	1857      	adds	r7, r2, r1
   23d32:	1906      	adds	r6, r0, r4
   23d34:	4601      	mov	r1, r0
   23d36:	00ec      	lsls	r4, r5, #3
   23d38:	1910      	adds	r0, r2, r4
   23d3a:	4421      	add	r1, r4
     k4  = k2 << 1;
   23d3c:	00ac      	lsls	r4, r5, #2
   23d3e:	9407      	str	r4, [sp, #28]
             gi     += k4;
   23d40:	012c      	lsls	r4, r5, #4
             f1      = fi[0 ] - fi[k1];
   23d42:	ed93 6a00 	vldr	s12, [r3]
             f3      = fi[k2] - fi[k3];
   23d46:	edd6 6a00 	vldr	s13, [r6]
             f1      = fi[0 ] - fi[k1];
   23d4a:	ed9e 7a00 	vldr	s14, [lr]
             f3      = fi[k2] - fi[k3];
   23d4e:	edd1 7a00 	vldr	s15, [r1]
             f0      = fi[0 ] + fi[k1];
   23d52:	ee76 5a07 	vadd.f32	s11, s12, s14
             f1      = fi[0 ] - fi[k1];
   23d56:	ee36 7a47 	vsub.f32	s14, s12, s14
             f2      = fi[k2] + fi[k3];
   23d5a:	ee37 6aa6 	vadd.f32	s12, s15, s13
             f3      = fi[k2] - fi[k3];
   23d5e:	ee77 7ae6 	vsub.f32	s15, s15, s13
             fi[k2]  = f0         - f2;
   23d62:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[k3]  = f1         - f3;
   23d66:	ee77 6a67 	vsub.f32	s13, s14, s15
             fi[0 ]  = f0         + f2;
   23d6a:	ee35 6a86 	vadd.f32	s12, s11, s12
             fi[k1]  = f1         + f3;
   23d6e:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[k2]  = f0         - f2;
   23d72:	ed81 5a00 	vstr	s10, [r1]
   23d76:	4421      	add	r1, r4
             fi[0 ]  = f0         + f2;
   23d78:	ed83 6a00 	vstr	s12, [r3]
             fi     += k4;
   23d7c:	4423      	add	r3, r4
             fi[k3]  = f1         - f3;
   23d7e:	edc6 6a00 	vstr	s13, [r6]
   23d82:	4426      	add	r6, r4
             fi[k1]  = f1         + f3;
   23d84:	edce 7a00 	vstr	s15, [lr]
            } while (fi<fn);
   23d88:	4553      	cmp	r3, sl
             g2      = SQRT2  * gi[k2];
   23d8a:	ed90 5a00 	vldr	s10, [r0]
   23d8e:	44a6      	add	lr, r4
             g3      = SQRT2  * gi[k3];
   23d90:	ed97 7a00 	vldr	s14, [r7]
             g2      = SQRT2  * gi[k2];
   23d94:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
             g1      = gi[0 ] - gi[k1];
   23d98:	ed92 6a00 	vldr	s12, [r2]
             g3      = SQRT2  * gi[k3];
   23d9c:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
             g1      = gi[0 ] - gi[k1];
   23da0:	eddc 6a00 	vldr	s13, [ip]
             g2      = SQRT2  * gi[k2];
   23da4:	ee25 5b08 	vmul.f64	d5, d5, d8
             g3      = SQRT2  * gi[k3];
   23da8:	ee27 7b08 	vmul.f64	d7, d7, d8
             g2      = SQRT2  * gi[k2];
   23dac:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
             g0      = gi[0 ] + gi[k1];
   23db0:	ee76 5a26 	vadd.f32	s11, s12, s13
             g1      = gi[0 ] - gi[k1];
   23db4:	ee76 6a66 	vsub.f32	s13, s12, s13
             g3      = SQRT2  * gi[k3];
   23db8:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
             gi[k2]  = g0         - g2;
   23dbc:	ee35 6ac5 	vsub.f32	s12, s11, s10
             gi[0 ]  = g0         + g2;
   23dc0:	ee35 5a85 	vadd.f32	s10, s11, s10
             gi[k3]  = g1         - g3;
   23dc4:	ee76 7ac7 	vsub.f32	s15, s13, s14
             gi[k1]  = g1         + g3;
   23dc8:	ee36 7a87 	vadd.f32	s14, s13, s14
             gi[k2]  = g0         - g2;
   23dcc:	ed80 6a00 	vstr	s12, [r0]
             gi[0 ]  = g0         + g2;
   23dd0:	ed82 5a00 	vstr	s10, [r2]
   23dd4:	4420      	add	r0, r4
             gi[k3]  = g1         - g3;
   23dd6:	edc7 7a00 	vstr	s15, [r7]
             gi     += k4;
   23dda:	4422      	add	r2, r4
             gi[k1]  = g1         + g3;
   23ddc:	ed8c 7a00 	vstr	s14, [ip]
   23de0:	4427      	add	r7, r4
   23de2:	44a4      	add	ip, r4
            } while (fi<fn);
   23de4:	d3ad      	bcc.n	23d42 <mayer_fht+0x19a>
   23de6:	9e06      	ldr	r6, [sp, #24]
   23de8:	497b      	ldr	r1, [pc, #492]	; (23fd8 <mayer_fht+0x430>)
   23dea:	4632      	mov	r2, r6
   23dec:	487b      	ldr	r0, [pc, #492]	; (23fdc <mayer_fht+0x434>)
   23dee:	f008 fd6d 	bl	2c8cc <memcpy>
   23df2:	4632      	mov	r2, r6
   23df4:	497a      	ldr	r1, [pc, #488]	; (23fe0 <mayer_fht+0x438>)
   23df6:	487b      	ldr	r0, [pc, #492]	; (23fe4 <mayer_fht+0x43c>)
   23df8:	f008 fd68 	bl	2c8cc <memcpy>
     TRIG_INIT(k,c1,s1);
     for (ii=1;ii<kx;ii++)
   23dfc:	9b02      	ldr	r3, [sp, #8]
   23dfe:	2b01      	cmp	r3, #1
   23e00:	f340 80f8 	ble.w	23ff4 <mayer_fht+0x44c>
   23e04:	f06f 4840 	mvn.w	r8, #3221225472	; 0xc0000000
   23e08:	9a08      	ldr	r2, [sp, #32]
        {
         REAL c2,s2;
         TRIG_NEXT(k,c1,s1);
   23e0a:	f04f 0e01 	mov.w	lr, #1
   23e0e:	2300      	movs	r3, #0
   23e10:	44a8      	add	r8, r5
   23e12:	f102 0904 	add.w	r9, r2, #4
   23e16:	f8df b1d8 	ldr.w	fp, [pc, #472]	; 23ff0 <mayer_fht+0x448>
   23e1a:	eb02 0888 	add.w	r8, r2, r8, lsl #2
   23e1e:	9a01      	ldr	r2, [sp, #4]
   23e20:	4871      	ldr	r0, [pc, #452]	; (23fe8 <mayer_fht+0x440>)
   23e22:	1ad2      	subs	r2, r2, r3
   23e24:	0091      	lsls	r1, r2, #2
   23e26:	2a01      	cmp	r2, #1
   23e28:	eb0b 0501 	add.w	r5, fp, r1
   23e2c:	4408      	add	r0, r1
   23e2e:	ed95 2a00 	vldr	s4, [r5]
   23e32:	edd0 2a00 	vldr	s5, [r0]
   23e36:	dd30      	ble.n	23e9a <mayer_fht+0x2f2>
   23e38:	3302      	adds	r3, #2
   23e3a:	fa4e f003 	asr.w	r0, lr, r3
   23e3e:	07c5      	lsls	r5, r0, #31
   23e40:	d504      	bpl.n	23e4c <mayer_fht+0x2a4>
   23e42:	3301      	adds	r3, #1
   23e44:	fa4e f003 	asr.w	r0, lr, r3
   23e48:	07c0      	lsls	r0, r0, #31
   23e4a:	d4fa      	bmi.n	23e42 <mayer_fht+0x29a>
   23e4c:	9801      	ldr	r0, [sp, #4]
   23e4e:	3a01      	subs	r2, #1
   23e50:	4e65      	ldr	r6, [pc, #404]	; (23fe8 <mayer_fht+0x440>)
   23e52:	1ac3      	subs	r3, r0, r3
   23e54:	4865      	ldr	r0, [pc, #404]	; (23fec <mayer_fht+0x444>)
   23e56:	0092      	lsls	r2, r2, #2
   23e58:	4408      	add	r0, r1
   23e5a:	009b      	lsls	r3, r3, #2
   23e5c:	eb0b 0502 	add.w	r5, fp, r2
   23e60:	4432      	add	r2, r6
   23e62:	edd0 7a00 	vldr	s15, [r0]
   23e66:	eb0b 0003 	add.w	r0, fp, r3
   23e6a:	4433      	add	r3, r6
   23e6c:	edd2 6a00 	vldr	s13, [r2]
   23e70:	ed90 6a00 	vldr	s12, [r0]
   23e74:	eb0b 0001 	add.w	r0, fp, r1
   23e78:	edd5 5a00 	vldr	s11, [r5]
   23e7c:	4431      	add	r1, r6
   23e7e:	ed93 7a00 	vldr	s14, [r3]
   23e82:	ee35 6a86 	vadd.f32	s12, s11, s12
   23e86:	ee36 7a87 	vadd.f32	s14, s13, s14
   23e8a:	ee66 6a27 	vmul.f32	s13, s12, s15
   23e8e:	ee67 7a27 	vmul.f32	s15, s14, s15
   23e92:	edc0 6a00 	vstr	s13, [r0]
   23e96:	edc1 7a00 	vstr	s15, [r1]
   23e9a:	9a03      	ldr	r2, [sp, #12]
         c2 = c1*c1 - s1*s1;
   23e9c:	ee22 3a42 	vnmul.f32	s6, s4, s4
         s2 = 2*(c1*s1);
   23ea0:	ee62 3a22 	vmul.f32	s7, s4, s5
             fn = fz + n;
             fi = fz +ii;
   23ea4:	464b      	mov	r3, r9
   23ea6:	eb02 0709 	add.w	r7, r2, r9
   23eaa:	eb02 0608 	add.w	r6, r2, r8
   23eae:	9a05      	ldr	r2, [sp, #20]
         c2 = c1*c1 - s1*s1;
   23eb0:	eea2 3aa2 	vfma.f32	s6, s5, s5
         s2 = 2*(c1*s1);
   23eb4:	ee73 3aa3 	vadd.f32	s7, s7, s7
             gi = fz +k1-ii;
   23eb8:	46c4      	mov	ip, r8
   23eba:	eb02 0509 	add.w	r5, r2, r9
   23ebe:	eb02 0008 	add.w	r0, r2, r8
   23ec2:	9a04      	ldr	r2, [sp, #16]
   23ec4:	4611      	mov	r1, r2
   23ec6:	4442      	add	r2, r8
   23ec8:	4449      	add	r1, r9
                 a       = c2*fi[k1] + s2*gi[k1];
                 f1      = fi[0 ]    - a;
                 f0      = fi[0 ]    + a;
                 g1      = gi[0 ]    - b;
                 g0      = gi[0 ]    + b;
                 b       = s2*fi[k3] - c2*gi[k3];
   23eca:	edd0 4a00 	vldr	s9, [r0]
   23ece:	edd5 7a00 	vldr	s15, [r5]
   23ed2:	ee63 1a64 	vnmul.f32	s3, s6, s9
                 a       = c2*fi[k3] + s2*gi[k3];
                 f3      = fi[k2]    - a;
                 f2      = fi[k2]    + a;
                 g3      = gi[k2]    - b;
   23ed6:	ed92 1a00 	vldr	s2, [r2]
                 a       = c2*fi[k3] + s2*gi[k3];
   23eda:	ee64 4aa3 	vmul.f32	s9, s9, s7
                 b       = s2*fi[k1] - c2*gi[k1];
   23ede:	edd6 5a00 	vldr	s11, [r6]
                 f3      = fi[k2]    - a;
   23ee2:	ed91 6a00 	vldr	s12, [r1]
                 b       = s2*fi[k3] - c2*gi[k3];
   23ee6:	eee7 1aa3 	vfma.f32	s3, s15, s7
                 b       = s2*fi[k1] - c2*gi[k1];
   23eea:	ed97 0a00 	vldr	s0, [r7]
                 a       = c2*fi[k3] + s2*gi[k3];
   23eee:	eee7 4a83 	vfma.f32	s9, s15, s6
                 f1      = fi[0 ]    - a;
   23ef2:	edd3 6a00 	vldr	s13, [r3]
                 a       = c2*fi[k1] + s2*gi[k1];
   23ef6:	ee25 7aa3 	vmul.f32	s14, s11, s7
                 g1      = gi[0 ]    - b;
   23efa:	ed9c 5a00 	vldr	s10, [ip]
                 b       = s2*fi[k1] - c2*gi[k1];
   23efe:	ee63 5a65 	vnmul.f32	s11, s6, s11
                 a       = c2*fi[k1] + s2*gi[k1];
   23f02:	eea0 7a03 	vfma.f32	s14, s0, s6
                 g3      = gi[k2]    - b;
   23f06:	ee31 4a61 	vsub.f32	s8, s2, s3
                 f3      = fi[k2]    - a;
   23f0a:	ee76 7a64 	vsub.f32	s15, s12, s9
                 g2      = gi[k2]    + b;
   23f0e:	ee71 1a21 	vadd.f32	s3, s2, s3
                 b       = s1*f2     - c1*g3;
                 a       = c1*f2     + s1*g3;
   23f12:	ee62 0a04 	vmul.f32	s1, s4, s8
                 f2      = fi[k2]    + a;
   23f16:	ee76 4a24 	vadd.f32	s9, s12, s9
                 b       = s1*f2     - c1*g3;
   23f1a:	ee24 4a62 	vnmul.f32	s8, s8, s5
                 a       = c1*f2     + s1*g3;
   23f1e:	eeb0 1a60 	vmov.f32	s2, s1
                 b       = s2*fi[k1] - c2*gi[k1];
   23f22:	eee0 5a23 	vfma.f32	s11, s0, s7
                 fi[k2]  = f0        - a;
                 fi[0 ]  = f0        + a;
                 gi[k3]  = g1        - b;
                 gi[k1]  = g1        + b;
                 b       = c1*g2     - s1*f3;
                 a       = s1*g2     + c1*f3;
   23f26:	ee22 6aa7 	vmul.f32	s12, s5, s15
                 a       = c1*f2     + s1*g3;
   23f2a:	eea2 1aa4 	vfma.f32	s2, s5, s9
                 b       = s1*f2     - c1*g3;
   23f2e:	eea2 4a24 	vfma.f32	s8, s4, s9
                 b       = c1*g2     - s1*f3;
   23f32:	ee67 7ac2 	vnmul.f32	s15, s15, s4
                 a       = s1*g2     + c1*f3;
   23f36:	eea2 6a21 	vfma.f32	s12, s4, s3
                 b       = c1*g2     - s1*f3;
   23f3a:	eee2 7aa1 	vfma.f32	s15, s5, s3
                 f0      = fi[0 ]    + a;
   23f3e:	ee76 1a87 	vadd.f32	s3, s13, s14
                 b       = s1*f2     - c1*g3;
   23f42:	eef0 4a44 	vmov.f32	s9, s8
                 f1      = fi[0 ]    - a;
   23f46:	ee36 7ac7 	vsub.f32	s14, s13, s14
                 g1      = gi[0 ]    - b;
   23f4a:	ee35 4a65 	vsub.f32	s8, s10, s11
                 g0      = gi[0 ]    + b;
   23f4e:	ee75 6a25 	vadd.f32	s13, s10, s11
                 fi[k2]  = f0        - a;
   23f52:	ee71 5ac1 	vsub.f32	s11, s3, s2
                 fi[0 ]  = f0        + a;
   23f56:	ee31 1a81 	vadd.f32	s2, s3, s2
                 gi[k3]  = g1        - b;
   23f5a:	ee34 5a64 	vsub.f32	s10, s8, s9
                 fi[k2]  = f0        - a;
   23f5e:	edc1 5a00 	vstr	s11, [r1]
                 gi[k1]  = g1        + b;
   23f62:	ee74 4a24 	vadd.f32	s9, s8, s9
                 fi[0 ]  = f0        + a;
   23f66:	ed83 1a00 	vstr	s2, [r3]
                 gi[k2]  = g0        - a;
                 gi[0 ]  = g0        + a;
                 fi[k3]  = f1        - b;
                 fi[k1]  = f1        + b;
                 gi     += k4;
                 fi     += k4;
   23f6a:	4423      	add	r3, r4
                 gi[k2]  = g0        - a;
   23f6c:	ee76 5ac6 	vsub.f32	s11, s13, s12
                 gi[k3]  = g1        - b;
   23f70:	ed80 5a00 	vstr	s10, [r0]
                 gi[0 ]  = g0        + a;
   23f74:	ee36 6a86 	vadd.f32	s12, s13, s12
                } while (fi<fn);
   23f78:	4553      	cmp	r3, sl
                 fi[k3]  = f1        - b;
   23f7a:	ee77 6a67 	vsub.f32	s13, s14, s15
                 gi[k1]  = g1        + b;
   23f7e:	edc6 4a00 	vstr	s9, [r6]
                 fi[k1]  = f1        + b;
   23f82:	ee77 7a27 	vadd.f32	s15, s14, s15
                 gi[k2]  = g0        - a;
   23f86:	edc2 5a00 	vstr	s11, [r2]
   23f8a:	4421      	add	r1, r4
                 gi[0 ]  = g0        + a;
   23f8c:	ed8c 6a00 	vstr	s12, [ip]
   23f90:	4420      	add	r0, r4
                 fi[k3]  = f1        - b;
   23f92:	edc5 6a00 	vstr	s13, [r5]
   23f96:	4426      	add	r6, r4
                 fi[k1]  = f1        + b;
   23f98:	edc7 7a00 	vstr	s15, [r7]
   23f9c:	4422      	add	r2, r4
                 gi     += k4;
   23f9e:	44a4      	add	ip, r4
   23fa0:	4425      	add	r5, r4
   23fa2:	4427      	add	r7, r4
                } while (fi<fn);
   23fa4:	d391      	bcc.n	23eca <mayer_fht+0x322>
     for (ii=1;ii<kx;ii++)
   23fa6:	f10e 0e01 	add.w	lr, lr, #1
   23faa:	9b02      	ldr	r3, [sp, #8]
   23fac:	4573      	cmp	r3, lr
   23fae:	d021      	beq.n	23ff4 <mayer_fht+0x44c>
         TRIG_NEXT(k,c1,s1);
   23fb0:	f01e 0301 	ands.w	r3, lr, #1
   23fb4:	d161      	bne.n	2407a <mayer_fht+0x4d2>
   23fb6:	3301      	adds	r3, #1
   23fb8:	fa4e f203 	asr.w	r2, lr, r3
   23fbc:	07d6      	lsls	r6, r2, #31
   23fbe:	d5fa      	bpl.n	23fb6 <mayer_fht+0x40e>
   23fc0:	f109 0904 	add.w	r9, r9, #4
   23fc4:	f1a8 0804 	sub.w	r8, r8, #4
   23fc8:	e729      	b.n	23e1e <mayer_fht+0x276>
   23fca:	bf00      	nop
   23fcc:	f3af 8000 	nop.w
   23fd0:	667f3bcd 	.word	0x667f3bcd
   23fd4:	3ff6a09e 	.word	0x3ff6a09e
   23fd8:	000323b0 	.word	0x000323b0
   23fdc:	00062854 	.word	0x00062854
   23fe0:	00032450 	.word	0x00032450
   23fe4:	000628a4 	.word	0x000628a4
   23fe8:	0006284c 	.word	0x0006284c
   23fec:	000323f8 	.word	0x000323f8
   23ff0:	0006289c 	.word	0x0006289c
   23ff4:	9b06      	ldr	r3, [sp, #24]
        }
     TRIG_RESET(k,c1,s1);
    } while (k4<n);
   23ff6:	9a07      	ldr	r2, [sp, #28]
   23ff8:	3308      	adds	r3, #8
   23ffa:	9306      	str	r3, [sp, #24]
   23ffc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   23ffe:	4293      	cmp	r3, r2
   24000:	f73f ae7c 	bgt.w	23cfc <mayer_fht+0x154>
}
   24004:	b00b      	add	sp, #44	; 0x2c
   24006:	ecbd 8b02 	vpop	{d8}
   2400a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
   2400e:	4614      	mov	r4, r2
   24010:	e5e6      	b.n	23be0 <mayer_fht+0x38>
   24012:	eb00 0a81 	add.w	sl, r0, r1, lsl #2
         for (fi=fz,fn=fz+n;fi<fn;fi+=4)
   24016:	4550      	cmp	r0, sl
   24018:	d22c      	bcs.n	24074 <mayer_fht+0x4cc>
   2401a:	f100 0310 	add.w	r3, r0, #16
   2401e:	f100 0420 	add.w	r4, r0, #32
   24022:	f1c3 020f 	rsb	r2, r3, #15
   24026:	4452      	add	r2, sl
   24028:	f022 020f 	bic.w	r2, r2, #15
   2402c:	4422      	add	r2, r4
             f1     = fi[0 ]-fi[1 ];
   2402e:	ed13 6a03 	vldr	s12, [r3, #-12]
   24032:	3310      	adds	r3, #16
             f3     = fi[2 ]-fi[3 ];
   24034:	ed53 6a06 	vldr	s13, [r3, #-24]	; 0xffffffe8
             f1     = fi[0 ]-fi[1 ];
   24038:	ed53 5a08 	vldr	s11, [r3, #-32]	; 0xffffffe0
             f3     = fi[2 ]-fi[3 ];
   2403c:	ed53 7a05 	vldr	s15, [r3, #-20]	; 0xffffffec
             f1     = fi[0 ]-fi[1 ];
   24040:	ee35 7ac6 	vsub.f32	s14, s11, s12
             f0     = fi[0 ]+fi[1 ];
   24044:	ee75 5a86 	vadd.f32	s11, s11, s12
             f2     = fi[2 ]+fi[3 ];
   24048:	ee36 6aa7 	vadd.f32	s12, s13, s15
             f3     = fi[2 ]-fi[3 ];
   2404c:	ee76 7ae7 	vsub.f32	s15, s13, s15
             fi[2 ] = (f0-f2);  
   24050:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[3 ] = (f1-f3);  
   24054:	ee77 6a67 	vsub.f32	s13, s14, s15
             fi[0 ] = (f0+f2);
   24058:	ee35 6a86 	vadd.f32	s12, s11, s12
             fi[1 ] = (f1+f3);
   2405c:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[2 ] = (f0-f2);  
   24060:	ed03 5a06 	vstr	s10, [r3, #-24]	; 0xffffffe8
             fi[3 ] = (f1-f3);  
   24064:	ed43 6a05 	vstr	s13, [r3, #-20]	; 0xffffffec
             fi[0 ] = (f0+f2);
   24068:	ed03 6a08 	vstr	s12, [r3, #-32]	; 0xffffffe0
             fi[1 ] = (f1+f3);
   2406c:	ed43 7a07 	vstr	s15, [r3, #-28]	; 0xffffffe4
         for (fi=fz,fn=fz+n;fi<fn;fi+=4)
   24070:	429a      	cmp	r2, r3
   24072:	d1dc      	bne.n	2402e <mayer_fht+0x486>
   24074:	2300      	movs	r3, #0
   24076:	9301      	str	r3, [sp, #4]
   24078:	e635      	b.n	23ce6 <mayer_fht+0x13e>
         TRIG_NEXT(k,c1,s1);
   2407a:	2300      	movs	r3, #0
   2407c:	e7a0      	b.n	23fc0 <mayer_fht+0x418>
   2407e:	bf00      	nop

00024080 <mayer_realfft>:
  real[i] = (q-t)*0.5;  real[j] = (q+t)*0.5;
 }
}

void mayer_realfft(int n, REAL *real)
{
   24080:	b538      	push	{r3, r4, r5, lr}
   24082:	460c      	mov	r4, r1
   24084:	4605      	mov	r5, r0
    REAL a,b;
 int i,j,k;
 mayer_fht(real,n);
   24086:	4601      	mov	r1, r0
   24088:	4620      	mov	r0, r4
   2408a:	f7ff fd8d 	bl	23ba8 <mayer_fht>
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   2408e:	2d00      	cmp	r5, #0
   24090:	bfb4      	ite	lt
   24092:	1c6b      	addlt	r3, r5, #1
   24094:	462b      	movge	r3, r5
   24096:	105b      	asrs	r3, r3, #1
   24098:	2b01      	cmp	r3, #1
   2409a:	dd18      	ble.n	240ce <mayer_realfft+0x4e>
  a = real[i];
  b = real[j];
  real[j] = (a-b)*0.5;
   2409c:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   240a0:	eb04 0085 	add.w	r0, r4, r5, lsl #2
   240a4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   240a8:	1d21      	adds	r1, r4, #4
  a = real[i];
   240aa:	edd1 7a00 	vldr	s15, [r1]
  b = real[j];
   240ae:	ed70 6a01 	vldmdb	r0!, {s13}
  real[j] = (a-b)*0.5;
   240b2:	ee37 7ae6 	vsub.f32	s14, s15, s13
  real[i] = (a+b)*0.5;
   240b6:	ee77 7aa6 	vadd.f32	s15, s15, s13
  real[j] = (a-b)*0.5;
   240ba:	ee27 7a06 	vmul.f32	s14, s14, s12
  real[i] = (a+b)*0.5;
   240be:	ee67 7a86 	vmul.f32	s15, s15, s12
  real[j] = (a-b)*0.5;
   240c2:	ed80 7a00 	vstr	s14, [r0]
  real[i] = (a+b)*0.5;
   240c6:	ece1 7a01 	vstmia	r1!, {s15}
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   240ca:	428b      	cmp	r3, r1
   240cc:	d1ed      	bne.n	240aa <mayer_realfft+0x2a>
 }
}
   240ce:	bd38      	pop	{r3, r4, r5, pc}

000240d0 <mayer_realifft>:

void mayer_realifft(int n, REAL *real)
{
    REAL a,b;
 int i,j,k;
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   240d0:	2800      	cmp	r0, #0
{
   240d2:	b410      	push	{r4}
   240d4:	460c      	mov	r4, r1
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   240d6:	bfb4      	ite	lt
   240d8:	1c41      	addlt	r1, r0, #1
   240da:	4601      	movge	r1, r0
   240dc:	1049      	asrs	r1, r1, #1
   240de:	2901      	cmp	r1, #1
   240e0:	dd12      	ble.n	24108 <mayer_realifft+0x38>
   240e2:	eb04 0181 	add.w	r1, r4, r1, lsl #2
   240e6:	1d23      	adds	r3, r4, #4
   240e8:	eb04 0280 	add.w	r2, r4, r0, lsl #2
  a = real[i];
   240ec:	edd3 7a00 	vldr	s15, [r3]
  b = real[j];
   240f0:	ed32 7a01 	vldmdb	r2!, {s14}
  real[j] = (a-b);
   240f4:	ee77 6ac7 	vsub.f32	s13, s15, s14
  real[i] = (a+b);
   240f8:	ee77 7a87 	vadd.f32	s15, s15, s14
  real[j] = (a-b);
   240fc:	edc2 6a00 	vstr	s13, [r2]
  real[i] = (a+b);
   24100:	ece3 7a01 	vstmia	r3!, {s15}
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   24104:	4299      	cmp	r1, r3
   24106:	d1f1      	bne.n	240ec <mayer_realifft+0x1c>
 }
 mayer_fht(real,n);
   24108:	4601      	mov	r1, r0
   2410a:	4620      	mov	r0, r4
}
   2410c:	f85d 4b04 	ldr.w	r4, [sp], #4
 mayer_fht(real,n);
   24110:	f7ff bd4a 	b.w	23ba8 <mayer_fht>

00024114 <tEnvelopeFollower_init>:
//===========================================================================
/* Envelope Follower */
//===========================================================================

void    tEnvelopeFollower_init(tEnvelopeFollower* const ef, float attackThreshold, float decayCoeff)
{
   24114:	b538      	push	{r3, r4, r5, lr}
    tEnvelopeFollower_initToPool(ef, attackThreshold, decayCoeff, &leaf.mempool);
}

void    tEnvelopeFollower_initToPool    (tEnvelopeFollower* const ef, float attackThreshold, float decayCoeff, tMempool* const mp)
{
    _tMempool* m = *mp;
   24116:	4b0c      	ldr	r3, [pc, #48]	; (24148 <tEnvelopeFollower_init+0x34>)
{
   24118:	4605      	mov	r5, r0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   2411a:	2010      	movs	r0, #16
{
   2411c:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   24120:	699c      	ldr	r4, [r3, #24]
{
   24122:	eef0 8a40 	vmov.f32	s17, s0
   24126:	eeb0 8a60 	vmov.f32	s16, s1
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   2412a:	4621      	mov	r1, r4
   2412c:	f005 fcfc 	bl	29b28 <mpool_alloc>
    e->mempool = m;
    
    e->y = 0.0f;
   24130:	2300      	movs	r3, #0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   24132:	6028      	str	r0, [r5, #0]
    e->mempool = m;
   24134:	6004      	str	r4, [r0, #0]
    e->a_thresh = attackThreshold;
   24136:	edc0 8a02 	vstr	s17, [r0, #8]
    e->d_coeff = decayCoeff;
   2413a:	ed80 8a03 	vstr	s16, [r0, #12]
    e->y = 0.0f;
   2413e:	6043      	str	r3, [r0, #4]
}
   24140:	ecbd 8b02 	vpop	{d8}
   24144:	bd38      	pop	{r3, r4, r5, pc}
   24146:	bf00      	nop
   24148:	020fbd68 	.word	0x020fbd68

0002414c <tEnvelopeFollower_initToPool>:
{
   2414c:	b538      	push	{r3, r4, r5, lr}
   2414e:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   24152:	680c      	ldr	r4, [r1, #0]
{
   24154:	eef0 8a40 	vmov.f32	s17, s0
   24158:	eeb0 8a60 	vmov.f32	s16, s1
   2415c:	4605      	mov	r5, r0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   2415e:	4621      	mov	r1, r4
   24160:	2010      	movs	r0, #16
   24162:	f005 fce1 	bl	29b28 <mpool_alloc>
    e->y = 0.0f;
   24166:	2300      	movs	r3, #0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   24168:	6028      	str	r0, [r5, #0]
    e->mempool = m;
   2416a:	6004      	str	r4, [r0, #0]
    e->a_thresh = attackThreshold;
   2416c:	edc0 8a02 	vstr	s17, [r0, #8]
    e->d_coeff = decayCoeff;
   24170:	ed80 8a03 	vstr	s16, [r0, #12]
    e->y = 0.0f;
   24174:	6043      	str	r3, [r0, #4]
}
   24176:	ecbd 8b02 	vpop	{d8}
   2417a:	bd38      	pop	{r3, r4, r5, pc}

0002417c <tEnvelopeFollower_free>:

void    tEnvelopeFollower_free  (tEnvelopeFollower* const ef)
{
    _tEnvelopeFollower* e = *ef;
   2417c:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)e, e->mempool);
   2417e:	6801      	ldr	r1, [r0, #0]
   24180:	f005 bd7a 	b.w	29c78 <mpool_free>

00024184 <tEnvelopeFollower_tick>:
}

float   tEnvelopeFollower_tick(tEnvelopeFollower* const ef, float x)
{
    _tEnvelopeFollower* e = *ef;
   24184:	6803      	ldr	r3, [r0, #0]
   24186:	eeb0 0ac0 	vabs.f32	s0, s0
    
    if (x < 0.0f ) x = -x;  /* Absolute value. */
    
    if ((x >= e->y) && (x > e->a_thresh)) e->y = x;                      /* If we hit a peak, ride the peak to the top. */
   2418a:	edd3 7a01 	vldr	s15, [r3, #4]
   2418e:	eef4 7ac0 	vcmpe.f32	s15, s0
   24192:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24196:	d814      	bhi.n	241c2 <tEnvelopeFollower_tick+0x3e>
   24198:	ed93 7a02 	vldr	s14, [r3, #8]
   2419c:	eeb4 7ac0 	vcmpe.f32	s14, s0
   241a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   241a4:	d50d      	bpl.n	241c2 <tEnvelopeFollower_tick+0x3e>
    //ef->y = envelope_pow[(uint16_t)(ef->y * (float)UINT16_MAX)] * ef->d_coeff; //not quite the right behavior - too much loss of precision?
    //ef->y = powf(ef->y, 1.000009f) * ef->d_coeff;  // too expensive
    
#ifdef NO_DENORMAL_CHECK
#else
    if( e->y < VSF)   e->y = 0.0f;
   241a6:	eddf 7a0e 	vldr	s15, [pc, #56]	; 241e0 <tEnvelopeFollower_tick+0x5c>
   241aa:	eeb4 0ae7 	vcmpe.f32	s0, s15
   241ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   241b2:	d511      	bpl.n	241d8 <tEnvelopeFollower_tick+0x54>
   241b4:	eddf 7a0b 	vldr	s15, [pc, #44]	; 241e4 <tEnvelopeFollower_tick+0x60>
   241b8:	eeb0 0a67 	vmov.f32	s0, s15
   241bc:	edc3 7a01 	vstr	s15, [r3, #4]
#endif
    return e->y;
}
   241c0:	4770      	bx	lr
    else                                    e->y = e->y * e->d_coeff;    /* Else, exponential decay of output. */
   241c2:	ed93 0a03 	vldr	s0, [r3, #12]
   241c6:	ee27 0a80 	vmul.f32	s0, s15, s0
    if( e->y < VSF)   e->y = 0.0f;
   241ca:	eddf 7a05 	vldr	s15, [pc, #20]	; 241e0 <tEnvelopeFollower_tick+0x5c>
   241ce:	eeb4 0ae7 	vcmpe.f32	s0, s15
   241d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   241d6:	d4ed      	bmi.n	241b4 <tEnvelopeFollower_tick+0x30>
   241d8:	ed83 0a01 	vstr	s0, [r3, #4]
   241dc:	4770      	bx	lr
   241de:	bf00      	nop
   241e0:	006ce3ee 	.word	0x006ce3ee
   241e4:	00000000 	.word	0x00000000

000241e8 <tZeroCrossing_initToPool>:
{
    tZeroCrossing_initToPool   (zc, maxWindowSize, &leaf.mempool);
}

void    tZeroCrossing_initToPool   (tZeroCrossing* const zc, int maxWindowSize, tMempool* const mp)
{
   241e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
   241ea:	6816      	ldr	r6, [r2, #0]
{
   241ec:	460d      	mov	r5, r1
   241ee:	4607      	mov	r7, r0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
   241f0:	2024      	movs	r0, #36	; 0x24
   241f2:	4631      	mov	r1, r6
   241f4:	f005 fc98 	bl	29b28 <mpool_alloc>
    z->mempool = m;

    z->count = 0;
    z->maxWindowSize = maxWindowSize;
    z->currentWindowSize = maxWindowSize;
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   241f8:	ee07 5a90 	vmov	s15, r5
   241fc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
   24200:	4604      	mov	r4, r0
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   24202:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    z->count = 0;
   24206:	2300      	movs	r3, #0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
   24208:	6038      	str	r0, [r7, #0]
    z->position = 0;
    z->prevPosition = maxWindowSize;
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   2420a:	4631      	mov	r1, r6
    z->mempool = m;
   2420c:	6006      	str	r6, [r0, #0]
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   2420e:	eec6 7a87 	vdiv.f32	s15, s13, s14
    z->maxWindowSize = maxWindowSize;
   24212:	6085      	str	r5, [r0, #8]
    z->count = 0;
   24214:	6063      	str	r3, [r4, #4]
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   24216:	00a8      	lsls	r0, r5, #2
    z->position = 0;
   24218:	6223      	str	r3, [r4, #32]
    z->currentWindowSize = maxWindowSize;
   2421a:	60e5      	str	r5, [r4, #12]
    z->prevPosition = maxWindowSize;
   2421c:	61e5      	str	r5, [r4, #28]
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   2421e:	edc4 7a04 	vstr	s15, [r4, #16]
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   24222:	f005 fcd7 	bl	29bd4 <mpool_calloc>
    z->countBuffer = (uint16_t*) mpool_calloc(sizeof(uint16_t) * maxWindowSize, m);
   24226:	4631      	mov	r1, r6
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   24228:	6160      	str	r0, [r4, #20]
    z->countBuffer = (uint16_t*) mpool_calloc(sizeof(uint16_t) * maxWindowSize, m);
   2422a:	0068      	lsls	r0, r5, #1
   2422c:	f005 fcd2 	bl	29bd4 <mpool_calloc>
   24230:	61a0      	str	r0, [r4, #24]
}
   24232:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00024234 <tZeroCrossing_free>:

void    tZeroCrossing_free (tZeroCrossing* const zc)
{
   24234:	b510      	push	{r4, lr}
    _tZeroCrossing* z = *zc;
   24236:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)z->inBuffer, z->mempool);
   24238:	6821      	ldr	r1, [r4, #0]
   2423a:	6960      	ldr	r0, [r4, #20]
   2423c:	f005 fd1c 	bl	29c78 <mpool_free>
    mpool_free((char*)z->countBuffer, z->mempool);
   24240:	6821      	ldr	r1, [r4, #0]
   24242:	69a0      	ldr	r0, [r4, #24]
   24244:	f005 fd18 	bl	29c78 <mpool_free>
    mpool_free((char*)z, z->mempool);
   24248:	6821      	ldr	r1, [r4, #0]
   2424a:	4620      	mov	r0, r4
}
   2424c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)z, z->mempool);
   24250:	f005 bd12 	b.w	29c78 <mpool_free>

00024254 <tZeroCrossing_tick>:

//returns proportion of zero crossings within window size (0.0 would be none in window, 1.0 would be all zero crossings)
float   tZeroCrossing_tick         (tZeroCrossing* const zc, float input)
{
   24254:	b430      	push	{r4, r5}
    _tZeroCrossing* z = *zc;
   24256:	6803      	ldr	r3, [r0, #0]

    z->inBuffer[z->position] = input;
   24258:	6a19      	ldr	r1, [r3, #32]
   2425a:	695a      	ldr	r2, [r3, #20]
   2425c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   24260:	ed82 0a00 	vstr	s0, [r2]
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   24264:	6a18      	ldr	r0, [r3, #32]
    float output = 0.0f;

    //add new value to count
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   24266:	695a      	ldr	r2, [r3, #20]
   24268:	69dc      	ldr	r4, [r3, #28]
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   2426a:	1c45      	adds	r5, r0, #1
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   2426c:	eb02 0180 	add.w	r1, r2, r0, lsl #2
   24270:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   24274:	68dc      	ldr	r4, [r3, #12]
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   24276:	ed91 7a00 	vldr	s14, [r1]
   2427a:	edd2 7a00 	vldr	s15, [r2]
    {
        //zero crossing happened, add it to the count array
        z->countBuffer[z->position] = 1;
   2427e:	699a      	ldr	r2, [r3, #24]
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   24280:	ee67 7a87 	vmul.f32	s15, s15, s14
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   24284:	fb95 f1f4 	sdiv	r1, r5, r4
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   24288:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   2428c:	fb04 5111 	mls	r1, r4, r1, r5
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   24290:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24294:	d41c      	bmi.n	242d0 <tZeroCrossing_tick+0x7c>
        z->count++;
    }
    else
    {
        z->countBuffer[z->position] = 0;
   24296:	2400      	movs	r4, #0
   24298:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
   2429c:	685a      	ldr	r2, [r3, #4]
    }

    //remove oldest value from count
    if (z->countBuffer[futurePosition] > 0)
   2429e:	6998      	ldr	r0, [r3, #24]
   242a0:	f830 0011 	ldrh.w	r0, [r0, r1, lsl #1]
   242a4:	b110      	cbz	r0, 242ac <tZeroCrossing_tick+0x58>
    {
        z->count--;
        if (z->count < 0)
   242a6:	3a01      	subs	r2, #1
   242a8:	d40d      	bmi.n	242c6 <tZeroCrossing_tick+0x72>
        z->count--;
   242aa:	605a      	str	r2, [r3, #4]
   242ac:	ee07 2a90 	vmov	s15, r2
   242b0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        {
            z->count = 0;
        }
    }

    z->prevPosition = z->position;
   242b4:	6a1a      	ldr	r2, [r3, #32]
    z->position = futurePosition;

    output = z->count * z->invCurrentWindowSize;
   242b6:	ed93 0a04 	vldr	s0, [r3, #16]
    z->position = futurePosition;
   242ba:	e9c3 2107 	strd	r2, r1, [r3, #28]

    return output;
}
   242be:	ee27 0a80 	vmul.f32	s0, s15, s0
   242c2:	bc30      	pop	{r4, r5}
   242c4:	4770      	bx	lr
            z->count = 0;
   242c6:	2200      	movs	r2, #0
   242c8:	eddf 7a05 	vldr	s15, [pc, #20]	; 242e0 <tZeroCrossing_tick+0x8c>
   242cc:	605a      	str	r2, [r3, #4]
   242ce:	e7f1      	b.n	242b4 <tZeroCrossing_tick+0x60>
        z->countBuffer[z->position] = 1;
   242d0:	2401      	movs	r4, #1
   242d2:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
        z->count++;
   242d6:	685a      	ldr	r2, [r3, #4]
   242d8:	4422      	add	r2, r4
   242da:	605a      	str	r2, [r3, #4]
   242dc:	e7df      	b.n	2429e <tZeroCrossing_tick+0x4a>
   242de:	bf00      	nop
   242e0:	00000000 	.word	0x00000000

000242e4 <tPowerFollower_initToPool>:
{
    tPowerFollower_initToPool(pf, factor, &leaf.mempool);
}

void    tPowerFollower_initToPool   (tPowerFollower* const pf, float factor, tMempool* const mp)
{
   242e4:	b538      	push	{r3, r4, r5, lr}
   242e6:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   242ea:	680c      	ldr	r4, [r1, #0]
{
   242ec:	4605      	mov	r5, r0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
   242ee:	2010      	movs	r0, #16
{
   242f0:	eeb0 8a40 	vmov.f32	s16, s0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
   242f4:	4621      	mov	r1, r4
   242f6:	f005 fc17 	bl	29b28 <mpool_alloc>
    p->mempool = m;
    
    p->curr=0.0f;
    p->factor=factor;
    p->oneminusfactor=1.0f-factor;
   242fa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    p->curr=0.0f;
   242fe:	2300      	movs	r3, #0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
   24300:	6028      	str	r0, [r5, #0]
    p->mempool = m;
   24302:	6004      	str	r4, [r0, #0]
    p->oneminusfactor=1.0f-factor;
   24304:	ee77 7ac8 	vsub.f32	s15, s15, s16
    p->factor=factor;
   24308:	ed80 8a01 	vstr	s16, [r0, #4]
    p->curr=0.0f;
   2430c:	60c3      	str	r3, [r0, #12]
    p->oneminusfactor=1.0f-factor;
   2430e:	edc0 7a02 	vstr	s15, [r0, #8]
}
   24312:	ecbd 8b02 	vpop	{d8}
   24316:	bd38      	pop	{r3, r4, r5, pc}

00024318 <tPowerFollower_free>:

void    tPowerFollower_free (tPowerFollower* const pf)
{
    _tPowerFollower* p = *pf;
   24318:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)p, p->mempool);
   2431a:	6801      	ldr	r1, [r0, #0]
   2431c:	f005 bcac 	b.w	29c78 <mpool_free>

00024320 <tPowerFollower_tick>:
    return 0;
}

float   tPowerFollower_tick(tPowerFollower* const pf, float input)
{
    _tPowerFollower* p = *pf;
   24320:	6803      	ldr	r3, [r0, #0]
    p->curr = p->factor*input*input+p->oneminusfactor*p->curr;
   24322:	ee20 7a00 	vmul.f32	s14, s0, s0
   24326:	edd3 7a02 	vldr	s15, [r3, #8]
   2432a:	ed93 0a03 	vldr	s0, [r3, #12]
   2432e:	edd3 6a01 	vldr	s13, [r3, #4]
   24332:	ee27 0a80 	vmul.f32	s0, s15, s0
   24336:	eea6 0a87 	vfma.f32	s0, s13, s14
   2433a:	ed83 0a03 	vstr	s0, [r3, #12]
    return p->curr;
}
   2433e:	4770      	bx	lr

00024340 <tEnvPD_initToPool>:
{
    tEnvPD_initToPool(xpd, ws, hs, bs, &leaf.mempool);
}

void    tEnvPD_initToPool       (tEnvPD* const xpd, int ws, int hs, int bs, tMempool* const mp)
{
   24340:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24344:	ed2d 8b04 	vpush	{d8-d9}
   24348:	b083      	sub	sp, #12
   2434a:	4688      	mov	r8, r1
   2434c:	4605      	mov	r5, r0
    _tMempool* m = *mp;
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
   2434e:	f241 109c 	movw	r0, #4508	; 0x119c
{
   24352:	9c10      	ldr	r4, [sp, #64]	; 0x40
   24354:	4616      	mov	r6, r2
   24356:	461f      	mov	r7, r3
    _tMempool* m = *mp;
   24358:	6824      	ldr	r4, [r4, #0]
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
   2435a:	4621      	mov	r1, r4
   2435c:	f005 fc3a 	bl	29bd4 <mpool_calloc>
    
    int period = hs, npoints = ws;
    
    int i;
    
    if (npoints < 1) npoints = 1024;
   24360:	f1b8 0f00 	cmp.w	r8, #0
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
   24364:	6028      	str	r0, [r5, #0]
   24366:	4682      	mov	sl, r0
    x->mempool = m;
   24368:	6004      	str	r4, [r0, #0]
    if (npoints < 1) npoints = 1024;
   2436a:	f340 8081 	ble.w	24470 <tEnvPD_initToPool+0x130>
   2436e:	ee07 8a90 	vmov	s15, r8
   24372:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   24376:	f108 033f 	add.w	r3, r8, #63	; 0x3f
   2437a:	ea4f 1168 	mov.w	r1, r8, asr #5
   2437e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   24382:	fa1f f288 	uxth.w	r2, r8
   24386:	9301      	str	r3, [sp, #4]
   24388:	ee87 8a27 	vdiv.f32	s16, s14, s15
    if (period < 1) period = npoints/2;
   2438c:	2e00      	cmp	r6, #0
    if (period < npoints / MAXOVERLAP + 1)
        period = npoints / MAXOVERLAP + 1;
    
    x->x_npoints = npoints;
    x->x_phase = 0;
    x->x_period = period;
   2438e:	f241 1506 	movw	r5, #4358	; 0x1106
    
    x->windowSize = npoints;
    x->hopSize = period;
    x->blockSize = bs;
   24392:	f241 1498 	movw	r4, #4504	; 0x1198
    x->x_npoints = npoints;
   24396:	f241 100a 	movw	r0, #4362	; 0x110a
    if (period < 1) period = npoints/2;
   2439a:	bfd8      	it	le
   2439c:	ea4f 0668 	movle.w	r6, r8, asr #1
   243a0:	ed9f 9a38 	vldr	s18, [pc, #224]	; 24484 <tEnvPD_initToPool+0x144>
    x->blockSize = bs;
   243a4:	b2bf      	uxth	r7, r7
    if (period < npoints / MAXOVERLAP + 1)
   243a6:	428e      	cmp	r6, r1
   243a8:	ea4f 0b88 	mov.w	fp, r8, lsl #2
        period = npoints / MAXOVERLAP + 1;
   243ac:	bfd8      	it	le
   243ae:	1c4e      	addle	r6, r1, #1
    x->hopSize = period;
   243b0:	f241 1196 	movw	r1, #4502	; 0x1196
    x->x_period = period;
   243b4:	b2b6      	uxth	r6, r6
   243b6:	f82a 6005 	strh.w	r6, [sl, r5]
    x->x_phase = 0;
   243ba:	f241 1504 	movw	r5, #4356	; 0x1104
    x->hopSize = period;
   243be:	f82a 6001 	strh.w	r6, [sl, r1]
    x->x_phase = 0;
   243c2:	2100      	movs	r1, #0
    x->blockSize = bs;
   243c4:	f82a 7004 	strh.w	r7, [sl, r4]
    x->windowSize = npoints;
   243c8:	f241 1494 	movw	r4, #4500	; 0x1194
    x->x_npoints = npoints;
   243cc:	f82a 2000 	strh.w	r2, [sl, r0]
   243d0:	f241 1010 	movw	r0, #4368	; 0x1110
    x->x_phase = 0;
   243d4:	f82a 1005 	strh.w	r1, [sl, r5]
    
    for (i = 0; i < MAXOVERLAP; i++) x->x_sumbuf[i] = 0;
    for (i = 0; i < npoints; i++)
   243d8:	460d      	mov	r5, r1
    x->windowSize = npoints;
   243da:	f82a 2004 	strh.w	r2, [sl, r4]
   243de:	4450      	add	r0, sl
   243e0:	2280      	movs	r2, #128	; 0x80
   243e2:	f10a 0404 	add.w	r4, sl, #4
   243e6:	f008 fa7c 	bl	2c8e2 <memset>
    for (i = 0; i < MAXOVERLAP; i++) x->x_sumbuf[i] = 0;
   243ea:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   243ee:	eb04 090b 	add.w	r9, r4, fp
        x->buf[i] = (1.0f - cosf((2 * PI * i) / npoints))/npoints;
   243f2:	eef0 8a40 	vmov.f32	s17, s0
   243f6:	e001      	b.n	243fc <tEnvPD_initToPool+0xbc>
   243f8:	f008 fb9c 	bl	2cb34 <cosf>
    for (i = 0; i < npoints; i++)
   243fc:	3501      	adds	r5, #1
        x->buf[i] = (1.0f - cosf((2 * PI * i) / npoints))/npoints;
   243fe:	ee38 0ac0 	vsub.f32	s0, s17, s0
   24402:	ee07 5a90 	vmov	s15, r5
   24406:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   2440a:	ee60 7a08 	vmul.f32	s15, s0, s16
   2440e:	ee27 0a09 	vmul.f32	s0, s14, s18
   24412:	ece4 7a01 	vstmia	r4!, {s15}
    for (i = 0; i < npoints; i++)
   24416:	45a1      	cmp	r9, r4
   24418:	ee20 0a08 	vmul.f32	s0, s0, s16
   2441c:	d1ec      	bne.n	243f8 <tEnvPD_initToPool+0xb8>
    for (; i < npoints+INITVSTAKEN; i++) x->buf[i] = 0;
   2441e:	9b01      	ldr	r3, [sp, #4]
   24420:	4598      	cmp	r8, r3
   24422:	dc09      	bgt.n	24438 <tEnvPD_initToPool+0xf8>
   24424:	3301      	adds	r3, #1
   24426:	f10b 0004 	add.w	r0, fp, #4
   2442a:	2100      	movs	r1, #0
   2442c:	eba3 0208 	sub.w	r2, r3, r8
   24430:	4450      	add	r0, sl
   24432:	0092      	lsls	r2, r2, #2
   24434:	f008 fa55 	bl	2c8e2 <memset>
    
    x->x_f = 0;
   24438:	f241 1190 	movw	r1, #4496	; 0x1190
   2443c:	2500      	movs	r5, #0
    
    x->x_allocforvs = INITVSTAKEN;
   2443e:	f241 109a 	movw	r0, #4506	; 0x119a
   24442:	2440      	movs	r4, #64	; 0x40
    x->x_f = 0;
   24444:	4451      	add	r1, sl
    
    // ~ ~ ~ dsp ~ ~ ~
    if (x->x_period % x->blockSize)
   24446:	fbb6 f2f7 	udiv	r2, r6, r7
   2444a:	fb07 6212 	mls	r2, r7, r2, r6
    x->x_f = 0;
   2444e:	600d      	str	r5, [r1, #0]
    if (x->x_period % x->blockSize)
   24450:	b292      	uxth	r2, r2
    x->x_allocforvs = INITVSTAKEN;
   24452:	f82a 4000 	strh.w	r4, [sl, r0]
    if (x->x_period % x->blockSize)
   24456:	b112      	cbz	r2, 2445e <tEnvPD_initToPool+0x11e>
    {
        x->x_realperiod = x->x_period + x->blockSize - (x->x_period % x->blockSize);
   24458:	443e      	add	r6, r7
   2445a:	1ab2      	subs	r2, r6, r2
   2445c:	b296      	uxth	r6, r2
   2445e:	f241 1208 	movw	r2, #4360	; 0x1108
   24462:	f82a 6002 	strh.w	r6, [sl, r2]
    else
    {
        x->x_realperiod = x->x_period;
    }
    // ~ ~ ~ ~ ~ ~ ~ ~
}
   24466:	b003      	add	sp, #12
   24468:	ecbd 8b04 	vpop	{d8-d9}
   2446c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24470:	f44f 6280 	mov.w	r2, #1024	; 0x400
   24474:	f240 433f 	movw	r3, #1087	; 0x43f
   24478:	ed9f 8a03 	vldr	s16, [pc, #12]	; 24488 <tEnvPD_initToPool+0x148>
   2447c:	2120      	movs	r1, #32
   2447e:	9301      	str	r3, [sp, #4]
    if (npoints < 1) npoints = 1024;
   24480:	4690      	mov	r8, r2
   24482:	e783      	b.n	2438c <tEnvPD_initToPool+0x4c>
   24484:	40c90fdb 	.word	0x40c90fdb
   24488:	3a800000 	.word	0x3a800000

0002448c <tEnvPD_tick>:
}

float tEnvPD_tick (tEnvPD* const xpd)
{
    _tEnvPD* x = *xpd;
    return powtodb(x->x_result);
   2448c:	6802      	ldr	r2, [r0, #0]
   2448e:	f241 130c 	movw	r3, #4364	; 0x110c
   24492:	4413      	add	r3, r2
   24494:	ed93 0a00 	vldr	s0, [r3]
   24498:	f005 bada 	b.w	29a50 <powtodb>

0002449c <tSNAC_initToPool>:
{
    tSNAC_initToPool(snac, overlaparg, &leaf.mempool);
}

void    tSNAC_initToPool    (tSNAC* const snac, int overlaparg, tMempool* const mp)
{
   2449c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   244a0:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   244a4:	6815      	ldr	r5, [r2, #0]
{
   244a6:	4680      	mov	r8, r0
   244a8:	460f      	mov	r7, r1
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   244aa:	202c      	movs	r0, #44	; 0x2c
   244ac:	4629      	mov	r1, r5
    s->mempool = m;
    
    s->biasfactor = DEFBIAS;
    s->timeindex = 0;
    s->periodindex = 0;
    s->periodlength = 0.;
   244ae:	ed9f 8a40 	vldr	s16, [pc, #256]	; 245b0 <tSNAC_initToPool+0x114>
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   244b2:	f005 fb39 	bl	29b28 <mpool_alloc>
    s->fidelity = 0.;
    s->minrms = DEFMINRMS;
   244b6:	4a3f      	ldr	r2, [pc, #252]	; (245b4 <tSNAC_initToPool+0x118>)
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   244b8:	4604      	mov	r4, r0
    s->timeindex = 0;
   244ba:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    s->biasfactor = DEFBIAS;
   244be:	483e      	ldr	r0, [pc, #248]	; (245b8 <tSNAC_initToPool+0x11c>)
    s->periodindex = 0;
   244c0:	2100      	movs	r1, #0
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   244c2:	f8c8 4000 	str.w	r4, [r8]
    s->minrms = DEFMINRMS;
   244c6:	62a2      	str	r2, [r4, #40]	; 0x28
    s->timeindex = 0;
   244c8:	6163      	str	r3, [r4, #20]
    s->biasfactor = DEFBIAS;
   244ca:	6260      	str	r0, [r4, #36]	; 0x24
    s->framesize = SNAC_FRAME_SIZE;

    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   244cc:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    s->periodindex = 0;
   244d0:	8361      	strh	r1, [r4, #26]
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   244d2:	4629      	mov	r1, r5
    s->mempool = m;
   244d4:	6025      	str	r5, [r4, #0]
    s->periodlength = 0.;
   244d6:	ed84 8a07 	vstr	s16, [r4, #28]
    s->fidelity = 0.;
   244da:	ed84 8a08 	vstr	s16, [r4, #32]
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   244de:	f005 fb79 	bl	29bd4 <mpool_calloc>
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
   244e2:	4629      	mov	r1, r5
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   244e4:	6060      	str	r0, [r4, #4]
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
   244e6:	f44f 5000 	mov.w	r0, #8192	; 0x2000
   244ea:	f005 fb73 	bl	29bd4 <mpool_calloc>
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
   244ee:	4629      	mov	r1, r5
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
   244f0:	60a0      	str	r0, [r4, #8]
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
   244f2:	f44f 6000 	mov.w	r0, #2048	; 0x800
   244f6:	f005 fb6d 	bl	29bd4 <mpool_calloc>
    s->biasbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   244fa:	4629      	mov	r1, r5
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
   244fc:	60e0      	str	r0, [r4, #12]
    s->biasbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   244fe:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   24502:	f005 fb67 	bl	29bd4 <mpool_calloc>
   24506:	6120      	str	r0, [r4, #16]
    
    snac_biasbuf(snac);
   24508:	f8d8 4000 	ldr.w	r4, [r8]
static void snac_biasbuf(tSNAC* const snac)
{
    _tSNAC* s = *snac;
    
    int n;
    int maxperiod = (int)(s->framesize * (float)SEEK);
   2450c:	ed9f 7a2b 	vldr	s14, [pc, #172]	; 245bc <tSNAC_initToPool+0x120>
   24510:	8ae3      	ldrh	r3, [r4, #22]
   24512:	ee07 3a90 	vmov	s15, r3
   24516:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2451a:	ee67 7a87 	vmul.f32	s15, s15, s14
   2451e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   24522:	ee17 6a90 	vmov	r6, s15
    float bias = s->biasfactor / logf((float)(maxperiod - 4));
   24526:	1f33      	subs	r3, r6, #4
   24528:	ee00 3a10 	vmov	s0, r3
   2452c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   24530:	f008 fbc6 	bl	2ccc0 <logf>
   24534:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    for(n=0; n<5; n++)    // periods < 5 samples can't be tracked
    {
        biasbuf[n] = 0.0f;
    }
    
    for(n=5; n<maxperiod; n++)
   24538:	2e05      	cmp	r6, #5
    float *biasbuf = s->biasbuf;
   2453a:	6924      	ldr	r4, [r4, #16]
    float bias = s->biasfactor / logf((float)(maxperiod - 4));
   2453c:	eec7 8a80 	vdiv.f32	s17, s15, s0
        biasbuf[n] = 0.0f;
   24540:	ed84 8a00 	vstr	s16, [r4]
   24544:	ed84 8a01 	vstr	s16, [r4, #4]
   24548:	ed84 8a02 	vstr	s16, [r4, #8]
   2454c:	ed84 8a03 	vstr	s16, [r4, #12]
   24550:	ed84 8a04 	vstr	s16, [r4, #16]
    for(n=5; n<maxperiod; n++)
   24554:	dd17      	ble.n	24586 <tSNAC_initToPool+0xea>
   24556:	eb04 0686 	add.w	r6, r4, r6, lsl #2
    {
        biasbuf[n] = 1.0f - (float)logf(n - 4) * bias;
   2455a:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   2455e:	3414      	adds	r4, #20
    for(n=5; n<maxperiod; n++)
   24560:	eeb0 0a48 	vmov.f32	s0, s16
   24564:	2502      	movs	r5, #2
   24566:	e001      	b.n	2456c <tSNAC_initToPool+0xd0>
   24568:	f008 fbaa 	bl	2ccc0 <logf>
        biasbuf[n] = 1.0f - (float)logf(n - 4) * bias;
   2456c:	eef0 7a49 	vmov.f32	s15, s18
   24570:	ee07 5a10 	vmov	s14, r5
   24574:	3501      	adds	r5, #1
   24576:	eee0 7a68 	vfms.f32	s15, s0, s17
   2457a:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
   2457e:	ece4 7a01 	vstmia	r4!, {s15}
    for(n=5; n<maxperiod; n++)
   24582:	42b4      	cmp	r4, r6
   24584:	d1f0      	bne.n	24568 <tSNAC_initToPool+0xcc>
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
   24586:	2f08      	cmp	r7, #8
    _tSNAC* s = *snac;
   24588:	f8d8 2000 	ldr.w	r2, [r8]
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
   2458c:	d905      	bls.n	2459a <tSNAC_initToPool+0xfe>
   2458e:	2701      	movs	r7, #1
    s->overlap = lap;
   24590:	8317      	strh	r7, [r2, #24]
}
   24592:	ecbd 8b04 	vpop	{d8-d9}
   24596:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
   2459a:	f44f 738b 	mov.w	r3, #278	; 0x116
   2459e:	40fb      	lsrs	r3, r7
   245a0:	07db      	lsls	r3, r3, #31
   245a2:	d5f4      	bpl.n	2458e <tSNAC_initToPool+0xf2>
   245a4:	b2bf      	uxth	r7, r7
    s->overlap = lap;
   245a6:	8317      	strh	r7, [r2, #24]
}
   245a8:	ecbd 8b04 	vpop	{d8-d9}
   245ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   245b0:	00000000 	.word	0x00000000
   245b4:	3b449ba6 	.word	0x3b449ba6
   245b8:	3e4ccccd 	.word	0x3e4ccccd
   245bc:	3f59999a 	.word	0x3f59999a

000245c0 <tSNAC_ioSamples>:
{
   245c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   245c4:	ed2d 8b02 	vpush	{d8}
   245c8:	b08b      	sub	sp, #44	; 0x2c
   245ca:	460d      	mov	r5, r1
   245cc:	9204      	str	r2, [sp, #16]
    _tSNAC* s = *snac;
   245ce:	6802      	ldr	r2, [r0, #0]
{
   245d0:	9002      	str	r0, [sp, #8]
   245d2:	9301      	str	r3, [sp, #4]
    int mask = s->framesize - 1;
   245d4:	8ad0      	ldrh	r0, [r2, #22]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
   245d6:	8b13      	ldrh	r3, [r2, #24]
    int timeindex = s->timeindex;
   245d8:	8a94      	ldrh	r4, [r2, #20]
    int mask = s->framesize - 1;
   245da:	1e46      	subs	r6, r0, #1
    _tSNAC* s = *snac;
   245dc:	9203      	str	r2, [sp, #12]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
   245de:	fbb0 f3f3 	udiv	r3, r0, r3
   245e2:	3b01      	subs	r3, #1
   245e4:	4023      	ands	r3, r4
    float *processbuf = s->processbuf;
   245e6:	e9d2 7801 	ldrd	r7, r8, [r2, #4]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
   245ea:	9305      	str	r3, [sp, #20]
   245ec:	d019      	beq.n	24622 <tSNAC_ioSamples+0x62>
    while(size--)
   245ee:	9b01      	ldr	r3, [sp, #4]
   245f0:	b183      	cbz	r3, 24614 <tSNAC_ioSamples+0x54>
   245f2:	9a04      	ldr	r2, [sp, #16]
   245f4:	eb05 0c83 	add.w	ip, r5, r3, lsl #2
        inputbuf[timeindex] = *in++;
   245f8:	00a3      	lsls	r3, r4, #2
   245fa:	f855 0b04 	ldr.w	r0, [r5], #4
        out[outindex++] = processbuf[timeindex++];
   245fe:	3401      	adds	r4, #1
        inputbuf[timeindex] = *in++;
   24600:	18f9      	adds	r1, r7, r3
        out[outindex++] = processbuf[timeindex++];
   24602:	4443      	add	r3, r8
    while(size--)
   24604:	4565      	cmp	r5, ip
        timeindex &= mask;
   24606:	ea04 0406 	and.w	r4, r4, r6
        inputbuf[timeindex] = *in++;
   2460a:	6008      	str	r0, [r1, #0]
        out[outindex++] = processbuf[timeindex++];
   2460c:	681b      	ldr	r3, [r3, #0]
   2460e:	f842 3b04 	str.w	r3, [r2], #4
    while(size--)
   24612:	d1f1      	bne.n	245f8 <tSNAC_ioSamples+0x38>
    s->timeindex = timeindex;
   24614:	9b03      	ldr	r3, [sp, #12]
   24616:	829c      	strh	r4, [r3, #20]
}
   24618:	b00b      	add	sp, #44	; 0x2c
   2461a:	ecbd 8b02 	vpop	{d8}
   2461e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    float norm = 1. / sqrt((float)(framesize * 2));
   24622:	ea4f 0e40 	mov.w	lr, r0, lsl #1
   24626:	eeb7 5b00 	vmov.f64	d5, #112	; 0x3f800000  1.0
   2462a:	ee07 ea90 	vmov	s15, lr
   2462e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   24632:	eeb1 6bc7 	vsqrt.f64	d6, d7
   24636:	ee85 7b06 	vdiv.f64	d7, d5, d6
   2463a:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    for(n=0; n<framesize; n++)
   2463e:	b178      	cbz	r0, 24660 <tSNAC_ioSamples+0xa0>
   24640:	4642      	mov	r2, r8
   24642:	eb08 0c80 	add.w	ip, r8, r0, lsl #2
    int timeindex = s->timeindex;
   24646:	4623      	mov	r3, r4
        processbuf[n] = inputbuf[tindex] * norm;
   24648:	eb07 0183 	add.w	r1, r7, r3, lsl #2
        tindex++;
   2464c:	3301      	adds	r3, #1
        processbuf[n] = inputbuf[tindex] * norm;
   2464e:	edd1 7a00 	vldr	s15, [r1]
        tindex &= mask;
   24652:	4033      	ands	r3, r6
        processbuf[n] = inputbuf[tindex] * norm;
   24654:	ee67 7a87 	vmul.f32	s15, s15, s14
   24658:	ece2 7a01 	vstmia	r2!, {s15}
    for(n=0; n<framesize; n++)
   2465c:	4594      	cmp	ip, r2
   2465e:	d1f3      	bne.n	24648 <tSNAC_ioSamples+0x88>
    for(n=framesize; n<(framesize<<1); n++) processbuf[n] = 0.;
   24660:	4570      	cmp	r0, lr
   24662:	da07      	bge.n	24674 <tSNAC_ioSamples+0xb4>
   24664:	ebae 0200 	sub.w	r2, lr, r0
   24668:	2100      	movs	r1, #0
   2466a:	eb08 0080 	add.w	r0, r8, r0, lsl #2
   2466e:	0092      	lsls	r2, r2, #2
   24670:	f008 f937 	bl	2c8e2 <memset>
    snac_autocorrelation(snac);
   24674:	9b02      	ldr	r3, [sp, #8]
   24676:	681b      	ldr	r3, [r3, #0]
    int framesize = s->framesize;
   24678:	f8b3 9016 	ldrh.w	r9, [r3, #22]
    float *processbuf = s->processbuf;
   2467c:	f8d3 a008 	ldr.w	sl, [r3, #8]
    int fftsize = framesize * 2;
   24680:	ea4f 0b49 	mov.w	fp, r9, lsl #1
    float *spectrumbuf = s->spectrumbuf;
   24684:	68db      	ldr	r3, [r3, #12]
    REALFFT(fftsize, processbuf);
   24686:	4651      	mov	r1, sl
   24688:	4658      	mov	r0, fp
    float *spectrumbuf = s->spectrumbuf;
   2468a:	9306      	str	r3, [sp, #24]
    REALFFT(fftsize, processbuf);
   2468c:	f7ff fcf8 	bl	24080 <mayer_realfft>
    processbuf[0] *= processbuf[0];                      // DC
   24690:	edda 7a00 	vldr	s15, [sl]
    processbuf[framesize] *= processbuf[framesize];      // Nyquist
   24694:	eb0a 0189 	add.w	r1, sl, r9, lsl #2
    for(n=1; n<framesize; n++)
   24698:	f1b9 0f01 	cmp.w	r9, #1
    processbuf[0] *= processbuf[0];                      // DC
   2469c:	ee67 7aa7 	vmul.f32	s15, s15, s15
   246a0:	edca 7a00 	vstr	s15, [sl]
    processbuf[framesize] *= processbuf[framesize];      // Nyquist
   246a4:	edd1 7a00 	vldr	s15, [r1]
   246a8:	ee67 7aa7 	vmul.f32	s15, s15, s15
   246ac:	edc1 7a00 	vstr	s15, [r1]
    for(n=1; n<framesize; n++)
   246b0:	dd11      	ble.n	246d6 <tSNAC_ioSamples+0x116>
   246b2:	f10a 0304 	add.w	r3, sl, #4
   246b6:	eb0a 02c9 	add.w	r2, sl, r9, lsl #3
        processbuf[fftsize-n] = 0.;
   246ba:	2000      	movs	r0, #0
        + processbuf[fftsize-n] * processbuf[fftsize-n]; // imag coefficients appear reversed
   246bc:	ed72 7a01 	vldmdb	r2!, {s15}
        processbuf[n] = processbuf[n] * processbuf[n]
   246c0:	ed93 7a00 	vldr	s14, [r3]
        + processbuf[fftsize-n] * processbuf[fftsize-n]; // imag coefficients appear reversed
   246c4:	ee67 7aa7 	vmul.f32	s15, s15, s15
   246c8:	eee7 7a07 	vfma.f32	s15, s14, s14
        processbuf[n] = processbuf[n] * processbuf[n]
   246cc:	ece3 7a01 	vstmia	r3!, {s15}
    for(n=1; n<framesize; n++)
   246d0:	4299      	cmp	r1, r3
        processbuf[fftsize-n] = 0.;
   246d2:	6010      	str	r0, [r2, #0]
    for(n=1; n<framesize; n++)
   246d4:	d1f2      	bne.n	246bc <tSNAC_ioSamples+0xfc>
    for(m=0; m<(framesize>>1); m++)
   246d6:	ea5f 0969 	movs.w	r9, r9, asr #1
   246da:	d009      	beq.n	246f0 <tSNAC_ioSamples+0x130>
   246dc:	9a06      	ldr	r2, [sp, #24]
   246de:	eb0a 0989 	add.w	r9, sl, r9, lsl #2
   246e2:	4653      	mov	r3, sl
        spectrumbuf[m] = processbuf[m];
   246e4:	f853 1b04 	ldr.w	r1, [r3], #4
    for(m=0; m<(framesize>>1); m++)
   246e8:	4599      	cmp	r9, r3
        spectrumbuf[m] = processbuf[m];
   246ea:	f842 1b04 	str.w	r1, [r2], #4
    for(m=0; m<(framesize>>1); m++)
   246ee:	d1f9      	bne.n	246e4 <tSNAC_ioSamples+0x124>
    REALIFFT(fftsize, processbuf);
   246f0:	4651      	mov	r1, sl
   246f2:	4658      	mov	r0, fp
   246f4:	f7ff fcec 	bl	240d0 <mayer_realifft>
    snac_normalize(snac);
   246f8:	9b02      	ldr	r3, [sp, #8]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   246fa:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    int seek = framesize * SEEK;
   246fe:	eddf 4ade 	vldr	s9, [pc, #888]	; 24a78 <tSNAC_ioSamples+0x4b8>
    snac_normalize(snac);
   24702:	681b      	ldr	r3, [r3, #0]
    int framesize = s->framesize;
   24704:	8ada      	ldrh	r2, [r3, #22]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   24706:	ed93 5a0a 	vldr	s10, [r3, #40]	; 0x28
    int seek = framesize * SEEK;
   2470a:	ee07 2a90 	vmov	s15, r2
    int framesize = s->framesize;
   2470e:	9206      	str	r2, [sp, #24]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   24710:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
    float *processbuf= s->processbuf;
   24714:	689a      	ldr	r2, [r3, #8]
    int seek = framesize * SEEK;
   24716:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    int framesizeplustimeindex = s->framesize + s->timeindex;
   2471a:	f8b3 a014 	ldrh.w	sl, [r3, #20]
    float rzero = processbuf[0];
   2471e:	ed92 6a00 	vldr	s12, [r2]
    float *inputbuf = s->inputbuf;
   24722:	f8d3 9004 	ldr.w	r9, [r3, #4]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   24726:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    processbuf[0] = 1;
   2472a:	edc2 6a00 	vstr	s13, [r2]
    int mask = framesize - 1;
   2472e:	9906      	ldr	r1, [sp, #24]
    float *processbuf= s->processbuf;
   24730:	9207      	str	r2, [sp, #28]
    int mask = framesize - 1;
   24732:	f101 3eff 	add.w	lr, r1, #4294967295	; 0xffffffff
    int framesizeplustimeindex = s->framesize + s->timeindex;
   24736:	eb0a 0b01 	add.w	fp, sl, r1
    int seek = framesize * SEEK;
   2473a:	ee67 7aa4 	vmul.f32	s15, s15, s9
   2473e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   24742:	ee17 0a90 	vmov	r0, s15
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   24746:	2801      	cmp	r0, #1
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   24748:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   2474c:	eeb1 4bc7 	vsqrt.f64	d4, d7
   24750:	ee85 7b04 	vdiv.f64	d7, d5, d4
   24754:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    float minrzero = rms * rms;
   24758:	ee27 7a07 	vmul.f32	s14, s14, s14
    double normintegral = (double)rzero * 2.;
   2475c:	fe87 6a06 	vmaxnm.f32	s12, s14, s12
   24760:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
   24764:	ee36 6b06 	vadd.f64	d6, d6, d6
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   24768:	dd2b      	ble.n	247c2 <tSNAC_ioSamples+0x202>
        processbuf[n] /= (float)normintegral * 0.5f;
   2476a:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
   2476e:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   24772:	f102 0c04 	add.w	ip, r2, #4
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   24776:	2101      	movs	r1, #1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   24778:	ebab 0201 	sub.w	r2, fp, r1
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   2477c:	eb0a 0301 	add.w	r3, sl, r1
        processbuf[n] /= (float)normintegral * 0.5f;
   24780:	eddc 5a00 	vldr	s11, [ip]
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   24784:	3101      	adds	r1, #1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   24786:	ea02 020e 	and.w	r2, r2, lr
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   2478a:	ea03 030e 	and.w	r3, r3, lr
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   2478e:	4288      	cmp	r0, r1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   24790:	eb09 0282 	add.w	r2, r9, r2, lsl #2
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   24794:	eb09 0383 	add.w	r3, r9, r3, lsl #2
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   24798:	ed92 7a00 	vldr	s14, [r2]
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   2479c:	edd3 7a00 	vldr	s15, [r3]
        normintegral -= (double)(signal1 * signal1 + signal2 * signal2);
   247a0:	ee27 7a07 	vmul.f32	s14, s14, s14
   247a4:	eea7 7aa7 	vfma.f32	s14, s15, s15
   247a8:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   247ac:	ee36 6b47 	vsub.f64	d6, d6, d7
        processbuf[n] /= (float)normintegral * 0.5f;
   247b0:	eef7 7bc6 	vcvt.f32.f64	s15, d6
   247b4:	ee67 7a85 	vmul.f32	s15, s15, s10
   247b8:	ee85 7aa7 	vdiv.f32	s14, s11, s15
   247bc:	ecac 7a01 	vstmia	ip!, {s14}
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   247c0:	d1da      	bne.n	24778 <tSNAC_ioSamples+0x1b8>
    for(n = seek; n<framesize; n++) processbuf[n] = 0.;
   247c2:	9b06      	ldr	r3, [sp, #24]
   247c4:	4283      	cmp	r3, r0
   247c6:	dd07      	ble.n	247d8 <tSNAC_ioSamples+0x218>
   247c8:	1a1a      	subs	r2, r3, r0
   247ca:	9b07      	ldr	r3, [sp, #28]
   247cc:	2100      	movs	r1, #0
   247ce:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   247d2:	0092      	lsls	r2, r2, #2
   247d4:	f008 f885 	bl	2c8e2 <memset>
    snac_pickpeak(snac);
   247d8:	9b02      	ldr	r3, [sp, #8]
    int seek = s->framesize * SEEK;
   247da:	ed9f 7aa7 	vldr	s14, [pc, #668]	; 24a78 <tSNAC_ioSamples+0x4b8>
    snac_pickpeak(snac);
   247de:	681b      	ldr	r3, [r3, #0]
    int seek = s->framesize * SEEK;
   247e0:	8ada      	ldrh	r2, [r3, #22]
    snac_pickpeak(snac);
   247e2:	9307      	str	r3, [sp, #28]
    int seek = s->framesize * SEEK;
   247e4:	ee07 2a90 	vmov	s15, r2
    float *biasbuf = s->biasbuf;
   247e8:	6918      	ldr	r0, [r3, #16]
    float *processbuf= s->processbuf;
   247ea:	689a      	ldr	r2, [r3, #8]
    int seek = s->framesize * SEEK;
   247ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   247f0:	ee67 7a87 	vmul.f32	s15, s15, s14
   247f4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   247f8:	ee17 aa90 	vmov	sl, s15
    for(n=1; n<seek; n++)
   247fc:	f1ba 0f01 	cmp.w	sl, #1
   24800:	f340 808b 	ble.w	2491a <tSNAC_ioSamples+0x35a>
        if(processbuf[n] < 0.) break;
   24804:	edd2 7a01 	vldr	s15, [r2, #4]
   24808:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2480c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24810:	f100 8083 	bmi.w	2491a <tSNAC_ioSamples+0x35a>
   24814:	f102 0108 	add.w	r1, r2, #8
    for(n=1; n<seek; n++)
   24818:	f04f 0901 	mov.w	r9, #1
   2481c:	e006      	b.n	2482c <tSNAC_ioSamples+0x26c>
        if(processbuf[n] < 0.) break;
   2481e:	ecf1 7a01 	vldmia	r1!, {s15}
   24822:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   24826:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2482a:	d404      	bmi.n	24836 <tSNAC_ioSamples+0x276>
    for(n=1; n<seek; n++)
   2482c:	f109 0901 	add.w	r9, r9, #1
   24830:	45ca      	cmp	sl, r9
   24832:	d1f4      	bne.n	2481e <tSNAC_ioSamples+0x25e>
   24834:	46d1      	mov	r9, sl
    for(; n<seek-1; n++)
   24836:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   2483a:	45ca      	cmp	sl, r9
   2483c:	dd6b      	ble.n	24916 <tSNAC_ioSamples+0x356>
   2483e:	ea4f 0389 	mov.w	r3, r9, lsl #2
   24842:	2100      	movs	r1, #0
   24844:	9408      	str	r4, [sp, #32]
   24846:	4614      	mov	r4, r2
   24848:	f1a3 0b04 	sub.w	fp, r3, #4
   2484c:	4403      	add	r3, r0
   2484e:	9509      	str	r5, [sp, #36]	; 0x24
   24850:	4655      	mov	r5, sl
   24852:	9106      	str	r1, [sp, #24]
   24854:	4493      	add	fp, r2
   24856:	ed9f 8a89 	vldr	s16, [pc, #548]	; 24a7c <tSNAC_ioSamples+0x4bc>
   2485a:	469a      	mov	sl, r3
   2485c:	e005      	b.n	2486a <tSNAC_ioSamples+0x2aa>
   2485e:	f109 0901 	add.w	r9, r9, #1
   24862:	f10a 0a04 	add.w	sl, sl, #4
   24866:	45a9      	cmp	r9, r5
   24868:	d029      	beq.n	248be <tSNAC_ioSamples+0x2fe>
   2486a:	4659      	mov	r1, fp
        if(processbuf[n] >= processbuf[n-1])
   2486c:	f10b 0b04 	add.w	fp, fp, #4
   24870:	ed91 7a00 	vldr	s14, [r1]
   24874:	eddb 7a00 	vldr	s15, [fp]
   24878:	eef4 7ac7 	vcmpe.f32	s15, s14
   2487c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24880:	dbed      	blt.n	2485e <tSNAC_ioSamples+0x29e>
            if(processbuf[n] > processbuf[n+1])     // we have a local peak
   24882:	ed9b 7a01 	vldr	s14, [fp, #4]
   24886:	eef4 7ac7 	vcmpe.f32	s15, s14
   2488a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2488e:	dde6      	ble.n	2485e <tSNAC_ioSamples+0x29e>
                biasedpeak = interpolate3max(processbuf, n) * biasbuf[n];
   24890:	4649      	mov	r1, r9
   24892:	4620      	mov	r0, r4
   24894:	f004 fe22 	bl	294dc <interpolate3max>
   24898:	edda 7a00 	vldr	s15, [sl]
   2489c:	ee20 0a27 	vmul.f32	s0, s0, s15
                if(biasedpeak > maxvalue)
   248a0:	eeb4 0ac8 	vcmpe.f32	s0, s16
   248a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   248a8:	ddd9      	ble.n	2485e <tSNAC_ioSamples+0x29e>
   248aa:	f8cd 9018 	str.w	r9, [sp, #24]
    for(; n<seek-1; n++)
   248ae:	f109 0901 	add.w	r9, r9, #1
                    maxvalue = biasedpeak;
   248b2:	eeb0 8a40 	vmov.f32	s16, s0
   248b6:	f10a 0a04 	add.w	sl, sl, #4
    for(; n<seek-1; n++)
   248ba:	45a9      	cmp	r9, r5
   248bc:	d1d5      	bne.n	2486a <tSNAC_ioSamples+0x2aa>
   248be:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   248c2:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
    s->periodindex = peakindex;
   248c6:	9a07      	ldr	r2, [sp, #28]
   248c8:	8353      	strh	r3, [r2, #26]
    _tSNAC* s = *snac;
   248ca:	9b02      	ldr	r3, [sp, #8]
   248cc:	f8d3 a000 	ldr.w	sl, [r3]
    if(s->periodindex)
   248d0:	f8ba 901a 	ldrh.w	r9, [sl, #26]
   248d4:	f1b9 0f00 	cmp.w	r9, #0
   248d8:	f43f ae89 	beq.w	245ee <tSNAC_ioSamples+0x2e>
        interpolate3phase(s->processbuf, s->periodindex);
   248dc:	4649      	mov	r1, r9
   248de:	f8da 0008 	ldr.w	r0, [sl, #8]
   248e2:	f004 fe19 	bl	29518 <interpolate3phase>
        periodlength = (float)s->periodindex +
   248e6:	ee07 9a90 	vmov	s15, r9
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   248ea:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
        periodlength = (float)s->periodindex +
   248ee:	eef8 7a67 	vcvt.f32.u32	s15, s15
   248f2:	ee37 0a80 	vadd.f32	s0, s15, s0
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   248f6:	eeb4 0ac7 	vcmpe.f32	s0, s14
   248fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   248fe:	d40f      	bmi.n	24920 <tSNAC_ioSamples+0x360>
        s->periodlength = periodlength;
   24900:	ed8a 0a07 	vstr	s0, [sl, #28]
        s->fidelity = interpolate3max(s->processbuf, s->periodindex);
   24904:	f8ba 101a 	ldrh.w	r1, [sl, #26]
   24908:	f8da 0008 	ldr.w	r0, [sl, #8]
   2490c:	f004 fde6 	bl	294dc <interpolate3max>
   24910:	ed8a 0a08 	vstr	s0, [sl, #32]
   24914:	e66b      	b.n	245ee <tSNAC_ioSamples+0x2e>
    for(; n<seek-1; n++)
   24916:	2300      	movs	r3, #0
   24918:	e7d5      	b.n	248c6 <tSNAC_ioSamples+0x306>
    for(n=1; n<seek; n++)
   2491a:	f04f 0901 	mov.w	r9, #1
   2491e:	e78a      	b.n	24836 <tSNAC_ioSamples+0x276>
    if(periodlength < 4.0f) return periodlength;
   24920:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
   24924:	eeb4 0ae7 	vcmpe.f32	s0, s15
   24928:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2492c:	d4e8      	bmi.n	24900 <tSNAC_ioSamples+0x340>
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   2492e:	9b02      	ldr	r3, [sp, #8]
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   24930:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   24934:	eef7 5a04 	vmov.f32	s11, #116	; 0x3fa00000  1.250
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   24938:	ed9f 6a51 	vldr	s12, [pc, #324]	; 24a80 <tSNAC_ioSamples+0x4c0>
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   2493c:	f8d3 9000 	ldr.w	r9, [r3]
    int spectrumsize = s->framesize>>1;
   24940:	f8b9 3016 	ldrh.w	r3, [r9, #22]
    float *spectrumbuf = s->spectrumbuf;
   24944:	f8d9 c00c 	ldr.w	ip, [r9, #12]
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
   24948:	ee07 3a10 	vmov	s14, r3
    int spectrumsize = s->framesize>>1;
   2494c:	085b      	lsrs	r3, r3, #1
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
   2494e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    if(stopbin >= spectrumsize - 1) stopbin = spectrumsize - 1;
   24952:	1e5a      	subs	r2, r3, #1
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
   24954:	ee37 7a07 	vadd.f32	s14, s14, s14
   24958:	eec7 6a00 	vdiv.f32	s13, s14, s0
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   2495c:	eeb0 7a67 	vmov.f32	s14, s15
   24960:	eea6 7aa5 	vfma.f32	s14, s13, s11
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   24964:	eee6 7a86 	vfma.f32	s15, s13, s12
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   24968:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   2496c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   24970:	ee17 1a10 	vmov	r1, s14
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   24974:	ee17 3a90 	vmov	r3, s15
   24978:	4291      	cmp	r1, r2
   2497a:	bfa8      	it	ge
   2497c:	4611      	movge	r1, r2
   2497e:	2b01      	cmp	r3, #1
   24980:	bfb8      	it	lt
   24982:	2301      	movlt	r3, #1
    for(n=startbin; n<stopbin; n++)
   24984:	4299      	cmp	r1, r3
   24986:	dd64      	ble.n	24a52 <tSNAC_ioSamples+0x492>
   24988:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
    float max = 0.;
   2498c:	eddf 6a3b 	vldr	s13, [pc, #236]	; 24a7c <tSNAC_ioSamples+0x4bc>
   24990:	441a      	add	r2, r3
   24992:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
   24996:	4610      	mov	r0, r2
        if(spectrumbuf[n] >= spectrumbuf[n-1])
   24998:	3204      	adds	r2, #4
   2499a:	ed90 7a00 	vldr	s14, [r0]
   2499e:	edd2 7a00 	vldr	s15, [r2]
   249a2:	eef4 7ac7 	vcmpe.f32	s15, s14
   249a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   249aa:	db0e      	blt.n	249ca <tSNAC_ioSamples+0x40a>
            if(spectrumbuf[n] > spectrumbuf[n+1])
   249ac:	ed92 7a01 	vldr	s14, [r2, #4]
                if(spectrumbuf[n] > max)
   249b0:	eef4 7a47 	vcmp.f32	s15, s14
   249b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   249b8:	dd07      	ble.n	249ca <tSNAC_ioSamples+0x40a>
   249ba:	eef4 7a66 	vcmp.f32	s15, s13
   249be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   249c2:	dd02      	ble.n	249ca <tSNAC_ioSamples+0x40a>
                    max = spectrumbuf[n];
   249c4:	eef0 6a67 	vmov.f32	s13, s15
                if(spectrumbuf[n] > max)
   249c8:	9305      	str	r3, [sp, #20]
    for(n=startbin; n<stopbin; n++)
   249ca:	3301      	adds	r3, #1
   249cc:	4299      	cmp	r1, r3
   249ce:	d1e2      	bne.n	24996 <tSNAC_ioSamples+0x3d6>
    for(n=(peakbin-1); n<(peakbin+2); n++)
   249d0:	9b05      	ldr	r3, [sp, #20]
   249d2:	461a      	mov	r2, r3
   249d4:	1e58      	subs	r0, r3, #1
   249d6:	3301      	adds	r3, #1
   249d8:	ee07 2a90 	vmov	s15, r2
   249dc:	4283      	cmp	r3, r0
   249de:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
   249e2:	db25      	blt.n	24a30 <tSNAC_ioSamples+0x470>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   249e4:	0080      	lsls	r0, r0, #2
    for(n=(peakbin-1); n<(peakbin+2); n++)
   249e6:	469e      	mov	lr, r3
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   249e8:	eb0c 0100 	add.w	r1, ip, r0
   249ec:	3004      	adds	r0, #4
   249ee:	ed91 7a00 	vldr	s14, [r1]
   249f2:	eb0c 0200 	add.w	r2, ip, r0
   249f6:	eef1 7ac7 	vsqrt.f32	s15, s14
   249fa:	edc1 7a00 	vstr	s15, [r1]
   249fe:	ed92 7a00 	vldr	s14, [r2]
   24a02:	eef1 7ac7 	vsqrt.f32	s15, s14
   24a06:	edc2 7a00 	vstr	s15, [r2]
   24a0a:	1d02      	adds	r2, r0, #4
    for(n=(peakbin-1); n<(peakbin+2); n++)
   24a0c:	459e      	cmp	lr, r3
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24a0e:	4462      	add	r2, ip
   24a10:	ed92 7a00 	vldr	s14, [r2]
   24a14:	eef1 7ac7 	vsqrt.f32	s15, s14
   24a18:	edc2 7a00 	vstr	s15, [r2]
    for(n=(peakbin-1); n<(peakbin+2); n++)
   24a1c:	da08      	bge.n	24a30 <tSNAC_ioSamples+0x470>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24a1e:	f100 0308 	add.w	r3, r0, #8
   24a22:	4463      	add	r3, ip
   24a24:	ed93 7a00 	vldr	s14, [r3]
   24a28:	eef1 7ac7 	vsqrt.f32	s15, s14
   24a2c:	edc3 7a00 	vstr	s15, [r3]
    peaklocation = (float)peakbin + interpolate3phase(spectrumbuf, peakbin);
   24a30:	9905      	ldr	r1, [sp, #20]
   24a32:	4660      	mov	r0, ip
   24a34:	f004 fd70 	bl	29518 <interpolate3phase>
    periodlength = (float)(s->framesize * 2.0f) / peaklocation;
   24a38:	f8b9 3016 	ldrh.w	r3, [r9, #22]
    peaklocation = (float)peakbin + interpolate3phase(spectrumbuf, peakbin);
   24a3c:	ee30 8a08 	vadd.f32	s16, s0, s16
    periodlength = (float)(s->framesize * 2.0f) / peaklocation;
   24a40:	ee07 3a90 	vmov	s15, r3
   24a44:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   24a48:	ee77 7aa7 	vadd.f32	s15, s15, s15
   24a4c:	ee87 0a88 	vdiv.f32	s0, s15, s16
   24a50:	e756      	b.n	24900 <tSNAC_ioSamples+0x340>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24a52:	ed5c 7a01 	vldr	s15, [ip, #-4]
    for(n=(peakbin-1); n<(peakbin+2); n++)
   24a56:	f04f 0e01 	mov.w	lr, #1
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24a5a:	eddc 6a00 	vldr	s13, [ip]
   24a5e:	2000      	movs	r0, #0
   24a60:	eeb1 7ae7 	vsqrt.f32	s14, s15
    for(n=(peakbin-1); n<(peakbin+2); n++)
   24a64:	4673      	mov	r3, lr
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24a66:	ed9f 8a05 	vldr	s16, [pc, #20]	; 24a7c <tSNAC_ioSamples+0x4bc>
   24a6a:	eef1 7ae6 	vsqrt.f32	s15, s13
   24a6e:	ed0c 7a01 	vstr	s14, [ip, #-4]
   24a72:	edcc 7a00 	vstr	s15, [ip]
   24a76:	e7c8      	b.n	24a0a <tSNAC_ioSamples+0x44a>
   24a78:	3f59999a 	.word	0x3f59999a
   24a7c:	00000000 	.word	0x00000000
   24a80:	3f4ccccd 	.word	0x3f4ccccd

00024a84 <tPeriodDetection_initToPool>:
{
    tPeriodDetection_initToPool(pd, in, out, bufSize, frameSize, &leaf.mempool);
}

void tPeriodDetection_initToPool (tPeriodDetection* const pd, float* in, float* out, int bufSize, int frameSize, tMempool* const mp)
{
   24a84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24a88:	b085      	sub	sp, #20
   24a8a:	4682      	mov	sl, r0
   24a8c:	468b      	mov	fp, r1
    _tMempool* m = *mp;
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
   24a8e:	2068      	movs	r0, #104	; 0x68
{
   24a90:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   24a92:	461d      	mov	r5, r3
   24a94:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    p->inBuffer = in;
    p->outBuffer = out;
    p->bufSize = bufSize;
    p->frameSize = frameSize;
    p->framesPerBuffer = p->bufSize / p->frameSize;
    p->curBlock = 1;
   24a96:	f04f 0801 	mov.w	r8, #1
    _tMempool* m = *mp;
   24a9a:	f8d6 9000 	ldr.w	r9, [r6]
{
   24a9e:	9203      	str	r2, [sp, #12]
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
   24aa0:	4649      	mov	r1, r9
   24aa2:	f005 f897 	bl	29bd4 <mpool_calloc>
   24aa6:	4604      	mov	r4, r0
    p->lastBlock = 0;
   24aa8:	f04f 0c00 	mov.w	ip, #0
    p->outBuffer = out;
   24aac:	9b03      	ldr	r3, [sp, #12]
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
   24aae:	f8ca 4000 	str.w	r4, [sl]
    
    p->hopSize = DEFHOPSIZE;
    p->windowSize = DEFWINDOWSIZE;
    p->fba = FBA;
    
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   24ab2:	2240      	movs	r2, #64	; 0x40
    p->hopSize = DEFHOPSIZE;
   24ab4:	f04f 1040 	mov.w	r0, #4194368	; 0x400040
    p->fba = FBA;
   24ab8:	2114      	movs	r1, #20
    p->index = 0;
   24aba:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
    p->outBuffer = out;
   24abe:	6123      	str	r3, [r4, #16]
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   24ac0:	463b      	mov	r3, r7
    p->hopSize = DEFHOPSIZE;
   24ac2:	63e0      	str	r0, [r4, #60]	; 0x3c
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   24ac4:	1d20      	adds	r0, r4, #4
    p->fba = FBA;
   24ac6:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   24aca:	4611      	mov	r1, r2
    p->mempool = m;
   24acc:	f8c4 9000 	str.w	r9, [r4]
    p->inBuffer = in;
   24ad0:	f8c4 b00c 	str.w	fp, [r4, #12]
    p->frameSize = frameSize;
   24ad4:	e9c4 7505 	strd	r7, r5, [r4, #20]
    p->framesPerBuffer = p->bufSize / p->frameSize;
   24ad8:	fb95 f5f7 	sdiv	r5, r5, r7
    p->lastBlock = 0;
   24adc:	e9c4 8c08 	strd	r8, ip, [r4, #32]
    p->framesPerBuffer = p->bufSize / p->frameSize;
   24ae0:	61e5      	str	r5, [r4, #28]
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   24ae2:	9600      	str	r6, [sp, #0]
   24ae4:	f7ff fc2c 	bl	24340 <tEnvPD_initToPool>
    
    tSNAC_initToPool(&p->snac, DEFOVERLAP, mp);
   24ae8:	4632      	mov	r2, r6
   24aea:	4641      	mov	r1, r8
   24aec:	f104 0008 	add.w	r0, r4, #8
   24af0:	f7ff fcd4 	bl	2449c <tSNAC_initToPool>

    p->history = 0.0f;
    p->alpha = 1.0f;
    p->tolerance = 1.0f;
    p->timeConstant = DEFTIMECONSTANT;
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24af4:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
   24af6:	4b0f      	ldr	r3, [pc, #60]	; (24b34 <tPeriodDetection_initToPool+0xb0>)
   24af8:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
   24afc:	ee00 2a10 	vmov	s0, r2
    p->history = 0.0f;
   24b00:	2100      	movs	r1, #0
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24b02:	edd3 7a01 	vldr	s15, [r3, #4]
    p->alpha = 1.0f;
   24b06:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24b0a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    p->timeConstant = DEFTIMECONSTANT;
   24b0e:	4a0a      	ldr	r2, [pc, #40]	; (24b38 <tPeriodDetection_initToPool+0xb4>)
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24b10:	ee67 7a87 	vmul.f32	s15, s15, s14
    p->alpha = 1.0f;
   24b14:	6623      	str	r3, [r4, #96]	; 0x60
    p->tolerance = 1.0f;
   24b16:	6663      	str	r3, [r4, #100]	; 0x64
    p->history = 0.0f;
   24b18:	65e1      	str	r1, [r4, #92]	; 0x5c
    p->timeConstant = DEFTIMECONSTANT;
   24b1a:	6462      	str	r2, [r4, #68]	; 0x44
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24b1c:	ee20 0a27 	vmul.f32	s0, s0, s15
   24b20:	f008 f848 	bl	2cbb4 <expf>
    p->fidelityThreshold = 0.95;
   24b24:	4b05      	ldr	r3, [pc, #20]	; (24b3c <tPeriodDetection_initToPool+0xb8>)
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24b26:	ed84 0a12 	vstr	s0, [r4, #72]	; 0x48
    p->fidelityThreshold = 0.95;
   24b2a:	65a3      	str	r3, [r4, #88]	; 0x58
}
   24b2c:	b005      	add	sp, #20
   24b2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24b32:	bf00      	nop
   24b34:	020fbd68 	.word	0x020fbd68
   24b38:	42c80000 	.word	0x42c80000
   24b3c:	3f733333 	.word	0x3f733333

00024b40 <tPeriodDetection_free>:

void tPeriodDetection_free (tPeriodDetection* const pd)
{
   24b40:	b538      	push	{r3, r4, r5, lr}
    _tPeriodDetection* p = *pd;
   24b42:	6805      	ldr	r5, [r0, #0]
    _tEnvPD* x = *xpd;
   24b44:	6868      	ldr	r0, [r5, #4]
    mpool_free((char*)x, x->mempool);
   24b46:	6801      	ldr	r1, [r0, #0]
   24b48:	f005 f896 	bl	29c78 <mpool_free>
    _tSNAC* s = *snac;
   24b4c:	68ac      	ldr	r4, [r5, #8]
    mpool_free((char*)s->inputbuf, s->mempool);
   24b4e:	e9d4 1000 	ldrd	r1, r0, [r4]
   24b52:	f005 f891 	bl	29c78 <mpool_free>
    mpool_free((char*)s->processbuf, s->mempool);
   24b56:	6821      	ldr	r1, [r4, #0]
   24b58:	68a0      	ldr	r0, [r4, #8]
   24b5a:	f005 f88d 	bl	29c78 <mpool_free>
    mpool_free((char*)s->spectrumbuf, s->mempool);
   24b5e:	6821      	ldr	r1, [r4, #0]
   24b60:	68e0      	ldr	r0, [r4, #12]
   24b62:	f005 f889 	bl	29c78 <mpool_free>
    mpool_free((char*)s->biasbuf, s->mempool);
   24b66:	6821      	ldr	r1, [r4, #0]
   24b68:	6920      	ldr	r0, [r4, #16]
   24b6a:	f005 f885 	bl	29c78 <mpool_free>
    mpool_free((char*)s, s->mempool);
   24b6e:	6821      	ldr	r1, [r4, #0]
   24b70:	4620      	mov	r0, r4
   24b72:	f005 f881 	bl	29c78 <mpool_free>
    
    tEnvPD_free(&p->env);
    tSNAC_free(&p->snac);
    mpool_free((char*)p, p->mempool);
   24b76:	6829      	ldr	r1, [r5, #0]
   24b78:	4628      	mov	r0, r5
}
   24b7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    mpool_free((char*)p, p->mempool);
   24b7e:	f005 b87b 	b.w	29c78 <mpool_free>
   24b82:	bf00      	nop

00024b84 <tPeriodDetection_tick>:

float tPeriodDetection_tick (tPeriodDetection* pd, float sample)
{
   24b84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    _tPeriodDetection* p = *pd;
   24b88:	6804      	ldr	r4, [r0, #0]
    
    int i, iLast;
    
    i = (p->curBlock*p->frameSize);
   24b8a:	6963      	ldr	r3, [r4, #20]
   24b8c:	6a21      	ldr	r1, [r4, #32]
    iLast = (p->lastBlock*p->frameSize)+p->index;
   24b8e:	6b62      	ldr	r2, [r4, #52]	; 0x34
    i = (p->curBlock*p->frameSize);
   24b90:	fb01 f103 	mul.w	r1, r1, r3
    iLast = (p->lastBlock*p->frameSize)+p->index;
   24b94:	6a65      	ldr	r5, [r4, #36]	; 0x24
    
    p->i = i;
    p->iLast = iLast;
    
    p->inBuffer[i+p->index] = sample;
   24b96:	68e0      	ldr	r0, [r4, #12]
    iLast = (p->lastBlock*p->frameSize)+p->index;
   24b98:	fb05 2303 	mla	r3, r5, r3, r2
    p->inBuffer[i+p->index] = sample;
   24b9c:	440a      	add	r2, r1
    p->i = i;
   24b9e:	62a1      	str	r1, [r4, #40]	; 0x28
    p->inBuffer[i+p->index] = sample;
   24ba0:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    p->iLast = iLast;
   24ba4:	6323      	str	r3, [r4, #48]	; 0x30
    p->inBuffer[i+p->index] = sample;
   24ba6:	ed82 0a00 	vstr	s0, [r2]
    
    p->index++;
   24baa:	6b63      	ldr	r3, [r4, #52]	; 0x34
    p->indexstore = p->index;
    if (p->index >= p->frameSize)
   24bac:	6962      	ldr	r2, [r4, #20]
    p->index++;
   24bae:	3301      	adds	r3, #1
    if (p->index >= p->frameSize)
   24bb0:	4293      	cmp	r3, r2
    p->index++;
   24bb2:	6363      	str	r3, [r4, #52]	; 0x34
    p->indexstore = p->index;
   24bb4:	62e3      	str	r3, [r4, #44]	; 0x2c
    if (p->index >= p->frameSize)
   24bb6:	da03      	bge.n	24bc0 <tPeriodDetection_tick+0x3c>
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
        p->lastBlock++;
        if (p->lastBlock >= p->framesPerBuffer) p->lastBlock = 0;
    }
    return p->period;
}
   24bb8:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
   24bbc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    _tEnvPD* x = *xpd;
   24bc0:	f8d4 c004 	ldr.w	ip, [r4, #4]
        p->index = 0;
   24bc4:	2200      	movs	r2, #0
    int n = x->blockSize;
   24bc6:	f241 1398 	movw	r3, #4504	; 0x1198
    for (count = x->x_phase, sump = x->x_sumbuf;
   24bca:	f241 1604 	movw	r6, #4356	; 0x1104
        p->index = 0;
   24bce:	6362      	str	r2, [r4, #52]	; 0x34
        tEnvPD_processBlock(&p->env, &(p->inBuffer[i]));
   24bd0:	0089      	lsls	r1, r1, #2
    int n = x->blockSize;
   24bd2:	f83c 5003 	ldrh.w	r5, [ip, r3]
         count < x->x_npoints; count += x->x_realperiod, sump++)
   24bd6:	f241 130a 	movw	r3, #4362	; 0x110a
    for (count = x->x_phase, sump = x->x_sumbuf;
   24bda:	f83c 6006 	ldrh.w	r6, [ip, r6]
   24bde:	f241 1010 	movw	r0, #4368	; 0x1110
   24be2:	f83c 3003 	ldrh.w	r3, [ip, r3]
    in += n;
   24be6:	eb01 0985 	add.w	r9, r1, r5, lsl #2
   24bea:	68e2      	ldr	r2, [r4, #12]
    for (count = x->x_phase, sump = x->x_sumbuf;
   24bec:	4460      	add	r0, ip
   24bee:	42b3      	cmp	r3, r6
    in += n;
   24bf0:	4491      	add	r9, r2
    for (count = x->x_phase, sump = x->x_sumbuf;
   24bf2:	d924      	bls.n	24c3e <tPeriodDetection_tick+0xba>
   24bf4:	f241 1808 	movw	r8, #4360	; 0x1108
   24bf8:	f241 1e0a 	movw	lr, #4362	; 0x110a
   24bfc:	4607      	mov	r7, r0
   24bfe:	f10c 0a04 	add.w	sl, ip, #4
   24c02:	44e0      	add	r8, ip
   24c04:	44e6      	add	lr, ip
        t_sample *hp = x->buf + count;
   24c06:	eb0a 0286 	add.w	r2, sl, r6, lsl #2
        t_sample sum = *sump;
   24c0a:	ecb7 7a01 	vldmia	r7!, {s14}
        for (i = 0; i < n; i++)
   24c0e:	b165      	cbz	r5, 24c2a <tPeriodDetection_tick+0xa6>
   24c10:	4648      	mov	r0, r9
   24c12:	2300      	movs	r3, #0
            sum += *hp++ * (*fp * *fp);
   24c14:	ed70 7a01 	vldmdb	r0!, {s15}
        for (i = 0; i < n; i++)
   24c18:	3301      	adds	r3, #1
            sum += *hp++ * (*fp * *fp);
   24c1a:	ecf2 6a01 	vldmia	r2!, {s13}
   24c1e:	ee67 7aa7 	vmul.f32	s15, s15, s15
        for (i = 0; i < n; i++)
   24c22:	429d      	cmp	r5, r3
            sum += *hp++ * (*fp * *fp);
   24c24:	eea6 7aa7 	vfma.f32	s14, s13, s15
        for (i = 0; i < n; i++)
   24c28:	d1f4      	bne.n	24c14 <tPeriodDetection_tick+0x90>
        *sump = sum;
   24c2a:	ed07 7a01 	vstr	s14, [r7, #-4]
   24c2e:	4638      	mov	r0, r7
         count < x->x_npoints; count += x->x_realperiod, sump++)
   24c30:	f8b8 2000 	ldrh.w	r2, [r8]
   24c34:	f8be 3000 	ldrh.w	r3, [lr]
   24c38:	4416      	add	r6, r2
    for (count = x->x_phase, sump = x->x_sumbuf;
   24c3a:	429e      	cmp	r6, r3
   24c3c:	dbe3      	blt.n	24c06 <tPeriodDetection_tick+0x82>
    x->x_phase -= n;
   24c3e:	f241 1204 	movw	r2, #4356	; 0x1104
    sump[0] = 0;
   24c42:	2300      	movs	r3, #0
   24c44:	6003      	str	r3, [r0, #0]
        tSNAC_ioSamples(&p->snac, &(p->inBuffer[i]), &(p->outBuffer[i]), p->frameSize);
   24c46:	f104 0008 	add.w	r0, r4, #8
    x->x_phase -= n;
   24c4a:	f83c 3002 	ldrh.w	r3, [ip, r2]
   24c4e:	1b5d      	subs	r5, r3, r5
   24c50:	f82c 5002 	strh.w	r5, [ip, r2]
        tSNAC_ioSamples(&p->snac, &(p->inBuffer[i]), &(p->outBuffer[i]), p->frameSize);
   24c54:	6963      	ldr	r3, [r4, #20]
   24c56:	e9d4 5203 	ldrd	r5, r2, [r4, #12]
   24c5a:	440a      	add	r2, r1
   24c5c:	4429      	add	r1, r5
   24c5e:	f7ff fcaf 	bl	245c0 <tSNAC_ioSamples>
    _tSNAC* s = *snac;
   24c62:	68a3      	ldr	r3, [r4, #8]
        if (fidelity > p->fidelityThreshold)
   24c64:	ed94 7a16 	vldr	s14, [r4, #88]	; 0x58
   24c68:	edd3 7a08 	vldr	s15, [r3, #32]
   24c6c:	eeb4 7ae7 	vcmpe.f32	s14, s15
   24c70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24c74:	d501      	bpl.n	24c7a <tPeriodDetection_tick+0xf6>
    return(s->periodlength);
   24c76:	69db      	ldr	r3, [r3, #28]
        	p->period = tSNAC_getPeriod(&p->snac);
   24c78:	63a3      	str	r3, [r4, #56]	; 0x38
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
   24c7a:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
        p->curBlock++;
   24c7e:	3301      	adds	r3, #1
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
   24c80:	4293      	cmp	r3, r2
        p->curBlock++;
   24c82:	6223      	str	r3, [r4, #32]
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
   24c84:	db01      	blt.n	24c8a <tPeriodDetection_tick+0x106>
   24c86:	2300      	movs	r3, #0
   24c88:	6223      	str	r3, [r4, #32]
        p->lastBlock++;
   24c8a:	6a63      	ldr	r3, [r4, #36]	; 0x24
}
   24c8c:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
        p->lastBlock++;
   24c90:	3301      	adds	r3, #1
        if (p->lastBlock >= p->framesPerBuffer) p->lastBlock = 0;
   24c92:	429a      	cmp	r2, r3
   24c94:	bfd8      	it	le
   24c96:	2300      	movle	r3, #0
   24c98:	6263      	str	r3, [r4, #36]	; 0x24
}
   24c9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   24c9e:	bf00      	nop

00024ca0 <tPeriodDetection_getPeriod>:

float tPeriodDetection_getPeriod(tPeriodDetection* pd)
{
    _tPeriodDetection* p = *pd;
    return p->period;
   24ca0:	6803      	ldr	r3, [r0, #0]
}
   24ca2:	ed93 0a0e 	vldr	s0, [r3, #56]	; 0x38
   24ca6:	4770      	bx	lr

00024ca8 <tPeriodDetection_setFidelityThreshold>:
    p->windowSize = ws;
}

void tPeriodDetection_setFidelityThreshold(tPeriodDetection* pd, float threshold)
{
    _tPeriodDetection* p = *pd;
   24ca8:	6803      	ldr	r3, [r0, #0]
    p->fidelityThreshold = threshold;
   24caa:	ed83 0a16 	vstr	s0, [r3, #88]	; 0x58
}
   24cae:	4770      	bx	lr

00024cb0 <tLinearDelay_initToPool>:
{
    tLinearDelay_initToPool(dl, delay, maxDelay, &leaf.mempool);
}

void tLinearDelay_initToPool  (tLinearDelay* const dl, float delay, uint32_t maxDelay, tMempool* const mp)
{
   24cb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24cb2:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   24cb6:	6816      	ldr	r6, [r2, #0]
{
   24cb8:	460d      	mov	r5, r1
   24cba:	4607      	mov	r7, r0
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
   24cbc:	202c      	movs	r0, #44	; 0x2c
   24cbe:	4631      	mov	r1, r6
{
   24cc0:	eeb0 8a40 	vmov.f32	s16, s0
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
   24cc4:	f004 ff30 	bl	29b28 <mpool_alloc>
    d->mempool = m;

    d->maxDelay = maxDelay;

    if (delay > maxDelay)   d->delay = maxDelay;
   24cc8:	ee07 5a90 	vmov	s15, r5
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
   24ccc:	6038      	str	r0, [r7, #0]
   24cce:	4604      	mov	r4, r0
    if (delay > maxDelay)   d->delay = maxDelay;
   24cd0:	eef8 7a67 	vcvt.f32.u32	s15, s15
    d->mempool = m;
   24cd4:	6006      	str	r6, [r0, #0]
    d->maxDelay = maxDelay;
   24cd6:	61c5      	str	r5, [r0, #28]
    if (delay > maxDelay)   d->delay = maxDelay;
   24cd8:	eef4 7ac8 	vcmpe.f32	s15, s16
   24cdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24ce0:	d457      	bmi.n	24d92 <tLinearDelay_initToPool+0xe2>
    else if (delay < 0.0f)  d->delay = 0.0f;
   24ce2:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   24ce6:	2300      	movs	r3, #0
   24ce8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24cec:	bf4c      	ite	mi
   24cee:	6203      	strmi	r3, [r0, #32]
    else                    d->delay = delay;
   24cf0:	ed80 8a08 	vstrpl	s16, [r0, #32]

    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   24cf4:	4631      	mov	r1, r6
   24cf6:	00a8      	lsls	r0, r5, #2
   24cf8:	f004 ff16 	bl	29b28 <mpool_alloc>

    d->gain = 1.0f;

    d->lastIn = 0.0f;
   24cfc:	eddf 7a26 	vldr	s15, [pc, #152]	; 24d98 <tLinearDelay_initToPool+0xe8>
    d->gain = 1.0f;
   24d00:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
    d->lastOut = 0.0f;
    
    d->inPoint = 0;
   24d04:	2300      	movs	r3, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   24d06:	60a0      	str	r0, [r4, #8]

int     tLinearDelay_setDelay (tLinearDelay* const dl, float delay)
{
    _tLinearDelay* d = *dl;

    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   24d08:	eeb0 0a67 	vmov.f32	s0, s15
    d->gain = 1.0f;
   24d0c:	6062      	str	r2, [r4, #4]
    d->lastIn = 0.0f;
   24d0e:	edc4 7a04 	vstr	s15, [r4, #16]
    d->lastOut = 0.0f;
   24d12:	edc4 7a03 	vstr	s15, [r4, #12]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   24d16:	edd4 0a08 	vldr	s1, [r4, #32]
    d->outPoint = 0;
   24d1a:	e9c4 3305 	strd	r3, r3, [r4, #20]
    _tLinearDelay* d = *dl;
   24d1e:	683d      	ldr	r5, [r7, #0]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   24d20:	edd5 7a07 	vldr	s15, [r5, #28]
   24d24:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   24d28:	f004 fcfe 	bl	29728 <LEAF_clip>

    float outPointer = d->inPoint - d->delay;
   24d2c:	edd5 7a05 	vldr	s15, [r5, #20]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   24d30:	ed85 0a08 	vstr	s0, [r5, #32]
    float outPointer = d->inPoint - d->delay;
   24d34:	eef8 7a67 	vcvt.f32.u32	s15, s15

    while ( outPointer < 0 )
        outPointer += d->maxDelay; // modulo maximum length
   24d38:	69ea      	ldr	r2, [r5, #28]
    float outPointer = d->inPoint - d->delay;
   24d3a:	ee37 0ac0 	vsub.f32	s0, s15, s0
    while ( outPointer < 0 )
   24d3e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   24d42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24d46:	d50a      	bpl.n	24d5e <tLinearDelay_initToPool+0xae>
        outPointer += d->maxDelay; // modulo maximum length
   24d48:	ee07 2a90 	vmov	s15, r2
   24d4c:	eef8 7a67 	vcvt.f32.u32	s15, s15
   24d50:	ee30 0a27 	vadd.f32	s0, s0, s15
    while ( outPointer < 0 )
   24d54:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   24d58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24d5c:	d4f8      	bmi.n	24d50 <tLinearDelay_initToPool+0xa0>

    d->outPoint = (uint32_t) outPointer;   // integer part
   24d5e:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   24d62:	ee17 3a90 	vmov	r3, s15

    d->alpha = outPointer - d->outPoint; // fractional part
    d->omAlpha = 1.0f - d->alpha;
   24d66:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->alpha = outPointer - d->outPoint; // fractional part
   24d6a:	ee07 3a10 	vmov	s14, r3

    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   24d6e:	4293      	cmp	r3, r2
    d->outPoint = (uint32_t) outPointer;   // integer part
   24d70:	61ab      	str	r3, [r5, #24]
    d->alpha = outPointer - d->outPoint; // fractional part
   24d72:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   24d76:	ee30 0a47 	vsub.f32	s0, s0, s14
    d->omAlpha = 1.0f - d->alpha;
   24d7a:	ee77 7ac0 	vsub.f32	s15, s15, s0
    d->alpha = outPointer - d->outPoint; // fractional part
   24d7e:	ed85 0a09 	vstr	s0, [r5, #36]	; 0x24
    d->omAlpha = 1.0f - d->alpha;
   24d82:	edc5 7a0a 	vstr	s15, [r5, #40]	; 0x28
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   24d86:	d101      	bne.n	24d8c <tLinearDelay_initToPool+0xdc>
   24d88:	2300      	movs	r3, #0
   24d8a:	61ab      	str	r3, [r5, #24]
}
   24d8c:	ecbd 8b02 	vpop	{d8}
   24d90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (delay > maxDelay)   d->delay = maxDelay;
   24d92:	edc0 7a08 	vstr	s15, [r0, #32]
   24d96:	e7ad      	b.n	24cf4 <tLinearDelay_initToPool+0x44>
   24d98:	00000000 	.word	0x00000000

00024d9c <tLinearDelay_free>:
{
   24d9c:	b510      	push	{r4, lr}
    _tLinearDelay* d = *dl;
   24d9e:	6804      	ldr	r4, [r0, #0]
    mpool_free((char*)d->buff, d->mempool);
   24da0:	6821      	ldr	r1, [r4, #0]
   24da2:	68a0      	ldr	r0, [r4, #8]
   24da4:	f004 ff68 	bl	29c78 <mpool_free>
    mpool_free((char*)d, d->mempool);
   24da8:	6821      	ldr	r1, [r4, #0]
   24daa:	4620      	mov	r0, r4
}
   24dac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)d, d->mempool);
   24db0:	f004 bf62 	b.w	29c78 <mpool_free>

00024db4 <tLinearDelay_clear>:
	_tLinearDelay* d = *dl;
   24db4:	6801      	ldr	r1, [r0, #0]
	for (int i = 0; i < d->maxDelay; i++)
   24db6:	69cb      	ldr	r3, [r1, #28]
   24db8:	b14b      	cbz	r3, 24dce <tLinearDelay_clear+0x1a>
   24dba:	2300      	movs	r3, #0
		d->buff[i] = 0;
   24dbc:	2000      	movs	r0, #0
   24dbe:	688a      	ldr	r2, [r1, #8]
   24dc0:	eb02 0283 	add.w	r2, r2, r3, lsl #2
	for (int i = 0; i < d->maxDelay; i++)
   24dc4:	3301      	adds	r3, #1
		d->buff[i] = 0;
   24dc6:	6010      	str	r0, [r2, #0]
	for (int i = 0; i < d->maxDelay; i++)
   24dc8:	69ca      	ldr	r2, [r1, #28]
   24dca:	429a      	cmp	r2, r3
   24dcc:	d8f7      	bhi.n	24dbe <tLinearDelay_clear+0xa>
}
   24dce:	4770      	bx	lr

00024dd0 <tLinearDelay_tick>:
{
   24dd0:	b410      	push	{r4}
    _tLinearDelay* d = *dl;
   24dd2:	6803      	ldr	r3, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
   24dd4:	edd3 7a01 	vldr	s15, [r3, #4]
   24dd8:	6959      	ldr	r1, [r3, #20]
   24dda:	689a      	ldr	r2, [r3, #8]
   24ddc:	ee27 0a80 	vmul.f32	s0, s15, s0
   24de0:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   24de4:	ed82 0a00 	vstr	s0, [r2]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
   24de8:	695a      	ldr	r2, [r3, #20]
   24dea:	69d9      	ldr	r1, [r3, #28]
   24dec:	3201      	adds	r2, #1
   24dee:	428a      	cmp	r2, r1
   24df0:	615a      	str	r2, [r3, #20]
   24df2:	d101      	bne.n	24df8 <tLinearDelay_tick+0x28>
   24df4:	2200      	movs	r2, #0
   24df6:	615a      	str	r2, [r3, #20]
    uint32_t idx = (uint32_t) d->outPoint;
   24df8:	699a      	ldr	r2, [r3, #24]
    d->lastOut = d->buff[idx] * d->omAlpha;
   24dfa:	6898      	ldr	r0, [r3, #8]
    if ((idx + 1) < d->maxDelay)
   24dfc:	1c54      	adds	r4, r2, #1
    d->lastOut = d->buff[idx] * d->omAlpha;
   24dfe:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
   24e02:	eb00 0282 	add.w	r2, r0, r2, lsl #2
   24e06:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    if ((idx + 1) < d->maxDelay)
   24e0a:	42a1      	cmp	r1, r4
    d->lastOut = d->buff[idx] * d->omAlpha;
   24e0c:	ed92 0a00 	vldr	s0, [r2]
   24e10:	ee20 0a07 	vmul.f32	s0, s0, s14
   24e14:	ed83 0a03 	vstr	s0, [r3, #12]
    if ((idx + 1) < d->maxDelay)
   24e18:	d909      	bls.n	24e2e <tLinearDelay_tick+0x5e>
        d->lastOut += d->buff[idx+1] * d->alpha;
   24e1a:	ed92 7a01 	vldr	s14, [r2, #4]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   24e1e:	619c      	str	r4, [r3, #24]
        d->lastOut += d->buff[idx+1] * d->alpha;
   24e20:	eea7 0a27 	vfma.f32	s0, s14, s15
   24e24:	ed83 0a03 	vstr	s0, [r3, #12]
}
   24e28:	f85d 4b04 	ldr.w	r4, [sp], #4
   24e2c:	4770      	bx	lr
        d->lastOut += d->buff[0] * d->alpha;
   24e2e:	ed90 7a00 	vldr	s14, [r0]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   24e32:	2200      	movs	r2, #0
        d->lastOut += d->buff[0] * d->alpha;
   24e34:	eea7 0a27 	vfma.f32	s0, s14, s15
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   24e38:	619a      	str	r2, [r3, #24]
        d->lastOut += d->buff[0] * d->alpha;
   24e3a:	ed83 0a03 	vstr	s0, [r3, #12]
}
   24e3e:	f85d 4b04 	ldr.w	r4, [sp], #4
   24e42:	4770      	bx	lr

00024e44 <tLinearDelay_tickIn>:
    _tLinearDelay* d = *dl;
   24e44:	6803      	ldr	r3, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
   24e46:	edd3 7a01 	vldr	s15, [r3, #4]
   24e4a:	6959      	ldr	r1, [r3, #20]
   24e4c:	689a      	ldr	r2, [r3, #8]
   24e4e:	ee27 0a80 	vmul.f32	s0, s15, s0
   24e52:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   24e56:	ed82 0a00 	vstr	s0, [r2]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
   24e5a:	695a      	ldr	r2, [r3, #20]
   24e5c:	69d9      	ldr	r1, [r3, #28]
   24e5e:	3201      	adds	r2, #1
   24e60:	428a      	cmp	r2, r1
   24e62:	615a      	str	r2, [r3, #20]
   24e64:	d101      	bne.n	24e6a <tLinearDelay_tickIn+0x26>
   24e66:	2200      	movs	r2, #0
   24e68:	615a      	str	r2, [r3, #20]
}
   24e6a:	4770      	bx	lr

00024e6c <tLinearDelay_tickOut>:
{
   24e6c:	b410      	push	{r4}
    _tLinearDelay* d = *dl;
   24e6e:	6803      	ldr	r3, [r0, #0]
	uint32_t idx = (uint32_t) d->outPoint;
   24e70:	699a      	ldr	r2, [r3, #24]
	d->lastOut = d->buff[idx] * d->omAlpha;
   24e72:	6899      	ldr	r1, [r3, #8]
	if ((idx + 1) < d->maxDelay)
   24e74:	1c50      	adds	r0, r2, #1
	d->lastOut = d->buff[idx] * d->omAlpha;
   24e76:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
   24e7a:	eb01 0282 	add.w	r2, r1, r2, lsl #2
	if ((idx + 1) < d->maxDelay)
   24e7e:	69dc      	ldr	r4, [r3, #28]
   24e80:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
	d->lastOut = d->buff[idx] * d->omAlpha;
   24e84:	ed92 0a00 	vldr	s0, [r2]
	if ((idx + 1) < d->maxDelay)
   24e88:	42a0      	cmp	r0, r4
	d->lastOut = d->buff[idx] * d->omAlpha;
   24e8a:	ee20 0a07 	vmul.f32	s0, s0, s14
   24e8e:	ed83 0a03 	vstr	s0, [r3, #12]
	if ((idx + 1) < d->maxDelay)
   24e92:	d209      	bcs.n	24ea8 <tLinearDelay_tickOut+0x3c>
		d->lastOut += d->buff[idx+1] * d->alpha;
   24e94:	ed92 7a01 	vldr	s14, [r2, #4]
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   24e98:	6198      	str	r0, [r3, #24]
		d->lastOut += d->buff[idx+1] * d->alpha;
   24e9a:	eea7 0a27 	vfma.f32	s0, s14, s15
   24e9e:	ed83 0a03 	vstr	s0, [r3, #12]
}
   24ea2:	f85d 4b04 	ldr.w	r4, [sp], #4
   24ea6:	4770      	bx	lr
		d->lastOut += d->buff[0] * d->alpha;
   24ea8:	ed91 7a00 	vldr	s14, [r1]
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   24eac:	2200      	movs	r2, #0
		d->lastOut += d->buff[0] * d->alpha;
   24eae:	eea7 0a27 	vfma.f32	s0, s14, s15
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   24eb2:	619a      	str	r2, [r3, #24]
		d->lastOut += d->buff[0] * d->alpha;
   24eb4:	ed83 0a03 	vstr	s0, [r3, #12]
}
   24eb8:	f85d 4b04 	ldr.w	r4, [sp], #4
   24ebc:	4770      	bx	lr
   24ebe:	bf00      	nop

00024ec0 <tLinearDelay_setDelay>:
{
   24ec0:	b510      	push	{r4, lr}
    _tLinearDelay* d = *dl;
   24ec2:	6804      	ldr	r4, [r0, #0]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   24ec4:	eef0 0a40 	vmov.f32	s1, s0
   24ec8:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 24f3c <tLinearDelay_setDelay+0x7c>
   24ecc:	edd4 7a07 	vldr	s15, [r4, #28]
   24ed0:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   24ed4:	f004 fc28 	bl	29728 <LEAF_clip>
    float outPointer = d->inPoint - d->delay;
   24ed8:	edd4 7a05 	vldr	s15, [r4, #20]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   24edc:	ed84 0a08 	vstr	s0, [r4, #32]
    float outPointer = d->inPoint - d->delay;
   24ee0:	eef8 7a67 	vcvt.f32.u32	s15, s15
        outPointer += d->maxDelay; // modulo maximum length
   24ee4:	69e2      	ldr	r2, [r4, #28]
    float outPointer = d->inPoint - d->delay;
   24ee6:	ee37 0ac0 	vsub.f32	s0, s15, s0
    while ( outPointer < 0 )
   24eea:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   24eee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24ef2:	d50a      	bpl.n	24f0a <tLinearDelay_setDelay+0x4a>
        outPointer += d->maxDelay; // modulo maximum length
   24ef4:	ee07 2a90 	vmov	s15, r2
   24ef8:	eef8 7a67 	vcvt.f32.u32	s15, s15
   24efc:	ee30 0a27 	vadd.f32	s0, s0, s15
    while ( outPointer < 0 )
   24f00:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   24f04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24f08:	d4f8      	bmi.n	24efc <tLinearDelay_setDelay+0x3c>
    d->outPoint = (uint32_t) outPointer;   // integer part
   24f0a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   24f0e:	ee17 3a90 	vmov	r3, s15
    d->omAlpha = 1.0f - d->alpha;
   24f12:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->alpha = outPointer - d->outPoint; // fractional part
   24f16:	ee07 3a10 	vmov	s14, r3
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   24f1a:	4293      	cmp	r3, r2
    d->outPoint = (uint32_t) outPointer;   // integer part
   24f1c:	61a3      	str	r3, [r4, #24]
    d->alpha = outPointer - d->outPoint; // fractional part
   24f1e:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   24f22:	ee30 0a47 	vsub.f32	s0, s0, s14
    d->omAlpha = 1.0f - d->alpha;
   24f26:	ee77 7ac0 	vsub.f32	s15, s15, s0
    d->alpha = outPointer - d->outPoint; // fractional part
   24f2a:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
    d->omAlpha = 1.0f - d->alpha;
   24f2e:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   24f32:	d101      	bne.n	24f38 <tLinearDelay_setDelay+0x78>
   24f34:	2300      	movs	r3, #0
   24f36:	61a3      	str	r3, [r4, #24]

    return 0;
}
   24f38:	2000      	movs	r0, #0
   24f3a:	bd10      	pop	{r4, pc}
   24f3c:	00000000 	.word	0x00000000

00024f40 <tLinearDelay_getDelay>:
}

float   tLinearDelay_getDelay (tLinearDelay* const dl)
{
    _tLinearDelay* d = *dl;
    return d->delay;
   24f40:	6803      	ldr	r3, [r0, #0]
}
   24f42:	ed93 0a08 	vldr	s0, [r3, #32]
   24f46:	4770      	bx	lr

00024f48 <tLinearDelay_getLastOut>:

float   tLinearDelay_getLastOut (tLinearDelay* const dl)
{
    _tLinearDelay* d = *dl;
    return d->lastOut;
   24f48:	6803      	ldr	r3, [r0, #0]
}
   24f4a:	ed93 0a03 	vldr	s0, [r3, #12]
   24f4e:	4770      	bx	lr

00024f50 <tTapeDelay_init>:
    return d->gain;
}

// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ TapeDelay ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ //
void tTapeDelay_init (tTapeDelay* const dl, float delay, uint32_t maxDelay)
{
   24f50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tTapeDelay_initToPool(dl, delay, maxDelay, &leaf.mempool);
}

void tTapeDelay_initToPool (tTapeDelay* const dl, float delay, uint32_t maxDelay, tMempool* const mp)
{
    _tMempool* m = *mp;
   24f52:	4b18      	ldr	r3, [pc, #96]	; (24fb4 <tTapeDelay_init+0x64>)
{
   24f54:	4606      	mov	r6, r0
   24f56:	460f      	mov	r7, r1
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   24f58:	202c      	movs	r0, #44	; 0x2c
{
   24f5a:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   24f5e:	699d      	ldr	r5, [r3, #24]
{
   24f60:	eeb0 8a40 	vmov.f32	s16, s0
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   24f64:	4629      	mov	r1, r5
   24f66:	f004 fddf 	bl	29b28 <mpool_alloc>
   24f6a:	4604      	mov	r4, r0
    d->mempool = m;

    d->maxDelay = maxDelay;

    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   24f6c:	4629      	mov	r1, r5
   24f6e:	00b8      	lsls	r0, r7, #2
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   24f70:	6034      	str	r4, [r6, #0]
    d->mempool = m;
   24f72:	6025      	str	r5, [r4, #0]
    d->maxDelay = maxDelay;
   24f74:	61a7      	str	r7, [r4, #24]
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   24f76:	f004 fdd7 	bl	29b28 <mpool_alloc>

    d->gain = 1.0f;
   24f7a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0

    d->lastIn = 0.0f;
   24f7e:	2300      	movs	r3, #0
    d->lastOut = 0.0f;

    d->idx = 0.0f;
    d->inc = 1.0f;
    d->inPoint = 0;
   24f80:	2200      	movs	r2, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   24f82:	60a0      	str	r0, [r4, #8]
}

void     tTapeDelay_setDelay (tTapeDelay* const dl, float delay)
{
    _tTapeDelay* d = *dl;
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   24f84:	eef0 0a48 	vmov.f32	s1, s16
    d->gain = 1.0f;
   24f88:	edc4 7a01 	vstr	s15, [r4, #4]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   24f8c:	eeb0 0a67 	vmov.f32	s0, s15
    d->inc = 1.0f;
   24f90:	edc4 7a08 	vstr	s15, [r4, #32]
    d->inPoint = 0;
   24f94:	6162      	str	r2, [r4, #20]
    d->lastIn = 0.0f;
   24f96:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
   24f98:	60e3      	str	r3, [r4, #12]
    d->idx = 0.0f;
   24f9a:	6263      	str	r3, [r4, #36]	; 0x24
    _tTapeDelay* d = *dl;
   24f9c:	6834      	ldr	r4, [r6, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   24f9e:	edd4 7a06 	vldr	s15, [r4, #24]
   24fa2:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   24fa6:	f004 fbbf 	bl	29728 <LEAF_clip>
   24faa:	ed84 0a07 	vstr	s0, [r4, #28]
}
   24fae:	ecbd 8b02 	vpop	{d8}
   24fb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   24fb4:	020fbd68 	.word	0x020fbd68

00024fb8 <tTapeDelay_initToPool>:
{
   24fb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24fba:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   24fbe:	6815      	ldr	r5, [r2, #0]
{
   24fc0:	4606      	mov	r6, r0
   24fc2:	460f      	mov	r7, r1
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   24fc4:	202c      	movs	r0, #44	; 0x2c
   24fc6:	4629      	mov	r1, r5
{
   24fc8:	eeb0 8a40 	vmov.f32	s16, s0
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   24fcc:	f004 fdac 	bl	29b28 <mpool_alloc>
   24fd0:	4604      	mov	r4, r0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   24fd2:	4629      	mov	r1, r5
   24fd4:	00b8      	lsls	r0, r7, #2
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   24fd6:	6034      	str	r4, [r6, #0]
    d->mempool = m;
   24fd8:	6025      	str	r5, [r4, #0]
    d->maxDelay = maxDelay;
   24fda:	61a7      	str	r7, [r4, #24]
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   24fdc:	f004 fda4 	bl	29b28 <mpool_alloc>
    d->gain = 1.0f;
   24fe0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->lastIn = 0.0f;
   24fe4:	2300      	movs	r3, #0
    d->inPoint = 0;
   24fe6:	2200      	movs	r2, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   24fe8:	60a0      	str	r0, [r4, #8]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   24fea:	eef0 0a48 	vmov.f32	s1, s16
    d->gain = 1.0f;
   24fee:	edc4 7a01 	vstr	s15, [r4, #4]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   24ff2:	eeb0 0a67 	vmov.f32	s0, s15
    d->inc = 1.0f;
   24ff6:	edc4 7a08 	vstr	s15, [r4, #32]
    d->inPoint = 0;
   24ffa:	6162      	str	r2, [r4, #20]
    d->lastIn = 0.0f;
   24ffc:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
   24ffe:	60e3      	str	r3, [r4, #12]
    d->idx = 0.0f;
   25000:	6263      	str	r3, [r4, #36]	; 0x24
    _tTapeDelay* d = *dl;
   25002:	6834      	ldr	r4, [r6, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   25004:	edd4 7a06 	vldr	s15, [r4, #24]
   25008:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   2500c:	f004 fb8c 	bl	29728 <LEAF_clip>
   25010:	ed84 0a07 	vstr	s0, [r4, #28]
}
   25014:	ecbd 8b02 	vpop	{d8}
   25018:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2501a:	bf00      	nop

0002501c <tTapeDelay_free>:
{
   2501c:	b510      	push	{r4, lr}
    _tTapeDelay* d = *dl;
   2501e:	6804      	ldr	r4, [r0, #0]
    mpool_free((char*)d->buff, d->mempool);
   25020:	6821      	ldr	r1, [r4, #0]
   25022:	68a0      	ldr	r0, [r4, #8]
   25024:	f004 fe28 	bl	29c78 <mpool_free>
    mpool_free((char*)d, d->mempool);
   25028:	6821      	ldr	r1, [r4, #0]
   2502a:	4620      	mov	r0, r4
}
   2502c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)d, d->mempool);
   25030:	f004 be22 	b.w	29c78 <mpool_free>

00025034 <tTapeDelay_tick>:
{
   25034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tTapeDelay* d = *dl;
   25036:	6804      	ldr	r4, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
   25038:	edd4 7a01 	vldr	s15, [r4, #4]
   2503c:	6962      	ldr	r2, [r4, #20]
   2503e:	68a3      	ldr	r3, [r4, #8]
   25040:	ee27 0a80 	vmul.f32	s0, s15, s0
   25044:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   25048:	ed83 0a00 	vstr	s0, [r3]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
   2504c:	e9d4 2305 	ldrd	r2, r3, [r4, #20]
   25050:	3201      	adds	r2, #1
   25052:	429a      	cmp	r2, r3
   25054:	6162      	str	r2, [r4, #20]
   25056:	d101      	bne.n	2505c <tTapeDelay_tick+0x28>
   25058:	2200      	movs	r2, #0
   2505a:	6162      	str	r2, [r4, #20]
    int idx =  (int) d->idx;
   2505c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   25060:	1e5e      	subs	r6, r3, #1
   25062:	68a1      	ldr	r1, [r4, #8]
    int idx =  (int) d->idx;
   25064:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   25068:	ee17 2a10 	vmov	r2, s14
    float alpha = d->idx - idx;
   2506c:	eeb8 2ac7 	vcvt.f32.s32	s4, s14
                                              d->buff[(idx + 1) % d->maxDelay],
   25070:	1c57      	adds	r7, r2, #1
                                              d->buff[(idx + 2) % d->maxDelay],
   25072:	f102 0c02 	add.w	ip, r2, #2
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   25076:	4416      	add	r6, r2
   25078:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   2507c:	ee37 2ac2 	vsub.f32	s4, s15, s4
   25080:	edd2 0a00 	vldr	s1, [r2]
                                              d->buff[(idx + 1) % d->maxDelay],
   25084:	fbb7 f0f3 	udiv	r0, r7, r3
   25088:	fb03 7010 	mls	r0, r3, r0, r7
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2508c:	eb01 0280 	add.w	r2, r1, r0, lsl #2
                                              d->buff[(idx + 2) % d->maxDelay],
   25090:	fbbc f5f3 	udiv	r5, ip, r3
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   25094:	ed92 1a00 	vldr	s2, [r2]
                                              d->buff[(idx + 2) % d->maxDelay],
   25098:	fb03 c515 	mls	r5, r3, r5, ip
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2509c:	fbb6 f2f3 	udiv	r2, r6, r3
   250a0:	fb03 6312 	mls	r3, r3, r2, r6
   250a4:	eb01 0585 	add.w	r5, r1, r5, lsl #2
   250a8:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   250ac:	edd5 1a00 	vldr	s3, [r5]
   250b0:	ed91 0a00 	vldr	s0, [r1]
   250b4:	f004 fc50 	bl	29958 <LEAF_interpolate_hermite_x>
    float diff = (d->inPoint - d->idx);
   250b8:	edd4 7a05 	vldr	s15, [r4, #20]
   250bc:	edd4 6a09 	vldr	s13, [r4, #36]	; 0x24
   250c0:	eef8 7a67 	vcvt.f32.u32	s15, s15
    while (diff < 0.f) diff += d->maxDelay;
   250c4:	ed94 7a06 	vldr	s14, [r4, #24]
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   250c8:	ed84 0a03 	vstr	s0, [r4, #12]
    while (diff < 0.f) diff += d->maxDelay;
   250cc:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    float diff = (d->inPoint - d->idx);
   250d0:	ee77 7ae6 	vsub.f32	s15, s15, s13
    while (diff < 0.f) diff += d->maxDelay;
   250d4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   250d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   250dc:	d506      	bpl.n	250ec <tTapeDelay_tick+0xb8>
   250de:	ee77 7a87 	vadd.f32	s15, s15, s14
   250e2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   250e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   250ea:	d4f8      	bmi.n	250de <tTapeDelay_tick+0xaa>
    d->inc = 1.0f + (diff - d->delay) / d->delay; //* SMOOTH_FACTOR;
   250ec:	edd4 5a07 	vldr	s11, [r4, #28]
   250f0:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   250f4:	ee77 7ae5 	vsub.f32	s15, s15, s11
   250f8:	ee87 6aa5 	vdiv.f32	s12, s15, s11
   250fc:	ee76 7a05 	vadd.f32	s15, s12, s10
    d->idx += d->inc;
   25100:	ee76 6aa7 	vadd.f32	s13, s13, s15
    d->inc = 1.0f + (diff - d->delay) / d->delay; //* SMOOTH_FACTOR;
   25104:	edc4 7a08 	vstr	s15, [r4, #32]
    if (d->idx >= d->maxDelay) d->idx = 0.0f;
   25108:	eef4 6ac7 	vcmpe.f32	s13, s14
   2510c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25110:	da02      	bge.n	25118 <tTapeDelay_tick+0xe4>
    d->idx += d->inc;
   25112:	edc4 6a09 	vstr	s13, [r4, #36]	; 0x24
}
   25116:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (d->idx >= d->maxDelay) d->idx = 0.0f;
   25118:	2300      	movs	r3, #0
   2511a:	6263      	str	r3, [r4, #36]	; 0x24
}
   2511c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2511e:	bf00      	nop

00025120 <tTapeDelay_setDelay>:
{
   25120:	b510      	push	{r4, lr}
    _tTapeDelay* d = *dl;
   25122:	6804      	ldr	r4, [r0, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   25124:	eef0 0a40 	vmov.f32	s1, s0
   25128:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2512c:	edd4 7a06 	vldr	s15, [r4, #24]
   25130:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   25134:	f004 faf8 	bl	29728 <LEAF_clip>
   25138:	ed84 0a07 	vstr	s0, [r4, #28]
}
   2513c:	bd10      	pop	{r4, pc}
   2513e:	bf00      	nop

00025140 <tTapeDelay_tapOut>:

float tTapeDelay_tapOut (tTapeDelay* const dl, float tapDelay)
{
   25140:	b4f0      	push	{r4, r5, r6, r7}
    _tTapeDelay* d = *dl;
   25142:	6801      	ldr	r1, [r0, #0]

    float tap = (float) d->inPoint - tapDelay - 1.f;
   25144:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   25148:	edd1 7a05 	vldr	s15, [r1, #20]
   2514c:	698b      	ldr	r3, [r1, #24]
   2514e:	eef8 7a67 	vcvt.f32.u32	s15, s15
   25152:	ee37 0ac0 	vsub.f32	s0, s15, s0

    // Check for wraparound.
    while ( tap < 0.f )   tap += (float)d->maxDelay;
   25156:	eeb4 0ac7 	vcmpe.f32	s0, s14
    float tap = (float) d->inPoint - tapDelay - 1.f;
   2515a:	ee70 7a47 	vsub.f32	s15, s0, s14
    while ( tap < 0.f )   tap += (float)d->maxDelay;
   2515e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25162:	d50a      	bpl.n	2517a <tTapeDelay_tapOut+0x3a>
   25164:	ee07 3a10 	vmov	s14, r3
   25168:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   2516c:	ee77 7a87 	vadd.f32	s15, s15, s14
   25170:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   25174:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25178:	d4f8      	bmi.n	2516c <tTapeDelay_tapOut+0x2c>

    int idx =  (int) tap;
   2517a:	eebd 7ae7 	vcvt.s32.f32	s14, s15

    float alpha = tap - idx;

    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2517e:	6889      	ldr	r1, [r1, #8]
   25180:	1e5d      	subs	r5, r3, #1
    int idx =  (int) tap;
   25182:	ee17 2a10 	vmov	r2, s14
    float alpha = tap - idx;
   25186:	eeb8 2ac7 	vcvt.f32.s32	s4, s14
                                              d->buff[idx],
                                              d->buff[(idx + 1) % d->maxDelay],
   2518a:	1c56      	adds	r6, r2, #1
                                              d->buff[(idx + 2) % d->maxDelay],
   2518c:	1c97      	adds	r7, r2, #2
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2518e:	4415      	add	r5, r2
   25190:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   25194:	ee37 2ac2 	vsub.f32	s4, s15, s4
   25198:	edd2 0a00 	vldr	s1, [r2]
                                              d->buff[(idx + 1) % d->maxDelay],
   2519c:	fbb6 f0f3 	udiv	r0, r6, r3
   251a0:	fb03 6210 	mls	r2, r3, r0, r6
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   251a4:	eb01 0282 	add.w	r2, r1, r2, lsl #2
                                              d->buff[(idx + 2) % d->maxDelay],
   251a8:	fbb7 f4f3 	udiv	r4, r7, r3
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   251ac:	ed92 1a00 	vldr	s2, [r2]
                                              d->buff[(idx + 2) % d->maxDelay],
   251b0:	fb03 7414 	mls	r4, r3, r4, r7
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   251b4:	fbb5 f2f3 	udiv	r2, r5, r3
   251b8:	fb03 5312 	mls	r3, r3, r2, r5
   251bc:	eb01 0084 	add.w	r0, r1, r4, lsl #2
   251c0:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   251c4:	edd0 1a00 	vldr	s3, [r0]
   251c8:	ed91 0a00 	vldr	s0, [r1]
                                              alpha);

    return samp;

}
   251cc:	bcf0      	pop	{r4, r5, r6, r7}
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   251ce:	f004 bbc3 	b.w	29958 <LEAF_interpolate_hermite_x>
   251d2:	bf00      	nop

000251d4 <tOversampler_initToPool>:
{
    tOversampler_initToPool(osr, ratio, extraQuality, &leaf.mempool);
}

void tOversampler_initToPool (tOversampler* const osr, int ratio, int extraQuality, tMempool* const mp)
{
   251d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tMempool* m = *mp;
   251d8:	681e      	ldr	r6, [r3, #0]
{
   251da:	4617      	mov	r7, r2
   251dc:	460d      	mov	r5, r1
   251de:	4680      	mov	r8, r0
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
   251e0:	4631      	mov	r1, r6
   251e2:	201c      	movs	r0, #28
   251e4:	f004 fca0 	bl	29b28 <mpool_alloc>
   251e8:	2f00      	cmp	r7, #0
    os->mempool = m;
    
    uint8_t offset = 0;
    if (extraQuality) offset = 6;
    if (ratio == 2 || ratio == 4  ||
   251ea:	f1a5 0202 	sub.w	r2, r5, #2
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
   251ee:	f8c8 0000 	str.w	r0, [r8]
   251f2:	bf18      	it	ne
   251f4:	2706      	movne	r7, #6
   251f6:	4604      	mov	r4, r0
    if (ratio == 2 || ratio == 4  ||
   251f8:	2a1e      	cmp	r2, #30
    os->mempool = m;
   251fa:	6006      	str	r6, [r0, #0]
    if (ratio == 2 || ratio == 4  ||
   251fc:	d92d      	bls.n	2525a <tOversampler_initToPool+0x86>
        ratio == 8 || ratio == 16 ||
        ratio == 32 || ratio == 64) {
   251fe:	2d40      	cmp	r5, #64	; 0x40
   25200:	d129      	bne.n	25256 <tOversampler_initToPool+0x82>
        os->ratio = ratio;
        int idx = (int)(log2f(os->ratio))-1+offset;
   25202:	ee07 5a90 	vmov	s15, r5
        os->ratio = ratio;
   25206:	6065      	str	r5, [r4, #4]
        int idx = (int)(log2f(os->ratio))-1+offset;
   25208:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   2520c:	f007 fdc0 	bl	2cd90 <log2f>
   25210:	eebd 0ac0 	vcvt.s32.f32	s0, s0
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
   25214:	4814      	ldr	r0, [pc, #80]	; (25268 <tOversampler_initToPool+0x94>)
        os->phaseLength = os->numTaps / os->ratio;
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   25216:	4631      	mov	r1, r6
        int idx = (int)(log2f(os->ratio))-1+offset;
   25218:	ee10 3a10 	vmov	r3, s0
   2521c:	3b01      	subs	r3, #1
   2521e:	19da      	adds	r2, r3, r7
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
   25220:	4f12      	ldr	r7, [pc, #72]	; (2526c <tOversampler_initToPool+0x98>)
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
   25222:	eb00 0382 	add.w	r3, r0, r2, lsl #2
   25226:	edd3 7a00 	vldr	s15, [r3]
   2522a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2522e:	ee17 0a90 	vmov	r0, s15
   25232:	edc4 7a05 	vstr	s15, [r4, #20]
        os->phaseLength = os->numTaps / os->ratio;
   25236:	fb90 f5f5 	sdiv	r5, r0, r5
   2523a:	61a5      	str	r5, [r4, #24]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   2523c:	00c0      	lsls	r0, r0, #3
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
   2523e:	f857 3022 	ldr.w	r3, [r7, r2, lsl #2]
   25242:	60a3      	str	r3, [r4, #8]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   25244:	f004 fc70 	bl	29b28 <mpool_alloc>
        os->downState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   25248:	6963      	ldr	r3, [r4, #20]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   2524a:	60e0      	str	r0, [r4, #12]
        os->downState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   2524c:	4631      	mov	r1, r6
   2524e:	00d8      	lsls	r0, r3, #3
   25250:	f004 fc6a 	bl	29b28 <mpool_alloc>
   25254:	6120      	str	r0, [r4, #16]
    }
}
   25256:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (ratio == 2 || ratio == 4  ||
   2525a:	4b05      	ldr	r3, [pc, #20]	; (25270 <tOversampler_initToPool+0x9c>)
   2525c:	40d3      	lsrs	r3, r2
   2525e:	07db      	lsls	r3, r3, #31
   25260:	d4cf      	bmi.n	25202 <tOversampler_initToPool+0x2e>
}
   25262:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   25266:	bf00      	nop
   25268:	00051b64 	.word	0x00051b64
   2526c:	00062910 	.word	0x00062910
   25270:	40004045 	.word	0x40004045

00025274 <tOversampler_free>:

void tOversampler_free (tOversampler* const osr)
{
   25274:	b510      	push	{r4, lr}
    _tOversampler* os = *osr;
   25276:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)os->upState, os->mempool);
   25278:	6821      	ldr	r1, [r4, #0]
   2527a:	68e0      	ldr	r0, [r4, #12]
   2527c:	f004 fcfc 	bl	29c78 <mpool_free>
    mpool_free((char*)os->downState, os->mempool);
   25280:	6821      	ldr	r1, [r4, #0]
   25282:	6920      	ldr	r0, [r4, #16]
   25284:	f004 fcf8 	bl	29c78 <mpool_free>
    mpool_free((char*)os, os->mempool);
   25288:	6821      	ldr	r1, [r4, #0]
   2528a:	4620      	mov	r0, r4
}
   2528c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)os, os->mempool);
   25290:	f004 bcf2 	b.w	29c78 <mpool_free>

00025294 <tOversampler_tick>:

float tOversampler_tick(tOversampler* const osr, float input, float* oversample, float (*effectTick)(float))
{
   25294:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tOversampler* os = *osr;
   25298:	f8d0 9000 	ldr.w	r9, [r0]
{
   2529c:	4680      	mov	r8, r0
   2529e:	468a      	mov	sl, r1
   252a0:	4617      	mov	r7, r2
// From CMSIS DSP Library
void tOversampler_upsample(tOversampler* const osr, float input, float* output)
{
    _tOversampler* os = *osr;
    
    float *pState = os->upState;                 /* State pointer */
   252a2:	f8d9 c00c 	ldr.w	ip, [r9, #12]
    float *pStateCur;
    float *ptr1;                               /* Temporary pointer for state buffer */
    float *ptr2;                               /* Temporary pointer for coefficient buffer */
    float sum0;                                /* Accumulators */
    uint32_t i, tapCnt;                    /* Loop counters */
    uint32_t phaseLen = os->phaseLength;            /* Length of each polyphase filter component */
   252a6:	f8d9 5018 	ldr.w	r5, [r9, #24]
    float *pCoeffs = os->pCoeffs;               /* Coefficient pointer */
   252aa:	f8d9 e008 	ldr.w	lr, [r9, #8]
    /* os->pState buffer contains previous frame (phaseLen - 1) samples */
    /* pStateCur points to the location where the new input data should be written */
    pStateCur = os->upState + (phaseLen - 1U);
    
    /* Copy new input sample into the state buffer */
    *pStateCur = input;
   252ae:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
   252b2:	ed03 0a01 	vstr	s0, [r3, #-4]
    
    /* Address modifier index of coefficient buffer */
    j = 1U;
    
    /* Loop over the Interpolation factor. */
    i = os->ratio;
   252b6:	f8d9 4004 	ldr.w	r4, [r9, #4]
    
    while (i > 0U)
   252ba:	b32c      	cbz	r4, 25308 <tOversampler_tick+0x74>
   252bc:	f104 0b01 	add.w	fp, r4, #1
    j = 1U;
   252c0:	2601      	movs	r6, #1
         Repeat until we've computed numTaps-(4*os->L) coefficients. */
        
        /* Initialize tapCnt with number of samples */
        tapCnt = phaseLen;
        
        while (tapCnt > 0U)
   252c2:	eddf 5a38 	vldr	s11, [pc, #224]	; 253a4 <tOversampler_tick+0x110>
        ptr2 = pCoeffs + (os->ratio - j);
   252c6:	1ba3      	subs	r3, r4, r6
   252c8:	ee07 4a90 	vmov	s15, r4
   252cc:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
   252d0:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
        while (tapCnt > 0U)
   252d4:	2d00      	cmp	r5, #0
   252d6:	d061      	beq.n	2539c <tOversampler_tick+0x108>
            sum0 += *ptr1++ * *ptr2;
            
            /* Upsampling is done by stuffing L-1 zeros between each sample.
             * So instead of multiplying zeros with coefficients,
             * Increment the coefficient pointer by interpolation factor times. */
            ptr2 += os->ratio;
   252d8:	00a4      	lsls	r4, r4, #2
   252da:	462a      	mov	r2, r5
        ptr1 = pState;
   252dc:	4660      	mov	r0, ip
        sum0 = 0.0f;
   252de:	eddf 7a31 	vldr	s15, [pc, #196]	; 253a4 <tOversampler_tick+0x110>
            sum0 += *ptr1++ * *ptr2;
   252e2:	ed93 7a00 	vldr	s14, [r3]
        while (tapCnt > 0U)
   252e6:	3a01      	subs	r2, #1
            sum0 += *ptr1++ * *ptr2;
   252e8:	ecf0 6a01 	vldmia	r0!, {s13}
            ptr2 += os->ratio;
   252ec:	4423      	add	r3, r4
            sum0 += *ptr1++ * *ptr2;
   252ee:	eee6 7a87 	vfma.f32	s15, s13, s14
        while (tapCnt > 0U)
   252f2:	d1f6      	bne.n	252e2 <tOversampler_tick+0x4e>
   252f4:	ee67 7a86 	vmul.f32	s15, s15, s12
        
        /* The result is in the accumulator, store in the destination buffer. */
        *output++ = sum0 * os->ratio;
        
        /* Increment the address modifier index of coefficient buffer */
        j++;
   252f8:	3601      	adds	r6, #1
        *output++ = sum0 * os->ratio;
   252fa:	ece1 7a01 	vstmia	r1!, {s15}
    while (i > 0U)
   252fe:	455e      	cmp	r6, fp
   25300:	d002      	beq.n	25308 <tOversampler_tick+0x74>
   25302:	f8d9 4004 	ldr.w	r4, [r9, #4]
   25306:	e7de      	b.n	252c6 <tOversampler_tick+0x32>
    
    /* Initialize tapCnt with number of samples */
    tapCnt = (phaseLen - 1U);
    
    /* Copy data */
    while (tapCnt > 0U)
   25308:	3d01      	subs	r5, #1
    pState = pState + 1;
   2530a:	f10c 0c04 	add.w	ip, ip, #4
    pStateCur = os->upState;
   2530e:	f8d9 300c 	ldr.w	r3, [r9, #12]
    while (tapCnt > 0U)
   25312:	d005      	beq.n	25320 <tOversampler_tick+0x8c>
    {
        *pStateCur++ = *pState++;
   25314:	f85c 2b04 	ldr.w	r2, [ip], #4
    while (tapCnt > 0U)
   25318:	3d01      	subs	r5, #1
        *pStateCur++ = *pState++;
   2531a:	f843 2b04 	str.w	r2, [r3], #4
    while (tapCnt > 0U)
   2531e:	d1f9      	bne.n	25314 <tOversampler_tick+0x80>
    for (int i = 0; i < os->ratio; ++i) {
   25320:	f8d9 3004 	ldr.w	r3, [r9, #4]
   25324:	2b00      	cmp	r3, #0
   25326:	dd0b      	ble.n	25340 <tOversampler_tick+0xac>
   25328:	4655      	mov	r5, sl
   2532a:	2400      	movs	r4, #0
        oversample[i] = effectTick(oversample[i]);
   2532c:	ed95 0a00 	vldr	s0, [r5]
    for (int i = 0; i < os->ratio; ++i) {
   25330:	3401      	adds	r4, #1
        oversample[i] = effectTick(oversample[i]);
   25332:	47b8      	blx	r7
   25334:	eca5 0a01 	vstmia	r5!, {s0}
    for (int i = 0; i < os->ratio; ++i) {
   25338:	f8d9 3004 	ldr.w	r3, [r9, #4]
   2533c:	42a3      	cmp	r3, r4
   2533e:	dcf5      	bgt.n	2532c <tOversampler_tick+0x98>
}

// From CMSIS DSP Library
float tOversampler_downsample(tOversampler *const osr, float* input)
{
    _tOversampler* os = *osr;
   25340:	f8d8 4000 	ldr.w	r4, [r8]
    uint32_t i, tapCnt;
    float output;
    
    /* os->pState buffer contains previous frame (numTaps - 1) samples */
    /* pStateCur points to the location where the new input data should be written */
    pStateCur = os->downState + (numTaps - 1U);
   25344:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
    float *pState = os->downState;                 /* State pointer */
   25348:	e9d4 0604 	ldrd	r0, r6, [r4, #16]
    
    /* Copy decimation factor number of new input samples into the state buffer */
    i = os->ratio;
   2534c:	e9d4 3501 	ldrd	r3, r5, [r4, #4]
    pStateCur = os->downState + (numTaps - 1U);
   25350:	4432      	add	r2, r6
   25352:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    
    do
    {
        *pStateCur++ = *input++;
   25356:	f85a 1b04 	ldr.w	r1, [sl], #4
        
    } while (--i);
   2535a:	3b01      	subs	r3, #1
        *pStateCur++ = *input++;
   2535c:	f842 1b04 	str.w	r1, [r2], #4
    } while (--i);
   25360:	d1f9      	bne.n	25356 <tOversampler_tick+0xc2>
   25362:	6861      	ldr	r1, [r4, #4]
   25364:	1e73      	subs	r3, r6, #1
   25366:	6924      	ldr	r4, [r4, #16]
   25368:	461a      	mov	r2, r3
   2536a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    
    /* Set accumulator to zero */
    acc0 = 0.0f;
   2536e:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 253a4 <tOversampler_tick+0x110>
    pb = pCoeffs;
    
    /* Initialize tapCnt with number of taps */
    tapCnt = numTaps;
    
    while (tapCnt > 0U)
   25372:	b90e      	cbnz	r6, 25378 <tOversampler_tick+0xe4>
   25374:	e009      	b.n	2538a <tOversampler_tick+0xf6>
   25376:	3a01      	subs	r2, #1
        
        /* Fetch 1 state variable */
        x0 = *px0++;
        
        /* Perform the multiply-accumulate */
        acc0 += x0 * c0;
   25378:	ecb5 7a01 	vldmia	r5!, {s14}
   2537c:	ecf0 7a01 	vldmia	r0!, {s15}
   25380:	eea7 0a27 	vfma.f32	s0, s14, s15
    while (tapCnt > 0U)
   25384:	2a00      	cmp	r2, #0
   25386:	d1f6      	bne.n	25376 <tOversampler_tick+0xe2>
    
    /* Initialize tapCnt with number of taps */
    tapCnt = (numTaps - 1U);
    
    /* Copy data */
    while (tapCnt > 0U)
   25388:	b133      	cbz	r3, 25398 <tOversampler_tick+0x104>
   2538a:	4622      	mov	r2, r4
    {
        *pStateCur++ = *pState++;
   2538c:	f851 0b04 	ldr.w	r0, [r1], #4
    while (tapCnt > 0U)
   25390:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
   25392:	f842 0b04 	str.w	r0, [r2], #4
    while (tapCnt > 0U)
   25396:	d1f9      	bne.n	2538c <tOversampler_tick+0xf8>
}
   25398:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while (tapCnt > 0U)
   2539c:	eef0 7a65 	vmov.f32	s15, s11
   253a0:	e7aa      	b.n	252f8 <tOversampler_tick+0x64>
   253a2:	bf00      	nop
   253a4:	00000000 	.word	0x00000000

000253a8 <tOversampler_upsample>:
{
   253a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tOversampler* os = *osr;
   253ac:	f8d0 c000 	ldr.w	ip, [r0]
    float *pState = os->upState;                 /* State pointer */
   253b0:	f8dc 700c 	ldr.w	r7, [ip, #12]
    uint32_t phaseLen = os->phaseLength;            /* Length of each polyphase filter component */
   253b4:	f8dc 5018 	ldr.w	r5, [ip, #24]
    float *pCoeffs = os->pCoeffs;               /* Coefficient pointer */
   253b8:	f8dc e008 	ldr.w	lr, [ip, #8]
    *pStateCur = input;
   253bc:	eb07 0385 	add.w	r3, r7, r5, lsl #2
   253c0:	ed03 0a01 	vstr	s0, [r3, #-4]
    i = os->ratio;
   253c4:	f8dc 4004 	ldr.w	r4, [ip, #4]
    while (i > 0U)
   253c8:	b324      	cbz	r4, 25414 <tOversampler_upsample+0x6c>
   253ca:	f104 0801 	add.w	r8, r4, #1
    j = 1U;
   253ce:	2601      	movs	r6, #1
        while (tapCnt > 0U)
   253d0:	eddf 5a19 	vldr	s11, [pc, #100]	; 25438 <tOversampler_upsample+0x90>
        ptr2 = pCoeffs + (os->ratio - j);
   253d4:	1ba3      	subs	r3, r4, r6
   253d6:	ee07 4a90 	vmov	s15, r4
   253da:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
   253de:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
        while (tapCnt > 0U)
   253e2:	b32d      	cbz	r5, 25430 <tOversampler_upsample+0x88>
            ptr2 += os->ratio;
   253e4:	00a4      	lsls	r4, r4, #2
   253e6:	462a      	mov	r2, r5
        ptr1 = pState;
   253e8:	4638      	mov	r0, r7
        sum0 = 0.0f;
   253ea:	eddf 7a13 	vldr	s15, [pc, #76]	; 25438 <tOversampler_upsample+0x90>
            sum0 += *ptr1++ * *ptr2;
   253ee:	ed93 7a00 	vldr	s14, [r3]
        while (tapCnt > 0U)
   253f2:	3a01      	subs	r2, #1
            sum0 += *ptr1++ * *ptr2;
   253f4:	ecf0 6a01 	vldmia	r0!, {s13}
            ptr2 += os->ratio;
   253f8:	4423      	add	r3, r4
            sum0 += *ptr1++ * *ptr2;
   253fa:	eee6 7a87 	vfma.f32	s15, s13, s14
        while (tapCnt > 0U)
   253fe:	d1f6      	bne.n	253ee <tOversampler_upsample+0x46>
   25400:	ee67 7a86 	vmul.f32	s15, s15, s12
        j++;
   25404:	3601      	adds	r6, #1
        *output++ = sum0 * os->ratio;
   25406:	ece1 7a01 	vstmia	r1!, {s15}
    while (i > 0U)
   2540a:	4546      	cmp	r6, r8
   2540c:	d002      	beq.n	25414 <tOversampler_upsample+0x6c>
   2540e:	f8dc 4004 	ldr.w	r4, [ip, #4]
   25412:	e7df      	b.n	253d4 <tOversampler_upsample+0x2c>
    while (tapCnt > 0U)
   25414:	1e6b      	subs	r3, r5, #1
    pState = pState + 1;
   25416:	f107 0204 	add.w	r2, r7, #4
    pStateCur = os->upState;
   2541a:	f8dc 100c 	ldr.w	r1, [ip, #12]
    while (tapCnt > 0U)
   2541e:	d005      	beq.n	2542c <tOversampler_upsample+0x84>
        *pStateCur++ = *pState++;
   25420:	f852 0b04 	ldr.w	r0, [r2], #4
    while (tapCnt > 0U)
   25424:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
   25426:	f841 0b04 	str.w	r0, [r1], #4
    while (tapCnt > 0U)
   2542a:	d1f9      	bne.n	25420 <tOversampler_upsample+0x78>
}
   2542c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (tapCnt > 0U)
   25430:	eef0 7a65 	vmov.f32	s15, s11
   25434:	e7e6      	b.n	25404 <tOversampler_upsample+0x5c>
   25436:	bf00      	nop
   25438:	00000000 	.word	0x00000000

0002543c <tOversampler_downsample>:
{
   2543c:	b4f0      	push	{r4, r5, r6, r7}
    _tOversampler* os = *osr;
   2543e:	6806      	ldr	r6, [r0, #0]
    pStateCur = os->downState + (numTaps - 1U);
   25440:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
    float *pState = os->downState;                 /* State pointer */
   25444:	e9d6 0704 	ldrd	r0, r7, [r6, #16]
    i = os->ratio;
   25448:	e9d6 3501 	ldrd	r3, r5, [r6, #4]
    pStateCur = os->downState + (numTaps - 1U);
   2544c:	443a      	add	r2, r7
   2544e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
        *pStateCur++ = *input++;
   25452:	f851 4b04 	ldr.w	r4, [r1], #4
    } while (--i);
   25456:	3b01      	subs	r3, #1
        *pStateCur++ = *input++;
   25458:	f842 4b04 	str.w	r4, [r2], #4
    } while (--i);
   2545c:	d1f9      	bne.n	25452 <tOversampler_downsample+0x16>
   2545e:	1e7b      	subs	r3, r7, #1
   25460:	6871      	ldr	r1, [r6, #4]
   25462:	6934      	ldr	r4, [r6, #16]
   25464:	461a      	mov	r2, r3
   25466:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    acc0 = 0.0f;
   2546a:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 25498 <tOversampler_downsample+0x5c>
    while (tapCnt > 0U)
   2546e:	b90f      	cbnz	r7, 25474 <tOversampler_downsample+0x38>
   25470:	e009      	b.n	25486 <tOversampler_downsample+0x4a>
   25472:	3a01      	subs	r2, #1
        acc0 += x0 * c0;
   25474:	ecb5 7a01 	vldmia	r5!, {s14}
   25478:	ecf0 7a01 	vldmia	r0!, {s15}
   2547c:	eea7 0a27 	vfma.f32	s0, s14, s15
    while (tapCnt > 0U)
   25480:	2a00      	cmp	r2, #0
   25482:	d1f6      	bne.n	25472 <tOversampler_downsample+0x36>
    while (tapCnt > 0U)
   25484:	b133      	cbz	r3, 25494 <tOversampler_downsample+0x58>
   25486:	4622      	mov	r2, r4
        *pStateCur++ = *pState++;
   25488:	f851 0b04 	ldr.w	r0, [r1], #4
    while (tapCnt > 0U)
   2548c:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
   2548e:	f842 0b04 	str.w	r0, [r2], #4
    while (tapCnt > 0U)
   25492:	d1f9      	bne.n	25488 <tOversampler_downsample+0x4c>
        /* Decrement loop counter */
        tapCnt--;
    }
    
    return output;
}
   25494:	bcf0      	pop	{r4, r5, r6, r7}
   25496:	4770      	bx	lr
	...

000254a0 <tLockhartWavefolder_initToPool>:
{
	tLockhartWavefolder_initToPool   (wf,  &leaf.mempool);
}

void tLockhartWavefolder_initToPool (tLockhartWavefolder* const wf, tMempool* const mp)
{
   254a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
   254a4:	680c      	ldr	r4, [r1, #0]
{
   254a6:	4605      	mov	r5, r0
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   254a8:	20e0      	movs	r0, #224	; 0xe0
    w->Is = 10e-16;
    
    w->a = 2.0*w->RL/w->R;
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
    w->d = (w->RL*w->Is)/w->VT;
    w->half_a = 0.5 * w->a;
   254aa:	f04f 0800 	mov.w	r8, #0
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   254ae:	4621      	mov	r1, r4
    w->half_a = 0.5 * w->a;
   254b0:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 255ac <tLockhartWavefolder_initToPool+0x10c>
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   254b4:	f004 fb38 	bl	29b28 <mpool_alloc>
    w->a = 2.0*w->RL/w->R;
   254b8:	2200      	movs	r2, #0
   254ba:	4b3b      	ldr	r3, [pc, #236]	; (255a8 <tLockhartWavefolder_initToPool+0x108>)
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   254bc:	6028      	str	r0, [r5, #0]
    w->mempool = m;
   254be:	6004      	str	r4, [r0, #0]
    w->a = 2.0*w->RL/w->R;
   254c0:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
    w->RL = 7.5e3;
   254c4:	a528      	add	r5, pc, #160	; (adr r5, 25568 <tLockhartWavefolder_initToPool+0xc8>)
   254c6:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->R = 15e3;
   254ca:	a329      	add	r3, pc, #164	; (adr r3, 25570 <tLockhartWavefolder_initToPool+0xd0>)
   254cc:	e9d3 2300 	ldrd	r2, r3, [r3]
    w->RL = 7.5e3;
   254d0:	e9c0 4508 	strd	r4, r5, [r0, #32]
    w->R = 15e3;
   254d4:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
    w->VT = 26e-3;
   254d8:	a527      	add	r5, pc, #156	; (adr r5, 25578 <tLockhartWavefolder_initToPool+0xd8>)
   254da:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->Is = 10e-16;
   254de:	a328      	add	r3, pc, #160	; (adr r3, 25580 <tLockhartWavefolder_initToPool+0xe0>)
   254e0:	e9d3 2300 	ldrd	r2, r3, [r3]
    w->VT = 26e-3;
   254e4:	e9c0 450c 	strd	r4, r5, [r0, #48]	; 0x30
    w->Is = 10e-16;
   254e8:	e9c0 230e 	strd	r2, r3, [r0, #56]	; 0x38
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   254ec:	a526      	add	r5, pc, #152	; (adr r5, 25588 <tLockhartWavefolder_initToPool+0xe8>)
   254ee:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->d = (w->RL*w->Is)/w->VT;
   254f2:	a327      	add	r3, pc, #156	; (adr r3, 25590 <tLockhartWavefolder_initToPool+0xf0>)
   254f4:	e9d3 2300 	ldrd	r2, r3, [r3]
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   254f8:	e9c0 4512 	strd	r4, r5, [r0, #72]	; 0x48
    w->d = (w->RL*w->Is)/w->VT;
   254fc:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
    w->longthing = (0.5*w->VT/w->b);
    
    
    // Antialiasing error threshold
    w->AAthresh = 10e-10; //10
   25500:	a525      	add	r5, pc, #148	; (adr r5, 25598 <tLockhartWavefolder_initToPool+0xf8>)
   25502:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->Ln1 = 0.0;
   25506:	2200      	movs	r2, #0
   25508:	2300      	movs	r3, #0
    w->longthing = (0.5*w->VT/w->b);
   2550a:	a725      	add	r7, pc, #148	; (adr r7, 255a0 <tLockhartWavefolder_initToPool+0x100>)
   2550c:	e9d7 6700 	ldrd	r6, r7, [r7]
    w->half_a = 0.5 * w->a;
   25510:	e9c0 8918 	strd	r8, r9, [r0, #96]	; 0x60
    w->longthing = (0.5*w->VT/w->b);
   25514:	e9c0 671a 	strd	r6, r7, [r0, #104]	; 0x68
    w->Ln1 = 0.0;
   25518:	e9c0 2302 	strd	r2, r3, [r0, #8]
    w->Fn1 = 0.0;
   2551c:	e9c0 2304 	strd	r2, r3, [r0, #16]
    w->xn1 = 0.0;
   25520:	e9c0 2306 	strd	r2, r3, [r0, #24]

	w->LambertThresh = 10e-10; //12  //was 8


    w->w = 0.0f;
   25524:	e9c0 231e 	strd	r2, r3, [r0, #120]	; 0x78
    w->expw = 0.0f;
   25528:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    w->p = 0.0f;
   2552c:	e9c0 2322 	strd	r2, r3, [r0, #136]	; 0x88
    w->r = 0.0f;
   25530:	e9c0 2324 	strd	r2, r3, [r0, #144]	; 0x90
    w->s= 0.0f;
   25534:	e9c0 2326 	strd	r2, r3, [r0, #152]	; 0x98
    w->myerr = 0.0f;
   25538:	e9c0 2328 	strd	r2, r3, [r0, #160]	; 0xa0
    w->l = 0.0f;
   2553c:	e9c0 232a 	strd	r2, r3, [r0, #168]	; 0xa8
    w->u = 0.0f;
   25540:	e9c0 232c 	strd	r2, r3, [r0, #176]	; 0xb0
    w->Ln = 0.0f;
   25544:	e9c0 232e 	strd	r2, r3, [r0, #184]	; 0xb8
	w->Fn = 0.0f;
   25548:	e9c0 2330 	strd	r2, r3, [r0, #192]	; 0xc0
    w->tempsDenom = 0.0f;
   2554c:	e9c0 2332 	strd	r2, r3, [r0, #200]	; 0xc8
    w->tempErrDenom = 0.0f;
   25550:	e9c0 2334 	strd	r2, r3, [r0, #208]	; 0xd0
    w->tempOutDenom = 0.0f;
   25554:	e9c0 2336 	strd	r2, r3, [r0, #216]	; 0xd8
    w->AAthresh = 10e-10; //10
   25558:	e9c0 4516 	strd	r4, r5, [r0, #88]	; 0x58
	w->LambertThresh = 10e-10; //12  //was 8
   2555c:	e9c0 451c 	strd	r4, r5, [r0, #112]	; 0x70


}
   25560:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   25564:	f3af 8000 	nop.w
   25568:	00000000 	.word	0x00000000
   2556c:	40bd4c00 	.word	0x40bd4c00
   25570:	00000000 	.word	0x00000000
   25574:	40cd4c00 	.word	0x40cd4c00
   25578:	76c8b439 	.word	0x76c8b439
   2557c:	3f9a9fbe 	.word	0x3f9a9fbe
   25580:	9ee75616 	.word	0x9ee75616
   25584:	3cd203af 	.word	0x3cd203af
   25588:	b13b13b1 	.word	0xb13b13b1
   2558c:	40533b13 	.word	0x40533b13
   25590:	46f1bc84 	.word	0x46f1bc84
   25594:	3df3d2ab 	.word	0x3df3d2ab
   25598:	e826d695 	.word	0xe826d695
   2559c:	3e112e0b 	.word	0x3e112e0b
   255a0:	f23033a4 	.word	0xf23033a4
   255a4:	3f2626b2 	.word	0x3f2626b2
   255a8:	3ff00000 	.word	0x3ff00000
   255ac:	3fe00000 	.word	0x3fe00000

000255b0 <tLockhartWavefolder_free>:

void tLockhartWavefolder_free (tLockhartWavefolder* const wf)
{
    _tLockhartWavefolder* w = *wf;
   255b0:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)w, w->mempool);
   255b2:	6801      	ldr	r1, [r0, #0]
   255b4:	f004 bb60 	b.w	29c78 <mpool_free>

000255b8 <tLockhartWavefolder_tick>:
    _tLockhartWavefolder* w = *wf;

    float out = 0.0f;
    
    // Compute Antiderivative
    w->l = (in > 0.0) - (in < 0.0);
   255b8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
   255bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    w->l = (in > 0.0) - (in < 0.0);
   255be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    _tLockhartWavefolder* w = *wf;
   255c2:	6806      	ldr	r6, [r0, #0]
{
   255c4:	4607      	mov	r7, r0
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   255c6:	f640 34b8 	movw	r4, #3000	; 0xbb8
{
   255ca:	ed2d 8b0e 	vpush	{d8-d14}
    w->l = (in > 0.0) - (in < 0.0);
   255ce:	bfc8      	it	gt
   255d0:	2301      	movgt	r3, #1
    w->u = w->d*exp(w->l*w->b*in);
   255d2:	eeb7 eac0 	vcvt.f64.f32	d14, s0
    w->l = (in > 0.0) - (in < 0.0);
   255d6:	bfd8      	it	le
   255d8:	2300      	movle	r3, #0
   255da:	bf4c      	ite	mi
   255dc:	2201      	movmi	r2, #1
   255de:	2200      	movpl	r2, #0
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   255e0:	eeb7 bb00 	vmov.f64	d11, #112	; 0x3f800000  1.0
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   255e4:	eeb0 9b00 	vmov.f64	d9, #0	; 0x40000000  2.0
    w->l = (in > 0.0) - (in < 0.0);
   255e8:	1a9b      	subs	r3, r3, r2
    w->u = w->d*exp(w->l*w->b*in);
   255ea:	ed96 0b12 	vldr	d0, [r6, #72]	; 0x48
    w->l = (in > 0.0) - (in < 0.0);
   255ee:	ee07 3a90 	vmov	s15, r3
    w->u = w->d*exp(w->l*w->b*in);
   255f2:	ee2e 0b00 	vmul.f64	d0, d14, d0
    w->l = (in > 0.0) - (in < 0.0);
   255f6:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   255fa:	ed86 7b2a 	vstr	d7, [r6, #168]	; 0xa8
    w->u = w->d*exp(w->l*w->b*in);
   255fe:	ee20 0b07 	vmul.f64	d0, d0, d7
   25602:	f007 fdfd 	bl	2d200 <exp>
   25606:	ed96 cb14 	vldr	d12, [r6, #80]	; 0x50
    	w->u = 10e-5;
    	LEAF_error();
    }
    */

    w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   2560a:	ed96 8b02 	vldr	d8, [r6, #8]
    w->u = w->d*exp(w->l*w->b*in);
   2560e:	ee20 cb0c 	vmul.f64	d12, d0, d12
   25612:	ed86 cb2c 	vstr	d12, [r6, #176]	; 0xb0
	_tLockhartWavefolder* mwf = *wf;
   25616:	683d      	ldr	r5, [r7, #0]
   25618:	eeb1 cb4c 	vneg.f64	d12, d12
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   2561c:	ed95 db1c 	vldr	d13, [r5, #112]	; 0x70
	mwf->w = ln;
   25620:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
   25624:	e006      	b.n	25634 <tLockhartWavefolder_tick+0x7c>
        mwf->w = mwf->w - mwf->myerr;
   25626:	ee38 8b45 	vsub.f64	d8, d8, d5
    for(int i=0; i<3000; i+=1) { //1000
   2562a:	3c01      	subs	r4, #1
        mwf->w = mwf->w - mwf->myerr;
   2562c:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
    for(int i=0; i<3000; i+=1) { //1000
   25630:	f000 80c9 	beq.w	257c6 <tLockhartWavefolder_tick+0x20e>
    	mwf->expw = exp(mwf->w);
   25634:	eeb0 0b48 	vmov.f64	d0, d8
   25638:	f007 fde2 	bl	2d200 <exp>
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   2563c:	ee38 7b0b 	vadd.f64	d7, d8, d11
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   25640:	ee38 4b09 	vadd.f64	d4, d8, d9
    	mwf->p = mwf->w*mwf->expw - x;
   25644:	eeb0 6b4c 	vmov.f64	d6, d12
    	mwf->tempsDenom = (2.0*(mwf->w+1.0));
   25648:	ee37 1b07 	vadd.f64	d1, d7, d7
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   2564c:	ee20 7b07 	vmul.f64	d7, d0, d7
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   25650:	ee84 2b01 	vdiv.f64	d2, d4, d1
    	mwf->p = mwf->w*mwf->expw - x;
   25654:	eea0 6b08 	vfma.f64	d6, d0, d8
        mwf->tempErrDenom = (mwf->r-(mwf->p*mwf->s));
   25658:	eeb0 3b47 	vmov.f64	d3, d7
   2565c:	eea6 3b42 	vfms.f64	d3, d6, d2
        mwf->myerr = (mwf->p/mwf->tempErrDenom);
   25660:	ee86 5b03 	vdiv.f64	d5, d6, d3
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   25664:	eeb0 abc5 	vabs.f64	d10, d5
   25668:	eeb4 abcd 	vcmpe.f64	d10, d13
   2566c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25670:	d5d9      	bpl.n	25626 <tLockhartWavefolder_tick+0x6e>
   25672:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
   25676:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
   2567a:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
   2567e:	ed85 1b32 	vstr	d1, [r5, #200]	; 0xc8
   25682:	ed85 2b26 	vstr	d2, [r5, #152]	; 0x98
   25686:	ed85 3b34 	vstr	d3, [r5, #208]	; 0xd0
   2568a:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
	{
		w->Ln = 10e-5;
		LEAF_error();
	}
*/
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   2568e:	ee2e 5b0e 	vmul.f64	d5, d14, d14
   25692:	ee24 4b08 	vmul.f64	d4, d4, d8
   25696:	ed96 7b18 	vldr	d7, [r6, #96]	; 0x60
		LEAF_error();
	}
	*/
    // Check for ill-conditioning

    if (fabs(in-w->xn1)<w->AAthresh)
   2569a:	ed96 db06 	vldr	d13, [r6, #24]
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   2569e:	ed96 6b1a 	vldr	d6, [r6, #104]	; 0x68
   256a2:	ee27 5b45 	vnmul.f64	d5, d7, d5
    if (fabs(in-w->xn1)<w->AAthresh)
   256a6:	ee3e 3b4d 	vsub.f64	d3, d14, d13
   256aa:	ed96 7b16 	vldr	d7, [r6, #88]	; 0x58
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   256ae:	eea6 5b04 	vfma.f64	d5, d6, d4
    if (fabs(in-w->xn1)<w->AAthresh)
   256b2:	eeb0 6bc3 	vabs.f64	d6, d3
    w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   256b6:	ed86 8b2e 	vstr	d8, [r6, #184]	; 0xb8
    if (fabs(in-w->xn1)<w->AAthresh)
   256ba:	eeb4 6bc7 	vcmpe.f64	d6, d7
   256be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   256c2:	ed86 5b30 	vstr	d5, [r6, #192]	; 0xc0
    if (fabs(in-w->xn1)<w->AAthresh)
   256c6:	d412      	bmi.n	256ee <tLockhartWavefolder_tick+0x136>
    	{
    		w->tempOutDenom = 10e-5;
    		LEAF_error();
    	}
    	*/
        out = ((w->Fn-w->Fn1)/w->tempOutDenom);
   256c8:	ed96 7b04 	vldr	d7, [r6, #16]
    	w->tempOutDenom = (in-w->xn1);
   256cc:	ed86 3b36 	vstr	d3, [r6, #216]	; 0xd8
        out = ((w->Fn-w->Fn1)/w->tempOutDenom);
   256d0:	ee35 7b47 	vsub.f64	d7, d5, d7
   256d4:	ee87 0b03 	vdiv.f64	d0, d7, d3
   256d8:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
		*/

    }

    // Update States
    w->Ln1 = w->Ln;
   256dc:	ed86 8b02 	vstr	d8, [r6, #8]
    w->Fn1 = w->Fn;
   256e0:	ed86 5b04 	vstr	d5, [r6, #16]
    w->xn1 = (double)in;
   256e4:	ed86 eb06 	vstr	d14, [r6, #24]
    
    return out;
}
   256e8:	ecbd 8b0e 	vpop	{d8-d14}
   256ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    	double xn = 0.5*(in+w->xn1);
   256ee:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   256f2:	f640 34b8 	movw	r4, #3000	; 0xbb8
    	double xn = 0.5*(in+w->xn1);
   256f6:	ee3e db0d 	vadd.f64	d13, d14, d13
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   256fa:	eeb7 9b00 	vmov.f64	d9, #112	; 0x3f800000  1.0
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   256fe:	eeb0 ab00 	vmov.f64	d10, #0	; 0x40000000  2.0
    	double xn = 0.5*(in+w->xn1);
   25702:	ee2d db07 	vmul.f64	d13, d13, d7
    	w->u = w->d*exp(w->l*w->b*xn);
   25706:	ed96 0b2a 	vldr	d0, [r6, #168]	; 0xa8
   2570a:	ed96 7b12 	vldr	d7, [r6, #72]	; 0x48
   2570e:	ee20 0b07 	vmul.f64	d0, d0, d7
   25712:	ee20 0b0d 	vmul.f64	d0, d0, d13
   25716:	f007 fd73 	bl	2d200 <exp>
   2571a:	ed96 bb14 	vldr	d11, [r6, #80]	; 0x50
    	w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   2571e:	ed96 8b02 	vldr	d8, [r6, #8]
    	w->u = w->d*exp(w->l*w->b*xn);
   25722:	ee20 bb0b 	vmul.f64	d11, d0, d11
   25726:	ed86 bb2c 	vstr	d11, [r6, #176]	; 0xb0
	_tLockhartWavefolder* mwf = *wf;
   2572a:	683d      	ldr	r5, [r7, #0]
   2572c:	eeb1 bb4b 	vneg.f64	d11, d11
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   25730:	ed95 cb1c 	vldr	d12, [r5, #112]	; 0x70
	mwf->w = ln;
   25734:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
   25738:	e005      	b.n	25746 <tLockhartWavefolder_tick+0x18e>
        mwf->w = mwf->w - mwf->myerr;
   2573a:	ee38 8b45 	vsub.f64	d8, d8, d5
    for(int i=0; i<3000; i+=1) { //1000
   2573e:	3c01      	subs	r4, #1
        mwf->w = mwf->w - mwf->myerr;
   25740:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
    for(int i=0; i<3000; i+=1) { //1000
   25744:	d01e      	beq.n	25784 <tLockhartWavefolder_tick+0x1cc>
    	mwf->expw = exp(mwf->w);
   25746:	eeb0 0b48 	vmov.f64	d0, d8
   2574a:	f007 fd59 	bl	2d200 <exp>
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   2574e:	ee38 7b09 	vadd.f64	d7, d8, d9
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   25752:	ee38 5b0a 	vadd.f64	d5, d8, d10
    	mwf->p = mwf->w*mwf->expw - x;
   25756:	eeb0 6b4b 	vmov.f64	d6, d11
    	mwf->tempsDenom = (2.0*(mwf->w+1.0));
   2575a:	ee37 2b07 	vadd.f64	d2, d7, d7
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   2575e:	ee20 7b07 	vmul.f64	d7, d0, d7
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   25762:	ee85 3b02 	vdiv.f64	d3, d5, d2
    	mwf->p = mwf->w*mwf->expw - x;
   25766:	eea0 6b08 	vfma.f64	d6, d0, d8
        mwf->tempErrDenom = (mwf->r-(mwf->p*mwf->s));
   2576a:	eeb0 4b47 	vmov.f64	d4, d7
   2576e:	eea6 4b43 	vfms.f64	d4, d6, d3
        mwf->myerr = (mwf->p/mwf->tempErrDenom);
   25772:	ee86 5b04 	vdiv.f64	d5, d6, d4
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   25776:	eeb0 1bc5 	vabs.f64	d1, d5
   2577a:	eeb4 1bcc 	vcmpe.f64	d1, d12
   2577e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25782:	d5da      	bpl.n	2573a <tLockhartWavefolder_tick+0x182>
   25784:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
   25788:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
   2578c:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
   25790:	ed85 2b32 	vstr	d2, [r5, #200]	; 0xc8
   25794:	ed85 3b26 	vstr	d3, [r5, #152]	; 0x98
   25798:	ed85 4b34 	vstr	d4, [r5, #208]	; 0xd0
   2579c:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
        out = (float)((w->l*w->VT*w->Ln) - (w->a*xn));
   257a0:	ed96 5b10 	vldr	d5, [r6, #64]	; 0x40
   257a4:	ed96 7b2a 	vldr	d7, [r6, #168]	; 0xa8
   257a8:	ed96 6b0c 	vldr	d6, [r6, #48]	; 0x30
   257ac:	ee25 db4d 	vnmul.f64	d13, d5, d13
   257b0:	ee27 7b06 	vmul.f64	d7, d7, d6
    	w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   257b4:	ed86 8b2e 	vstr	d8, [r6, #184]	; 0xb8
   257b8:	ed96 5b30 	vldr	d5, [r6, #192]	; 0xc0
        out = (float)((w->l*w->VT*w->Ln) - (w->a*xn));
   257bc:	eea7 db08 	vfma.f64	d13, d7, d8
   257c0:	eeb7 0bcd 	vcvt.f32.f64	s0, d13
   257c4:	e78a      	b.n	256dc <tLockhartWavefolder_tick+0x124>
   257c6:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
   257ca:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
   257ce:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
   257d2:	ed85 1b32 	vstr	d1, [r5, #200]	; 0xc8
   257d6:	ed85 2b26 	vstr	d2, [r5, #152]	; 0x98
   257da:	ed85 3b34 	vstr	d3, [r5, #208]	; 0xd0
   257de:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
   257e2:	ee38 4b09 	vadd.f64	d4, d8, d9
   257e6:	e752      	b.n	2568e <tLockhartWavefolder_tick+0xd6>

000257e8 <tCrusher_initToPool>:
{
    tCrusher_initToPool(cr, &leaf.mempool);
}

void tCrusher_initToPool (tCrusher* const cr, tMempool* const mp)
{
   257e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
   257ea:	680e      	ldr	r6, [r1, #0]
{
   257ec:	460d      	mov	r5, r1
   257ee:	4607      	mov	r7, r0
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
   257f0:	2020      	movs	r0, #32
   257f2:	4631      	mov	r1, r6
   257f4:	f004 f998 	bl	29b28 <mpool_alloc>
    c->mempool = m;
    
    c->op = 4;
    c->div = SCALAR;
    c->rnd = 0.25f;
   257f8:	f04f 537a 	mov.w	r3, #1048576000	; 0x3e800000
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
   257fc:	4604      	mov	r4, r0
    c->div = SCALAR;
   257fe:	4a10      	ldr	r2, [pc, #64]	; (25840 <tCrusher_initToPool+0x58>)
    c->op = 4;
   25800:	2104      	movs	r1, #4
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
   25802:	6038      	str	r0, [r7, #0]
    c->div = SCALAR;
   25804:	60e2      	str	r2, [r4, #12]
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
   25806:	2010      	movs	r0, #16
    c->op = 4;
   25808:	6161      	str	r1, [r4, #20]
    c->rnd = 0.25f;
   2580a:	6123      	str	r3, [r4, #16]
    c->srr = 0.25f;
   2580c:	6063      	str	r3, [r4, #4]
    c->mempool = m;
   2580e:	6026      	str	r6, [r4, #0]
    _tMempool* m = *mp;
   25810:	682d      	ldr	r5, [r5, #0]
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
   25812:	4629      	mov	r1, r5
   25814:	f004 f988 	bl	29b28 <mpool_alloc>
    s->invRatio = 1.0f;
   25818:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    s->hold = 0.0f;
   2581c:	2200      	movs	r2, #0
    s->count = 0;
   2581e:	2300      	movs	r3, #0
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
   25820:	61e0      	str	r0, [r4, #28]
    tSampleReducer_initToPool(&c->sReducer, mp);
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   25822:	ed9f 7a08 	vldr	s14, [pc, #32]	; 25844 <tCrusher_initToPool+0x5c>
    s->mempool = m;
   25826:	6005      	str	r5, [r0, #0]
    s->invRatio = 1.0f;
   25828:	6041      	str	r1, [r0, #4]
    s->hold = 0.0f;
   2582a:	6082      	str	r2, [r0, #8]
    s->count = 0;
   2582c:	60c3      	str	r3, [r0, #12]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   2582e:	eddf 7a06 	vldr	s15, [pc, #24]	; 25848 <tCrusher_initToPool+0x60>
   25832:	edd4 6a03 	vldr	s13, [r4, #12]
   25836:	eee6 7a87 	vfma.f32	s15, s13, s14
   2583a:	edc4 7a06 	vstr	s15, [r4, #24]
}
   2583e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   25840:	459c4000 	.word	0x459c4000
   25844:	3912ccf6 	.word	0x3912ccf6
   25848:	3e99999a 	.word	0x3e99999a

0002584c <tCrusher_free>:

void tCrusher_free (tCrusher* const cr)
{
   2584c:	b510      	push	{r4, lr}
    _tCrusher* c = *cr;
   2584e:	6804      	ldr	r4, [r0, #0]
    _tSampleReducer* s = *sr;
   25850:	69e0      	ldr	r0, [r4, #28]
    mpool_free((char*)s, s->mempool);
   25852:	6801      	ldr	r1, [r0, #0]
   25854:	f004 fa10 	bl	29c78 <mpool_free>
    
    tSampleReducer_free(&c->sReducer);
    mpool_free((char*)c, c->mempool);
   25858:	6821      	ldr	r1, [r4, #0]
   2585a:	4620      	mov	r0, r4
}
   2585c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)c, c->mempool);
   25860:	f004 ba0a 	b.w	29c78 <mpool_free>

00025864 <tCrusher_tick>:
{
    _tCrusher* c = *cr;
    
    float sample = input;
    
    sample *= SCALAR; // SCALAR is 5000 by default
   25864:	eddf 7a1e 	vldr	s15, [pc, #120]	; 258e0 <tCrusher_tick+0x7c>
   25868:	ee20 0a27 	vmul.f32	s0, s0, s15
{
   2586c:	b510      	push	{r4, lr}
    
    sample = (int32_t) sample;
   2586e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tCrusher* c = *cr;
   25872:	6804      	ldr	r4, [r0, #0]
    
    sample /= c->div;
   25874:	edd4 7a03 	vldr	s15, [r4, #12]
    sample = (int32_t) sample;
   25878:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    
    sample = LEAF_bitwise_xor(sample, c->op << 23);
   2587c:	6960      	ldr	r0, [r4, #20]
   2587e:	05c0      	lsls	r0, r0, #23
   25880:	ee80 0a27 	vdiv.f32	s0, s0, s15
   25884:	f003 ff4a 	bl	2971c <LEAF_bitwise_xor>
    
    sample = LEAF_clip(-1.f, sample, 1.f);
   25888:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   2588c:	eef0 0a40 	vmov.f32	s1, s0
   25890:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   25894:	f003 ff48 	bl	29728 <LEAF_clip>
    
    sample = LEAF_round(sample, c->rnd);
   25898:	edd4 0a04 	vldr	s1, [r4, #16]
   2589c:	f003 ff2c 	bl	296f8 <LEAF_round>
    _tSampleReducer* s = *sr;
   258a0:	69e3      	ldr	r3, [r4, #28]
    if (s->count > s->invRatio)
   258a2:	68da      	ldr	r2, [r3, #12]
   258a4:	edd3 7a01 	vldr	s15, [r3, #4]
   258a8:	ee07 2a10 	vmov	s14, r2
   258ac:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   258b0:	eeb4 7ae7 	vcmpe.f32	s14, s15
   258b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   258b8:	dd08      	ble.n	258cc <tCrusher_tick+0x68>
        s->hold = input;
   258ba:	2201      	movs	r2, #1
   258bc:	ed83 0a02 	vstr	s0, [r3, #8]
    s->count++;
   258c0:	60da      	str	r2, [r3, #12]
    
    sample = tSampleReducer_tick(&c->sReducer, sample);
    
    return sample * c->gain;
   258c2:	edd4 7a06 	vldr	s15, [r4, #24]
    
}
   258c6:	ee20 0a27 	vmul.f32	s0, s0, s15
   258ca:	bd10      	pop	{r4, pc}
   258cc:	3201      	adds	r2, #1
   258ce:	ed93 0a02 	vldr	s0, [r3, #8]
    s->count++;
   258d2:	60da      	str	r2, [r3, #12]
    return sample * c->gain;
   258d4:	edd4 7a06 	vldr	s15, [r4, #24]
}
   258d8:	ee20 0a27 	vmul.f32	s0, s0, s15
   258dc:	bd10      	pop	{r4, pc}
   258de:	bf00      	nop
   258e0:	459c4000 	.word	0x459c4000

000258e4 <tCrusher_setOperation>:

void    tCrusher_setOperation (tCrusher* const cr, float op)
{
    _tCrusher* c = *cr;
    c->op = (uint32_t) (op * 8.0f);
   258e4:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    _tCrusher* c = *cr;
   258e8:	6803      	ldr	r3, [r0, #0]
    c->op = (uint32_t) (op * 8.0f);
   258ea:	ee20 0a27 	vmul.f32	s0, s0, s15
   258ee:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   258f2:	ed83 0a05 	vstr	s0, [r3, #20]
}
   258f6:	4770      	bx	lr

000258f8 <tCrusher_setQuality>:

// 0.0 - 1.0
void    tCrusher_setQuality (tCrusher* const cr, float val)
{
   258f8:	b510      	push	{r4, lr}
    _tCrusher* c = *cr;
    
    val = LEAF_clip(0.0f, val, 1.0f);
   258fa:	eef0 0a40 	vmov.f32	s1, s0
   258fe:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 25930 <tCrusher_setQuality+0x38>
   25902:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    _tCrusher* c = *cr;
   25906:	6804      	ldr	r4, [r0, #0]
    val = LEAF_clip(0.0f, val, 1.0f);
   25908:	f003 ff0e 	bl	29728 <LEAF_clip>
    
    c->div = 0.01f + val * SCALAR;
   2590c:	ed9f 7a09 	vldr	s14, [pc, #36]	; 25934 <tCrusher_setQuality+0x3c>
   25910:	eddf 7a09 	vldr	s15, [pc, #36]	; 25938 <tCrusher_setQuality+0x40>
    
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   25914:	eddf 6a09 	vldr	s13, [pc, #36]	; 2593c <tCrusher_setQuality+0x44>
    c->div = 0.01f + val * SCALAR;
   25918:	eee0 7a07 	vfma.f32	s15, s0, s14
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   2591c:	ed9f 7a08 	vldr	s14, [pc, #32]	; 25940 <tCrusher_setQuality+0x48>
   25920:	eea7 7aa6 	vfma.f32	s14, s15, s13
    c->div = 0.01f + val * SCALAR;
   25924:	edc4 7a03 	vstr	s15, [r4, #12]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   25928:	ed84 7a06 	vstr	s14, [r4, #24]
}
   2592c:	bd10      	pop	{r4, pc}
   2592e:	bf00      	nop
   25930:	00000000 	.word	0x00000000
   25934:	459c4000 	.word	0x459c4000
   25938:	3c23d70a 	.word	0x3c23d70a
   2593c:	3912ccf6 	.word	0x3912ccf6
   25940:	3e99999a 	.word	0x3e99999a

00025944 <tCrusher_setRound>:

// what decimal to round to
void    tCrusher_setRound (tCrusher* const cr, float rnd)
{
    _tCrusher* c = *cr;
    c->rnd = fabsf(rnd);
   25944:	eeb0 0ac0 	vabs.f32	s0, s0
    _tCrusher* c = *cr;
   25948:	6803      	ldr	r3, [r0, #0]
    c->rnd = fabsf(rnd);
   2594a:	ed83 0a04 	vstr	s0, [r3, #16]
}
   2594e:	4770      	bx	lr

00025950 <tCrusher_setSamplingRatio>:
    if ((ratio <= 1.0f) && (ratio >= 0.0f))
   25950:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0

void    tCrusher_setSamplingRatio (tCrusher* const cr, float ratio)
{
    _tCrusher* c = *cr;
   25954:	6803      	ldr	r3, [r0, #0]
    c->srr = ratio;
   25956:	ed83 0a01 	vstr	s0, [r3, #4]
    if ((ratio <= 1.0f) && (ratio >= 0.0f))
   2595a:	eeb4 0a67 	vcmp.f32	s0, s15
   2595e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25962:	d809      	bhi.n	25978 <tCrusher_setSamplingRatio+0x28>
   25964:	eeb5 0a40 	vcmp.f32	s0, #0.0
   25968:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2596c:	db04      	blt.n	25978 <tCrusher_setSamplingRatio+0x28>
        s->invRatio = 1.0f / ratio;
   2596e:	ee87 7a80 	vdiv.f32	s14, s15, s0
    _tSampleReducer* s = *sr;
   25972:	69db      	ldr	r3, [r3, #28]
        s->invRatio = 1.0f / ratio;
   25974:	ed83 7a01 	vstr	s14, [r3, #4]
    tSampleReducer_setRatio(&c->sReducer, ratio);

}
   25978:	4770      	bx	lr
   2597a:	bf00      	nop

0002597c <tFeedbackLeveler_init>:
}

/* Feedback Leveler */

void tFeedbackLeveler_init (tFeedbackLeveler* const fb, float targetLevel, float factor, float strength, int mode)
{
   2597c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    tFeedbackLeveler_initToPool(fb, targetLevel, factor, strength, mode, &leaf.mempool);
}

void tFeedbackLeveler_initToPool (tFeedbackLeveler* const fb, float targetLevel, float factor, float strength, int mode, tMempool* const mp)
{
    _tMempool* m = *mp;
   25980:	4d12      	ldr	r5, [pc, #72]	; (259cc <tFeedbackLeveler_init+0x50>)
{
   25982:	4680      	mov	r8, r0
   25984:	460f      	mov	r7, r1
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   25986:	2018      	movs	r0, #24
    _tMempool* m = *mp;
   25988:	f855 6f18 	ldr.w	r6, [r5, #24]!
{
   2598c:	ed2d 8b04 	vpush	{d8-d9}
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   25990:	4631      	mov	r1, r6
{
   25992:	eef0 8a40 	vmov.f32	s17, s0
   25996:	eeb0 9a60 	vmov.f32	s18, s1
   2599a:	eeb0 8a41 	vmov.f32	s16, s2
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   2599e:	f004 f8c3 	bl	29b28 <mpool_alloc>
    p->mempool = m;
    
    p->curr=0.0f;
   259a2:	2300      	movs	r3, #0
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   259a4:	4604      	mov	r4, r0
   259a6:	f8c8 0000 	str.w	r0, [r8]
    p->targetLevel=targetLevel;
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   259aa:	eeb0 0a49 	vmov.f32	s0, s18
    p->mempool = m;
   259ae:	6006      	str	r6, [r0, #0]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   259b0:	4629      	mov	r1, r5
    p->targetLevel=targetLevel;
   259b2:	edc4 8a01 	vstr	s17, [r4, #4]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   259b6:	3014      	adds	r0, #20
    p->curr=0.0f;
   259b8:	6123      	str	r3, [r4, #16]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   259ba:	f7fe fc93 	bl	242e4 <tPowerFollower_initToPool>
    p->mode=mode;
   259be:	60e7      	str	r7, [r4, #12]
    p->strength=strength;
   259c0:	ed84 8a02 	vstr	s16, [r4, #8]
}
   259c4:	ecbd 8b04 	vpop	{d8-d9}
   259c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   259cc:	020fbd68 	.word	0x020fbd68

000259d0 <tFeedbackLeveler_initToPool>:
{
   259d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tMempool* m = *mp;
   259d4:	6815      	ldr	r5, [r2, #0]
{
   259d6:	4680      	mov	r8, r0
   259d8:	460f      	mov	r7, r1
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   259da:	2018      	movs	r0, #24
   259dc:	4629      	mov	r1, r5
{
   259de:	4616      	mov	r6, r2
   259e0:	ed2d 8b04 	vpush	{d8-d9}
   259e4:	eef0 8a40 	vmov.f32	s17, s0
   259e8:	eeb0 9a60 	vmov.f32	s18, s1
   259ec:	eeb0 8a41 	vmov.f32	s16, s2
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   259f0:	f004 f89a 	bl	29b28 <mpool_alloc>
    p->curr=0.0f;
   259f4:	2300      	movs	r3, #0
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   259f6:	4604      	mov	r4, r0
   259f8:	f8c8 0000 	str.w	r0, [r8]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   259fc:	eeb0 0a49 	vmov.f32	s0, s18
    p->mempool = m;
   25a00:	6005      	str	r5, [r0, #0]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25a02:	4631      	mov	r1, r6
    p->targetLevel=targetLevel;
   25a04:	edc4 8a01 	vstr	s17, [r4, #4]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25a08:	3014      	adds	r0, #20
    p->curr=0.0f;
   25a0a:	6123      	str	r3, [r4, #16]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25a0c:	f7fe fc6a 	bl	242e4 <tPowerFollower_initToPool>
    p->mode=mode;
   25a10:	60e7      	str	r7, [r4, #12]
    p->strength=strength;
   25a12:	ed84 8a02 	vstr	s16, [r4, #8]
}
   25a16:	ecbd 8b04 	vpop	{d8-d9}
   25a1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   25a1e:	bf00      	nop

00025a20 <tFeedbackLeveler_free>:

void tFeedbackLeveler_free (tFeedbackLeveler* const fb)
{
   25a20:	b510      	push	{r4, lr}
    _tFeedbackLeveler* p = *fb;
   25a22:	6804      	ldr	r4, [r0, #0]
    
    tPowerFollower_free(&p->pwrFlw);
   25a24:	f104 0014 	add.w	r0, r4, #20
   25a28:	f7fe fc76 	bl	24318 <tPowerFollower_free>
    mpool_free((char*)p, p->mempool);
   25a2c:	6821      	ldr	r1, [r4, #0]
   25a2e:	4620      	mov	r0, r4
}
   25a30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
   25a34:	f004 b920 	b.w	29c78 <mpool_free>

00025a38 <tFeedbackLeveler_setMode>:
    tPowerFollower_setFactor(&p->pwrFlw,factor);
}

void     tFeedbackLeveler_setMode(tFeedbackLeveler* const fb, int mode)
{    // 0 for decaying with upwards lev limiting, 1 for constrained absolute level (also downwards limiting)
    _tFeedbackLeveler* p = *fb;
   25a38:	6803      	ldr	r3, [r0, #0]
    p->mode=mode;
   25a3a:	60d9      	str	r1, [r3, #12]
}
   25a3c:	4770      	bx	lr
   25a3e:	bf00      	nop

00025a40 <tFeedbackLeveler_tick>:

float   tFeedbackLeveler_tick(tFeedbackLeveler* const fb, float input)
{
   25a40:	b510      	push	{r4, lr}
   25a42:	ed2d 8b02 	vpush	{d8}
    _tFeedbackLeveler* p = *fb;
   25a46:	6804      	ldr	r4, [r0, #0]
{
   25a48:	eeb0 8a40 	vmov.f32	s16, s0
    float levdiff=(tPowerFollower_tick(&p->pwrFlw, input)-p->targetLevel);
   25a4c:	f104 0014 	add.w	r0, r4, #20
   25a50:	f7fe fc66 	bl	24320 <tPowerFollower_tick>
   25a54:	edd4 7a01 	vldr	s15, [r4, #4]
    if (p->mode==0 && levdiff<0.0f) levdiff=0.0f;
   25a58:	68e3      	ldr	r3, [r4, #12]
    float levdiff=(tPowerFollower_tick(&p->pwrFlw, input)-p->targetLevel);
   25a5a:	ee70 7a67 	vsub.f32	s15, s0, s15
    if (p->mode==0 && levdiff<0.0f) levdiff=0.0f;
   25a5e:	b943      	cbnz	r3, 25a72 <tFeedbackLeveler_tick+0x32>
   25a60:	eef5 7a40 	vcmp.f32	s15, #0.0
   25a64:	ed9f 7a09 	vldr	s14, [pc, #36]	; 25a8c <tFeedbackLeveler_tick+0x4c>
   25a68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25a6c:	bf48      	it	mi
   25a6e:	eef0 7a47 	vmovmi.f32	s15, s14
    p->curr=input*(1.0f-p->strength*levdiff);
   25a72:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   25a76:	ed94 7a02 	vldr	s14, [r4, #8]
   25a7a:	eea7 0a67 	vfms.f32	s0, s14, s15
   25a7e:	ee20 0a08 	vmul.f32	s0, s0, s16
   25a82:	ed84 0a04 	vstr	s0, [r4, #16]
    return p->curr;
}
   25a86:	ecbd 8b02 	vpop	{d8}
   25a8a:	bd10      	pop	{r4, pc}
   25a8c:	00000000 	.word	0x00000000

00025a90 <tFeedbackLeveler_setTargetLevel>:
}


void     tFeedbackLeveler_setTargetLevel   (tFeedbackLeveler* const fb, float TargetLevel)
{
    _tFeedbackLeveler* p = *fb;
   25a90:	6803      	ldr	r3, [r0, #0]
    p->targetLevel=TargetLevel;
   25a92:	ed83 0a01 	vstr	s0, [r3, #4]
}
   25a96:	4770      	bx	lr

00025a98 <tTalkbox_lpcDurbin>:
    }

}

void tTalkbox_lpcDurbin(float *r, int p, float *k, float *g)
{
   25a98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i, j;
    float a[ORD_MAX], at[ORD_MAX], e=r[0];

    for(i=0; i<=p; i++)
   25a9c:	f1b1 0900 	subs.w	r9, r1, #0
{
   25aa0:	4615      	mov	r5, r2
   25aa2:	ed2d 8b04 	vpush	{d8-d9}
   25aa6:	b0c7      	sub	sp, #284	; 0x11c
    float a[ORD_MAX], at[ORD_MAX], e=r[0];
   25aa8:	edd0 8a00 	vldr	s17, [r0]
{
   25aac:	9301      	str	r3, [sp, #4]
    for(i=0; i<=p; i++)
   25aae:	db7e      	blt.n	25bae <tTalkbox_lpcDurbin+0x116>
    {
    	a[i] = 0.0f; //probably don't need to clear at[] or k[]
   25ab0:	f109 0201 	add.w	r2, r9, #1
   25ab4:	4607      	mov	r7, r0
   25ab6:	2100      	movs	r1, #0
   25ab8:	a802      	add	r0, sp, #8
   25aba:	0092      	lsls	r2, r2, #2
   25abc:	f006 ff11 	bl	2c8e2 <memset>
    }
	k[0] = 0.0f;
   25ac0:	2300      	movs	r3, #0
    at[0] = 0.0f;
    for(i=1; i<=p; i++)
   25ac2:	f1b9 0f00 	cmp.w	r9, #0
	k[0] = 0.0f;
   25ac6:	602b      	str	r3, [r5, #0]
    at[0] = 0.0f;
   25ac8:	9324      	str	r3, [sp, #144]	; 0x90
    for(i=1; i<=p; i++)
   25aca:	dd50      	ble.n	25b6e <tTalkbox_lpcDurbin+0xd6>
   25acc:	1d3e      	adds	r6, r7, #4
   25ace:	f06f 0a07 	mvn.w	sl, #7
   25ad2:	3504      	adds	r5, #4
   25ad4:	f10d 0808 	add.w	r8, sp, #8
   25ad8:	ebaa 0a07 	sub.w	sl, sl, r7
   25adc:	4634      	mov	r4, r6
   25ade:	2701      	movs	r7, #1
        for(j=1; j<i; j++)
        {
            at[j] = a[j];
            k[i] -= a[j] * r[i-j];
        }
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
   25ae0:	eddf 9a38 	vldr	s19, [pc, #224]	; 25bc4 <tTalkbox_lpcDurbin+0x12c>
        k[i] = -r[i];
   25ae4:	ed94 8a00 	vldr	s16, [r4]
        for(j=1; j<i; j++)
   25ae8:	2f01      	cmp	r7, #1
   25aea:	f104 0b04 	add.w	fp, r4, #4
   25aee:	eeb0 9ae8 	vabs.f32	s18, s17
        k[i] = -r[i];
   25af2:	eeb1 8a48 	vneg.f32	s16, s16
   25af6:	eca5 8a01 	vstmia	r5!, {s16}
        for(j=1; j<i; j++)
   25afa:	d04c      	beq.n	25b96 <tTalkbox_lpcDurbin+0xfe>
   25afc:	ab25      	add	r3, sp, #148	; 0x94
   25afe:	eb0a 020b 	add.w	r2, sl, fp
   25b02:	a903      	add	r1, sp, #12
   25b04:	4618      	mov	r0, r3
   25b06:	f006 fee1 	bl	2c8cc <memcpy>
   25b0a:	a903      	add	r1, sp, #12
   25b0c:	4603      	mov	r3, r0
   25b0e:	460a      	mov	r2, r1
            k[i] -= a[j] * r[i-j];
   25b10:	ed74 7a01 	vldmdb	r4!, {s15}
            at[j] = a[j];
   25b14:	ecb2 7a01 	vldmia	r2!, {s14}
        for(j=1; j<i; j++)
   25b18:	42a6      	cmp	r6, r4
            k[i] -= a[j] * r[i-j];
   25b1a:	eea7 8a67 	vfms.f32	s16, s14, s15
   25b1e:	ed05 8a01 	vstr	s16, [r5, #-4]
        for(j=1; j<i; j++)
   25b22:	d1f5      	bne.n	25b10 <tTalkbox_lpcDurbin+0x78>
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
   25b24:	eeb4 9ae9 	vcmpe.f32	s18, s19
   25b28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25b2c:	d429      	bmi.n	25b82 <tTalkbox_lpcDurbin+0xea>
        k[i] /= e;
   25b2e:	eec8 6a28 	vdiv.f32	s13, s16, s17
   25b32:	aa24      	add	r2, sp, #144	; 0x90
   25b34:	4618      	mov	r0, r3
   25b36:	eb02 0287 	add.w	r2, r2, r7, lsl #2
   25b3a:	ed45 6a01 	vstr	s13, [r5, #-4]

        a[i] = k[i];
   25b3e:	edc8 6a01 	vstr	s13, [r8, #4]
        for(j=1; j<i; j++) a[j] = at[j] + k[i] * at[i-j];
   25b42:	ed32 7a01 	vldmdb	r2!, {s14}
   25b46:	ecf0 7a01 	vldmia	r0!, {s15}
   25b4a:	4293      	cmp	r3, r2
   25b4c:	eee7 7a26 	vfma.f32	s15, s14, s13
   25b50:	ece1 7a01 	vstmia	r1!, {s15}
   25b54:	d1f5      	bne.n	25b42 <tTalkbox_lpcDurbin+0xaa>

        e *= 1.0f - k[i] * k[i];
   25b56:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    for(i=1; i<=p; i++)
   25b5a:	3701      	adds	r7, #1
   25b5c:	f108 0804 	add.w	r8, r8, #4
   25b60:	465c      	mov	r4, fp
   25b62:	45b9      	cmp	r9, r7
        e *= 1.0f - k[i] * k[i];
   25b64:	eee6 7ae6 	vfms.f32	s15, s13, s13
   25b68:	ee68 8aa7 	vmul.f32	s17, s17, s15
    for(i=1; i<=p; i++)
   25b6c:	daba      	bge.n	25ae4 <tTalkbox_lpcDurbin+0x4c>
    }

    if(e < 1.0e-20f) e = 0.0f;
   25b6e:	eddf 7a15 	vldr	s15, [pc, #84]	; 25bc4 <tTalkbox_lpcDurbin+0x12c>
   25b72:	eef4 8ae7 	vcmpe.f32	s17, s15
   25b76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25b7a:	d402      	bmi.n	25b82 <tTalkbox_lpcDurbin+0xea>
   25b7c:	eef1 7ae8 	vsqrt.f32	s15, s17
   25b80:	e001      	b.n	25b86 <tTalkbox_lpcDurbin+0xee>
        for(j=1; j<i; j++)
   25b82:	eddf 7a11 	vldr	s15, [pc, #68]	; 25bc8 <tTalkbox_lpcDurbin+0x130>
    *g = sqrtf(e);
   25b86:	9b01      	ldr	r3, [sp, #4]
   25b88:	edc3 7a00 	vstr	s15, [r3]
}
   25b8c:	b047      	add	sp, #284	; 0x11c
   25b8e:	ecbd 8b04 	vpop	{d8-d9}
   25b92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
   25b96:	eeb4 9ae9 	vcmpe.f32	s18, s19
   25b9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25b9e:	d4f0      	bmi.n	25b82 <tTalkbox_lpcDurbin+0xea>
        k[i] /= e;
   25ba0:	eec8 6a28 	vdiv.f32	s13, s16, s17
   25ba4:	ed45 6a01 	vstr	s13, [r5, #-4]
        a[i] = k[i];
   25ba8:	edc8 6a01 	vstr	s13, [r8, #4]
   25bac:	e7d3      	b.n	25b56 <tTalkbox_lpcDurbin+0xbe>
    if(e < 1.0e-20f) e = 0.0f;
   25bae:	eddf 7a05 	vldr	s15, [pc, #20]	; 25bc4 <tTalkbox_lpcDurbin+0x12c>
	k[0] = 0.0f;
   25bb2:	2300      	movs	r3, #0
    if(e < 1.0e-20f) e = 0.0f;
   25bb4:	eef4 8ae7 	vcmpe.f32	s17, s15
	k[0] = 0.0f;
   25bb8:	6013      	str	r3, [r2, #0]
    if(e < 1.0e-20f) e = 0.0f;
   25bba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25bbe:	d5dd      	bpl.n	25b7c <tTalkbox_lpcDurbin+0xe4>
   25bc0:	e7df      	b.n	25b82 <tTalkbox_lpcDurbin+0xea>
   25bc2:	bf00      	nop
   25bc4:	1e3ce508 	.word	0x1e3ce508
   25bc8:	00000000 	.word	0x00000000

00025bcc <tTalkboxFloat_free>:
    tTalkboxFloat_update(voc);
    tTalkboxFloat_suspend(voc);
}

void tTalkboxFloat_free (tTalkboxFloat* const voc)
{
   25bcc:	b510      	push	{r4, lr}
    _tTalkboxFloat* v = *voc;
   25bce:	6804      	ldr	r4, [r0, #0]

    mpool_free((char*)v->buf1, v->mempool);
   25bd0:	6821      	ldr	r1, [r4, #0]
   25bd2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   25bd4:	f004 f850 	bl	29c78 <mpool_free>
    mpool_free((char*)v->buf0, v->mempool);
   25bd8:	6821      	ldr	r1, [r4, #0]
   25bda:	6a60      	ldr	r0, [r4, #36]	; 0x24
   25bdc:	f004 f84c 	bl	29c78 <mpool_free>
    mpool_free((char*)v->window, v->mempool);
   25be0:	6821      	ldr	r1, [r4, #0]
   25be2:	6a20      	ldr	r0, [r4, #32]
   25be4:	f004 f848 	bl	29c78 <mpool_free>
    mpool_free((char*)v->car1, v->mempool);
   25be8:	6821      	ldr	r1, [r4, #0]
   25bea:	69e0      	ldr	r0, [r4, #28]
   25bec:	f004 f844 	bl	29c78 <mpool_free>
    mpool_free((char*)v->car0, v->mempool);
   25bf0:	6821      	ldr	r1, [r4, #0]
   25bf2:	69a0      	ldr	r0, [r4, #24]
   25bf4:	f004 f840 	bl	29c78 <mpool_free>

    mpool_free((char*)v->dl, v->mempool);
   25bf8:	6821      	ldr	r1, [r4, #0]
   25bfa:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
   25bfe:	f004 f83b 	bl	29c78 <mpool_free>
    mpool_free((char*)v->Rt, v->mempool);
   25c02:	6821      	ldr	r1, [r4, #0]
   25c04:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
   25c08:	f004 f836 	bl	29c78 <mpool_free>
    mpool_free((char*)v->k, v->mempool);
   25c0c:	6821      	ldr	r1, [r4, #0]
   25c0e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   25c10:	f004 f832 	bl	29c78 <mpool_free>
    mpool_free((char*)v, v->mempool);
   25c14:	6821      	ldr	r1, [r4, #0]
   25c16:	4620      	mov	r0, r4
}
   25c18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)v, v->mempool);
   25c1c:	f004 b82c 	b.w	29c78 <mpool_free>

00025c20 <tTalkboxFloat_update>:

void tTalkboxFloat_update(tTalkboxFloat* const voc) ///update internal parameters...
{
   25c20:	b538      	push	{r3, r4, r5, lr}
    _tTalkboxFloat* v = *voc;
   25c22:	6804      	ldr	r4, [r0, #0]

    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
    if(n > v->bufsize) n = v->bufsize;

    //O = (VstInt32)(0.0005f * fs);
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   25c24:	eddf 7a33 	vldr	s15, [pc, #204]	; 25cf4 <tTalkboxFloat_update+0xd4>
    float fs = leaf.sampleRate;
   25c28:	4b33      	ldr	r3, [pc, #204]	; (25cf8 <tTalkboxFloat_update+0xd8>)
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   25c2a:	ed9f 7a34 	vldr	s14, [pc, #208]	; 25cfc <tTalkboxFloat_update+0xdc>
   25c2e:	eddf 5a34 	vldr	s11, [pc, #208]	; 25d00 <tTalkboxFloat_update+0xe0>
   25c32:	ed9f 6a34 	vldr	s12, [pc, #208]	; 25d04 <tTalkboxFloat_update+0xe4>
{
   25c36:	ed2d 8b04 	vpush	{d8-d9}
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   25c3a:	edd4 6a04 	vldr	s13, [r4, #16]
   25c3e:	6961      	ldr	r1, [r4, #20]
   25c40:	eea6 7aa7 	vfma.f32	s14, s13, s15
   25c44:	edd3 6a00 	vldr	s13, [r3]
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   25c48:	eddf 7a2f 	vldr	s15, [pc, #188]	; 25d08 <tTalkboxFloat_update+0xe8>
   25c4c:	fec6 6ae5 	vminnm.f32	s13, s13, s11
   25c50:	fec6 6a86 	vmaxnm.f32	s13, s13, s12
   25c54:	ee66 7aa7 	vmul.f32	s15, s13, s15

    if(n != v->N) //recalc hanning window
   25c58:	6c62      	ldr	r2, [r4, #68]	; 0x44
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   25c5a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   25c5e:	ee27 7a26 	vmul.f32	s14, s14, s13
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   25c62:	ee17 3a90 	vmov	r3, s15
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   25c66:	eebd 7ac7 	vcvt.s32.f32	s14, s14
   25c6a:	428b      	cmp	r3, r1
   25c6c:	bfa8      	it	ge
   25c6e:	460b      	movge	r3, r1
   25c70:	ed84 7a12 	vstr	s14, [r4, #72]	; 0x48
    if(n != v->N) //recalc hanning window
   25c74:	429a      	cmp	r2, r3
   25c76:	d027      	beq.n	25cc8 <tTalkboxFloat_update+0xa8>
    {
        v->N = n;
        float dp = TWO_PI / v->N;
   25c78:	ee07 3a90 	vmov	s15, r3
   25c7c:	ed9f 7a23 	vldr	s14, [pc, #140]	; 25d0c <tTalkboxFloat_update+0xec>
        float p = 0.0f;
        for(n=0; n<v->N; n++)
   25c80:	2b00      	cmp	r3, #0
        v->N = n;
   25c82:	6463      	str	r3, [r4, #68]	; 0x44
        float dp = TWO_PI / v->N;
   25c84:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   25c88:	eec7 8a27 	vdiv.f32	s17, s14, s15
        for(n=0; n<v->N; n++)
   25c8c:	dd1c      	ble.n	25cc8 <tTalkboxFloat_update+0xa8>
        float p = 0.0f;
   25c8e:	ed9f 8a20 	vldr	s16, [pc, #128]	; 25d10 <tTalkboxFloat_update+0xf0>
        for(n=0; n<v->N; n++)
   25c92:	2500      	movs	r5, #0
   25c94:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
        {
            v->window[n] = 0.5f - 0.5f * cosf(p);
   25c98:	eef6 9a00 	vmov.f32	s19, #96	; 0x3f000000  0.5
   25c9c:	eeb0 9a40 	vmov.f32	s18, s0
   25ca0:	e001      	b.n	25ca6 <tTalkboxFloat_update+0x86>
   25ca2:	f006 ff47 	bl	2cb34 <cosf>
   25ca6:	ee39 0a40 	vsub.f32	s0, s18, s0
   25caa:	6a23      	ldr	r3, [r4, #32]
            p += dp;
   25cac:	ee38 8a28 	vadd.f32	s16, s16, s17
            v->window[n] = 0.5f - 0.5f * cosf(p);
   25cb0:	eb03 0385 	add.w	r3, r3, r5, lsl #2
        for(n=0; n<v->N; n++)
   25cb4:	3501      	adds	r5, #1
            v->window[n] = 0.5f - 0.5f * cosf(p);
   25cb6:	ee60 7a29 	vmul.f32	s15, s0, s19
   25cba:	eeb0 0a48 	vmov.f32	s0, s16
   25cbe:	edc3 7a00 	vstr	s15, [r3]
        for(n=0; n<v->N; n++)
   25cc2:	6c63      	ldr	r3, [r4, #68]	; 0x44
   25cc4:	42ab      	cmp	r3, r5
   25cc6:	dcec      	bgt.n	25ca2 <tTalkboxFloat_update+0x82>
        }
    }
    v->wet = 0.5f * v->param[0] * v->param[0];
   25cc8:	ed94 7a01 	vldr	s14, [r4, #4]
   25ccc:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    v->dry = 2.0f * v->param[1] * v->param[1];
   25cd0:	edd4 7a02 	vldr	s15, [r4, #8]
    v->wet = 0.5f * v->param[0] * v->param[0];
   25cd4:	ee27 7a07 	vmul.f32	s14, s14, s14
    v->dry = 2.0f * v->param[1] * v->param[1];
   25cd8:	ee67 7aa7 	vmul.f32	s15, s15, s15
    v->wet = 0.5f * v->param[0] * v->param[0];
   25cdc:	ee27 7a26 	vmul.f32	s14, s14, s13
    v->dry = 2.0f * v->param[1] * v->param[1];
   25ce0:	ee77 7aa7 	vadd.f32	s15, s15, s15
    v->wet = 0.5f * v->param[0] * v->param[0];
   25ce4:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
    v->dry = 2.0f * v->param[1] * v->param[1];
   25ce8:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
}
   25cec:	ecbd 8b04 	vpop	{d8-d9}
   25cf0:	bd38      	pop	{r3, r4, r5, pc}
   25cf2:	bf00      	nop
   25cf4:	39d1b717 	.word	0x39d1b717
   25cf8:	020fbd68 	.word	0x020fbd68
   25cfc:	38d1b717 	.word	0x38d1b717
   25d00:	47bb8000 	.word	0x47bb8000
   25d04:	45fa0000 	.word	0x45fa0000
   25d08:	3c85c67e 	.word	0x3c85c67e
   25d0c:	40c90fdb 	.word	0x40c90fdb
   25d10:	00000000 	.word	0x00000000

00025d14 <tTalkboxFloat_initToPool>:
{
   25d14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
   25d18:	6817      	ldr	r7, [r2, #0]
{
   25d1a:	4680      	mov	r8, r0
   25d1c:	4689      	mov	r9, r1
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   25d1e:	2090      	movs	r0, #144	; 0x90
   25d20:	4639      	mov	r1, r7
    v->param[1] = 0.0f;  //dry
   25d22:	2400      	movs	r4, #0
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   25d24:	f003 ff00 	bl	29b28 <mpool_alloc>
    v->warpOn = 0;
   25d28:	2500      	movs	r5, #0
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   25d2a:	4606      	mov	r6, r0
    v->param[0] = 0.5f;  //wet
   25d2c:	f04f 527c 	mov.w	r2, #1056964608	; 0x3f000000
    v->param[3] = 1.0f;  //quality
   25d30:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   25d34:	f8c8 0000 	str.w	r0, [r8]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d38:	4639      	mov	r1, r7
    v->mempool = m;
   25d3a:	6007      	str	r7, [r0, #0]
    v->bufsize = bufsize;
   25d3c:	f8c0 9014 	str.w	r9, [r0, #20]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d40:	ea4f 0089 	mov.w	r0, r9, lsl #2
    v->param[0] = 0.5f;  //wet
   25d44:	6072      	str	r2, [r6, #4]
    v->param[3] = 1.0f;  //quality
   25d46:	6133      	str	r3, [r6, #16]
    v->param[1] = 0.0f;  //dry
   25d48:	60b4      	str	r4, [r6, #8]
    v->param[2] = 0; // Swap
   25d4a:	60f4      	str	r4, [r6, #12]
    v->warpFactor = 0.0f;
   25d4c:	6334      	str	r4, [r6, #48]	; 0x30
    v->G = 0.0f;
   25d4e:	f8c6 4084 	str.w	r4, [r6, #132]	; 0x84
    v->freeze = 0;
   25d52:	e9c6 550d 	strd	r5, r5, [r6, #52]	; 0x34
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d56:	f003 fee7 	bl	29b28 <mpool_alloc>
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d5a:	6973      	ldr	r3, [r6, #20]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d5c:	61b0      	str	r0, [r6, #24]
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d5e:	4639      	mov	r1, r7
   25d60:	0098      	lsls	r0, r3, #2
   25d62:	f003 fee1 	bl	29b28 <mpool_alloc>
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d66:	6973      	ldr	r3, [r6, #20]
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d68:	61f0      	str	r0, [r6, #28]
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d6a:	4639      	mov	r1, r7
   25d6c:	0098      	lsls	r0, r3, #2
   25d6e:	f003 fedb 	bl	29b28 <mpool_alloc>
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d72:	6973      	ldr	r3, [r6, #20]
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d74:	6230      	str	r0, [r6, #32]
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d76:	4639      	mov	r1, r7
   25d78:	0098      	lsls	r0, r3, #2
   25d7a:	f003 fed5 	bl	29b28 <mpool_alloc>
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d7e:	6973      	ldr	r3, [r6, #20]
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d80:	6270      	str	r0, [r6, #36]	; 0x24
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d82:	4639      	mov	r1, r7
   25d84:	0098      	lsls	r0, r3, #2
   25d86:	f003 fecf 	bl	29b28 <mpool_alloc>
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d8a:	6973      	ldr	r3, [r6, #20]
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d8c:	62b0      	str	r0, [r6, #40]	; 0x28
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d8e:	4639      	mov	r1, r7
   25d90:	0098      	lsls	r0, r3, #2
   25d92:	f003 fec9 	bl	29b28 <mpool_alloc>
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d96:	6973      	ldr	r3, [r6, #20]
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d98:	f8c6 0088 	str.w	r0, [r6, #136]	; 0x88
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25d9c:	4639      	mov	r1, r7
   25d9e:	0098      	lsls	r0, r3, #2
   25da0:	f003 fec2 	bl	29b28 <mpool_alloc>
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
   25da4:	4639      	mov	r1, r7
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25da6:	f8c6 008c 	str.w	r0, [r6, #140]	; 0x8c
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
   25daa:	2088      	movs	r0, #136	; 0x88
   25dac:	f003 febc 	bl	29b28 <mpool_alloc>
   25db0:	62f0      	str	r0, [r6, #44]	; 0x2c
    tTalkboxFloat_update(voc);
   25db2:	4640      	mov	r0, r8
   25db4:	f7ff ff34 	bl	25c20 <tTalkboxFloat_update>

void tTalkboxFloat_suspend(tTalkboxFloat* const voc) ///clear any buffers...
{
    _tTalkboxFloat* v = *voc;
   25db8:	f8d8 3000 	ldr.w	r3, [r8]
    v->FX = 0;

    v->u0 = v->u1 = v->u2 = v->u3 = v->u4 = 0.0f;
    v->d0 = v->d1 = v->d2 = v->d3 = v->d4 = 0.0f;

    for (int32_t i = 0; i < v->bufsize; i++)
   25dbc:	695a      	ldr	r2, [r3, #20]
    v->pos = v->K = 0;
   25dbe:	641d      	str	r5, [r3, #64]	; 0x40
    for (int32_t i = 0; i < v->bufsize; i++)
   25dc0:	42aa      	cmp	r2, r5
    v->pos = v->K = 0;
   25dc2:	64dd      	str	r5, [r3, #76]	; 0x4c
    v->emphasis = 0.0f;
   25dc4:	63dc      	str	r4, [r3, #60]	; 0x3c
    v->FX = 0;
   25dc6:	659c      	str	r4, [r3, #88]	; 0x58
    v->u0 = v->u1 = v->u2 = v->u3 = v->u4 = 0.0f;
   25dc8:	f8c3 4080 	str.w	r4, [r3, #128]	; 0x80
   25dcc:	67dc      	str	r4, [r3, #124]	; 0x7c
   25dce:	679c      	str	r4, [r3, #120]	; 0x78
   25dd0:	675c      	str	r4, [r3, #116]	; 0x74
   25dd2:	671c      	str	r4, [r3, #112]	; 0x70
    v->d0 = v->d1 = v->d2 = v->d3 = v->d4 = 0.0f;
   25dd4:	66dc      	str	r4, [r3, #108]	; 0x6c
   25dd6:	669c      	str	r4, [r3, #104]	; 0x68
   25dd8:	665c      	str	r4, [r3, #100]	; 0x64
   25dda:	661c      	str	r4, [r3, #96]	; 0x60
   25ddc:	65dc      	str	r4, [r3, #92]	; 0x5c
    for (int32_t i = 0; i < v->bufsize; i++)
   25dde:	dd12      	ble.n	25e06 <tTalkboxFloat_initToPool+0xf2>
   25de0:	4629      	mov	r1, r5
    {
        v->buf0[i] = 0;
   25de2:	4622      	mov	r2, r4
   25de4:	0088      	lsls	r0, r1, #2
   25de6:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    for (int32_t i = 0; i < v->bufsize; i++)
   25de8:	3101      	adds	r1, #1
        v->buf0[i] = 0;
   25dea:	4404      	add	r4, r0
   25dec:	6022      	str	r2, [r4, #0]
        v->buf1[i] = 0;
   25dee:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   25df0:	4404      	add	r4, r0
   25df2:	6022      	str	r2, [r4, #0]
        v->car0[i] = 0;
   25df4:	699c      	ldr	r4, [r3, #24]
   25df6:	4404      	add	r4, r0
   25df8:	6022      	str	r2, [r4, #0]
        v->car1[i] = 0;
   25dfa:	69dc      	ldr	r4, [r3, #28]
   25dfc:	4420      	add	r0, r4
   25dfe:	6002      	str	r2, [r0, #0]
    for (int32_t i = 0; i < v->bufsize; i++)
   25e00:	6958      	ldr	r0, [r3, #20]
   25e02:	4281      	cmp	r1, r0
   25e04:	dbee      	blt.n	25de4 <tTalkboxFloat_initToPool+0xd0>
}
   25e06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   25e0a:	bf00      	nop

00025e0c <tTalkboxFloat_warpedAutocorrelate>:

// warped autocorrelation adapted from ten.enegatum@liam's post on music-dsp 2004-04-07 09:37:51
//find the order-P autocorrelation array, R, for the sequence x of length L and warping of lambda
//wAutocorrelate(&pfSrc[stIndex],siglen,R,P,0);
void tTalkboxFloat_warpedAutocorrelate(float * x, float* dl, float* Rt, unsigned int L, float * R, unsigned int P, float lambda)
{
   25e0c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    float r1,r2,r1t;
    R[0]=0;
   25e10:	ed9f 7a34 	vldr	s14, [pc, #208]	; 25ee4 <tTalkboxFloat_warpedAutocorrelate+0xd8>
{
   25e14:	f8dd e01c 	ldr.w	lr, [sp, #28]
   25e18:	9d08      	ldr	r5, [sp, #32]
    R[0]=0;
   25e1a:	ed8e 7a00 	vstr	s14, [lr]
    Rt[0]=0;
   25e1e:	ed82 7a00 	vstr	s14, [r2]
    r1=0;
    r2=0;
    r1t=0;
    for(uint32_t m=0; m<L;m++)
   25e22:	b1f3      	cbz	r3, 25e62 <tTalkboxFloat_warpedAutocorrelate+0x56>
   25e24:	4604      	mov	r4, r0
   25e26:	460e      	mov	r6, r1
   25e28:	eb00 0783 	add.w	r7, r0, r3, lsl #2
    r2=0;
   25e2c:	eef0 7a47 	vmov.f32	s15, s14
    r1=0;
   25e30:	eeb0 6a47 	vmov.f32	s12, s14
   25e34:	e001      	b.n	25e3a <tTalkboxFloat_warpedAutocorrelate+0x2e>
   25e36:	ed92 7a00 	vldr	s14, [r2]
    {
                    Rt[0] += (x[m]) * (x[m]);
   25e3a:	edd4 6a00 	vldr	s13, [r4]
   25e3e:	eea6 7aa6 	vfma.f32	s14, s13, s13
   25e42:	ed82 7a00 	vstr	s14, [r2]

                    dl[m]= r1 - lambda * (x[m]-r2);
   25e46:	ecb4 7a01 	vldmia	r4!, {s14}
   25e4a:	ee77 7ac7 	vsub.f32	s15, s15, s14
    for(uint32_t m=0; m<L;m++)
   25e4e:	42bc      	cmp	r4, r7
                    dl[m]= r1 - lambda * (x[m]-r2);
   25e50:	eea7 6a80 	vfma.f32	s12, s15, s0
   25e54:	eef0 7a46 	vmov.f32	s15, s12
   25e58:	eca6 6a01 	vstmia	r6!, {s12}
                    r1 = x[m];
   25e5c:	ed14 6a01 	vldr	s12, [r4, #-4]
    for(uint32_t m=0; m<L;m++)
   25e60:	d1e9      	bne.n	25e36 <tTalkboxFloat_warpedAutocorrelate+0x2a>
                    r2 = dl[m];
    }
    for(uint32_t i=1; i<=P; i++)
   25e62:	b3d5      	cbz	r5, 25eda <tTalkboxFloat_warpedAutocorrelate+0xce>
   25e64:	ea4f 0885 	mov.w	r8, r5, lsl #2
   25e68:	4694      	mov	ip, r2
   25e6a:	1d15      	adds	r5, r2, #4
   25e6c:	eb01 0783 	add.w	r7, r1, r3, lsl #2
   25e70:	f108 0804 	add.w	r8, r8, #4
    {
            Rt[i]=0;
   25e74:	ed9f 5a1b 	vldr	s10, [pc, #108]	; 25ee4 <tTalkboxFloat_warpedAutocorrelate+0xd8>
   25e78:	eb02 0908 	add.w	r9, r2, r8
   25e7c:	eca5 5a01 	vstmia	r5!, {s10}
            r1=0;
            r2=0;
            for(unsigned int m=0; m<L;m++)
   25e80:	b303      	cbz	r3, 25ec4 <tTalkboxFloat_warpedAutocorrelate+0xb8>
   25e82:	4606      	mov	r6, r0
   25e84:	460c      	mov	r4, r1
   25e86:	eeb0 7a45 	vmov.f32	s14, s10
            r2=0;
   25e8a:	eef0 7a45 	vmov.f32	s15, s10
            r1=0;
   25e8e:	eef0 6a45 	vmov.f32	s13, s10
   25e92:	e001      	b.n	25e98 <tTalkboxFloat_warpedAutocorrelate+0x8c>
   25e94:	ed15 7a01 	vldr	s14, [r5, #-4]
            {
                    Rt[i] +=  (dl[m]) * (x[m]);
   25e98:	edd4 5a00 	vldr	s11, [r4]
   25e9c:	ecb6 6a01 	vldmia	r6!, {s12}
   25ea0:	eea5 7a86 	vfma.f32	s14, s11, s12
   25ea4:	ed05 7a01 	vstr	s14, [r5, #-4]

                    r1t = dl[m];
   25ea8:	ecb4 7a01 	vldmia	r4!, {s14}
                    dl[m]= r1 - lambda * (r1t-r2);
   25eac:	ee77 7ac7 	vsub.f32	s15, s15, s14
            for(unsigned int m=0; m<L;m++)
   25eb0:	42a7      	cmp	r7, r4
                    dl[m]= r1 - lambda * (r1t-r2);
   25eb2:	eee7 6a80 	vfma.f32	s13, s15, s0
   25eb6:	eef0 7a66 	vmov.f32	s15, s13
                    r1 = r1t;
   25eba:	eef0 6a47 	vmov.f32	s13, s14
                    dl[m]= r1 - lambda * (r1t-r2);
   25ebe:	ed44 7a01 	vstr	s15, [r4, #-4]
            for(unsigned int m=0; m<L;m++)
   25ec2:	d1e7      	bne.n	25e94 <tTalkboxFloat_warpedAutocorrelate+0x88>
    for(uint32_t i=1; i<=P; i++)
   25ec4:	45a9      	cmp	r9, r5
   25ec6:	d1d9      	bne.n	25e7c <tTalkboxFloat_warpedAutocorrelate+0x70>
   25ec8:	4442      	add	r2, r8
                    r2 = dl[m];
            }
    }
    for(uint32_t i=0; i<=P; i++)
    {
            R[i]=Rt[i];
   25eca:	f85c 3b04 	ldr.w	r3, [ip], #4
    for(uint32_t i=0; i<=P; i++)
   25ece:	4562      	cmp	r2, ip
            R[i]=Rt[i];
   25ed0:	f84e 3b04 	str.w	r3, [lr], #4
    for(uint32_t i=0; i<=P; i++)
   25ed4:	d1f9      	bne.n	25eca <tTalkboxFloat_warpedAutocorrelate+0xbe>
    }

}
   25ed6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            R[i]=Rt[i];
   25eda:	6813      	ldr	r3, [r2, #0]
   25edc:	f8ce 3000 	str.w	r3, [lr]
}
   25ee0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   25ee4:	00000000 	.word	0x00000000

00025ee8 <tTalkboxFloat_lpc>:
    return o;
}


void tTalkboxFloat_lpc(float *buf, float *car, float* dl, float* Rt, int32_t n, int32_t o, float warp, int warpOn, float *k, int freeze, float *G)
{
   25ee8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25eec:	ed2d 8b02 	vpush	{d8}
   25ef0:	b0c9      	sub	sp, #292	; 0x124
   25ef2:	4604      	mov	r4, r0
   25ef4:	468b      	mov	fp, r1
   25ef6:	9f56      	ldr	r7, [sp, #344]	; 0x158
   25ef8:	9d54      	ldr	r5, [sp, #336]	; 0x150
   25efa:	9e55      	ldr	r6, [sp, #340]	; 0x154
   25efc:	f8dd 8164 	ldr.w	r8, [sp, #356]	; 0x164
    float z[ORD_MAX], r[ORD_MAX], x;
    int32_t i, j, nn=n;


	if (warpOn == 0)
   25f00:	2f00      	cmp	r7, #0
   25f02:	d03a      	beq.n	25f7a <tTalkboxFloat_lpc+0x92>
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
		}
	}
	else
	{
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
   25f04:	2e00      	cmp	r6, #0
   25f06:	4692      	mov	sl, r2
   25f08:	eeb0 8a40 	vmov.f32	s16, s0
   25f0c:	f2c0 80b7 	blt.w	2607e <tTalkboxFloat_lpc+0x196>
		{
			z[j] = r[j] = 0.0f;
   25f10:	1c77      	adds	r7, r6, #1
   25f12:	a826      	add	r0, sp, #152	; 0x98
   25f14:	2100      	movs	r1, #0
   25f16:	9303      	str	r3, [sp, #12]
   25f18:	00bf      	lsls	r7, r7, #2
   25f1a:	9002      	str	r0, [sp, #8]
   25f1c:	463a      	mov	r2, r7
   25f1e:	f006 fce0 	bl	2c8e2 <memset>
   25f22:	463a      	mov	r2, r7
   25f24:	2100      	movs	r1, #0
   25f26:	a804      	add	r0, sp, #16
   25f28:	f006 fcdb 	bl	2c8e2 <memset>
   25f2c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
		}
		tTalkboxFloat_warpedAutocorrelate(buf, dl, Rt, n, r, o, warp);
   25f30:	9200      	str	r2, [sp, #0]
   25f32:	eeb0 0a48 	vmov.f32	s0, s16
   25f36:	461a      	mov	r2, r3
   25f38:	9601      	str	r6, [sp, #4]
   25f3a:	4651      	mov	r1, sl
   25f3c:	462b      	mov	r3, r5
   25f3e:	4620      	mov	r0, r4
   25f40:	f7ff ff64 	bl	25e0c <tTalkboxFloat_warpedAutocorrelate>
	}

	r[0] *= 1.001f;  //stability fix
   25f44:	eddd 7a26 	vldr	s15, [sp, #152]	; 0x98
   25f48:	ed9f 7a4e 	vldr	s14, [pc, #312]	; 26084 <tTalkboxFloat_lpc+0x19c>

	float min = 0.000001f;
	if (!freeze)
   25f4c:	9b58      	ldr	r3, [sp, #352]	; 0x160
	r[0] *= 1.001f;  //stability fix
   25f4e:	ee67 7a87 	vmul.f32	s15, s15, s14
   25f52:	edcd 7a26 	vstr	s15, [sp, #152]	; 0x98
	if (!freeze)
   25f56:	2b00      	cmp	r3, #0
   25f58:	d13f      	bne.n	25fda <tTalkboxFloat_lpc+0xf2>
	{
		if(r[0] < min)
   25f5a:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 26088 <tTalkboxFloat_lpc+0x1a0>
   25f5e:	eef4 7ac7 	vcmpe.f32	s15, s14
   25f62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25f66:	d566      	bpl.n	26036 <tTalkboxFloat_lpc+0x14e>
		{
//            for(i=0; i<n; i++)
//            {
				buf[i] = 0.0f;
   25f68:	eb04 0489 	add.w	r4, r4, r9, lsl #2
   25f6c:	2300      	movs	r3, #0
   25f6e:	6023      	str	r3, [r4, #0]
            x -= k[j] * z[j-1];
            z[j] = z[j-1] + k[j] * x;
        }
        buf[i] = z[0] = x;  //output buf[] will be windowed elsewhere
    }
}
   25f70:	b049      	add	sp, #292	; 0x124
   25f72:	ecbd 8b02 	vpop	{d8}
   25f76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
   25f7a:	2e00      	cmp	r6, #0
   25f7c:	dbe2      	blt.n	25f44 <tTalkboxFloat_lpc+0x5c>
   25f7e:	4629      	mov	r1, r5
			z[j] = r[j] = 0.0f;
   25f80:	f04f 0a00 	mov.w	sl, #0
   25f84:	ea6f 0e06 	mvn.w	lr, r6
   25f88:	af26      	add	r7, sp, #152	; 0x98
   25f8a:	f10d 0c10 	add.w	ip, sp, #16
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
   25f8e:	2900      	cmp	r1, #0
   25f90:	eb00 0285 	add.w	r2, r0, r5, lsl #2
   25f94:	44ae      	add	lr, r5
			z[j] = r[j] = 0.0f;
   25f96:	f847 ab04 	str.w	sl, [r7], #4
   25f9a:	f84c ab04 	str.w	sl, [ip], #4
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
   25f9e:	dd19      	ble.n	25fd4 <tTalkboxFloat_lpc+0xec>
   25fa0:	4681      	mov	r9, r0
   25fa2:	4623      	mov	r3, r4
   25fa4:	eddf 7a39 	vldr	s15, [pc, #228]	; 2608c <tTalkboxFloat_lpc+0x1a4>
   25fa8:	ecf3 6a01 	vldmia	r3!, {s13}
   25fac:	ecb9 7a01 	vldmia	r9!, {s14}
   25fb0:	429a      	cmp	r2, r3
   25fb2:	eee6 7a87 	vfma.f32	s15, s13, s14
   25fb6:	d1f7      	bne.n	25fa8 <tTalkboxFloat_lpc+0xc0>
   25fb8:	4689      	mov	r9, r1
   25fba:	ed47 7a01 	vstr	s15, [r7, #-4]
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
   25fbe:	3901      	subs	r1, #1
   25fc0:	3004      	adds	r0, #4
   25fc2:	3a04      	subs	r2, #4
   25fc4:	458e      	cmp	lr, r1
   25fc6:	d0bd      	beq.n	25f44 <tTalkboxFloat_lpc+0x5c>
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
   25fc8:	2900      	cmp	r1, #0
			z[j] = r[j] = 0.0f;
   25fca:	f847 ab04 	str.w	sl, [r7], #4
   25fce:	f84c ab04 	str.w	sl, [ip], #4
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
   25fd2:	dce5      	bgt.n	25fa0 <tTalkboxFloat_lpc+0xb8>
   25fd4:	f04f 0900 	mov.w	r9, #0
   25fd8:	e7f1      	b.n	25fbe <tTalkboxFloat_lpc+0xd6>
    for(i=0; i<n; i++)
   25fda:	2d00      	cmp	r5, #0
   25fdc:	ddc8      	ble.n	25f70 <tTalkboxFloat_lpc+0x88>
   25fde:	1c77      	adds	r7, r6, #1
   25fe0:	9b57      	ldr	r3, [sp, #348]	; 0x15c
   25fe2:	4658      	mov	r0, fp
   25fe4:	eb0b 0585 	add.w	r5, fp, r5, lsl #2
   25fe8:	00bf      	lsls	r7, r7, #2
   25fea:	1d19      	adds	r1, r3, #4
   25fec:	eb03 0c07 	add.w	ip, r3, r7
   25ff0:	ab04      	add	r3, sp, #16
   25ff2:	441f      	add	r7, r3
        x = G[0] * car[i];
   25ff4:	ecb0 7a01 	vldmia	r0!, {s14}
        for(j=o; j>0; j--)  //lattice filter
   25ff8:	2e00      	cmp	r6, #0
        x = G[0] * car[i];
   25ffa:	edd8 7a00 	vldr	s15, [r8]
   25ffe:	ee27 7a27 	vmul.f32	s14, s14, s15
        for(j=o; j>0; j--)  //lattice filter
   26002:	dd0d      	ble.n	26020 <tTalkboxFloat_lpc+0x138>
   26004:	463a      	mov	r2, r7
   26006:	4663      	mov	r3, ip
            x -= k[j] * z[j-1];
   26008:	ed73 6a01 	vldmdb	r3!, {s13}
   2600c:	ed52 7a02 	vldr	s15, [r2, #-8]
        for(j=o; j>0; j--)  //lattice filter
   26010:	4299      	cmp	r1, r3
            x -= k[j] * z[j-1];
   26012:	eea6 7ae7 	vfms.f32	s14, s13, s15
            z[j] = z[j-1] + k[j] * x;
   26016:	eee6 7a87 	vfma.f32	s15, s13, s14
   2601a:	ed62 7a01 	vstmdb	r2!, {s15}
        for(j=o; j>0; j--)  //lattice filter
   2601e:	d1f3      	bne.n	26008 <tTalkboxFloat_lpc+0x120>
    for(i=0; i<n; i++)
   26020:	4285      	cmp	r5, r0
        buf[i] = z[0] = x;  //output buf[] will be windowed elsewhere
   26022:	ed8d 7a04 	vstr	s14, [sp, #16]
   26026:	eca4 7a01 	vstmia	r4!, {s14}
    for(i=0; i<n; i++)
   2602a:	d1e3      	bne.n	25ff4 <tTalkboxFloat_lpc+0x10c>
}
   2602c:	b049      	add	sp, #292	; 0x124
   2602e:	ecbd 8b02 	vpop	{d8}
   26032:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tTalkbox_lpcDurbin(r, o, k, G);  //calc reflection coeffs
   26036:	4643      	mov	r3, r8
   26038:	9a57      	ldr	r2, [sp, #348]	; 0x15c
   2603a:	4631      	mov	r1, r6
   2603c:	a826      	add	r0, sp, #152	; 0x98
   2603e:	f7ff fd2b 	bl	25a98 <tTalkbox_lpcDurbin>
		for(i=0; i<=o; i++)
   26042:	2e00      	cmp	r6, #0
   26044:	dbc9      	blt.n	25fda <tTalkboxFloat_lpc+0xf2>
   26046:	9b57      	ldr	r3, [sp, #348]	; 0x15c
			if(k[i] > 0.998f) k[i] = 0.998f; else if(k[i] < -0.998f) k[i] = -.998f;
   26048:	ed9f 7a11 	vldr	s14, [pc, #68]	; 26090 <tTalkboxFloat_lpc+0x1a8>
   2604c:	1d1a      	adds	r2, r3, #4
   2604e:	eddf 6a11 	vldr	s13, [pc, #68]	; 26094 <tTalkboxFloat_lpc+0x1ac>
   26052:	eb02 0286 	add.w	r2, r2, r6, lsl #2
   26056:	e003      	b.n	26060 <tTalkboxFloat_lpc+0x178>
   26058:	ed03 7a01 	vstr	s14, [r3, #-4]
		for(i=0; i<=o; i++)
   2605c:	429a      	cmp	r2, r3
   2605e:	d0bc      	beq.n	25fda <tTalkboxFloat_lpc+0xf2>
			if(k[i] > 0.998f) k[i] = 0.998f; else if(k[i] < -0.998f) k[i] = -.998f;
   26060:	ecf3 7a01 	vldmia	r3!, {s15}
   26064:	eef4 7ac7 	vcmpe.f32	s15, s14
   26068:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2606c:	dcf4      	bgt.n	26058 <tTalkboxFloat_lpc+0x170>
   2606e:	eef4 7ae6 	vcmpe.f32	s15, s13
   26072:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26076:	bf48      	it	mi
   26078:	ed43 6a01 	vstrmi	s13, [r3, #-4]
   2607c:	e7ee      	b.n	2605c <tTalkboxFloat_lpc+0x174>
   2607e:	aa26      	add	r2, sp, #152	; 0x98
   26080:	9202      	str	r2, [sp, #8]
   26082:	e755      	b.n	25f30 <tTalkboxFloat_lpc+0x48>
   26084:	3f8020c5 	.word	0x3f8020c5
   26088:	358637bd 	.word	0x358637bd
   2608c:	00000000 	.word	0x00000000
   26090:	3f7f7cee 	.word	0x3f7f7cee
   26094:	bf7f7cee 	.word	0xbf7f7cee

00026098 <tTalkboxFloat_tick>:
{
   26098:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2609c:	ed2d 8b04 	vpush	{d8-d9}
    _tTalkboxFloat* v = *voc;
   260a0:	6804      	ldr	r4, [r0, #0]
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   260a2:	eeb0 5a40 	vmov.f32	s10, s0
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   260a6:	eddf 6a62 	vldr	s13, [pc, #392]	; 26230 <tTalkboxFloat_tick+0x198>
{
   260aa:	b086      	sub	sp, #24
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   260ac:	ed94 7a1b 	vldr	s14, [r4, #108]	; 0x6c
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   260b0:	eddf 5a60 	vldr	s11, [pc, #384]	; 26234 <tTalkboxFloat_tick+0x19c>
   260b4:	edd4 7a17 	vldr	s15, [r4, #92]	; 0x5c
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   260b8:	ed94 6a19 	vldr	s12, [r4, #100]	; 0x64
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   260bc:	eee0 7a25 	vfma.f32	s15, s0, s11
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   260c0:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   260c2:	eea7 6a26 	vfma.f32	s12, s14, s13
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   260c6:	6e21      	ldr	r1, [r4, #96]	; 0x60
    if(v->K++)
   260c8:	6c22      	ldr	r2, [r4, #64]	; 0x40
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   260ca:	6663      	str	r3, [r4, #100]	; 0x64
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   260cc:	65e1      	str	r1, [r4, #92]	; 0x5c
    v->d4 = x;
   260ce:	ed84 0a1b 	vstr	s0, [r4, #108]	; 0x6c
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   260d2:	eea7 5ae5 	vfms.f32	s10, s15, s11
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   260d6:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   260d8:	eea6 7a66 	vfms.f32	s14, s12, s13
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   260dc:	6c63      	ldr	r3, [r4, #68]	; 0x44
    float e=v->emphasis, w, o, x, fx=v->FX;
   260de:	edd4 6a0f 	vldr	s13, [r4, #60]	; 0x3c
   260e2:	ed94 8a16 	vldr	s16, [r4, #88]	; 0x58
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   260e6:	ed84 5a18 	vstr	s10, [r4, #96]	; 0x60
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   260ea:	ed84 7a1a 	vstr	s14, [r4, #104]	; 0x68
    if(v->K++)
   260ee:	2a00      	cmp	r2, #0
   260f0:	d06b      	beq.n	261ca <tTalkboxFloat_tick+0x132>
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   260f2:	2b00      	cmp	r3, #0
   260f4:	461e      	mov	r6, r3
        v->car0[p0] = v->car1[p1] = x; //carrier input
   260f6:	69e0      	ldr	r0, [r4, #28]
    x = p + q;
   260f8:	ee77 7a86 	vadd.f32	s15, s15, s12
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   260fc:	bfb8      	it	lt
   260fe:	1c5e      	addlt	r6, r3, #1
        v->K = 0;
   26100:	2700      	movs	r7, #0
        v->car0[p0] = v->car1[p1] = x; //carrier input
   26102:	00a9      	lsls	r1, r5, #2
        x = o - e;  e = o;  //6dB/oct pre-emphasis
   26104:	ee70 8ae6 	vsub.f32	s17, s1, s13
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   26108:	eb05 0266 	add.w	r2, r5, r6, asr #1
        v->K = 0;
   2610c:	6427      	str	r7, [r4, #64]	; 0x40
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
   2610e:	3501      	adds	r5, #1
   26110:	eeb0 9a60 	vmov.f32	s18, s1
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   26114:	fb92 f6f3 	sdiv	r6, r2, r3
   26118:	fb03 2616 	mls	r6, r3, r6, r2
        v->car0[p0] = v->car1[p1] = x; //carrier input
   2611c:	ea4f 0886 	mov.w	r8, r6, lsl #2
   26120:	4440      	add	r0, r8
   26122:	edc0 7a00 	vstr	s15, [r0]
   26126:	69a3      	ldr	r3, [r4, #24]
   26128:	440b      	add	r3, r1
   2612a:	edc3 7a00 	vstr	s15, [r3]
        w = v->window[p0]; fx = v->buf0[p0] * w;  v->buf0[p0] = x * w;  //50% overlapping hanning windows
   2612e:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
   26132:	440a      	add	r2, r1
   26134:	440b      	add	r3, r1
   26136:	edd2 9a00 	vldr	s19, [r2]
   2613a:	ed93 8a00 	vldr	s16, [r3]
   2613e:	ee68 7aa9 	vmul.f32	s15, s17, s19
   26142:	ee29 8a88 	vmul.f32	s16, s19, s16
   26146:	edc3 7a00 	vstr	s15, [r3]
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
   2614a:	f8d4 c044 	ldr.w	ip, [r4, #68]	; 0x44
   2614e:	45ac      	cmp	ip, r5
   26150:	dd55      	ble.n	261fe <tTalkboxFloat_tick+0x166>
        w = 1.0f - w;  fx += v->buf1[p1] * w;  v->buf1[p1] = x * w;
   26152:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   26156:	6aa3      	ldr	r3, [r4, #40]	; 0x28
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
   26158:	3601      	adds	r6, #1
        w = 1.0f - w;  fx += v->buf1[p1] * w;  v->buf1[p1] = x * w;
   2615a:	4498      	add	r8, r3
   2615c:	ee77 7ae9 	vsub.f32	s15, s15, s19
   26160:	ed98 7a00 	vldr	s14, [r8]
   26164:	ee68 6aa7 	vmul.f32	s13, s17, s15
   26168:	eea7 8a27 	vfma.f32	s16, s14, s15
   2616c:	edc8 6a00 	vstr	s13, [r8]
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
   26170:	6c67      	ldr	r7, [r4, #68]	; 0x44
   26172:	42b7      	cmp	r7, r6
   26174:	dd2e      	ble.n	261d4 <tTalkboxFloat_tick+0x13c>
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   26176:	edd4 7a20 	vldr	s15, [r4, #128]	; 0x80
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   2617a:	eef0 5a48 	vmov.f32	s11, s16
   2617e:	ed9f 6a2d 	vldr	s12, [pc, #180]	; 26234 <tTalkboxFloat_tick+0x19c>
   26182:	ed94 0a1c 	vldr	s0, [r4, #112]	; 0x70
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   26186:	eddf 6a2a 	vldr	s13, [pc, #168]	; 26230 <tTalkboxFloat_tick+0x198>
   2618a:	ed94 7a1e 	vldr	s14, [r4, #120]	; 0x78
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   2618e:	eea8 0a06 	vfma.f32	s0, s16, s12
   26192:	6f62      	ldr	r2, [r4, #116]	; 0x74
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   26194:	eea7 7aa6 	vfma.f32	s14, s15, s13
   26198:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    v->emphasis = e;
   2619a:	ed84 9a0f 	vstr	s18, [r4, #60]	; 0x3c
    v->pos = p0;
   2619e:	64e5      	str	r5, [r4, #76]	; 0x4c
    v->FX = fx;
   261a0:	ed84 8a16 	vstr	s16, [r4, #88]	; 0x58
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   261a4:	eee0 5a46 	vfms.f32	s11, s0, s12
   261a8:	6722      	str	r2, [r4, #112]	; 0x70
    v->u4 = fx;
   261aa:	ed84 8a20 	vstr	s16, [r4, #128]	; 0x80
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   261ae:	eee7 7a66 	vfms.f32	s15, s14, s13
   261b2:	67a3      	str	r3, [r4, #120]	; 0x78
}
   261b4:	ee30 0a07 	vadd.f32	s0, s0, s14
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   261b8:	edc4 5a1d 	vstr	s11, [r4, #116]	; 0x74
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   261bc:	edc4 7a1f 	vstr	s15, [r4, #124]	; 0x7c
}
   261c0:	b006      	add	sp, #24
   261c2:	ecbd 8b04 	vpop	{d8-d9}
   261c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(v->K++)
   261ca:	2301      	movs	r3, #1
    float e=v->emphasis, w, o, x, fx=v->FX;
   261cc:	eeb0 9a66 	vmov.f32	s18, s13
    if(v->K++)
   261d0:	6423      	str	r3, [r4, #64]	; 0x40
   261d2:	e7d0      	b.n	26176 <tTalkboxFloat_tick+0xde>
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
   261d4:	f104 0684 	add.w	r6, r4, #132	; 0x84
   261d8:	ed94 0a0c 	vldr	s0, [r4, #48]	; 0x30
   261dc:	69e1      	ldr	r1, [r4, #28]
   261de:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   261e0:	e9d4 2322 	ldrd	r2, r3, [r4, #136]	; 0x88
   261e4:	9605      	str	r6, [sp, #20]
   261e6:	6ba6      	ldr	r6, [r4, #56]	; 0x38
   261e8:	9604      	str	r6, [sp, #16]
   261ea:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   261ec:	9603      	str	r6, [sp, #12]
   261ee:	6b66      	ldr	r6, [r4, #52]	; 0x34
   261f0:	9602      	str	r6, [sp, #8]
   261f2:	6ca6      	ldr	r6, [r4, #72]	; 0x48
   261f4:	e9cd 7600 	strd	r7, r6, [sp]
   261f8:	f7ff fe76 	bl	25ee8 <tTalkboxFloat_lpc>
   261fc:	e7bb      	b.n	26176 <tTalkboxFloat_tick+0xde>
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
   261fe:	f104 0e84 	add.w	lr, r4, #132	; 0x84
   26202:	ed94 0a0c 	vldr	s0, [r4, #48]	; 0x30
   26206:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
   2620a:	463d      	mov	r5, r7
   2620c:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
   26210:	69a1      	ldr	r1, [r4, #24]
   26212:	6a60      	ldr	r0, [r4, #36]	; 0x24
   26214:	f8cd e014 	str.w	lr, [sp, #20]
   26218:	6ba7      	ldr	r7, [r4, #56]	; 0x38
   2621a:	9704      	str	r7, [sp, #16]
   2621c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   2621e:	9703      	str	r7, [sp, #12]
   26220:	6b67      	ldr	r7, [r4, #52]	; 0x34
   26222:	9702      	str	r7, [sp, #8]
   26224:	6ca7      	ldr	r7, [r4, #72]	; 0x48
   26226:	e9cd c700 	strd	ip, r7, [sp]
   2622a:	f7ff fe5d 	bl	25ee8 <tTalkboxFloat_lpc>
   2622e:	e790      	b.n	26152 <tTalkboxFloat_tick+0xba>
   26230:	3f451eb8 	.word	0x3f451eb8
   26234:	3e99999a 	.word	0x3e99999a

00026238 <tTalkboxFloat_setQuality>:

void tTalkboxFloat_setQuality(tTalkboxFloat* const voc, float quality)
{
    _tTalkboxFloat* v = *voc;
    v->param[3] = quality;
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
   26238:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 26268 <tTalkboxFloat_setQuality+0x30>
   2623c:	eddf 7a0b 	vldr	s15, [pc, #44]	; 2626c <tTalkboxFloat_setQuality+0x34>
   26240:	4b0b      	ldr	r3, [pc, #44]	; (26270 <tTalkboxFloat_setQuality+0x38>)
   26242:	eee0 7a07 	vfma.f32	s15, s0, s14
    _tTalkboxFloat* v = *voc;
   26246:	6802      	ldr	r2, [r0, #0]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
   26248:	ed93 7a00 	vldr	s14, [r3]
    v->param[3] = quality;
   2624c:	ed82 0a04 	vstr	s0, [r2, #16]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
   26250:	ee67 7a87 	vmul.f32	s15, s15, s14
   26254:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   26258:	ee17 3a90 	vmov	r3, s15
    if (v->O >= ORD_MAX)
   2625c:	2b21      	cmp	r3, #33	; 0x21
    {
    	v->O = ORD_MAX-1;
   2625e:	bfc8      	it	gt
   26260:	2321      	movgt	r3, #33	; 0x21
   26262:	6493      	str	r3, [r2, #72]	; 0x48
    }
}
   26264:	4770      	bx	lr
   26266:	bf00      	nop
   26268:	39d1b717 	.word	0x39d1b717
   2626c:	38d1b717 	.word	0x38d1b717
   26270:	020fbd68 	.word	0x020fbd68

00026274 <tTalkboxFloat_setWarpFactor>:

void tTalkboxFloat_setWarpFactor(tTalkboxFloat* const voc, float warpFactor)
{
    _tTalkboxFloat* v = *voc;
   26274:	6803      	ldr	r3, [r0, #0]

    v->warpFactor = warpFactor;
   26276:	ed83 0a0c 	vstr	s0, [r3, #48]	; 0x30
}
   2627a:	4770      	bx	lr

0002627c <tTalkboxFloat_setWarpOn>:

void tTalkboxFloat_setWarpOn(tTalkboxFloat* const voc, float warpOn)
{
    _tTalkboxFloat* v = *voc;

    v->warpOn = warpOn;
   2627c:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tTalkboxFloat* v = *voc;
   26280:	6803      	ldr	r3, [r0, #0]
    v->warpOn = warpOn;
   26282:	ed83 0a0d 	vstr	s0, [r3, #52]	; 0x34
}
   26286:	4770      	bx	lr

00026288 <tTalkboxFloat_setFreeze>:

void tTalkboxFloat_setFreeze(tTalkboxFloat* const voc, float freeze)
{
    _tTalkboxFloat* v = *voc;

    v->freeze = freeze;
   26288:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tTalkboxFloat* v = *voc;
   2628c:	6803      	ldr	r3, [r0, #0]
    v->freeze = freeze;
   2628e:	ed83 0a0e 	vstr	s0, [r3, #56]	; 0x38
}
   26292:	4770      	bx	lr

00026294 <tRosenbergGlottalPulse_initToPool>:
{
    tRosenbergGlottalPulse_initToPool(gp, &leaf.mempool);
}

void tRosenbergGlottalPulse_initToPool (tRosenbergGlottalPulse* const gp, tMempool* const mp)
{
   26294:	b538      	push	{r3, r4, r5, lr}
     _tMempool* m = *mp;
   26296:	680c      	ldr	r4, [r1, #0]
{
   26298:	4605      	mov	r5, r0
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
   2629a:	201c      	movs	r0, #28
   2629c:	4621      	mov	r1, r4
   2629e:	f003 fc43 	bl	29b28 <mpool_alloc>
    g->mempool = m;

    g->phase  = 0.0f;
   262a2:	2300      	movs	r3, #0
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
   262a4:	6028      	str	r0, [r5, #0]
    g->mempool = m;
   262a6:	6004      	str	r4, [r0, #0]
    g->phase  = 0.0f;
   262a8:	6043      	str	r3, [r0, #4]
    g->openLength = 0.0f;
   262aa:	6083      	str	r3, [r0, #8]
    g->pulseLength = 0.0f;
   262ac:	60c3      	str	r3, [r0, #12]
    g->freq = 0.0f;
   262ae:	6143      	str	r3, [r0, #20]
    g->inc = 0.0f;
   262b0:	6183      	str	r3, [r0, #24]


}
   262b2:	bd38      	pop	{r3, r4, r5, pc}

000262b4 <tRosenbergGlottalPulse_free>:
void tRosenbergGlottalPulse_free (tRosenbergGlottalPulse* const gp)
{
    _tRosenbergGlottalPulse* g = *gp;
   262b4:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)g, g->mempool);
   262b6:	6801      	ldr	r1, [r0, #0]
   262b8:	f003 bcde 	b.w	29c78 <mpool_free>

000262bc <tRosenbergGlottalPulse_tick>:
}

float   tRosenbergGlottalPulse_tick           (tRosenbergGlottalPulse* const gp)
{
   262bc:	b508      	push	{r3, lr}
    _tRosenbergGlottalPulse* g = *gp;
   262be:	6803      	ldr	r3, [r0, #0]

    float output = 0.0f;

    // Phasor increment
    g->phase += g->inc;
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   262c0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    g->phase += g->inc;
   262c4:	ed93 7a01 	vldr	s14, [r3, #4]
   262c8:	edd3 7a06 	vldr	s15, [r3, #24]
   262cc:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   262d0:	eeb4 7ae6 	vcmpe.f32	s14, s13
    g->phase += g->inc;
   262d4:	ed83 7a01 	vstr	s14, [r3, #4]
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   262d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   262dc:	db51      	blt.n	26382 <tRosenbergGlottalPulse_tick+0xc6>
   262de:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   262e2:	eeb4 7ac6 	vcmpe.f32	s14, s12
   262e6:	ee77 7a66 	vsub.f32	s15, s14, s13
   262ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   262ee:	eeb0 7a67 	vmov.f32	s14, s15
   262f2:	daf6      	bge.n	262e2 <tRosenbergGlottalPulse_tick+0x26>
   262f4:	edc3 7a01 	vstr	s15, [r3, #4]
    while (g->phase < 0.0f) g->phase += 1.0f;
   262f8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   262fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26300:	d53c      	bpl.n	2637c <tRosenbergGlottalPulse_tick+0xc0>
   26302:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   26306:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   2630a:	eef4 7ac7 	vcmpe.f32	s15, s14
   2630e:	ee37 0aa6 	vadd.f32	s0, s15, s13
   26312:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26316:	eef0 7a40 	vmov.f32	s15, s0
   2631a:	d4f6      	bmi.n	2630a <tRosenbergGlottalPulse_tick+0x4e>
   2631c:	ed83 0a01 	vstr	s0, [r3, #4]

    if (g->phase < g->openLength)
   26320:	edd3 7a02 	vldr	s15, [r3, #8]
   26324:	eef4 7ac0 	vcmpe.f32	s15, s0
   26328:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2632c:	dc17      	bgt.n	2635e <tRosenbergGlottalPulse_tick+0xa2>
    {
        output = 0.5f*(1.0f-fastercosf(PI * g->phase));
    }

    else if (g->phase < g->pulseLength)
   2632e:	ed93 7a03 	vldr	s14, [r3, #12]
   26332:	eeb4 7ac0 	vcmpe.f32	s14, s0
   26336:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2633a:	dc02      	bgt.n	26342 <tRosenbergGlottalPulse_tick+0x86>
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
    }

    else
    {
        output = 0.0f;
   2633c:	ed9f 0a12 	vldr	s0, [pc, #72]	; 26388 <tRosenbergGlottalPulse_tick+0xcc>
    }
    return output;
}
   26340:	bd08      	pop	{r3, pc}
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   26342:	ed93 7a04 	vldr	s14, [r3, #16]
   26346:	ee30 0a67 	vsub.f32	s0, s0, s15
   2634a:	eddf 7a10 	vldr	s15, [pc, #64]	; 2638c <tRosenbergGlottalPulse_tick+0xd0>
   2634e:	ee67 7a27 	vmul.f32	s15, s14, s15
}
   26352:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   26356:	ee27 0a80 	vmul.f32	s0, s15, s0
   2635a:	f003 b8f9 	b.w	29550 <fastercosf>
        output = 0.5f*(1.0f-fastercosf(PI * g->phase));
   2635e:	eddf 7a0c 	vldr	s15, [pc, #48]	; 26390 <tRosenbergGlottalPulse_tick+0xd4>
   26362:	ee20 0a27 	vmul.f32	s0, s0, s15
   26366:	f003 f8f3 	bl	29550 <fastercosf>
   2636a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2636e:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   26372:	ee37 0ac0 	vsub.f32	s0, s15, s0
   26376:	ee20 0a07 	vmul.f32	s0, s0, s14
}
   2637a:	bd08      	pop	{r3, pc}
    while (g->phase < 0.0f) g->phase += 1.0f;
   2637c:	eeb0 0a67 	vmov.f32	s0, s15
   26380:	e7ce      	b.n	26320 <tRosenbergGlottalPulse_tick+0x64>
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   26382:	eef0 7a47 	vmov.f32	s15, s14
   26386:	e7b7      	b.n	262f8 <tRosenbergGlottalPulse_tick+0x3c>
   26388:	00000000 	.word	0x00000000
   2638c:	3fc90fdb 	.word	0x3fc90fdb
   26390:	40490fdb 	.word	0x40490fdb

00026394 <tRosenbergGlottalPulse_tickHQ>:


float   tRosenbergGlottalPulse_tickHQ           (tRosenbergGlottalPulse* const gp)
{
   26394:	b508      	push	{r3, lr}
    _tRosenbergGlottalPulse* g = *gp;
   26396:	6803      	ldr	r3, [r0, #0]

    float output = 0.0f;

    // Phasor increment
    g->phase += g->inc;
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   26398:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    g->phase += g->inc;
   2639c:	ed93 7a01 	vldr	s14, [r3, #4]
   263a0:	edd3 7a06 	vldr	s15, [r3, #24]
   263a4:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   263a8:	eeb4 7ae6 	vcmpe.f32	s14, s13
    g->phase += g->inc;
   263ac:	ed83 7a01 	vstr	s14, [r3, #4]
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   263b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   263b4:	db4e      	blt.n	26454 <tRosenbergGlottalPulse_tickHQ+0xc0>
   263b6:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   263ba:	eeb4 7ac6 	vcmpe.f32	s14, s12
   263be:	ee77 7a66 	vsub.f32	s15, s14, s13
   263c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   263c6:	eeb0 7a67 	vmov.f32	s14, s15
   263ca:	daf6      	bge.n	263ba <tRosenbergGlottalPulse_tickHQ+0x26>
    while (g->phase < 0.0f) g->phase += 1.0f;
   263cc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   263d0:	edc3 7a01 	vstr	s15, [r3, #4]
   263d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   263d8:	d543      	bpl.n	26462 <tRosenbergGlottalPulse_tickHQ+0xce>
   263da:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   263de:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   263e2:	eef4 7ac7 	vcmpe.f32	s15, s14
   263e6:	ee37 0aa6 	vadd.f32	s0, s15, s13
   263ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   263ee:	eef0 7a40 	vmov.f32	s15, s0
   263f2:	d4f6      	bmi.n	263e2 <tRosenbergGlottalPulse_tickHQ+0x4e>
   263f4:	ed83 0a01 	vstr	s0, [r3, #4]

    if (g->phase < g->openLength)
   263f8:	edd3 7a02 	vldr	s15, [r3, #8]
   263fc:	eef4 7ac0 	vcmpe.f32	s15, s0
   26400:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26404:	dc17      	bgt.n	26436 <tRosenbergGlottalPulse_tickHQ+0xa2>
    {
        output = 0.5f*(1.0f-cosf(PI * g->phase));
    }

    else if (g->phase < g->pulseLength)
   26406:	ed93 7a03 	vldr	s14, [r3, #12]
   2640a:	eeb4 7ac0 	vcmpe.f32	s14, s0
   2640e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26412:	dd0d      	ble.n	26430 <tRosenbergGlottalPulse_tickHQ+0x9c>
    {
        output = cosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   26414:	ed93 7a04 	vldr	s14, [r3, #16]
   26418:	ee30 0a67 	vsub.f32	s0, s0, s15
   2641c:	eddf 7a12 	vldr	s15, [pc, #72]	; 26468 <tRosenbergGlottalPulse_tickHQ+0xd4>
   26420:	ee67 7a27 	vmul.f32	s15, s14, s15
    else
    {
        output = 0.0f;
    }
    return output;
}
   26424:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        output = cosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   26428:	ee27 0a80 	vmul.f32	s0, s15, s0
   2642c:	f006 bb82 	b.w	2cb34 <cosf>
        output = 0.0f;
   26430:	ed9f 0a0e 	vldr	s0, [pc, #56]	; 2646c <tRosenbergGlottalPulse_tickHQ+0xd8>
}
   26434:	bd08      	pop	{r3, pc}
        output = 0.5f*(1.0f-cosf(PI * g->phase));
   26436:	eddf 7a0e 	vldr	s15, [pc, #56]	; 26470 <tRosenbergGlottalPulse_tickHQ+0xdc>
   2643a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2643e:	f006 fb79 	bl	2cb34 <cosf>
   26442:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   26446:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   2644a:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2644e:	ee20 0a07 	vmul.f32	s0, s0, s14
}
   26452:	bd08      	pop	{r3, pc}
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   26454:	eef0 7a47 	vmov.f32	s15, s14
    while (g->phase < 0.0f) g->phase += 1.0f;
   26458:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2645c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26460:	d4bb      	bmi.n	263da <tRosenbergGlottalPulse_tickHQ+0x46>
   26462:	eeb0 0a67 	vmov.f32	s0, s15
   26466:	e7c7      	b.n	263f8 <tRosenbergGlottalPulse_tickHQ+0x64>
   26468:	3fc90fdb 	.word	0x3fc90fdb
   2646c:	00000000 	.word	0x00000000
   26470:	40490fdb 	.word	0x40490fdb

00026474 <tRosenbergGlottalPulse_setFreq>:

void   tRosenbergGlottalPulse_setFreq           (tRosenbergGlottalPulse* const gp, float freq)
{
    _tRosenbergGlottalPulse* g = *gp;
    g->freq = freq;
    g->inc = freq * leaf.invSampleRate;
   26474:	4a05      	ldr	r2, [pc, #20]	; (2648c <tRosenbergGlottalPulse_setFreq+0x18>)
    _tRosenbergGlottalPulse* g = *gp;
   26476:	6803      	ldr	r3, [r0, #0]
    g->inc = freq * leaf.invSampleRate;
   26478:	edd2 7a01 	vldr	s15, [r2, #4]
    g->freq = freq;
   2647c:	ed83 0a05 	vstr	s0, [r3, #20]
    g->inc = freq * leaf.invSampleRate;
   26480:	ee27 0a80 	vmul.f32	s0, s15, s0
   26484:	ed83 0a06 	vstr	s0, [r3, #24]
}
   26488:	4770      	bx	lr
   2648a:	bf00      	nop
   2648c:	020fbd68 	.word	0x020fbd68

00026490 <tRosenbergGlottalPulse_setOpenLength>:

void   tRosenbergGlottalPulse_setOpenLength           (tRosenbergGlottalPulse* const gp, float openLength)
{
    _tRosenbergGlottalPulse* g = *gp;
   26490:	6803      	ldr	r3, [r0, #0]
    g->openLength = openLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   26492:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   26496:	edd3 7a03 	vldr	s15, [r3, #12]
    g->openLength = openLength;
   2649a:	ed83 0a02 	vstr	s0, [r3, #8]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   2649e:	ee37 0ac0 	vsub.f32	s0, s15, s0
   264a2:	eec7 7a00 	vdiv.f32	s15, s14, s0
   264a6:	edc3 7a04 	vstr	s15, [r3, #16]
}
   264aa:	4770      	bx	lr

000264ac <tRosenbergGlottalPulse_setPulseLength>:

void   tRosenbergGlottalPulse_setPulseLength           (tRosenbergGlottalPulse* const gp, float pulseLength)
{
    _tRosenbergGlottalPulse* g = *gp;
   264ac:	6803      	ldr	r3, [r0, #0]
    g->pulseLength = pulseLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   264ae:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   264b2:	edd3 7a02 	vldr	s15, [r3, #8]
    g->pulseLength = pulseLength;
   264b6:	ed83 0a03 	vstr	s0, [r3, #12]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   264ba:	ee30 0a67 	vsub.f32	s0, s0, s15
   264be:	eec7 7a00 	vdiv.f32	s15, s14, s0
   264c2:	edc3 7a04 	vstr	s15, [r3, #16]
}
   264c6:	4770      	bx	lr

000264c8 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>:
void   tRosenbergGlottalPulse_setOpenLengthAndPulseLength           (tRosenbergGlottalPulse* const gp, float openLength, float pulseLength)
{
    _tRosenbergGlottalPulse* g = *gp;
    g->openLength = openLength;
    g->pulseLength = pulseLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   264c8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    _tRosenbergGlottalPulse* g = *gp;
   264cc:	6803      	ldr	r3, [r0, #0]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   264ce:	ee30 7ac0 	vsub.f32	s14, s1, s0
    g->openLength = openLength;
   264d2:	ed83 0a02 	vstr	s0, [r3, #8]
    g->pulseLength = pulseLength;
   264d6:	edc3 0a03 	vstr	s1, [r3, #12]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   264da:	eec6 7a87 	vdiv.f32	s15, s13, s14
   264de:	edc3 7a04 	vstr	s15, [r3, #16]
}
   264e2:	4770      	bx	lr

000264e4 <tSOLAD_ioSamples>:
    mpool_free((char*)w, w->mempool);
}

// send one block of input samples, receive one block of output samples
void tSOLAD_ioSamples(tSOLAD* const wp, float* in, float* out, int blocksize)
{
   264e4:	b4f0      	push	{r4, r5, r6, r7}
   264e6:	ed2d 8b02 	vpush	{d8}
    _tSOLAD* w = *wp;
   264ea:	6800      	ldr	r0, [r0, #0]
    
    int i = w->timeindex;
    int n = w->blocksize = blocksize;
   264ec:	b29d      	uxth	r5, r3
    int i = w->timeindex;
   264ee:	8886      	ldrh	r6, [r0, #4]
   264f0:	462b      	mov	r3, r5
    int n = w->blocksize = blocksize;
   264f2:	80c5      	strh	r5, [r0, #6]
    
    if(!i) w->delaybuf[LOOPSIZE] = in[0];   // copy one sample for interpolation
   264f4:	b926      	cbnz	r6, 26500 <tSOLAD_ioSamples+0x1c>
   264f6:	6a04      	ldr	r4, [r0, #32]
   264f8:	680f      	ldr	r7, [r1, #0]
   264fa:	f504 4480 	add.w	r4, r4, #16384	; 0x4000
   264fe:	6027      	str	r7, [r4, #0]
    while(n--) w->delaybuf[i++] = *in++;    // copy one input block to delay buffer
   26500:	b163      	cbz	r3, 2651c <tSOLAD_ioSamples+0x38>
   26502:	eb01 0483 	add.w	r4, r1, r3, lsl #2
   26506:	ebc1 0c86 	rsb	ip, r1, r6, lsl #2
   2650a:	eb0c 0701 	add.w	r7, ip, r1
   2650e:	6a03      	ldr	r3, [r0, #32]
   26510:	f851 6b04 	ldr.w	r6, [r1], #4
   26514:	443b      	add	r3, r7
   26516:	428c      	cmp	r4, r1
   26518:	601e      	str	r6, [r3, #0]
   2651a:	d1f6      	bne.n	2650a <tSOLAD_ioSamples+0x26>
    
    if(w->pitchfactor > 1) pitchup(w, out);
   2651c:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
   26520:	edd0 6a02 	vldr	s13, [r0, #8]
   26524:	8883      	ldrh	r3, [r0, #4]
   26526:	edd0 3a04 	vldr	s7, [r0, #16]
   2652a:	eef4 6ac2 	vcmpe.f32	s13, s4
   2652e:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
   26532:	edd0 7a03 	vldr	s15, [r0, #12]
   26536:	ee06 1a10 	vmov	s12, r1
   2653a:	edd0 5a05 	vldr	s11, [r0, #20]
   2653e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26542:	88c1      	ldrh	r1, [r0, #6]
   26544:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
   26548:	ed90 7a07 	vldr	s14, [r0, #28]
   2654c:	ed90 3a06 	vldr	s6, [r0, #24]
   26550:	f340 80b8 	ble.w	266c4 <tSOLAD_ioSamples+0x1e0>
    float xfadelength = w->xfadelength;
    
    float readlagstep = pitchfactor - 1;
    float xfadespeed = pitchfactor * pitchfactor;
    float xfadestep = xfadespeed / xfadelength;
    float limitfactor = (pitchfactor - (float)0.99) / xfadespeed;
   26554:	ed9f 5aa1 	vldr	s10, [pc, #644]	; 267dc <tSOLAD_ioSamples+0x2f8>
    float xfadespeed = pitchfactor * pitchfactor;
   26558:	ee66 1aa6 	vmul.f32	s3, s13, s13
    float readlagstep = pitchfactor - 1;
   2655c:	ee36 2ac2 	vsub.f32	s4, s13, s4
    float limitfactor = (pitchfactor - (float)0.99) / xfadespeed;
   26560:	ee76 6ac5 	vsub.f32	s13, s13, s10
   26564:	ee86 5aa1 	vdiv.f32	s10, s13, s3
    float limit = period * limitfactor;
   26568:	ee25 1a23 	vmul.f32	s2, s10, s7
    float readindex, outputsample;
    
    if((readlag > (period + 2 * limit)) & (xfadevalue < 0))
   2656c:	ee71 6a01 	vadd.f32	s13, s2, s2
   26570:	ee76 4aa3 	vadd.f32	s9, s13, s7
   26574:	eef4 4a67 	vcmp.f32	s9, s15
   26578:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2657c:	f140 808a 	bpl.w	26694 <tSOLAD_ioSamples+0x1b0>
   26580:	eeb5 7a40 	vcmp.f32	s14, #0.0
   26584:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26588:	f140 8084 	bpl.w	26694 <tSOLAD_ioSamples+0x1b0>
   2658c:	ee77 6ae6 	vsub.f32	s13, s15, s13
    {
        jump = period;                                        // jump forward
   26590:	eef0 5a63 	vmov.f32	s11, s7
   26594:	e001      	b.n	2659a <tSOLAD_ioSamples+0xb6>
        while((jump * 2) < (readlag - 2 * limit)) jump *= 2;  // use available space
   26596:	eef0 5a47 	vmov.f32	s11, s14
   2659a:	ee35 7aa5 	vadd.f32	s14, s11, s11
   2659e:	eeb4 7ae6 	vcmpe.f32	s14, s13
   265a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   265a6:	d4f6      	bmi.n	26596 <tSOLAD_ioSamples+0xb2>
        readlag -= jump;                                      // reduce read pointer lag
        xfadevalue = 1;                                       // start crossfade
        xfadelength = period - 1;
   265a8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        readlag -= jump;                                      // reduce read pointer lag
   265ac:	ee77 7ae5 	vsub.f32	s15, s15, s11
        xfadelength = period - 1;
   265b0:	ee33 3ac7 	vsub.f32	s6, s7, s14
        xfadestep = xfadespeed / xfadelength;
   265b4:	eec1 0a83 	vdiv.f32	s1, s3, s6
    }
    
    while(n--)
   265b8:	1e4c      	subs	r4, r1, #1
   265ba:	2900      	cmp	r1, #0
   265bc:	d05a      	beq.n	26674 <tSOLAD_ioSamples+0x190>
   265be:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
            {
                xfadelength = readlag / limitfactor;
                if(xfadelength < 1) xfadelength = 1;
                xfadestep = xfadespeed / xfadelength;
                
                jump = -period;         // jump backward
   265c2:	eeb1 8a63 	vneg.f32	s16, s7
   265c6:	ee82 0a85 	vdiv.f32	s0, s5, s10
        if(readlag < limit)  // check if read pointer should jump backward...
   265ca:	eeb4 1ae7 	vcmpe.f32	s2, s15
   265ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   265d2:	dd0b      	ble.n	265ec <tSOLAD_ioSamples+0x108>
            if((xfadevalue < 0) | (readlag < 0)) // ...but try not to interrupt crossfade
   265d4:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
                xfadelength = readlag / limitfactor;
   265d8:	ee60 6a27 	vmul.f32	s13, s0, s15
            if((xfadevalue < 0) | (readlag < 0)) // ...but try not to interrupt crossfade
   265dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   265e0:	d465      	bmi.n	266ae <tSOLAD_ioSamples+0x1ca>
   265e2:	eef5 7a40 	vcmp.f32	s15, #0.0
   265e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   265ea:	d460      	bmi.n	266ae <tSOLAD_ioSamples+0x1ca>
                readlag += period;      // increase read pointer lag
                xfadevalue = 1;         // start crossfade
            }
        }
        
        readindex = refindex - readlag;
   265ec:	ee76 6a67 	vsub.f32	s13, s12, s15
        outputsample = read_sample(w, readindex);
   265f0:	6a03      	ldr	r3, [r0, #32]
        
        if(xfadevalue > 0)
   265f2:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
        {
            outputsample *= (1 - xfadevalue);
   265f6:	ee72 8ac7 	vsub.f32	s17, s5, s14
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
   265fa:	ee36 4ae5 	vsub.f32	s8, s13, s11
}

// read one sample from delay buffer, with linear interpolation
static inline float read_sample(_tSOLAD* const w, float floatindex)
{
    int index = (int)floatindex;
   265fe:	eefd 4ae6 	vcvt.s32.f32	s9, s13
        if(xfadevalue > 0)
   26602:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    int index = (int)floatindex;
   26606:	eebd 5ac4 	vcvt.s32.f32	s10, s8
    float fraction = floatindex - (float)index;
    float *buf = w->delaybuf;
    index &= LOOPMASK;
   2660a:	ee14 1a90 	vmov	r1, s9
    float fraction = floatindex - (float)index;
   2660e:	eef8 4ae4 	vcvt.f32.s32	s9, s9
    index &= LOOPMASK;
   26612:	f3c1 010b 	ubfx	r1, r1, #0, #12
   26616:	ee15 6a10 	vmov	r6, s10
    float fraction = floatindex - (float)index;
   2661a:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
    
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   2661e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    float fraction = floatindex - (float)index;
   26622:	ee76 6ae4 	vsub.f32	s13, s13, s9
    index &= LOOPMASK;
   26626:	f3c6 060b 	ubfx	r6, r6, #0, #12
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   2662a:	edd1 4a00 	vldr	s9, [r1]
    float fraction = floatindex - (float)index;
   2662e:	ee34 5a45 	vsub.f32	s10, s8, s10
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   26632:	ed91 4a01 	vldr	s8, [r1, #4]
   26636:	eb03 0386 	add.w	r3, r3, r6, lsl #2
   2663a:	ee34 4a64 	vsub.f32	s8, s8, s9
   2663e:	eee6 4a84 	vfma.f32	s9, s13, s8
        if(xfadevalue > 0)
   26642:	dd2a      	ble.n	2669a <tSOLAD_ioSamples+0x1b6>
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   26644:	edd3 6a00 	vldr	s13, [r3]
    while(n--)
   26648:	3c01      	subs	r4, #1
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   2664a:	ed93 4a01 	vldr	s8, [r3, #4]
        refindex += 1;
   2664e:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
   26652:	1c67      	adds	r7, r4, #1
        readlag -= readlagstep;
   26654:	ee77 7ac2 	vsub.f32	s15, s15, s4
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   26658:	ee34 4a66 	vsub.f32	s8, s8, s13
   2665c:	eee5 6a04 	vfma.f32	s13, s10, s8
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
   26660:	ee66 6a87 	vmul.f32	s13, s13, s14
            xfadevalue -= xfadestep;
   26664:	ee37 7a60 	vsub.f32	s14, s14, s1
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
   26668:	eee4 6aa8 	vfma.f32	s13, s9, s17
        *out++ = outputsample;
   2666c:	ece2 6a01 	vstmia	r2!, {s13}
    while(n--)
   26670:	d1ab      	bne.n	265ca <tSOLAD_ioSamples+0xe6>
   26672:	8883      	ldrh	r3, [r0, #4]
    w->readlag = readlag;               // state variables
   26674:	edc0 7a03 	vstr	s15, [r0, #12]
    w->jump = jump;
   26678:	edc0 5a05 	vstr	s11, [r0, #20]
    w->xfadelength = xfadelength;
   2667c:	ed80 3a06 	vstr	s6, [r0, #24]
    w->xfadevalue = xfadevalue;
   26680:	ed80 7a07 	vstr	s14, [r0, #28]
    w->timeindex += blocksize;
   26684:	441d      	add	r5, r3
    w->timeindex &= LOOPMASK;
   26686:	f3c5 050b 	ubfx	r5, r5, #0, #12
   2668a:	8085      	strh	r5, [r0, #4]
}
   2668c:	ecbd 8b02 	vpop	{d8}
   26690:	bcf0      	pop	{r4, r5, r6, r7}
   26692:	4770      	bx	lr
    float xfadestep = xfadespeed / xfadelength;
   26694:	eec1 0a83 	vdiv.f32	s1, s3, s6
   26698:	e78e      	b.n	265b8 <tSOLAD_ioSamples+0xd4>
    while(n--)
   2669a:	3c01      	subs	r4, #1
        *out++ = outputsample;
   2669c:	ece2 4a01 	vstmia	r2!, {s9}
        refindex += 1;
   266a0:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
   266a4:	1c66      	adds	r6, r4, #1
        readlag -= readlagstep;
   266a6:	ee77 7ac2 	vsub.f32	s15, s15, s4
    while(n--)
   266aa:	d18e      	bne.n	265ca <tSOLAD_ioSamples+0xe6>
   266ac:	e7e1      	b.n	26672 <tSOLAD_ioSamples+0x18e>
   266ae:	fe86 3aa2 	vmaxnm.f32	s6, s13, s5
                jump = -period;         // jump backward
   266b2:	eef0 5a48 	vmov.f32	s11, s16
                xfadestep = xfadespeed / xfadelength;
   266b6:	eec1 0a83 	vdiv.f32	s1, s3, s6
                readlag += period;      // increase read pointer lag
   266ba:	ee77 7aa3 	vadd.f32	s15, s15, s7
                xfadevalue = 1;         // start crossfade
   266be:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   266c2:	e793      	b.n	265ec <tSOLAD_ioSamples+0x108>
    if(pitchfactor > 0.5) xfadespeed = pitchfactor;
   266c4:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
    while(n--)
   266c8:	1e4c      	subs	r4, r1, #1
    float readlagstep = 1 - pitchfactor;
   266ca:	ee72 1a66 	vsub.f32	s3, s4, s13
    else xfadespeed = 1 - pitchfactor;
   266ce:	eef4 6ac5 	vcmpe.f32	s13, s10
   266d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   266d6:	fe76 6aa1 	vselgt.f32	s13, s13, s3
    xfadestep = xfadespeed / xfadelength;
   266da:	eec6 0a83 	vdiv.f32	s1, s13, s6
    while(n--)
   266de:	2900      	cmp	r1, #0
   266e0:	d053      	beq.n	2678a <tSOLAD_ioSamples+0x2a6>
        refindex += 1;
   266e2:	eef0 2a42 	vmov.f32	s5, s4
                xfadelength = period - 1;
   266e6:	ee33 2ac2 	vsub.f32	s4, s7, s4
                xfadestep = xfadespeed / xfadelength;
   266ea:	ee86 0a82 	vdiv.f32	s0, s13, s4
            if(xfadevalue <= 0)      // ...but do not interrupt crossfade
   266ee:	eeb5 7a40 	vcmp.f32	s14, #0.0
   266f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   266f6:	d804      	bhi.n	26702 <tSOLAD_ioSamples+0x21e>
   266f8:	eef4 7a63 	vcmp.f32	s15, s7
   266fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26700:	dc56      	bgt.n	267b0 <tSOLAD_ioSamples+0x2cc>
        readindex = refindex - readlag;
   26702:	ee36 5a67 	vsub.f32	s10, s12, s15
        outputsample = read_sample(w, readindex);
   26706:	6a01      	ldr	r1, [r0, #32]
        if(xfadevalue > 0)
   26708:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
    int index = (int)floatindex;
   2670c:	eefd 6ac5 	vcvt.s32.f32	s13, s10
        if(xfadevalue > 0)
   26710:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    index &= LOOPMASK;
   26714:	ee16 3a90 	vmov	r3, s13
    float fraction = floatindex - (float)index;
   26718:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    index &= LOOPMASK;
   2671c:	f3c3 030b 	ubfx	r3, r3, #0, #12
    float fraction = floatindex - (float)index;
   26720:	ee75 6a66 	vsub.f32	s13, s10, s13
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   26724:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   26728:	edd3 4a00 	vldr	s9, [r3]
   2672c:	ed93 4a01 	vldr	s8, [r3, #4]
   26730:	ee34 4a64 	vsub.f32	s8, s8, s9
   26734:	eee6 4a84 	vfma.f32	s9, s13, s8
        if(xfadevalue > 0)
   26738:	dd30      	ble.n	2679c <tSOLAD_ioSamples+0x2b8>
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
   2673a:	ee35 5a65 	vsub.f32	s10, s10, s11
    while(n--)
   2673e:	3c01      	subs	r4, #1
            outputsample *= (1 - xfadevalue);                               // fadein
   26740:	ee32 1ac7 	vsub.f32	s2, s5, s14
        refindex += 1;
   26744:	ee36 6a22 	vadd.f32	s12, s12, s5
    int index = (int)floatindex;
   26748:	eefd 6ac5 	vcvt.s32.f32	s13, s10
        readlag += readlagstep;
   2674c:	ee77 7aa1 	vadd.f32	s15, s15, s3
    index &= LOOPMASK;
   26750:	ee16 3a90 	vmov	r3, s13
    float fraction = floatindex - (float)index;
   26754:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    index &= LOOPMASK;
   26758:	f3c3 030b 	ubfx	r3, r3, #0, #12
    float fraction = floatindex - (float)index;
   2675c:	ee35 5a66 	vsub.f32	s10, s10, s13
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   26760:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   26764:	edd1 6a00 	vldr	s13, [r1]
   26768:	ed91 4a01 	vldr	s8, [r1, #4]
    while(n--)
   2676c:	1c61      	adds	r1, r4, #1
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   2676e:	ee34 4a66 	vsub.f32	s8, s8, s13
   26772:	eee5 6a04 	vfma.f32	s13, s10, s8
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
   26776:	ee66 6a87 	vmul.f32	s13, s13, s14
            xfadevalue -= xfadestep;
   2677a:	ee37 7a60 	vsub.f32	s14, s14, s1
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
   2677e:	eee4 6a81 	vfma.f32	s13, s9, s2
        *out++ = outputsample;
   26782:	ece2 6a01 	vstmia	r2!, {s13}
    while(n--)
   26786:	d1b2      	bne.n	266ee <tSOLAD_ioSamples+0x20a>
   26788:	8883      	ldrh	r3, [r0, #4]
    w->jump = jump;                 // state variables
   2678a:	edc0 5a05 	vstr	s11, [r0, #20]
    w->readlag = readlag;
   2678e:	edc0 7a03 	vstr	s15, [r0, #12]
    w->xfadevalue = xfadevalue;
   26792:	ed80 7a07 	vstr	s14, [r0, #28]
    w->xfadelength = xfadelength;
   26796:	ed80 3a06 	vstr	s6, [r0, #24]
   2679a:	e773      	b.n	26684 <tSOLAD_ioSamples+0x1a0>
    while(n--)
   2679c:	3c01      	subs	r4, #1
        *out++ = outputsample;
   2679e:	ece2 4a01 	vstmia	r2!, {s9}
        refindex += 1;
   267a2:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
   267a6:	1c63      	adds	r3, r4, #1
        readlag += readlagstep;
   267a8:	ee77 7aa1 	vadd.f32	s15, s15, s3
    while(n--)
   267ac:	d19f      	bne.n	266ee <tSOLAD_ioSamples+0x20a>
   267ae:	e7eb      	b.n	26788 <tSOLAD_ioSamples+0x2a4>
                jump = period;                           // jump forward
   267b0:	eef0 5a63 	vmov.f32	s11, s7
   267b4:	e001      	b.n	267ba <tSOLAD_ioSamples+0x2d6>
                while((jump * 2) < readlag) jump *= 2;   // use available space
   267b6:	eef0 5a47 	vmov.f32	s11, s14
   267ba:	ee35 7aa5 	vadd.f32	s14, s11, s11
   267be:	eeb4 7ae7 	vcmpe.f32	s14, s15
   267c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   267c6:	d4f6      	bmi.n	267b6 <tSOLAD_ioSamples+0x2d2>
                readlag -= jump;                         // reduce read pointer lag
   267c8:	ee77 7ae5 	vsub.f32	s15, s15, s11
                xfadestep = xfadespeed / xfadelength;
   267cc:	eef0 0a40 	vmov.f32	s1, s0
                xfadevalue = 1;                          // start crossfade
   267d0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
                xfadelength = period - 1;
   267d4:	eeb0 3a42 	vmov.f32	s6, s4
   267d8:	e793      	b.n	26702 <tSOLAD_ioSamples+0x21e>
   267da:	bf00      	nop
   267dc:	3f7d70a4 	.word	0x3f7d70a4

000267e0 <tRetune_initToPool>:
{
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
}

void tRetune_initToPool (tRetune* const rt, int numVoices, int bufSize, int frameSize, tMempool* const mp)
{
   267e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   267e4:	ed2d 8b02 	vpush	{d8}
   267e8:	b085      	sub	sp, #20
   267ea:	4604      	mov	r4, r0
   267ec:	4689      	mov	r9, r1
    _tMempool* m = *mp;
    _tRetune* r = *rt = (_tRetune*) mpool_alloc(sizeof(_tRetune), m);
   267ee:	203c      	movs	r0, #60	; 0x3c
{
   267f0:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
   267f4:	4617      	mov	r7, r2
   267f6:	469a      	mov	sl, r3
    _tMempool* m = *mp;
   267f8:	f8d8 6000 	ldr.w	r6, [r8]
    _tRetune* r = *rt = (_tRetune*) mpool_alloc(sizeof(_tRetune), m);
   267fc:	4631      	mov	r1, r6
   267fe:	f003 f993 	bl	29b28 <mpool_alloc>
   26802:	4605      	mov	r5, r0
   26804:	6020      	str	r0, [r4, #0]
    
    r->bufSize = bufSize;
    r->frameSize = frameSize;
    r->numVoices = numVoices;
    
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   26806:	4631      	mov	r1, r6
    r->mempool = *mp;
   26808:	f8d8 2000 	ldr.w	r2, [r8]
    r->frameSize = frameSize;
   2680c:	f8c0 a018 	str.w	sl, [r0, #24]
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   26810:	00b8      	lsls	r0, r7, #2
    r->mempool = *mp;
   26812:	602a      	str	r2, [r5, #0]
    r->bufSize = bufSize;
   26814:	61ef      	str	r7, [r5, #28]
    r->numVoices = numVoices;
   26816:	f8c5 9038 	str.w	r9, [r5, #56]	; 0x38
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   2681a:	f003 f9db 	bl	29bd4 <mpool_calloc>
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
   2681e:	6bab      	ldr	r3, [r5, #56]	; 0x38
   26820:	4631      	mov	r1, r6
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   26822:	60e8      	str	r0, [r5, #12]
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
   26824:	0098      	lsls	r0, r3, #2
   26826:	f003 f9d5 	bl	29bd4 <mpool_calloc>
    
    r->hopSize = DEFHOPSIZE;
   2682a:	f04f 1240 	mov.w	r2, #4194368	; 0x400040
    r->windowSize = DEFWINDOWSIZE;
    r->fba = FBA;
   2682e:	2314      	movs	r3, #20
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
   26830:	6128      	str	r0, [r5, #16]
    r->hopSize = DEFHOPSIZE;
   26832:	622a      	str	r2, [r5, #32]
void tRetune_setTimeConstant(tRetune* const rt, float tc)
{
    _tRetune* r = *rt;
    
    r->timeConstant = tc;
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26834:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
    r->fba = FBA;
   26838:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   2683c:	4b50      	ldr	r3, [pc, #320]	; (26980 <tRetune_initToPool+0x1a0>)
    _tRetune* r = *rt;
   2683e:	6824      	ldr	r4, [r4, #0]
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26840:	ed93 0a01 	vldr	s0, [r3, #4]
   26844:	8c23      	ldrh	r3, [r4, #32]
   26846:	ee20 0a07 	vmul.f32	s0, s0, s14
   2684a:	ee07 3a90 	vmov	s15, r3
    r->timeConstant = tc;
   2684e:	4b4d      	ldr	r3, [pc, #308]	; (26984 <tRetune_initToPool+0x1a4>)
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26850:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    r->timeConstant = tc;
   26854:	62e3      	str	r3, [r4, #44]	; 0x2c
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26856:	ee20 0a27 	vmul.f32	s0, s0, s15
   2685a:	f006 f9ab 	bl	2cbb4 <expf>
    r->inputPeriod = 0.0f;
   2685e:	2300      	movs	r3, #0
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26860:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
   26864:	4631      	mov	r1, r6
   26866:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    r->inputPeriod = 0.0f;
   26868:	636b      	str	r3, [r5, #52]	; 0x34
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
   2686a:	0080      	lsls	r0, r0, #2
   2686c:	f003 f9b2 	bl	29bd4 <mpool_calloc>
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   26870:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
   26872:	60a8      	str	r0, [r5, #8]
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   26874:	4631      	mov	r1, r6
   26876:	0098      	lsls	r0, r3, #2
   26878:	f003 f9ac 	bl	29bd4 <mpool_calloc>
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   2687c:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   2687e:	62a8      	str	r0, [r5, #40]	; 0x28
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   26880:	4631      	mov	r1, r6
   26882:	0098      	lsls	r0, r3, #2
   26884:	f003 f9a6 	bl	29bd4 <mpool_calloc>
    for (int i = 0; i < r->numVoices; ++i)
   26888:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   2688a:	6168      	str	r0, [r5, #20]
    for (int i = 0; i < r->numVoices; ++i)
   2688c:	2b00      	cmp	r3, #0
   2688e:	dd0c      	ble.n	268aa <tRetune_initToPool+0xca>
   26890:	2400      	movs	r4, #0
        r->outBuffers[i] = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   26892:	69e8      	ldr	r0, [r5, #28]
   26894:	4631      	mov	r1, r6
   26896:	692f      	ldr	r7, [r5, #16]
   26898:	0080      	lsls	r0, r0, #2
   2689a:	f003 f99b 	bl	29bd4 <mpool_calloc>
   2689e:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   268a2:	3401      	adds	r4, #1
   268a4:	6bab      	ldr	r3, [r5, #56]	; 0x38
   268a6:	42a3      	cmp	r3, r4
   268a8:	dcf3      	bgt.n	26892 <tRetune_initToPool+0xb2>
    tPeriodDetection_initToPool(&r->pd, r->inBuffer, r->outBuffers[0], r->bufSize, r->frameSize, mp);
   268aa:	692a      	ldr	r2, [r5, #16]
   268ac:	1d28      	adds	r0, r5, #4
   268ae:	69eb      	ldr	r3, [r5, #28]
   268b0:	6812      	ldr	r2, [r2, #0]
   268b2:	68e9      	ldr	r1, [r5, #12]
   268b4:	f8cd 8004 	str.w	r8, [sp, #4]
   268b8:	69ac      	ldr	r4, [r5, #24]
   268ba:	9003      	str	r0, [sp, #12]
   268bc:	9400      	str	r4, [sp, #0]
   268be:	f7fe f8e1 	bl	24a84 <tPeriodDetection_initToPool>
    for (int i = 0; i < r->numVoices; ++i)
   268c2:	6bab      	ldr	r3, [r5, #56]	; 0x38
   268c4:	2b00      	cmp	r3, #0
   268c6:	dd56      	ble.n	26976 <tRetune_initToPool+0x196>
   268c8:	2700      	movs	r7, #0
    w->period = INITPERIOD;
   268ca:	ed9f 8a2f 	vldr	s16, [pc, #188]	; 26988 <tRetune_initToPool+0x1a8>
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   268ce:	eddf 8a2f 	vldr	s17, [pc, #188]	; 2698c <tRetune_initToPool+0x1ac>
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   268d2:	692b      	ldr	r3, [r5, #16]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   268d4:	2038      	movs	r0, #56	; 0x38
    _tMempool* m = *mp;
   268d6:	f8d8 a000 	ldr.w	sl, [r8]
    ps->pitchFactor = 1.0f;
   268da:	f04f 5b7e 	mov.w	fp, #1065353216	; 0x3f800000
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   268de:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   268e2:	4651      	mov	r1, sl
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   268e4:	69ee      	ldr	r6, [r5, #28]
   268e6:	f8d5 9008 	ldr.w	r9, [r5, #8]
   268ea:	9302      	str	r3, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   268ec:	f003 f972 	bl	29bd4 <mpool_calloc>
    ps->outBuffer = out;
   268f0:	9902      	ldr	r1, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   268f2:	4604      	mov	r4, r0
    ps->curBlock = 1;
   268f4:	f04f 0c01 	mov.w	ip, #1
    ps->lastBlock = 0;
   268f8:	2200      	movs	r2, #0
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   268fa:	f849 4027 	str.w	r4, [r9, r7, lsl #2]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   268fe:	2024      	movs	r0, #36	; 0x24
    ps->mempool = m;
   26900:	f8c4 a000 	str.w	sl, [r4]
    for (int i = 0; i < r->numVoices; ++i)
   26904:	4467      	add	r7, ip
    _tPeriodDetection* p = *pd;
   26906:	686b      	ldr	r3, [r5, #4]
    ps->outBuffer = out;
   26908:	6121      	str	r1, [r4, #16]
    ps->p = pd;
   2690a:	9903      	ldr	r1, [sp, #12]
    ps->bufSize = bufSize;
   2690c:	61a6      	str	r6, [r4, #24]
    ps->p = pd;
   2690e:	60e1      	str	r1, [r4, #12]
    ps->frameSize = p->frameSize;
   26910:	695b      	ldr	r3, [r3, #20]
    ps->curBlock = 1;
   26912:	f8c4 c020 	str.w	ip, [r4, #32]
    ps->frameSize = p->frameSize;
   26916:	6163      	str	r3, [r4, #20]
    ps->pitchFactor = 1.0f;
   26918:	f8c4 b02c 	str.w	fp, [r4, #44]	; 0x2c
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   2691c:	fb96 f6f3 	sdiv	r6, r6, r3
    ps->index = 0;
   26920:	e9c4 2209 	strd	r2, r2, [r4, #36]	; 0x24
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   26924:	61e6      	str	r6, [r4, #28]
    _tMempool* m = *mp;
   26926:	f8d8 a000 	ldr.w	sl, [r8]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   2692a:	4651      	mov	r1, sl
   2692c:	f003 f952 	bl	29bd4 <mpool_calloc>
   26930:	4606      	mov	r6, r0
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26932:	4651      	mov	r1, sl
   26934:	f244 0040 	movw	r0, #16448	; 0x4040
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   26938:	6066      	str	r6, [r4, #4]
    w->mempool = m;
   2693a:	f8c6 a000 	str.w	sl, [r6]
    w->pitchfactor = 1.;
   2693e:	f8c6 b008 	str.w	fp, [r6, #8]
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26942:	f003 f947 	bl	29bd4 <mpool_calloc>
    w->xfadevalue = -1;
   26946:	4a12      	ldr	r2, [pc, #72]	; (26990 <tRetune_initToPool+0x1b0>)
    w->timeindex = 0;
   26948:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   2694c:	6230      	str	r0, [r6, #32]
    w->xfadevalue = -1;
   2694e:	61f2      	str	r2, [r6, #28]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26950:	f104 0008 	add.w	r0, r4, #8
    w->timeindex = 0;
   26954:	6073      	str	r3, [r6, #4]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26956:	4641      	mov	r1, r8
    w->period = INITPERIOD;
   26958:	ed86 8a04 	vstr	s16, [r6, #16]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   2695c:	eeb0 0a68 	vmov.f32	s0, s17
    w->readlag = INITPERIOD;
   26960:	ed86 8a03 	vstr	s16, [r6, #12]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26964:	f001 fd5a 	bl	2841c <tHighpass_initToPool>
    _tSOLAD* w = *wp;
   26968:	6863      	ldr	r3, [r4, #4]
    w->pitchfactor = pitchfactor;
   2696a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   2696e:	609a      	str	r2, [r3, #8]
    for (int i = 0; i < r->numVoices; ++i)
   26970:	6bab      	ldr	r3, [r5, #56]	; 0x38
   26972:	42bb      	cmp	r3, r7
   26974:	dcad      	bgt.n	268d2 <tRetune_initToPool+0xf2>
}
   26976:	b005      	add	sp, #20
   26978:	ecbd 8b02 	vpop	{d8}
   2697c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   26980:	020fbd68 	.word	0x020fbd68
   26984:	42c80000 	.word	0x42c80000
   26988:	42800000 	.word	0x42800000
   2698c:	42200000 	.word	0x42200000
   26990:	bf800000 	.word	0xbf800000

00026994 <tRetune_init>:
{
   26994:	b510      	push	{r4, lr}
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   26996:	4c03      	ldr	r4, [pc, #12]	; (269a4 <tRetune_init+0x10>)
{
   26998:	b082      	sub	sp, #8
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   2699a:	9400      	str	r4, [sp, #0]
   2699c:	f7ff ff20 	bl	267e0 <tRetune_initToPool>
}
   269a0:	b002      	add	sp, #8
   269a2:	bd10      	pop	{r4, pc}
   269a4:	020fbd80 	.word	0x020fbd80

000269a8 <tRetune_free>:
{
   269a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tRetune* r = *rt;
   269aa:	6804      	ldr	r4, [r0, #0]
    tPeriodDetection_free(&r->pd);
   269ac:	1d20      	adds	r0, r4, #4
   269ae:	f7fe f8c7 	bl	24b40 <tPeriodDetection_free>
    for (int i = 0; i < r->numVoices; ++i)
   269b2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   269b4:	2b00      	cmp	r3, #0
   269b6:	dd1e      	ble.n	269f6 <tRetune_free+0x4e>
   269b8:	2500      	movs	r5, #0
    _tPitchShift* ps = *psr;
   269ba:	68a3      	ldr	r3, [r4, #8]
   269bc:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    _tSOLAD* w = *wp;
   269c0:	6877      	ldr	r7, [r6, #4]
    mpool_free((char*)w->delaybuf, w->mempool);
   269c2:	6839      	ldr	r1, [r7, #0]
   269c4:	6a38      	ldr	r0, [r7, #32]
   269c6:	f003 f957 	bl	29c78 <mpool_free>
    mpool_free((char*)w, w->mempool);
   269ca:	6839      	ldr	r1, [r7, #0]
   269cc:	4638      	mov	r0, r7
   269ce:	f003 f953 	bl	29c78 <mpool_free>
    tHighpass_free(&ps->hp);
   269d2:	f106 0008 	add.w	r0, r6, #8
   269d6:	f001 fd41 	bl	2845c <tHighpass_free>
    mpool_free((char*)ps, ps->mempool);
   269da:	6831      	ldr	r1, [r6, #0]
   269dc:	4630      	mov	r0, r6
   269de:	f003 f94b 	bl	29c78 <mpool_free>
        mpool_free((char*)r->outBuffers[i], r->mempool);
   269e2:	6923      	ldr	r3, [r4, #16]
   269e4:	6821      	ldr	r1, [r4, #0]
   269e6:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   269ea:	3501      	adds	r5, #1
        mpool_free((char*)r->outBuffers[i], r->mempool);
   269ec:	f003 f944 	bl	29c78 <mpool_free>
    for (int i = 0; i < r->numVoices; ++i)
   269f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   269f2:	42ab      	cmp	r3, r5
   269f4:	dce1      	bgt.n	269ba <tRetune_free+0x12>
    mpool_free((char*)r->tickOutput, r->mempool);
   269f6:	6821      	ldr	r1, [r4, #0]
   269f8:	6960      	ldr	r0, [r4, #20]
   269fa:	f003 f93d 	bl	29c78 <mpool_free>
    mpool_free((char*)r->pitchFactor, r->mempool);
   269fe:	6821      	ldr	r1, [r4, #0]
   26a00:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   26a02:	f003 f939 	bl	29c78 <mpool_free>
    mpool_free((char*)r->ps, r->mempool);
   26a06:	6821      	ldr	r1, [r4, #0]
   26a08:	68a0      	ldr	r0, [r4, #8]
   26a0a:	f003 f935 	bl	29c78 <mpool_free>
    mpool_free((char*)r->inBuffer, r->mempool);
   26a0e:	6821      	ldr	r1, [r4, #0]
   26a10:	68e0      	ldr	r0, [r4, #12]
   26a12:	f003 f931 	bl	29c78 <mpool_free>
    mpool_free((char*)r->outBuffers, r->mempool);
   26a16:	6821      	ldr	r1, [r4, #0]
   26a18:	6920      	ldr	r0, [r4, #16]
   26a1a:	f003 f92d 	bl	29c78 <mpool_free>
    mpool_free((char*)r, r->mempool);
   26a1e:	6821      	ldr	r1, [r4, #0]
   26a20:	4620      	mov	r0, r4
}
   26a22:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
   26a26:	f003 b927 	b.w	29c78 <mpool_free>
   26a2a:	bf00      	nop

00026a2c <tRetune_tick>:
{
   26a2c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   26a30:	ed2d 8b04 	vpush	{d8-d9}
    _tRetune* r = *rt;
   26a34:	6807      	ldr	r7, [r0, #0]
{
   26a36:	b083      	sub	sp, #12
    r->inputPeriod = tPeriodDetection_tick(&r->pd, sample);
   26a38:	1d38      	adds	r0, r7, #4
   26a3a:	f7fe f8a3 	bl	24b84 <tPeriodDetection_tick>
    for (int v = 0; v < r->numVoices; ++v)
   26a3e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    r->inputPeriod = tPeriodDetection_tick(&r->pd, sample);
   26a40:	ed87 0a0d 	vstr	s0, [r7, #52]	; 0x34
    for (int v = 0; v < r->numVoices; ++v)
   26a44:	2b00      	cmp	r3, #0
   26a46:	f340 8083 	ble.w	26b50 <tRetune_tick+0x124>
   26a4a:	2500      	movs	r5, #0
    if(period > MAXPERIOD) period = MAXPERIOD;
   26a4c:	ed9f 9a5f 	vldr	s18, [pc, #380]	; 26bcc <tRetune_tick+0x1a0>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   26a50:	eddf 9a5f 	vldr	s19, [pc, #380]	; 26bd0 <tRetune_tick+0x1a4>
   26a54:	e005      	b.n	26a62 <tRetune_tick+0x36>
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   26a56:	ed86 8a00 	vstr	s16, [r6]
    for (int v = 0; v < r->numVoices; ++v)
   26a5a:	3501      	adds	r5, #1
   26a5c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26a5e:	42ab      	cmp	r3, r5
   26a60:	dd76      	ble.n	26b50 <tRetune_tick+0x124>
    _tPitchShift* ps = *psr;
   26a62:	68bb      	ldr	r3, [r7, #8]
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   26a64:	697e      	ldr	r6, [r7, #20]
    _tPitchShift* ps = *psr;
   26a66:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   26a6a:	eb06 0685 	add.w	r6, r6, r5, lsl #2
    _tPeriodDetection* p = *ps->p;
   26a6e:	68e2      	ldr	r2, [r4, #12]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26a70:	f104 0008 	add.w	r0, r4, #8
   26a74:	6923      	ldr	r3, [r4, #16]
    _tPeriodDetection* p = *ps->p;
   26a76:	6812      	ldr	r2, [r2, #0]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26a78:	6b11      	ldr	r1, [r2, #48]	; 0x30
    _tPeriodDetection* p = *ps->p;
   26a7a:	9201      	str	r2, [sp, #4]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26a7c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    i = p->i;
   26a80:	f8d2 8028 	ldr.w	r8, [r2, #40]	; 0x28
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26a84:	ed93 0a00 	vldr	s0, [r3]
   26a88:	f001 fcfc 	bl	28484 <tHighpass_tick>
    if (p->indexstore >= ps->frameSize)
   26a8c:	9a01      	ldr	r2, [sp, #4]
   26a8e:	6963      	ldr	r3, [r4, #20]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26a90:	eeb0 8a40 	vmov.f32	s16, s0
    if (p->indexstore >= ps->frameSize)
   26a94:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   26a96:	429a      	cmp	r2, r3
   26a98:	dbdd      	blt.n	26a56 <tRetune_tick+0x2a>
        period = tPeriodDetection_getPeriod(&p);
   26a9a:	a801      	add	r0, sp, #4
   26a9c:	f7fe f900 	bl	24ca0 <tPeriodDetection_getPeriod>
    _tPeriodDetection* p = *ps->p;
   26aa0:	68e3      	ldr	r3, [r4, #12]
        period = tPeriodDetection_getPeriod(&p);
   26aa2:	eef0 8a40 	vmov.f32	s17, s0
    _tPeriodDetection* p = *ps->p;
   26aa6:	f8d3 9000 	ldr.w	r9, [r3]
    envout = tEnvPD_tick(&p->env);
   26aaa:	f109 0004 	add.w	r0, r9, #4
   26aae:	f7fd fced 	bl	2448c <tEnvPD_tick>
    if (envout >= 1.0f)
   26ab2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   26ab6:	eeb4 0ae7 	vcmpe.f32	s0, s15
   26aba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26abe:	db0e      	blt.n	26ade <tRetune_tick+0xb2>
        p->lastmax = p->max;
   26ac0:	edd9 7a13 	vldr	s15, [r9, #76]	; 0x4c
        if (envout > p->max)
   26ac4:	eeb4 0ae7 	vcmpe.f32	s0, s15
        p->lastmax = p->max;
   26ac8:	edc9 7a14 	vstr	s15, [r9, #80]	; 0x50
   26acc:	ee30 7a67 	vsub.f32	s14, s0, s15
        if (envout > p->max)
   26ad0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26ad4:	dd6e      	ble.n	26bb4 <tRetune_tick+0x188>
            p->max = envout;
   26ad6:	ed89 0a13 	vstr	s0, [r9, #76]	; 0x4c
        p->deltamax = p->max - p->lastmax;
   26ada:	ed89 7a15 	vstr	s14, [r9, #84]	; 0x54
    p->fba = p->fba ? (p->fba - 1) : 0;
   26ade:	f899 3040 	ldrb.w	r3, [r9, #64]	; 0x40
   26ae2:	9901      	ldr	r1, [sp, #4]
   26ae4:	2b00      	cmp	r3, #0
   26ae6:	d039      	beq.n	26b5c <tRetune_tick+0x130>
   26ae8:	3b01      	subs	r3, #1
   26aea:	b2db      	uxtb	r3, r3
   26aec:	f889 3040 	strb.w	r3, [r9, #64]	; 0x40
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   26af0:	b3a3      	cbz	r3, 26b5c <tRetune_tick+0x130>
   26af2:	6862      	ldr	r2, [r4, #4]
    if(period > MAXPERIOD) period = MAXPERIOD;
   26af4:	88d3      	ldrh	r3, [r2, #6]
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   26af6:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    if(period > MAXPERIOD) period = MAXPERIOD;
   26afa:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
   26afe:	ee00 3a10 	vmov	s0, r3
   26b02:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   26b06:	ee20 0a09 	vmul.f32	s0, s0, s18
   26b0a:	fe80 0a68 	vminnm.f32	s0, s0, s17
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   26b0e:	eeb4 0ae7 	vcmpe.f32	s0, s15
   26b12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26b16:	dd02      	ble.n	26b1e <tRetune_tick+0xf2>
   26b18:	ed82 0a04 	vstr	s0, [r2, #16]
   26b1c:	6862      	ldr	r2, [r4, #4]
        tSOLAD_setPitchFactor(&ps->sola, ps->pitchFactor);
   26b1e:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   26b22:	ea4f 0888 	mov.w	r8, r8, lsl #2
   26b26:	1d20      	adds	r0, r4, #4
    for (int v = 0; v < r->numVoices; ++v)
   26b28:	3501      	adds	r5, #1
    if (pitchfactor <= 0.0f) return;
   26b2a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   26b2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    w->pitchfactor = pitchfactor;
   26b32:	bf88      	it	hi
   26b34:	edc2 7a02 	vstrhi	s15, [r2, #8]
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   26b38:	68c9      	ldr	r1, [r1, #12]
   26b3a:	6922      	ldr	r2, [r4, #16]
   26b3c:	6963      	ldr	r3, [r4, #20]
   26b3e:	4441      	add	r1, r8
   26b40:	4442      	add	r2, r8
   26b42:	f7ff fccf 	bl	264e4 <tSOLAD_ioSamples>
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   26b46:	ed86 8a00 	vstr	s16, [r6]
    for (int v = 0; v < r->numVoices; ++v)
   26b4a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26b4c:	42ab      	cmp	r3, r5
   26b4e:	dc88      	bgt.n	26a62 <tRetune_tick+0x36>
}
   26b50:	6978      	ldr	r0, [r7, #20]
   26b52:	b003      	add	sp, #12
   26b54:	ecbd 8b04 	vpop	{d8-d9}
   26b58:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   26b5c:	edd9 7a13 	vldr	s15, [r9, #76]	; 0x4c
   26b60:	eef4 7ae9 	vcmpe.f32	s15, s19
   26b64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26b68:	ddc3      	ble.n	26af2 <tRetune_tick+0xc6>
   26b6a:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
   26b6e:	ed99 7a15 	vldr	s14, [r9, #84]	; 0x54
   26b72:	eeb4 7ae7 	vcmpe.f32	s14, s15
   26b76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26b7a:	ddba      	ble.n	26af2 <tRetune_tick+0xc6>
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   26b7c:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
            p->fba = 5;
   26b7e:	2305      	movs	r3, #5
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   26b80:	ee07 2a90 	vmov	s15, r2
            p->fba = 5;
   26b84:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
    _tSOLAD* w = *wp;
   26b88:	6862      	ldr	r2, [r4, #4]
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   26b8a:	eef8 7a67 	vcvt.f32.u32	s15, s15
    if(readlag < w->readlag)               // do not jump backward, only forward
   26b8e:	ed92 7a03 	vldr	s14, [r2, #12]
   26b92:	eef4 7ac7 	vcmpe.f32	s15, s14
   26b96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26b9a:	d5ab      	bpl.n	26af4 <tRetune_tick+0xc8>
        w->jump = w->readlag - readlag;
   26b9c:	ee37 7a67 	vsub.f32	s14, s14, s15
        w->xfadevalue = 1;
   26ba0:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
        w->readlag = readlag;
   26ba4:	edc2 7a03 	vstr	s15, [r2, #12]
        w->xfadelength = readlag;
   26ba8:	edc2 7a06 	vstr	s15, [r2, #24]
        w->jump = w->readlag - readlag;
   26bac:	ed82 7a05 	vstr	s14, [r2, #20]
        w->xfadevalue = 1;
   26bb0:	61d3      	str	r3, [r2, #28]
   26bb2:	e79e      	b.n	26af2 <tRetune_tick+0xc6>
            p->deltamax = envout - p->max;
   26bb4:	ed89 7a15 	vstr	s14, [r9, #84]	; 0x54
            p->max = p->max * ps->radius;
   26bb8:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
   26bbc:	ee67 6aa6 	vmul.f32	s13, s15, s13
   26bc0:	ee36 7ae7 	vsub.f32	s14, s13, s15
   26bc4:	edc9 6a13 	vstr	s13, [r9, #76]	; 0x4c
   26bc8:	e787      	b.n	26ada <tRetune_tick+0xae>
   26bca:	bf00      	nop
   26bcc:	3f4ccccd 	.word	0x3f4ccccd
   26bd0:	42700000 	.word	0x42700000

00026bd4 <tRetune_setPitchFactor>:
{
   26bd4:	b410      	push	{r4}
    _tRetune* r = *rt;
   26bd6:	6802      	ldr	r2, [r0, #0]
    r->pitchFactor[voice] = pf;
   26bd8:	008c      	lsls	r4, r1, #2
   26bda:	6a90      	ldr	r0, [r2, #40]	; 0x28
   26bdc:	4420      	add	r0, r4
   26bde:	ed80 0a00 	vstr	s0, [r0]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
   26be2:	6a93      	ldr	r3, [r2, #40]	; 0x28
    _tPitchShift* ps = *psr;
   26be4:	6892      	ldr	r2, [r2, #8]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
   26be6:	4423      	add	r3, r4
    _tPitchShift* ps = *psr;
   26be8:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
   26bec:	681b      	ldr	r3, [r3, #0]
    ps->pitchFactor = pf;
   26bee:	62d3      	str	r3, [r2, #44]	; 0x2c
}
   26bf0:	f85d 4b04 	ldr.w	r4, [sp], #4
   26bf4:	4770      	bx	lr
   26bf6:	bf00      	nop

00026bf8 <tRetune_setFidelityThreshold>:

void tRetune_setFidelityThreshold(tRetune* const rt, float threshold)
{
    _tRetune* r = *rt;
    
    tPeriodDetection_setFidelityThreshold(&r->pd, threshold);
   26bf8:	6800      	ldr	r0, [r0, #0]
   26bfa:	3004      	adds	r0, #4
   26bfc:	f7fe b854 	b.w	24ca8 <tPeriodDetection_setFidelityThreshold>

00026c00 <tRetune_getInputPeriod>:

float tRetune_getInputPeriod(tRetune* const rt)
{
    _tRetune* r = *rt;
    
    return (r->inputPeriod * leaf.invSampleRate);
   26c00:	6802      	ldr	r2, [r0, #0]
   26c02:	4b04      	ldr	r3, [pc, #16]	; (26c14 <tRetune_getInputPeriod+0x14>)
   26c04:	ed92 0a0d 	vldr	s0, [r2, #52]	; 0x34
   26c08:	edd3 7a01 	vldr	s15, [r3, #4]
}
   26c0c:	ee20 0a27 	vmul.f32	s0, s0, s15
   26c10:	4770      	bx	lr
   26c12:	bf00      	nop
   26c14:	020fbd68 	.word	0x020fbd68

00026c18 <tAutotune_initToPool>:
{
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
}

void tAutotune_initToPool (tAutotune* const rt, int numVoices, int bufSize, int frameSize, tMempool* const mp)
{
   26c18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26c1c:	ed2d 8b02 	vpush	{d8}
   26c20:	b085      	sub	sp, #20
   26c22:	4604      	mov	r4, r0
   26c24:	4689      	mov	r9, r1
    _tMempool* m = *mp;
    _tAutotune* r = *rt = (_tAutotune*) mpool_alloc(sizeof(_tAutotune), m);
   26c26:	2040      	movs	r0, #64	; 0x40
{
   26c28:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
   26c2c:	4617      	mov	r7, r2
   26c2e:	469a      	mov	sl, r3
    _tMempool* m = *mp;
   26c30:	f8d8 6000 	ldr.w	r6, [r8]
    _tAutotune* r = *rt = (_tAutotune*) mpool_alloc(sizeof(_tAutotune), m);
   26c34:	4631      	mov	r1, r6
   26c36:	f002 ff77 	bl	29b28 <mpool_alloc>
   26c3a:	4605      	mov	r5, r0
   26c3c:	6020      	str	r0, [r4, #0]
    
    r->bufSize = bufSize;
    r->frameSize = frameSize;
    r->numVoices = numVoices;
    
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   26c3e:	4631      	mov	r1, r6
    r->mempool = *mp;
   26c40:	f8d8 2000 	ldr.w	r2, [r8]
    r->frameSize = frameSize;
   26c44:	f8c0 a018 	str.w	sl, [r0, #24]
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   26c48:	00b8      	lsls	r0, r7, #2
    r->mempool = *mp;
   26c4a:	602a      	str	r2, [r5, #0]
    r->bufSize = bufSize;
   26c4c:	61ef      	str	r7, [r5, #28]
    r->numVoices = numVoices;
   26c4e:	f8c5 903c 	str.w	r9, [r5, #60]	; 0x3c
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   26c52:	f002 ff69 	bl	29b28 <mpool_alloc>
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
   26c56:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   26c58:	4631      	mov	r1, r6
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   26c5a:	60e8      	str	r0, [r5, #12]
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
   26c5c:	0098      	lsls	r0, r3, #2
   26c5e:	f002 ff63 	bl	29b28 <mpool_alloc>
    
    r->hopSize = DEFHOPSIZE;
   26c62:	f04f 1240 	mov.w	r2, #4194368	; 0x400040
    r->windowSize = DEFWINDOWSIZE;
    r->fba = FBA;
   26c66:	2314      	movs	r3, #20
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
   26c68:	6128      	str	r0, [r5, #16]
    r->hopSize = DEFHOPSIZE;
   26c6a:	622a      	str	r2, [r5, #32]
void tAutotune_setTimeConstant(tAutotune* const rt, float tc)
{
    _tAutotune* r = *rt;
    
    r->timeConstant = tc;
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26c6c:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
    r->fba = FBA;
   26c70:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26c74:	4b51      	ldr	r3, [pc, #324]	; (26dbc <tAutotune_initToPool+0x1a4>)
    _tAutotune* r = *rt;
   26c76:	6824      	ldr	r4, [r4, #0]
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26c78:	ed93 0a01 	vldr	s0, [r3, #4]
   26c7c:	8c23      	ldrh	r3, [r4, #32]
   26c7e:	ee20 0a07 	vmul.f32	s0, s0, s14
   26c82:	ee07 3a90 	vmov	s15, r3
    r->timeConstant = tc;
   26c86:	4b4e      	ldr	r3, [pc, #312]	; (26dc0 <tAutotune_initToPool+0x1a8>)
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26c88:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    r->timeConstant = tc;
   26c8c:	62e3      	str	r3, [r4, #44]	; 0x2c
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26c8e:	ee20 0a27 	vmul.f32	s0, s0, s15
   26c92:	f005 ff8f 	bl	2cbb4 <expf>
   26c96:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    r->ps = (tPitchShift*) mpool_alloc(sizeof(tPitchShift) * r->numVoices, m);
   26c9a:	6be8      	ldr	r0, [r5, #60]	; 0x3c
   26c9c:	4631      	mov	r1, r6
   26c9e:	0080      	lsls	r0, r0, #2
   26ca0:	f002 ff42 	bl	29b28 <mpool_alloc>
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26ca4:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->ps = (tPitchShift*) mpool_alloc(sizeof(tPitchShift) * r->numVoices, m);
   26ca6:	60a8      	str	r0, [r5, #8]
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26ca8:	4631      	mov	r1, r6
   26caa:	0098      	lsls	r0, r3, #2
   26cac:	f002 ff3c 	bl	29b28 <mpool_alloc>
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26cb0:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26cb2:	62a8      	str	r0, [r5, #40]	; 0x28
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26cb4:	4631      	mov	r1, r6
   26cb6:	0098      	lsls	r0, r3, #2
   26cb8:	f002 ff36 	bl	29b28 <mpool_alloc>
    for (int i = 0; i < r->numVoices; ++i)
   26cbc:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26cbe:	6168      	str	r0, [r5, #20]
    for (int i = 0; i < r->numVoices; ++i)
   26cc0:	2b00      	cmp	r3, #0
   26cc2:	dd0c      	ble.n	26cde <tAutotune_initToPool+0xc6>
   26cc4:	2400      	movs	r4, #0
        r->outBuffers[i] = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   26cc6:	69e8      	ldr	r0, [r5, #28]
   26cc8:	4631      	mov	r1, r6
   26cca:	692f      	ldr	r7, [r5, #16]
   26ccc:	0080      	lsls	r0, r0, #2
   26cce:	f002 ff2b 	bl	29b28 <mpool_alloc>
   26cd2:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   26cd6:	3401      	adds	r4, #1
   26cd8:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   26cda:	42a3      	cmp	r3, r4
   26cdc:	dcf3      	bgt.n	26cc6 <tAutotune_initToPool+0xae>
    tPeriodDetection_initToPool(&r->pd, r->inBuffer, r->outBuffers[0], r->bufSize, r->frameSize, mp);
   26cde:	692a      	ldr	r2, [r5, #16]
   26ce0:	1d28      	adds	r0, r5, #4
   26ce2:	69eb      	ldr	r3, [r5, #28]
   26ce4:	6812      	ldr	r2, [r2, #0]
   26ce6:	68e9      	ldr	r1, [r5, #12]
   26ce8:	f8cd 8004 	str.w	r8, [sp, #4]
   26cec:	69ac      	ldr	r4, [r5, #24]
   26cee:	9003      	str	r0, [sp, #12]
   26cf0:	9400      	str	r4, [sp, #0]
   26cf2:	f7fd fec7 	bl	24a84 <tPeriodDetection_initToPool>
    for (int i = 0; i < r->numVoices; ++i)
   26cf6:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   26cf8:	2b00      	cmp	r3, #0
   26cfa:	dd56      	ble.n	26daa <tAutotune_initToPool+0x192>
   26cfc:	2700      	movs	r7, #0
    w->period = INITPERIOD;
   26cfe:	ed9f 8a31 	vldr	s16, [pc, #196]	; 26dc4 <tAutotune_initToPool+0x1ac>
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26d02:	eddf 8a31 	vldr	s17, [pc, #196]	; 26dc8 <tAutotune_initToPool+0x1b0>
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   26d06:	692b      	ldr	r3, [r5, #16]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26d08:	2038      	movs	r0, #56	; 0x38
    _tMempool* m = *mp;
   26d0a:	f8d8 a000 	ldr.w	sl, [r8]
    ps->pitchFactor = 1.0f;
   26d0e:	f04f 5b7e 	mov.w	fp, #1065353216	; 0x3f800000
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   26d12:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26d16:	4651      	mov	r1, sl
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   26d18:	69ee      	ldr	r6, [r5, #28]
   26d1a:	f8d5 9008 	ldr.w	r9, [r5, #8]
   26d1e:	9302      	str	r3, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26d20:	f002 ff58 	bl	29bd4 <mpool_calloc>
    ps->outBuffer = out;
   26d24:	9902      	ldr	r1, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26d26:	4604      	mov	r4, r0
    ps->curBlock = 1;
   26d28:	f04f 0c01 	mov.w	ip, #1
    ps->lastBlock = 0;
   26d2c:	2200      	movs	r2, #0
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26d2e:	f849 4027 	str.w	r4, [r9, r7, lsl #2]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   26d32:	2024      	movs	r0, #36	; 0x24
    ps->mempool = m;
   26d34:	f8c4 a000 	str.w	sl, [r4]
    for (int i = 0; i < r->numVoices; ++i)
   26d38:	4467      	add	r7, ip
    _tPeriodDetection* p = *pd;
   26d3a:	686b      	ldr	r3, [r5, #4]
    ps->outBuffer = out;
   26d3c:	6121      	str	r1, [r4, #16]
    ps->p = pd;
   26d3e:	9903      	ldr	r1, [sp, #12]
    ps->bufSize = bufSize;
   26d40:	61a6      	str	r6, [r4, #24]
    ps->p = pd;
   26d42:	60e1      	str	r1, [r4, #12]
    ps->frameSize = p->frameSize;
   26d44:	695b      	ldr	r3, [r3, #20]
    ps->curBlock = 1;
   26d46:	f8c4 c020 	str.w	ip, [r4, #32]
    ps->frameSize = p->frameSize;
   26d4a:	6163      	str	r3, [r4, #20]
    ps->pitchFactor = 1.0f;
   26d4c:	f8c4 b02c 	str.w	fp, [r4, #44]	; 0x2c
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   26d50:	fb96 f6f3 	sdiv	r6, r6, r3
    ps->index = 0;
   26d54:	e9c4 2209 	strd	r2, r2, [r4, #36]	; 0x24
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   26d58:	61e6      	str	r6, [r4, #28]
    _tMempool* m = *mp;
   26d5a:	f8d8 a000 	ldr.w	sl, [r8]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   26d5e:	4651      	mov	r1, sl
   26d60:	f002 ff38 	bl	29bd4 <mpool_calloc>
   26d64:	4606      	mov	r6, r0
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26d66:	4651      	mov	r1, sl
   26d68:	f244 0040 	movw	r0, #16448	; 0x4040
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   26d6c:	6066      	str	r6, [r4, #4]
    w->mempool = m;
   26d6e:	f8c6 a000 	str.w	sl, [r6]
    w->pitchfactor = 1.;
   26d72:	f8c6 b008 	str.w	fp, [r6, #8]
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26d76:	f002 ff2d 	bl	29bd4 <mpool_calloc>
    w->xfadevalue = -1;
   26d7a:	4a14      	ldr	r2, [pc, #80]	; (26dcc <tAutotune_initToPool+0x1b4>)
    w->timeindex = 0;
   26d7c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26d80:	6230      	str	r0, [r6, #32]
    w->xfadevalue = -1;
   26d82:	61f2      	str	r2, [r6, #28]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26d84:	f104 0008 	add.w	r0, r4, #8
    w->timeindex = 0;
   26d88:	6073      	str	r3, [r6, #4]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26d8a:	4641      	mov	r1, r8
    w->period = INITPERIOD;
   26d8c:	ed86 8a04 	vstr	s16, [r6, #16]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26d90:	eeb0 0a68 	vmov.f32	s0, s17
    w->readlag = INITPERIOD;
   26d94:	ed86 8a03 	vstr	s16, [r6, #12]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26d98:	f001 fb40 	bl	2841c <tHighpass_initToPool>
    _tSOLAD* w = *wp;
   26d9c:	6863      	ldr	r3, [r4, #4]
    w->pitchfactor = pitchfactor;
   26d9e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   26da2:	609a      	str	r2, [r3, #8]
    for (int i = 0; i < r->numVoices; ++i)
   26da4:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   26da6:	42bb      	cmp	r3, r7
   26da8:	dcad      	bgt.n	26d06 <tAutotune_initToPool+0xee>
    r->inputPeriod = 0.0f;
   26daa:	2200      	movs	r2, #0
    r->shiftOn = 0;
   26dac:	2300      	movs	r3, #0
    r->inputPeriod = 0.0f;
   26dae:	636a      	str	r2, [r5, #52]	; 0x34
    r->shiftOn = 0;
   26db0:	63ab      	str	r3, [r5, #56]	; 0x38
}
   26db2:	b005      	add	sp, #20
   26db4:	ecbd 8b02 	vpop	{d8}
   26db8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   26dbc:	020fbd68 	.word	0x020fbd68
   26dc0:	42c80000 	.word	0x42c80000
   26dc4:	42800000 	.word	0x42800000
   26dc8:	42200000 	.word	0x42200000
   26dcc:	bf800000 	.word	0xbf800000

00026dd0 <tAutotune_init>:
{
   26dd0:	b510      	push	{r4, lr}
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   26dd2:	4c03      	ldr	r4, [pc, #12]	; (26de0 <tAutotune_init+0x10>)
{
   26dd4:	b082      	sub	sp, #8
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   26dd6:	9400      	str	r4, [sp, #0]
   26dd8:	f7ff ff1e 	bl	26c18 <tAutotune_initToPool>
}
   26ddc:	b002      	add	sp, #8
   26dde:	bd10      	pop	{r4, pc}
   26de0:	020fbd80 	.word	0x020fbd80

00026de4 <tAutotune_free>:
{
   26de4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tAutotune* r = *rt;
   26de6:	6804      	ldr	r4, [r0, #0]
    tPeriodDetection_free(&r->pd);
   26de8:	1d20      	adds	r0, r4, #4
   26dea:	f7fd fea9 	bl	24b40 <tPeriodDetection_free>
    for (int i = 0; i < r->numVoices; ++i)
   26dee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   26df0:	2b00      	cmp	r3, #0
   26df2:	dd1e      	ble.n	26e32 <tAutotune_free+0x4e>
   26df4:	2500      	movs	r5, #0
    _tPitchShift* ps = *psr;
   26df6:	68a3      	ldr	r3, [r4, #8]
   26df8:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    _tSOLAD* w = *wp;
   26dfc:	6877      	ldr	r7, [r6, #4]
    mpool_free((char*)w->delaybuf, w->mempool);
   26dfe:	6839      	ldr	r1, [r7, #0]
   26e00:	6a38      	ldr	r0, [r7, #32]
   26e02:	f002 ff39 	bl	29c78 <mpool_free>
    mpool_free((char*)w, w->mempool);
   26e06:	6839      	ldr	r1, [r7, #0]
   26e08:	4638      	mov	r0, r7
   26e0a:	f002 ff35 	bl	29c78 <mpool_free>
    tHighpass_free(&ps->hp);
   26e0e:	f106 0008 	add.w	r0, r6, #8
   26e12:	f001 fb23 	bl	2845c <tHighpass_free>
    mpool_free((char*)ps, ps->mempool);
   26e16:	6831      	ldr	r1, [r6, #0]
   26e18:	4630      	mov	r0, r6
   26e1a:	f002 ff2d 	bl	29c78 <mpool_free>
        mpool_free((char*)r->outBuffers[i], r->mempool);
   26e1e:	6923      	ldr	r3, [r4, #16]
   26e20:	6821      	ldr	r1, [r4, #0]
   26e22:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   26e26:	3501      	adds	r5, #1
        mpool_free((char*)r->outBuffers[i], r->mempool);
   26e28:	f002 ff26 	bl	29c78 <mpool_free>
    for (int i = 0; i < r->numVoices; ++i)
   26e2c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   26e2e:	42ab      	cmp	r3, r5
   26e30:	dce1      	bgt.n	26df6 <tAutotune_free+0x12>
    mpool_free((char*)r->tickOutput, r->mempool);
   26e32:	6821      	ldr	r1, [r4, #0]
   26e34:	6960      	ldr	r0, [r4, #20]
   26e36:	f002 ff1f 	bl	29c78 <mpool_free>
    mpool_free((char*)r->freq, r->mempool);
   26e3a:	6821      	ldr	r1, [r4, #0]
   26e3c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   26e3e:	f002 ff1b 	bl	29c78 <mpool_free>
    mpool_free((char*)r->ps, r->mempool);
   26e42:	6821      	ldr	r1, [r4, #0]
   26e44:	68a0      	ldr	r0, [r4, #8]
   26e46:	f002 ff17 	bl	29c78 <mpool_free>
    mpool_free((char*)r->inBuffer, r->mempool);
   26e4a:	6821      	ldr	r1, [r4, #0]
   26e4c:	68e0      	ldr	r0, [r4, #12]
   26e4e:	f002 ff13 	bl	29c78 <mpool_free>
    mpool_free((char*)r->outBuffers, r->mempool);
   26e52:	6821      	ldr	r1, [r4, #0]
   26e54:	6920      	ldr	r0, [r4, #16]
   26e56:	f002 ff0f 	bl	29c78 <mpool_free>
    mpool_free((char*)r, r->mempool);
   26e5a:	6821      	ldr	r1, [r4, #0]
   26e5c:	4620      	mov	r0, r4
}
   26e5e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
   26e62:	f002 bf09 	b.w	29c78 <mpool_free>
   26e66:	bf00      	nop

00026e68 <tAutotune_tick>:
{
   26e68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   26e6c:	ed2d 8b06 	vpush	{d8-d10}
    _tAutotune* r = *rt;
   26e70:	6806      	ldr	r6, [r0, #0]
{
   26e72:	b082      	sub	sp, #8
    float tempPeriod = tPeriodDetection_tick(&r->pd, sample);
   26e74:	1d30      	adds	r0, r6, #4
   26e76:	f7fd fe85 	bl	24b84 <tPeriodDetection_tick>
    if (tempPeriod < 1000.0f) //to avoid trying to follow consonants JS
   26e7a:	eddf 7a75 	vldr	s15, [pc, #468]	; 27050 <tAutotune_tick+0x1e8>
   26e7e:	eeb4 0ae7 	vcmpe.f32	s0, s15
   26e82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26e86:	d501      	bpl.n	26e8c <tAutotune_tick+0x24>
		r->inputPeriod = tempPeriod;
   26e88:	ed86 0a0d 	vstr	s0, [r6, #52]	; 0x34
	for (int v = 0; v < r->numVoices; ++v)
   26e8c:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   26e8e:	2b00      	cmp	r3, #0
   26e90:	f340 8097 	ble.w	26fc2 <tAutotune_tick+0x15a>
   26e94:	2500      	movs	r5, #0
    if(period > MAXPERIOD) period = MAXPERIOD;
   26e96:	eddf 9a6f 	vldr	s19, [pc, #444]	; 27054 <tAutotune_tick+0x1ec>
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
   26e9a:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 2705c <tAutotune_tick+0x1f4>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   26e9e:	ed9f aa6e 	vldr	s20, [pc, #440]	; 27058 <tAutotune_tick+0x1f0>
   26ea2:	e006      	b.n	26eb2 <tAutotune_tick+0x4a>
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   26ea4:	edc7 8a00 	vstr	s17, [r7]
	for (int v = 0; v < r->numVoices; ++v)
   26ea8:	3501      	adds	r5, #1
   26eaa:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   26eac:	42ab      	cmp	r3, r5
   26eae:	f340 8088 	ble.w	26fc2 <tAutotune_tick+0x15a>
    _tPitchShift* ps = *psr;
   26eb2:	68b1      	ldr	r1, [r6, #8]
   26eb4:	00ab      	lsls	r3, r5, #2
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   26eb6:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    _tPitchShift* ps = *psr;
   26eb8:	f851 4025 	ldr.w	r4, [r1, r5, lsl #2]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   26ebc:	6977      	ldr	r7, [r6, #20]
   26ebe:	eb02 0c03 	add.w	ip, r2, r3
    _tPeriodDetection* p = *ps->p;
   26ec2:	68e1      	ldr	r1, [r4, #12]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26ec4:	f104 0008 	add.w	r0, r4, #8
   26ec8:	6922      	ldr	r2, [r4, #16]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   26eca:	441f      	add	r7, r3
    _tPeriodDetection* p = *ps->p;
   26ecc:	6809      	ldr	r1, [r1, #0]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   26ece:	ed9c 8a00 	vldr	s16, [ip]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26ed2:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    _tPeriodDetection* p = *ps->p;
   26ed4:	9101      	str	r1, [sp, #4]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26ed6:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    i = p->i;
   26eda:	f8d1 9028 	ldr.w	r9, [r1, #40]	; 0x28
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26ede:	ed92 0a00 	vldr	s0, [r2]
   26ee2:	f001 facf 	bl	28484 <tHighpass_tick>
    if (p->indexstore >= ps->frameSize)
   26ee6:	9a01      	ldr	r2, [sp, #4]
   26ee8:	6963      	ldr	r3, [r4, #20]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26eea:	eef0 8a40 	vmov.f32	s17, s0
    if (p->indexstore >= ps->frameSize)
   26eee:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   26ef0:	429a      	cmp	r2, r3
   26ef2:	dbd7      	blt.n	26ea4 <tAutotune_tick+0x3c>
        period = tPeriodDetection_getPeriod(&p);
   26ef4:	a801      	add	r0, sp, #4
   26ef6:	f7fd fed3 	bl	24ca0 <tPeriodDetection_getPeriod>
    _tPeriodDetection* p = *ps->p;
   26efa:	68e3      	ldr	r3, [r4, #12]
        period = tPeriodDetection_getPeriod(&p);
   26efc:	eeb0 9a40 	vmov.f32	s18, s0
    _tPeriodDetection* p = *ps->p;
   26f00:	f8d3 a000 	ldr.w	sl, [r3]
    envout = tEnvPD_tick(&p->env);
   26f04:	f10a 0004 	add.w	r0, sl, #4
   26f08:	f7fd fac0 	bl	2448c <tEnvPD_tick>
    if (envout >= 1.0f)
   26f0c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   26f10:	eeb4 0ae7 	vcmpe.f32	s0, s15
   26f14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26f18:	db0f      	blt.n	26f3a <tAutotune_tick+0xd2>
        p->lastmax = p->max;
   26f1a:	edda 7a13 	vldr	s15, [sl, #76]	; 0x4c
        if (envout > p->max)
   26f1e:	eeb4 0ae7 	vcmpe.f32	s0, s15
        p->lastmax = p->max;
   26f22:	edca 7a14 	vstr	s15, [sl, #80]	; 0x50
   26f26:	ee30 7a67 	vsub.f32	s14, s0, s15
        if (envout > p->max)
   26f2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26f2e:	f340 8083 	ble.w	27038 <tAutotune_tick+0x1d0>
            p->max = envout;
   26f32:	ed8a 0a13 	vstr	s0, [sl, #76]	; 0x4c
        p->deltamax = p->max - p->lastmax;
   26f36:	ed8a 7a15 	vstr	s14, [sl, #84]	; 0x54
    p->fba = p->fba ? (p->fba - 1) : 0;
   26f3a:	f89a 3040 	ldrb.w	r3, [sl, #64]	; 0x40
   26f3e:	2b00      	cmp	r3, #0
   26f40:	d04c      	beq.n	26fdc <tAutotune_tick+0x174>
   26f42:	3b01      	subs	r3, #1
   26f44:	b2db      	uxtb	r3, r3
   26f46:	f88a 3040 	strb.w	r3, [sl, #64]	; 0x40
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   26f4a:	2b00      	cmp	r3, #0
   26f4c:	d046      	beq.n	26fdc <tAutotune_tick+0x174>
   26f4e:	6862      	ldr	r2, [r4, #4]
   26f50:	9901      	ldr	r1, [sp, #4]
    if(period > MAXPERIOD) period = MAXPERIOD;
   26f52:	88d3      	ldrh	r3, [r2, #6]
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   26f54:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
    if(period > MAXPERIOD) period = MAXPERIOD;
   26f58:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
   26f5c:	ee07 3a90 	vmov	s15, r3
   26f60:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   26f64:	ee67 7aa9 	vmul.f32	s15, s15, s19
   26f68:	fec7 7ac9 	vminnm.f32	s15, s15, s18
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   26f6c:	eef4 7ac7 	vcmpe.f32	s15, s14
   26f70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26f74:	dd02      	ble.n	26f7c <tAutotune_tick+0x114>
   26f76:	edc2 7a04 	vstr	s15, [r2, #16]
   26f7a:	6862      	ldr	r2, [r4, #4]
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
   26f7c:	eeb5 9a40 	vcmp.f32	s18, #0.0
   26f80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26f84:	d023      	beq.n	26fce <tAutotune_tick+0x166>
   26f86:	edd8 7a01 	vldr	s15, [r8, #4]
   26f8a:	ee28 8a27 	vmul.f32	s16, s16, s15
   26f8e:	ee28 8a09 	vmul.f32	s16, s16, s18
    if (pitchfactor <= 0.0f) return;
   26f92:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   26f96:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
   26f9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26f9e:	d81a      	bhi.n	26fd6 <tAutotune_tick+0x16e>
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   26fa0:	ea4f 0989 	mov.w	r9, r9, lsl #2
   26fa4:	68c9      	ldr	r1, [r1, #12]
   26fa6:	6922      	ldr	r2, [r4, #16]
   26fa8:	1d20      	adds	r0, r4, #4
   26faa:	6963      	ldr	r3, [r4, #20]
   26fac:	4449      	add	r1, r9
   26fae:	444a      	add	r2, r9
	for (int v = 0; v < r->numVoices; ++v)
   26fb0:	3501      	adds	r5, #1
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   26fb2:	f7ff fa97 	bl	264e4 <tSOLAD_ioSamples>
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   26fb6:	edc7 8a00 	vstr	s17, [r7]
	for (int v = 0; v < r->numVoices; ++v)
   26fba:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   26fbc:	42ab      	cmp	r3, r5
   26fbe:	f73f af78 	bgt.w	26eb2 <tAutotune_tick+0x4a>
    return r->tickOutput;
   26fc2:	6970      	ldr	r0, [r6, #20]
}
   26fc4:	b002      	add	sp, #8
   26fc6:	ecbd 8b06 	vpop	{d8-d10}
   26fca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   26fce:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   26fd2:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
    w->pitchfactor = pitchfactor;
   26fd6:	ed82 8a02 	vstr	s16, [r2, #8]
   26fda:	e7e1      	b.n	26fa0 <tAutotune_tick+0x138>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   26fdc:	edda 7a13 	vldr	s15, [sl, #76]	; 0x4c
   26fe0:	eef4 7aca 	vcmpe.f32	s15, s20
   26fe4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26fe8:	ddb1      	ble.n	26f4e <tAutotune_tick+0xe6>
   26fea:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
   26fee:	ed9a 7a15 	vldr	s14, [sl, #84]	; 0x54
   26ff2:	eeb4 7ae7 	vcmpe.f32	s14, s15
   26ff6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26ffa:	dda8      	ble.n	26f4e <tAutotune_tick+0xe6>
            p->fba = 5;
   26ffc:	9901      	ldr	r1, [sp, #4]
   26ffe:	2305      	movs	r3, #5
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   27000:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
            p->fba = 5;
   27002:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   27006:	ee07 2a90 	vmov	s15, r2
    _tSOLAD* w = *wp;
   2700a:	6862      	ldr	r2, [r4, #4]
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   2700c:	eef8 7a67 	vcvt.f32.u32	s15, s15
    if(readlag < w->readlag)               // do not jump backward, only forward
   27010:	ed92 7a03 	vldr	s14, [r2, #12]
   27014:	eef4 7ac7 	vcmpe.f32	s15, s14
   27018:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2701c:	d599      	bpl.n	26f52 <tAutotune_tick+0xea>
        w->jump = w->readlag - readlag;
   2701e:	ee37 7a67 	vsub.f32	s14, s14, s15
        w->xfadevalue = 1;
   27022:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
        w->readlag = readlag;
   27026:	edc2 7a03 	vstr	s15, [r2, #12]
        w->xfadelength = readlag;
   2702a:	edc2 7a06 	vstr	s15, [r2, #24]
        w->jump = w->readlag - readlag;
   2702e:	ed82 7a05 	vstr	s14, [r2, #20]
        w->xfadevalue = 1;
   27032:	61d3      	str	r3, [r2, #28]
   27034:	6862      	ldr	r2, [r4, #4]
   27036:	e78c      	b.n	26f52 <tAutotune_tick+0xea>
            p->deltamax = envout - p->max;
   27038:	ed8a 7a15 	vstr	s14, [sl, #84]	; 0x54
            p->max = p->max * ps->radius;
   2703c:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
   27040:	ee67 6aa6 	vmul.f32	s13, s15, s13
   27044:	ee36 7ae7 	vsub.f32	s14, s13, s15
   27048:	edca 6a13 	vstr	s13, [sl, #76]	; 0x4c
   2704c:	e773      	b.n	26f36 <tAutotune_tick+0xce>
   2704e:	bf00      	nop
   27050:	447a0000 	.word	0x447a0000
   27054:	3f4ccccd 	.word	0x3f4ccccd
   27058:	42700000 	.word	0x42700000
   2705c:	020fbd68 	.word	0x020fbd68

00027060 <tAutotune_setFreq>:
    r->freq[voice] = f;
   27060:	6803      	ldr	r3, [r0, #0]
   27062:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   27064:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   27068:	ed81 0a00 	vstr	s0, [r1]
}
   2706c:	4770      	bx	lr
   2706e:	bf00      	nop

00027070 <tAutotune_setFidelityThreshold>:

void tAutotune_setFidelityThreshold(tAutotune* const rt, float threshold)
{
    _tAutotune* r = *rt;

    tPeriodDetection_setFidelityThreshold(&r->pd, threshold);
   27070:	6800      	ldr	r0, [r0, #0]
   27072:	3004      	adds	r0, #4
   27074:	f7fd be18 	b.w	24ca8 <tPeriodDetection_setFidelityThreshold>

00027078 <tFormantShifter_initToPool>:
{
    tFormantShifter_initToPool(fsr, order, &leaf.mempool);
}

void tFormantShifter_initToPool (tFormantShifter* const fsr, int order, tMempool* const mp)
{
   27078:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2707c:	ed2d 8b06 	vpush	{d8-d10}
    _tMempool* m = *mp;
   27080:	6815      	ldr	r5, [r2, #0]
{
   27082:	4688      	mov	r8, r1
   27084:	4681      	mov	r9, r0
    _tFormantShifter* fs = *fsr = (_tFormantShifter*) mpool_alloc(sizeof(_tFormantShifter), m);
   27086:	2068      	movs	r0, #104	; 0x68
   27088:	4629      	mov	r1, r5
{
   2708a:	4616      	mov	r6, r2
    _tFormantShifter* fs = *fsr = (_tFormantShifter*) mpool_alloc(sizeof(_tFormantShifter), m);
   2708c:	f002 fd4c 	bl	29b28 <mpool_alloc>
   27090:	4604      	mov	r4, r0
   27092:	f8c9 0000 	str.w	r0, [r9]
    fs->mempool = m;
    
    fs->ford = order;
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27096:	4629      	mov	r1, r5
   27098:	ea4f 0088 	mov.w	r0, r8, lsl #2
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
    
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);

    
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   2709c:	eddf 9a4d 	vldr	s19, [pc, #308]	; 271d4 <tFormantShifter_initToPool+0x15c>
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
    fs->fhp = 0.0f;
    fs->flp = 0.0f;
    fs->flpa = powf(0.001f, 10.0f * leaf.invSampleRate);
    fs->fmute = 1.0f;
   270a0:	f04f 577e 	mov.w	r7, #1065353216	; 0x3f800000
    fs->cbi = 0;
    fs->intensity = 1.0f;
    fs->invIntensity = 1.0f;
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
    tHighpass_initToPool(&fs->hp2, 20.0f, mp);
    tFeedbackLeveler_initToPool(&fs->fbl1, 0.8f, .005f, 0.125, 1, mp);
   270a4:	eddf 8a4c 	vldr	s17, [pc, #304]	; 271d8 <tFormantShifter_initToPool+0x160>
   270a8:	ed9f 8a4c 	vldr	s16, [pc, #304]	; 271dc <tFormantShifter_initToPool+0x164>
    fs->ford = order;
   270ac:	e9c4 5800 	strd	r5, r8, [r4]
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270b0:	f002 fd90 	bl	29bd4 <mpool_calloc>
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270b4:	6863      	ldr	r3, [r4, #4]
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270b6:	6120      	str	r0, [r4, #16]
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270b8:	4629      	mov	r1, r5
   270ba:	0098      	lsls	r0, r3, #2
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   270bc:	f8df 812c 	ldr.w	r8, [pc, #300]	; 271ec <tFormantShifter_initToPool+0x174>
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270c0:	f002 fd88 	bl	29bd4 <mpool_calloc>
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270c4:	6863      	ldr	r3, [r4, #4]
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270c6:	6160      	str	r0, [r4, #20]
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270c8:	4629      	mov	r1, r5
   270ca:	0098      	lsls	r0, r3, #2
   270cc:	f002 fd82 	bl	29bd4 <mpool_calloc>
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270d0:	6863      	ldr	r3, [r4, #4]
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270d2:	61a0      	str	r0, [r4, #24]
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270d4:	4629      	mov	r1, r5
   270d6:	0098      	lsls	r0, r3, #2
   270d8:	f002 fd7c 	bl	29bd4 <mpool_calloc>
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270dc:	6863      	ldr	r3, [r4, #4]
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270de:	61e0      	str	r0, [r4, #28]
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270e0:	4629      	mov	r1, r5
   270e2:	0098      	lsls	r0, r3, #2
   270e4:	f002 fd76 	bl	29bd4 <mpool_calloc>
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270e8:	6863      	ldr	r3, [r4, #4]
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270ea:	6220      	str	r0, [r4, #32]
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270ec:	4629      	mov	r1, r5
   270ee:	0098      	lsls	r0, r3, #2
   270f0:	f002 fd70 	bl	29bd4 <mpool_calloc>
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270f4:	6863      	ldr	r3, [r4, #4]
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270f6:	6260      	str	r0, [r4, #36]	; 0x24
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   270f8:	4629      	mov	r1, r5
   270fa:	0098      	lsls	r0, r3, #2
   270fc:	f002 fd6a 	bl	29bd4 <mpool_calloc>
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27100:	6863      	ldr	r3, [r4, #4]
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27102:	62a0      	str	r0, [r4, #40]	; 0x28
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27104:	4629      	mov	r1, r5
   27106:	0098      	lsls	r0, r3, #2
   27108:	f002 fd64 	bl	29bd4 <mpool_calloc>
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
   2710c:	6863      	ldr	r3, [r4, #4]
   2710e:	4629      	mov	r1, r5
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27110:	63e0      	str	r0, [r4, #60]	; 0x3c
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
   27112:	0098      	lsls	r0, r3, #2
   27114:	f002 fd5e 	bl	29bd4 <mpool_calloc>
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   27118:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
   2711c:	ed98 aa01 	vldr	s20, [r8, #4]
   27120:	eeb0 0a69 	vmov.f32	s0, s19
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
   27124:	63a0      	str	r0, [r4, #56]	; 0x38
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   27126:	ee6a 0a20 	vmul.f32	s1, s20, s1
   2712a:	f005 feb1 	bl	2ce90 <powf>
   2712e:	eeb0 9a40 	vmov.f32	s18, s0
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   27132:	eddf 7a2b 	vldr	s15, [pc, #172]	; 271e0 <tFormantShifter_initToPool+0x168>
   27136:	ed98 0a00 	vldr	s0, [r8]
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   2713a:	ed84 9a02 	vstr	s18, [r4, #8]
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   2713e:	ee20 0a27 	vmul.f32	s0, s0, s15
   27142:	f005 fc25 	bl	2c990 <atanf>
   27146:	eef1 6ac0 	vsqrt.f32	s13, s0
   2714a:	ed9f 7a26 	vldr	s14, [pc, #152]	; 271e4 <tFormantShifter_initToPool+0x16c>
    fs->fhp = 0.0f;
   2714e:	2300      	movs	r3, #0
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   27150:	eddf 7a25 	vldr	s15, [pc, #148]	; 271e8 <tFormantShifter_initToPool+0x170>
    fs->flpa = powf(0.001f, 10.0f * leaf.invSampleRate);
   27154:	ed84 9a0d 	vstr	s18, [r4, #52]	; 0x34
    fs->fhp = 0.0f;
   27158:	62e3      	str	r3, [r4, #44]	; 0x2c
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   2715a:	eef0 0a4a 	vmov.f32	s1, s20
    fs->flp = 0.0f;
   2715e:	6323      	str	r3, [r4, #48]	; 0x30
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   27160:	eeb0 0a69 	vmov.f32	s0, s19
    fs->fmute = 1.0f;
   27164:	6427      	str	r7, [r4, #64]	; 0x40
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   27166:	eee6 7ac7 	vfms.f32	s15, s13, s14
   2716a:	edc4 7a03 	vstr	s15, [r4, #12]
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   2716e:	f005 fe8f 	bl	2ce90 <powf>
    fs->cbi = 0;
   27172:	2300      	movs	r3, #0
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   27174:	ed84 0a11 	vstr	s0, [r4, #68]	; 0x44
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   27178:	4631      	mov	r1, r6
    fs->cbi = 0;
   2717a:	64a3      	str	r3, [r4, #72]	; 0x48
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   2717c:	f104 0058 	add.w	r0, r4, #88	; 0x58
    fs->intensity = 1.0f;
   27180:	6527      	str	r7, [r4, #80]	; 0x50
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   27182:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
    fs->invIntensity = 1.0f;
   27186:	6567      	str	r7, [r4, #84]	; 0x54
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   27188:	f001 f948 	bl	2841c <tHighpass_initToPool>
    tHighpass_initToPool(&fs->hp2, 20.0f, mp);
   2718c:	4631      	mov	r1, r6
   2718e:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   27192:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   27196:	f001 f941 	bl	2841c <tHighpass_initToPool>
    tFeedbackLeveler_initToPool(&fs->fbl1, 0.8f, .005f, 0.125, 1, mp);
   2719a:	4632      	mov	r2, r6
   2719c:	f104 0060 	add.w	r0, r4, #96	; 0x60
   271a0:	eef0 0a68 	vmov.f32	s1, s17
   271a4:	eeb0 0a48 	vmov.f32	s0, s16
   271a8:	2101      	movs	r1, #1
   271aa:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
   271ae:	f7fe fc0f 	bl	259d0 <tFeedbackLeveler_initToPool>
    tFeedbackLeveler_initToPool(&fs->fbl2, 0.8f, .005f, 0.125, 1, mp);
   271b2:	eef0 0a68 	vmov.f32	s1, s17
   271b6:	eeb0 0a48 	vmov.f32	s0, s16
   271ba:	4632      	mov	r2, r6
   271bc:	f104 0064 	add.w	r0, r4, #100	; 0x64
   271c0:	2101      	movs	r1, #1
   271c2:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
}
   271c6:	ecbd 8b06 	vpop	{d8-d10}
   271ca:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tFeedbackLeveler_initToPool(&fs->fbl2, 0.8f, .005f, 0.125, 1, mp);
   271ce:	f7fe bbff 	b.w	259d0 <tFeedbackLeveler_initToPool>
   271d2:	bf00      	nop
   271d4:	3a83126f 	.word	0x3a83126f
   271d8:	3ba3d70a 	.word	0x3ba3d70a
   271dc:	3f4ccccd 	.word	0x3f4ccccd
   271e0:	3d86d1e1 	.word	0x3d86d1e1
   271e4:	3f5a0903 	.word	0x3f5a0903
   271e8:	3e4432ca 	.word	0x3e4432ca
   271ec:	020fbd68 	.word	0x020fbd68

000271f0 <tFormantShifter_free>:

void tFormantShifter_free (tFormantShifter* const fsr)
{
   271f0:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;
   271f2:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)fs->fk, fs->mempool);
   271f4:	6821      	ldr	r1, [r4, #0]
   271f6:	6920      	ldr	r0, [r4, #16]
   271f8:	f002 fd3e 	bl	29c78 <mpool_free>
    mpool_free((char*)fs->fb, fs->mempool);
   271fc:	6821      	ldr	r1, [r4, #0]
   271fe:	6960      	ldr	r0, [r4, #20]
   27200:	f002 fd3a 	bl	29c78 <mpool_free>
    mpool_free((char*)fs->fc, fs->mempool);
   27204:	6821      	ldr	r1, [r4, #0]
   27206:	69a0      	ldr	r0, [r4, #24]
   27208:	f002 fd36 	bl	29c78 <mpool_free>
    mpool_free((char*)fs->frb, fs->mempool);
   2720c:	6821      	ldr	r1, [r4, #0]
   2720e:	69e0      	ldr	r0, [r4, #28]
   27210:	f002 fd32 	bl	29c78 <mpool_free>
    mpool_free((char*)fs->frc, fs->mempool);
   27214:	6821      	ldr	r1, [r4, #0]
   27216:	6a20      	ldr	r0, [r4, #32]
   27218:	f002 fd2e 	bl	29c78 <mpool_free>
    mpool_free((char*)fs->fsig, fs->mempool);
   2721c:	6821      	ldr	r1, [r4, #0]
   2721e:	6a60      	ldr	r0, [r4, #36]	; 0x24
   27220:	f002 fd2a 	bl	29c78 <mpool_free>
    mpool_free((char*)fs->fsmooth, fs->mempool);
   27224:	6821      	ldr	r1, [r4, #0]
   27226:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   27228:	f002 fd26 	bl	29c78 <mpool_free>
    mpool_free((char*)fs->ftvec, fs->mempool);
   2722c:	6821      	ldr	r1, [r4, #0]
   2722e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   27230:	f002 fd22 	bl	29c78 <mpool_free>
    mpool_free((char*)fs->fbuff, fs->mempool);
   27234:	6821      	ldr	r1, [r4, #0]
   27236:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   27238:	f002 fd1e 	bl	29c78 <mpool_free>
    tHighpass_free(&fs->hp);
   2723c:	f104 0058 	add.w	r0, r4, #88	; 0x58
   27240:	f001 f90c 	bl	2845c <tHighpass_free>
    tHighpass_free(&fs->hp2);
   27244:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   27248:	f001 f908 	bl	2845c <tHighpass_free>
    tFeedbackLeveler_free(&fs->fbl1);
   2724c:	f104 0060 	add.w	r0, r4, #96	; 0x60
   27250:	f7fe fbe6 	bl	25a20 <tFeedbackLeveler_free>
    tFeedbackLeveler_free(&fs->fbl2);
   27254:	f104 0064 	add.w	r0, r4, #100	; 0x64
   27258:	f7fe fbe2 	bl	25a20 <tFeedbackLeveler_free>
    mpool_free((char*)fs, fs->mempool);
   2725c:	6821      	ldr	r1, [r4, #0]
   2725e:	4620      	mov	r0, r4
}
   27260:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)fs, fs->mempool);
   27264:	f002 bd08 	b.w	29c78 <mpool_free>

00027268 <tFormantShifter_remove>:
{
    return tFormantShifter_add(fsr, tFormantShifter_remove(fsr, in));
}

float tFormantShifter_remove(tFormantShifter* const fsr, float in)
{
   27268:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;
   2726a:	6804      	ldr	r4, [r0, #0]
    in = tFeedbackLeveler_tick(&fs->fbl1, in);
   2726c:	f104 0060 	add.w	r0, r4, #96	; 0x60
   27270:	f7fe fbe6 	bl	25a40 <tFeedbackLeveler_tick>
    in = tHighpass_tick(&fs->hp, in * fs->intensity);
   27274:	edd4 7a14 	vldr	s15, [r4, #80]	; 0x50
   27278:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2727c:	ee20 0a27 	vmul.f32	s0, s0, s15
   27280:	f001 f900 	bl	28484 <tHighpass_tick>
    

    float fa, fb, fc, foma, falph, ford, flamb, tf, fk;

    ford = fs->ford;
   27284:	edd4 7a01 	vldr	s15, [r4, #4]
    foma = (1.0f - falph);
    flamb = fs->flamb;
    
    tf = in;
    
    fa = tf - fs->fhp;
   27288:	edd4 6a0b 	vldr	s13, [r4, #44]	; 0x2c
    foma = (1.0f - falph);
   2728c:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    ford = fs->ford;
   27290:	eef8 3ae7 	vcvt.f32.s32	s7, s15
    falph = fs->falph;
   27294:	ed94 5a02 	vldr	s10, [r4, #8]
    fa = tf - fs->fhp;
   27298:	ee70 6a66 	vsub.f32	s13, s0, s13
    fs->fhp = tf;
   2729c:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
    foma = (1.0f - falph);
   272a0:	ee75 5ac5 	vsub.f32	s11, s11, s10
    flamb = fs->flamb;
   272a4:	ed94 3a03 	vldr	s6, [r4, #12]
    fb = fa;
    for(int i = 0; i < ford; i++)
   272a8:	eef5 3ac0 	vcmpe.f32	s7, #0.0
    fa = tf - fs->fhp;
   272ac:	eeb0 0a66 	vmov.f32	s0, s13
    for(int i = 0; i < ford; i++)
   272b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   272b4:	dd53      	ble.n	2735e <tFormantShifter_remove+0xf6>
   272b6:	2100      	movs	r1, #0
        fc = (fb - fs->fc[i])*flamb + fs->fb[i];
        fs->fc[i] = fc;
        fs->fb[i] = fb;
        fk = fa*fc*foma + fs->fk[i]*falph;
        fs->fk[i] = fk;
        tf = fk/(fs->fsig[i] + 0.000001f);
   272b8:	eddf 2a29 	vldr	s5, [pc, #164]	; 27360 <tFormantShifter_remove+0xf8>
   272bc:	008b      	lsls	r3, r1, #2
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   272be:	6a62      	ldr	r2, [r4, #36]	; 0x24
    for(int i = 0; i < ford; i++)
   272c0:	3101      	adds	r1, #1
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   272c2:	ee20 7a00 	vmul.f32	s14, s0, s0
   272c6:	441a      	add	r2, r3
        fk = fa*fc*foma + fs->fk[i]*falph;
   272c8:	ee25 6a80 	vmul.f32	s12, s11, s0
    for(int i = 0; i < ford; i++)
   272cc:	ee07 1a90 	vmov	s15, r1
   272d0:	eef8 4ae7 	vcvt.f32.s32	s9, s15
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   272d4:	edd2 7a00 	vldr	s15, [r2]
   272d8:	ee65 7a27 	vmul.f32	s15, s10, s15
    for(int i = 0; i < ford; i++)
   272dc:	eef4 4ae3 	vcmpe.f32	s9, s7
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   272e0:	eee5 7a87 	vfma.f32	s15, s11, s14
    for(int i = 0; i < ford; i++)
   272e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   272e8:	edc2 7a00 	vstr	s15, [r2]
        fc = (fb - fs->fc[i])*flamb + fs->fb[i];
   272ec:	e9d4 0205 	ldrd	r0, r2, [r4, #20]
   272f0:	441a      	add	r2, r3
   272f2:	4418      	add	r0, r3
   272f4:	edd2 7a00 	vldr	s15, [r2]
   272f8:	ed90 7a00 	vldr	s14, [r0]
   272fc:	ee76 7ae7 	vsub.f32	s15, s13, s15
   27300:	eea7 7a83 	vfma.f32	s14, s15, s6
        fs->fc[i] = fc;
   27304:	ed82 7a00 	vstr	s14, [r2]
        fs->fb[i] = fb;
   27308:	6962      	ldr	r2, [r4, #20]
   2730a:	441a      	add	r2, r3
   2730c:	edc2 6a00 	vstr	s13, [r2]
        fk = fa*fc*foma + fs->fk[i]*falph;
   27310:	6922      	ldr	r2, [r4, #16]
   27312:	441a      	add	r2, r3
   27314:	edd2 6a00 	vldr	s13, [r2]
   27318:	ee65 6a26 	vmul.f32	s13, s10, s13
   2731c:	eee6 6a07 	vfma.f32	s13, s12, s14
        fs->fk[i] = fk;
   27320:	edc2 6a00 	vstr	s13, [r2]
        tf = tf*foma + fs->fsmooth[i]*falph;
   27324:	e9d4 0209 	ldrd	r0, r2, [r4, #36]	; 0x24
        tf = fk/(fs->fsig[i] + 0.000001f);
   27328:	4418      	add	r0, r3
        tf = tf*foma + fs->fsmooth[i]*falph;
   2732a:	441a      	add	r2, r3
        tf = fk/(fs->fsig[i] + 0.000001f);
   2732c:	ed90 6a00 	vldr	s12, [r0]
        tf = tf*foma + fs->fsmooth[i]*falph;
   27330:	edd2 7a00 	vldr	s15, [r2]
        tf = fk/(fs->fsig[i] + 0.000001f);
   27334:	ee36 6a22 	vadd.f32	s12, s12, s5
        tf = tf*foma + fs->fsmooth[i]*falph;
   27338:	ee65 7a27 	vmul.f32	s15, s10, s15
        tf = fk/(fs->fsig[i] + 0.000001f);
   2733c:	ee86 4a86 	vdiv.f32	s8, s13, s12
        fs->fsmooth[i] = tf;
        fs->fbuff[i] = tf;
        fb = fc - tf*fa;
   27340:	eef0 6a47 	vmov.f32	s13, s14
        tf = tf*foma + fs->fsmooth[i]*falph;
   27344:	eee5 7a84 	vfma.f32	s15, s11, s8
        fs->fsmooth[i] = tf;
   27348:	edc2 7a00 	vstr	s15, [r2]
        fb = fc - tf*fa;
   2734c:	eee7 6ac0 	vfms.f32	s13, s15, s0
        fs->fbuff[i] = tf;
   27350:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        fa = fa - tf*fc;
   27352:	eea7 0a67 	vfms.f32	s0, s14, s15
        fs->fbuff[i] = tf;
   27356:	4413      	add	r3, r2
   27358:	edc3 7a00 	vstr	s15, [r3]
    for(int i = 0; i < ford; i++)
   2735c:	d4ae      	bmi.n	272bc <tFormantShifter_remove+0x54>
    }

    //return fa * 0.1f;
    return fa;
}
   2735e:	bd10      	pop	{r4, pc}
   27360:	358637bd 	.word	0x358637bd

00027364 <tFormantShifter_add>:

float tFormantShifter_add(tFormantShifter* const fsr, float in)
{
   27364:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   27366:	ed2d 8b02 	vpush	{d8}
    _tFormantShifter* fs = *fsr;
   2736a:	6804      	ldr	r4, [r0, #0]
    float fa, fb, fc, ford, flpa, flamb, tf, tf2, f0resp, f1resp, frlamb;
    ford = fs->ford;

    flpa = fs->flpa;
    flamb = fs->flamb;
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   2736c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    flamb = fs->flamb;
   27370:	edd4 7a03 	vldr	s15, [r4, #12]
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   27374:	ed94 5a13 	vldr	s10, [r4, #76]	; 0x4c
   27378:	ee37 6a87 	vadd.f32	s12, s15, s14
    flpa = fs->flpa;
   2737c:	ed94 3a0d 	vldr	s6, [r4, #52]	; 0x34
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   27380:	ee77 6a67 	vsub.f32	s13, s14, s15
    ford = fs->ford;
   27384:	edd4 7a01 	vldr	s15, [r4, #4]
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   27388:	ee26 6a05 	vmul.f32	s12, s12, s10
    ford = fs->ford;
   2738c:	eef8 5ae7 	vcvt.f32.s32	s11, s15
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   27390:	eec6 7a26 	vdiv.f32	s15, s12, s13
    frlamb = (tf-1.0f)/(tf+1.0f);
    
    tf2 = in;
    fa = 0.0f;
    fb = fa;
    for (int i=0; i<ford; i++)
   27394:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   27398:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    frlamb = (tf-1.0f)/(tf+1.0f);
   2739c:	ee77 6ac7 	vsub.f32	s13, s15, s14
   273a0:	ee77 7a87 	vadd.f32	s15, s15, s14
   273a4:	ee86 5aa7 	vdiv.f32	s10, s13, s15
    for (int i=0; i<ford; i++)
   273a8:	f340 8107 	ble.w	275ba <tFormantShifter_add+0x256>
    fb = fa;
   273ac:	eddf 6a87 	vldr	s13, [pc, #540]	; 275cc <tFormantShifter_add+0x268>
    for (int i=0; i<ford; i++)
   273b0:	2100      	movs	r1, #0
   273b2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    fa = 0.0f;
   273b4:	eef0 7a66 	vmov.f32	s15, s13
   273b8:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
   273ba:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   273bc:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
    for (int i=0; i<ford; i++)
   273c0:	ee04 1a90 	vmov	s9, r1
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
        fs->ftvec[i] = tf*fc;
   273c4:	441a      	add	r2, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   273c6:	18c6      	adds	r6, r0, r3
   273c8:	441d      	add	r5, r3
        tf = fs->fbuff[i];
   273ca:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    for (int i=0; i<ford; i++)
   273cc:	eef8 4ae4 	vcvt.f32.s32	s9, s9
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   273d0:	ed96 6a00 	vldr	s12, [r6]
   273d4:	ed95 7a00 	vldr	s14, [r5]
        tf = fs->fbuff[i];
   273d8:	4418      	add	r0, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   273da:	ee76 6ac6 	vsub.f32	s13, s13, s12
        tf = fs->fbuff[i];
   273de:	ed90 6a00 	vldr	s12, [r0]
    for (int i=0; i<ford; i++)
   273e2:	eef4 4ae5 	vcmpe.f32	s9, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   273e6:	eea6 7a85 	vfma.f32	s14, s13, s10
    for (int i=0; i<ford; i++)
   273ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->ftvec[i] = tf*fc;
   273ee:	ee27 4a06 	vmul.f32	s8, s14, s12
        fb = fc - tf*fa;
   273f2:	eea6 7a67 	vfms.f32	s14, s12, s15
        fs->ftvec[i] = tf*fc;
   273f6:	ed82 4a00 	vstr	s8, [r2]
        fa = fa - fs->ftvec[i];
   273fa:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   273fc:	4413      	add	r3, r2
        fb = fc - tf*fa;
   273fe:	eef0 6a47 	vmov.f32	s13, s14
        fa = fa - fs->ftvec[i];
   27402:	ed93 7a00 	vldr	s14, [r3]
   27406:	ee77 7ac7 	vsub.f32	s15, s15, s14
    for (int i=0; i<ford; i++)
   2740a:	d4d5      	bmi.n	273b8 <tFormantShifter_add+0x54>
   2740c:	eeb1 7a67 	vneg.f32	s14, s15
    }
    tf = -fa;
    for (int i=ford-1; i>=0; i--)
   27410:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27414:	ee75 7ae7 	vsub.f32	s15, s11, s15
   27418:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2741c:	ee17 7a90 	vmov	r7, s15
   27420:	2f00      	cmp	r7, #0
   27422:	f2c0 80c2 	blt.w	275aa <tFormantShifter_add+0x246>
    {
        tf = tf + fs->ftvec[i];
   27426:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   27428:	1c7b      	adds	r3, r7, #1
   2742a:	eb02 0183 	add.w	r1, r2, r3, lsl #2
   2742e:	ed71 7a01 	vldmdb	r1!, {s15}
    for (int i=ford-1; i>=0; i--)
   27432:	428a      	cmp	r2, r1
        tf = tf + fs->ftvec[i];
   27434:	ee37 7a27 	vadd.f32	s14, s14, s15
    for (int i=ford-1; i>=0; i--)
   27438:	d1f9      	bne.n	2742e <tFormantShifter_add+0xca>
    f0resp = tf;
    
    //  second time: compute 1-response
    fa = 1.0f;
    fb = fa;
    for (int i=0; i<ford; i++)
   2743a:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   2743e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27442:	f340 80bf 	ble.w	275c4 <tFormantShifter_add+0x260>
    fb = fa;
   27446:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    for (int i=0; i<ford; i++)
   2744a:	2100      	movs	r1, #0
    fa = 1.0f;
   2744c:	eef0 7a46 	vmov.f32	s15, s12
   27450:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
   27452:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   27454:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
    for (int i=0; i<ford; i++)
   27458:	ee04 1a10 	vmov	s8, r1
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
        fs->ftvec[i] = tf*fc;
   2745c:	441a      	add	r2, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2745e:	18c6      	adds	r6, r0, r3
   27460:	441d      	add	r5, r3
        tf = fs->fbuff[i];
   27462:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    for (int i=0; i<ford; i++)
   27464:	eeb8 4ac4 	vcvt.f32.s32	s8, s8
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   27468:	edd6 4a00 	vldr	s9, [r6]
   2746c:	edd5 6a00 	vldr	s13, [r5]
        tf = fs->fbuff[i];
   27470:	4418      	add	r0, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   27472:	ee36 6a64 	vsub.f32	s12, s12, s9
        tf = fs->fbuff[i];
   27476:	edd0 4a00 	vldr	s9, [r0]
    for (int i=0; i<ford; i++)
   2747a:	eeb4 4ae5 	vcmpe.f32	s8, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2747e:	eee6 6a05 	vfma.f32	s13, s12, s10
    for (int i=0; i<ford; i++)
   27482:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->ftvec[i] = tf*fc;
   27486:	ee66 3aa4 	vmul.f32	s7, s13, s9
        fb = fc - tf*fa;
   2748a:	eee4 6ae7 	vfms.f32	s13, s9, s15
        fs->ftvec[i] = tf*fc;
   2748e:	edc2 3a00 	vstr	s7, [r2]
        fa = fa - fs->ftvec[i];
   27492:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   27494:	4413      	add	r3, r2
        fb = fc - tf*fa;
   27496:	eeb0 6a66 	vmov.f32	s12, s13
        fa = fa - fs->ftvec[i];
   2749a:	edd3 6a00 	vldr	s13, [r3]
   2749e:	ee77 7ae6 	vsub.f32	s15, s15, s13
    for (int i=0; i<ford; i++)
   274a2:	d4d5      	bmi.n	27450 <tFormantShifter_add+0xec>
    }
    tf = -fa;
    for (int i=ford-1; i>=0; i--)
   274a4:	2f00      	cmp	r7, #0
   274a6:	eef1 7a67 	vneg.f32	s15, s15
   274aa:	db08      	blt.n	274be <tFormantShifter_add+0x15a>
   274ac:	1c7b      	adds	r3, r7, #1
   274ae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    {
        tf = tf + fs->ftvec[i];
   274b2:	ed73 6a01 	vldmdb	r3!, {s13}
    for (int i=ford-1; i>=0; i--)
   274b6:	429a      	cmp	r2, r3
        tf = tf + fs->ftvec[i];
   274b8:	ee77 7aa6 	vadd.f32	s15, s15, s13
    for (int i=ford-1; i>=0; i--)
   274bc:	d1f9      	bne.n	274b2 <tFormantShifter_add+0x14e>
    f1resp = tf;
    
    //  now solve equations for output, based on 0-response and 1-response
    tf = 2.0f*tf2;
    tf2 = tf;
    tf = (1.0f - f1resp + f0resp);
   274be:	ee77 7a67 	vsub.f32	s15, s14, s15
    if (tf!=0.0f)
   274c2:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   274c6:	eef4 7a66 	vcmp.f32	s15, s13
   274ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   274ce:	d066      	beq.n	2759e <tFormantShifter_add+0x23a>
    {
        tf2 = (tf2 + f0resp) / tf;
   274d0:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
    tf = (1.0f - f1resp + f0resp);
   274d4:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
        tf2 = (tf2 + f0resp) / tf;
   274d8:	eea0 7a06 	vfma.f32	s14, s0, s12
    tf = (1.0f - f1resp + f0resp);
   274dc:	ee77 7aa6 	vadd.f32	s15, s15, s13
        tf2 = (tf2 + f0resp) / tf;
   274e0:	ee87 0a27 	vdiv.f32	s0, s14, s15
    }
    
    //  third time: update delay registers
    fa = tf2;
    fb = fa;
    for (int i=0; i<ford; i++)
   274e4:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   274e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   274ec:	dd2b      	ble.n	27546 <tFormantShifter_add+0x1e2>
    fb = fa;
   274ee:	eeb0 6a40 	vmov.f32	s12, s0
    for (int i=0; i<ford; i++)
   274f2:	2100      	movs	r1, #0
    fa = tf2;
   274f4:	eef0 6a40 	vmov.f32	s13, s0
   274f8:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
   274fa:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   274fc:	e9d4 0207 	ldrd	r0, r2, [r4, #28]
    for (int i=0; i<ford; i++)
   27500:	ee07 1a90 	vmov	s15, r1
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   27504:	441a      	add	r2, r3
   27506:	4418      	add	r0, r3
    for (int i=0; i<ford; i++)
   27508:	eef8 4ae7 	vcvt.f32.s32	s9, s15
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2750c:	ed92 7a00 	vldr	s14, [r2]
   27510:	edd0 7a00 	vldr	s15, [r0]
   27514:	ee36 7a47 	vsub.f32	s14, s12, s14
    for (int i=0; i<ford; i++)
   27518:	eef4 4ae5 	vcmpe.f32	s9, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2751c:	eee7 7a05 	vfma.f32	s15, s14, s10
    for (int i=0; i<ford; i++)
   27520:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->frc[i] = fc;
   27524:	edc2 7a00 	vstr	s15, [r2]
        fs->frb[i] = fb;
   27528:	69e2      	ldr	r2, [r4, #28]
   2752a:	441a      	add	r2, r3
   2752c:	ed82 6a00 	vstr	s12, [r2]
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
   27530:	eeb0 6a67 	vmov.f32	s12, s15
        tf = fs->fbuff[i];
   27534:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   27536:	4413      	add	r3, r2
   27538:	ed93 7a00 	vldr	s14, [r3]
        fb = fc - tf*fa;
   2753c:	eea7 6a66 	vfms.f32	s12, s14, s13
        fa = fa - tf*fc;
   27540:	eee7 6ac7 	vfms.f32	s13, s15, s14
    for (int i=0; i<ford; i++)
   27544:	d4d8      	bmi.n	274f8 <tFormantShifter_add+0x194>
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
    fs->flp = tf;
    
    // Bring up the gain slowly when formant correction goes from disabled
    // to enabled, while things stabilize.
    if (fs->fmute>0.5f)
   27546:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
   2754a:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
    if (fs->fmute>0.5f)
   2754e:	ed94 8a10 	vldr	s16, [r4, #64]	; 0x40
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
   27552:	eea7 0a03 	vfma.f32	s0, s14, s6
    if (fs->fmute>0.5f)
   27556:	eeb4 8ae7 	vcmpe.f32	s16, s15
   2755a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    fs->flp = tf;
   2755e:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    if (fs->fmute>0.5f)
   27562:	dd1f      	ble.n	275a4 <tFormantShifter_add+0x240>
    {
        tf = tf*(fs->fmute - 0.5f)*2.0f;
   27564:	ee78 7a67 	vsub.f32	s15, s16, s15
   27568:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2756c:	ee27 0a80 	vmul.f32	s0, s15, s0
   27570:	f005 fdf4 	bl	2d15c <tanhf>
    else
    {
        tf = 0.0f;
    }
    tf2 = fs->fmutealph;
    fs->fmute = (1.0f-tf2) + tf2*fs->fmute;
   27574:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27578:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
    // now tf is signal output
    // ...and we're done messing with formants
    //tf = tFeedbackLeveler_tick(&fs->fbl2, tf);
    tf = tHighpass_tick(&fs->hp2, tanhf(tf));
   2757c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    fs->fmute = (1.0f-tf2) + tf2*fs->fmute;
   27580:	ee38 8a67 	vsub.f32	s16, s16, s15
   27584:	eee8 7a07 	vfma.f32	s15, s16, s14
   27588:	edc4 7a10 	vstr	s15, [r4, #64]	; 0x40
    tf = tHighpass_tick(&fs->hp2, tanhf(tf));
   2758c:	f000 ff7a 	bl	28484 <tHighpass_tick>

    return tf * fs->invIntensity;
   27590:	edd4 7a15 	vldr	s15, [r4, #84]	; 0x54
}
   27594:	ecbd 8b02 	vpop	{d8}
    return tf * fs->invIntensity;
   27598:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   2759c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        tf2 = 0.0f;
   2759e:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 275cc <tFormantShifter_add+0x268>
   275a2:	e79f      	b.n	274e4 <tFormantShifter_add+0x180>
   275a4:	ed9f 0a09 	vldr	s0, [pc, #36]	; 275cc <tFormantShifter_add+0x268>
   275a8:	e7e4      	b.n	27574 <tFormantShifter_add+0x210>
    for (int i=0; i<ford; i++)
   275aa:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   275ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   275b2:	dc05      	bgt.n	275c0 <tFormantShifter_add+0x25c>
   275b4:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   275b8:	e781      	b.n	274be <tFormantShifter_add+0x15a>
    for (int i=0; i<ford; i++)
   275ba:	ed9f 7a04 	vldr	s14, [pc, #16]	; 275cc <tFormantShifter_add+0x268>
   275be:	e727      	b.n	27410 <tFormantShifter_add+0xac>
   275c0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   275c2:	e740      	b.n	27446 <tFormantShifter_add+0xe2>
    for (int i=0; i<ford; i++)
   275c4:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   275c8:	e771      	b.n	274ae <tFormantShifter_add+0x14a>
   275ca:	bf00      	nop
   275cc:	00000000 	.word	0x00000000

000275d0 <tFormantShifter_setShiftFactor>:

// 1.0f is no change, 2.0f is an octave up, 0.5f is an octave down
void tFormantShifter_setShiftFactor(tFormantShifter* const fsr, float shiftFactor)
{
    _tFormantShifter* fs = *fsr;
   275d0:	6803      	ldr	r3, [r0, #0]
    fs->shiftFactor = shiftFactor;
   275d2:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
   275d6:	4770      	bx	lr

000275d8 <tFormantShifter_setIntensity>:

void tFormantShifter_setIntensity(tFormantShifter* const fsr, float intensity)
{
   275d8:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;



    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
   275da:	eef0 0a40 	vmov.f32	s1, s0
   275de:	ed9f 1a0d 	vldr	s2, [pc, #52]	; 27614 <tFormantShifter_setIntensity+0x3c>
   275e2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    _tFormantShifter* fs = *fsr;
   275e6:	6804      	ldr	r4, [r0, #0]
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
   275e8:	f002 f89e 	bl	29728 <LEAF_clip>

   // tFeedbackLeveler_setTargetLevel(&fs->fbl1, fs->intensity);
    //tFeedbackLeveler_setTargetLevel(&fs->fbl2, fs->intensity);
    //make sure you don't divide by zero, doofies
    if (fs->intensity != 0.0f)
   275ec:	eeb5 0a40 	vcmp.f32	s0, #0.0
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
   275f0:	ed84 0a14 	vstr	s0, [r4, #80]	; 0x50
    if (fs->intensity != 0.0f)
   275f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   275f8:	d104      	bne.n	27604 <tFormantShifter_setIntensity+0x2c>
    {
    	fs->invIntensity = 1.0f/fs->intensity;
    }
    else
    {
    	fs->invIntensity = 1.0f;
   275fa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   275fe:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
    }

}
   27602:	bd10      	pop	{r4, pc}
    	fs->invIntensity = 1.0f/fs->intensity;
   27604:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27608:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2760c:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
}
   27610:	bd10      	pop	{r4, pc}
   27612:	bf00      	nop
   27614:	42c80000 	.word	0x42c80000

00027618 <tADSR4_initToPool>:
}

//initialize with an exponential function that decays -- i.e. a call to LEAF_generate_exp(expBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, EXP_BUFFER_SIZE);
//times are in ms
void    tADSR4_initToPool    (tADSR4* const adsrenv, float attack, float decay, float sustain, float release, float* expBuffer, int bufferSize, tMempool* const mp)
{
   27618:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2761a:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   2761e:	681d      	ldr	r5, [r3, #0]
{
   27620:	4614      	mov	r4, r2
   27622:	4607      	mov	r7, r0
   27624:	460e      	mov	r6, r1
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
   27626:	2050      	movs	r0, #80	; 0x50
   27628:	4629      	mov	r1, r5
{
   2762a:	eef0 8a61 	vmov.f32	s17, s3
   2762e:	eef0 9a40 	vmov.f32	s19, s0
   27632:	eeb0 9a60 	vmov.f32	s18, s1
   27636:	eeb0 8a41 	vmov.f32	s16, s2
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
   2763a:	f002 fa75 	bl	29b28 <mpool_alloc>

    adsr->exp_buff = expBuffer;
    adsr->buff_size = bufferSize;
    adsr->buff_sizeMinusOne = bufferSize - 1;

    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   2763e:	4b20      	ldr	r3, [pc, #128]	; (276c0 <tADSR4_initToPool+0xa8>)
   27640:	ee07 4a90 	vmov	s15, r4
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
   27644:	6038      	str	r0, [r7, #0]

    adsr->next = 0.0f;

    adsr->whichStage = env_idle;

    adsr->sustain = sustain;
   27646:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   2764a:	eeb8 5ae7 	vcvt.f32.s32	s10, s15
    adsr->mempool = m;
   2764e:	6005      	str	r5, [r0, #0]
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   27650:	eddf 7a1c 	vldr	s15, [pc, #112]	; 276c4 <tADSR4_initToPool+0xac>

    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
   27654:	eef4 5a00 	vmov.f32	s11, #64	; 0x3e000000  0.125
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   27658:	edd3 6a00 	vldr	s13, [r3]
    adsr->buff_sizeMinusOne = bufferSize - 1;
   2765c:	1e62      	subs	r2, r4, #1
   2765e:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 276c8 <tADSR4_initToPool+0xb0>
    adsr->whichStage = env_idle;
   27662:	2300      	movs	r3, #0
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   27664:	ee66 6aa7 	vmul.f32	s13, s13, s15

    adsr->leakFactor = 1.0f;
   27668:	ed80 6a13 	vstr	s12, [r0, #76]	; 0x4c
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   2766c:	fec9 9a87 	vmaxnm.f32	s19, s19, s14
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   27670:	fe89 9a07 	vmaxnm.f32	s18, s18, s14
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   27674:	fec8 1a87 	vmaxnm.f32	s3, s17, s14
   27678:	fe88 8a07 	vmaxnm.f32	s16, s16, s14
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   2767c:	eec5 7a26 	vdiv.f32	s15, s10, s13
    adsr->sustain = sustain;
   27680:	fe88 8a46 	vminnm.f32	s16, s16, s12
    adsr->next = 0.0f;
   27684:	ed80 7a05 	vstr	s14, [r0, #20]
    adsr->exp_buff = expBuffer;
   27688:	6046      	str	r6, [r0, #4]
    adsr->buff_size = bufferSize;
   2768a:	6084      	str	r4, [r0, #8]
    adsr->buff_sizeMinusOne = bufferSize - 1;
   2768c:	60c2      	str	r2, [r0, #12]
    adsr->whichStage = env_idle;
   2768e:	6283      	str	r3, [r0, #40]	; 0x28
    adsr->sustain = sustain;
   27690:	ed80 8a0b 	vstr	s16, [r0, #44]	; 0x2c
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   27694:	ee87 6aa9 	vdiv.f32	s12, s15, s19
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   27698:	edc0 7a04 	vstr	s15, [r0, #16]
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   2769c:	eec7 6a89 	vdiv.f32	s13, s15, s18
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   276a0:	ee87 7aa1 	vdiv.f32	s14, s15, s3
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
   276a4:	ee67 7aa5 	vmul.f32	s15, s15, s11
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   276a8:	ed80 6a06 	vstr	s12, [r0, #24]
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
   276ac:	edc0 7a09 	vstr	s15, [r0, #36]	; 0x24
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   276b0:	edc0 6a07 	vstr	s13, [r0, #28]
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   276b4:	ed80 7a08 	vstr	s14, [r0, #32]
}
   276b8:	ecbd 8b04 	vpop	{d8-d9}
   276bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   276be:	bf00      	nop
   276c0:	020fbd68 	.word	0x020fbd68
   276c4:	3a83126f 	.word	0x3a83126f
   276c8:	00000000 	.word	0x00000000

000276cc <tADSR4_free>:

void    tADSR4_free  (tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
   276cc:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)adsr, adsr->mempool);
   276ce:	6801      	ldr	r1, [r0, #0]
   276d0:	f002 bad2 	b.w	29c78 <mpool_free>

000276d4 <tADSR4_setAttack>:
}

void     tADSR4_setAttack(tADSR4* const adsrenv, float attack)
{
    _tADSR4* adsr = *adsrenv;
   276d4:	6803      	ldr	r3, [r0, #0]
    if (attack < 0.0f)
    {
        attack = 0.0f;
    }

    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   276d6:	eddf 7a05 	vldr	s15, [pc, #20]	; 276ec <tADSR4_setAttack+0x18>
   276da:	ed93 7a04 	vldr	s14, [r3, #16]
   276de:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
   276e2:	eec7 7a00 	vdiv.f32	s15, s14, s0
   276e6:	edc3 7a06 	vstr	s15, [r3, #24]
}
   276ea:	4770      	bx	lr
   276ec:	00000000 	.word	0x00000000

000276f0 <tADSR4_setDecay>:

void     tADSR4_setDecay(tADSR4* const adsrenv, float decay)
{
    _tADSR4* adsr = *adsrenv;
   276f0:	6803      	ldr	r3, [r0, #0]

    if (decay < 0.0f)
    {
        decay = 0.0f;
    }
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   276f2:	eddf 7a05 	vldr	s15, [pc, #20]	; 27708 <tADSR4_setDecay+0x18>
   276f6:	ed93 7a04 	vldr	s14, [r3, #16]
   276fa:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
   276fe:	eec7 7a00 	vdiv.f32	s15, s14, s0
   27702:	edc3 7a07 	vstr	s15, [r3, #28]
}
   27706:	4770      	bx	lr
   27708:	00000000 	.word	0x00000000

0002770c <tADSR4_setSustain>:

void     tADSR4_setSustain(tADSR4* const adsrenv, float sustain)
{
    _tADSR4* adsr = *adsrenv;

    if (sustain > 1.0f)      adsr->sustain = 1.0f;
   2770c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tADSR4* adsr = *adsrenv;
   27710:	6803      	ldr	r3, [r0, #0]
    if (sustain > 1.0f)      adsr->sustain = 1.0f;
   27712:	eeb4 0ae7 	vcmpe.f32	s0, s15
   27716:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2771a:	dd02      	ble.n	27722 <tADSR4_setSustain+0x16>
   2771c:	edc3 7a0b 	vstr	s15, [r3, #44]	; 0x2c
   27720:	4770      	bx	lr
    else if (sustain < 0.0f) adsr->sustain = 0.0f;
   27722:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   27726:	2200      	movs	r2, #0
   27728:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2772c:	bf4c      	ite	mi
   2772e:	62da      	strmi	r2, [r3, #44]	; 0x2c
    else                     adsr->sustain = sustain;
   27730:	ed83 0a0b 	vstrpl	s0, [r3, #44]	; 0x2c
}
   27734:	4770      	bx	lr
   27736:	bf00      	nop

00027738 <tADSR4_setRelease>:

void     tADSR4_setRelease(tADSR4* const adsrenv, float release)
{
    _tADSR4* adsr = *adsrenv;
   27738:	6803      	ldr	r3, [r0, #0]

    if (release < 0.0f)
    {
        release = 0.0f;
    }
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   2773a:	eddf 7a05 	vldr	s15, [pc, #20]	; 27750 <tADSR4_setRelease+0x18>
   2773e:	ed93 7a04 	vldr	s14, [r3, #16]
   27742:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
   27746:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2774a:	edc3 7a08 	vstr	s15, [r3, #32]
}
   2774e:	4770      	bx	lr
   27750:	00000000 	.word	0x00000000

00027754 <tADSR4_setLeakFactor>:

// 0.999999 is slow leak, 0.9 is fast leak
void     tADSR4_setLeakFactor(tADSR4* const adsrenv, float leakFactor)
{
    _tADSR4* adsr = *adsrenv;
   27754:	6803      	ldr	r3, [r0, #0]


    adsr->leakFactor = leakFactor;
   27756:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
   2775a:	4770      	bx	lr

0002775c <tADSR4_on>:

void tADSR4_on(tADSR4* const adsrenv, float velocity)
{
    _tADSR4* adsr = *adsrenv;
   2775c:	6803      	ldr	r3, [r0, #0]

    if (adsr->whichStage != env_idle) // In case ADSR retriggered while it is still happening.
   2775e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   27760:	b942      	cbnz	r2, 27774 <tADSR4_on+0x18>
        adsr->whichStage = env_ramp;
        adsr->rampPeak = adsr->next;
    }
    else // Normal start.
    {
        adsr->whichStage = env_attack;
   27762:	2101      	movs	r1, #1
    }

    adsr->attackPhase = 0;
   27764:	2200      	movs	r2, #0
   27766:	6299      	str	r1, [r3, #40]	; 0x28
    adsr->decayPhase = 0;
    adsr->releasePhase = 0;
    adsr->gain = velocity;
   27768:	ed83 0a0c 	vstr	s0, [r3, #48]	; 0x30
    adsr->attackPhase = 0;
   2776c:	63da      	str	r2, [r3, #60]	; 0x3c
    adsr->decayPhase = 0;
   2776e:	641a      	str	r2, [r3, #64]	; 0x40
    adsr->releasePhase = 0;
   27770:	645a      	str	r2, [r3, #68]	; 0x44
}
   27772:	4770      	bx	lr
        adsr->rampPhase = 0;
   27774:	2000      	movs	r0, #0
        adsr->rampPeak = adsr->next;
   27776:	695a      	ldr	r2, [r3, #20]
        adsr->whichStage = env_ramp;
   27778:	2105      	movs	r1, #5
        adsr->rampPhase = 0;
   2777a:	6498      	str	r0, [r3, #72]	; 0x48
        adsr->rampPeak = adsr->next;
   2777c:	635a      	str	r2, [r3, #52]	; 0x34
   2777e:	e7f1      	b.n	27764 <tADSR4_on+0x8>

00027780 <tADSR4_off>:

void tADSR4_off(tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
   27780:	6803      	ldr	r3, [r0, #0]

    if (adsr->whichStage == env_idle)
   27782:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   27784:	b11a      	cbz	r2, 2778e <tADSR4_off+0xe>
    {
        return;
    }
    else
    {
        adsr->whichStage = env_release;
   27786:	2104      	movs	r1, #4
        adsr->releasePeak = adsr->next;
   27788:	695a      	ldr	r2, [r3, #20]
        adsr->whichStage = env_release;
   2778a:	6299      	str	r1, [r3, #40]	; 0x28
        adsr->releasePeak = adsr->next;
   2778c:	639a      	str	r2, [r3, #56]	; 0x38
    }
}
   2778e:	4770      	bx	lr

00027790 <tADSR4_tick>:

float   tADSR4_tick(tADSR4* const adsrenv)
{
   27790:	b510      	push	{r4, lr}
    _tADSR4* adsr = *adsrenv;
   27792:	6804      	ldr	r4, [r0, #0]
{
   27794:	ed2d 8b02 	vpush	{d8}

    switch (adsr->whichStage)
   27798:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2779a:	3b01      	subs	r3, #1
   2779c:	2b04      	cmp	r3, #4
   2779e:	f200 808c 	bhi.w	278ba <tADSR4_tick+0x12a>
   277a2:	e8df f003 	tbb	[pc, r3]
   277a6:	4b22      	.short	0x4b22
   277a8:	6b3e      	.short	0x6b3e
   277aa:	03          	.byte	0x03
   277ab:	00          	.byte	0x00
    {
        case env_ramp:
            if (adsr->rampPhase > adsr->buff_sizeMinusOne)
   277ac:	edd4 7a03 	vldr	s15, [r4, #12]
   277b0:	ed94 1a12 	vldr	s2, [r4, #72]	; 0x48
   277b4:	eef8 7a67 	vcvt.f32.u32	s15, s15
   277b8:	eeb4 1ae7 	vcmpe.f32	s2, s15
   277bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   277c0:	f340 80e3 	ble.w	2798a <tADSR4_tick+0x1fa>
            {
                adsr->whichStage = env_attack;
                adsr->next = 0.0f;
   277c4:	eddf 7aa0 	vldr	s15, [pc, #640]	; 27a48 <tADSR4_tick+0x2b8>
                adsr->whichStage = env_attack;
   277c8:	2301      	movs	r3, #1
   277ca:	eeb0 8a67 	vmov.f32	s16, s15
   277ce:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = 0.0f;
   277d0:	edc4 7a05 	vstr	s15, [r4, #20]
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->rampPhase)+1)];
                }
                adsr->next = adsr->rampPeak * LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart);
            }

            adsr->rampPhase += adsr->rampInc;
   277d4:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
            // Increment envelope release;
            adsr->releasePhase += adsr->releaseInc;
            break;
    }
    return adsr->next;
}
   277d8:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->rampPhase += adsr->rampInc;
   277dc:	ee37 1a81 	vadd.f32	s2, s15, s2
   277e0:	ed84 1a12 	vstr	s2, [r4, #72]	; 0x48
}
   277e4:	ecbd 8b02 	vpop	{d8}
   277e8:	bd10      	pop	{r4, pc}
            if (adsr->attackPhase > adsr->buff_sizeMinusOne)
   277ea:	edd4 7a03 	vldr	s15, [r4, #12]
   277ee:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
   277f2:	eef8 7a67 	vcvt.f32.u32	s15, s15
   277f6:	ed94 8a0c 	vldr	s16, [r4, #48]	; 0x30
   277fa:	eeb4 1ae7 	vcmpe.f32	s2, s15
   277fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27802:	dd61      	ble.n	278c8 <tADSR4_tick+0x138>
                adsr->whichStage = env_decay;
   27804:	2302      	movs	r3, #2
                adsr->next = adsr->gain;
   27806:	ed84 8a05 	vstr	s16, [r4, #20]
                adsr->whichStage = env_decay;
   2780a:	62a3      	str	r3, [r4, #40]	; 0x28
            adsr->attackPhase += adsr->attackInc;
   2780c:	edd4 7a06 	vldr	s15, [r4, #24]
}
   27810:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->attackPhase += adsr->attackInc;
   27814:	ee37 1a81 	vadd.f32	s2, s15, s2
   27818:	ed84 1a0f 	vstr	s2, [r4, #60]	; 0x3c
}
   2781c:	ecbd 8b02 	vpop	{d8}
   27820:	bd10      	pop	{r4, pc}
            adsr->next = adsr->next * adsr->leakFactor;
   27822:	ed94 8a05 	vldr	s16, [r4, #20]
   27826:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2782a:	ee28 8a27 	vmul.f32	s16, s16, s15
}
   2782e:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->next = adsr->next * adsr->leakFactor;
   27832:	ed84 8a05 	vstr	s16, [r4, #20]
}
   27836:	ecbd 8b02 	vpop	{d8}
   2783a:	bd10      	pop	{r4, pc}
            if (adsr->decayPhase > adsr->buff_sizeMinusOne)
   2783c:	edd4 7a03 	vldr	s15, [r4, #12]
   27840:	ed94 1a10 	vldr	s2, [r4, #64]	; 0x40
   27844:	eef8 7a67 	vcvt.f32.u32	s15, s15
   27848:	eeb4 1ae7 	vcmpe.f32	s2, s15
   2784c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27850:	dd66      	ble.n	27920 <tADSR4_tick+0x190>
                adsr->next = adsr->gain * adsr->sustain;
   27852:	ed94 8a0c 	vldr	s16, [r4, #48]	; 0x30
                adsr->whichStage = env_sustain;
   27856:	2303      	movs	r3, #3
                adsr->next = adsr->gain * adsr->sustain;
   27858:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
                adsr->whichStage = env_sustain;
   2785c:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = adsr->gain * adsr->sustain;
   2785e:	ee28 8a27 	vmul.f32	s16, s16, s15
   27862:	ed84 8a05 	vstr	s16, [r4, #20]
            adsr->decayPhase += adsr->decayInc;
   27866:	edd4 7a07 	vldr	s15, [r4, #28]
}
   2786a:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->decayPhase += adsr->decayInc;
   2786e:	ee37 1a81 	vadd.f32	s2, s15, s2
   27872:	ed84 1a10 	vstr	s2, [r4, #64]	; 0x40
}
   27876:	ecbd 8b02 	vpop	{d8}
   2787a:	bd10      	pop	{r4, pc}
            if (adsr->releasePhase > adsr->buff_sizeMinusOne)
   2787c:	edd4 7a03 	vldr	s15, [r4, #12]
   27880:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
   27884:	eef8 7a67 	vcvt.f32.u32	s15, s15
   27888:	eeb4 1ae7 	vcmpe.f32	s2, s15
   2788c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27890:	f340 80a4 	ble.w	279dc <tADSR4_tick+0x24c>
                adsr->next = 0.0f;
   27894:	eddf 7a6c 	vldr	s15, [pc, #432]	; 27a48 <tADSR4_tick+0x2b8>
                adsr->whichStage = env_idle;
   27898:	2300      	movs	r3, #0
   2789a:	eeb0 8a67 	vmov.f32	s16, s15
   2789e:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = 0.0f;
   278a0:	edc4 7a05 	vstr	s15, [r4, #20]
            adsr->releasePhase += adsr->releaseInc;
   278a4:	edd4 7a08 	vldr	s15, [r4, #32]
}
   278a8:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->releasePhase += adsr->releaseInc;
   278ac:	ee37 1a81 	vadd.f32	s2, s15, s2
   278b0:	ed84 1a11 	vstr	s2, [r4, #68]	; 0x44
}
   278b4:	ecbd 8b02 	vpop	{d8}
   278b8:	bd10      	pop	{r4, pc}
   278ba:	ed94 8a05 	vldr	s16, [r4, #20]
   278be:	eeb0 0a48 	vmov.f32	s0, s16
   278c2:	ecbd 8b02 	vpop	{d8}
   278c6:	bd10      	pop	{r4, pc}
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   278c8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   278cc:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->attackPhase;
   278ce:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   278d2:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->attackPhase - intPart;
   278d6:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   278da:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->attackPhase - intPart;
   278de:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   278e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   278e6:	f100 80ab 	bmi.w	27a40 <tADSR4_tick+0x2b0>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->attackPhase)+1)];
   278ea:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   278ee:	ee17 3a90 	vmov	r3, s15
   278f2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   278f6:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->gain * (1.0f - LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart)); // inverted and backwards to get proper rising exponential shape/perception
   278fa:	ee16 3a90 	vmov	r3, s13
   278fe:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   27902:	ed92 0a00 	vldr	s0, [r2]
   27906:	f002 f845 	bl	29994 <LEAF_interpolation_linear>
   2790a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2790e:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
   27912:	ee37 0ac0 	vsub.f32	s0, s15, s0
   27916:	ee28 8a00 	vmul.f32	s16, s16, s0
   2791a:	ed84 8a05 	vstr	s16, [r4, #20]
   2791e:	e775      	b.n	2780c <tADSR4_tick+0x7c>
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   27920:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27924:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->decayPhase;
   27926:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   2792a:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->decayPhase - intPart;
   2792e:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   27932:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->decayPhase - intPart;
   27936:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   2793a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2793e:	d47c      	bmi.n	27a3a <tADSR4_tick+0x2aa>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->decayPhase)+1)];
   27940:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   27944:	ee17 3a90 	vmov	r3, s15
   27948:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2794c:	edd3 0a00 	vldr	s1, [r3]
                float interpValue = (LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart));
   27950:	ee16 3a90 	vmov	r3, s13
   27954:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   27958:	ed92 0a00 	vldr	s0, [r2]
   2795c:	f002 f81a 	bl	29994 <LEAF_interpolation_linear>
                adsr->next = (adsr->gain * (adsr->sustain + (interpValue * (1.0f - adsr->sustain)))) * adsr->leakFactor; // do interpolation !
   27960:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27964:	ed94 8a0b 	vldr	s16, [r4, #44]	; 0x2c
   27968:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2796c:	ee37 7a48 	vsub.f32	s14, s14, s16
   27970:	edd4 6a13 	vldr	s13, [r4, #76]	; 0x4c
   27974:	ed94 1a10 	vldr	s2, [r4, #64]	; 0x40
   27978:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2797c:	eea7 8a00 	vfma.f32	s16, s14, s0
   27980:	ee27 8a88 	vmul.f32	s16, s15, s16
   27984:	ed84 8a05 	vstr	s16, [r4, #20]
   27988:	e76d      	b.n	27866 <tADSR4_tick+0xd6>
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   2798a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2798e:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->rampPhase;
   27990:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   27994:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->rampPhase - intPart;
   27998:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   2799c:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->rampPhase - intPart;
   279a0:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   279a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   279a8:	d444      	bmi.n	27a34 <tADSR4_tick+0x2a4>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->rampPhase)+1)];
   279aa:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   279ae:	ee17 3a90 	vmov	r3, s15
   279b2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   279b6:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->rampPeak * LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart);
   279ba:	ee16 3a90 	vmov	r3, s13
   279be:	ed94 8a0d 	vldr	s16, [r4, #52]	; 0x34
   279c2:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   279c6:	ed92 0a00 	vldr	s0, [r2]
   279ca:	f001 ffe3 	bl	29994 <LEAF_interpolation_linear>
   279ce:	ee28 8a00 	vmul.f32	s16, s16, s0
   279d2:	ed94 1a12 	vldr	s2, [r4, #72]	; 0x48
   279d6:	ed84 8a05 	vstr	s16, [r4, #20]
   279da:	e6fb      	b.n	277d4 <tADSR4_tick+0x44>
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   279dc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   279e0:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->releasePhase;
   279e2:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   279e6:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->releasePhase - intPart;
   279ea:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   279ee:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->releasePhase - intPart;
   279f2:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   279f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   279fa:	d418      	bmi.n	27a2e <tADSR4_tick+0x29e>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->releasePhase)+1)];
   279fc:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   27a00:	ee17 3a90 	vmov	r3, s15
   27a04:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   27a08:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->releasePeak * (LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart)); // do interpolation !
   27a0c:	ee16 3a90 	vmov	r3, s13
   27a10:	ed94 8a0e 	vldr	s16, [r4, #56]	; 0x38
   27a14:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   27a18:	ed92 0a00 	vldr	s0, [r2]
   27a1c:	f001 ffba 	bl	29994 <LEAF_interpolation_linear>
   27a20:	ee28 8a00 	vmul.f32	s16, s16, s0
   27a24:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
   27a28:	ed84 8a05 	vstr	s16, [r4, #20]
   27a2c:	e73a      	b.n	278a4 <tADSR4_tick+0x114>
                    secondValue = 0.0f;
   27a2e:	eddf 0a06 	vldr	s1, [pc, #24]	; 27a48 <tADSR4_tick+0x2b8>
   27a32:	e7eb      	b.n	27a0c <tADSR4_tick+0x27c>
                    secondValue = 0.0f;
   27a34:	eddf 0a04 	vldr	s1, [pc, #16]	; 27a48 <tADSR4_tick+0x2b8>
   27a38:	e7bf      	b.n	279ba <tADSR4_tick+0x22a>
                    secondValue = 0.0f;
   27a3a:	eddf 0a03 	vldr	s1, [pc, #12]	; 27a48 <tADSR4_tick+0x2b8>
   27a3e:	e787      	b.n	27950 <tADSR4_tick+0x1c0>
                    secondValue = 0.0f;
   27a40:	eddf 0a01 	vldr	s1, [pc, #4]	; 27a48 <tADSR4_tick+0x2b8>
   27a44:	e759      	b.n	278fa <tADSR4_tick+0x16a>
   27a46:	bf00      	nop
   27a48:	00000000 	.word	0x00000000

00027a4c <tADSR4_tickNoInterp>:

float   tADSR4_tickNoInterp(tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
   27a4c:	6803      	ldr	r3, [r0, #0]

    switch (adsr->whichStage)
   27a4e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   27a50:	3a01      	subs	r2, #1
   27a52:	2a04      	cmp	r2, #4
   27a54:	d872      	bhi.n	27b3c <tADSR4_tickNoInterp+0xf0>
   27a56:	e8df f002 	tbb	[pc, r2]
   27a5a:	3d1c      	.short	0x3d1c
   27a5c:	5934      	.short	0x5934
   27a5e:	03          	.byte	0x03
   27a5f:	00          	.byte	0x00
    {
        case env_ramp:
            if (adsr->rampPhase > adsr->buff_sizeMinusOne)
   27a60:	edd3 7a03 	vldr	s15, [r3, #12]
   27a64:	edd3 6a12 	vldr	s13, [r3, #72]	; 0x48
   27a68:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   27a6c:	eef4 6ac7 	vcmpe.f32	s13, s14
   27a70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27a74:	f340 808b 	ble.w	27b8e <tADSR4_tickNoInterp+0x142>
            {
                adsr->whichStage = env_attack;
   27a78:	2201      	movs	r2, #1
                adsr->next = 0.0f;
   27a7a:	ed9f 0a53 	vldr	s0, [pc, #332]	; 27bc8 <tADSR4_tickNoInterp+0x17c>
                adsr->whichStage = env_attack;
   27a7e:	629a      	str	r2, [r3, #40]	; 0x28
            else
            {
                adsr->next = adsr->rampPeak * adsr->exp_buff[(uint32_t)adsr->rampPhase];
            }

            adsr->rampPhase += adsr->rampInc;
   27a80:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
   27a84:	ed83 0a05 	vstr	s0, [r3, #20]
   27a88:	ee77 7aa6 	vadd.f32	s15, s15, s13
   27a8c:	edc3 7a12 	vstr	s15, [r3, #72]	; 0x48
            break;
   27a90:	4770      	bx	lr


        case env_attack:

            // If attack done, time to turn around.
            if (adsr->attackPhase > adsr->buff_sizeMinusOne)
   27a92:	edd3 7a03 	vldr	s15, [r3, #12]
   27a96:	edd3 6a0f 	vldr	s13, [r3, #60]	; 0x3c
   27a9a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   27a9e:	ed93 0a0c 	vldr	s0, [r3, #48]	; 0x30
   27aa2:	eef4 6ac7 	vcmpe.f32	s13, s14
   27aa6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27aaa:	dd4a      	ble.n	27b42 <tADSR4_tickNoInterp+0xf6>
            {
                adsr->whichStage = env_decay;
   27aac:	2202      	movs	r2, #2
   27aae:	629a      	str	r2, [r3, #40]	; 0x28
            {
                adsr->next = adsr->gain * (1.0f - adsr->exp_buff[(uint32_t)adsr->attackPhase]); // inverted and backwards to get proper rising exponential shape/perception
            }

            // Increment ADSR attack.
            adsr->attackPhase += adsr->attackInc;
   27ab0:	edd3 7a06 	vldr	s15, [r3, #24]
   27ab4:	ed83 0a05 	vstr	s0, [r3, #20]
   27ab8:	ee77 7aa6 	vadd.f32	s15, s15, s13
   27abc:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
            break;
   27ac0:	4770      	bx	lr
            // Increment ADSR decay.
            adsr->decayPhase += adsr->decayInc;
            break;

        case env_sustain:
            adsr->next = adsr->next * adsr->leakFactor;
   27ac2:	ed93 0a05 	vldr	s0, [r3, #20]
   27ac6:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
   27aca:	ee20 0a27 	vmul.f32	s0, s0, s15
   27ace:	ed83 0a05 	vstr	s0, [r3, #20]
            break;
   27ad2:	4770      	bx	lr
            if (adsr->decayPhase > adsr->buff_sizeMinusOne)
   27ad4:	edd3 7a03 	vldr	s15, [r3, #12]
   27ad8:	edd3 6a10 	vldr	s13, [r3, #64]	; 0x40
   27adc:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   27ae0:	ed93 0a0b 	vldr	s0, [r3, #44]	; 0x2c
   27ae4:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
   27ae8:	eef4 6ac7 	vcmpe.f32	s13, s14
   27aec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27af0:	dd37      	ble.n	27b62 <tADSR4_tickNoInterp+0x116>
                adsr->next = adsr->gain * adsr->sustain;
   27af2:	ee20 0a27 	vmul.f32	s0, s0, s15
                adsr->whichStage = env_sustain;
   27af6:	2203      	movs	r2, #3
   27af8:	629a      	str	r2, [r3, #40]	; 0x28
            adsr->decayPhase += adsr->decayInc;
   27afa:	edd3 7a07 	vldr	s15, [r3, #28]
   27afe:	ed83 0a05 	vstr	s0, [r3, #20]
   27b02:	ee77 7aa6 	vadd.f32	s15, s15, s13
   27b06:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
            break;
   27b0a:	4770      	bx	lr

        case env_release:
            // If release done, finish.
            if (adsr->releasePhase > adsr->buff_sizeMinusOne)
   27b0c:	edd3 7a03 	vldr	s15, [r3, #12]
   27b10:	edd3 6a11 	vldr	s13, [r3, #68]	; 0x44
   27b14:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   27b18:	eef4 6ac7 	vcmpe.f32	s13, s14
   27b1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27b20:	dd43      	ble.n	27baa <tADSR4_tickNoInterp+0x15e>
            {
                adsr->whichStage = env_idle;
   27b22:	2200      	movs	r2, #0
                adsr->next = 0.0f;
   27b24:	ed9f 0a28 	vldr	s0, [pc, #160]	; 27bc8 <tADSR4_tickNoInterp+0x17c>
                adsr->whichStage = env_idle;
   27b28:	629a      	str	r2, [r3, #40]	; 0x28
            else {
                adsr->next = adsr->releasePeak * adsr->exp_buff[(uint32_t)adsr->releasePhase];
            }

            // Increment envelope release;
            adsr->releasePhase += adsr->releaseInc;
   27b2a:	edd3 7a08 	vldr	s15, [r3, #32]
   27b2e:	ed83 0a05 	vstr	s0, [r3, #20]
   27b32:	ee77 7aa6 	vadd.f32	s15, s15, s13
   27b36:	edc3 7a11 	vstr	s15, [r3, #68]	; 0x44
            break;
    }
    return adsr->next;
}
   27b3a:	4770      	bx	lr
   27b3c:	ed93 0a05 	vldr	s0, [r3, #20]
   27b40:	4770      	bx	lr
                adsr->next = adsr->gain * (1.0f - adsr->exp_buff[(uint32_t)adsr->attackPhase]); // inverted and backwards to get proper rising exponential shape/perception
   27b42:	eebc 7ae6 	vcvt.u32.f32	s14, s13
   27b46:	685a      	ldr	r2, [r3, #4]
   27b48:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27b4c:	ee17 1a10 	vmov	r1, s14
   27b50:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   27b54:	ed92 7a00 	vldr	s14, [r2]
   27b58:	ee77 7ac7 	vsub.f32	s15, s15, s14
   27b5c:	ee20 0a27 	vmul.f32	s0, s0, s15
   27b60:	e7a6      	b.n	27ab0 <tADSR4_tickNoInterp+0x64>
                adsr->next = (adsr->gain * (adsr->sustain + (adsr->exp_buff[(uint32_t)adsr->decayPhase] * (1.0f - adsr->sustain)))) * adsr->leakFactor;
   27b62:	eefc 5ae6 	vcvt.u32.f32	s11, s13
   27b66:	685a      	ldr	r2, [r3, #4]
   27b68:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27b6c:	ed93 6a13 	vldr	s12, [r3, #76]	; 0x4c
   27b70:	ee15 1a90 	vmov	r1, s11
   27b74:	ee67 7a86 	vmul.f32	s15, s15, s12
   27b78:	ee37 7a40 	vsub.f32	s14, s14, s0
   27b7c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   27b80:	ed92 6a00 	vldr	s12, [r2]
   27b84:	eea6 0a07 	vfma.f32	s0, s12, s14
   27b88:	ee20 0a27 	vmul.f32	s0, s0, s15
   27b8c:	e7b5      	b.n	27afa <tADSR4_tickNoInterp+0xae>
                adsr->next = adsr->rampPeak * adsr->exp_buff[(uint32_t)adsr->rampPhase];
   27b8e:	eebc 7ae6 	vcvt.u32.f32	s14, s13
   27b92:	685a      	ldr	r2, [r3, #4]
   27b94:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
   27b98:	ee17 1a10 	vmov	r1, s14
   27b9c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   27ba0:	ed92 0a00 	vldr	s0, [r2]
   27ba4:	ee20 0a27 	vmul.f32	s0, s0, s15
   27ba8:	e76a      	b.n	27a80 <tADSR4_tickNoInterp+0x34>
                adsr->next = adsr->releasePeak * adsr->exp_buff[(uint32_t)adsr->releasePhase];
   27baa:	eebc 7ae6 	vcvt.u32.f32	s14, s13
   27bae:	685a      	ldr	r2, [r3, #4]
   27bb0:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
   27bb4:	ee17 1a10 	vmov	r1, s14
   27bb8:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   27bbc:	ed92 0a00 	vldr	s0, [r2]
   27bc0:	ee20 0a27 	vmul.f32	s0, s0, s15
   27bc4:	e7b1      	b.n	27b2a <tADSR4_tickNoInterp+0xde>
   27bc6:	bf00      	nop
   27bc8:	00000000 	.word	0x00000000

00027bcc <tRamp_init>:


/////-----------------
/* Ramp */
void    tRamp_init(tRamp* const r, float time, int samples_per_tick)
{
   27bcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tRamp_initToPool(r, time, samples_per_tick, &leaf.mempool);
}

void    tRamp_initToPool    (tRamp* const r, float time, int samples_per_tick, tMempool* const mp)
{
    _tMempool* m = *mp;
   27bce:	4d17      	ldr	r5, [pc, #92]	; (27c2c <tRamp_init+0x60>)
{
   27bd0:	4607      	mov	r7, r0
   27bd2:	460c      	mov	r4, r1
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27bd4:	2024      	movs	r0, #36	; 0x24
    _tMempool* m = *mp;
   27bd6:	69ae      	ldr	r6, [r5, #24]
{
   27bd8:	ed2d 8b02 	vpush	{d8}
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27bdc:	4631      	mov	r1, r6
{
   27bde:	eeb0 8a40 	vmov.f32	s16, s0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27be2:	f001 ffa1 	bl	29b28 <mpool_alloc>
    ramp->mempool = m;
    
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27be6:	ed9f 6a12 	vldr	s12, [pc, #72]	; 27c30 <tRamp_init+0x64>
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27bea:	6038      	str	r0, [r7, #0]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27bec:	ee07 4a90 	vmov	s15, r4
    ramp->mempool = m;
   27bf0:	6006      	str	r6, [r0, #0]
    ramp->curr = 0.0f;
   27bf2:	2300      	movs	r3, #0
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27bf4:	edd5 6a00 	vldr	s13, [r5]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27bf8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    }
    else
    {
        ramp->time = time;
    }
    ramp->samples_per_tick = samples_per_tick;
   27bfc:	6204      	str	r4, [r0, #32]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27bfe:	ee86 7a26 	vdiv.f32	s14, s12, s13
    ramp->curr = 0.0f;
   27c02:	6103      	str	r3, [r0, #16]
    ramp->dest = 0.0f;
   27c04:	6143      	str	r3, [r0, #20]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
    ramp->inc = (ramp->dest - ramp->curr) * ramp->factor;
   27c06:	6043      	str	r3, [r0, #4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27c08:	ee67 7a87 	vmul.f32	s15, s15, s14
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27c0c:	ed80 7a02 	vstr	s14, [r0, #8]
   27c10:	fe88 0a27 	vmaxnm.f32	s0, s16, s15
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   27c14:	ee87 7a80 	vdiv.f32	s14, s15, s0
   27c18:	ed80 0a06 	vstr	s0, [r0, #24]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27c1c:	edc0 7a03 	vstr	s15, [r0, #12]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   27c20:	ed80 7a07 	vstr	s14, [r0, #28]
}
   27c24:	ecbd 8b02 	vpop	{d8}
   27c28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   27c2a:	bf00      	nop
   27c2c:	020fbd68 	.word	0x020fbd68
   27c30:	4479ffff 	.word	0x4479ffff

00027c34 <tRamp_initToPool>:
{
   27c34:	b570      	push	{r4, r5, r6, lr}
    _tMempool* m = *mp;
   27c36:	6815      	ldr	r5, [r2, #0]
{
   27c38:	460c      	mov	r4, r1
   27c3a:	4606      	mov	r6, r0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27c3c:	2024      	movs	r0, #36	; 0x24
   27c3e:	4629      	mov	r1, r5
{
   27c40:	ed2d 8b02 	vpush	{d8}
   27c44:	eeb0 8a40 	vmov.f32	s16, s0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27c48:	f001 ff6e 	bl	29b28 <mpool_alloc>
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27c4c:	4b11      	ldr	r3, [pc, #68]	; (27c94 <tRamp_initToPool+0x60>)
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27c4e:	ee07 4a90 	vmov	s15, r4
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27c52:	6030      	str	r0, [r6, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27c54:	ed9f 6a10 	vldr	s12, [pc, #64]	; 27c98 <tRamp_initToPool+0x64>
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27c58:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    ramp->mempool = m;
   27c5c:	6005      	str	r5, [r0, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27c5e:	edd3 6a00 	vldr	s13, [r3]
    ramp->curr = 0.0f;
   27c62:	2300      	movs	r3, #0
    ramp->samples_per_tick = samples_per_tick;
   27c64:	6204      	str	r4, [r0, #32]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27c66:	ee86 7a26 	vdiv.f32	s14, s12, s13
    ramp->curr = 0.0f;
   27c6a:	6103      	str	r3, [r0, #16]
    ramp->dest = 0.0f;
   27c6c:	6143      	str	r3, [r0, #20]
    ramp->inc = (ramp->dest - ramp->curr) * ramp->factor;
   27c6e:	6043      	str	r3, [r0, #4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27c70:	ee67 7a87 	vmul.f32	s15, s15, s14
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27c74:	ed80 7a02 	vstr	s14, [r0, #8]
   27c78:	fe87 0a88 	vmaxnm.f32	s0, s15, s16
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   27c7c:	ee87 7a80 	vdiv.f32	s14, s15, s0
   27c80:	ed80 0a06 	vstr	s0, [r0, #24]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27c84:	edc0 7a03 	vstr	s15, [r0, #12]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   27c88:	ed80 7a07 	vstr	s14, [r0, #28]
}
   27c8c:	ecbd 8b02 	vpop	{d8}
   27c90:	bd70      	pop	{r4, r5, r6, pc}
   27c92:	bf00      	nop
   27c94:	020fbd68 	.word	0x020fbd68
   27c98:	4479ffff 	.word	0x4479ffff

00027c9c <tRamp_free>:

void    tRamp_free (tRamp* const r)
{
    _tRamp* ramp = *r;
   27c9c:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)ramp, ramp->mempool);
   27c9e:	6801      	ldr	r1, [r0, #0]
   27ca0:	f001 bfea 	b.w	29c78 <mpool_free>

00027ca4 <tRamp_setDest>:

}

void     tRamp_setDest(tRamp* const ramp, float dest)
{
    _tRamp* r = *ramp;
   27ca4:	6803      	ldr	r3, [r0, #0]
    r->dest = dest;
    r->inc = (r->dest - r->curr) * r->factor;
   27ca6:	edd3 7a04 	vldr	s15, [r3, #16]
   27caa:	ed93 7a07 	vldr	s14, [r3, #28]
   27cae:	ee70 7a67 	vsub.f32	s15, s0, s15
    r->dest = dest;
   27cb2:	ed83 0a05 	vstr	s0, [r3, #20]
    r->inc = (r->dest - r->curr) * r->factor;
   27cb6:	ee67 7a87 	vmul.f32	s15, s15, s14
   27cba:	edc3 7a01 	vstr	s15, [r3, #4]
}
   27cbe:	4770      	bx	lr

00027cc0 <tRamp_setVal>:

void     tRamp_setVal(tRamp* const ramp, float val)
{
    _tRamp* r = *ramp;
   27cc0:	6803      	ldr	r3, [r0, #0]
    r->curr = val;
    r->inc = (r->dest - r->curr) * r->factor;
   27cc2:	edd3 7a05 	vldr	s15, [r3, #20]
   27cc6:	ed93 7a07 	vldr	s14, [r3, #28]
   27cca:	ee77 7ac0 	vsub.f32	s15, s15, s0
    r->curr = val;
   27cce:	ed83 0a04 	vstr	s0, [r3, #16]
    r->inc = (r->dest - r->curr) * r->factor;
   27cd2:	ee67 7a87 	vmul.f32	s15, s15, s14
   27cd6:	edc3 7a01 	vstr	s15, [r3, #4]
}
   27cda:	4770      	bx	lr

00027cdc <tRamp_tick>:

float   tRamp_tick(tRamp* const ramp)
{
    _tRamp* r = *ramp;
   27cdc:	6803      	ldr	r3, [r0, #0]
    
    r->curr += r->inc;
   27cde:	edd3 7a01 	vldr	s15, [r3, #4]
   27ce2:	ed93 0a04 	vldr	s0, [r3, #16]
    
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
   27ce6:	eef5 7a40 	vcmp.f32	s15, #0.0
   27cea:	ed93 7a05 	vldr	s14, [r3, #20]
    r->curr += r->inc;
   27cee:	ee37 0a80 	vadd.f32	s0, s15, s0
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
   27cf2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    r->curr += r->inc;
   27cf6:	ed83 0a04 	vstr	s0, [r3, #16]
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
   27cfa:	dd04      	ble.n	27d06 <tRamp_tick+0x2a>
   27cfc:	eeb4 0ac7 	vcmpe.f32	s0, s14
   27d00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27d04:	da0a      	bge.n	27d1c <tRamp_tick+0x40>
   27d06:	eef5 7a40 	vcmp.f32	s15, #0.0
   27d0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27d0e:	d504      	bpl.n	27d1a <tRamp_tick+0x3e>
   27d10:	eeb4 0a47 	vcmp.f32	s0, s14
   27d14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27d18:	d900      	bls.n	27d1c <tRamp_tick+0x40>
		r->inc = 0.0f;
		r->curr=r->dest;
	}
    
    return r->curr;
}
   27d1a:	4770      	bx	lr
		r->inc = 0.0f;
   27d1c:	2200      	movs	r2, #0
		r->curr=r->dest;
   27d1e:	eeb0 0a47 	vmov.f32	s0, s14
   27d22:	ed83 7a04 	vstr	s14, [r3, #16]
		r->inc = 0.0f;
   27d26:	605a      	str	r2, [r3, #4]
}
   27d28:	4770      	bx	lr
   27d2a:	bf00      	nop

00027d2c <tRamp_sample>:

float   tRamp_sample(tRamp* const ramp)
{
    _tRamp* r = *ramp;
    return r->curr;
   27d2c:	6803      	ldr	r3, [r0, #0]
}
   27d2e:	ed93 0a04 	vldr	s0, [r3, #16]
   27d32:	4770      	bx	lr

00027d34 <tExpSmooth_init>:



/* Exponential Smoother */
void    tExpSmooth_init(tExpSmooth* const expsmooth, float val, float factor)
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   27d34:	b538      	push	{r3, r4, r5, lr}
    tExpSmooth_initToPool(expsmooth, val, factor, &leaf.mempool);
}

void    tExpSmooth_initToPool   (tExpSmooth* const expsmooth, float val, float factor, tMempool* const mp)
{
    _tMempool* m = *mp;
   27d36:	4b12      	ldr	r3, [pc, #72]	; (27d80 <tExpSmooth_init+0x4c>)
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   27d38:	4605      	mov	r5, r0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   27d3a:	2014      	movs	r0, #20
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   27d3c:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   27d40:	699c      	ldr	r4, [r3, #24]
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   27d42:	eef0 8a40 	vmov.f32	s17, s0
   27d46:	eeb0 8a60 	vmov.f32	s16, s1
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   27d4a:	4621      	mov	r1, r4
   27d4c:	f001 feec 	bl	29b28 <mpool_alloc>
   27d50:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27d54:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 27d84 <tExpSmooth_init+0x50>
   27d58:	6028      	str	r0, [r5, #0]
   27d5a:	fec8 0a67 	vminnm.f32	s1, s16, s15
   27d5e:	fec0 0a87 	vmaxnm.f32	s1, s1, s14
    smooth->curr=val;
    smooth->dest=val;
    if (factor<0) factor=0;
    if (factor>1) factor=1;
    smooth->factor=factor;
    smooth->oneminusfactor=1.0f-factor;
   27d62:	ee77 7ae0 	vsub.f32	s15, s15, s1
    smooth->mempool = m;
   27d66:	6004      	str	r4, [r0, #0]
    smooth->curr=val;
   27d68:	edc0 8a03 	vstr	s17, [r0, #12]
    smooth->dest=val;
   27d6c:	edc0 8a04 	vstr	s17, [r0, #16]
    smooth->factor=factor;
   27d70:	edc0 0a01 	vstr	s1, [r0, #4]
    smooth->oneminusfactor=1.0f-factor;
   27d74:	edc0 7a02 	vstr	s15, [r0, #8]
}
   27d78:	ecbd 8b02 	vpop	{d8}
   27d7c:	bd38      	pop	{r3, r4, r5, pc}
   27d7e:	bf00      	nop
   27d80:	020fbd68 	.word	0x020fbd68
   27d84:	00000000 	.word	0x00000000

00027d88 <tExpSmooth_initToPool>:
{
   27d88:	b538      	push	{r3, r4, r5, lr}
   27d8a:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   27d8e:	680c      	ldr	r4, [r1, #0]
{
   27d90:	4605      	mov	r5, r0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   27d92:	2014      	movs	r0, #20
{
   27d94:	eef0 8a40 	vmov.f32	s17, s0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   27d98:	4621      	mov	r1, r4
{
   27d9a:	eeb0 8a60 	vmov.f32	s16, s1
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   27d9e:	f001 fec3 	bl	29b28 <mpool_alloc>
   27da2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27da6:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 27dd0 <tExpSmooth_initToPool+0x48>
   27daa:	6028      	str	r0, [r5, #0]
   27dac:	fec8 0a67 	vminnm.f32	s1, s16, s15
   27db0:	fec0 0a87 	vmaxnm.f32	s1, s1, s14
    smooth->oneminusfactor=1.0f-factor;
   27db4:	ee77 7ae0 	vsub.f32	s15, s15, s1
    smooth->mempool = m;
   27db8:	6004      	str	r4, [r0, #0]
    smooth->curr=val;
   27dba:	edc0 8a03 	vstr	s17, [r0, #12]
    smooth->dest=val;
   27dbe:	edc0 8a04 	vstr	s17, [r0, #16]
    smooth->factor=factor;
   27dc2:	edc0 0a01 	vstr	s1, [r0, #4]
    smooth->oneminusfactor=1.0f-factor;
   27dc6:	edc0 7a02 	vstr	s15, [r0, #8]
}
   27dca:	ecbd 8b02 	vpop	{d8}
   27dce:	bd38      	pop	{r3, r4, r5, pc}
   27dd0:	00000000 	.word	0x00000000

00027dd4 <tExpSmooth_free>:

void    tExpSmooth_free (tExpSmooth* const expsmooth)
{
    _tExpSmooth* smooth = *expsmooth;
   27dd4:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)smooth, smooth->mempool);
   27dd6:	6801      	ldr	r1, [r0, #0]
   27dd8:	f001 bf4e 	b.w	29c78 <mpool_free>

00027ddc <tExpSmooth_setFactor>:
}

void     tExpSmooth_setFactor(tExpSmooth* const expsmooth, float factor)
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   27ddc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27de0:	ed9f 7a06 	vldr	s14, [pc, #24]	; 27dfc <tExpSmooth_setFactor+0x20>
    _tExpSmooth* smooth = *expsmooth;
   27de4:	6803      	ldr	r3, [r0, #0]
   27de6:	fe80 0a67 	vminnm.f32	s0, s0, s15
   27dea:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
	if (factor<0)
		factor=0;
	else
		if (factor>1) factor=1;
	smooth->factor=factor;
	smooth->oneminusfactor=1.0f-factor;
   27dee:	ee77 7ac0 	vsub.f32	s15, s15, s0
	smooth->factor=factor;
   27df2:	ed83 0a01 	vstr	s0, [r3, #4]
	smooth->oneminusfactor=1.0f-factor;
   27df6:	edc3 7a02 	vstr	s15, [r3, #8]
}
   27dfa:	4770      	bx	lr
   27dfc:	00000000 	.word	0x00000000

00027e00 <tExpSmooth_setDest>:

void     tExpSmooth_setDest(tExpSmooth* const expsmooth, float dest)
{
    _tExpSmooth* smooth = *expsmooth;
   27e00:	6803      	ldr	r3, [r0, #0]
	smooth->dest=dest;
   27e02:	ed83 0a04 	vstr	s0, [r3, #16]
}
   27e06:	4770      	bx	lr

00027e08 <tExpSmooth_setValAndDest>:
	smooth->curr=val;
}

void     tExpSmooth_setValAndDest(tExpSmooth* const expsmooth, float val)
{
    _tExpSmooth* smooth = *expsmooth;
   27e08:	6803      	ldr	r3, [r0, #0]
	smooth->curr=val;
   27e0a:	ed83 0a03 	vstr	s0, [r3, #12]
	smooth->dest=val;
   27e0e:	ed83 0a04 	vstr	s0, [r3, #16]
}
   27e12:	4770      	bx	lr

00027e14 <tExpSmooth_tick>:

float   tExpSmooth_tick(tExpSmooth* const expsmooth)
{
    _tExpSmooth* smooth = *expsmooth;
   27e14:	6803      	ldr	r3, [r0, #0]
    smooth->curr = smooth->factor*smooth->dest+smooth->oneminusfactor*smooth->curr;
   27e16:	edd3 7a03 	vldr	s15, [r3, #12]
   27e1a:	ed93 0a02 	vldr	s0, [r3, #8]
   27e1e:	ed93 7a01 	vldr	s14, [r3, #4]
   27e22:	ee20 0a27 	vmul.f32	s0, s0, s15
   27e26:	edd3 7a04 	vldr	s15, [r3, #16]
   27e2a:	eea7 0a27 	vfma.f32	s0, s14, s15
   27e2e:	ed83 0a03 	vstr	s0, [r3, #12]
    return smooth->curr;
}
   27e32:	4770      	bx	lr

00027e34 <tSlide_initToPool>:
{
	tSlide_initToPool    (sl, upSlide, downSlide, &leaf.mempool);
}

void    tSlide_initToPool    (tSlide* const sl, float upSlide, float downSlide, tMempool* const mp)
{
   27e34:	b538      	push	{r3, r4, r5, lr}
   27e36:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   27e3a:	680c      	ldr	r4, [r1, #0]
{
   27e3c:	4605      	mov	r5, r0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   27e3e:	201c      	movs	r0, #28
{
   27e40:	eeb0 8a60 	vmov.f32	s16, s1
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   27e44:	4621      	mov	r1, r4
{
   27e46:	eef0 8a40 	vmov.f32	s17, s0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   27e4a:	f001 fe6d 	bl	29b28 <mpool_alloc>

    if (downSlide < 1.0f)
    {
    	downSlide = 1.0f;
    }
    s->invUpSlide = 1.0f / upSlide;
   27e4e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    s->prevIn = 0.0f;
   27e52:	2300      	movs	r3, #0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   27e54:	6028      	str	r0, [r5, #0]
    s->mempool = m;
   27e56:	6004      	str	r4, [r0, #0]
    s->invUpSlide = 1.0f / upSlide;
   27e58:	fec8 8aa7 	vmaxnm.f32	s17, s17, s15
    s->invDownSlide = 1.0f / downSlide;
   27e5c:	fec8 0a27 	vmaxnm.f32	s1, s16, s15
    s->invUpSlide = 1.0f / upSlide;
   27e60:	eec7 6aa8 	vdiv.f32	s13, s15, s17
    s->prevIn = 0.0f;
   27e64:	60c3      	str	r3, [r0, #12]
    s->currentOut = 0.0f;
   27e66:	6083      	str	r3, [r0, #8]
    s->prevOut = 0.0f;
   27e68:	6043      	str	r3, [r0, #4]
    s->dest = 0.0f;
   27e6a:	6183      	str	r3, [r0, #24]
    s->invDownSlide = 1.0f / downSlide;
   27e6c:	ee87 7aa0 	vdiv.f32	s14, s15, s1
    s->invUpSlide = 1.0f / upSlide;
   27e70:	edc0 6a04 	vstr	s13, [r0, #16]
    s->invDownSlide = 1.0f / downSlide;
   27e74:	ed80 7a05 	vstr	s14, [r0, #20]
}
   27e78:	ecbd 8b02 	vpop	{d8}
   27e7c:	bd38      	pop	{r3, r4, r5, pc}
   27e7e:	bf00      	nop

00027e80 <tSlide_free>:

void    tSlide_free  (tSlide* const sl)
{
    _tSlide* s = *sl;
   27e80:	6800      	ldr	r0, [r0, #0]

    mpool_free((char*)s, s->mempool);
   27e82:	6801      	ldr	r1, [r0, #0]
   27e84:	f001 bef8 	b.w	29c78 <mpool_free>

00027e88 <tSlide_setDownSlide>:
}

void tSlide_setDownSlide(tSlide* const sl, float downSlide)
{
	_tSlide* s = *sl;
	s->invDownSlide = 1.0f / downSlide;
   27e88:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	_tSlide* s = *sl;
   27e8c:	6803      	ldr	r3, [r0, #0]
	s->invDownSlide = 1.0f / downSlide;
   27e8e:	ee87 0a80 	vdiv.f32	s0, s15, s0
   27e92:	ed83 0a05 	vstr	s0, [r3, #20]
}
   27e96:	4770      	bx	lr

00027e98 <tSlide_setDest>:

void tSlide_setDest(tSlide* const sl, float dest)
{
	_tSlide* s = *sl;
   27e98:	6803      	ldr	r3, [r0, #0]
	s->dest = dest;
   27e9a:	ed83 0a06 	vstr	s0, [r3, #24]
}
   27e9e:	4770      	bx	lr

00027ea0 <tSlide_tickNoInput>:

float tSlide_tickNoInput(tSlide* const sl)
{
	_tSlide* s = *sl;
   27ea0:	6803      	ldr	r3, [r0, #0]
	float in = s->dest;

	if (in >= s->prevOut)
   27ea2:	edd3 7a01 	vldr	s15, [r3, #4]
	float in = s->dest;
   27ea6:	ed93 7a06 	vldr	s14, [r3, #24]
	if (in >= s->prevOut)
   27eaa:	eef4 7ac7 	vcmpe.f32	s15, s14
   27eae:	ee77 6a67 	vsub.f32	s13, s14, s15
   27eb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	{
		s->currentOut = s->prevOut + ((in - s->prevOut) * s->invUpSlide);
   27eb6:	bf94      	ite	ls
   27eb8:	ed93 6a04 	vldrls	s12, [r3, #16]
	}
	else
	{
		s->currentOut = s->prevOut + ((in - s->prevOut) * s->invDownSlide);
   27ebc:	ed93 6a05 	vldrhi	s12, [r3, #20]
   27ec0:	eee6 7a26 	vfma.f32	s15, s12, s13
	}
#ifdef NO_DENORMAL_CHECK
#else
	if (s->currentOut < VSF) s->currentOut = 0.0f;
   27ec4:	eddf 6a0e 	vldr	s13, [pc, #56]	; 27f00 <tSlide_tickNoInput+0x60>
   27ec8:	eef4 7ae6 	vcmpe.f32	s15, s13
   27ecc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27ed0:	d50c      	bpl.n	27eec <tSlide_tickNoInput+0x4c>
   27ed2:	eddf 6a0c 	vldr	s13, [pc, #48]	; 27f04 <tSlide_tickNoInput+0x64>
#endif
	s->prevIn = in;
   27ed6:	ed83 7a03 	vstr	s14, [r3, #12]
	if (s->currentOut < VSF) s->currentOut = 0.0f;
   27eda:	eef0 7a66 	vmov.f32	s15, s13
   27ede:	edc3 6a02 	vstr	s13, [r3, #8]
	s->prevOut = s->currentOut;
	return s->currentOut;
}
   27ee2:	eeb0 0a67 	vmov.f32	s0, s15
	s->prevOut = s->currentOut;
   27ee6:	edc3 7a01 	vstr	s15, [r3, #4]
}
   27eea:	4770      	bx	lr
   27eec:	edc3 7a02 	vstr	s15, [r3, #8]
   27ef0:	eeb0 0a67 	vmov.f32	s0, s15
	s->prevIn = in;
   27ef4:	ed83 7a03 	vstr	s14, [r3, #12]
	s->prevOut = s->currentOut;
   27ef8:	edc3 7a01 	vstr	s15, [r3, #4]
}
   27efc:	4770      	bx	lr
   27efe:	bf00      	nop
   27f00:	006ce3ee 	.word	0x006ce3ee
   27f04:	00000000 	.word	0x00000000

00027f08 <tAllpass_initToPool>:
{
    tAllpass_initToPool(ft, initDelay, maxDelay, &leaf.mempool);
}

void    tAllpass_initToPool     (tAllpass* const ft, float initDelay, uint32_t maxDelay, tMempool* const mp)
{
   27f08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27f0c:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   27f10:	6814      	ldr	r4, [r2, #0]
{
   27f12:	4615      	mov	r5, r2
   27f14:	4607      	mov	r7, r0
   27f16:	4688      	mov	r8, r1
   27f18:	eeb0 8a40 	vmov.f32	s16, s0
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   27f1c:	4621      	mov	r1, r4
   27f1e:	2010      	movs	r0, #16
    f->mempool = m;
    
    f->gain = 0.7f;
   27f20:	4e09      	ldr	r6, [pc, #36]	; (27f48 <tAllpass_initToPool+0x40>)
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   27f22:	f001 fe01 	bl	29b28 <mpool_alloc>
    
    f->lastOut = 0.0f;
    
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   27f26:	462a      	mov	r2, r5
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   27f28:	4603      	mov	r3, r0
    f->lastOut = 0.0f;
   27f2a:	2500      	movs	r5, #0
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   27f2c:	6038      	str	r0, [r7, #0]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   27f2e:	eeb0 0a48 	vmov.f32	s0, s16
    f->mempool = m;
   27f32:	6004      	str	r4, [r0, #0]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   27f34:	4641      	mov	r1, r8
    f->gain = 0.7f;
   27f36:	605e      	str	r6, [r3, #4]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   27f38:	3008      	adds	r0, #8
    f->lastOut = 0.0f;
   27f3a:	60dd      	str	r5, [r3, #12]
}
   27f3c:	ecbd 8b02 	vpop	{d8}
   27f40:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   27f44:	f7fc beb4 	b.w	24cb0 <tLinearDelay_initToPool>
   27f48:	3f333333 	.word	0x3f333333

00027f4c <tAllpass_free>:

void    tAllpass_free  (tAllpass* const ft)
{
   27f4c:	b510      	push	{r4, lr}
    _tAllpass* f = *ft;
   27f4e:	6804      	ldr	r4, [r0, #0]
    
    tLinearDelay_free(&f->delay);
   27f50:	f104 0008 	add.w	r0, r4, #8
   27f54:	f7fc ff22 	bl	24d9c <tLinearDelay_free>
    mpool_free((char*)f, f->mempool);
   27f58:	6821      	ldr	r1, [r4, #0]
   27f5a:	4620      	mov	r0, r4
}
   27f5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)f, f->mempool);
   27f60:	f001 be8a 	b.w	29c78 <mpool_free>

00027f64 <tAllpass_setDelay>:

void    tAllpass_setDelay(tAllpass* const ft, float delay)
{
    _tAllpass* f = *ft;
    
    tLinearDelay_setDelay(&f->delay, delay);
   27f64:	6800      	ldr	r0, [r0, #0]
   27f66:	3008      	adds	r0, #8
   27f68:	f7fc bfaa 	b.w	24ec0 <tLinearDelay_setDelay>

00027f6c <tAllpass_setGain>:
}

void    tAllpass_setGain(tAllpass* const ft, float gain)
{
    _tAllpass* f = *ft;
   27f6c:	6803      	ldr	r3, [r0, #0]
    
    f->gain = gain;
   27f6e:	ed83 0a01 	vstr	s0, [r3, #4]
}
   27f72:	4770      	bx	lr

00027f74 <tAllpass_tick>:

float   tAllpass_tick(tAllpass* const ft, float input)
{
   27f74:	b510      	push	{r4, lr}
   27f76:	ed2d 8b02 	vpush	{d8}
    _tAllpass* f = *ft;
   27f7a:	6804      	ldr	r4, [r0, #0]
{
   27f7c:	eeb0 8a40 	vmov.f32	s16, s0
    
    float s1 = (-f->gain) * f->lastOut + input;
    
    float s2 = tLinearDelay_tick(&f->delay, s1) + (f->gain) * input;
   27f80:	edd4 7a03 	vldr	s15, [r4, #12]
   27f84:	f104 0008 	add.w	r0, r4, #8
   27f88:	ed94 7a01 	vldr	s14, [r4, #4]
   27f8c:	eea7 0a67 	vfms.f32	s0, s14, s15
   27f90:	f7fc ff1e 	bl	24dd0 <tLinearDelay_tick>
   27f94:	edd4 7a01 	vldr	s15, [r4, #4]
   27f98:	eea7 0a88 	vfma.f32	s0, s15, s16
    
    f->lastOut = s2;
   27f9c:	ed84 0a03 	vstr	s0, [r4, #12]
    
    return f->lastOut;
}
   27fa0:	ecbd 8b02 	vpop	{d8}
   27fa4:	bd10      	pop	{r4, pc}
   27fa6:	bf00      	nop

00027fa8 <tOnePole_initToPool>:
{
    tOnePole_initToPool(ft, freq, &leaf.mempool);
}

void    tOnePole_initToPool     (tOnePole* const ft, float freq, tMempool* const mp)
{
   27fa8:	b570      	push	{r4, r5, r6, lr}
   27faa:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   27fae:	680e      	ldr	r6, [r1, #0]
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
    f->mempool = m;
    
    f->gain = 1.0f;
   27fb0:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
{
   27fb4:	4605      	mov	r5, r0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   27fb6:	2020      	movs	r0, #32
   27fb8:	4631      	mov	r1, r6
{
   27fba:	eef0 8a40 	vmov.f32	s17, s0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   27fbe:	f001 fdb3 	bl	29b28 <mpool_alloc>
}

void        tOnePole_setFreq        (tOnePole* const ft, float freq)
{
    _tOnePole* f = *ft;
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   27fc2:	4b12      	ldr	r3, [pc, #72]	; (2800c <tOnePole_initToPool+0x64>)
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   27fc4:	6028      	str	r0, [r5, #0]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   27fc6:	eeb0 1a48 	vmov.f32	s2, s16
    f->gain = 1.0f;
   27fca:	ed80 8a01 	vstr	s16, [r0, #4]
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   27fce:	4604      	mov	r4, r0
    f->a0 = 1.0;
   27fd0:	ed80 8a02 	vstr	s16, [r0, #8]
    f->mempool = m;
   27fd4:	6006      	str	r6, [r0, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   27fd6:	edd3 0a03 	vldr	s1, [r3, #12]
    _tOnePole* f = *ft;
   27fda:	682d      	ldr	r5, [r5, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   27fdc:	ee68 0aa0 	vmul.f32	s1, s17, s1
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   27fe0:	eddf 8a0b 	vldr	s17, [pc, #44]	; 28010 <tOnePole_initToPool+0x68>
   27fe4:	eeb0 0a68 	vmov.f32	s0, s17
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   27fe8:	edc5 0a04 	vstr	s1, [r5, #16]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   27fec:	f001 fb9c 	bl	29728 <LEAF_clip>
    f->a1 = 1.0f - f->b0;
   27ff0:	ee38 8a40 	vsub.f32	s16, s16, s0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   27ff4:	ed85 0a04 	vstr	s0, [r5, #16]
    f->a1 = 1.0f - f->b0;
   27ff8:	ed85 8a03 	vstr	s16, [r5, #12]
    f->lastIn = 0.0f;
   27ffc:	edc4 8a06 	vstr	s17, [r4, #24]
    f->lastOut = 0.0f;
   28000:	edc4 8a07 	vstr	s17, [r4, #28]
}
   28004:	ecbd 8b02 	vpop	{d8}
   28008:	bd70      	pop	{r4, r5, r6, pc}
   2800a:	bf00      	nop
   2800c:	020fbd68 	.word	0x020fbd68
   28010:	00000000 	.word	0x00000000

00028014 <tOnePole_free>:
    _tOnePole* f = *ft;
   28014:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)f, f->mempool);
   28016:	6801      	ldr	r1, [r0, #0]
   28018:	f001 be2e 	b.w	29c78 <mpool_free>

0002801c <tOnePole_setFreq>:
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2801c:	4b0b      	ldr	r3, [pc, #44]	; (2804c <tOnePole_setFreq+0x30>)
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2801e:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
{
   28022:	b510      	push	{r4, lr}
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   28024:	edd3 0a03 	vldr	s1, [r3, #12]
    _tOnePole* f = *ft;
   28028:	6804      	ldr	r4, [r0, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2802a:	ee60 0a20 	vmul.f32	s1, s0, s1
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2802e:	ed9f 0a08 	vldr	s0, [pc, #32]	; 28050 <tOnePole_setFreq+0x34>
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   28032:	edc4 0a04 	vstr	s1, [r4, #16]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   28036:	f001 fb77 	bl	29728 <LEAF_clip>
    f->a1 = 1.0f - f->b0;
   2803a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2803e:	ed84 0a04 	vstr	s0, [r4, #16]
    f->a1 = 1.0f - f->b0;
   28042:	ee37 0ac0 	vsub.f32	s0, s15, s0
   28046:	ed84 0a03 	vstr	s0, [r4, #12]
}
   2804a:	bd10      	pop	{r4, pc}
   2804c:	020fbd68 	.word	0x020fbd68
   28050:	00000000 	.word	0x00000000

00028054 <tOnePole_tick>:
    f->gain = gain;
}

float   tOnePole_tick(tOnePole* const ft, float input)
{
    _tOnePole* f = *ft;
   28054:	6803      	ldr	r3, [r0, #0]
    
    float in = input * f->gain;
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   28056:	ed93 6a07 	vldr	s12, [r3, #28]
    float in = input * f->gain;
   2805a:	ed93 7a01 	vldr	s14, [r3, #4]
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   2805e:	edd3 7a03 	vldr	s15, [r3, #12]
    float in = input * f->gain;
   28062:	ee20 7a07 	vmul.f32	s14, s0, s14
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   28066:	edd3 6a04 	vldr	s13, [r3, #16]
   2806a:	ee27 0a86 	vmul.f32	s0, s15, s12
    
    f->lastIn = in;
   2806e:	ed83 7a06 	vstr	s14, [r3, #24]
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   28072:	eea6 0a87 	vfma.f32	s0, s13, s14
    f->lastOut = out;
   28076:	ed83 0a07 	vstr	s0, [r3, #28]
    
    return out;
}
   2807a:	4770      	bx	lr

0002807c <tSVF_init>:
}

// Less efficient, more accurate version of SVF, in which cutoff frequency is taken as floating point Hz value and tanf
// is calculated when frequency changes.
void tSVF_init(tSVF* const svff, SVFType type, float freq, float Q)
{
   2807c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

}

void    tSVF_initToPool     (tSVF* const svff, SVFType type, float freq, float Q, tMempool* const mp)
{
    _tMempool* m = *mp;
   28080:	4f38      	ldr	r7, [pc, #224]	; (28164 <tSVF_init+0xe8>)
{
   28082:	460e      	mov	r6, r1
   28084:	4681      	mov	r9, r0
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   28086:	203c      	movs	r0, #60	; 0x3c
    svf->mempool = m;

    svf->type = type;

    svf->ic1eq = 0;
   28088:	2500      	movs	r5, #0
{
   2808a:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2808e:	f8d7 8018 	ldr.w	r8, [r7, #24]
{
   28092:	eef0 8a40 	vmov.f32	s17, s0
   28096:	eeb0 8a60 	vmov.f32	s16, s1
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   2809a:	4641      	mov	r1, r8
   2809c:	f001 fd44 	bl	29b28 <mpool_alloc>
   280a0:	f8c9 0000 	str.w	r0, [r9]
    svf->mempool = m;
   280a4:	f8c0 8000 	str.w	r8, [r0]
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   280a8:	4604      	mov	r4, r0
    svf->type = type;
   280aa:	7106      	strb	r6, [r0, #4]
    svf->ic2eq = 0;
    svf->Q = Q;
    svf->cutoff = freq;
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   280ac:	edd7 7a01 	vldr	s15, [r7, #4]
   280b0:	ed9f 0a2d 	vldr	s0, [pc, #180]	; 28168 <tSVF_init+0xec>
    svf->Q = Q;
   280b4:	ed80 8a03 	vstr	s16, [r0, #12]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   280b8:	ee27 0a80 	vmul.f32	s0, s15, s0
    svf->cutoff = freq;
   280bc:	edc0 8a02 	vstr	s17, [r0, #8]
    svf->ic1eq = 0;
   280c0:	6105      	str	r5, [r0, #16]
    svf->ic2eq = 0;
   280c2:	6145      	str	r5, [r0, #20]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   280c4:	ee20 0a28 	vmul.f32	s0, s0, s17
   280c8:	f005 f820 	bl	2d10c <tanf>
    svf->k = 1.0f/Q;
   280cc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   280d0:	ed84 0a06 	vstr	s0, [r4, #24]
    svf->a3 = svf->g*svf->a2;
    svf->cH = 0.0f;
    svf->cB = 0.0f;
    svf->cL = 1.0f;

    if (type == SVFTypeLowpass)
   280d4:	2e01      	cmp	r6, #1
    svf->cH = 0.0f;
   280d6:	62e5      	str	r5, [r4, #44]	; 0x2c
    svf->k = 1.0f/Q;
   280d8:	ee87 7a88 	vdiv.f32	s14, s15, s16
    svf->cB = 0.0f;
   280dc:	6325      	str	r5, [r4, #48]	; 0x30
    svf->cL = 1.0f;
   280de:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   280e2:	ee70 6a07 	vadd.f32	s13, s0, s14
    svf->k = 1.0f/Q;
   280e6:	ed84 7a07 	vstr	s14, [r4, #28]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   280ea:	eeb0 7a67 	vmov.f32	s14, s15
   280ee:	eea0 7a26 	vfma.f32	s14, s0, s13
   280f2:	eec7 6a87 	vdiv.f32	s13, s15, s14
    svf->a2 = svf->g*svf->a1;
   280f6:	ee20 7a26 	vmul.f32	s14, s0, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   280fa:	edc4 6a08 	vstr	s13, [r4, #32]
    svf->a3 = svf->g*svf->a2;
   280fe:	ee20 0a07 	vmul.f32	s0, s0, s14
    svf->a2 = svf->g*svf->a1;
   28102:	ed84 7a09 	vstr	s14, [r4, #36]	; 0x24
    svf->a3 = svf->g*svf->a2;
   28106:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
    if (type == SVFTypeLowpass)
   2810a:	d016      	beq.n	2813a <tSVF_init+0xbe>
        svf->cH = 0.0f;
        svf->cB = 0.0f;
        svf->cBK = 0.0f;
        svf->cL = 1.0f;
    }
    else if (type == SVFTypeBandpass)
   2810c:	2e02      	cmp	r6, #2
   2810e:	d00c      	beq.n	2812a <tSVF_init+0xae>
        svf->cB = 1.0f;
        svf->cBK = 0.0f;
        svf->cL = 0.0f;
    }

    else if (type == SVFTypeHighpass)
   28110:	b1c6      	cbz	r6, 28144 <tSVF_init+0xc8>
        svf->cB = 0.0f;
        svf->cBK = -1.0f;
        svf->cL = -1.0f;
    }

    else if (type == SVFTypeNotch)
   28112:	2e03      	cmp	r6, #3
   28114:	d01f      	beq.n	28156 <tSVF_init+0xda>
        svf->cBK = -1.0f;
        svf->cL = 0.0f;
    }


    else if (type == SVFTypePeak)
   28116:	2e04      	cmp	r6, #4
   28118:	d10b      	bne.n	28132 <tSVF_init+0xb6>
    {
        svf->cH = 1.0f;
        svf->cB = 0.0f;
        svf->cBK = -1.0f;
   2811a:	4a14      	ldr	r2, [pc, #80]	; (2816c <tSVF_init+0xf0>)
        svf->cL = -2.0f;
   2811c:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
        svf->cH = 1.0f;
   28120:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cBK = -1.0f;
   28124:	63a2      	str	r2, [r4, #56]	; 0x38
        svf->cL = -2.0f;
   28126:	6363      	str	r3, [r4, #52]	; 0x34
}
   28128:	e003      	b.n	28132 <tSVF_init+0xb6>
        svf->cB = 1.0f;
   2812a:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
        svf->cBK = 0.0f;
   2812e:	63a5      	str	r5, [r4, #56]	; 0x38
        svf->cL = 0.0f;
   28130:	6365      	str	r5, [r4, #52]	; 0x34
}
   28132:	ecbd 8b02 	vpop	{d8}
   28136:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = 0.0f;
   2813a:	63a5      	str	r5, [r4, #56]	; 0x38
}
   2813c:	ecbd 8b02 	vpop	{d8}
   28140:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = -1.0f;
   28144:	4b09      	ldr	r3, [pc, #36]	; (2816c <tSVF_init+0xf0>)
        svf->cH = 1.0f;
   28146:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cBK = -1.0f;
   2814a:	63a3      	str	r3, [r4, #56]	; 0x38
        svf->cL = -1.0f;
   2814c:	6363      	str	r3, [r4, #52]	; 0x34
}
   2814e:	ecbd 8b02 	vpop	{d8}
   28152:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = -1.0f;
   28156:	4b05      	ldr	r3, [pc, #20]	; (2816c <tSVF_init+0xf0>)
        svf->cH = 1.0f;
   28158:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cL = 0.0f;
   2815c:	6365      	str	r5, [r4, #52]	; 0x34
        svf->cBK = -1.0f;
   2815e:	63a3      	str	r3, [r4, #56]	; 0x38
   28160:	e7e7      	b.n	28132 <tSVF_init+0xb6>
   28162:	bf00      	nop
   28164:	020fbd68 	.word	0x020fbd68
   28168:	40490fdb 	.word	0x40490fdb
   2816c:	bf800000 	.word	0xbf800000

00028170 <tSVF_free>:
    }
}

void    tSVF_free   (tSVF* const svff)
{
    _tSVF* svf = *svff;
   28170:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)svf, svf->mempool);
   28172:	6801      	ldr	r1, [r0, #0]
   28174:	f001 bd80 	b.w	29c78 <mpool_free>

00028178 <tSVF_tick>:
}

float   tSVF_tick(tSVF* const svff, float v0)
{
    _tSVF* svf = *svff;
   28178:	6803      	ldr	r3, [r0, #0]
    
    float v1,v2,v3;
    v3 = v0 - svf->ic2eq;
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   2817a:	eef0 4a00 	vmov.f32	s9, #0	; 0x40000000  2.0
    v3 = v0 - svf->ic2eq;
   2817e:	edd3 6a05 	vldr	s13, [r3, #20]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   28182:	ed93 6a04 	vldr	s12, [r3, #16]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   28186:	eef0 5a66 	vmov.f32	s11, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2818a:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    v3 = v0 - svf->ic2eq;
   2818e:	ee30 4a66 	vsub.f32	s8, s0, s13
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   28192:	edd3 2a0a 	vldr	s5, [r3, #40]	; 0x28
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
    
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   28196:	edd3 3a0e 	vldr	s7, [r3, #56]	; 0x38
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2819a:	eee6 5a27 	vfma.f32	s11, s12, s15
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2819e:	ed93 3a08 	vldr	s6, [r3, #32]
   281a2:	ee67 7a84 	vmul.f32	s15, s15, s8
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   281a6:	ed93 2a07 	vldr	s4, [r3, #28]
   281aa:	ed93 5a0c 	vldr	s10, [r3, #48]	; 0x30
   281ae:	ed93 7a0d 	vldr	s14, [r3, #52]	; 0x34
   281b2:	eea2 5a23 	vfma.f32	s10, s4, s7
   281b6:	edd3 3a0b 	vldr	s7, [r3, #44]	; 0x2c
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   281ba:	eee3 7a06 	vfma.f32	s15, s6, s12
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   281be:	eee2 5a84 	vfma.f32	s11, s5, s8
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   281c2:	ee97 6aa4 	vfnms.f32	s12, s15, s9
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   281c6:	ee25 7a87 	vmul.f32	s14, s11, s14
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   281ca:	eed5 6aa4 	vfnms.f32	s13, s11, s9
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   281ce:	eea7 7a85 	vfma.f32	s14, s15, s10
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   281d2:	ed83 6a04 	vstr	s12, [r3, #16]
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   281d6:	edc3 6a05 	vstr	s13, [r3, #20]
}
   281da:	eea3 7a80 	vfma.f32	s14, s7, s0
   281de:	eeb0 0a47 	vmov.f32	s0, s14
   281e2:	4770      	bx	lr

000281e4 <tSVF_setFreq>:

void     tSVF_setFreq(tSVF* const svff, float freq)
{
    _tSVF* svf = *svff;
    svf->cutoff = freq;
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   281e4:	4b14      	ldr	r3, [pc, #80]	; (28238 <tSVF_setFreq+0x54>)
   281e6:	ed9f 7a15 	vldr	s14, [pc, #84]	; 2823c <tSVF_setFreq+0x58>
{
   281ea:	b510      	push	{r4, lr}
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   281ec:	edd3 7a01 	vldr	s15, [r3, #4]
    _tSVF* svf = *svff;
   281f0:	6804      	ldr	r4, [r0, #0]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   281f2:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->cutoff = freq;
   281f6:	ed84 0a02 	vstr	s0, [r4, #8]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   281fa:	ee27 0a80 	vmul.f32	s0, s15, s0
   281fe:	f004 ff85 	bl	2d10c <tanf>
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   28202:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   28206:	edd4 7a07 	vldr	s15, [r4, #28]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2820a:	ed84 0a06 	vstr	s0, [r4, #24]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2820e:	ee70 7a27 	vadd.f32	s15, s0, s15
   28212:	eeb0 7a66 	vmov.f32	s14, s13
   28216:	eea0 7a27 	vfma.f32	s14, s0, s15
   2821a:	eef0 7a47 	vmov.f32	s15, s14
   2821e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    svf->a2 = svf->g * svf->a1;
   28222:	ee60 7a07 	vmul.f32	s15, s0, s14
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   28226:	ed84 7a08 	vstr	s14, [r4, #32]
    svf->a3 = svf->g * svf->a2;
   2822a:	ee20 0a27 	vmul.f32	s0, s0, s15
    svf->a2 = svf->g * svf->a1;
   2822e:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
   28232:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
}
   28236:	bd10      	pop	{r4, pc}
   28238:	020fbd68 	.word	0x020fbd68
   2823c:	40490fdb 	.word	0x40490fdb

00028240 <tEfficientSVF_initToPool>:
{
    tEfficientSVF_initToPool(svff, type, input, Q, &leaf.mempool);
}

void    tEfficientSVF_initToPool    (tEfficientSVF* const svff, SVFType type, uint16_t input, float Q, tMempool* const mp)
{
   28240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28242:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   28246:	681c      	ldr	r4, [r3, #0]
{
   28248:	4607      	mov	r7, r0
   2824a:	460d      	mov	r5, r1
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
   2824c:	202c      	movs	r0, #44	; 0x2c
   2824e:	4621      	mov	r1, r4
{
   28250:	4616      	mov	r6, r2
   28252:	eeb0 8a40 	vmov.f32	s16, s0
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
   28256:	f001 fc67 	bl	29b28 <mpool_alloc>
    
    svf->ic1eq = 0;
    svf->ic2eq = 0;
    
    svf->g = __leaf_table_filtertan[input];
    svf->k = 1.0f/Q;
   2825a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    svf->g = __leaf_table_filtertan[input];
   2825e:	4a14      	ldr	r2, [pc, #80]	; (282b0 <tEfficientSVF_initToPool+0x70>)
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
   28260:	6038      	str	r0, [r7, #0]
    svf->ic1eq = 0;
   28262:	2300      	movs	r3, #0
    svf->g = __leaf_table_filtertan[input];
   28264:	eb02 0286 	add.w	r2, r2, r6, lsl #2
    svf->mempool = m;
   28268:	6004      	str	r4, [r0, #0]
    svf->k = 1.0f/Q;
   2826a:	eec7 6a08 	vdiv.f32	s13, s14, s16
    svf->type = type;
   2826e:	7105      	strb	r5, [r0, #4]
    svf->g = __leaf_table_filtertan[input];
   28270:	edd2 7a00 	vldr	s15, [r2]
    svf->ic1eq = 0;
   28274:	6103      	str	r3, [r0, #16]
    svf->g = __leaf_table_filtertan[input];
   28276:	edc0 7a06 	vstr	s15, [r0, #24]
    svf->ic2eq = 0;
   2827a:	6143      	str	r3, [r0, #20]
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
   2827c:	ee37 6aa6 	vadd.f32	s12, s15, s13
    svf->k = 1.0f/Q;
   28280:	edc0 6a07 	vstr	s13, [r0, #28]
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
   28284:	eef0 6a47 	vmov.f32	s13, s14
   28288:	eee7 6a86 	vfma.f32	s13, s15, s12
   2828c:	eeb0 6a66 	vmov.f32	s12, s13
   28290:	eec7 6a06 	vdiv.f32	s13, s14, s12
    svf->a2 = svf->g*svf->a1;
   28294:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
   28298:	edc0 6a08 	vstr	s13, [r0, #32]
    svf->a3 = svf->g*svf->a2;
   2829c:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g*svf->a1;
   282a0:	ed80 7a09 	vstr	s14, [r0, #36]	; 0x24
    svf->a3 = svf->g*svf->a2;
   282a4:	edc0 7a0a 	vstr	s15, [r0, #40]	; 0x28
}
   282a8:	ecbd 8b02 	vpop	{d8}
   282ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   282ae:	bf00      	nop
   282b0:	000324e4 	.word	0x000324e4

000282b4 <tEfficientSVF_free>:

void    tEfficientSVF_free (tEfficientSVF* const svff)
{
    _tEfficientSVF* svf = *svff;
   282b4:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)svf, svf->mempool);
   282b6:	6801      	ldr	r1, [r0, #0]
   282b8:	f001 bcde 	b.w	29c78 <mpool_free>

000282bc <tEfficientSVF_tick>:
}

float   tEfficientSVF_tick(tEfficientSVF* const svff, float v0)
{
    _tEfficientSVF* svf = *svff;
   282bc:	6803      	ldr	r3, [r0, #0]
    
    float v1,v2,v3;
    v3 = v0 - svf->ic2eq;
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   282be:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
    v3 = v0 - svf->ic2eq;
   282c2:	edd3 6a05 	vldr	s13, [r3, #20]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   282c6:	ed93 6a04 	vldr	s12, [r3, #16]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   282ca:	eeb0 7a66 	vmov.f32	s14, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   282ce:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    v3 = v0 - svf->ic2eq;
   282d2:	ee70 5a66 	vsub.f32	s11, s0, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   282d6:	ed93 4a08 	vldr	s8, [r3, #32]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   282da:	edd3 4a0a 	vldr	s9, [r3, #40]	; 0x28
   282de:	eea6 7a27 	vfma.f32	s14, s12, s15
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
    
    if (svf->type == SVFTypeLowpass)        return v2;
   282e2:	791a      	ldrb	r2, [r3, #4]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   282e4:	ee67 7aa5 	vmul.f32	s15, s15, s11
    if (svf->type == SVFTypeLowpass)        return v2;
   282e8:	2a01      	cmp	r2, #1
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   282ea:	eee4 7a06 	vfma.f32	s15, s8, s12
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   282ee:	eea4 7aa5 	vfma.f32	s14, s9, s11
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   282f2:	ee97 6a85 	vfnms.f32	s12, s15, s10
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   282f6:	ee77 5a07 	vadd.f32	s11, s14, s14
   282fa:	ee75 6ae6 	vsub.f32	s13, s11, s13
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   282fe:	ed83 6a04 	vstr	s12, [r3, #16]
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   28302:	edc3 6a05 	vstr	s13, [r3, #20]
    if (svf->type == SVFTypeLowpass)        return v2;
   28306:	d008      	beq.n	2831a <tEfficientSVF_tick+0x5e>
    else if (svf->type == SVFTypeBandpass)  return v1;
   28308:	2a02      	cmp	r2, #2
   2830a:	d009      	beq.n	28320 <tEfficientSVF_tick+0x64>
    else if (svf->type == SVFTypeHighpass)  return v0 - (svf->k * v1) - v2;
   2830c:	b16a      	cbz	r2, 2832a <tEfficientSVF_tick+0x6e>
    else if (svf->type == SVFTypeNotch)     return v0 - (svf->k * v1);
   2830e:	2a03      	cmp	r2, #3
   28310:	d014      	beq.n	2833c <tEfficientSVF_tick+0x80>
    else if (svf->type == SVFTypePeak)      return v0 - (svf->k * v1) - (2.0f * v2);
   28312:	2a04      	cmp	r2, #4
   28314:	d019      	beq.n	2834a <tEfficientSVF_tick+0x8e>
    else                                    return 0.0f;
   28316:	ed9f 7a10 	vldr	s14, [pc, #64]	; 28358 <tEfficientSVF_tick+0x9c>
    
}
   2831a:	eeb0 0a47 	vmov.f32	s0, s14
   2831e:	4770      	bx	lr
    else if (svf->type == SVFTypeBandpass)  return v1;
   28320:	eeb0 7a67 	vmov.f32	s14, s15
}
   28324:	eeb0 0a47 	vmov.f32	s0, s14
   28328:	4770      	bx	lr
    else if (svf->type == SVFTypeHighpass)  return v0 - (svf->k * v1) - v2;
   2832a:	edd3 6a07 	vldr	s13, [r3, #28]
   2832e:	eea6 0ae7 	vfms.f32	s0, s13, s15
   28332:	ee30 7a47 	vsub.f32	s14, s0, s14
}
   28336:	eeb0 0a47 	vmov.f32	s0, s14
   2833a:	4770      	bx	lr
    else if (svf->type == SVFTypeNotch)     return v0 - (svf->k * v1);
   2833c:	ed93 7a07 	vldr	s14, [r3, #28]
   28340:	eea7 0a67 	vfms.f32	s0, s14, s15
   28344:	eeb0 7a40 	vmov.f32	s14, s0
   28348:	e7e7      	b.n	2831a <tEfficientSVF_tick+0x5e>
    else if (svf->type == SVFTypePeak)      return v0 - (svf->k * v1) - (2.0f * v2);
   2834a:	ed93 7a07 	vldr	s14, [r3, #28]
   2834e:	eea7 0a67 	vfms.f32	s0, s14, s15
   28352:	ee30 7a65 	vsub.f32	s14, s0, s11
   28356:	e7e0      	b.n	2831a <tEfficientSVF_tick+0x5e>
   28358:	00000000 	.word	0x00000000

0002835c <tEfficientSVF_setFreq>:

void     tEfficientSVF_setFreq(tEfficientSVF* const svff, uint16_t input)
{
    _tEfficientSVF* svf = *svff;
    
    svf->g = __leaf_table_filtertan[input];
   2835c:	4a10      	ldr	r2, [pc, #64]	; (283a0 <tEfficientSVF_setFreq+0x44>)
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2835e:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    _tEfficientSVF* svf = *svff;
   28362:	6803      	ldr	r3, [r0, #0]
    svf->g = __leaf_table_filtertan[input];
   28364:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   28368:	ed93 7a07 	vldr	s14, [r3, #28]
   2836c:	eef0 6a46 	vmov.f32	s13, s12
    svf->g = __leaf_table_filtertan[input];
   28370:	edd1 7a00 	vldr	s15, [r1]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   28374:	ee37 7a87 	vadd.f32	s14, s15, s14
    svf->g = __leaf_table_filtertan[input];
   28378:	edc3 7a06 	vstr	s15, [r3, #24]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2837c:	eee7 6a87 	vfma.f32	s13, s15, s14
   28380:	eeb0 7a66 	vmov.f32	s14, s13
   28384:	eec6 6a07 	vdiv.f32	s13, s12, s14
    svf->a2 = svf->g * svf->a1;
   28388:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2838c:	edc3 6a08 	vstr	s13, [r3, #32]
    svf->a3 = svf->g * svf->a2;
   28390:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g * svf->a1;
   28394:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
   28398:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
}
   2839c:	4770      	bx	lr
   2839e:	bf00      	nop
   283a0:	000324e4 	.word	0x000324e4

000283a4 <tEfficientSVF_setQ>:

void     tEfficientSVF_setQ(tEfficientSVF* const svff, float Q)
{
    _tEfficientSVF* svf = *svff;
    
    svf->k = 1.0f/Q;
   283a4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    _tEfficientSVF* svf = *svff;
   283a8:	6803      	ldr	r3, [r0, #0]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   283aa:	edd3 7a06 	vldr	s15, [r3, #24]
    svf->k = 1.0f/Q;
   283ae:	ee87 0a00 	vdiv.f32	s0, s14, s0
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   283b2:	eeb0 6a47 	vmov.f32	s12, s14
   283b6:	ee70 6a27 	vadd.f32	s13, s0, s15
    svf->k = 1.0f/Q;
   283ba:	ed83 0a07 	vstr	s0, [r3, #28]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   283be:	eea7 6aa6 	vfma.f32	s12, s15, s13
   283c2:	eec7 6a06 	vdiv.f32	s13, s14, s12
    svf->a2 = svf->g * svf->a1;
   283c6:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   283ca:	edc3 6a08 	vstr	s13, [r3, #32]
    svf->a3 = svf->g * svf->a2;
   283ce:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g * svf->a1;
   283d2:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
   283d6:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
}
   283da:	4770      	bx	lr

000283dc <tHighpass_init>:

/* Highpass */
void    tHighpass_init(tHighpass* const ft, float freq)
{
   283dc:	b570      	push	{r4, r5, r6, lr}
    tHighpass_initToPool(ft, freq, &leaf.mempool);
}

void    tHighpass_initToPool    (tHighpass* const ft, float freq, tMempool* const mp)
{
    _tMempool* m = *mp;
   283de:	4c0e      	ldr	r4, [pc, #56]	; (28418 <tHighpass_init+0x3c>)
{
   283e0:	4606      	mov	r6, r0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   283e2:	2014      	movs	r0, #20
    _tMempool* m = *mp;
   283e4:	69a5      	ldr	r5, [r4, #24]
{
   283e6:	ed2d 8b02 	vpush	{d8}
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   283ea:	4629      	mov	r1, r5
{
   283ec:	eeb0 8a40 	vmov.f32	s16, s0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   283f0:	f001 fbf0 	bl	29bd4 <mpool_calloc>
    f->mempool = m;
    
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   283f4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   283f8:	6030      	str	r0, [r6, #0]
    f->ys = 0.0f;
   283fa:	2300      	movs	r3, #0
    f->mempool = m;
   283fc:	6005      	str	r5, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   283fe:	ed94 7a03 	vldr	s14, [r4, #12]
    f->xs = 0.0f;
    
    f->frequency = freq;
   28402:	ed80 8a04 	vstr	s16, [r0, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   28406:	eee8 7a47 	vfms.f32	s15, s16, s14
    f->ys = 0.0f;
   2840a:	6083      	str	r3, [r0, #8]
    f->xs = 0.0f;
   2840c:	6043      	str	r3, [r0, #4]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2840e:	edc0 7a03 	vstr	s15, [r0, #12]
}
   28412:	ecbd 8b02 	vpop	{d8}
   28416:	bd70      	pop	{r4, r5, r6, pc}
   28418:	020fbd68 	.word	0x020fbd68

0002841c <tHighpass_initToPool>:
{
   2841c:	b538      	push	{r3, r4, r5, lr}
   2841e:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   28422:	680c      	ldr	r4, [r1, #0]
{
   28424:	4605      	mov	r5, r0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   28426:	2014      	movs	r0, #20
{
   28428:	eeb0 8a40 	vmov.f32	s16, s0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   2842c:	4621      	mov	r1, r4
   2842e:	f001 fbd1 	bl	29bd4 <mpool_calloc>
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   28432:	4b09      	ldr	r3, [pc, #36]	; (28458 <tHighpass_initToPool+0x3c>)
   28434:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   28438:	6028      	str	r0, [r5, #0]
    f->mempool = m;
   2843a:	6004      	str	r4, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2843c:	ed93 7a03 	vldr	s14, [r3, #12]
    f->ys = 0.0f;
   28440:	2300      	movs	r3, #0
    f->frequency = freq;
   28442:	ed80 8a04 	vstr	s16, [r0, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   28446:	eee7 7a48 	vfms.f32	s15, s14, s16
    f->ys = 0.0f;
   2844a:	6083      	str	r3, [r0, #8]
    f->xs = 0.0f;
   2844c:	6043      	str	r3, [r0, #4]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2844e:	edc0 7a03 	vstr	s15, [r0, #12]
}
   28452:	ecbd 8b02 	vpop	{d8}
   28456:	bd38      	pop	{r3, r4, r5, pc}
   28458:	020fbd68 	.word	0x020fbd68

0002845c <tHighpass_free>:

void    tHighpass_free  (tHighpass* const ft)
{
    _tHighpass* f = *ft;
   2845c:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)f, f->mempool);
   2845e:	6801      	ldr	r1, [r0, #0]
   28460:	f001 bc0a 	b.w	29c78 <mpool_free>

00028464 <tHighpass_setFreq>:

void     tHighpass_setFreq(tHighpass* const ft, float freq)
{
    _tHighpass* f = *ft;
    f->frequency = freq;
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   28464:	4a06      	ldr	r2, [pc, #24]	; (28480 <tHighpass_setFreq+0x1c>)
   28466:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft;
   2846a:	6803      	ldr	r3, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2846c:	ed92 7a03 	vldr	s14, [r2, #12]
    f->frequency = freq;
   28470:	ed83 0a04 	vstr	s0, [r3, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   28474:	eee7 7a40 	vfms.f32	s15, s14, s0
   28478:	edc3 7a03 	vstr	s15, [r3, #12]
    
}
   2847c:	4770      	bx	lr
   2847e:	bf00      	nop
   28480:	020fbd68 	.word	0x020fbd68

00028484 <tHighpass_tick>:
}

// From JOS DC Blocker
float   tHighpass_tick(tHighpass* const ft, float x)
{
    _tHighpass* f = *ft;
   28484:	6803      	ldr	r3, [r0, #0]
    f->ys = x - f->xs + f->R * f->ys;
   28486:	edd3 7a01 	vldr	s15, [r3, #4]
   2848a:	ed93 7a02 	vldr	s14, [r3, #8]
   2848e:	edd3 6a03 	vldr	s13, [r3, #12]
    f->xs = x;
   28492:	ed83 0a01 	vstr	s0, [r3, #4]
    f->ys = x - f->xs + f->R * f->ys;
   28496:	eed6 7a87 	vfnms.f32	s15, s13, s14
   2849a:	ee37 0a80 	vadd.f32	s0, s15, s0
   2849e:	ed83 0a02 	vstr	s0, [r3, #8]
    return f->ys;
}
   284a2:	4770      	bx	lr

000284a4 <tVZFilter_initToPool>:
{
	tVZFilter_initToPool(vf, type, freq, bandWidth, &leaf.mempool);
}

void    tVZFilter_initToPool     (tVZFilter* const vf, VZFilterType type, float freq, float bandWidth, tMempool* const mp)
{
   284a4:	b570      	push	{r4, r5, r6, lr}
   284a6:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   284aa:	6814      	ldr	r4, [r2, #0]
{
   284ac:	4605      	mov	r5, r0
   284ae:	460e      	mov	r6, r1
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
   284b0:	2044      	movs	r0, #68	; 0x44
   284b2:	4621      	mov	r1, r4
{
   284b4:	eef0 8a40 	vmov.f32	s17, s0
   284b8:	eeb0 8a60 	vmov.f32	s16, s1
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
   284bc:	f001 fb34 	bl	29b28 <mpool_alloc>
	f->invG    = 1.0f/ONE_OVER_SQRT2;
	f->B    = bandWidth;
	f->m    = 0.0f;
	f->s1 = 0.0f;
	f->s2 = 0.0f;
	f->sr = leaf.sampleRate;
   284c0:	4bc1      	ldr	r3, [pc, #772]	; (287c8 <tVZFilter_initToPool+0x324>)
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
   284c2:	6028      	str	r0, [r5, #0]
    f->mempool = m;
   284c4:	6004      	str	r4, [r0, #0]
	f->type = type;
   284c6:	7106      	strb	r6, [r0, #4]
	f->sr = leaf.sampleRate;
   284c8:	6819      	ldr	r1, [r3, #0]
	f->inv_sr = leaf.invSampleRate;
   284ca:	685a      	ldr	r2, [r3, #4]
	f->m    = 0.0f;
   284cc:	2300      	movs	r3, #0
	f->invG    = 1.0f/ONE_OVER_SQRT2;
   284ce:	4cbf      	ldr	r4, [pc, #764]	; (287cc <tVZFilter_initToPool+0x328>)
	f->G    = ONE_OVER_SQRT2;
   284d0:	4ebf      	ldr	r6, [pc, #764]	; (287d0 <tVZFilter_initToPool+0x32c>)
	f->fc   = freq;
   284d2:	edc0 8a0a 	vstr	s17, [r0, #40]	; 0x28
	f->m    = 0.0f;
   284d6:	6383      	str	r3, [r0, #56]	; 0x38
	f->s1 = 0.0f;
   284d8:	6083      	str	r3, [r0, #8]
	f->s2 = 0.0f;
   284da:	60c3      	str	r3, [r0, #12]
	f->B    = bandWidth;
   284dc:	ed80 8a0d 	vstr	s16, [r0, #52]	; 0x34
	f->G    = ONE_OVER_SQRT2;
   284e0:	62c6      	str	r6, [r0, #44]	; 0x2c
	f->invG    = 1.0f/ONE_OVER_SQRT2;
   284e2:	6304      	str	r4, [r0, #48]	; 0x30
	f->sr = leaf.sampleRate;
   284e4:	63c1      	str	r1, [r0, #60]	; 0x3c
	f->inv_sr = leaf.invSampleRate;
   284e6:	6402      	str	r2, [r0, #64]	; 0x40


void   tVZFilter_calcCoeffs           (tVZFilter* const vf)
{

	_tVZFilter* f = *vf;
   284e8:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   284ea:	eddf 7aba 	vldr	s15, [pc, #744]	; 287d4 <tVZFilter_initToPool+0x330>
   284ee:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   284f2:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   284f6:	ee28 8a07 	vmul.f32	s16, s16, s14
   284fa:	ee28 8a27 	vmul.f32	s16, s16, s15
   284fe:	eeb0 0a48 	vmov.f32	s0, s16
   28502:	f004 fe03 	bl	2d10c <tanf>

	  switch( f->type )
   28506:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   28508:	eef0 8a40 	vmov.f32	s17, s0
   2850c:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   28510:	2b0a      	cmp	r3, #10
   28512:	f200 81b5 	bhi.w	28880 <tVZFilter_initToPool+0x3dc>
   28516:	e8df f013 	tbh	[pc, r3, lsl #1]
   2851a:	0053      	.short	0x0053
   2851c:	0069005e 	.word	0x0069005e
   28520:	00ab0074 	.word	0x00ab0074
   28524:	011600e3 	.word	0x011600e3
   28528:	01630136 	.word	0x01630136
   2852c:	000b01a8 	.word	0x000b01a8
}

float tVZFilter_BandwidthToR(tVZFilter* const vf, float B)
{
	_tVZFilter* f = *vf;
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28530:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28534:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28538:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2853a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2853e:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28542:	f004 fca5 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28546:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   2854a:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2854e:	ed9f 7aa1 	vldr	s14, [pc, #644]	; 287d4 <tVZFilter_initToPool+0x330>
   28552:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28556:	ee67 7a87 	vmul.f32	s15, s15, s14
   2855a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2855e:	f004 fdd5 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28562:	ed95 7a04 	vldr	s14, [r5, #16]
							   // unwarped: r = pow(2, -B/2) -> approximation for low
							   // center-frequencies
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28566:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2856a:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2856e:	edc4 7a07 	vstr	s15, [r4, #28]
   28572:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28576:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2857a:	ee20 0a00 	vmul.f32	s0, s0, s0
   2857e:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28582:	ee20 0a07 	vmul.f32	s0, s0, s14
   28586:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2858a:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2858e:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28592:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28596:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2859a:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2859e:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   285a2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   285a6:	ee77 7aa8 	vadd.f32	s15, s15, s17
   285aa:	eef0 6a47 	vmov.f32	s13, s14
   285ae:	eee7 6aa8 	vfma.f32	s13, s15, s17
   285b2:	eec7 7a26 	vdiv.f32	s15, s14, s13
   285b6:	edc4 7a06 	vstr	s15, [r4, #24]
}
   285ba:	ecbd 8b04 	vpop	{d8-d9}
   285be:	bd70      	pop	{r4, r5, r6, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   285c0:	2300      	movs	r3, #0
   285c2:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   285c6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   285ca:	6262      	str	r2, [r4, #36]	; 0x24
			f->R2 = f->invG;
   285cc:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   285d0:	61e3      	str	r3, [r4, #28]
   285d2:	6223      	str	r3, [r4, #32]
   285d4:	e7e5      	b.n	285a2 <tVZFilter_initToPool+0xfe>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   285d6:	2300      	movs	r3, #0
   285d8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   285dc:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   285e0:	61e2      	str	r2, [r4, #28]
			f->R2 = f->invG;
   285e2:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   285e6:	6223      	str	r3, [r4, #32]
   285e8:	6263      	str	r3, [r4, #36]	; 0x24
   285ea:	e7da      	b.n	285a2 <tVZFilter_initToPool+0xfe>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   285ec:	2300      	movs	r3, #0
   285ee:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   285f2:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   285f6:	6222      	str	r2, [r4, #32]
			f->R2 = f->invG;
   285f8:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   285fc:	61e3      	str	r3, [r4, #28]
   285fe:	6263      	str	r3, [r4, #36]	; 0x24
   28600:	e7cf      	b.n	285a2 <tVZFilter_initToPool+0xfe>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28602:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28606:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2860a:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2860c:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28610:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28614:	f004 fc3c 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28618:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   2861c:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28620:	ed9f 7a6c 	vldr	s14, [pc, #432]	; 287d4 <tVZFilter_initToPool+0x330>
   28624:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28628:	ee67 7a87 	vmul.f32	s15, s15, s14
   2862c:	ee27 0a80 	vmul.f32	s0, s15, s0
   28630:	f004 fd6c 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28634:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28638:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2863c:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2863e:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   28642:	61e3      	str	r3, [r4, #28]
   28644:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28646:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2864a:	ee20 0a00 	vmul.f32	s0, s0, s0
   2864e:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28652:	ee20 0a07 	vmul.f32	s0, s0, s14
   28656:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2865a:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2865e:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28662:	ee77 7aa7 	vadd.f32	s15, s15, s15
   28666:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2866a:	edc4 7a08 	vstr	s15, [r4, #32]
   2866e:	e798      	b.n	285a2 <tVZFilter_initToPool+0xfe>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28670:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28674:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28678:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2867a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2867e:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28682:	f004 fc05 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28686:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   2868a:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2868e:	ed9f 7a51 	vldr	s14, [pc, #324]	; 287d4 <tVZFilter_initToPool+0x330>
   28692:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28696:	ee67 7a87 	vmul.f32	s15, s15, s14
   2869a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2869e:	f004 fd35 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   286a2:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   286a6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   286aa:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   286ac:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   286b0:	6223      	str	r3, [r4, #32]
   286b2:	edc4 7a07 	vstr	s15, [r4, #28]
   286b6:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   286ba:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   286be:	ee20 0a00 	vmul.f32	s0, s0, s0
   286c2:	ee77 7ac0 	vsub.f32	s15, s15, s0
   286c6:	ee20 0a07 	vmul.f32	s0, s0, s14
   286ca:	ee67 7aa7 	vmul.f32	s15, s15, s15
   286ce:	ee87 7a80 	vdiv.f32	s14, s15, s0
   286d2:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   286d6:	ee77 7aa7 	vadd.f32	s15, s15, s15
   286da:	edc4 7a05 	vstr	s15, [r4, #20]
   286de:	e760      	b.n	285a2 <tVZFilter_initToPool+0xfe>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   286e0:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   286e4:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   286e8:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   286ec:	ee60 0aa7 	vmul.f32	s1, s1, s15
   286f0:	f004 fbce 	bl	2ce90 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   286f4:	ee28 0a00 	vmul.f32	s0, s16, s0
   286f8:	f004 fd08 	bl	2d10c <tanf>
			float r  = f->g/wl;
   286fc:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28700:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   28704:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   28708:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   2870c:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28710:	edc4 7a07 	vstr	s15, [r4, #28]
   28714:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28718:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   2871c:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28720:	eee0 7a00 	vfma.f32	s15, s0, s0
   28724:	ee87 6a80 	vdiv.f32	s12, s15, s0
   28728:	ee76 7a65 	vsub.f32	s15, s12, s11
   2872c:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   28730:	eef1 7ac6 	vsqrt.f32	s15, s12
   28734:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28738:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2873c:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28740:	ed84 7a08 	vstr	s14, [r4, #32]
   28744:	e72d      	b.n	285a2 <tVZFilter_initToPool+0xfe>
			float A = sqrtf(f->G);
   28746:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2874a:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2874e:	eddf 7a22 	vldr	s15, [pc, #136]	; 287d8 <tVZFilter_initToPool+0x334>
			float A = sqrtf(f->G);
   28752:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28756:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   2875a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2875e:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   28762:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   28766:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2876a:	f004 ffb9 	bl	2d6e0 <sinhf>
   2876e:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   28772:	ed84 9a07 	vstr	s18, [r4, #28]
   28776:	6265      	str	r5, [r4, #36]	; 0x24
   28778:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2877c:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   28780:	ed84 8a08 	vstr	s16, [r4, #32]
   28784:	e70d      	b.n	285a2 <tVZFilter_initToPool+0xfe>
		  float A = sqrtf(f->G);
   28786:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2878a:	eddf 7a13 	vldr	s15, [pc, #76]	; 287d8 <tVZFilter_initToPool+0x334>
		  float A = sqrtf(f->G);
   2878e:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   28792:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   28796:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2879a:	eef1 7ac8 	vsqrt.f32	s15, s16
   2879e:	ee68 8aa7 	vmul.f32	s17, s17, s15
   287a2:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   287a6:	f004 ff9b 	bl	2d6e0 <sinhf>
   287aa:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   287ae:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   287b2:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   287b6:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   287ba:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   287be:	61e3      	str	r3, [r4, #28]
   287c0:	ed84 8a08 	vstr	s16, [r4, #32]
   287c4:	e6ed      	b.n	285a2 <tVZFilter_initToPool+0xfe>
   287c6:	bf00      	nop
   287c8:	020fbd68 	.word	0x020fbd68
   287cc:	3fb504f3 	.word	0x3fb504f3
   287d0:	3f3504f3 	.word	0x3f3504f3
   287d4:	40490fdb 	.word	0x40490fdb
   287d8:	3eb17218 	.word	0x3eb17218
   287dc:	00000000 	.word	0x00000000
		  float x  = 2.0f*f->m-1.0f;
   287e0:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   287e4:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   287e8:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   287ec:	6b23      	ldr	r3, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   287ee:	ed5f 0a05 	vldr	s1, [pc, #-20]	; 287dc <tVZFilter_initToPool+0x338>
			f->R2 = f->invG;
   287f2:	6163      	str	r3, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   287f4:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   287f8:	eef1 8a48 	vneg.f32	s17, s16
   287fc:	eeb0 0a68 	vmov.f32	s0, s17
   28800:	f001 f972 	bl	29ae8 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   28804:	ed5f 0a0b 	vldr	s1, [pc, #-44]	; 287dc <tVZFilter_initToPool+0x338>
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   28808:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2880c:	eeb0 0a48 	vmov.f32	s0, s16
   28810:	f001 f96e 	bl	29af0 <minimum>
		  f->cB = 1.0f-x*x;
   28814:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   28818:	edd4 6a07 	vldr	s13, [r4, #28]
   2881c:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   28820:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   28824:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   28828:	ee36 5aa6 	vadd.f32	s10, s13, s13
   2882c:	edd4 8a04 	vldr	s17, [r4, #16]
   28830:	ee67 4aa7 	vmul.f32	s9, s15, s15
   28834:	ee27 6a07 	vmul.f32	s12, s14, s14
   28838:	eea6 6aa6 	vfma.f32	s12, s13, s13
   2883c:	eea0 6a00 	vfma.f32	s12, s0, s0
   28840:	eea0 6a45 	vfms.f32	s12, s0, s10
   28844:	ee84 5a86 	vdiv.f32	s10, s9, s12
   28848:	eeb1 6ac5 	vsqrt.f32	s12, s10
   2884c:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   28850:	ee66 6a86 	vmul.f32	s13, s13, s12
   28854:	ee27 7a06 	vmul.f32	s14, s14, s12
   28858:	ee20 0a06 	vmul.f32	s0, s0, s12
   2885c:	edc4 6a07 	vstr	s13, [r4, #28]
   28860:	ed84 7a08 	vstr	s14, [r4, #32]
   28864:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   28868:	e69b      	b.n	285a2 <tVZFilter_initToPool+0xfe>
		  f->cL = 1.0f;
   2886a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2886e:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   28872:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   28874:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   28878:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   2887a:	edc4 7a08 	vstr	s15, [r4, #32]
   2887e:	e690      	b.n	285a2 <tVZFilter_initToPool+0xfe>
   28880:	edd4 7a05 	vldr	s15, [r4, #20]
   28884:	e68d      	b.n	285a2 <tVZFilter_initToPool+0xfe>
   28886:	bf00      	nop

00028888 <tVZFilter_free>:
    _tVZFilter* f = *vf;
   28888:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)f, f->mempool);
   2888a:	6801      	ldr	r1, [r0, #0]
   2888c:	f001 b9f4 	b.w	29c78 <mpool_free>

00028890 <tVZFilter_setSampleRate>:
	f->inv_sr = 1.0f/sampleRate;
   28890:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
	_tVZFilter* f = *vf;
   28894:	6803      	ldr	r3, [r0, #0]
	f->sr = sampleRate;
   28896:	ed83 0a0f 	vstr	s0, [r3, #60]	; 0x3c
	f->inv_sr = 1.0f/sampleRate;
   2889a:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2889e:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
}
   288a2:	4770      	bx	lr

000288a4 <tVZFilter_tick>:
{
   288a4:	b510      	push	{r4, lr}
	_tVZFilter* f = *vf;
   288a6:	6804      	ldr	r4, [r0, #0]
{
   288a8:	ed2d 8b06 	vpush	{d8-d10}
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
   288ac:	ed94 8a02 	vldr	s16, [r4, #8]
   288b0:	edd4 7a05 	vldr	s15, [r4, #20]
   288b4:	ed94 9a04 	vldr	s18, [r4, #16]
   288b8:	eea7 0ac8 	vfms.f32	s0, s15, s16
   288bc:	edd4 9a03 	vldr	s19, [r4, #12]
   288c0:	edd4 7a06 	vldr	s15, [r4, #24]
   288c4:	eea8 0a49 	vfms.f32	s0, s16, s18
   288c8:	ee70 8a69 	vsub.f32	s17, s0, s19
   288cc:	ee68 8aa7 	vmul.f32	s17, s17, s15
	yB = tanhf(f->g*yH) + f->s1;
   288d0:	ee29 aa28 	vmul.f32	s20, s18, s17
   288d4:	eeb0 0a4a 	vmov.f32	s0, s20
   288d8:	f004 fc40 	bl	2d15c <tanhf>
   288dc:	ee38 8a00 	vadd.f32	s16, s16, s0
	yL = tanhf(f->g*yB) + f->s2;
   288e0:	ee29 9a08 	vmul.f32	s18, s18, s16
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   288e4:	ee3a aa08 	vadd.f32	s20, s20, s16
	yL = tanhf(f->g*yB) + f->s2;
   288e8:	eeb0 0a49 	vmov.f32	s0, s18
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   288ec:	ed84 aa02 	vstr	s20, [r4, #8]
	yL = tanhf(f->g*yB) + f->s2;
   288f0:	f004 fc34 	bl	2d15c <tanhf>
	return f->cL*yL + f->cB*yB + f->cH*yH;
   288f4:	edd4 7a08 	vldr	s15, [r4, #32]
	yL = tanhf(f->g*yB) + f->s2;
   288f8:	ee79 9a80 	vadd.f32	s19, s19, s0
	return f->cL*yL + f->cB*yB + f->cH*yH;
   288fc:	ed94 7a07 	vldr	s14, [r4, #28]
   28900:	ee28 0a27 	vmul.f32	s0, s16, s15
   28904:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   28908:	ee39 9a29 	vadd.f32	s18, s18, s19
	return f->cL*yL + f->cB*yB + f->cH*yH;
   2890c:	eea7 0a29 	vfma.f32	s0, s14, s19
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   28910:	ed84 9a03 	vstr	s18, [r4, #12]
}
   28914:	eea7 0aa8 	vfma.f32	s0, s15, s17
   28918:	ecbd 8b06 	vpop	{d8-d10}
   2891c:	bd10      	pop	{r4, pc}
   2891e:	bf00      	nop

00028920 <tVZFilter_tickEfficient>:
	_tVZFilter* f = *vf;
   28920:	6803      	ldr	r3, [r0, #0]
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
   28922:	ed93 7a02 	vldr	s14, [r3, #8]
   28926:	edd3 7a05 	vldr	s15, [r3, #20]
   2892a:	edd3 5a04 	vldr	s11, [r3, #16]
   2892e:	eea7 0ac7 	vfms.f32	s0, s15, s14
   28932:	ed93 6a03 	vldr	s12, [r3, #12]
   28936:	ed93 4a06 	vldr	s8, [r3, #24]
	return f->cL*yL + f->cB*yB + f->cH*yH;
   2893a:	edd3 6a09 	vldr	s13, [r3, #36]	; 0x24
   2893e:	edd3 4a08 	vldr	s9, [r3, #32]
   28942:	ed93 5a07 	vldr	s10, [r3, #28]
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
   28946:	eea7 0a65 	vfms.f32	s0, s14, s11
   2894a:	ee70 7a46 	vsub.f32	s15, s0, s12
   2894e:	ee67 7a84 	vmul.f32	s15, s15, s8
	yB = (f->g*yH) + f->s1;
   28952:	eea5 7aa7 	vfma.f32	s14, s11, s15
	return f->cL*yL + f->cB*yB + f->cH*yH;
   28956:	ee27 0aa6 	vmul.f32	s0, s15, s13
	yL = (f->g*yB) + f->s2;
   2895a:	eef0 6a46 	vmov.f32	s13, s12
   2895e:	eee5 6a87 	vfma.f32	s13, s11, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   28962:	eeb0 6a47 	vmov.f32	s12, s14
	return f->cL*yL + f->cB*yB + f->cH*yH;
   28966:	eea4 0a87 	vfma.f32	s0, s9, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   2896a:	eea5 6aa7 	vfma.f32	s12, s11, s15
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   2896e:	eef0 7a66 	vmov.f32	s15, s13
}
   28972:	eea5 0a26 	vfma.f32	s0, s10, s13
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   28976:	eee5 7a87 	vfma.f32	s15, s11, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   2897a:	ed83 6a02 	vstr	s12, [r3, #8]
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   2897e:	edc3 7a03 	vstr	s15, [r3, #12]
}
   28982:	4770      	bx	lr

00028984 <tVZFilter_setFreq>:
{
   28984:	b538      	push	{r3, r4, r5, lr}
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   28986:	4be3      	ldr	r3, [pc, #908]	; (28d14 <tVZFilter_setFreq+0x390>)
   28988:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	_tVZFilter* f = *vf;
   2898c:	6804      	ldr	r4, [r0, #0]
{
   2898e:	4605      	mov	r5, r0
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   28990:	eef0 0a40 	vmov.f32	s1, s0
   28994:	ed9f 0ae0 	vldr	s0, [pc, #896]	; 28d18 <tVZFilter_setFreq+0x394>
{
   28998:	ed2d 8b04 	vpush	{d8-d9}
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   2899c:	ed93 1a00 	vldr	s2, [r3]
   289a0:	ee21 1a27 	vmul.f32	s2, s2, s15
   289a4:	f000 fec0 	bl	29728 <LEAF_clip>
   289a8:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
	_tVZFilter* f = *vf;
   289ac:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   289ae:	eddf 7adb 	vldr	s15, [pc, #876]	; 28d1c <tVZFilter_setFreq+0x398>
   289b2:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   289b6:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   289ba:	ee28 8a07 	vmul.f32	s16, s16, s14
   289be:	ee28 8a27 	vmul.f32	s16, s16, s15
   289c2:	eeb0 0a48 	vmov.f32	s0, s16
   289c6:	f004 fba1 	bl	2d10c <tanf>
	  switch( f->type )
   289ca:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   289cc:	eef0 8a40 	vmov.f32	s17, s0
   289d0:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   289d4:	2b0a      	cmp	r3, #10
   289d6:	f200 81b0 	bhi.w	28d3a <tVZFilter_setFreq+0x3b6>
   289da:	e8df f013 	tbh	[pc, r3, lsl #1]
   289de:	0053      	.short	0x0053
   289e0:	0069005e 	.word	0x0069005e
   289e4:	00ab0074 	.word	0x00ab0074
   289e8:	011600e3 	.word	0x011600e3
   289ec:	01560136 	.word	0x01560136
   289f0:	000b01a3 	.word	0x000b01a3
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   289f4:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   289f8:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   289fc:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   289fe:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28a02:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28a06:	f004 fa43 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28a0a:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   28a0e:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28a12:	ed9f 7ac2 	vldr	s14, [pc, #776]	; 28d1c <tVZFilter_setFreq+0x398>
   28a16:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28a1a:	ee67 7a87 	vmul.f32	s15, s15, s14
   28a1e:	ee27 0a80 	vmul.f32	s0, s15, s0
   28a22:	f004 fb73 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28a26:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28a2a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28a2e:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28a32:	edc4 7a07 	vstr	s15, [r4, #28]
   28a36:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28a3a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   28a3e:	ee20 0a00 	vmul.f32	s0, s0, s0
   28a42:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28a46:	ee20 0a07 	vmul.f32	s0, s0, s14
   28a4a:	ee67 7aa7 	vmul.f32	s15, s15, s15
   28a4e:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28a52:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28a56:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28a5a:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28a5e:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28a62:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   28a66:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   28a6a:	ee77 7aa8 	vadd.f32	s15, s15, s17
   28a6e:	eef0 6a47 	vmov.f32	s13, s14
   28a72:	eee7 6aa8 	vfma.f32	s13, s15, s17
   28a76:	eec7 7a26 	vdiv.f32	s15, s14, s13
   28a7a:	edc4 7a06 	vstr	s15, [r4, #24]
}
   28a7e:	ecbd 8b04 	vpop	{d8-d9}
   28a82:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28a84:	2300      	movs	r3, #0
   28a86:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28a8a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28a8e:	6262      	str	r2, [r4, #36]	; 0x24
			f->R2 = f->invG;
   28a90:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28a94:	61e3      	str	r3, [r4, #28]
   28a96:	6223      	str	r3, [r4, #32]
   28a98:	e7e5      	b.n	28a66 <tVZFilter_setFreq+0xe2>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28a9a:	2300      	movs	r3, #0
   28a9c:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28aa0:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28aa4:	61e2      	str	r2, [r4, #28]
			f->R2 = f->invG;
   28aa6:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28aaa:	6223      	str	r3, [r4, #32]
   28aac:	6263      	str	r3, [r4, #36]	; 0x24
   28aae:	e7da      	b.n	28a66 <tVZFilter_setFreq+0xe2>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28ab0:	2300      	movs	r3, #0
   28ab2:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28ab6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28aba:	6222      	str	r2, [r4, #32]
			f->R2 = f->invG;
   28abc:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28ac0:	61e3      	str	r3, [r4, #28]
   28ac2:	6263      	str	r3, [r4, #36]	; 0x24
   28ac4:	e7cf      	b.n	28a66 <tVZFilter_setFreq+0xe2>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28ac6:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28aca:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28ace:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28ad0:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28ad4:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28ad8:	f004 f9da 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28adc:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   28ae0:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28ae4:	ed9f 7a8d 	vldr	s14, [pc, #564]	; 28d1c <tVZFilter_setFreq+0x398>
   28ae8:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28aec:	ee67 7a87 	vmul.f32	s15, s15, s14
   28af0:	ee27 0a80 	vmul.f32	s0, s15, s0
   28af4:	f004 fb0a 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28af8:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28afc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   28b00:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28b02:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   28b06:	61e3      	str	r3, [r4, #28]
   28b08:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28b0a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   28b0e:	ee20 0a00 	vmul.f32	s0, s0, s0
   28b12:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28b16:	ee20 0a07 	vmul.f32	s0, s0, s14
   28b1a:	ee67 7aa7 	vmul.f32	s15, s15, s15
   28b1e:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28b22:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28b26:	ee77 7aa7 	vadd.f32	s15, s15, s15
   28b2a:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   28b2e:	edc4 7a08 	vstr	s15, [r4, #32]
   28b32:	e798      	b.n	28a66 <tVZFilter_setFreq+0xe2>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28b34:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28b38:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28b3c:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28b3e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28b42:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28b46:	f004 f9a3 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28b4a:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   28b4e:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28b52:	ed9f 7a72 	vldr	s14, [pc, #456]	; 28d1c <tVZFilter_setFreq+0x398>
   28b56:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28b5a:	ee67 7a87 	vmul.f32	s15, s15, s14
   28b5e:	ee27 0a80 	vmul.f32	s0, s15, s0
   28b62:	f004 fad3 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28b66:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28b6a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   28b6e:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28b70:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   28b74:	6223      	str	r3, [r4, #32]
   28b76:	edc4 7a07 	vstr	s15, [r4, #28]
   28b7a:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28b7e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   28b82:	ee20 0a00 	vmul.f32	s0, s0, s0
   28b86:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28b8a:	ee20 0a07 	vmul.f32	s0, s0, s14
   28b8e:	ee67 7aa7 	vmul.f32	s15, s15, s15
   28b92:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28b96:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28b9a:	ee77 7aa7 	vadd.f32	s15, s15, s15
   28b9e:	edc4 7a05 	vstr	s15, [r4, #20]
   28ba2:	e760      	b.n	28a66 <tVZFilter_setFreq+0xe2>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   28ba4:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28ba8:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   28bac:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28bb0:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28bb4:	f004 f96c 	bl	2ce90 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28bb8:	ee28 0a00 	vmul.f32	s0, s16, s0
   28bbc:	f004 faa6 	bl	2d10c <tanf>
			float r  = f->g/wl;
   28bc0:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28bc4:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   28bc8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   28bcc:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   28bd0:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28bd4:	edc4 7a07 	vstr	s15, [r4, #28]
   28bd8:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28bdc:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   28be0:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28be4:	eee0 7a00 	vfma.f32	s15, s0, s0
   28be8:	ee87 6a80 	vdiv.f32	s12, s15, s0
   28bec:	ee76 7a65 	vsub.f32	s15, s12, s11
   28bf0:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   28bf4:	eef1 7ac6 	vsqrt.f32	s15, s12
   28bf8:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28bfc:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28c00:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28c04:	ed84 7a08 	vstr	s14, [r4, #32]
   28c08:	e72d      	b.n	28a66 <tVZFilter_setFreq+0xe2>
			float A = sqrtf(f->G);
   28c0a:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   28c0e:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28c12:	eddf 7a43 	vldr	s15, [pc, #268]	; 28d20 <tVZFilter_setFreq+0x39c>
			float A = sqrtf(f->G);
   28c16:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28c1a:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   28c1e:	ee20 0a27 	vmul.f32	s0, s0, s15
   28c22:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   28c26:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   28c2a:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28c2e:	f004 fd57 	bl	2d6e0 <sinhf>
   28c32:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   28c36:	ed84 9a07 	vstr	s18, [r4, #28]
   28c3a:	6265      	str	r5, [r4, #36]	; 0x24
   28c3c:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28c40:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   28c44:	ed84 8a08 	vstr	s16, [r4, #32]
   28c48:	e70d      	b.n	28a66 <tVZFilter_setFreq+0xe2>
		  float A = sqrtf(f->G);
   28c4a:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   28c4e:	eddf 7a34 	vldr	s15, [pc, #208]	; 28d20 <tVZFilter_setFreq+0x39c>
		  float A = sqrtf(f->G);
   28c52:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   28c56:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   28c5a:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   28c5e:	eef1 7ac8 	vsqrt.f32	s15, s16
   28c62:	ee68 8aa7 	vmul.f32	s17, s17, s15
   28c66:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   28c6a:	f004 fd39 	bl	2d6e0 <sinhf>
   28c6e:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   28c72:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   28c76:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   28c7a:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   28c7e:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   28c82:	61e3      	str	r3, [r4, #28]
   28c84:	ed84 8a08 	vstr	s16, [r4, #32]
   28c88:	e6ed      	b.n	28a66 <tVZFilter_setFreq+0xe2>
		  float x  = 2.0f*f->m-1.0f;
   28c8a:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   28c8e:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   28c92:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   28c96:	6b23      	ldr	r3, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   28c98:	eddf 0a1f 	vldr	s1, [pc, #124]	; 28d18 <tVZFilter_setFreq+0x394>
			f->R2 = f->invG;
   28c9c:	6163      	str	r3, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   28c9e:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   28ca2:	eef1 8a48 	vneg.f32	s17, s16
   28ca6:	eeb0 0a68 	vmov.f32	s0, s17
   28caa:	f000 ff1d 	bl	29ae8 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   28cae:	eddf 0a1a 	vldr	s1, [pc, #104]	; 28d18 <tVZFilter_setFreq+0x394>
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   28cb2:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   28cb6:	eeb0 0a48 	vmov.f32	s0, s16
   28cba:	f000 ff19 	bl	29af0 <minimum>
		  f->cB = 1.0f-x*x;
   28cbe:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   28cc2:	edd4 6a07 	vldr	s13, [r4, #28]
   28cc6:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   28cca:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   28cce:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   28cd2:	ee36 5aa6 	vadd.f32	s10, s13, s13
   28cd6:	edd4 8a04 	vldr	s17, [r4, #16]
   28cda:	ee67 4aa7 	vmul.f32	s9, s15, s15
   28cde:	ee27 6a07 	vmul.f32	s12, s14, s14
   28ce2:	eea6 6aa6 	vfma.f32	s12, s13, s13
   28ce6:	eea0 6a00 	vfma.f32	s12, s0, s0
   28cea:	eea0 6a45 	vfms.f32	s12, s0, s10
   28cee:	ee84 5a86 	vdiv.f32	s10, s9, s12
   28cf2:	eeb1 6ac5 	vsqrt.f32	s12, s10
   28cf6:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   28cfa:	ee66 6a86 	vmul.f32	s13, s13, s12
   28cfe:	ee27 7a06 	vmul.f32	s14, s14, s12
   28d02:	ee20 0a06 	vmul.f32	s0, s0, s12
   28d06:	edc4 6a07 	vstr	s13, [r4, #28]
   28d0a:	ed84 7a08 	vstr	s14, [r4, #32]
   28d0e:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   28d12:	e6a8      	b.n	28a66 <tVZFilter_setFreq+0xe2>
   28d14:	020fbd68 	.word	0x020fbd68
   28d18:	00000000 	.word	0x00000000
   28d1c:	40490fdb 	.word	0x40490fdb
   28d20:	3eb17218 	.word	0x3eb17218
		  f->cL = 1.0f;
   28d24:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   28d28:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   28d2c:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   28d2e:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   28d32:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   28d34:	edc4 7a08 	vstr	s15, [r4, #32]
   28d38:	e695      	b.n	28a66 <tVZFilter_setFreq+0xe2>
   28d3a:	edd4 7a05 	vldr	s15, [r4, #20]
   28d3e:	e692      	b.n	28a66 <tVZFilter_setFreq+0xe2>

00028d40 <tVZFilter_setFreqAndBandwidth>:
{
   28d40:	b538      	push	{r3, r4, r5, lr}
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   28d42:	ed9f 1ac6 	vldr	s2, [pc, #792]	; 2905c <tVZFilter_setFreqAndBandwidth+0x31c>
{
   28d46:	4605      	mov	r5, r0
	_tVZFilter* f = *vf;
   28d48:	6804      	ldr	r4, [r0, #0]
{
   28d4a:	ed2d 8b04 	vpush	{d8-d9}
   28d4e:	eeb0 8a40 	vmov.f32	s16, s0
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   28d52:	ed9f 0ac6 	vldr	s0, [pc, #792]	; 2906c <tVZFilter_setFreqAndBandwidth+0x32c>
   28d56:	f000 fce7 	bl	29728 <LEAF_clip>
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   28d5a:	4bc1      	ldr	r3, [pc, #772]	; (29060 <tVZFilter_setFreqAndBandwidth+0x320>)
   28d5c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   28d60:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   28d64:	ed93 1a00 	vldr	s2, [r3]
   28d68:	eef0 0a48 	vmov.f32	s1, s16
   28d6c:	ed9f 0abf 	vldr	s0, [pc, #764]	; 2906c <tVZFilter_setFreqAndBandwidth+0x32c>
   28d70:	ee21 1a27 	vmul.f32	s2, s2, s15
   28d74:	f000 fcd8 	bl	29728 <LEAF_clip>
   28d78:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
	_tVZFilter* f = *vf;
   28d7c:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   28d7e:	eddf 7ab9 	vldr	s15, [pc, #740]	; 29064 <tVZFilter_setFreqAndBandwidth+0x324>
   28d82:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   28d86:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   28d8a:	ee28 8a07 	vmul.f32	s16, s16, s14
   28d8e:	ee28 8a27 	vmul.f32	s16, s16, s15
   28d92:	eeb0 0a48 	vmov.f32	s0, s16
   28d96:	f004 f9b9 	bl	2d10c <tanf>
	  switch( f->type )
   28d9a:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   28d9c:	eef0 8a40 	vmov.f32	s17, s0
   28da0:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   28da4:	2b0a      	cmp	r3, #10
   28da6:	f200 81b3 	bhi.w	29110 <tVZFilter_setFreqAndBandwidth+0x3d0>
   28daa:	e8df f013 	tbh	[pc, r3, lsl #1]
   28dae:	0053      	.short	0x0053
   28db0:	0069005e 	.word	0x0069005e
   28db4:	00ab0074 	.word	0x00ab0074
   28db8:	011600e3 	.word	0x011600e3
   28dbc:	01610136 	.word	0x01610136
   28dc0:	000b01a6 	.word	0x000b01a6
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28dc4:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28dc8:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28dcc:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28dce:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28dd2:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28dd6:	f004 f85b 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28dda:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   28dde:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28de2:	ed9f 7aa0 	vldr	s14, [pc, #640]	; 29064 <tVZFilter_setFreqAndBandwidth+0x324>
   28de6:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28dea:	ee67 7a87 	vmul.f32	s15, s15, s14
   28dee:	ee27 0a80 	vmul.f32	s0, s15, s0
   28df2:	f004 f98b 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28df6:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28dfa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28dfe:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28e02:	edc4 7a07 	vstr	s15, [r4, #28]
   28e06:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28e0a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   28e0e:	ee20 0a00 	vmul.f32	s0, s0, s0
   28e12:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28e16:	ee20 0a07 	vmul.f32	s0, s0, s14
   28e1a:	ee67 7aa7 	vmul.f32	s15, s15, s15
   28e1e:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28e22:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28e26:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28e2a:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28e2e:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28e32:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   28e36:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   28e3a:	ee77 7aa8 	vadd.f32	s15, s15, s17
   28e3e:	eef0 6a47 	vmov.f32	s13, s14
   28e42:	eee7 6aa8 	vfma.f32	s13, s15, s17
   28e46:	eec7 7a26 	vdiv.f32	s15, s14, s13
   28e4a:	edc4 7a06 	vstr	s15, [r4, #24]
}
   28e4e:	ecbd 8b04 	vpop	{d8-d9}
   28e52:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28e54:	2300      	movs	r3, #0
   28e56:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28e5a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28e5e:	6262      	str	r2, [r4, #36]	; 0x24
			f->R2 = f->invG;
   28e60:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28e64:	61e3      	str	r3, [r4, #28]
   28e66:	6223      	str	r3, [r4, #32]
   28e68:	e7e5      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28e6a:	2300      	movs	r3, #0
   28e6c:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28e70:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28e74:	61e2      	str	r2, [r4, #28]
			f->R2 = f->invG;
   28e76:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28e7a:	6223      	str	r3, [r4, #32]
   28e7c:	6263      	str	r3, [r4, #36]	; 0x24
   28e7e:	e7da      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28e80:	2300      	movs	r3, #0
   28e82:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28e86:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28e8a:	6222      	str	r2, [r4, #32]
			f->R2 = f->invG;
   28e8c:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28e90:	61e3      	str	r3, [r4, #28]
   28e92:	6263      	str	r3, [r4, #36]	; 0x24
   28e94:	e7cf      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28e96:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28e9a:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28e9e:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28ea0:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28ea4:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28ea8:	f003 fff2 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28eac:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   28eb0:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28eb4:	ed9f 7a6b 	vldr	s14, [pc, #428]	; 29064 <tVZFilter_setFreqAndBandwidth+0x324>
   28eb8:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28ebc:	ee67 7a87 	vmul.f32	s15, s15, s14
   28ec0:	ee27 0a80 	vmul.f32	s0, s15, s0
   28ec4:	f004 f922 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28ec8:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28ecc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   28ed0:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28ed2:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   28ed6:	61e3      	str	r3, [r4, #28]
   28ed8:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28eda:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   28ede:	ee20 0a00 	vmul.f32	s0, s0, s0
   28ee2:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28ee6:	ee20 0a07 	vmul.f32	s0, s0, s14
   28eea:	ee67 7aa7 	vmul.f32	s15, s15, s15
   28eee:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28ef2:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28ef6:	ee77 7aa7 	vadd.f32	s15, s15, s15
   28efa:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   28efe:	edc4 7a08 	vstr	s15, [r4, #32]
   28f02:	e798      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28f04:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28f08:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28f0c:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28f0e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28f12:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28f16:	f003 ffbb 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28f1a:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   28f1e:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28f22:	ed9f 7a50 	vldr	s14, [pc, #320]	; 29064 <tVZFilter_setFreqAndBandwidth+0x324>
   28f26:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28f2a:	ee67 7a87 	vmul.f32	s15, s15, s14
   28f2e:	ee27 0a80 	vmul.f32	s0, s15, s0
   28f32:	f004 f8eb 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28f36:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28f3a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   28f3e:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28f40:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   28f44:	6223      	str	r3, [r4, #32]
   28f46:	edc4 7a07 	vstr	s15, [r4, #28]
   28f4a:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28f4e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   28f52:	ee20 0a00 	vmul.f32	s0, s0, s0
   28f56:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28f5a:	ee20 0a07 	vmul.f32	s0, s0, s14
   28f5e:	ee67 7aa7 	vmul.f32	s15, s15, s15
   28f62:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28f66:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28f6a:	ee77 7aa7 	vadd.f32	s15, s15, s15
   28f6e:	edc4 7a05 	vstr	s15, [r4, #20]
   28f72:	e760      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   28f74:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28f78:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   28f7c:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28f80:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28f84:	f003 ff84 	bl	2ce90 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28f88:	ee28 0a00 	vmul.f32	s0, s16, s0
   28f8c:	f004 f8be 	bl	2d10c <tanf>
			float r  = f->g/wl;
   28f90:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28f94:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   28f98:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   28f9c:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   28fa0:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28fa4:	edc4 7a07 	vstr	s15, [r4, #28]
   28fa8:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28fac:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   28fb0:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28fb4:	eee0 7a00 	vfma.f32	s15, s0, s0
   28fb8:	ee87 6a80 	vdiv.f32	s12, s15, s0
   28fbc:	ee76 7a65 	vsub.f32	s15, s12, s11
   28fc0:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   28fc4:	eef1 7ac6 	vsqrt.f32	s15, s12
   28fc8:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28fcc:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28fd0:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28fd4:	ed84 7a08 	vstr	s14, [r4, #32]
   28fd8:	e72d      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
			float A = sqrtf(f->G);
   28fda:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   28fde:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28fe2:	eddf 7a21 	vldr	s15, [pc, #132]	; 29068 <tVZFilter_setFreqAndBandwidth+0x328>
			float A = sqrtf(f->G);
   28fe6:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28fea:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   28fee:	ee20 0a27 	vmul.f32	s0, s0, s15
   28ff2:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   28ff6:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   28ffa:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28ffe:	f004 fb6f 	bl	2d6e0 <sinhf>
   29002:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   29006:	ed84 9a07 	vstr	s18, [r4, #28]
   2900a:	6265      	str	r5, [r4, #36]	; 0x24
   2900c:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   29010:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   29014:	ed84 8a08 	vstr	s16, [r4, #32]
   29018:	e70d      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
		  float A = sqrtf(f->G);
   2901a:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2901e:	eddf 7a12 	vldr	s15, [pc, #72]	; 29068 <tVZFilter_setFreqAndBandwidth+0x328>
		  float A = sqrtf(f->G);
   29022:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   29026:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   2902a:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2902e:	eef1 7ac8 	vsqrt.f32	s15, s16
   29032:	ee68 8aa7 	vmul.f32	s17, s17, s15
   29036:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2903a:	f004 fb51 	bl	2d6e0 <sinhf>
   2903e:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   29042:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   29046:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   2904a:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2904e:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   29052:	61e3      	str	r3, [r4, #28]
   29054:	ed84 8a08 	vstr	s16, [r4, #32]
   29058:	e6ed      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
   2905a:	bf00      	nop
   2905c:	42c80000 	.word	0x42c80000
   29060:	020fbd68 	.word	0x020fbd68
   29064:	40490fdb 	.word	0x40490fdb
   29068:	3eb17218 	.word	0x3eb17218
   2906c:	00000000 	.word	0x00000000
		  float x  = 2.0f*f->m-1.0f;
   29070:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   29074:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   29078:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   2907c:	6b23      	ldr	r3, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2907e:	ed5f 0a05 	vldr	s1, [pc, #-20]	; 2906c <tVZFilter_setFreqAndBandwidth+0x32c>
			f->R2 = f->invG;
   29082:	6163      	str	r3, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   29084:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   29088:	eef1 8a48 	vneg.f32	s17, s16
   2908c:	eeb0 0a68 	vmov.f32	s0, s17
   29090:	f000 fd2a 	bl	29ae8 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   29094:	ed5f 0a0b 	vldr	s1, [pc, #-44]	; 2906c <tVZFilter_setFreqAndBandwidth+0x32c>
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   29098:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2909c:	eeb0 0a48 	vmov.f32	s0, s16
   290a0:	f000 fd26 	bl	29af0 <minimum>
		  f->cB = 1.0f-x*x;
   290a4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   290a8:	edd4 6a07 	vldr	s13, [r4, #28]
   290ac:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   290b0:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   290b4:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   290b8:	ee36 5aa6 	vadd.f32	s10, s13, s13
   290bc:	edd4 8a04 	vldr	s17, [r4, #16]
   290c0:	ee67 4aa7 	vmul.f32	s9, s15, s15
   290c4:	ee27 6a07 	vmul.f32	s12, s14, s14
   290c8:	eea6 6aa6 	vfma.f32	s12, s13, s13
   290cc:	eea0 6a00 	vfma.f32	s12, s0, s0
   290d0:	eea0 6a45 	vfms.f32	s12, s0, s10
   290d4:	ee84 5a86 	vdiv.f32	s10, s9, s12
   290d8:	eeb1 6ac5 	vsqrt.f32	s12, s10
   290dc:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   290e0:	ee66 6a86 	vmul.f32	s13, s13, s12
   290e4:	ee27 7a06 	vmul.f32	s14, s14, s12
   290e8:	ee20 0a06 	vmul.f32	s0, s0, s12
   290ec:	edc4 6a07 	vstr	s13, [r4, #28]
   290f0:	ed84 7a08 	vstr	s14, [r4, #32]
   290f4:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   290f8:	e69d      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
		  f->cL = 1.0f;
   290fa:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   290fe:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   29102:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   29104:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   29108:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   2910a:	edc4 7a08 	vstr	s15, [r4, #32]
   2910e:	e692      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
   29110:	edd4 7a05 	vldr	s15, [r4, #20]
   29114:	e68f      	b.n	28e36 <tVZFilter_setFreqAndBandwidth+0xf6>
   29116:	bf00      	nop

00029118 <tVZFilter_setGain>:
{
   29118:	b538      	push	{r3, r4, r5, lr}
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   2911a:	eef0 0a40 	vmov.f32	s1, s0
   2911e:	ed9f 1ae3 	vldr	s2, [pc, #908]	; 294ac <tVZFilter_setGain+0x394>
   29122:	ed9f 0ae3 	vldr	s0, [pc, #908]	; 294b0 <tVZFilter_setGain+0x398>
{
   29126:	4605      	mov	r5, r0
	_tVZFilter* f = *vf;
   29128:	6804      	ldr	r4, [r0, #0]
{
   2912a:	ed2d 8b04 	vpush	{d8-d9}
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   2912e:	f000 fafb 	bl	29728 <LEAF_clip>
	f->invG = 1.0f/f->G;
   29132:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   29136:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2913a:	eddf 7ade 	vldr	s15, [pc, #888]	; 294b4 <tVZFilter_setGain+0x39c>
	f->invG = 1.0f/f->G;
   2913e:	ee86 7a80 	vdiv.f32	s14, s13, s0
   29142:	ed84 7a0c 	vstr	s14, [r4, #48]	; 0x30
	_tVZFilter* f = *vf;
   29146:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   29148:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   2914c:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   29150:	ee28 8a07 	vmul.f32	s16, s16, s14
   29154:	ee28 8a27 	vmul.f32	s16, s16, s15
   29158:	eeb0 0a48 	vmov.f32	s0, s16
   2915c:	f003 ffd6 	bl	2d10c <tanf>
	  switch( f->type )
   29160:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   29162:	eef0 8a40 	vmov.f32	s17, s0
   29166:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   2916a:	2b0a      	cmp	r3, #10
   2916c:	f200 81b3 	bhi.w	294d6 <tVZFilter_setGain+0x3be>
   29170:	e8df f013 	tbh	[pc, r3, lsl #1]
   29174:	005e0053 	.word	0x005e0053
   29178:	00740069 	.word	0x00740069
   2917c:	00e300ab 	.word	0x00e300ab
   29180:	01360116 	.word	0x01360116
   29184:	01a60156 	.word	0x01a60156
   29188:	000b      	.short	0x000b
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2918a:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2918e:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   29192:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   29194:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   29198:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2919c:	f003 fe78 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   291a0:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   291a4:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   291a8:	ed9f 7ac2 	vldr	s14, [pc, #776]	; 294b4 <tVZFilter_setGain+0x39c>
   291ac:	ee67 7aa6 	vmul.f32	s15, s15, s13
   291b0:	ee67 7a87 	vmul.f32	s15, s15, s14
   291b4:	ee27 0a80 	vmul.f32	s0, s15, s0
   291b8:	f003 ffa8 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   291bc:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   291c0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   291c4:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   291c8:	edc4 7a07 	vstr	s15, [r4, #28]
   291cc:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   291d0:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   291d4:	ee20 0a00 	vmul.f32	s0, s0, s0
   291d8:	ee77 7ac0 	vsub.f32	s15, s15, s0
   291dc:	ee20 0a07 	vmul.f32	s0, s0, s14
   291e0:	ee67 7aa7 	vmul.f32	s15, s15, s15
   291e4:	ee87 7a80 	vdiv.f32	s14, s15, s0
   291e8:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   291ec:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   291f0:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   291f4:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   291f8:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   291fc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   29200:	ee77 7aa8 	vadd.f32	s15, s15, s17
   29204:	eef0 6a47 	vmov.f32	s13, s14
   29208:	eee7 6aa8 	vfma.f32	s13, s15, s17
   2920c:	eec7 7a26 	vdiv.f32	s15, s14, s13
   29210:	edc4 7a06 	vstr	s15, [r4, #24]
}
   29214:	ecbd 8b04 	vpop	{d8-d9}
   29218:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2921a:	2300      	movs	r3, #0
   2921c:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   29220:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   29224:	6262      	str	r2, [r4, #36]	; 0x24
			f->R2 = f->invG;
   29226:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2922a:	61e3      	str	r3, [r4, #28]
   2922c:	6223      	str	r3, [r4, #32]
   2922e:	e7e5      	b.n	291fc <tVZFilter_setGain+0xe4>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   29230:	2300      	movs	r3, #0
   29232:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   29236:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   2923a:	61e2      	str	r2, [r4, #28]
			f->R2 = f->invG;
   2923c:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   29240:	6223      	str	r3, [r4, #32]
   29242:	6263      	str	r3, [r4, #36]	; 0x24
   29244:	e7da      	b.n	291fc <tVZFilter_setGain+0xe4>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   29246:	2300      	movs	r3, #0
   29248:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2924c:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   29250:	6222      	str	r2, [r4, #32]
			f->R2 = f->invG;
   29252:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   29256:	61e3      	str	r3, [r4, #28]
   29258:	6263      	str	r3, [r4, #36]	; 0x24
   2925a:	e7cf      	b.n	291fc <tVZFilter_setGain+0xe4>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2925c:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   29260:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   29264:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   29266:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2926a:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2926e:	f003 fe0f 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   29272:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   29276:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2927a:	ed9f 7a8e 	vldr	s14, [pc, #568]	; 294b4 <tVZFilter_setGain+0x39c>
   2927e:	ee67 7aa6 	vmul.f32	s15, s15, s13
   29282:	ee67 7a87 	vmul.f32	s15, s15, s14
   29286:	ee27 0a80 	vmul.f32	s0, s15, s0
   2928a:	f003 ff3f 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2928e:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   29292:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   29296:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   29298:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2929c:	61e3      	str	r3, [r4, #28]
   2929e:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   292a0:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   292a4:	ee20 0a00 	vmul.f32	s0, s0, s0
   292a8:	ee77 7ac0 	vsub.f32	s15, s15, s0
   292ac:	ee20 0a07 	vmul.f32	s0, s0, s14
   292b0:	ee67 7aa7 	vmul.f32	s15, s15, s15
   292b4:	ee87 7a80 	vdiv.f32	s14, s15, s0
   292b8:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   292bc:	ee77 7aa7 	vadd.f32	s15, s15, s15
   292c0:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   292c4:	edc4 7a08 	vstr	s15, [r4, #32]
   292c8:	e798      	b.n	291fc <tVZFilter_setGain+0xe4>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   292ca:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   292ce:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   292d2:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   292d4:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   292d8:	ee60 0aa7 	vmul.f32	s1, s1, s15
   292dc:	f003 fdd8 	bl	2ce90 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   292e0:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   292e4:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   292e8:	ed9f 7a72 	vldr	s14, [pc, #456]	; 294b4 <tVZFilter_setGain+0x39c>
   292ec:	ee67 7aa6 	vmul.f32	s15, s15, s13
   292f0:	ee67 7a87 	vmul.f32	s15, s15, s14
   292f4:	ee27 0a80 	vmul.f32	s0, s15, s0
   292f8:	f003 ff08 	bl	2d10c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   292fc:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   29300:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   29304:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   29306:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2930a:	6223      	str	r3, [r4, #32]
   2930c:	edc4 7a07 	vstr	s15, [r4, #28]
   29310:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   29314:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   29318:	ee20 0a00 	vmul.f32	s0, s0, s0
   2931c:	ee77 7ac0 	vsub.f32	s15, s15, s0
   29320:	ee20 0a07 	vmul.f32	s0, s0, s14
   29324:	ee67 7aa7 	vmul.f32	s15, s15, s15
   29328:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2932c:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   29330:	ee77 7aa7 	vadd.f32	s15, s15, s15
   29334:	edc4 7a05 	vstr	s15, [r4, #20]
   29338:	e760      	b.n	291fc <tVZFilter_setGain+0xe4>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   2933a:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2933e:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   29342:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   29346:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2934a:	f003 fda1 	bl	2ce90 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2934e:	ee28 0a00 	vmul.f32	s0, s16, s0
   29352:	f003 fedb 	bl	2d10c <tanf>
			float r  = f->g/wl;
   29356:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2935a:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   2935e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   29362:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   29366:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2936a:	edc4 7a07 	vstr	s15, [r4, #28]
   2936e:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   29372:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   29376:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2937a:	eee0 7a00 	vfma.f32	s15, s0, s0
   2937e:	ee87 6a80 	vdiv.f32	s12, s15, s0
   29382:	ee76 7a65 	vsub.f32	s15, s12, s11
   29386:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   2938a:	eef1 7ac6 	vsqrt.f32	s15, s12
   2938e:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   29392:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   29396:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2939a:	ed84 7a08 	vstr	s14, [r4, #32]
   2939e:	e72d      	b.n	291fc <tVZFilter_setGain+0xe4>
			float A = sqrtf(f->G);
   293a0:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   293a4:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   293a8:	eddf 7a43 	vldr	s15, [pc, #268]	; 294b8 <tVZFilter_setGain+0x3a0>
			float A = sqrtf(f->G);
   293ac:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   293b0:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   293b4:	ee20 0a27 	vmul.f32	s0, s0, s15
   293b8:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   293bc:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   293c0:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   293c4:	f004 f98c 	bl	2d6e0 <sinhf>
   293c8:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   293cc:	ed84 9a07 	vstr	s18, [r4, #28]
   293d0:	6265      	str	r5, [r4, #36]	; 0x24
   293d2:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   293d6:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   293da:	ed84 8a08 	vstr	s16, [r4, #32]
   293de:	e70d      	b.n	291fc <tVZFilter_setGain+0xe4>
		  float A = sqrtf(f->G);
   293e0:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   293e4:	eddf 7a34 	vldr	s15, [pc, #208]	; 294b8 <tVZFilter_setGain+0x3a0>
		  float A = sqrtf(f->G);
   293e8:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   293ec:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   293f0:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   293f4:	eef1 7ac8 	vsqrt.f32	s15, s16
   293f8:	ee68 8aa7 	vmul.f32	s17, s17, s15
   293fc:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   29400:	f004 f96e 	bl	2d6e0 <sinhf>
   29404:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   29408:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   2940c:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   29410:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   29414:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   29418:	61e3      	str	r3, [r4, #28]
   2941a:	ed84 8a08 	vstr	s16, [r4, #32]
   2941e:	e6ed      	b.n	291fc <tVZFilter_setGain+0xe4>
		  float x  = 2.0f*f->m-1.0f;
   29420:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   29424:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   29428:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   2942c:	6b23      	ldr	r3, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2942e:	eddf 0a23 	vldr	s1, [pc, #140]	; 294bc <tVZFilter_setGain+0x3a4>
			f->R2 = f->invG;
   29432:	6163      	str	r3, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   29434:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   29438:	eef1 8a48 	vneg.f32	s17, s16
   2943c:	eeb0 0a68 	vmov.f32	s0, s17
   29440:	f000 fb52 	bl	29ae8 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   29444:	eddf 0a1d 	vldr	s1, [pc, #116]	; 294bc <tVZFilter_setGain+0x3a4>
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   29448:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2944c:	eeb0 0a48 	vmov.f32	s0, s16
   29450:	f000 fb4e 	bl	29af0 <minimum>
		  f->cB = 1.0f-x*x;
   29454:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   29458:	edd4 6a07 	vldr	s13, [r4, #28]
   2945c:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   29460:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   29464:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   29468:	ee36 5aa6 	vadd.f32	s10, s13, s13
   2946c:	edd4 8a04 	vldr	s17, [r4, #16]
   29470:	ee67 4aa7 	vmul.f32	s9, s15, s15
   29474:	ee27 6a07 	vmul.f32	s12, s14, s14
   29478:	eea6 6aa6 	vfma.f32	s12, s13, s13
   2947c:	eea0 6a00 	vfma.f32	s12, s0, s0
   29480:	eea0 6a45 	vfms.f32	s12, s0, s10
   29484:	ee84 5a86 	vdiv.f32	s10, s9, s12
   29488:	eeb1 6ac5 	vsqrt.f32	s12, s10
   2948c:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   29490:	ee66 6a86 	vmul.f32	s13, s13, s12
   29494:	ee27 7a06 	vmul.f32	s14, s14, s12
   29498:	ee20 0a06 	vmul.f32	s0, s0, s12
   2949c:	edc4 6a07 	vstr	s13, [r4, #28]
   294a0:	ed84 7a08 	vstr	s14, [r4, #32]
   294a4:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   294a8:	e6a8      	b.n	291fc <tVZFilter_setGain+0xe4>
   294aa:	bf00      	nop
   294ac:	42c80000 	.word	0x42c80000
   294b0:	358637bd 	.word	0x358637bd
   294b4:	40490fdb 	.word	0x40490fdb
   294b8:	3eb17218 	.word	0x3eb17218
   294bc:	00000000 	.word	0x00000000
		  f->cL = 1.0f;
   294c0:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   294c4:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   294c8:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   294ca:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   294ce:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   294d0:	edc4 7a08 	vstr	s15, [r4, #32]
   294d4:	e692      	b.n	291fc <tVZFilter_setGain+0xe4>
   294d6:	edd4 7a05 	vldr	s15, [r4, #20]
   294da:	e68f      	b.n	291fc <tVZFilter_setGain+0xe4>

000294dc <interpolate3max>:
    return(Y);
}

float interpolate3max(float *buf, const int peakindex)
{
    float a = buf[peakindex-1];
   294dc:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
    float b = buf[peakindex];
    float c = buf[peakindex+1];
    float realpeak;
    
    realpeak = b + (float)0.125 * (c - a) * (c - a) / ((float)2. * b - a - c);
   294e0:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
   294e4:	eef4 5a00 	vmov.f32	s11, #64	; 0x3e000000  0.125
    float a = buf[peakindex-1];
   294e8:	440b      	add	r3, r1
   294ea:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   294ee:	edd0 7a00 	vldr	s15, [r0]
    float c = buf[peakindex+1];
   294f2:	ed90 6a02 	vldr	s12, [r0, #8]
    float b = buf[peakindex];
   294f6:	edd0 6a01 	vldr	s13, [r0, #4]
    realpeak = b + (float)0.125 * (c - a) * (c - a) / ((float)2. * b - a - c);
   294fa:	ee36 7a67 	vsub.f32	s14, s12, s15
   294fe:	eed6 7a85 	vfnms.f32	s15, s13, s10
   29502:	ee27 7a07 	vmul.f32	s14, s14, s14
   29506:	ee27 7a25 	vmul.f32	s14, s14, s11
   2950a:	ee77 7ac6 	vsub.f32	s15, s15, s12
   2950e:	ee87 0a27 	vdiv.f32	s0, s14, s15
    
    return(realpeak);
}
   29512:	ee30 0a26 	vadd.f32	s0, s0, s13
   29516:	4770      	bx	lr

00029518 <interpolate3phase>:

float interpolate3phase(float *buf, const int peakindex)
{
    float a = buf[peakindex-1];
   29518:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
    float b = buf[peakindex];
    float c = buf[peakindex+1];
    float fraction;
    
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
   2951c:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   29520:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    float a = buf[peakindex-1];
   29524:	440b      	add	r3, r1
   29526:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   2952a:	edd0 7a00 	vldr	s15, [r0]
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
   2952e:	edd0 5a01 	vldr	s11, [r0, #4]
   29532:	eeb0 0a67 	vmov.f32	s0, s15
    float c = buf[peakindex+1];
   29536:	ed90 7a02 	vldr	s14, [r0, #8]
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
   2953a:	ee77 7a67 	vsub.f32	s15, s14, s15
   2953e:	ee95 0a86 	vfnms.f32	s0, s11, s12
   29542:	ee67 7aa6 	vmul.f32	s15, s15, s13
   29546:	ee30 0a47 	vsub.f32	s0, s0, s14
    
    return(fraction);
}
   2954a:	ee87 0a80 	vdiv.f32	s0, s15, s0
   2954e:	4770      	bx	lr

00029550 <fastercosf>:
    return fResult;
}

float fastercosf(float fAngle)
{
    float fASqr = fAngle*fAngle;
   29550:	ee20 7a00 	vmul.f32	s14, s0, s0
    float fResult = 3.705e-02f;
    fResult *= fASqr;
    fResult -= 4.967e-01f;
   29554:	eddf 6a05 	vldr	s13, [pc, #20]	; 2956c <fastercosf+0x1c>
   29558:	eddf 7a05 	vldr	s15, [pc, #20]	; 29570 <fastercosf+0x20>
    fResult *= fASqr;
    fResult += 1.0f;
   2955c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    fResult -= 4.967e-01f;
   29560:	eee7 7a26 	vfma.f32	s15, s14, s13
    return fResult;
}
   29564:	eea7 0a27 	vfma.f32	s0, s14, s15
   29568:	4770      	bx	lr
   2956a:	bf00      	nop
   2956c:	3d17c1be 	.word	0x3d17c1be
   29570:	befe4f76 	.word	0xbefe4f76

00029574 <fastabsf>:
        unsigned int ui;
    }alias;
    
    alias.f = f;
    alias.ui &= 0x7fffffff;
    return alias.f;
   29574:	ee10 3a10 	vmov	r3, s0
   29578:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
}
   2957c:	ee00 3a10 	vmov	s0, r3
   29580:	4770      	bx	lr
   29582:	bf00      	nop

00029584 <fastexp2f>:

// fast floating-point exp2 function taken from Robert Bristow Johnson's
// post in the music-dsp list on Date: Tue, 02 Sep 2014 16:50:11 -0400
float fastexp2f(float x)
{
    if (x >= -127.0)
   29584:	eddf 7a1f 	vldr	s15, [pc, #124]	; 29604 <fastexp2f+0x80>
   29588:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2958c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29590:	db34      	blt.n	295fc <fastexp2f+0x78>
    {
        float accumulator, xPower;
        union {float f; int32_t i;} xBits;
        
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   29592:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 29608 <fastexp2f+0x84>
        xPower = x*x;
        accumulator += 0.24137976293709f*xPower;
        xPower *= x;
        accumulator += 0.05203236900844f*xPower;
        xPower *= x;
        accumulator += 0.01355574723481f*xPower;
   29596:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2959a:	eddf 4a1c 	vldr	s9, [pc, #112]	; 2960c <fastexp2f+0x88>
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   2959e:	ee30 7a07 	vadd.f32	s14, s0, s14
        accumulator += 0.01355574723481f*xPower;
   295a2:	eddf 5a1b 	vldr	s11, [pc, #108]	; 29610 <fastexp2f+0x8c>
   295a6:	ed9f 6a1b 	vldr	s12, [pc, #108]	; 29614 <fastexp2f+0x90>
   295aa:	ed9f 5a1b 	vldr	s10, [pc, #108]	; 29618 <fastexp2f+0x94>
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   295ae:	eebd 7ac7 	vcvt.s32.f32	s14, s14
   295b2:	ee17 3a10 	vmov	r3, s14
   295b6:	f5a3 5280 	sub.w	r2, r3, #4096	; 0x1000
   295ba:	ee07 2a10 	vmov	s14, r2
        
        xBits.i += 127;                                                    /* bias integer part */
   295be:	f46f 6278 	mvn.w	r2, #3968	; 0xf80
        x -= (float)(xBits.i);                                             /* fractional part */
   295c2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
        xBits.i += 127;                                                    /* bias integer part */
   295c6:	4413      	add	r3, r2
        xBits.i<<= 23;                                                     /* move biased int part into exponent bits */
   295c8:	05db      	lsls	r3, r3, #23
        x -= (float)(xBits.i);                                             /* fractional part */
   295ca:	ee30 7a47 	vsub.f32	s14, s0, s14
        xPower = x*x;
   295ce:	ee67 6a07 	vmul.f32	s13, s14, s14
        accumulator += 0.01355574723481f*xPower;
   295d2:	eee6 7aa4 	vfma.f32	s15, s13, s9
   295d6:	eeb0 0a67 	vmov.f32	s0, s15
        xPower *= x;
   295da:	ee67 7a26 	vmul.f32	s15, s14, s13
        accumulator += 0.01355574723481f*xPower;
   295de:	eef0 6a46 	vmov.f32	s13, s12
   295e2:	eea7 0aa5 	vfma.f32	s0, s15, s11
   295e6:	eee7 6a85 	vfma.f32	s13, s15, s10
   295ea:	eef0 7a40 	vmov.f32	s15, s0
   295ee:	eee7 7a26 	vfma.f32	s15, s14, s13
        
        return accumulator * xBits.f;
   295f2:	ee07 3a10 	vmov	s14, r3
   295f6:	ee27 0a87 	vmul.f32	s0, s15, s14
   295fa:	4770      	bx	lr
    }
    else
    {
        return 0.0f;
   295fc:	ed9f 0a07 	vldr	s0, [pc, #28]	; 2961c <fastexp2f+0x98>
    }
}
   29600:	4770      	bx	lr
   29602:	bf00      	nop
   29604:	c2fe0000 	.word	0xc2fe0000
   29608:	45800000 	.word	0x45800000
   2960c:	3e772c42 	.word	0x3e772c42
   29610:	3d551fe5 	.word	0x3d551fe5
   29614:	3f316a8e 	.word	0x3f316a8e
   29618:	3c5e18ed 	.word	0x3c5e18ed
   2961c:	00000000 	.word	0x00000000

00029620 <LEAF_crossfade>:
 when t = 0, volumes[0] = 0.707, volumes[1] = 0.707 (equal-power cross fade)
 when t = 1, volumes[0] = 1, volumes[1] = 0
 */

void LEAF_crossfade(float fade, float* volumes) {
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   29620:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   29624:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   29628:	ee30 7a27 	vadd.f32	s14, s0, s15
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   2962c:	ee77 7ac0 	vsub.f32	s15, s15, s0
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   29630:	ee27 7a26 	vmul.f32	s14, s14, s13
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   29634:	ee67 7aa6 	vmul.f32	s15, s15, s13
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   29638:	eef1 6ac7 	vsqrt.f32	s13, s14
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   2963c:	eeb1 7ae7 	vsqrt.f32	s14, s15
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   29640:	edc0 6a00 	vstr	s13, [r0]
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   29644:	ed80 7a01 	vstr	s14, [r0, #4]
}
   29648:	4770      	bx	lr
   2964a:	bf00      	nop

0002964c <LEAF_frequencyToMidi>:
}
#endif

float LEAF_frequencyToMidi(float f)
{
    return (69.0f + 12.0f * log2f(f * INV_440));
   2964c:	eddf 7a07 	vldr	s15, [pc, #28]	; 2966c <LEAF_frequencyToMidi+0x20>
{
   29650:	b508      	push	{r3, lr}
    return (69.0f + 12.0f * log2f(f * INV_440));
   29652:	ee20 0a27 	vmul.f32	s0, s0, s15
   29656:	f003 fb9b 	bl	2cd90 <log2f>
   2965a:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
   2965e:	eddf 7a04 	vldr	s15, [pc, #16]	; 29670 <LEAF_frequencyToMidi+0x24>
}
   29662:	eee0 7a07 	vfma.f32	s15, s0, s14
   29666:	eeb0 0a67 	vmov.f32	s0, s15
   2966a:	bd08      	pop	{r3, pc}
   2966c:	3b14f209 	.word	0x3b14f209
   29670:	428a0000 	.word	0x428a0000

00029674 <LEAF_shaper>:

// Jones shaper
float LEAF_shaper(float input, float m_drive)
{
    float fx = input * 2.0f;    // prescale
   29674:	ee30 0a00 	vadd.f32	s0, s0, s0
   29678:	eddf 6a1a 	vldr	s13, [pc, #104]	; 296e4 <LEAF_shaper+0x70>
   2967c:	eddf 7a1a 	vldr	s15, [pc, #104]	; 296e8 <LEAF_shaper+0x74>
    
    xc = LEAF_clip(-SQRT8, fx, SQRT8);
    xc2 = xc*xc;
    c = 0.5f*fx*(3.0f - (xc2));
    xc4 = xc2 * xc2;
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   29680:	eeb5 7a00 	vmov.f32	s14, #80	; 0x3e800000  0.250
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   29684:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   29688:	ed9f 4a18 	vldr	s8, [pc, #96]	; 296ec <LEAF_shaper+0x78>
   2968c:	fec0 7a67 	vminnm.f32	s15, s0, s15
   29690:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
    xc2 = xc*xc;
   29694:	ee67 7aa7 	vmul.f32	s15, s15, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   29698:	eddf 4a15 	vldr	s9, [pc, #84]	; 296f0 <LEAF_shaper+0x7c>
   2969c:	ee20 6a06 	vmul.f32	s12, s0, s12
    shaperOut *= 0.5f;    // post_scale
   296a0:	ed9f 5a14 	vldr	s10, [pc, #80]	; 296f4 <LEAF_shaper+0x80>
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   296a4:	eef6 6a08 	vmov.f32	s13, #104	; 0x3f400000  0.750
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   296a8:	ee67 3aa7 	vmul.f32	s7, s15, s15
   296ac:	ee27 7a67 	vnmul.f32	s14, s14, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   296b0:	ee27 0aa4 	vmul.f32	s0, s15, s9
    c = 0.5f*fx*(3.0f - (xc2));
   296b4:	eef0 5a08 	vmov.f32	s11, #8	; 0x40400000  3.0
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   296b8:	eea3 7a84 	vfma.f32	s14, s7, s8
   296bc:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    c = 0.5f*fx*(3.0f - (xc2));
   296c0:	ee75 5ae7 	vsub.f32	s11, s11, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   296c4:	ee70 0aa6 	vadd.f32	s1, s1, s13
   296c8:	eef0 7a40 	vmov.f32	s15, s0
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   296cc:	ee37 7a24 	vadd.f32	s14, s14, s9
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   296d0:	eee5 7a86 	vfma.f32	s15, s11, s12
    shaperOut *= 0.5f;    // post_scale
   296d4:	ee20 0a85 	vmul.f32	s0, s1, s10
   296d8:	ee27 0a00 	vmul.f32	s0, s14, s0
    return shaperOut;
}
   296dc:	ee20 0a27 	vmul.f32	s0, s0, s15
   296e0:	4770      	bx	lr
   296e2:	bf00      	nop
   296e4:	c03504f3 	.word	0xc03504f3
   296e8:	403504f3 	.word	0x403504f3
   296ec:	3c800000 	.word	0x3c800000
   296f0:	3d4ccccd 	.word	0x3d4ccccd
   296f4:	3f272f05 	.word	0x3f272f05

000296f8 <LEAF_round>:

// round input to nearest rnd
float LEAF_round (float input, float rnd)
{
    rnd = fabsf(rnd);
   296f8:	eef0 0ae0 	vabs.f32	s1, s1
    
    if (rnd <= 0.0000001f) return input;
   296fc:	eddf 7a06 	vldr	s15, [pc, #24]	; 29718 <LEAF_round+0x20>
   29700:	eef4 0ae7 	vcmpe.f32	s1, s15
   29704:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29708:	d905      	bls.n	29716 <LEAF_round+0x1e>
    
    float scale = 1.f / rnd;
    
    return roundf(input * scale) / scale;
   2970a:	eec0 7a20 	vdiv.f32	s15, s0, s1
   2970e:	feb8 0a67 	vrinta.f32	s0, s15
   29712:	ee20 0a20 	vmul.f32	s0, s0, s1
}
   29716:	4770      	bx	lr
   29718:	33d6bf95 	.word	0x33d6bf95

0002971c <LEAF_bitwise_xor>:
{
    union unholy_t unholy;
    unholy.f = input;
    unholy.i = (unholy.i ^ op);
    
    return unholy.f;
   2971c:	ee10 3a10 	vmov	r3, s0
   29720:	4058      	eors	r0, r3
}
   29722:	ee00 0a10 	vmov	s0, r0
   29726:	4770      	bx	lr

00029728 <LEAF_clip>:

float   LEAF_clip(float min, float val, float max)
{
    float tempmin = min;
    float tempmax = max;
    if (min > max)
   29728:	eeb4 0ac1 	vcmpe.f32	s0, s2
   2972c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29730:	dd05      	ble.n	2973e <LEAF_clip+0x16>
   29732:	eef0 7a40 	vmov.f32	s15, s0
    {
        tempmin = max;
   29736:	eeb0 0a41 	vmov.f32	s0, s2
        tempmax = min;
   2973a:	eeb0 1a67 	vmov.f32	s2, s15
    }
    if (val < tempmin)
   2973e:	eeb4 0ae0 	vcmpe.f32	s0, s1
   29742:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29746:	dc01      	bgt.n	2974c <LEAF_clip+0x24>
   29748:	fe81 0a60 	vminnm.f32	s0, s2, s1
    }
    else
    {
        return val;
    }
}
   2974c:	4770      	bx	lr
   2974e:	bf00      	nop

00029750 <LEAF_clipInt>:

int   LEAF_clipInt(int min, int val, int max)
{
    int tempmin = min;
    int tempmax = max;
    if (min > max)
   29750:	4290      	cmp	r0, r2
   29752:	dd02      	ble.n	2975a <LEAF_clipInt+0xa>
   29754:	4603      	mov	r3, r0
   29756:	4610      	mov	r0, r2
   29758:	461a      	mov	r2, r3
    {
        tempmin = max;
        tempmax = min;
    }
    if (val < tempmin) {
   2975a:	4288      	cmp	r0, r1
   2975c:	dc03      	bgt.n	29766 <LEAF_clipInt+0x16>
   2975e:	428a      	cmp	r2, r1
   29760:	bfa8      	it	ge
   29762:	460a      	movge	r2, r1
   29764:	4610      	mov	r0, r2
    } else if (val > tempmax) {
        return tempmax;
    } else {
        return val;
    }
}
   29766:	4770      	bx	lr

00029768 <LEAF_isPrime>:

int     LEAF_isPrime(uint64_t number )
{
    if ( number == 2 ) return 1;
   29768:	2900      	cmp	r1, #0
   2976a:	bf08      	it	eq
   2976c:	2802      	cmpeq	r0, #2
   2976e:	d029      	beq.n	297c4 <LEAF_isPrime+0x5c>
{
   29770:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if ( number & 1 ) {
   29774:	f000 0401 	and.w	r4, r0, #1
   29778:	2500      	movs	r5, #0
   2977a:	4606      	mov	r6, r0
   2977c:	ea54 0305 	orrs.w	r3, r4, r5
   29780:	d01d      	beq.n	297be <LEAF_isPrime+0x56>
   29782:	460f      	mov	r7, r1
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
   29784:	f006 f816 	bl	2f7b4 <__aeabi_ul2d>
   29788:	2403      	movs	r4, #3
   2978a:	2500      	movs	r5, #0
   2978c:	ec41 0b17 	vmov	d7, r0, r1
   29790:	eeb1 7bc7 	vsqrt.f64	d7, d7
   29794:	eefd 7bc7 	vcvt.s32.f64	s15, d7
   29798:	ee17 8a90 	vmov	r8, s15
   2979c:	e006      	b.n	297ac <LEAF_isPrime+0x44>
            if ( (number % i) == 0 ) return 0;
   2979e:	f006 f83f 	bl	2f820 <__aeabi_uldivmod>
   297a2:	3402      	adds	r4, #2
   297a4:	f145 0500 	adc.w	r5, r5, #0
   297a8:	4313      	orrs	r3, r2
   297aa:	d008      	beq.n	297be <LEAF_isPrime+0x56>
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
   297ac:	45a0      	cmp	r8, r4
            if ( (number % i) == 0 ) return 0;
   297ae:	4622      	mov	r2, r4
   297b0:	462b      	mov	r3, r5
   297b2:	4630      	mov	r0, r6
   297b4:	4639      	mov	r1, r7
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
   297b6:	daf2      	bge.n	2979e <LEAF_isPrime+0x36>
    if ( number == 2 ) return 1;
   297b8:	2001      	movs	r0, #1
        return 1; // prime
    }
    else return 0; // even
}
   297ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else return 0; // even
   297be:	2000      	movs	r0, #0
}
   297c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( number == 2 ) return 1;
   297c4:	2001      	movs	r0, #1
}
   297c6:	4770      	bx	lr

000297c8 <LEAF_tanh>:

// Adapted from MusicDSP: http://www.musicdsp.org/showone.php?id=238
float LEAF_tanh(float x)
{
    
    if( x < -3.0f )
   297c8:	eef8 7a08 	vmov.f32	s15, #136	; 0xc0400000 -3.0
   297cc:	eeb4 0ae7 	vcmpe.f32	s0, s15
   297d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   297d4:	d418      	bmi.n	29808 <LEAF_tanh+0x40>
        return -1.0f;
    else if( x > 3.0f )
   297d6:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
   297da:	eeb4 0ae7 	vcmpe.f32	s0, s15
   297de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   297e2:	dc0e      	bgt.n	29802 <LEAF_tanh+0x3a>
        return 1.0f;
    else
        return x * ( 27.0f + x * x ) / ( 27.0f + 9.0f * x * x );
   297e4:	ee60 6a00 	vmul.f32	s13, s0, s0
   297e8:	eef3 7a0b 	vmov.f32	s15, #59	; 0x41d80000  27.0
   297ec:	eeb2 6a02 	vmov.f32	s12, #34	; 0x41100000  9.0
   297f0:	ee36 7aa7 	vadd.f32	s14, s13, s15
   297f4:	eee6 7a86 	vfma.f32	s15, s13, s12
   297f8:	ee27 7a00 	vmul.f32	s14, s14, s0
   297fc:	ee87 0a27 	vdiv.f32	s0, s14, s15
   29800:	4770      	bx	lr
        return 1.0f;
   29802:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
}
   29806:	4770      	bx	lr
        return -1.0f;
   29808:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   2980c:	4770      	bx	lr
   2980e:	bf00      	nop

00029810 <LEAF_generate_exp>:


//0.001 base gives a good curve that goes from 1 to near zero
void LEAF_generate_exp(float* buffer, float base, float start, float end, float offset, int size)
{
	float increment = (end - start) / (float)size;
   29810:	ee07 1a90 	vmov	s15, r1
   29814:	ee31 1a60 	vsub.f32	s2, s2, s1
	float x = start;
	for (int i = 0; i < size; i++)
   29818:	2900      	cmp	r1, #0
	float increment = (end - start) / (float)size;
   2981a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
{
   2981e:	b538      	push	{r3, r4, r5, lr}
   29820:	ed2d 8b04 	vpush	{d8-d9}
	float increment = (end - start) / (float)size;
   29824:	eec1 8a27 	vdiv.f32	s17, s2, s15
	for (int i = 0; i < size; i++)
   29828:	dd16      	ble.n	29858 <LEAF_generate_exp+0x48>
   2982a:	4604      	mov	r4, r0
   2982c:	eb00 0581 	add.w	r5, r0, r1, lsl #2
   29830:	eeb0 8a60 	vmov.f32	s16, s1
   29834:	eeb0 9a40 	vmov.f32	s18, s0
   29838:	eef0 9a61 	vmov.f32	s19, s3
	{
		buffer[i] = powf(base, x) + offset;
   2983c:	eef0 0a48 	vmov.f32	s1, s16
   29840:	eeb0 0a49 	vmov.f32	s0, s18
   29844:	f003 fb24 	bl	2ce90 <powf>
   29848:	ee30 0a29 	vadd.f32	s0, s0, s19
		x += increment;
   2984c:	ee38 8a28 	vadd.f32	s16, s16, s17
		buffer[i] = powf(base, x) + offset;
   29850:	eca4 0a01 	vstmia	r4!, {s0}
	for (int i = 0; i < size; i++)
   29854:	42a5      	cmp	r5, r4
   29856:	d1f1      	bne.n	2983c <LEAF_generate_exp+0x2c>
    }
}
   29858:	ecbd 8b04 	vpop	{d8-d9}
   2985c:	bd38      	pop	{r3, r4, r5, pc}
   2985e:	bf00      	nop

00029860 <LEAF_generate_atodbPositiveClipped>:
    }
}


void LEAF_generate_atodbPositiveClipped(float* buffer, float lowerThreshold, float range, int size)
{
   29860:	b538      	push	{r3, r4, r5, lr}
    alias.ui &= 0x7fffffff;
   29862:	ee10 3a10 	vmov	r3, s0
    float increment = 1.0f / (float)size;
   29866:	ee07 1a90 	vmov	s15, r1
   2986a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    float x = 0.0f;
    float scalar = range / fastabsf(lowerThreshold);
    for (int i = 0; i < size; i++)
   2986e:	2900      	cmp	r1, #0
    alias.ui &= 0x7fffffff;
   29870:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    float increment = 1.0f / (float)size;
   29874:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    float scalar = range / fastabsf(lowerThreshold);
   29878:	ee06 3a90 	vmov	s13, r3
{
   2987c:	ed2d 8b08 	vpush	{d8-d11}
    float scalar = range / fastabsf(lowerThreshold);
   29880:	eec0 9aa6 	vdiv.f32	s19, s1, s13
    float increment = 1.0f / (float)size;
   29884:	eec7 aa27 	vdiv.f32	s21, s14, s15
    for (int i = 0; i < size; i++)
   29888:	dd29      	ble.n	298de <LEAF_generate_atodbPositiveClipped+0x7e>
   2988a:	ed9f 9a1b 	vldr	s18, [pc, #108]	; 298f8 <LEAF_generate_atodbPositiveClipped+0x98>
   2988e:	4604      	mov	r4, r0
   29890:	eb00 0581 	add.w	r5, r0, r1, lsl #2
   29894:	fe80 aa49 	vminnm.f32	s20, s0, s18
    {
        float temp = atodb(x);
        temp = LEAF_clip(lowerThreshold, temp, 0.0f);
        buffer[i] = (temp-lowerThreshold) * scalar;
   29898:	ee7a ba40 	vsub.f32	s23, s20, s0
   2989c:	eef0 8a40 	vmov.f32	s17, s0
}


float atodb(float a)
{
    return 20.0f*log10f(a);
   298a0:	eeb3 ba04 	vmov.f32	s22, #52	; 0x41a00000  20.0
        buffer[i] = (temp-lowerThreshold) * scalar;
   298a4:	ee6b baa9 	vmul.f32	s23, s23, s19
    float x = 0.0f;
   298a8:	eeb0 8a49 	vmov.f32	s16, s18
   298ac:	fe80 9a09 	vmaxnm.f32	s18, s0, s18
    return 20.0f*log10f(a);
   298b0:	eeb0 0a48 	vmov.f32	s0, s16
   298b4:	f003 fea0 	bl	2d5f8 <log10f>
   298b8:	ee20 0a0b 	vmul.f32	s0, s0, s22
    if (val < tempmin)
   298bc:	eeb4 aac0 	vcmpe.f32	s20, s0
        buffer[i] = (temp-lowerThreshold) * scalar;
   298c0:	fec9 7a40 	vminnm.f32	s15, s18, s0
   298c4:	ee77 7ae8 	vsub.f32	s15, s15, s17
    if (val < tempmin)
   298c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        buffer[i] = (temp-lowerThreshold) * scalar;
   298cc:	ee67 7aa9 	vmul.f32	s15, s15, s19
    if (val < tempmin)
   298d0:	dc08      	bgt.n	298e4 <LEAF_generate_atodbPositiveClipped+0x84>
        buffer[i] = (temp-lowerThreshold) * scalar;
   298d2:	ece4 7a01 	vstmia	r4!, {s15}
    for (int i = 0; i < size; i++)
   298d6:	42ac      	cmp	r4, r5
        x += increment;
   298d8:	ee38 8a2a 	vadd.f32	s16, s16, s21
    for (int i = 0; i < size; i++)
   298dc:	d1e8      	bne.n	298b0 <LEAF_generate_atodbPositiveClipped+0x50>
}
   298de:	ecbd 8b08 	vpop	{d8-d11}
   298e2:	bd38      	pop	{r3, r4, r5, pc}
        buffer[i] = (temp-lowerThreshold) * scalar;
   298e4:	ece4 ba01 	vstmia	r4!, {s23}
    for (int i = 0; i < size; i++)
   298e8:	42a5      	cmp	r5, r4
        x += increment;
   298ea:	ee38 8a2a 	vadd.f32	s16, s16, s21
    for (int i = 0; i < size; i++)
   298ee:	d1df      	bne.n	298b0 <LEAF_generate_atodbPositiveClipped+0x50>
}
   298f0:	ecbd 8b08 	vpop	{d8-d11}
   298f4:	bd38      	pop	{r3, r4, r5, pc}
   298f6:	bf00      	nop
   298f8:	00000000 	.word	0x00000000

000298fc <LEAF_midiToFrequency>:
    if( f <= -1500.0f ) return (0);
   298fc:	eddf 7a10 	vldr	s15, [pc, #64]	; 29940 <LEAF_midiToFrequency+0x44>
   29900:	eeb4 0ae7 	vcmpe.f32	s0, s15
   29904:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29908:	d917      	bls.n	2993a <LEAF_midiToFrequency+0x3e>
   2990a:	eef0 7a40 	vmov.f32	s15, s0
    else return ( powf(2.0f, (f - 69.0f) * 0.083333333333333f) * 440.0f );
   2990e:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 29944 <LEAF_midiToFrequency+0x48>
   29912:	eddf 0a0d 	vldr	s1, [pc, #52]	; 29948 <LEAF_midiToFrequency+0x4c>
   29916:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2991a:	fec7 7ae0 	vminnm.f32	s15, s15, s1
   2991e:	ee77 7ac7 	vsub.f32	s15, s15, s14
   29922:	eddf 0a0a 	vldr	s1, [pc, #40]	; 2994c <LEAF_midiToFrequency+0x50>
{
   29926:	b508      	push	{r3, lr}
    else return ( powf(2.0f, (f - 69.0f) * 0.083333333333333f) * 440.0f );
   29928:	ee67 0aa0 	vmul.f32	s1, s15, s1
   2992c:	f003 fab0 	bl	2ce90 <powf>
   29930:	eddf 7a07 	vldr	s15, [pc, #28]	; 29950 <LEAF_midiToFrequency+0x54>
   29934:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   29938:	bd08      	pop	{r3, pc}
    if( f <= -1500.0f ) return (0);
   2993a:	ed9f 0a06 	vldr	s0, [pc, #24]	; 29954 <LEAF_midiToFrequency+0x58>
}
   2993e:	4770      	bx	lr
   29940:	c4bb8000 	.word	0xc4bb8000
   29944:	428a0000 	.word	0x428a0000
   29948:	44bb6000 	.word	0x44bb6000
   2994c:	3daaaaab 	.word	0x3daaaaab
   29950:	43dc0000 	.word	0x43dc0000
   29954:	00000000 	.word	0x00000000

00029958 <LEAF_interpolate_hermite_x>:
    float y0my1 = yy0 - yy1;
   29958:	ee70 7a60 	vsub.f32	s15, s0, s1
    float c1 = 0.5f * (yy2 - yy0);
   2995c:	ee31 7a40 	vsub.f32	s14, s2, s0
    float c3 = (yy1 - yy2) + 0.5f * (yy3 - y0my1 - yy2);
   29960:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   29964:	ee71 1ae7 	vsub.f32	s3, s3, s15
   29968:	ee70 6ac1 	vsub.f32	s13, s1, s2
    float c2 = y0my1 + c1 - c3;
   2996c:	eee7 7a06 	vfma.f32	s15, s14, s12
    float c3 = (yy1 - yy2) + 0.5f * (yy3 - y0my1 - yy2);
   29970:	ee31 1ac1 	vsub.f32	s2, s3, s2
   29974:	eee1 6a06 	vfma.f32	s13, s2, s12
    float c2 = y0my1 + c1 - c3;
   29978:	ee77 7ae6 	vsub.f32	s15, s15, s13
    return ((c3 * xx + c2) * xx + c1) * xx + c0;
   2997c:	eee6 7a82 	vfma.f32	s15, s13, s4
   29980:	ee67 7a82 	vmul.f32	s15, s15, s4
   29984:	eee7 7a06 	vfma.f32	s15, s14, s12
}
   29988:	eee7 0a82 	vfma.f32	s1, s15, s4
   2998c:	eeb0 0a60 	vmov.f32	s0, s1
   29990:	4770      	bx	lr
   29992:	bf00      	nop

00029994 <LEAF_interpolation_linear>:
{
   29994:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   29998:	ed9f 7a07 	vldr	s14, [pc, #28]	; 299b8 <LEAF_interpolation_linear+0x24>
   2999c:	fe81 1a67 	vminnm.f32	s2, s2, s15
   299a0:	fe81 1a07 	vmaxnm.f32	s2, s2, s14
    float omAlpha = 1.0f - alpha;
   299a4:	ee77 7ac1 	vsub.f32	s15, s15, s2
    out += B * alpha;
   299a8:	ee20 1a81 	vmul.f32	s2, s1, s2
}
   299ac:	eea7 1a80 	vfma.f32	s2, s15, s0
   299b0:	eeb0 0a41 	vmov.f32	s0, s2
   299b4:	4770      	bx	lr
   299b6:	bf00      	nop
   299b8:	00000000 	.word	0x00000000

000299bc <mtof>:
    if (f <= -1500.0f) return(0);
   299bc:	eddf 7a0c 	vldr	s15, [pc, #48]	; 299f0 <mtof+0x34>
   299c0:	eeb4 0ae7 	vcmpe.f32	s0, s15
   299c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   299c8:	d90f      	bls.n	299ea <mtof+0x2e>
    else return (8.17579891564f * expf(0.0577622650f * f));
   299ca:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 299f4 <mtof+0x38>
   299ce:	eddf 7a0a 	vldr	s15, [pc, #40]	; 299f8 <mtof+0x3c>
   299d2:	fe80 0a47 	vminnm.f32	s0, s0, s14
{
   299d6:	b508      	push	{r3, lr}
    else return (8.17579891564f * expf(0.0577622650f * f));
   299d8:	ee20 0a27 	vmul.f32	s0, s0, s15
   299dc:	f003 f8ea 	bl	2cbb4 <expf>
   299e0:	eddf 7a06 	vldr	s15, [pc, #24]	; 299fc <mtof+0x40>
   299e4:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   299e8:	bd08      	pop	{r3, pc}
    if (f <= -1500.0f) return(0);
   299ea:	ed9f 0a05 	vldr	s0, [pc, #20]	; 29a00 <mtof+0x44>
}
   299ee:	4770      	bx	lr
   299f0:	c4bb8000 	.word	0xc4bb8000
   299f4:	44bb6000 	.word	0x44bb6000
   299f8:	3d6c9820 	.word	0x3d6c9820
   299fc:	4102d013 	.word	0x4102d013
   29a00:	00000000 	.word	0x00000000

00029a04 <faster_mtof>:
   29a04:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   29a08:	eddf 6a0e 	vldr	s13, [pc, #56]	; 29a44 <faster_mtof+0x40>
   29a0c:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 29a48 <faster_mtof+0x44>
   29a10:	eee0 7a26 	vfma.f32	s15, s0, s13
   29a14:	ee27 0aa7 	vmul.f32	s0, s15, s15
   29a18:	ee20 0a00 	vmul.f32	s0, s0, s0
   29a1c:	ee20 0a00 	vmul.f32	s0, s0, s0
   29a20:	ee20 0a00 	vmul.f32	s0, s0, s0
   29a24:	ee20 0a00 	vmul.f32	s0, s0, s0
   29a28:	ee20 0a00 	vmul.f32	s0, s0, s0
   29a2c:	ee20 0a00 	vmul.f32	s0, s0, s0
   29a30:	ee20 0a00 	vmul.f32	s0, s0, s0
   29a34:	ee20 0a00 	vmul.f32	s0, s0, s0
   29a38:	ee20 0a00 	vmul.f32	s0, s0, s0
   29a3c:	ee20 0a07 	vmul.f32	s0, s0, s14
   29a40:	4770      	bx	lr
   29a42:	bf00      	nop
   29a44:	386c9820 	.word	0x386c9820
   29a48:	4102d013 	.word	0x4102d013
   29a4c:	00000000 	.word	0x00000000

00029a50 <powtodb>:
{
   29a50:	b508      	push	{r3, lr}
   29a52:	ed2d 8b02 	vpush	{d8}
    if (f <= 0) return (0);
   29a56:	ed9f 8a12 	vldr	s16, [pc, #72]	; 29aa0 <powtodb+0x50>
   29a5a:	eeb4 0ac8 	vcmpe.f32	s0, s16
   29a5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29a62:	d910      	bls.n	29a86 <powtodb+0x36>
        float val = 100.0f + 10.0f/LOGTEN * logf(f);
   29a64:	f003 f92c 	bl	2ccc0 <logf>
   29a68:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
   29a6c:	ed9f 7b08 	vldr	d7, [pc, #32]	; 29a90 <powtodb+0x40>
   29a70:	ed9f 0b09 	vldr	d0, [pc, #36]	; 29a98 <powtodb+0x48>
   29a74:	eea6 0b07 	vfma.f64	d0, d6, d7
   29a78:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
        return (val < 0.0f ? 0.0f : val);
   29a7c:	fe80 0a08 	vmaxnm.f32	s0, s0, s16
}
   29a80:	ecbd 8b02 	vpop	{d8}
   29a84:	bd08      	pop	{r3, pc}
    if (f <= 0) return (0);
   29a86:	eeb0 0a48 	vmov.f32	s0, s16
}
   29a8a:	ecbd 8b02 	vpop	{d8}
   29a8e:	bd08      	pop	{r3, pc}
   29a90:	ed384f8a 	.word	0xed384f8a
   29a94:	40115f2c 	.word	0x40115f2c
   29a98:	00000000 	.word	0x00000000
   29a9c:	40590000 	.word	0x40590000
   29aa0:	00000000 	.word	0x00000000

00029aa4 <fastdbtoa>:


float fastdbtoa(float db)
{
    //return powf(10.0f, db * 0.05f);
    return expf(0.115129254649702f * db); //faster version from http://openaudio.blogspot.com/2017/02/faster-log10-and-pow.html
   29aa4:	eddf 7a02 	vldr	s15, [pc, #8]	; 29ab0 <fastdbtoa+0xc>
   29aa8:	ee20 0a27 	vmul.f32	s0, s0, s15
   29aac:	f003 b882 	b.w	2cbb4 <expf>
   29ab0:	3debc8e3 	.word	0x3debc8e3

00029ab4 <fasterdbtoa>:
    x = 1.0f + (x * 0.00390625f);
   29ab4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   29ab8:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 29ae4 <fasterdbtoa+0x30>
   29abc:	eee0 7a07 	vfma.f32	s15, s0, s14
    x *= x; x *= x; x *= x; x *= x;
   29ac0:	ee27 0aa7 	vmul.f32	s0, s15, s15
   29ac4:	ee20 0a00 	vmul.f32	s0, s0, s0
   29ac8:	ee20 0a00 	vmul.f32	s0, s0, s0
   29acc:	ee20 0a00 	vmul.f32	s0, s0, s0
    x *= x; x *= x; x *= x; x *= x;
   29ad0:	ee20 0a00 	vmul.f32	s0, s0, s0
   29ad4:	ee20 0a00 	vmul.f32	s0, s0, s0
   29ad8:	ee20 0a00 	vmul.f32	s0, s0, s0

float fasterdbtoa(float db)
{
    //return powf(10.0f, db * 0.05f);
    return fasterexpf(0.115129254649702f * db); //faster version from http://openaudio.blogspot.com/2017/02/faster-log10-and-pow.html
}
   29adc:	ee20 0a00 	vmul.f32	s0, s0, s0
   29ae0:	4770      	bx	lr
   29ae2:	bf00      	nop
   29ae4:	39ebc8e3 	.word	0x39ebc8e3

00029ae8 <maximum>:


float maximum (float num1, float num2)
{
    return (num1 > num2 ) ? num1 : num2;
}
   29ae8:	fe80 0a80 	vmaxnm.f32	s0, s1, s0
   29aec:	4770      	bx	lr
   29aee:	bf00      	nop

00029af0 <minimum>:

float minimum (float num1, float num2)
{
    return (num1 < num2 ) ? num1 : num2;
}
   29af0:	fe80 0ac0 	vminnm.f32	s0, s1, s0
   29af4:	4770      	bx	lr
   29af6:	bf00      	nop

00029af8 <leaf_pool_init>:
    */
    //is zeroing out the memory necessary? This takes a long time on large pools - JS
}

void leaf_pool_init(char* memory, size_t size)
{
   29af8:	b470      	push	{r4, r5, r6}
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29afa:	4b0a      	ldr	r3, [pc, #40]	; (29b24 <leaf_pool_init+0x2c>)
   29afc:	2610      	movs	r6, #16
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   29afe:	f1a1 0410 	sub.w	r4, r1, #16
    pool->usize  = 0;
   29b02:	2200      	movs	r2, #0
    pool->msize  = size;
   29b04:	6259      	str	r1, [r3, #36]	; 0x24
}

static inline mpool_node_t* create_node(char* block_location, mpool_node_t* next, mpool_node_t* prev, size_t size)
{
    mpool_node_t* node = (mpool_node_t*)block_location;
    node->pool = block_location + leaf.header_size;
   29b06:	1985      	adds	r5, r0, r6
    leaf.mempool = &leaf._mempool;
   29b08:	f103 011c 	add.w	r1, r3, #28
    pool->mpool = (char*)memory;
   29b0c:	61d8      	str	r0, [r3, #28]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29b0e:	62de      	str	r6, [r3, #44]	; 0x2c
    pool->usize  = 0;
   29b10:	621a      	str	r2, [r3, #32]
    node->pool = block_location + leaf.header_size;
   29b12:	6005      	str	r5, [r0, #0]
    node->next = next;
    node->prev = prev;
    node->size = size;
   29b14:	60c4      	str	r4, [r0, #12]
    node->prev = prev;
   29b16:	e9c0 2201 	strd	r2, r2, [r0, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   29b1a:	6298      	str	r0, [r3, #40]	; 0x28
    leaf.mempool = &leaf._mempool;
   29b1c:	6199      	str	r1, [r3, #24]
}
   29b1e:	bc70      	pop	{r4, r5, r6}
   29b20:	4770      	bx	lr
   29b22:	bf00      	nop
   29b24:	020fbd68 	.word	0x020fbd68

00029b28 <mpool_alloc>:
{
   29b28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pool->head == NULL)
   29b2a:	68cb      	ldr	r3, [r1, #12]
   29b2c:	2b00      	cmp	r3, #0
   29b2e:	d049      	beq.n	29bc4 <mpool_alloc+0x9c>
    return (size + (MPOOL_ALIGN_SIZE - 1)) & ~(MPOOL_ALIGN_SIZE - 1);
   29b30:	3007      	adds	r0, #7
   29b32:	f020 0007 	bic.w	r0, r0, #7
    while (node_to_alloc->size < size_to_alloc)
   29b36:	e002      	b.n	29b3e <mpool_alloc+0x16>
        if (node_to_alloc == NULL)
   29b38:	4623      	mov	r3, r4
   29b3a:	2c00      	cmp	r4, #0
   29b3c:	d042      	beq.n	29bc4 <mpool_alloc+0x9c>
    while (node_to_alloc->size < size_to_alloc)
   29b3e:	68da      	ldr	r2, [r3, #12]
   29b40:	685c      	ldr	r4, [r3, #4]
   29b42:	4282      	cmp	r2, r0
   29b44:	d3f8      	bcc.n	29b38 <mpool_alloc+0x10>
    if (leftover > leaf.header_size)
   29b46:	4e22      	ldr	r6, [pc, #136]	; (29bd0 <mpool_alloc+0xa8>)
    size_t leftover = node_to_alloc->size - size_to_alloc;
   29b48:	1a17      	subs	r7, r2, r0
    node_to_alloc->size = size_to_alloc;
   29b4a:	60d8      	str	r0, [r3, #12]
    if (leftover > leaf.header_size)
   29b4c:	6af5      	ldr	r5, [r6, #44]	; 0x2c
   29b4e:	42bd      	cmp	r5, r7
   29b50:	d327      	bcc.n	29ba2 <mpool_alloc+0x7a>
        node_to_alloc->size += leftover;
   29b52:	46a4      	mov	ip, r4
   29b54:	60da      	str	r2, [r3, #12]
    if (pool->head == node_to_alloc)
   29b56:	68ca      	ldr	r2, [r1, #12]
   29b58:	429a      	cmp	r2, r3
        pool->head = new_node;
   29b5a:	bf08      	it	eq
   29b5c:	f8c1 c00c 	streq.w	ip, [r1, #12]
   29b60:	e9d3 0201 	ldrd	r0, r2, [r3, #4]
}

static inline void delink_node(mpool_node_t* node)
{
    // If there is a node after the node to remove
    if (node->next != NULL)
   29b64:	b108      	cbz	r0, 29b6a <mpool_alloc+0x42>
    {
        // Close the link
        node->next->prev = node->prev;
   29b66:	6082      	str	r2, [r0, #8]
   29b68:	689a      	ldr	r2, [r3, #8]
    }
    // If there is a node before the node to remove
    if (node->prev != NULL)
   29b6a:	b10a      	cbz	r2, 29b70 <mpool_alloc+0x48>
    {
        // Close the link
        node->prev->next = node->next;
   29b6c:	6858      	ldr	r0, [r3, #4]
   29b6e:	6050      	str	r0, [r2, #4]
    }
    
    node->next = NULL;
   29b70:	2200      	movs	r2, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
   29b72:	68dc      	ldr	r4, [r3, #12]
    node->prev = NULL;
   29b74:	e9c3 2201 	strd	r2, r2, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   29b78:	6848      	ldr	r0, [r1, #4]
   29b7a:	6af5      	ldr	r5, [r6, #44]	; 0x2c
   29b7c:	4428      	add	r0, r5
   29b7e:	4420      	add	r0, r4
   29b80:	6048      	str	r0, [r1, #4]
    if (leaf.clearOnAllocation > 0)
   29b82:	6971      	ldr	r1, [r6, #20]
   29b84:	4291      	cmp	r1, r2
   29b86:	dd0a      	ble.n	29b9e <mpool_alloc+0x76>
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29b88:	68d9      	ldr	r1, [r3, #12]
        char* new_pool = (char*)node_to_alloc->pool;
   29b8a:	6818      	ldr	r0, [r3, #0]
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29b8c:	b141      	cbz	r1, 29ba0 <mpool_alloc+0x78>
   29b8e:	3801      	subs	r0, #1
   29b90:	4614      	mov	r4, r2
   29b92:	f800 4f01 	strb.w	r4, [r0, #1]!
   29b96:	3201      	adds	r2, #1
   29b98:	68d9      	ldr	r1, [r3, #12]
   29b9a:	4291      	cmp	r1, r2
   29b9c:	d8f9      	bhi.n	29b92 <mpool_alloc+0x6a>
   29b9e:	6818      	ldr	r0, [r3, #0]
}
   29ba0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29ba2:	680a      	ldr	r2, [r1, #0]
        offset += leaf.header_size + node_to_alloc->size;
   29ba4:	4428      	add	r0, r5
                               node_to_alloc->prev,
   29ba6:	f8d3 e008 	ldr.w	lr, [r3, #8]
        new_node = create_node(&pool->mpool[offset],
   29baa:	1b7f      	subs	r7, r7, r5
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29bac:	eba3 0c02 	sub.w	ip, r3, r2
        offset += leaf.header_size + node_to_alloc->size;
   29bb0:	4460      	add	r0, ip
        new_node = create_node(&pool->mpool[offset],
   29bb2:	eb02 0c00 	add.w	ip, r2, r0
    node->pool = block_location + leaf.header_size;
   29bb6:	4465      	add	r5, ip
   29bb8:	5015      	str	r5, [r2, r0]
    node->size = size;
   29bba:	f8cc 700c 	str.w	r7, [ip, #12]
    node->prev = prev;
   29bbe:	e9cc 4e01 	strd	r4, lr, [ip, #4]
   29bc2:	e7c8      	b.n	29b56 <mpool_alloc+0x2e>
}

void leaf_mempool_overrun(void)
{
    LEAF_error(1);
   29bc4:	2001      	movs	r0, #1
   29bc6:	f002 fe3b 	bl	2c840 <LEAF_error>
        return NULL;
   29bca:	2000      	movs	r0, #0
}
   29bcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   29bce:	bf00      	nop
   29bd0:	020fbd68 	.word	0x020fbd68

00029bd4 <mpool_calloc>:
{
   29bd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pool->head == NULL)
   29bd6:	68cb      	ldr	r3, [r1, #12]
   29bd8:	2b00      	cmp	r3, #0
   29bda:	d046      	beq.n	29c6a <mpool_calloc+0x96>
    return (size + (MPOOL_ALIGN_SIZE - 1)) & ~(MPOOL_ALIGN_SIZE - 1);
   29bdc:	3007      	adds	r0, #7
   29bde:	f020 0007 	bic.w	r0, r0, #7
    while (node_to_alloc->size < size_to_alloc)
   29be2:	e002      	b.n	29bea <mpool_calloc+0x16>
        if (node_to_alloc == NULL)
   29be4:	4623      	mov	r3, r4
   29be6:	2c00      	cmp	r4, #0
   29be8:	d03f      	beq.n	29c6a <mpool_calloc+0x96>
    while (node_to_alloc->size < size_to_alloc)
   29bea:	68da      	ldr	r2, [r3, #12]
   29bec:	685c      	ldr	r4, [r3, #4]
   29bee:	4282      	cmp	r2, r0
   29bf0:	d3f8      	bcc.n	29be4 <mpool_calloc+0x10>
    if (leftover > leaf.header_size)
   29bf2:	4f20      	ldr	r7, [pc, #128]	; (29c74 <mpool_calloc+0xa0>)
    size_t leftover = node_to_alloc->size - size_to_alloc;
   29bf4:	1a16      	subs	r6, r2, r0
    node_to_alloc->size = size_to_alloc;
   29bf6:	60d8      	str	r0, [r3, #12]
    if (leftover > leaf.header_size)
   29bf8:	6afd      	ldr	r5, [r7, #44]	; 0x2c
   29bfa:	42b5      	cmp	r5, r6
   29bfc:	d324      	bcc.n	29c48 <mpool_calloc+0x74>
        node_to_alloc->size += leftover;
   29bfe:	46a4      	mov	ip, r4
   29c00:	60da      	str	r2, [r3, #12]
    if (pool->head == node_to_alloc)
   29c02:	68ca      	ldr	r2, [r1, #12]
   29c04:	429a      	cmp	r2, r3
        pool->head = new_node;
   29c06:	bf08      	it	eq
   29c08:	f8c1 c00c 	streq.w	ip, [r1, #12]
   29c0c:	e9d3 0201 	ldrd	r0, r2, [r3, #4]
    if (node->next != NULL)
   29c10:	b108      	cbz	r0, 29c16 <mpool_calloc+0x42>
        node->next->prev = node->prev;
   29c12:	6082      	str	r2, [r0, #8]
   29c14:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
   29c16:	b10a      	cbz	r2, 29c1c <mpool_calloc+0x48>
        node->prev->next = node->next;
   29c18:	6858      	ldr	r0, [r3, #4]
   29c1a:	6050      	str	r0, [r2, #4]
    node->next = NULL;
   29c1c:	2200      	movs	r2, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
   29c1e:	68dc      	ldr	r4, [r3, #12]
    node->prev = NULL;
   29c20:	e9c3 2201 	strd	r2, r2, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   29c24:	6848      	ldr	r0, [r1, #4]
   29c26:	6afd      	ldr	r5, [r7, #44]	; 0x2c
   29c28:	4428      	add	r0, r5
   29c2a:	4420      	add	r0, r4
   29c2c:	6048      	str	r0, [r1, #4]
    for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29c2e:	68d9      	ldr	r1, [r3, #12]
    char* new_pool = (char*)node_to_alloc->pool;
   29c30:	6818      	ldr	r0, [r3, #0]
    for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29c32:	b141      	cbz	r1, 29c46 <mpool_calloc+0x72>
   29c34:	3801      	subs	r0, #1
   29c36:	4614      	mov	r4, r2
   29c38:	f800 4f01 	strb.w	r4, [r0, #1]!
   29c3c:	3201      	adds	r2, #1
   29c3e:	68d9      	ldr	r1, [r3, #12]
   29c40:	4291      	cmp	r1, r2
   29c42:	d8f9      	bhi.n	29c38 <mpool_calloc+0x64>
   29c44:	6818      	ldr	r0, [r3, #0]
}
   29c46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29c48:	680a      	ldr	r2, [r1, #0]
        offset += leaf.header_size + node_to_alloc->size;
   29c4a:	4428      	add	r0, r5
                               node_to_alloc->prev,
   29c4c:	f8d3 e008 	ldr.w	lr, [r3, #8]
        new_node = create_node(&pool->mpool[offset],
   29c50:	1b76      	subs	r6, r6, r5
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29c52:	eba3 0c02 	sub.w	ip, r3, r2
        offset += leaf.header_size + node_to_alloc->size;
   29c56:	4460      	add	r0, ip
        new_node = create_node(&pool->mpool[offset],
   29c58:	eb02 0c00 	add.w	ip, r2, r0
    node->pool = block_location + leaf.header_size;
   29c5c:	4465      	add	r5, ip
   29c5e:	5015      	str	r5, [r2, r0]
    node->size = size;
   29c60:	f8cc 600c 	str.w	r6, [ip, #12]
    node->prev = prev;
   29c64:	e9cc 4e01 	strd	r4, lr, [ip, #4]
   29c68:	e7cb      	b.n	29c02 <mpool_calloc+0x2e>
    LEAF_error(1);
   29c6a:	2001      	movs	r0, #1
   29c6c:	f002 fde8 	bl	2c840 <LEAF_error>
        return NULL;
   29c70:	2000      	movs	r0, #0
}
   29c72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   29c74:	020fbd68 	.word	0x020fbd68

00029c78 <mpool_free>:
{
   29c78:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
   29c7c:	4f33      	ldr	r7, [pc, #204]	; (29d4c <mpool_free+0xd4>)
    pool->usize -= leaf.header_size + freed_node->size;
   29c7e:	684a      	ldr	r2, [r1, #4]
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
   29c80:	6afc      	ldr	r4, [r7, #44]	; 0x2c
    mpool_node_t* other_node = pool->head;
   29c82:	68cb      	ldr	r3, [r1, #12]
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
   29c84:	1b00      	subs	r0, r0, r4
    pool->usize -= leaf.header_size + freed_node->size;
   29c86:	1b12      	subs	r2, r2, r4
   29c88:	68c4      	ldr	r4, [r0, #12]
   29c8a:	1b12      	subs	r2, r2, r4
   29c8c:	604a      	str	r2, [r1, #4]
    while (other_node != NULL)
   29c8e:	2b00      	cmp	r3, #0
   29c90:	d03e      	beq.n	29d10 <mpool_free+0x98>
        if ((long) other_node < (long) pool->mpool ||
   29c92:	680a      	ldr	r2, [r1, #0]
   29c94:	4293      	cmp	r3, r2
   29c96:	db1f      	blt.n	29cd8 <mpool_free+0x60>
            (long) other_node >= (((long) pool->mpool) + pool->msize))
   29c98:	688c      	ldr	r4, [r1, #8]
   29c9a:	461d      	mov	r5, r3
   29c9c:	4422      	add	r2, r4
        if ((long) other_node < (long) pool->mpool ||
   29c9e:	429a      	cmp	r2, r3
   29ca0:	d91a      	bls.n	29cd8 <mpool_free+0x60>
    node->next = NULL;
   29ca2:	f04f 0c00 	mov.w	ip, #0
        if (((long) freed_node) + (leaf.header_size + freed_node->size) == (long) other_node)
   29ca6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   29ca8:	68c4      	ldr	r4, [r0, #12]
        next_node = other_node->next;
   29caa:	685e      	ldr	r6, [r3, #4]
        if (((long) freed_node) + (leaf.header_size + freed_node->size) == (long) other_node)
   29cac:	eb02 0e04 	add.w	lr, r2, r4
   29cb0:	f8d3 800c 	ldr.w	r8, [r3, #12]
   29cb4:	eb0e 0900 	add.w	r9, lr, r0
   29cb8:	45a9      	cmp	r9, r5
   29cba:	d030      	beq.n	29d1e <mpool_free+0xa6>
        else if (((long) other_node) + (leaf.header_size + other_node->size) == (long) freed_node)
   29cbc:	442a      	add	r2, r5
   29cbe:	4442      	add	r2, r8
   29cc0:	4290      	cmp	r0, r2
   29cc2:	d00e      	beq.n	29ce2 <mpool_free+0x6a>
    while (other_node != NULL)
   29cc4:	b31e      	cbz	r6, 29d0e <mpool_free+0x96>
        if ((long) other_node < (long) pool->mpool ||
   29cc6:	680b      	ldr	r3, [r1, #0]
   29cc8:	42b3      	cmp	r3, r6
   29cca:	dc05      	bgt.n	29cd8 <mpool_free+0x60>
            (long) other_node >= (((long) pool->mpool) + pool->msize))
   29ccc:	688c      	ldr	r4, [r1, #8]
   29cce:	4635      	mov	r5, r6
   29cd0:	441c      	add	r4, r3
   29cd2:	4633      	mov	r3, r6
        if ((long) other_node < (long) pool->mpool ||
   29cd4:	42b4      	cmp	r4, r6
   29cd6:	d8e6      	bhi.n	29ca6 <mpool_free+0x2e>
            LEAF_error(2);
   29cd8:	2002      	movs	r0, #2
}
   29cda:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            LEAF_error(2);
   29cde:	f002 bdaf 	b.w	2c840 <LEAF_error>
            other_node->size += leaf.header_size + freed_node->size;
   29ce2:	eb0e 0408 	add.w	r4, lr, r8
   29ce6:	60dc      	str	r4, [r3, #12]
            if (other_node != pool->head)
   29ce8:	68ca      	ldr	r2, [r1, #12]
   29cea:	429a      	cmp	r2, r3
   29cec:	d02b      	beq.n	29d46 <mpool_free+0xce>
   29cee:	689a      	ldr	r2, [r3, #8]
    if (node->next != NULL)
   29cf0:	b10e      	cbz	r6, 29cf6 <mpool_free+0x7e>
        node->next->prev = node->prev;
   29cf2:	60b2      	str	r2, [r6, #8]
   29cf4:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
   29cf6:	b10a      	cbz	r2, 29cfc <mpool_free+0x84>
        node->prev->next = node->next;
   29cf8:	6858      	ldr	r0, [r3, #4]
   29cfa:	6050      	str	r0, [r2, #4]
    node->next = NULL;
   29cfc:	f8c3 c004 	str.w	ip, [r3, #4]
   29d00:	4618      	mov	r0, r3
    node->prev = NULL;
   29d02:	f8c3 c008 	str.w	ip, [r3, #8]
                other_node->next = pool->head;
   29d06:	68ca      	ldr	r2, [r1, #12]
   29d08:	605a      	str	r2, [r3, #4]
    while (other_node != NULL)
   29d0a:	2e00      	cmp	r6, #0
   29d0c:	d1db      	bne.n	29cc6 <mpool_free+0x4e>
   29d0e:	68cb      	ldr	r3, [r1, #12]
    freed_node->next = pool->head;
   29d10:	6043      	str	r3, [r0, #4]
    if (pool->head != NULL) pool->head->prev = freed_node;
   29d12:	68cb      	ldr	r3, [r1, #12]
   29d14:	b103      	cbz	r3, 29d18 <mpool_free+0xa0>
   29d16:	6098      	str	r0, [r3, #8]
    pool->head = freed_node;
   29d18:	60c8      	str	r0, [r1, #12]
}
   29d1a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            freed_node->size += leaf.header_size + other_node->size;
   29d1e:	4444      	add	r4, r8
   29d20:	4422      	add	r2, r4
   29d22:	60c2      	str	r2, [r0, #12]
            if (other_node == pool->head) pool->head = pool->head->next;
   29d24:	68ca      	ldr	r2, [r1, #12]
   29d26:	429a      	cmp	r2, r3
   29d28:	d00a      	beq.n	29d40 <mpool_free+0xc8>
   29d2a:	e9d3 4201 	ldrd	r4, r2, [r3, #4]
    if (node->next != NULL)
   29d2e:	b10c      	cbz	r4, 29d34 <mpool_free+0xbc>
        node->next->prev = node->prev;
   29d30:	60a2      	str	r2, [r4, #8]
   29d32:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
   29d34:	b10a      	cbz	r2, 29d3a <mpool_free+0xc2>
        node->prev->next = node->next;
   29d36:	685c      	ldr	r4, [r3, #4]
   29d38:	6054      	str	r4, [r2, #4]
    node->prev = NULL;
   29d3a:	e9c3 cc01 	strd	ip, ip, [r3, #4]
   29d3e:	e7c1      	b.n	29cc4 <mpool_free+0x4c>
            if (other_node == pool->head) pool->head = pool->head->next;
   29d40:	685a      	ldr	r2, [r3, #4]
   29d42:	60ca      	str	r2, [r1, #12]
   29d44:	e7f1      	b.n	29d2a <mpool_free+0xb2>
                pool->head = pool->head->next;
   29d46:	4618      	mov	r0, r3
   29d48:	60ce      	str	r6, [r1, #12]
   29d4a:	e7bb      	b.n	29cc4 <mpool_free+0x4c>
   29d4c:	020fbd68 	.word	0x020fbd68

00029d50 <tMempool_init>:
    //TODO: we should make a set of real error codes that are in an enum type
}

void tMempool_init(tMempool* const mp, char* memory, size_t size)
{
   29d50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    tMempool_freeFromPool(mp, &leaf.mempool);
}

void    tMempool_initToPool     (tMempool* const mp, char* memory, size_t size, tMempool* const mem)
{
    _tMempool* mm = *mem;
   29d54:	4e3a      	ldr	r6, [pc, #232]	; (29e40 <tMempool_init+0xf0>)
{
   29d56:	b082      	sub	sp, #8
    _tMempool* mm = *mem;
   29d58:	f8d6 c018 	ldr.w	ip, [r6, #24]
    if (pool->head == NULL)
   29d5c:	f8dc 300c 	ldr.w	r3, [ip, #12]
   29d60:	b91b      	cbnz	r3, 29d6a <tMempool_init+0x1a>
   29d62:	e04c      	b.n	29dfe <tMempool_init+0xae>
        if (node_to_alloc == NULL)
   29d64:	462b      	mov	r3, r5
   29d66:	2d00      	cmp	r5, #0
   29d68:	d049      	beq.n	29dfe <tMempool_init+0xae>
    while (node_to_alloc->size < size_to_alloc)
   29d6a:	68dc      	ldr	r4, [r3, #12]
   29d6c:	685d      	ldr	r5, [r3, #4]
   29d6e:	2c0f      	cmp	r4, #15
   29d70:	d9f8      	bls.n	29d64 <tMempool_init+0x14>
    node_to_alloc->size = size_to_alloc;
   29d72:	2710      	movs	r7, #16
    size_t leftover = node_to_alloc->size - size_to_alloc;
   29d74:	f1a4 0e10 	sub.w	lr, r4, #16
    node_to_alloc->size = size_to_alloc;
   29d78:	60df      	str	r7, [r3, #12]
    if (leftover > leaf.header_size)
   29d7a:	6af7      	ldr	r7, [r6, #44]	; 0x2c
   29d7c:	45be      	cmp	lr, r7
   29d7e:	d849      	bhi.n	29e14 <tMempool_init+0xc4>
        node_to_alloc->size += leftover;
   29d80:	46ae      	mov	lr, r5
   29d82:	60dc      	str	r4, [r3, #12]
    if (pool->head == node_to_alloc)
   29d84:	f8dc 400c 	ldr.w	r4, [ip, #12]
   29d88:	42a3      	cmp	r3, r4
        pool->head = new_node;
   29d8a:	bf08      	it	eq
   29d8c:	f8cc e00c 	streq.w	lr, [ip, #12]
   29d90:	e9d3 5401 	ldrd	r5, r4, [r3, #4]
    if (node->next != NULL)
   29d94:	b10d      	cbz	r5, 29d9a <tMempool_init+0x4a>
        node->next->prev = node->prev;
   29d96:	60ac      	str	r4, [r5, #8]
   29d98:	689c      	ldr	r4, [r3, #8]
    if (node->prev != NULL)
   29d9a:	b10c      	cbz	r4, 29da0 <tMempool_init+0x50>
        node->prev->next = node->next;
   29d9c:	685d      	ldr	r5, [r3, #4]
   29d9e:	6065      	str	r5, [r4, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   29da0:	68dc      	ldr	r4, [r3, #12]
    node->next = NULL;
   29da2:	2500      	movs	r5, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
   29da4:	9401      	str	r4, [sp, #4]
    node->prev = NULL;
   29da6:	e9c3 5501 	strd	r5, r5, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   29daa:	6af4      	ldr	r4, [r6, #44]	; 0x2c
   29dac:	f8dc 7004 	ldr.w	r7, [ip, #4]
   29db0:	4427      	add	r7, r4
   29db2:	463c      	mov	r4, r7
   29db4:	9f01      	ldr	r7, [sp, #4]
   29db6:	4427      	add	r7, r4
   29db8:	f8cc 7004 	str.w	r7, [ip, #4]
    if (leaf.clearOnAllocation > 0)
   29dbc:	6974      	ldr	r4, [r6, #20]
   29dbe:	42ac      	cmp	r4, r5
   29dc0:	dd0a      	ble.n	29dd8 <tMempool_init+0x88>
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29dc2:	68df      	ldr	r7, [r3, #12]
        char* new_pool = (char*)node_to_alloc->pool;
   29dc4:	681c      	ldr	r4, [r3, #0]
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29dc6:	b147      	cbz	r7, 29dda <tMempool_init+0x8a>
   29dc8:	3c01      	subs	r4, #1
   29dca:	46ac      	mov	ip, r5
   29dcc:	f804 cf01 	strb.w	ip, [r4, #1]!
   29dd0:	3501      	adds	r5, #1
   29dd2:	68df      	ldr	r7, [r3, #12]
   29dd4:	42bd      	cmp	r5, r7
   29dd6:	d3f9      	bcc.n	29dcc <tMempool_init+0x7c>
   29dd8:	681c      	ldr	r4, [r3, #0]
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
   29dda:	6004      	str	r4, [r0, #0]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29ddc:	2310      	movs	r3, #16
    pool->usize  = 0;
   29dde:	2000      	movs	r0, #0
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29de0:	62f3      	str	r3, [r6, #44]	; 0x2c
    pool->mpool = (char*)memory;
   29de2:	6021      	str	r1, [r4, #0]
    pool->usize  = 0;
   29de4:	e9c4 0201 	strd	r0, r2, [r4, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   29de8:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    node->next = next;
   29dea:	6048      	str	r0, [r1, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   29dec:	1ad2      	subs	r2, r2, r3
    node->pool = block_location + leaf.header_size;
   29dee:	440b      	add	r3, r1
    node->size = size;
   29df0:	e9c1 0202 	strd	r0, r2, [r1, #8]
    node->pool = block_location + leaf.header_size;
   29df4:	600b      	str	r3, [r1, #0]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   29df6:	60e1      	str	r1, [r4, #12]
}
   29df8:	b002      	add	sp, #8
   29dfa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   29dfe:	4605      	mov	r5, r0
    LEAF_error(1);
   29e00:	2001      	movs	r0, #1
   29e02:	460c      	mov	r4, r1
   29e04:	f002 fd1c 	bl	2c840 <LEAF_error>
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
   29e08:	2300      	movs	r3, #0
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29e0a:	2210      	movs	r2, #16
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
   29e0c:	602b      	str	r3, [r5, #0]
    pool->mpool = (char*)memory;
   29e0e:	601c      	str	r4, [r3, #0]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29e10:	62f2      	str	r2, [r6, #44]	; 0x2c
   29e12:	deff      	udf	#255	; 0xff
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29e14:	f8dc 9000 	ldr.w	r9, [ip]
        new_node = create_node(&pool->mpool[offset],
   29e18:	ebae 0407 	sub.w	r4, lr, r7
        offset += leaf.header_size + node_to_alloc->size;
   29e1c:	f107 0810 	add.w	r8, r7, #16
                               node_to_alloc->prev,
   29e20:	f8d3 a008 	ldr.w	sl, [r3, #8]
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29e24:	eba3 0e09 	sub.w	lr, r3, r9
        offset += leaf.header_size + node_to_alloc->size;
   29e28:	44f0      	add	r8, lr
        new_node = create_node(&pool->mpool[offset],
   29e2a:	eb09 0e08 	add.w	lr, r9, r8
    node->pool = block_location + leaf.header_size;
   29e2e:	4477      	add	r7, lr
   29e30:	f849 7008 	str.w	r7, [r9, r8]
    node->size = size;
   29e34:	f8ce 400c 	str.w	r4, [lr, #12]
    node->prev = prev;
   29e38:	e9ce 5a01 	strd	r5, sl, [lr, #4]
   29e3c:	e7a2      	b.n	29d84 <tMempool_init+0x34>
   29e3e:	bf00      	nop
   29e40:	020fbd68 	.word	0x020fbd68

00029e44 <tSimplePoly_initToPool>:
{
    tSimplePoly_initToPool(polyh, maxNumVoices, &leaf.mempool);
}

void    tSimplePoly_initToPool            (tSimplePoly* const polyh, int maxNumVoices, tMempool* const mp)
{
   29e44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
   29e48:	6816      	ldr	r6, [r2, #0]
{
   29e4a:	4680      	mov	r8, r0
   29e4c:	460c      	mov	r4, r1
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
   29e4e:	f240 401c 	movw	r0, #1052	; 0x41c
   29e52:	4631      	mov	r1, r6
{
   29e54:	4617      	mov	r7, r2
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
   29e56:	f7ff fe67 	bl	29b28 <mpool_alloc>
   29e5a:	4605      	mov	r5, r0
    poly->maxNumVoices = maxNumVoices;

    for (int i = 0; i < 128; i++)
    {
        poly->notes[i][0] = -1;
        poly->notes[i][1] = 0;
   29e5c:	2100      	movs	r1, #0
        poly->notes[i][0] = -1;
   29e5e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29e62:	462b      	mov	r3, r5
   29e64:	f505 6280 	add.w	r2, r5, #1024	; 0x400
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
   29e68:	f8c8 5000 	str.w	r5, [r8]
    poly->mempool = m;
   29e6c:	602e      	str	r6, [r5, #0]
    poly->maxNumVoices = maxNumVoices;
   29e6e:	e9c5 4402 	strd	r4, r4, [r5, #8]
        poly->notes[i][1] = 0;
   29e72:	e9c3 0107 	strd	r0, r1, [r3, #28]
   29e76:	3308      	adds	r3, #8
    for (int i = 0; i < 128; i++)
   29e78:	4293      	cmp	r3, r2
   29e7a:	d1fa      	bne.n	29e72 <tSimplePoly_initToPool+0x2e>
    }
    poly->stealing_on = 1;
   29e7c:	2301      	movs	r3, #1
    poly->recover_stolen = 1;
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
   29e7e:	00a0      	lsls	r0, r4, #2
   29e80:	4631      	mov	r1, r6
    poly->recover_stolen = 1;
   29e82:	e9c5 3305 	strd	r3, r3, [r5, #20]
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
   29e86:	f7ff fe4f 	bl	29b28 <mpool_alloc>

    for (int i = 0; i < poly->maxNumVoices; ++i)
   29e8a:	68eb      	ldr	r3, [r5, #12]
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
   29e8c:	4680      	mov	r8, r0
   29e8e:	6128      	str	r0, [r5, #16]
    for (int i = 0; i < poly->maxNumVoices; ++i)
   29e90:	2b00      	cmp	r3, #0
   29e92:	dd14      	ble.n	29ebe <tSimplePoly_initToPool+0x7a>
   29e94:	2400      	movs	r4, #0
    {
        poly->voices[i] = (int*) mpool_alloc(sizeof(int) * 3, m);
        poly->voices[i][0] = -1;
   29e96:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   29e9a:	e001      	b.n	29ea0 <tSimplePoly_initToPool+0x5c>
   29e9c:	f8d5 8010 	ldr.w	r8, [r5, #16]
        poly->voices[i] = (int*) mpool_alloc(sizeof(int) * 3, m);
   29ea0:	4631      	mov	r1, r6
   29ea2:	200c      	movs	r0, #12
   29ea4:	f7ff fe40 	bl	29b28 <mpool_alloc>
   29ea8:	f848 0024 	str.w	r0, [r8, r4, lsl #2]
        poly->voices[i][0] = -1;
   29eac:	692b      	ldr	r3, [r5, #16]
   29eae:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
    for (int i = 0; i < poly->maxNumVoices; ++i)
   29eb2:	3401      	adds	r4, #1
        poly->voices[i][0] = -1;
   29eb4:	f8c3 9000 	str.w	r9, [r3]
    for (int i = 0; i < poly->maxNumVoices; ++i)
   29eb8:	68eb      	ldr	r3, [r5, #12]
   29eba:	42a3      	cmp	r3, r4
   29ebc:	dcee      	bgt.n	29e9c <tSimplePoly_initToPool+0x58>
    _tMempool* m = *mp;
   29ebe:	683e      	ldr	r6, [r7, #0]
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
   29ec0:	f44f 7004 	mov.w	r0, #528	; 0x210
    ns->ordered = 0;
   29ec4:	2400      	movs	r4, #0
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
   29ec6:	4631      	mov	r1, r6
   29ec8:	f7ff fe2e 	bl	29b28 <mpool_alloc>
    ns->capacity = STACK_SIZE;
   29ecc:	2180      	movs	r1, #128	; 0x80
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
   29ece:	4603      	mov	r3, r0
   29ed0:	6068      	str	r0, [r5, #4]
   29ed2:	f44f 7200 	mov.w	r2, #512	; 0x200
   29ed6:	3004      	adds	r0, #4
    ns->capacity = STACK_SIZE;
   29ed8:	f8a3 1208 	strh.w	r1, [r3, #520]	; 0x208
   29edc:	21ff      	movs	r1, #255	; 0xff
    ns->mempool = m;
   29ede:	601e      	str	r6, [r3, #0]
    ns->ordered = 0;
   29ee0:	f8c3 420c 	str.w	r4, [r3, #524]	; 0x20c
    ns->pos = 0;
   29ee4:	f8c3 4204 	str.w	r4, [r3, #516]	; 0x204
    }
    tStack_initToPool(&poly->stack, mp);

}
   29ee8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   29eec:	f002 bcf9 	b.w	2c8e2 <memset>

00029ef0 <tSimplePoly_noteOn>:
    mpool_free((char*)poly->voices, poly->mempool);
    mpool_free((char*)poly, poly->mempool);
}

int tSimplePoly_noteOn(tSimplePoly* const polyh, int note, uint8_t vel)
{
   29ef0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tSimplePoly* poly = *polyh;
   29ef4:	6806      	ldr	r6, [r0, #0]
    _tStack* ns = *stack;
   29ef6:	f8d6 c004 	ldr.w	ip, [r6, #4]
    for (int i = 0; i < ns->size; i++)
   29efa:	f8bc 7206 	ldrh.w	r7, [ip, #518]	; 0x206
   29efe:	b18f      	cbz	r7, 29f24 <tSimplePoly_noteOn+0x34>
   29f00:	b28d      	uxth	r5, r1
        if (ns->data[i] == noteVal)    return i;
   29f02:	f8dc 3004 	ldr.w	r3, [ip, #4]
   29f06:	429d      	cmp	r5, r3
   29f08:	f000 809f 	beq.w	2a04a <tSimplePoly_noteOn+0x15a>
   29f0c:	f10c 0004 	add.w	r0, ip, #4
    for (int i = 0; i < ns->size; i++)
   29f10:	2300      	movs	r3, #0
   29f12:	e004      	b.n	29f1e <tSimplePoly_noteOn+0x2e>
        if (ns->data[i] == noteVal)    return i;
   29f14:	f850 4f04 	ldr.w	r4, [r0, #4]!
   29f18:	42ac      	cmp	r4, r5
   29f1a:	f000 8096 	beq.w	2a04a <tSimplePoly_noteOn+0x15a>
    for (int i = 0; i < ns->size; i++)
   29f1e:	3301      	adds	r3, #1
   29f20:	42bb      	cmp	r3, r7
   29f22:	d1f7      	bne.n	29f14 <tSimplePoly_noteOn+0x24>
    if (tStack_contains(&poly->stack, note) >= 0) return -1;
    else
    {
        alteredVoice = -1;
        int found = 0;
        for (int i = 0; i < poly->numVoices; i++)
   29f24:	f8d6 8008 	ldr.w	r8, [r6, #8]
   29f28:	f1b8 0f00 	cmp.w	r8, #0
   29f2c:	dd29      	ble.n	29f82 <tSimplePoly_noteOn+0x92>
        {
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
   29f2e:	6933      	ldr	r3, [r6, #16]
   29f30:	f8d3 9000 	ldr.w	r9, [r3]
   29f34:	f8d9 b000 	ldr.w	fp, [r9]
   29f38:	f1bb 3fff 	cmp.w	fp, #4294967295	; 0xffffffff
   29f3c:	f000 8089 	beq.w	2a052 <tSimplePoly_noteOn+0x162>
   29f40:	469e      	mov	lr, r3
        for (int i = 0; i < poly->numVoices; i++)
   29f42:	2000      	movs	r0, #0
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
   29f44:	461c      	mov	r4, r3
   29f46:	e005      	b.n	29f54 <tSimplePoly_noteOn+0x64>
   29f48:	f854 3f04 	ldr.w	r3, [r4, #4]!
   29f4c:	681d      	ldr	r5, [r3, #0]
   29f4e:	3501      	adds	r5, #1
   29f50:	f000 8082 	beq.w	2a058 <tSimplePoly_noteOn+0x168>
        for (int i = 0; i < poly->numVoices; i++)
   29f54:	3001      	adds	r0, #1
   29f56:	4540      	cmp	r0, r8
   29f58:	ea4f 0a80 	mov.w	sl, r0, lsl #2
   29f5c:	d1f4      	bne.n	29f48 <tSimplePoly_noteOn+0x58>
        if (!found)
        {
            //second preference is grabbing one that is in release phase but not finished sounding yet
            for (int i = 0 ; i < poly->numVoices; i++)
            {
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
   29f5e:	f11b 0f02 	cmn.w	fp, #2
            for (int i = 0 ; i < poly->numVoices; i++)
   29f62:	f04f 0300 	mov.w	r3, #0
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
   29f66:	d107      	bne.n	29f78 <tSimplePoly_noteOn+0x88>
   29f68:	e0b4      	b.n	2a0d4 <tSimplePoly_noteOn+0x1e4>
   29f6a:	f85e 9f04 	ldr.w	r9, [lr, #4]!
   29f6e:	f8d9 4000 	ldr.w	r4, [r9]
   29f72:	3402      	adds	r4, #2
   29f74:	f000 80af 	beq.w	2a0d6 <tSimplePoly_noteOn+0x1e6>
            for (int i = 0 ; i < poly->numVoices; i++)
   29f78:	3301      	adds	r3, #1
   29f7a:	4298      	cmp	r0, r3
   29f7c:	ea4f 0583 	mov.w	r5, r3, lsl #2
   29f80:	d1f3      	bne.n	29f6a <tSimplePoly_noteOn+0x7a>
                    tStack_add(&poly->stack, note);
                    break;
                }
            }
        }
        if ((!found) && (poly->stealing_on)) //steal
   29f82:	6973      	ldr	r3, [r6, #20]
   29f84:	2b00      	cmp	r3, #0
   29f86:	d060      	beq.n	2a04a <tSimplePoly_noteOn+0x15a>
        {
            for (int j = tStack_getSize(&poly->stack) - 1; j >= 0; j--)
   29f88:	1e78      	subs	r0, r7, #1
   29f8a:	2f00      	cmp	r7, #0
   29f8c:	d05f      	beq.n	2a04e <tSimplePoly_noteOn+0x15e>
    return ns->data[which];
   29f8e:	eb0c 0380 	add.w	r3, ip, r0, lsl #2
            {
                whichNote = tStack_get(&poly->stack, j);
                whichVoice = poly->notes[whichNote][0];
   29f92:	685b      	ldr	r3, [r3, #4]
   29f94:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
   29f98:	69db      	ldr	r3, [r3, #28]
                if (whichVoice >= 0)
   29f9a:	2b00      	cmp	r3, #0
   29f9c:	da0b      	bge.n	29fb6 <tSimplePoly_noteOn+0xc6>
   29f9e:	eb0c 0787 	add.w	r7, ip, r7, lsl #2
            for (int j = tStack_getSize(&poly->stack) - 1; j >= 0; j--)
   29fa2:	f110 30ff 	adds.w	r0, r0, #4294967295	; 0xffffffff
   29fa6:	d352      	bcc.n	2a04e <tSimplePoly_noteOn+0x15e>
                whichVoice = poly->notes[whichNote][0];
   29fa8:	f857 3d04 	ldr.w	r3, [r7, #-4]!
   29fac:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
   29fb0:	69db      	ldr	r3, [r3, #28]
                if (whichVoice >= 0)
   29fb2:	2b00      	cmp	r3, #0
   29fb4:	dbf5      	blt.n	29fa2 <tSimplePoly_noteOn+0xb2>
                {
                    oldNote = poly->voices[whichVoice][0];
   29fb6:	6930      	ldr	r0, [r6, #16]
                    poly->voices[whichVoice][0] = note;
                    poly->voices[whichVoice][1] = vel;
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
                    poly->notes[note][0] = whichVoice;
   29fb8:	eb06 05c1 	add.w	r5, r6, r1, lsl #3
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
   29fbc:	f06f 0702 	mvn.w	r7, #2
                    oldNote = poly->voices[whichVoice][0];
   29fc0:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   29fc4:	6820      	ldr	r0, [r4, #0]
                    poly->voices[whichVoice][0] = note;
   29fc6:	6021      	str	r1, [r4, #0]
                    poly->voices[whichVoice][1] = vel;
   29fc8:	6934      	ldr	r4, [r6, #16]
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
   29fca:	eb06 00c0 	add.w	r0, r6, r0, lsl #3
                    poly->voices[whichVoice][1] = vel;
   29fce:	f854 c023 	ldr.w	ip, [r4, r3, lsl #2]
   29fd2:	f8cc 2004 	str.w	r2, [ip, #4]
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
   29fd6:	61c7      	str	r7, [r0, #28]
   29fd8:	b28f      	uxth	r7, r1
                    poly->notes[note][0] = whichVoice;
   29fda:	61eb      	str	r3, [r5, #28]
                    poly->notes[note][1] = vel;
   29fdc:	622a      	str	r2, [r5, #32]

                    poly->voices[whichVoice][2] = note;
   29fde:	6932      	ldr	r2, [r6, #16]
   29fe0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   29fe4:	6091      	str	r1, [r2, #8]
    _tStack* ns = *stack;
   29fe6:	6871      	ldr	r1, [r6, #4]
    if (ns->ordered)
   29fe8:	f8d1 420c 	ldr.w	r4, [r1, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
   29fec:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
    if (ns->ordered)
   29ff0:	b1a4      	cbz	r4, 2a01c <tSimplePoly_noteOn+0x12c>
        for (j = 0; j < ns->size; j++)
   29ff2:	f1bc 0f00 	cmp.w	ip, #0
   29ff6:	f000 80a3 	beq.w	2a140 <tSimplePoly_noteOn+0x250>
   29ffa:	2200      	movs	r2, #0
   29ffc:	eb01 0582 	add.w	r5, r1, r2, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a000:	1c50      	adds	r0, r2, #1
            if (noteVal > ns->data[j])
   2a002:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a004:	4604      	mov	r4, r0
            if (noteVal > ns->data[j])
   2a006:	42be      	cmp	r6, r7
   2a008:	da04      	bge.n	2a014 <tSimplePoly_noteOn+0x124>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a00a:	68aa      	ldr	r2, [r5, #8]
   2a00c:	1c55      	adds	r5, r2, #1
   2a00e:	d005      	beq.n	2a01c <tSimplePoly_noteOn+0x12c>
   2a010:	42ba      	cmp	r2, r7
   2a012:	dc03      	bgt.n	2a01c <tSimplePoly_noteOn+0x12c>
        for (j = 0; j < ns->size; j++)
   2a014:	b2c2      	uxtb	r2, r0
   2a016:	4562      	cmp	r2, ip
   2a018:	d3f0      	bcc.n	29ffc <tSimplePoly_noteOn+0x10c>
    int whereToInsert = 0;
   2a01a:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
   2a01c:	fa5f f28c 	uxtb.w	r2, ip
   2a020:	4294      	cmp	r4, r2
   2a022:	da08      	bge.n	2a036 <tSimplePoly_noteOn+0x146>
   2a024:	1e56      	subs	r6, r2, #1
   2a026:	eb01 0082 	add.w	r0, r1, r2, lsl #2
        ns->data[j] = ns->data[(j - 1)];
   2a02a:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
   2a02e:	b2f2      	uxtb	r2, r6
        ns->data[j] = ns->data[(j - 1)];
   2a030:	6045      	str	r5, [r0, #4]
    for (j = ns->size; j > whereToInsert; j--)
   2a032:	42a2      	cmp	r2, r4
   2a034:	dcf6      	bgt.n	2a024 <tSimplePoly_noteOn+0x134>
    ns->data[whereToInsert] = noteVal;
   2a036:	eb01 0484 	add.w	r4, r1, r4, lsl #2
    ns->size++;
   2a03a:	f10c 0c01 	add.w	ip, ip, #1
   2a03e:	4618      	mov	r0, r3
    ns->data[whereToInsert] = noteVal;
   2a040:	6067      	str	r7, [r4, #4]
    ns->size++;
   2a042:	f8a1 c206 	strh.w	ip, [r1, #518]	; 0x206
                }
            }
        }
        return alteredVoice;
    }
}
   2a046:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (tStack_contains(&poly->stack, note) >= 0) return -1;
   2a04a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   2a04e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for (int i = 0; i < poly->numVoices; i++)
   2a052:	2000      	movs	r0, #0
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
   2a054:	464b      	mov	r3, r9
   2a056:	4682      	mov	sl, r0
                poly->voices[i][0] = note;
   2a058:	6019      	str	r1, [r3, #0]
                poly->notes[note][0] = i;
   2a05a:	eb06 04c1 	add.w	r4, r6, r1, lsl #3
                poly->voices[i][1] = vel;
   2a05e:	6935      	ldr	r5, [r6, #16]
   2a060:	b28f      	uxth	r7, r1
   2a062:	f855 500a 	ldr.w	r5, [r5, sl]
   2a066:	606a      	str	r2, [r5, #4]
                poly->notes[note][0] = i;
   2a068:	61e0      	str	r0, [r4, #28]
                poly->notes[note][1] = vel;
   2a06a:	6222      	str	r2, [r4, #32]
                poly->voices[i][2] = note; // voices[i][2] is the output midi note, (avoiding the -1 when a voice is inactive)
   2a06c:	6933      	ldr	r3, [r6, #16]
   2a06e:	f853 300a 	ldr.w	r3, [r3, sl]
   2a072:	6099      	str	r1, [r3, #8]
    _tStack* ns = *stack;
   2a074:	6872      	ldr	r2, [r6, #4]
    if (ns->ordered)
   2a076:	f8d2 420c 	ldr.w	r4, [r2, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
   2a07a:	f8b2 c206 	ldrh.w	ip, [r2, #518]	; 0x206
    if (ns->ordered)
   2a07e:	b19c      	cbz	r4, 2a0a8 <tSimplePoly_noteOn+0x1b8>
        for (j = 0; j < ns->size; j++)
   2a080:	f1bc 0f00 	cmp.w	ip, #0
   2a084:	d05e      	beq.n	2a144 <tSimplePoly_noteOn+0x254>
   2a086:	2300      	movs	r3, #0
   2a088:	eb02 0583 	add.w	r5, r2, r3, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a08c:	1c59      	adds	r1, r3, #1
            if (noteVal > ns->data[j])
   2a08e:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a090:	460c      	mov	r4, r1
            if (noteVal > ns->data[j])
   2a092:	42be      	cmp	r6, r7
   2a094:	da04      	bge.n	2a0a0 <tSimplePoly_noteOn+0x1b0>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a096:	68ab      	ldr	r3, [r5, #8]
   2a098:	1c5d      	adds	r5, r3, #1
   2a09a:	d005      	beq.n	2a0a8 <tSimplePoly_noteOn+0x1b8>
   2a09c:	42bb      	cmp	r3, r7
   2a09e:	dc03      	bgt.n	2a0a8 <tSimplePoly_noteOn+0x1b8>
        for (j = 0; j < ns->size; j++)
   2a0a0:	b2cb      	uxtb	r3, r1
   2a0a2:	459c      	cmp	ip, r3
   2a0a4:	d8f0      	bhi.n	2a088 <tSimplePoly_noteOn+0x198>
    int whereToInsert = 0;
   2a0a6:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
   2a0a8:	fa5f f38c 	uxtb.w	r3, ip
   2a0ac:	42a3      	cmp	r3, r4
   2a0ae:	dd08      	ble.n	2a0c2 <tSimplePoly_noteOn+0x1d2>
   2a0b0:	1e5e      	subs	r6, r3, #1
   2a0b2:	eb02 0183 	add.w	r1, r2, r3, lsl #2
        ns->data[j] = ns->data[(j - 1)];
   2a0b6:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
   2a0ba:	b2f3      	uxtb	r3, r6
        ns->data[j] = ns->data[(j - 1)];
   2a0bc:	604d      	str	r5, [r1, #4]
    for (j = ns->size; j > whereToInsert; j--)
   2a0be:	42a3      	cmp	r3, r4
   2a0c0:	dcf6      	bgt.n	2a0b0 <tSimplePoly_noteOn+0x1c0>
    ns->data[whereToInsert] = noteVal;
   2a0c2:	eb02 0484 	add.w	r4, r2, r4, lsl #2
    ns->size++;
   2a0c6:	f10c 0c01 	add.w	ip, ip, #1
    ns->data[whereToInsert] = noteVal;
   2a0ca:	6067      	str	r7, [r4, #4]
    ns->size++;
   2a0cc:	f8a2 c206 	strh.w	ip, [r2, #518]	; 0x206
}
   2a0d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
   2a0d4:	461d      	mov	r5, r3
                    poly->voices[i][0] = note;
   2a0d6:	f8c9 1000 	str.w	r1, [r9]
                    poly->notes[note][0] = i;
   2a0da:	eb06 04c1 	add.w	r4, r6, r1, lsl #3
                    poly->voices[i][1] = vel;
   2a0de:	6937      	ldr	r7, [r6, #16]
   2a0e0:	597f      	ldr	r7, [r7, r5]
   2a0e2:	607a      	str	r2, [r7, #4]
   2a0e4:	b28f      	uxth	r7, r1
                    poly->notes[note][0] = i;
   2a0e6:	61e3      	str	r3, [r4, #28]
                    poly->notes[note][1] = vel;
   2a0e8:	6222      	str	r2, [r4, #32]
                    poly->voices[i][2] = note; // voices[i][2] is the output midi note, (avoiding the -1 when a voice is inactive)
   2a0ea:	6932      	ldr	r2, [r6, #16]
   2a0ec:	5952      	ldr	r2, [r2, r5]
   2a0ee:	6091      	str	r1, [r2, #8]
    _tStack* ns = *stack;
   2a0f0:	6871      	ldr	r1, [r6, #4]
    if (ns->ordered)
   2a0f2:	f8d1 420c 	ldr.w	r4, [r1, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
   2a0f6:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
    if (ns->ordered)
   2a0fa:	b19c      	cbz	r4, 2a124 <tSimplePoly_noteOn+0x234>
        for (j = 0; j < ns->size; j++)
   2a0fc:	f1bc 0f00 	cmp.w	ip, #0
   2a100:	d01e      	beq.n	2a140 <tSimplePoly_noteOn+0x250>
   2a102:	2200      	movs	r2, #0
   2a104:	eb01 0582 	add.w	r5, r1, r2, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a108:	1c50      	adds	r0, r2, #1
            if (noteVal > ns->data[j])
   2a10a:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a10c:	4604      	mov	r4, r0
            if (noteVal > ns->data[j])
   2a10e:	42be      	cmp	r6, r7
   2a110:	da04      	bge.n	2a11c <tSimplePoly_noteOn+0x22c>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a112:	68aa      	ldr	r2, [r5, #8]
   2a114:	1c56      	adds	r6, r2, #1
   2a116:	d005      	beq.n	2a124 <tSimplePoly_noteOn+0x234>
   2a118:	42ba      	cmp	r2, r7
   2a11a:	dc03      	bgt.n	2a124 <tSimplePoly_noteOn+0x234>
        for (j = 0; j < ns->size; j++)
   2a11c:	b2c2      	uxtb	r2, r0
   2a11e:	4562      	cmp	r2, ip
   2a120:	d3f0      	bcc.n	2a104 <tSimplePoly_noteOn+0x214>
    int whereToInsert = 0;
   2a122:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
   2a124:	fa5f f28c 	uxtb.w	r2, ip
   2a128:	4294      	cmp	r4, r2
   2a12a:	da84      	bge.n	2a036 <tSimplePoly_noteOn+0x146>
   2a12c:	1e56      	subs	r6, r2, #1
   2a12e:	eb01 0082 	add.w	r0, r1, r2, lsl #2
        ns->data[j] = ns->data[(j - 1)];
   2a132:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
   2a136:	b2f2      	uxtb	r2, r6
        ns->data[j] = ns->data[(j - 1)];
   2a138:	6045      	str	r5, [r0, #4]
    for (j = ns->size; j > whereToInsert; j--)
   2a13a:	42a2      	cmp	r2, r4
   2a13c:	dcf6      	bgt.n	2a12c <tSimplePoly_noteOn+0x23c>
   2a13e:	e77a      	b.n	2a036 <tSimplePoly_noteOn+0x146>
    int whereToInsert = 0;
   2a140:	4664      	mov	r4, ip
   2a142:	e778      	b.n	2a036 <tSimplePoly_noteOn+0x146>
   2a144:	4664      	mov	r4, ip
   2a146:	e7bc      	b.n	2a0c2 <tSimplePoly_noteOn+0x1d2>

0002a148 <tSimplePoly_noteOff>:



int tSimplePoly_noteOff(tSimplePoly* const polyh, uint8_t note)
{
   2a148:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tSimplePoly* poly = *polyh;
   2a14c:	6805      	ldr	r5, [r0, #0]
    _tStack* ns = *stack;
   2a14e:	f8d5 c004 	ldr.w	ip, [r5, #4]
    for (int i = 0; i < ns->size; i++)
   2a152:	f8bc 0206 	ldrh.w	r0, [ip, #518]	; 0x206
   2a156:	b178      	cbz	r0, 2a178 <tSimplePoly_noteOff+0x30>
        if (ns->data[i] == noteVal)    return i;
   2a158:	f8dc 3004 	ldr.w	r3, [ip, #4]
   2a15c:	428b      	cmp	r3, r1
   2a15e:	f000 808a 	beq.w	2a276 <tSimplePoly_noteOff+0x12e>
   2a162:	f10c 0304 	add.w	r3, ip, #4
    for (int i = 0; i < ns->size; i++)
   2a166:	2600      	movs	r6, #0
   2a168:	e003      	b.n	2a172 <tSimplePoly_noteOff+0x2a>
        if (ns->data[i] == noteVal)    return i;
   2a16a:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2a16e:	428a      	cmp	r2, r1
   2a170:	d057      	beq.n	2a222 <tSimplePoly_noteOff+0xda>
    for (int i = 0; i < ns->size; i++)
   2a172:	3601      	adds	r6, #1
   2a174:	4286      	cmp	r6, r0
   2a176:	d1f8      	bne.n	2a16a <tSimplePoly_noteOff+0x22>
    int16_t noteToTest = -1;

    tStack_remove(&poly->stack, note);
    poly->notes[note][0] = -1;
   2a178:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
   2a17c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a180:	61d8      	str	r0, [r3, #28]

    int deactivatedVoice = -1;
    for (int i = 0; i < poly->maxNumVoices; i++)
   2a182:	68ee      	ldr	r6, [r5, #12]
   2a184:	2e00      	cmp	r6, #0
   2a186:	dd12      	ble.n	2a1ae <tSimplePoly_noteOff+0x66>
    {
        if (poly->voices[i][0] == note)
   2a188:	692b      	ldr	r3, [r5, #16]
   2a18a:	681a      	ldr	r2, [r3, #0]
   2a18c:	6810      	ldr	r0, [r2, #0]
   2a18e:	4288      	cmp	r0, r1
   2a190:	d00f      	beq.n	2a1b2 <tSimplePoly_noteOff+0x6a>
    for (int i = 0; i < poly->maxNumVoices; i++)
   2a192:	2000      	movs	r0, #0
   2a194:	e004      	b.n	2a1a0 <tSimplePoly_noteOff+0x58>
        if (poly->voices[i][0] == note)
   2a196:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2a19a:	6814      	ldr	r4, [r2, #0]
   2a19c:	428c      	cmp	r4, r1
   2a19e:	d00a      	beq.n	2a1b6 <tSimplePoly_noteOff+0x6e>
    for (int i = 0; i < poly->maxNumVoices; i++)
   2a1a0:	3001      	adds	r0, #1
   2a1a2:	42b0      	cmp	r0, r6
   2a1a4:	ea4f 0780 	mov.w	r7, r0, lsl #2
   2a1a8:	d1f5      	bne.n	2a196 <tSimplePoly_noteOff+0x4e>
                {
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
                    poly->voices[deactivatedVoice][2] = noteToTest;
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
                    return -1;
   2a1aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
                }
            }
        }
    }
    return deactivatedVoice;
}
   2a1ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    for (int i = 0; i < poly->maxNumVoices; i++)
   2a1b2:	2000      	movs	r0, #0
        if (poly->voices[i][0] == note)
   2a1b4:	4607      	mov	r7, r0
            poly->voices[i][0] = -1;
   2a1b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
            poly->voices[i][1] = 0;
   2a1ba:	2600      	movs	r6, #0
            poly->voices[i][0] = -1;
   2a1bc:	6013      	str	r3, [r2, #0]
            poly->voices[i][1] = 0;
   2a1be:	692b      	ldr	r3, [r5, #16]
   2a1c0:	59db      	ldr	r3, [r3, r7]
   2a1c2:	605e      	str	r6, [r3, #4]
    if (poly->recover_stolen)
   2a1c4:	69ab      	ldr	r3, [r5, #24]
   2a1c6:	2b00      	cmp	r3, #0
   2a1c8:	d0f1      	beq.n	2a1ae <tSimplePoly_noteOff+0x66>
    _tStack* ns = *stack;
   2a1ca:	6869      	ldr	r1, [r5, #4]
    return ns->size;
   2a1cc:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a1d0:	f1bc 0f00 	cmp.w	ip, #0
   2a1d4:	d0eb      	beq.n	2a1ae <tSimplePoly_noteOff+0x66>
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2a1d6:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
   2a1da:	1cdc      	adds	r4, r3, #3
   2a1dc:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
   2a1e0:	6852      	ldr	r2, [r2, #4]
   2a1e2:	3203      	adds	r2, #3
   2a1e4:	d00d      	beq.n	2a202 <tSimplePoly_noteOff+0xba>
   2a1e6:	3104      	adds	r1, #4
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a1e8:	4632      	mov	r2, r6
   2a1ea:	3201      	adds	r2, #1
   2a1ec:	4562      	cmp	r2, ip
   2a1ee:	d0de      	beq.n	2a1ae <tSimplePoly_noteOff+0x66>
                noteToTest = tStack_get(&poly->stack, j);
   2a1f0:	f851 3f04 	ldr.w	r3, [r1, #4]!
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2a1f4:	b21b      	sxth	r3, r3
   2a1f6:	1cdc      	adds	r4, r3, #3
   2a1f8:	eb05 06c4 	add.w	r6, r5, r4, lsl #3
   2a1fc:	6876      	ldr	r6, [r6, #4]
   2a1fe:	3603      	adds	r6, #3
   2a200:	d1f3      	bne.n	2a1ea <tSimplePoly_noteOff+0xa2>
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2a202:	692a      	ldr	r2, [r5, #16]
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2a204:	eb05 01c3 	add.w	r1, r5, r3, lsl #3
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
   2a208:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2a20c:	59d2      	ldr	r2, [r2, r7]
   2a20e:	6013      	str	r3, [r2, #0]
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2a210:	692a      	ldr	r2, [r5, #16]
   2a212:	6a09      	ldr	r1, [r1, #32]
   2a214:	59d2      	ldr	r2, [r2, r7]
   2a216:	6051      	str	r1, [r2, #4]
                    poly->voices[deactivatedVoice][2] = noteToTest;
   2a218:	692a      	ldr	r2, [r5, #16]
   2a21a:	59d2      	ldr	r2, [r2, r7]
   2a21c:	6093      	str	r3, [r2, #8]
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
   2a21e:	6060      	str	r0, [r4, #4]
   2a220:	e7c3      	b.n	2a1aa <tSimplePoly_noteOff+0x62>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a222:	eba0 0806 	sub.w	r8, r0, r6
   2a226:	f1b8 0f00 	cmp.w	r8, #0
   2a22a:	dd22      	ble.n	2a272 <tSimplePoly_noteOff+0x12a>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a22c:	f8bc e208 	ldrh.w	lr, [ip, #520]	; 0x208
   2a230:	2200      	movs	r2, #0
                    ns->data[k + foundIndex + 1] = -1;
   2a232:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   2a236:	3801      	subs	r0, #1
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a238:	4613      	mov	r3, r2
   2a23a:	44ce      	add	lr, r9
   2a23c:	e006      	b.n	2a24c <tSimplePoly_noteOff+0x104>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a23e:	3201      	adds	r2, #1
                ns->data[k + foundIndex] = -1;
   2a240:	f8c4 9004 	str.w	r9, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a244:	b2d2      	uxtb	r2, r2
   2a246:	4590      	cmp	r8, r2
   2a248:	4613      	mov	r3, r2
   2a24a:	dd0f      	ble.n	2a26c <tSimplePoly_noteOff+0x124>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a24c:	4433      	add	r3, r6
   2a24e:	4573      	cmp	r3, lr
   2a250:	eb0c 0483 	add.w	r4, ip, r3, lsl #2
   2a254:	daf3      	bge.n	2a23e <tSimplePoly_noteOff+0xf6>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a256:	3201      	adds	r2, #1
                if ((k + foundIndex) == (ns->size - 1))
   2a258:	4283      	cmp	r3, r0
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2a25a:	68a7      	ldr	r7, [r4, #8]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a25c:	b2d2      	uxtb	r2, r2
                    ns->data[k + foundIndex + 1] = -1;
   2a25e:	bf08      	it	eq
   2a260:	f8c4 9008 	streq.w	r9, [r4, #8]
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2a264:	6067      	str	r7, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a266:	4590      	cmp	r8, r2
   2a268:	4613      	mov	r3, r2
   2a26a:	dcef      	bgt.n	2a24c <tSimplePoly_noteOff+0x104>
        ns->size--;
   2a26c:	f8ac 0206 	strh.w	r0, [ip, #518]	; 0x206
   2a270:	e782      	b.n	2a178 <tSimplePoly_noteOff+0x30>
   2a272:	3801      	subs	r0, #1
   2a274:	e7fa      	b.n	2a26c <tSimplePoly_noteOff+0x124>
        if (ns->data[i] == noteVal)    return i;
   2a276:	4680      	mov	r8, r0
    for (int i = 0; i < ns->size; i++)
   2a278:	2600      	movs	r6, #0
   2a27a:	e7d7      	b.n	2a22c <tSimplePoly_noteOff+0xe4>

0002a27c <tSimplePoly_deactivateVoice>:


void tSimplePoly_deactivateVoice(tSimplePoly* const polyh, uint8_t voice)
{
   2a27c:	b4f0      	push	{r4, r5, r6, r7}
    _tSimplePoly* poly = *polyh;
   2a27e:	6803      	ldr	r3, [r0, #0]

    if (poly->voices[voice][0] == -2) //only do this if the voice is waiting for deactivation (not already reassigned while waiting)
   2a280:	b208      	sxth	r0, r1
   2a282:	691a      	ldr	r2, [r3, #16]
   2a284:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
   2a288:	6822      	ldr	r2, [r4, #0]
   2a28a:	3202      	adds	r2, #2
   2a28c:	d001      	beq.n	2a292 <tSimplePoly_deactivateVoice+0x16>
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
                }
            }
        }
    }
}
   2a28e:	bcf0      	pop	{r4, r5, r6, r7}
   2a290:	4770      	bx	lr
        poly->voices[voice][0] = -1;
   2a292:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2a296:	0085      	lsls	r5, r0, #2
        poly->voices[voice][1] = 0;
   2a298:	2200      	movs	r2, #0
        poly->voices[voice][0] = -1;
   2a29a:	6026      	str	r6, [r4, #0]
        poly->voices[voice][1] = 0;
   2a29c:	691c      	ldr	r4, [r3, #16]
   2a29e:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
   2a2a2:	6042      	str	r2, [r0, #4]
        if (poly->recover_stolen)
   2a2a4:	6998      	ldr	r0, [r3, #24]
   2a2a6:	2800      	cmp	r0, #0
   2a2a8:	d0f1      	beq.n	2a28e <tSimplePoly_deactivateVoice+0x12>
    _tStack* ns = *stack;
   2a2aa:	6858      	ldr	r0, [r3, #4]
    return ns->size;
   2a2ac:	f8b0 6206 	ldrh.w	r6, [r0, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a2b0:	2e00      	cmp	r6, #0
   2a2b2:	d0ec      	beq.n	2a28e <tSimplePoly_deactivateVoice+0x12>
   2a2b4:	4607      	mov	r7, r0
   2a2b6:	f8df c054 	ldr.w	ip, [pc, #84]	; 2a30c <tSimplePoly_deactivateVoice+0x90>
    return ns->data[which];
   2a2ba:	eb00 0082 	add.w	r0, r0, r2, lsl #2
                noteToTest = tStack_get(&poly->stack, j);
   2a2be:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2a2c2:	eb03 04c0 	add.w	r4, r3, r0, lsl #3
                noteToTest = tStack_get(&poly->stack, j);
   2a2c6:	f8ac 0000 	strh.w	r0, [ip]
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2a2ca:	69e4      	ldr	r4, [r4, #28]
   2a2cc:	3403      	adds	r4, #3
   2a2ce:	d004      	beq.n	2a2da <tSimplePoly_deactivateVoice+0x5e>
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a2d0:	3201      	adds	r2, #1
   2a2d2:	42b2      	cmp	r2, r6
   2a2d4:	dadb      	bge.n	2a28e <tSimplePoly_deactivateVoice+0x12>
{
   2a2d6:	4638      	mov	r0, r7
   2a2d8:	e7ef      	b.n	2a2ba <tSimplePoly_deactivateVoice+0x3e>
                    poly->voices[voice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2a2da:	691c      	ldr	r4, [r3, #16]
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a2dc:	3201      	adds	r2, #1
                    poly->voices[voice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2a2de:	5964      	ldr	r4, [r4, r5]
   2a2e0:	6020      	str	r0, [r4, #0]
                    poly->voices[voice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2a2e2:	f9bc 0000 	ldrsh.w	r0, [ip]
   2a2e6:	691c      	ldr	r4, [r3, #16]
   2a2e8:	eb03 06c0 	add.w	r6, r3, r0, lsl #3
   2a2ec:	5967      	ldr	r7, [r4, r5]
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
   2a2ee:	4634      	mov	r4, r6
                    poly->voices[voice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2a2f0:	6a36      	ldr	r6, [r6, #32]
   2a2f2:	607e      	str	r6, [r7, #4]
                    poly->voices[voice][2] = noteToTest;
   2a2f4:	691e      	ldr	r6, [r3, #16]
   2a2f6:	5976      	ldr	r6, [r6, r5]
   2a2f8:	60b0      	str	r0, [r6, #8]
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
   2a2fa:	61e1      	str	r1, [r4, #28]
   2a2fc:	685f      	ldr	r7, [r3, #4]
   2a2fe:	f8b7 6206 	ldrh.w	r6, [r7, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a302:	4296      	cmp	r6, r2
   2a304:	ddc3      	ble.n	2a28e <tSimplePoly_deactivateVoice+0x12>
{
   2a306:	4638      	mov	r0, r7
   2a308:	e7d7      	b.n	2a2ba <tSimplePoly_deactivateVoice+0x3e>
   2a30a:	bf00      	nop
   2a30c:	000628ec 	.word	0x000628ec

0002a310 <tSimplePoly_markPendingNoteOff>:
    return voiceWithThatNote;
}


int tSimplePoly_markPendingNoteOff(tSimplePoly* const polyh, uint8_t note)
{
   2a310:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tSimplePoly* poly = *polyh;
   2a314:	6805      	ldr	r5, [r0, #0]
    _tStack* ns = *stack;
   2a316:	f8d5 c004 	ldr.w	ip, [r5, #4]
    for (int i = 0; i < ns->size; i++)
   2a31a:	f8bc 0206 	ldrh.w	r0, [ip, #518]	; 0x206
   2a31e:	b170      	cbz	r0, 2a33e <tSimplePoly_markPendingNoteOff+0x2e>
        if (ns->data[i] == noteVal)    return i;
   2a320:	f8dc 3004 	ldr.w	r3, [ip, #4]
   2a324:	428b      	cmp	r3, r1
   2a326:	d05c      	beq.n	2a3e2 <tSimplePoly_markPendingNoteOff+0xd2>
   2a328:	f10c 0304 	add.w	r3, ip, #4
    for (int i = 0; i < ns->size; i++)
   2a32c:	2600      	movs	r6, #0
   2a32e:	e003      	b.n	2a338 <tSimplePoly_markPendingNoteOff+0x28>
        if (ns->data[i] == noteVal)    return i;
   2a330:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2a334:	4291      	cmp	r1, r2
   2a336:	d006      	beq.n	2a346 <tSimplePoly_markPendingNoteOff+0x36>
    for (int i = 0; i < ns->size; i++)
   2a338:	3601      	adds	r6, #1
   2a33a:	42b0      	cmp	r0, r6
   2a33c:	d1f8      	bne.n	2a330 <tSimplePoly_markPendingNoteOff+0x20>
    int deactivatedVoice = -1;
   2a33e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        }


    }
    return deactivatedVoice;
}
   2a342:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a346:	eba0 0806 	sub.w	r8, r0, r6
   2a34a:	f1b8 0f00 	cmp.w	r8, #0
   2a34e:	dd46      	ble.n	2a3de <tSimplePoly_markPendingNoteOff+0xce>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a350:	f8bc e208 	ldrh.w	lr, [ip, #520]	; 0x208
   2a354:	2200      	movs	r2, #0
                    ns->data[k + foundIndex + 1] = -1;
   2a356:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   2a35a:	3801      	subs	r0, #1
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a35c:	4613      	mov	r3, r2
   2a35e:	44ce      	add	lr, r9
   2a360:	e006      	b.n	2a370 <tSimplePoly_markPendingNoteOff+0x60>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a362:	3201      	adds	r2, #1
                ns->data[k + foundIndex] = -1;
   2a364:	f8c4 9004 	str.w	r9, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a368:	b2d2      	uxtb	r2, r2
   2a36a:	4590      	cmp	r8, r2
   2a36c:	4613      	mov	r3, r2
   2a36e:	dd0f      	ble.n	2a390 <tSimplePoly_markPendingNoteOff+0x80>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a370:	4433      	add	r3, r6
   2a372:	4573      	cmp	r3, lr
   2a374:	eb0c 0483 	add.w	r4, ip, r3, lsl #2
   2a378:	daf3      	bge.n	2a362 <tSimplePoly_markPendingNoteOff+0x52>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a37a:	3201      	adds	r2, #1
                if ((k + foundIndex) == (ns->size - 1))
   2a37c:	4283      	cmp	r3, r0
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2a37e:	68a7      	ldr	r7, [r4, #8]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a380:	b2d2      	uxtb	r2, r2
                    ns->data[k + foundIndex + 1] = -1;
   2a382:	bf08      	it	eq
   2a384:	f8c4 9008 	streq.w	r9, [r4, #8]
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2a388:	6067      	str	r7, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a38a:	4590      	cmp	r8, r2
   2a38c:	4613      	mov	r3, r2
   2a38e:	dcef      	bgt.n	2a370 <tSimplePoly_markPendingNoteOff+0x60>
        poly->notes[note][0] = -2;
   2a390:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
   2a394:	f06f 0201 	mvn.w	r2, #1
        ns->size--;
   2a398:	f8ac 0206 	strh.w	r0, [ip, #518]	; 0x206
        poly->notes[note][0] = -2;
   2a39c:	61da      	str	r2, [r3, #28]
        for (int i = 0; i < poly->maxNumVoices; i++)
   2a39e:	68ee      	ldr	r6, [r5, #12]
   2a3a0:	2e00      	cmp	r6, #0
   2a3a2:	ddcc      	ble.n	2a33e <tSimplePoly_markPendingNoteOff+0x2e>
            if (poly->voices[i][0] == note)
   2a3a4:	692b      	ldr	r3, [r5, #16]
   2a3a6:	681a      	ldr	r2, [r3, #0]
   2a3a8:	6810      	ldr	r0, [r2, #0]
   2a3aa:	4281      	cmp	r1, r0
   2a3ac:	d00c      	beq.n	2a3c8 <tSimplePoly_markPendingNoteOff+0xb8>
        for (int i = 0; i < poly->maxNumVoices; i++)
   2a3ae:	2000      	movs	r0, #0
   2a3b0:	e004      	b.n	2a3bc <tSimplePoly_markPendingNoteOff+0xac>
            if (poly->voices[i][0] == note)
   2a3b2:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2a3b6:	6814      	ldr	r4, [r2, #0]
   2a3b8:	428c      	cmp	r4, r1
   2a3ba:	d007      	beq.n	2a3cc <tSimplePoly_markPendingNoteOff+0xbc>
        for (int i = 0; i < poly->maxNumVoices; i++)
   2a3bc:	3001      	adds	r0, #1
   2a3be:	42b0      	cmp	r0, r6
   2a3c0:	ea4f 0780 	mov.w	r7, r0, lsl #2
   2a3c4:	d1f5      	bne.n	2a3b2 <tSimplePoly_markPendingNoteOff+0xa2>
   2a3c6:	e7ba      	b.n	2a33e <tSimplePoly_markPendingNoteOff+0x2e>
   2a3c8:	2000      	movs	r0, #0
            if (poly->voices[i][0] == note)
   2a3ca:	4607      	mov	r7, r0
                poly->voices[i][0] = -2;
   2a3cc:	f06f 0301 	mvn.w	r3, #1
                poly->voices[i][1] = 0;
   2a3d0:	2100      	movs	r1, #0
                poly->voices[i][0] = -2;
   2a3d2:	6013      	str	r3, [r2, #0]
                poly->voices[i][1] = 0;
   2a3d4:	692b      	ldr	r3, [r5, #16]
   2a3d6:	59db      	ldr	r3, [r3, r7]
   2a3d8:	6059      	str	r1, [r3, #4]
}
   2a3da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2a3de:	3801      	subs	r0, #1
   2a3e0:	e7d6      	b.n	2a390 <tSimplePoly_markPendingNoteOff+0x80>
        if (ns->data[i] == noteVal)    return i;
   2a3e2:	4680      	mov	r8, r0
    for (int i = 0; i < ns->size; i++)
   2a3e4:	2600      	movs	r6, #0
   2a3e6:	e7b3      	b.n	2a350 <tSimplePoly_markPendingNoteOff+0x40>

0002a3e8 <tSimplePoly_setNumVoices>:

void tSimplePoly_setNumVoices(tSimplePoly* const polyh, uint8_t numVoices)
{
    _tSimplePoly* poly = *polyh;
   2a3e8:	6802      	ldr	r2, [r0, #0]
    poly->numVoices = (numVoices > poly->maxNumVoices) ? poly->maxNumVoices : numVoices;
   2a3ea:	68d3      	ldr	r3, [r2, #12]
   2a3ec:	4299      	cmp	r1, r3
   2a3ee:	bfa8      	it	ge
   2a3f0:	4619      	movge	r1, r3
   2a3f2:	6091      	str	r1, [r2, #8]
}
   2a3f4:	4770      	bx	lr
   2a3f6:	bf00      	nop

0002a3f8 <tSimplePoly_getNumVoices>:


int tSimplePoly_getNumVoices(tSimplePoly* const polyh)
{
    _tSimplePoly* poly = *polyh;
    return poly->numVoices;
   2a3f8:	6803      	ldr	r3, [r0, #0]
}
   2a3fa:	6898      	ldr	r0, [r3, #8]
   2a3fc:	4770      	bx	lr
   2a3fe:	bf00      	nop

0002a400 <tSimplePoly_getNumActiveVoices>:

int tSimplePoly_getNumActiveVoices(tSimplePoly* const polyh)
{
   2a400:	b508      	push	{r3, lr}
    _tSimplePoly* poly = *polyh;
   2a402:	6803      	ldr	r3, [r0, #0]
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2a404:	ed9f 0a09 	vldr	s0, [pc, #36]	; 2a42c <tSimplePoly_getNumActiveVoices+0x2c>
    return ns->size;
   2a408:	685a      	ldr	r2, [r3, #4]
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2a40a:	ed93 1a02 	vldr	s2, [r3, #8]
    return ns->size;
   2a40e:	f8b2 3206 	ldrh.w	r3, [r2, #518]	; 0x206
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2a412:	eeb8 1ac1 	vcvt.f32.s32	s2, s2
    return ns->size;
   2a416:	ee00 3a90 	vmov	s1, r3
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2a41a:	eef8 0ae0 	vcvt.f32.s32	s1, s1
   2a41e:	f7ff f983 	bl	29728 <LEAF_clip>
}
   2a422:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   2a426:	ee17 0a90 	vmov	r0, s15
   2a42a:	bd08      	pop	{r3, pc}
   2a42c:	00000000 	.word	0x00000000

0002a430 <tSimplePoly_getPitch>:


int tSimplePoly_getPitch(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][2];
   2a430:	6803      	ldr	r3, [r0, #0]
   2a432:	691b      	ldr	r3, [r3, #16]
   2a434:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
   2a438:	6898      	ldr	r0, [r3, #8]
   2a43a:	4770      	bx	lr

0002a43c <tSimplePoly_getPitchAndCheckActive>:

//this one returns negative one if the voice is inactive
int tSimplePoly_getPitchAndCheckActive(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][0];
   2a43c:	6803      	ldr	r3, [r0, #0]
   2a43e:	691b      	ldr	r3, [r3, #16]
   2a440:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
   2a444:	6818      	ldr	r0, [r3, #0]
   2a446:	4770      	bx	lr

0002a448 <tSimplePoly_getVelocity>:

int tSimplePoly_getVelocity(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][1];
   2a448:	6803      	ldr	r3, [r0, #0]
   2a44a:	691b      	ldr	r3, [r3, #16]
   2a44c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
   2a450:	6858      	ldr	r0, [r3, #4]
   2a452:	4770      	bx	lr

0002a454 <tSimplePoly_isOn>:

int tSimplePoly_isOn(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return (poly->voices[voice][0] > 0) ? 1 : 0;
   2a454:	6803      	ldr	r3, [r0, #0]
   2a456:	691b      	ldr	r3, [r3, #16]
   2a458:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   2a45c:	6818      	ldr	r0, [r3, #0]
}
   2a45e:	2800      	cmp	r0, #0
   2a460:	bfd4      	ite	le
   2a462:	2000      	movle	r0, #0
   2a464:	2001      	movgt	r0, #1
   2a466:	4770      	bx	lr

0002a468 <tCycle_initToPool>:
{
    tCycle_initToPool(cy, &leaf.mempool);
}

void    tCycle_initToPool   (tCycle* const cy, tMempool* const mp)
{
   2a468:	b538      	push	{r3, r4, r5, lr}
    _tMempool* m = *mp;
   2a46a:	680c      	ldr	r4, [r1, #0]
{
   2a46c:	4605      	mov	r5, r0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
   2a46e:	2010      	movs	r0, #16
   2a470:	4621      	mov	r1, r4
   2a472:	f7ff fb59 	bl	29b28 <mpool_alloc>
    c->mempool = m;
    
    c->inc      =  0.0f;
   2a476:	2300      	movs	r3, #0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
   2a478:	6028      	str	r0, [r5, #0]
    c->mempool = m;
   2a47a:	6004      	str	r4, [r0, #0]
    c->inc      =  0.0f;
   2a47c:	6083      	str	r3, [r0, #8]
    c->phase    =  0.0f;
   2a47e:	6043      	str	r3, [r0, #4]
}
   2a480:	bd38      	pop	{r3, r4, r5, pc}
   2a482:	bf00      	nop

0002a484 <tCycle_free>:

void    tCycle_free (tCycle* const cy)
{
    _tCycle* c = *cy;
   2a484:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)c, c->mempool);
   2a486:	6801      	ldr	r1, [r0, #0]
   2a488:	f7ff bbf6 	b.w	29c78 <mpool_free>

0002a48c <tCycle_setFreq>:
{
    _tCycle* c = *cy;
    
    c->freq  = freq;

    c->inc = freq * leaf.invSampleRate;
   2a48c:	4a05      	ldr	r2, [pc, #20]	; (2a4a4 <tCycle_setFreq+0x18>)
    _tCycle* c = *cy;
   2a48e:	6803      	ldr	r3, [r0, #0]
    c->inc = freq * leaf.invSampleRate;
   2a490:	edd2 7a01 	vldr	s15, [r2, #4]
    c->freq  = freq;
   2a494:	ed83 0a03 	vstr	s0, [r3, #12]
    c->inc = freq * leaf.invSampleRate;
   2a498:	ee27 0a80 	vmul.f32	s0, s15, s0
   2a49c:	ed83 0a02 	vstr	s0, [r3, #8]
}
   2a4a0:	4770      	bx	lr
   2a4a2:	bf00      	nop
   2a4a4:	020fbd68 	.word	0x020fbd68

0002a4a8 <tCycle_tick>:

//need to check bounds and wrap table properly to allow through-zero FM
float   tCycle_tick(tCycle* const cy)
{
    _tCycle* c = *cy;
   2a4a8:	6803      	ldr	r3, [r0, #0]
    float samp0;
    float samp1;
    
    // Phasor increment
    c->phase += c->inc;
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a4aa:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    c->phase += c->inc;
   2a4ae:	ed93 7a01 	vldr	s14, [r3, #4]
   2a4b2:	edd3 7a02 	vldr	s15, [r3, #8]
   2a4b6:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a4ba:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c->phase += c->inc;
   2a4be:	ed83 7a01 	vstr	s14, [r3, #4]
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a4c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a4c6:	db3f      	blt.n	2a548 <tCycle_tick+0xa0>
   2a4c8:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2a4cc:	eeb4 7ac6 	vcmpe.f32	s14, s12
   2a4d0:	ee77 7a66 	vsub.f32	s15, s14, s13
   2a4d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a4d8:	eeb0 7a67 	vmov.f32	s14, s15
   2a4dc:	daf6      	bge.n	2a4cc <tCycle_tick+0x24>
    while (c->phase < 0.0f) c->phase += 1.0f;
   2a4de:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2a4e2:	edc3 7a01 	vstr	s15, [r3, #4]
   2a4e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a4ea:	d534      	bpl.n	2a556 <tCycle_tick+0xae>
   2a4ec:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2a4f0:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   2a4f4:	eef4 7ae6 	vcmpe.f32	s15, s13
   2a4f8:	ee37 7a86 	vadd.f32	s14, s15, s12
   2a4fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a500:	eef0 7a47 	vmov.f32	s15, s14
   2a504:	d4f6      	bmi.n	2a4f4 <tCycle_tick+0x4c>
   2a506:	ed83 7a01 	vstr	s14, [r3, #4]

    // Wavetable synthesis

	temp = SINE_TABLE_SIZE * c->phase;
   2a50a:	eddf 7a14 	vldr	s15, [pc, #80]	; 2a55c <tCycle_tick+0xb4>
	intPart = (int)temp;
	fracPart = temp - (float)intPart;
	samp0 = __leaf_table_sinewave[intPart];
   2a50e:	4a14      	ldr	r2, [pc, #80]	; (2a560 <tCycle_tick+0xb8>)
	temp = SINE_TABLE_SIZE * c->phase;
   2a510:	ee27 7a27 	vmul.f32	s14, s14, s15
	intPart = (int)temp;
   2a514:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   2a518:	ee17 3a90 	vmov	r3, s15
	fracPart = temp - (float)intPart;
   2a51c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
   2a520:	1c59      	adds	r1, r3, #1
	samp0 = __leaf_table_sinewave[intPart];
   2a522:	eb02 0083 	add.w	r0, r2, r3, lsl #2
	fracPart = temp - (float)intPart;
   2a526:	ee37 7a67 	vsub.f32	s14, s14, s15
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
   2a52a:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
	samp0 = __leaf_table_sinewave[intPart];
   2a52e:	ed90 0a00 	vldr	s0, [r0]
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
   2a532:	bfa8      	it	ge
   2a534:	2100      	movge	r1, #0
	samp1 = __leaf_table_sinewave[intPart];
   2a536:	eb02 0281 	add.w	r2, r2, r1, lsl #2

    return (samp0 + (samp1 - samp0) * fracPart);
   2a53a:	edd2 7a00 	vldr	s15, [r2]
   2a53e:	ee77 7ac0 	vsub.f32	s15, s15, s0
}
   2a542:	eea7 0a87 	vfma.f32	s0, s15, s14
   2a546:	4770      	bx	lr
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a548:	eef0 7a47 	vmov.f32	s15, s14
    while (c->phase < 0.0f) c->phase += 1.0f;
   2a54c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2a550:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a554:	d4ca      	bmi.n	2a4ec <tCycle_tick+0x44>
   2a556:	eeb0 7a67 	vmov.f32	s14, s15
   2a55a:	e7d6      	b.n	2a50a <tCycle_tick+0x62>
   2a55c:	45000000 	.word	0x45000000
   2a560:	0004fb64 	.word	0x0004fb64

0002a564 <tSawtooth_initToPool>:
{
    tSawtooth_initToPool(cy, &leaf.mempool);
}

void    tSawtooth_initToPool    (tSawtooth* const cy, tMempool* const mp)
{
   2a564:	b570      	push	{r4, r5, r6, lr}
    _tMempool* m = *mp;
   2a566:	680d      	ldr	r5, [r1, #0]
{
   2a568:	4604      	mov	r4, r0
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
   2a56a:	2018      	movs	r0, #24
{
    _tSawtooth* c = *cy;
    
    c->freq  = freq;
    
    c->inc = c->freq * leaf.invSampleRate;
   2a56c:	4e0c      	ldr	r6, [pc, #48]	; (2a5a0 <tSawtooth_initToPool+0x3c>)
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
   2a56e:	4629      	mov	r1, r5
   2a570:	f7ff fada 	bl	29b28 <mpool_alloc>
    c->inc      = 0.0f;
   2a574:	2300      	movs	r3, #0
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
   2a576:	6020      	str	r0, [r4, #0]
   2a578:	2103      	movs	r1, #3
    c->mempool = m;
   2a57a:	6005      	str	r5, [r0, #0]
    c->phase    = 0.0f;
   2a57c:	6043      	str	r3, [r0, #4]
    c->freq  = freq;
   2a57e:	ed9f 7a09 	vldr	s14, [pc, #36]	; 2a5a4 <tSawtooth_initToPool+0x40>
    c->inc = c->freq * leaf.invSampleRate;
   2a582:	edd6 7a01 	vldr	s15, [r6, #4]
    c->inc      = 0.0f;
   2a586:	6083      	str	r3, [r0, #8]
    c->inc = c->freq * leaf.invSampleRate;
   2a588:	ee67 7a87 	vmul.f32	s15, s15, s14
    _tSawtooth* c = *cy;
   2a58c:	6823      	ldr	r3, [r4, #0]
    c->w = c->freq * INV_20;
    for (c->oct = 0; c->w > 2.0f; c->oct++)
    {
        c->w = 0.5f * c->w;
    }
    c->w = 2.0f - c->w;
   2a58e:	4a06      	ldr	r2, [pc, #24]	; (2a5a8 <tSawtooth_initToPool+0x44>)
    c->freq  = freq;
   2a590:	ed83 7a03 	vstr	s14, [r3, #12]
    c->inc = c->freq * leaf.invSampleRate;
   2a594:	edc3 7a02 	vstr	s15, [r3, #8]
   2a598:	6119      	str	r1, [r3, #16]
    c->w = 2.0f - c->w;
   2a59a:	615a      	str	r2, [r3, #20]
}
   2a59c:	bd70      	pop	{r4, r5, r6, pc}
   2a59e:	bf00      	nop
   2a5a0:	020fbd68 	.word	0x020fbd68
   2a5a4:	435c0000 	.word	0x435c0000
   2a5a8:	3f200000 	.word	0x3f200000

0002a5ac <tSawtooth_free>:
    _tSawtooth* c = *cy;
   2a5ac:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)c, c->mempool);
   2a5ae:	6801      	ldr	r1, [r0, #0]
   2a5b0:	f7ff bb62 	b.w	29c78 <mpool_free>

0002a5b4 <tSawtooth_setFreq>:
    c->w = c->freq * INV_20;
   2a5b4:	eddf 7a16 	vldr	s15, [pc, #88]	; 2a610 <tSawtooth_setFreq+0x5c>
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a5b8:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
    c->inc = c->freq * leaf.invSampleRate;
   2a5bc:	4b15      	ldr	r3, [pc, #84]	; (2a614 <tSawtooth_setFreq+0x60>)
    c->w = c->freq * INV_20;
   2a5be:	ee60 7a27 	vmul.f32	s15, s0, s15
    _tSawtooth* c = *cy;
   2a5c2:	6802      	ldr	r2, [r0, #0]
    c->inc = c->freq * leaf.invSampleRate;
   2a5c4:	edd3 6a01 	vldr	s13, [r3, #4]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a5c8:	2300      	movs	r3, #0
    c->freq  = freq;
   2a5ca:	ed82 0a03 	vstr	s0, [r2, #12]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a5ce:	eef4 7ac7 	vcmpe.f32	s15, s14
    c->w = c->freq * INV_20;
   2a5d2:	edc2 7a05 	vstr	s15, [r2, #20]
    c->inc = c->freq * leaf.invSampleRate;
   2a5d6:	ee66 6a80 	vmul.f32	s13, s13, s0
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a5da:	6113      	str	r3, [r2, #16]
   2a5dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c->inc = c->freq * leaf.invSampleRate;
   2a5e0:	edc2 6a02 	vstr	s13, [r2, #8]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a5e4:	dd0c      	ble.n	2a600 <tSawtooth_setFreq+0x4c>
        c->w = 0.5f * c->w;
   2a5e6:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a5ea:	2301      	movs	r3, #1
        c->w = 0.5f * c->w;
   2a5ec:	ee67 7aa6 	vmul.f32	s15, s15, s13
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a5f0:	4619      	mov	r1, r3
   2a5f2:	3301      	adds	r3, #1
   2a5f4:	eef4 7ac7 	vcmpe.f32	s15, s14
   2a5f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a5fc:	dcf6      	bgt.n	2a5ec <tSawtooth_setFreq+0x38>
   2a5fe:	6111      	str	r1, [r2, #16]
    c->w = 2.0f - c->w;
   2a600:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
   2a604:	ee77 7a67 	vsub.f32	s15, s14, s15
   2a608:	edc2 7a05 	vstr	s15, [r2, #20]
}
   2a60c:	4770      	bx	lr
   2a60e:	bf00      	nop
   2a610:	3d4ccccd 	.word	0x3d4ccccd
   2a614:	020fbd68 	.word	0x020fbd68

0002a618 <tSawtooth_tick>:

float   tSawtooth_tick(tSawtooth* const cy)
{
   2a618:	b410      	push	{r4}
    _tSawtooth* c = *cy;
   2a61a:	6802      	ldr	r2, [r0, #0]
    
    // Phasor increment
    c->phase += c->inc;
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a61c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    c->phase += c->inc;
   2a620:	ed92 7a01 	vldr	s14, [r2, #4]
   2a624:	edd2 7a02 	vldr	s15, [r2, #8]
   2a628:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a62c:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c->phase += c->inc;
   2a630:	ed82 7a01 	vstr	s14, [r2, #4]
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a634:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a638:	db3e      	blt.n	2a6b8 <tSawtooth_tick+0xa0>
   2a63a:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2a63e:	eeb4 7ac6 	vcmpe.f32	s14, s12
   2a642:	ee77 7a66 	vsub.f32	s15, s14, s13
   2a646:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a64a:	eeb0 7a67 	vmov.f32	s14, s15
   2a64e:	daf6      	bge.n	2a63e <tSawtooth_tick+0x26>
    while (c->phase < 0.0f) c->phase += 1.0f;
   2a650:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2a654:	edc2 7a01 	vstr	s15, [r2, #4]
   2a658:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a65c:	d533      	bpl.n	2a6c6 <tSawtooth_tick+0xae>
   2a65e:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2a662:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   2a666:	eef4 7ae6 	vcmpe.f32	s15, s13
   2a66a:	ee37 7a86 	vadd.f32	s14, s15, s12
   2a66e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a672:	eef0 7a47 	vmov.f32	s15, s14
   2a676:	d4f6      	bmi.n	2a666 <tSawtooth_tick+0x4e>
   2a678:	ed82 7a01 	vstr	s14, [r2, #4]
    
    float out = 0.0f;
    
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
   2a67c:	eef0 7a47 	vmov.f32	s15, s14
    
    // Wavetable synthesis
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2a680:	6911      	ldr	r1, [r2, #16]
   2a682:	4812      	ldr	r0, [pc, #72]	; (2a6cc <tSawtooth_tick+0xb4>)
   2a684:	1c4c      	adds	r4, r1, #1
   2a686:	ed92 7a05 	vldr	s14, [r2, #20]
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
   2a68a:	eefe 7aea 	vcvt.s32.f32	s15, s15, #11
   2a68e:	ee17 3a90 	vmov	r3, s15
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2a692:	eb03 21c1 	add.w	r1, r3, r1, lsl #11
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2a696:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
    
    return out;
}
   2a69a:	f85d 4b04 	ldr.w	r4, [sp], #4
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2a69e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2a6a2:	eb00 0383 	add.w	r3, r0, r3, lsl #2
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2a6a6:	edd1 7a00 	vldr	s15, [r1]
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2a6aa:	ed93 0a00 	vldr	s0, [r3]
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2a6ae:	ee77 7ac0 	vsub.f32	s15, s15, s0
}
   2a6b2:	eea7 0a87 	vfma.f32	s0, s15, s14
   2a6b6:	4770      	bx	lr
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a6b8:	eef0 7a47 	vmov.f32	s15, s14
    while (c->phase < 0.0f) c->phase += 1.0f;
   2a6bc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2a6c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a6c4:	d4cb      	bmi.n	2a65e <tSawtooth_tick+0x46>
   2a6c6:	eeb0 7a67 	vmov.f32	s14, s15
   2a6ca:	e7d7      	b.n	2a67c <tSawtooth_tick+0x64>
   2a6cc:	00039b64 	.word	0x00039b64

0002a6d0 <tNoise_initToPool>:
{
    tNoise_initToPool(ns, type, &leaf.mempool);
}

void    tNoise_initToPool   (tNoise* const ns, NoiseType type, tMempool* const mp)
{
   2a6d0:	b570      	push	{r4, r5, r6, lr}
    _tMempool* m = *mp;
   2a6d2:	6814      	ldr	r4, [r2, #0]
{
   2a6d4:	4606      	mov	r6, r0
   2a6d6:	460d      	mov	r5, r1
    _tNoise* n = *ns = (_tNoise*) mpool_alloc(sizeof(_tNoise), m);
   2a6d8:	2018      	movs	r0, #24
   2a6da:	4621      	mov	r1, r4
   2a6dc:	f7ff fa24 	bl	29b28 <mpool_alloc>
    n->mempool = m;
    
    n->type = type;
    n->rand = leaf.random;
   2a6e0:	4b03      	ldr	r3, [pc, #12]	; (2a6f0 <tNoise_initToPool+0x20>)
    _tNoise* n = *ns = (_tNoise*) mpool_alloc(sizeof(_tNoise), m);
   2a6e2:	6030      	str	r0, [r6, #0]
    n->mempool = m;
   2a6e4:	6004      	str	r4, [r0, #0]
    n->type = type;
   2a6e6:	7105      	strb	r5, [r0, #4]
    n->rand = leaf.random;
   2a6e8:	691b      	ldr	r3, [r3, #16]
   2a6ea:	6143      	str	r3, [r0, #20]
}
   2a6ec:	bd70      	pop	{r4, r5, r6, pc}
   2a6ee:	bf00      	nop
   2a6f0:	020fbd68 	.word	0x020fbd68

0002a6f4 <tNoise_free>:

void    tNoise_free (tNoise* const ns)
{
    _tNoise* n = *ns;
   2a6f4:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)n, n->mempool);
   2a6f6:	6801      	ldr	r1, [r0, #0]
   2a6f8:	f7ff babe 	b.w	29c78 <mpool_free>

0002a6fc <tNoise_tick>:
}

float   tNoise_tick(tNoise* const ns)
{
   2a6fc:	b510      	push	{r4, lr}
    _tNoise* n = *ns;
   2a6fe:	6804      	ldr	r4, [r0, #0]
    
    float rand = (n->rand() * 2.0f) - 1.0f;
   2a700:	6963      	ldr	r3, [r4, #20]
   2a702:	4798      	blx	r3
   2a704:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
   2a708:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
    
    if (n->type == PinkNoise)
   2a70c:	7923      	ldrb	r3, [r4, #4]
   2a70e:	2b01      	cmp	r3, #1
    float rand = (n->rand() * 2.0f) - 1.0f;
   2a710:	eee0 7a07 	vfma.f32	s15, s0, s14
   2a714:	eeb0 0a67 	vmov.f32	s0, s15
    if (n->type == PinkNoise)
   2a718:	d000      	beq.n	2a71c <tNoise_tick+0x20>
    }
    else // WhiteNoise
    {
        return rand;
    }
}
   2a71a:	bd10      	pop	{r4, pc}
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2a71c:	eddf 7a18 	vldr	s15, [pc, #96]	; 2a780 <tNoise_tick+0x84>
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2a720:	eddf 6a18 	vldr	s13, [pc, #96]	; 2a784 <tNoise_tick+0x88>
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2a724:	ee60 7a27 	vmul.f32	s15, s0, s15
   2a728:	ed94 5a02 	vldr	s10, [r4, #8]
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2a72c:	ee60 6a26 	vmul.f32	s13, s0, s13
   2a730:	edd4 5a03 	vldr	s11, [r4, #12]
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2a734:	ed9f 7a14 	vldr	s14, [pc, #80]	; 2a788 <tNoise_tick+0x8c>
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2a738:	ed9f 6a14 	vldr	s12, [pc, #80]	; 2a78c <tNoise_tick+0x90>
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2a73c:	eee5 7a07 	vfma.f32	s15, s10, s14
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2a740:	ed9f 7a13 	vldr	s14, [pc, #76]	; 2a790 <tNoise_tick+0x94>
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2a744:	eee5 6a86 	vfma.f32	s13, s11, s12
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2a748:	edd4 4a04 	vldr	s9, [r4, #16]
   2a74c:	ee20 7a07 	vmul.f32	s14, s0, s14
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2a750:	eddf 5a10 	vldr	s11, [pc, #64]	; 2a794 <tNoise_tick+0x98>
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2a754:	ed9f 5a10 	vldr	s10, [pc, #64]	; 2a798 <tNoise_tick+0x9c>
        return (tmp * 0.05f);
   2a758:	ed9f 6a10 	vldr	s12, [pc, #64]	; 2a79c <tNoise_tick+0xa0>
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2a75c:	eea4 7a85 	vfma.f32	s14, s9, s10
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2a760:	edc4 7a02 	vstr	s15, [r4, #8]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2a764:	ee77 7aa6 	vadd.f32	s15, s15, s13
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2a768:	edc4 6a03 	vstr	s13, [r4, #12]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2a76c:	eee0 7a25 	vfma.f32	s15, s0, s11
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2a770:	ed84 7a04 	vstr	s14, [r4, #16]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2a774:	ee37 0a87 	vadd.f32	s0, s15, s14
        return (tmp * 0.05f);
   2a778:	ee20 0a06 	vmul.f32	s0, s0, s12
}
   2a77c:	bd10      	pop	{r4, pc}
   2a77e:	bf00      	nop
   2a780:	3dcad8a1 	.word	0x3dcad8a1
   2a784:	3e97d0ff 	.word	0x3e97d0ff
   2a788:	3f7f65fe 	.word	0x3f7f65fe
   2a78c:	3f76872b 	.word	0x3f76872b
   2a790:	3f86be97 	.word	0x3f86be97
   2a794:	3e3d3c36 	.word	0x3e3d3c36
   2a798:	3f11eb85 	.word	0x3f11eb85
   2a79c:	3d4ccccd 	.word	0x3d4ccccd

0002a7a0 <tComplexLivingString_initToPool>:
}

void    tComplexLivingString_initToPool    (tComplexLivingString* const pl, float freq, float pickPos, float prepPos, float prepIndex,
                                     float dampFreq, float decay, float targetLev, float levSmoothFactor,
                                     float levStrength, int levMode, tMempool* const mp)
{
   2a7a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a7a4:	ed2d 8b0c 	vpush	{d8-d13}
   2a7a8:	b083      	sub	sp, #12
    _tMempool* m = *mp;
   2a7aa:	f8d2 8000 	ldr.w	r8, [r2]
{
   2a7ae:	4606      	mov	r6, r0
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
   2a7b0:	2070      	movs	r0, #112	; 0x70
{
   2a7b2:	9100      	str	r1, [sp, #0]
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
   2a7b4:	4641      	mov	r1, r8
{
   2a7b6:	eef0 8a42 	vmov.f32	s17, s4
   2a7ba:	4615      	mov	r5, r2
   2a7bc:	eef0 9a41 	vmov.f32	s19, s2
    p->mempool = m;

    p->curr=0.0f;
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a7c0:	4f86      	ldr	r7, [pc, #536]	; (2a9dc <tComplexLivingString_initToPool+0x23c>)
{
   2a7c2:	eeb0 ba43 	vmov.f32	s22, s6
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a7c6:	ed9f aa86 	vldr	s20, [pc, #536]	; 2a9e0 <tComplexLivingString_initToPool+0x240>
{
   2a7ca:	eef0 ba63 	vmov.f32	s23, s7
    p->curr=0.0f;
   2a7ce:	eddf ca85 	vldr	s25, [pc, #532]	; 2a9e4 <tComplexLivingString_initToPool+0x244>
{
   2a7d2:	eeb0 ca44 	vmov.f32	s24, s8
   2a7d6:	eeb0 da61 	vmov.f32	s26, s3
   2a7da:	eef0 da62 	vmov.f32	s27, s5
   2a7de:	eef0 aa40 	vmov.f32	s21, s0
   2a7e2:	eeb0 9a60 	vmov.f32	s18, s1
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
   2a7e6:	f7ff f99f 	bl	29b28 <mpool_alloc>
   2a7ea:	4604      	mov	r4, r0
   2a7ec:	6030      	str	r0, [r6, #0]
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a7ee:	4629      	mov	r1, r5
   2a7f0:	eef0 0a4a 	vmov.f32	s1, s20
    p->mempool = m;
   2a7f4:	f8c4 8000 	str.w	r8, [r4]
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a7f8:	3064      	adds	r0, #100	; 0x64
   2a7fa:	ed97 0a00 	vldr	s0, [r7]
   2a7fe:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
    p->curr=0.0f;
   2a802:	edc4 ca0a 	vstr	s25, [r4, #40]	; 0x28
    tComplexLivingString_setPickPos(pl, pickPos);
    tComplexLivingString_setPrepPos(pl, prepPos);

    p->prepPos=prepPos;
    p->pickPos=pickPos;
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2a806:	f104 0b2c 	add.w	fp, r4, #44	; 0x2c
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a80a:	ee80 0a2a 	vdiv.f32	s0, s0, s21
    tLinearDelay_initToPool(&p->delMF,p->waveLengthInSamples, 2400, mp);
   2a80e:	f104 0a34 	add.w	sl, r4, #52	; 0x34
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a812:	f7fd fab9 	bl	27d88 <tExpSmooth_initToPool>
void     tComplexLivingString_setFreq(tComplexLivingString* const pl, float freq)
{    // NOTE: It is faster to set wavelength in samples directly
    _tComplexLivingString* p = *pl;
    if (freq<20.0f) freq=20.0f;
    else if (freq>10000.0f) freq=10000.0f;
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2a816:	ed97 7a00 	vldr	s14, [r7]
   2a81a:	eddf 7a73 	vldr	s15, [pc, #460]	; 2a9e8 <tComplexLivingString_initToPool+0x248>
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
   2a81e:	f104 0240 	add.w	r2, r4, #64	; 0x40
    _tComplexLivingString* p = *pl;
   2a822:	6833      	ldr	r3, [r6, #0]
    tLinearDelay_initToPool(&p->delUF,p->waveLengthInSamples, 2400, mp);
   2a824:	f104 0930 	add.w	r9, r4, #48	; 0x30
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2a828:	feca 7ae7 	vminnm.f32	s15, s21, s15
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
   2a82c:	9201      	str	r2, [sp, #4]
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2a82e:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2a832:	f103 0064 	add.w	r0, r3, #100	; 0x64
    tLinearDelay_initToPool(&p->delUB,p->waveLengthInSamples, 2400, mp);
   2a836:	f104 083c 	add.w	r8, r4, #60	; 0x3c
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
   2a83a:	f104 0738 	add.w	r7, r4, #56	; 0x38
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2a83e:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
   2a842:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2a846:	ed83 0a02 	vstr	s0, [r3, #8]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2a84a:	f7fd fad9 	bl	27e00 <tExpSmooth_setDest>
    tExpSmooth_initToPool(&p->pickPosSmooth, pickPos, 0.01f, mp); // smoother for pick position
   2a84e:	4629      	mov	r1, r5
   2a850:	eef0 0a4a 	vmov.f32	s1, s20
   2a854:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2a858:	eeb0 0a49 	vmov.f32	s0, s18
    p->freq = freq;
   2a85c:	edc4 aa01 	vstr	s21, [r4, #4]
    tExpSmooth_initToPool(&p->pickPosSmooth, pickPos, 0.01f, mp); // smoother for pick position
   2a860:	f7fd fa92 	bl	27d88 <tExpSmooth_initToPool>
    tExpSmooth_initToPool(&p->prepPosSmooth, prepPos, 0.01f, mp); // smoother for pick position
   2a864:	eef0 0a4a 	vmov.f32	s1, s20
   2a868:	4629      	mov	r1, r5
   2a86a:	eeb0 0a69 	vmov.f32	s0, s19
   2a86e:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2a872:	f7fd fa89 	bl	27d88 <tExpSmooth_initToPool>
   2a876:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
}

void     tComplexLivingString_setPickPos(tComplexLivingString* const pl, float pickPos)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
   2a87a:	6833      	ldr	r3, [r6, #0]
   2a87c:	fe89 0a40 	vminnm.f32	s0, s18, s0
    if (pickPos<0.5f) pickPos=0.5f;
    else if (pickPos>1.f) pickPos=1.f;
    p->pickPos = pickPos;
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2a880:	f103 0068 	add.w	r0, r3, #104	; 0x68
   2a884:	fe80 0a08 	vmaxnm.f32	s0, s0, s16
    p->pickPos = pickPos;
   2a888:	ed83 0a03 	vstr	s0, [r3, #12]
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2a88c:	f7fd fab8 	bl	27e00 <tExpSmooth_setDest>
}

void     tComplexLivingString_setPrepPos(tComplexLivingString* const pl, float prepPos)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
   2a890:	6833      	ldr	r3, [r6, #0]
   2a892:	fe89 0ac8 	vminnm.f32	s0, s19, s16
   2a896:	fe80 0a2c 	vmaxnm.f32	s0, s0, s25
    if (prepPos<0.f) prepPos=0.f;
    else if (prepPos>0.5f) prepPos=0.5f;
    p->prepPos = prepPos;
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2a89a:	f103 006c 	add.w	r0, r3, #108	; 0x6c
    p->prepPos = prepPos;
   2a89e:	ed83 0a04 	vstr	s0, [r3, #16]
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2a8a2:	f7fd faad 	bl	27e00 <tExpSmooth_setDest>
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2a8a6:	4658      	mov	r0, fp
   2a8a8:	462a      	mov	r2, r5
   2a8aa:	ed94 0a02 	vldr	s0, [r4, #8]
    p->prepPos=prepPos;
   2a8ae:	edc4 9a04 	vstr	s19, [r4, #16]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2a8b2:	f44f 6116 	mov.w	r1, #2400	; 0x960
    p->pickPos=pickPos;
   2a8b6:	ed84 9a03 	vstr	s18, [r4, #12]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2a8ba:	f7fa f9f9 	bl	24cb0 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delMF,p->waveLengthInSamples, 2400, mp);
   2a8be:	4650      	mov	r0, sl
   2a8c0:	462a      	mov	r2, r5
   2a8c2:	ed94 0a02 	vldr	s0, [r4, #8]
   2a8c6:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2a8ca:	f7fa f9f1 	bl	24cb0 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delUF,p->waveLengthInSamples, 2400, mp);
   2a8ce:	4648      	mov	r0, r9
   2a8d0:	462a      	mov	r2, r5
   2a8d2:	ed94 0a02 	vldr	s0, [r4, #8]
   2a8d6:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2a8da:	f7fa f9e9 	bl	24cb0 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delUB,p->waveLengthInSamples, 2400, mp);
   2a8de:	4640      	mov	r0, r8
   2a8e0:	462a      	mov	r2, r5
   2a8e2:	ed94 0a02 	vldr	s0, [r4, #8]
   2a8e6:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2a8ea:	f7fa f9e1 	bl	24cb0 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
   2a8ee:	4638      	mov	r0, r7
   2a8f0:	462a      	mov	r2, r5
   2a8f2:	ed94 0a02 	vldr	s0, [r4, #8]
   2a8f6:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2a8fa:	f7fa f9d9 	bl	24cb0 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
   2a8fe:	9e01      	ldr	r6, [sp, #4]
   2a900:	462a      	mov	r2, r5
   2a902:	ed94 0a02 	vldr	s0, [r4, #8]
   2a906:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2a90a:	4630      	mov	r0, r6
   2a90c:	f7fa f9d0 	bl	24cb0 <tLinearDelay_initToPool>
    tLinearDelay_clear(&p->delLF);
   2a910:	4658      	mov	r0, fp
   2a912:	f7fa fa4f 	bl	24db4 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delMF);
   2a916:	4650      	mov	r0, sl
   2a918:	f7fa fa4c 	bl	24db4 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delUF);
   2a91c:	4648      	mov	r0, r9
   2a91e:	f7fa fa49 	bl	24db4 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delUB);
   2a922:	4640      	mov	r0, r8
   2a924:	f7fa fa46 	bl	24db4 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delMB);
   2a928:	4638      	mov	r0, r7
   2a92a:	f7fa fa43 	bl	24db4 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delLB);
   2a92e:	4630      	mov	r0, r6
   2a930:	f7fa fa40 	bl	24db4 <tLinearDelay_clear>
    tOnePole_initToPool(&p->bridgeFilter, dampFreq, mp);
   2a934:	4629      	mov	r1, r5
   2a936:	eeb0 0a68 	vmov.f32	s0, s17
   2a93a:	f104 0044 	add.w	r0, r4, #68	; 0x44
    p->dampFreq = dampFreq;
   2a93e:	edc4 8a07 	vstr	s17, [r4, #28]
    tOnePole_initToPool(&p->bridgeFilter, dampFreq, mp);
   2a942:	f7fd fb31 	bl	27fa8 <tOnePole_initToPool>
    tOnePole_initToPool(&p->nutFilter, dampFreq, mp);
   2a946:	4629      	mov	r1, r5
   2a948:	eeb0 0a68 	vmov.f32	s0, s17
   2a94c:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2a950:	f7fd fb2a 	bl	27fa8 <tOnePole_initToPool>
    tOnePole_initToPool(&p->prepFilterU, dampFreq, mp);
   2a954:	4629      	mov	r1, r5
   2a956:	eeb0 0a68 	vmov.f32	s0, s17
   2a95a:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2a95e:	f7fd fb23 	bl	27fa8 <tOnePole_initToPool>
    tOnePole_initToPool(&p->prepFilterL, dampFreq, mp);
   2a962:	4629      	mov	r1, r5
   2a964:	eeb0 0a68 	vmov.f32	s0, s17
   2a968:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2a96c:	f7fd fb1c 	bl	27fa8 <tOnePole_initToPool>
    tHighpass_initToPool(&p->DCblockerU,13, mp);
   2a970:	4629      	mov	r1, r5
   2a972:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2a976:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
   2a97a:	f7fd fd4f 	bl	2841c <tHighpass_initToPool>
    tHighpass_initToPool(&p->DCblockerL,13, mp);
   2a97e:	4629      	mov	r1, r5
   2a980:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2a984:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
   2a988:	f7fd fd48 	bl	2841c <tHighpass_initToPool>
    tFeedbackLeveler_initToPool(&p->fbLevU, targetLev, levSmoothFactor, levStrength, levMode, mp);
   2a98c:	462a      	mov	r2, r5
   2a98e:	9900      	ldr	r1, [sp, #0]
   2a990:	eeb0 1a4c 	vmov.f32	s2, s24
   2a994:	eef0 0a6b 	vmov.f32	s1, s23
   2a998:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2a99c:	eeb0 0a4b 	vmov.f32	s0, s22
    p->decay=decay;
   2a9a0:	edc4 da08 	vstr	s27, [r4, #32]
    p->prepIndex = prepIndex;
   2a9a4:	ed84 da06 	vstr	s26, [r4, #24]
    tFeedbackLeveler_initToPool(&p->fbLevU, targetLev, levSmoothFactor, levStrength, levMode, mp);
   2a9a8:	f7fb f812 	bl	259d0 <tFeedbackLeveler_initToPool>
    tFeedbackLeveler_initToPool(&p->fbLevL, targetLev, levSmoothFactor, levStrength, levMode, mp);
   2a9ac:	462a      	mov	r2, r5
   2a9ae:	9900      	ldr	r1, [sp, #0]
   2a9b0:	eeb0 1a4c 	vmov.f32	s2, s24
   2a9b4:	eef0 0a6b 	vmov.f32	s1, s23
   2a9b8:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2a9bc:	eeb0 0a4b 	vmov.f32	s0, s22
   2a9c0:	f7fb f806 	bl	259d0 <tFeedbackLeveler_initToPool>
    p->levMode=levMode;
   2a9c4:	eddd 7a00 	vldr	s15, [sp]
   2a9c8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2a9cc:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
}
   2a9d0:	b003      	add	sp, #12
   2a9d2:	ecbd 8b0c 	vpop	{d8-d13}
   2a9d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2a9da:	bf00      	nop
   2a9dc:	020fbd68 	.word	0x020fbd68
   2a9e0:	3c23d70a 	.word	0x3c23d70a
   2a9e4:	00000000 	.word	0x00000000
   2a9e8:	461c4000 	.word	0x461c4000

0002a9ec <tComplexLivingString_init>:
    tComplexLivingString_initToPool(pl, freq, pickPos, prepPos, prepIndex, dampFreq, decay, targetLev, levSmoothFactor, levStrength, levMode, &leaf.mempool);
   2a9ec:	4a01      	ldr	r2, [pc, #4]	; (2a9f4 <tComplexLivingString_init+0x8>)
   2a9ee:	f7ff bed7 	b.w	2a7a0 <tComplexLivingString_initToPool>
   2a9f2:	bf00      	nop
   2a9f4:	020fbd80 	.word	0x020fbd80

0002a9f8 <tComplexLivingString_free>:
{
   2a9f8:	b510      	push	{r4, lr}
    _tComplexLivingString* p = *pl;
   2a9fa:	6804      	ldr	r4, [r0, #0]
    tExpSmooth_free(&p->wlSmooth);
   2a9fc:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2aa00:	f7fd f9e8 	bl	27dd4 <tExpSmooth_free>
    tExpSmooth_free(&p->pickPosSmooth);
   2aa04:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2aa08:	f7fd f9e4 	bl	27dd4 <tExpSmooth_free>
    tExpSmooth_free(&p->prepPosSmooth);
   2aa0c:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2aa10:	f7fd f9e0 	bl	27dd4 <tExpSmooth_free>
    tLinearDelay_free(&p->delLF);
   2aa14:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   2aa18:	f7fa f9c0 	bl	24d9c <tLinearDelay_free>
    tLinearDelay_free(&p->delMF);
   2aa1c:	f104 0034 	add.w	r0, r4, #52	; 0x34
   2aa20:	f7fa f9bc 	bl	24d9c <tLinearDelay_free>
    tLinearDelay_free(&p->delUF);
   2aa24:	f104 0030 	add.w	r0, r4, #48	; 0x30
   2aa28:	f7fa f9b8 	bl	24d9c <tLinearDelay_free>
    tLinearDelay_free(&p->delUB);
   2aa2c:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2aa30:	f7fa f9b4 	bl	24d9c <tLinearDelay_free>
    tLinearDelay_free(&p->delMB);
   2aa34:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2aa38:	f7fa f9b0 	bl	24d9c <tLinearDelay_free>
    tLinearDelay_free(&p->delLB);
   2aa3c:	f104 0040 	add.w	r0, r4, #64	; 0x40
   2aa40:	f7fa f9ac 	bl	24d9c <tLinearDelay_free>
    tOnePole_free(&p->bridgeFilter);
   2aa44:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2aa48:	f7fd fae4 	bl	28014 <tOnePole_free>
    tOnePole_free(&p->nutFilter);
   2aa4c:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2aa50:	f7fd fae0 	bl	28014 <tOnePole_free>
    tOnePole_free(&p->prepFilterU);
   2aa54:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2aa58:	f7fd fadc 	bl	28014 <tOnePole_free>
    tOnePole_free(&p->prepFilterL);
   2aa5c:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2aa60:	f7fd fad8 	bl	28014 <tOnePole_free>
    tHighpass_free(&p->DCblockerU);
   2aa64:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2aa68:	f7fd fcf8 	bl	2845c <tHighpass_free>
    tHighpass_free(&p->DCblockerL);
   2aa6c:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2aa70:	f7fd fcf4 	bl	2845c <tHighpass_free>
    tFeedbackLeveler_free(&p->fbLevU);
   2aa74:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2aa78:	f7fa ffd2 	bl	25a20 <tFeedbackLeveler_free>
    tFeedbackLeveler_free(&p->fbLevL);
   2aa7c:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2aa80:	f7fa ffce 	bl	25a20 <tFeedbackLeveler_free>
    mpool_free((char*)p, p->mempool);
   2aa84:	6821      	ldr	r1, [r4, #0]
   2aa86:	4620      	mov	r0, r4
}
   2aa88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
   2aa8c:	f7ff b8f4 	b.w	29c78 <mpool_free>

0002aa90 <tComplexLivingString_setFreq>:
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2aa90:	4b09      	ldr	r3, [pc, #36]	; (2aab8 <tComplexLivingString_setFreq+0x28>)
   2aa92:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
   2aa96:	eddf 7a09 	vldr	s15, [pc, #36]	; 2aabc <tComplexLivingString_setFreq+0x2c>
   2aa9a:	ed93 7a00 	vldr	s14, [r3]
   2aa9e:	fec0 7a67 	vminnm.f32	s15, s0, s15
   2aaa2:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
   2aaa6:	ee87 0a27 	vdiv.f32	s0, s14, s15
    _tComplexLivingString* p = *pl;
   2aaaa:	6803      	ldr	r3, [r0, #0]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2aaac:	f103 0064 	add.w	r0, r3, #100	; 0x64
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2aab0:	ed83 0a02 	vstr	s0, [r3, #8]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2aab4:	f7fd b9a4 	b.w	27e00 <tExpSmooth_setDest>
   2aab8:	020fbd68 	.word	0x020fbd68
   2aabc:	461c4000 	.word	0x461c4000

0002aac0 <tComplexLivingString_setPickPos>:
{    // between 0 and 1
   2aac0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tComplexLivingString* p = *pl;
   2aac4:	6803      	ldr	r3, [r0, #0]
   2aac6:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2aaca:	f103 0068 	add.w	r0, r3, #104	; 0x68
   2aace:	fe80 0a67 	vminnm.f32	s0, s0, s15
   2aad2:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    p->pickPos = pickPos;
   2aad6:	ed83 0a03 	vstr	s0, [r3, #12]
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2aada:	f7fd b991 	b.w	27e00 <tExpSmooth_setDest>
   2aade:	bf00      	nop

0002aae0 <tComplexLivingString_setPrepPos>:
{    // between 0 and 1
   2aae0:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    _tComplexLivingString* p = *pl;
   2aae4:	6803      	ldr	r3, [r0, #0]
   2aae6:	ed9f 7a06 	vldr	s14, [pc, #24]	; 2ab00 <tComplexLivingString_setPrepPos+0x20>
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2aaea:	f103 006c 	add.w	r0, r3, #108	; 0x6c
   2aaee:	fe80 0a67 	vminnm.f32	s0, s0, s15
   2aaf2:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    p->prepPos = prepPos;
   2aaf6:	ed83 0a04 	vstr	s0, [r3, #16]
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2aafa:	f7fd b981 	b.w	27e00 <tExpSmooth_setDest>
   2aafe:	bf00      	nop
   2ab00:	00000000 	.word	0x00000000

0002ab04 <tComplexLivingString_setPrepIndex>:
}

void     tComplexLivingString_setPrepIndex(tComplexLivingString* const pl, float prepIndex)
{    // between 0 and 1
   2ab04:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tComplexLivingString* p = *pl;
   2ab08:	6803      	ldr	r3, [r0, #0]
    if (prepIndex<0.f) prepIndex=0.f;
    else if (prepIndex>1.f) prepIndex=1.f;
    p->prepIndex = prepIndex;
   2ab0a:	ed9f 7a04 	vldr	s14, [pc, #16]	; 2ab1c <tComplexLivingString_setPrepIndex+0x18>
   2ab0e:	fe80 0a67 	vminnm.f32	s0, s0, s15
   2ab12:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
   2ab16:	ed83 0a06 	vstr	s0, [r3, #24]
}
   2ab1a:	4770      	bx	lr
   2ab1c:	00000000 	.word	0x00000000

0002ab20 <tComplexLivingString_setDampFreq>:

void     tComplexLivingString_setDampFreq(tComplexLivingString* const pl, float dampFreq)
{
   2ab20:	b510      	push	{r4, lr}
   2ab22:	ed2d 8b02 	vpush	{d8}
   2ab26:	eeb0 8a40 	vmov.f32	s16, s0
    _tComplexLivingString* p = *pl;
   2ab2a:	6804      	ldr	r4, [r0, #0]
    tOnePole_setFreq(&p->bridgeFilter, dampFreq);
   2ab2c:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2ab30:	f7fd fa74 	bl	2801c <tOnePole_setFreq>
    tOnePole_setFreq(&p->nutFilter, dampFreq);
   2ab34:	eeb0 0a48 	vmov.f32	s0, s16
   2ab38:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2ab3c:	f7fd fa6e 	bl	2801c <tOnePole_setFreq>
    tOnePole_setFreq(&p->prepFilterU, dampFreq);
   2ab40:	eeb0 0a48 	vmov.f32	s0, s16
   2ab44:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2ab48:	f7fd fa68 	bl	2801c <tOnePole_setFreq>
    tOnePole_setFreq(&p->prepFilterL, dampFreq);
   2ab4c:	eeb0 0a48 	vmov.f32	s0, s16
   2ab50:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
   2ab54:	ecbd 8b02 	vpop	{d8}
   2ab58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&p->prepFilterL, dampFreq);
   2ab5c:	f7fd ba5e 	b.w	2801c <tOnePole_setFreq>

0002ab60 <tComplexLivingString_setDecay>:

void     tComplexLivingString_setDecay(tComplexLivingString* const pl, float decay)
{
    _tComplexLivingString* p = *pl;
   2ab60:	6803      	ldr	r3, [r0, #0]
    p->decay=decay;
   2ab62:	ed83 0a08 	vstr	s0, [r3, #32]
}
   2ab66:	4770      	bx	lr

0002ab68 <tComplexLivingString_setTargetLev>:

void     tComplexLivingString_setTargetLev(tComplexLivingString* const pl, float targetLev)
{
   2ab68:	b510      	push	{r4, lr}
   2ab6a:	ed2d 8b02 	vpush	{d8}
   2ab6e:	eeb0 8a40 	vmov.f32	s16, s0
    _tComplexLivingString* p = *pl;
   2ab72:	6804      	ldr	r4, [r0, #0]
    tFeedbackLeveler_setTargetLevel(&p->fbLevU, targetLev);
   2ab74:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2ab78:	f7fa ff8a 	bl	25a90 <tFeedbackLeveler_setTargetLevel>
    tFeedbackLeveler_setTargetLevel(&p->fbLevL, targetLev);
   2ab7c:	eeb0 0a48 	vmov.f32	s0, s16
   2ab80:	f104 0060 	add.w	r0, r4, #96	; 0x60
}
   2ab84:	ecbd 8b02 	vpop	{d8}
   2ab88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tFeedbackLeveler_setTargetLevel(&p->fbLevL, targetLev);
   2ab8c:	f7fa bf80 	b.w	25a90 <tFeedbackLeveler_setTargetLevel>

0002ab90 <tComplexLivingString_setLevMode>:
    tFeedbackLeveler_setStrength(&p->fbLevU, levStrength);
    tFeedbackLeveler_setStrength(&p->fbLevL, levStrength);
}

void     tComplexLivingString_setLevMode(tComplexLivingString* const pl, int levMode)
{
   2ab90:	b510      	push	{r4, lr}
    _tComplexLivingString* p = *pl;
   2ab92:	6804      	ldr	r4, [r0, #0]
{
   2ab94:	b082      	sub	sp, #8
    tFeedbackLeveler_setMode(&p->fbLevU, levMode);
   2ab96:	f104 005c 	add.w	r0, r4, #92	; 0x5c
{
   2ab9a:	9101      	str	r1, [sp, #4]
    tFeedbackLeveler_setMode(&p->fbLevU, levMode);
   2ab9c:	f7fa ff4c 	bl	25a38 <tFeedbackLeveler_setMode>
    tFeedbackLeveler_setMode(&p->fbLevL, levMode);
   2aba0:	9901      	ldr	r1, [sp, #4]
   2aba2:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2aba6:	f7fa ff47 	bl	25a38 <tFeedbackLeveler_setMode>
    p->levMode=levMode;
   2abaa:	eddd 7a01 	vldr	s15, [sp, #4]
   2abae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2abb2:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
}
   2abb6:	b002      	add	sp, #8
   2abb8:	bd10      	pop	{r4, pc}
   2abba:	bf00      	nop

0002abbc <tComplexLivingString_tick>:

float   tComplexLivingString_tick(tComplexLivingString* const pl, float input)
{
   2abbc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2abc0:	ed2d 8b08 	vpush	{d8-d11}
    _tComplexLivingString* p = *pl;
   2abc4:	6804      	ldr	r4, [r0, #0]
{
   2abc6:	eef0 8a40 	vmov.f32	s17, s0

    // from pickPos upwards=forwards
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2abca:	f104 0a2c 	add.w	sl, r4, #44	; 0x2c
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2abce:	f104 0834 	add.w	r8, r4, #52	; 0x34
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2abd2:	f104 0630 	add.w	r6, r4, #48	; 0x30
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2abd6:	f104 053c 	add.w	r5, r4, #60	; 0x3c
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2abda:	4650      	mov	r0, sl
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2abdc:	f104 0738 	add.w	r7, r4, #56	; 0x38
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2abe0:	f7fa f944 	bl	24e6c <tLinearDelay_tickOut>
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2abe4:	4640      	mov	r0, r8
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2abe6:	eeb0 9a40 	vmov.f32	s18, s0
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2abea:	f7fa f93f 	bl	24e6c <tLinearDelay_tickOut>
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2abee:	4630      	mov	r0, r6
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2abf0:	f104 0940 	add.w	r9, r4, #64	; 0x40
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2abf4:	eef0 aa40 	vmov.f32	s21, s0
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2abf8:	f7fa f938 	bl	24e6c <tLinearDelay_tickOut>
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2abfc:	4628      	mov	r0, r5
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2abfe:	eef0 9a40 	vmov.f32	s19, s0
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2ac02:	f7fa f933 	bl	24e6c <tLinearDelay_tickOut>
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2ac06:	4638      	mov	r0, r7
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2ac08:	eeb0 aa40 	vmov.f32	s20, s0
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2ac0c:	f7fa f92e 	bl	24e6c <tLinearDelay_tickOut>
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2ac10:	4648      	mov	r0, r9
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2ac12:	eef0 ba40 	vmov.f32	s23, s0
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2ac16:	f7fa f929 	bl	24e6c <tLinearDelay_tickOut>

    // into upper part of string, from bridge, going backwards
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
   2ac1a:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2ac1e:	eeb0 ba40 	vmov.f32	s22, s0
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
   2ac22:	f104 0b5c 	add.w	fp, r4, #92	; 0x5c
   2ac26:	eef5 7a40 	vcmp.f32	s15, #0.0
   2ac2a:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2ac2e:	eeb0 0a69 	vmov.f32	s0, s19
   2ac32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ac36:	bf14      	ite	ne
   2ac38:	eeb7 8a00 	vmovne.f32	s16, #112	; 0x3f800000  1.0
   2ac3c:	ed94 8a08 	vldreq	s16, [r4, #32]
   2ac40:	f7fd fa08 	bl	28054 <tOnePole_tick>
   2ac44:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2ac48:	f7fd fc1c 	bl	28484 <tHighpass_tick>
   2ac4c:	4658      	mov	r0, fp
   2ac4e:	ee20 0a08 	vmul.f32	s0, s0, s16
    float fromLowerPrep=-tOnePole_tick(&p->prepFilterL, fromLF);
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
    tLinearDelay_tickIn(&p->delLB, intoLower);

    // into lower part of string, from nut, going forwards toward prep position
    float fromNut=-tFeedbackLeveler_tick(&p->fbLevL, (p->levMode==0?p->decay:1.0f)*tHighpass_tick(&p->DCblockerL, tOnePole_tick(&p->nutFilter, fromLB)));
   2ac52:	f104 0b60 	add.w	fp, r4, #96	; 0x60
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
   2ac56:	f7fa fef3 	bl	25a40 <tFeedbackLeveler_tick>
   2ac5a:	eef1 9a40 	vneg.f32	s19, s0
    tLinearDelay_tickIn(&p->delUB, fromBridge);
   2ac5e:	4628      	mov	r0, r5
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
   2ac60:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    tLinearDelay_tickIn(&p->delUB, fromBridge);
   2ac64:	eeb0 0a69 	vmov.f32	s0, s19
   2ac68:	f7fa f8ec 	bl	24e44 <tLinearDelay_tickIn>
    tLinearDelay_tickIn(&p->delMB, fromUB+input);
   2ac6c:	ee3a 0a28 	vadd.f32	s0, s20, s17
   2ac70:	4638      	mov	r0, r7
   2ac72:	f7fa f8e7 	bl	24e44 <tLinearDelay_tickIn>
    float fromLowerPrep=-tOnePole_tick(&p->prepFilterL, fromLF);
   2ac76:	eeb0 0a49 	vmov.f32	s0, s18
   2ac7a:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2ac7e:	f7fd f9e9 	bl	28054 <tOnePole_tick>
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
   2ac82:	ed94 7a06 	vldr	s14, [r4, #24]
    tLinearDelay_tickIn(&p->delLB, intoLower);
   2ac86:	4648      	mov	r0, r9
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
   2ac88:	ee78 7a47 	vsub.f32	s15, s16, s14
   2ac8c:	ee67 7aab 	vmul.f32	s15, s15, s23
    tLinearDelay_tickIn(&p->delLB, intoLower);
   2ac90:	eee0 7a47 	vfms.f32	s15, s0, s14
   2ac94:	eeb0 0a67 	vmov.f32	s0, s15
   2ac98:	f7fa f8d4 	bl	24e44 <tLinearDelay_tickIn>
    float fromNut=-tFeedbackLeveler_tick(&p->fbLevL, (p->levMode==0?p->decay:1.0f)*tHighpass_tick(&p->DCblockerL, tOnePole_tick(&p->nutFilter, fromLB)));
   2ac9c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2aca0:	eeb0 0a4b 	vmov.f32	s0, s22
   2aca4:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2aca8:	eef5 7a40 	vcmp.f32	s15, #0.0
   2acac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2acb0:	bf08      	it	eq
   2acb2:	ed94 8a08 	vldreq	s16, [r4, #32]
   2acb6:	f7fd f9cd 	bl	28054 <tOnePole_tick>
   2acba:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2acbe:	f7fd fbe1 	bl	28484 <tHighpass_tick>
   2acc2:	4658      	mov	r0, fp
   2acc4:	ee20 0a08 	vmul.f32	s0, s0, s16
   2acc8:	f7fa feba 	bl	25a40 <tFeedbackLeveler_tick>
    tLinearDelay_tickIn(&p->delLF, fromNut);
   2accc:	4650      	mov	r0, sl
   2acce:	eeb1 0a40 	vneg.f32	s0, s0
   2acd2:	f7fa f8b7 	bl	24e44 <tLinearDelay_tickIn>

    // into middle part of string, from prep going toward pick position
    float fromUpperPrep=-tOnePole_tick(&p->prepFilterU, fromUB);
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
   2acd6:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    float fromUpperPrep=-tOnePole_tick(&p->prepFilterU, fromUB);
   2acda:	eeb0 0a4a 	vmov.f32	s0, s20
   2acde:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2ace2:	f7fd f9b7 	bl	28054 <tOnePole_tick>
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
   2ace6:	edd4 7a06 	vldr	s15, [r4, #24]

    //pick position, take input and add it into the waveguide, going to come out of middle segment
    tLinearDelay_tickIn(&p->delMF, intoMiddle + input);
   2acea:	4640      	mov	r0, r8
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
   2acec:	ee38 7a67 	vsub.f32	s14, s16, s15
    tLinearDelay_tickIn(&p->delMF, intoMiddle + input);
   2acf0:	eee7 8a09 	vfma.f32	s17, s14, s18
   2acf4:	eee0 8a67 	vfms.f32	s17, s0, s15
   2acf8:	eeb0 0a68 	vmov.f32	s0, s17
   2acfc:	f7fa f8a2 	bl	24e44 <tLinearDelay_tickIn>

    //take output of middle segment and put it into upper segment connecting to the bridge
    tLinearDelay_tickIn(&p->delUF, fromMF);
   2ad00:	eeb0 0a6a 	vmov.f32	s0, s21
   2ad04:	4630      	mov	r0, r6
   2ad06:	f7fa f89d 	bl	24e44 <tLinearDelay_tickIn>

    // update all delay lengths
    float pickP=tExpSmooth_tick(&p->pickPosSmooth);
   2ad0a:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2ad0e:	f7fd f881 	bl	27e14 <tExpSmooth_tick>
    float prepP=tExpSmooth_tick(&p->prepPosSmooth);
   2ad12:	f104 006c 	add.w	r0, r4, #108	; 0x6c
    float pickP=tExpSmooth_tick(&p->pickPosSmooth);
   2ad16:	eeb0 9a40 	vmov.f32	s18, s0
    float prepP=tExpSmooth_tick(&p->prepPosSmooth);
   2ad1a:	f7fd f87b 	bl	27e14 <tExpSmooth_tick>
   2ad1e:	eef0 8a40 	vmov.f32	s17, s0
    float wLen=tExpSmooth_tick(&p->wlSmooth);
   2ad22:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2ad26:	f7fd f875 	bl	27e14 <tExpSmooth_tick>
   2ad2a:	eef0 7a40 	vmov.f32	s15, s0

    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
    float lowLen = prepP*wLen; // the length from prep to nut
    float upLen = (1.0f-pickP)*wLen; // the length from pick to bridge
   2ad2e:	ee38 8a49 	vsub.f32	s16, s16, s18


    tLinearDelay_setDelay(&p->delLF, lowLen);
   2ad32:	4650      	mov	r0, sl
    float lowLen = prepP*wLen; // the length from prep to nut
   2ad34:	ee28 aa80 	vmul.f32	s20, s17, s0
    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
   2ad38:	ee79 8a68 	vsub.f32	s17, s18, s17
    float upLen = (1.0f-pickP)*wLen; // the length from pick to bridge
   2ad3c:	ee28 8a00 	vmul.f32	s16, s16, s0
    tLinearDelay_setDelay(&p->delLF, lowLen);
   2ad40:	eeb0 0a4a 	vmov.f32	s0, s20
    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
   2ad44:	ee68 8aa7 	vmul.f32	s17, s17, s15
    tLinearDelay_setDelay(&p->delLF, lowLen);
   2ad48:	f7fa f8ba 	bl	24ec0 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delLB, lowLen);
   2ad4c:	eeb0 0a4a 	vmov.f32	s0, s20
   2ad50:	4648      	mov	r0, r9
   2ad52:	f7fa f8b5 	bl	24ec0 <tLinearDelay_setDelay>

    tLinearDelay_setDelay(&p->delMF, midLen);
   2ad56:	4640      	mov	r0, r8
   2ad58:	eeb0 0a68 	vmov.f32	s0, s17
   2ad5c:	f7fa f8b0 	bl	24ec0 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delMB, midLen);
   2ad60:	eeb0 0a68 	vmov.f32	s0, s17
   2ad64:	4638      	mov	r0, r7
   2ad66:	f7fa f8ab 	bl	24ec0 <tLinearDelay_setDelay>

    tLinearDelay_setDelay(&p->delUF, upLen);
   2ad6a:	eeb0 0a48 	vmov.f32	s0, s16
   2ad6e:	4630      	mov	r0, r6
   2ad70:	f7fa f8a6 	bl	24ec0 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delUB, upLen);
   2ad74:	eeb0 0a48 	vmov.f32	s0, s16
   2ad78:	4628      	mov	r0, r5
   2ad7a:	f7fa f8a1 	bl	24ec0 <tLinearDelay_setDelay>

    //update this to allow pickup position variation
    p->curr = fromBridge;
    return p->curr;
}
   2ad7e:	eeb0 0a69 	vmov.f32	s0, s19
    p->curr = fromBridge;
   2ad82:	edc4 9a0a 	vstr	s19, [r4, #40]	; 0x28
}
   2ad86:	ecbd 8b08 	vpop	{d8-d11}
   2ad8a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ad8e:	bf00      	nop

0002ad90 <tNReverb_initToPool>:
{
    tNReverb_initToPool(rev, t60, &leaf.mempool);
}

void    tNReverb_initToPool     (tNReverb* const rev, float t60, tMempool* const mp)
{
   2ad90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ad94:	ed2d 8b06 	vpush	{d8-d10}
   2ad98:	eeb0 aa40 	vmov.f32	s20, s0
   2ad9c:	b095      	sub	sp, #84	; 0x54
    _tMempool* m = *mp;
   2ad9e:	680c      	ldr	r4, [r1, #0]
{
   2ada0:	4605      	mov	r5, r0
   2ada2:	9101      	str	r1, [sp, #4]
   2ada4:	9002      	str	r0, [sp, #8]
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
   2ada6:	4621      	mov	r1, r4
   2ada8:	2074      	movs	r0, #116	; 0x74
   2adaa:	f7fe febd 	bl	29b28 <mpool_alloc>
    r->mempool = m;
    
    if (t60 <= 0.0f) t60 = 0.001f;
   2adae:	eeb5 aac0 	vcmpe.f32	s20, #0.0
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
   2adb2:	6028      	str	r0, [r5, #0]
   2adb4:	4682      	mov	sl, r0
    r->mempool = m;
   2adb6:	6004      	str	r4, [r0, #0]
    if (t60 <= 0.0f) t60 = 0.001f;
   2adb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2adbc:	f240 80c6 	bls.w	2af4c <tNReverb_initToPool+0x1bc>
   2adc0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2adc4:	ee87 8a8a 	vdiv.f32	s16, s15, s20
    
    r->inv_441 = 1.0f/44100.0f;
    
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
    double scaler = leaf.sampleRate / 25641.0f;
   2adc8:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 2af80 <tNReverb_initToPool+0x1f0>
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2adcc:	af05      	add	r7, sp, #20
   2adce:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 2af84 <tNReverb_initToPool+0x1f4>
   2add2:	ac04      	add	r4, sp, #16
    double scaler = leaf.sampleRate / 25641.0f;
   2add4:	ed9f 7a64 	vldr	s14, [pc, #400]	; 2af68 <tNReverb_initToPool+0x1d8>
   2add8:	f10d 0914 	add.w	r9, sp, #20
   2addc:	edd8 7a00 	vldr	s15, [r8]
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2ade0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    double scaler = leaf.sampleRate / 25641.0f;
   2ade4:	ee67 7a87 	vmul.f32	s15, s15, s14
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2ade8:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   2adea:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   2adee:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2adf2:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   2adf4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   2adf8:	ee17 ba90 	vmov	fp, s15
   2adfc:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    r->inv_441 = 1.0f/44100.0f;
   2adfe:	4b5b      	ldr	r3, [pc, #364]	; (2af6c <tNReverb_initToPool+0x1dc>)
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2ae00:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
    r->inv_441 = 1.0f/44100.0f;
   2ae04:	f8ca 3010 	str.w	r3, [sl, #16]
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2ae08:	e887 0007 	stmia.w	r7, {r0, r1, r2}
    
    int delay, i;
    
    for (i=0; i < 15; i++)
    {
        delay = (int) scaler * lengths[i];
   2ae0c:	f854 5f04 	ldr.w	r5, [r4, #4]!
   2ae10:	fb05 f50b 	mul.w	r5, r5, fp
        if ( (delay & 1) == 0)
   2ae14:	07eb      	lsls	r3, r5, #31
            delay++;
   2ae16:	bf58      	it	pl
   2ae18:	3501      	addpl	r5, #1
   2ae1a:	462e      	mov	r6, r5
   2ae1c:	17ef      	asrs	r7, r5, #31
   2ae1e:	e000      	b.n	2ae22 <tNReverb_initToPool+0x92>
        while ( !LEAF_isPrime(delay) )
            delay += 2;
   2ae20:	3502      	adds	r5, #2
        while ( !LEAF_isPrime(delay) )
   2ae22:	4630      	mov	r0, r6
   2ae24:	3602      	adds	r6, #2
   2ae26:	4639      	mov	r1, r7
   2ae28:	f147 0700 	adc.w	r7, r7, #0
   2ae2c:	f7fe fc9c 	bl	29768 <LEAF_isPrime>
   2ae30:	2800      	cmp	r0, #0
   2ae32:	d0f5      	beq.n	2ae20 <tNReverb_initToPool+0x90>
    for (i=0; i < 15; i++)
   2ae34:	ab13      	add	r3, sp, #76	; 0x4c
        lengths[i] = delay;
   2ae36:	6025      	str	r5, [r4, #0]
    for (i=0; i < 15; i++)
   2ae38:	429c      	cmp	r4, r3
   2ae3a:	d1e7      	bne.n	2ae0c <tNReverb_initToPool+0x7c>
   2ae3c:	f10a 0750 	add.w	r7, sl, #80	; 0x50
   2ae40:	f10a 0668 	add.w	r6, sl, #104	; 0x68
   2ae44:	f8dd b004 	ldr.w	fp, [sp, #4]
   2ae48:	9403      	str	r4, [sp, #12]
    }
    
    for ( i=0; i<6; i++ )
    {
        tLinearDelay_initToPool(&r->combDelays[i], lengths[i], lengths[i] * 2.0f, mp);
   2ae4a:	f859 5b04 	ldr.w	r5, [r9], #4
   2ae4e:	f1a7 041c 	sub.w	r4, r7, #28
   2ae52:	465a      	mov	r2, fp
   2ae54:	ee07 5a90 	vmov	s15, r5
   2ae58:	4620      	mov	r0, r4
        tLinearDelay_clear(&r->combDelays[i]);
        r->combCoeffs[i] = pow(10.0, (-3 * lengths[i] * leaf.invSampleRate / t60));
   2ae5a:	eba5 0585 	sub.w	r5, r5, r5, lsl #2
        tLinearDelay_initToPool(&r->combDelays[i], lengths[i], lengths[i] * 2.0f, mp);
   2ae5e:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   2ae62:	ee70 7a00 	vadd.f32	s15, s0, s0
   2ae66:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2ae6a:	ee17 1a90 	vmov	r1, s15
   2ae6e:	f7f9 ff1f 	bl	24cb0 <tLinearDelay_initToPool>
        tLinearDelay_clear(&r->combDelays[i]);
   2ae72:	4620      	mov	r0, r4
   2ae74:	f7f9 ff9e 	bl	24db4 <tLinearDelay_clear>
        r->combCoeffs[i] = pow(10.0, (-3 * lengths[i] * leaf.invSampleRate / t60));
   2ae78:	edd8 7a01 	vldr	s15, [r8, #4]
   2ae7c:	ee07 5a10 	vmov	s14, r5
   2ae80:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
   2ae84:	ee68 7a27 	vmul.f32	s15, s16, s15
   2ae88:	eeb8 1ac7 	vcvt.f32.s32	s2, s14
   2ae8c:	ee21 1a27 	vmul.f32	s2, s2, s15
   2ae90:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
   2ae94:	f002 fa28 	bl	2d2e8 <pow>
   2ae98:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2ae9c:	eca7 0a01 	vstmia	r7!, {s0}
    for ( i=0; i<6; i++ )
   2aea0:	42be      	cmp	r6, r7
   2aea2:	d1d2      	bne.n	2ae4a <tNReverb_initToPool+0xba>
   2aea4:	9c03      	ldr	r4, [sp, #12]
   2aea6:	af0b      	add	r7, sp, #44	; 0x2c
   2aea8:	f10a 0514 	add.w	r5, sl, #20
   2aeac:	9e01      	ldr	r6, [sp, #4]
    }
    
    for ( i=0; i<8; i++ )
    {
        tLinearDelay_initToPool(&r->allpassDelays[i], lengths[i+6], lengths[i+6] * 2.0f, mp);
   2aeae:	ecb7 0a01 	vldmia	r7!, {s0}
   2aeb2:	4628      	mov	r0, r5
   2aeb4:	4632      	mov	r2, r6
   2aeb6:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   2aeba:	ee70 7a00 	vadd.f32	s15, s0, s0
   2aebe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2aec2:	ee17 1a90 	vmov	r1, s15
   2aec6:	f7f9 fef3 	bl	24cb0 <tLinearDelay_initToPool>
        tLinearDelay_clear(&r->allpassDelays[i]);
   2aeca:	4628      	mov	r0, r5
   2aecc:	f7f9 ff72 	bl	24db4 <tLinearDelay_clear>
    for ( i=0; i<8; i++ )
   2aed0:	42bc      	cmp	r4, r7
   2aed2:	f105 0504 	add.w	r5, r5, #4
   2aed6:	d1ea      	bne.n	2aeae <tNReverb_initToPool+0x11e>

void    tNReverb_setT60(tNReverb* const rev, float t60)
{
    _tNReverb* r = *rev;
    
    if (t60 <= 0.0f)           t60 = 0.001f;
   2aed8:	eeb5 aac0 	vcmpe.f32	s20, #0.0
    _tNReverb* r = *rev;
   2aedc:	9b02      	ldr	r3, [sp, #8]
   2aede:	681b      	ldr	r3, [r3, #0]
    if (t60 <= 0.0f)           t60 = 0.001f;
   2aee0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2aee4:	d937      	bls.n	2af56 <tNReverb_initToPool+0x1c6>
   2aee6:	eeb7 7aca 	vcvt.f64.f32	d7, s20
   2aeea:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   2aeee:	ee86 9b07 	vdiv.f64	d9, d6, d7
   2aef2:	f103 0450 	add.w	r4, r3, #80	; 0x50
   2aef6:	f103 0568 	add.w	r5, r3, #104	; 0x68
    
    r->t60 = t60;
   2aefa:	ed83 aa02 	vstr	s20, [r3, #8]
    
    for (int i=0; i<6; i++)   r->combCoeffs[i] = pow(10.0, (-3.0 * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
   2aefe:	eeb8 8b08 	vmov.f64	d8, #136	; 0xc0400000 -3.0
   2af02:	f1a4 001c 	sub.w	r0, r4, #28
   2af06:	f7fa f81b 	bl	24f40 <tLinearDelay_getDelay>
   2af0a:	ed98 7a01 	vldr	s14, [r8, #4]
   2af0e:	eeb7 1ac0 	vcvt.f64.f32	d1, s0
   2af12:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   2af16:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
   2af1a:	ee27 7b08 	vmul.f64	d7, d7, d8
   2af1e:	ee27 7b09 	vmul.f64	d7, d7, d9
   2af22:	ee27 1b01 	vmul.f64	d1, d7, d1
   2af26:	f002 f9df 	bl	2d2e8 <pow>
   2af2a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2af2e:	eca4 0a01 	vstmia	r4!, {s0}
   2af32:	42a5      	cmp	r5, r4
   2af34:	d1e5      	bne.n	2af02 <tNReverb_initToPool+0x172>
    r->allpassCoeff = 0.7f;
   2af36:	4a0e      	ldr	r2, [pc, #56]	; (2af70 <tNReverb_initToPool+0x1e0>)
    r->mix = 0.3f;
   2af38:	4b0e      	ldr	r3, [pc, #56]	; (2af74 <tNReverb_initToPool+0x1e4>)
    r->allpassCoeff = 0.7f;
   2af3a:	f8ca 204c 	str.w	r2, [sl, #76]	; 0x4c
    r->mix = 0.3f;
   2af3e:	f8ca 3004 	str.w	r3, [sl, #4]
}
   2af42:	b015      	add	sp, #84	; 0x54
   2af44:	ecbd 8b06 	vpop	{d8-d10}
   2af48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2af4c:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 2af78 <tNReverb_initToPool+0x1e8>
    if (t60 <= 0.0f) t60 = 0.001f;
   2af50:	ed9f aa0a 	vldr	s20, [pc, #40]	; 2af7c <tNReverb_initToPool+0x1ec>
   2af54:	e738      	b.n	2adc8 <tNReverb_initToPool+0x38>
    if (t60 <= 0.0f)           t60 = 0.001f;
   2af56:	ed9f 9b02 	vldr	d9, [pc, #8]	; 2af60 <tNReverb_initToPool+0x1d0>
   2af5a:	ed9f aa08 	vldr	s20, [pc, #32]	; 2af7c <tNReverb_initToPool+0x1ec>
   2af5e:	e7c8      	b.n	2aef2 <tNReverb_initToPool+0x162>
   2af60:	e7190014 	.word	0xe7190014
   2af64:	408f3fff 	.word	0x408f3fff
   2af68:	382393f9 	.word	0x382393f9
   2af6c:	37be37c6 	.word	0x37be37c6
   2af70:	3f333333 	.word	0x3f333333
   2af74:	3e99999a 	.word	0x3e99999a
   2af78:	4479ffff 	.word	0x4479ffff
   2af7c:	3a83126f 	.word	0x3a83126f
   2af80:	020fbd68 	.word	0x020fbd68
   2af84:	000324a8 	.word	0x000324a8

0002af88 <tNReverb_init>:
    tNReverb_initToPool(rev, t60, &leaf.mempool);
   2af88:	4901      	ldr	r1, [pc, #4]	; (2af90 <tNReverb_init+0x8>)
   2af8a:	f7ff bf01 	b.w	2ad90 <tNReverb_initToPool>
   2af8e:	bf00      	nop
   2af90:	020fbd80 	.word	0x020fbd80

0002af94 <tNReverb_free>:
{
   2af94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tNReverb* r = *rev;
   2af96:	6807      	ldr	r7, [r0, #0]
   2af98:	f107 0534 	add.w	r5, r7, #52	; 0x34
   2af9c:	f107 064c 	add.w	r6, r7, #76	; 0x4c
   2afa0:	462c      	mov	r4, r5
        tLinearDelay_free(&r->combDelays[i]);
   2afa2:	4620      	mov	r0, r4
   2afa4:	3404      	adds	r4, #4
   2afa6:	f7f9 fef9 	bl	24d9c <tLinearDelay_free>
    for (int i = 0; i < 6; i++)
   2afaa:	42b4      	cmp	r4, r6
   2afac:	d1f9      	bne.n	2afa2 <tNReverb_free+0xe>
   2afae:	f107 0414 	add.w	r4, r7, #20
        tLinearDelay_free(&r->allpassDelays[i]);
   2afb2:	4620      	mov	r0, r4
   2afb4:	3404      	adds	r4, #4
   2afb6:	f7f9 fef1 	bl	24d9c <tLinearDelay_free>
    for (int i = 0; i < 8; i++)
   2afba:	42a5      	cmp	r5, r4
   2afbc:	d1f9      	bne.n	2afb2 <tNReverb_free+0x1e>
    mpool_free((char*)r, r->mempool);
   2afbe:	6839      	ldr	r1, [r7, #0]
   2afc0:	4638      	mov	r0, r7
}
   2afc2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
   2afc6:	f7fe be57 	b.w	29c78 <mpool_free>
   2afca:	bf00      	nop
   2afcc:	0000      	movs	r0, r0
	...

0002afd0 <tNReverb_setT60>:
    if (t60 <= 0.0f)           t60 = 0.001f;
   2afd0:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
   2afd4:	b570      	push	{r4, r5, r6, lr}
    if (t60 <= 0.0f)           t60 = 0.001f;
   2afd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
   2afda:	ed2d 8b04 	vpush	{d8-d9}
    _tNReverb* r = *rev;
   2afde:	6803      	ldr	r3, [r0, #0]
    if (t60 <= 0.0f)           t60 = 0.001f;
   2afe0:	d92b      	bls.n	2b03a <tNReverb_setT60+0x6a>
   2afe2:	eeb7 7ac0 	vcvt.f64.f32	d7, s0
   2afe6:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   2afea:	ee86 9b07 	vdiv.f64	d9, d6, d7
   2afee:	f103 0450 	add.w	r4, r3, #80	; 0x50
   2aff2:	f103 0668 	add.w	r6, r3, #104	; 0x68
   2aff6:	4d16      	ldr	r5, [pc, #88]	; (2b050 <tNReverb_setT60+0x80>)
    r->t60 = t60;
   2aff8:	ed83 0a02 	vstr	s0, [r3, #8]
    for (int i=0; i<6; i++)   r->combCoeffs[i] = pow(10.0, (-3.0 * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
   2affc:	eeb8 8b08 	vmov.f64	d8, #136	; 0xc0400000 -3.0
   2b000:	f1a4 001c 	sub.w	r0, r4, #28
   2b004:	f7f9 ff9c 	bl	24f40 <tLinearDelay_getDelay>
   2b008:	ed95 7a01 	vldr	s14, [r5, #4]
   2b00c:	eeb7 1ac0 	vcvt.f64.f32	d1, s0
   2b010:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   2b014:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
   2b018:	ee27 7b08 	vmul.f64	d7, d7, d8
   2b01c:	ee27 7b09 	vmul.f64	d7, d7, d9
   2b020:	ee27 1b01 	vmul.f64	d1, d7, d1
   2b024:	f002 f960 	bl	2d2e8 <pow>
   2b028:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2b02c:	eca4 0a01 	vstmia	r4!, {s0}
   2b030:	42b4      	cmp	r4, r6
   2b032:	d1e5      	bne.n	2b000 <tNReverb_setT60+0x30>
    
}
   2b034:	ecbd 8b04 	vpop	{d8-d9}
   2b038:	bd70      	pop	{r4, r5, r6, pc}
   2b03a:	ed9f 9b03 	vldr	d9, [pc, #12]	; 2b048 <tNReverb_setT60+0x78>
    if (t60 <= 0.0f)           t60 = 0.001f;
   2b03e:	ed9f 0a05 	vldr	s0, [pc, #20]	; 2b054 <tNReverb_setT60+0x84>
   2b042:	e7d4      	b.n	2afee <tNReverb_setT60+0x1e>
   2b044:	f3af 8000 	nop.w
   2b048:	e7190014 	.word	0xe7190014
   2b04c:	408f3fff 	.word	0x408f3fff
   2b050:	020fbd68 	.word	0x020fbd68
   2b054:	3a83126f 	.word	0x3a83126f

0002b058 <tNReverb_setMix>:

void    tNReverb_setMix(tNReverb* const rev, float mix)
{
    _tNReverb* r = *rev;
   2b058:	6803      	ldr	r3, [r0, #0]
    r->mix = mix;
   2b05a:	ed83 0a01 	vstr	s0, [r3, #4]
}
   2b05e:	4770      	bx	lr

0002b060 <tNReverb_tickStereo>:

    return out;
}

void   tNReverb_tickStereo(tNReverb* const rev, float input, float* output)
{
   2b060:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2b064:	ed2d 8b06 	vpush	{d8-d10}
    _tNReverb* r = *rev;
   2b068:	6805      	ldr	r5, [r0, #0]
{
   2b06a:	eeb0 9a40 	vmov.f32	s18, s0
   2b06e:	4688      	mov	r8, r1
    r->lastIn = input;

    float temp, temp0, temp1, temp2, temp3, out;
    int i;

    temp0 = 0.0;
   2b070:	ed9f 8a4c 	vldr	s16, [pc, #304]	; 2b1a4 <tNReverb_tickStereo+0x144>
   2b074:	f105 0450 	add.w	r4, r5, #80	; 0x50
   2b078:	f105 0768 	add.w	r7, r5, #104	; 0x68
    r->lastIn = input;
   2b07c:	ed85 0a1b 	vstr	s0, [r5, #108]	; 0x6c
   2b080:	f1a4 061c 	sub.w	r6, r4, #28
    for ( i=0; i<6; i++ )
    {
        temp = input + (r->combCoeffs[i] * tLinearDelay_getLastOut(&r->combDelays[i]));
   2b084:	ecf4 8a01 	vldmia	r4!, {s17}
   2b088:	4630      	mov	r0, r6
   2b08a:	f7f9 ff5d 	bl	24f48 <tLinearDelay_getLastOut>
        temp0 += tLinearDelay_tick(&r->combDelays[i],temp);
   2b08e:	eef0 7a49 	vmov.f32	s15, s18
   2b092:	4630      	mov	r0, r6
   2b094:	eee8 7a80 	vfma.f32	s15, s17, s0
   2b098:	eeb0 0a67 	vmov.f32	s0, s15
   2b09c:	f7f9 fe98 	bl	24dd0 <tLinearDelay_tick>
    for ( i=0; i<6; i++ )
   2b0a0:	42bc      	cmp	r4, r7
        temp0 += tLinearDelay_tick(&r->combDelays[i],temp);
   2b0a2:	ee38 8a00 	vadd.f32	s16, s16, s0
    for ( i=0; i<6; i++ )
   2b0a6:	d1eb      	bne.n	2b080 <tNReverb_tickStereo+0x20>
   2b0a8:	f105 0414 	add.w	r4, r5, #20
   2b0ac:	f105 0620 	add.w	r6, r5, #32
    }

    for ( i=0; i<3; i++ )
    {
        temp = tLinearDelay_getLastOut(&r->allpassDelays[i]);
   2b0b0:	4620      	mov	r0, r4
   2b0b2:	f7f9 ff49 	bl	24f48 <tLinearDelay_getLastOut>
        temp1 = r->allpassCoeff * temp;
        temp1 += temp0;
   2b0b6:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
        temp = tLinearDelay_getLastOut(&r->allpassDelays[i]);
   2b0ba:	eef0 8a40 	vmov.f32	s17, s0
        tLinearDelay_tick(&r->allpassDelays[i], temp1);
   2b0be:	4620      	mov	r0, r4
        temp1 += temp0;
   2b0c0:	eea7 8a80 	vfma.f32	s16, s15, s0
   2b0c4:	3404      	adds	r4, #4
        tLinearDelay_tick(&r->allpassDelays[i], temp1);
   2b0c6:	eeb0 0a48 	vmov.f32	s0, s16
   2b0ca:	f7f9 fe81 	bl	24dd0 <tLinearDelay_tick>
        temp0 = -(r->allpassCoeff * temp1) + temp;
   2b0ce:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    for ( i=0; i<3; i++ )
   2b0d2:	42a6      	cmp	r6, r4
        temp0 = -(r->allpassCoeff * temp1) + temp;
   2b0d4:	eee7 8ac8 	vfms.f32	s17, s15, s16
   2b0d8:	eeb0 8a68 	vmov.f32	s16, s17
    for ( i=0; i<3; i++ )
   2b0dc:	d1e8      	bne.n	2b0b0 <tNReverb_tickStereo+0x50>
    }

    // One-pole lowpass filter.
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2b0de:	eddf 7a32 	vldr	s15, [pc, #200]	; 2b1a8 <tNReverb_tickStereo+0x148>

    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
   2b0e2:	4630      	mov	r0, r6
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2b0e4:	ed95 7a1a 	vldr	s14, [r5, #104]	; 0x68
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
    temp1 = -(r->allpassCoeff * temp1) + temp;

    float drymix = ( 1.0f - r->mix ) * input;

    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2b0e8:	f105 0724 	add.w	r7, r5, #36	; 0x24
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2b0ec:	ee28 8aa7 	vmul.f32	s16, s17, s15
   2b0f0:	eddf 7a2e 	vldr	s15, [pc, #184]	; 2b1ac <tNReverb_tickStereo+0x14c>
    float drymix = ( 1.0f - r->mix ) * input;
   2b0f4:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
    out = output[0];


    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2b0f8:	f105 0428 	add.w	r4, r5, #40	; 0x28
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2b0fc:	eea7 8a27 	vfma.f32	s16, s14, s15
   2b100:	ed85 8a1a 	vstr	s16, [r5, #104]	; 0x68
    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
   2b104:	f7f9 ff20 	bl	24f48 <tLinearDelay_getLastOut>
    temp1 += r->lowpassState;
   2b108:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
   2b10c:	ed95 8a1a 	vldr	s16, [r5, #104]	; 0x68
    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
   2b110:	eef0 8a40 	vmov.f32	s17, s0
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
   2b114:	4630      	mov	r0, r6
    temp1 += r->lowpassState;
   2b116:	eea7 8a80 	vfma.f32	s16, s15, s0
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
   2b11a:	eeb0 0a48 	vmov.f32	s0, s16
   2b11e:	f7f9 fe57 	bl	24dd0 <tLinearDelay_tick>
    temp1 = -(r->allpassCoeff * temp1) + temp;
   2b122:	ed95 7a13 	vldr	s14, [r5, #76]	; 0x4c
    float drymix = ( 1.0f - r->mix ) * input;
   2b126:	edd5 7a01 	vldr	s15, [r5, #4]
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2b12a:	4638      	mov	r0, r7
    temp1 = -(r->allpassCoeff * temp1) + temp;
   2b12c:	eee7 8a48 	vfms.f32	s17, s14, s16
    float drymix = ( 1.0f - r->mix ) * input;
   2b130:	ee3a aa67 	vsub.f32	s20, s20, s15
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2b134:	f7f9 ff08 	bl	24f48 <tLinearDelay_getLastOut>
    temp2 += temp1;
   2b138:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2b13c:	eef0 9a40 	vmov.f32	s19, s0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
   2b140:	4638      	mov	r0, r7
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
   2b142:	eeea 9a09 	vfma.f32	s19, s20, s18
    temp2 += temp1;
   2b146:	eeb0 8a68 	vmov.f32	s16, s17
   2b14a:	eea7 8a80 	vfma.f32	s16, s15, s0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
   2b14e:	eeb0 0a48 	vmov.f32	s0, s16
   2b152:	f7f9 fe3d 	bl	24dd0 <tLinearDelay_tick>
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
   2b156:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2b15a:	4620      	mov	r0, r4
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
   2b15c:	eee7 9ac8 	vfms.f32	s19, s15, s16
   2b160:	edc8 9a00 	vstr	s19, [r8]
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2b164:	f7f9 fef0 	bl	24f48 <tLinearDelay_getLastOut>
    temp3 = r->allpassCoeff * temp;
    temp3 += temp1;
   2b168:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2b16c:	eeb0 8a40 	vmov.f32	s16, s0
    tLinearDelay_tick(&r->allpassDelays[5], temp3 );
   2b170:	4620      	mov	r0, r4
    temp3 += temp1;
   2b172:	eee7 8a80 	vfma.f32	s17, s15, s0
    output[1] = r->mix *( - ( r->allpassCoeff * temp3 ) + temp + drymix);
   2b176:	eeaa 8a09 	vfma.f32	s16, s20, s18
    tLinearDelay_tick(&r->allpassDelays[5], temp3 );
   2b17a:	eeb0 0a68 	vmov.f32	s0, s17
   2b17e:	f7f9 fe27 	bl	24dd0 <tLinearDelay_tick>
    output[1] = r->mix *( - ( r->allpassCoeff * temp3 ) + temp + drymix);
   2b182:	ed95 7a13 	vldr	s14, [r5, #76]	; 0x4c
   2b186:	edd5 7a01 	vldr	s15, [r5, #4]
   2b18a:	eea7 8a68 	vfms.f32	s16, s14, s17
   2b18e:	ee28 8a27 	vmul.f32	s16, s16, s15
   2b192:	ed88 8a01 	vstr	s16, [r8, #4]

    r->lastOut = out;
   2b196:	edc5 9a1c 	vstr	s19, [r5, #112]	; 0x70
}
   2b19a:	ecbd 8b06 	vpop	{d8-d10}
   2b19e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2b1a2:	bf00      	nop
   2b1a4:	00000000 	.word	0x00000000
   2b1a8:	3e99999a 	.word	0x3e99999a
   2b1ac:	3f333333 	.word	0x3f333333

0002b1b0 <tDattorroReverb_initToPool>:
{
    tDattorroReverb_initToPool(rev, &leaf.mempool);
}

void    tDattorroReverb_initToPool        (tDattorroReverb* const rev, tMempool* const mp)
{
   2b1b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2b1b4:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   2b1b8:	680d      	ldr	r5, [r1, #0]
{
   2b1ba:	460e      	mov	r6, r1
   2b1bc:	4681      	mov	r9, r0
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
   2b1be:	2088      	movs	r0, #136	; 0x88
   2b1c0:	4629      	mov	r1, r5
    r->mempool = m;
    
    r->size_max = 2.0f;
    r->size = 1.f;
   2b1c2:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
   2b1c6:	f7fe fcaf 	bl	29b28 <mpool_alloc>
    r->t = r->size * leaf.sampleRate * 0.001f;
   2b1ca:	4ac4      	ldr	r2, [pc, #784]	; (2b4dc <tDattorroReverb_initToPool+0x32c>)
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
   2b1cc:	f8c9 0000 	str.w	r0, [r9]
   2b1d0:	4604      	mov	r4, r0
    r->mempool = m;
   2b1d2:	6005      	str	r5, [r0, #0]
    r->size_max = 2.0f;
   2b1d4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    r->t = r->size * leaf.sampleRate * 0.001f;
   2b1d8:	edd2 7a00 	vldr	s15, [r2]
    r->frozen = 0;
   2b1dc:	2300      	movs	r3, #0
    r->t = r->size * leaf.sampleRate * 0.001f;
   2b1de:	eddf 6ac0 	vldr	s13, [pc, #768]	; 2b4e0 <tDattorroReverb_initToPool+0x330>
    // INPUT
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2b1e2:	3038      	adds	r0, #56	; 0x38
   2b1e4:	ed9f 7abf 	vldr	s14, [pc, #764]	; 2b4e4 <tDattorroReverb_initToPool+0x334>
   2b1e8:	4632      	mov	r2, r6
    r->t = r->size * leaf.sampleRate * 0.001f;
   2b1ea:	ee67 7aa6 	vmul.f32	s15, s15, s13
    r->size_max = 2.0f;
   2b1ee:	f840 1c18 	str.w	r1, [r0, #-24]
    r->frozen = 0;
   2b1f2:	f840 3c20 	str.w	r3, [r0, #-32]
    tOnePole_initToPool(&r->in_filter, 1.f, mp);
    
    for (int i = 0; i < 4; i++)
    {
        tAllpass_initToPool(&r->in_allpass[i], SAMP(in_allpass_delays[i]), SAMP(20.f), mp); // * r->size_max
   2b1f6:	eeb3 8a04 	vmov.f32	s16, #52	; 0x41a00000  20.0
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2b1fa:	ed9f 0abb 	vldr	s0, [pc, #748]	; 2b4e8 <tDattorroReverb_initToPool+0x338>
   2b1fe:	f104 0540 	add.w	r5, r4, #64	; 0x40
   2b202:	ee27 7a87 	vmul.f32	s14, s15, s14
    r->t = r->size * leaf.sampleRate * 0.001f;
   2b206:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
    r->size = 1.f;
   2b20a:	edc4 8a07 	vstr	s17, [r4, #28]
   2b20e:	f104 0a50 	add.w	sl, r4, #80	; 0x50
   2b212:	f8df 831c 	ldr.w	r8, [pc, #796]	; 2b530 <tDattorroReverb_initToPool+0x380>
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2b216:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b21a:	4fb4      	ldr	r7, [pc, #720]	; (2b4ec <tDattorroReverb_initToPool+0x33c>)
   2b21c:	ee17 1a90 	vmov	r1, s15
   2b220:	f7f9 feca 	bl	24fb8 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->in_filter, 1.f, mp);
   2b224:	4631      	mov	r1, r6
   2b226:	eeb0 0a68 	vmov.f32	s0, s17
   2b22a:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2b22e:	f7fc febb 	bl	27fa8 <tOnePole_initToPool>
        tAllpass_initToPool(&r->in_allpass[i], SAMP(in_allpass_delays[i]), SAMP(20.f), mp); // * r->size_max
   2b232:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b236:	4628      	mov	r0, r5
   2b238:	ecb8 0a01 	vldmia	r8!, {s0}
   2b23c:	4632      	mov	r2, r6
   2b23e:	ee27 7a88 	vmul.f32	s14, s15, s16
   2b242:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b246:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b24a:	ee17 1a90 	vmov	r1, s15
   2b24e:	f7fc fe5b 	bl	27f08 <tAllpass_initToPool>
        tAllpass_setGain(&r->in_allpass[i], in_allpass_gains[i]);
   2b252:	4628      	mov	r0, r5
   2b254:	3504      	adds	r5, #4
   2b256:	ecb7 0a01 	vldmia	r7!, {s0}
   2b25a:	f7fc fe87 	bl	27f6c <tAllpass_setGain>
    for (int i = 0; i < 4; i++)
   2b25e:	4555      	cmp	r5, sl
   2b260:	d1e7      	bne.n	2b232 <tDattorroReverb_initToPool+0x82>
    }
    
    // FEEDBACK 1
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2b262:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b266:	4632      	mov	r2, r6
   2b268:	ed9f 9aa1 	vldr	s18, [pc, #644]	; 2b4f0 <tDattorroReverb_initToPool+0x340>
   2b26c:	4628      	mov	r0, r5
   2b26e:	ed9f 0aa1 	vldr	s0, [pc, #644]	; 2b4f4 <tDattorroReverb_initToPool+0x344>
    tAllpass_setGain(&r->f1_allpass, 0.7f);
    
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
   2b272:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2b276:	ee27 7a89 	vmul.f32	s14, s15, s18
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
   2b27a:	eddf 8a9a 	vldr	s17, [pc, #616]	; 2b4e4 <tDattorroReverb_initToPool+0x334>
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2b27e:	ee27 0a80 	vmul.f32	s0, s15, s0
    
    tOnePole_initToPool(&r->f1_filter, 1.f, mp);
    
    tHighpass_initToPool(&r->f1_hp, 20.f, mp);
    
    tCycle_initToPool(&r->f1_lfo, mp);
   2b282:	f104 0868 	add.w	r8, r4, #104	; 0x68
    tCycle_setFreq(&r->f1_lfo, 0.1f);
    
    // FEEDBACK 2
    tAllpass_initToPool(&r->f2_allpass, SAMP(22.58f), SAMP(100.f), mp); // * r->size_max
   2b286:	f104 076c 	add.w	r7, r4, #108	; 0x6c
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2b28a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b28e:	ee17 1a90 	vmov	r1, s15
   2b292:	f7fc fe39 	bl	27f08 <tAllpass_initToPool>
    tAllpass_setGain(&r->f1_allpass, 0.7f);
   2b296:	4628      	mov	r0, r5
   2b298:	ed9f 0a97 	vldr	s0, [pc, #604]	; 2b4f8 <tDattorroReverb_initToPool+0x348>
    
    tOnePole_initToPool(&r->f2_filter, 1.f, mp);
    
    tHighpass_initToPool(&r->f2_hp, 20.f, mp);
    
    tCycle_initToPool(&r->f2_lfo, mp);
   2b29c:	f104 0584 	add.w	r5, r4, #132	; 0x84
    tAllpass_setGain(&r->f1_allpass, 0.7f);
   2b2a0:	f7fc fe64 	bl	27f6c <tAllpass_setGain>
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
   2b2a4:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b2a8:	edd4 7a08 	vldr	s15, [r4, #32]
   2b2ac:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2b2b0:	ed9f 0a92 	vldr	s0, [pc, #584]	; 2b4fc <tDattorroReverb_initToPool+0x34c>
   2b2b4:	4632      	mov	r2, r6
   2b2b6:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b2ba:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b2be:	eeb0 7a48 	vmov.f32	s14, s16
   2b2c2:	eea7 7aa8 	vfma.f32	s14, s15, s17
   2b2c6:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b2ca:	ee17 1a90 	vmov	r1, s15
   2b2ce:	f7f9 fe73 	bl	24fb8 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f1_delay_2, SAMP(89.24f), SAMP(100.0f) * r->size_max + 1, mp);
   2b2d2:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b2d6:	edd4 7a08 	vldr	s15, [r4, #32]
   2b2da:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2b2de:	ed9f 0a88 	vldr	s0, [pc, #544]	; 2b500 <tDattorroReverb_initToPool+0x350>
   2b2e2:	4632      	mov	r2, r6
   2b2e4:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b2e8:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b2ec:	eeb0 7a48 	vmov.f32	s14, s16
   2b2f0:	eea7 7a89 	vfma.f32	s14, s15, s18
   2b2f4:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b2f8:	ee17 1a90 	vmov	r1, s15
   2b2fc:	f7f9 fe5c 	bl	24fb8 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f1_delay_3, SAMP(125.f), SAMP(200.0f) * r->size_max + 1, mp);
   2b300:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b304:	edd4 7a08 	vldr	s15, [r4, #32]
   2b308:	4632      	mov	r2, r6
   2b30a:	ed9f 0a7e 	vldr	s0, [pc, #504]	; 2b504 <tDattorroReverb_initToPool+0x354>
   2b30e:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2b312:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b316:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b31a:	eeb0 7a48 	vmov.f32	s14, s16
   2b31e:	eea7 7aa8 	vfma.f32	s14, s15, s17
   2b322:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b326:	ee17 1a90 	vmov	r1, s15
   2b32a:	f7f9 fe45 	bl	24fb8 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->f1_filter, 1.f, mp);
   2b32e:	eeb0 0a48 	vmov.f32	s0, s16
   2b332:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2b336:	4631      	mov	r1, r6
   2b338:	f7fc fe36 	bl	27fa8 <tOnePole_initToPool>
    tHighpass_initToPool(&r->f1_hp, 20.f, mp);
   2b33c:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   2b340:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2b344:	4631      	mov	r1, r6
   2b346:	f7fd f869 	bl	2841c <tHighpass_initToPool>
    tCycle_initToPool(&r->f1_lfo, mp);
   2b34a:	4631      	mov	r1, r6
   2b34c:	4640      	mov	r0, r8
   2b34e:	f7ff f88b 	bl	2a468 <tCycle_initToPool>
    tCycle_setFreq(&r->f1_lfo, 0.1f);
   2b352:	4640      	mov	r0, r8
   2b354:	ed9f 0a6c 	vldr	s0, [pc, #432]	; 2b508 <tDattorroReverb_initToPool+0x358>
   2b358:	f7ff f898 	bl	2a48c <tCycle_setFreq>
    tAllpass_initToPool(&r->f2_allpass, SAMP(22.58f), SAMP(100.f), mp); // * r->size_max
   2b35c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b360:	ed9f 0a6a 	vldr	s0, [pc, #424]	; 2b50c <tDattorroReverb_initToPool+0x35c>
   2b364:	4632      	mov	r2, r6
   2b366:	ee27 7a89 	vmul.f32	s14, s15, s18
   2b36a:	4638      	mov	r0, r7
   2b36c:	ee27 0a80 	vmul.f32	s0, s15, s0
   2b370:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b374:	ee17 1a90 	vmov	r1, s15
   2b378:	f7fc fdc6 	bl	27f08 <tAllpass_initToPool>
    tAllpass_setGain(&r->f2_allpass, 0.7f);
   2b37c:	4638      	mov	r0, r7
   2b37e:	ed9f 0a5e 	vldr	s0, [pc, #376]	; 2b4f8 <tDattorroReverb_initToPool+0x348>
   2b382:	f7fc fdf3 	bl	27f6c <tAllpass_setGain>
    tTapeDelay_initToPool(&r->f2_delay_1, SAMP(149.62f), SAMP(200.f) * r->size_max + 1, mp);
   2b386:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b38a:	edd4 7a08 	vldr	s15, [r4, #32]
   2b38e:	f104 0070 	add.w	r0, r4, #112	; 0x70
   2b392:	ed9f 0a5f 	vldr	s0, [pc, #380]	; 2b510 <tDattorroReverb_initToPool+0x360>
   2b396:	4632      	mov	r2, r6
   2b398:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b39c:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b3a0:	eeb0 7a48 	vmov.f32	s14, s16
   2b3a4:	eea7 7aa8 	vfma.f32	s14, s15, s17
   2b3a8:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b3ac:	ee17 1a90 	vmov	r1, s15
   2b3b0:	f7f9 fe02 	bl	24fb8 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f2_delay_2, SAMP(60.48f), SAMP(100.f) * r->size_max + 1, mp);
   2b3b4:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b3b8:	edd4 7a08 	vldr	s15, [r4, #32]
   2b3bc:	f104 0078 	add.w	r0, r4, #120	; 0x78
   2b3c0:	ed9f 0a54 	vldr	s0, [pc, #336]	; 2b514 <tDattorroReverb_initToPool+0x364>
   2b3c4:	4632      	mov	r2, r6
   2b3c6:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b3ca:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b3ce:	eeb0 7a48 	vmov.f32	s14, s16
   2b3d2:	eea7 7a89 	vfma.f32	s14, s15, s18
   2b3d6:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b3da:	ee17 1a90 	vmov	r1, s15
   2b3de:	f7f9 fdeb 	bl	24fb8 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f2_delay_3, SAMP(106.28f), SAMP(200.f) * r->size_max + 1, mp);
   2b3e2:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b3e6:	edd4 7a08 	vldr	s15, [r4, #32]
   2b3ea:	4632      	mov	r2, r6
   2b3ec:	ed9f 0a4a 	vldr	s0, [pc, #296]	; 2b518 <tDattorroReverb_initToPool+0x368>
   2b3f0:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   2b3f4:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b3f8:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b3fc:	eeb0 7a48 	vmov.f32	s14, s16
   2b400:	eea7 7aa8 	vfma.f32	s14, s15, s17
   2b404:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b408:	ee17 1a90 	vmov	r1, s15
   2b40c:	f7f9 fdd4 	bl	24fb8 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->f2_filter, 1.f, mp);
   2b410:	eeb0 0a48 	vmov.f32	s0, s16
   2b414:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2b418:	4631      	mov	r1, r6
   2b41a:	f7fc fdc5 	bl	27fa8 <tOnePole_initToPool>
    tHighpass_initToPool(&r->f2_hp, 20.f, mp);
   2b41e:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   2b422:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2b426:	4631      	mov	r1, r6
   2b428:	f7fc fff8 	bl	2841c <tHighpass_initToPool>
    tCycle_initToPool(&r->f2_lfo, mp);
   2b42c:	4631      	mov	r1, r6
   2b42e:	4628      	mov	r0, r5
   2b430:	f7ff f81a 	bl	2a468 <tCycle_initToPool>
    tCycle_setFreq(&r->f2_lfo, 0.07f);
   2b434:	4628      	mov	r0, r5
   2b436:	ed9f 0a39 	vldr	s0, [pc, #228]	; 2b51c <tDattorroReverb_initToPool+0x36c>
   2b43a:	f7ff f827 	bl	2a48c <tCycle_setFreq>
}

void    tDattorroReverb_setMix            (tDattorroReverb* const rev, float mix)
{
    _tDattorroReverb* r = *rev;
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2b43e:	eeb0 1a48 	vmov.f32	s2, s16
    _tDattorroReverb* r = *rev;
   2b442:	f8d9 4000 	ldr.w	r4, [r9]
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2b446:	eef6 0a00 	vmov.f32	s1, #96	; 0x3f000000  0.5
   2b44a:	ed9f 0a27 	vldr	s0, [pc, #156]	; 2b4e8 <tDattorroReverb_initToPool+0x338>
   2b44e:	f7fe f96b 	bl	29728 <LEAF_clip>

void    tDattorroReverb_setInputDelay     (tDattorroReverb* const rev, float preDelay)
{
    _tDattorroReverb* r = *rev;
    
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2b452:	eddf 0a25 	vldr	s1, [pc, #148]	; 2b4e8 <tDattorroReverb_initToPool+0x338>
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2b456:	ed84 0a05 	vstr	s0, [r4, #20]
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2b45a:	eeb0 1a68 	vmov.f32	s2, s17
    _tDattorroReverb* r = *rev;
   2b45e:	f8d9 4000 	ldr.w	r4, [r9]
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2b462:	eeb0 0a60 	vmov.f32	s0, s1
   2b466:	f7fe f95f 	bl	29728 <LEAF_clip>
    
    tTapeDelay_setDelay(&r->in_delay, SAMP(r->predelay));
   2b46a:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b46e:	f104 0038 	add.w	r0, r4, #56	; 0x38
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2b472:	ed84 0a01 	vstr	s0, [r4, #4]
    tTapeDelay_setDelay(&r->in_delay, SAMP(r->predelay));
   2b476:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b47a:	f7f9 fe51 	bl	25120 <tTapeDelay_setDelay>
}

void    tDattorroReverb_setInputFilter    (tDattorroReverb* const rev, float freq)
{
    _tDattorroReverb* r = *rev;
   2b47e:	f8d9 4000 	ldr.w	r4, [r9]
    
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2b482:	ed9f 1a27 	vldr	s2, [pc, #156]	; 2b520 <tDattorroReverb_initToPool+0x370>
   2b486:	eddf 0a27 	vldr	s1, [pc, #156]	; 2b524 <tDattorroReverb_initToPool+0x374>
   2b48a:	ed9f 0a17 	vldr	s0, [pc, #92]	; 2b4e8 <tDattorroReverb_initToPool+0x338>
   2b48e:	f7fe f94b 	bl	29728 <LEAF_clip>
    
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2b492:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2b496:	ed84 0a02 	vstr	s0, [r4, #8]
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2b49a:	f7fc fdbf 	bl	2801c <tOnePole_setFreq>
}

void    tDattorroReverb_setFeedbackFilter (tDattorroReverb* const rev, float freq)
{
    _tDattorroReverb* r = *rev;
   2b49e:	f8d9 4000 	ldr.w	r4, [r9]
    
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2b4a2:	ed9f 1a1f 	vldr	s2, [pc, #124]	; 2b520 <tDattorroReverb_initToPool+0x370>
   2b4a6:	eddf 0a20 	vldr	s1, [pc, #128]	; 2b528 <tDattorroReverb_initToPool+0x378>
   2b4aa:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 2b4e8 <tDattorroReverb_initToPool+0x338>
   2b4ae:	f7fe f93b 	bl	29728 <LEAF_clip>
    
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2b4b2:	f104 0058 	add.w	r0, r4, #88	; 0x58
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2b4b6:	ed84 0a03 	vstr	s0, [r4, #12]
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2b4ba:	f7fc fdaf 	bl	2801c <tOnePole_setFreq>
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
   2b4be:	ed94 0a03 	vldr	s0, [r4, #12]
   2b4c2:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2b4c6:	f7fc fda9 	bl	2801c <tOnePole_setFreq>
}

void    tDattorroReverb_setFeedbackGain   (tDattorroReverb* const rev, float gain)
{
    _tDattorroReverb* r = *rev;
   2b4ca:	f8d9 3000 	ldr.w	r3, [r9]
    r->feedback_gain = gain;
   2b4ce:	4a17      	ldr	r2, [pc, #92]	; (2b52c <tDattorroReverb_initToPool+0x37c>)
   2b4d0:	611a      	str	r2, [r3, #16]
}
   2b4d2:	ecbd 8b04 	vpop	{d8-d9}
   2b4d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2b4da:	bf00      	nop
   2b4dc:	020fbd68 	.word	0x020fbd68
   2b4e0:	3a83126f 	.word	0x3a83126f
   2b4e4:	43480000 	.word	0x43480000
   2b4e8:	00000000 	.word	0x00000000
   2b4ec:	00062900 	.word	0x00062900
   2b4f0:	42c80000 	.word	0x42c80000
   2b4f4:	41f4147b 	.word	0x41f4147b
   2b4f8:	3f333333 	.word	0x3f333333
   2b4fc:	430db0a4 	.word	0x430db0a4
   2b500:	42b27ae1 	.word	0x42b27ae1
   2b504:	42fa0000 	.word	0x42fa0000
   2b508:	3dcccccd 	.word	0x3dcccccd
   2b50c:	41b4a3d7 	.word	0x41b4a3d7
   2b510:	43159eb8 	.word	0x43159eb8
   2b514:	4271eb85 	.word	0x4271eb85
   2b518:	42d48f5c 	.word	0x42d48f5c
   2b51c:	3d8f5c29 	.word	0x3d8f5c29
   2b520:	469c4000 	.word	0x469c4000
   2b524:	461c4000 	.word	0x461c4000
   2b528:	459c4000 	.word	0x459c4000
   2b52c:	3ecccccd 	.word	0x3ecccccd
   2b530:	000628f0 	.word	0x000628f0

0002b534 <tDattorroReverb_init>:
    tDattorroReverb_initToPool(rev, &leaf.mempool);
   2b534:	4901      	ldr	r1, [pc, #4]	; (2b53c <tDattorroReverb_init+0x8>)
   2b536:	f7ff be3b 	b.w	2b1b0 <tDattorroReverb_initToPool>
   2b53a:	bf00      	nop
   2b53c:	020fbd80 	.word	0x020fbd80

0002b540 <tDattorroReverb_free>:
{
   2b540:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2b542:	6804      	ldr	r4, [r0, #0]
    tTapeDelay_free(&r->in_delay);
   2b544:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2b548:	f7f9 fd68 	bl	2501c <tTapeDelay_free>
    tOnePole_free(&r->in_filter);
   2b54c:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2b550:	f7fc fd60 	bl	28014 <tOnePole_free>
        tAllpass_free(&r->in_allpass[i]);
   2b554:	f104 0040 	add.w	r0, r4, #64	; 0x40
   2b558:	f7fc fcf8 	bl	27f4c <tAllpass_free>
   2b55c:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2b560:	f7fc fcf4 	bl	27f4c <tAllpass_free>
   2b564:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2b568:	f7fc fcf0 	bl	27f4c <tAllpass_free>
   2b56c:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2b570:	f7fc fcec 	bl	27f4c <tAllpass_free>
    tAllpass_free(&r->f1_allpass);
   2b574:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2b578:	f7fc fce8 	bl	27f4c <tAllpass_free>
    tTapeDelay_free(&r->f1_delay_1);
   2b57c:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2b580:	f7f9 fd4c 	bl	2501c <tTapeDelay_free>
    tTapeDelay_free(&r->f1_delay_2);
   2b584:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2b588:	f7f9 fd48 	bl	2501c <tTapeDelay_free>
    tTapeDelay_free(&r->f1_delay_3);
   2b58c:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2b590:	f7f9 fd44 	bl	2501c <tTapeDelay_free>
    tOnePole_free(&r->f1_filter);
   2b594:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2b598:	f7fc fd3c 	bl	28014 <tOnePole_free>
    tHighpass_free(&r->f1_hp);
   2b59c:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2b5a0:	f7fc ff5c 	bl	2845c <tHighpass_free>
    tCycle_free(&r->f1_lfo);
   2b5a4:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2b5a8:	f7fe ff6c 	bl	2a484 <tCycle_free>
    tAllpass_free(&r->f2_allpass);
   2b5ac:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2b5b0:	f7fc fccc 	bl	27f4c <tAllpass_free>
    tTapeDelay_free(&r->f2_delay_1);
   2b5b4:	f104 0070 	add.w	r0, r4, #112	; 0x70
   2b5b8:	f7f9 fd30 	bl	2501c <tTapeDelay_free>
    tTapeDelay_free(&r->f2_delay_2);
   2b5bc:	f104 0078 	add.w	r0, r4, #120	; 0x78
   2b5c0:	f7f9 fd2c 	bl	2501c <tTapeDelay_free>
    tTapeDelay_free(&r->f2_delay_3);
   2b5c4:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   2b5c8:	f7f9 fd28 	bl	2501c <tTapeDelay_free>
    tOnePole_free(&r->f2_filter);
   2b5cc:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2b5d0:	f7fc fd20 	bl	28014 <tOnePole_free>
    tHighpass_free(&r->f2_hp);
   2b5d4:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2b5d8:	f7fc ff40 	bl	2845c <tHighpass_free>
    tCycle_free(&r->f2_lfo);
   2b5dc:	f104 0084 	add.w	r0, r4, #132	; 0x84
   2b5e0:	f7fe ff50 	bl	2a484 <tCycle_free>
    mpool_free((char*)r, r->mempool);
   2b5e4:	6821      	ldr	r1, [r4, #0]
   2b5e6:	4620      	mov	r0, r4
}
   2b5e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)r, r->mempool);
   2b5ec:	f7fe bb44 	b.w	29c78 <mpool_free>

0002b5f0 <tDattorroReverb_tickStereo>:
{
   2b5f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2b5f4:	ed2d 8b06 	vpush	{d8-d10}
    _tDattorroReverb* r = *rev;
   2b5f8:	6804      	ldr	r4, [r0, #0]
{
   2b5fa:	468a      	mov	sl, r1
    	input = 0.0f;
   2b5fc:	eddf 9abf 	vldr	s19, [pc, #764]	; 2b8fc <tDattorroReverb_tickStereo+0x30c>
    if (r->frozen)
   2b600:	69a3      	ldr	r3, [r4, #24]
	in_sample = tTapeDelay_tick(&r->in_delay, input);
   2b602:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2b606:	f104 0540 	add.w	r5, r4, #64	; 0x40
   2b60a:	f104 0650 	add.w	r6, r4, #80	; 0x50
    	input = 0.0f;
   2b60e:	2b00      	cmp	r3, #0
   2b610:	fe40 9a29 	vseleq.f32	s19, s0, s19
	in_sample = tTapeDelay_tick(&r->in_delay, input);
   2b614:	eeb0 0a69 	vmov.f32	s0, s19
   2b618:	f7f9 fd0c 	bl	25034 <tTapeDelay_tick>
	in_sample = tOnePole_tick(&r->in_filter, in_sample);
   2b61c:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2b620:	f7fc fd18 	bl	28054 <tOnePole_tick>
   2b624:	eeb0 8a40 	vmov.f32	s16, s0
		in_sample = tAllpass_tick(&r->in_allpass[i], in_sample);
   2b628:	4628      	mov	r0, r5
   2b62a:	3504      	adds	r5, #4
   2b62c:	eeb0 0a48 	vmov.f32	s0, s16
   2b630:	f7fc fca0 	bl	27f74 <tAllpass_tick>
	for (int i = 0; i < 4; i++)
   2b634:	42b5      	cmp	r5, r6
		in_sample = tAllpass_tick(&r->in_allpass[i], in_sample);
   2b636:	eeb0 8a40 	vmov.f32	s16, s0
	for (int i = 0; i < 4; i++)
   2b63a:	d1f5      	bne.n	2b628 <tDattorroReverb_tickStereo+0x38>
		f1_sample = in_sample + r->f2_last; // + f2_last_out;
   2b63c:	edd4 8a0d 	vldr	s17, [r4, #52]	; 0x34
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
   2b640:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2b644:	ed94 9a09 	vldr	s18, [r4, #36]	; 0x24
		f1_sample = tTapeDelay_tick(&r->f1_delay_1, f1_sample);
   2b648:	f104 0654 	add.w	r6, r4, #84	; 0x54
		f1_sample = in_sample + r->f2_last; // + f2_last_out;
   2b64c:	ee70 8a28 	vadd.f32	s17, s0, s17
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
   2b650:	f7fe ff2a 	bl	2a4a8 <tCycle_tick>
   2b654:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
   2b658:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b65c:	ed9f 7aa8 	vldr	s14, [pc, #672]	; 2b900 <tDattorroReverb_tickStereo+0x310>
   2b660:	4628      	mov	r0, r5
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
   2b662:	f104 095c 	add.w	r9, r4, #92	; 0x5c
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
   2b666:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2b66a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2b66e:	eea9 0a07 	vfma.f32	s0, s18, s14
   2b672:	f7fc fc77 	bl	27f64 <tAllpass_setDelay>
		f1_sample = tAllpass_tick(&r->f1_allpass, f1_sample);
   2b676:	eeb0 0a68 	vmov.f32	s0, s17
   2b67a:	4628      	mov	r0, r5
   2b67c:	f7fc fc7a 	bl	27f74 <tAllpass_tick>
		f1_sample = tTapeDelay_tick(&r->f1_delay_1, f1_sample);
   2b680:	4630      	mov	r0, r6
   2b682:	f7f9 fcd7 	bl	25034 <tTapeDelay_tick>
		f1_sample = tOnePole_tick(&r->f1_filter, f1_sample);
   2b686:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2b68a:	f7fc fce3 	bl	28054 <tOnePole_tick>
		f1_sample = f1_sample + r->f1_delay_2_last * 0.5f;
   2b68e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2b692:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
   2b696:	4648      	mov	r0, r9
		f1_sample = f1_sample + r->f1_delay_2_last * 0.5f;
   2b698:	eea7 0a27 	vfma.f32	s0, s14, s15
   2b69c:	eef0 8a40 	vmov.f32	s17, s0
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
   2b6a0:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b6a4:	f7f9 fcc6 	bl	25034 <tTapeDelay_tick>
   2b6a8:	eef0 7a40 	vmov.f32	s15, s0
		f1_sample = tHighpass_tick(&r->f1_hp, f1_sample);
   2b6ac:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2b6b0:	ee38 0a80 	vadd.f32	s0, s17, s0
		r->f1_delay_2_last = f1_delay_2_sample;
   2b6b4:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
		f1_sample = tHighpass_tick(&r->f1_hp, f1_sample);
   2b6b8:	f7fc fee4 	bl	28484 <tHighpass_tick>
		if (r->frozen)
   2b6bc:	69a3      	ldr	r3, [r4, #24]
		f1_sample *= r->feedback_gain;
   2b6be:	edd4 7a04 	vldr	s15, [r4, #16]
		if (r->frozen)
   2b6c2:	2b00      	cmp	r3, #0
   2b6c4:	f040 8114 	bne.w	2b8f0 <tDattorroReverb_tickStereo+0x300>
		f1_sample *= r->feedback_gain;
   2b6c8:	ee27 0a80 	vmul.f32	s0, s15, s0
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
   2b6cc:	f104 0860 	add.w	r8, r4, #96	; 0x60
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
   2b6d0:	f104 076c 	add.w	r7, r4, #108	; 0x6c
		f2_sample = tTapeDelay_tick(&r->f2_delay_1, f2_sample);
   2b6d4:	f104 0570 	add.w	r5, r4, #112	; 0x70
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
   2b6d8:	f104 0b78 	add.w	fp, r4, #120	; 0x78
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
   2b6dc:	4640      	mov	r0, r8
   2b6de:	f7f9 fca9 	bl	25034 <tTapeDelay_tick>
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
   2b6e2:	f104 0084 	add.w	r0, r4, #132	; 0x84
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
   2b6e6:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
		f2_sample = in_sample + r->f1_last;
   2b6ea:	ee30 8a08 	vadd.f32	s16, s0, s16
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
   2b6ee:	edd4 8a09 	vldr	s17, [r4, #36]	; 0x24
   2b6f2:	f7fe fed9 	bl	2a4a8 <tCycle_tick>
   2b6f6:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
   2b6fa:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b6fe:	ed9f 7a81 	vldr	s14, [pc, #516]	; 2b904 <tDattorroReverb_tickStereo+0x314>
   2b702:	4638      	mov	r0, r7
   2b704:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2b708:	ee27 0a80 	vmul.f32	s0, s15, s0
   2b70c:	eea8 0a87 	vfma.f32	s0, s17, s14
   2b710:	f7fc fc28 	bl	27f64 <tAllpass_setDelay>
		f2_sample = tAllpass_tick(&r->f2_allpass, f2_sample);
   2b714:	eeb0 0a48 	vmov.f32	s0, s16
   2b718:	4638      	mov	r0, r7
   2b71a:	f7fc fc2b 	bl	27f74 <tAllpass_tick>
		f2_sample = tTapeDelay_tick(&r->f2_delay_1, f2_sample);
   2b71e:	4628      	mov	r0, r5
   2b720:	f7f9 fc88 	bl	25034 <tTapeDelay_tick>
		f2_sample = tOnePole_tick(&r->f2_filter, f2_sample);
   2b724:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2b728:	f7fc fc94 	bl	28054 <tOnePole_tick>
		f2_sample = f2_sample + r->f2_delay_2_last * 0.5f;
   2b72c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2b730:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
   2b734:	4658      	mov	r0, fp
		f2_sample = f2_sample + r->f2_delay_2_last * 0.5f;
   2b736:	eea7 0a27 	vfma.f32	s0, s14, s15
   2b73a:	eeb0 8a40 	vmov.f32	s16, s0
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
   2b73e:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b742:	f7f9 fc77 	bl	25034 <tTapeDelay_tick>
   2b746:	eef0 7a40 	vmov.f32	s15, s0
		f2_sample = tHighpass_tick(&r->f2_hp, f2_sample);
   2b74a:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2b74e:	ee38 0a00 	vadd.f32	s0, s16, s0
		r->f2_delay_2_last = f2_delay_2_sample;
   2b752:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
		f2_sample = tHighpass_tick(&r->f2_hp, f2_sample);
   2b756:	f7fc fe95 	bl	28484 <tHighpass_tick>
		if (r->frozen)
   2b75a:	69a3      	ldr	r3, [r4, #24]
		f2_sample *= r->feedback_gain;
   2b75c:	edd4 7a04 	vldr	s15, [r4, #16]
		if (r->frozen)
   2b760:	2b00      	cmp	r3, #0
   2b762:	f000 80c8 	beq.w	2b8f6 <tDattorroReverb_tickStereo+0x306>
			f2_sample = 0.0f;
   2b766:	ed9f 0a65 	vldr	s0, [pc, #404]	; 2b8fc <tDattorroReverb_tickStereo+0x30c>
		r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
   2b76a:	f104 077c 	add.w	r7, r4, #124	; 0x7c
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b76e:	ed9f aa66 	vldr	s20, [pc, #408]	; 2b908 <tDattorroReverb_tickStereo+0x318>
		r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
   2b772:	4638      	mov	r0, r7
   2b774:	f7f9 fc5e 	bl	25034 <tTapeDelay_tick>
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
   2b778:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b77c:	eddf 7a63 	vldr	s15, [pc, #396]	; 2b90c <tDattorroReverb_tickStereo+0x31c>
   2b780:	4630      	mov	r0, r6
		r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
   2b782:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
   2b786:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b78a:	f7f9 fcd9 	bl	25140 <tTapeDelay_tapOut>
    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(99.8f));
   2b78e:	eddf 7a60 	vldr	s15, [pc, #384]	; 2b910 <tDattorroReverb_tickStereo+0x320>
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
   2b792:	eeb0 8a40 	vmov.f32	s16, s0
    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(99.8f));
   2b796:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2b79a:	4630      	mov	r0, r6
   2b79c:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b7a0:	f7f9 fcce 	bl	25140 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(64.2f));
   2b7a4:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b7a8:	eddf 7a5a 	vldr	s15, [pc, #360]	; 2b914 <tDattorroReverb_tickStereo+0x324>
   2b7ac:	ee38 8a00 	vadd.f32	s16, s16, s0
   2b7b0:	4648      	mov	r0, r9
   2b7b2:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b7b6:	f7f9 fcc3 	bl	25140 <tTapeDelay_tapOut>
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
   2b7ba:	eddf 7a57 	vldr	s15, [pc, #348]	; 2b918 <tDattorroReverb_tickStereo+0x328>
    f1_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(64.2f));
   2b7be:	eef0 8a40 	vmov.f32	s17, s0
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
   2b7c2:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2b7c6:	4640      	mov	r0, r8
   2b7c8:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b7cc:	f7f9 fcb8 	bl	25140 <tTapeDelay_tapOut>
   2b7d0:	ee30 9a08 	vadd.f32	s18, s0, s16
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
   2b7d4:	eddf 7a51 	vldr	s15, [pc, #324]	; 2b91c <tDattorroReverb_tickStereo+0x32c>
   2b7d8:	4628      	mov	r0, r5
   2b7da:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
   2b7de:	ee39 9a68 	vsub.f32	s18, s18, s17
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
   2b7e2:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b7e6:	f7f9 fcab 	bl	25140 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b7ea:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
   2b7ee:	ee39 9a40 	vsub.f32	s18, s18, s0
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b7f2:	4658      	mov	r0, fp
   2b7f4:	ee27 0a8a 	vmul.f32	s0, s15, s20
   2b7f8:	f7f9 fca2 	bl	25140 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
   2b7fc:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b800:	eddf 7a47 	vldr	s15, [pc, #284]	; 2b920 <tDattorroReverb_tickStereo+0x330>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b804:	ee39 9a40 	vsub.f32	s18, s18, s0
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
   2b808:	4638      	mov	r0, r7
   2b80a:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b80e:	f7f9 fc97 	bl	25140 <tTapeDelay_tapOut>
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
   2b812:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b816:	eddf 7a43 	vldr	s15, [pc, #268]	; 2b924 <tDattorroReverb_tickStereo+0x334>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
   2b81a:	ee39 9a40 	vsub.f32	s18, s18, s0
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
   2b81e:	4628      	mov	r0, r5
   2b820:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b824:	f7f9 fc8c 	bl	25140 <tTapeDelay_tapOut>
    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(121.7f));
   2b828:	eddf 7a3f 	vldr	s15, [pc, #252]	; 2b928 <tDattorroReverb_tickStereo+0x338>
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
   2b82c:	eef0 8a40 	vmov.f32	s17, s0
    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(121.7f));
   2b830:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2b834:	4628      	mov	r0, r5
   2b836:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b83a:	f7f9 fc81 	bl	25140 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b83e:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b842:	ee78 8a80 	vadd.f32	s17, s17, s0
   2b846:	4658      	mov	r0, fp
   2b848:	ee27 0a8a 	vmul.f32	s0, s15, s20
   2b84c:	f7f9 fc78 	bl	25140 <tTapeDelay_tapOut>
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
   2b850:	eddf 7a36 	vldr	s15, [pc, #216]	; 2b92c <tDattorroReverb_tickStereo+0x33c>
    f2_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b854:	eeb0 aa40 	vmov.f32	s20, s0
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
   2b858:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2b85c:	4638      	mov	r0, r7
   2b85e:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b862:	f7f9 fc6d 	bl	25140 <tTapeDelay_tapOut>
   2b866:	ee30 8a28 	vadd.f32	s16, s0, s17
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
   2b86a:	eddf 7a31 	vldr	s15, [pc, #196]	; 2b930 <tDattorroReverb_tickStereo+0x340>
   2b86e:	4630      	mov	r0, r6
   2b870:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
   2b874:	ee38 8a4a 	vsub.f32	s16, s16, s20
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
   2b878:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b87c:	f7f9 fc60 	bl	25140 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
   2b880:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b884:	eddf 7a2b 	vldr	s15, [pc, #172]	; 2b934 <tDattorroReverb_tickStereo+0x344>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
   2b888:	ee38 8a40 	vsub.f32	s16, s16, s0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
   2b88c:	4648      	mov	r0, r9
   2b88e:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b892:	f7f9 fc55 	bl	25140 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
   2b896:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b89a:	eddf 7a27 	vldr	s15, [pc, #156]	; 2b938 <tDattorroReverb_tickStereo+0x348>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
   2b89e:	ee38 8a40 	vsub.f32	s16, s16, s0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
   2b8a2:	4640      	mov	r0, r8
   2b8a4:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b8a8:	f7f9 fc4a 	bl	25140 <tTapeDelay_tapOut>
    output[0] = input * (1.0f - r->mix) + f1_sample  * r->mix;
   2b8ac:	ed94 6a05 	vldr	s12, [r4, #20]
   2b8b0:	eddf 6a22 	vldr	s13, [pc, #136]	; 2b93c <tDattorroReverb_tickStereo+0x34c>
   2b8b4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
   2b8b8:	ee38 0a40 	vsub.f32	s0, s16, s0
    output[0] = input * (1.0f - r->mix) + f1_sample  * r->mix;
   2b8bc:	ee66 7a26 	vmul.f32	s15, s12, s13
   2b8c0:	ee37 6a46 	vsub.f32	s12, s14, s12
   2b8c4:	ee27 9a89 	vmul.f32	s18, s15, s18
   2b8c8:	eea6 9a29 	vfma.f32	s18, s12, s19
   2b8cc:	ed8a 9a00 	vstr	s18, [sl]
    output[1] = input * (1.0f - r->mix) + f2_sample * r->mix;
   2b8d0:	edd4 7a05 	vldr	s15, [r4, #20]
   2b8d4:	ee67 6aa6 	vmul.f32	s13, s15, s13
   2b8d8:	ee37 7a67 	vsub.f32	s14, s14, s15
   2b8dc:	ee20 0a26 	vmul.f32	s0, s0, s13
   2b8e0:	eea7 0a29 	vfma.f32	s0, s14, s19
   2b8e4:	ed8a 0a01 	vstr	s0, [sl, #4]
}
   2b8e8:	ecbd 8b06 	vpop	{d8-d10}
   2b8ec:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			f1_sample = 0.0f;
   2b8f0:	ed9f 0a02 	vldr	s0, [pc, #8]	; 2b8fc <tDattorroReverb_tickStereo+0x30c>
   2b8f4:	e6ea      	b.n	2b6cc <tDattorroReverb_tickStereo+0xdc>
		f2_sample *= r->feedback_gain;
   2b8f6:	ee27 0a80 	vmul.f32	s0, s15, s0
   2b8fa:	e736      	b.n	2b76a <tDattorroReverb_tickStereo+0x17a>
   2b8fc:	00000000 	.word	0x00000000
   2b900:	41f4147b 	.word	0x41f4147b
   2b904:	41b4a3d7 	.word	0x41b4a3d7
   2b908:	40c9999a 	.word	0x40c9999a
   2b90c:	410e6666 	.word	0x410e6666
   2b910:	42c7999a 	.word	0x42c7999a
   2b914:	42806666 	.word	0x42806666
   2b918:	42860000 	.word	0x42860000
   2b91c:	4285999a 	.word	0x4285999a
   2b920:	420f3333 	.word	0x420f3333
   2b924:	413ccccd 	.word	0x413ccccd
   2b928:	42f36666 	.word	0x42f36666
   2b92c:	42b36666 	.word	0x42b36666
   2b930:	428d999a 	.word	0x428d999a
   2b934:	41333333 	.word	0x41333333
   2b938:	40833333 	.word	0x40833333
   2b93c:	3e0f5c29 	.word	0x3e0f5c29

0002b940 <tDattorroReverb_setMix>:
{
   2b940:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2b942:	6804      	ldr	r4, [r0, #0]
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2b944:	eef0 0a40 	vmov.f32	s1, s0
   2b948:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   2b94c:	ed9f 0a03 	vldr	s0, [pc, #12]	; 2b95c <tDattorroReverb_setMix+0x1c>
   2b950:	f7fd feea 	bl	29728 <LEAF_clip>
   2b954:	ed84 0a05 	vstr	s0, [r4, #20]
}
   2b958:	bd10      	pop	{r4, pc}
   2b95a:	bf00      	nop
   2b95c:	00000000 	.word	0x00000000

0002b960 <tDattorroReverb_setFreeze>:
{
   2b960:	b570      	push	{r4, r5, r6, lr}
    _tDattorroReverb* r = *rev;
   2b962:	6804      	ldr	r4, [r0, #0]
    r->frozen = freeze;
   2b964:	61a1      	str	r1, [r4, #24]
   2b966:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2b96a:	f104 0650 	add.w	r6, r4, #80	; 0x50
   2b96e:	f104 0568 	add.w	r5, r4, #104	; 0x68
   2b972:	3484      	adds	r4, #132	; 0x84
    if (freeze)
   2b974:	b9a1      	cbnz	r1, 2b9a0 <tDattorroReverb_setFreeze+0x40>
    	tAllpass_setGain(&r->f2_allpass, 0.7f);
   2b976:	ed9f 0a15 	vldr	s0, [pc, #84]	; 2b9cc <tDattorroReverb_setFreeze+0x6c>
   2b97a:	f7fc faf7 	bl	27f6c <tAllpass_setGain>
    	tAllpass_setGain(&r->f1_allpass, 0.7f);
   2b97e:	4630      	mov	r0, r6
   2b980:	ed9f 0a12 	vldr	s0, [pc, #72]	; 2b9cc <tDattorroReverb_setFreeze+0x6c>
   2b984:	f7fc faf2 	bl	27f6c <tAllpass_setGain>
    	tCycle_setFreq(&r->f1_lfo, 0.1f);
   2b988:	4628      	mov	r0, r5
   2b98a:	ed9f 0a11 	vldr	s0, [pc, #68]	; 2b9d0 <tDattorroReverb_setFreeze+0x70>
   2b98e:	f7fe fd7d 	bl	2a48c <tCycle_setFreq>
    	tCycle_setFreq(&r->f2_lfo, 0.07f);
   2b992:	4620      	mov	r0, r4
   2b994:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 2b9d4 <tDattorroReverb_setFreeze+0x74>
}
   2b998:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    	tCycle_setFreq(&r->f2_lfo, 0.07f);
   2b99c:	f7fe bd76 	b.w	2a48c <tCycle_setFreq>
    	tAllpass_setGain(&r->f2_allpass, 1.0f);
   2b9a0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2b9a4:	f7fc fae2 	bl	27f6c <tAllpass_setGain>
    	tAllpass_setGain(&r->f1_allpass, 1.0f);
   2b9a8:	4630      	mov	r0, r6
   2b9aa:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2b9ae:	f7fc fadd 	bl	27f6c <tAllpass_setGain>
    	tCycle_setFreq(&r->f1_lfo, 0.0f);
   2b9b2:	4628      	mov	r0, r5
   2b9b4:	ed9f 0a08 	vldr	s0, [pc, #32]	; 2b9d8 <tDattorroReverb_setFreeze+0x78>
   2b9b8:	f7fe fd68 	bl	2a48c <tCycle_setFreq>
    	tCycle_setFreq(&r->f2_lfo, 0.0f);
   2b9bc:	4620      	mov	r0, r4
   2b9be:	ed9f 0a06 	vldr	s0, [pc, #24]	; 2b9d8 <tDattorroReverb_setFreeze+0x78>
}
   2b9c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    	tCycle_setFreq(&r->f2_lfo, 0.0f);
   2b9c6:	f7fe bd61 	b.w	2a48c <tCycle_setFreq>
   2b9ca:	bf00      	nop
   2b9cc:	3f333333 	.word	0x3f333333
   2b9d0:	3dcccccd 	.word	0x3dcccccd
   2b9d4:	3d8f5c29 	.word	0x3d8f5c29
   2b9d8:	00000000 	.word	0x00000000

0002b9dc <tDattorroReverb_setHP>:
{
   2b9dc:	b510      	push	{r4, lr}
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
   2b9de:	eef0 0a40 	vmov.f32	s1, s0
   2b9e2:	ed9f 1a0c 	vldr	s2, [pc, #48]	; 2ba14 <tDattorroReverb_setHP+0x38>
   2b9e6:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
{
   2b9ea:	ed2d 8b02 	vpush	{d8}
    _tDattorroReverb* r = *rev;
   2b9ee:	6804      	ldr	r4, [r0, #0]
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
   2b9f0:	f7fd fe9a 	bl	29728 <LEAF_clip>
   2b9f4:	eeb0 8a40 	vmov.f32	s16, s0
    tHighpass_setFreq(&r->f1_hp, newFreq);
   2b9f8:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2b9fc:	f7fc fd32 	bl	28464 <tHighpass_setFreq>
    tHighpass_setFreq(&r->f2_hp, newFreq);
   2ba00:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2ba04:	eeb0 0a48 	vmov.f32	s0, s16
}
   2ba08:	ecbd 8b02 	vpop	{d8}
   2ba0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tHighpass_setFreq(&r->f2_hp, newFreq);
   2ba10:	f7fc bd28 	b.w	28464 <tHighpass_setFreq>
   2ba14:	469c4000 	.word	0x469c4000

0002ba18 <tDattorroReverb_setSize>:
{
   2ba18:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2ba1a:	6804      	ldr	r4, [r0, #0]
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
   2ba1c:	ed94 1a08 	vldr	s2, [r4, #32]
   2ba20:	ee61 0a00 	vmul.f32	s1, s2, s0
   2ba24:	ed9f 0a26 	vldr	s0, [pc, #152]	; 2bac0 <tDattorroReverb_setSize+0xa8>
   2ba28:	f7fd fe7e 	bl	29728 <LEAF_clip>
    r->t = r->size * leaf.sampleRate * 0.001f;
   2ba2c:	4b25      	ldr	r3, [pc, #148]	; (2bac4 <tDattorroReverb_setSize+0xac>)
   2ba2e:	eddf 6a26 	vldr	s13, [pc, #152]	; 2bac8 <tDattorroReverb_setSize+0xb0>
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2ba32:	f104 0054 	add.w	r0, r4, #84	; 0x54
    r->t = r->size * leaf.sampleRate * 0.001f;
   2ba36:	edd3 7a00 	vldr	s15, [r3]
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
   2ba3a:	ed84 0a07 	vstr	s0, [r4, #28]
    r->t = r->size * leaf.sampleRate * 0.001f;
   2ba3e:	ee67 7aa6 	vmul.f32	s15, s15, s13
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2ba42:	ed9f 7a22 	vldr	s14, [pc, #136]	; 2bacc <tDattorroReverb_setSize+0xb4>
    r->t = r->size * leaf.sampleRate * 0.001f;
   2ba46:	ee27 0a80 	vmul.f32	s0, s15, s0
   2ba4a:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2ba4e:	ee20 0a07 	vmul.f32	s0, s0, s14
   2ba52:	f7f9 fb65 	bl	25120 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f1_delay_2, SAMP(89.24f));
   2ba56:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2ba5a:	eddf 7a1d 	vldr	s15, [pc, #116]	; 2bad0 <tDattorroReverb_setSize+0xb8>
   2ba5e:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2ba62:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ba66:	f7f9 fb5b 	bl	25120 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f1_delay_3, SAMP(125.f));
   2ba6a:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2ba6e:	eddf 7a19 	vldr	s15, [pc, #100]	; 2bad4 <tDattorroReverb_setSize+0xbc>
   2ba72:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2ba76:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ba7a:	f7f9 fb51 	bl	25120 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_1, SAMP(149.62f));
   2ba7e:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2ba82:	eddf 7a15 	vldr	s15, [pc, #84]	; 2bad8 <tDattorroReverb_setSize+0xc0>
   2ba86:	f104 0070 	add.w	r0, r4, #112	; 0x70
   2ba8a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ba8e:	f7f9 fb47 	bl	25120 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_2, SAMP(60.48f));
   2ba92:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2ba96:	eddf 7a11 	vldr	s15, [pc, #68]	; 2badc <tDattorroReverb_setSize+0xc4>
   2ba9a:	f104 0078 	add.w	r0, r4, #120	; 0x78
   2ba9e:	ee20 0a27 	vmul.f32	s0, s0, s15
   2baa2:	f7f9 fb3d 	bl	25120 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_3, SAMP(106.28f));
   2baa6:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2baaa:	eddf 7a0d 	vldr	s15, [pc, #52]	; 2bae0 <tDattorroReverb_setSize+0xc8>
   2baae:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   2bab2:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   2bab6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tTapeDelay_setDelay(&r->f2_delay_3, SAMP(106.28f));
   2baba:	f7f9 bb31 	b.w	25120 <tTapeDelay_setDelay>
   2babe:	bf00      	nop
   2bac0:	3c23d70a 	.word	0x3c23d70a
   2bac4:	020fbd68 	.word	0x020fbd68
   2bac8:	3a83126f 	.word	0x3a83126f
   2bacc:	430db0a4 	.word	0x430db0a4
   2bad0:	42b27ae1 	.word	0x42b27ae1
   2bad4:	42fa0000 	.word	0x42fa0000
   2bad8:	43159eb8 	.word	0x43159eb8
   2badc:	4271eb85 	.word	0x4271eb85
   2bae0:	42d48f5c 	.word	0x42d48f5c

0002bae4 <tDattorroReverb_setInputFilter>:
{
   2bae4:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2bae6:	6804      	ldr	r4, [r0, #0]
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2bae8:	eef0 0a40 	vmov.f32	s1, s0
   2baec:	ed9f 1a06 	vldr	s2, [pc, #24]	; 2bb08 <tDattorroReverb_setInputFilter+0x24>
   2baf0:	ed9f 0a06 	vldr	s0, [pc, #24]	; 2bb0c <tDattorroReverb_setInputFilter+0x28>
   2baf4:	f7fd fe18 	bl	29728 <LEAF_clip>
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2baf8:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2bafc:	ed84 0a02 	vstr	s0, [r4, #8]
}
   2bb00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2bb04:	f7fc ba8a 	b.w	2801c <tOnePole_setFreq>
   2bb08:	469c4000 	.word	0x469c4000
   2bb0c:	00000000 	.word	0x00000000

0002bb10 <tDattorroReverb_setFeedbackFilter>:
{
   2bb10:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2bb12:	6804      	ldr	r4, [r0, #0]
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2bb14:	eef0 0a40 	vmov.f32	s1, s0
   2bb18:	ed9f 1a09 	vldr	s2, [pc, #36]	; 2bb40 <tDattorroReverb_setFeedbackFilter+0x30>
   2bb1c:	ed9f 0a09 	vldr	s0, [pc, #36]	; 2bb44 <tDattorroReverb_setFeedbackFilter+0x34>
   2bb20:	f7fd fe02 	bl	29728 <LEAF_clip>
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2bb24:	f104 0058 	add.w	r0, r4, #88	; 0x58
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2bb28:	ed84 0a03 	vstr	s0, [r4, #12]
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2bb2c:	f7fc fa76 	bl	2801c <tOnePole_setFreq>
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
   2bb30:	ed94 0a03 	vldr	s0, [r4, #12]
   2bb34:	f104 0074 	add.w	r0, r4, #116	; 0x74
}
   2bb38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
   2bb3c:	f7fc ba6e 	b.w	2801c <tOnePole_setFreq>
   2bb40:	469c4000 	.word	0x469c4000
   2bb44:	00000000 	.word	0x00000000

0002bb48 <tDattorroReverb_setFeedbackGain>:
    _tDattorroReverb* r = *rev;
   2bb48:	6803      	ldr	r3, [r0, #0]
    r->feedback_gain = gain;
   2bb4a:	ed83 0a04 	vstr	s0, [r3, #16]
}
   2bb4e:	4770      	bx	lr

0002bb50 <tBuffer_initToPool>:
{
    tBuffer_initToPool(sb, length, &leaf.mempool);
}

void  tBuffer_initToPool (tBuffer* const sb, uint32_t length, tMempool* const mp)
{
   2bb50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
   2bb52:	6815      	ldr	r5, [r2, #0]
{
   2bb54:	460e      	mov	r6, r1
   2bb56:	4607      	mov	r7, r0
    _tBuffer* s = *sb = (_tBuffer*) mpool_alloc(sizeof(_tBuffer), m);
   2bb58:	201c      	movs	r0, #28
   2bb5a:	4629      	mov	r1, r5
   2bb5c:	f7fd ffe4 	bl	29b28 <mpool_alloc>
   2bb60:	4604      	mov	r4, r0
    s->mempool = m;
    
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
   2bb62:	4629      	mov	r1, r5
   2bb64:	00b0      	lsls	r0, r6, #2
    _tBuffer* s = *sb = (_tBuffer*) mpool_alloc(sizeof(_tBuffer), m);
   2bb66:	603c      	str	r4, [r7, #0]
    s->mempool = m;
   2bb68:	6025      	str	r5, [r4, #0]
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
   2bb6a:	f7fd ffdd 	bl	29b28 <mpool_alloc>
    
    s->bufferLength = length;
    s->recordedLength = 0;
   2bb6e:	2300      	movs	r3, #0
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
   2bb70:	6060      	str	r0, [r4, #4]
    s->active = 0;
   2bb72:	61a3      	str	r3, [r4, #24]
    s->idx = 0;
   2bb74:	60a3      	str	r3, [r4, #8]
    s->mode = RecordOneShot;
   2bb76:	7523      	strb	r3, [r4, #20]
    s->recordedLength = 0;
   2bb78:	e9c4 6303 	strd	r6, r3, [r4, #12]
}
   2bb7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2bb7e:	bf00      	nop

0002bb80 <tBuffer_free>:

void  tBuffer_free (tBuffer* const sb)
{
   2bb80:	b510      	push	{r4, lr}
    _tBuffer* s = *sb;
   2bb82:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)s->buff, s->mempool);
   2bb84:	e9d4 1000 	ldrd	r1, r0, [r4]
   2bb88:	f7fe f876 	bl	29c78 <mpool_free>
    mpool_free((char*)s, s->mempool);
   2bb8c:	6821      	ldr	r1, [r4, #0]
   2bb8e:	4620      	mov	r0, r4
}
   2bb90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)s, s->mempool);
   2bb94:	f7fe b870 	b.w	29c78 <mpool_free>

0002bb98 <tBuffer_tick>:

void tBuffer_tick (tBuffer* const sb, float sample)
{
    _tBuffer* s = *sb;
   2bb98:	6803      	ldr	r3, [r0, #0]
    
    if (s->active == 1)
   2bb9a:	699a      	ldr	r2, [r3, #24]
   2bb9c:	2a01      	cmp	r2, #1
   2bb9e:	d000      	beq.n	2bba2 <tBuffer_tick+0xa>
                s->idx = 0;
            }
        }
        s->recordedLength = s->idx;
    }
}
   2bba0:	4770      	bx	lr
        s->buff[s->idx] = sample;
   2bba2:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   2bba6:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   2bbaa:	ed82 0a00 	vstr	s0, [r2]
        if (s->idx >= s->bufferLength)
   2bbae:	e9d3 2102 	ldrd	r2, r1, [r3, #8]
        s->idx += 1;
   2bbb2:	3201      	adds	r2, #1
        if (s->idx >= s->bufferLength)
   2bbb4:	428a      	cmp	r2, r1
        s->idx += 1;
   2bbb6:	609a      	str	r2, [r3, #8]
        if (s->idx >= s->bufferLength)
   2bbb8:	d304      	bcc.n	2bbc4 <tBuffer_tick+0x2c>
            if (s->mode == RecordOneShot)
   2bbba:	7d19      	ldrb	r1, [r3, #20]
   2bbbc:	b921      	cbnz	r1, 2bbc8 <tBuffer_tick+0x30>
    s->idx = 0;
}

void  tBuffer_stop(tBuffer* const sb)
{
    _tBuffer* s = *sb;
   2bbbe:	6802      	ldr	r2, [r0, #0]
    s->active = 0;
   2bbc0:	6191      	str	r1, [r2, #24]
   2bbc2:	689a      	ldr	r2, [r3, #8]
        s->recordedLength = s->idx;
   2bbc4:	611a      	str	r2, [r3, #16]
}
   2bbc6:	4770      	bx	lr
            else if (s->mode == RecordLoop)
   2bbc8:	2901      	cmp	r1, #1
   2bbca:	d1fb      	bne.n	2bbc4 <tBuffer_tick+0x2c>
                s->idx = 0;
   2bbcc:	2100      	movs	r1, #0
   2bbce:	460a      	mov	r2, r1
   2bbd0:	6099      	str	r1, [r3, #8]
   2bbd2:	e7f7      	b.n	2bbc4 <tBuffer_tick+0x2c>

0002bbd4 <tBuffer_get>:
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
   2bbd4:	2900      	cmp	r1, #0
   2bbd6:	db09      	blt.n	2bbec <tBuffer_get+0x18>
    _tBuffer* s = *sb;
   2bbd8:	6803      	ldr	r3, [r0, #0]
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
   2bbda:	68da      	ldr	r2, [r3, #12]
   2bbdc:	428a      	cmp	r2, r1
   2bbde:	d905      	bls.n	2bbec <tBuffer_get+0x18>
    return s->buff[idx];
   2bbe0:	685b      	ldr	r3, [r3, #4]
   2bbe2:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   2bbe6:	ed91 0a00 	vldr	s0, [r1]
   2bbea:	4770      	bx	lr
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
   2bbec:	ed9f 0a01 	vldr	s0, [pc, #4]	; 2bbf4 <tBuffer_get+0x20>
}
   2bbf0:	4770      	bx	lr
   2bbf2:	bf00      	nop
   2bbf4:	00000000 	.word	0x00000000

0002bbf8 <tBuffer_record>:
    _tBuffer* s = *sb;
   2bbf8:	6803      	ldr	r3, [r0, #0]
    s->active = 1;
   2bbfa:	2101      	movs	r1, #1
    s->idx = 0;
   2bbfc:	2200      	movs	r2, #0
    s->active = 1;
   2bbfe:	6199      	str	r1, [r3, #24]
    s->idx = 0;
   2bc00:	609a      	str	r2, [r3, #8]
}
   2bc02:	4770      	bx	lr

0002bc04 <tBuffer_stop>:
    _tBuffer* s = *sb;
   2bc04:	6803      	ldr	r3, [r0, #0]
    s->active = 0;
   2bc06:	2200      	movs	r2, #0
   2bc08:	619a      	str	r2, [r3, #24]
}
   2bc0a:	4770      	bx	lr

0002bc0c <tBuffer_getRecordPosition>:

int   tBuffer_getRecordPosition(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->idx;
   2bc0c:	6803      	ldr	r3, [r0, #0]
}
   2bc0e:	6898      	ldr	r0, [r3, #8]
   2bc10:	4770      	bx	lr
   2bc12:	bf00      	nop

0002bc14 <tBuffer_setRecordPosition>:

void   tBuffer_setRecordPosition(tBuffer* const sb, int pos)
{
    _tBuffer* s = *sb;
   2bc14:	6803      	ldr	r3, [r0, #0]
    s->idx = pos;
   2bc16:	6099      	str	r1, [r3, #8]
}
   2bc18:	4770      	bx	lr
   2bc1a:	bf00      	nop

0002bc1c <tBuffer_setRecordMode>:

void  tBuffer_setRecordMode (tBuffer* const sb, RecordMode mode)
{
    _tBuffer* s = *sb;
   2bc1c:	6803      	ldr	r3, [r0, #0]
    s->mode = mode;
   2bc1e:	7519      	strb	r1, [r3, #20]
}
   2bc20:	4770      	bx	lr
   2bc22:	bf00      	nop

0002bc24 <tBuffer_getRecordedLength>:
}

uint32_t tBuffer_getRecordedLength(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->recordedLength;
   2bc24:	6803      	ldr	r3, [r0, #0]
}
   2bc26:	6918      	ldr	r0, [r3, #16]
   2bc28:	4770      	bx	lr
   2bc2a:	bf00      	nop

0002bc2c <tBuffer_setRecordedLength>:

void tBuffer_setRecordedLength(tBuffer* const sb, int length)
{
    _tBuffer* s = *sb;
   2bc2c:	6803      	ldr	r3, [r0, #0]
    s->recordedLength = length;
   2bc2e:	6119      	str	r1, [r3, #16]
}
   2bc30:	4770      	bx	lr
   2bc32:	bf00      	nop

0002bc34 <tBuffer_isActive>:

int tBuffer_isActive(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->active;
   2bc34:	6803      	ldr	r3, [r0, #0]
}
   2bc36:	6998      	ldr	r0, [r3, #24]
   2bc38:	4770      	bx	lr
   2bc3a:	bf00      	nop

0002bc3c <tSampler_init>:
static void handleStartEndChange(tSampler* const sp);

static void attemptStartEndChange(tSampler* const sp);

void tSampler_init(tSampler* const sp, tBuffer* const b)
{
   2bc3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tSampler_initToPool(sp, b, &leaf.mempool);
}

void tSampler_initToPool(tSampler* const sp, tBuffer* const b, tMempool* const mp)
{
    _tMempool* m = *mp;
   2bc40:	4e23      	ldr	r6, [pc, #140]	; (2bcd0 <tSampler_init+0x94>)
{
   2bc42:	4681      	mov	r9, r0
   2bc44:	4688      	mov	r8, r1
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2bc46:	2054      	movs	r0, #84	; 0x54
    
    _tBuffer* s = *b;
    
    p->samp = s;
    
    p->active = 0;
   2bc48:	2500      	movs	r5, #0
{
   2bc4a:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2bc4e:	f856 7f18 	ldr.w	r7, [r6, #24]!
    p->start = 0;
    p->end = 0;
    
    p->len = p->end - p->start;
    
    p->idx = 0.f;
   2bc52:	ed9f 8a20 	vldr	s16, [pc, #128]	; 2bcd4 <tSampler_init+0x98>
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2bc56:	4639      	mov	r1, r7
   2bc58:	f7fd ff66 	bl	29b28 <mpool_alloc>
   2bc5c:	4604      	mov	r4, r0
   2bc5e:	f8c9 0000 	str.w	r0, [r9]
    
    p->mode = PlayNormal;
    
    p->cfxlen = 500; // default 300 sample crossfade
    
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bc62:	4632      	mov	r2, r6
    p->mempool = m;
   2bc64:	6007      	str	r7, [r0, #0]
    p->inc = 1.f;
   2bc66:	f04f 5e7e 	mov.w	lr, #1065353216	; 0x3f800000
    _tBuffer* s = *b;
   2bc6a:	f8d8 3000 	ldr.w	r3, [r8]
    p->iinc = 1.f;
   2bc6e:	f04f 5c7e 	mov.w	ip, #1065353216	; 0x3f800000
   2bc72:	f240 1001 	movw	r0, #257	; 0x101
    p->cfxlen = 500; // default 300 sample crossfade
   2bc76:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bc7a:	f104 0608 	add.w	r6, r4, #8
    p->samp = s;
   2bc7e:	6063      	str	r3, [r4, #4]
    p->flip = 1;
   2bc80:	2301      	movs	r3, #1
    p->inc = 1.f;
   2bc82:	f8c4 e010 	str.w	lr, [r4, #16]
    p->iinc = 1.f;
   2bc86:	f8c4 c018 	str.w	ip, [r4, #24]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bc8a:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
    p->flip = 1;
   2bc8e:	77a3      	strb	r3, [r4, #30]
    p->iinc = 1.f;
   2bc90:	83a0      	strh	r0, [r4, #28]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bc92:	4630      	mov	r0, r6
    p->cfxlen = 500; // default 300 sample crossfade
   2bc94:	6361      	str	r1, [r4, #52]	; 0x34
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bc96:	4619      	mov	r1, r3
    p->idx = 0.f;
   2bc98:	ed84 8a03 	vstr	s16, [r4, #12]
    p->active = 0;
   2bc9c:	6465      	str	r5, [r4, #68]	; 0x44
    p->start = 0;
   2bc9e:	6225      	str	r5, [r4, #32]
    p->end = 0;
   2bca0:	62a5      	str	r5, [r4, #40]	; 0x28
    p->len = p->end - p->start;
   2bca2:	6325      	str	r5, [r4, #48]	; 0x30
    p->mode = PlayNormal;
   2bca4:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bca8:	f7fb ffc4 	bl	27c34 <tRamp_initToPool>
    tRamp_setVal(&p->gain, 0.f);
   2bcac:	eeb0 0a48 	vmov.f32	s0, s16
   2bcb0:	4630      	mov	r0, r6
   2bcb2:	f7fc f805 	bl	27cc0 <tRamp_setVal>
    
    p->targetstart = -1;
    p->targetend = -1;
    
    p->inCrossfade = 0;
    p->flipStart = -1;
   2bcb6:	4b08      	ldr	r3, [pc, #32]	; (2bcd8 <tSampler_init+0x9c>)
    p->targetstart = -1;
   2bcb8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    p->inCrossfade = 0;
   2bcbc:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
    p->flipStart = -1;
   2bcc0:	64e3      	str	r3, [r4, #76]	; 0x4c
    p->targetstart = -1;
   2bcc2:	6262      	str	r2, [r4, #36]	; 0x24
    p->targetend = -1;
   2bcc4:	62e2      	str	r2, [r4, #44]	; 0x2c
    p->flipIdx = -1;
   2bcc6:	6523      	str	r3, [r4, #80]	; 0x50
}
   2bcc8:	ecbd 8b02 	vpop	{d8}
   2bccc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2bcd0:	020fbd68 	.word	0x020fbd68
   2bcd4:	00000000 	.word	0x00000000
   2bcd8:	bf800000 	.word	0xbf800000

0002bcdc <tSampler_initToPool>:
{
   2bcdc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2bce0:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2bce4:	6816      	ldr	r6, [r2, #0]
{
   2bce6:	4681      	mov	r9, r0
   2bce8:	4688      	mov	r8, r1
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2bcea:	2054      	movs	r0, #84	; 0x54
   2bcec:	4631      	mov	r1, r6
{
   2bcee:	4617      	mov	r7, r2
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2bcf0:	f7fd ff1a 	bl	29b28 <mpool_alloc>
   2bcf4:	4604      	mov	r4, r0
   2bcf6:	f8c9 0000 	str.w	r0, [r9]
    p->active = 0;
   2bcfa:	2500      	movs	r5, #0
    p->mempool = m;
   2bcfc:	6006      	str	r6, [r0, #0]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bcfe:	463a      	mov	r2, r7
    _tBuffer* s = *b;
   2bd00:	f8d8 3000 	ldr.w	r3, [r8]
    p->inc = 1.f;
   2bd04:	f04f 5c7e 	mov.w	ip, #1065353216	; 0x3f800000
    p->idx = 0.f;
   2bd08:	ed9f 8a18 	vldr	s16, [pc, #96]	; 2bd6c <tSampler_initToPool+0x90>
    p->iinc = 1.f;
   2bd0c:	f240 1001 	movw	r0, #257	; 0x101
    p->cfxlen = 500; // default 300 sample crossfade
   2bd10:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bd14:	f104 0608 	add.w	r6, r4, #8
    p->samp = s;
   2bd18:	6063      	str	r3, [r4, #4]
    p->iinc = 1.f;
   2bd1a:	f04f 577e 	mov.w	r7, #1065353216	; 0x3f800000
    p->flip = 1;
   2bd1e:	2301      	movs	r3, #1
    p->inc = 1.f;
   2bd20:	f8c4 c010 	str.w	ip, [r4, #16]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bd24:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
    p->iinc = 1.f;
   2bd28:	83a0      	strh	r0, [r4, #28]
    p->flip = 1;
   2bd2a:	77a3      	strb	r3, [r4, #30]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bd2c:	4630      	mov	r0, r6
    p->cfxlen = 500; // default 300 sample crossfade
   2bd2e:	6361      	str	r1, [r4, #52]	; 0x34
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bd30:	4619      	mov	r1, r3
    p->idx = 0.f;
   2bd32:	ed84 8a03 	vstr	s16, [r4, #12]
    p->iinc = 1.f;
   2bd36:	61a7      	str	r7, [r4, #24]
    p->active = 0;
   2bd38:	6465      	str	r5, [r4, #68]	; 0x44
    p->start = 0;
   2bd3a:	6225      	str	r5, [r4, #32]
    p->end = 0;
   2bd3c:	62a5      	str	r5, [r4, #40]	; 0x28
    p->len = p->end - p->start;
   2bd3e:	6325      	str	r5, [r4, #48]	; 0x30
    p->mode = PlayNormal;
   2bd40:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bd44:	f7fb ff76 	bl	27c34 <tRamp_initToPool>
    tRamp_setVal(&p->gain, 0.f);
   2bd48:	eeb0 0a48 	vmov.f32	s0, s16
   2bd4c:	4630      	mov	r0, r6
   2bd4e:	f7fb ffb7 	bl	27cc0 <tRamp_setVal>
    p->flipStart = -1;
   2bd52:	4b07      	ldr	r3, [pc, #28]	; (2bd70 <tSampler_initToPool+0x94>)
    p->targetstart = -1;
   2bd54:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    p->inCrossfade = 0;
   2bd58:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
    p->flipStart = -1;
   2bd5c:	64e3      	str	r3, [r4, #76]	; 0x4c
    p->targetstart = -1;
   2bd5e:	6262      	str	r2, [r4, #36]	; 0x24
    p->targetend = -1;
   2bd60:	62e2      	str	r2, [r4, #44]	; 0x2c
    p->flipIdx = -1;
   2bd62:	6523      	str	r3, [r4, #80]	; 0x50
}
   2bd64:	ecbd 8b02 	vpop	{d8}
   2bd68:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2bd6c:	00000000 	.word	0x00000000
   2bd70:	bf800000 	.word	0xbf800000

0002bd74 <tSampler_free>:

void tSampler_free (tSampler* const sp)
{
   2bd74:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
   2bd76:	6804      	ldr	r4, [r0, #0]
    tRamp_free(&p->gain);
   2bd78:	f104 0008 	add.w	r0, r4, #8
   2bd7c:	f7fb ff8e 	bl	27c9c <tRamp_free>
    
    mpool_free((char*)p, p->mempool);
   2bd80:	6821      	ldr	r1, [r4, #0]
   2bd82:	4620      	mov	r0, r4
}
   2bd84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
   2bd88:	f7fd bf76 	b.w	29c78 <mpool_free>

0002bd8c <tSampler_setMode>:
    return p->last;
}

void tSampler_setMode      (tSampler* const sp, PlayMode mode)
{
    _tSampler* p = *sp;
   2bd8c:	6803      	ldr	r3, [r0, #0]
    p->mode = mode;
   2bd8e:	f883 103c 	strb.w	r1, [r3, #60]	; 0x3c
}
   2bd92:	4770      	bx	lr

0002bd94 <tSampler_setCrossfadeLength>:

void tSampler_setCrossfadeLength  (tSampler* const sp, uint32_t length)
{
   2bd94:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
   2bd96:	6804      	ldr	r4, [r0, #0]
    
    uint32_t cfxlen = LEAF_clip(0, length, p->len * 0.25f);
   2bd98:	ee07 1a90 	vmov	s15, r1
   2bd9c:	ed9f 0a07 	vldr	s0, [pc, #28]	; 2bdbc <tSampler_setCrossfadeLength+0x28>
   2bda0:	ed94 1a0c 	vldr	s2, [r4, #48]	; 0x30
   2bda4:	eef8 0a67 	vcvt.f32.u32	s1, s15
   2bda8:	eebb 1acf 	vcvt.f32.u32	s2, s2, #2
   2bdac:	f7fd fcbc 	bl	29728 <LEAF_clip>
   2bdb0:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   2bdb4:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    
    p->cfxlen = cfxlen;
}
   2bdb8:	bd10      	pop	{r4, pc}
   2bdba:	bf00      	nop
   2bdbc:	00000000 	.word	0x00000000

0002bdc0 <tSampler_play>:

void tSampler_play         (tSampler* const sp)
{
   2bdc0:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
   2bdc2:	6804      	ldr	r4, [r0, #0]
    
    if (p->active != 0)
   2bdc4:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2bdc6:	f104 0008 	add.w	r0, r4, #8
   2bdca:	bb93      	cbnz	r3, 2be32 <tSampler_play+0x72>
        
        tRamp_setDest(&p->gain, 0.f);
    }
    else
    {
        p->active = 1;
   2bdcc:	2201      	movs	r2, #1
        p->retrigger = 0;
   2bdce:	6423      	str	r3, [r4, #64]	; 0x40
        
        tRamp_setDest(&p->gain, 1.f);
   2bdd0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
        p->active = 1;
   2bdd4:	6462      	str	r2, [r4, #68]	; 0x44
        tRamp_setDest(&p->gain, 1.f);
   2bdd6:	f7fb ff65 	bl	27ca4 <tRamp_setDest>
        
        if (p->dir > 0)
   2bdda:	f994 301c 	ldrsb.w	r3, [r4, #28]
   2bdde:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   2bde0:	2b00      	cmp	r3, #0
   2bde2:	6a22      	ldr	r2, [r4, #32]
        {
            if (p->flip > 0)    p->idx = p->start;
   2bde4:	f994 301d 	ldrsb.w	r3, [r4, #29]
        if (p->dir > 0)
   2bde8:	dd2e      	ble.n	2be48 <tSampler_play+0x88>
            if (p->flip > 0)    p->idx = p->start;
   2bdea:	2b00      	cmp	r3, #0
   2bdec:	dd2e      	ble.n	2be4c <tSampler_play+0x8c>
            else                p->idx = p->end;
        }
        else
        {
            if (p->flip > 0)    p->idx = p->end;
            else                p->idx = p->start;
   2bdee:	ee07 2a90 	vmov	s15, r2
   2bdf2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2bdf6:	edc4 7a03 	vstr	s15, [r4, #12]

static void handleStartEndChange(tSampler* const sp)
{
    _tSampler* p = *sp;
    
    p->len = abs(p->end - p->start);
   2bdfa:	1a8b      	subs	r3, r1, r2
    
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2bdfc:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2be00:	2b00      	cmp	r3, #0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2be02:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2be06:	bfb8      	it	lt
   2be08:	425b      	neglt	r3, r3
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2be0a:	ee07 3a10 	vmov	s14, r3
    p->len = abs(p->end - p->start);
   2be0e:	6323      	str	r3, [r4, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2be10:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2be14:	eef4 7ac7 	vcmpe.f32	s15, s14
   2be18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2be1c:	dd03      	ble.n	2be26 <tSampler_play+0x66>
   2be1e:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2be22:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
    
    if (p->start > p->end)
   2be26:	4291      	cmp	r1, r2
    {
        p->flip = -1;
   2be28:	bfb4      	ite	lt
   2be2a:	23ff      	movlt	r3, #255	; 0xff
    }
    else
    {
        p->flip = 1;
   2be2c:	2301      	movge	r3, #1
   2be2e:	7763      	strb	r3, [r4, #29]
}
   2be30:	bd10      	pop	{r4, pc}
        p->active = -1;
   2be32:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
        p->retrigger = 1;
   2be36:	2301      	movs	r3, #1
        tRamp_setDest(&p->gain, 0.f);
   2be38:	ed9f 0a08 	vldr	s0, [pc, #32]	; 2be5c <tSampler_play+0x9c>
        p->retrigger = 1;
   2be3c:	e9c4 3210 	strd	r3, r2, [r4, #64]	; 0x40
}
   2be40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        tRamp_setDest(&p->gain, 0.f);
   2be44:	f7fb bf2e 	b.w	27ca4 <tRamp_setDest>
            if (p->flip > 0)    p->idx = p->end;
   2be48:	2b00      	cmp	r3, #0
   2be4a:	ddd0      	ble.n	2bdee <tSampler_play+0x2e>
   2be4c:	ee07 1a90 	vmov	s15, r1
   2be50:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2be54:	edc4 7a03 	vstr	s15, [r4, #12]
   2be58:	e7cf      	b.n	2bdfa <tSampler_play+0x3a>
   2be5a:	bf00      	nop
   2be5c:	00000000 	.word	0x00000000

0002be60 <tSampler_stop>:
    _tSampler* p = *sp;
   2be60:	6800      	ldr	r0, [r0, #0]
    p->active = -1;
   2be62:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    tRamp_setDest(&p->gain, 0.f);
   2be66:	ed9f 0a03 	vldr	s0, [pc, #12]	; 2be74 <tSampler_stop+0x14>
    p->active = -1;
   2be6a:	6443      	str	r3, [r0, #68]	; 0x44
    tRamp_setDest(&p->gain, 0.f);
   2be6c:	3008      	adds	r0, #8
   2be6e:	f7fb bf19 	b.w	27ca4 <tRamp_setDest>
   2be72:	bf00      	nop
   2be74:	00000000 	.word	0x00000000

0002be78 <tSampler_setStart>:
        tSampler_setEnd(sp, p->targetend);
    }
}

void tSampler_setStart     (tSampler* const sp, int32_t start)
{
   2be78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
   2be7a:	6804      	ldr	r4, [r0, #0]
    if (start == p->end)
    {
        return;
    }
    */
    if (p->active) // only bother with these checks if we're actually playing
   2be7c:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2be7e:	2b00      	cmp	r3, #0
   2be80:	d042      	beq.n	2bf08 <tSampler_setStart+0x90>
    {
        if (start > p->end)
   2be82:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2be84:	428b      	cmp	r3, r1
   2be86:	db1d      	blt.n	2bec4 <tSampler_setStart+0x4c>
   2be88:	2501      	movs	r5, #1
   2be8a:	2700      	movs	r7, #0
        {
            tempflip = -1;
        }
        else
        {
            tempflip = 1;
   2be8c:	462e      	mov	r6, r5
        }
        
        int dir = p->bnf * p->dir * tempflip;
        
        uint32_t cfxlen = p->cfxlen;
   2be8e:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2be92:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2be96:	eef8 6a47 	vcvt.f32.u32	s13, s14
        
        if (p->inCrossfade || p->flipStart >= 0)
   2be9a:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2be9e:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
   2bea2:	eef4 7ae6 	vcmpe.f32	s15, s13
   2bea6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2beaa:	bf48      	it	mi
   2beac:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
   2beb0:	b932      	cbnz	r2, 2bec0 <tSampler_setStart+0x48>
   2beb2:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2beb6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2beba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2bebe:	db06      	blt.n	2bece <tSampler_setStart+0x56>
        }
    }
    
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
    handleStartEndChange(sp);
    p->targetstart = -1;
   2bec0:	6261      	str	r1, [r4, #36]	; 0x24
    
}
   2bec2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (start > p->end)
   2bec4:	2701      	movs	r7, #1
   2bec6:	2500      	movs	r5, #0
            tempflip = -1;
   2bec8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2becc:	e7df      	b.n	2be8e <tSampler_setStart+0x16>
        int dir = p->bnf * p->dir * tempflip;
   2bece:	f994 201e 	ldrsb.w	r2, [r4, #30]
   2bed2:	f994 c01c 	ldrsb.w	ip, [r4, #28]
   2bed6:	fb12 f20c 	smulbb	r2, r2, ip
   2beda:	fb06 f202 	mul.w	r2, r6, r2
        if ((tempflip > 0) && (dir > 0)) // start is start and we're playing forward
   2bede:	2a00      	cmp	r2, #0
   2bee0:	dd3c      	ble.n	2bf5c <tSampler_setStart+0xe4>
   2bee2:	2d00      	cmp	r5, #0
   2bee4:	d03a      	beq.n	2bf5c <tSampler_setStart+0xe4>
            if (start > p->idx)// start given is after current index or we're in a crossfade
   2bee6:	ee07 1a90 	vmov	s15, r1
   2beea:	edd4 6a03 	vldr	s13, [r4, #12]
   2beee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2bef2:	eef4 7ae6 	vcmpe.f32	s15, s13
   2bef6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2befa:	dc3e      	bgt.n	2bf7a <tSampler_setStart+0x102>
        if (tempflip != p->flip && p->flipStart < 0)
   2befc:	f994 301d 	ldrsb.w	r3, [r4, #29]
   2bf00:	42b3      	cmp	r3, r6
   2bf02:	d001      	beq.n	2bf08 <tSampler_setStart+0x90>
            p->flipIdx = 0;
   2bf04:	2300      	movs	r3, #0
   2bf06:	6523      	str	r3, [r4, #80]	; 0x50
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
   2bf08:	6863      	ldr	r3, [r4, #4]
   2bf0a:	4605      	mov	r5, r0
   2bf0c:	2000      	movs	r0, #0
   2bf0e:	691a      	ldr	r2, [r3, #16]
   2bf10:	3a01      	subs	r2, #1
   2bf12:	f7fd fc1d 	bl	29750 <LEAF_clipInt>
   2bf16:	6220      	str	r0, [r4, #32]
    handleStartEndChange(sp);
   2bf18:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   2bf1a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2bf1c:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2bf1e:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2bf22:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2bf24:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2bf28:	2900      	cmp	r1, #0
   2bf2a:	bfb8      	it	lt
   2bf2c:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2bf2e:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   2bf32:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2bf34:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2bf38:	eef4 7ac7 	vcmpe.f32	s15, s14
   2bf3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2bf40:	dd03      	ble.n	2bf4a <tSampler_setStart+0xd2>
   2bf42:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2bf46:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
   2bf4a:	4282      	cmp	r2, r0
   2bf4c:	bfac      	ite	ge
   2bf4e:	2201      	movge	r2, #1
   2bf50:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetstart = -1;
   2bf54:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2bf58:	775a      	strb	r2, [r3, #29]
   2bf5a:	e7b1      	b.n	2bec0 <tSampler_setStart+0x48>
        else if ((tempflip < 0) && (dir < 0)) // start is end and we're playing in reverse
   2bf5c:	2a00      	cmp	r2, #0
   2bf5e:	dacd      	bge.n	2befc <tSampler_setStart+0x84>
   2bf60:	2f00      	cmp	r7, #0
   2bf62:	d0cb      	beq.n	2befc <tSampler_setStart+0x84>
            if (start < p->idx)// start given is before current index or we're in a crossfade
   2bf64:	ee07 1a90 	vmov	s15, r1
   2bf68:	edd4 6a03 	vldr	s13, [r4, #12]
   2bf6c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2bf70:	eef4 7ae6 	vcmpe.f32	s15, s13
   2bf74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2bf78:	d5c0      	bpl.n	2befc <tSampler_setStart+0x84>
                float tempLen = abs(p->end - start) * 0.25f;
   2bf7a:	1a5b      	subs	r3, r3, r1
                if (cfxlen > tempLen)
   2bf7c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetstart = start;
   2bf80:	6261      	str	r1, [r4, #36]	; 0x24
                float tempLen = abs(p->end - start) * 0.25f;
   2bf82:	2b00      	cmp	r3, #0
   2bf84:	bfb8      	it	lt
   2bf86:	425b      	neglt	r3, r3
   2bf88:	ee07 3a90 	vmov	s15, r3
   2bf8c:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
   2bf90:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2bf94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2bf98:	dd93      	ble.n	2bec2 <tSampler_setStart+0x4a>
                    p->cfxlen = tempLen;
   2bf9a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2bf9e:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
   2bfa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002bfa4 <tSampler_setEnd>:

void tSampler_setEnd       (tSampler* const sp, int32_t end)
{
   2bfa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
   2bfa6:	6804      	ldr	r4, [r0, #0]
    if (end == p->start)
    {
        return;
    }
    */
    if (p->active) // only bother with these checks if we're actually playing
   2bfa8:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2bfaa:	2b00      	cmp	r3, #0
   2bfac:	d042      	beq.n	2c034 <tSampler_setEnd+0x90>
    {
        if (p->start > end)
   2bfae:	6a23      	ldr	r3, [r4, #32]
   2bfb0:	428b      	cmp	r3, r1
   2bfb2:	dc1d      	bgt.n	2bff0 <tSampler_setEnd+0x4c>
   2bfb4:	2501      	movs	r5, #1
   2bfb6:	2700      	movs	r7, #0
        {
            tempflip = -1;
        }
        else
        {
            tempflip = 1;
   2bfb8:	462e      	mov	r6, r5
        }
        
        int dir = p->bnf * p->dir * tempflip;
        
        uint32_t cfxlen = p->cfxlen;
   2bfba:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2bfbe:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2bfc2:	eef8 6a47 	vcvt.f32.u32	s13, s14
        
        if (p->inCrossfade || p->flipStart >= 0)
   2bfc6:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2bfca:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
   2bfce:	eef4 7ae6 	vcmpe.f32	s15, s13
   2bfd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2bfd6:	bf48      	it	mi
   2bfd8:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
   2bfdc:	b932      	cbnz	r2, 2bfec <tSampler_setEnd+0x48>
   2bfde:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2bfe2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2bfe6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2bfea:	db06      	blt.n	2bffa <tSampler_setEnd+0x56>
        }
    }
    
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
    handleStartEndChange(sp);
    p->targetend = -1;
   2bfec:	62e1      	str	r1, [r4, #44]	; 0x2c
}
   2bfee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (p->start > end)
   2bff0:	2701      	movs	r7, #1
   2bff2:	2500      	movs	r5, #0
            tempflip = -1;
   2bff4:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2bff8:	e7df      	b.n	2bfba <tSampler_setEnd+0x16>
        int dir = p->bnf * p->dir * tempflip;
   2bffa:	f994 201e 	ldrsb.w	r2, [r4, #30]
   2bffe:	f994 c01c 	ldrsb.w	ip, [r4, #28]
   2c002:	fb12 f20c 	smulbb	r2, r2, ip
   2c006:	fb06 f202 	mul.w	r2, r6, r2
        if (tempflip > 0 && dir < 0) // end is end and we're playing in reverse
   2c00a:	2a00      	cmp	r2, #0
   2c00c:	da3c      	bge.n	2c088 <tSampler_setEnd+0xe4>
   2c00e:	2d00      	cmp	r5, #0
   2c010:	d03a      	beq.n	2c088 <tSampler_setEnd+0xe4>
            if (end < p->idx) // end given is before current index or we're in a crossfade
   2c012:	ee07 1a90 	vmov	s15, r1
   2c016:	edd4 6a03 	vldr	s13, [r4, #12]
   2c01a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c01e:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c022:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c026:	d43e      	bmi.n	2c0a6 <tSampler_setEnd+0x102>
        if (tempflip != p->flip && p->flipStart < 0)
   2c028:	f994 301d 	ldrsb.w	r3, [r4, #29]
   2c02c:	42b3      	cmp	r3, r6
   2c02e:	d001      	beq.n	2c034 <tSampler_setEnd+0x90>
            p->flipIdx = 0;
   2c030:	2300      	movs	r3, #0
   2c032:	6523      	str	r3, [r4, #80]	; 0x50
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
   2c034:	6863      	ldr	r3, [r4, #4]
   2c036:	4605      	mov	r5, r0
   2c038:	2000      	movs	r0, #0
   2c03a:	691a      	ldr	r2, [r3, #16]
   2c03c:	3a01      	subs	r2, #1
   2c03e:	f7fd fb87 	bl	29750 <LEAF_clipInt>
   2c042:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
   2c044:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   2c046:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2c048:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c04a:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2c04e:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c050:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2c054:	2900      	cmp	r1, #0
   2c056:	bfb8      	it	lt
   2c058:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c05a:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   2c05e:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c060:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2c064:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c068:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c06c:	dd03      	ble.n	2c076 <tSampler_setEnd+0xd2>
   2c06e:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2c072:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
   2c076:	4282      	cmp	r2, r0
   2c078:	bfac      	ite	ge
   2c07a:	2201      	movge	r2, #1
   2c07c:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetend = -1;
   2c080:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2c084:	775a      	strb	r2, [r3, #29]
   2c086:	e7b1      	b.n	2bfec <tSampler_setEnd+0x48>
        else if (tempflip < 0 && dir > 0) // end is start and we're playing forward
   2c088:	2a00      	cmp	r2, #0
   2c08a:	ddcd      	ble.n	2c028 <tSampler_setEnd+0x84>
   2c08c:	2f00      	cmp	r7, #0
   2c08e:	d0cb      	beq.n	2c028 <tSampler_setEnd+0x84>
            if (end > p->idx) // end given is after current index or we're in a crossfade
   2c090:	ee07 1a90 	vmov	s15, r1
   2c094:	edd4 6a03 	vldr	s13, [r4, #12]
   2c098:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c09c:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c0a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c0a4:	ddc0      	ble.n	2c028 <tSampler_setEnd+0x84>
                float tempLen = abs(end - p->start) * 0.25f;
   2c0a6:	1acb      	subs	r3, r1, r3
                if (cfxlen > tempLen)
   2c0a8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetend = end;
   2c0ac:	62e1      	str	r1, [r4, #44]	; 0x2c
                float tempLen = abs(end - p->start) * 0.25f;
   2c0ae:	2b00      	cmp	r3, #0
   2c0b0:	bfb8      	it	lt
   2c0b2:	425b      	neglt	r3, r3
   2c0b4:	ee07 3a90 	vmov	s15, r3
   2c0b8:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
   2c0bc:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2c0c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c0c4:	dd93      	ble.n	2bfee <tSampler_setEnd+0x4a>
                    p->cfxlen = tempLen;
   2c0c6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2c0ca:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
   2c0ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002c0d0 <tSampler_tick>:
{
   2c0d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2c0d4:	ed2d 8b04 	vpush	{d8-d9}
    _tSampler* p = *sp;
   2c0d8:	6804      	ldr	r4, [r0, #0]
{
   2c0da:	b087      	sub	sp, #28
   2c0dc:	4605      	mov	r5, r0
    if (p->targetstart >= 0)
   2c0de:	6a61      	ldr	r1, [r4, #36]	; 0x24
   2c0e0:	2900      	cmp	r1, #0
   2c0e2:	db01      	blt.n	2c0e8 <tSampler_tick+0x18>
        tSampler_setStart(sp, p->targetstart);
   2c0e4:	f7ff fec8 	bl	2be78 <tSampler_setStart>
    if (p->targetend >= 0)
   2c0e8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   2c0ea:	2900      	cmp	r1, #0
   2c0ec:	db02      	blt.n	2c0f4 <tSampler_tick+0x24>
        tSampler_setEnd(sp, p->targetend);
   2c0ee:	4628      	mov	r0, r5
   2c0f0:	f7ff ff58 	bl	2bfa4 <tSampler_setEnd>
    if (p->active == 0)         return 0.f;
   2c0f4:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2c0f6:	2b00      	cmp	r3, #0
   2c0f8:	f000 812f 	beq.w	2c35a <tSampler_tick+0x28a>
    if ((p->inc == 0.0f) || (p->len < 2))
   2c0fc:	edd4 7a04 	vldr	s15, [r4, #16]
   2c100:	eef5 7a40 	vcmp.f32	s15, #0.0
   2c104:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c108:	f000 811e 	beq.w	2c348 <tSampler_tick+0x278>
   2c10c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   2c10e:	2b01      	cmp	r3, #1
   2c110:	f240 811a 	bls.w	2c348 <tSampler_tick+0x278>
    if (p->flip < 0)
   2c114:	f994 801d 	ldrsb.w	r8, [r4, #29]
    float* buff = p->samp->buff;
   2c118:	6862      	ldr	r2, [r4, #4]
    if (p->flip < 0)
   2c11a:	f1b8 0f00 	cmp.w	r8, #0
    int myStart = p->start;
   2c11e:	f8d4 a020 	ldr.w	sl, [r4, #32]
    float* buff = p->samp->buff;
   2c122:	6851      	ldr	r1, [r2, #4]
    int myEnd = p->end;
   2c124:	f8d4 9028 	ldr.w	r9, [r4, #40]	; 0x28
    if (p->flip < 0)
   2c128:	db02      	blt.n	2c130 <tSampler_tick+0x60>
   2c12a:	464b      	mov	r3, r9
    int myStart = p->start;
   2c12c:	46d1      	mov	r9, sl
    int myEnd = p->end;
   2c12e:	469a      	mov	sl, r3
    int dir = p->bnf * p->dir * p->flip;
   2c130:	f994 001c 	ldrsb.w	r0, [r4, #28]
   2c134:	f994 301e 	ldrsb.w	r3, [r4, #30]
    int idx = (int) p->idx;
   2c138:	edd4 7a03 	vldr	s15, [r4, #12]
    int dir = p->bnf * p->dir * p->flip;
   2c13c:	fb13 f300 	smulbb	r3, r3, r0
    int length = p->samp->recordedLength;
   2c140:	f8d2 b010 	ldr.w	fp, [r2, #16]
    int idx = (int) p->idx;
   2c144:	eebd 7ae7 	vcvt.s32.f32	s14, s15
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c148:	9101      	str	r1, [sp, #4]
    int dir = p->bnf * p->dir * p->flip;
   2c14a:	fb08 f803 	mul.w	r8, r8, r3
    idx += rev;
   2c14e:	ee17 6a10 	vmov	r6, s14
    if (dir < 0) rev = 1;
   2c152:	ea4f 77d8 	mov.w	r7, r8, lsr #31
    float alpha = rev + (p->idx - idx) * dir;
   2c156:	eef8 6ac7 	vcvt.f32.s32	s13, s14
   2c15a:	ee06 8a10 	vmov	s12, r8
    idx += rev;
   2c15e:	443e      	add	r6, r7
    float alpha = rev + (p->idx - idx) * dir;
   2c160:	ee07 7a10 	vmov	s14, r7
   2c164:	f1c7 0001 	rsb	r0, r7, #1
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
   2c168:	fb07 f70b 	mul.w	r7, r7, fp
    int i1 = idx-(1*dir);
   2c16c:	eba6 0208 	sub.w	r2, r6, r8
    int i3 = idx+(1*dir);
   2c170:	eb08 0306 	add.w	r3, r8, r6
   2c174:	9003      	str	r0, [sp, #12]
    float alpha = rev + (p->idx - idx) * dir;
   2c176:	eef8 8ac7 	vcvt.f32.s32	s17, s14
   2c17a:	fb00 f00b 	mul.w	r0, r0, fp
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
   2c17e:	4297      	cmp	r7, r2
    float alpha = rev + (p->idx - idx) * dir;
   2c180:	ee77 7ae6 	vsub.f32	s15, s15, s13
    int i4 = idx+(2*dir);
   2c184:	eb08 0c03 	add.w	ip, r8, r3
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
   2c188:	bfcc      	ite	gt
   2c18a:	1812      	addgt	r2, r2, r0
   2c18c:	1bd2      	suble	r2, r2, r7
    i2 = (i2 < length*rev) ? i2 + (length * (1-rev)) : i2 - (length * rev);
   2c18e:	42b7      	cmp	r7, r6
    float alpha = rev + (p->idx - idx) * dir;
   2c190:	eeb8 9ac6 	vcvt.f32.s32	s18, s12
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c194:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   2c198:	9002      	str	r0, [sp, #8]
    i2 = (i2 < length*rev) ? i2 + (length * (1-rev)) : i2 - (length * rev);
   2c19a:	bfcc      	ite	gt
   2c19c:	eb06 0e00 	addgt.w	lr, r6, r0
   2c1a0:	eba6 0e07 	suble.w	lr, r6, r7
    i3 = (i3 < length*(1-rev)) ? i3 + (length * rev) : i3 - (length * (1-rev));
   2c1a4:	4283      	cmp	r3, r0
    float alpha = rev + (p->idx - idx) * dir;
   2c1a6:	eee7 8a89 	vfma.f32	s17, s15, s18
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c1aa:	eb01 0e8e 	add.w	lr, r1, lr, lsl #2
   2c1ae:	ed92 0a00 	vldr	s0, [r2]
    i3 = (i3 < length*(1-rev)) ? i3 + (length * rev) : i3 - (length * (1-rev));
   2c1b2:	bfac      	ite	ge
   2c1b4:	1a1b      	subge	r3, r3, r0
   2c1b6:	19db      	addlt	r3, r3, r7
    i4 = (i4 < length*(1-rev)) ? i4 + (length * rev) : i4 - (length * (1-rev));
   2c1b8:	4584      	cmp	ip, r0
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c1ba:	edde 0a00 	vldr	s1, [lr]
   2c1be:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    i4 = (i4 < length*(1-rev)) ? i4 + (length * rev) : i4 - (length * (1-rev));
   2c1c2:	bfac      	ite	ge
   2c1c4:	ebac 0c00 	subge.w	ip, ip, r0
   2c1c8:	44bc      	addlt	ip, r7
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c1ca:	eeb0 2a68 	vmov.f32	s4, s17
   2c1ce:	ed93 1a00 	vldr	s2, [r3]
   2c1d2:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
   2c1d6:	eddc 1a00 	vldr	s3, [ip]
   2c1da:	f7fd fbbd 	bl	29958 <LEAF_interpolate_hermite_x>
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c1de:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
    int32_t cfxlen = p->cfxlen;
   2c1e2:	f8d4 c034 	ldr.w	ip, [r4, #52]	; 0x34
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c1e6:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
   2c1ea:	eef8 0a47 	vcvt.f32.u32	s1, s14
   2c1ee:	ee07 ca10 	vmov	s14, ip
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c1f2:	eeb0 8a40 	vmov.f32	s16, s0
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c1f6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c1fa:	ee60 7aa7 	vmul.f32	s15, s1, s15
   2c1fe:	e9dd 1001 	ldrd	r1, r0, [sp, #4]
   2c202:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c206:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c20a:	d503      	bpl.n	2c214 <tSampler_tick+0x144>
   2c20c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2c210:	ee17 ca90 	vmov	ip, s15
    if (myStart >= cfxlen) fadeLeftStart = myStart - cfxlen;
   2c214:	45e1      	cmp	r9, ip
   2c216:	f2c0 80a9 	blt.w	2c36c <tSampler_tick+0x29c>
   2c21a:	eba9 0e0c 	sub.w	lr, r9, ip
   2c21e:	f8cd 9004 	str.w	r9, [sp, #4]
    if (p->mode == PlayLoop)
   2c222:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
   2c226:	2a01      	cmp	r2, #1
   2c228:	f000 80ca 	beq.w	2c3c0 <tSampler_tick+0x2f0>
   2c22c:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
    float inc = fmodf(p->inc, (float)p->len);
   2c230:	ed94 0a04 	vldr	s0, [r4, #16]
   2c234:	f001 f988 	bl	2d548 <fmodf>
    p->idx += (dir * inc);
   2c238:	edd4 7a03 	vldr	s15, [r4, #12]
    if (p->flipStart >= 0)
   2c23c:	eef5 8ac0 	vcmpe.f32	s17, #0.0
    p->idx += (dir * inc);
   2c240:	eee9 7a00 	vfma.f32	s15, s18, s0
    if (p->flipStart >= 0)
   2c244:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    p->idx += (dir * inc);
   2c248:	edc4 7a03 	vstr	s15, [r4, #12]
    if (p->flipStart >= 0)
   2c24c:	db29      	blt.n	2c2a2 <tSampler_tick+0x1d2>
        p->flipIdx += (-dir * inc);
   2c24e:	f1c8 0300 	rsb	r3, r8, #0
   2c252:	edd4 6a14 	vldr	s13, [r4, #80]	; 0x50
   2c256:	ee07 3a10 	vmov	s14, r3
   2c25a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c25e:	eee7 6a00 	vfma.f32	s13, s14, s0
   2c262:	eeb0 7a66 	vmov.f32	s14, s13
        if((int)p->flipIdx < 0)
   2c266:	eefd 6ae6 	vcvt.s32.f32	s13, s13
        p->flipIdx += (-dir * inc);
   2c26a:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
        if((int)p->flipIdx < 0)
   2c26e:	ee16 3a90 	vmov	r3, s13
   2c272:	2b00      	cmp	r3, #0
   2c274:	da07      	bge.n	2c286 <tSampler_tick+0x1b6>
            p->idx += (float)length;
   2c276:	ee07 ba10 	vmov	s14, fp
   2c27a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c27e:	ee77 7a87 	vadd.f32	s15, s15, s14
   2c282:	edc4 7a03 	vstr	s15, [r4, #12]
        if((int)p->idx >= length)
   2c286:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2c28a:	ee17 3a10 	vmov	r3, s14
   2c28e:	455b      	cmp	r3, fp
   2c290:	db07      	blt.n	2c2a2 <tSampler_tick+0x1d2>
            p->idx -= (float)length;
   2c292:	ee07 ba10 	vmov	s14, fp
   2c296:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c29a:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2c29e:	edc4 7a03 	vstr	s15, [r4, #12]
    _tSampler* p = *sp;
   2c2a2:	682f      	ldr	r7, [r5, #0]
    if (p->targetstart >= 0)
   2c2a4:	6a79      	ldr	r1, [r7, #36]	; 0x24
   2c2a6:	2900      	cmp	r1, #0
   2c2a8:	db02      	blt.n	2c2b0 <tSampler_tick+0x1e0>
        tSampler_setStart(sp, p->targetstart);
   2c2aa:	4628      	mov	r0, r5
   2c2ac:	f7ff fde4 	bl	2be78 <tSampler_setStart>
    if (p->targetend >= 0)
   2c2b0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   2c2b2:	2900      	cmp	r1, #0
   2c2b4:	db02      	blt.n	2c2bc <tSampler_tick+0x1ec>
        tSampler_setEnd(sp, p->targetend);
   2c2b6:	4628      	mov	r0, r5
   2c2b8:	f7ff fe74 	bl	2bfa4 <tSampler_setEnd>
    if (p->mode == PlayLoop)
   2c2bc:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   2c2c0:	f104 0508 	add.w	r5, r4, #8
   2c2c4:	2b01      	cmp	r3, #1
   2c2c6:	d056      	beq.n	2c376 <tSampler_tick+0x2a6>
    else if (p->mode == PlayBackAndForth)
   2c2c8:	2b02      	cmp	r3, #2
   2c2ca:	f000 8100 	beq.w	2c4ce <tSampler_tick+0x3fe>
    if (p->mode == PlayNormal)
   2c2ce:	bb4b      	cbnz	r3, 2c324 <tSampler_tick+0x254>
    	if (p->idx < myStart)
   2c2d0:	ee07 9a90 	vmov	s15, r9
   2c2d4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   2c2d8:	edd4 7a03 	vldr	s15, [r4, #12]
   2c2dc:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c2e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c2e4:	f140 80d8 	bpl.w	2c498 <tSampler_tick+0x3c8>
    		p->idx = myEnd;
   2c2e8:	ed84 7a03 	vstr	s14, [r4, #12]
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2c2ec:	f1b8 0f00 	cmp.w	r8, #0
   2c2f0:	ed94 7a06 	vldr	s14, [r4, #24]
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2c2f4:	eddf 6add 	vldr	s13, [pc, #884]	; 2c66c <tSampler_tick+0x59c>
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2c2f8:	bfb4      	ite	lt
   2c2fa:	eba6 0309 	sublt.w	r3, r6, r9
   2c2fe:	ebaa 0306 	subge.w	r3, sl, r6
   2c302:	ee07 3a90 	vmov	s15, r3
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2c306:	4bda      	ldr	r3, [pc, #872]	; (2c670 <tSampler_tick+0x5a0>)
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2c308:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c30c:	ee67 7a87 	vmul.f32	s15, s15, s14
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2c310:	ed93 7a00 	vldr	s14, [r3]
   2c314:	ee27 7a26 	vmul.f32	s14, s14, s13
   2c318:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2c31c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c320:	f300 8159 	bgt.w	2c5d6 <tSampler_tick+0x506>
    sample = sample * tRamp_tick(&p->gain);
   2c324:	4628      	mov	r0, r5
   2c326:	f7fb fcd9 	bl	27cdc <tRamp_tick>
    if (p->active < 0)
   2c32a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    sample = sample * tRamp_tick(&p->gain);
   2c32c:	ee20 8a08 	vmul.f32	s16, s0, s16
    if (p->active < 0)
   2c330:	2b00      	cmp	r3, #0
   2c332:	f2c0 80e4 	blt.w	2c4fe <tSampler_tick+0x42e>
}
   2c336:	eeb0 0a48 	vmov.f32	s0, s16
    p->last = sample;
   2c33a:	ed84 8a05 	vstr	s16, [r4, #20]
}
   2c33e:	b007      	add	sp, #28
   2c340:	ecbd 8b04 	vpop	{d8-d9}
   2c344:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return p->last;
   2c348:	ed94 8a05 	vldr	s16, [r4, #20]
}
   2c34c:	eeb0 0a48 	vmov.f32	s0, s16
   2c350:	b007      	add	sp, #28
   2c352:	ecbd 8b04 	vpop	{d8-d9}
   2c356:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (p->active == 0)         return 0.f;
   2c35a:	ed9f 8ac6 	vldr	s16, [pc, #792]	; 2c674 <tSampler_tick+0x5a4>
}
   2c35e:	eeb0 0a48 	vmov.f32	s0, s16
   2c362:	b007      	add	sp, #28
   2c364:	ecbd 8b04 	vpop	{d8-d9}
   2c368:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2c36c:	f8cd c004 	str.w	ip, [sp, #4]
    int32_t fadeLeftStart = 0;
   2c370:	f04f 0e00 	mov.w	lr, #0
   2c374:	e755      	b.n	2c222 <tSampler_tick+0x152>
        if((int)p->idx < myStart)
   2c376:	edd4 7a03 	vldr	s15, [r4, #12]
   2c37a:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2c37e:	ee17 3a10 	vmov	r3, s14
   2c382:	454b      	cmp	r3, r9
   2c384:	da0e      	bge.n	2c3a4 <tSampler_tick+0x2d4>
            p->idx += (float)(fadeRightEnd - fadeLeftEnd);
   2c386:	9b01      	ldr	r3, [sp, #4]
   2c388:	ebaa 0303 	sub.w	r3, sl, r3
   2c38c:	ee07 3a10 	vmov	s14, r3
   2c390:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c394:	ee77 7a87 	vadd.f32	s15, s15, s14
   2c398:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2c39c:	edc4 7a03 	vstr	s15, [r4, #12]
   2c3a0:	ee17 3a10 	vmov	r3, s14
        if((int)p->idx > myEnd)
   2c3a4:	459a      	cmp	sl, r3
   2c3a6:	dabd      	bge.n	2c324 <tSampler_tick+0x254>
            p->idx -= (float)(fadeRightEnd - fadeLeftEnd);
   2c3a8:	9b01      	ldr	r3, [sp, #4]
   2c3aa:	ebaa 0a03 	sub.w	sl, sl, r3
   2c3ae:	ee07 aa10 	vmov	s14, sl
   2c3b2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c3b6:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2c3ba:	edc4 7a03 	vstr	s15, [r4, #12]
   2c3be:	e7b1      	b.n	2c324 <tSampler_tick+0x254>
   2c3c0:	ee07 ca90 	vmov	s15, ip
        if ((fadeLeftStart <= idx) && (idx <= fadeLeftEnd))
   2c3c4:	45b6      	cmp	lr, r6
   2c3c6:	eef8 9ae7 	vcvt.f32.s32	s19, s15
   2c3ca:	dc70      	bgt.n	2c4ae <tSampler_tick+0x3de>
   2c3cc:	9b01      	ldr	r3, [sp, #4]
   2c3ce:	429e      	cmp	r6, r3
   2c3d0:	dc6d      	bgt.n	2c4ae <tSampler_tick+0x3de>
            offset = fadeLeftEnd - idx;
   2c3d2:	1b9b      	subs	r3, r3, r6
            p->inCrossfade = 1;
   2c3d4:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
            offset = fadeLeftEnd - idx;
   2c3d8:	9302      	str	r3, [sp, #8]
            cdx = fadeRightEnd - offset;
   2c3da:	ebaa 0303 	sub.w	r3, sl, r3
            int c1 = cdx-(1*dir);
   2c3de:	eba3 0e08 	sub.w	lr, r3, r8
            c1 = (c1 < length * rev) ? c1 + (length * (1-rev)) : c1 - (length * rev);
   2c3e2:	4577      	cmp	r7, lr
   2c3e4:	f340 8127 	ble.w	2c636 <tSampler_tick+0x566>
   2c3e8:	4486      	add	lr, r0
            c2 = (c2 < length * rev) ? c2 + (length * (1-rev)) : c2 - (length * rev);
   2c3ea:	429f      	cmp	r7, r3
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c3ec:	eeb0 2a68 	vmov.f32	s4, s17
   2c3f0:	9005      	str	r0, [sp, #20]
            c2 = (c2 < length * rev) ? c2 + (length * (1-rev)) : c2 - (length * rev);
   2c3f2:	bfcc      	ite	gt
   2c3f4:	eb03 0c00 	addgt.w	ip, r3, r0
   2c3f8:	eba3 0c07 	suble.w	ip, r3, r7
            int c3 = cdx+(1*dir);
   2c3fc:	4443      	add	r3, r8
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c3fe:	9104      	str	r1, [sp, #16]
   2c400:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
            c3 = (c3 < length * (1-rev)) ? c3 + (length * rev) : c3 - (length * (1-rev));
   2c404:	4283      	cmp	r3, r0
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c406:	eddc 0a00 	vldr	s1, [ip]
            c3 = (c3 < length * (1-rev)) ? c3 + (length * rev) : c3 - (length * (1-rev));
   2c40a:	bfac      	ite	ge
   2c40c:	1a1a      	subge	r2, r3, r0
   2c40e:	18fa      	addlt	r2, r7, r3
            int c4 = cdx+(2*dir);
   2c410:	4443      	add	r3, r8
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c412:	eb01 0282 	add.w	r2, r1, r2, lsl #2
            c4 = (c4 < length * (1-rev)) ? c4 + (length * rev) : c4 - (length * (1-rev));
   2c416:	4283      	cmp	r3, r0
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c418:	ed92 1a00 	vldr	s2, [r2]
            c4 = (c4 < length * (1-rev)) ? c4 + (length * rev) : c4 - (length * (1-rev));
   2c41c:	bfac      	ite	ge
   2c41e:	1a1b      	subge	r3, r3, r0
   2c420:	19db      	addlt	r3, r3, r7
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c422:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   2c426:	edd3 1a00 	vldr	s3, [r3]
   2c42a:	eb01 038e 	add.w	r3, r1, lr, lsl #2
   2c42e:	ed93 0a00 	vldr	s0, [r3]
   2c432:	f7fd fa91 	bl	29958 <LEAF_interpolate_hermite_x>
            crossfadeMix = (float) offset / (float) cfxlen;
   2c436:	eddd 7a02 	vldr	s15, [sp, #8]
   2c43a:	eef8 6ae7 	vcvt.f32.s32	s13, s15
   2c43e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2c442:	ee86 7aa9 	vdiv.f32	s14, s13, s19
   2c446:	e9dd 1004 	ldrd	r1, r0, [sp, #16]
   2c44a:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c44e:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2c452:	eea8 0a27 	vfma.f32	s0, s16, s15
   2c456:	eeb0 8a40 	vmov.f32	s16, s0
        float flipLength = fabsf(p->flipIdx - p->flipStart);
   2c45a:	ed94 7a14 	vldr	s14, [r4, #80]	; 0x50
   2c45e:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
   2c462:	ee77 7a68 	vsub.f32	s15, s14, s17
   2c466:	eef0 7ae7 	vabs.f32	s15, s15
        if (flipLength > cfxlen)
   2c46a:	eef4 7ae9 	vcmpe.f32	s15, s19
   2c46e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c472:	dd56      	ble.n	2c522 <tSampler_tick+0x452>
            p->flipStart = -1;
   2c474:	4b80      	ldr	r3, [pc, #512]	; (2c678 <tSampler_tick+0x5a8>)
    float inc = fmodf(p->inc, (float)p->len);
   2c476:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2c47a:	ed94 0a04 	vldr	s0, [r4, #16]
   2c47e:	eef8 0a67 	vcvt.f32.u32	s1, s15
            p->flipStart = -1;
   2c482:	64e3      	str	r3, [r4, #76]	; 0x4c
            p->flipIdx = -1;
   2c484:	6523      	str	r3, [r4, #80]	; 0x50
    float inc = fmodf(p->inc, (float)p->len);
   2c486:	f001 f85f 	bl	2d548 <fmodf>
    p->idx += (dir * inc);
   2c48a:	edd4 7a03 	vldr	s15, [r4, #12]
   2c48e:	eee9 7a00 	vfma.f32	s15, s18, s0
   2c492:	edc4 7a03 	vstr	s15, [r4, #12]
   2c496:	e704      	b.n	2c2a2 <tSampler_tick+0x1d2>
    	else if (p->idx > myEnd)
   2c498:	ee07 aa10 	vmov	s14, sl
   2c49c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c4a0:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c4a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c4a8:	f77f af20 	ble.w	2c2ec <tSampler_tick+0x21c>
   2c4ac:	e71c      	b.n	2c2e8 <tSampler_tick+0x218>
    int32_t fadeRightStart = fadeRightEnd - cfxlen;
   2c4ae:	ebaa 0c0c 	sub.w	ip, sl, ip
        else if ((fadeRightStart <= idx) && (idx <= fadeRightEnd))
   2c4b2:	4566      	cmp	r6, ip
   2c4b4:	f2c0 80bb 	blt.w	2c62e <tSampler_tick+0x55e>
   2c4b8:	45b2      	cmp	sl, r6
   2c4ba:	f2c0 80b8 	blt.w	2c62e <tSampler_tick+0x55e>
            offset = idx - fadeRightStart;
   2c4be:	eba6 030c 	sub.w	r3, r6, ip
            p->inCrossfade = 1;
   2c4c2:	2201      	movs	r2, #1
            offset = idx - fadeRightStart;
   2c4c4:	9302      	str	r3, [sp, #8]
            cdx = fadeLeftStart + offset;
   2c4c6:	4473      	add	r3, lr
            p->inCrossfade = 1;
   2c4c8:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
   2c4cc:	e787      	b.n	2c3de <tSampler_tick+0x30e>
        if (p->idx < myStart)
   2c4ce:	ee07 9a90 	vmov	s15, r9
   2c4d2:	ed94 7a03 	vldr	s14, [r4, #12]
   2c4d6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c4da:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2c4de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c4e2:	f140 8081 	bpl.w	2c5e8 <tSampler_tick+0x518>
            p->idx = myStart + 1;
   2c4e6:	f109 0901 	add.w	r9, r9, #1
            p->bnf = -p->bnf;
   2c4ea:	7fa3      	ldrb	r3, [r4, #30]
            p->idx = myStart + 1;
   2c4ec:	ee07 9a90 	vmov	s15, r9
            p->bnf = -p->bnf;
   2c4f0:	425b      	negs	r3, r3
            p->idx = myStart + 1;
   2c4f2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            p->bnf = -p->bnf;
   2c4f6:	77a3      	strb	r3, [r4, #30]
            p->idx = myStart + 1;
   2c4f8:	edc4 7a03 	vstr	s15, [r4, #12]
   2c4fc:	e712      	b.n	2c324 <tSampler_tick+0x254>
        if (tRamp_sample(&p->gain) <= 0.00001f)
   2c4fe:	4628      	mov	r0, r5
   2c500:	f7fb fc14 	bl	27d2c <tRamp_sample>
   2c504:	eddf 7a5d 	vldr	s15, [pc, #372]	; 2c67c <tSampler_tick+0x5ac>
   2c508:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2c50c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c510:	f63f af11 	bhi.w	2c336 <tSampler_tick+0x266>
            if (p->retrigger == 1)
   2c514:	6c23      	ldr	r3, [r4, #64]	; 0x40
   2c516:	2b01      	cmp	r3, #1
   2c518:	f000 8090 	beq.w	2c63c <tSampler_tick+0x56c>
                p->active = 0;
   2c51c:	2300      	movs	r3, #0
   2c51e:	6463      	str	r3, [r4, #68]	; 0x44
   2c520:	e709      	b.n	2c336 <tSampler_tick+0x266>
        if (p->flipIdx >= 0)
   2c522:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
   2c526:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c52a:	db4f      	blt.n	2c5cc <tSampler_tick+0x4fc>
            if (p->flipStart == -1)
   2c52c:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   2c530:	eef4 8a66 	vcmp.f32	s17, s13
   2c534:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c538:	d06e      	beq.n	2c618 <tSampler_tick+0x548>
   2c53a:	ee79 7ae7 	vsub.f32	s15, s19, s15
   2c53e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2c542:	eec7 8aa9 	vdiv.f32	s17, s15, s19
   2c546:	ee76 7ae8 	vsub.f32	s15, s13, s17
   2c54a:	ee27 8a88 	vmul.f32	s16, s15, s16
            int fdx = (int) p->flipIdx;
   2c54e:	eefd 7ac7 	vcvt.s32.f32	s15, s14
            idx += (1-rev);
   2c552:	9a03      	ldr	r2, [sp, #12]
   2c554:	4416      	add	r6, r2
            int fdx = (int) p->flipIdx;
   2c556:	eef0 6a67 	vmov.f32	s13, s15
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2c55a:	ee07 2a90 	vmov	s15, r2
   2c55e:	eeb8 2ae7 	vcvt.f32.s32	s4, s15
            int f3 = fdx-(1*dir);
   2c562:	ee16 3a90 	vmov	r3, s13
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2c566:	eef8 7ae6 	vcvt.f32.s32	s15, s13
            int f1 = fdx+(1*dir);
   2c56a:	eb08 0e03 	add.w	lr, r8, r3
            int f3 = fdx-(1*dir);
   2c56e:	eba3 0208 	sub.w	r2, r3, r8
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2c572:	ee37 7ac7 	vsub.f32	s14, s15, s14
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
   2c576:	4586      	cmp	lr, r0
            int f4 = fdx-(2*dir);
   2c578:	eba2 0c08 	sub.w	ip, r2, r8
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
   2c57c:	bfb4      	ite	lt
   2c57e:	44be      	addlt	lr, r7
   2c580:	ebae 0e00 	subge.w	lr, lr, r0
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
   2c584:	4283      	cmp	r3, r0
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2c586:	eea9 2a07 	vfma.f32	s4, s18, s14
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
   2c58a:	da43      	bge.n	2c614 <tSampler_tick+0x544>
   2c58c:	443b      	add	r3, r7
            f3 = (f3 < length*rev) ? f3 + (length * (1-rev)) : f3 - (length * rev);
   2c58e:	4297      	cmp	r7, r2
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
   2c590:	eb01 0383 	add.w	r3, r1, r3, lsl #2
            f3 = (f3 < length*rev) ? f3 + (length * (1-rev)) : f3 - (length * rev);
   2c594:	bfcc      	ite	gt
   2c596:	1812      	addgt	r2, r2, r0
   2c598:	1bd2      	suble	r2, r2, r7
            f4 = (f4 < length*rev) ? f4 + (length * (1-rev)) : f4 - (length * rev);
   2c59a:	4567      	cmp	r7, ip
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
   2c59c:	edd3 0a00 	vldr	s1, [r3]
   2c5a0:	eb01 0282 	add.w	r2, r1, r2, lsl #2
            f4 = (f4 < length*rev) ? f4 + (length * (1-rev)) : f4 - (length * rev);
   2c5a4:	bfcc      	ite	gt
   2c5a6:	4460      	addgt	r0, ip
   2c5a8:	ebac 0007 	suble.w	r0, ip, r7
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
   2c5ac:	ed92 1a00 	vldr	s2, [r2]
   2c5b0:	eb01 0080 	add.w	r0, r1, r0, lsl #2
   2c5b4:	eb01 018e 	add.w	r1, r1, lr, lsl #2
   2c5b8:	edd0 1a00 	vldr	s3, [r0]
   2c5bc:	ed91 0a00 	vldr	s0, [r1]
   2c5c0:	f7fd f9ca 	bl	29958 <LEAF_interpolate_hermite_x>
   2c5c4:	eea0 8a28 	vfma.f32	s16, s0, s17
   2c5c8:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
   2c5cc:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2c5d0:	eef8 0a67 	vcvt.f32.u32	s1, s15
   2c5d4:	e62c      	b.n	2c230 <tSampler_tick+0x160>
            tRamp_setDest(&p->gain, 0.f);
   2c5d6:	ed9f 0a27 	vldr	s0, [pc, #156]	; 2c674 <tSampler_tick+0x5a4>
   2c5da:	4628      	mov	r0, r5
   2c5dc:	f7fb fb62 	bl	27ca4 <tRamp_setDest>
            p->active = -1;
   2c5e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c5e4:	6463      	str	r3, [r4, #68]	; 0x44
   2c5e6:	e69d      	b.n	2c324 <tSampler_tick+0x254>
        else if (p->idx > myEnd)
   2c5e8:	ee07 aa90 	vmov	s15, sl
   2c5ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c5f0:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2c5f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c5f8:	f77f ae94 	ble.w	2c324 <tSampler_tick+0x254>
            p->idx = myEnd - 1;
   2c5fc:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
            p->bnf = -p->bnf;
   2c600:	7fa3      	ldrb	r3, [r4, #30]
            p->idx = myEnd - 1;
   2c602:	ee07 aa90 	vmov	s15, sl
            p->bnf = -p->bnf;
   2c606:	425b      	negs	r3, r3
            p->idx = myEnd - 1;
   2c608:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            p->bnf = -p->bnf;
   2c60c:	77a3      	strb	r3, [r4, #30]
            p->idx = myEnd - 1;
   2c60e:	edc4 7a03 	vstr	s15, [r4, #12]
   2c612:	e687      	b.n	2c324 <tSampler_tick+0x254>
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
   2c614:	1a1b      	subs	r3, r3, r0
   2c616:	e7ba      	b.n	2c58e <tSampler_tick+0x4be>
                p->flipStart = p->idx;
   2c618:	ed94 7a03 	vldr	s14, [r4, #12]
                p->flipIdx = p->idx;
   2c61c:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
   2c620:	ed9f 8a14 	vldr	s16, [pc, #80]	; 2c674 <tSampler_tick+0x5a4>
                p->flipStart = p->idx;
   2c624:	ed84 7a13 	vstr	s14, [r4, #76]	; 0x4c
                p->flipIdx = p->idx;
   2c628:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
   2c62c:	e78f      	b.n	2c54e <tSampler_tick+0x47e>
        else p->inCrossfade = 0;
   2c62e:	2300      	movs	r3, #0
   2c630:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
   2c634:	e711      	b.n	2c45a <tSampler_tick+0x38a>
            c1 = (c1 < length * rev) ? c1 + (length * (1-rev)) : c1 - (length * rev);
   2c636:	ebae 0e07 	sub.w	lr, lr, r7
   2c63a:	e6d6      	b.n	2c3ea <tSampler_tick+0x31a>
                p->retrigger = 0;
   2c63c:	2200      	movs	r2, #0
                p->active = 1;
   2c63e:	6463      	str	r3, [r4, #68]	; 0x44
                tRamp_setDest(&p->gain, 1.f);
   2c640:	4628      	mov	r0, r5
   2c642:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
                p->retrigger = 0;
   2c646:	6422      	str	r2, [r4, #64]	; 0x40
                tRamp_setDest(&p->gain, 1.f);
   2c648:	f7fb fb2c 	bl	27ca4 <tRamp_setDest>
                if (p->dir > 0)
   2c64c:	f994 301c 	ldrsb.w	r3, [r4, #28]
   2c650:	2b00      	cmp	r3, #0
                    if (p->flip > 0)    p->idx = p->start;
   2c652:	f994 301d 	ldrsb.w	r3, [r4, #29]
                if (p->dir > 0)
   2c656:	dd13      	ble.n	2c680 <tSampler_tick+0x5b0>
                    if (p->flip > 0)    p->idx = p->start;
   2c658:	2b00      	cmp	r3, #0
   2c65a:	dd13      	ble.n	2c684 <tSampler_tick+0x5b4>
                    else                p->idx = p->start;
   2c65c:	edd4 7a08 	vldr	s15, [r4, #32]
   2c660:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c664:	edc4 7a03 	vstr	s15, [r4, #12]
   2c668:	e665      	b.n	2c336 <tSampler_tick+0x266>
   2c66a:	bf00      	nop
   2c66c:	3be56042 	.word	0x3be56042
   2c670:	020fbd68 	.word	0x020fbd68
   2c674:	00000000 	.word	0x00000000
   2c678:	bf800000 	.word	0xbf800000
   2c67c:	3727c5ac 	.word	0x3727c5ac
                    if (p->flip > 0)    p->idx = p->end;
   2c680:	2b00      	cmp	r3, #0
   2c682:	ddeb      	ble.n	2c65c <tSampler_tick+0x58c>
   2c684:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
   2c688:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c68c:	edc4 7a03 	vstr	s15, [r4, #12]
   2c690:	e651      	b.n	2c336 <tSampler_tick+0x266>
   2c692:	bf00      	nop

0002c694 <tSampler_setLength>:

void    tSampler_setLength    (tSampler* const sp, int32_t length)
{
   2c694:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
   2c696:	6804      	ldr	r4, [r0, #0]
    if (length == 0) length = 1;
   2c698:	2900      	cmp	r1, #0
   2c69a:	bf14      	ite	ne
   2c69c:	460a      	movne	r2, r1
   2c69e:	2201      	moveq	r2, #1
    tSampler_setEnd(sp, p->start + length);
   2c6a0:	6a23      	ldr	r3, [r4, #32]
    if (p->active) // only bother with these checks if we're actually playing
   2c6a2:	6c65      	ldr	r5, [r4, #68]	; 0x44
    tSampler_setEnd(sp, p->start + length);
   2c6a4:	1899      	adds	r1, r3, r2
    if (p->active) // only bother with these checks if we're actually playing
   2c6a6:	2d00      	cmp	r5, #0
   2c6a8:	d041      	beq.n	2c72e <tSampler_setLength+0x9a>
        if (p->start > end)
   2c6aa:	428b      	cmp	r3, r1
   2c6ac:	dc1d      	bgt.n	2c6ea <tSampler_setLength+0x56>
   2c6ae:	2501      	movs	r5, #1
   2c6b0:	2700      	movs	r7, #0
            tempflip = 1;
   2c6b2:	462e      	mov	r6, r5
        uint32_t cfxlen = p->cfxlen;
   2c6b4:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c6b8:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2c6bc:	eef8 6a47 	vcvt.f32.u32	s13, s14
        if (p->inCrossfade || p->flipStart >= 0)
   2c6c0:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c6c4:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
   2c6c8:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c6cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c6d0:	bf48      	it	mi
   2c6d2:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
   2c6d6:	b933      	cbnz	r3, 2c6e6 <tSampler_setLength+0x52>
   2c6d8:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2c6dc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2c6e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c6e4:	db06      	blt.n	2c6f4 <tSampler_setLength+0x60>
    p->targetend = -1;
   2c6e6:	62e1      	str	r1, [r4, #44]	; 0x2c
}
   2c6e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (p->start > end)
   2c6ea:	2701      	movs	r7, #1
   2c6ec:	2500      	movs	r5, #0
            tempflip = -1;
   2c6ee:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2c6f2:	e7df      	b.n	2c6b4 <tSampler_setLength+0x20>
        int dir = p->bnf * p->dir * tempflip;
   2c6f4:	f994 301e 	ldrsb.w	r3, [r4, #30]
   2c6f8:	f994 c01c 	ldrsb.w	ip, [r4, #28]
   2c6fc:	fb13 f30c 	smulbb	r3, r3, ip
   2c700:	fb06 f303 	mul.w	r3, r6, r3
        if (tempflip > 0 && dir < 0) // end is end and we're playing in reverse
   2c704:	2b00      	cmp	r3, #0
   2c706:	da3c      	bge.n	2c782 <tSampler_setLength+0xee>
   2c708:	2d00      	cmp	r5, #0
   2c70a:	d03a      	beq.n	2c782 <tSampler_setLength+0xee>
            if (end < p->idx) // end given is before current index or we're in a crossfade
   2c70c:	ee07 1a90 	vmov	s15, r1
   2c710:	edd4 6a03 	vldr	s13, [r4, #12]
   2c714:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c718:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c71c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c720:	d43e      	bmi.n	2c7a0 <tSampler_setLength+0x10c>
        if (tempflip != p->flip && p->flipStart < 0)
   2c722:	f994 301d 	ldrsb.w	r3, [r4, #29]
   2c726:	429e      	cmp	r6, r3
   2c728:	d001      	beq.n	2c72e <tSampler_setLength+0x9a>
            p->flipIdx = 0;
   2c72a:	2300      	movs	r3, #0
   2c72c:	6523      	str	r3, [r4, #80]	; 0x50
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
   2c72e:	6863      	ldr	r3, [r4, #4]
   2c730:	4605      	mov	r5, r0
   2c732:	2000      	movs	r0, #0
   2c734:	691a      	ldr	r2, [r3, #16]
   2c736:	3a01      	subs	r2, #1
   2c738:	f7fd f80a 	bl	29750 <LEAF_clipInt>
   2c73c:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
   2c73e:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   2c740:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2c742:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c744:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2c748:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c74a:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2c74e:	2900      	cmp	r1, #0
   2c750:	bfb8      	it	lt
   2c752:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c754:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   2c758:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c75a:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2c75e:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c762:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c766:	dd03      	ble.n	2c770 <tSampler_setLength+0xdc>
   2c768:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2c76c:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
   2c770:	4282      	cmp	r2, r0
   2c772:	bfac      	ite	ge
   2c774:	2201      	movge	r2, #1
   2c776:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetend = -1;
   2c77a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2c77e:	775a      	strb	r2, [r3, #29]
   2c780:	e7b1      	b.n	2c6e6 <tSampler_setLength+0x52>
        else if (tempflip < 0 && dir > 0) // end is start and we're playing forward
   2c782:	2b00      	cmp	r3, #0
   2c784:	ddcd      	ble.n	2c722 <tSampler_setLength+0x8e>
   2c786:	2f00      	cmp	r7, #0
   2c788:	d0cb      	beq.n	2c722 <tSampler_setLength+0x8e>
            if (end > p->idx) // end given is after current index or we're in a crossfade
   2c78a:	ee07 1a90 	vmov	s15, r1
   2c78e:	edd4 6a03 	vldr	s13, [r4, #12]
   2c792:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c796:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c79a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c79e:	ddc0      	ble.n	2c722 <tSampler_setLength+0x8e>
                float tempLen = abs(end - p->start) * 0.25f;
   2c7a0:	2a00      	cmp	r2, #0
                if (cfxlen > tempLen)
   2c7a2:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetend = end;
   2c7a6:	62e1      	str	r1, [r4, #44]	; 0x2c
                float tempLen = abs(end - p->start) * 0.25f;
   2c7a8:	bfb8      	it	lt
   2c7aa:	4252      	neglt	r2, r2
   2c7ac:	ee07 2a90 	vmov	s15, r2
   2c7b0:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
   2c7b4:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c7b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c7bc:	d594      	bpl.n	2c6e8 <tSampler_setLength+0x54>
                    p->cfxlen = tempLen;
   2c7be:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2c7c2:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
   2c7c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002c7c8 <tSampler_setRate>:

void tSampler_setRate      (tSampler* const sp, float rate)
{
    _tSampler* p = *sp;
    
    if (rate < 0.f)
   2c7c8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
    _tSampler* p = *sp;
   2c7cc:	6803      	ldr	r3, [r0, #0]
    if (rate < 0.f)
   2c7ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c7d2:	d40a      	bmi.n	2c7ea <tSampler_setRate+0x22>
        rate = -rate;
        p->dir = -1;
    }
    else
    {
        p->dir = 1;
   2c7d4:	2201      	movs	r2, #1
    }
    
    p->inc = rate;
    p->iinc = 1.f / p->inc;
   2c7d6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2c7da:	771a      	strb	r2, [r3, #28]
    p->inc = rate;
   2c7dc:	ed83 0a04 	vstr	s0, [r3, #16]
    p->iinc = 1.f / p->inc;
   2c7e0:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2c7e4:	edc3 7a06 	vstr	s15, [r3, #24]
}
   2c7e8:	4770      	bx	lr
        rate = -rate;
   2c7ea:	eeb1 0a40 	vneg.f32	s0, s0
        p->dir = -1;
   2c7ee:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2c7f2:	e7f0      	b.n	2c7d6 <tSampler_setRate+0xe>

0002c7f4 <LEAF_init>:

LEAF leaf;

void LEAF_init(float sr, int blocksize, char* memory, size_t memorysize, float(*random)(void))

{
   2c7f4:	b538      	push	{r3, r4, r5, lr}
   2c7f6:	460c      	mov	r4, r1
   2c7f8:	4605      	mov	r5, r0
    leaf_pool_init(memory, memorysize);
   2c7fa:	4611      	mov	r1, r2
   2c7fc:	4620      	mov	r0, r4
{
   2c7fe:	461c      	mov	r4, r3
   2c800:	ed2d 8b02 	vpush	{d8}
   2c804:	eeb0 8a40 	vmov.f32	s16, s0
    leaf_pool_init(memory, memorysize);
   2c808:	f7fd f976 	bl	29af8 <leaf_pool_init>
    
    leaf.sampleRate = sr;

    leaf.blockSize = blocksize;
    
    leaf.invSampleRate = 1.0f/sr;
   2c80c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   2c810:	eddf 7a09 	vldr	s15, [pc, #36]	; 2c838 <LEAF_init+0x44>
    leaf.sampleRate = sr;
   2c814:	4a09      	ldr	r2, [pc, #36]	; (2c83c <LEAF_init+0x48>)

    leaf.random = random;
    
    leaf.clearOnAllocation = 0;
   2c816:	2100      	movs	r1, #0
    leaf.invSampleRate = 1.0f/sr;
   2c818:	ee86 7a88 	vdiv.f32	s14, s13, s16
    leaf.blockSize = blocksize;
   2c81c:	6095      	str	r5, [r2, #8]
    leaf.sampleRate = sr;
   2c81e:	ed82 8a00 	vstr	s16, [r2]
    leaf.clearOnAllocation = 0;
   2c822:	e9c2 4104 	strd	r4, r1, [r2, #16]
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   2c826:	ee67 7a27 	vmul.f32	s15, s14, s15
    leaf.invSampleRate = 1.0f/sr;
   2c82a:	ed82 7a01 	vstr	s14, [r2, #4]
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   2c82e:	edc2 7a03 	vstr	s15, [r2, #12]
}
   2c832:	ecbd 8b02 	vpop	{d8}
   2c836:	bd38      	pop	{r3, r4, r5, pc}
   2c838:	40c90fdb 	.word	0x40c90fdb
   2c83c:	020fbd68 	.word	0x020fbd68

0002c840 <LEAF_error>:
//implement a function called this in your user code to catch errors
//__attribute__((weak))
uint8_t LEAF_error(uint8_t whichone)
{
    return whichone;
}
   2c840:	4770      	bx	lr
   2c842:	bf00      	nop

0002c844 <__errno>:
   2c844:	4b01      	ldr	r3, [pc, #4]	; (2c84c <__errno+0x8>)
   2c846:	6818      	ldr	r0, [r3, #0]
   2c848:	4770      	bx	lr
   2c84a:	bf00      	nop
   2c84c:	00062990 	.word	0x00062990

0002c850 <__libc_init_array>:
   2c850:	b570      	push	{r4, r5, r6, lr}
   2c852:	4e0d      	ldr	r6, [pc, #52]	; (2c888 <__libc_init_array+0x38>)
   2c854:	4c0d      	ldr	r4, [pc, #52]	; (2c88c <__libc_init_array+0x3c>)
   2c856:	1ba4      	subs	r4, r4, r6
   2c858:	10a4      	asrs	r4, r4, #2
   2c85a:	2500      	movs	r5, #0
   2c85c:	42a5      	cmp	r5, r4
   2c85e:	d109      	bne.n	2c874 <__libc_init_array+0x24>
   2c860:	4e0b      	ldr	r6, [pc, #44]	; (2c890 <__libc_init_array+0x40>)
   2c862:	4c0c      	ldr	r4, [pc, #48]	; (2c894 <__libc_init_array+0x44>)
   2c864:	f7db fbcc 	bl	8000 <_init>
   2c868:	1ba4      	subs	r4, r4, r6
   2c86a:	10a4      	asrs	r4, r4, #2
   2c86c:	2500      	movs	r5, #0
   2c86e:	42a5      	cmp	r5, r4
   2c870:	d105      	bne.n	2c87e <__libc_init_array+0x2e>
   2c872:	bd70      	pop	{r4, r5, r6, pc}
   2c874:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   2c878:	4798      	blx	r3
   2c87a:	3501      	adds	r5, #1
   2c87c:	e7ee      	b.n	2c85c <__libc_init_array+0xc>
   2c87e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   2c882:	4798      	blx	r3
   2c884:	3501      	adds	r5, #1
   2c886:	e7f2      	b.n	2c86e <__libc_init_array+0x1e>
   2c888:	00062554 	.word	0x00062554
   2c88c:	00062554 	.word	0x00062554
   2c890:	00062554 	.word	0x00062554
   2c894:	00062558 	.word	0x00062558

0002c898 <__itoa>:
   2c898:	1e93      	subs	r3, r2, #2
   2c89a:	2b22      	cmp	r3, #34	; 0x22
   2c89c:	b510      	push	{r4, lr}
   2c89e:	460c      	mov	r4, r1
   2c8a0:	d904      	bls.n	2c8ac <__itoa+0x14>
   2c8a2:	2300      	movs	r3, #0
   2c8a4:	700b      	strb	r3, [r1, #0]
   2c8a6:	461c      	mov	r4, r3
   2c8a8:	4620      	mov	r0, r4
   2c8aa:	bd10      	pop	{r4, pc}
   2c8ac:	2a0a      	cmp	r2, #10
   2c8ae:	d109      	bne.n	2c8c4 <__itoa+0x2c>
   2c8b0:	2800      	cmp	r0, #0
   2c8b2:	da07      	bge.n	2c8c4 <__itoa+0x2c>
   2c8b4:	232d      	movs	r3, #45	; 0x2d
   2c8b6:	700b      	strb	r3, [r1, #0]
   2c8b8:	4240      	negs	r0, r0
   2c8ba:	2101      	movs	r1, #1
   2c8bc:	4421      	add	r1, r4
   2c8be:	f000 f829 	bl	2c914 <__utoa>
   2c8c2:	e7f1      	b.n	2c8a8 <__itoa+0x10>
   2c8c4:	2100      	movs	r1, #0
   2c8c6:	e7f9      	b.n	2c8bc <__itoa+0x24>

0002c8c8 <itoa>:
   2c8c8:	f7ff bfe6 	b.w	2c898 <__itoa>

0002c8cc <memcpy>:
   2c8cc:	b510      	push	{r4, lr}
   2c8ce:	1e43      	subs	r3, r0, #1
   2c8d0:	440a      	add	r2, r1
   2c8d2:	4291      	cmp	r1, r2
   2c8d4:	d100      	bne.n	2c8d8 <memcpy+0xc>
   2c8d6:	bd10      	pop	{r4, pc}
   2c8d8:	f811 4b01 	ldrb.w	r4, [r1], #1
   2c8dc:	f803 4f01 	strb.w	r4, [r3, #1]!
   2c8e0:	e7f7      	b.n	2c8d2 <memcpy+0x6>

0002c8e2 <memset>:
   2c8e2:	4402      	add	r2, r0
   2c8e4:	4603      	mov	r3, r0
   2c8e6:	4293      	cmp	r3, r2
   2c8e8:	d100      	bne.n	2c8ec <memset+0xa>
   2c8ea:	4770      	bx	lr
   2c8ec:	f803 1b01 	strb.w	r1, [r3], #1
   2c8f0:	e7f9      	b.n	2c8e6 <memset+0x4>

0002c8f2 <stpcpy>:
   2c8f2:	4603      	mov	r3, r0
   2c8f4:	f811 2b01 	ldrb.w	r2, [r1], #1
   2c8f8:	4618      	mov	r0, r3
   2c8fa:	f803 2b01 	strb.w	r2, [r3], #1
   2c8fe:	2a00      	cmp	r2, #0
   2c900:	d1f8      	bne.n	2c8f4 <stpcpy+0x2>
   2c902:	4770      	bx	lr

0002c904 <strlen>:
   2c904:	4603      	mov	r3, r0
   2c906:	f813 2b01 	ldrb.w	r2, [r3], #1
   2c90a:	2a00      	cmp	r2, #0
   2c90c:	d1fb      	bne.n	2c906 <strlen+0x2>
   2c90e:	1a18      	subs	r0, r3, r0
   2c910:	3801      	subs	r0, #1
   2c912:	4770      	bx	lr

0002c914 <__utoa>:
   2c914:	b5f0      	push	{r4, r5, r6, r7, lr}
   2c916:	4b1d      	ldr	r3, [pc, #116]	; (2c98c <__utoa+0x78>)
   2c918:	b08b      	sub	sp, #44	; 0x2c
   2c91a:	4605      	mov	r5, r0
   2c91c:	460c      	mov	r4, r1
   2c91e:	466e      	mov	r6, sp
   2c920:	f103 0c20 	add.w	ip, r3, #32
   2c924:	6818      	ldr	r0, [r3, #0]
   2c926:	6859      	ldr	r1, [r3, #4]
   2c928:	4637      	mov	r7, r6
   2c92a:	c703      	stmia	r7!, {r0, r1}
   2c92c:	3308      	adds	r3, #8
   2c92e:	4563      	cmp	r3, ip
   2c930:	463e      	mov	r6, r7
   2c932:	d1f7      	bne.n	2c924 <__utoa+0x10>
   2c934:	6818      	ldr	r0, [r3, #0]
   2c936:	791b      	ldrb	r3, [r3, #4]
   2c938:	713b      	strb	r3, [r7, #4]
   2c93a:	1e93      	subs	r3, r2, #2
   2c93c:	2b22      	cmp	r3, #34	; 0x22
   2c93e:	6038      	str	r0, [r7, #0]
   2c940:	f04f 0300 	mov.w	r3, #0
   2c944:	d904      	bls.n	2c950 <__utoa+0x3c>
   2c946:	7023      	strb	r3, [r4, #0]
   2c948:	461c      	mov	r4, r3
   2c94a:	4620      	mov	r0, r4
   2c94c:	b00b      	add	sp, #44	; 0x2c
   2c94e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2c950:	1e66      	subs	r6, r4, #1
   2c952:	fbb5 f0f2 	udiv	r0, r5, r2
   2c956:	af0a      	add	r7, sp, #40	; 0x28
   2c958:	fb02 5510 	mls	r5, r2, r0, r5
   2c95c:	443d      	add	r5, r7
   2c95e:	1c59      	adds	r1, r3, #1
   2c960:	f815 5c28 	ldrb.w	r5, [r5, #-40]
   2c964:	f806 5f01 	strb.w	r5, [r6, #1]!
   2c968:	4605      	mov	r5, r0
   2c96a:	b968      	cbnz	r0, 2c988 <__utoa+0x74>
   2c96c:	5460      	strb	r0, [r4, r1]
   2c96e:	4423      	add	r3, r4
   2c970:	4622      	mov	r2, r4
   2c972:	1b19      	subs	r1, r3, r4
   2c974:	1b10      	subs	r0, r2, r4
   2c976:	4281      	cmp	r1, r0
   2c978:	dde7      	ble.n	2c94a <__utoa+0x36>
   2c97a:	7811      	ldrb	r1, [r2, #0]
   2c97c:	7818      	ldrb	r0, [r3, #0]
   2c97e:	f802 0b01 	strb.w	r0, [r2], #1
   2c982:	f803 1901 	strb.w	r1, [r3], #-1
   2c986:	e7f4      	b.n	2c972 <__utoa+0x5e>
   2c988:	460b      	mov	r3, r1
   2c98a:	e7e2      	b.n	2c952 <__utoa+0x3e>
   2c98c:	00051be8 	.word	0x00051be8

0002c990 <atanf>:
   2c990:	b538      	push	{r3, r4, r5, lr}
   2c992:	ee10 5a10 	vmov	r5, s0
   2c996:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
   2c99a:	f1b4 4fa1 	cmp.w	r4, #1350565888	; 0x50800000
   2c99e:	eef0 7a40 	vmov.f32	s15, s0
   2c9a2:	db0f      	blt.n	2c9c4 <atanf+0x34>
   2c9a4:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   2c9a8:	dd04      	ble.n	2c9b4 <atanf+0x24>
   2c9aa:	ee70 7a00 	vadd.f32	s15, s0, s0
   2c9ae:	eeb0 0a67 	vmov.f32	s0, s15
   2c9b2:	bd38      	pop	{r3, r4, r5, pc}
   2c9b4:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 2cae8 <atanf+0x158>
   2c9b8:	eddf 7a4c 	vldr	s15, [pc, #304]	; 2caec <atanf+0x15c>
   2c9bc:	2d00      	cmp	r5, #0
   2c9be:	fe77 7a87 	vselgt.f32	s15, s15, s14
   2c9c2:	e7f4      	b.n	2c9ae <atanf+0x1e>
   2c9c4:	4b4a      	ldr	r3, [pc, #296]	; (2caf0 <atanf+0x160>)
   2c9c6:	429c      	cmp	r4, r3
   2c9c8:	dc10      	bgt.n	2c9ec <atanf+0x5c>
   2c9ca:	f1b4 5f44 	cmp.w	r4, #822083584	; 0x31000000
   2c9ce:	da0a      	bge.n	2c9e6 <atanf+0x56>
   2c9d0:	ed9f 7a48 	vldr	s14, [pc, #288]	; 2caf4 <atanf+0x164>
   2c9d4:	ee30 7a07 	vadd.f32	s14, s0, s14
   2c9d8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2c9dc:	eeb4 7ae6 	vcmpe.f32	s14, s13
   2c9e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c9e4:	dce3      	bgt.n	2c9ae <atanf+0x1e>
   2c9e6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c9ea:	e013      	b.n	2ca14 <atanf+0x84>
   2c9ec:	f000 f960 	bl	2ccb0 <fabsf>
   2c9f0:	4b41      	ldr	r3, [pc, #260]	; (2caf8 <atanf+0x168>)
   2c9f2:	429c      	cmp	r4, r3
   2c9f4:	dc4f      	bgt.n	2ca96 <atanf+0x106>
   2c9f6:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
   2c9fa:	429c      	cmp	r4, r3
   2c9fc:	dc41      	bgt.n	2ca82 <atanf+0xf2>
   2c9fe:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   2ca02:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   2ca06:	eea0 7a27 	vfma.f32	s14, s0, s15
   2ca0a:	2300      	movs	r3, #0
   2ca0c:	ee30 0a27 	vadd.f32	s0, s0, s15
   2ca10:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2ca14:	1c5a      	adds	r2, r3, #1
   2ca16:	ee27 6aa7 	vmul.f32	s12, s15, s15
   2ca1a:	ed9f 7a38 	vldr	s14, [pc, #224]	; 2cafc <atanf+0x16c>
   2ca1e:	eddf 5a38 	vldr	s11, [pc, #224]	; 2cb00 <atanf+0x170>
   2ca22:	ed9f 5a38 	vldr	s10, [pc, #224]	; 2cb04 <atanf+0x174>
   2ca26:	ee66 6a06 	vmul.f32	s13, s12, s12
   2ca2a:	eee6 5a87 	vfma.f32	s11, s13, s14
   2ca2e:	ed9f 7a36 	vldr	s14, [pc, #216]	; 2cb08 <atanf+0x178>
   2ca32:	eea5 7aa6 	vfma.f32	s14, s11, s13
   2ca36:	eddf 5a35 	vldr	s11, [pc, #212]	; 2cb0c <atanf+0x17c>
   2ca3a:	eee7 5a26 	vfma.f32	s11, s14, s13
   2ca3e:	ed9f 7a34 	vldr	s14, [pc, #208]	; 2cb10 <atanf+0x180>
   2ca42:	eea5 7aa6 	vfma.f32	s14, s11, s13
   2ca46:	eddf 5a33 	vldr	s11, [pc, #204]	; 2cb14 <atanf+0x184>
   2ca4a:	eee7 5a26 	vfma.f32	s11, s14, s13
   2ca4e:	ed9f 7a32 	vldr	s14, [pc, #200]	; 2cb18 <atanf+0x188>
   2ca52:	eea6 5a87 	vfma.f32	s10, s13, s14
   2ca56:	ed9f 7a31 	vldr	s14, [pc, #196]	; 2cb1c <atanf+0x18c>
   2ca5a:	eea5 7a26 	vfma.f32	s14, s10, s13
   2ca5e:	ed9f 5a30 	vldr	s10, [pc, #192]	; 2cb20 <atanf+0x190>
   2ca62:	eea7 5a26 	vfma.f32	s10, s14, s13
   2ca66:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 2cb24 <atanf+0x194>
   2ca6a:	eea5 7a26 	vfma.f32	s14, s10, s13
   2ca6e:	ee27 7a26 	vmul.f32	s14, s14, s13
   2ca72:	eea5 7a86 	vfma.f32	s14, s11, s12
   2ca76:	ee27 7a27 	vmul.f32	s14, s14, s15
   2ca7a:	d121      	bne.n	2cac0 <atanf+0x130>
   2ca7c:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2ca80:	e795      	b.n	2c9ae <atanf+0x1e>
   2ca82:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2ca86:	ee30 7a67 	vsub.f32	s14, s0, s15
   2ca8a:	ee30 0a27 	vadd.f32	s0, s0, s15
   2ca8e:	2301      	movs	r3, #1
   2ca90:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2ca94:	e7be      	b.n	2ca14 <atanf+0x84>
   2ca96:	4b24      	ldr	r3, [pc, #144]	; (2cb28 <atanf+0x198>)
   2ca98:	429c      	cmp	r4, r3
   2ca9a:	dc0b      	bgt.n	2cab4 <atanf+0x124>
   2ca9c:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
   2caa0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2caa4:	eea0 7a27 	vfma.f32	s14, s0, s15
   2caa8:	2302      	movs	r3, #2
   2caaa:	ee70 6a67 	vsub.f32	s13, s0, s15
   2caae:	eec6 7a87 	vdiv.f32	s15, s13, s14
   2cab2:	e7af      	b.n	2ca14 <atanf+0x84>
   2cab4:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   2cab8:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2cabc:	2303      	movs	r3, #3
   2cabe:	e7a9      	b.n	2ca14 <atanf+0x84>
   2cac0:	4a1a      	ldr	r2, [pc, #104]	; (2cb2c <atanf+0x19c>)
   2cac2:	491b      	ldr	r1, [pc, #108]	; (2cb30 <atanf+0x1a0>)
   2cac4:	009b      	lsls	r3, r3, #2
   2cac6:	441a      	add	r2, r3
   2cac8:	440b      	add	r3, r1
   2caca:	edd3 6a00 	vldr	s13, [r3]
   2cace:	ee37 7a66 	vsub.f32	s14, s14, s13
   2cad2:	2d00      	cmp	r5, #0
   2cad4:	ee77 7a67 	vsub.f32	s15, s14, s15
   2cad8:	ed92 7a00 	vldr	s14, [r2]
   2cadc:	ee77 7a67 	vsub.f32	s15, s14, s15
   2cae0:	bfb8      	it	lt
   2cae2:	eef1 7a67 	vneglt.f32	s15, s15
   2cae6:	e762      	b.n	2c9ae <atanf+0x1e>
   2cae8:	bfc90fdb 	.word	0xbfc90fdb
   2caec:	3fc90fdb 	.word	0x3fc90fdb
   2caf0:	3edfffff 	.word	0x3edfffff
   2caf4:	7149f2ca 	.word	0x7149f2ca
   2caf8:	3f97ffff 	.word	0x3f97ffff
   2cafc:	3c8569d7 	.word	0x3c8569d7
   2cb00:	3d4bda59 	.word	0x3d4bda59
   2cb04:	bd6ef16b 	.word	0xbd6ef16b
   2cb08:	3d886b35 	.word	0x3d886b35
   2cb0c:	3dba2e6e 	.word	0x3dba2e6e
   2cb10:	3e124925 	.word	0x3e124925
   2cb14:	3eaaaaab 	.word	0x3eaaaaab
   2cb18:	bd15a221 	.word	0xbd15a221
   2cb1c:	bd9d8795 	.word	0xbd9d8795
   2cb20:	bde38e38 	.word	0xbde38e38
   2cb24:	be4ccccd 	.word	0xbe4ccccd
   2cb28:	401bffff 	.word	0x401bffff
   2cb2c:	00051c10 	.word	0x00051c10
   2cb30:	00051c20 	.word	0x00051c20

0002cb34 <cosf>:
   2cb34:	ee10 3a10 	vmov	r3, s0
   2cb38:	b507      	push	{r0, r1, r2, lr}
   2cb3a:	4a1c      	ldr	r2, [pc, #112]	; (2cbac <cosf+0x78>)
   2cb3c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2cb40:	4293      	cmp	r3, r2
   2cb42:	dc04      	bgt.n	2cb4e <cosf+0x1a>
   2cb44:	eddf 0a1a 	vldr	s1, [pc, #104]	; 2cbb0 <cosf+0x7c>
   2cb48:	f001 fd40 	bl	2e5cc <__kernel_cosf>
   2cb4c:	e004      	b.n	2cb58 <cosf+0x24>
   2cb4e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2cb52:	db04      	blt.n	2cb5e <cosf+0x2a>
   2cb54:	ee30 0a40 	vsub.f32	s0, s0, s0
   2cb58:	b003      	add	sp, #12
   2cb5a:	f85d fb04 	ldr.w	pc, [sp], #4
   2cb5e:	4668      	mov	r0, sp
   2cb60:	f001 fb9a 	bl	2e298 <__ieee754_rem_pio2f>
   2cb64:	f000 0003 	and.w	r0, r0, #3
   2cb68:	2801      	cmp	r0, #1
   2cb6a:	d007      	beq.n	2cb7c <cosf+0x48>
   2cb6c:	2802      	cmp	r0, #2
   2cb6e:	d00e      	beq.n	2cb8e <cosf+0x5a>
   2cb70:	b9a0      	cbnz	r0, 2cb9c <cosf+0x68>
   2cb72:	eddd 0a01 	vldr	s1, [sp, #4]
   2cb76:	ed9d 0a00 	vldr	s0, [sp]
   2cb7a:	e7e5      	b.n	2cb48 <cosf+0x14>
   2cb7c:	eddd 0a01 	vldr	s1, [sp, #4]
   2cb80:	ed9d 0a00 	vldr	s0, [sp]
   2cb84:	f002 f802 	bl	2eb8c <__kernel_sinf>
   2cb88:	eeb1 0a40 	vneg.f32	s0, s0
   2cb8c:	e7e4      	b.n	2cb58 <cosf+0x24>
   2cb8e:	eddd 0a01 	vldr	s1, [sp, #4]
   2cb92:	ed9d 0a00 	vldr	s0, [sp]
   2cb96:	f001 fd19 	bl	2e5cc <__kernel_cosf>
   2cb9a:	e7f5      	b.n	2cb88 <cosf+0x54>
   2cb9c:	2001      	movs	r0, #1
   2cb9e:	eddd 0a01 	vldr	s1, [sp, #4]
   2cba2:	ed9d 0a00 	vldr	s0, [sp]
   2cba6:	f001 fff1 	bl	2eb8c <__kernel_sinf>
   2cbaa:	e7d5      	b.n	2cb58 <cosf+0x24>
   2cbac:	3f490fd8 	.word	0x3f490fd8
   2cbb0:	00000000 	.word	0x00000000

0002cbb4 <expf>:
   2cbb4:	ee10 2a10 	vmov	r2, s0
   2cbb8:	f240 412a 	movw	r1, #1066	; 0x42a
   2cbbc:	f3c2 530a 	ubfx	r3, r2, #20, #11
   2cbc0:	428b      	cmp	r3, r1
   2cbc2:	e92d 0830 	stmdb	sp!, {r4, r5, fp}
   2cbc6:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
   2cbca:	d92e      	bls.n	2cc2a <expf+0x76>
   2cbcc:	f512 0f00 	cmn.w	r2, #8388608	; 0x800000
   2cbd0:	d061      	beq.n	2cc96 <expf+0xe2>
   2cbd2:	f5b3 6fff 	cmp.w	r3, #2040	; 0x7f8
   2cbd6:	d304      	bcc.n	2cbe2 <expf+0x2e>
   2cbd8:	ee30 0a00 	vadd.f32	s0, s0, s0
   2cbdc:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   2cbe0:	4770      	bx	lr
   2cbe2:	eddf 7a2e 	vldr	s15, [pc, #184]	; 2cc9c <expf+0xe8>
   2cbe6:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2cbea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cbee:	dd04      	ble.n	2cbfa <expf+0x46>
   2cbf0:	2000      	movs	r0, #0
   2cbf2:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   2cbf6:	f002 b91b 	b.w	2ee30 <__math_oflowf>
   2cbfa:	eddf 7a29 	vldr	s15, [pc, #164]	; 2cca0 <expf+0xec>
   2cbfe:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2cc02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cc06:	d504      	bpl.n	2cc12 <expf+0x5e>
   2cc08:	2000      	movs	r0, #0
   2cc0a:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   2cc0e:	f002 b903 	b.w	2ee18 <__math_uflowf>
   2cc12:	eddf 7a24 	vldr	s15, [pc, #144]	; 2cca4 <expf+0xf0>
   2cc16:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2cc1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cc1e:	d504      	bpl.n	2cc2a <expf+0x76>
   2cc20:	2000      	movs	r0, #0
   2cc22:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   2cc26:	f002 b8fd 	b.w	2ee24 <__math_may_uflowf>
   2cc2a:	491f      	ldr	r1, [pc, #124]	; (2cca8 <expf+0xf4>)
   2cc2c:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
   2cc30:	ed91 5b4a 	vldr	d5, [r1, #296]	; 0x128
   2cc34:	ed91 7b48 	vldr	d7, [r1, #288]	; 0x120
   2cc38:	eeb0 4b47 	vmov.f64	d4, d7
   2cc3c:	eea5 4b06 	vfma.f64	d4, d5, d6
   2cc40:	ec55 4b14 	vmov	r4, r5, d4
   2cc44:	ee34 7b47 	vsub.f64	d7, d4, d7
   2cc48:	f004 021f 	and.w	r2, r4, #31
   2cc4c:	ee95 7b06 	vfnms.f64	d7, d5, d6
   2cc50:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   2cc54:	ed91 6b50 	vldr	d6, [r1, #320]	; 0x140
   2cc58:	e9d2 4500 	ldrd	r4, r5, [r2]
   2cc5c:	eea6 0b07 	vfma.f64	d0, d6, d7
   2cc60:	ee14 0a10 	vmov	r0, s8
   2cc64:	ed91 5b4c 	vldr	d5, [r1, #304]	; 0x130
   2cc68:	ed91 6b4e 	vldr	d6, [r1, #312]	; 0x138
   2cc6c:	f04f 0b00 	mov.w	fp, #0
   2cc70:	eb1b 0204 	adds.w	r2, fp, r4
   2cc74:	ea4f 3cc0 	mov.w	ip, r0, lsl #15
   2cc78:	eb4c 0305 	adc.w	r3, ip, r5
   2cc7c:	eea5 6b07 	vfma.f64	d6, d5, d7
   2cc80:	ee27 7b07 	vmul.f64	d7, d7, d7
   2cc84:	eea6 0b07 	vfma.f64	d0, d6, d7
   2cc88:	ec43 2b17 	vmov	d7, r2, r3
   2cc8c:	ee20 0b07 	vmul.f64	d0, d0, d7
   2cc90:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2cc94:	e7a2      	b.n	2cbdc <expf+0x28>
   2cc96:	ed9f 0a05 	vldr	s0, [pc, #20]	; 2ccac <expf+0xf8>
   2cc9a:	e79f      	b.n	2cbdc <expf+0x28>
   2cc9c:	42b17217 	.word	0x42b17217
   2cca0:	c2cff1b4 	.word	0xc2cff1b4
   2cca4:	c2ce8ecf 	.word	0xc2ce8ecf
   2cca8:	00051c30 	.word	0x00051c30
   2ccac:	00000000 	.word	0x00000000

0002ccb0 <fabsf>:
   2ccb0:	ee10 3a10 	vmov	r3, s0
   2ccb4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2ccb8:	ee00 3a10 	vmov	s0, r3
   2ccbc:	4770      	bx	lr
	...

0002ccc0 <logf>:
   2ccc0:	ee10 3a10 	vmov	r3, s0
   2ccc4:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
   2ccc8:	b410      	push	{r4}
   2ccca:	d057      	beq.n	2cd7c <logf+0xbc>
   2cccc:	f5a3 0200 	sub.w	r2, r3, #8388608	; 0x800000
   2ccd0:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
   2ccd4:	d31a      	bcc.n	2cd0c <logf+0x4c>
   2ccd6:	005a      	lsls	r2, r3, #1
   2ccd8:	d104      	bne.n	2cce4 <logf+0x24>
   2ccda:	2001      	movs	r0, #1
   2ccdc:	f85d 4b04 	ldr.w	r4, [sp], #4
   2cce0:	f002 b8ac 	b.w	2ee3c <__math_divzerof>
   2cce4:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2cce8:	d045      	beq.n	2cd76 <logf+0xb6>
   2ccea:	2b00      	cmp	r3, #0
   2ccec:	db02      	blt.n	2ccf4 <logf+0x34>
   2ccee:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
   2ccf2:	d303      	bcc.n	2ccfc <logf+0x3c>
   2ccf4:	f85d 4b04 	ldr.w	r4, [sp], #4
   2ccf8:	f002 b8b0 	b.w	2ee5c <__math_invalidf>
   2ccfc:	eddf 7a21 	vldr	s15, [pc, #132]	; 2cd84 <logf+0xc4>
   2cd00:	ee20 0a27 	vmul.f32	s0, s0, s15
   2cd04:	ee10 3a10 	vmov	r3, s0
   2cd08:	f1a3 6338 	sub.w	r3, r3, #192937984	; 0xb800000
   2cd0c:	f103 4240 	add.w	r2, r3, #3221225472	; 0xc0000000
   2cd10:	491d      	ldr	r1, [pc, #116]	; (2cd88 <logf+0xc8>)
   2cd12:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
   2cd16:	f502 024d 	add.w	r2, r2, #13434880	; 0xcd0000
   2cd1a:	f3c2 40c3 	ubfx	r0, r2, #19, #4
   2cd1e:	0dd4      	lsrs	r4, r2, #23
   2cd20:	eb01 1000 	add.w	r0, r1, r0, lsl #4
   2cd24:	05e4      	lsls	r4, r4, #23
   2cd26:	ed90 5b00 	vldr	d5, [r0]
   2cd2a:	1b1b      	subs	r3, r3, r4
   2cd2c:	ee07 3a90 	vmov	s15, r3
   2cd30:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
   2cd34:	eea5 6b07 	vfma.f64	d6, d5, d7
   2cd38:	ed91 5b44 	vldr	d5, [r1, #272]	; 0x110
   2cd3c:	ee26 3b06 	vmul.f64	d3, d6, d6
   2cd40:	ed91 7b46 	vldr	d7, [r1, #280]	; 0x118
   2cd44:	eea5 7b06 	vfma.f64	d7, d5, d6
   2cd48:	ed91 5b42 	vldr	d5, [r1, #264]	; 0x108
   2cd4c:	15d2      	asrs	r2, r2, #23
   2cd4e:	ed91 4b40 	vldr	d4, [r1, #256]	; 0x100
   2cd52:	eea5 7b03 	vfma.f64	d7, d5, d3
   2cd56:	eeb0 5b47 	vmov.f64	d5, d7
   2cd5a:	ed90 0b02 	vldr	d0, [r0, #8]
   2cd5e:	ee07 2a90 	vmov	s15, r2
   2cd62:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   2cd66:	eea7 0b04 	vfma.f64	d0, d7, d4
   2cd6a:	ee30 0b06 	vadd.f64	d0, d0, d6
   2cd6e:	eea3 0b05 	vfma.f64	d0, d3, d5
   2cd72:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2cd76:	f85d 4b04 	ldr.w	r4, [sp], #4
   2cd7a:	4770      	bx	lr
   2cd7c:	ed9f 0a03 	vldr	s0, [pc, #12]	; 2cd8c <logf+0xcc>
   2cd80:	e7f9      	b.n	2cd76 <logf+0xb6>
   2cd82:	bf00      	nop
   2cd84:	4b000000 	.word	0x4b000000
   2cd88:	00051e98 	.word	0x00051e98
   2cd8c:	00000000 	.word	0x00000000

0002cd90 <log2f>:
   2cd90:	ee10 2a10 	vmov	r2, s0
   2cd94:	f1b2 5f7e 	cmp.w	r2, #1065353216	; 0x3f800000
   2cd98:	b410      	push	{r4}
   2cd9a:	d057      	beq.n	2ce4c <log2f+0xbc>
   2cd9c:	f5a2 0300 	sub.w	r3, r2, #8388608	; 0x800000
   2cda0:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   2cda4:	d31a      	bcc.n	2cddc <log2f+0x4c>
   2cda6:	0053      	lsls	r3, r2, #1
   2cda8:	d104      	bne.n	2cdb4 <log2f+0x24>
   2cdaa:	2001      	movs	r0, #1
   2cdac:	f85d 4b04 	ldr.w	r4, [sp], #4
   2cdb0:	f002 b844 	b.w	2ee3c <__math_divzerof>
   2cdb4:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
   2cdb8:	d045      	beq.n	2ce46 <log2f+0xb6>
   2cdba:	2a00      	cmp	r2, #0
   2cdbc:	db02      	blt.n	2cdc4 <log2f+0x34>
   2cdbe:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   2cdc2:	d303      	bcc.n	2cdcc <log2f+0x3c>
   2cdc4:	f85d 4b04 	ldr.w	r4, [sp], #4
   2cdc8:	f002 b848 	b.w	2ee5c <__math_invalidf>
   2cdcc:	eddf 7a21 	vldr	s15, [pc, #132]	; 2ce54 <log2f+0xc4>
   2cdd0:	ee20 0a27 	vmul.f32	s0, s0, s15
   2cdd4:	ee10 3a10 	vmov	r3, s0
   2cdd8:	f1a3 6238 	sub.w	r2, r3, #192937984	; 0xb800000
   2cddc:	f102 4340 	add.w	r3, r2, #3221225472	; 0xc0000000
   2cde0:	491d      	ldr	r1, [pc, #116]	; (2ce58 <log2f+0xc8>)
   2cde2:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
   2cde6:	f503 034d 	add.w	r3, r3, #13434880	; 0xcd0000
   2cdea:	f3c3 40c3 	ubfx	r0, r3, #19, #4
   2cdee:	0ddc      	lsrs	r4, r3, #23
   2cdf0:	eb01 1000 	add.w	r0, r1, r0, lsl #4
   2cdf4:	05e4      	lsls	r4, r4, #23
   2cdf6:	ed90 5b00 	vldr	d5, [r0]
   2cdfa:	1b12      	subs	r2, r2, r4
   2cdfc:	ee07 2a90 	vmov	s15, r2
   2ce00:	ed91 4b42 	vldr	d4, [r1, #264]	; 0x108
   2ce04:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
   2ce08:	eea5 6b07 	vfma.f64	d6, d5, d7
   2ce0c:	eeb0 7b46 	vmov.f64	d7, d6
   2ce10:	ee26 5b06 	vmul.f64	d5, d6, d6
   2ce14:	ed91 6b44 	vldr	d6, [r1, #272]	; 0x110
   2ce18:	eea4 6b07 	vfma.f64	d6, d4, d7
   2ce1c:	ed91 4b40 	vldr	d4, [r1, #256]	; 0x100
   2ce20:	15db      	asrs	r3, r3, #23
   2ce22:	eea4 6b05 	vfma.f64	d6, d4, d5
   2ce26:	ed90 4b02 	vldr	d4, [r0, #8]
   2ce2a:	ee00 3a10 	vmov	s0, r3
   2ce2e:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
   2ce32:	ee30 0b04 	vadd.f64	d0, d0, d4
   2ce36:	ed91 4b46 	vldr	d4, [r1, #280]	; 0x118
   2ce3a:	eea4 0b07 	vfma.f64	d0, d4, d7
   2ce3e:	eea5 0b06 	vfma.f64	d0, d5, d6
   2ce42:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2ce46:	f85d 4b04 	ldr.w	r4, [sp], #4
   2ce4a:	4770      	bx	lr
   2ce4c:	ed9f 0a03 	vldr	s0, [pc, #12]	; 2ce5c <log2f+0xcc>
   2ce50:	e7f9      	b.n	2ce46 <log2f+0xb6>
   2ce52:	bf00      	nop
   2ce54:	4b000000 	.word	0x4b000000
   2ce58:	00051d78 	.word	0x00051d78
   2ce5c:	00000000 	.word	0x00000000

0002ce60 <checkint>:
   2ce60:	f3c0 53c7 	ubfx	r3, r0, #23, #8
   2ce64:	2b7e      	cmp	r3, #126	; 0x7e
   2ce66:	dd10      	ble.n	2ce8a <checkint+0x2a>
   2ce68:	2b96      	cmp	r3, #150	; 0x96
   2ce6a:	dc0c      	bgt.n	2ce86 <checkint+0x26>
   2ce6c:	2201      	movs	r2, #1
   2ce6e:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
   2ce72:	fa02 f303 	lsl.w	r3, r2, r3
   2ce76:	1e5a      	subs	r2, r3, #1
   2ce78:	4202      	tst	r2, r0
   2ce7a:	d106      	bne.n	2ce8a <checkint+0x2a>
   2ce7c:	4203      	tst	r3, r0
   2ce7e:	bf0c      	ite	eq
   2ce80:	2002      	moveq	r0, #2
   2ce82:	2001      	movne	r0, #1
   2ce84:	4770      	bx	lr
   2ce86:	2002      	movs	r0, #2
   2ce88:	4770      	bx	lr
   2ce8a:	2000      	movs	r0, #0
   2ce8c:	4770      	bx	lr
	...

0002ce90 <powf>:
   2ce90:	ee10 1a10 	vmov	r1, s0
   2ce94:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
   2ce98:	ee10 4a90 	vmov	r4, s1
   2ce9c:	f5a1 0300 	sub.w	r3, r1, #8388608	; 0x800000
   2cea0:	0062      	lsls	r2, r4, #1
   2cea2:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   2cea6:	eef0 4a60 	vmov.f32	s9, s1
   2ceaa:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
   2ceae:	4b92      	ldr	r3, [pc, #584]	; (2d0f8 <powf+0x268>)
   2ceb0:	d255      	bcs.n	2cf5e <powf+0xce>
   2ceb2:	4298      	cmp	r0, r3
   2ceb4:	d855      	bhi.n	2cf62 <powf+0xd2>
   2ceb6:	2000      	movs	r0, #0
   2ceb8:	f101 4340 	add.w	r3, r1, #3221225472	; 0xc0000000
   2cebc:	4a8f      	ldr	r2, [pc, #572]	; (2d0fc <powf+0x26c>)
   2cebe:	eebf 2b00 	vmov.f64	d2, #240	; 0xbf800000 -1.0
   2cec2:	f503 034d 	add.w	r3, r3, #13434880	; 0xcd0000
   2cec6:	f3c3 44c3 	ubfx	r4, r3, #19, #4
   2ceca:	0ddb      	lsrs	r3, r3, #23
   2cecc:	eb02 1404 	add.w	r4, r2, r4, lsl #4
   2ced0:	05db      	lsls	r3, r3, #23
   2ced2:	ed94 6b00 	vldr	d6, [r4]
   2ced6:	1ac9      	subs	r1, r1, r3
   2ced8:	ee07 1a90 	vmov	s15, r1
   2cedc:	ed92 5b40 	vldr	d5, [r2, #256]	; 0x100
   2cee0:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
   2cee4:	eea6 2b07 	vfma.f64	d2, d6, d7
   2cee8:	ed92 7b42 	vldr	d7, [r2, #264]	; 0x108
   2ceec:	ee22 6b02 	vmul.f64	d6, d2, d2
   2cef0:	eea2 7b05 	vfma.f64	d7, d2, d5
   2cef4:	15db      	asrs	r3, r3, #23
   2cef6:	ed94 5b02 	vldr	d5, [r4, #8]
   2cefa:	ee00 3a10 	vmov	s0, r3
   2cefe:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
   2cf02:	ee30 0b05 	vadd.f64	d0, d0, d5
   2cf06:	ed92 5b48 	vldr	d5, [r2, #288]	; 0x120
   2cf0a:	ed92 3b44 	vldr	d3, [r2, #272]	; 0x110
   2cf0e:	eea2 0b05 	vfma.f64	d0, d2, d5
   2cf12:	ed92 5b46 	vldr	d5, [r2, #280]	; 0x118
   2cf16:	eea2 5b03 	vfma.f64	d5, d2, d3
   2cf1a:	eea6 0b05 	vfma.f64	d0, d6, d5
   2cf1e:	ee26 6b06 	vmul.f64	d6, d6, d6
   2cf22:	eea7 0b06 	vfma.f64	d0, d7, d6
   2cf26:	eeb7 7ae4 	vcvt.f64.f32	d7, s9
   2cf2a:	ee20 0b07 	vmul.f64	d0, d0, d7
   2cf2e:	ee10 3a90 	vmov	r3, s1
   2cf32:	2500      	movs	r5, #0
   2cf34:	0bda      	lsrs	r2, r3, #15
   2cf36:	2300      	movs	r3, #0
   2cf38:	b292      	uxth	r2, r2
   2cf3a:	f248 04be 	movw	r4, #32958	; 0x80be
   2cf3e:	429d      	cmp	r5, r3
   2cf40:	bf08      	it	eq
   2cf42:	4294      	cmpeq	r4, r2
   2cf44:	f080 8094 	bcs.w	2d070 <powf+0x1e0>
   2cf48:	ed9f 7b65 	vldr	d7, [pc, #404]	; 2d0e0 <powf+0x250>
   2cf4c:	eeb4 0bc7 	vcmpe.f64	d0, d7
   2cf50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cf54:	dd76      	ble.n	2d044 <powf+0x1b4>
   2cf56:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   2cf5a:	f001 bf69 	b.w	2ee30 <__math_oflowf>
   2cf5e:	4298      	cmp	r0, r3
   2cf60:	d92d      	bls.n	2cfbe <powf+0x12e>
   2cf62:	b952      	cbnz	r2, 2cf7a <powf+0xea>
   2cf64:	f481 0380 	eor.w	r3, r1, #4194304	; 0x400000
   2cf68:	005b      	lsls	r3, r3, #1
   2cf6a:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
   2cf6e:	f240 80ae 	bls.w	2d0ce <powf+0x23e>
   2cf72:	ee30 0a24 	vadd.f32	s0, s0, s9
   2cf76:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
   2cf7a:	f1b1 5f7e 	cmp.w	r1, #1065353216	; 0x3f800000
   2cf7e:	d105      	bne.n	2cf8c <powf+0xfc>
   2cf80:	f484 0480 	eor.w	r4, r4, #4194304	; 0x400000
   2cf84:	0064      	lsls	r4, r4, #1
   2cf86:	f514 0f00 	cmn.w	r4, #8388608	; 0x800000
   2cf8a:	e7f0      	b.n	2cf6e <powf+0xde>
   2cf8c:	004b      	lsls	r3, r1, #1
   2cf8e:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   2cf92:	d8ee      	bhi.n	2cf72 <powf+0xe2>
   2cf94:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
   2cf98:	d1eb      	bne.n	2cf72 <powf+0xe2>
   2cf9a:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   2cf9e:	f000 8096 	beq.w	2d0ce <powf+0x23e>
   2cfa2:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   2cfa6:	ea6f 0404 	mvn.w	r4, r4
   2cfaa:	bf34      	ite	cc
   2cfac:	2300      	movcc	r3, #0
   2cfae:	2301      	movcs	r3, #1
   2cfb0:	0fe4      	lsrs	r4, r4, #31
   2cfb2:	42a3      	cmp	r3, r4
   2cfb4:	f040 808e 	bne.w	2d0d4 <powf+0x244>
   2cfb8:	ee24 0aa4 	vmul.f32	s0, s9, s9
   2cfbc:	e7db      	b.n	2cf76 <powf+0xe6>
   2cfbe:	004d      	lsls	r5, r1, #1
   2cfc0:	1e6a      	subs	r2, r5, #1
   2cfc2:	429a      	cmp	r2, r3
   2cfc4:	d91b      	bls.n	2cffe <powf+0x16e>
   2cfc6:	2900      	cmp	r1, #0
   2cfc8:	ee20 0a00 	vmul.f32	s0, s0, s0
   2cfcc:	da0e      	bge.n	2cfec <powf+0x15c>
   2cfce:	ee10 0a90 	vmov	r0, s1
   2cfd2:	f7ff ff45 	bl	2ce60 <checkint>
   2cfd6:	2801      	cmp	r0, #1
   2cfd8:	d108      	bne.n	2cfec <powf+0x15c>
   2cfda:	eeb1 0a40 	vneg.f32	s0, s0
   2cfde:	b93d      	cbnz	r5, 2cff0 <powf+0x160>
   2cfe0:	2c00      	cmp	r4, #0
   2cfe2:	dac8      	bge.n	2cf76 <powf+0xe6>
   2cfe4:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   2cfe8:	f001 bf28 	b.w	2ee3c <__math_divzerof>
   2cfec:	2000      	movs	r0, #0
   2cfee:	e7f6      	b.n	2cfde <powf+0x14e>
   2cff0:	2c00      	cmp	r4, #0
   2cff2:	dac0      	bge.n	2cf76 <powf+0xe6>
   2cff4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2cff8:	ee87 0a80 	vdiv.f32	s0, s15, s0
   2cffc:	e7bb      	b.n	2cf76 <powf+0xe6>
   2cffe:	2900      	cmp	r1, #0
   2d000:	da1e      	bge.n	2d040 <powf+0x1b0>
   2d002:	ee10 0a90 	vmov	r0, s1
   2d006:	f7ff ff2b 	bl	2ce60 <checkint>
   2d00a:	b918      	cbnz	r0, 2d014 <powf+0x184>
   2d00c:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   2d010:	f001 bf24 	b.w	2ee5c <__math_invalidf>
   2d014:	2801      	cmp	r0, #1
   2d016:	bf0c      	ite	eq
   2d018:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
   2d01c:	2000      	movne	r0, #0
   2d01e:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   2d022:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
   2d026:	f4bf af47 	bcs.w	2ceb8 <powf+0x28>
   2d02a:	eddf 0a35 	vldr	s1, [pc, #212]	; 2d100 <powf+0x270>
   2d02e:	ee20 0a20 	vmul.f32	s0, s0, s1
   2d032:	ee10 3a10 	vmov	r3, s0
   2d036:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2d03a:	f1a3 6138 	sub.w	r1, r3, #192937984	; 0xb800000
   2d03e:	e73b      	b.n	2ceb8 <powf+0x28>
   2d040:	2000      	movs	r0, #0
   2d042:	e7ee      	b.n	2d022 <powf+0x192>
   2d044:	ed9f 7b28 	vldr	d7, [pc, #160]	; 2d0e8 <powf+0x258>
   2d048:	eeb4 0bc7 	vcmpe.f64	d0, d7
   2d04c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d050:	d803      	bhi.n	2d05a <powf+0x1ca>
   2d052:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   2d056:	f001 bedf 	b.w	2ee18 <__math_uflowf>
   2d05a:	ed9f 7b25 	vldr	d7, [pc, #148]	; 2d0f0 <powf+0x260>
   2d05e:	eeb4 0bc7 	vcmpe.f64	d0, d7
   2d062:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d066:	d503      	bpl.n	2d070 <powf+0x1e0>
   2d068:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   2d06c:	f001 beda 	b.w	2ee24 <__math_may_uflowf>
   2d070:	4924      	ldr	r1, [pc, #144]	; (2d104 <powf+0x274>)
   2d072:	ed91 7b40 	vldr	d7, [r1, #256]	; 0x100
   2d076:	ee30 6b07 	vadd.f64	d6, d0, d7
   2d07a:	ec55 4b16 	vmov	r4, r5, d6
   2d07e:	ee36 7b47 	vsub.f64	d7, d6, d7
   2d082:	f004 021f 	and.w	r2, r4, #31
   2d086:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   2d08a:	ed91 6b46 	vldr	d6, [r1, #280]	; 0x118
   2d08e:	ee30 0b47 	vsub.f64	d0, d0, d7
   2d092:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   2d096:	e9d2 6700 	ldrd	r6, r7, [r2]
   2d09a:	eea0 7b06 	vfma.f64	d7, d0, d6
   2d09e:	1824      	adds	r4, r4, r0
   2d0a0:	ed91 5b42 	vldr	d5, [r1, #264]	; 0x108
   2d0a4:	ed91 6b44 	vldr	d6, [r1, #272]	; 0x110
   2d0a8:	2000      	movs	r0, #0
   2d0aa:	1982      	adds	r2, r0, r6
   2d0ac:	ea4f 31c4 	mov.w	r1, r4, lsl #15
   2d0b0:	eb41 0307 	adc.w	r3, r1, r7
   2d0b4:	eea0 6b05 	vfma.f64	d6, d0, d5
   2d0b8:	ee20 0b00 	vmul.f64	d0, d0, d0
   2d0bc:	eea6 7b00 	vfma.f64	d7, d6, d0
   2d0c0:	ec43 2b16 	vmov	d6, r2, r3
   2d0c4:	ee27 0b06 	vmul.f64	d0, d7, d6
   2d0c8:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2d0cc:	e753      	b.n	2cf76 <powf+0xe6>
   2d0ce:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2d0d2:	e750      	b.n	2cf76 <powf+0xe6>
   2d0d4:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 2d108 <powf+0x278>
   2d0d8:	e74d      	b.n	2cf76 <powf+0xe6>
   2d0da:	bf00      	nop
   2d0dc:	f3af 8000 	nop.w
   2d0e0:	ffd1d571 	.word	0xffd1d571
   2d0e4:	405fffff 	.word	0x405fffff
   2d0e8:	00000000 	.word	0x00000000
   2d0ec:	c062c000 	.word	0xc062c000
   2d0f0:	00000000 	.word	0x00000000
   2d0f4:	c062a000 	.word	0xc062a000
   2d0f8:	fefffffe 	.word	0xfefffffe
   2d0fc:	00051fb8 	.word	0x00051fb8
   2d100:	4b000000 	.word	0x4b000000
   2d104:	00051c30 	.word	0x00051c30
   2d108:	00000000 	.word	0x00000000

0002d10c <tanf>:
   2d10c:	ee10 3a10 	vmov	r3, s0
   2d110:	b507      	push	{r0, r1, r2, lr}
   2d112:	4a10      	ldr	r2, [pc, #64]	; (2d154 <tanf+0x48>)
   2d114:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2d118:	4293      	cmp	r3, r2
   2d11a:	dc05      	bgt.n	2d128 <tanf+0x1c>
   2d11c:	eddf 0a0e 	vldr	s1, [pc, #56]	; 2d158 <tanf+0x4c>
   2d120:	2001      	movs	r0, #1
   2d122:	f001 fd7b 	bl	2ec1c <__kernel_tanf>
   2d126:	e004      	b.n	2d132 <tanf+0x26>
   2d128:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2d12c:	db04      	blt.n	2d138 <tanf+0x2c>
   2d12e:	ee30 0a40 	vsub.f32	s0, s0, s0
   2d132:	b003      	add	sp, #12
   2d134:	f85d fb04 	ldr.w	pc, [sp], #4
   2d138:	4668      	mov	r0, sp
   2d13a:	f001 f8ad 	bl	2e298 <__ieee754_rem_pio2f>
   2d13e:	0040      	lsls	r0, r0, #1
   2d140:	f000 0002 	and.w	r0, r0, #2
   2d144:	f1c0 0001 	rsb	r0, r0, #1
   2d148:	eddd 0a01 	vldr	s1, [sp, #4]
   2d14c:	ed9d 0a00 	vldr	s0, [sp]
   2d150:	e7e7      	b.n	2d122 <tanf+0x16>
   2d152:	bf00      	nop
   2d154:	3f490fda 	.word	0x3f490fda
   2d158:	00000000 	.word	0x00000000

0002d15c <tanhf>:
   2d15c:	b510      	push	{r4, lr}
   2d15e:	ee10 4a10 	vmov	r4, s0
   2d162:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
   2d166:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2d16a:	ed2d 8b02 	vpush	{d8}
   2d16e:	eef0 7a40 	vmov.f32	s15, s0
   2d172:	db0c      	blt.n	2d18e <tanhf+0x32>
   2d174:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2d178:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2d17c:	2c00      	cmp	r4, #0
   2d17e:	bfac      	ite	ge
   2d180:	ee30 0a07 	vaddge.f32	s0, s0, s14
   2d184:	ee30 0a47 	vsublt.f32	s0, s0, s14
   2d188:	ecbd 8b02 	vpop	{d8}
   2d18c:	bd10      	pop	{r4, pc}
   2d18e:	4a1b      	ldr	r2, [pc, #108]	; (2d1fc <tanhf+0xa0>)
   2d190:	4293      	cmp	r3, r2
   2d192:	dc30      	bgt.n	2d1f6 <tanhf+0x9a>
   2d194:	f1b3 5f10 	cmp.w	r3, #603979776	; 0x24000000
   2d198:	da06      	bge.n	2d1a8 <tanhf+0x4c>
   2d19a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2d19e:	ee37 0a80 	vadd.f32	s0, s15, s0
   2d1a2:	ee20 0a27 	vmul.f32	s0, s0, s15
   2d1a6:	e7ef      	b.n	2d188 <tanhf+0x2c>
   2d1a8:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
   2d1ac:	eeb0 8a00 	vmov.f32	s16, #0	; 0x40000000  2.0
   2d1b0:	db12      	blt.n	2d1d8 <tanhf+0x7c>
   2d1b2:	f7ff fd7d 	bl	2ccb0 <fabsf>
   2d1b6:	ee30 0a00 	vadd.f32	s0, s0, s0
   2d1ba:	f001 ff83 	bl	2f0c4 <expm1f>
   2d1be:	ee30 0a08 	vadd.f32	s0, s0, s16
   2d1c2:	eec8 7a00 	vdiv.f32	s15, s16, s0
   2d1c6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2d1ca:	ee30 0a67 	vsub.f32	s0, s0, s15
   2d1ce:	2c00      	cmp	r4, #0
   2d1d0:	bfb8      	it	lt
   2d1d2:	eeb1 0a40 	vneglt.f32	s0, s0
   2d1d6:	e7d7      	b.n	2d188 <tanhf+0x2c>
   2d1d8:	f7ff fd6a 	bl	2ccb0 <fabsf>
   2d1dc:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
   2d1e0:	ee20 0a27 	vmul.f32	s0, s0, s15
   2d1e4:	f001 ff6e 	bl	2f0c4 <expm1f>
   2d1e8:	ee70 7a08 	vadd.f32	s15, s0, s16
   2d1ec:	eeb1 7a40 	vneg.f32	s14, s0
   2d1f0:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2d1f4:	e7eb      	b.n	2d1ce <tanhf+0x72>
   2d1f6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2d1fa:	e7e8      	b.n	2d1ce <tanhf+0x72>
   2d1fc:	41afffff 	.word	0x41afffff

0002d200 <exp>:
   2d200:	b510      	push	{r4, lr}
   2d202:	ed2d 8b04 	vpush	{d8-d9}
   2d206:	eeb0 8b40 	vmov.f64	d8, d0
   2d20a:	4c33      	ldr	r4, [pc, #204]	; (2d2d8 <exp+0xd8>)
   2d20c:	b08a      	sub	sp, #40	; 0x28
   2d20e:	f000 fad3 	bl	2d7b8 <__ieee754_exp>
   2d212:	f994 3000 	ldrsb.w	r3, [r4]
   2d216:	eeb0 9b40 	vmov.f64	d9, d0
   2d21a:	3301      	adds	r3, #1
   2d21c:	d029      	beq.n	2d272 <exp+0x72>
   2d21e:	eeb0 0b48 	vmov.f64	d0, d8
   2d222:	f001 fe33 	bl	2ee8c <finite>
   2d226:	b320      	cbz	r0, 2d272 <exp+0x72>
   2d228:	ed9f 7b27 	vldr	d7, [pc, #156]	; 2d2c8 <exp+0xc8>
   2d22c:	eeb4 8bc7 	vcmpe.f64	d8, d7
   2d230:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d234:	dd2e      	ble.n	2d294 <exp+0x94>
   2d236:	2303      	movs	r3, #3
   2d238:	9300      	str	r3, [sp, #0]
   2d23a:	4b28      	ldr	r3, [pc, #160]	; (2d2dc <exp+0xdc>)
   2d23c:	9301      	str	r3, [sp, #4]
   2d23e:	2300      	movs	r3, #0
   2d240:	9308      	str	r3, [sp, #32]
   2d242:	f994 3000 	ldrsb.w	r3, [r4]
   2d246:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d24a:	ed8d 8b02 	vstr	d8, [sp, #8]
   2d24e:	b9b3      	cbnz	r3, 2d27e <exp+0x7e>
   2d250:	4b23      	ldr	r3, [pc, #140]	; (2d2e0 <exp+0xe0>)
   2d252:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   2d256:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d25a:	4668      	mov	r0, sp
   2d25c:	f001 fe1e 	bl	2ee9c <matherr>
   2d260:	b198      	cbz	r0, 2d28a <exp+0x8a>
   2d262:	9b08      	ldr	r3, [sp, #32]
   2d264:	b11b      	cbz	r3, 2d26e <exp+0x6e>
   2d266:	f7ff faed 	bl	2c844 <__errno>
   2d26a:	9b08      	ldr	r3, [sp, #32]
   2d26c:	6003      	str	r3, [r0, #0]
   2d26e:	ed9d 9b06 	vldr	d9, [sp, #24]
   2d272:	eeb0 0b49 	vmov.f64	d0, d9
   2d276:	b00a      	add	sp, #40	; 0x28
   2d278:	ecbd 8b04 	vpop	{d8-d9}
   2d27c:	bd10      	pop	{r4, pc}
   2d27e:	4919      	ldr	r1, [pc, #100]	; (2d2e4 <exp+0xe4>)
   2d280:	2000      	movs	r0, #0
   2d282:	e9cd 0106 	strd	r0, r1, [sp, #24]
   2d286:	2b02      	cmp	r3, #2
   2d288:	d1e7      	bne.n	2d25a <exp+0x5a>
   2d28a:	f7ff fadb 	bl	2c844 <__errno>
   2d28e:	2322      	movs	r3, #34	; 0x22
   2d290:	6003      	str	r3, [r0, #0]
   2d292:	e7e6      	b.n	2d262 <exp+0x62>
   2d294:	ed9f 7b0e 	vldr	d7, [pc, #56]	; 2d2d0 <exp+0xd0>
   2d298:	eeb4 8bc7 	vcmpe.f64	d8, d7
   2d29c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d2a0:	d5e7      	bpl.n	2d272 <exp+0x72>
   2d2a2:	2304      	movs	r3, #4
   2d2a4:	9300      	str	r3, [sp, #0]
   2d2a6:	4b0d      	ldr	r3, [pc, #52]	; (2d2dc <exp+0xdc>)
   2d2a8:	9301      	str	r3, [sp, #4]
   2d2aa:	2300      	movs	r3, #0
   2d2ac:	9308      	str	r3, [sp, #32]
   2d2ae:	2200      	movs	r2, #0
   2d2b0:	2300      	movs	r3, #0
   2d2b2:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d2b6:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d2ba:	ed8d 8b02 	vstr	d8, [sp, #8]
   2d2be:	f994 3000 	ldrsb.w	r3, [r4]
   2d2c2:	e7e0      	b.n	2d286 <exp+0x86>
   2d2c4:	f3af 8000 	nop.w
   2d2c8:	fefa39ef 	.word	0xfefa39ef
   2d2cc:	40862e42 	.word	0x40862e42
   2d2d0:	d52d3051 	.word	0xd52d3051
   2d2d4:	c0874910 	.word	0xc0874910
   2d2d8:	000629f4 	.word	0x000629f4
   2d2dc:	000520e0 	.word	0x000520e0
   2d2e0:	47efffff 	.word	0x47efffff
   2d2e4:	7ff00000 	.word	0x7ff00000

0002d2e8 <pow>:
   2d2e8:	b570      	push	{r4, r5, r6, lr}
   2d2ea:	ed2d 8b0a 	vpush	{d8-d12}
   2d2ee:	eeb0 9b40 	vmov.f64	d9, d0
   2d2f2:	eeb0 8b41 	vmov.f64	d8, d1
   2d2f6:	4c8c      	ldr	r4, [pc, #560]	; (2d528 <pow+0x240>)
   2d2f8:	b08a      	sub	sp, #40	; 0x28
   2d2fa:	f000 fb65 	bl	2d9c8 <__ieee754_pow>
   2d2fe:	f994 3000 	ldrsb.w	r3, [r4]
   2d302:	eeb0 ab40 	vmov.f64	d10, d0
   2d306:	1c5a      	adds	r2, r3, #1
   2d308:	4626      	mov	r6, r4
   2d30a:	d04b      	beq.n	2d3a4 <pow+0xbc>
   2d30c:	eeb4 8b48 	vcmp.f64	d8, d8
   2d310:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d314:	d646      	bvs.n	2d3a4 <pow+0xbc>
   2d316:	eeb4 9b49 	vcmp.f64	d9, d9
   2d31a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d31e:	d719      	bvc.n	2d354 <pow+0x6c>
   2d320:	eeb5 8b40 	vcmp.f64	d8, #0.0
   2d324:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d328:	d13c      	bne.n	2d3a4 <pow+0xbc>
   2d32a:	2201      	movs	r2, #1
   2d32c:	9200      	str	r2, [sp, #0]
   2d32e:	497f      	ldr	r1, [pc, #508]	; (2d52c <pow+0x244>)
   2d330:	4a7f      	ldr	r2, [pc, #508]	; (2d530 <pow+0x248>)
   2d332:	9201      	str	r2, [sp, #4]
   2d334:	2000      	movs	r0, #0
   2d336:	2200      	movs	r2, #0
   2d338:	2b02      	cmp	r3, #2
   2d33a:	9208      	str	r2, [sp, #32]
   2d33c:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d340:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d344:	e9cd 0106 	strd	r0, r1, [sp, #24]
   2d348:	d02a      	beq.n	2d3a0 <pow+0xb8>
   2d34a:	4668      	mov	r0, sp
   2d34c:	f001 fda6 	bl	2ee9c <matherr>
   2d350:	bb00      	cbnz	r0, 2d394 <pow+0xac>
   2d352:	e04e      	b.n	2d3f2 <pow+0x10a>
   2d354:	ed9f bb72 	vldr	d11, [pc, #456]	; 2d520 <pow+0x238>
   2d358:	eeb4 9b4b 	vcmp.f64	d9, d11
   2d35c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d360:	eeb0 cb4b 	vmov.f64	d12, d11
   2d364:	d14a      	bne.n	2d3fc <pow+0x114>
   2d366:	eeb4 8b4b 	vcmp.f64	d8, d11
   2d36a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d36e:	d11f      	bne.n	2d3b0 <pow+0xc8>
   2d370:	2201      	movs	r2, #1
   2d372:	9200      	str	r2, [sp, #0]
   2d374:	4a6e      	ldr	r2, [pc, #440]	; (2d530 <pow+0x248>)
   2d376:	9201      	str	r2, [sp, #4]
   2d378:	2200      	movs	r2, #0
   2d37a:	9208      	str	r2, [sp, #32]
   2d37c:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d380:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d384:	ed8d bb06 	vstr	d11, [sp, #24]
   2d388:	2b00      	cmp	r3, #0
   2d38a:	d0de      	beq.n	2d34a <pow+0x62>
   2d38c:	4b67      	ldr	r3, [pc, #412]	; (2d52c <pow+0x244>)
   2d38e:	2200      	movs	r2, #0
   2d390:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d394:	9b08      	ldr	r3, [sp, #32]
   2d396:	b11b      	cbz	r3, 2d3a0 <pow+0xb8>
   2d398:	f7ff fa54 	bl	2c844 <__errno>
   2d39c:	9b08      	ldr	r3, [sp, #32]
   2d39e:	6003      	str	r3, [r0, #0]
   2d3a0:	ed9d ab06 	vldr	d10, [sp, #24]
   2d3a4:	eeb0 0b4a 	vmov.f64	d0, d10
   2d3a8:	b00a      	add	sp, #40	; 0x28
   2d3aa:	ecbd 8b0a 	vpop	{d8-d12}
   2d3ae:	bd70      	pop	{r4, r5, r6, pc}
   2d3b0:	eeb0 0b48 	vmov.f64	d0, d8
   2d3b4:	f001 fd6a 	bl	2ee8c <finite>
   2d3b8:	2800      	cmp	r0, #0
   2d3ba:	d0f3      	beq.n	2d3a4 <pow+0xbc>
   2d3bc:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
   2d3c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d3c4:	d5ee      	bpl.n	2d3a4 <pow+0xbc>
   2d3c6:	2301      	movs	r3, #1
   2d3c8:	9300      	str	r3, [sp, #0]
   2d3ca:	4b59      	ldr	r3, [pc, #356]	; (2d530 <pow+0x248>)
   2d3cc:	9301      	str	r3, [sp, #4]
   2d3ce:	2300      	movs	r3, #0
   2d3d0:	9308      	str	r3, [sp, #32]
   2d3d2:	f994 3000 	ldrsb.w	r3, [r4]
   2d3d6:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d3da:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d3de:	b913      	cbnz	r3, 2d3e6 <pow+0xfe>
   2d3e0:	ed8d bb06 	vstr	d11, [sp, #24]
   2d3e4:	e7b1      	b.n	2d34a <pow+0x62>
   2d3e6:	4953      	ldr	r1, [pc, #332]	; (2d534 <pow+0x24c>)
   2d3e8:	2000      	movs	r0, #0
   2d3ea:	e9cd 0106 	strd	r0, r1, [sp, #24]
   2d3ee:	2b02      	cmp	r3, #2
   2d3f0:	d1ab      	bne.n	2d34a <pow+0x62>
   2d3f2:	f7ff fa27 	bl	2c844 <__errno>
   2d3f6:	2321      	movs	r3, #33	; 0x21
   2d3f8:	6003      	str	r3, [r0, #0]
   2d3fa:	e7cb      	b.n	2d394 <pow+0xac>
   2d3fc:	f001 fd46 	bl	2ee8c <finite>
   2d400:	4605      	mov	r5, r0
   2d402:	2800      	cmp	r0, #0
   2d404:	d164      	bne.n	2d4d0 <pow+0x1e8>
   2d406:	eeb0 0b49 	vmov.f64	d0, d9
   2d40a:	f001 fd3f 	bl	2ee8c <finite>
   2d40e:	2800      	cmp	r0, #0
   2d410:	d05e      	beq.n	2d4d0 <pow+0x1e8>
   2d412:	eeb0 0b48 	vmov.f64	d0, d8
   2d416:	f001 fd39 	bl	2ee8c <finite>
   2d41a:	2800      	cmp	r0, #0
   2d41c:	d058      	beq.n	2d4d0 <pow+0x1e8>
   2d41e:	eeb4 ab4a 	vcmp.f64	d10, d10
   2d422:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d426:	f994 3000 	ldrsb.w	r3, [r4]
   2d42a:	4a41      	ldr	r2, [pc, #260]	; (2d530 <pow+0x248>)
   2d42c:	d70e      	bvc.n	2d44c <pow+0x164>
   2d42e:	2101      	movs	r1, #1
   2d430:	e9cd 1200 	strd	r1, r2, [sp]
   2d434:	9508      	str	r5, [sp, #32]
   2d436:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d43a:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d43e:	2b00      	cmp	r3, #0
   2d440:	d0ce      	beq.n	2d3e0 <pow+0xf8>
   2d442:	ee8b 7b0b 	vdiv.f64	d7, d11, d11
   2d446:	ed8d 7b06 	vstr	d7, [sp, #24]
   2d44a:	e7d0      	b.n	2d3ee <pow+0x106>
   2d44c:	2103      	movs	r1, #3
   2d44e:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d452:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
   2d456:	ee28 8b07 	vmul.f64	d8, d8, d7
   2d45a:	e9cd 1200 	strd	r1, r2, [sp]
   2d45e:	9508      	str	r5, [sp, #32]
   2d460:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d464:	b9fb      	cbnz	r3, 2d4a6 <pow+0x1be>
   2d466:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
   2d46a:	4b33      	ldr	r3, [pc, #204]	; (2d538 <pow+0x250>)
   2d46c:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   2d470:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d474:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d478:	d54b      	bpl.n	2d512 <pow+0x22a>
   2d47a:	eeb0 0b48 	vmov.f64	d0, d8
   2d47e:	f001 fd17 	bl	2eeb0 <rint>
   2d482:	eeb4 0b48 	vcmp.f64	d0, d8
   2d486:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d48a:	d004      	beq.n	2d496 <pow+0x1ae>
   2d48c:	4b2b      	ldr	r3, [pc, #172]	; (2d53c <pow+0x254>)
   2d48e:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   2d492:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d496:	f996 3000 	ldrsb.w	r3, [r6]
   2d49a:	2b02      	cmp	r3, #2
   2d49c:	d139      	bne.n	2d512 <pow+0x22a>
   2d49e:	f7ff f9d1 	bl	2c844 <__errno>
   2d4a2:	2322      	movs	r3, #34	; 0x22
   2d4a4:	e7a8      	b.n	2d3f8 <pow+0x110>
   2d4a6:	4b26      	ldr	r3, [pc, #152]	; (2d540 <pow+0x258>)
   2d4a8:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
   2d4ac:	2200      	movs	r2, #0
   2d4ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d4b2:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d4b6:	d5ee      	bpl.n	2d496 <pow+0x1ae>
   2d4b8:	eeb0 0b48 	vmov.f64	d0, d8
   2d4bc:	f001 fcf8 	bl	2eeb0 <rint>
   2d4c0:	eeb4 0b48 	vcmp.f64	d0, d8
   2d4c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d4c8:	d0e5      	beq.n	2d496 <pow+0x1ae>
   2d4ca:	2200      	movs	r2, #0
   2d4cc:	4b19      	ldr	r3, [pc, #100]	; (2d534 <pow+0x24c>)
   2d4ce:	e7e0      	b.n	2d492 <pow+0x1aa>
   2d4d0:	eeb5 ab40 	vcmp.f64	d10, #0.0
   2d4d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d4d8:	f47f af64 	bne.w	2d3a4 <pow+0xbc>
   2d4dc:	eeb0 0b49 	vmov.f64	d0, d9
   2d4e0:	f001 fcd4 	bl	2ee8c <finite>
   2d4e4:	2800      	cmp	r0, #0
   2d4e6:	f43f af5d 	beq.w	2d3a4 <pow+0xbc>
   2d4ea:	eeb0 0b48 	vmov.f64	d0, d8
   2d4ee:	f001 fccd 	bl	2ee8c <finite>
   2d4f2:	2800      	cmp	r0, #0
   2d4f4:	f43f af56 	beq.w	2d3a4 <pow+0xbc>
   2d4f8:	2304      	movs	r3, #4
   2d4fa:	9300      	str	r3, [sp, #0]
   2d4fc:	4b0c      	ldr	r3, [pc, #48]	; (2d530 <pow+0x248>)
   2d4fe:	9301      	str	r3, [sp, #4]
   2d500:	2300      	movs	r3, #0
   2d502:	9308      	str	r3, [sp, #32]
   2d504:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d508:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d50c:	ed8d cb06 	vstr	d12, [sp, #24]
   2d510:	e7c1      	b.n	2d496 <pow+0x1ae>
   2d512:	4668      	mov	r0, sp
   2d514:	f001 fcc2 	bl	2ee9c <matherr>
   2d518:	2800      	cmp	r0, #0
   2d51a:	f47f af3b 	bne.w	2d394 <pow+0xac>
   2d51e:	e7be      	b.n	2d49e <pow+0x1b6>
	...
   2d528:	000629f4 	.word	0x000629f4
   2d52c:	3ff00000 	.word	0x3ff00000
   2d530:	000520e4 	.word	0x000520e4
   2d534:	fff00000 	.word	0xfff00000
   2d538:	47efffff 	.word	0x47efffff
   2d53c:	c7efffff 	.word	0xc7efffff
   2d540:	7ff00000 	.word	0x7ff00000
   2d544:	00000000 	.word	0x00000000

0002d548 <fmodf>:
   2d548:	b500      	push	{lr}
   2d54a:	ed2d 8b02 	vpush	{d8}
   2d54e:	b08b      	sub	sp, #44	; 0x2c
   2d550:	eeb0 8a40 	vmov.f32	s16, s0
   2d554:	eef0 8a60 	vmov.f32	s17, s1
   2d558:	f000 fdc0 	bl	2e0dc <__ieee754_fmodf>
   2d55c:	4b24      	ldr	r3, [pc, #144]	; (2d5f0 <fmodf+0xa8>)
   2d55e:	f993 3000 	ldrsb.w	r3, [r3]
   2d562:	1c5a      	adds	r2, r3, #1
   2d564:	d02d      	beq.n	2d5c2 <fmodf+0x7a>
   2d566:	eef4 8a68 	vcmp.f32	s17, s17
   2d56a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d56e:	d628      	bvs.n	2d5c2 <fmodf+0x7a>
   2d570:	eeb4 8a48 	vcmp.f32	s16, s16
   2d574:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d578:	d623      	bvs.n	2d5c2 <fmodf+0x7a>
   2d57a:	eef5 8a40 	vcmp.f32	s17, #0.0
   2d57e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d582:	d11e      	bne.n	2d5c2 <fmodf+0x7a>
   2d584:	2201      	movs	r2, #1
   2d586:	9200      	str	r2, [sp, #0]
   2d588:	eeb7 0ac8 	vcvt.f64.f32	d0, s16
   2d58c:	4a19      	ldr	r2, [pc, #100]	; (2d5f4 <fmodf+0xac>)
   2d58e:	9201      	str	r2, [sp, #4]
   2d590:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
   2d594:	2200      	movs	r2, #0
   2d596:	9208      	str	r2, [sp, #32]
   2d598:	ed8d 0b02 	vstr	d0, [sp, #8]
   2d59c:	ed8d 7b04 	vstr	d7, [sp, #16]
   2d5a0:	b9a3      	cbnz	r3, 2d5cc <fmodf+0x84>
   2d5a2:	ed8d 0b06 	vstr	d0, [sp, #24]
   2d5a6:	4668      	mov	r0, sp
   2d5a8:	f001 fc78 	bl	2ee9c <matherr>
   2d5ac:	b1b0      	cbz	r0, 2d5dc <fmodf+0x94>
   2d5ae:	9b08      	ldr	r3, [sp, #32]
   2d5b0:	b11b      	cbz	r3, 2d5ba <fmodf+0x72>
   2d5b2:	f7ff f947 	bl	2c844 <__errno>
   2d5b6:	9b08      	ldr	r3, [sp, #32]
   2d5b8:	6003      	str	r3, [r0, #0]
   2d5ba:	ed9d 0b06 	vldr	d0, [sp, #24]
   2d5be:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2d5c2:	b00b      	add	sp, #44	; 0x2c
   2d5c4:	ecbd 8b02 	vpop	{d8}
   2d5c8:	f85d fb04 	ldr.w	pc, [sp], #4
   2d5cc:	ed9f 7b06 	vldr	d7, [pc, #24]	; 2d5e8 <fmodf+0xa0>
   2d5d0:	2b02      	cmp	r3, #2
   2d5d2:	ee87 6b07 	vdiv.f64	d6, d7, d7
   2d5d6:	ed8d 6b06 	vstr	d6, [sp, #24]
   2d5da:	d1e4      	bne.n	2d5a6 <fmodf+0x5e>
   2d5dc:	f7ff f932 	bl	2c844 <__errno>
   2d5e0:	2321      	movs	r3, #33	; 0x21
   2d5e2:	6003      	str	r3, [r0, #0]
   2d5e4:	e7e3      	b.n	2d5ae <fmodf+0x66>
   2d5e6:	bf00      	nop
	...
   2d5f0:	000629f4 	.word	0x000629f4
   2d5f4:	000520e8 	.word	0x000520e8

0002d5f8 <log10f>:
   2d5f8:	b500      	push	{lr}
   2d5fa:	ed2d 8b02 	vpush	{d8}
   2d5fe:	b08b      	sub	sp, #44	; 0x2c
   2d600:	eeb0 8a40 	vmov.f32	s16, s0
   2d604:	f000 fdf2 	bl	2e1ec <__ieee754_log10f>
   2d608:	4b2f      	ldr	r3, [pc, #188]	; (2d6c8 <log10f+0xd0>)
   2d60a:	f993 3000 	ldrsb.w	r3, [r3]
   2d60e:	1c5a      	adds	r2, r3, #1
   2d610:	d055      	beq.n	2d6be <log10f+0xc6>
   2d612:	eeb4 8a48 	vcmp.f32	s16, s16
   2d616:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d61a:	d650      	bvs.n	2d6be <log10f+0xc6>
   2d61c:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   2d620:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d624:	d84b      	bhi.n	2d6be <log10f+0xc6>
   2d626:	4a29      	ldr	r2, [pc, #164]	; (2d6cc <log10f+0xd4>)
   2d628:	9201      	str	r2, [sp, #4]
   2d62a:	eeb7 7ac8 	vcvt.f64.f32	d7, s16
   2d62e:	2200      	movs	r2, #0
   2d630:	9208      	str	r2, [sp, #32]
   2d632:	ed8d 7b04 	vstr	d7, [sp, #16]
   2d636:	ed8d 7b02 	vstr	d7, [sp, #8]
   2d63a:	b993      	cbnz	r3, 2d662 <log10f+0x6a>
   2d63c:	4924      	ldr	r1, [pc, #144]	; (2d6d0 <log10f+0xd8>)
   2d63e:	eeb5 8a40 	vcmp.f32	s16, #0.0
   2d642:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
   2d646:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d64a:	e9cd 0106 	strd	r0, r1, [sp, #24]
   2d64e:	d025      	beq.n	2d69c <log10f+0xa4>
   2d650:	2201      	movs	r2, #1
   2d652:	2b02      	cmp	r3, #2
   2d654:	9200      	str	r2, [sp, #0]
   2d656:	d116      	bne.n	2d686 <log10f+0x8e>
   2d658:	f7ff f8f4 	bl	2c844 <__errno>
   2d65c:	2321      	movs	r3, #33	; 0x21
   2d65e:	6003      	str	r3, [r0, #0]
   2d660:	e016      	b.n	2d690 <log10f+0x98>
   2d662:	491c      	ldr	r1, [pc, #112]	; (2d6d4 <log10f+0xdc>)
   2d664:	eeb5 8a40 	vcmp.f32	s16, #0.0
   2d668:	2000      	movs	r0, #0
   2d66a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d66e:	e9cd 0106 	strd	r0, r1, [sp, #24]
   2d672:	d1ed      	bne.n	2d650 <log10f+0x58>
   2d674:	2202      	movs	r2, #2
   2d676:	4293      	cmp	r3, r2
   2d678:	9200      	str	r2, [sp, #0]
   2d67a:	d111      	bne.n	2d6a0 <log10f+0xa8>
   2d67c:	f7ff f8e2 	bl	2c844 <__errno>
   2d680:	2322      	movs	r3, #34	; 0x22
   2d682:	6003      	str	r3, [r0, #0]
   2d684:	e011      	b.n	2d6aa <log10f+0xb2>
   2d686:	4668      	mov	r0, sp
   2d688:	f001 fc08 	bl	2ee9c <matherr>
   2d68c:	2800      	cmp	r0, #0
   2d68e:	d0e3      	beq.n	2d658 <log10f+0x60>
   2d690:	4811      	ldr	r0, [pc, #68]	; (2d6d8 <log10f+0xe0>)
   2d692:	f001 fc05 	bl	2eea0 <nan>
   2d696:	ed8d 0b06 	vstr	d0, [sp, #24]
   2d69a:	e006      	b.n	2d6aa <log10f+0xb2>
   2d69c:	2302      	movs	r3, #2
   2d69e:	9300      	str	r3, [sp, #0]
   2d6a0:	4668      	mov	r0, sp
   2d6a2:	f001 fbfb 	bl	2ee9c <matherr>
   2d6a6:	2800      	cmp	r0, #0
   2d6a8:	d0e8      	beq.n	2d67c <log10f+0x84>
   2d6aa:	9b08      	ldr	r3, [sp, #32]
   2d6ac:	b11b      	cbz	r3, 2d6b6 <log10f+0xbe>
   2d6ae:	f7ff f8c9 	bl	2c844 <__errno>
   2d6b2:	9b08      	ldr	r3, [sp, #32]
   2d6b4:	6003      	str	r3, [r0, #0]
   2d6b6:	ed9d 0b06 	vldr	d0, [sp, #24]
   2d6ba:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2d6be:	b00b      	add	sp, #44	; 0x2c
   2d6c0:	ecbd 8b02 	vpop	{d8}
   2d6c4:	f85d fb04 	ldr.w	pc, [sp], #4
   2d6c8:	000629f4 	.word	0x000629f4
   2d6cc:	000520ee 	.word	0x000520ee
   2d6d0:	c7efffff 	.word	0xc7efffff
   2d6d4:	fff00000 	.word	0xfff00000
   2d6d8:	000520f4 	.word	0x000520f4
   2d6dc:	00000000 	.word	0x00000000

0002d6e0 <sinhf>:
   2d6e0:	b530      	push	{r4, r5, lr}
   2d6e2:	ed2d 8b02 	vpush	{d8}
   2d6e6:	4c32      	ldr	r4, [pc, #200]	; (2d7b0 <sinhf+0xd0>)
   2d6e8:	b08b      	sub	sp, #44	; 0x2c
   2d6ea:	eef0 8a40 	vmov.f32	s17, s0
   2d6ee:	f000 feff 	bl	2e4f0 <__ieee754_sinhf>
   2d6f2:	f994 3000 	ldrsb.w	r3, [r4]
   2d6f6:	3301      	adds	r3, #1
   2d6f8:	eeb0 8a40 	vmov.f32	s16, s0
   2d6fc:	d030      	beq.n	2d760 <sinhf+0x80>
   2d6fe:	f001 fe0b 	bl	2f318 <finitef>
   2d702:	4605      	mov	r5, r0
   2d704:	bb60      	cbnz	r0, 2d760 <sinhf+0x80>
   2d706:	eeb0 0a68 	vmov.f32	s0, s17
   2d70a:	f001 fe05 	bl	2f318 <finitef>
   2d70e:	b338      	cbz	r0, 2d760 <sinhf+0x80>
   2d710:	2303      	movs	r3, #3
   2d712:	9300      	str	r3, [sp, #0]
   2d714:	4b27      	ldr	r3, [pc, #156]	; (2d7b4 <sinhf+0xd4>)
   2d716:	9301      	str	r3, [sp, #4]
   2d718:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
   2d71c:	f994 3000 	ldrsb.w	r3, [r4]
   2d720:	9508      	str	r5, [sp, #32]
   2d722:	ed8d 7b04 	vstr	d7, [sp, #16]
   2d726:	ed8d 7b02 	vstr	d7, [sp, #8]
   2d72a:	eef5 8ac0 	vcmpe.f32	s17, #0.0
   2d72e:	b9eb      	cbnz	r3, 2d76c <sinhf+0x8c>
   2d730:	ed9f 7b17 	vldr	d7, [pc, #92]	; 2d790 <sinhf+0xb0>
   2d734:	ed9f 6b18 	vldr	d6, [pc, #96]	; 2d798 <sinhf+0xb8>
   2d738:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d73c:	fe37 7b06 	vselgt.f64	d7, d7, d6
   2d740:	ed8d 7b06 	vstr	d7, [sp, #24]
   2d744:	4668      	mov	r0, sp
   2d746:	f001 fba9 	bl	2ee9c <matherr>
   2d74a:	b1d8      	cbz	r0, 2d784 <sinhf+0xa4>
   2d74c:	9b08      	ldr	r3, [sp, #32]
   2d74e:	b11b      	cbz	r3, 2d758 <sinhf+0x78>
   2d750:	f7ff f878 	bl	2c844 <__errno>
   2d754:	9b08      	ldr	r3, [sp, #32]
   2d756:	6003      	str	r3, [r0, #0]
   2d758:	ed9d 8b06 	vldr	d8, [sp, #24]
   2d75c:	eeb7 8bc8 	vcvt.f32.f64	s16, d8
   2d760:	eeb0 0a48 	vmov.f32	s0, s16
   2d764:	b00b      	add	sp, #44	; 0x2c
   2d766:	ecbd 8b02 	vpop	{d8}
   2d76a:	bd30      	pop	{r4, r5, pc}
   2d76c:	ed9f 7b0c 	vldr	d7, [pc, #48]	; 2d7a0 <sinhf+0xc0>
   2d770:	ed9f 6b0d 	vldr	d6, [pc, #52]	; 2d7a8 <sinhf+0xc8>
   2d774:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d778:	fe37 7b06 	vselgt.f64	d7, d7, d6
   2d77c:	2b02      	cmp	r3, #2
   2d77e:	ed8d 7b06 	vstr	d7, [sp, #24]
   2d782:	d1df      	bne.n	2d744 <sinhf+0x64>
   2d784:	f7ff f85e 	bl	2c844 <__errno>
   2d788:	2322      	movs	r3, #34	; 0x22
   2d78a:	6003      	str	r3, [r0, #0]
   2d78c:	e7de      	b.n	2d74c <sinhf+0x6c>
   2d78e:	bf00      	nop
   2d790:	e0000000 	.word	0xe0000000
   2d794:	47efffff 	.word	0x47efffff
   2d798:	e0000000 	.word	0xe0000000
   2d79c:	c7efffff 	.word	0xc7efffff
   2d7a0:	00000000 	.word	0x00000000
   2d7a4:	7ff00000 	.word	0x7ff00000
   2d7a8:	00000000 	.word	0x00000000
   2d7ac:	fff00000 	.word	0xfff00000
   2d7b0:	000629f4 	.word	0x000629f4
   2d7b4:	000520f5 	.word	0x000520f5

0002d7b8 <__ieee754_exp>:
   2d7b8:	ee10 1a90 	vmov	r1, s1
   2d7bc:	4b7a      	ldr	r3, [pc, #488]	; (2d9a8 <__ieee754_exp+0x1f0>)
   2d7be:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
   2d7c2:	429a      	cmp	r2, r3
   2d7c4:	b082      	sub	sp, #8
   2d7c6:	ea4f 70d1 	mov.w	r0, r1, lsr #31
   2d7ca:	d928      	bls.n	2d81e <__ieee754_exp+0x66>
   2d7cc:	4b77      	ldr	r3, [pc, #476]	; (2d9ac <__ieee754_exp+0x1f4>)
   2d7ce:	429a      	cmp	r2, r3
   2d7d0:	d90f      	bls.n	2d7f2 <__ieee754_exp+0x3a>
   2d7d2:	ee10 3a10 	vmov	r3, s0
   2d7d6:	f3c1 0113 	ubfx	r1, r1, #0, #20
   2d7da:	430b      	orrs	r3, r1
   2d7dc:	d003      	beq.n	2d7e6 <__ieee754_exp+0x2e>
   2d7de:	ee30 0b00 	vadd.f64	d0, d0, d0
   2d7e2:	b002      	add	sp, #8
   2d7e4:	4770      	bx	lr
   2d7e6:	ed9f 7b56 	vldr	d7, [pc, #344]	; 2d940 <__ieee754_exp+0x188>
   2d7ea:	2800      	cmp	r0, #0
   2d7ec:	fe00 0b07 	vseleq.f64	d0, d0, d7
   2d7f0:	e7f7      	b.n	2d7e2 <__ieee754_exp+0x2a>
   2d7f2:	ed9f 7b55 	vldr	d7, [pc, #340]	; 2d948 <__ieee754_exp+0x190>
   2d7f6:	eeb4 0bc7 	vcmpe.f64	d0, d7
   2d7fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d7fe:	dd04      	ble.n	2d80a <__ieee754_exp+0x52>
   2d800:	ed9f 0b53 	vldr	d0, [pc, #332]	; 2d950 <__ieee754_exp+0x198>
   2d804:	ee20 0b00 	vmul.f64	d0, d0, d0
   2d808:	e7eb      	b.n	2d7e2 <__ieee754_exp+0x2a>
   2d80a:	ed9f 7b53 	vldr	d7, [pc, #332]	; 2d958 <__ieee754_exp+0x1a0>
   2d80e:	eeb4 0bc7 	vcmpe.f64	d0, d7
   2d812:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d816:	d505      	bpl.n	2d824 <__ieee754_exp+0x6c>
   2d818:	ed9f 0b49 	vldr	d0, [pc, #292]	; 2d940 <__ieee754_exp+0x188>
   2d81c:	e7e1      	b.n	2d7e2 <__ieee754_exp+0x2a>
   2d81e:	4b64      	ldr	r3, [pc, #400]	; (2d9b0 <__ieee754_exp+0x1f8>)
   2d820:	429a      	cmp	r2, r3
   2d822:	d956      	bls.n	2d8d2 <__ieee754_exp+0x11a>
   2d824:	4b63      	ldr	r3, [pc, #396]	; (2d9b4 <__ieee754_exp+0x1fc>)
   2d826:	429a      	cmp	r2, r3
   2d828:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   2d82c:	d838      	bhi.n	2d8a0 <__ieee754_exp+0xe8>
   2d82e:	4b62      	ldr	r3, [pc, #392]	; (2d9b8 <__ieee754_exp+0x200>)
   2d830:	4413      	add	r3, r2
   2d832:	ed93 6b00 	vldr	d6, [r3]
   2d836:	4b61      	ldr	r3, [pc, #388]	; (2d9bc <__ieee754_exp+0x204>)
   2d838:	ee30 6b46 	vsub.f64	d6, d0, d6
   2d83c:	4413      	add	r3, r2
   2d83e:	ed93 7b00 	vldr	d7, [r3]
   2d842:	f1c0 0301 	rsb	r3, r0, #1
   2d846:	1a1b      	subs	r3, r3, r0
   2d848:	ee36 0b47 	vsub.f64	d0, d6, d7
   2d84c:	ed9f 4b44 	vldr	d4, [pc, #272]	; 2d960 <__ieee754_exp+0x1a8>
   2d850:	ee20 5b00 	vmul.f64	d5, d0, d0
   2d854:	ed9f 3b44 	vldr	d3, [pc, #272]	; 2d968 <__ieee754_exp+0x1b0>
   2d858:	eea5 3b04 	vfma.f64	d3, d5, d4
   2d85c:	ed9f 4b44 	vldr	d4, [pc, #272]	; 2d970 <__ieee754_exp+0x1b8>
   2d860:	eea3 4b05 	vfma.f64	d4, d3, d5
   2d864:	ed9f 3b44 	vldr	d3, [pc, #272]	; 2d978 <__ieee754_exp+0x1c0>
   2d868:	eea4 3b05 	vfma.f64	d3, d4, d5
   2d86c:	ed9f 4b44 	vldr	d4, [pc, #272]	; 2d980 <__ieee754_exp+0x1c8>
   2d870:	eea3 4b05 	vfma.f64	d4, d3, d5
   2d874:	eeb0 3b40 	vmov.f64	d3, d0
   2d878:	eea4 3b45 	vfms.f64	d3, d4, d5
   2d87c:	eeb0 4b00 	vmov.f64	d4, #0	; 0x40000000  2.0
   2d880:	eeb0 5b43 	vmov.f64	d5, d3
   2d884:	ee20 2b03 	vmul.f64	d2, d0, d3
   2d888:	eeb7 3b00 	vmov.f64	d3, #112	; 0x3f800000  1.0
   2d88c:	bba3      	cbnz	r3, 2d8f8 <__ieee754_exp+0x140>
   2d88e:	ee35 5b44 	vsub.f64	d5, d5, d4
   2d892:	ee82 7b05 	vdiv.f64	d7, d2, d5
   2d896:	ee37 0b40 	vsub.f64	d0, d7, d0
   2d89a:	ee33 0b40 	vsub.f64	d0, d3, d0
   2d89e:	e7a0      	b.n	2d7e2 <__ieee754_exp+0x2a>
   2d8a0:	4b47      	ldr	r3, [pc, #284]	; (2d9c0 <__ieee754_exp+0x208>)
   2d8a2:	4413      	add	r3, r2
   2d8a4:	ed93 7b00 	vldr	d7, [r3]
   2d8a8:	ed9f 6b37 	vldr	d6, [pc, #220]	; 2d988 <__ieee754_exp+0x1d0>
   2d8ac:	ed9f 5b38 	vldr	d5, [pc, #224]	; 2d990 <__ieee754_exp+0x1d8>
   2d8b0:	eea0 7b06 	vfma.f64	d7, d0, d6
   2d8b4:	ed9f 6b38 	vldr	d6, [pc, #224]	; 2d998 <__ieee754_exp+0x1e0>
   2d8b8:	eefd 7bc7 	vcvt.s32.f64	s15, d7
   2d8bc:	ee17 3a90 	vmov	r3, s15
   2d8c0:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   2d8c4:	eea7 0b46 	vfms.f64	d0, d7, d6
   2d8c8:	ee27 7b05 	vmul.f64	d7, d7, d5
   2d8cc:	eeb0 6b40 	vmov.f64	d6, d0
   2d8d0:	e7ba      	b.n	2d848 <__ieee754_exp+0x90>
   2d8d2:	4b3c      	ldr	r3, [pc, #240]	; (2d9c4 <__ieee754_exp+0x20c>)
   2d8d4:	429a      	cmp	r2, r3
   2d8d6:	d80d      	bhi.n	2d8f4 <__ieee754_exp+0x13c>
   2d8d8:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
   2d8dc:	ed9f 5b1c 	vldr	d5, [pc, #112]	; 2d950 <__ieee754_exp+0x198>
   2d8e0:	ee30 5b05 	vadd.f64	d5, d0, d5
   2d8e4:	eeb4 5bc4 	vcmpe.f64	d5, d4
   2d8e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d8ec:	dd02      	ble.n	2d8f4 <__ieee754_exp+0x13c>
   2d8ee:	ee30 0b04 	vadd.f64	d0, d0, d4
   2d8f2:	e776      	b.n	2d7e2 <__ieee754_exp+0x2a>
   2d8f4:	2300      	movs	r3, #0
   2d8f6:	e7a9      	b.n	2d84c <__ieee754_exp+0x94>
   2d8f8:	f46f 717f 	mvn.w	r1, #1020	; 0x3fc
   2d8fc:	ee34 5b45 	vsub.f64	d5, d4, d5
   2d900:	428b      	cmp	r3, r1
   2d902:	ee82 4b05 	vdiv.f64	d4, d2, d5
   2d906:	ee37 7b44 	vsub.f64	d7, d7, d4
   2d90a:	ee37 7b46 	vsub.f64	d7, d7, d6
   2d90e:	ee33 7b47 	vsub.f64	d7, d3, d7
   2d912:	ed8d 7b00 	vstr	d7, [sp]
   2d916:	9a01      	ldr	r2, [sp, #4]
   2d918:	e9dd 0100 	ldrd	r0, r1, [sp]
   2d91c:	db04      	blt.n	2d928 <__ieee754_exp+0x170>
   2d91e:	eb02 5103 	add.w	r1, r2, r3, lsl #20
   2d922:	ec41 0b10 	vmov	d0, r0, r1
   2d926:	e75c      	b.n	2d7e2 <__ieee754_exp+0x2a>
   2d928:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
   2d92c:	eb02 5103 	add.w	r1, r2, r3, lsl #20
   2d930:	ed9f 7b1b 	vldr	d7, [pc, #108]	; 2d9a0 <__ieee754_exp+0x1e8>
   2d934:	ec41 0b10 	vmov	d0, r0, r1
   2d938:	ee20 0b07 	vmul.f64	d0, d0, d7
   2d93c:	e751      	b.n	2d7e2 <__ieee754_exp+0x2a>
   2d93e:	bf00      	nop
	...
   2d948:	fefa39ef 	.word	0xfefa39ef
   2d94c:	40862e42 	.word	0x40862e42
   2d950:	8800759c 	.word	0x8800759c
   2d954:	7e37e43c 	.word	0x7e37e43c
   2d958:	d52d3051 	.word	0xd52d3051
   2d95c:	c0874910 	.word	0xc0874910
   2d960:	72bea4d0 	.word	0x72bea4d0
   2d964:	3e663769 	.word	0x3e663769
   2d968:	c5d26bf1 	.word	0xc5d26bf1
   2d96c:	bebbbd41 	.word	0xbebbbd41
   2d970:	af25de2c 	.word	0xaf25de2c
   2d974:	3f11566a 	.word	0x3f11566a
   2d978:	16bebd93 	.word	0x16bebd93
   2d97c:	bf66c16c 	.word	0xbf66c16c
   2d980:	5555553e 	.word	0x5555553e
   2d984:	3fc55555 	.word	0x3fc55555
   2d988:	652b82fe 	.word	0x652b82fe
   2d98c:	3ff71547 	.word	0x3ff71547
   2d990:	35793c76 	.word	0x35793c76
   2d994:	3dea39ef 	.word	0x3dea39ef
   2d998:	fee00000 	.word	0xfee00000
   2d99c:	3fe62e42 	.word	0x3fe62e42
   2d9a0:	00000000 	.word	0x00000000
   2d9a4:	01700000 	.word	0x01700000
   2d9a8:	40862e41 	.word	0x40862e41
   2d9ac:	7fefffff 	.word	0x7fefffff
   2d9b0:	3fd62e42 	.word	0x3fd62e42
   2d9b4:	3ff0a2b1 	.word	0x3ff0a2b1
   2d9b8:	00052110 	.word	0x00052110
   2d9bc:	00052120 	.word	0x00052120
   2d9c0:	00052100 	.word	0x00052100
   2d9c4:	3e2fffff 	.word	0x3e2fffff

0002d9c8 <__ieee754_pow>:
   2d9c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2d9cc:	ec57 6b11 	vmov	r6, r7, d1
   2d9d0:	ed2d 8b02 	vpush	{d8}
   2d9d4:	eeb0 8b40 	vmov.f64	d8, d0
   2d9d8:	f027 4800 	bic.w	r8, r7, #2147483648	; 0x80000000
   2d9dc:	ea58 0306 	orrs.w	r3, r8, r6
   2d9e0:	b085      	sub	sp, #20
   2d9e2:	46b9      	mov	r9, r7
   2d9e4:	ee11 2a10 	vmov	r2, s2
   2d9e8:	f000 8306 	beq.w	2dff8 <__ieee754_pow+0x630>
   2d9ec:	ee18 aa90 	vmov	sl, s17
   2d9f0:	4bb9      	ldr	r3, [pc, #740]	; (2dcd8 <__ieee754_pow+0x310>)
   2d9f2:	f02a 4400 	bic.w	r4, sl, #2147483648	; 0x80000000
   2d9f6:	429c      	cmp	r4, r3
   2d9f8:	ee10 ba10 	vmov	fp, s0
   2d9fc:	dc0b      	bgt.n	2da16 <__ieee754_pow+0x4e>
   2d9fe:	d105      	bne.n	2da0c <__ieee754_pow+0x44>
   2da00:	f1bb 0f00 	cmp.w	fp, #0
   2da04:	d107      	bne.n	2da16 <__ieee754_pow+0x4e>
   2da06:	45a0      	cmp	r8, r4
   2da08:	dc0d      	bgt.n	2da26 <__ieee754_pow+0x5e>
   2da0a:	e001      	b.n	2da10 <__ieee754_pow+0x48>
   2da0c:	4598      	cmp	r8, r3
   2da0e:	dc02      	bgt.n	2da16 <__ieee754_pow+0x4e>
   2da10:	4598      	cmp	r8, r3
   2da12:	d110      	bne.n	2da36 <__ieee754_pow+0x6e>
   2da14:	b17a      	cbz	r2, 2da36 <__ieee754_pow+0x6e>
   2da16:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
   2da1a:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
   2da1e:	ea54 030b 	orrs.w	r3, r4, fp
   2da22:	f000 82e9 	beq.w	2dff8 <__ieee754_pow+0x630>
   2da26:	48ad      	ldr	r0, [pc, #692]	; (2dcdc <__ieee754_pow+0x314>)
   2da28:	b005      	add	sp, #20
   2da2a:	ecbd 8b02 	vpop	{d8}
   2da2e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2da32:	f001 ba35 	b.w	2eea0 <nan>
   2da36:	f1ba 0f00 	cmp.w	sl, #0
   2da3a:	da4e      	bge.n	2dada <__ieee754_pow+0x112>
   2da3c:	4ba8      	ldr	r3, [pc, #672]	; (2dce0 <__ieee754_pow+0x318>)
   2da3e:	4598      	cmp	r8, r3
   2da40:	dc49      	bgt.n	2dad6 <__ieee754_pow+0x10e>
   2da42:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
   2da46:	4598      	cmp	r8, r3
   2da48:	dd47      	ble.n	2dada <__ieee754_pow+0x112>
   2da4a:	ea4f 5328 	mov.w	r3, r8, asr #20
   2da4e:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
   2da52:	2b14      	cmp	r3, #20
   2da54:	dd24      	ble.n	2daa0 <__ieee754_pow+0xd8>
   2da56:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
   2da5a:	fa22 f503 	lsr.w	r5, r2, r3
   2da5e:	fa05 f303 	lsl.w	r3, r5, r3
   2da62:	4293      	cmp	r3, r2
   2da64:	d139      	bne.n	2dada <__ieee754_pow+0x112>
   2da66:	f005 0501 	and.w	r5, r5, #1
   2da6a:	f1c5 0502 	rsb	r5, r5, #2
   2da6e:	2a00      	cmp	r2, #0
   2da70:	d15a      	bne.n	2db28 <__ieee754_pow+0x160>
   2da72:	4b99      	ldr	r3, [pc, #612]	; (2dcd8 <__ieee754_pow+0x310>)
   2da74:	4598      	cmp	r8, r3
   2da76:	d122      	bne.n	2dabe <__ieee754_pow+0xf6>
   2da78:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
   2da7c:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
   2da80:	ea53 030b 	orrs.w	r3, r3, fp
   2da84:	f000 82b8 	beq.w	2dff8 <__ieee754_pow+0x630>
   2da88:	4b96      	ldr	r3, [pc, #600]	; (2dce4 <__ieee754_pow+0x31c>)
   2da8a:	429c      	cmp	r4, r3
   2da8c:	dd27      	ble.n	2dade <__ieee754_pow+0x116>
   2da8e:	f1b9 0f00 	cmp.w	r9, #0
   2da92:	f280 82b4 	bge.w	2dffe <__ieee754_pow+0x636>
   2da96:	ed9f 7b84 	vldr	d7, [pc, #528]	; 2dca8 <__ieee754_pow+0x2e0>
   2da9a:	ed8d 7b00 	vstr	d7, [sp]
   2da9e:	e026      	b.n	2daee <__ieee754_pow+0x126>
   2daa0:	2a00      	cmp	r2, #0
   2daa2:	d140      	bne.n	2db26 <__ieee754_pow+0x15e>
   2daa4:	f1c3 0314 	rsb	r3, r3, #20
   2daa8:	fa48 f503 	asr.w	r5, r8, r3
   2daac:	fa05 f303 	lsl.w	r3, r5, r3
   2dab0:	4543      	cmp	r3, r8
   2dab2:	f040 82aa 	bne.w	2e00a <__ieee754_pow+0x642>
   2dab6:	f005 0501 	and.w	r5, r5, #1
   2daba:	f1c5 0502 	rsb	r5, r5, #2
   2dabe:	4b8a      	ldr	r3, [pc, #552]	; (2dce8 <__ieee754_pow+0x320>)
   2dac0:	4598      	cmp	r8, r3
   2dac2:	d11b      	bne.n	2dafc <__ieee754_pow+0x134>
   2dac4:	f1b9 0f00 	cmp.w	r9, #0
   2dac8:	f280 829c 	bge.w	2e004 <__ieee754_pow+0x63c>
   2dacc:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   2dad0:	ee87 7b08 	vdiv.f64	d7, d7, d8
   2dad4:	e7e1      	b.n	2da9a <__ieee754_pow+0xd2>
   2dad6:	2502      	movs	r5, #2
   2dad8:	e7c9      	b.n	2da6e <__ieee754_pow+0xa6>
   2dada:	2500      	movs	r5, #0
   2dadc:	e7c7      	b.n	2da6e <__ieee754_pow+0xa6>
   2dade:	f1b9 0f00 	cmp.w	r9, #0
   2dae2:	dad8      	bge.n	2da96 <__ieee754_pow+0xce>
   2dae4:	f087 4400 	eor.w	r4, r7, #2147483648	; 0x80000000
   2dae8:	4633      	mov	r3, r6
   2daea:	e9cd 3400 	strd	r3, r4, [sp]
   2daee:	ed9d 0b00 	vldr	d0, [sp]
   2daf2:	b005      	add	sp, #20
   2daf4:	ecbd 8b02 	vpop	{d8}
   2daf8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2dafc:	f1b9 4f80 	cmp.w	r9, #1073741824	; 0x40000000
   2db00:	d102      	bne.n	2db08 <__ieee754_pow+0x140>
   2db02:	ee28 7b08 	vmul.f64	d7, d8, d8
   2db06:	e7c8      	b.n	2da9a <__ieee754_pow+0xd2>
   2db08:	4b78      	ldr	r3, [pc, #480]	; (2dcec <__ieee754_pow+0x324>)
   2db0a:	4599      	cmp	r9, r3
   2db0c:	d10c      	bne.n	2db28 <__ieee754_pow+0x160>
   2db0e:	f1ba 0f00 	cmp.w	sl, #0
   2db12:	db09      	blt.n	2db28 <__ieee754_pow+0x160>
   2db14:	eeb0 0b48 	vmov.f64	d0, d8
   2db18:	b005      	add	sp, #20
   2db1a:	ecbd 8b02 	vpop	{d8}
   2db1e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2db22:	f000 bad7 	b.w	2e0d4 <__ieee754_sqrt>
   2db26:	2500      	movs	r5, #0
   2db28:	eeb0 0b48 	vmov.f64	d0, d8
   2db2c:	f001 f9a5 	bl	2ee7a <fabs>
   2db30:	ed8d 0b00 	vstr	d0, [sp]
   2db34:	f1bb 0f00 	cmp.w	fp, #0
   2db38:	d128      	bne.n	2db8c <__ieee754_pow+0x1c4>
   2db3a:	b124      	cbz	r4, 2db46 <__ieee754_pow+0x17e>
   2db3c:	4b6a      	ldr	r3, [pc, #424]	; (2dce8 <__ieee754_pow+0x320>)
   2db3e:	f02a 4240 	bic.w	r2, sl, #3221225472	; 0xc0000000
   2db42:	429a      	cmp	r2, r3
   2db44:	d122      	bne.n	2db8c <__ieee754_pow+0x1c4>
   2db46:	f1b9 0f00 	cmp.w	r9, #0
   2db4a:	da07      	bge.n	2db5c <__ieee754_pow+0x194>
   2db4c:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   2db50:	ed9d 6b00 	vldr	d6, [sp]
   2db54:	ee87 7b06 	vdiv.f64	d7, d7, d6
   2db58:	ed8d 7b00 	vstr	d7, [sp]
   2db5c:	f1ba 0f00 	cmp.w	sl, #0
   2db60:	dac5      	bge.n	2daee <__ieee754_pow+0x126>
   2db62:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
   2db66:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
   2db6a:	ea54 0305 	orrs.w	r3, r4, r5
   2db6e:	d106      	bne.n	2db7e <__ieee754_pow+0x1b6>
   2db70:	ed9d 7b00 	vldr	d7, [sp]
   2db74:	ee37 7b47 	vsub.f64	d7, d7, d7
   2db78:	ee87 7b07 	vdiv.f64	d7, d7, d7
   2db7c:	e78d      	b.n	2da9a <__ieee754_pow+0xd2>
   2db7e:	2d01      	cmp	r5, #1
   2db80:	d1b5      	bne.n	2daee <__ieee754_pow+0x126>
   2db82:	ed9d 7b00 	vldr	d7, [sp]
   2db86:	eeb1 7b47 	vneg.f64	d7, d7
   2db8a:	e786      	b.n	2da9a <__ieee754_pow+0xd2>
   2db8c:	ea4f 7ada 	mov.w	sl, sl, lsr #31
   2db90:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   2db94:	ea55 030a 	orrs.w	r3, r5, sl
   2db98:	d104      	bne.n	2dba4 <__ieee754_pow+0x1dc>
   2db9a:	ee38 8b48 	vsub.f64	d8, d8, d8
   2db9e:	ee88 7b08 	vdiv.f64	d7, d8, d8
   2dba2:	e77a      	b.n	2da9a <__ieee754_pow+0xd2>
   2dba4:	4b52      	ldr	r3, [pc, #328]	; (2dcf0 <__ieee754_pow+0x328>)
   2dba6:	4598      	cmp	r8, r3
   2dba8:	f340 80a8 	ble.w	2dcfc <__ieee754_pow+0x334>
   2dbac:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
   2dbb0:	4598      	cmp	r8, r3
   2dbb2:	dd0b      	ble.n	2dbcc <__ieee754_pow+0x204>
   2dbb4:	4b4b      	ldr	r3, [pc, #300]	; (2dce4 <__ieee754_pow+0x31c>)
   2dbb6:	429c      	cmp	r4, r3
   2dbb8:	dc0e      	bgt.n	2dbd8 <__ieee754_pow+0x210>
   2dbba:	f1b9 0f00 	cmp.w	r9, #0
   2dbbe:	f6bf af6a 	bge.w	2da96 <__ieee754_pow+0xce>
   2dbc2:	ed9f 7b3b 	vldr	d7, [pc, #236]	; 2dcb0 <__ieee754_pow+0x2e8>
   2dbc6:	ee27 7b07 	vmul.f64	d7, d7, d7
   2dbca:	e766      	b.n	2da9a <__ieee754_pow+0xd2>
   2dbcc:	4b49      	ldr	r3, [pc, #292]	; (2dcf4 <__ieee754_pow+0x32c>)
   2dbce:	429c      	cmp	r4, r3
   2dbd0:	ddf3      	ble.n	2dbba <__ieee754_pow+0x1f2>
   2dbd2:	4b45      	ldr	r3, [pc, #276]	; (2dce8 <__ieee754_pow+0x320>)
   2dbd4:	429c      	cmp	r4, r3
   2dbd6:	dd03      	ble.n	2dbe0 <__ieee754_pow+0x218>
   2dbd8:	f1b9 0f00 	cmp.w	r9, #0
   2dbdc:	dcf1      	bgt.n	2dbc2 <__ieee754_pow+0x1fa>
   2dbde:	e75a      	b.n	2da96 <__ieee754_pow+0xce>
   2dbe0:	ed9d 7b00 	vldr	d7, [sp]
   2dbe4:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   2dbe8:	ed9f 5b33 	vldr	d5, [pc, #204]	; 2dcb8 <__ieee754_pow+0x2f0>
   2dbec:	ee37 6b46 	vsub.f64	d6, d7, d6
   2dbf0:	eeb5 7b00 	vmov.f64	d7, #80	; 0x3e800000  0.250
   2dbf4:	eeb1 3b46 	vneg.f64	d3, d6
   2dbf8:	eea3 5b07 	vfma.f64	d5, d3, d7
   2dbfc:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
   2dc00:	eea5 7b46 	vfms.f64	d7, d5, d6
   2dc04:	ee26 5b06 	vmul.f64	d5, d6, d6
   2dc08:	ee27 5b05 	vmul.f64	d5, d7, d5
   2dc0c:	ed9f 7b2c 	vldr	d7, [pc, #176]	; 2dcc0 <__ieee754_pow+0x2f8>
   2dc10:	ee27 7b45 	vnmul.f64	d7, d7, d5
   2dc14:	ed9f 5b2c 	vldr	d5, [pc, #176]	; 2dcc8 <__ieee754_pow+0x300>
   2dc18:	eea6 7b05 	vfma.f64	d7, d6, d5
   2dc1c:	ed9f 5b2c 	vldr	d5, [pc, #176]	; 2dcd0 <__ieee754_pow+0x308>
   2dc20:	eeb0 4b47 	vmov.f64	d4, d7
   2dc24:	eea6 4b05 	vfma.f64	d4, d6, d5
   2dc28:	ec53 2b14 	vmov	r2, r3, d4
   2dc2c:	2200      	movs	r2, #0
   2dc2e:	ec43 2b14 	vmov	d4, r2, r3
   2dc32:	eeb0 6b44 	vmov.f64	d6, d4
   2dc36:	eea3 6b05 	vfma.f64	d6, d3, d5
   2dc3a:	ee37 7b46 	vsub.f64	d7, d7, d6
   2dc3e:	3d01      	subs	r5, #1
   2dc40:	ea55 030a 	orrs.w	r3, r5, sl
   2dc44:	f04f 0200 	mov.w	r2, #0
   2dc48:	463b      	mov	r3, r7
   2dc4a:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
   2dc4e:	eeb7 8b00 	vmov.f64	d8, #112	; 0x3f800000  1.0
   2dc52:	ec47 6b15 	vmov	d5, r6, r7
   2dc56:	fe06 8b08 	vseleq.f64	d8, d6, d8
   2dc5a:	ec47 6b13 	vmov	d3, r6, r7
   2dc5e:	ec43 2b16 	vmov	d6, r2, r3
   2dc62:	ee27 7b03 	vmul.f64	d7, d7, d3
   2dc66:	ee35 5b46 	vsub.f64	d5, d5, d6
   2dc6a:	4b23      	ldr	r3, [pc, #140]	; (2dcf8 <__ieee754_pow+0x330>)
   2dc6c:	eea5 7b04 	vfma.f64	d7, d5, d4
   2dc70:	ee24 6b06 	vmul.f64	d6, d4, d6
   2dc74:	ee37 5b06 	vadd.f64	d5, d7, d6
   2dc78:	ee15 1a90 	vmov	r1, s11
   2dc7c:	4299      	cmp	r1, r3
   2dc7e:	ee15 2a10 	vmov	r2, s10
   2dc82:	f340 819b 	ble.w	2dfbc <__ieee754_pow+0x5f4>
   2dc86:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
   2dc8a:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
   2dc8e:	4313      	orrs	r3, r2
   2dc90:	f000 810a 	beq.w	2dea8 <__ieee754_pow+0x4e0>
   2dc94:	ed9f 7b06 	vldr	d7, [pc, #24]	; 2dcb0 <__ieee754_pow+0x2e8>
   2dc98:	ee28 8b07 	vmul.f64	d8, d8, d7
   2dc9c:	ee28 7b07 	vmul.f64	d7, d8, d7
   2dca0:	e6fb      	b.n	2da9a <__ieee754_pow+0xd2>
   2dca2:	bf00      	nop
   2dca4:	f3af 8000 	nop.w
	...
   2dcb0:	8800759c 	.word	0x8800759c
   2dcb4:	7e37e43c 	.word	0x7e37e43c
   2dcb8:	55555555 	.word	0x55555555
   2dcbc:	3fd55555 	.word	0x3fd55555
   2dcc0:	652b82fe 	.word	0x652b82fe
   2dcc4:	3ff71547 	.word	0x3ff71547
   2dcc8:	f85ddf44 	.word	0xf85ddf44
   2dccc:	3e54ae0b 	.word	0x3e54ae0b
   2dcd0:	60000000 	.word	0x60000000
   2dcd4:	3ff71547 	.word	0x3ff71547
   2dcd8:	7ff00000 	.word	0x7ff00000
   2dcdc:	000520f4 	.word	0x000520f4
   2dce0:	433fffff 	.word	0x433fffff
   2dce4:	3fefffff 	.word	0x3fefffff
   2dce8:	3ff00000 	.word	0x3ff00000
   2dcec:	3fe00000 	.word	0x3fe00000
   2dcf0:	41e00000 	.word	0x41e00000
   2dcf4:	3feffffe 	.word	0x3feffffe
   2dcf8:	408fffff 	.word	0x408fffff
   2dcfc:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
   2dd00:	f280 80ce 	bge.w	2dea0 <__ieee754_pow+0x4d8>
   2dd04:	ed9d 6b00 	vldr	d6, [sp]
   2dd08:	ed9f 7bc1 	vldr	d7, [pc, #772]	; 2e010 <__ieee754_pow+0x648>
   2dd0c:	ee26 7b07 	vmul.f64	d7, d6, d7
   2dd10:	ed8d 7b00 	vstr	d7, [sp]
   2dd14:	9c01      	ldr	r4, [sp, #4]
   2dd16:	f06f 0334 	mvn.w	r3, #52	; 0x34
   2dd1a:	1521      	asrs	r1, r4, #20
   2dd1c:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
   2dd20:	4419      	add	r1, r3
   2dd22:	4be3      	ldr	r3, [pc, #908]	; (2e0b0 <__ieee754_pow+0x6e8>)
   2dd24:	f3c4 0413 	ubfx	r4, r4, #0, #20
   2dd28:	f044 507f 	orr.w	r0, r4, #1069547520	; 0x3fc00000
   2dd2c:	429c      	cmp	r4, r3
   2dd2e:	f440 1040 	orr.w	r0, r0, #3145728	; 0x300000
   2dd32:	dd06      	ble.n	2dd42 <__ieee754_pow+0x37a>
   2dd34:	4bdf      	ldr	r3, [pc, #892]	; (2e0b4 <__ieee754_pow+0x6ec>)
   2dd36:	429c      	cmp	r4, r3
   2dd38:	f340 80b4 	ble.w	2dea4 <__ieee754_pow+0x4dc>
   2dd3c:	3101      	adds	r1, #1
   2dd3e:	f5a0 1080 	sub.w	r0, r0, #1048576	; 0x100000
   2dd42:	2400      	movs	r4, #0
   2dd44:	e9dd 2300 	ldrd	r2, r3, [sp]
   2dd48:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
   2dd4c:	4603      	mov	r3, r0
   2dd4e:	ec43 2b17 	vmov	d7, r2, r3
   2dd52:	4bd9      	ldr	r3, [pc, #868]	; (2e0b8 <__ieee754_pow+0x6f0>)
   2dd54:	ea4f 0cc4 	mov.w	ip, r4, lsl #3
   2dd58:	4463      	add	r3, ip
   2dd5a:	ed93 5b00 	vldr	d5, [r3]
   2dd5e:	1040      	asrs	r0, r0, #1
   2dd60:	ee37 2b45 	vsub.f64	d2, d7, d5
   2dd64:	ee35 6b07 	vadd.f64	d6, d5, d7
   2dd68:	ee84 1b06 	vdiv.f64	d1, d4, d6
   2dd6c:	ee22 6b01 	vmul.f64	d6, d2, d1
   2dd70:	ed8d 6b00 	vstr	d6, [sp]
   2dd74:	e9dd 8900 	ldrd	r8, r9, [sp]
   2dd78:	f040 5000 	orr.w	r0, r0, #536870912	; 0x20000000
   2dd7c:	f500 2000 	add.w	r0, r0, #524288	; 0x80000
   2dd80:	f04f 0800 	mov.w	r8, #0
   2dd84:	eb00 4384 	add.w	r3, r0, r4, lsl #18
   2dd88:	2200      	movs	r2, #0
   2dd8a:	ec49 8b14 	vmov	d4, r8, r9
   2dd8e:	ec43 2b16 	vmov	d6, r2, r3
   2dd92:	eeb1 3b44 	vneg.f64	d3, d4
   2dd96:	eea3 2b06 	vfma.f64	d2, d3, d6
   2dd9a:	ee36 6b45 	vsub.f64	d6, d6, d5
   2dd9e:	ee37 7b46 	vsub.f64	d7, d7, d6
   2dda2:	eea3 2b07 	vfma.f64	d2, d3, d7
   2dda6:	ed9d 7b00 	vldr	d7, [sp]
   2ddaa:	ee22 2b01 	vmul.f64	d2, d2, d1
   2ddae:	ee27 5b07 	vmul.f64	d5, d7, d7
   2ddb2:	ee37 6b04 	vadd.f64	d6, d7, d4
   2ddb6:	ed9f 1b98 	vldr	d1, [pc, #608]	; 2e018 <__ieee754_pow+0x650>
   2ddba:	ee25 0b05 	vmul.f64	d0, d5, d5
   2ddbe:	ee26 6b02 	vmul.f64	d6, d6, d2
   2ddc2:	ed9f 7b97 	vldr	d7, [pc, #604]	; 2e020 <__ieee754_pow+0x658>
   2ddc6:	eea5 7b01 	vfma.f64	d7, d5, d1
   2ddca:	ed9f 1b97 	vldr	d1, [pc, #604]	; 2e028 <__ieee754_pow+0x660>
   2ddce:	eea7 1b05 	vfma.f64	d1, d7, d5
   2ddd2:	ed9f 7b97 	vldr	d7, [pc, #604]	; 2e030 <__ieee754_pow+0x668>
   2ddd6:	eea1 7b05 	vfma.f64	d7, d1, d5
   2ddda:	ed9f 1b97 	vldr	d1, [pc, #604]	; 2e038 <__ieee754_pow+0x670>
   2ddde:	eea7 1b05 	vfma.f64	d1, d7, d5
   2dde2:	ed9f 7b97 	vldr	d7, [pc, #604]	; 2e040 <__ieee754_pow+0x678>
   2dde6:	eea1 7b05 	vfma.f64	d7, d1, d5
   2ddea:	eea0 6b07 	vfma.f64	d6, d0, d7
   2ddee:	eeb0 7b08 	vmov.f64	d7, #8	; 0x40400000  3.0
   2ddf2:	eeb0 5b47 	vmov.f64	d5, d7
   2ddf6:	eea4 5b04 	vfma.f64	d5, d4, d4
   2ddfa:	ee35 5b06 	vadd.f64	d5, d5, d6
   2ddfe:	ed8d 5b02 	vstr	d5, [sp, #8]
   2de02:	f8cd 8008 	str.w	r8, [sp, #8]
   2de06:	ed9d 5b02 	vldr	d5, [sp, #8]
   2de0a:	ee35 7b47 	vsub.f64	d7, d5, d7
   2de0e:	eea3 7b04 	vfma.f64	d7, d3, d4
   2de12:	ee36 7b47 	vsub.f64	d7, d6, d7
   2de16:	ed9d 6b00 	vldr	d6, [sp]
   2de1a:	ee27 7b06 	vmul.f64	d7, d7, d6
   2de1e:	eea2 7b05 	vfma.f64	d7, d2, d5
   2de22:	eeb0 6b47 	vmov.f64	d6, d7
   2de26:	eea4 6b05 	vfma.f64	d6, d4, d5
   2de2a:	ed8d 6b00 	vstr	d6, [sp]
   2de2e:	f8cd 8000 	str.w	r8, [sp]
   2de32:	ed9d 2b00 	vldr	d2, [sp]
   2de36:	eeb0 6b42 	vmov.f64	d6, d2
   2de3a:	eea3 6b05 	vfma.f64	d6, d3, d5
   2de3e:	ee37 7b46 	vsub.f64	d7, d7, d6
   2de42:	ed9f 6b81 	vldr	d6, [pc, #516]	; 2e048 <__ieee754_pow+0x680>
   2de46:	4b9d      	ldr	r3, [pc, #628]	; (2e0bc <__ieee754_pow+0x6f4>)
   2de48:	ee27 7b06 	vmul.f64	d7, d7, d6
   2de4c:	ed9f 6b80 	vldr	d6, [pc, #512]	; 2e050 <__ieee754_pow+0x688>
   2de50:	4463      	add	r3, ip
   2de52:	eea2 7b06 	vfma.f64	d7, d2, d6
   2de56:	ed93 6b00 	vldr	d6, [r3]
   2de5a:	4b99      	ldr	r3, [pc, #612]	; (2e0c0 <__ieee754_pow+0x6f8>)
   2de5c:	ee37 6b06 	vadd.f64	d6, d7, d6
   2de60:	449c      	add	ip, r3
   2de62:	ed9c 1b00 	vldr	d1, [ip]
   2de66:	eeb0 4b46 	vmov.f64	d4, d6
   2de6a:	ed9f 3b7b 	vldr	d3, [pc, #492]	; 2e058 <__ieee754_pow+0x690>
   2de6e:	ee07 1a90 	vmov	s15, r1
   2de72:	eea2 4b03 	vfma.f64	d4, d2, d3
   2de76:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   2de7a:	ee34 4b01 	vadd.f64	d4, d4, d1
   2de7e:	ee34 5b07 	vadd.f64	d5, d4, d7
   2de82:	ed8d 5b00 	vstr	d5, [sp]
   2de86:	f8cd 8000 	str.w	r8, [sp]
   2de8a:	ed9d 4b00 	vldr	d4, [sp]
   2de8e:	ee34 7b47 	vsub.f64	d7, d4, d7
   2de92:	ee37 7b41 	vsub.f64	d7, d7, d1
   2de96:	eea2 7b43 	vfms.f64	d7, d2, d3
   2de9a:	ee36 7b47 	vsub.f64	d7, d6, d7
   2de9e:	e6ce      	b.n	2dc3e <__ieee754_pow+0x276>
   2dea0:	2300      	movs	r3, #0
   2dea2:	e73a      	b.n	2dd1a <__ieee754_pow+0x352>
   2dea4:	2401      	movs	r4, #1
   2dea6:	e74d      	b.n	2dd44 <__ieee754_pow+0x37c>
   2dea8:	ed9f 4b6d 	vldr	d4, [pc, #436]	; 2e060 <__ieee754_pow+0x698>
   2deac:	ee35 5b46 	vsub.f64	d5, d5, d6
   2deb0:	ee37 4b04 	vadd.f64	d4, d7, d4
   2deb4:	eeb4 4bc5 	vcmpe.f64	d4, d5
   2deb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2debc:	f73f aeea 	bgt.w	2dc94 <__ieee754_pow+0x2cc>
   2dec0:	4a80      	ldr	r2, [pc, #512]	; (2e0c4 <__ieee754_pow+0x6fc>)
   2dec2:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   2dec6:	4293      	cmp	r3, r2
   2dec8:	f340 808e 	ble.w	2dfe8 <__ieee754_pow+0x620>
   2decc:	151b      	asrs	r3, r3, #20
   2dece:	f2a3 30fe 	subw	r0, r3, #1022	; 0x3fe
   2ded2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   2ded6:	4103      	asrs	r3, r0
   2ded8:	440b      	add	r3, r1
   2deda:	f3c3 520a 	ubfx	r2, r3, #20, #11
   2dede:	487a      	ldr	r0, [pc, #488]	; (2e0c8 <__ieee754_pow+0x700>)
   2dee0:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
   2dee4:	4110      	asrs	r0, r2
   2dee6:	ea23 0500 	bic.w	r5, r3, r0
   2deea:	f3c3 0013 	ubfx	r0, r3, #0, #20
   2deee:	2400      	movs	r4, #0
   2def0:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
   2def4:	f1c2 0214 	rsb	r2, r2, #20
   2def8:	ec45 4b15 	vmov	d5, r4, r5
   2defc:	4110      	asrs	r0, r2
   2defe:	2900      	cmp	r1, #0
   2df00:	bfb8      	it	lt
   2df02:	4240      	neglt	r0, r0
   2df04:	ee36 6b45 	vsub.f64	d6, d6, d5
   2df08:	ee36 5b07 	vadd.f64	d5, d6, d7
   2df0c:	ec53 2b15 	vmov	r2, r3, d5
   2df10:	2200      	movs	r2, #0
   2df12:	ec43 2b15 	vmov	d5, r2, r3
   2df16:	ed9f 4b54 	vldr	d4, [pc, #336]	; 2e068 <__ieee754_pow+0x6a0>
   2df1a:	ee35 6b46 	vsub.f64	d6, d5, d6
   2df1e:	ee37 6b46 	vsub.f64	d6, d7, d6
   2df22:	ed9f 7b53 	vldr	d7, [pc, #332]	; 2e070 <__ieee754_pow+0x6a8>
   2df26:	ee25 7b07 	vmul.f64	d7, d5, d7
   2df2a:	eea6 7b04 	vfma.f64	d7, d6, d4
   2df2e:	ed9f 6b52 	vldr	d6, [pc, #328]	; 2e078 <__ieee754_pow+0x6b0>
   2df32:	eeb0 4b47 	vmov.f64	d4, d7
   2df36:	eea5 4b06 	vfma.f64	d4, d5, d6
   2df3a:	eeb0 3b44 	vmov.f64	d3, d4
   2df3e:	eea5 3b46 	vfms.f64	d3, d5, d6
   2df42:	ed9f 5b4f 	vldr	d5, [pc, #316]	; 2e080 <__ieee754_pow+0x6b8>
   2df46:	ee37 7b43 	vsub.f64	d7, d7, d3
   2df4a:	ee24 6b04 	vmul.f64	d6, d4, d4
   2df4e:	ed9f 3b4e 	vldr	d3, [pc, #312]	; 2e088 <__ieee754_pow+0x6c0>
   2df52:	eea4 7b07 	vfma.f64	d7, d4, d7
   2df56:	eea6 3b05 	vfma.f64	d3, d6, d5
   2df5a:	ed9f 5b4d 	vldr	d5, [pc, #308]	; 2e090 <__ieee754_pow+0x6c8>
   2df5e:	eea3 5b06 	vfma.f64	d5, d3, d6
   2df62:	ed9f 3b4d 	vldr	d3, [pc, #308]	; 2e098 <__ieee754_pow+0x6d0>
   2df66:	eea5 3b06 	vfma.f64	d3, d5, d6
   2df6a:	ed9f 5b4d 	vldr	d5, [pc, #308]	; 2e0a0 <__ieee754_pow+0x6d8>
   2df6e:	eea3 5b06 	vfma.f64	d5, d3, d6
   2df72:	eeb0 3b44 	vmov.f64	d3, d4
   2df76:	eea5 3b46 	vfms.f64	d3, d5, d6
   2df7a:	eeb0 5b00 	vmov.f64	d5, #0	; 0x40000000  2.0
   2df7e:	eeb0 6b43 	vmov.f64	d6, d3
   2df82:	ee24 3b03 	vmul.f64	d3, d4, d3
   2df86:	ee36 5b45 	vsub.f64	d5, d6, d5
   2df8a:	ee83 6b05 	vdiv.f64	d6, d3, d5
   2df8e:	ee36 7b47 	vsub.f64	d7, d6, d7
   2df92:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   2df96:	ee37 7b44 	vsub.f64	d7, d7, d4
   2df9a:	ee36 7b47 	vsub.f64	d7, d6, d7
   2df9e:	ed8d 7b00 	vstr	d7, [sp]
   2dfa2:	9901      	ldr	r1, [sp, #4]
   2dfa4:	eb01 5100 	add.w	r1, r1, r0, lsl #20
   2dfa8:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   2dfac:	da1e      	bge.n	2dfec <__ieee754_pow+0x624>
   2dfae:	eeb0 0b47 	vmov.f64	d0, d7
   2dfb2:	f001 f809 	bl	2efc8 <scalbn>
   2dfb6:	ee20 7b08 	vmul.f64	d7, d0, d8
   2dfba:	e56e      	b.n	2da9a <__ieee754_pow+0xd2>
   2dfbc:	4b43      	ldr	r3, [pc, #268]	; (2e0cc <__ieee754_pow+0x704>)
   2dfbe:	f021 4000 	bic.w	r0, r1, #2147483648	; 0x80000000
   2dfc2:	4298      	cmp	r0, r3
   2dfc4:	f77f af7c 	ble.w	2dec0 <__ieee754_pow+0x4f8>
   2dfc8:	4b41      	ldr	r3, [pc, #260]	; (2e0d0 <__ieee754_pow+0x708>)
   2dfca:	440b      	add	r3, r1
   2dfcc:	4313      	orrs	r3, r2
   2dfce:	d002      	beq.n	2dfd6 <__ieee754_pow+0x60e>
   2dfd0:	ed9f 7b35 	vldr	d7, [pc, #212]	; 2e0a8 <__ieee754_pow+0x6e0>
   2dfd4:	e660      	b.n	2dc98 <__ieee754_pow+0x2d0>
   2dfd6:	ee35 5b46 	vsub.f64	d5, d5, d6
   2dfda:	eeb4 5bc7 	vcmpe.f64	d5, d7
   2dfde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dfe2:	f6ff af6d 	blt.w	2dec0 <__ieee754_pow+0x4f8>
   2dfe6:	e7f3      	b.n	2dfd0 <__ieee754_pow+0x608>
   2dfe8:	2000      	movs	r0, #0
   2dfea:	e78d      	b.n	2df08 <__ieee754_pow+0x540>
   2dfec:	e9dd 2300 	ldrd	r2, r3, [sp]
   2dff0:	460b      	mov	r3, r1
   2dff2:	ec43 2b10 	vmov	d0, r2, r3
   2dff6:	e7de      	b.n	2dfb6 <__ieee754_pow+0x5ee>
   2dff8:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   2dffc:	e54d      	b.n	2da9a <__ieee754_pow+0xd2>
   2dffe:	e9cd 6700 	strd	r6, r7, [sp]
   2e002:	e574      	b.n	2daee <__ieee754_pow+0x126>
   2e004:	ed8d 8b00 	vstr	d8, [sp]
   2e008:	e571      	b.n	2daee <__ieee754_pow+0x126>
   2e00a:	4615      	mov	r5, r2
   2e00c:	e557      	b.n	2dabe <__ieee754_pow+0xf6>
   2e00e:	bf00      	nop
   2e010:	00000000 	.word	0x00000000
   2e014:	43400000 	.word	0x43400000
   2e018:	4a454eef 	.word	0x4a454eef
   2e01c:	3fca7e28 	.word	0x3fca7e28
   2e020:	93c9db65 	.word	0x93c9db65
   2e024:	3fcd864a 	.word	0x3fcd864a
   2e028:	a91d4101 	.word	0xa91d4101
   2e02c:	3fd17460 	.word	0x3fd17460
   2e030:	518f264d 	.word	0x518f264d
   2e034:	3fd55555 	.word	0x3fd55555
   2e038:	db6fabff 	.word	0xdb6fabff
   2e03c:	3fdb6db6 	.word	0x3fdb6db6
   2e040:	33333303 	.word	0x33333303
   2e044:	3fe33333 	.word	0x3fe33333
   2e048:	dc3a03fd 	.word	0xdc3a03fd
   2e04c:	3feec709 	.word	0x3feec709
   2e050:	145b01f5 	.word	0x145b01f5
   2e054:	be3e2fe0 	.word	0xbe3e2fe0
   2e058:	e0000000 	.word	0xe0000000
   2e05c:	3feec709 	.word	0x3feec709
   2e060:	652b82fe 	.word	0x652b82fe
   2e064:	3c971547 	.word	0x3c971547
   2e068:	fefa39ef 	.word	0xfefa39ef
   2e06c:	3fe62e42 	.word	0x3fe62e42
   2e070:	0ca86c39 	.word	0x0ca86c39
   2e074:	be205c61 	.word	0xbe205c61
   2e078:	00000000 	.word	0x00000000
   2e07c:	3fe62e43 	.word	0x3fe62e43
   2e080:	72bea4d0 	.word	0x72bea4d0
   2e084:	3e663769 	.word	0x3e663769
   2e088:	c5d26bf1 	.word	0xc5d26bf1
   2e08c:	bebbbd41 	.word	0xbebbbd41
   2e090:	af25de2c 	.word	0xaf25de2c
   2e094:	3f11566a 	.word	0x3f11566a
   2e098:	16bebd93 	.word	0x16bebd93
   2e09c:	bf66c16c 	.word	0xbf66c16c
   2e0a0:	5555553e 	.word	0x5555553e
   2e0a4:	3fc55555 	.word	0x3fc55555
   2e0a8:	c2f8f359 	.word	0xc2f8f359
   2e0ac:	01a56e1f 	.word	0x01a56e1f
   2e0b0:	0003988e 	.word	0x0003988e
   2e0b4:	000bb679 	.word	0x000bb679
   2e0b8:	00052130 	.word	0x00052130
   2e0bc:	00052150 	.word	0x00052150
   2e0c0:	00052140 	.word	0x00052140
   2e0c4:	3fe00000 	.word	0x3fe00000
   2e0c8:	000fffff 	.word	0x000fffff
   2e0cc:	4090cbff 	.word	0x4090cbff
   2e0d0:	3f6f3400 	.word	0x3f6f3400

0002e0d4 <__ieee754_sqrt>:
   2e0d4:	eeb1 0bc0 	vsqrt.f64	d0, d0
   2e0d8:	4770      	bx	lr
	...

0002e0dc <__ieee754_fmodf>:
   2e0dc:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e0de:	ee10 6a90 	vmov	r6, s1
   2e0e2:	f036 4500 	bics.w	r5, r6, #2147483648	; 0x80000000
   2e0e6:	ee10 3a10 	vmov	r3, s0
   2e0ea:	d009      	beq.n	2e100 <__ieee754_fmodf+0x24>
   2e0ec:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
   2e0f0:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
   2e0f4:	ee10 7a10 	vmov	r7, s0
   2e0f8:	da02      	bge.n	2e100 <__ieee754_fmodf+0x24>
   2e0fa:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
   2e0fe:	dd0a      	ble.n	2e116 <__ieee754_fmodf+0x3a>
   2e100:	ee07 3a90 	vmov	s15, r3
   2e104:	ee67 0aa0 	vmul.f32	s1, s15, s1
   2e108:	eec0 7aa0 	vdiv.f32	s15, s1, s1
   2e10c:	ee17 3a90 	vmov	r3, s15
   2e110:	ee00 3a10 	vmov	s0, r3
   2e114:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e116:	42a9      	cmp	r1, r5
   2e118:	dbfa      	blt.n	2e110 <__ieee754_fmodf+0x34>
   2e11a:	f003 4400 	and.w	r4, r3, #2147483648	; 0x80000000
   2e11e:	d105      	bne.n	2e12c <__ieee754_fmodf+0x50>
   2e120:	4a30      	ldr	r2, [pc, #192]	; (2e1e4 <__ieee754_fmodf+0x108>)
   2e122:	0fe3      	lsrs	r3, r4, #31
   2e124:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2e128:	681b      	ldr	r3, [r3, #0]
   2e12a:	e7f1      	b.n	2e110 <__ieee754_fmodf+0x34>
   2e12c:	4b2e      	ldr	r3, [pc, #184]	; (2e1e8 <__ieee754_fmodf+0x10c>)
   2e12e:	4299      	cmp	r1, r3
   2e130:	dc3e      	bgt.n	2e1b0 <__ieee754_fmodf+0xd4>
   2e132:	020a      	lsls	r2, r1, #8
   2e134:	f06f 007d 	mvn.w	r0, #125	; 0x7d
   2e138:	2a00      	cmp	r2, #0
   2e13a:	dc36      	bgt.n	2e1aa <__ieee754_fmodf+0xce>
   2e13c:	429d      	cmp	r5, r3
   2e13e:	dc3a      	bgt.n	2e1b6 <__ieee754_fmodf+0xda>
   2e140:	022b      	lsls	r3, r5, #8
   2e142:	f06f 027d 	mvn.w	r2, #125	; 0x7d
   2e146:	005b      	lsls	r3, r3, #1
   2e148:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
   2e14c:	d5fb      	bpl.n	2e146 <__ieee754_fmodf+0x6a>
   2e14e:	f110 0f7e 	cmn.w	r0, #126	; 0x7e
   2e152:	bfbb      	ittet	lt
   2e154:	f06f 037d 	mvnlt.w	r3, #125	; 0x7d
   2e158:	1a1b      	sublt	r3, r3, r0
   2e15a:	f3c7 0116 	ubfxge	r1, r7, #0, #23
   2e15e:	4099      	lsllt	r1, r3
   2e160:	bfa8      	it	ge
   2e162:	f441 0100 	orrge.w	r1, r1, #8388608	; 0x800000
   2e166:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
   2e16a:	bfb5      	itete	lt
   2e16c:	f06f 037d 	mvnlt.w	r3, #125	; 0x7d
   2e170:	f3c6 0516 	ubfxge	r5, r6, #0, #23
   2e174:	1a9b      	sublt	r3, r3, r2
   2e176:	f445 0500 	orrge.w	r5, r5, #8388608	; 0x800000
   2e17a:	bfb8      	it	lt
   2e17c:	409d      	lsllt	r5, r3
   2e17e:	1a80      	subs	r0, r0, r2
   2e180:	1b4b      	subs	r3, r1, r5
   2e182:	b9d8      	cbnz	r0, 2e1bc <__ieee754_fmodf+0xe0>
   2e184:	ea33 0323 	bics.w	r3, r3, r3, asr #32
   2e188:	bf28      	it	cs
   2e18a:	460b      	movcs	r3, r1
   2e18c:	2b00      	cmp	r3, #0
   2e18e:	d0c7      	beq.n	2e120 <__ieee754_fmodf+0x44>
   2e190:	4915      	ldr	r1, [pc, #84]	; (2e1e8 <__ieee754_fmodf+0x10c>)
   2e192:	428b      	cmp	r3, r1
   2e194:	dd1a      	ble.n	2e1cc <__ieee754_fmodf+0xf0>
   2e196:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
   2e19a:	db1a      	blt.n	2e1d2 <__ieee754_fmodf+0xf6>
   2e19c:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   2e1a0:	4323      	orrs	r3, r4
   2e1a2:	327f      	adds	r2, #127	; 0x7f
   2e1a4:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
   2e1a8:	e7b2      	b.n	2e110 <__ieee754_fmodf+0x34>
   2e1aa:	3801      	subs	r0, #1
   2e1ac:	0052      	lsls	r2, r2, #1
   2e1ae:	e7c3      	b.n	2e138 <__ieee754_fmodf+0x5c>
   2e1b0:	15c8      	asrs	r0, r1, #23
   2e1b2:	387f      	subs	r0, #127	; 0x7f
   2e1b4:	e7c2      	b.n	2e13c <__ieee754_fmodf+0x60>
   2e1b6:	15ea      	asrs	r2, r5, #23
   2e1b8:	3a7f      	subs	r2, #127	; 0x7f
   2e1ba:	e7c8      	b.n	2e14e <__ieee754_fmodf+0x72>
   2e1bc:	2b00      	cmp	r3, #0
   2e1be:	da02      	bge.n	2e1c6 <__ieee754_fmodf+0xea>
   2e1c0:	0049      	lsls	r1, r1, #1
   2e1c2:	3801      	subs	r0, #1
   2e1c4:	e7dc      	b.n	2e180 <__ieee754_fmodf+0xa4>
   2e1c6:	d0ab      	beq.n	2e120 <__ieee754_fmodf+0x44>
   2e1c8:	0059      	lsls	r1, r3, #1
   2e1ca:	e7fa      	b.n	2e1c2 <__ieee754_fmodf+0xe6>
   2e1cc:	005b      	lsls	r3, r3, #1
   2e1ce:	3a01      	subs	r2, #1
   2e1d0:	e7df      	b.n	2e192 <__ieee754_fmodf+0xb6>
   2e1d2:	f1c2 22ff 	rsb	r2, r2, #4278255360	; 0xff00ff00
   2e1d6:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
   2e1da:	3282      	adds	r2, #130	; 0x82
   2e1dc:	4113      	asrs	r3, r2
   2e1de:	4323      	orrs	r3, r4
   2e1e0:	e796      	b.n	2e110 <__ieee754_fmodf+0x34>
   2e1e2:	bf00      	nop
   2e1e4:	00052160 	.word	0x00052160
   2e1e8:	007fffff 	.word	0x007fffff

0002e1ec <__ieee754_log10f>:
   2e1ec:	b508      	push	{r3, lr}
   2e1ee:	ee10 2a10 	vmov	r2, s0
   2e1f2:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
   2e1f6:	ed2d 8b02 	vpush	{d8}
   2e1fa:	d108      	bne.n	2e20e <__ieee754_log10f+0x22>
   2e1fc:	ed9f 7a20 	vldr	s14, [pc, #128]	; 2e280 <__ieee754_log10f+0x94>
   2e200:	eddf 7a20 	vldr	s15, [pc, #128]	; 2e284 <__ieee754_log10f+0x98>
   2e204:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2e208:	ecbd 8b02 	vpop	{d8}
   2e20c:	bd08      	pop	{r3, pc}
   2e20e:	2a00      	cmp	r2, #0
   2e210:	da02      	bge.n	2e218 <__ieee754_log10f+0x2c>
   2e212:	ee30 7a40 	vsub.f32	s14, s0, s0
   2e216:	e7f3      	b.n	2e200 <__ieee754_log10f+0x14>
   2e218:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
   2e21c:	db02      	blt.n	2e224 <__ieee754_log10f+0x38>
   2e21e:	ee30 0a00 	vadd.f32	s0, s0, s0
   2e222:	e7f1      	b.n	2e208 <__ieee754_log10f+0x1c>
   2e224:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
   2e228:	bfbf      	itttt	lt
   2e22a:	eddf 7a17 	vldrlt	s15, [pc, #92]	; 2e288 <__ieee754_log10f+0x9c>
   2e22e:	ee60 7a27 	vmullt.f32	s15, s0, s15
   2e232:	f06f 0118 	mvnlt.w	r1, #24
   2e236:	ee17 2a90 	vmovlt	r2, s15
   2e23a:	ea4f 53e2 	mov.w	r3, r2, asr #23
   2e23e:	bfa8      	it	ge
   2e240:	2100      	movge	r1, #0
   2e242:	3b7f      	subs	r3, #127	; 0x7f
   2e244:	440b      	add	r3, r1
   2e246:	0fd9      	lsrs	r1, r3, #31
   2e248:	440b      	add	r3, r1
   2e24a:	f3c2 0216 	ubfx	r2, r2, #0, #23
   2e24e:	f1c1 017f 	rsb	r1, r1, #127	; 0x7f
   2e252:	ee07 3a90 	vmov	s15, r3
   2e256:	ea42 53c1 	orr.w	r3, r2, r1, lsl #23
   2e25a:	ee00 3a10 	vmov	s0, r3
   2e25e:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
   2e262:	f7fe fd2d 	bl	2ccc0 <logf>
   2e266:	eddf 7a09 	vldr	s15, [pc, #36]	; 2e28c <__ieee754_log10f+0xa0>
   2e26a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2e26e:	eddf 7a08 	vldr	s15, [pc, #32]	; 2e290 <__ieee754_log10f+0xa4>
   2e272:	eea8 0a27 	vfma.f32	s0, s16, s15
   2e276:	eddf 7a07 	vldr	s15, [pc, #28]	; 2e294 <__ieee754_log10f+0xa8>
   2e27a:	eea8 0a27 	vfma.f32	s0, s16, s15
   2e27e:	e7c3      	b.n	2e208 <__ieee754_log10f+0x1c>
   2e280:	cc000000 	.word	0xcc000000
   2e284:	00000000 	.word	0x00000000
   2e288:	4c000000 	.word	0x4c000000
   2e28c:	3ede5bd9 	.word	0x3ede5bd9
   2e290:	355427db 	.word	0x355427db
   2e294:	3e9a2080 	.word	0x3e9a2080

0002e298 <__ieee754_rem_pio2f>:
   2e298:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e29a:	ee10 6a10 	vmov	r6, s0
   2e29e:	4b86      	ldr	r3, [pc, #536]	; (2e4b8 <__ieee754_rem_pio2f+0x220>)
   2e2a0:	f026 4400 	bic.w	r4, r6, #2147483648	; 0x80000000
   2e2a4:	429c      	cmp	r4, r3
   2e2a6:	b087      	sub	sp, #28
   2e2a8:	4605      	mov	r5, r0
   2e2aa:	dc05      	bgt.n	2e2b8 <__ieee754_rem_pio2f+0x20>
   2e2ac:	2300      	movs	r3, #0
   2e2ae:	ed85 0a00 	vstr	s0, [r5]
   2e2b2:	6043      	str	r3, [r0, #4]
   2e2b4:	2000      	movs	r0, #0
   2e2b6:	e020      	b.n	2e2fa <__ieee754_rem_pio2f+0x62>
   2e2b8:	4b80      	ldr	r3, [pc, #512]	; (2e4bc <__ieee754_rem_pio2f+0x224>)
   2e2ba:	429c      	cmp	r4, r3
   2e2bc:	dc38      	bgt.n	2e330 <__ieee754_rem_pio2f+0x98>
   2e2be:	2e00      	cmp	r6, #0
   2e2c0:	f024 040f 	bic.w	r4, r4, #15
   2e2c4:	ed9f 7a7e 	vldr	s14, [pc, #504]	; 2e4c0 <__ieee754_rem_pio2f+0x228>
   2e2c8:	4b7e      	ldr	r3, [pc, #504]	; (2e4c4 <__ieee754_rem_pio2f+0x22c>)
   2e2ca:	dd18      	ble.n	2e2fe <__ieee754_rem_pio2f+0x66>
   2e2cc:	429c      	cmp	r4, r3
   2e2ce:	ee70 7a47 	vsub.f32	s15, s0, s14
   2e2d2:	bf09      	itett	eq
   2e2d4:	ed9f 7a7c 	vldreq	s14, [pc, #496]	; 2e4c8 <__ieee754_rem_pio2f+0x230>
   2e2d8:	ed9f 7a7c 	vldrne	s14, [pc, #496]	; 2e4cc <__ieee754_rem_pio2f+0x234>
   2e2dc:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
   2e2e0:	ed9f 7a7b 	vldreq	s14, [pc, #492]	; 2e4d0 <__ieee754_rem_pio2f+0x238>
   2e2e4:	ee77 6ac7 	vsub.f32	s13, s15, s14
   2e2e8:	ee77 7ae6 	vsub.f32	s15, s15, s13
   2e2ec:	edc0 6a00 	vstr	s13, [r0]
   2e2f0:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2e2f4:	edc0 7a01 	vstr	s15, [r0, #4]
   2e2f8:	2001      	movs	r0, #1
   2e2fa:	b007      	add	sp, #28
   2e2fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e2fe:	429c      	cmp	r4, r3
   2e300:	ee70 7a07 	vadd.f32	s15, s0, s14
   2e304:	bf09      	itett	eq
   2e306:	ed9f 7a70 	vldreq	s14, [pc, #448]	; 2e4c8 <__ieee754_rem_pio2f+0x230>
   2e30a:	ed9f 7a70 	vldrne	s14, [pc, #448]	; 2e4cc <__ieee754_rem_pio2f+0x234>
   2e30e:	ee77 7a87 	vaddeq.f32	s15, s15, s14
   2e312:	ed9f 7a6f 	vldreq	s14, [pc, #444]	; 2e4d0 <__ieee754_rem_pio2f+0x238>
   2e316:	ee77 6a87 	vadd.f32	s13, s15, s14
   2e31a:	ee77 7ae6 	vsub.f32	s15, s15, s13
   2e31e:	edc0 6a00 	vstr	s13, [r0]
   2e322:	ee77 7a87 	vadd.f32	s15, s15, s14
   2e326:	edc0 7a01 	vstr	s15, [r0, #4]
   2e32a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2e32e:	e7e4      	b.n	2e2fa <__ieee754_rem_pio2f+0x62>
   2e330:	4b68      	ldr	r3, [pc, #416]	; (2e4d4 <__ieee754_rem_pio2f+0x23c>)
   2e332:	429c      	cmp	r4, r3
   2e334:	dc71      	bgt.n	2e41a <__ieee754_rem_pio2f+0x182>
   2e336:	f7fe fcbb 	bl	2ccb0 <fabsf>
   2e33a:	ed9f 7a67 	vldr	s14, [pc, #412]	; 2e4d8 <__ieee754_rem_pio2f+0x240>
   2e33e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2e342:	eee0 7a07 	vfma.f32	s15, s0, s14
   2e346:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2e34a:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
   2e34e:	ee17 0a90 	vmov	r0, s15
   2e352:	eddf 7a5b 	vldr	s15, [pc, #364]	; 2e4c0 <__ieee754_rem_pio2f+0x228>
   2e356:	eeb1 7a46 	vneg.f32	s14, s12
   2e35a:	eea7 0a27 	vfma.f32	s0, s14, s15
   2e35e:	281f      	cmp	r0, #31
   2e360:	eddf 7a5a 	vldr	s15, [pc, #360]	; 2e4cc <__ieee754_rem_pio2f+0x234>
   2e364:	ee66 7a27 	vmul.f32	s15, s12, s15
   2e368:	ee70 6a67 	vsub.f32	s13, s0, s15
   2e36c:	ee16 3a90 	vmov	r3, s13
   2e370:	dc1c      	bgt.n	2e3ac <__ieee754_rem_pio2f+0x114>
   2e372:	1e47      	subs	r7, r0, #1
   2e374:	4959      	ldr	r1, [pc, #356]	; (2e4dc <__ieee754_rem_pio2f+0x244>)
   2e376:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
   2e37a:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
   2e37e:	428a      	cmp	r2, r1
   2e380:	d014      	beq.n	2e3ac <__ieee754_rem_pio2f+0x114>
   2e382:	602b      	str	r3, [r5, #0]
   2e384:	ed95 7a00 	vldr	s14, [r5]
   2e388:	ee30 0a47 	vsub.f32	s0, s0, s14
   2e38c:	2e00      	cmp	r6, #0
   2e38e:	ee30 0a67 	vsub.f32	s0, s0, s15
   2e392:	ed85 0a01 	vstr	s0, [r5, #4]
   2e396:	dab0      	bge.n	2e2fa <__ieee754_rem_pio2f+0x62>
   2e398:	eeb1 7a47 	vneg.f32	s14, s14
   2e39c:	eeb1 0a40 	vneg.f32	s0, s0
   2e3a0:	ed85 7a00 	vstr	s14, [r5]
   2e3a4:	ed85 0a01 	vstr	s0, [r5, #4]
   2e3a8:	4240      	negs	r0, r0
   2e3aa:	e7a6      	b.n	2e2fa <__ieee754_rem_pio2f+0x62>
   2e3ac:	15e4      	asrs	r4, r4, #23
   2e3ae:	f3c3 52c7 	ubfx	r2, r3, #23, #8
   2e3b2:	1aa2      	subs	r2, r4, r2
   2e3b4:	2a08      	cmp	r2, #8
   2e3b6:	dde4      	ble.n	2e382 <__ieee754_rem_pio2f+0xea>
   2e3b8:	eddf 7a43 	vldr	s15, [pc, #268]	; 2e4c8 <__ieee754_rem_pio2f+0x230>
   2e3bc:	eef0 6a40 	vmov.f32	s13, s0
   2e3c0:	eee7 6a27 	vfma.f32	s13, s14, s15
   2e3c4:	ee30 0a66 	vsub.f32	s0, s0, s13
   2e3c8:	eea7 0a27 	vfma.f32	s0, s14, s15
   2e3cc:	eddf 7a40 	vldr	s15, [pc, #256]	; 2e4d0 <__ieee754_rem_pio2f+0x238>
   2e3d0:	ee96 0a27 	vfnms.f32	s0, s12, s15
   2e3d4:	ee76 5ac0 	vsub.f32	s11, s13, s0
   2e3d8:	eef0 7a40 	vmov.f32	s15, s0
   2e3dc:	ee15 3a90 	vmov	r3, s11
   2e3e0:	f3c3 52c7 	ubfx	r2, r3, #23, #8
   2e3e4:	1aa4      	subs	r4, r4, r2
   2e3e6:	2c19      	cmp	r4, #25
   2e3e8:	dc04      	bgt.n	2e3f4 <__ieee754_rem_pio2f+0x15c>
   2e3ea:	edc5 5a00 	vstr	s11, [r5]
   2e3ee:	eeb0 0a66 	vmov.f32	s0, s13
   2e3f2:	e7c7      	b.n	2e384 <__ieee754_rem_pio2f+0xec>
   2e3f4:	eddf 5a3a 	vldr	s11, [pc, #232]	; 2e4e0 <__ieee754_rem_pio2f+0x248>
   2e3f8:	eeb0 0a66 	vmov.f32	s0, s13
   2e3fc:	eea7 0a25 	vfma.f32	s0, s14, s11
   2e400:	ee76 7ac0 	vsub.f32	s15, s13, s0
   2e404:	eee7 7a25 	vfma.f32	s15, s14, s11
   2e408:	ed9f 7a36 	vldr	s14, [pc, #216]	; 2e4e4 <__ieee754_rem_pio2f+0x24c>
   2e40c:	eed6 7a07 	vfnms.f32	s15, s12, s14
   2e410:	ee30 7a67 	vsub.f32	s14, s0, s15
   2e414:	ed85 7a00 	vstr	s14, [r5]
   2e418:	e7b4      	b.n	2e384 <__ieee754_rem_pio2f+0xec>
   2e41a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   2e41e:	db06      	blt.n	2e42e <__ieee754_rem_pio2f+0x196>
   2e420:	ee70 7a40 	vsub.f32	s15, s0, s0
   2e424:	edc0 7a01 	vstr	s15, [r0, #4]
   2e428:	edc0 7a00 	vstr	s15, [r0]
   2e42c:	e742      	b.n	2e2b4 <__ieee754_rem_pio2f+0x1c>
   2e42e:	15e2      	asrs	r2, r4, #23
   2e430:	3a86      	subs	r2, #134	; 0x86
   2e432:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
   2e436:	ee07 3a90 	vmov	s15, r3
   2e43a:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2e43e:	eddf 6a2a 	vldr	s13, [pc, #168]	; 2e4e8 <__ieee754_rem_pio2f+0x250>
   2e442:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2e446:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2e44a:	ed8d 7a03 	vstr	s14, [sp, #12]
   2e44e:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2e452:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2e456:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2e45a:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2e45e:	ed8d 7a04 	vstr	s14, [sp, #16]
   2e462:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2e466:	eef5 7a40 	vcmp.f32	s15, #0.0
   2e46a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e46e:	edcd 7a05 	vstr	s15, [sp, #20]
   2e472:	d11e      	bne.n	2e4b2 <__ieee754_rem_pio2f+0x21a>
   2e474:	eeb5 7a40 	vcmp.f32	s14, #0.0
   2e478:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e47c:	bf0c      	ite	eq
   2e47e:	2301      	moveq	r3, #1
   2e480:	2302      	movne	r3, #2
   2e482:	491a      	ldr	r1, [pc, #104]	; (2e4ec <__ieee754_rem_pio2f+0x254>)
   2e484:	9101      	str	r1, [sp, #4]
   2e486:	2102      	movs	r1, #2
   2e488:	9100      	str	r1, [sp, #0]
   2e48a:	a803      	add	r0, sp, #12
   2e48c:	4629      	mov	r1, r5
   2e48e:	f000 f8fb 	bl	2e688 <__kernel_rem_pio2f>
   2e492:	2e00      	cmp	r6, #0
   2e494:	f6bf af31 	bge.w	2e2fa <__ieee754_rem_pio2f+0x62>
   2e498:	edd5 7a00 	vldr	s15, [r5]
   2e49c:	eef1 7a67 	vneg.f32	s15, s15
   2e4a0:	edc5 7a00 	vstr	s15, [r5]
   2e4a4:	edd5 7a01 	vldr	s15, [r5, #4]
   2e4a8:	eef1 7a67 	vneg.f32	s15, s15
   2e4ac:	edc5 7a01 	vstr	s15, [r5, #4]
   2e4b0:	e77a      	b.n	2e3a8 <__ieee754_rem_pio2f+0x110>
   2e4b2:	2303      	movs	r3, #3
   2e4b4:	e7e5      	b.n	2e482 <__ieee754_rem_pio2f+0x1ea>
   2e4b6:	bf00      	nop
   2e4b8:	3f490fd8 	.word	0x3f490fd8
   2e4bc:	4016cbe3 	.word	0x4016cbe3
   2e4c0:	3fc90f80 	.word	0x3fc90f80
   2e4c4:	3fc90fd0 	.word	0x3fc90fd0
   2e4c8:	37354400 	.word	0x37354400
   2e4cc:	37354443 	.word	0x37354443
   2e4d0:	2e85a308 	.word	0x2e85a308
   2e4d4:	43490f80 	.word	0x43490f80
   2e4d8:	3f22f984 	.word	0x3f22f984
   2e4dc:	00052168 	.word	0x00052168
   2e4e0:	2e85a300 	.word	0x2e85a300
   2e4e4:	248d3132 	.word	0x248d3132
   2e4e8:	43800000 	.word	0x43800000
   2e4ec:	000521e8 	.word	0x000521e8

0002e4f0 <__ieee754_sinhf>:
   2e4f0:	b510      	push	{r4, lr}
   2e4f2:	ee10 3a10 	vmov	r3, s0
   2e4f6:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
   2e4fa:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   2e4fe:	ed2d 8b02 	vpush	{d8}
   2e502:	eef0 7a40 	vmov.f32	s15, s0
   2e506:	db06      	blt.n	2e516 <__ieee754_sinhf+0x26>
   2e508:	ee70 7a00 	vadd.f32	s15, s0, s0
   2e50c:	ecbd 8b02 	vpop	{d8}
   2e510:	eeb0 0a67 	vmov.f32	s0, s15
   2e514:	bd10      	pop	{r4, pc}
   2e516:	2b00      	cmp	r3, #0
   2e518:	4b28      	ldr	r3, [pc, #160]	; (2e5bc <__ieee754_sinhf+0xcc>)
   2e51a:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
   2e51e:	eebe 8a00 	vmov.f32	s16, #224	; 0xbf000000 -0.5
   2e522:	fe28 8a88 	vselge.f32	s16, s17, s16
   2e526:	429c      	cmp	r4, r3
   2e528:	dc2a      	bgt.n	2e580 <__ieee754_sinhf+0x90>
   2e52a:	f1b4 5f46 	cmp.w	r4, #830472192	; 0x31800000
   2e52e:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
   2e532:	da08      	bge.n	2e546 <__ieee754_sinhf+0x56>
   2e534:	ed9f 7a22 	vldr	s14, [pc, #136]	; 2e5c0 <__ieee754_sinhf+0xd0>
   2e538:	ee30 7a07 	vadd.f32	s14, s0, s14
   2e53c:	eeb4 7ae8 	vcmpe.f32	s14, s17
   2e540:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e544:	dce2      	bgt.n	2e50c <__ieee754_sinhf+0x1c>
   2e546:	eeb0 0a67 	vmov.f32	s0, s15
   2e54a:	f7fe fbb1 	bl	2ccb0 <fabsf>
   2e54e:	f000 fdb9 	bl	2f0c4 <expm1f>
   2e552:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
   2e556:	bfbb      	ittet	lt
   2e558:	ee20 7a00 	vmullt.f32	s14, s0, s0
   2e55c:	ee70 8a28 	vaddlt.f32	s17, s0, s17
   2e560:	ee70 8a28 	vaddge.f32	s17, s0, s17
   2e564:	eec7 7a28 	vdivlt.f32	s15, s14, s17
   2e568:	bfad      	iteet	ge
   2e56a:	eec0 7a28 	vdivge.f32	s15, s0, s17
   2e56e:	eeb0 7a00 	vmovlt.f32	s14, #0	; 0x40000000  2.0
   2e572:	eed0 7a07 	vfnmslt.f32	s15, s0, s14
   2e576:	ee77 7a80 	vaddge.f32	s15, s15, s0
   2e57a:	ee67 7a88 	vmul.f32	s15, s15, s16
   2e57e:	e7c5      	b.n	2e50c <__ieee754_sinhf+0x1c>
   2e580:	4b10      	ldr	r3, [pc, #64]	; (2e5c4 <__ieee754_sinhf+0xd4>)
   2e582:	429c      	cmp	r4, r3
   2e584:	dc06      	bgt.n	2e594 <__ieee754_sinhf+0xa4>
   2e586:	f7fe fb93 	bl	2ccb0 <fabsf>
   2e58a:	f7fe fb13 	bl	2cbb4 <expf>
   2e58e:	ee60 7a08 	vmul.f32	s15, s0, s16
   2e592:	e7bb      	b.n	2e50c <__ieee754_sinhf+0x1c>
   2e594:	4b0c      	ldr	r3, [pc, #48]	; (2e5c8 <__ieee754_sinhf+0xd8>)
   2e596:	429c      	cmp	r4, r3
   2e598:	dc0a      	bgt.n	2e5b0 <__ieee754_sinhf+0xc0>
   2e59a:	f7fe fb89 	bl	2ccb0 <fabsf>
   2e59e:	ee20 0a28 	vmul.f32	s0, s0, s17
   2e5a2:	f7fe fb07 	bl	2cbb4 <expf>
   2e5a6:	ee68 7a00 	vmul.f32	s15, s16, s0
   2e5aa:	ee67 7a80 	vmul.f32	s15, s15, s0
   2e5ae:	e7ad      	b.n	2e50c <__ieee754_sinhf+0x1c>
   2e5b0:	ed9f 7a03 	vldr	s14, [pc, #12]	; 2e5c0 <__ieee754_sinhf+0xd0>
   2e5b4:	ee60 7a07 	vmul.f32	s15, s0, s14
   2e5b8:	e7a8      	b.n	2e50c <__ieee754_sinhf+0x1c>
   2e5ba:	bf00      	nop
   2e5bc:	41afffff 	.word	0x41afffff
   2e5c0:	7cf0bdc2 	.word	0x7cf0bdc2
   2e5c4:	42b17217 	.word	0x42b17217
   2e5c8:	42b2d4fc 	.word	0x42b2d4fc

0002e5cc <__kernel_cosf>:
   2e5cc:	ee10 3a10 	vmov	r3, s0
   2e5d0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2e5d4:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   2e5d8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2e5dc:	da05      	bge.n	2e5ea <__kernel_cosf+0x1e>
   2e5de:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   2e5e2:	ee17 2a90 	vmov	r2, s15
   2e5e6:	2a00      	cmp	r2, #0
   2e5e8:	d03b      	beq.n	2e662 <__kernel_cosf+0x96>
   2e5ea:	ee20 6a00 	vmul.f32	s12, s0, s0
   2e5ee:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   2e5f2:	eddf 5a1d 	vldr	s11, [pc, #116]	; 2e668 <__kernel_cosf+0x9c>
   2e5f6:	4a1d      	ldr	r2, [pc, #116]	; (2e66c <__kernel_cosf+0xa0>)
   2e5f8:	ee66 7a07 	vmul.f32	s15, s12, s14
   2e5fc:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 2e670 <__kernel_cosf+0xa4>
   2e600:	eea6 7a25 	vfma.f32	s14, s12, s11
   2e604:	4293      	cmp	r3, r2
   2e606:	eddf 5a1b 	vldr	s11, [pc, #108]	; 2e674 <__kernel_cosf+0xa8>
   2e60a:	eee7 5a06 	vfma.f32	s11, s14, s12
   2e60e:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 2e678 <__kernel_cosf+0xac>
   2e612:	eea5 7a86 	vfma.f32	s14, s11, s12
   2e616:	eddf 5a19 	vldr	s11, [pc, #100]	; 2e67c <__kernel_cosf+0xb0>
   2e61a:	eee7 5a06 	vfma.f32	s11, s14, s12
   2e61e:	ed9f 7a18 	vldr	s14, [pc, #96]	; 2e680 <__kernel_cosf+0xb4>
   2e622:	eea5 7a86 	vfma.f32	s14, s11, s12
   2e626:	ee60 0ac0 	vnmul.f32	s1, s1, s0
   2e62a:	ee27 7a06 	vmul.f32	s14, s14, s12
   2e62e:	eee6 0a07 	vfma.f32	s1, s12, s14
   2e632:	dc04      	bgt.n	2e63e <__kernel_cosf+0x72>
   2e634:	ee77 0ae0 	vsub.f32	s1, s15, s1
   2e638:	ee36 0ae0 	vsub.f32	s0, s13, s1
   2e63c:	4770      	bx	lr
   2e63e:	4a11      	ldr	r2, [pc, #68]	; (2e684 <__kernel_cosf+0xb8>)
   2e640:	4293      	cmp	r3, r2
   2e642:	bfda      	itte	le
   2e644:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
   2e648:	ee07 3a10 	vmovle	s14, r3
   2e64c:	eeb5 7a02 	vmovgt.f32	s14, #82	; 0x3e900000  0.2812500
   2e650:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2e654:	ee36 0ac7 	vsub.f32	s0, s13, s14
   2e658:	ee77 7ae0 	vsub.f32	s15, s15, s1
   2e65c:	ee30 0a67 	vsub.f32	s0, s0, s15
   2e660:	4770      	bx	lr
   2e662:	eeb0 0a66 	vmov.f32	s0, s13
   2e666:	4770      	bx	lr
   2e668:	ad47d74e 	.word	0xad47d74e
   2e66c:	3e999999 	.word	0x3e999999
   2e670:	310f74f6 	.word	0x310f74f6
   2e674:	b493f27c 	.word	0xb493f27c
   2e678:	37d00d01 	.word	0x37d00d01
   2e67c:	bab60b61 	.word	0xbab60b61
   2e680:	3d2aaaab 	.word	0x3d2aaaab
   2e684:	3f480000 	.word	0x3f480000

0002e688 <__kernel_rem_pio2f>:
   2e688:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2e68c:	ed2d 8b04 	vpush	{d8-d9}
   2e690:	b0d7      	sub	sp, #348	; 0x15c
   2e692:	469b      	mov	fp, r3
   2e694:	460e      	mov	r6, r1
   2e696:	4bbe      	ldr	r3, [pc, #760]	; (2e990 <__kernel_rem_pio2f+0x308>)
   2e698:	9964      	ldr	r1, [sp, #400]	; 0x190
   2e69a:	9002      	str	r0, [sp, #8]
   2e69c:	f853 9021 	ldr.w	r9, [r3, r1, lsl #2]
   2e6a0:	9865      	ldr	r0, [sp, #404]	; 0x194
   2e6a2:	ed9f 7abf 	vldr	s14, [pc, #764]	; 2e9a0 <__kernel_rem_pio2f+0x318>
   2e6a6:	1ed1      	subs	r1, r2, #3
   2e6a8:	2308      	movs	r3, #8
   2e6aa:	fb91 f1f3 	sdiv	r1, r1, r3
   2e6ae:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
   2e6b2:	f10b 3aff 	add.w	sl, fp, #4294967295	; 0xffffffff
   2e6b6:	1c4c      	adds	r4, r1, #1
   2e6b8:	eba2 04c4 	sub.w	r4, r2, r4, lsl #3
   2e6bc:	eba1 050a 	sub.w	r5, r1, sl
   2e6c0:	aa1a      	add	r2, sp, #104	; 0x68
   2e6c2:	eb09 070a 	add.w	r7, r9, sl
   2e6c6:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
   2e6ca:	4696      	mov	lr, r2
   2e6cc:	2300      	movs	r3, #0
   2e6ce:	42bb      	cmp	r3, r7
   2e6d0:	dd0f      	ble.n	2e6f2 <__kernel_rem_pio2f+0x6a>
   2e6d2:	af42      	add	r7, sp, #264	; 0x108
   2e6d4:	2200      	movs	r2, #0
   2e6d6:	454a      	cmp	r2, r9
   2e6d8:	dc27      	bgt.n	2e72a <__kernel_rem_pio2f+0xa2>
   2e6da:	f10d 0c68 	add.w	ip, sp, #104	; 0x68
   2e6de:	eb0b 0302 	add.w	r3, fp, r2
   2e6e2:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
   2e6e6:	9d02      	ldr	r5, [sp, #8]
   2e6e8:	eddf 7aad 	vldr	s15, [pc, #692]	; 2e9a0 <__kernel_rem_pio2f+0x318>
   2e6ec:	f04f 0c00 	mov.w	ip, #0
   2e6f0:	e015      	b.n	2e71e <__kernel_rem_pio2f+0x96>
   2e6f2:	42dd      	cmn	r5, r3
   2e6f4:	bf5d      	ittte	pl
   2e6f6:	f85c 2023 	ldrpl.w	r2, [ip, r3, lsl #2]
   2e6fa:	ee07 2a90 	vmovpl	s15, r2
   2e6fe:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
   2e702:	eef0 7a47 	vmovmi.f32	s15, s14
   2e706:	ecee 7a01 	vstmia	lr!, {s15}
   2e70a:	3301      	adds	r3, #1
   2e70c:	e7df      	b.n	2e6ce <__kernel_rem_pio2f+0x46>
   2e70e:	ecf5 6a01 	vldmia	r5!, {s13}
   2e712:	ed33 7a01 	vldmdb	r3!, {s14}
   2e716:	eee6 7a87 	vfma.f32	s15, s13, s14
   2e71a:	f10c 0c01 	add.w	ip, ip, #1
   2e71e:	45d4      	cmp	ip, sl
   2e720:	ddf5      	ble.n	2e70e <__kernel_rem_pio2f+0x86>
   2e722:	ece7 7a01 	vstmia	r7!, {s15}
   2e726:	3201      	adds	r2, #1
   2e728:	e7d5      	b.n	2e6d6 <__kernel_rem_pio2f+0x4e>
   2e72a:	ab06      	add	r3, sp, #24
   2e72c:	eb03 0389 	add.w	r3, r3, r9, lsl #2
   2e730:	9304      	str	r3, [sp, #16]
   2e732:	eddf 8a9a 	vldr	s17, [pc, #616]	; 2e99c <__kernel_rem_pio2f+0x314>
   2e736:	ed9f 9a98 	vldr	s18, [pc, #608]	; 2e998 <__kernel_rem_pio2f+0x310>
   2e73a:	eb00 0381 	add.w	r3, r0, r1, lsl #2
   2e73e:	9303      	str	r3, [sp, #12]
   2e740:	464d      	mov	r5, r9
   2e742:	ab56      	add	r3, sp, #344	; 0x158
   2e744:	f105 4780 	add.w	r7, r5, #1073741824	; 0x40000000
   2e748:	eb03 0385 	add.w	r3, r3, r5, lsl #2
   2e74c:	3f01      	subs	r7, #1
   2e74e:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
   2e752:	00bf      	lsls	r7, r7, #2
   2e754:	ab56      	add	r3, sp, #344	; 0x158
   2e756:	19da      	adds	r2, r3, r7
   2e758:	3a4c      	subs	r2, #76	; 0x4c
   2e75a:	2300      	movs	r3, #0
   2e75c:	1ae9      	subs	r1, r5, r3
   2e75e:	2900      	cmp	r1, #0
   2e760:	dc4c      	bgt.n	2e7fc <__kernel_rem_pio2f+0x174>
   2e762:	4620      	mov	r0, r4
   2e764:	f000 fe24 	bl	2f3b0 <scalbnf>
   2e768:	eeb0 8a40 	vmov.f32	s16, s0
   2e76c:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
   2e770:	ee28 0a00 	vmul.f32	s0, s16, s0
   2e774:	f000 fdda 	bl	2f32c <floorf>
   2e778:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
   2e77c:	eea0 8a67 	vfms.f32	s16, s0, s15
   2e780:	2c00      	cmp	r4, #0
   2e782:	eefd 7ac8 	vcvt.s32.f32	s15, s16
   2e786:	edcd 7a01 	vstr	s15, [sp, #4]
   2e78a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2e78e:	ee38 8a67 	vsub.f32	s16, s16, s15
   2e792:	dd48      	ble.n	2e826 <__kernel_rem_pio2f+0x19e>
   2e794:	1e69      	subs	r1, r5, #1
   2e796:	ab06      	add	r3, sp, #24
   2e798:	f1c4 0008 	rsb	r0, r4, #8
   2e79c:	f853 c021 	ldr.w	ip, [r3, r1, lsl #2]
   2e7a0:	9a01      	ldr	r2, [sp, #4]
   2e7a2:	fa4c f300 	asr.w	r3, ip, r0
   2e7a6:	441a      	add	r2, r3
   2e7a8:	4083      	lsls	r3, r0
   2e7aa:	9201      	str	r2, [sp, #4]
   2e7ac:	ebac 0203 	sub.w	r2, ip, r3
   2e7b0:	ab06      	add	r3, sp, #24
   2e7b2:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
   2e7b6:	f1c4 0307 	rsb	r3, r4, #7
   2e7ba:	fa42 f803 	asr.w	r8, r2, r3
   2e7be:	f1b8 0f00 	cmp.w	r8, #0
   2e7c2:	dd41      	ble.n	2e848 <__kernel_rem_pio2f+0x1c0>
   2e7c4:	9b01      	ldr	r3, [sp, #4]
   2e7c6:	2000      	movs	r0, #0
   2e7c8:	3301      	adds	r3, #1
   2e7ca:	9301      	str	r3, [sp, #4]
   2e7cc:	4601      	mov	r1, r0
   2e7ce:	4285      	cmp	r5, r0
   2e7d0:	dc6d      	bgt.n	2e8ae <__kernel_rem_pio2f+0x226>
   2e7d2:	2c00      	cmp	r4, #0
   2e7d4:	dd04      	ble.n	2e7e0 <__kernel_rem_pio2f+0x158>
   2e7d6:	2c01      	cmp	r4, #1
   2e7d8:	d07e      	beq.n	2e8d8 <__kernel_rem_pio2f+0x250>
   2e7da:	2c02      	cmp	r4, #2
   2e7dc:	f000 8086 	beq.w	2e8ec <__kernel_rem_pio2f+0x264>
   2e7e0:	f1b8 0f02 	cmp.w	r8, #2
   2e7e4:	d130      	bne.n	2e848 <__kernel_rem_pio2f+0x1c0>
   2e7e6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2e7ea:	ee30 8a48 	vsub.f32	s16, s0, s16
   2e7ee:	b359      	cbz	r1, 2e848 <__kernel_rem_pio2f+0x1c0>
   2e7f0:	4620      	mov	r0, r4
   2e7f2:	f000 fddd 	bl	2f3b0 <scalbnf>
   2e7f6:	ee38 8a40 	vsub.f32	s16, s16, s0
   2e7fa:	e025      	b.n	2e848 <__kernel_rem_pio2f+0x1c0>
   2e7fc:	ee60 7a28 	vmul.f32	s15, s0, s17
   2e800:	a806      	add	r0, sp, #24
   2e802:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2e806:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2e80a:	eea7 0ac9 	vfms.f32	s0, s15, s18
   2e80e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   2e812:	ee10 1a10 	vmov	r1, s0
   2e816:	ed32 0a01 	vldmdb	r2!, {s0}
   2e81a:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
   2e81e:	ee37 0a80 	vadd.f32	s0, s15, s0
   2e822:	3301      	adds	r3, #1
   2e824:	e79a      	b.n	2e75c <__kernel_rem_pio2f+0xd4>
   2e826:	d106      	bne.n	2e836 <__kernel_rem_pio2f+0x1ae>
   2e828:	1e6b      	subs	r3, r5, #1
   2e82a:	aa06      	add	r2, sp, #24
   2e82c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   2e830:	ea4f 2822 	mov.w	r8, r2, asr #8
   2e834:	e7c3      	b.n	2e7be <__kernel_rem_pio2f+0x136>
   2e836:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2e83a:	eeb4 8ae7 	vcmpe.f32	s16, s15
   2e83e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e842:	da31      	bge.n	2e8a8 <__kernel_rem_pio2f+0x220>
   2e844:	f04f 0800 	mov.w	r8, #0
   2e848:	eeb5 8a40 	vcmp.f32	s16, #0.0
   2e84c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e850:	f040 80a8 	bne.w	2e9a4 <__kernel_rem_pio2f+0x31c>
   2e854:	1e6b      	subs	r3, r5, #1
   2e856:	4618      	mov	r0, r3
   2e858:	2200      	movs	r2, #0
   2e85a:	4548      	cmp	r0, r9
   2e85c:	da4d      	bge.n	2e8fa <__kernel_rem_pio2f+0x272>
   2e85e:	2a00      	cmp	r2, #0
   2e860:	f000 8087 	beq.w	2e972 <__kernel_rem_pio2f+0x2ea>
   2e864:	aa06      	add	r2, sp, #24
   2e866:	3c08      	subs	r4, #8
   2e868:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
   2e86c:	2900      	cmp	r1, #0
   2e86e:	f000 808d 	beq.w	2e98c <__kernel_rem_pio2f+0x304>
   2e872:	4620      	mov	r0, r4
   2e874:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2e878:	9302      	str	r3, [sp, #8]
   2e87a:	f000 fd99 	bl	2f3b0 <scalbnf>
   2e87e:	9b02      	ldr	r3, [sp, #8]
   2e880:	ed9f 7a46 	vldr	s14, [pc, #280]	; 2e99c <__kernel_rem_pio2f+0x314>
   2e884:	0099      	lsls	r1, r3, #2
   2e886:	aa42      	add	r2, sp, #264	; 0x108
   2e888:	1850      	adds	r0, r2, r1
   2e88a:	1d05      	adds	r5, r0, #4
   2e88c:	461c      	mov	r4, r3
   2e88e:	2c00      	cmp	r4, #0
   2e890:	f280 80b8 	bge.w	2ea04 <__kernel_rem_pio2f+0x37c>
   2e894:	2500      	movs	r5, #0
   2e896:	1b5c      	subs	r4, r3, r5
   2e898:	2c00      	cmp	r4, #0
   2e89a:	f2c0 80d8 	blt.w	2ea4e <__kernel_rem_pio2f+0x3c6>
   2e89e:	4f3d      	ldr	r7, [pc, #244]	; (2e994 <__kernel_rem_pio2f+0x30c>)
   2e8a0:	eddf 7a3f 	vldr	s15, [pc, #252]	; 2e9a0 <__kernel_rem_pio2f+0x318>
   2e8a4:	2400      	movs	r4, #0
   2e8a6:	e0c6      	b.n	2ea36 <__kernel_rem_pio2f+0x3ae>
   2e8a8:	f04f 0802 	mov.w	r8, #2
   2e8ac:	e78a      	b.n	2e7c4 <__kernel_rem_pio2f+0x13c>
   2e8ae:	ab06      	add	r3, sp, #24
   2e8b0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2e8b4:	b949      	cbnz	r1, 2e8ca <__kernel_rem_pio2f+0x242>
   2e8b6:	b12b      	cbz	r3, 2e8c4 <__kernel_rem_pio2f+0x23c>
   2e8b8:	aa06      	add	r2, sp, #24
   2e8ba:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
   2e8be:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   2e8c2:	2301      	movs	r3, #1
   2e8c4:	3001      	adds	r0, #1
   2e8c6:	4619      	mov	r1, r3
   2e8c8:	e781      	b.n	2e7ce <__kernel_rem_pio2f+0x146>
   2e8ca:	aa06      	add	r2, sp, #24
   2e8cc:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
   2e8d0:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   2e8d4:	460b      	mov	r3, r1
   2e8d6:	e7f5      	b.n	2e8c4 <__kernel_rem_pio2f+0x23c>
   2e8d8:	1e68      	subs	r0, r5, #1
   2e8da:	ab06      	add	r3, sp, #24
   2e8dc:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2e8e0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   2e8e4:	aa06      	add	r2, sp, #24
   2e8e6:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   2e8ea:	e779      	b.n	2e7e0 <__kernel_rem_pio2f+0x158>
   2e8ec:	1e68      	subs	r0, r5, #1
   2e8ee:	ab06      	add	r3, sp, #24
   2e8f0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2e8f4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   2e8f8:	e7f4      	b.n	2e8e4 <__kernel_rem_pio2f+0x25c>
   2e8fa:	a906      	add	r1, sp, #24
   2e8fc:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   2e900:	3801      	subs	r0, #1
   2e902:	430a      	orrs	r2, r1
   2e904:	e7a9      	b.n	2e85a <__kernel_rem_pio2f+0x1d2>
   2e906:	f10c 0c01 	add.w	ip, ip, #1
   2e90a:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   2e90e:	2a00      	cmp	r2, #0
   2e910:	d0f9      	beq.n	2e906 <__kernel_rem_pio2f+0x27e>
   2e912:	eb0b 0305 	add.w	r3, fp, r5
   2e916:	aa1a      	add	r2, sp, #104	; 0x68
   2e918:	009b      	lsls	r3, r3, #2
   2e91a:	1898      	adds	r0, r3, r2
   2e91c:	3004      	adds	r0, #4
   2e91e:	1c69      	adds	r1, r5, #1
   2e920:	3704      	adds	r7, #4
   2e922:	2200      	movs	r2, #0
   2e924:	4465      	add	r5, ip
   2e926:	9005      	str	r0, [sp, #20]
   2e928:	428d      	cmp	r5, r1
   2e92a:	f6ff af0a 	blt.w	2e742 <__kernel_rem_pio2f+0xba>
   2e92e:	a81a      	add	r0, sp, #104	; 0x68
   2e930:	eb02 0c03 	add.w	ip, r2, r3
   2e934:	4484      	add	ip, r0
   2e936:	9803      	ldr	r0, [sp, #12]
   2e938:	f8dd e008 	ldr.w	lr, [sp, #8]
   2e93c:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
   2e940:	9001      	str	r0, [sp, #4]
   2e942:	ee07 0a90 	vmov	s15, r0
   2e946:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2e94a:	9805      	ldr	r0, [sp, #20]
   2e94c:	edcc 7a00 	vstr	s15, [ip]
   2e950:	eddf 7a13 	vldr	s15, [pc, #76]	; 2e9a0 <__kernel_rem_pio2f+0x318>
   2e954:	eb00 0802 	add.w	r8, r0, r2
   2e958:	f04f 0c00 	mov.w	ip, #0
   2e95c:	45d4      	cmp	ip, sl
   2e95e:	dd0c      	ble.n	2e97a <__kernel_rem_pio2f+0x2f2>
   2e960:	eb02 0c07 	add.w	ip, r2, r7
   2e964:	a842      	add	r0, sp, #264	; 0x108
   2e966:	4484      	add	ip, r0
   2e968:	edcc 7a01 	vstr	s15, [ip, #4]
   2e96c:	3101      	adds	r1, #1
   2e96e:	3204      	adds	r2, #4
   2e970:	e7da      	b.n	2e928 <__kernel_rem_pio2f+0x2a0>
   2e972:	9b04      	ldr	r3, [sp, #16]
   2e974:	f04f 0c01 	mov.w	ip, #1
   2e978:	e7c7      	b.n	2e90a <__kernel_rem_pio2f+0x282>
   2e97a:	ecfe 6a01 	vldmia	lr!, {s13}
   2e97e:	ed38 7a01 	vldmdb	r8!, {s14}
   2e982:	f10c 0c01 	add.w	ip, ip, #1
   2e986:	eee6 7a87 	vfma.f32	s15, s13, s14
   2e98a:	e7e7      	b.n	2e95c <__kernel_rem_pio2f+0x2d4>
   2e98c:	3b01      	subs	r3, #1
   2e98e:	e769      	b.n	2e864 <__kernel_rem_pio2f+0x1dc>
   2e990:	0005252c 	.word	0x0005252c
   2e994:	00052500 	.word	0x00052500
   2e998:	43800000 	.word	0x43800000
   2e99c:	3b800000 	.word	0x3b800000
   2e9a0:	00000000 	.word	0x00000000
   2e9a4:	4260      	negs	r0, r4
   2e9a6:	eeb0 0a48 	vmov.f32	s0, s16
   2e9aa:	f000 fd01 	bl	2f3b0 <scalbnf>
   2e9ae:	ed1f 7a06 	vldr	s14, [pc, #-24]	; 2e998 <__kernel_rem_pio2f+0x310>
   2e9b2:	eeb4 0ac7 	vcmpe.f32	s0, s14
   2e9b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e9ba:	db1a      	blt.n	2e9f2 <__kernel_rem_pio2f+0x36a>
   2e9bc:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 2e99c <__kernel_rem_pio2f+0x314>
   2e9c0:	ee60 7a27 	vmul.f32	s15, s0, s15
   2e9c4:	aa06      	add	r2, sp, #24
   2e9c6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2e9ca:	a906      	add	r1, sp, #24
   2e9cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2e9d0:	3408      	adds	r4, #8
   2e9d2:	eea7 0ac7 	vfms.f32	s0, s15, s14
   2e9d6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2e9da:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   2e9de:	ee10 3a10 	vmov	r3, s0
   2e9e2:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
   2e9e6:	1c6b      	adds	r3, r5, #1
   2e9e8:	ee17 2a90 	vmov	r2, s15
   2e9ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   2e9f0:	e73f      	b.n	2e872 <__kernel_rem_pio2f+0x1ea>
   2e9f2:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   2e9f6:	aa06      	add	r2, sp, #24
   2e9f8:	ee10 3a10 	vmov	r3, s0
   2e9fc:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
   2ea00:	462b      	mov	r3, r5
   2ea02:	e736      	b.n	2e872 <__kernel_rem_pio2f+0x1ea>
   2ea04:	aa06      	add	r2, sp, #24
   2ea06:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
   2ea0a:	9202      	str	r2, [sp, #8]
   2ea0c:	ee07 2a90 	vmov	s15, r2
   2ea10:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2ea14:	3c01      	subs	r4, #1
   2ea16:	ee67 7a80 	vmul.f32	s15, s15, s0
   2ea1a:	ee20 0a07 	vmul.f32	s0, s0, s14
   2ea1e:	ed65 7a01 	vstmdb	r5!, {s15}
   2ea22:	e734      	b.n	2e88e <__kernel_rem_pio2f+0x206>
   2ea24:	eb00 0c84 	add.w	ip, r0, r4, lsl #2
   2ea28:	ecf7 6a01 	vldmia	r7!, {s13}
   2ea2c:	ed9c 7a00 	vldr	s14, [ip]
   2ea30:	eee6 7a87 	vfma.f32	s15, s13, s14
   2ea34:	3401      	adds	r4, #1
   2ea36:	454c      	cmp	r4, r9
   2ea38:	dc01      	bgt.n	2ea3e <__kernel_rem_pio2f+0x3b6>
   2ea3a:	42a5      	cmp	r5, r4
   2ea3c:	daf2      	bge.n	2ea24 <__kernel_rem_pio2f+0x39c>
   2ea3e:	aa56      	add	r2, sp, #344	; 0x158
   2ea40:	eb02 0485 	add.w	r4, r2, r5, lsl #2
   2ea44:	ed44 7a28 	vstr	s15, [r4, #-160]	; 0xffffff60
   2ea48:	3501      	adds	r5, #1
   2ea4a:	3804      	subs	r0, #4
   2ea4c:	e723      	b.n	2e896 <__kernel_rem_pio2f+0x20e>
   2ea4e:	9a64      	ldr	r2, [sp, #400]	; 0x190
   2ea50:	2a03      	cmp	r2, #3
   2ea52:	d84d      	bhi.n	2eaf0 <__kernel_rem_pio2f+0x468>
   2ea54:	e8df f002 	tbb	[pc, r2]
   2ea58:	021f1f3e 	.word	0x021f1f3e
   2ea5c:	aa56      	add	r2, sp, #344	; 0x158
   2ea5e:	4411      	add	r1, r2
   2ea60:	399c      	subs	r1, #156	; 0x9c
   2ea62:	4608      	mov	r0, r1
   2ea64:	461c      	mov	r4, r3
   2ea66:	2c00      	cmp	r4, #0
   2ea68:	dc5f      	bgt.n	2eb2a <__kernel_rem_pio2f+0x4a2>
   2ea6a:	4608      	mov	r0, r1
   2ea6c:	461c      	mov	r4, r3
   2ea6e:	2c01      	cmp	r4, #1
   2ea70:	dc6b      	bgt.n	2eb4a <__kernel_rem_pio2f+0x4c2>
   2ea72:	ed5f 7a35 	vldr	s15, [pc, #-212]	; 2e9a0 <__kernel_rem_pio2f+0x318>
   2ea76:	2b01      	cmp	r3, #1
   2ea78:	dc77      	bgt.n	2eb6a <__kernel_rem_pio2f+0x4e2>
   2ea7a:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
   2ea7e:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
   2ea82:	f1b8 0f00 	cmp.w	r8, #0
   2ea86:	d176      	bne.n	2eb76 <__kernel_rem_pio2f+0x4ee>
   2ea88:	edc6 6a00 	vstr	s13, [r6]
   2ea8c:	ed86 7a01 	vstr	s14, [r6, #4]
   2ea90:	edc6 7a02 	vstr	s15, [r6, #8]
   2ea94:	e02c      	b.n	2eaf0 <__kernel_rem_pio2f+0x468>
   2ea96:	aa56      	add	r2, sp, #344	; 0x158
   2ea98:	4411      	add	r1, r2
   2ea9a:	ed1f 7a3f 	vldr	s14, [pc, #-252]	; 2e9a0 <__kernel_rem_pio2f+0x318>
   2ea9e:	399c      	subs	r1, #156	; 0x9c
   2eaa0:	4618      	mov	r0, r3
   2eaa2:	2800      	cmp	r0, #0
   2eaa4:	da32      	bge.n	2eb0c <__kernel_rem_pio2f+0x484>
   2eaa6:	f1b8 0f00 	cmp.w	r8, #0
   2eaaa:	d035      	beq.n	2eb18 <__kernel_rem_pio2f+0x490>
   2eaac:	eef1 7a47 	vneg.f32	s15, s14
   2eab0:	edc6 7a00 	vstr	s15, [r6]
   2eab4:	eddd 7a2e 	vldr	s15, [sp, #184]	; 0xb8
   2eab8:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2eabc:	a82f      	add	r0, sp, #188	; 0xbc
   2eabe:	2101      	movs	r1, #1
   2eac0:	428b      	cmp	r3, r1
   2eac2:	da2c      	bge.n	2eb1e <__kernel_rem_pio2f+0x496>
   2eac4:	f1b8 0f00 	cmp.w	r8, #0
   2eac8:	d001      	beq.n	2eace <__kernel_rem_pio2f+0x446>
   2eaca:	eef1 7a67 	vneg.f32	s15, s15
   2eace:	edc6 7a01 	vstr	s15, [r6, #4]
   2ead2:	e00d      	b.n	2eaf0 <__kernel_rem_pio2f+0x468>
   2ead4:	aa56      	add	r2, sp, #344	; 0x158
   2ead6:	4411      	add	r1, r2
   2ead8:	ed5f 7a4f 	vldr	s15, [pc, #-316]	; 2e9a0 <__kernel_rem_pio2f+0x318>
   2eadc:	399c      	subs	r1, #156	; 0x9c
   2eade:	2b00      	cmp	r3, #0
   2eae0:	da0e      	bge.n	2eb00 <__kernel_rem_pio2f+0x478>
   2eae2:	f1b8 0f00 	cmp.w	r8, #0
   2eae6:	d001      	beq.n	2eaec <__kernel_rem_pio2f+0x464>
   2eae8:	eef1 7a67 	vneg.f32	s15, s15
   2eaec:	edc6 7a00 	vstr	s15, [r6]
   2eaf0:	9b01      	ldr	r3, [sp, #4]
   2eaf2:	f003 0007 	and.w	r0, r3, #7
   2eaf6:	b057      	add	sp, #348	; 0x15c
   2eaf8:	ecbd 8b04 	vpop	{d8-d9}
   2eafc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2eb00:	ed31 7a01 	vldmdb	r1!, {s14}
   2eb04:	3b01      	subs	r3, #1
   2eb06:	ee77 7a87 	vadd.f32	s15, s15, s14
   2eb0a:	e7e8      	b.n	2eade <__kernel_rem_pio2f+0x456>
   2eb0c:	ed71 7a01 	vldmdb	r1!, {s15}
   2eb10:	3801      	subs	r0, #1
   2eb12:	ee37 7a27 	vadd.f32	s14, s14, s15
   2eb16:	e7c4      	b.n	2eaa2 <__kernel_rem_pio2f+0x41a>
   2eb18:	eef0 7a47 	vmov.f32	s15, s14
   2eb1c:	e7c8      	b.n	2eab0 <__kernel_rem_pio2f+0x428>
   2eb1e:	ecb0 7a01 	vldmia	r0!, {s14}
   2eb22:	3101      	adds	r1, #1
   2eb24:	ee77 7a87 	vadd.f32	s15, s15, s14
   2eb28:	e7ca      	b.n	2eac0 <__kernel_rem_pio2f+0x438>
   2eb2a:	ed50 7a02 	vldr	s15, [r0, #-8]
   2eb2e:	ed70 6a01 	vldmdb	r0!, {s13}
   2eb32:	ee37 7aa6 	vadd.f32	s14, s15, s13
   2eb36:	3c01      	subs	r4, #1
   2eb38:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2eb3c:	ed00 7a01 	vstr	s14, [r0, #-4]
   2eb40:	ee77 7aa6 	vadd.f32	s15, s15, s13
   2eb44:	edc0 7a00 	vstr	s15, [r0]
   2eb48:	e78d      	b.n	2ea66 <__kernel_rem_pio2f+0x3de>
   2eb4a:	ed50 7a02 	vldr	s15, [r0, #-8]
   2eb4e:	ed70 6a01 	vldmdb	r0!, {s13}
   2eb52:	ee37 7aa6 	vadd.f32	s14, s15, s13
   2eb56:	3c01      	subs	r4, #1
   2eb58:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2eb5c:	ed00 7a01 	vstr	s14, [r0, #-4]
   2eb60:	ee77 7aa6 	vadd.f32	s15, s15, s13
   2eb64:	edc0 7a00 	vstr	s15, [r0]
   2eb68:	e781      	b.n	2ea6e <__kernel_rem_pio2f+0x3e6>
   2eb6a:	ed31 7a01 	vldmdb	r1!, {s14}
   2eb6e:	3b01      	subs	r3, #1
   2eb70:	ee77 7a87 	vadd.f32	s15, s15, s14
   2eb74:	e77f      	b.n	2ea76 <__kernel_rem_pio2f+0x3ee>
   2eb76:	eef1 6a66 	vneg.f32	s13, s13
   2eb7a:	eeb1 7a47 	vneg.f32	s14, s14
   2eb7e:	edc6 6a00 	vstr	s13, [r6]
   2eb82:	ed86 7a01 	vstr	s14, [r6, #4]
   2eb86:	eef1 7a67 	vneg.f32	s15, s15
   2eb8a:	e781      	b.n	2ea90 <__kernel_rem_pio2f+0x408>

0002eb8c <__kernel_sinf>:
   2eb8c:	ee10 3a10 	vmov	r3, s0
   2eb90:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2eb94:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   2eb98:	da04      	bge.n	2eba4 <__kernel_sinf+0x18>
   2eb9a:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   2eb9e:	ee17 3a90 	vmov	r3, s15
   2eba2:	b35b      	cbz	r3, 2ebfc <__kernel_sinf+0x70>
   2eba4:	ee20 7a00 	vmul.f32	s14, s0, s0
   2eba8:	eddf 7a15 	vldr	s15, [pc, #84]	; 2ec00 <__kernel_sinf+0x74>
   2ebac:	ed9f 6a15 	vldr	s12, [pc, #84]	; 2ec04 <__kernel_sinf+0x78>
   2ebb0:	eea7 6a27 	vfma.f32	s12, s14, s15
   2ebb4:	eddf 7a14 	vldr	s15, [pc, #80]	; 2ec08 <__kernel_sinf+0x7c>
   2ebb8:	eee6 7a07 	vfma.f32	s15, s12, s14
   2ebbc:	ed9f 6a13 	vldr	s12, [pc, #76]	; 2ec0c <__kernel_sinf+0x80>
   2ebc0:	eea7 6a87 	vfma.f32	s12, s15, s14
   2ebc4:	eddf 7a12 	vldr	s15, [pc, #72]	; 2ec10 <__kernel_sinf+0x84>
   2ebc8:	ee60 6a07 	vmul.f32	s13, s0, s14
   2ebcc:	eee6 7a07 	vfma.f32	s15, s12, s14
   2ebd0:	b930      	cbnz	r0, 2ebe0 <__kernel_sinf+0x54>
   2ebd2:	ed9f 6a10 	vldr	s12, [pc, #64]	; 2ec14 <__kernel_sinf+0x88>
   2ebd6:	eea7 6a27 	vfma.f32	s12, s14, s15
   2ebda:	eea6 0a26 	vfma.f32	s0, s12, s13
   2ebde:	4770      	bx	lr
   2ebe0:	ee67 7ae6 	vnmul.f32	s15, s15, s13
   2ebe4:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   2ebe8:	eee0 7a86 	vfma.f32	s15, s1, s12
   2ebec:	eed7 0a87 	vfnms.f32	s1, s15, s14
   2ebf0:	eddf 7a09 	vldr	s15, [pc, #36]	; 2ec18 <__kernel_sinf+0x8c>
   2ebf4:	eee6 0aa7 	vfma.f32	s1, s13, s15
   2ebf8:	ee30 0a60 	vsub.f32	s0, s0, s1
   2ebfc:	4770      	bx	lr
   2ebfe:	bf00      	nop
   2ec00:	2f2ec9d3 	.word	0x2f2ec9d3
   2ec04:	b2d72f34 	.word	0xb2d72f34
   2ec08:	3638ef1b 	.word	0x3638ef1b
   2ec0c:	b9500d01 	.word	0xb9500d01
   2ec10:	3c088889 	.word	0x3c088889
   2ec14:	be2aaaab 	.word	0xbe2aaaab
   2ec18:	3e2aaaab 	.word	0x3e2aaaab

0002ec1c <__kernel_tanf>:
   2ec1c:	b508      	push	{r3, lr}
   2ec1e:	ee10 3a10 	vmov	r3, s0
   2ec22:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
   2ec26:	f1b2 5f46 	cmp.w	r2, #830472192	; 0x31800000
   2ec2a:	eef0 7a40 	vmov.f32	s15, s0
   2ec2e:	da17      	bge.n	2ec60 <__kernel_tanf+0x44>
   2ec30:	eebd 7ac0 	vcvt.s32.f32	s14, s0
   2ec34:	ee17 1a10 	vmov	r1, s14
   2ec38:	bb41      	cbnz	r1, 2ec8c <__kernel_tanf+0x70>
   2ec3a:	1c43      	adds	r3, r0, #1
   2ec3c:	4313      	orrs	r3, r2
   2ec3e:	d108      	bne.n	2ec52 <__kernel_tanf+0x36>
   2ec40:	f7fe f836 	bl	2ccb0 <fabsf>
   2ec44:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2ec48:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2ec4c:	eeb0 0a67 	vmov.f32	s0, s15
   2ec50:	bd08      	pop	{r3, pc}
   2ec52:	2801      	cmp	r0, #1
   2ec54:	d0fa      	beq.n	2ec4c <__kernel_tanf+0x30>
   2ec56:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   2ec5a:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2ec5e:	e7f5      	b.n	2ec4c <__kernel_tanf+0x30>
   2ec60:	494e      	ldr	r1, [pc, #312]	; (2ed9c <__kernel_tanf+0x180>)
   2ec62:	428a      	cmp	r2, r1
   2ec64:	dd12      	ble.n	2ec8c <__kernel_tanf+0x70>
   2ec66:	2b00      	cmp	r3, #0
   2ec68:	ed9f 7a4d 	vldr	s14, [pc, #308]	; 2eda0 <__kernel_tanf+0x184>
   2ec6c:	bfb8      	it	lt
   2ec6e:	eef1 7a40 	vneglt.f32	s15, s0
   2ec72:	ee77 7a67 	vsub.f32	s15, s14, s15
   2ec76:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 2eda4 <__kernel_tanf+0x188>
   2ec7a:	bfb8      	it	lt
   2ec7c:	eef1 0a60 	vneglt.f32	s1, s1
   2ec80:	ee77 0a60 	vsub.f32	s1, s14, s1
   2ec84:	ee70 7aa7 	vadd.f32	s15, s1, s15
   2ec88:	eddf 0a47 	vldr	s1, [pc, #284]	; 2eda8 <__kernel_tanf+0x18c>
   2ec8c:	ed9f 6a47 	vldr	s12, [pc, #284]	; 2edac <__kernel_tanf+0x190>
   2ec90:	eddf 5a47 	vldr	s11, [pc, #284]	; 2edb0 <__kernel_tanf+0x194>
   2ec94:	ed9f 5a47 	vldr	s10, [pc, #284]	; 2edb4 <__kernel_tanf+0x198>
   2ec98:	4940      	ldr	r1, [pc, #256]	; (2ed9c <__kernel_tanf+0x180>)
   2ec9a:	ee67 6aa7 	vmul.f32	s13, s15, s15
   2ec9e:	428a      	cmp	r2, r1
   2eca0:	ee26 7aa6 	vmul.f32	s14, s13, s13
   2eca4:	ee67 4aa6 	vmul.f32	s9, s15, s13
   2eca8:	eee7 5a06 	vfma.f32	s11, s14, s12
   2ecac:	ed9f 6a42 	vldr	s12, [pc, #264]	; 2edb8 <__kernel_tanf+0x19c>
   2ecb0:	eea5 6a87 	vfma.f32	s12, s11, s14
   2ecb4:	eddf 5a41 	vldr	s11, [pc, #260]	; 2edbc <__kernel_tanf+0x1a0>
   2ecb8:	eee6 5a07 	vfma.f32	s11, s12, s14
   2ecbc:	ed9f 6a40 	vldr	s12, [pc, #256]	; 2edc0 <__kernel_tanf+0x1a4>
   2ecc0:	eea5 6a87 	vfma.f32	s12, s11, s14
   2ecc4:	eddf 5a3f 	vldr	s11, [pc, #252]	; 2edc4 <__kernel_tanf+0x1a8>
   2ecc8:	eee6 5a07 	vfma.f32	s11, s12, s14
   2eccc:	ed9f 6a3e 	vldr	s12, [pc, #248]	; 2edc8 <__kernel_tanf+0x1ac>
   2ecd0:	eea7 6a05 	vfma.f32	s12, s14, s10
   2ecd4:	ed9f 5a3d 	vldr	s10, [pc, #244]	; 2edcc <__kernel_tanf+0x1b0>
   2ecd8:	eea6 5a07 	vfma.f32	s10, s12, s14
   2ecdc:	ed9f 6a3c 	vldr	s12, [pc, #240]	; 2edd0 <__kernel_tanf+0x1b4>
   2ece0:	eea5 6a07 	vfma.f32	s12, s10, s14
   2ece4:	ed9f 5a3b 	vldr	s10, [pc, #236]	; 2edd4 <__kernel_tanf+0x1b8>
   2ece8:	eea6 5a07 	vfma.f32	s10, s12, s14
   2ecec:	ed9f 6a3a 	vldr	s12, [pc, #232]	; 2edd8 <__kernel_tanf+0x1bc>
   2ecf0:	eea5 6a07 	vfma.f32	s12, s10, s14
   2ecf4:	eeb0 7a46 	vmov.f32	s14, s12
   2ecf8:	eea5 7aa6 	vfma.f32	s14, s11, s13
   2ecfc:	eeb0 6a60 	vmov.f32	s12, s1
   2ed00:	eea7 6a24 	vfma.f32	s12, s14, s9
   2ed04:	ed9f 7a35 	vldr	s14, [pc, #212]	; 2eddc <__kernel_tanf+0x1c0>
   2ed08:	eee6 0a26 	vfma.f32	s1, s12, s13
   2ed0c:	eee4 0a87 	vfma.f32	s1, s9, s14
   2ed10:	ee77 6aa0 	vadd.f32	s13, s15, s1
   2ed14:	dd1d      	ble.n	2ed52 <__kernel_tanf+0x136>
   2ed16:	ee07 0a10 	vmov	s14, r0
   2ed1a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2ed1e:	ee66 5aa6 	vmul.f32	s11, s13, s13
   2ed22:	ee76 6a87 	vadd.f32	s13, s13, s14
   2ed26:	179b      	asrs	r3, r3, #30
   2ed28:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   2ed2c:	f003 0302 	and.w	r3, r3, #2
   2ed30:	f1c3 0301 	rsb	r3, r3, #1
   2ed34:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
   2ed38:	ee76 0a60 	vsub.f32	s1, s12, s1
   2ed3c:	ee77 7ae0 	vsub.f32	s15, s15, s1
   2ed40:	eea7 7ae6 	vfms.f32	s14, s15, s13
   2ed44:	ee07 3a90 	vmov	s15, r3
   2ed48:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2ed4c:	ee67 7a27 	vmul.f32	s15, s14, s15
   2ed50:	e77c      	b.n	2ec4c <__kernel_tanf+0x30>
   2ed52:	2801      	cmp	r0, #1
   2ed54:	d01f      	beq.n	2ed96 <__kernel_tanf+0x17a>
   2ed56:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   2ed5a:	eec7 5a26 	vdiv.f32	s11, s14, s13
   2ed5e:	4b20      	ldr	r3, [pc, #128]	; (2ede0 <__kernel_tanf+0x1c4>)
   2ed60:	ee16 2a90 	vmov	r2, s13
   2ed64:	401a      	ands	r2, r3
   2ed66:	ee06 2a10 	vmov	s12, r2
   2ed6a:	ee15 2a90 	vmov	r2, s11
   2ed6e:	4013      	ands	r3, r2
   2ed70:	ee07 3a10 	vmov	s14, r3
   2ed74:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2ed78:	eee6 6a07 	vfma.f32	s13, s12, s14
   2ed7c:	ee76 7a67 	vsub.f32	s15, s12, s15
   2ed80:	ee70 0ae7 	vsub.f32	s1, s1, s15
   2ed84:	eef0 7a66 	vmov.f32	s15, s13
   2ed88:	eee7 7a20 	vfma.f32	s15, s14, s1
   2ed8c:	eea7 7aa5 	vfma.f32	s14, s15, s11
   2ed90:	eef0 7a47 	vmov.f32	s15, s14
   2ed94:	e75a      	b.n	2ec4c <__kernel_tanf+0x30>
   2ed96:	eef0 7a66 	vmov.f32	s15, s13
   2ed9a:	e757      	b.n	2ec4c <__kernel_tanf+0x30>
   2ed9c:	3f2ca13f 	.word	0x3f2ca13f
   2eda0:	3f490fda 	.word	0x3f490fda
   2eda4:	33222168 	.word	0x33222168
   2eda8:	00000000 	.word	0x00000000
   2edac:	37d95384 	.word	0x37d95384
   2edb0:	3895c07a 	.word	0x3895c07a
   2edb4:	b79bae5f 	.word	0xb79bae5f
   2edb8:	398137b9 	.word	0x398137b9
   2edbc:	3abede48 	.word	0x3abede48
   2edc0:	3c11371f 	.word	0x3c11371f
   2edc4:	3d5d0dd1 	.word	0x3d5d0dd1
   2edc8:	38a3f445 	.word	0x38a3f445
   2edcc:	3a1a26c8 	.word	0x3a1a26c8
   2edd0:	3b6b6916 	.word	0x3b6b6916
   2edd4:	3cb327a4 	.word	0x3cb327a4
   2edd8:	3e088889 	.word	0x3e088889
   2eddc:	3eaaaaab 	.word	0x3eaaaaab
   2ede0:	fffff000 	.word	0xfffff000

0002ede4 <with_errnof>:
   2ede4:	b510      	push	{r4, lr}
   2ede6:	ed2d 8b02 	vpush	{d8}
   2edea:	eeb0 8a40 	vmov.f32	s16, s0
   2edee:	4604      	mov	r4, r0
   2edf0:	f7fd fd28 	bl	2c844 <__errno>
   2edf4:	eeb0 0a48 	vmov.f32	s0, s16
   2edf8:	ecbd 8b02 	vpop	{d8}
   2edfc:	6004      	str	r4, [r0, #0]
   2edfe:	bd10      	pop	{r4, pc}

0002ee00 <xflowf>:
   2ee00:	b130      	cbz	r0, 2ee10 <xflowf+0x10>
   2ee02:	eef1 7a40 	vneg.f32	s15, s0
   2ee06:	2022      	movs	r0, #34	; 0x22
   2ee08:	ee27 0a80 	vmul.f32	s0, s15, s0
   2ee0c:	f7ff bfea 	b.w	2ede4 <with_errnof>
   2ee10:	eef0 7a40 	vmov.f32	s15, s0
   2ee14:	e7f7      	b.n	2ee06 <xflowf+0x6>
	...

0002ee18 <__math_uflowf>:
   2ee18:	ed9f 0a01 	vldr	s0, [pc, #4]	; 2ee20 <__math_uflowf+0x8>
   2ee1c:	f7ff bff0 	b.w	2ee00 <xflowf>
   2ee20:	10000000 	.word	0x10000000

0002ee24 <__math_may_uflowf>:
   2ee24:	ed9f 0a01 	vldr	s0, [pc, #4]	; 2ee2c <__math_may_uflowf+0x8>
   2ee28:	f7ff bfea 	b.w	2ee00 <xflowf>
   2ee2c:	1a200000 	.word	0x1a200000

0002ee30 <__math_oflowf>:
   2ee30:	ed9f 0a01 	vldr	s0, [pc, #4]	; 2ee38 <__math_oflowf+0x8>
   2ee34:	f7ff bfe4 	b.w	2ee00 <xflowf>
   2ee38:	70000000 	.word	0x70000000

0002ee3c <__math_divzerof>:
   2ee3c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2ee40:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   2ee44:	2800      	cmp	r0, #0
   2ee46:	fe40 7a27 	vseleq.f32	s15, s0, s15
   2ee4a:	ed9f 0a03 	vldr	s0, [pc, #12]	; 2ee58 <__math_divzerof+0x1c>
   2ee4e:	2022      	movs	r0, #34	; 0x22
   2ee50:	ee87 0a80 	vdiv.f32	s0, s15, s0
   2ee54:	f7ff bfc6 	b.w	2ede4 <with_errnof>
   2ee58:	00000000 	.word	0x00000000

0002ee5c <__math_invalidf>:
   2ee5c:	eef0 7a40 	vmov.f32	s15, s0
   2ee60:	ee30 7a40 	vsub.f32	s14, s0, s0
   2ee64:	eef4 7a67 	vcmp.f32	s15, s15
   2ee68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ee6c:	ee87 0a07 	vdiv.f32	s0, s14, s14
   2ee70:	d602      	bvs.n	2ee78 <__math_invalidf+0x1c>
   2ee72:	2021      	movs	r0, #33	; 0x21
   2ee74:	f7ff bfb6 	b.w	2ede4 <with_errnof>
   2ee78:	4770      	bx	lr

0002ee7a <fabs>:
   2ee7a:	ec51 0b10 	vmov	r0, r1, d0
   2ee7e:	ee10 2a10 	vmov	r2, s0
   2ee82:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   2ee86:	ec43 2b10 	vmov	d0, r2, r3
   2ee8a:	4770      	bx	lr

0002ee8c <finite>:
   2ee8c:	ee10 3a90 	vmov	r3, s1
   2ee90:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
   2ee94:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
   2ee98:	0fc0      	lsrs	r0, r0, #31
   2ee9a:	4770      	bx	lr

0002ee9c <matherr>:
   2ee9c:	2000      	movs	r0, #0
   2ee9e:	4770      	bx	lr

0002eea0 <nan>:
   2eea0:	ed9f 0b01 	vldr	d0, [pc, #4]	; 2eea8 <nan+0x8>
   2eea4:	4770      	bx	lr
   2eea6:	bf00      	nop
   2eea8:	00000000 	.word	0x00000000
   2eeac:	7ff80000 	.word	0x7ff80000

0002eeb0 <rint>:
   2eeb0:	b530      	push	{r4, r5, lr}
   2eeb2:	b085      	sub	sp, #20
   2eeb4:	ed8d 0b00 	vstr	d0, [sp]
   2eeb8:	e9dd 2300 	ldrd	r2, r3, [sp]
   2eebc:	f3c3 510a 	ubfx	r1, r3, #20, #11
   2eec0:	f2a1 30ff 	subw	r0, r1, #1023	; 0x3ff
   2eec4:	2813      	cmp	r0, #19
   2eec6:	ea4f 74d3 	mov.w	r4, r3, lsr #31
   2eeca:	dc5a      	bgt.n	2ef82 <rint+0xd2>
   2eecc:	2800      	cmp	r0, #0
   2eece:	da2f      	bge.n	2ef30 <rint+0x80>
   2eed0:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
   2eed4:	4311      	orrs	r1, r2
   2eed6:	d027      	beq.n	2ef28 <rint+0x78>
   2eed8:	f3c3 0513 	ubfx	r5, r3, #0, #20
   2eedc:	4315      	orrs	r5, r2
   2eede:	426a      	negs	r2, r5
   2eee0:	432a      	orrs	r2, r5
   2eee2:	0b12      	lsrs	r2, r2, #12
   2eee4:	0c5b      	lsrs	r3, r3, #17
   2eee6:	045b      	lsls	r3, r3, #17
   2eee8:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
   2eeec:	e9dd 0100 	ldrd	r0, r1, [sp]
   2eef0:	ea42 0103 	orr.w	r1, r2, r3
   2eef4:	4b31      	ldr	r3, [pc, #196]	; (2efbc <rint+0x10c>)
   2eef6:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
   2eefa:	ed93 6b00 	vldr	d6, [r3]
   2eefe:	ec41 0b17 	vmov	d7, r0, r1
   2ef02:	ee36 7b07 	vadd.f64	d7, d6, d7
   2ef06:	ed8d 7b02 	vstr	d7, [sp, #8]
   2ef0a:	ed9d 7b02 	vldr	d7, [sp, #8]
   2ef0e:	ee37 7b46 	vsub.f64	d7, d7, d6
   2ef12:	ed8d 7b00 	vstr	d7, [sp]
   2ef16:	9b01      	ldr	r3, [sp, #4]
   2ef18:	e9dd 0100 	ldrd	r0, r1, [sp]
   2ef1c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2ef20:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
   2ef24:	e9cd 0100 	strd	r0, r1, [sp]
   2ef28:	ed9d 0b00 	vldr	d0, [sp]
   2ef2c:	b005      	add	sp, #20
   2ef2e:	bd30      	pop	{r4, r5, pc}
   2ef30:	4923      	ldr	r1, [pc, #140]	; (2efc0 <rint+0x110>)
   2ef32:	4101      	asrs	r1, r0
   2ef34:	ea03 0501 	and.w	r5, r3, r1
   2ef38:	4315      	orrs	r5, r2
   2ef3a:	d0f5      	beq.n	2ef28 <rint+0x78>
   2ef3c:	0849      	lsrs	r1, r1, #1
   2ef3e:	ea03 0501 	and.w	r5, r3, r1
   2ef42:	432a      	orrs	r2, r5
   2ef44:	d00b      	beq.n	2ef5e <rint+0xae>
   2ef46:	ea23 0101 	bic.w	r1, r3, r1
   2ef4a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   2ef4e:	2813      	cmp	r0, #19
   2ef50:	fa43 f300 	asr.w	r3, r3, r0
   2ef54:	bf0c      	ite	eq
   2ef56:	f04f 4200 	moveq.w	r2, #2147483648	; 0x80000000
   2ef5a:	2200      	movne	r2, #0
   2ef5c:	430b      	orrs	r3, r1
   2ef5e:	4619      	mov	r1, r3
   2ef60:	4b16      	ldr	r3, [pc, #88]	; (2efbc <rint+0x10c>)
   2ef62:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   2ef66:	ed94 6b00 	vldr	d6, [r4]
   2ef6a:	4610      	mov	r0, r2
   2ef6c:	ec41 0b17 	vmov	d7, r0, r1
   2ef70:	ee36 7b07 	vadd.f64	d7, d6, d7
   2ef74:	ed8d 7b02 	vstr	d7, [sp, #8]
   2ef78:	ed9d 7b02 	vldr	d7, [sp, #8]
   2ef7c:	ee37 7b46 	vsub.f64	d7, d7, d6
   2ef80:	e008      	b.n	2ef94 <rint+0xe4>
   2ef82:	2833      	cmp	r0, #51	; 0x33
   2ef84:	dd09      	ble.n	2ef9a <rint+0xea>
   2ef86:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
   2ef8a:	d1cd      	bne.n	2ef28 <rint+0x78>
   2ef8c:	ed9d 7b00 	vldr	d7, [sp]
   2ef90:	ee37 7b07 	vadd.f64	d7, d7, d7
   2ef94:	ed8d 7b00 	vstr	d7, [sp]
   2ef98:	e7c6      	b.n	2ef28 <rint+0x78>
   2ef9a:	f2a1 4013 	subw	r0, r1, #1043	; 0x413
   2ef9e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2efa2:	40c1      	lsrs	r1, r0
   2efa4:	420a      	tst	r2, r1
   2efa6:	d0bf      	beq.n	2ef28 <rint+0x78>
   2efa8:	0849      	lsrs	r1, r1, #1
   2efaa:	420a      	tst	r2, r1
   2efac:	bf1f      	itttt	ne
   2efae:	ea22 0101 	bicne.w	r1, r2, r1
   2efb2:	f04f 4280 	movne.w	r2, #1073741824	; 0x40000000
   2efb6:	4102      	asrne	r2, r0
   2efb8:	430a      	orrne	r2, r1
   2efba:	e7d0      	b.n	2ef5e <rint+0xae>
   2efbc:	00052538 	.word	0x00052538
   2efc0:	000fffff 	.word	0x000fffff
   2efc4:	00000000 	.word	0x00000000

0002efc8 <scalbn>:
   2efc8:	b500      	push	{lr}
   2efca:	ed2d 8b02 	vpush	{d8}
   2efce:	b083      	sub	sp, #12
   2efd0:	ed8d 0b00 	vstr	d0, [sp]
   2efd4:	9b01      	ldr	r3, [sp, #4]
   2efd6:	f3c3 520a 	ubfx	r2, r3, #20, #11
   2efda:	b9a2      	cbnz	r2, 2f006 <scalbn+0x3e>
   2efdc:	9a00      	ldr	r2, [sp, #0]
   2efde:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2efe2:	4313      	orrs	r3, r2
   2efe4:	d03a      	beq.n	2f05c <scalbn+0x94>
   2efe6:	ed9f 7b2e 	vldr	d7, [pc, #184]	; 2f0a0 <scalbn+0xd8>
   2efea:	4b35      	ldr	r3, [pc, #212]	; (2f0c0 <scalbn+0xf8>)
   2efec:	ee20 7b07 	vmul.f64	d7, d0, d7
   2eff0:	4298      	cmp	r0, r3
   2eff2:	ed8d 7b00 	vstr	d7, [sp]
   2eff6:	da11      	bge.n	2f01c <scalbn+0x54>
   2eff8:	ed9f 7b2b 	vldr	d7, [pc, #172]	; 2f0a8 <scalbn+0xe0>
   2effc:	ed9d 6b00 	vldr	d6, [sp]
   2f000:	ee27 7b06 	vmul.f64	d7, d7, d6
   2f004:	e007      	b.n	2f016 <scalbn+0x4e>
   2f006:	f240 71ff 	movw	r1, #2047	; 0x7ff
   2f00a:	428a      	cmp	r2, r1
   2f00c:	d10a      	bne.n	2f024 <scalbn+0x5c>
   2f00e:	ed9d 7b00 	vldr	d7, [sp]
   2f012:	ee37 7b07 	vadd.f64	d7, d7, d7
   2f016:	ed8d 7b00 	vstr	d7, [sp]
   2f01a:	e01f      	b.n	2f05c <scalbn+0x94>
   2f01c:	9b01      	ldr	r3, [sp, #4]
   2f01e:	f3c3 520a 	ubfx	r2, r3, #20, #11
   2f022:	3a36      	subs	r2, #54	; 0x36
   2f024:	4402      	add	r2, r0
   2f026:	f240 71fe 	movw	r1, #2046	; 0x7fe
   2f02a:	428a      	cmp	r2, r1
   2f02c:	dd0a      	ble.n	2f044 <scalbn+0x7c>
   2f02e:	ed9f 8b20 	vldr	d8, [pc, #128]	; 2f0b0 <scalbn+0xe8>
   2f032:	eeb0 0b48 	vmov.f64	d0, d8
   2f036:	ed9d 1b00 	vldr	d1, [sp]
   2f03a:	f000 fa19 	bl	2f470 <copysign>
   2f03e:	ee20 7b08 	vmul.f64	d7, d0, d8
   2f042:	e7e8      	b.n	2f016 <scalbn+0x4e>
   2f044:	2a00      	cmp	r2, #0
   2f046:	dd10      	ble.n	2f06a <scalbn+0xa2>
   2f048:	e9dd 0100 	ldrd	r0, r1, [sp]
   2f04c:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   2f050:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
   2f054:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
   2f058:	e9cd 0100 	strd	r0, r1, [sp]
   2f05c:	ed9d 0b00 	vldr	d0, [sp]
   2f060:	b003      	add	sp, #12
   2f062:	ecbd 8b02 	vpop	{d8}
   2f066:	f85d fb04 	ldr.w	pc, [sp], #4
   2f06a:	f112 0f35 	cmn.w	r2, #53	; 0x35
   2f06e:	da06      	bge.n	2f07e <scalbn+0xb6>
   2f070:	f24c 3350 	movw	r3, #50000	; 0xc350
   2f074:	4298      	cmp	r0, r3
   2f076:	dcda      	bgt.n	2f02e <scalbn+0x66>
   2f078:	ed9f 8b0b 	vldr	d8, [pc, #44]	; 2f0a8 <scalbn+0xe0>
   2f07c:	e7d9      	b.n	2f032 <scalbn+0x6a>
   2f07e:	e9dd 0100 	ldrd	r0, r1, [sp]
   2f082:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   2f086:	3236      	adds	r2, #54	; 0x36
   2f088:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
   2f08c:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
   2f090:	ec41 0b17 	vmov	d7, r0, r1
   2f094:	ed9f 6b08 	vldr	d6, [pc, #32]	; 2f0b8 <scalbn+0xf0>
   2f098:	e7b2      	b.n	2f000 <scalbn+0x38>
   2f09a:	bf00      	nop
   2f09c:	f3af 8000 	nop.w
   2f0a0:	00000000 	.word	0x00000000
   2f0a4:	43500000 	.word	0x43500000
   2f0a8:	c2f8f359 	.word	0xc2f8f359
   2f0ac:	01a56e1f 	.word	0x01a56e1f
   2f0b0:	8800759c 	.word	0x8800759c
   2f0b4:	7e37e43c 	.word	0x7e37e43c
   2f0b8:	00000000 	.word	0x00000000
   2f0bc:	3c900000 	.word	0x3c900000
   2f0c0:	ffff3cb0 	.word	0xffff3cb0

0002f0c4 <expm1f>:
   2f0c4:	ee10 2a10 	vmov	r2, s0
   2f0c8:	4984      	ldr	r1, [pc, #528]	; (2f2dc <expm1f+0x218>)
   2f0ca:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
   2f0ce:	428b      	cmp	r3, r1
   2f0d0:	d923      	bls.n	2f11a <expm1f+0x56>
   2f0d2:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2f0d6:	d902      	bls.n	2f0de <expm1f+0x1a>
   2f0d8:	ee30 0a00 	vadd.f32	s0, s0, s0
   2f0dc:	4770      	bx	lr
   2f0de:	d105      	bne.n	2f0ec <expm1f+0x28>
   2f0e0:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   2f0e4:	2a00      	cmp	r2, #0
   2f0e6:	fe20 0a27 	vselge.f32	s0, s0, s15
   2f0ea:	4770      	bx	lr
   2f0ec:	2a00      	cmp	r2, #0
   2f0ee:	db08      	blt.n	2f102 <expm1f+0x3e>
   2f0f0:	4a7b      	ldr	r2, [pc, #492]	; (2f2e0 <expm1f+0x21c>)
   2f0f2:	4293      	cmp	r3, r2
   2f0f4:	f240 80ea 	bls.w	2f2cc <expm1f+0x208>
   2f0f8:	ed9f 0a7a 	vldr	s0, [pc, #488]	; 2f2e4 <expm1f+0x220>
   2f0fc:	ee20 0a00 	vmul.f32	s0, s0, s0
   2f100:	4770      	bx	lr
   2f102:	eddf 7a79 	vldr	s15, [pc, #484]	; 2f2e8 <expm1f+0x224>
   2f106:	ee70 7a27 	vadd.f32	s15, s0, s15
   2f10a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2f10e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f112:	d554      	bpl.n	2f1be <expm1f+0xfa>
   2f114:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   2f118:	4770      	bx	lr
   2f11a:	4974      	ldr	r1, [pc, #464]	; (2f2ec <expm1f+0x228>)
   2f11c:	428b      	cmp	r3, r1
   2f11e:	d96c      	bls.n	2f1fa <expm1f+0x136>
   2f120:	4973      	ldr	r1, [pc, #460]	; (2f2f0 <expm1f+0x22c>)
   2f122:	428b      	cmp	r3, r1
   2f124:	d84b      	bhi.n	2f1be <expm1f+0xfa>
   2f126:	ed9f 7a73 	vldr	s14, [pc, #460]	; 2f2f4 <expm1f+0x230>
   2f12a:	2a00      	cmp	r2, #0
   2f12c:	bfa7      	ittee	ge
   2f12e:	ee30 7a47 	vsubge.f32	s14, s0, s14
   2f132:	eddf 7a71 	vldrge	s15, [pc, #452]	; 2f2f8 <expm1f+0x234>
   2f136:	eddf 7a71 	vldrlt	s15, [pc, #452]	; 2f2fc <expm1f+0x238>
   2f13a:	ee30 7a07 	vaddlt.f32	s14, s0, s14
   2f13e:	bfac      	ite	ge
   2f140:	2301      	movge	r3, #1
   2f142:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   2f146:	ee37 0a67 	vsub.f32	s0, s14, s15
   2f14a:	ee37 7a40 	vsub.f32	s14, s14, s0
   2f14e:	ee77 7a67 	vsub.f32	s15, s14, s15
   2f152:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
   2f156:	ee20 5a25 	vmul.f32	s10, s0, s11
   2f15a:	eddf 6a69 	vldr	s13, [pc, #420]	; 2f300 <expm1f+0x23c>
   2f15e:	ed9f 6a69 	vldr	s12, [pc, #420]	; 2f304 <expm1f+0x240>
   2f162:	ee20 7a05 	vmul.f32	s14, s0, s10
   2f166:	eea7 6a26 	vfma.f32	s12, s14, s13
   2f16a:	eddf 6a67 	vldr	s13, [pc, #412]	; 2f308 <expm1f+0x244>
   2f16e:	eee6 6a07 	vfma.f32	s13, s12, s14
   2f172:	ed9f 6a66 	vldr	s12, [pc, #408]	; 2f30c <expm1f+0x248>
   2f176:	eea6 6a87 	vfma.f32	s12, s13, s14
   2f17a:	eddf 6a65 	vldr	s13, [pc, #404]	; 2f310 <expm1f+0x24c>
   2f17e:	eee6 6a07 	vfma.f32	s13, s12, s14
   2f182:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2f186:	eef0 4a46 	vmov.f32	s9, s12
   2f18a:	eee6 4a87 	vfma.f32	s9, s13, s14
   2f18e:	eef0 6a64 	vmov.f32	s13, s9
   2f192:	eef0 4a08 	vmov.f32	s9, #8	; 0x40400000  3.0
   2f196:	eee5 4a66 	vfms.f32	s9, s10, s13
   2f19a:	ee36 5ae4 	vsub.f32	s10, s13, s9
   2f19e:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
   2f1a2:	eee0 6a64 	vfms.f32	s13, s0, s9
   2f1a6:	eef0 4a66 	vmov.f32	s9, s13
   2f1aa:	eec5 6a24 	vdiv.f32	s13, s10, s9
   2f1ae:	ee66 6a87 	vmul.f32	s13, s13, s14
   2f1b2:	bb83      	cbnz	r3, 2f216 <expm1f+0x152>
   2f1b4:	eef0 7a47 	vmov.f32	s15, s14
   2f1b8:	eed0 7a26 	vfnms.f32	s15, s0, s13
   2f1bc:	e026      	b.n	2f20c <expm1f+0x148>
   2f1be:	eddf 7a55 	vldr	s15, [pc, #340]	; 2f314 <expm1f+0x250>
   2f1c2:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   2f1c6:	ee20 7a27 	vmul.f32	s14, s0, s15
   2f1ca:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2f1ce:	2a00      	cmp	r2, #0
   2f1d0:	fe66 7aa7 	vselge.f32	s15, s13, s15
   2f1d4:	ee77 7a87 	vadd.f32	s15, s15, s14
   2f1d8:	ed9f 7a46 	vldr	s14, [pc, #280]	; 2f2f4 <expm1f+0x230>
   2f1dc:	eddf 6a46 	vldr	s13, [pc, #280]	; 2f2f8 <expm1f+0x234>
   2f1e0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2f1e4:	ee17 3a90 	vmov	r3, s15
   2f1e8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2f1ec:	eea7 0ac7 	vfms.f32	s0, s15, s14
   2f1f0:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2f1f4:	eeb0 7a40 	vmov.f32	s14, s0
   2f1f8:	e7a5      	b.n	2f146 <expm1f+0x82>
   2f1fa:	f1b3 5f4c 	cmp.w	r3, #855638016	; 0x33000000
   2f1fe:	d208      	bcs.n	2f212 <expm1f+0x14e>
   2f200:	eddf 7a38 	vldr	s15, [pc, #224]	; 2f2e4 <expm1f+0x220>
   2f204:	ee70 7a27 	vadd.f32	s15, s0, s15
   2f208:	ee77 7ae7 	vsub.f32	s15, s15, s15
   2f20c:	ee30 0a67 	vsub.f32	s0, s0, s15
   2f210:	4770      	bx	lr
   2f212:	2300      	movs	r3, #0
   2f214:	e79d      	b.n	2f152 <expm1f+0x8e>
   2f216:	ee76 6ae7 	vsub.f32	s13, s13, s15
   2f21a:	1c5a      	adds	r2, r3, #1
   2f21c:	eed6 7a80 	vfnms.f32	s15, s13, s0
   2f220:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2f224:	d106      	bne.n	2f234 <expm1f+0x170>
   2f226:	ee70 7a67 	vsub.f32	s15, s0, s15
   2f22a:	eebe 0a00 	vmov.f32	s0, #224	; 0xbf000000 -0.5
   2f22e:	eea7 0aa5 	vfma.f32	s0, s15, s11
   2f232:	4770      	bx	lr
   2f234:	2b01      	cmp	r3, #1
   2f236:	d118      	bne.n	2f26a <expm1f+0x1a6>
   2f238:	eebd 7a00 	vmov.f32	s14, #208	; 0xbe800000 -0.250
   2f23c:	eeb4 0ac7 	vcmpe.f32	s0, s14
   2f240:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f244:	bf41      	itttt	mi
   2f246:	ee30 0a25 	vaddmi.f32	s0, s0, s11
   2f24a:	ee37 0ac0 	vsubmi.f32	s0, s15, s0
   2f24e:	eef8 7a00 	vmovmi.f32	s15, #128	; 0xc0000000 -2.0
   2f252:	ee20 0a27 	vmulmi.f32	s0, s0, s15
   2f256:	bf5f      	itttt	pl
   2f258:	ee30 0a67 	vsubpl.f32	s0, s0, s15
   2f25c:	eef0 7a00 	vmovpl.f32	s15, #0	; 0x40000000  2.0
   2f260:	eea0 6a27 	vfmapl.f32	s12, s0, s15
   2f264:	eeb0 0a46 	vmovpl.f32	s0, s12
   2f268:	4770      	bx	lr
   2f26a:	1c5a      	adds	r2, r3, #1
   2f26c:	2a39      	cmp	r2, #57	; 0x39
   2f26e:	ea4f 51c3 	mov.w	r1, r3, lsl #23
   2f272:	d90b      	bls.n	2f28c <expm1f+0x1c8>
   2f274:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2f278:	ee36 0a40 	vsub.f32	s0, s12, s0
   2f27c:	ee10 3a10 	vmov	r3, s0
   2f280:	440b      	add	r3, r1
   2f282:	ee00 3a10 	vmov	s0, r3
   2f286:	ee30 0a46 	vsub.f32	s0, s0, s12
   2f28a:	4770      	bx	lr
   2f28c:	2b16      	cmp	r3, #22
   2f28e:	dc11      	bgt.n	2f2b4 <expm1f+0x1f0>
   2f290:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   2f294:	fa42 f303 	asr.w	r3, r2, r3
   2f298:	f1c3 537e 	rsb	r3, r3, #1065353216	; 0x3f800000
   2f29c:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2f2a0:	ee07 3a90 	vmov	s15, r3
   2f2a4:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2f2a8:	ee10 3a10 	vmov	r3, s0
   2f2ac:	440b      	add	r3, r1
   2f2ae:	ee00 3a10 	vmov	s0, r3
   2f2b2:	4770      	bx	lr
   2f2b4:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
   2f2b8:	05db      	lsls	r3, r3, #23
   2f2ba:	ee07 3a10 	vmov	s14, r3
   2f2be:	ee77 7a87 	vadd.f32	s15, s15, s14
   2f2c2:	ee30 0a67 	vsub.f32	s0, s0, s15
   2f2c6:	ee30 0a06 	vadd.f32	s0, s0, s12
   2f2ca:	e7ed      	b.n	2f2a8 <expm1f+0x1e4>
   2f2cc:	eddf 7a11 	vldr	s15, [pc, #68]	; 2f314 <expm1f+0x250>
   2f2d0:	ee20 7a27 	vmul.f32	s14, s0, s15
   2f2d4:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2f2d8:	e77c      	b.n	2f1d4 <expm1f+0x110>
   2f2da:	bf00      	nop
   2f2dc:	4195b843 	.word	0x4195b843
   2f2e0:	42b17217 	.word	0x42b17217
   2f2e4:	7149f2ca 	.word	0x7149f2ca
   2f2e8:	0da24260 	.word	0x0da24260
   2f2ec:	3eb17218 	.word	0x3eb17218
   2f2f0:	3f851591 	.word	0x3f851591
   2f2f4:	3f317180 	.word	0x3f317180
   2f2f8:	3717f7d1 	.word	0x3717f7d1
   2f2fc:	b717f7d1 	.word	0xb717f7d1
   2f300:	b457edbb 	.word	0xb457edbb
   2f304:	36867e54 	.word	0x36867e54
   2f308:	b8a670cd 	.word	0xb8a670cd
   2f30c:	3ad00d01 	.word	0x3ad00d01
   2f310:	bd088889 	.word	0xbd088889
   2f314:	3fb8aa3b 	.word	0x3fb8aa3b

0002f318 <finitef>:
   2f318:	ee10 3a10 	vmov	r3, s0
   2f31c:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
   2f320:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
   2f324:	bfac      	ite	ge
   2f326:	2000      	movge	r0, #0
   2f328:	2001      	movlt	r0, #1
   2f32a:	4770      	bx	lr

0002f32c <floorf>:
   2f32c:	ee10 3a10 	vmov	r3, s0
   2f330:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
   2f334:	0dca      	lsrs	r2, r1, #23
   2f336:	3a7f      	subs	r2, #127	; 0x7f
   2f338:	2a16      	cmp	r2, #22
   2f33a:	dc2a      	bgt.n	2f392 <floorf+0x66>
   2f33c:	2a00      	cmp	r2, #0
   2f33e:	da11      	bge.n	2f364 <floorf+0x38>
   2f340:	eddf 7a18 	vldr	s15, [pc, #96]	; 2f3a4 <floorf+0x78>
   2f344:	ee30 0a27 	vadd.f32	s0, s0, s15
   2f348:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   2f34c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f350:	dd05      	ble.n	2f35e <floorf+0x32>
   2f352:	2b00      	cmp	r3, #0
   2f354:	da23      	bge.n	2f39e <floorf+0x72>
   2f356:	4a14      	ldr	r2, [pc, #80]	; (2f3a8 <floorf+0x7c>)
   2f358:	2900      	cmp	r1, #0
   2f35a:	bf18      	it	ne
   2f35c:	4613      	movne	r3, r2
   2f35e:	ee00 3a10 	vmov	s0, r3
   2f362:	4770      	bx	lr
   2f364:	4911      	ldr	r1, [pc, #68]	; (2f3ac <floorf+0x80>)
   2f366:	4111      	asrs	r1, r2
   2f368:	420b      	tst	r3, r1
   2f36a:	d0fa      	beq.n	2f362 <floorf+0x36>
   2f36c:	eddf 7a0d 	vldr	s15, [pc, #52]	; 2f3a4 <floorf+0x78>
   2f370:	ee30 0a27 	vadd.f32	s0, s0, s15
   2f374:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   2f378:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f37c:	ddef      	ble.n	2f35e <floorf+0x32>
   2f37e:	2b00      	cmp	r3, #0
   2f380:	bfbe      	ittt	lt
   2f382:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
   2f386:	fa40 f202 	asrlt.w	r2, r0, r2
   2f38a:	189b      	addlt	r3, r3, r2
   2f38c:	ea23 0301 	bic.w	r3, r3, r1
   2f390:	e7e5      	b.n	2f35e <floorf+0x32>
   2f392:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
   2f396:	d3e4      	bcc.n	2f362 <floorf+0x36>
   2f398:	ee30 0a00 	vadd.f32	s0, s0, s0
   2f39c:	4770      	bx	lr
   2f39e:	2300      	movs	r3, #0
   2f3a0:	e7dd      	b.n	2f35e <floorf+0x32>
   2f3a2:	bf00      	nop
   2f3a4:	7149f2ca 	.word	0x7149f2ca
   2f3a8:	bf800000 	.word	0xbf800000
   2f3ac:	007fffff 	.word	0x007fffff

0002f3b0 <scalbnf>:
   2f3b0:	b508      	push	{r3, lr}
   2f3b2:	ee10 2a10 	vmov	r2, s0
   2f3b6:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
   2f3ba:	ed2d 8b02 	vpush	{d8}
   2f3be:	eef0 0a40 	vmov.f32	s1, s0
   2f3c2:	d004      	beq.n	2f3ce <scalbnf+0x1e>
   2f3c4:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2f3c8:	d306      	bcc.n	2f3d8 <scalbnf+0x28>
   2f3ca:	ee70 0a00 	vadd.f32	s1, s0, s0
   2f3ce:	ecbd 8b02 	vpop	{d8}
   2f3d2:	eeb0 0a60 	vmov.f32	s0, s1
   2f3d6:	bd08      	pop	{r3, pc}
   2f3d8:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   2f3dc:	d21c      	bcs.n	2f418 <scalbnf+0x68>
   2f3de:	4b1f      	ldr	r3, [pc, #124]	; (2f45c <scalbnf+0xac>)
   2f3e0:	eddf 7a1f 	vldr	s15, [pc, #124]	; 2f460 <scalbnf+0xb0>
   2f3e4:	4298      	cmp	r0, r3
   2f3e6:	ee60 0a27 	vmul.f32	s1, s0, s15
   2f3ea:	db10      	blt.n	2f40e <scalbnf+0x5e>
   2f3ec:	ee10 2a90 	vmov	r2, s1
   2f3f0:	f3c2 53c7 	ubfx	r3, r2, #23, #8
   2f3f4:	3b19      	subs	r3, #25
   2f3f6:	4403      	add	r3, r0
   2f3f8:	2bfe      	cmp	r3, #254	; 0xfe
   2f3fa:	dd0f      	ble.n	2f41c <scalbnf+0x6c>
   2f3fc:	ed9f 8a19 	vldr	s16, [pc, #100]	; 2f464 <scalbnf+0xb4>
   2f400:	eeb0 0a48 	vmov.f32	s0, s16
   2f404:	f000 f843 	bl	2f48e <copysignf>
   2f408:	ee60 0a08 	vmul.f32	s1, s0, s16
   2f40c:	e7df      	b.n	2f3ce <scalbnf+0x1e>
   2f40e:	eddf 7a16 	vldr	s15, [pc, #88]	; 2f468 <scalbnf+0xb8>
   2f412:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2f416:	e7da      	b.n	2f3ce <scalbnf+0x1e>
   2f418:	0ddb      	lsrs	r3, r3, #23
   2f41a:	e7ec      	b.n	2f3f6 <scalbnf+0x46>
   2f41c:	2b00      	cmp	r3, #0
   2f41e:	dd06      	ble.n	2f42e <scalbnf+0x7e>
   2f420:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
   2f424:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
   2f428:	ee00 3a90 	vmov	s1, r3
   2f42c:	e7cf      	b.n	2f3ce <scalbnf+0x1e>
   2f42e:	f113 0f16 	cmn.w	r3, #22
   2f432:	da06      	bge.n	2f442 <scalbnf+0x92>
   2f434:	f24c 3350 	movw	r3, #50000	; 0xc350
   2f438:	4298      	cmp	r0, r3
   2f43a:	dcdf      	bgt.n	2f3fc <scalbnf+0x4c>
   2f43c:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 2f468 <scalbnf+0xb8>
   2f440:	e7de      	b.n	2f400 <scalbnf+0x50>
   2f442:	3319      	adds	r3, #25
   2f444:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
   2f448:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
   2f44c:	eddf 7a07 	vldr	s15, [pc, #28]	; 2f46c <scalbnf+0xbc>
   2f450:	ee07 3a10 	vmov	s14, r3
   2f454:	ee67 0a27 	vmul.f32	s1, s14, s15
   2f458:	e7b9      	b.n	2f3ce <scalbnf+0x1e>
   2f45a:	bf00      	nop
   2f45c:	ffff3cb0 	.word	0xffff3cb0
   2f460:	4c000000 	.word	0x4c000000
   2f464:	7149f2ca 	.word	0x7149f2ca
   2f468:	0da24260 	.word	0x0da24260
   2f46c:	33000000 	.word	0x33000000

0002f470 <copysign>:
   2f470:	ec51 0b10 	vmov	r0, r1, d0
   2f474:	ee11 0a90 	vmov	r0, s3
   2f478:	ee10 2a10 	vmov	r2, s0
   2f47c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   2f480:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   2f484:	ea41 0300 	orr.w	r3, r1, r0
   2f488:	ec43 2b10 	vmov	d0, r2, r3
   2f48c:	4770      	bx	lr

0002f48e <copysignf>:
   2f48e:	ee10 3a10 	vmov	r3, s0
   2f492:	ee10 2a90 	vmov	r2, s1
   2f496:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2f49a:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
   2f49e:	4313      	orrs	r3, r2
   2f4a0:	ee00 3a10 	vmov	s0, r3
   2f4a4:	4770      	bx	lr
	...

0002f4a8 <__aeabi_drsub>:
   2f4a8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   2f4ac:	e002      	b.n	2f4b4 <__adddf3>
   2f4ae:	bf00      	nop

0002f4b0 <__aeabi_dsub>:
   2f4b0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0002f4b4 <__adddf3>:
   2f4b4:	b530      	push	{r4, r5, lr}
   2f4b6:	ea4f 0441 	mov.w	r4, r1, lsl #1
   2f4ba:	ea4f 0543 	mov.w	r5, r3, lsl #1
   2f4be:	ea94 0f05 	teq	r4, r5
   2f4c2:	bf08      	it	eq
   2f4c4:	ea90 0f02 	teqeq	r0, r2
   2f4c8:	bf1f      	itttt	ne
   2f4ca:	ea54 0c00 	orrsne.w	ip, r4, r0
   2f4ce:	ea55 0c02 	orrsne.w	ip, r5, r2
   2f4d2:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   2f4d6:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   2f4da:	f000 80e2 	beq.w	2f6a2 <__adddf3+0x1ee>
   2f4de:	ea4f 5454 	mov.w	r4, r4, lsr #21
   2f4e2:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   2f4e6:	bfb8      	it	lt
   2f4e8:	426d      	neglt	r5, r5
   2f4ea:	dd0c      	ble.n	2f506 <__adddf3+0x52>
   2f4ec:	442c      	add	r4, r5
   2f4ee:	ea80 0202 	eor.w	r2, r0, r2
   2f4f2:	ea81 0303 	eor.w	r3, r1, r3
   2f4f6:	ea82 0000 	eor.w	r0, r2, r0
   2f4fa:	ea83 0101 	eor.w	r1, r3, r1
   2f4fe:	ea80 0202 	eor.w	r2, r0, r2
   2f502:	ea81 0303 	eor.w	r3, r1, r3
   2f506:	2d36      	cmp	r5, #54	; 0x36
   2f508:	bf88      	it	hi
   2f50a:	bd30      	pophi	{r4, r5, pc}
   2f50c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   2f510:	ea4f 3101 	mov.w	r1, r1, lsl #12
   2f514:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   2f518:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   2f51c:	d002      	beq.n	2f524 <__adddf3+0x70>
   2f51e:	4240      	negs	r0, r0
   2f520:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   2f524:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   2f528:	ea4f 3303 	mov.w	r3, r3, lsl #12
   2f52c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   2f530:	d002      	beq.n	2f538 <__adddf3+0x84>
   2f532:	4252      	negs	r2, r2
   2f534:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   2f538:	ea94 0f05 	teq	r4, r5
   2f53c:	f000 80a7 	beq.w	2f68e <__adddf3+0x1da>
   2f540:	f1a4 0401 	sub.w	r4, r4, #1
   2f544:	f1d5 0e20 	rsbs	lr, r5, #32
   2f548:	db0d      	blt.n	2f566 <__adddf3+0xb2>
   2f54a:	fa02 fc0e 	lsl.w	ip, r2, lr
   2f54e:	fa22 f205 	lsr.w	r2, r2, r5
   2f552:	1880      	adds	r0, r0, r2
   2f554:	f141 0100 	adc.w	r1, r1, #0
   2f558:	fa03 f20e 	lsl.w	r2, r3, lr
   2f55c:	1880      	adds	r0, r0, r2
   2f55e:	fa43 f305 	asr.w	r3, r3, r5
   2f562:	4159      	adcs	r1, r3
   2f564:	e00e      	b.n	2f584 <__adddf3+0xd0>
   2f566:	f1a5 0520 	sub.w	r5, r5, #32
   2f56a:	f10e 0e20 	add.w	lr, lr, #32
   2f56e:	2a01      	cmp	r2, #1
   2f570:	fa03 fc0e 	lsl.w	ip, r3, lr
   2f574:	bf28      	it	cs
   2f576:	f04c 0c02 	orrcs.w	ip, ip, #2
   2f57a:	fa43 f305 	asr.w	r3, r3, r5
   2f57e:	18c0      	adds	r0, r0, r3
   2f580:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   2f584:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   2f588:	d507      	bpl.n	2f59a <__adddf3+0xe6>
   2f58a:	f04f 0e00 	mov.w	lr, #0
   2f58e:	f1dc 0c00 	rsbs	ip, ip, #0
   2f592:	eb7e 0000 	sbcs.w	r0, lr, r0
   2f596:	eb6e 0101 	sbc.w	r1, lr, r1
   2f59a:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   2f59e:	d31b      	bcc.n	2f5d8 <__adddf3+0x124>
   2f5a0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   2f5a4:	d30c      	bcc.n	2f5c0 <__adddf3+0x10c>
   2f5a6:	0849      	lsrs	r1, r1, #1
   2f5a8:	ea5f 0030 	movs.w	r0, r0, rrx
   2f5ac:	ea4f 0c3c 	mov.w	ip, ip, rrx
   2f5b0:	f104 0401 	add.w	r4, r4, #1
   2f5b4:	ea4f 5244 	mov.w	r2, r4, lsl #21
   2f5b8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   2f5bc:	f080 809a 	bcs.w	2f6f4 <__adddf3+0x240>
   2f5c0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   2f5c4:	bf08      	it	eq
   2f5c6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   2f5ca:	f150 0000 	adcs.w	r0, r0, #0
   2f5ce:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   2f5d2:	ea41 0105 	orr.w	r1, r1, r5
   2f5d6:	bd30      	pop	{r4, r5, pc}
   2f5d8:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   2f5dc:	4140      	adcs	r0, r0
   2f5de:	eb41 0101 	adc.w	r1, r1, r1
   2f5e2:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   2f5e6:	f1a4 0401 	sub.w	r4, r4, #1
   2f5ea:	d1e9      	bne.n	2f5c0 <__adddf3+0x10c>
   2f5ec:	f091 0f00 	teq	r1, #0
   2f5f0:	bf04      	itt	eq
   2f5f2:	4601      	moveq	r1, r0
   2f5f4:	2000      	moveq	r0, #0
   2f5f6:	fab1 f381 	clz	r3, r1
   2f5fa:	bf08      	it	eq
   2f5fc:	3320      	addeq	r3, #32
   2f5fe:	f1a3 030b 	sub.w	r3, r3, #11
   2f602:	f1b3 0220 	subs.w	r2, r3, #32
   2f606:	da0c      	bge.n	2f622 <__adddf3+0x16e>
   2f608:	320c      	adds	r2, #12
   2f60a:	dd08      	ble.n	2f61e <__adddf3+0x16a>
   2f60c:	f102 0c14 	add.w	ip, r2, #20
   2f610:	f1c2 020c 	rsb	r2, r2, #12
   2f614:	fa01 f00c 	lsl.w	r0, r1, ip
   2f618:	fa21 f102 	lsr.w	r1, r1, r2
   2f61c:	e00c      	b.n	2f638 <__adddf3+0x184>
   2f61e:	f102 0214 	add.w	r2, r2, #20
   2f622:	bfd8      	it	le
   2f624:	f1c2 0c20 	rsble	ip, r2, #32
   2f628:	fa01 f102 	lsl.w	r1, r1, r2
   2f62c:	fa20 fc0c 	lsr.w	ip, r0, ip
   2f630:	bfdc      	itt	le
   2f632:	ea41 010c 	orrle.w	r1, r1, ip
   2f636:	4090      	lslle	r0, r2
   2f638:	1ae4      	subs	r4, r4, r3
   2f63a:	bfa2      	ittt	ge
   2f63c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   2f640:	4329      	orrge	r1, r5
   2f642:	bd30      	popge	{r4, r5, pc}
   2f644:	ea6f 0404 	mvn.w	r4, r4
   2f648:	3c1f      	subs	r4, #31
   2f64a:	da1c      	bge.n	2f686 <__adddf3+0x1d2>
   2f64c:	340c      	adds	r4, #12
   2f64e:	dc0e      	bgt.n	2f66e <__adddf3+0x1ba>
   2f650:	f104 0414 	add.w	r4, r4, #20
   2f654:	f1c4 0220 	rsb	r2, r4, #32
   2f658:	fa20 f004 	lsr.w	r0, r0, r4
   2f65c:	fa01 f302 	lsl.w	r3, r1, r2
   2f660:	ea40 0003 	orr.w	r0, r0, r3
   2f664:	fa21 f304 	lsr.w	r3, r1, r4
   2f668:	ea45 0103 	orr.w	r1, r5, r3
   2f66c:	bd30      	pop	{r4, r5, pc}
   2f66e:	f1c4 040c 	rsb	r4, r4, #12
   2f672:	f1c4 0220 	rsb	r2, r4, #32
   2f676:	fa20 f002 	lsr.w	r0, r0, r2
   2f67a:	fa01 f304 	lsl.w	r3, r1, r4
   2f67e:	ea40 0003 	orr.w	r0, r0, r3
   2f682:	4629      	mov	r1, r5
   2f684:	bd30      	pop	{r4, r5, pc}
   2f686:	fa21 f004 	lsr.w	r0, r1, r4
   2f68a:	4629      	mov	r1, r5
   2f68c:	bd30      	pop	{r4, r5, pc}
   2f68e:	f094 0f00 	teq	r4, #0
   2f692:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   2f696:	bf06      	itte	eq
   2f698:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   2f69c:	3401      	addeq	r4, #1
   2f69e:	3d01      	subne	r5, #1
   2f6a0:	e74e      	b.n	2f540 <__adddf3+0x8c>
   2f6a2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   2f6a6:	bf18      	it	ne
   2f6a8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   2f6ac:	d029      	beq.n	2f702 <__adddf3+0x24e>
   2f6ae:	ea94 0f05 	teq	r4, r5
   2f6b2:	bf08      	it	eq
   2f6b4:	ea90 0f02 	teqeq	r0, r2
   2f6b8:	d005      	beq.n	2f6c6 <__adddf3+0x212>
   2f6ba:	ea54 0c00 	orrs.w	ip, r4, r0
   2f6be:	bf04      	itt	eq
   2f6c0:	4619      	moveq	r1, r3
   2f6c2:	4610      	moveq	r0, r2
   2f6c4:	bd30      	pop	{r4, r5, pc}
   2f6c6:	ea91 0f03 	teq	r1, r3
   2f6ca:	bf1e      	ittt	ne
   2f6cc:	2100      	movne	r1, #0
   2f6ce:	2000      	movne	r0, #0
   2f6d0:	bd30      	popne	{r4, r5, pc}
   2f6d2:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   2f6d6:	d105      	bne.n	2f6e4 <__adddf3+0x230>
   2f6d8:	0040      	lsls	r0, r0, #1
   2f6da:	4149      	adcs	r1, r1
   2f6dc:	bf28      	it	cs
   2f6de:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   2f6e2:	bd30      	pop	{r4, r5, pc}
   2f6e4:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   2f6e8:	bf3c      	itt	cc
   2f6ea:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   2f6ee:	bd30      	popcc	{r4, r5, pc}
   2f6f0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   2f6f4:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   2f6f8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   2f6fc:	f04f 0000 	mov.w	r0, #0
   2f700:	bd30      	pop	{r4, r5, pc}
   2f702:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   2f706:	bf1a      	itte	ne
   2f708:	4619      	movne	r1, r3
   2f70a:	4610      	movne	r0, r2
   2f70c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   2f710:	bf1c      	itt	ne
   2f712:	460b      	movne	r3, r1
   2f714:	4602      	movne	r2, r0
   2f716:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   2f71a:	bf06      	itte	eq
   2f71c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   2f720:	ea91 0f03 	teqeq	r1, r3
   2f724:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   2f728:	bd30      	pop	{r4, r5, pc}
   2f72a:	bf00      	nop

0002f72c <__aeabi_ui2d>:
   2f72c:	f090 0f00 	teq	r0, #0
   2f730:	bf04      	itt	eq
   2f732:	2100      	moveq	r1, #0
   2f734:	4770      	bxeq	lr
   2f736:	b530      	push	{r4, r5, lr}
   2f738:	f44f 6480 	mov.w	r4, #1024	; 0x400
   2f73c:	f104 0432 	add.w	r4, r4, #50	; 0x32
   2f740:	f04f 0500 	mov.w	r5, #0
   2f744:	f04f 0100 	mov.w	r1, #0
   2f748:	e750      	b.n	2f5ec <__adddf3+0x138>
   2f74a:	bf00      	nop

0002f74c <__aeabi_i2d>:
   2f74c:	f090 0f00 	teq	r0, #0
   2f750:	bf04      	itt	eq
   2f752:	2100      	moveq	r1, #0
   2f754:	4770      	bxeq	lr
   2f756:	b530      	push	{r4, r5, lr}
   2f758:	f44f 6480 	mov.w	r4, #1024	; 0x400
   2f75c:	f104 0432 	add.w	r4, r4, #50	; 0x32
   2f760:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   2f764:	bf48      	it	mi
   2f766:	4240      	negmi	r0, r0
   2f768:	f04f 0100 	mov.w	r1, #0
   2f76c:	e73e      	b.n	2f5ec <__adddf3+0x138>
   2f76e:	bf00      	nop

0002f770 <__aeabi_f2d>:
   2f770:	0042      	lsls	r2, r0, #1
   2f772:	ea4f 01e2 	mov.w	r1, r2, asr #3
   2f776:	ea4f 0131 	mov.w	r1, r1, rrx
   2f77a:	ea4f 7002 	mov.w	r0, r2, lsl #28
   2f77e:	bf1f      	itttt	ne
   2f780:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   2f784:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   2f788:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   2f78c:	4770      	bxne	lr
   2f78e:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   2f792:	bf08      	it	eq
   2f794:	4770      	bxeq	lr
   2f796:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   2f79a:	bf04      	itt	eq
   2f79c:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   2f7a0:	4770      	bxeq	lr
   2f7a2:	b530      	push	{r4, r5, lr}
   2f7a4:	f44f 7460 	mov.w	r4, #896	; 0x380
   2f7a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   2f7ac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   2f7b0:	e71c      	b.n	2f5ec <__adddf3+0x138>
   2f7b2:	bf00      	nop

0002f7b4 <__aeabi_ul2d>:
   2f7b4:	ea50 0201 	orrs.w	r2, r0, r1
   2f7b8:	bf08      	it	eq
   2f7ba:	4770      	bxeq	lr
   2f7bc:	b530      	push	{r4, r5, lr}
   2f7be:	f04f 0500 	mov.w	r5, #0
   2f7c2:	e00a      	b.n	2f7da <__aeabi_l2d+0x16>

0002f7c4 <__aeabi_l2d>:
   2f7c4:	ea50 0201 	orrs.w	r2, r0, r1
   2f7c8:	bf08      	it	eq
   2f7ca:	4770      	bxeq	lr
   2f7cc:	b530      	push	{r4, r5, lr}
   2f7ce:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   2f7d2:	d502      	bpl.n	2f7da <__aeabi_l2d+0x16>
   2f7d4:	4240      	negs	r0, r0
   2f7d6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   2f7da:	f44f 6480 	mov.w	r4, #1024	; 0x400
   2f7de:	f104 0432 	add.w	r4, r4, #50	; 0x32
   2f7e2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   2f7e6:	f43f aed8 	beq.w	2f59a <__adddf3+0xe6>
   2f7ea:	f04f 0203 	mov.w	r2, #3
   2f7ee:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   2f7f2:	bf18      	it	ne
   2f7f4:	3203      	addne	r2, #3
   2f7f6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   2f7fa:	bf18      	it	ne
   2f7fc:	3203      	addne	r2, #3
   2f7fe:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   2f802:	f1c2 0320 	rsb	r3, r2, #32
   2f806:	fa00 fc03 	lsl.w	ip, r0, r3
   2f80a:	fa20 f002 	lsr.w	r0, r0, r2
   2f80e:	fa01 fe03 	lsl.w	lr, r1, r3
   2f812:	ea40 000e 	orr.w	r0, r0, lr
   2f816:	fa21 f102 	lsr.w	r1, r1, r2
   2f81a:	4414      	add	r4, r2
   2f81c:	e6bd      	b.n	2f59a <__adddf3+0xe6>
   2f81e:	bf00      	nop

0002f820 <__aeabi_uldivmod>:
   2f820:	b953      	cbnz	r3, 2f838 <__aeabi_uldivmod+0x18>
   2f822:	b94a      	cbnz	r2, 2f838 <__aeabi_uldivmod+0x18>
   2f824:	2900      	cmp	r1, #0
   2f826:	bf08      	it	eq
   2f828:	2800      	cmpeq	r0, #0
   2f82a:	bf1c      	itt	ne
   2f82c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   2f830:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   2f834:	f000 b972 	b.w	2fb1c <__aeabi_idiv0>
   2f838:	f1ad 0c08 	sub.w	ip, sp, #8
   2f83c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   2f840:	f000 f806 	bl	2f850 <__udivmoddi4>
   2f844:	f8dd e004 	ldr.w	lr, [sp, #4]
   2f848:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   2f84c:	b004      	add	sp, #16
   2f84e:	4770      	bx	lr

0002f850 <__udivmoddi4>:
   2f850:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2f854:	9e08      	ldr	r6, [sp, #32]
   2f856:	4604      	mov	r4, r0
   2f858:	4688      	mov	r8, r1
   2f85a:	2b00      	cmp	r3, #0
   2f85c:	d14b      	bne.n	2f8f6 <__udivmoddi4+0xa6>
   2f85e:	428a      	cmp	r2, r1
   2f860:	4615      	mov	r5, r2
   2f862:	d967      	bls.n	2f934 <__udivmoddi4+0xe4>
   2f864:	fab2 f282 	clz	r2, r2
   2f868:	b14a      	cbz	r2, 2f87e <__udivmoddi4+0x2e>
   2f86a:	f1c2 0720 	rsb	r7, r2, #32
   2f86e:	fa01 f302 	lsl.w	r3, r1, r2
   2f872:	fa20 f707 	lsr.w	r7, r0, r7
   2f876:	4095      	lsls	r5, r2
   2f878:	ea47 0803 	orr.w	r8, r7, r3
   2f87c:	4094      	lsls	r4, r2
   2f87e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   2f882:	0c23      	lsrs	r3, r4, #16
   2f884:	fbb8 f7fe 	udiv	r7, r8, lr
   2f888:	fa1f fc85 	uxth.w	ip, r5
   2f88c:	fb0e 8817 	mls	r8, lr, r7, r8
   2f890:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   2f894:	fb07 f10c 	mul.w	r1, r7, ip
   2f898:	4299      	cmp	r1, r3
   2f89a:	d909      	bls.n	2f8b0 <__udivmoddi4+0x60>
   2f89c:	18eb      	adds	r3, r5, r3
   2f89e:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   2f8a2:	f080 811b 	bcs.w	2fadc <__udivmoddi4+0x28c>
   2f8a6:	4299      	cmp	r1, r3
   2f8a8:	f240 8118 	bls.w	2fadc <__udivmoddi4+0x28c>
   2f8ac:	3f02      	subs	r7, #2
   2f8ae:	442b      	add	r3, r5
   2f8b0:	1a5b      	subs	r3, r3, r1
   2f8b2:	b2a4      	uxth	r4, r4
   2f8b4:	fbb3 f0fe 	udiv	r0, r3, lr
   2f8b8:	fb0e 3310 	mls	r3, lr, r0, r3
   2f8bc:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   2f8c0:	fb00 fc0c 	mul.w	ip, r0, ip
   2f8c4:	45a4      	cmp	ip, r4
   2f8c6:	d909      	bls.n	2f8dc <__udivmoddi4+0x8c>
   2f8c8:	192c      	adds	r4, r5, r4
   2f8ca:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   2f8ce:	f080 8107 	bcs.w	2fae0 <__udivmoddi4+0x290>
   2f8d2:	45a4      	cmp	ip, r4
   2f8d4:	f240 8104 	bls.w	2fae0 <__udivmoddi4+0x290>
   2f8d8:	3802      	subs	r0, #2
   2f8da:	442c      	add	r4, r5
   2f8dc:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   2f8e0:	eba4 040c 	sub.w	r4, r4, ip
   2f8e4:	2700      	movs	r7, #0
   2f8e6:	b11e      	cbz	r6, 2f8f0 <__udivmoddi4+0xa0>
   2f8e8:	40d4      	lsrs	r4, r2
   2f8ea:	2300      	movs	r3, #0
   2f8ec:	e9c6 4300 	strd	r4, r3, [r6]
   2f8f0:	4639      	mov	r1, r7
   2f8f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2f8f6:	428b      	cmp	r3, r1
   2f8f8:	d909      	bls.n	2f90e <__udivmoddi4+0xbe>
   2f8fa:	2e00      	cmp	r6, #0
   2f8fc:	f000 80eb 	beq.w	2fad6 <__udivmoddi4+0x286>
   2f900:	2700      	movs	r7, #0
   2f902:	e9c6 0100 	strd	r0, r1, [r6]
   2f906:	4638      	mov	r0, r7
   2f908:	4639      	mov	r1, r7
   2f90a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2f90e:	fab3 f783 	clz	r7, r3
   2f912:	2f00      	cmp	r7, #0
   2f914:	d147      	bne.n	2f9a6 <__udivmoddi4+0x156>
   2f916:	428b      	cmp	r3, r1
   2f918:	d302      	bcc.n	2f920 <__udivmoddi4+0xd0>
   2f91a:	4282      	cmp	r2, r0
   2f91c:	f200 80fa 	bhi.w	2fb14 <__udivmoddi4+0x2c4>
   2f920:	1a84      	subs	r4, r0, r2
   2f922:	eb61 0303 	sbc.w	r3, r1, r3
   2f926:	2001      	movs	r0, #1
   2f928:	4698      	mov	r8, r3
   2f92a:	2e00      	cmp	r6, #0
   2f92c:	d0e0      	beq.n	2f8f0 <__udivmoddi4+0xa0>
   2f92e:	e9c6 4800 	strd	r4, r8, [r6]
   2f932:	e7dd      	b.n	2f8f0 <__udivmoddi4+0xa0>
   2f934:	b902      	cbnz	r2, 2f938 <__udivmoddi4+0xe8>
   2f936:	deff      	udf	#255	; 0xff
   2f938:	fab2 f282 	clz	r2, r2
   2f93c:	2a00      	cmp	r2, #0
   2f93e:	f040 808f 	bne.w	2fa60 <__udivmoddi4+0x210>
   2f942:	1b49      	subs	r1, r1, r5
   2f944:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   2f948:	fa1f f885 	uxth.w	r8, r5
   2f94c:	2701      	movs	r7, #1
   2f94e:	fbb1 fcfe 	udiv	ip, r1, lr
   2f952:	0c23      	lsrs	r3, r4, #16
   2f954:	fb0e 111c 	mls	r1, lr, ip, r1
   2f958:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   2f95c:	fb08 f10c 	mul.w	r1, r8, ip
   2f960:	4299      	cmp	r1, r3
   2f962:	d907      	bls.n	2f974 <__udivmoddi4+0x124>
   2f964:	18eb      	adds	r3, r5, r3
   2f966:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   2f96a:	d202      	bcs.n	2f972 <__udivmoddi4+0x122>
   2f96c:	4299      	cmp	r1, r3
   2f96e:	f200 80cd 	bhi.w	2fb0c <__udivmoddi4+0x2bc>
   2f972:	4684      	mov	ip, r0
   2f974:	1a59      	subs	r1, r3, r1
   2f976:	b2a3      	uxth	r3, r4
   2f978:	fbb1 f0fe 	udiv	r0, r1, lr
   2f97c:	fb0e 1410 	mls	r4, lr, r0, r1
   2f980:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   2f984:	fb08 f800 	mul.w	r8, r8, r0
   2f988:	45a0      	cmp	r8, r4
   2f98a:	d907      	bls.n	2f99c <__udivmoddi4+0x14c>
   2f98c:	192c      	adds	r4, r5, r4
   2f98e:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   2f992:	d202      	bcs.n	2f99a <__udivmoddi4+0x14a>
   2f994:	45a0      	cmp	r8, r4
   2f996:	f200 80b6 	bhi.w	2fb06 <__udivmoddi4+0x2b6>
   2f99a:	4618      	mov	r0, r3
   2f99c:	eba4 0408 	sub.w	r4, r4, r8
   2f9a0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   2f9a4:	e79f      	b.n	2f8e6 <__udivmoddi4+0x96>
   2f9a6:	f1c7 0c20 	rsb	ip, r7, #32
   2f9aa:	40bb      	lsls	r3, r7
   2f9ac:	fa22 fe0c 	lsr.w	lr, r2, ip
   2f9b0:	ea4e 0e03 	orr.w	lr, lr, r3
   2f9b4:	fa01 f407 	lsl.w	r4, r1, r7
   2f9b8:	fa20 f50c 	lsr.w	r5, r0, ip
   2f9bc:	fa21 f30c 	lsr.w	r3, r1, ip
   2f9c0:	ea4f 481e 	mov.w	r8, lr, lsr #16
   2f9c4:	4325      	orrs	r5, r4
   2f9c6:	fbb3 f9f8 	udiv	r9, r3, r8
   2f9ca:	0c2c      	lsrs	r4, r5, #16
   2f9cc:	fb08 3319 	mls	r3, r8, r9, r3
   2f9d0:	fa1f fa8e 	uxth.w	sl, lr
   2f9d4:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   2f9d8:	fb09 f40a 	mul.w	r4, r9, sl
   2f9dc:	429c      	cmp	r4, r3
   2f9de:	fa02 f207 	lsl.w	r2, r2, r7
   2f9e2:	fa00 f107 	lsl.w	r1, r0, r7
   2f9e6:	d90b      	bls.n	2fa00 <__udivmoddi4+0x1b0>
   2f9e8:	eb1e 0303 	adds.w	r3, lr, r3
   2f9ec:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   2f9f0:	f080 8087 	bcs.w	2fb02 <__udivmoddi4+0x2b2>
   2f9f4:	429c      	cmp	r4, r3
   2f9f6:	f240 8084 	bls.w	2fb02 <__udivmoddi4+0x2b2>
   2f9fa:	f1a9 0902 	sub.w	r9, r9, #2
   2f9fe:	4473      	add	r3, lr
   2fa00:	1b1b      	subs	r3, r3, r4
   2fa02:	b2ad      	uxth	r5, r5
   2fa04:	fbb3 f0f8 	udiv	r0, r3, r8
   2fa08:	fb08 3310 	mls	r3, r8, r0, r3
   2fa0c:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   2fa10:	fb00 fa0a 	mul.w	sl, r0, sl
   2fa14:	45a2      	cmp	sl, r4
   2fa16:	d908      	bls.n	2fa2a <__udivmoddi4+0x1da>
   2fa18:	eb1e 0404 	adds.w	r4, lr, r4
   2fa1c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   2fa20:	d26b      	bcs.n	2fafa <__udivmoddi4+0x2aa>
   2fa22:	45a2      	cmp	sl, r4
   2fa24:	d969      	bls.n	2fafa <__udivmoddi4+0x2aa>
   2fa26:	3802      	subs	r0, #2
   2fa28:	4474      	add	r4, lr
   2fa2a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   2fa2e:	fba0 8902 	umull	r8, r9, r0, r2
   2fa32:	eba4 040a 	sub.w	r4, r4, sl
   2fa36:	454c      	cmp	r4, r9
   2fa38:	46c2      	mov	sl, r8
   2fa3a:	464b      	mov	r3, r9
   2fa3c:	d354      	bcc.n	2fae8 <__udivmoddi4+0x298>
   2fa3e:	d051      	beq.n	2fae4 <__udivmoddi4+0x294>
   2fa40:	2e00      	cmp	r6, #0
   2fa42:	d069      	beq.n	2fb18 <__udivmoddi4+0x2c8>
   2fa44:	ebb1 050a 	subs.w	r5, r1, sl
   2fa48:	eb64 0403 	sbc.w	r4, r4, r3
   2fa4c:	fa04 fc0c 	lsl.w	ip, r4, ip
   2fa50:	40fd      	lsrs	r5, r7
   2fa52:	40fc      	lsrs	r4, r7
   2fa54:	ea4c 0505 	orr.w	r5, ip, r5
   2fa58:	e9c6 5400 	strd	r5, r4, [r6]
   2fa5c:	2700      	movs	r7, #0
   2fa5e:	e747      	b.n	2f8f0 <__udivmoddi4+0xa0>
   2fa60:	f1c2 0320 	rsb	r3, r2, #32
   2fa64:	fa20 f703 	lsr.w	r7, r0, r3
   2fa68:	4095      	lsls	r5, r2
   2fa6a:	fa01 f002 	lsl.w	r0, r1, r2
   2fa6e:	fa21 f303 	lsr.w	r3, r1, r3
   2fa72:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   2fa76:	4338      	orrs	r0, r7
   2fa78:	0c01      	lsrs	r1, r0, #16
   2fa7a:	fbb3 f7fe 	udiv	r7, r3, lr
   2fa7e:	fa1f f885 	uxth.w	r8, r5
   2fa82:	fb0e 3317 	mls	r3, lr, r7, r3
   2fa86:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   2fa8a:	fb07 f308 	mul.w	r3, r7, r8
   2fa8e:	428b      	cmp	r3, r1
   2fa90:	fa04 f402 	lsl.w	r4, r4, r2
   2fa94:	d907      	bls.n	2faa6 <__udivmoddi4+0x256>
   2fa96:	1869      	adds	r1, r5, r1
   2fa98:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   2fa9c:	d22f      	bcs.n	2fafe <__udivmoddi4+0x2ae>
   2fa9e:	428b      	cmp	r3, r1
   2faa0:	d92d      	bls.n	2fafe <__udivmoddi4+0x2ae>
   2faa2:	3f02      	subs	r7, #2
   2faa4:	4429      	add	r1, r5
   2faa6:	1acb      	subs	r3, r1, r3
   2faa8:	b281      	uxth	r1, r0
   2faaa:	fbb3 f0fe 	udiv	r0, r3, lr
   2faae:	fb0e 3310 	mls	r3, lr, r0, r3
   2fab2:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   2fab6:	fb00 f308 	mul.w	r3, r0, r8
   2faba:	428b      	cmp	r3, r1
   2fabc:	d907      	bls.n	2face <__udivmoddi4+0x27e>
   2fabe:	1869      	adds	r1, r5, r1
   2fac0:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   2fac4:	d217      	bcs.n	2faf6 <__udivmoddi4+0x2a6>
   2fac6:	428b      	cmp	r3, r1
   2fac8:	d915      	bls.n	2faf6 <__udivmoddi4+0x2a6>
   2faca:	3802      	subs	r0, #2
   2facc:	4429      	add	r1, r5
   2face:	1ac9      	subs	r1, r1, r3
   2fad0:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   2fad4:	e73b      	b.n	2f94e <__udivmoddi4+0xfe>
   2fad6:	4637      	mov	r7, r6
   2fad8:	4630      	mov	r0, r6
   2fada:	e709      	b.n	2f8f0 <__udivmoddi4+0xa0>
   2fadc:	4607      	mov	r7, r0
   2fade:	e6e7      	b.n	2f8b0 <__udivmoddi4+0x60>
   2fae0:	4618      	mov	r0, r3
   2fae2:	e6fb      	b.n	2f8dc <__udivmoddi4+0x8c>
   2fae4:	4541      	cmp	r1, r8
   2fae6:	d2ab      	bcs.n	2fa40 <__udivmoddi4+0x1f0>
   2fae8:	ebb8 0a02 	subs.w	sl, r8, r2
   2faec:	eb69 020e 	sbc.w	r2, r9, lr
   2faf0:	3801      	subs	r0, #1
   2faf2:	4613      	mov	r3, r2
   2faf4:	e7a4      	b.n	2fa40 <__udivmoddi4+0x1f0>
   2faf6:	4660      	mov	r0, ip
   2faf8:	e7e9      	b.n	2face <__udivmoddi4+0x27e>
   2fafa:	4618      	mov	r0, r3
   2fafc:	e795      	b.n	2fa2a <__udivmoddi4+0x1da>
   2fafe:	4667      	mov	r7, ip
   2fb00:	e7d1      	b.n	2faa6 <__udivmoddi4+0x256>
   2fb02:	4681      	mov	r9, r0
   2fb04:	e77c      	b.n	2fa00 <__udivmoddi4+0x1b0>
   2fb06:	3802      	subs	r0, #2
   2fb08:	442c      	add	r4, r5
   2fb0a:	e747      	b.n	2f99c <__udivmoddi4+0x14c>
   2fb0c:	f1ac 0c02 	sub.w	ip, ip, #2
   2fb10:	442b      	add	r3, r5
   2fb12:	e72f      	b.n	2f974 <__udivmoddi4+0x124>
   2fb14:	4638      	mov	r0, r7
   2fb16:	e708      	b.n	2f92a <__udivmoddi4+0xda>
   2fb18:	4637      	mov	r7, r6
   2fb1a:	e6e9      	b.n	2f8f0 <__udivmoddi4+0xa0>

0002fb1c <__aeabi_idiv0>:
   2fb1c:	4770      	bx	lr
   2fb1e:	bf00      	nop

Disassembly of section .fini:

0002fb20 <_fini>:
   2fb20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2fb22:	bf00      	nop
   2fb24:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2fb26:	bc08      	pop	{r3}
   2fb28:	469e      	mov	lr, r3
   2fb2a:	4770      	bx	lr
